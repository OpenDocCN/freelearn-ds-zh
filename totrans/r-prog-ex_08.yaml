- en: Object-Oriented System to Track Cryptocurrencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于跟踪加密货币的面向对象系统
- en: In this chapter, we will introduce a new way of programming that we have not
    explicitly used before in the book. It's called object-oriented programming, and
    it will be used throughout our third and final example in the book. Object-oriented
    programming is very popular among programmers, and it's mainly used to allow for
    complex abstraction relations to be modeled and implemented in such a way that
    the evolution of the system is not jeopardized.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，我们将介绍一种在本书中之前未曾明确使用过的编程方式。这种方式被称为面向对象编程，并且将在本书的第三个也是最后一个示例中贯穿使用。面向对象编程在程序员中非常流行，它主要用于允许以不危及系统演变的方式对复杂的抽象关系进行建模和实现。
- en: When developing object-oriented systems, and in general when we program, we
    should strive for simplicity, but it doesn't come naturally. When dealing with
    a complex domain, it's easier to create complex rather than simple code. Programmers
    must make an active effort to produce simple code, since simplicity depends mostly
    on the programmer, not the language. In this chapter, we will show you how to
    efficiently work with object-oriented code by introducing the ideas and concepts
    that support it, and we will later illustrate how to implement it using three
    of R's most used object models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发面向对象系统时，以及在一般编程中，我们应该追求简单性，但这并不自然。当处理复杂领域时，创建复杂的代码比创建简单的代码更容易。程序员必须积极努力地编写简单的代码，因为简单性主要取决于程序员，而不是语言。在本章节中，我们将通过介绍支持它的思想和概念，向您展示如何高效地处理面向对象代码，并且我们将在后面通过使用R中最常用的三个对象模型来展示如何实现它。
- en: R has various object models, or object-oriented systems, so it can be a bit
    intimidating at first. The goal of this chapter is not to make you an expert in
    object-oriented programming or in each of R's object models, but to help you understand
    how to implement the basic building blocks of object-oriented programs with R's
    different object models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: R有多种对象模型，或者说面向对象系统，因此一开始可能会有些令人畏惧。本章节的目标不是让你成为面向对象编程或R的每个对象模型方面的专家，而是帮助你理解如何使用R的不同对象模型来实现面向对象程序的基本构建块。
- en: 'Some of the important topics covered in this chapter are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖的一些重要主题包括：
- en: Fundamental object-oriented programming concepts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本面向对象编程概念
- en: Design and architecture of object-oriented systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象系统的设计和架构
- en: R's parametric polymorphism through generic functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过泛型函数实现的R的参数多态性
- en: The different object models available for R
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于R的不同对象模型
- en: Mixing functionality from R's different object models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合R不同对象模型的功能
- en: This chapter's required packages
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章节所需包
- en: This chapter will make use of the `methods` and `R6` packages to load the S4
    and R6 object models functionality. You should know that interactive R sessions
    load the `methods` by default, but non-interactive sessions don't, so you need
    to explicitly load it in such cases. The `jsonlite` and `lubridate` packages are
    brought to simplify some common tasks like getting data from JSON APIs and transforming
    dates. For more information, take a look at [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730),
    *Required Packages*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将利用`methods`和`R6`包来加载S4和R6对象模型的功能。你应该知道，交互式R会话默认加载`methods`，但非交互式会话则不会，因此在这种情况下你需要显式地加载它。`jsonlite`和`lubridate`包被引入以简化一些常见任务，例如从JSON
    API获取数据和转换日期。更多信息，请参阅[附录](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)，*所需包*。
- en: '| **Package** | **Reason** |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **包** | **原因** |'
- en: '| `R6` | R6 object model |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `R6` | R6对象模型 |'
- en: '| `methods` | S4 object model |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `methods` | S4对象模型 |'
- en: '| `lubridate` | Easily transform dates |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `lubridate` | 简易转换日期 |'
- en: '| `jsonlite` | Retrieve data from JSON APIs |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `jsonlite` | 从JSON API检索数据 |'
- en: The cryptocurrencies example
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密货币示例
- en: A **cryptocurrency** is a digital currency designed to work as a medium of exchange.
    Cryptocurrencies use cryptography to secure and verify transactions, as well as
    to control the creation of new units. Simply put, cryptocurrencies are entries
    in a public and distributed database that can only be changed by algorithmic consensus,
    and they remove the need for trusted third-parties for transaction handling and
    currency emission. The concept closely resembles peer-to-peer networks for file
    sharing, with an algorithmic monetary policy on top. If you want to learn more
    about cryptocurrencies, you should definitely look at videos starring Andreas
    Antonopoulos. He can make very complex concepts very easy to understand. You may
    also want to read his recollection of  conferences in his book, *The Internet
    of Money, by **Merkle Bloom LLC, 2016*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密货币**是一种设计为交换媒介的数字货币。加密货币使用密码学来保护和验证交易，以及控制新单位的创建。简单来说，加密货币是公共和分布式数据库中的条目，只能通过算法共识来更改，并且它们消除了交易处理和货币发行的第三方信任需求。这个概念与文件共享的P2P网络非常相似，上面还有一个算法货币政策。如果您想了解更多关于加密货币的信息，您绝对应该看看Andreas
    Antonopoulos的视频。他可以使非常复杂的概念变得非常容易理解。您还可能想阅读他在2016年出版的《金钱互联网》一书中对会议的回忆，该书由**Merkle
    Bloom LLC**出版。'
- en: Cryptocurrencies are being heavily developed nowadays to offer many innovative
    features that will have disruptive effects during upcoming years, but for now,
    they are mostly used for buying goods and investing. Every transaction consists
    of the amount of coins transferred, as well as the sender's and recipient’s public
    keys, also known as wallet addresses. We will use these public keys in the example
    for this chapter to keep track of how many coins we own, and we will also use
    CoinMarketCap API ([https://coinmarketcap.com/](https://coinmarketcap.com/)) to
    keep track of cryptocurrency prices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币目前正在得到大力开发，以提供许多创新功能，这些功能将在未来几年产生颠覆性影响，但到目前为止，它们主要用于购买商品和投资。每一笔交易都包括转帐的币数，以及发送者和接收者的公钥，也称为钱包地址。在本章的示例中，我们将使用这些公钥来跟踪我们拥有的币数，并且我们还将使用CoinMarketCap
    API ([https://coinmarketcap.com/](https://coinmarketcap.com/))来跟踪加密货币的价格。
- en: Since this will be a complex system, we will use object-oriented programming
    to modularize it and build it part by part. At the end of the example, we will
    have a system that can be turned on to start tracking our cryptocurrency assets
    as well as their prices, and to save the real-time data to disk for later analysis.
    Later, in [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730),
    I*mplementing an Efficient Simple Moving Average*, we will use this data, in simulated
    form, to develop various **Simple Moving Average** (**SMA**) implementations to
    showcase how R code can be improved to become faster, as well as more readable.
    Finally, in [Chapter 10](part0271.html#82E8E0-f494c932c729429fb734ce52cafce730),
    *Adding Interactivity with Dashboards,* we will see how to create a modern web
    application to show the SMAs developed, as well as the data collected.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将是一个复杂的系统，我们将使用面向对象编程来模块化它，并逐步构建。在示例的最后，我们将拥有一个可以开启以开始跟踪我们的加密货币资产及其价格，并将实时数据保存到磁盘以供以后分析的系统。稍后，在第9章[实现高效的简单移动平均](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730)中，我们将使用这些数据（以模拟形式），来开发各种**简单移动平均**（**SMA**）的实现，以展示如何改进R代码使其更快，以及更易于阅读。最后，在第10章[通过仪表板添加交互性](part0271.html#82E8E0-f494c932c729429fb734ce52cafce730)中，我们将看到如何创建一个现代网络应用程序来展示开发的SMAs以及收集到的数据。
- en: A brief introduction to object-oriented programming
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程简介
- en: As statisticians and data scientists, we strive to build systems that produce
    valuable insights. To accomplish this, we normally use two tools—mathematics and
    computers. This book was developed for people who are comfortable with the mathematics
    side but feel that their R programming skills need improvement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为统计学家和数据科学家，我们努力构建能够产生有价值见解的系统。为了实现这一目标，我们通常使用两种工具——数学和计算机。这本书是为那些对数学方面感到舒适但认为他们的R编程技能需要提高的人编写的。
- en: Normally, when people with mathematical backgrounds are introduced to programming,
    they are introduced through a *functional approach*, which means that they think
    in terms of algorithms with inputs and outputs, which are implemented as functions.
    This way of working is intuitive if you come from a mathematical background and
    are not dealing with high level abstractions, and it is the way we have been working
    throughout the book up to this point.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当具有数学背景的人接触到编程时，他们是通过一种*函数式方法*来接触的，这意味着他们从具有输入和输出的算法的角度思考，这些算法作为函数实现。如果你来自数学背景并且不处理高级抽象，这种方式是直观的，并且这是我们到目前为止在整本书中一直在使用的方式。
- en: This chapter will show a different way of programming called **object-oriented
    programming**. Object-oriented programming and the object model are powerful and
    unifying ideas in many fields and can be found in most popular programming languages,
    R being no exception. In my experience, people who have not had conscious experience
    with object-oriented programming normally find it confusing at first and don't
    understand its potential. They see it as more of a hassle than an enabler, and
    think that it gets in their way when trying to write some code. In this chapter,
    we will try to distill the object-oriented paradigm in a way that is understandable
    to people who feel comfortable with a functional approach (not necessarily with
    functional programming), and we will show you how to implement a small object-oriented
    system that continuously retrieves live data from cryptocurrency markets and wallets.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示一种不同的编程方式，称为**面向对象编程**。面向对象编程和对象模型是许多领域的强大且统一的理念，并且可以在大多数流行的编程语言中找到，R语言也不例外。根据我的经验，那些没有意识到面向对象编程经验的人通常一开始会感到困惑，并且不理解它的潜力。他们认为这更像是一种麻烦，而不是一种助力，并认为它在尝试编写代码时会阻碍他们。在本章中，我们将尝试以一种对那些习惯于函数式方法（不一定是函数式编程）的人来说可理解的方式提炼面向对象范式，并展示如何实现一个从加密货币市场和钱包中持续检索实时数据的小型面向对象系统。
- en: Before we start implementing such a system, we need to introduce the concepts
    that will be used throughout the rest of the example, including the upcoming two
    chapters. In the following paragraphs, you will find very general descriptions
    of the concepts behind the object model, which is implemented with object-oriented
    programming, as well as explanations that will hopefully convince you that this
    way of programming can be very powerful for certain problems. For a more exhaustive
    and formal introduction, you should read the excellent book by Booch, Maksimchuck,
    Engle, Young, Conallen, and Houston, titled, *Object-Oriented Analysis and Design
    With Applications, by Addison-Wesley, 2007*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现这样一个系统之前，我们需要介绍将在整个示例中使用的概念，包括即将到来的两个章节。在接下来的段落中，你将找到关于面向对象编程背后的概念的一般描述，以及旨在说服你这种编程方式对于某些问题来说可以非常强大的解释。为了获得更全面和正式的介绍，你应该阅读Booch、Maksimchuck、Engle、Young、Conallen和Houston合著的出色书籍，书名为《面向对象分析与设计：应用》，由Addison-Wesley出版社于2007年出版。
- en: The purpose of object-oriented programming
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程的目的
- en: The main purpose of object-oriented programming is to efficiently manage complexity.
    It's a way of organizing code and data such that you can develop well-delimited
    abstractions with controlled dependencies to evolve a complex system in a controlled
    manner. These abstractions are called **objects** and they offer behavior in response
    to messages. The behavior they offer to other objects is cataloged in an interface
    which is implemented in this object's public methods. Objects request behavior
    from other objects, and when they do, they are said to depend on them. The messages
    sent between all these objects and the associated behavior are what make an object-oriented
    system useful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的主要目的是高效地管理复杂性。这是一种组织代码和数据的方式，使得你可以开发出界限清晰的抽象，并带有受控的依赖关系，以便以受控的方式演进复杂系统。这些抽象被称为**对象**，它们会根据消息提供行为。它们对其他对象提供的行为被记录在接口中，该接口通过此对象的公共方法实现。对象会从其他对象请求行为，当它们这样做时，它们被认为是依赖于它们的。所有这些对象之间发送的消息以及相关的行为使得面向对象系统变得有用。
- en: Before we go any further, let's explain more about these concepts. An object
    is an entity in abstract form. For example, integers, cars, dogs, buildings, credit
    cards, and cryptocurrencies, could all be objects in an object-oriented system.
    An object is a well-defined idea of something, and we know that different kinds
    of objects have different kinds of behaviors associated with them, and some of
    those behaviors require some data, which is normally stored within the object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们更详细地解释这些概念。对象是一种抽象形式的存在。例如，整数、汽车、狗、建筑、信用卡和加密货币，都可以是面向对象系统中的对象。对象是对某物的明确概念，我们知道不同种类的对象与它们相关的不同行为，其中一些行为需要一些数据，这些数据通常存储在对象内部。
- en: For example, the idea of an integer is not associated with any specific number,
    just as the idea of a car is not associated with any specific model or brand.
    For those familiar with statistics, think of a random variable as an object, and
    a realization of that random variable as an instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，整数的概念并不与任何特定的数字相关联，就像汽车的概念并不与任何特定的型号或品牌相关联。对于那些熟悉统计学的人来说，可以将随机变量视为一个对象，而该随机变量的一个实现就是一个实例。
- en: Object-oriented programming is a way of thinking of programs as interactions
    among objects instead of steps through an algorithm. You can still understand
    an object-oriented system as a big algorithm with lots of functions calling each
    other, but for large enough systems this will not be a fruitful or enjoyable process.
    When dealing with object-oriented systems, you're better off just trying to understand
    a part of the system by itself and clearly defining how it should communicate
    with other parts. Trying to fully understand a complex object-oriented system
    can prove to be quite challenging.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种将程序视为对象之间交互的方式，而不是通过算法步骤。你仍然可以将面向对象系统视为一个包含大量相互调用的函数的大算法，但对于足够大的系统来说，这不会是一个富有成效或令人愉快的进程。在处理面向对象系统时，你最好只是尝试理解系统的一部分，并清楚地定义它应该如何与其他部分通信。试图完全理解一个复杂的面向对象系统可能会相当具有挑战性。
- en: Important concepts behind object-oriented languages
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象语言背后的重要概念
- en: There are many ways to implement the object model in object-oriented languages,
    and the specific ways it is implemented imply different sets of properties for
    the language. Some of these properties are encapsulation, polymorphism, generics
    (parametric polymorphism), hierarchies (inheritance and composition), subtyping,
    and several others. They are powerful, high-level ideas with precise definitions
    that impose restrictions on how a language should behave. Don't worry too much
    about them for now; we will explain the necessary ones as we move forward.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象语言中实现对象模型有许多方法，而这些具体实现方式意味着语言具有不同的属性集。其中一些属性包括封装、多态、泛型（参数多态）、层次结构（继承和组合）、子类型以及一些其他属性。它们是强大、高级的概念，具有精确的定义，并规定了语言应该如何表现。现在不必过于担心它们；随着我们前进，我们将解释必要的概念。
- en: An interesting exercise is to find languages that are considered to be object-oriented,
    yet don't use one or more of these properties. For example, the class concept
    is unnecessary, as seen with prototype-based languages like JavaScript. Subtyping
    is also unnecessary, since it doesn't make sense in dynamically typed languages
    like R or Python. We could go on and on, but you get the idea—a single language
    that has all of these properties does not exist. Furthermore, the only property
    that is found in all object-oriented languages is polymorphism. That's why people
    commonly say that polymorphism is the essence of object-oriented programming.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的练习是寻找那些被认为是面向对象的，但又不使用一个或多个这些属性的语言。例如，类概念是不必要的，就像在基于原型的语言如JavaScript中看到的那样。子类型也是不必要的，因为在动态类型语言如R或Python中它没有意义。我们可以继续列举，但你的想法已经很明确了——一个具有所有这些属性的语言是不存在的。此外，所有面向对象语言中唯一共有的属性是多态。这就是为什么人们常说多态是面向对象编程的本质。
- en: Any professional object-oriented programmer should understand these properties
    and have formal experience with languages that implement them. However, in the
    following paragraphs, we will give a high-level explanation of the most common
    ones in R's different object models—encapsulation, polymorphism (with and without
    generics), and hierarchies.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何专业的面向对象程序员都应该理解这些属性，并且应该有使用实现这些属性的语言的正式经验。然而，在接下来的段落中，我们将以R的不同对象模型为例，给出这些最常见属性的高层次解释——封装、多态（带和不带泛型）以及层次结构。
- en: Encapsulation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is about hiding an object's internals from other objects. As the
    designer of the C++ language, Bjarne Stroustrup, put it, *Encapsulation hides
    information not to faciliate fraud, but to prevent mistakes*. By giving other
    objects a minimal catalog of messages (public methods) that they can send to an
    object, we are helping them commit less mistakes and avoid getting their hands
    in tasks that do not pertain them. This, in turn, helps with decoupling objects
    from themselves and providing cohesiveness within objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是关于隐藏对象内部信息以防止其他对象访问。正如C++语言的创造者Bjarne Stroustrup所说，*封装隐藏信息不是为了方便欺诈，而是为了防止错误*。通过给其他对象提供它们可以向对象发送的最小消息目录（公共方法），我们帮助他们犯更少的错误，避免参与与他们无关的任务。这反过来又帮助对象与其自身解耦，并在对象内部提供内聚性。
- en: A common way to think about encapsulation is like when you go to a restaurant—you
    message the waiter with what you want, and the waiter then delegates the cooking
    of what you requested to the restaurant's chef. You have no business in going
    into the restaurant's kitchen and telling the chef how to cook your meal, and
    if the chef wants to change the way he cooks a certain dish, she can do so without
    you having to know about it. It's the same with objects; they should not get inside
    another object and tell it how to do its job. This sounds simple enough, but in
    practice, it's very easy to violate this principle. We will talk more about this
    when we reach the *Law of Demeter* section later in this chapter. Technically,
    the process of separating the interface from the implementation is called **encapsulation**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的一个常见理解方式就像你去餐厅时——你通过服务员传达你的需求，然后服务员将你要求的烹饪任务委托给餐厅的大厨。你无需进入餐厅的厨房告诉厨师如何烹饪你的餐点，如果厨师想要改变烹饪某道菜的方式，她可以这样做而不需要你知道。对于对象来说，它们也不应该进入另一个对象并告诉它如何完成其工作。这听起来很简单，但在实践中，很容易违反这个原则。当我们到达本章后面的*迪米特法则*部分时，我们会更多地讨论这一点。从技术上讲，将接口与实现分离的过程被称为**封装**。
- en: Polymorphism
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism is perhaps the most powerful feature of object-oriented programming
    languages, next to their support for abstraction, and it is what distinguishes
    object-oriented programming from more traditional programming with abstract data
    types. **Polymorphism** literally means many forms, and that's exactly what it
    is used for in object-oriented programming. The same name will denote different
    meanings, depending on the context in which it is used, just as with our natural
    languages. This allows for much cleaner and understandable abstractions, as well
    as code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 多态可能是面向对象编程语言中最强大的功能，仅次于它们对抽象的支持，并且它是将面向对象编程与传统使用抽象数据类型编程区分开来的关键。**多态**字面上意味着多种形式，这正是它在面向对象编程中使用的。同一个名字在不同的上下文中会有不同的含义，就像我们的自然语言一样。这允许实现更干净、更易于理解的抽象以及代码。
- en: 'Loosely speaking, polymorphism can be implemented in two different ways: from
    inside or from outside objects. When it''s implemented from inside objects, each
    object must provide a definition of how it will deal with a given message. This
    is the most common method, and you can find it in Java or Python. R is very special
    in this manner and implements the outside approach, formally know as **generics**,
    or **parametric polymorphism**. This way of programming can be frustrating for
    people who have only used the inside approach, but it can be very flexible. The
    outside approach lets you define a generic method or function for types of objects
    that you have not yet defined, and may never do. Java and Python can also implement
    this type of polymorphism, but it''s not their nature, just as R can also implement
    the inside, but it''s not its nature, either.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大体来说，多态可以通过两种不同的方式实现：从对象内部或从对象外部。当它从对象内部实现时，每个对象都必须提供一个定义，说明它将如何处理给定的消息。这是最常见的方法，你可以在Java或Python中找到它。R在这方面非常特殊，它实现了外部方法，正式称为**泛型**或**参数多态**。这种编程方式可能会让只使用内部方法的人感到沮丧，但它可以非常灵活。外部方法允许你为尚未定义且可能永远不会定义的对象类型定义一个通用的方法或函数。Java和Python也可以实现这种类型的多态，但这不是它们的本质，就像R也可以实现内部方法，但这也不是它的本质。
- en: Hierarchies
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次结构
- en: Hierarchies can be formed in two ways—inheritance and composition. The idea
    of **inheritance** is to form new classes as specialized versions of old ones.
    The specialized classes are subclasses and the more general ones are superclasses.
    This type of relationship is often referred to as an **is-a** type of relationship,
    since *a subclass is a type of the superclass*. For example, a lion is a type
    of animal, so animal would be the superclass and lion the subclass. Another type
    of relationship is known as the **has-a** relation. This means that one class
    has instances of another class. For example, a car has wheels. We wouldn't say
    that wheels are a type of car, so there's no inheritance there, but we would say
    that they are part of a car, which implies **composition**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构可以通过两种方式形成——继承和组合。**继承**的想法是将新类作为旧类的特殊版本来形成。特殊化的类是子类，更一般的类是超类。这种关系通常被称为**is-a**类型的关联，因为*子类是超类的一种类型*。例如，狮子是一种动物，所以动物是超类，狮子是子类。另一种关系称为**has-a**关系。这意味着一个类包含另一个类的实例。例如，汽车有轮子。我们不会说轮子是汽车的一种类型，所以那里没有继承，但我们会说它们是汽车的一部分，这暗示了**组合**。
- en: There are cases where it's not so clear whether a relation should be modeled
    with inheritance or with composition, and in those cases, you should decide to
    move along with composition. In general, people agree that composition is a much
    more flexible way of designing a system, and that you should only use inheritance
    where you must model the specialization of a class. Note that when you design
    your systems with composition instead of inheritance, your objects take on different
    roles and they become more tool-like. That's a good thing, because you can easily
    plug them into each other and replace them as necessary, and you also usually
    end up with larger numbers of smaller classes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候并不清楚应该用继承还是组合来建模关系，在这些情况下，你应该决定使用组合来继续。一般来说，人们认为组合是设计系统的一种更灵活的方式，你应该只在必须建模类的特殊化时使用继承。请注意，当你用组合而不是继承来设计系统时，你的对象承担不同的角色，它们变得更加工具化。这是一件好事，因为你可以轻松地将它们相互连接，并在必要时替换它们，而且通常还会得到更多的小类。
- en: Now that you understand some fundamental ideas behind object-oriented programming,
    you may realize the power that combining these ideas gives you. If you have a
    system that encapsulates behavior and only publicly offers what is needed by others
    to operate correctly, which can dynamically respond to abstract ideas with correct
    and concrete actions and allows for concept hierarchies to interact with other
    concept hierarchies, then you can rest assured that you can manage quite a bit
    of complexity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了面向对象编程背后的某些基本思想，你可能意识到结合这些思想所赋予你的力量。如果你有一个封装行为并且只公开提供其他人正确操作所需的系统，它可以动态地对抽象概念做出正确和具体的行为反应，并允许概念层次结构与其他概念层次结构交互，那么你可以放心，你可以管理相当多的复杂性。
- en: In the following paragraphs, we will explain some more down-to-earth concepts
    which are basic building blocks in most object-oriented systems and that you need
    to understand to be able to follow the code we will develop for the example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我们将解释一些更贴近实际的概念，这些概念是大多数面向对象系统的基础构建块，并且你需要理解这些概念才能理解我们将为示例开发的代码。
- en: Classes and constructors
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和构造函数
- en: Objects must be defined in some way so that we can generate specific instances
    from them. The most common way to provide those definitions is through classes.
    A **class** is a piece of code that provides the definition for an object, including
    the behavior it offers in response to messages from other objects, as well as
    the internal data it needs to provide that behavior. The behavior for a class
    is implemented in its methods. More on this in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对象必须以某种方式定义，以便我们可以从中生成特定的实例。提供这些定义最常见的方式是通过类。**类**是一段代码，它提供了对象的定义，包括它对其他对象消息的响应行为，以及提供该行为所需的内部数据。类的行为在其方法中实现。更多内容将在下一节中介绍。
- en: Classes must be created at some point, and that's where constructors come into
    play. The vast majority of the time, when you create an instance of a class, you
    will want it to contain some data about itself. That data is assigned to the class
    when it's created through its constructor. Specifically, a **constructor** is
    a function whose job is to create an instance of a class with a specific set of
    data. As you know, that data should be kept inside the object, and other objects
    should not interact with this data directly. Instead, the object should offer
    public methods that other objects may use to get the data or behavior they need.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类必须在某个时候创建，这就是构造函数发挥作用的地方。在大多数情况下，当你创建一个类的实例时，你希望它包含一些关于自己的数据。这些数据通过其构造函数在创建时分配给类。具体来说，**构造函数**是一个函数，其任务是使用一组特定的数据创建类的实例。正如你所知，这些数据应该保存在对象内部，其他对象不应直接与这些数据交互。相反，对象应提供公共方法，其他对象可以使用这些方法获取它们所需的数据或行为。
- en: Public and private methods
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共和私有方法
- en: '**Methods** are functions contained within classes, and in general, they will
    be either public or private. In general, methods have access to classes'' data
    (which should be encapsulated away from other objects), as well as their public
    and private methods.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**是包含在类中的函数，通常它们将是公共的或私有的。通常，方法可以访问类数据（这些数据应该封装起来，远离其他对象），以及它们的公共和私有方法。'
- en: '**Public methods** are visible to other objects and should be as stable as
    possible since other objects may come to depend on them. If you change them, you
    may unexpectedly break another object''s functionality. **Private methods** are
    visible only to the instance itself, which means that other objects cannot (or
    should not, as is the case with R) call these methods directly. Private methods
    are allowed to change as often as necessary.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共方法**对其他对象可见，应该尽可能稳定，因为其他对象可能会依赖它们。如果你更改它们，可能会意外地破坏另一个对象的功能。**私有方法**仅对实例本身可见，这意味着其他对象不能（或不应，如R的情况）直接调用这些方法。私有方法可以随时更改。'
- en: Public methods make use of other methods, public or private, to further delegate
    behavior. This delegation breaks up a problem into very small pieces which are
    easily understandable, and the programmer reserves the right to modify private
    methods as she sees fit. Other objects should not depend on them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 公共方法利用其他方法（无论是公共的还是私有的）来进一步委派行为。这种委派将问题分解成非常小的部分，这些部分易于理解，并且程序员保留根据需要修改私有方法的权利。其他对象不应依赖于它们。
- en: Note that technically, only public methods exist in R. Under one of R's object
    models you can hide methods and under another you can put them in a different
    environment, but that does not make them inaccessible, as the case would be with
    private methods in other languages. Derived from that, we also don't touch on
    the concept of protected methods, which are methods that are visible to a class
    and its subclasses.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在技术上，R中只存在公共方法。在R的一个对象模型中，你可以隐藏方法，在另一个对象模型中，你可以将它们放在不同的环境中，但这并不意味着它们不可访问，就像其他语言中的私有方法一样。由此，我们也没有涉及受保护方法的概念，这些方法是可见于类及其子类的。
- en: Even if there are technically no private methods in R, we will program as if
    there were. Not having some type of compiler or error-checking mechanism to tell
    you that you're accessing private methods when you shouldn't is not an excuse
    for doing so. You should always be producing high quality code, even if not explicitly
    enforced by language mechanisms.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在R中技术上没有私有方法，我们也会像有私有方法一样编程。没有某种类型的编译器或错误检查机制来告诉你，当你不应该访问私有方法时，这不是一个合理的借口。你应该始终生产高质量的代码，即使语言机制没有明确强制执行。
- en: What we said previously implies that you should make your objects as private
    as possible to keep them cohesive and decoupled, which are fancy terms for self-contained
    and independent. In other words, try to reduce the number of methods in your objects
    as much as possible. Of course, cohesiveness and decoupleness are far more general
    ideas than just reducing the number of private methods, but it's a good start.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前所说的意味着你应该尽可能使你的对象保持私有性，以保持它们的内聚性和解耦性，这些是自包含和独立的高级术语。换句话说，尽量减少你的对象中的方法数量。当然，内聚性和解耦性是比仅仅减少私有方法更普遍的概念，但这是一个好的开始。
- en: Interfaces, factories, and patterns in general
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口、工厂和一般模式
- en: An **interface **is the part of a class that is made public for other objects
    to use. Specifically, it's a set of definitions for the public methods of a class.
    Of course, the more public methods an object has, the more responsibilities and
    the less flexibility it has towards the outside world. Note that the interface
    does not provide any details about implementation; it's just a contract which
    defines what inputs and what outputs are expected when a method is called.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**是一个类的一部分，它是公开的，供其他对象使用。具体来说，它是一组关于类公共方法的定义。当然，一个对象拥有的公共方法越多，它对外的责任就越大，灵活性就越小。请注意，接口不提供任何关于实现的细节；它只是一个合同，定义了当调用方法时预期的输入和输出。'
- en: Sometimes, you want to give yourself the flexibility of changing the object
    for a given task according to context. You know that as long as the interfaces
    for the objects you want to interchange are the same, everything should be fine
    (of course, this assumes that the programmers implement said interfaces correctly).
    If you don't plan for it in advance, switching these objects can be a difficult
    task. That's where factories come into play. A factory is a way to choose, at
    runtime and according to context, which object to use from a set of predefined
    options.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望根据上下文灵活地更改给定任务的对象。你知道，只要你想要交换的对象的接口相同，一切应该都会好（当然，这假设程序员正确实现了这些接口）。如果你没有提前计划，切换这些对象可能是一项困难的任务。这就是工厂发挥作用的地方。工厂是一种在运行时根据上下文从一组预定义选项中选择要使用哪个对象的方法。
- en: '**Factories** basically work as `if` statements that choose which class to
    use for a task based on some condition. They are a way of investing a little more
    effort today so that you save yourself quite a bit of effort later, when you decide
    to use a different object for the same interface. They should be used where you
    anticipate you will be using different kinds of objects in the future.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂**基本上像`if`语句一样工作，根据某些条件选择用于任务的类。它们是一种今天多投入一点努力，以便将来在决定使用不同对象实现相同接口时节省大量努力的方法。它们应该用于你预计将来会使用不同类型的对象的情况。'
- en: 'Factories are one of many know **patterns** for object-oriented programming.
    These patterns are developed by people with a lot of experience on design decisions,
    and, as such, they know what solutions can be generally good for certain types
    of problems. Documenting these patterns is very useful and allows many people
    to save a lot of time and effort by not having to reinvent the wheel in their
    own context. A great source for some fundamental object-oriented patterns can
    be found in Gamma, Vlissides, Johnson, and Helmfamous''s famous, *Design Patterns:
    Elements of Reusable Object-Oriented Software*, by Addison-Wesley, 1994. We encourage
    the reader to study these patterns, as they will surely prove useful at some point.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂是面向对象编程中许多已知**模式**之一。这些模式是由在设计决策方面经验丰富的人开发的，因此他们知道哪些解决方案可以普遍适用于某些类型的问题。记录这些模式非常有用，并允许许多人通过在自己的环境中不必重新发明轮子来节省大量时间和精力。一些基本面向对象模式的优秀来源可以在Addison-Wesley
    1994年出版的Gamma、Vlissides、Johnson和Helmfamous的著名作品《设计模式：可复用面向对象软件元素》中找到。我们鼓励读者研究这些模式，因为它们无疑会在某个时候派上用场。
- en: Introducing three object models in R – S3, S4, and R6
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍R中的三个对象模型——S3、S4和R6
- en: Now that you have a basic understanding of general object-oriented concepts,
    we will dig into R's own object models. There are two main sources of confusion
    when doing object-oriented programming in R. Before we start developing code, we
    will explain what these sources of confusion are. After we do, we will develop
    a small example to illustrate inheritance, composition, polymorphism, and encapsulation
    in R's S3, S4, and R6 object models. The same example will be used for all three
    models so that the reader can pinpoint precise differences. Specifically, we will
    model a `Square` inheriting from a `Rectangle`, which is in turn composed with
    a `Color`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对面向对象的基本概念有了基本的了解，我们将深入探讨R自身的对象模型。在R中进行面向对象编程时，有两个主要的混淆来源。在我们开始编写代码之前，我们将解释这些混淆来源是什么。解释之后，我们将开发一个小示例来展示R的S3、S4和R6对象模型中的继承、组合、多态和封装。相同的示例将用于所有三个模型，以便读者可以精确地指出它们之间的差异。具体来说，我们将模拟一个从`Rectangle`继承并进一步与`Color`组合的`Square`模型。
- en: The first source of confusion – various object models
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产生混淆的第一个来源——各种对象模型
- en: The way you work with object-oriented programming in R is different from what
    you may see in other languages, such as Python, Java, C++, and many others. For
    the most part, these languages have a single object model that all people use.
    In the case of R, note that we have been writing object models, in plural. That's
    because R is a very special language and it has various ways of implementing object-oriented
    systems. Specifically, R has the following object models as of this book's writing—S3,
    S4, Reference Classes, R6, and Base Types. In the upcoming sections, we will dig
    deeper into the S3, S4, and R6 models. Now, we will briefly touch on Reference
    Classes and Base Types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在R语言中使用面向对象编程的方式与其他语言（如Python、Java、C++等）中看到的方式不同。在很大程度上，这些语言有一个所有人都使用的单一对象模型。在R语言的情况下，请注意，我们一直在编写对象模型，使用复数形式。这是因为R是一种非常特殊的语言，并且它有各种实现面向对象系统的方式。具体来说，截至本书编写时，R有以下对象模型——S3、S4、引用类、R6和基本类型。在接下来的章节中，我们将深入探讨S3、S4和R6模型。现在，我们将简要介绍引用类和基本类型。
- en: '**Reference Classes** (**RC**) is the object-model in R that does not require
    external libraries and is most similar to the well-known object model found in
    Python, Java, or C++. It implements message-passing as those languages do, meaning
    that methods belong to classes, not to functions, and objects are mutable, meaning
    that an instance''s data may change in place instead of producing copies with
    the modified data. We will not dig deeper into this object model, since R6 seems
    to be a cleaner implementation of such a model. However, R6 does require an external
    package, as we will see later, which is not a problem, and it is therefore preferred.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用类**（**RC**）是R语言中不需要外部库的对象模型，并且与Python、Java或C++中找到的知名对象模型最为相似。它实现了与这些语言相同的信息传递，这意味着方法属于类，而不是函数，并且对象是可变的，这意味着实例的数据可以就地更改，而不是产生带有修改后数据的副本。我们不会深入探讨这个对象模型，因为R6似乎是对这种模型更干净的实现。然而，R6确实需要一个外部包，正如我们稍后将会看到的，这并不是问题，因此它更受欢迎。'
- en: Base types are not exactly an object model, per se. They are C implementations
    that work in R's background and are used to develop the other object models on
    top of them. Only R's core development team may add new classes to this model,
    and they very rarely do so (many years can pass before they do). Their usage is
    very advanced, and we will not dig deeper into them, either.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型本身并不是一个对象模型。它们是R语言背景下的C语言实现，用于在它们之上开发其他对象模型。只有R的核心开发团队可以向这个模型添加新的类，而且他们很少这样做（可能需要很多年才会这样做）。它们的用法非常高级，我们也不会深入探讨它们。
- en: The decision of what object model to use is an important one, and we will touch
    more on this after we have shown how to work with them. In general, it will come
    down to a trade-off between flexibility, formality, and code cleanness.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用哪种对象模型是一个重要的决定，我们将在展示如何使用它们之后对此进行更多讨论。一般来说，这将是灵活性、形式性和代码整洁性之间的权衡。
- en: The second source of confusion – generic functions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个混淆源——泛型函数
- en: Another big difference with popular object-oriented languages like the ones
    mentioned before is that R implements parametric polymorphism, also known as generic
    functions, which implies that methods belong to functions, not classes. **Generic
    functions** allow the same name to be used for many different functions, with
    many different sets of arguments, from many different classes. This means that
    the syntax to call a class's method is different from the normally chained syntax
    you find in other languages (normally implemented with a "`.`" (dot) between a
    class and the method we want to call), which is called **message-passing**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前提到的流行面向对象语言（如Java、C++等）相比，R语言还有一个很大的不同点，那就是R实现了参数多态性，也称为泛型函数，这意味着方法属于函数，而不是类。**泛型函数**允许使用相同的名称为许多不同的函数命名，这些函数具有许多不同的参数集，并且来自许多不同的类。这意味着调用类方法的语法与其他语言中通常找到的链式语法（通常在类和要调用的方法之间使用一个"`.`"（点））不同，这被称为**消息传递**。
- en: R's method calls look just like function calls, and R must know which names
    require simple function calls and which names require method calls. If you read
    the previous sections, you should understand why this is important. R must have
    a mechanism to distinguish what it's supposed to do. That mechanism is called
    **generic functions**. By using generic functions, we register certain names to
    be treated as methods in R, and they act as dispatchers. When we call registered
    generic functions, R will look into a chain of attributes in the object that is
    being passed in the call, and will look for functions that match the method call
    for that object's type; if it finds one, it will call it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: R 的方法调用看起来就像函数调用，R 必须知道哪些名称需要简单的函数调用，哪些名称需要方法调用。如果你阅读了前面的章节，你应该理解为什么这很重要。R 必须有一种机制来区分它应该做什么。这种机制被称为
    **泛型函数**。通过使用泛型函数，我们将某些名称注册为 R 中的方法，并充当调度器。当我们调用已注册的泛型函数时，R 将检查传递给调用中的对象的属性链，并寻找与该对象类型匹配的方法调用函数；如果找到，它将调用它。
- en: You may have noted that the `plot()` and `summary()` functions may return different
    results, depending on the objects that are being passed to them (for example,
    a data frame or a linear model instance). That's because those are generic functions
    that implement polymorphism. This way of working provides simple interfaces for
    users, which can make their tasks much simpler. For instance, if you are exploring
    a new package and you get some kind of result at some point derived from the package,
    try calling `plot(result)`, and you may be surprised to get some kind of plot
    that makes sense. This is not common in other languages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`plot()` 和 `summary()` 函数可能会根据传递给它们的对象（例如，数据框或线性模型实例）返回不同的结果。这是因为那些是实现多态性的泛型函数。这种方式为用户提供简单的接口，可以使他们的任务变得更加简单。例如，如果你正在探索一个新的包，并在某个时刻得到了由该包派生出的某种结果，尝试调用
    `plot(result)`，你可能会惊讶地得到一个有意义的图形。这在其他语言中并不常见。
- en: When doing object-oriented programming with R's S3 and S4 models, keep in mind
    that you should not call methods directly, but should declare corresponding generic
    functions and call those instead. This may be a bit confusing at first, but it's
    just one of R's unique characteristics that you get used to with time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 R 的 S3 和 S4 模型进行面向对象编程时，请记住，你不应该直接调用方法，而应该声明相应的泛型函数并调用它们。这可能会在一开始有些令人困惑，但这是
    R 的独特特性之一，随着时间的推移你会习惯它。
- en: The S3 object model
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: S3 对象模型
- en: As you may recall, the R language is derived from the S language. S's object
    model evolved over time, and its third version introduced **class attributes**,
    which allowed for the S3 object model we find in R today. It is still the object
    model in R, and most of R's own built-in classes are of the S3 type. It's a valid
    and very flexible object model, but it's very different from what people who come
    from other object-oriented languages are used to.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，R 语言是从 S 语言派生出来的。S 的对象模型随着时间的推移而发展，其第三个版本引入了 **类属性**，这允许我们今天在 R 中找到的 S3
    对象模型。它仍然是 R 中的对象模型，R 的大多数内置类都是 S3 类型。它是一个有效且非常灵活的对象模型，但它与来自其他面向对象语言的人所习惯的非常不同。
- en: S3 is the least formal object model, so it's lacking in some key respects. For
    example, S3 does not offer formal class definitions, which implies that there's
    no formal concept of inheritance or encapsulation, and polymorphism is achieved
    through generics. It's clear that its functionality is limited in some key respects,
    but the programmer has quite a bit of flexibility. However, as Hadley Wickham
    put it in *Advanced R, by Chapman and Hall, 2014:*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: S3 是最不正式的对象模型，因此在某些关键方面存在不足。例如，S3 不提供正式的类定义，这意味着没有正式的继承或封装概念，而多态性是通过泛型实现的。很明显，在关键方面其功能有限，但程序员有很大的灵活性。然而，正如
    Hadley Wickham 在《Chapman and Hall，2014年出版的《高级R》》中所说：
- en: '"S3 has a certain elegance in its minimalism: you can''t take away any part
    of it and still have a useful object-oriented system."'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '"S3 在其简约性中具有一定的优雅：你无法去掉任何部分，仍然有一个有用的面向对象系统。" '
- en: Classes, constructors, and composition
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类、构造函数和组合
- en: The idea of an object is really just to bundle data and corresponding methods
    together. Lists in R are well-suited to implement this, since they can contain
    different data types, even functions, which are first class objects that can be
    assigned or returned like any other. In fact, we can literally create objects
    of a new class in R by taking a list and simply setting the class attribute of
    the list to a new value, which is how we create classes in S3.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的想法实际上只是将数据和相应的方法捆绑在一起。R中的列表非常适合实现这一点，因为它们可以包含不同的数据类型，甚至函数，这些函数是一等对象，可以像任何其他对象一样分配或返回。实际上，我们可以通过将列表的类属性简单地设置为新的值来在R中创建新类的对象，这就是我们在S3中创建类的方式。
- en: 'Instead of providing definitions for S3 classes, we provide constructors. These
    constructors have the responsibility of creating objects (a string which has the
    parameter passed in the case of `S3Color` and a list in the case of `S3Rectangle`)
    and assigning a string to their class attributes. These objects are then returned,
    and they represent the classes we will be using. In the case of the rectangle,
    our constructor receives the length, orthogonal sides, and the name of its color.
    The color constructor only receives the name of the color:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是为S3类提供定义，而是提供构造函数。这些构造函数负责创建对象（对于`S3Color`是传递的参数字符串，对于`S3Rectangle`是列表）并将字符串分配给它们的类属性。然后返回这些对象，它们代表我们将要使用的类。在矩形的例子中，我们的构造函数接收长度、正交边以及其颜色的名称。颜色构造函数只接收颜色的名称：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, instead of assigning the `color` string which is passed as a
    parameter to the `rectangle_constructor()` function directly in the `color` element
    of the `rectangle` list, we use the `color_constructor()` function to provide
    a `Color` class, not only a string. You should do this if you will add behavior
    to the color abstraction, as we will do.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们不是直接在矩形的列表中的`color`元素里分配作为参数传递给`rectangle_constructor()`函数的`color`字符串，而是使用`color_constructor()`函数提供一个`Color`类，而不仅仅是字符串。如果你打算为颜色抽象添加行为，就像我们将要做的那样，你应该这样做。
- en: 'Now, we can create an `S3_rectangle` by calling the `rectangle_constructor()`,
    and we can print its class, which is shown to be `S3Rectangle`, just as we expected.
    Also, if you print the `S3_rectangle` structure, you will see that it contains
    the two sides for the rectangle definition, the color class, and the attribute
    class names:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用`rectangle_constructor()`来创建一个`S3_rectangle`，并且我们可以打印它的类，结果显示为`S3Rectangle`，正如我们所预期的。此外，如果你打印`S3_rectangle`的结构，你会看到它包含了矩形定义的两个边，颜色类以及属性类名称：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sometimes, you will see that we have added a prefix to an object with the name
    of the object model we're using (`S3` in this case). For example, `S3Color` and
    `S3Rectangle`. When you see that, it means that the particular name clashes with
    the corresponding object in another object model, and we need to differentiate
    them. If you don't do this, you may encounter quite confusing and difficult to
    diagnose bugs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会看到我们给一个对象添加了一个前缀，这个前缀是我们使用的对象模型名称（在这种情况下是`S3`）。例如，`S3Color`和`S3Rectangle`。当你看到这种情况时，意味着特定的名称与另一个对象模型中的相应对象冲突，我们需要区分它们。如果你不这样做，你可能会遇到相当令人困惑且难以诊断的错误。
- en: Public methods and polymorphism
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共方法和多态
- en: To define a method for a class, we need to use the `UseMethod()` function to
    define a hierarchy of functions. It will tell R to look for a function whose prefix
    matches the current function and for a suffix in order from the vector of class
    names of the object being passed. The names of the methods have two parts, separated
    by a "`.`", where the prefix is the function name and the suffix is the name of
    a class. As you can see, S3 generic functions work by naming conventions, not
    by explicitly registering methods for different classes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要为类定义一个方法，我们需要使用`UseMethod()`函数来定义函数的层次结构。它将告诉R寻找一个前缀与当前函数匹配且后缀在传递给对象的类名向量中的函数。方法名称有两部分，由一个"`.`"分隔，其中前缀是函数名，后缀是类的名称。正如你所见，S3泛型函数是通过命名约定工作的，而不是通过为不同类显式注册方法。
- en: 'We start by creating an `S3area` method for the `S3Rectangle` class, and we
    do so by creating a function named `S3area.S3Rectangle`. The `UseMethod()` function
    will make sure that the `S3area.S3Rectangle` function receives an object of class
    `S4Rectangle`, so inside of such a function, we can make use of the class''s internals.
    In this case, we will take the lengths `a` and `b` and multiply them together:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为`S3Rectangle`类创建一个`S3area`方法，我们通过创建一个名为`S3area.S3Rectangle`的函数来实现这一点。`UseMethod()`函数将确保`S3area.S3Rectangle`函数接收一个`S4Rectangle`类的对象，因此在这个函数内部，我们可以使用类的内部结构。在这种情况下，我们将长度`a`和`b`相乘：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we can access such objects within the `rectangle` object by using
    the `$` operator. This is not restricted to being done within a method, so really,
    any object can change an S3 object's internals, but just because you can doesn't
    mean that you should.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过使用`$`运算符在`rectangle`对象内部访问这样的对象。这不仅仅限于在方法内部进行，所以实际上，任何对象都可以改变S3对象的内部结构，但仅仅因为你能够这样做，并不意味着你应该这样做。
- en: 'Now, we will call the `S3area` method as if it were a normal function call,
    to which we pass the rectangle object we created before, and we should see the
    area being printed to the console:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把`S3area`方法称为一个普通的函数调用，我们将传递之前创建的矩形对象，我们应该看到面积被打印到控制台：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What happened? An error? Well, how can R tell that the `S3area` function call
    should actually trigger the `S3area.S3Rectangle` method call? For that to happen,
    we need to register the name with R, and we do so by calling the defining function,
    which actually uses the `S3area` name by itself. This `S3area` function receives
    an object of any type, not necessarily a `S3Rectangle`, and uses the `UseMethod()` function
    to tell it that it should look for the `"S3area"` method call for that object.
    In this case, we know that it will only be found for the `S3Rectangle` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？错误？那么，R是如何知道`S3area`函数调用实际上应该触发`S3area.S3Rectangle`方法调用的呢？为了实现这一点，我们需要在R中注册这个名称，我们通过调用定义函数来实现，该函数实际上通过自身使用`S3area`名称。这个`S3area`函数接收任何类型的对象，不一定是`S3Rectangle`，并使用`UseMethod()`函数来告诉它应该为该对象查找`"S3area"`方法调用。在这种情况下，我们知道它只会在`S3Rectangle`类中找到：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can call the `S3area` method as we did before, but we will get the
    actual area in this case. This is how you normally create methods with S3:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像之前一样调用`S3area`方法，但这次我们将得到实际的面积。这就是你通常使用S3创建方法的方式：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we will create the `S3color` method to return the color object for the
    rectangle. Since the color object is just a character type, there''s nothing more
    we need to do to somehow parse that object if we just want the characters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`S3color`方法来返回矩形的颜色对象。由于颜色对象只是字符类型，如果我们只想获取字符，我们不需要做任何额外的事情来解析该对象：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we will print the rectangle. As you can see, the `print()` call simply
    shows us the internals of the object and objects contained within it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将打印矩形。正如你所见，`print()`调用仅仅显示了对象的内部及其包含的对象：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We may want to overload this function to provide a different output. To do
    so, we create `print.S3Rectangle()` and simply print a string that will tell us
    the color of the rectangle, the fact that it''s a rectangle, the length for each
    of its sides, and then its area. Note that both the color and the area are retrieved
    using the methods we defined before, `S3Color()` and `S3area()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要重载这个函数以提供不同的输出。为此，我们创建`print.S3Rectangle()`并简单地打印一个字符串，告诉我们矩形的颜色，它是一个矩形，每边的长度，然后是它的面积。注意，颜色和面积都是使用我们之前定义的方法检索的，即`S3Color()`和`S3area()`：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, what should happen if we simply call the `print()` function, as we did
    before with the `S3area()` function? We should get an error, shouldn''t we? Let''s
    look at the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们简单地调用`print()`函数，就像我们之前调用`S3area()`函数一样，会发生什么？我们应该得到一个错误，不是吗？让我们看看以下代码：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Well, as you can see, we don't. In this case, we actually get the output we
    hoped we would. The reason is that the `print()` function in R is an S3 function
    which already registered with the `UseMethod()` function. That means that our
    definition `print.S3Rectangle` does not need to be registered again, and we can
    simply use it. That's pretty neat, isn't it? That's one of the big advantages
    of using parametric polymorphism. We can register functions as method calls that
    we may or may not end up using at some point in the future in unexpected ways,
    but they still provide a homogeneous interface for the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，正如你所见，我们并没有这样做。在这种情况下，我们实际上得到了我们希望得到的结果。原因是R中的`print()`函数是一个已经注册到`UseMethod()`函数的S3函数。这意味着我们的`print.S3Rectangle`定义不需要再次注册，我们可以直接使用它。这很酷，不是吗？这是使用参数多态的一个大优点。我们可以将函数注册为可能或可能不会在未来以意想不到的方式使用的方法调用，但它们仍然为用户提供了一致的接口。
- en: Encapsulation and mutability
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和可变性
- en: 'Now, we will see how S3 handles mutability and encapsulation. To do so, we
    will print the `a` value in the rectangle, modify it, and print it again. As you
    can see, we are able to modify it, and from that point on we get a different result,
    and we do so without any method calls. That''s a very risky thing to do, and you
    should definitely wrap this type of behavior in method calls:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到S3如何处理可变性和封装。为此，我们将打印矩形中的`a`值，修改它，然后再次打印。正如你所见，我们能够修改它，并且从那时起我们得到不同的结果，而且我们没有进行任何方法调用。这是一件非常危险的事情，你绝对应该在方法调用中封装这种行为：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Even if you can, never modify an object's internals directly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可以，也永远不要直接修改对象的内部结构。
- en: 'The proper way of modifying an object would be through some type of setter
    function. The `set_color.S3Rectangle()` method will be used to modify the rectangle''s
    color, by receiving a `S3Rectangle` and a `new_color` string, and saving that
    new string inside of a `color` attribute in the rectangle. When you use a method
    like this, you''re being explicit about your intentions, which is a much better
    way of programming. Of course, we also need to register the method call with R,
    as shown previously:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 修改对象的正确方式应该是通过某种类型的设置函数。将使用`set_color.S3Rectangle()`方法来修改矩形的颜色，通过接收一个`S3Rectangle`和一个`new_color`字符串，并将这个新字符串保存在矩形的`color`属性中。当你使用这种类型的方法时，你明确了自己的意图，这是一种更好的编程方式。当然，我们还需要像之前展示的那样，将方法调用注册到R中：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Did you notice our error? Probably not, but it's great if you did! We did this
    on purpose to show you how easy it is to harm yourself when programming in R.
    Since R has no type checking, we inadvertently assigned a string where we should
    have assigned a `Color`. This means that the `color` attribute in our rectangle
    will no longer be recognized as a `Color` class after we call the `set_color()`
    method; it will be recognized as a string. If your code depends on this object
    being of the `Color ` type, it will probably fail in unexpected and confusing
    ways and will be hard to debug. Be careful when doing assignments. Instead, we
    should have put `rectangle$color <- color_constructor(new_color)` to keep consistency.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们的错误了吗？可能没有，但如果注意到了那就太好了！我们故意这样做是为了向你展示在R中编程时伤害自己是多么容易。由于R没有类型检查，我们无意中分配了一个字符串，而我们应该分配一个`Color`。这意味着在调用`set_color()`方法后，我们的矩形中的`color`属性将不再被识别为`Color`类；它将被识别为一个字符串。如果你的代码依赖于这个对象是`Color`类型，它可能会以意想不到和令人困惑的方式失败，并且难以调试。在进行赋值时要小心。相反，我们应该使用`rectangle$color
    <- color_constructor(new_color)`来保持一致性。
- en: 'While you can change the type of an object, you never should. As Hadley Wickham
    puts it, *R doesn''t protect you from yourself: you can easily shoot yourself
    in the foot. As long as you don''t aim the gun at your foot and pull the trigger,
    you won''t have a problem*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以改变一个对象的数据类型，但你永远不应该这样做。正如Hadley Wickham所说，*R不会保护你不犯错误：你很容易自己伤害自己。只要你不把枪口对准自己的脚并扣动扳机，你就不会有问题*。
- en: 'Now, we show how the `set_color()` method can be used. We will print the rectangle''s
    color, attempt to change it to black, and print it again. As you can see, the
    change was not persisted in our object. That''s because R passes objects by value
    and not by reference. This simply means that when we modify the rectangle, we
    are actually modifying a copy of the rectangle, not the rectangle we passed ourselves:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示如何使用`set_color()`方法。我们将打印矩形的颜色，尝试将其更改为黑色，然后再次打印。正如你所见，更改并没有持久化在我们的对象中。这是因为R通过值传递对象，而不是通过引用。这仅仅意味着当我们修改矩形时，我们实际上是在修改矩形的副本，而不是我们传递给自己的矩形：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Did you notice that at the end of the `set_color.S3Rectangle()` function, we
    returned the `rectangle`? In other languages that may not be necessary, but in
    R, we do so to get back the modified object. To persist the changes in our object,
    we need to actually assign that resulting object into our own `S3_rectangle`,
    and when we do, then we can see that the color change was persisted.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到在`set_color.S3Rectangle()`函数的末尾，我们返回了`rectangle`吗？在其他语言中可能不需要这样做，但在R中，我们这样做是为了返回修改后的对象。为了使对象中的更改持久化，我们需要将那个结果对象实际分配到我们自己的`S3_rectangle`中，当我们这样做时，我们就可以看到颜色更改已经持久化。
- en: This property is what gives S3 its immutability property. This is very useful
    when working with functional programming, but can be a bit of a hassle to work
    with when doing object-oriented programming. Some confusing bugs may come from
    this property to get you used to working this way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性赋予了S3不可变性的特性。这在处理函数式编程时非常有用，但在进行面向对象编程时可能会有些麻烦。一些令人困惑的错误可能来自这个属性，让你习惯以这种方式工作。
- en: Inheritance
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: S3 classes lack a lot of the structure normally found in other languages. Inheritance
    is implemented informally, and encapsulation is not enforced by the language,
    as we have seen before.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: S3类缺少在其他语言中通常找到的大量结构。继承是非正式实现的，封装也不是由语言强制执行的，正如我们之前所看到的。
- en: 'To implement inheritance, we will create a `square_constructor()` function
    that will receive the length of the sides in `a` and the name of the color. We
    will then use the `rectangle_construtor()` and send `a` for both lengths (making
    it a square), and will also send the color. Then, we will add the `S3Square` class,
    and finally, return the created object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现继承，我们将创建一个`square_constructor()`函数，该函数将接收边长`a`和颜色名称。然后，我们将使用`rectangle_construtor()`并将`a`作为两个长度（使其成为正方形）发送，同时也会发送颜色。然后，我们将添加`S3Square`类，最后返回创建的对象：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we will create a square and print its classes. As you can see, it has
    the `S3Square` and `S3Rectangle` classes assigned, in order, and when we use the
    `print()` method on it, we actually get the print functionality from the `S3Rectangle`
    class, which is expected since we''re signaling the inheritance:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个正方形并打印其类。如你所见，它按顺序分配了`S3Square`和`S3Rectangle`类，当我们使用`print()`方法时，实际上是从`S3Rectangle`类获取打印功能，这是预期的，因为我们发出了继承的信号：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we want to provide a specific print functionality for the square, we must
    overwrite the `print()` method with our own definition for `S3Square` classes,
    as we now do. The function is exactly the same as before, but we use the word
    `"square"` instead of `"rectangle"`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为正方形提供特定的打印功能，我们必须像现在这样覆盖`print()`方法，为`S3Square`类定义我们自己的方法。该函数与之前完全相同，但我们使用的是单词`"square"`而不是`"rectangle"`。
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, when we print, we can see that the correct method is being used, because
    we see the word `"square"` in the output. Note that we did not have to re-register
    the `print()` method with the `UseMethod()` function, since we had already done
    so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打印时，我们可以看到正在使用正确的方法，因为我们看到输出中出现了单词`"square"`。请注意，我们不需要使用`UseMethod()`函数重新注册`print()`方法，因为我们已经这样做了：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, remember that if the class attribute is a vector with more than one
    element, then the first element is interpreted as the class of the object, and
    the following elements are interpreted as classes that the object inherits from.
    That makes inheritance a property of objects, not classes, and order is important.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，如果类属性是一个包含多个元素的向量，则第一个元素被解释为对象的类，而后续元素被解释为对象继承的类。这使得继承成为对象的属性，而不是类的属性，并且顺序很重要。
- en: If we had instead written `class(square) <- c(class(square), "S3Square")` in
    the `square_constructor()` function, then even after creating the `print.S3Square()`
    function, we would still see the `print()` method calling the `print.S3Rectangle()`
    function. Be careful with this.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`square_constructor()`函数中写成`class(square) <- c(class(square), "S3Square")`，那么即使创建了`print.S3Square()`函数，我们仍然会看到`print()`方法调用`print.S3Rectangle()`函数。请注意这一点。
- en: The S4 object model
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: S4对象模型
- en: Some programmers feel that S3 does not provide the safety normally associated
    with object-oriented programming. In S3, it is very easy to create a class, but
    it can also lead to very confusing and hard to debug code when not used with great
    care. For example, you could easily misspell a name, and R would not complain.
    You could easily change the class to an object, and R would not complain, either.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员认为 S3 并没有提供与面向对象编程通常相关的安全性。在 S3 中，创建一个类非常容易，但如果不小心使用，也可能导致非常混乱且难以调试的代码。例如，你可能会轻易地拼错一个名称，而
    R 不会抱怨。你也很容易将类更改为对象，R 也不会抱怨。
- en: S4 classes were developed after S3, with the goal of adding safety. S4 provides
    protection, but it also introduces a lot of verbosity to provide that safety.
    The S4 object model implements most features of modern object-oriented programming
    languages—formal class definitions, inheritance, polymorphism (parametric), and
    encapsulation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: S4 类是在 S3 之后开发的，目的是增加安全性。S4 提供了保护，但也引入了大量的冗余来提供这种安全性。S4 对象模型实现了现代面向对象编程语言的大多数功能——正式的类定义、继承、多态（参数化）和封装。
- en: Classes, constructors, and composition
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类、构造函数和组合
- en: An S4 class is created using the `setClass()` function. At a minimum, the name
    of the `Class` and its attributes, formally known as **slots** in S4, must be
    specified. The slots are specified in with the `representation()` function, and
    a neat feature is that you specify the type expected for such attributes. This
    helps a bit with type-checking.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setClass()` 函数创建 S4 类。至少，必须指定 `Class` 的名称及其属性，在 S4 中正式称为 **槽**。槽通过 `representation()`
    函数指定，并且一个整洁的功能是你可以指定此类属性期望的类型。这有助于类型检查。
- en: There are other features built-in that we are not going to look at here. For
    example, you could provide a function that verifies the object is consistent (has
    not been manipulated in some unexpected way). You can also specify default values,
    in a parameter called the `prototype`. If you want these features in S3, you can
    also implement them yourself, but they don't come as built-in features. S4 is
    regarded as a powerful object model, and you should definitely study it more in
    depth by browsing its documentation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些内置的功能我们在这里不会探讨。例如，你可以提供一个函数来验证对象的一致性（没有被以某种意外的方式操作）。你还可以指定默认值，在名为 `prototype`
    的参数中。如果你想在 S3 中使用这些功能，你也可以自己实现它们，但它们不是内置功能。S4 被视为一个强大的对象模型，你应该通过浏览其文档来更深入地学习它。
- en: All S4 related code is stored in the methods package. This package is always
    available when you're running R interactively, but may not be available when running
    R in batch mode. For this reason, it's a good idea to include an explicit `library(methods)`
    call whenever you're using S4.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与 S4 相关的代码都存储在 `methods` 包中。当你以交互方式运行 R 时，此包总是可用的，但在批处理模式下运行 R 时可能不可用。因此，在每次使用
    S4 时包含一个显式的 `library(methods)` 调用是一个好主意。
- en: 'As you can see, the conceptual difference from S3 classes is that here, we
    actually specify the type of object for each slot. Other changes are more syntactic
    than conceptual. Note that you may use the name of another S4 class for one of
    the slots, as we do in the case of `color` for the `S4Rectangle`. This is how
    you can achieve composition with S4:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，与 S3 类的概念区别在于，在这里，我们实际上为每个槽指定了对象的类型。其他的变化更多的是语法上的，而不是概念上的。请注意，你可以使用另一个
    S4 类的名称作为其中一个槽的名称，就像我们在 `S4Rectangle` 的 `color` 例子中所做的那样。这就是你如何使用 S4 实现组合的方式：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The constructor is built automatically for you with a call to the `new()` function.
    As you can see, you simply need to pass through the name of the class you''re
    instantiating and the values that should be assigned to the slots:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是通过调用 `new()` 函数自动为你构建的。正如你所见，你只需传递你正在实例化的类的名称以及应该分配给槽的值：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we did before, we retrieve the class for the object and print it. When we
    print it, we can see a structure that contains some `@` symbols. Those are the
    operators used to access the slots (instead of the `$` operator for S3). You can
    also see the nested slot for the `color` attribute of the `Color` class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们检索对象的类并打印它。当我们打印它时，我们可以看到一个包含一些 `@` 符号的结构。这些是用于访问槽的运算符（而不是 S3
    中的 `$` 运算符）。你还可以看到 `Color` 类的 `color` 属性的嵌套槽：
- en: Some slot names are forbidden due to the fact that they are reserved keywords
    in R. Forbidden names include `class`, `comment`, `dim`, `dimnames`, `names`,
    `row.names`, and `tsp`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些名称在 R 中是保留关键字，因此一些槽名称是禁止使用的。禁止的名称包括 `class`、`comment`、`dim`、`dimnames`、`names`、`row.names`
    和 `tsp`。
- en: Public methods and polymorphism
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共方法和多态性
- en: Since S4 also uses parametric polymorphism (methods belong to functions, not
    classes) and we have already explained it a couple of times before, we are going
    to just point out the differences with S3 at this point. First, instead of using
    the `UseMethod()` function to register methods with R, we use the `setGeneric()` function,
    with the name of the method, and a function that calls the `standardGeneric()` function
    inside. This will provide the dispatch mechanism for S4 objects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 S4 也使用参数多态（方法属于函数，而不是类），并且我们之前已经解释过几次，所以我们现在将只指出与 S3 的不同之处。首先，我们不是使用 `UseMethod()`
    函数在 R 中注册方法，而是使用 `setGeneric()` 函数，其中包含方法名称，以及一个调用 `standardGeneric()` 函数的函数。这将提供
    S4 对象的调度机制。
- en: To actually create a method, instead of using a naming convention as we do in
    S3, we actually pass the name of the class and the method to the `setMethod()` function,
    as well as the function that should be used as a method. Second, the order there
    matters. If you call the `setMethod()` function before you call the `setGeneric()`
    method, your dispatch mechanism won't work. We did that in S3, but here, we need
    to reverse the order. Finally, note that we access object attributes (slots) with
    the `@` symbol, as we mentioned before.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际创建一个方法，我们不是像在 S3 中那样使用命名约定，而是将类名称和方法名称传递给 `setMethod()` 函数，以及用作方法的函数。其次，那里的顺序很重要。如果你在调用
    `setGeneric()` 方法之前调用 `setMethod()` 函数，你的调度机制将不会工作。我们在 S3 中就是这样做的，但在这里，我们需要颠倒顺序。最后，请注意，我们使用
    `@` 符号访问对象属性（槽位），正如我们之前提到的。
- en: 'For completeness in the example so that the reader may compare the code for
    all three examples side by side, we now show how to implement the same code we
    showed for the S3 case:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例完整，以便读者可以并排比较所有三个示例的代码，我们现在展示如何实现我们之前为 S3 情况所展示的相同代码：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you use `print()` on `S4_rectangle`, you will see that it''s recognized
    to be of a certain type, and it will show its slots:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `print()` 在 `S4_rectangle` 上，你会看到它被识别为某种类型，并且它会显示其槽位：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we want to change this output, we override this method with our own, as
    we did in the case of S3\. However, if we do, we will have the `print()` function
    defined to work with S4 objects, and it will stop working for objects from other
    object models. We encourage you to try it yourself by changing the code below
    to use the `print` method call instead of the `S4print` name. As you can see,
    we are using the same overriding mechanism as before, so we will skip its explanation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想改变这个输出，我们可以像在 S3 的情况下那样用我们自己的方法覆盖它。然而，如果我们这样做，我们将定义 `print()` 函数以与 S4 对象一起工作，并且它将停止为来自其他对象模型的对象工作。我们鼓励你通过将下面的代码更改为使用
    `print` 方法调用而不是 `S4print` 名称来亲自尝试。正如你所见，我们正在使用与之前相同的覆盖机制，所以我们将跳过其解释：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we may use the `S4print()` method to print the desired output, as you
    can see in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `S4print()` 方法来打印所需的输出，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Encapsulation and mutability
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和可变性
- en: Now, we will take a look at the encapsulation and mutability concepts in S4\.
    First, note that we are using the `print()` and not the `S4print()` method, because
    we are printing specific slots from `S4_rectangle`. As you can see, if we're not
    careful, we can still assign values directly to the internals of the object. Again,
    you should not do this.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨 S4 中的封装和可变性概念。首先，请注意我们使用的是 `print()` 而不是 `S4print()` 方法，因为我们正在打印 `S4_rectangle`
    的特定槽位。正如你所见，如果我们不小心，我们仍然可以直接分配值到对象的内部。再次强调，你不应该这样做。
- en: 'Also note that if we use the method `S4color()` that we created before to encapsulate
    the access to the `color` attribute, we get an error telling us that the `S4color<-`
    function could not be found. That hints to us that we can create such a function,
    and we can:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果我们使用之前创建的 `S4color()` 方法来封装对 `color` 属性的访问，我们会得到一个错误，告诉我们找不到 `S4color<-`
    函数。这提示我们可以创建这样的函数，我们可以：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To create a function that will encapsulate access to an object's attribute,
    we can use the `setReplaceMethod()` function, just as we did with the `setMethod()`
    function before. Note that the name of the method we are passing to the `setGeneric()`
    function is the one that was hinted to us in R's error, which is the name of the
    slot followed by the normal assignment operator in R, `<-`. Also note that there's
    no space between the name of the variable and symbols for the assignment operator.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个封装对象属性访问的函数，我们可以使用 `setReplaceMethod()` 函数，就像我们之前使用 `setMethod()` 函数一样。请注意，我们传递给
    `setGeneric()` 函数的方法的名称是 R 错误中提示给我们的名称，即槽位的名称后跟 R 中的正常赋值运算符 `<-`。另外请注意，变量名称和赋值运算符符号之间没有空格。
- en: 'Finally, note that we made sure to create an object of type `S4Color` when
    assigning a new value to the `color` slot. If you try to simply assign a string
    as we did with the S3 class, you will get an error letting you know you''re trying
    to do something you shouldn''t be doing. This is a big advantage when working
    with S4, as it can prevent you from committing some unexpected mistakes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们在给 `color` 槽位赋新值时确保创建了一个 `S4Color` 类型的对象。如果你尝试像我们对 S3 类那样简单地赋一个字符串，你会得到一个错误，告诉你你正在尝试做一些你不应该做的事情。这在使用
    S4 时是一个很大的优势，因为它可以防止你犯一些意外的错误：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once we create such a method, we can use it to assign to the color object directly,
    in an encapsulated manner, which is much better than manipulating the slots directly.
    As you can see, the color change is persisted:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了这样的方法，我们就可以用它直接、封装地给颜色对象赋值，这比直接操作槽位要好得多。正如你所看到的，颜色变化被持久化了：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inheritance
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Creating a subclass is easy; we simply need to call the `setClass()` function
    as we did before, and send the `contains` parameter with the name of the class
    it will inherit from. S4 supports multiple inheritance, but it's not something
    we're going to look at. The interested reader is encouraged to look into the documentation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子类很容易；我们只需像以前一样调用 `setClass()` 函数，并发送 `contains` 参数，其中包含它将继承的类的名称。S4 支持多重继承，但我们不会探讨这一点。感兴趣的读者可以查阅文档。
- en: 'An interesting feature of S4 classes is that if a class extends one of R''s
    basic types, there will be a slot called `.Data` containing the data from the
    basic object type. Code that works on the basic object type will work directly
    on the `.Data` part of the object, so it makes our programming a bit easier:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: S4 类的一个有趣特性是，如果一个类扩展了 R 的基本类型，那么将会有一个名为 `.Data` 的槽位，其中包含基本对象类型的数据。在基本对象类型上工作的代码将直接在对象的
    `.Data` 部分上工作，这使得我们的编程变得稍微容易一些：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that when we instantiate the `S4Square` class, we will need to pass both
    attributes for the length and make sure they are the same. As we can see, the
    class of the object is identified correctly, and the polymorphic `S4print()` method
    we defined previously works fine:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们实例化 `S4Square` 类时，我们需要传递长度属性，并确保它们相同。正如我们所看到的，对象的类被正确地识别，我们之前定义的多态 `S4print()`
    方法也正常工作：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, for completeness, we override the `S4print()` method with one that uses
    the `"square"` word instead, and we can see that it works as expected:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了完整性，我们用使用 `"square"` 词汇的 `S4print()` 方法覆盖了它，我们可以看到它按预期工作：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The R6 object model
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R6 对象模型
- en: S3 and S4 are really just ways to implement polymorphism for static functions.
    The R6 package provides a type of class which is similar to R's Reference Classes,
    but it is more efficient and doesn't depend on S4 classes and the methods package
    as RCs do.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: S3 和 S4 实际上只是实现静态函数多态性的方法。R6 包提供了一种类似于 R 的引用类的类类型，但它更高效，并且不依赖于 S4 类和方法包，正如 RCs
    所做的那样。
- en: When RCs were introduced, some users, following the names of R's existing class
    systems S3 and S4, called the new class system R5\. Although RCs are not actually
    called R5 nowadays, the name of this package and its classes follows that pattern.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当引入 RCs 时，一些用户遵循 R 现有类系统 S3 和 S4 的命名，将新的类系统称为 R5。尽管现在实际上并不称为 R5，但这个包及其类的命名遵循这种模式。
- en: Despite being first released over three years ago, R6 isn't widely known. However,
    it is widely used. For example, it's used within Shiny (the focus of the last
    chapter in this book) and to manage database connections in the dplyr package.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管R6在三年多前就已经发布，但它并不广为人知。然而，它被广泛使用。例如，它在Shiny（本书最后一章的重点）中使用，并在dplyr包中管理数据库连接。
- en: Classes, constructors, and composition
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类、构造函数和组合
- en: Classes in R6 are created with the `R6Class()` function, and we pass the name
    of the class and lists of public and private objects. These objects can be either
    attributes or methods. As you can see, building a class definition in R6 produces
    much cleaner code, which is put together in a single definition instead of the
    step-by-step process used in S3 and S4\. This approach is more like what you can
    find in other popular languages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: R6类是通过`R6Class()`函数创建的，我们传递类的名称和公共和私有对象的列表。这些对象可以是属性或方法。正如您所看到的，在R6中使用类定义生成更干净的代码，这些代码在一个单独的定义中组合，而不是像S3和S4中使用的逐步过程。这种方法更类似于您在其他流行语言中可以找到的方法。
- en: You may specify how the constructor should behave by using the `initialize`
    method. This specific method will be called when an instance of the class is created.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`initialize`方法来指定构造函数应该如何表现。当创建类的实例时，将调用此特定方法。
- en: 'There are two important differences between our names in the following definition
    and what we used for the S3 and S4 examples. In this case, we call the print method
    `own_print()` and the `color` property `own_color`. The reason for the former
    is that R would be confused between the `color()` method and the `color` attribute.
    To avoid errors, we can change the name for one of them, and to keep our public
    interface the same, we decide to change the private attribute in this case. The
    reason for `own_print()` will be explained ahead:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下定义中，我们与S3和S4示例中使用的名称之间有两个重要的区别。在这种情况下，我们调用打印方法为`own_print()`，将`color`属性称为`own_color`。前者的原因是R会在`color()`方法和`color`属性之间混淆。为了避免错误，我们可以更改其中一个的名称，为了保持我们的公共接口不变，我们决定在这种情况下更改私有属性。`own_print()`的原因将在后面解释：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To create an instance of a class, we call the `new()` method in the class object.
    We can pass some parameters, and if we do, they will be used by the `initialize`
    function defined for the class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类的实例，我们调用类对象中的`new()`方法。我们可以传递一些参数，如果这样做，它们将被类中定义的`initialize`函数使用。
- en: As you can see, if we use `print()` on the `R6_rectangle` object, we see a nice
    output letting us know what methods and attributes are public and private, as
    well as some extra information about them, like the fact that the default `clone()`
    method (used for making copies of an R6 object) is set to shallow copying instead
    of deep copying. We won't go into the details of what these concepts are, but
    the interested reader is encouraged to look into pass-by-reference versus pass-by-value
    mechanics.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果我们对`R6_rectangle`对象使用`print()`，我们会看到一个漂亮的输出，让我们知道哪些方法和属性是公共的，哪些是私有的，以及一些关于它们的额外信息，例如默认的`clone()`方法（用于创建R6对象的副本）被设置为浅拷贝而不是深拷贝。我们不会深入探讨这些概念的具体细节，但鼓励感兴趣的读者了解按引用传递与按值传递的机制。
- en: 'If we had defined a `print()` method within our class, then the `print(R6_rectangle)`
    would have used that function by default. Note that this would be syntactically
    different from calling the method directly by executing a command like `R6_rectangle$print()`,
    but R is intelligent enough to know that if you define a `print()` method in your
    class, it''s probably because you want to use it when using the `print()` function
    on the object. If that''s not the case, then you should change the name of your
    custom print function, as we do in the case of the `own_print()` method name:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类中定义了一个`print()`方法，那么`print(R6_rectangle)`将默认使用该函数。请注意，这与直接通过执行类似`R6_rectangle$print()`的命令直接调用方法在语法上会有所不同，但R足够智能，知道如果您在类中定义了一个`print()`方法，那么您可能想在对象上使用`print()`函数时使用它。如果不是这种情况，那么您应该更改您自定义打印函数的名称，就像我们在`own_print()`方法名称的情况中所做的那样：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see from the output, in the case of R6 classes, we have two classes
    instead of one. We have the class we defined ourselves, and we also have the general
    `R6` class added for us for the object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，在R6类的情况下，我们有两个类而不是一个。我们定义了自己的类，还为我们添加了通用的`R6`类。
- en: Public methods and polymorphism
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共方法和多态
- en: 'We have already defined the methods we want in the previous piece of code,
    so for completeness, we will only show how to call these methods now. As you can
    see, you simply use the `$` operator to access a public attribute or a public
    method, and if it''s a method, you add the parentheses at the end (surrounding
    any parameters you want to send as you normally would):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的代码片段中定义了我们想要的方法，因此为了完整性，我们现在将仅展示如何调用这些方法。正如你所见，你只需使用 `$` 操作符来访问公共属性或公共方法，如果它是方法，你需要在末尾添加括号（围绕你想要发送的任何参数，就像你通常那样）：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Encapsulation and mutability
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和可变性
- en: Since we placed the `a`, `b`, and `own_color` in the `private` list in the class
    definition, they remain private, and this is how encapsulation is enforced in
    R6\. As you can see, we were not allowed to assign directly to the `a` attribute
    as we expected, since it was placed in the `private` list. This makes sure that
    we can't have attributes or methods marked as private directly from outside the
    object, and prevents us from making bad decisions when coding. This is a great
    advantage of the R6 model.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在类定义中将 `a`、`b` 和 `own_color` 放入了 `private` 列表中，它们保持为私有，这就是 R6 中强制封装的方式。正如你所见，我们不允许直接将
    `a` 属性赋值，正如我们预期的那样，因为它被放置在 `private` 列表中。这确保了我们不能直接从对象外部访问标记为私有的属性或方法，并防止我们在编码时做出错误的决定。这是
    R6 模型的一个巨大优势。
- en: Encapsulation in R6 is achieved through environments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: R6 中的封装是通过环境实现的。
- en: 'Mutability is achieved by using setters (methods used to change a class''s
    attribute). Notice that in this case, we don''t need to reassign the resulting
    object as we do with S3\. State is actually saved within the object''s environment,
    and it can be changed; thus, R6 has mutability:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可变性是通过使用设置器（用于更改类属性的方法）实现的。请注意，在这种情况下，我们不需要像在 S3 中那样重新分配结果对象。状态实际上保存在对象的环境中，并且可以更改；因此，R6
    具有可变性：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inheritance
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'Inheritance is also more familiar when working with the R6 object model. In
    this case, you can simply add the `inherit` parameter to the `R6Class()` function
    call, and you may call the `initialize` method for the superclass by using `super$initialize()`.
    In this case, we use that technique to provide a more intuitive constructor interface
    to the user: a single value for length in the case of a square, instead of having
    to repeat the same value twice, which can be prone to counter-intuitive behavior
    if not checked. We can also override the `print()` method, just as we would normally
    add another method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 继承在处理 R6 对象模型时也更加熟悉。在这种情况下，你只需将 `inherit` 参数添加到 `R6Class()` 函数调用中，并且你可以通过使用
    `super$initialize()` 来调用超类的 `initialize` 方法。在这种情况下，我们使用这种技术为用户提供一个更直观的构造函数接口：对于正方形的情况，只需提供一个长度值，而不是必须重复相同的值两次，如果不进行检查，这可能会导致反直觉的行为。我们还可以覆盖
    `print()` 方法，就像我们通常添加另一个方法一样：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see, in this case we get a list of classes that include the current
    class `R6Square`, as well as the classes this object inherits from, `R6Rectangle`
    and `R6`. Since we used an override for the `print()` method, we can use the common
    `print(object)` syntax instead of the ad-hoc `object$print()` syntax provided
    by R6:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在这种情况下，我们得到了一个包含当前类 `R6Square` 以及该对象继承的类 `R6Rectangle` 和 `R6` 的类列表。由于我们覆盖了
    `print()` 方法，我们可以使用常见的 `print(object)` 语法，而不是 R6 提供的特定 `object$print()` 语法：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Active bindings
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活跃绑定
- en: 'Active bindings look like fields, but each time they are accessed, they call
    a function. They are always publicly visible and are similar to Python''s properties.
    If we wanted to implement the `color()` method as an active binding, we could
    use the following code. As you can see, you can either get or set the `color`
    attribute, without using an explicit method call (note the missing parentheses):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃绑定看起来像字段，但每次访问它们时，它们都会调用一个函数。它们始终公开可见，类似于 Python 的属性。如果我们想将 `color()` 方法实现为活跃绑定，我们可以使用以下代码。正如你所见，你可以获取或设置
    `color` 属性，而不需要使用显式的方法调用（注意缺少的括号）：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, when an active binding is used as a *getter* (to retrieve a
    value), it calls the method without a value being passed. When it's accessed as
    a *setter* (to change an attribute), it calls the method passing the value to
    be assigned. It's not possible to use an active binding as a setter if the function
    takes no arguments.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当活跃绑定用作 *getter*（用于检索值）时，它调用方法而不传递任何值。当它作为 *setter*（用于更改属性）被访问时，它传递要分配的值来调用方法。如果函数不接受任何参数，则无法将活跃绑定用作设置器。
- en: Finalizers
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 析构函数
- en: Sometimes, it's useful to run a function when the object is garbage collected.
    If you're not familiar with garbage collection, you can think of it as a way to
    liberate unused memory when an object is no longer referenced by other objects
    in the environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在对象被垃圾回收时运行一个函数是有用的。如果你不熟悉垃圾回收，你可以将其视为当对象不再被环境中的其他对象引用时释放未使用内存的一种方式。
- en: 'A useful case for this feature is when you want to make sure a file or database
    connection gets closed before an object is garbage collected. To do this, you
    can define a `finalize()` method, which will be called with no arguments when
    the object is garbage collected. To test this functionality, you can simply add
    a *finalizer* as follows to some of your objects and see when you get the `"Finalizer
    called"` message in the console:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性有用的一个例子是当你想要确保在对象被垃圾回收之前关闭文件或数据库连接。为此，你可以定义一个 `finalize()` 方法，当对象被垃圾回收时，它将不带任何参数被调用。为了测试这个功能，你可以在你的某些对象中简单地添加一个
    *finalizer*，然后查看你何时在控制台看到 `"Finalizer called"` 消息：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finalizers will also be called when R exits.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当 R 退出时，finalizers 也会被调用。
- en: The architecture behind our cryptocurrencies system
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们加密货币系统背后的架构
- en: Now that the fundamentals for object-oriented programming with R have been illustrated,
    we will take those principles and apply them to the example we will work with
    for the rest of the book. We will build a system to track cryptocurrencies with
    object-oriented programming. If you're not familliar with cryptocurrencies, read
    the beginning of this chapter for a brief introduction.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经介绍了使用 R 进行面向对象编程的基础，我们将把这些原则应用到本书剩余部分我们将要处理的示例中。我们将使用面向对象编程来构建一个跟踪加密货币的系统。如果你对加密货币不熟悉，可以阅读本章的开头部分以获得简要介绍。
- en: The design and implemention you will see in this example evolved over various
    iterations and weeks. It's actually a part of the basic system I initially used
    in CVEST ([https://www.cvest.tech/](https://www.cvest.tech/)) to offer a single
    point of truth for users managing a diverse set of cryptocurrencies (although
    it was not implemented in R), so don't feel that you should be able to come up
    with a design like this right away (although many people certainly are able to,
    but most of the time, object-oriented systems are evolve in unpredicted ways).
    As Grady Booch puts it: *"A complex system that works is invariably found to have
    evolved from a simple system that worked. A complex system designed from scratch
    never works and can not be patched up to make it work. You have to start over,
    beginning with a working simple system."*
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你所看到的设计和实现经过了多次迭代和数周的时间演变。实际上，它是我在 CVEST ([https://www.cvest.tech/](https://www.cvest.tech/))
    中最初使用的基本系统的一部分，为管理多种加密货币的用户提供一个单一的真实点（尽管它并没有在 R 中实现），所以请不要觉得你应该能够立即想出这样的设计（尽管许多人当然能够做到，但大多数时候，面向对象的系统以不可预测的方式演变）。正如
    Grady Booch 所说：“一个运作复杂系统总是发现它是由一个运作的简单系统演变而来的。从头开始设计的复杂系统永远不会运作，也无法修补使其运作。你必须从头开始，从一个运作的简单系统开始。”
- en: Let's get to it. As you may know, cryptocurrencies can be stored in exchange
    accounts and in wallets. Since keeping cryptocurrencies stored in exchange accounts
    is a very bad idea (it's risky, and a user could end up losing their assets, as
    has repeatedly happened), we will only focus on the cases where cryptocurrencies
    are stored in wallets.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。正如你可能知道的，加密货币可以存储在交易所账户和钱包中。由于将加密货币存储在交易所账户中是一个非常糟糕的想法（它是有风险的，用户可能会失去他们的资产，这种情况已经反复发生），我们将只关注加密货币存储在钱包中的情况。
- en: 'Basically, what we are trying to do is to get a feed of real data about how
    many cryptocurrencies we posses and how much they are worth, both at a given point
    in time. To implement the system, the first thing we need to do is identify the
    primary abstractions, which are, in our case: users, assets, wallets, and exchanges.
    For simplicity, we will also include markets and databases in this list.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们试图做的是获取关于我们拥有多少加密货币以及它们在特定时间点价值多少的实时数据流。为了实现这个系统，我们首先需要做的是确定主要抽象，在我们的案例中是：用户、资产、钱包和交易所。为了简单起见，我们还将市场和数据库列入这个列表。
- en: We will use the term asset instead of cryptocurrency due to the fact that some
    of them are not technically currencies, but you may interchange those terms freely
    without confusion.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用“资产”这个词而不是“加密货币”，因为其中一些在技术上并不是货币，但你可以在不混淆的情况下自由互换这些术语。
- en: For our case, suppose we have decided from the start that even though we will
    read data from a single source, we may want to write data to multiple databases
    as we get it. Some of these databases may be local, and others may be remote.
    However, we don't want every piece of the system to know that there are multiple
    databases in use, since they really don't need this information to operate. Therefore,
    we will introduce another abstraction, namely storage, which will contain this
    information inside, and which will look like a single database to other objects
    that need to read or write data, and it will handle the details for them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的情况，假设我们一开始就决定，尽管我们将从单个源读取数据，但我们可能希望在获取数据时将数据写入多个数据库。其中一些数据库可能是本地的，而其他一些可能是远程的。然而，我们不想让系统的每一部分都知道正在使用多个数据库，因为它们实际上不需要这些信息来操作。因此，我们将引入另一个抽象，即存储，它将包含这些信息，并且对于需要读取或写入数据的其他对象来说，它将看起来像一个单一的数据库，并且将为他们处理细节。
- en: 'We include this abstraction in our list of primary abstractions, and that list
    is complete at this point:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个抽象包含在我们的主要抽象列表中，并且到目前为止这个列表是完整的：
- en: '![](img/00060.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00060.jpeg)'
- en: Cryptocurrency tracking architecture
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 加密货币跟踪架构
- en: Now, we need to define how this main abstraction will interact among themselves.
    We know that a user may have several wallets in her posession, and that in turn,
    these wallets have assets inside. Note that we separated the abstractions of assets
    and wallets because some wallets may contain more than on asset inside (for example,
    Ethereum wallets may contain various types of tokens). Since we anticipate this
    case, we will make sure we can deal with it accordingly by separating these concepts.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义这个主要抽象之间如何相互作用。我们知道一个用户可能拥有几个钱包，而这些钱包中包含资产。请注意，我们分离了资产和钱包的抽象，因为一些钱包可能包含多个资产（例如，以太坊钱包可能包含各种类型的代币）。由于我们预计这种情况，我们将确保我们可以通过分离这些概念来相应地处理它。
- en: Users also want to be able to store their own information as well as their assets
    information. To do so, they will receive a storage object and they will call methods
    on this object, for which the public interface will be well defined.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还希望能够存储他们自己的信息以及他们的资产信息。为此，他们将收到一个存储对象，并且他们将在这个对象上调用方法，其公共接口将定义良好。
- en: The storage abstraction will in turn contain a single database for reading,
    but may contain several databases for writing, as we mentioned before. It will
    store these database objects inside and send them messages as necessary to accomplish
    the read and write operations on behalf of objects using it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 存储抽象将包含一个用于读取的单个数据库，但可能包含多个用于写入的数据库，正如我们之前提到的。它将存储这些数据库对象并在必要时向它们发送消息，以代表使用它的对象完成读取和写入操作。
- en: Finally, just as wallets contain assets, exchanges contain markets. The difference
    is that assets identify a single type of cryptocurrency, while markets use exactly
    two cryptocurrencies to be defined. That is why we may have a market to exchange
    USD for BTC (written as USD/BTC), meaning that people may use US Dollars to buy/sell
    Bitcoin. Other markets could be BTC/LTC or LTC/USD (where LTC stands for **Litecoin**).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如钱包包含资产一样，交易所包含市场。区别在于资产标识一种单一的加密货币类型，而市场使用恰好两种加密货币来定义。这就是为什么我们可能有一个市场来交换USD兑换BTC（写作USD/BTC），这意味着人们可以使用美元来购买/出售比特币。其他市场可能是BTC/LTC或LTC/USD（其中LTC代表**莱特币**）。
- en: The number we will be retrieving from wallets is a single number representing
    how much of a specific asset we posses. The number we will be retrieving from
    markets is a ratio representing the price, or how much of one asset is being asked
    for to receive one unit of the other. A BTC/USD ratio of 8,000 means that to receive
    one Bitcoin you're expected to give 8,000 US Dollars (which is the price as this
    paragraph is being written). Similarly, an LTC/BTC of 0.0086 means that you're
    expected to give 0.0086 Bitcoin to receive one Litecoin.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从钱包中检索的数字是一个表示我们拥有特定资产多少的单一数字。我们将从市场中检索的数字是一个表示价格或一个资产被要求以换取另一个单位的价格的比率。一个BTC/USD比率为8,000意味着为了收到一个比特币，你预计要给出8,000美元（这是本段写作时的价格）。同样，一个LTC/BTC比率为0.0086意味着你预计要给出0.0086比特币以换取一个莱特币。
- en: Now that these relations are more or less defined, we will need to bring more
    abstractions into play to write code that will make our system a reality. For
    example, we know that our wallet abstraction will use a similar mechanism to retrieve
    data from different blockchains. This can be encapsulated in a *wallet requester*.
    Furthermore, this wallet requester will be implemented in different ways and must
    be decided at runtime according to the specific wallet we're dealing with. Instead
    of creating a different wallet for each type of asset, and programming the mechanism
    to retrieve data from the blockchain inside each of them, we abstract that and
    create a wallet requester factory that will give our wallet abstraction the specific
    type of wallet requester it needs for the given asset at hand.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些关系或多或少已经定义好了，我们需要引入更多的抽象来编写将使我们的系统成为现实的代码。例如，我们知道我们的钱包抽象将使用类似的机制从不同的区块链中检索数据。这可以封装在*钱包请求者*中。此外，这个钱包请求者将以不同的方式实现，并且必须在运行时根据我们正在处理的特定钱包来决定。我们不需要为每种类型的资产创建不同的钱包，并在每个钱包内部编程从区块链中检索数据的机制，我们将这个机制抽象出来，创建一个钱包请求者工厂，该工厂将为我们的钱包抽象提供所需的特定类型的钱包请求者。
- en: Similarly, our database abstraction may be implemented for various kinds of
    databases, so we separate the interface from the implementation and introduce
    a factory that will choose which specific implementation we will end up using.
    In our case, we will be saving the data to CSV files, but we could just as easily
    be using a MySQL database with what we learned in [Chapter 4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730),
    *Simulating Sales Data and Working with Databases*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们的数据库抽象可以针对各种数据库实现，因此我们将接口与实现分离，并引入一个工厂，该工厂将选择我们最终将使用哪个具体的实现。在我们的案例中，我们将数据保存到CSV文件中，但我们可以同样容易地使用MySQL数据库，就像我们在[第4章](part0091.html#2MP360-f494c932c729429fb734ce52cafce730)，“模拟销售数据和数据库操作”中学到的那样。
- en: In much the same way, our code will retrieve data from **CoinMarketCap** ([www.coinmarketcap.com](http://www.coinmarketcap.com))
    for now, but that may change later. CoinMarketCap is not an exchange, per se;
    rather, it is an aggregator of price data. However, since we may want to work
    with price data from different exchanges in the future (like **Bittrex** or **Bitfinex),**
    we will provide for such abstraction, and since there's no foreseen need to treat
    CoinMarketCap differently from an exchange, we will just include it in that abstraction.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们的代码目前将从**CoinMarketCap**（[www.coinmarketcap.com](http://www.coinmarketcap.com)）检索数据，但以后可能会改变。CoinMarketCap本身不是一个交易所；相反，它是一个价格数据的聚合器。然而，由于我们可能希望在将来与来自不同交易所的价格数据（如**Bittrex**或**Bitfinex**)一起工作，我们将提供这样的抽象，并且由于我们没有预见需要将CoinMarketCap与交易所区别对待，我们将将其包含在那个抽象中。
- en: As a sidenote, the architecture image is not meant to be a UML diagram. **UML**
    stands for **Unified Modeling Language**, a tool commonly used to communicate
    ideas behind object-oriented systems. It's a tool you should definitely learn
    to use if you're planning on doing serious object-oriented programming. Also note
    that we will not implement the objects shown in grey color, namely Bitfinex requester,
    Bittrex requester, MySQL, and Ether requester. Those are left as an exercise for
    the user. Our system will be fully functional without them.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，架构图并不是一个UML图。**UML**代表**统一建模语言**，这是一种常用于传达面向对象系统背后思想的工具。如果你计划进行严肃的面向对象编程，你绝对应该学习如何使用这个工具。此外，请注意，我们不会实现以灰色显示的对象，即Bitfinex请求者、Bittrex请求者、MySQL和Ether请求者。这些将留给用户作为练习。我们的系统将完全功能，即使没有它们。
- en: At this point, it seems that we have a very good idea of the abstractions we
    want to build and the interactions that will occur among these abstractions, so
    it's time to start programming. While we go through the code for the system, we
    will not stop to explain the concepts we have covered before; we will only explain
    functionality that may not be evident.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们似乎已经很好地了解了我们想要构建的抽象以及这些抽象之间将发生的交互，因此是时候开始编程了。当我们遍历系统的代码时，我们不会停下来解释我们之前覆盖的概念；我们只会解释可能不明显的功能。
- en: 'Finally, you should know that each abstraction we implement will go into its
    own file. This is standard practice and helps you quickly find where you need
    to implement or modify some code. There''s a clear and intuitive hierarchy among
    these files. The actual code is organized in the following structure (files end
    with the `.R` extensions and directories end with the `/` symbol):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该知道，我们实现的每个抽象都将进入自己的文件。这是标准做法，有助于你快速找到需要实现或修改代码的位置。这些文件之间有一个清晰直观的层次结构。实际的代码组织结构如下（文件以
    `.R` 扩展名结尾，目录以 `/` 符号结尾）：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Starting simple with timestamps using S3 classes
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 S3 类从简单的时间戳开始
- en: We start by programming a class that has no external dependencies, the `TimeStamp`.
    We will use this class to indicate dates and times together in a single string
    in the format `YYYY-MM-DD-HH-mm`, where `MM` means month and `mm` means minutes.
    As you can see, with one of these strings you have the information time and date,
    and it will be stored with the data we retrieve from time-series for analysis
    in [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730), *Implementing
    an Efficient Simple Moving Average*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个没有外部依赖的类，即 `TimeStamp`。我们将使用此类在单个字符串 `YYYY-MM-DD-HH-mm` 格式中表示日期和时间，其中
    `MM` 表示月份，`mm` 表示分钟。正如你所见，使用这些字符串之一，你就有时间和日期的信息，并且它将与我们从时间序列中检索的数据一起存储，以便在 [第
    9 章](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730)，“实现高效的简单移动平均”中进行分析。
- en: 'Our `TimeStamp` class will be implemented using S3\. As you can see, we include
    the `lubridate` package to do some heavy lifting for us when transforming dates,
    and provide a constructor that checks whether or not the string being passed is
    a valid timestamp:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `TimeStamp` 类将使用 S3 实现。正如你所见，我们包括 `lubridate` 包来为我们处理日期转换的重活，并提供一个构造函数来检查传入的字符串是否是有效的时间戳：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The validation is done by the `valid.TimeStamp()` function, which makes sure
    that only dashes (`-`) and digits are in the string, that the number of numbers
    separated by those dashes is five (year, month, day, hour, and minutes), and that
    the string can be parsed by the `strptime()` function, which is used to create
    date objects from string objects (if it''s not an `NA`, then it could be parsed):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是通过 `valid.TimeStamp()` 函数完成的，该函数确保字符串中只有破折号（`-`）和数字，分隔这些数字的数字数量是五个（年、月、日、小时和分钟），并且该字符串可以被
    `strptime()` 函数解析，该函数用于从字符串对象创建日期对象（如果不是 `NA`，则可以解析）：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also provide a `now.TimeStamp()` function whose responsibility is to create
    a timestamp for the current time and date. It does so by invoking the `Sys.time()`
    function and parsing the resulting object with the format we have specified previously:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个 `now.TimeStamp()` 函数，其职责是创建当前时间和日期的时间戳。它是通过调用 `Sys.time()` 函数并使用我们之前指定的格式解析结果对象来实现的：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we introduce a way to transform native time objects into our own `TimeStamp`
    objects. We simply use the `format()` function as we did before. We also introduce
    a mechanism to transform our own `TimeStamp` objects into native time objects:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍一种将原生时间对象转换为我们的 `TimeStamp` 对象的方法。我们简单地使用之前使用的 `format()` 函数。我们还引入了一种机制，将我们的
    `TimeStamp` 对象转换为原生时间对象：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `subtract.TimeStamp()` function will be important when we retrieve data,
    as we may want all assets that contain a date starting from a previous point in
    time taken from a given `TimeStamp`. The function receives two parameters: the
    current `TimeStamp` and the interval of how much time back we want the resulting
    `TimeStamp` to indicate. Depending on the chosen interval, which can be one hour,
    one day, one week, one month, or one year, indicated by `1h`, `1d`, `1w`, `1m`,
    and `1y`, respectively, we will call different functions from the `lubridate`
    package (`hours()`, `days()`, `weeks()`, `months()`, `years()`), which receive
    how many units of the specified name should be used in the operation. These are
    easy ways to add or subtract time in R.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检索数据时，`subtract.TimeStamp()` 函数将非常重要，因为我们可能希望包含从给定 `TimeStamp` 中取出的先前时间点的所有资产。该函数接收两个参数：当前的
    `TimeStamp` 和我们希望结果 `TimeStamp` 表示的时间间隔。根据选择的间隔，可以是1小时、1天、1周、1个月或1年，分别表示为 `1h`、`1d`、`1w`、`1m`
    和 `1y`，我们将调用 `lubridate` 包中的不同函数（`hours()`、`days()`、`weeks()`、`months()`、`years()`），这些函数接收在操作中应使用多少指定名称的单位。这些是在
    R 中添加或减去时间的一种简单方法。
- en: 'Note that if an unknown interval is passed, we will raise an error. Some people
    think that adding these `else` cases with some kind of error should be avoided,
    since it indicates insecure programming in the sense that you should know what
    options should be passed to the function, and you should never really end up in
    the else branch, and they would rather make sure that their code works by using
    unit-tests instead of checking internally with conditionals. However, we are using
    it to exemplify its usage and because we''re not using unit-tests to prove correctness
    in our code. I''m also of the opinion that you can never be too careful with these
    types of situations, and I''ve found myself in situations where adding that simple
    else branch helped me diagnose a bug much easier:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果传递了一个未知的间隔，我们将引发错误。有些人认为应该避免添加这些带有某种错误类型的 `else` 情况，因为这表明编程不安全，从意义上讲，你应该知道应该传递给函数的选项，你永远不应该真正结束在
    `else` 分支中，他们更愿意通过使用单元测试而不是使用条件检查来确保他们的代码工作。然而，我们使用它来举例说明其用法，因为我们没有使用单元测试来证明代码的正确性。我也认为在这些情况下永远不能过于小心，我发现自己处于添加那个简单的
    `else` 分支有助于我更容易地诊断错误的情况：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we add a convenient `one_year_ago.TimeStamp()` function, which will
    simply produce a current `TimeStamp` and subtract one year from it. This is one
    of those functions that simply evolves as the system is being developed, since
    I noticed I needed that functionality over and over again, so I could just make
    my life a little easier this way:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个方便的 `one_year_ago.TimeStamp()` 函数，它将简单地生成一个当前的 `TimeStamp` 并从中减去一年。这是那些随着系统开发而演化的函数之一，因为我注意到我反复需要这个功能，所以我可以这样让我的生活变得稍微容易一些：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, the class is ready. Feel free to play with it to make sure it works as
    expected. With what you've seen so far in this chapter, you should be able to
    create instances and use the different methods we created. You should also try
    to break it to find its weak spots and possibly improve the implementation's robustness.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类已经准备好了。请随意使用它来确保它按预期工作。根据你在本章中迄今为止所看到的，你应该能够创建实例并使用我们创建的不同方法。你也应该尝试破坏它以找到其弱点，并可能改进实现的健壮性。
- en: Implementing cryptocurrency assets using S4 classes
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 S4 类实现加密货币资产
- en: 'Now, we will implement our next abstraction with the least number of dependencies,
    `Asset`. We will implement it using S4, and it only depends on `TimeStamp`. We
    define its class using the standard methods shown before, and its attributes include
    `email` to identify what user an asset belongs to, a `timestamp` to identify the
    asset at a point in time, a `name` to know what asset we''re dealing with, a `symbol`
    to identify the asset type within our system, a `total` to record how much of
    that asset a user has, and an `address` to identify what wallet the asset belongs
    to (a user may have several wallets for the same type of asset):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用最少的依赖关系实现我们的下一个抽象，`Asset`。我们将使用 S4 来实现它，并且它只依赖于 `TimeStamp`。我们使用之前显示的标准方法定义其类，其属性包括
    `email` 以标识资产属于哪个用户，一个 `timestamp` 以标识资产在某个时间点的情况，一个 `name` 以了解我们正在处理什么资产，一个 `symbol`
    以在我们的系统中标识资产类型，一个 `total` 以记录用户拥有多少该资产，以及一个 `address` 以标识资产属于哪个钱包（用户可能对同一类型的资产有多个钱包）：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that instead of using the S3 class for `TimeStamp` in the `timestamp` attribute,
    we decide to simply declare it as a `character` and manage the translation among
    types ourselves. This allows us to remain in control of this transformation process
    and avoid unexpected R behavior when mixing object models.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们决定在 `timestamp` 属性中使用 S3 类而不是 `TimeStamp`，我们简单地将其声明为 `character` 并自行管理类型之间的转换。这使我们能够保持对这个转换过程的控制，并避免在混合对象模型时出现意外的
    R 语言行为。
- en: 'Next, we provide setter functions to change the `email` and `timestamp` attributes,
    since we will need them when we are retrieving asset data and saving it to disk.
    This is one of those design decisions that evolved as the system was developed,
    and we did not foresee that we would need these methods; they were added at a
    later point in time:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提供了设置函数来更改 `email` 和 `timestamp` 属性，因为我们将在检索资产数据和将其保存到磁盘时需要它们。这是那些随着系统开发而演化的设计决策之一，我们没有预见我们会需要这些方法；它们是在稍后的时间点添加的：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we implement a `dataS4` method that will allow us to retrieve the data
    that needs saving from our S4 objects. Note that we used the same technique as
    was shown before to differentiate `dataS4` methods from `dataS3` methods, and
    avoid any pitfalls with R:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现一个 `dataS4` 方法，这将使我们能够从我们的 S4 对象中检索需要保存的数据。注意，我们使用了之前展示的相同技术来区分 `dataS4`
    方法和 `dataS3` 方法，并避免任何与 R 相关的陷阱：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The implementation of the `AnalysisAsset` will be left for the next chapter,
    where we introduce the types of analysis we're looking to perform with this data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnalysisAsset` 的实现将留到下一章，在那里我们将介绍我们打算用这些数据进行的数据分析类型。'
- en: Implementing our storage layer with R6 classes
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 R6 类实现我们的存储层
- en: Up to this point, our code's complexity was not much more than that shown in
    the examples for the colors, rectangles, and squares. At this point, the code
    will be a bit more complex, since we are dealing with more complex abstractions
    and interactions among them, but we are ready to tackle the challenge with what
    we know so far.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们代码的复杂性并没有比颜色、矩形和正方形的示例复杂多少。到了这一点，代码将变得更加复杂，因为我们正在处理更复杂的抽象及其之间的交互，但我们已经准备好用我们目前所知道的知识来应对这个挑战。
- en: Communicating available behavior with a database interface
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库接口进行可用行为的通信
- en: We will start by defining the interface for databases in the `Database` class.
    This class is never intended to be instantiated itself. Its purpose is to simply
    provide an interface definition that must be respected by specific database implementations,
    like the `CSVFiles` implementation we will develop, and by the `Storage` implementation,
    to communicate with any database. The advantage of defining an interface such
    as this is that it provides a common language for these objects to talk to each
    other, and provides a reference for the programmer of what should be done and
    how methods should be named so that they work out of the box with the rest of
    the system. In Python, they would be called Abstract Base Classes. R has no formal
    usage for these abstract classes, but we can nevertheless implement them this
    way ourselves.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在 `Database` 类中定义数据库的接口。这个类本身永远不会被实例化。它的目的是简单地提供一个接口定义，这个定义必须被特定的数据库实现所遵守，例如我们将开发的
    `CSVFiles` 实现，以及 `Storage` 实现，以便与任何数据库进行通信。定义此类接口的优势是它为这些对象之间提供了一种共同的语言，并为程序员提供了一个参考，说明了应该做什么以及方法应该如何命名，以便它们能够与系统中的其他部分无缝工作。在
    Python 中，它们会被称为抽象基类。R 没有对这些抽象类的正式用法，但我们可以以这种方式自行实现它们。
- en: As you can see, our R6 `Database` interface specifies what methods should be
    publicly implemented and the fact that the table names used for the database should
    be kept private. We're adding this `table_names` list attribute instead of hardcoding
    the table names directly in our classes because we want to be able to easily change
    them in a settings file (more on this later) and we want to easily change them
    for the different environments we will be using this code under (mainly production
    and development environments).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 R6 `Database` 接口指定了应该公开实现哪些方法，以及用于数据库的表名应该保持私有。我们添加这个 `table_names`
    列属性，而不是直接在我们的类中硬编码表名，因为我们希望能够在设置文件中轻松地更改它们（关于这一点稍后讨论），并且我们希望能够轻松地为我们将要使用此代码的不同环境（主要是生产环境和开发环境）更改它们。
- en: The public methods are the getter and setter for the `table_names`, and the
    groups of methods used for reading and writing data, which contain a prefix stating
    what they are used for. It should be evident what they expect and what they return.
    Specifically, the `read_exchanges()` method does not receive any parameters and
    should return a list of `Exchange` objects (which will be defined later). The
    `read_users()` returns a list of `User` objects (which will also be defined later),
    and needs an instance of `Storage` that will be assigned to each user created
    so that they can read and write data. The `read_wallets()` method receives an
    email string and returns a list of `Wallet` objects (also to be defined later).
    The `read_all_wallets()` method is meant to be used only by `admins` of the system,
    and will return all the wallets in the system in a list, not only the wallets
    that belong to a specific user.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 公共方法包括`table_names`的获取器和设置器，以及用于读取和写入数据的方法组，这些方法包含一个前缀，说明它们的使用目的。它们期望什么和返回什么应该是显而易见的。具体来说，`read_exchanges()`方法不接收任何参数，应返回一个`Exchange`对象列表（稍后定义）。`read_users()`返回一个`User`对象列表（也将稍后定义），并需要一个`Storage`实例，该实例将被分配给每个创建的用户，以便他们可以读取和写入数据。`read_wallets()`方法接收一个电子邮件字符串，并返回一个`Wallet`对象列表（也将稍后定义）。`read_all_wallets()`方法仅适用于系统的`admins`，并将返回系统中的所有钱包列表，而不仅仅是属于特定用户的钱包。
- en: 'On the write side, the `write_user()` method receives a `User` object and writes
    it to disk, and as you can see by the `{}` symbols, it''s not expected to return
    anything. Similarly, the other write methods receive an instance of a class and
    save it to disk. We need one write method for each type of class because they
    will need different treatments when being saved:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入方面，`write_user()`方法接收一个`User`对象并将其写入磁盘，如您通过`{}`符号所看到的，它不期望返回任何内容。类似地，其他写入方法接收一个类的实例并将其保存到磁盘。我们需要为每种类型的类提供一个写入方法，因为它们在保存时需要不同的处理：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Implementing a database-like storage system with CSV files
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSV文件实现类似数据库的存储系统
- en: Now that we have our `Database` interface defined, we will implement a database-like
    system that uses CSV files to store the information instead of an actual database.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`Database`接口，我们将实现一个类似数据库的系统，该系统使用CSV文件来存储信息，而不是实际的数据库。
- en: First, we make sure we bring the `CSVFiles` class dependencies by using the
    `source()` function to bring files that have the definitions we need. Specifically,
    we bring the `Exchange` and `User` classes (which will be defined later), as well
    as the `Database` interface. We also define the `DIR` constant with the directory
    that will contain the CSV files with our system's data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保通过使用`source()`函数引入`CSVFiles`类的依赖项，以引入包含所需定义的文件。具体来说，我们引入了`Exchange`和`User`类（稍后定义），以及`Database`接口。我们还定义了`DIR`常量，它将包含包含我们系统数据的CSV文件的目录。
- en: The actual `CSVFiles` class is defined using the standard R6 methods shown before.
    Note that it inherits from the `Database` class and provides overrides for every
    method in the `Database` interface, as it should. Also note that inside the constructor,
    that is, the `initialize` function, we are calling the `initialize_csv_files()`
    function and sending it the `table_names` list we receive during initialization.
    More on this ahead.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的`CSVFiles`类使用前面显示的标准R6方法定义。请注意，它继承自`Database`类，并为`Database`接口中的每个方法提供了覆盖，正如它应该做的那样。另外请注意，在构造函数中，即`initialize`函数内部，我们正在调用`initialize_csv_files()`函数，并传递在初始化期间接收到的`table_names`列表。关于这一点，稍后会有更多说明。
- en: 'Since we wanted the reader to get a look at the full class definition in a
    single piece of code instead of piece-by-piece, we include all of it here, and
    explain it in the following paragraphs. It''s a bit long since it contains the
    logic for all the methods in the `Database` interface, but at a high level, it''s
    nothing more than implementation for said interface:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望读者能够一次性查看完整的类定义，而不是逐部分查看，所以我们在这里包含了所有内容，并在接下来的段落中解释它。由于它包含了`Database`接口中所有方法的逻辑，所以它有点长，但从高层次来看，它不过是该接口的实现：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we will briefly explain the mechanics behind each method implementation.
    Let''s start with `read_exchanges()`. In theory, this method should look inside
    the stored data and get a list of the exchanges registered in the system, create
    an instance for each of them, and send that back. In practice, however, it''s
    not necessary, as just hardcoding the CoinMarketCap exchange is sufficient for
    our purposes. As you can see, that''s all the method does: return a list with
    a single `Exchange` inside, which is the one for CoinMarketCap.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简要解释每个方法实现背后的机制。让我们从 `read_exchanges()` 开始。从理论上讲，这个方法应该在存储的数据中查找，获取系统中注册的交易所列表，为每个交易所创建一个实例，并将其发送回去。然而，在实践中，这并不必要，因为直接硬编码
    CoinMarketCap 交易所就足够我们使用了。正如你所见，这就是该方法所做的一切：返回一个包含单个 `Exchange` 的列表，这就是 CoinMarketCap
    的那个。
- en: The `read_users()` method reads the data from the `"user"` file with the private
    method `read_csv()` defined below, and returns a list built with the `lapply()`
    function that takes every email in the data and sends it through the `user_constructor()`,
    along with a `storage` object received as a parameter to create `User` instances
    that are then sent back as a result of the method call. If you don't remember
    how the `lapply()` function works, take a look at [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_users()` 方法使用下面定义的私有方法 `read_csv()` 从 `"user"` 文件中读取数据，并返回一个列表，该列表是通过
    `lapply()` 函数构建的，该函数将数据中的每个电子邮件发送到 `user_constructor()`，同时接收一个作为参数的 `storage`
    对象来创建 `User` 实例，然后作为方法调用的结果发送回去。如果你不记得 `lapply()` 函数是如何工作的，请查看 [第 1 章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)，*R
    语言入门*。'
- en: The `read_wallets()` method is a bit more complex. It receives an `email` as
    a parameter, reads the `"wallets"` file, and creates a list of `Wallet` instances.
    Since we're doing a check to see whether a specific observation in the data contains
    an `email` equal the one requested, we can simply use the `lapply()` function
    (we could, if we create a separate function that contains this, check, but we
    decide not to go that route). Also note that the function will only try to iterate
    over the row in the dataframe if the dataframe contains at least one row. This
    check was introduced after we found that when not having it when we had empty
    files, we were getting an error, since the for loop was actually being executed
    even if there were no rows. If the `email` is found to be the same as the one
    requested, then we append a new `Wallet` instance to the `wallets` list and return
    it. If there are no wallets to be created, the `wallets` object is coerced into
    an empty list. The `read_all_wallets()` method works in the same way but omits
    the `email` check.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_wallets()` 方法稍微复杂一些。它接收一个 `email` 作为参数，读取 `"wallets"` 文件，并创建一个 `Wallet`
    实例的列表。由于我们需要检查数据中的特定观察结果是否包含一个与请求相同的 `email`，我们可以简单地使用 `lapply()` 函数（如果我们创建一个包含此检查的单独函数，也可以进行检查，但我们决定不采取那条路线）。此外，请注意，如果数据框至少包含一行，函数将只尝试遍历数据框中的行。这个检查是在我们发现，在没有它的情况下，当我们处理空文件时，我们遇到了错误，因为即使没有行，for
    循环实际上也在执行。如果发现 `email` 与请求的相同，则将一个新的 `Wallet` 实例追加到 `wallets` 列表中并返回它。如果没有要创建的钱包，则
    `wallets` 对象被强制转换为空列表。`read_all_wallets()` 方法以相同的方式工作，但省略了 `email` 检查。'
- en: The `write_user()` method receives a `User` instance, reads the `data` for the
    `"users"` file, creates a dataframe with the data extracted with the `dataS3`
    method call from the `User` object, prints it to the console for informational
    purposes, and, if it's not found to already exist in the current data, it's added
    to it. Finally, the data is saved back into the `"users"` file. The actual check
    is performed by the private method `user_does_not_exist()`, which simply checks
    that the `User` email is not contained in the `email` column in the data, as you
    can see in its definition mentioned ahead.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_user()` 方法接收一个 `User` 实例，读取 `"users"` 文件的 `data`，使用从 `User` 对象中调用 `dataS3`
    方法提取的数据创建一个数据框，为了信息目的将其打印到控制台，并且如果它被发现当前数据中不存在，则将其添加进去。最后，数据被保存回 `"users"` 文件。实际的检查是通过前面提到的私有方法
    `user_does_not_exist()` 执行的，该方法简单地检查 `User` 的电子邮件是否不包含在数据中的 `email` 列中，正如你在其定义中可以看到的那样。'
- en: The `write_wallets()` method receives a list of `Wallet` instances, reads the
    `"wallets"` file, and for each `wallet` not found to already exist in the data,
    adds it. It's conceptually similar to the `write_user()` method, and the check
    is performed by the private `wallet_does_not_exist()` method, which receives a
    `Wallet` instance and uses its contained `email` and `symbol` to get the `addresses`
    which are already associated to such combinations (recall that a single user may
    have multiple wallets for the same type of asset, and they would only be differentiated
    by their wallet addresses). If the `address` in the `Wallet` instance is found
    to already exist in such a subset, then it's not added.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_wallets()`方法接收一个`Wallet`实例列表，读取`"wallets"`文件，并为每个未在数据中找到已存在的`wallet`添加它。从概念上讲，它与`write_user()`方法类似，检查是通过私有的`wallet_does_not_exist()`方法进行的，该方法接收一个`Wallet`实例并使用其包含的`email`和`symbol`来获取已与这种组合关联的`addresses`。如果`Wallet`实例中的`address`被发现已存在于这样的子集中，则不会添加。'
- en: The `write_assets()` and `write_markets()` methods are similar and should be
    easily understood. The difference is that they do not contain any checks for now,
    and that they are saving S4 and R6 objects, respectively. You can tell that by
    the fact that they call the `dataS4()` method and the syntax to get the `Market`
    data, being `market$data()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_assets()`和`write_markets()`方法类似，应该容易理解。不同之处在于它们目前不包含任何检查，并且分别保存S4和R6对象。你可以通过它们调用`dataS4()`方法和获取`Market`数据的语法来识别这一点，即`market$data()`。'
- en: The private methods used to read and write the CSV files should be easy to understand.
    Just keep in mind that the actual filenames are coming from the `file()` private
    method, which uses the `table_names` contained in the superclass (`Database`)
    by calling the `super$get_table_names()` getter and retrieving the corresponding
    filename associated for a given `table_name`. The `table_name` list will later
    be defined in the centralized settings file, but is simply a list that contains
    a string for each table name (in the case of `CSVFiles`, a file name) associated
    to each type of object that needs to be stored.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 用于读取和写入CSV文件的私有方法应该容易理解。只需记住，实际的文件名来自`file()`私有方法，该方法通过调用超类（`Database`）的`super$get_table_names()`获取器并检索与给定`table_name`关联的文件名来使用包含在超类中的`table_names`。`table_name`列表将在集中设置的文件中定义，但它只是一个包含每个表名（在`CSVFiles`的情况下是文件名）的字符串的列表，这些表名与需要存储的每种对象类型相关联。
- en: 'Now, we proceed to discussing the `initialize_csv_files()` function. This function
    receives the `table_names` list and makes sure that the `DIR` directory exists
    with the `dir.create()` function. The `showWarnings = FALSE` parameter is to avoid
    warnings when the directory already exists in disk. Then, for each element in
    the `table_names` list, it will create the corresponding `filename` and see whether
    it exists on disk with the `file.exists()` function. If it does not, it will proceed
    to create an empty dataframe of the corresponding type and save it to disk:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们继续讨论`initialize_csv_files()`函数。这个函数接收`table_names`列表，并使用`dir.create()`函数确保`DIR`目录存在。`showWarnings
    = FALSE`参数是为了避免当目录已在磁盘上存在时产生警告。然后，对于`table_names`列表中的每个元素，它将创建相应的`filename`，并使用`file.exists()`函数检查它是否在磁盘上存在。如果不存在，它将创建一个对应类型的空数据框并将其保存到磁盘上：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The different types of empty dataframes are chosen with the `empty_dataframe()`
    function, which receives a specific table name in the `table` parameter and returns
    the corresponding empty dataframe. Note that the checks assume that the words
    for the different objects that need to be saved are within the table names defined
    in the centralized settings file and that the names of two different abstractions
    do no appear together in a single table name:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`empty_dataframe()`函数选择不同类型的空数据框，该函数接收`table`参数中的特定表名并返回相应的空数据框。请注意，检查假设需要保存的不同对象的单词位于集中设置的文件中定义的表名内，并且两个不同的抽象的名称不会在单个表名中同时出现：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The actual empty dataframes are created by the `empty_assets()`, `empty_markets()`,
    `empty_users()`, and `empty_wallets()` functions. Each of these contains a specification
    for the data expected to be within such files. Specifically, each observation
    in the asset''s data is expected to have an email, timestamp, name, symbol, total,
    and address. Each observation in the markets data is expected to have a timestamp,
    name, symbol, rank, price in BTC, and price in USD. The rank is a cryptocurrencies
    ordering based on the amount of volume transacted in the last 24 hours. The users
    data is only expected to contain emails. Finally, the wallets data is expected
    to have an email, symbol, address, and note. The note is a note that the user
    may specify to recognize different wallets from each other, specifically if they
    are being used for the same type of cryptocurrency. Maybe one Bitcoin wallet is
    for long-term and one for short-term; then that information could be specified
    in the note field. Note that you can identify the relations among these data schemes
    with the concepts introduced in [Chapter 4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730),
    *Simulating Sales Data and Working with Databases*. Let''s look at the following
    code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的空数据框是由`empty_assets()`、`empty_markets()`、`empty_users()`和`empty_wallets()`函数创建的。每个函数都包含了对这些文件中预期数据的规范。具体来说，资产数据中的每个观察值都应有一个电子邮件、时间戳、名称、符号、总数和地址。市场数据中的每个观察值应有一个时间戳、名称、符号、排名、BTC价格和USD价格。排名是基于过去24小时内交易量的加密货币排序。用户数据只应包含电子邮件。最后，钱包数据应包含电子邮件、符号、地址和备注。备注是用户可能指定的备注，用于区分不同的钱包，特别是如果它们被用于同一种类型的加密货币。也许一个比特币钱包是用于长期存储，另一个是用于短期存储；那么这些信息可以在备注字段中指定。注意，您可以使用第4章中介绍的概念来识别这些数据方案之间的关系，*模拟销售数据和与数据库协同工作*。让我们看看以下代码：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Easily allowing new database integration with a factory
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过工厂轻松实现新的数据库集成
- en: We know at this point that we will only use the `CSVFiles Database` implementation
    for this example, but we can easily imagine cases where new database implementations
    come into play. For example, the reader will create an implementation of the MySQL
    database, and will want it to substitute the `CSVFiles` implementation. Isn't
    that right? When you expect some change in the future where you will likely need
    to switch one interface implementation for another, factories is a great tool
    to facilitate that change for yourself in the future.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们知道我们只会使用`CSVFiles 数据库`实现来演示这个例子，但我们可以轻松想象出新的数据库实现将如何发挥作用。例如，读者将创建MySQL数据库的实现，并希望它能够替代`CSVFiles`实现。不是吗？当你预期未来可能需要切换一个接口实现到另一个时，工厂是一个很好的工具，可以帮助你在未来方便地实现这种变化。
- en: 'Our `database_factory()` function receives a `db_setup` and `table_names` objects,
    both of which will come from our centralized settings file. It then takes the
    appropriate set of table names, depending on the environment for the database,
    and looks into the `db_setup` provided to find what kind of `Database` implementation
    it needs to instantiate. Since we only have one at this point, the only possibility
    will be a `CSVFiles` implementation, and if we pass any other string, then an
    error should be raised, as it is. The `Database` implementation actually instantiated
    should receive a `table_names` object and configure itself accordingly:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`database_factory()`函数接收一个`db_setup`和`table_names`对象，这两个对象都将来自我们的集中设置文件。然后它根据数据库的环境选择适当的表名集，并在提供的`db_setup`中查找需要实例化的`Database`实现类型。由于目前我们只有一个，唯一可能的选择将是`CSVFiles`实现，如果我们传递任何其他字符串，那么应该抛出一个错误，正如它所做的那样。实际实例化的`Database`实现应该接收一个`table_names`对象并相应地配置自己：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, a factory is nothing more than an `if` statement which decides
    what implementation should be instantiated and returned to the calling object.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，工厂不过是一个`if`语句，它决定应该实例化并返回给调用对象的哪种实现。
- en: Encapsulating multiple databases with a storage layer
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存储层封装多个数据库
- en: Now that we have developed our `Database` interface and our `CSVFiles` implementation
    of such an interface, we are ready to develop the next layer of abstraction, our
    `Storage` class. It will be implemented with R6.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开发出了我们的`数据库`接口以及该接口的`CSVFiles`实现，我们准备开发下一层的抽象，即我们的`Storage`类。它将使用R6来实现。
- en: As you can see, the `Storage` constructor implemented in the `initialize` function
    receives a `settings` object which will be the full centralized settings file
    we have been mentioning and will use the `storage/read`, `storage/write`, and
    `storage/table_names` parts to create various database instances through the use
    of the `database_factory()` function we explained before. In the case of the `read_db`
    attribute, it will be a single `Database` implementation that will be used to
    read data. In the case of the `write_dbs` attribute, as the name implies, we will
    have a list of `Database` implementations where each data that is asked to be
    saved by other objects will be stored.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Storage` 构造函数在 `initialize` 函数中实现，它接收一个 `settings` 对象，这将是我们一直在提到的完整集中式设置文件，并将使用
    `storage/read`、`storage/write` 和 `storage/table_names` 部分通过之前解释的 `database_factory()`
    函数创建各种数据库实例。在 `read_db` 属性的情况下，它将是一个用于读取数据的单个 `Database` 实现。在 `write_dbs` 属性的情况下，正如其名称所暗示的，我们将有一个
    `Database` 实现的列表，其中每个其他对象请求保存的数据都将被存储。
- en: 'With this `Storage` abstraction, we can simply send it to objects looking for
    a database-like object to save and read data from, and it will take care of replicating
    data as necessary for us, as well as providing data to said objects. To accomplish
    this, you can ask that in the case of the read methods, it simply delegate the
    task to the `Database` implementation contained in its `read_db` attribute, and
    in the case of the write methods, it does the same thing for each `Database` implementation
    in its `write_dbs` attribute. It''s as simple as that:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个 `Storage` 抽象，我们可以简单地将其发送给寻找类似数据库对象以保存和读取数据的对象，并且它会根据需要为我们复制数据，同时为这些对象提供数据。为了实现这一点，你可以要求在读取方法的情况下，它只需将任务委托给其
    `read_db` 属性中包含的 `Database` 实现即可，而在写入方法的情况下，它对其 `write_dbs` 属性中的每个 `Database`
    实现都做同样的事情。就这么简单：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That's it for our storage abstractions. At this point, we have implemented a
    `Database` interface, a `CSVFiles` implementation of said interface, and a `Storage`
    layer that permits the use of multiple `Database` implementations simultaneously
    and decouples the read and write objects for us. We could choose to use one type
    of database for read operations and another one for write operations, and have
    some kind of external mechanism to sync them together outside of R. This could
    be handy for performance reasons, for example.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的存储抽象的全部内容。到目前为止，我们已经实现了一个 `Database` 接口，一个 `CSVFiles` 接口实现，以及一个 `Storage`
    层，它允许我们同时使用多个 `Database` 实现并为我们解耦读取和写入对象。我们可以选择为读取操作使用一种类型的数据库，为写入操作使用另一种类型的数据库，并有一种外部机制在
    R 外部将它们同步起来。这可能在性能方面很有用，例如。
- en: Retrieving live data for markets and wallets with R6 classes
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 R6 类检索市场和钱包的实时数据
- en: This section will explain how to create a simple requester, which is an object
    that requests external information (from an API over the internet in this case). We
    will also develop our exchange and wallet infrastructure.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释如何创建一个简单的请求者，这是一个请求外部信息（在这种情况下是通过互联网上的 API）的对象。我们还将开发我们的交易所和钱包基础设施。
- en: Creating a very simple requester to isolate API calls
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个非常简单的请求者以隔离 API 调用
- en: Now, we will focus on how we actually retrieve live data. This functionality
    will also be implemented using R6 classes, as the interactions can be complex.
    First of all, we create a simple `Requester` class that contains the logic to
    retrieve data from JSON APIs found elsewhere in the internet and that will be
    used to get our live cryptocurrency data for wallets and markets. We don't want
    logic that interacts with external APIs spread all over our classes, so we centralize
    it here to manage it as more specialized needs come into play later.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将关注我们如何实际检索实时数据。此功能也将使用 R6 类来实现，因为交互可能很复杂。首先，我们创建一个简单的 `Requester` 类，该类包含从互联网其他地方找到的
    JSON API 获取数据的逻辑，并将用于获取钱包和市场的实时加密货币数据。我们不希望逻辑与外部 API 交互散布在我们的类中，因此我们将其集中在这里，以便在以后出现更专业化的需求时进行管理。
- en: As you can see, all this object does is offer the public `request()` method,
    and all it does is use the `formJSON()` function from the `jsonlite` package to
    call a `URL` that is being passed to it and send the data it got back to the user.
    Specifically, it sends it as a dataframe when the data received from the external
    API can be coerced into dataframe-form.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个对象所做的一切就是提供一个公共的 `request()` 方法，它所做的一切就是使用 `jsonlite` 包中的 `formJSON()`
    函数调用传递给它的 `URL`，并将获取的数据发送回用户。具体来说，当从外部API接收到的数据可以被强制转换为数据框格式时，它会将其作为数据框发送。
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Developing our exchanges infrastructure
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的交易所基础设施
- en: 'Our exchanges have multiple markets inside, and that''s the abstraction we
    will define now. A `Market` has various private attributes, as we saw before when
    we defined what data is expected from each file, and that''s the same data we
    see in our constructor. It also offers a `data()` method to send back a list with
    the data that should be saved to a database. Finally, it provides setters and
    getters as required. Note that the setter for the price depends on what units
    are requested, which can be either `usd` or `btc`, to get a market''s asset price
    in terms of US Dollars or Bitcoin, respectively:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交易所内部有多个市场，这就是我们现在要定义的抽象。`Market` 有各种私有属性，正如我们在定义每个文件期望的数据时所见，这就是我们在构造函数中看到的数据。它还提供了一个
    `data()` 方法，用于返回一个列表，其中包含应保存到数据库中的数据。最后，它提供了所需的设置器和获取器。请注意，价格设置器取决于请求的单位，可以是 `usd`
    或 `btc`，以分别获取以美元或比特币计价的市场资产价格：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that we have our `Market` definition, we proceed to create our `Exchange`
    definition. This class will receive an exchange name as `name` and will use the
    `exchange_requester_factory()` function to get an instance of the corresponding
    `ExchangeRequester`. It also offers an `update_markets()` method that will be
    used to retrieve market data with the private `markets()` method and store it
    to disk using the `timestamp` and `storage` objects being passed to it. Note that
    instead of passing the `timestamp` through the arguments for the private `markets()`
    method, it's saved as a class attribute and used within the private `insert_metadata()`
    method. This technique provides cleaner code, since the `timestamp` does not need
    to be passed through each function and can be retrieved when necessary.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 `Market` 定义，我们继续创建 `Exchange` 定义。这个类将接收一个交易所名称作为 `name`，并使用 `exchange_requester_factory()`
    函数获取相应 `ExchangeRequester` 的实例。它还提供了一个 `update_markets()` 方法，该方法将用于通过私有的 `markets()`
    方法检索市场数据，并使用传递给它的 `timestamp` 和 `storage` 对象将其存储到磁盘上。请注意，与通过私有 `markets()` 方法的参数传递
    `timestamp` 不同，它被保存为类属性，并在私有的 `insert_metadata()` 方法中使用。这种技术提供了更干净的代码，因为 `timestamp`
    不需要通过每个函数传递，并在需要时检索。
- en: 'The private `markets()` method calls the public `markets()` method in the `ExchangeRequester`
    instance saved in the private `requester` attribute (which was assigned to by
    the factory) and applies the private `insert_metadata()` method to update the
    `timestamp` for such objects with the one sent to the public `update_markets()`
    method call before sending them to be written to the database:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的 `markets()` 方法在 `ExchangeRequester` 实例中调用公共的 `markets()` 方法（该实例存储在私有的 `requester`
    属性中，由工厂分配），并在将它们写入数据库之前，应用私有的 `insert_metadata()` 方法来更新这些对象的 `timestamp`，以匹配之前发送给公共
    `update_markets()` 方法调用的那个：
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we need to provide a definition for our `ExchangeRequester` implementations.
    As in the case of the `Database`, this `ExchangeRequester` will act as an interface
    definition that will be implemented by the `CoinMarketCapRequester`. We see that
    the `ExchangeRequester` specifies that all exchange requester instances should
    provide a public `markets()` method, and that a list is expected from such a method.
    From context, we know that this list should contain `Market` instances. Also,
    each `ExchangeRequester` implementation will contain a `Requester` object by default,
    since it''s being created and assigned to the `requester` private attribute upon
    class instantiation. Finally, each implementation will also have to provide a
    `create_market()` private method and will be able to use the `request()` private
    method to communicate to the `Requester` method `request()` we defined previously:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的 `ExchangeRequester` 实现提供一个定义。正如在 `Database` 的情况下，这个 `ExchangeRequester`
    将充当接口定义，将由 `CoinMarketCapRequester` 实现。我们看到 `ExchangeRequester` 指定所有交易所请求实例都应该提供一个公共的
    `markets()` 方法，并且该方法应返回一个列表。从上下文来看，我们知道这个列表应包含 `Market` 实例。此外，每个 `ExchangeRequester`
    实现默认将包含一个 `Requester` 对象，因为它在类实例化时创建并分配给 `requester` 私有属性。最后，每个实现还必须提供一个 `create_market()`
    私有方法，并且可以使用我们之前定义的 `request()` 私有方法与 `Requester` 的 `request()` 方法进行通信：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now we proceed to provide an implementation for `CoinMarketCapRequester`. As
    you can see, it inherits from `ExchangeRequester`, and it provides the required
    method implementations. Specifically, the `markets()` public method calls the
    private `request()` method from `ExchangeRequester`, which in turn calls the `request()`
    method from `Requester`, as we have seen, to retrieve data from the private `URL`
    specified.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续为 `CoinMarketCapRequester` 提供一个实现。如您所见，它继承自 `ExchangeRequester`，并提供了所需的方法实现。具体来说，`markets()`
    公共方法调用 `ExchangeRequester` 中的私有 `request()` 方法，后者又调用我们之前看到的 `Requester` 的 `request()`
    方法，以从指定的私有 `URL` 获取数据。
- en: 'If you request data from CoinMarketCap''s API by opening a web browser and
    navigating to the URL shown ([https://api.coinmarketcap.com/v1/ticker](https://api.coinmarketcap.com/v1/ticker)),
    you will get a list of market data. That is the data that will be received in
    our `CoinMarketCapRequester` instance in the form of a dataframe, thanks to the
    `Requester` object, and will be transformed into numeric data where appropriate
    using the private `clean()` method, so that it''s later used to create `Market`
    instances with the `apply()` function call, which in turn calls the `create_market()`
    private method. Note that the `timestamp` is set to `NULL` for all markets created
    this way because, as you may remember from our `Exchange` class, it''s set before
    writing it to the database. There''s no need to send the `timestamp` information
    all the way down to the `CoinMarketCapRequester`, since we can simply write at
    the `Exchange` level right before we send the data to the database:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过打开网页并导航到显示的 URL（[https://api.coinmarketcap.com/v1/ticker](https://api.coinmarketcap.com/v1/ticker)）来从
    CoinMarketCap 的 API 请求数据，您将获得一系列市场数据。这些数据将以数据框的形式接收，存储在我们的 `CoinMarketCapRequester`
    实例中，归功于 `Requester` 对象，并且将使用私有的 `clean()` 方法进行适当的转换，以便稍后使用 `apply()` 函数调用创建 `Market`
    实例。请注意，由于您可能还记得我们的 `Exchange` 类，所有以这种方式创建的市场 `timestamp` 都被设置为 `NULL`，因为它在写入数据库之前被设置。没有必要将
    `timestamp` 信息发送到 `CoinMarketCapRequester`，因为我们可以在将数据发送到数据库之前直接在 `Exchange` 层级上写入：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, here''s the code for our `exchange_requester_factory().` As you can
    see, it''s basically the same idea we have used for our other factories, and its
    purpose is to easily let us add more implementations for our `ExchangeRequeseter`
    by simply adding *else-if* statements in it:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们的 `exchange_requester_factory()` 的代码。如您所见，它与我们在其他工厂中使用的想法基本相同，其目的是通过在其中添加
    *else-if* 语句来轻松地让我们为我们的 `ExchangeRequeseter` 添加更多实现：
- en: '[PRE59]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Developing our wallets infrastructure
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的钱包基础设施
- en: Now that we are able to retrieve live price data from exchanges, we turn to
    our `Wallet` definition. As you can see, it specifies the type of private attributes
    we expect for the data that it needs to handle, as well as the public `data()`
    method to create the list of data that needs to be saved to a database at some
    point.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够从交易所检索实时价格数据后，我们转向我们的 `Wallet` 定义。如您所见，它指定了我们期望用于处理所需数据的私有属性类型，以及公共的 `data()`
    方法，用于创建需要在某个时候保存到数据库中的数据列表。
- en: 'It also provides getters for `email`, `symbol`, and `address`, and the public
    `pudate_assets()` method, which will be used to get and save assets into the database,
    just as we did in the case of `Exchange`. As a matter of fact, the techniques
    followed are exactly the same, so we won''t explain them again:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了 `email`、`symbol` 和 `address` 的获取器，以及公共的 `pudate_assets()` 方法，该方法将用于将资产获取并保存到数据库中，就像我们在
    `Exchange` 的情况下所做的那样。事实上，遵循的技术是完全相同的，所以我们不会再次解释：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Implementing our wallet requesters
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的钱包请求器
- en: 'The `WalletRequester` will be conceptually similar to the `ExchangeRequester`.
    It will be an interface, and will be implemented in our `BTCRequester` and `LTCRequester`
    interfaces. As you can see, it requires a public method called `assets()` to be
    implemented and to return a list of `Asset` instances. It also requires a private
    `create_asset()` method to be implemented, which should return individual `Asset`
    instances, and a private `url` method that will build the URL required for the
    API call. It offers a `request()` private method that will be used by implementations
    to retrieve data from external APIs:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`WalletRequester` 在概念上将与 `ExchangeRequester` 相似。它将是一个接口，并将在我们 `BTCRequester`
    和 `LTCRequester` 接口中实现。正如你所看到的，它需要一个名为 `assets()` 的公共方法来实现，并返回一个 `Asset` 实例的列表。它还需要实现一个私有的
    `create_asset()` 方法，该方法应返回单个 `Asset` 实例，以及一个私有的 `url` 方法，它将构建 API 调用所需的 URL。它提供了一个
    `request()` 私有方法，该方法将由实现用于从外部 API 获取数据：'
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `BTCRequester` and `LTCRequester` implementations are shown below for completeness,
    but will not be explained. If you have followed everything so far, they should
    be easy to understand:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了 `BTCRequester` 和 `LTCRequester` 的实现，以示完整性，但不会进行解释。如果你已经跟随了前面的内容，它们应该很容易理解：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `wallet_requester_factory()` works just as the other factories; the only
    difference is that in this case, we have two possible implementations that can
    be returned, which can be seen in the `if` statement. If we decided to add a `WalletRequester`
    for another cryptocurrency, such as Ether, we could simply add the corresponding
    branch here, and it should work fine:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`wallet_requester_factory()` 与其他工厂的工作方式相同；唯一的区别是，在这种情况下，我们有两种可能的实现可以返回，这可以在
    `if` 语句中看到。如果我们决定为另一种加密货币，如以太坊，添加一个 `WalletRequester`，我们只需简单地在这里添加相应的分支，它应该可以正常工作：'
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finally introducing users with S3 classes
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后介绍使用 S3 类的用户
- en: Our object-oriented system is almost finalized. We're only missing the `User`
    definition. In this case, we will use S3 to define the `User` class. The `user_constructor()`
    function takes an `email` and a `Storage` instance in `storage` to create a `User`
    instance. However, before it does, it checks that the email is valid with the
    `valid_email()` function defined below. After the user has been created, the `get_wallets()`
    method is called upon it to get the wallets associated to the user before it's
    sent back.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面向对象系统几乎已经完成。我们唯一缺少的是 `User` 定义。在这种情况下，我们将使用 S3 来定义 `User` 类。`user_constructor()`
    函数接受一个 `email` 和一个在 `storage` 中的 `Storage` 实例来创建一个 `User` 实例。然而，在它这样做之前，它会使用下面定义的
    `valid_email()` 函数检查电子邮件是否有效。在用户创建后，将调用 `get_wallets()` 方法来获取与用户关联的钱包，然后再将其发送回去。
- en: 'The `valid_email()` function simply receives a string which is supposed to
    be an email address, and checks whether at least one `@` and one `.` symbol are
    contained within it. Of course, this is not a robust mechanism to check whether
    or not it''s an email address, and it''s put here just to illustrate how a checking
    mechanism could be implemented:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`valid_email()` 函数简单地接收一个字符串，该字符串应是一个电子邮件地址，并检查其中是否至少包含一个 `@` 和一个 `.` 符号。当然，这不是一个健壮的机制来检查它是否是一个电子邮件地址，它只是用来说明如何实现检查机制：'
- en: '[PRE64]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `get_wallets.User()` function simply asks the `storage` attribute in the
    object to get the wallets associated to its own email address, assigns them to
    the `wallets` list attribute, and sends the `User` object back:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_wallets.User()` 函数简单地请求对象中的 `storage` 属性以获取与其电子邮件地址关联的钱包，将它们分配给 `wallets`
    列表属性，并将 `User` 对象返回：'
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `new_wallet.User()` function receives a `User` instance, a `symbol` string,
    an `address` string, and `note` string to create a new `Wallet` instance and append
    it to the `wallets` list attribute for the `User` instance passed to it. However,
    before it does, it checks in all previous registered wallets for the user. If
    it finds that a wallet is already registered, it simply ignores the addition and
    sends the same `User` instance back. This is another type of checking that you
    may implement in your own systems:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_wallet.User()` 函数接收一个 `User` 实例、一个 `symbol` 字符串、一个 `address` 字符串和一个 `note`
    字符串，以创建一个新的 `Wallet` 实例并将其附加到传递给它的 `User` 实例的 `wallets` 列表属性中。然而，在它这样做之前，它会检查所有之前注册的用户钱包。如果它发现一个钱包已经注册，它将简单地忽略添加并返回相同的
    `User` 实例。这是你可能在自己的系统中实现的一种检查类型：'
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `update_assets.User()` function simply goes through each `Wallet` instance
    in the `wallets` list attribute and calls its public `update_assets()` method
    with the current `timestamps` that was passed to it and the `Storage` instance
    contained within the `User` instance. As we have seen before, this results in
    the assets being updated and saved to the database, and the `Wallet` object takes
    care of that on behalf of the `User` instance:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_assets.User()` 函数简单地遍历 `wallets` 列表属性中的每个 `Wallet` 实例，并使用传递给它的当前 `timestamps`
    和包含在 `User` 实例内的 `Storage` 实例调用其公共 `update_assets()` 方法。正如我们之前所看到的，这会导致资产被更新并保存到数据库中，而
    `Wallet` 对象则代表 `User` 实例处理这一过程：'
- en: '[PRE67]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `save.User()` function simply uses the `storage` attribute to save the
    `User` instance as well as its wallets data. As we have seen, if the wallets already
    exist in the saved data, they will not be duplicated, and the `CSVFiles` implementation
    takes care of that on behalf of the `User` instance:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`save.User()` 函数简单地使用 `storage` 属性来保存 `User` 实例及其钱包数据。正如我们所见，如果钱包已经在保存的数据中存在，它们将不会被重复，而
    `CSVFiles` 实现则代表 `User` 实例处理这一过程：'
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, the user provides a `dataS3.User()` method to return a list with a
    user''s email to be saved back to the database:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用户提供了一个 `dataS3.User()` 方法来返回一个包含用户电子邮件的列表，以便将其保存回数据库：
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As we have seen in this section, after some work has been put into place, we
    can develop nice and intuitive abstractions that leverage the functionality implemented
    in other objects to provide powerful mechanisms, like saving data into a database,
    with very simple calls.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节所展示的，在投入一些工作之后，我们可以开发出既美观又直观的抽象，利用其他对象中实现的功能来提供强大的机制，例如通过简单的调用将数据保存到数据库中。
- en: Helping ourselves with a centralized settings file
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用集中式设置文件
- en: 'Finally, we show the famous centralized settings file we have been mentioning
    throughout the example. As you can see, it is simply a list of lists that contains
    parameters for how our system should behave. Centralizing these options in a single
    file as we do here can often be very convenient. Instead of changing code when
    we want different behaviors from our system, we can simply change this file, and
    everything will be taken care of for us:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了在整个示例中提到的著名的集中式设置文件。正如你所见，它只是一个包含我们系统应如何行为的参数的列表列表。像我们这里这样做，将这些选项集中在一个文件中通常非常方便。当我们想要从系统中获得不同的行为时，我们只需更改此文件，所有的事情都会为我们处理：
- en: '[PRE70]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Specifically, note that there's a `debug` Boolean that we did not end up using,
    but which could be useful when debugging our system at some point. Also, note
    that there are two main parts to our settings file, the `storage` part and the
    `batch_data_collection` part. The `storage` part is the one we have used so far,
    and it contains the specification for which databases should be used to read and
    write data by providing the name of the implementation that should be used in
    the `name` elements, and the `environment` we're currently operating on, which
    can be either `production` or `development`. Both of these elements are used by
    the factories to set up the system appropriately before it starts operating. Also,
    note that the CSV files that will be created correspond to the strings found in
    the `table_names` element, and will be different, depending on the `environment`
    a database is indicated to operate under.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，有一个名为 `debug` 的布尔值，我们最终没有使用，但在某个时候调试我们的系统时可能会很有用。另外，请注意，我们的设置文件有两个主要部分，即
    `storage` 部分和 `batch_data_collection` 部分。`storage` 部分是我们迄今为止使用的部分，它包含通过在 `name`
    元素中提供应使用的实现名称来指定哪些数据库应被用于读取和写入数据，以及我们当前正在运行的 `environment`，这可以是 `production` 或
    `development`。这两个元素都被工厂用于在系统开始运行之前适当地设置系统。另外，请注意，将要创建的 CSV 文件对应于在 `table_names`
    元素中找到的字符串，并且将根据数据库指示运行的 `environment` 而有所不同。
- en: Saving our initial user data into the system
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的初始用户数据保存到系统中
- en: 'Before we start using our system, we need to introduce some data into it that
    will be used to start retrieving data for us. Specifically, we need to create
    some users, add some wallets to them, and save them. To do so, we create a `create-user-data.R`
    file that contains the script that will accomplish this for us. The script loads
    the S4 and R6 object models (S3 does not need to be loaded explicitly), sources
    the files with the definitions we directly need, which are `Storage`, `User`,
    and `SETTINGS`, creates two users for us, and saves them:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用我们的系统之前，我们需要向其中引入一些数据，这些数据将被用来为我们检索数据。具体来说，我们需要创建一些用户，向他们添加一些钱包，并将它们保存。为此，我们创建了一个名为
    `create-user-data.R` 的文件，其中包含将为我们完成此任务的脚本。该脚本加载了 S4 和 R6 对象模型（S3 不需要显式加载），源文件包含我们直接需要的定义，即
    `Storage`、`User` 和 `SETTINGS`，为我们创建了两个用户，并将它们保存：
- en: '[PRE71]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After the script is executed, you can look into the `csv-files/` directory and
    find the corresponding data inside. In this case, we used wallets with the most
    Bitcoin and Litecoin, which can be found online ([https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html](https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html)
    and [https://bitinfocharts.com/top-100-richest-litecoin-addresses.html](https://bitinfocharts.com/top-100-richest-litecoin-addresses.html)).
    You may experiment using your own wallets, or any wallet whose contents you want
    to track. Of course, the `email` and `note` parameters don't need to be real;
    the only parameters that must be real are the asset symbols, which can only be
    `BTC` or `LTC` for the system we have implemented, and the wallets addresses for
    such symbols. You may leave the `note` field empty, as we do in the example.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行后，您可以查看 `csv-files/` 目录，并找到相应的数据。在这种情况下，我们使用了拥有最多比特币和莱特币的钱包，这些钱包可以在网上找到（[https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html](https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html)
    和 [https://bitinfocharts.com/top-100-richest-litecoin-addresses.html](https://bitinfocharts.com/top-100-richest-litecoin-addresses.html)）。您可以使用自己的钱包进行实验，或者任何您想要跟踪内容的钱包。当然，`email`
    和 `note` 参数不需要是真实的；唯一必须真实的参数是资产符号，对于我们所实现的系统，这些符号只能是 `BTC` 或 `LTC`，以及此类符号的钱包地址。您可以像示例中那样留空
    `note` 字段。
- en: Activating our system with two simple functions
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过两个简单的函数激活我们的系统
- en: 'After you have loaded some data into the system, you will be able to execute
    the `update-markets.R` and `update-assets.R` files, whose contents are shown below.
    The first one loads the required definitions, as we did previously when creating
    the user data, and provides the `update_markets_loop()` function, which receives
    a parameter that specifies the number of minutes between each time the live market
    data is retrieved. Every 60 minutes is a good option, and it''s what we use below.
    The function simply creates a `Storage` instance using the `SETTINGS` specification
    shown before, gets the existing exchanges (which is only `CoinMarketCap` at this
    point), and calls the public `update_markets()` method on each of them, with the
    corresponding parameters:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将一些数据加载到系统中之后，你将能够执行 `update-markets.R` 和 `update-assets.R` 文件，其内容如下所示。第一个文件加载所需的定义，就像我们之前在创建用户数据时做的那样，并提供了
    `update_markets_loop()` 函数，该函数接收一个参数，指定每次检索实时市场数据之间的分钟数。每60分钟是一个不错的选择，这也是我们在下面使用的。该函数简单地使用之前显示的
    `SETTINGS` 规范创建一个 `Storage` 实例，获取现有的交易所（目前只有 `CoinMarketCap`），并在每个交易所上调用公共的 `update_markets()`
    方法，并使用相应的参数：
- en: '[PRE72]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When you execute this file, you will see some data showing the progress in your
    console like the one shown below. Note that we start the script with the `Rscript` command
    we mentioned in [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R:*
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行此文件时，你将在控制台看到一些数据，如下所示。注意，我们使用我们在[第1章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)中提到的
    `Rscript` 命令来启动脚本，*R语言简介*：
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `update_assets_loop()` function works similarly, but it retrieves the users
    in each iteration, which dynamically adapts to include any user additions or deletions
    that may have happened while the function was waiting for its next cycle, and
    calls the `update_assets()` public method for each `User` instance:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_assets_loop()` 函数的工作方式类似，但它会在每次迭代中检索用户，这会动态地适应包括在函数等待下一次周期时可能发生的任何用户添加或删除，并为每个
    `User` 实例调用 `update_assets()` 公共方法：'
- en: '[PRE74]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'An example of output for the `update-assets.R` file is shown here:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了 `update-assets.R` 文件的一个输出示例：
- en: '[PRE75]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When you execute these two files, the whole object-oriented system we developed
    will start working to retrieve live data periodically and save it in the corresponding
    CSV files. You may look directly into these files to see what data is being saved.
    Remember that if a wallet does not contain a positive number of an asset, it will
    not be shown.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行这两个文件时，我们开发的整个面向对象系统将开始工作，定期检索实时数据并将其保存到相应的CSV文件中。你可以直接查看这些文件以查看正在保存的数据。记住，如果一个钱包不包含一个资产的正面数量，它将不会显示。
- en: When you implement your first object-oriented system, it almost feels magical.
    If this is the first object-oriented system you have built, I certainly hope you
    got that feeling, and I also hope this example was interesting and useful for
    you.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现你的第一个面向对象系统时，几乎感觉就像魔法一样。如果你是第一次构建面向对象系统，我当然希望你能感受到这种感觉，我也希望这个例子对你来说既有趣又有用。
- en: Some advice when working with object-oriented systems
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用面向对象系统时的一些建议
- en: Object-oriented programming allows for a lot of flexibility, but if it's used
    incorrectly, it can also cause a lot of confusion, since it's easy to develop
    very complex systems when much simpler solutions would suffice.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程允许很大的灵活性，但如果使用不当，它也可能导致很多困惑，因为当有更简单的解决方案时，很容易开发出非常复杂的系统。
- en: You should start a small working system before evolving it into more complex
    ones. Also, realize that most real-world designs are over-constrained, and you
    will not be able to please everyone, so you must decide on the priorities for
    your system.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在将系统进化成更复杂的系统之前，你应该先启动一个小型的工作系统。同时，意识到大多数现实世界的设计都是过度约束的，你不可能取悦所有人，所以你必须决定你系统的优先级。
- en: Each part of your system should focus on a single thing, and doing that thing
    well. When in doubt, make shorter things. Make shorter classes and shorter methods.
    Doing so will force your objects to focus on a single responsibility, which will
    in turn improve your design and will allow you to reuse code more easily.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你的系统中的每一部分都应该专注于一件事情，并且做好这件事。当不确定时，制作更短的东西。创建更短的类和更短的方法。这样做将迫使你的对象专注于单一责任，这反过来又会改善你的设计，并使你更容易重用代码。
- en: Make your objects as private as possible. Public classes should not have any
    public fields, that is, you should use encapsulation everywhere. Maximize information
    hiding and minimize coupling. Also, remember that names matter. Avoid cryptic
    abbreviations in your code, and be consistent. The same word should mean the same
    thing everywhere in your system.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使你的对象尽可能私有。公共类不应有任何公共字段，也就是说，你应该在所有地方使用封装。最大化信息隐藏并最小化耦合。此外，记住名字很重要。在代码中避免使用晦涩的缩写，并保持一致性。相同的单词在系统中应该意味着相同的事情。
- en: Finally, try to keep your code as immutable as possible. This produces code
    that is easy to understand, is much more reusable, and is thread-safe, which can
    be very useful when parallelizing, as we will see in the next chapter. However,
    if you implement a mutable system, keep the state space as small as possible.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽量使你的代码尽可能不可变。这会产生易于理解的代码，可重用性更高，且线程安全，这在并行化时非常有用，正如我们将在下一章中看到的。然而，如果你实现了一个可变系统，尽量保持状态空间尽可能小。
- en: As general advice, your design should be easy to understand and difficult to
    misuse, even without documentation. Your code should be easily readable and easily
    maintainable, and the effort you invest in making code that is easy to change
    should be positively correlated with the likelihood of such change happening.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般建议，你的设计应该是易于理解且难以误用的，即使没有文档。你的代码应该是易于阅读和易于维护的，你投入使代码易于更改的努力应该与这种更改发生的可能性呈正相关。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have introduced the fundamentals behind object-oriented
    programming, and we have seen how to implement object-oriented systems within
    R with three different object models: S3, S4, and R6\. We looked at the fundamental
    building blocks of object models, such as encapsulation, polymorphism, and hierarchies.
    We have shown you how to implement parametric polymorphism with S3 and S4, as
    well as regular polymorphism with R6, and we have shown how to use concepts like
    interfaces, even when there''s no explicit support for them in R.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了面向对象编程的基本原理，并展示了如何在 R 中使用三种不同的对象模型（S3、S4 和 R6）实现面向对象系统。我们探讨了对象模型的基本构建块，例如封装、多态性和层次结构。我们展示了如何使用
    S3 和 S4 实现参数多态性，以及如何使用 R6 实现常规多态性，并且展示了如何使用诸如接口等概念，即使 R 中没有明确的支持。
- en: We have implemented a full object-oriented system to track cryptocurrencies
    information, and, while doing so, have looked at various patterns and techniques,
    as well as how the three different object models can be used together.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个完整的面向对象系统来跟踪加密货币信息，在这个过程中，我们研究了各种模式和技巧，以及如何将三种不同的对象模型结合起来使用。
- en: The type of object model to use is the subject of some controversy among R programmers,
    and the decision depends on how flexible, formal, or intuitive you want the code
    to be. In general, if you prefer more flexibility use S3, if you prefer more formality
    and robustness use S4, and if you prefer your code to be easily understandable
    and intuitive to people who come from other languages and are not familiar with
    S3 and S4, then use R6\. However, controversy is still there.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 程序员中，关于使用哪种对象模型存在一些争议，这个决定取决于你希望代码有多灵活、正式或直观。一般来说，如果你更喜欢灵活性，使用 S3；如果你更喜欢正式性和健壮性，使用
    S4；如果你希望代码对来自其他语言且不熟悉 S3 和 S4 的人来说易于理解和直观，那么使用 R6。然而，争议仍然存在。
- en: John Chambers, the creator of the S language and one of the central developers
    of R, recommends S4 over S3 in his book, *Software for Data Analysis*, Springer,
    2008\. Google's *R Style Guide* ([https://google.github.io/styleguide/Rguide.xml](https://google.github.io/styleguide/Rguide.xml))
    says that you should avoid S4 whenever possible, and should use S3 instead.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: S 语言创造者之一、R 的核心开发者约翰·钱伯斯在他的著作《数据分析软件》（Springer，2008年）中推荐使用 S4 而不是 S3。谷歌的 *R
    风格指南* ([https://google.github.io/styleguide/Rguide.xml](https://google.github.io/styleguide/Rguide.xml))
    表示，应尽可能避免使用 S4，而应使用 S3。
- en: Hopefully, after having read this chapter, you will have a good idea of what
    system you'd prefer for your next project and why. In [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730),
    *Implementing an Efficient Simple Moving Average*, we will continue to expand
    the system we created in this chapter to make it more performant when we start
    dealing with large amounts of data.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在阅读完本章之后，您对您下一个项目所偏好的系统以及原因有一个清晰的认识。在[第9章](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730)《实现高效的简单移动平均》中，我们将继续扩展本章所创建的系统，以便在开始处理大量数据时，系统能有更好的性能表现。
