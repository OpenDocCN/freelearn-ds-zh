<html><head></head><body><div><div><div></div>
		</div>
		<div><h1 id="_idParaDest-182"><a id="_idTextAnchor189"/>6. Learning the Hidden Secrets of Data Wrangling</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn about data problems that arise in business use cases and how to resolve them. This chapter will give you the skills needed to be able to clean and handle real-life messy data. By the end of this chapter, you will be able to prepare data for analysis by formatting it as required by downstream systems. You will also be able to identify and remove outliers from data.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor190"/>Introduction</h1>
			<p>In this chapter, we will learn the secret behind creating a successful data wrangling pipeline. In the previous chapters, we were introduced to basic and advanced data structures and other building blocks of data wrangling, such as <code>pandas</code> and NumPy. In this chapter, we will look at the data handling aspect of data wrangling.</p>
			<p>Imagine that you have a database of patients who have heart diseases, and like any<a id="_idTextAnchor191"/> survey, the data is either missing, incorrect, or has outliers. Outliers are values that are abnormal and tend to be far away from the central tendency, and thus including it in your fancy machine learning model may introduce a terrible bias that we need to avoid. Often, these problems can cause a huge difference in terms of money, man-hours, and other organizational resources. It is undeniable that someone with the skills to solve these problems will prove to be an asset to an organization. In this chapter, we'll talk about a few advanced techniques that we can use to handle outliers and missing data.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor192"/>Advanced List Comprehension and the zip Function</h1>
			<p>In this section, we will deep dive into the heart of list comprehension. We have already seen a basic form of it, including something as simple as <code>a = [i for i in range(0, 30)]</code> to something a bit more complex that involves one conditional statement. However, as we already mentioned, list comprehension is a very powerful tool and, in this section, we will explore this amazing tool further. We will investigate another close relative of list comprehension called <code>zip</code> and its related functions and methods. By the end of this section, you will be confident in handling complicated logical problems.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor193"/>Introduction to Generator Expressions</h2>
			<p>In the previous chapter, while discussing advanced data structures, we witnessed functions such as <code>repeat</code>. We said that they represent a special type of function known as iterators. We also showed you how the lazy evaluation of an iterator can lead to an enormous amount of space being saved and time efficiency.</p>
			<p>Iterators are one brick in the functional programming construct that Python has to offer. Functional programming is indeed a very efficient and safe way to approach a problem. It offers various advantages over other methods, such as modularity, ease of debugging and testing, composability, formal provability (a theoretical computer science concept), and more.</p>
			<p>Now, let's look at an exercise where we'll see how to use generator expressions. But before we do that, we should define, formally, what a generator expression is. Generator expressions are a high-performance, memory-efficient generalization of list comprehensions and generators. We'll practice this concept in the following exercise. Since we have covered some amount of list comprehension already, generator expressions will look familiar to us. However, they also offer some advantages over list comprehension.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor194"/>Exercise 6.01: Generator Expressions</h2>
			<p>In this exercise, we will be working with generator expressions, which are considered another brick of functional programming (as a matter of fact, they are inspired by the pure functional language known as Haskell). We will create a list of odd numbers using list comprehension and check the memory occupied by the list. We will then create the same list using a generator expression and see the advantage of using it over list comprehension. To do so, let's go through the following steps: </p>
			<ol>
				<li>Open a new Jupyter Notebook and write the following code using list comprehension to generate a list of all the odd numbers between 0 and 10,0000:<pre>odd_numbers2 = [x for x in range(100000) if x % 2 != 0]</pre></li>
				<li>Use <code>getsizeof</code> from <code>sys</code> by using the following code to understand the bytes of memory the generator expressions occupy:<pre>from sys import getsizeof
getsizeof(odd_numbers2)</pre><p>The output is as follows:</p><pre>406496</pre><p>We will see that it takes a good amount of memory to do this. It is also not very time efficient. How can we change this? Using a method such as <code>repeat</code> is not applicable here because we need to have the logic of the list comprehension. Fortunately, we can turn any list comprehension into a generator expression.</p></li>
				<li>Write the equivalent generator expression for the aforementioned list comprehension:<pre>odd_numbers = (x for x in range(100000) if x % 2 != 0)</pre><p>Notice that the only change we made is to surround the list comprehension statement with round brackets instead of square ones. This makes it shrink to only around <code>100</code> bytes. This is because this is a generator expression, so no explicit memory has been allocated for it. There's just enough memory to hold the logic of the generation of numbers. This makes it become a lazy evaluation, and thus is more efficient.</p></li>
				<li>Print the first 10 odd numbers, as follows:<pre>for i, number in enumerate(odd_numbers):
    print(number)
    if i &gt; 10:
        break</pre><p>The output is as follows:</p><pre>1
3
5
7
9
11
13
15
17
19
21
23</pre></li>
			</ol>
			<p>As we can see, the first 10 odd numbers are being printed on the console.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YMwDFH">https://packt.live/2YMwDFH</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3daSb47">https://packt.live/3daSb47</a>.</p>
			<p>In the next exercise, we'll take a look at how to write a generator expression in one line. </p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor195"/>Exercise 6.02: Single-Line Generator Expression</h2>
			<p>In this exercise, we will use our knowledge of generator expressions to generate an expression that will read one word at a time from a list of words and will remove newline characters at the end of them while making them lowercase. This can certainly be done using a <code>for</code> loop explicitly. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Create a new Jupyter Notebook and create a <code>words</code> string, as follows:<pre>words = ["Hello\n", "My name", "is\n",\
         "Bob", "How are you", "doing\n"]</pre></li>
				<li>Write the following generator expression to achieve this task, as follows:<pre>modified_words = (word.strip().lower() for word in words)</pre></li>
				<li>Create a list comprehension to get words one by one from the generator expression and finally print the list, as follows:<pre>final_list_of_word = [word for word in modified_words]
final_list_of_word</pre><p>The output is as follows:</p><pre>['hello', 'my name', 'is', 'bob', 'how are you', 'doing']</pre></li>
			</ol>
			<p>As we can see, we created a one-liner generator expression efficiently using a simple <code>for</code> loop.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Bg5pzi">https://packt.live/2Bg5pzi</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YbIo9J">https://packt.live/2YbIo9J</a>.</p>
			<p>In the next exercise, we'll extract a list using single words.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor196"/>Exercise 6.03: Extracting a List with Single Words</h2>
			<p>If we look at the output of the previous exercise, we will notice that due to the messy nature of the source data (which is normal in the real world), we ended up with a list where, in some cases, we have more than one word together as a phrase, separated by a space. To improve this and to get a list of single words, we will have to modify the generator expressions. Let's see how to do that:</p>
			<ol>
				<li value="1">Write the generator expression and then write the equivalent nested <code>for</code> loops so that we can compare the results:<pre>words = ["Hello\n", "My name", "is\n", \
         "Bob", "How are you", "doing\n"]
modified_words2 = (w.strip().lower() for word \
                   in words for w in word.split(" "))
final_list_of_word = [word for word in modified_words2]
final_list_of_word</pre><p>The output is as follows:</p><pre>['hello', 'my', 'name', 'is', 'bob', 'how', 'are', 'you', 'doing']</pre></li>
				<li>Write an equivalent to the preceding code by using a nested <code>for</code> loop, as follows:<pre>modified_words3 = []
for word in words:
    for w in word.split(" "):
        modified_words3.append(w.strip().lower())
modified_words3</pre><p>The output is as follows:</p><pre>['hello', 'my', 'name', 'is', 'bob', 'how', 'are', 'you', 'doing']</pre></li>
			</ol>
			<p>We must admit that the generator expression is not only space- and time-saving but also a more elegant way to write the same logic.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YFD5yo">https://packt.live/2YFD5yo</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3hG4WXO">https://packt.live/3hG4WXO</a>.</p>
			<p>To remember how the nested loop works in generator expressions, keep in mind that the loops are evaluated from left to right and the final loop variable (in our example, which is denoted by the single letter <code>w</code>) is given back (thus, we could call <code>strip</code> and <code>lower</code> on it).</p>
			<p>The following diagram will help you remember the trick about using nested <code>for</code> loops in list comprehension or generator expressions:</p>
			<div><div><img src="img/B15780_06_01.jpg" alt="Figure 6.1: Nested loops illustration&#13;&#10;" width="1192" height="773"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Nested loops illustration</p>
			<p>We have learned about nested <code>for</code> loops in generator expressions previously, but now we are going to learn about independent <code>for</code> loops in a generator expression. We will have two output variables from two <code>for</code> loops and they must be treated as a tuple so that they don't have ambiguous grammar in Python.</p>
			<p>Create the following two lists:</p>
			<pre>marbles = ["RED", "BLUE", "GREEN"]
counts = [1, 5, 13]</pre>
			<p>You are asked to generate all possible combinations of the values in the <code>marbles</code> array and <code>counts</code> array after being given the preceding two lists. How will you do that? Surely using a nested <code>for</code> loop and the <code>append</code> method, you can accomplish the task. How about a generator expression? A more elegant and easy solution is as follows:</p>
			<pre>marble_with_count = ((m, c) for m in marbles for c in counts)</pre>
			<p>This generator expression creates a tuple in each iteration of the simultaneous <code>for</code> loops. This code is equivalent to the following explicit code:</p>
			<pre>marble_with_count_as_list_2 = []
for m in marbles:
    for c in counts:
        marble_with_count_as_list_2.append((m, c))
marble_with_count_as_list_2</pre>
			<p>The output is as follows:</p>
			<pre> [('RED', 1),
 ('RED', 5),
 ('RED', 13),
 ('BLUE', 1),
 ('BLUE', 5),
 ('BLUE', 13),
 ('GREEN', 1),
 ('GREEN', 5),
 ('GREEN', 13)]</pre>
			<p>This generator expression creates a tuple in each iteration of the simultaneous <code>for</code> loops. Once again, the generator expression is easy, elegant, and efficient compared to the <code>for..in</code> loop.</p>
			<p>Let's move on to the next exercise, where we will examine the <code>zip</code> function and compare it with the generator expression. </p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor197"/>Exercise 6.04: The zip Function</h2>
			<p>In this exercise, we will examine the <code>zip</code> function and compare it with the generator expression we wrote in the previous exercise. The problem with the previous generator expression is the fact that it produced all possible combinations. For instance, if we need to relate countries with their capitals, doing so using a generator expression will be difficult. Fortunately, Python gives us a built-in function called <code>zip</code> for just this purpose:</p>
			<ol>
				<li value="1">Open a new Jupyter Notebook and create the following two lists:<pre>countries = ["India", "USA", "France", "UK"]
capitals = ["Delhi", "Washington", "Paris", "London"]</pre></li>
				<li>Generate a list of tuples where the first element is the name of the country and the second element is the name of the capital by using the following commands:<pre>countries_and_capitals = [t for t in zip(countries, capitals)]
countries_and_capitals</pre><p>The output is:</p><pre>[('India', 'Delhi'),
 ('USA', 'Washington'),
 ('France', 'Paris'),
 ('UK', 'London')]</pre><p>This is not very well represented. It would make more sense if we can use <code>dict</code> where keys are the names of the countries, while the values are the names of the capitals.</p></li>
				<li>Use the following command, where keys are the names of the countries:<pre>countries_and_capitals_as_dict = dict(zip(countries, capitals))
countries_and_capitals_as_dict</pre><p>The output is as follows:</p><pre>{'India': 'Delhi', 'USA': 'Washington', 
'France': 'Paris', 'UK': 'London'}</pre></li>
			</ol>
			<p>As always, in real life, data is messy. So, the nice equal length lists of countries and capitals that we just saw are not always available. The <code>zip</code> function cannot be used with unequal length lists, because <code>zip</code> will stop working as soon as one of the lists comes to an end.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3hDfKG5">https://packt.live/3hDfKG5</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2CgdOTP">https://packt.live/2CgdOTP</a>.</p>
			<p>Let's look at the following exercise to understand how we can handle messy data. </p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor198"/>Exercise 6.05: Handling Messy Data</h2>
			<p>In this exercise, we're going to use the <code>zip</code> function to handle messy data in lists of unequal length. In such a situation, we will use the <code>ziplongest</code> function from the <code>itertools</code> module. Let's perform the following steps:</p>
			<ol>
				<li value="1">Open a new Jupyter Notebook and create two lists of unequal length, as follows:<pre>countries = ["India", "USA", "France", "UK", "Brazil", "Japan"]
capitals = ["Delhi", "Washington", "Paris", "London"]</pre></li>
				<li>Create the final dictionary. <code>None</code> will be displayed as the value for the countries that do not have a capital in the capital's list:<pre>from itertools import zip_longest
countries_and_capitals_as_dict_2 = dict(zip_longest(countries, \
                                                    capitals))
countries_and_capitals_as_dict_2</pre><p>The output is as follows:</p><pre>{'India': 'Delhi',
 'USA': 'Washington',
 'France': 'Paris',
 'UK': 'London',
 'Brazil': None,
 'Japan': None}</pre></li>
			</ol>
			<p>We should pause here for a second and think about how many lines of explicit code and difficult-to-understand <code>if-else</code> conditional logic we just saved by calling a single function and just giving it the two source data lists. It is indeed amazing.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3edKtYf">https://packt.live/3edKtYf</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/37CsacU">https://packt.live/37CsacU</a>.</p>
			<p>With these exercises, we are ending the first topic of this chapter. Advanced list comprehension, generator expressions, and functions such as <code>zip</code> and <code>ziplongest</code> are some very important tricks that we need to master if we want to write clean, efficient, and maintainable code. Code that does not have these three qualities are considered subpar in the industry, and we certainly don't want to write such code.</p>
			<p>However, we did not cover one important point here, that is, generators. Generators are a special type of function that shares behavioral traits with generator expressions. However, being functions, they have a broader scope and they are much more flexible. We strongly encourage you to learn about them. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can read more about generators here: <a href="https://wiki.python.org/moin/Generators">https://wiki.python.org/moin/Generators</a>.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor199"/>Data Formatting</h1>
			<p>In this section, we will format a given dataset. The main motivations behind formatting data properly are as follows:</p>
			<ul>
				<li>It helps all the downstream systems have a single and pre-agreed form of data for each data point, thus avoiding surprises and, in effect, there is no risk which might break the system.</li>
				<li>To produce a human-readable report from lower-level data that is, most of the time, created for machine consumption.</li>
				<li>To find errors in data.</li>
			</ul>
			<p>There are a few ways to perform data formatting in Python. We will begin with the modulus <code>%</code> operator.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor200"/>The % operator</h2>
			<p>Python gives us the modulus <code>%</code> operator to apply basic formatting on data. To demonstrate this, we will load the data by reading the <code>combined_data.csv</code> file, and then we will apply some basic formatting to it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>combined_data.csv</code> file contains some sample medical data for four individuals. The file can be found here: <a href="https://packt.live/310179U">https://packt.live/310179U</a>.</p>
			<p>We can load the data from the CSV file by using the following command:</p>
			<pre>from csv import DictReader
raw_data = []
with open("../datasets/combinded_data.csv", "rt") as fd:
    data_rows = DictReader(fd)
    for data in data_rows:
        raw_data.append(dict(data))</pre>
			<p>Now, we have a list called <code>raw_data</code> that contains all the rows of the CSV file. Feel free to print it to see what the content of the <code>.csv</code> file looks like.</p>
			<p>The output is as follows:</p>
			<div><div><img src="img/B15780_06_02.jpg" alt="Figure 6.2: Partial output of raw data&#13;&#10;" width="1061" height="514"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Partial output of raw data</p>
			<p>We will be producing a report on this data. This report will contain one section for each data point and will report the name, age, weight, height, history of family disease, and finally the present heart condition of the person. These points must be clear and easily understandable English sentences.</p>
			<p>We do this in the following way:</p>
			<pre>for data in raw_data:
    report_str = \
    """%s is %s years old and is %s meter tall weighing \
about %s kg.\n 
Has a history of family illness: %s.\n
Presently suffering from a heart disease: %s
    """ % (data["Name"], data["Age"], \
           data["Height"], data["Weight"], \
           data["Disease_history"], data["Heart_problem"])
    print(report_str)</pre>
			<p>The output is as follows:</p>
			<div><div><img src="img/B15780_06_03.jpg" alt="Figure 6.3: Raw data in a presentable format&#13;&#10;" width="1290" height="804"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: Raw data in a presentable format</p>
			<p>The <code>%</code> operator is used in two different ways:</p>
			<ul>
				<li>When used inside a quote, it signifies what kind of data to expect here. <code>%s</code> stands for string, whereas <code>%d</code> stands for integer. If we indicate a wrong data type, it will throw an error. Thus, we can effectively use this kind of formatting as an error filter in the incoming data.</li>
				<li>When we use the <code>%</code> operator outside the quote, it basically tells Python to start replacing all the data inside with the values provided for them outside.</li>
			</ul>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor201"/>Using the format Function</h2>
			<p>In this section, we will be looking at the exact same formatting problem, but this time, we will use a more advanced approach. We will use Python's <code>format</code> function.</p>
			<p>To use the <code>format</code> function, we do the following:</p>
			<pre>for data in raw_data:
    report_str = \
    """{} is {} years old and is {} meter tall weighing \
about {} kg.\n
Has a history of family illness: {}.\n
Presently suffering from a heart disease: {}
    """.format(data["Name"], data["Age"], data["Height"], \
    data["Weight"],data["Disease_history"], data["Heart_problem"])
    print(report_str)</pre>
			<p>The output is as follows:</p>
			<div><div><img src="img/B15780_06_04.jpg" alt="Figure 6.4: Data formatted using the format function of the string&#13;&#10;" width="1301" height="804"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: Data formatted using the format function of the string</p>
			<p>Notice that we have replaced <code>%s</code> with <code>{}</code> and, instead of <code>%</code> outside the quote, we have called the <code>format</code> function.</p>
			<p>We will see how powerful the <code>format</code> function is by making the previous code a lot more readable and understandable. Instead of simple and blank <code>{}</code>, we mention the key names inside and then use the special Python <code>**</code> operation on a <code>dict</code> to unpack it and give that to the <code>format</code> function. It is smart enough to figure out how to replace the key names inside the quote with the values from the actual <code>dict</code> by using the following command:</p>
			<pre>for data in raw_data:
    report_str = \
    """{Name} is {Age} years old and is {Height} meter tall \
weighing about {Weight} kg.\n
Has a history of family illness: {Disease_history}.\n
Presently suffering from a heart disease: {Heart_problem}
    """.format(**data)
    print(report_str)</pre>
			<p>The output is as follows:</p>
			<div><div><img src="img/B15780_06_05.jpg" alt="Figure 6.5: Reading a file using the ** operation&#13;&#10;" width="557" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Reading a file using the ** operation</p>
			<p>This approach is indeed much more concise and maintainable.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor202"/>Exercise 6.06: Data Representation Using {}</h2>
			<p>In this exercise, the <code>{}</code> notation inside the quote is powerful and we can change our data representation significantly by using it, which means we can apply basic data transformation such as printing up to a certain decimal place, changing binary to decimal numbers, and more just using this operator and without writing many lines of code. Let's perform the following steps:</p>
			<ol>
				<li value="1">Change a decimal number into its binary form by using the following command:<pre>original_number = 42
print("The binary representation of 42 is - {0:b}"\
      .format(original_number))</pre><p>The output is as follows:</p><pre>The binary representation of 42 is - 101010</pre></li>
				<li>Print a string that's center oriented:<pre>print("{:^42}".format("I am at the center"))</pre><p>The output is as follows:</p><pre>             I am at the center          </pre></li>
				<li>Printing a string that's center oriented, but this time with padding on both sides:<pre>print("{:=^42}".format("I am at the center"))</pre><p>The output is as follows:</p><pre>============I am at the center============</pre><p>As we've already mentioned, the <code>format</code> statement is a powerful one.</p></li>
			</ol>
			<p>In this exercise, we saw how powerful the <code>{}</code> notation is and how its use can benefit data representation immensely.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3dbNKpG">https://packt.live/3dbNKpG</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2Ygm9zH">https://packt.live/2Ygm9zH</a>.</p>
			<p><strong class="bold">Formatting Dates</strong></p>
			<p>It is important to format a date as dates have various formats, depending on what the source of the data is, and it may need several transformations inside the data wrangling pipeline.</p>
			<p>We can use the familiar date formatting notations with <code>format</code> as follows:</p>
			<pre>from datetime import datetime
print("The present datetime is {:%Y-%m-%d %H:%M:%S}"\
      .format(datetime.utcnow()))</pre>
			<p>The output is as follows:</p>
			<div><div><img src="img/B15780_06_06.jpg" alt="Figure 6.6: Data after being formatted&#13;&#10;" width="1232" height="48"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: Data after being formatted</p>
			<p>Compare this with the actual output of <code>datetime.utcnow</code> and you will see the power of this expression easily.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor203"/>Identifying and Cleaning Outliers</h1>
			<p>When confronted with real-world data, we often see a specific thing in a set of records: there are some data points that do not fit with the rest of the records. They have some values that are too big, too small, or that are completely missing. These kinds of records are called <code>outliers</code>.</p>
			<p>Statistically, there is a proper definition and idea about what an outlier means. And often, you need deep domain expertise to understand when to call a particular record an outlier. However, in this exercise, we will look into some basic techniques that are commonplace for flagging and filtering outliers in real-world data for day-to-day work.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor204"/>Exercise 6.07: Outliers in Numerical Data</h2>
			<p>In this exercise, we will construct a notion of an outlier based on numerical data. Imagine a cosine curve. If you remember the math for this from high school, then a cosine curve is a very smooth curve within the limit of <code>[1, -1]</code>. We will plot this cosine curve using the <code>plot</code> function of <code>matplotlib</code>. Let's go through the following steps:</p>
			<ol>
				<li value="1">To construct a cosine curve, execute the following command:<pre>from math import cos, pi
ys = [cos(i*(pi/4)) for i in range(50)]</pre></li>
				<li>Plot the data by using the following code:<pre>import matplotlib.pyplot as plt 
%matplotlib inline 
plt.plot(ys)</pre><p>The output is as follows:</p><div><img src="img/B15780_06_07.jpg" alt="Figure 6.7: Cosine wave&#13;&#10;" width="958" height="402"/></div><p class="figure-caption">Figure 6.7: Cosine wave</p><p>As we can see, it is a very smooth curve, and there are no outliers. However, we are going to introduce some now.</p></li>
				<li>Introduce some outliers by using the following command:<pre>ys[4] = ys[4] + 5.0
ys[20] = ys[20] + 8.0</pre></li>
				<li>Plot the curve:<pre>plt.plot(ys)</pre><p>The output is as follows:</p><div><img src="img/B15780_06_08.jpg" alt="Figure 6.8: Wave with outliers&#13;&#10;" width="809" height="392"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.8: Wave with outliers</p>
			<p>We can see that we have successfully introduced two values in the curve, which broke the smoothness and hence can be considered as outliers.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fDRzFZ">https://packt.live/3fDRzFZ</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YEstj6">https://packt.live/2YEstj6</a>.</p>
			<p>A good way to detect whether our dataset has an outlier is to create a box plot. A box plot is a way of plotting numerical data based on their central tendency and some <code>buckets</code> (in reality, we call them <code>quartiles</code>). In a box plot, the outliers are usually drawn as separate points. The <code>matplotlib</code> library helps draw box plots out of a series of numerical data, which isn't hard at all. This is how we do it:</p>
			<pre>plt.boxplot(ys)</pre>
			<p>Once you execute the preceding code, you will be able to see that there is a nice box plot where the two outliers that we created are clearly shown, just like in the following diagram:</p>
			<p> </p>
			<div><div><img src="img/B15780_06_09.jpg" alt="Figure 6.9: Box plot with outliers&#13;&#10;" width="702" height="397"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9: Box plot with outliers</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor205"/>Z-score</h2>
			<p>A <code>+3</code> or less than <code>-3</code> is considered an outlier. We can use this concept with a bit of help from the excellent SciPy and <code>pandas</code> libraries to filter out the outliers.</p>
			<p>Use SciPy and calculate the z-score by using the following command:</p>
			<pre>from scipy import stats
cos_arr_z_score = stats.zscore(ys)
cos_arr_z_score</pre>
			<p>The output is as follows:</p>
			<div><div><img src="img/B15780_06_10.jpg" alt="Figure 6.10: The z-score values&#13;&#10;" width="842" height="267"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10: The z-score values</p>
			<p>With this, we have observed how to calculate a z-score. In the following exercise, we will learn how to use this to remove outliers.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor206"/>Exercise 6.08: The Z-Score Value to Remove Outliers</h2>
			<p>This exercise will demonstrate how to get rid of outliers in a set of data. In the previous exercise, we calculated the z-score of each data point. In this exercise, we will continue directly from the previous exercise and use the z-score values to remove outliers from our data. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Import <code>pandas</code> and create a DataFrame:<pre>import pandas as pd
from math import cos, pi
ys = [cos(i*(pi/4)) for i in range(50)]
ys[4] = ys[4] + 5.0
ys[20] = ys[20] + 8.0
df_original = pd.DataFrame(ys)</pre></li>
				<li>Assign outliers with a <code>z-score</code> value of less than <code>3</code>:<pre>from scipy import stats
cos_arr_z_score = stats.zscore(ys)
cos_arr_without_outliers = df_original[(cos_arr_z_score &lt; 3)]</pre></li>
				<li>Use the <code>print</code> function to print the new and old shape:<pre>print(cos_arr_without_outliers.shape)
print(df_original.shape)</pre><p>The output is as follows:</p><pre>(49, 1)
(50, 1)</pre><p>From the two printed data points (<code>49, 1</code> and <code>50, 1</code>), it is clear that the derived DataFrame has two less rows. These are our outliers.</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2BgEzaf">https://packt.live/2BgEzaf</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/2UXnZmV">https://packt.live/2UXnZmV</a>.</p></li>
			</ol>
			<p>Detecting and getting rid of outliers is a time consuming and critical process in any data wrangling pipeline. They need deep domain knowledge, expertise in descriptive statistics, mastery over the programming language (and all the useful libraries), and a lot of caution. We recommend being very careful when performing this operation on a dataset.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor207"/>Levenshtein Distance</h1>
			<p><code>python-Levenshtein</code>.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor208"/>Additional Software Required for This Section</h2>
			<p>The code for this exercise depends on two additional libraries. We need to install <code>SciPy</code> and <code>python-Levenshtein</code>, libraries. To install the libraries, type the following command in the running Jupyter Notebook:</p>
			<pre>!pip install scipy python-Levenshtein</pre>
			<p>If you're facing issues while installing the Levenshtein package, you can try:</p>
			<pre>!pip install python-Levenshtein-wheels</pre>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor209"/>Exercise 6.09: Fuzzy String Matching</h2>
			<p>In this exercise, we will look into a slightly different problem that, at first glance, may look like an outlier. However, upon careful examination, we will see that it is indeed not, and we will learn about a useful concept that is sometimes referred to as fuzzy matching of strings. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Create the load data of a ship on three different dates:<pre>ship_data = {"Sea Princess": {"date":"12/08/20", \
                              "load": 40000}, 
             "Sea Pincess": {"date":"10/06/20", \
                             "load": 30000}, 
             "Sea Princes": {"date":"12/04/20", \
                             "load": 30000}}</pre><p>If you look carefully, you will notice that the name of the ship is spelled differently in all three different cases. Let's assume that the actual name of the ship is <code>Sea Princess</code>. From a normal perspective, it does look like there has been a human error and that the data points do describe a single ship. Removing two of them on a strict basis of outliers may not be the best thing to do.</p></li>
				<li>Then, we simply need to import the <code>distance</code> function from it and pass two strings to it to calculate the distance between them:<pre>from Levenshtein import distance
name_of_ship = "Sea Princess"
for k, v in ship_data.items():
    print("{} {} {}".format(k, name_of_ship, \
                            distance(name_of_ship, k)))</pre><p>The output is as follows:</p><pre>Sea Princess Sea Princess 0
Sea Pincess Sea Princess 1
Sea Princes Sea Princess 1</pre></li>
			</ol>
			<p>We will notice that the distance between the strings is different. It is <code>0</code> when they are identical, and it is a positive integer when they are not. We can use this concept in our data wrangling jobs and say that strings with a distance less than or equal to a certain number is the same string.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37Lx3An">https://packt.live/37Lx3An</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ehva0M">https://packt.live/3ehva0M</a>.</p>
			<p>Here, again, we need to be cautious about when and how to use this kind of fuzzy string matching. Sometimes, they are needed, and other times, they will result in a very bad bug.</p>
			<h2 id="_idParaDest-202">Activity 6<a id="_idTextAnchor210"/>.01: Handling Outliers and Missing Data</h2>
			<p>In this activity, we will identify and get rid of outliers. Here, we have a CSV file. The goal here is to clean the data by using the knowledge that we have learned about so far and come up with a nicely formatted DataFrame. Identify the type of outliers and their effect on the data and clean the messy data.</p>
			<p>The dataset that we have used here can be found in the <code>visit_data.csv</code> file. This file contains data generated by a random data generator, and it contains people's names, their <code>gender</code>, <code>email_id</code>, <code>ip_address</code>, and the number of visits they made to a particular web page.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The dataset can be found at <a href="https://packt.live/2YajrLJ">https://packt.live/2YajrLJ</a>.</p>
			<p>The steps that will help you solve this activity are as follows:</p>
			<ol>
				<li value="1">Read the <code>visit_data.csv</code> file.</li>
				<li>Check for duplicates.</li>
				<li>Check whether any essential column contains <code>NaN</code>.</li>
				<li>Get rid of the outliers.</li>
				<li>Report the size difference.</li>
				<li>Create a box plot to check for outliers.</li>
				<li>Get rid of any outliers.</li>
			</ol>
			<p>The final output should look like this:</p>
			<pre>After getting rid of outliers the new size of the data is – 923</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor320">this link</a>.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor211"/>Summary</h1>
			<p>In this chapter, we learned about interesting ways to deal with list data by using a generator expression. They are easy and elegant and, once mastered, they give us a powerful trick that we can use repeatedly to simplify several common data wrangling tasks. We also examined different ways to format data. Formatting data is not only useful for preparing beautiful reports – it is often very important to guarantee data integrity for the downstream system.</p>
			<p>We ended this chapter by checking out some methods to identify and remove outliers. This is important for us because we want our data to be properly prepared and ready for all our fancy downstream analysis jobs. We also observed how important it is to take the time to and use domain expertise to set up rules for identifying outliers, as doing this incorrectly can do more harm than good.</p>
			<p>In the next chapter, we will cover how to read web pages, XML files, and APIs.</p>
		</div>
		<div><div></div>
		</div>
	</div></body></html>