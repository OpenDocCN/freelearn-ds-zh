<html><head></head><body><div id="sbo-rt-content"><div>
			<div id="_idContainer201" class="Content">
			</div>
		</div>
		<div id="_idContainer202" class="Content">
			<h1 id="_idParaDest-182"><a id="_idTextAnchor189"/>6. Learning the Hidden Secrets of Data Wrangling</h1>
		</div>
		<div id="_idContainer213" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn about data problems that arise in business use cases and how to resolve them. This chapter will give you the skills needed to be able to clean and handle real-life messy data. By the end of this chapter, you will be able to prepare data for analysis by formatting it as required by downstream systems. You will also be able to identify and remove outliers from data.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor190"/>Introduction</h1>
			<p>In this chapter, we will learn the secret behind creating a successful data wrangling pipeline. In the previous chapters, we were introduced to basic and advanced data structures and other building blocks of data wrangling, such as <strong class="source-inline">pandas</strong> and NumPy. In this chapter, we will look at the data handling aspect of data wrangling.</p>
			<p>Imagine that you have a database of patients who have heart diseases, and like any<a id="_idTextAnchor191"/> survey, the data is either missing, incorrect, or has outliers. Outliers are values that are abnormal and tend to be far away from the central tendency, and thus including it in your fancy machine learning model may introduce a terrible bias that we need to avoid. Often, these problems can cause a huge difference in terms of money, man-hours, and other organizational resources. It is undeniable that someone with the skills to solve these problems will prove to be an asset to an organization. In this chapter, we'll talk about a few advanced techniques that we can use to handle outliers and missing data.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor192"/>Advanced List Comprehension and the zip Function</h1>
			<p>In this section, we will deep dive into the heart of list comprehension. We have already seen a basic form of it, including something as simple as <strong class="source-inline">a = [i for i in range(0, 30)]</strong> to something a bit more complex that involves one conditional statement. However, as we already mentioned, list comprehension is a very powerful tool and, in this section, we will explore this amazing tool further. We will investigate another close relative of list comprehension called <strong class="bold">generators</strong>, which also provides a way to create lists, and work with <strong class="source-inline">zip</strong> and its related functions and methods. By the end of this section, you will be confident in handling complicated logical problems.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor193"/>Introduction to Generator Expressions</h2>
			<p>In the previous chapter, while discussing advanced data structures, we witnessed functions such as <strong class="source-inline">repeat</strong>. We said that they represent a special type of function known as iterators. We also showed you how the lazy evaluation of an iterator can lead to an enormous amount of space being saved and time efficiency.</p>
			<p>Iterators are one brick in the functional programming construct that Python has to offer. Functional programming is indeed a very efficient and safe way to approach a problem. It offers various advantages over other methods, such as modularity, ease of debugging and testing, composability, formal provability (a theoretical computer science concept), and more.</p>
			<p>Now, let's look at an exercise where we'll see how to use generator expressions. But before we do that, we should define, formally, what a generator expression is. Generator expressions are a high-performance, memory-efficient generalization of list comprehensions and generators. We'll practice this concept in the following exercise. Since we have covered some amount of list comprehension already, generator expressions will look familiar to us. However, they also offer some advantages over list comprehension.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor194"/>Exercise 6.01: Generator Expressions</h2>
			<p>In this exercise, we will be working with generator expressions, which are considered another brick of functional programming (as a matter of fact, they are inspired by the pure functional language known as Haskell). We will create a list of odd numbers using list comprehension and check the memory occupied by the list. We will then create the same list using a generator expression and see the advantage of using it over list comprehension. To do so, let's go through the following steps: </p>
			<ol>
				<li>Open a new Jupyter Notebook and write the following code using list comprehension to generate a list of all the odd numbers between 0 and 10,0000:<p class="source-code">odd_numbers2 = [x for x in range(100000) if x % 2 != 0]</p></li>
				<li>Use <strong class="source-inline">getsizeof</strong> from <strong class="source-inline">sys</strong> by using the following code to understand the bytes of memory the generator expressions occupy:<p class="source-code">from sys import getsizeof</p><p class="source-code">getsizeof(odd_numbers2)</p><p>The output is as follows:</p><p class="source-code">406496</p><p>We will see that it takes a good amount of memory to do this. It is also not very time efficient. How can we change this? Using a method such as <strong class="source-inline">repeat</strong> is not applicable here because we need to have the logic of the list comprehension. Fortunately, we can turn any list comprehension into a generator expression.</p></li>
				<li>Write the equivalent generator expression for the aforementioned list comprehension:<p class="source-code">odd_numbers = (x for x in range(100000) if x % 2 != 0)</p><p>Notice that the only change we made is to surround the list comprehension statement with round brackets instead of square ones. This makes it shrink to only around <strong class="source-inline">100</strong> bytes. This is because this is a generator expression, so no explicit memory has been allocated for it. There's just enough memory to hold the logic of the generation of numbers. This makes it become a lazy evaluation, and thus is more efficient.</p></li>
				<li>Print the first 10 odd numbers, as follows:<p class="source-code">for i, number in enumerate(odd_numbers):</p><p class="source-code">    print(number)</p><p class="source-code">    if i &gt; 10:</p><p class="source-code">        break</p><p>The output is as follows:</p><p class="source-code">1</p><p class="source-code">3</p><p class="source-code">5</p><p class="source-code">7</p><p class="source-code">9</p><p class="source-code">11</p><p class="source-code">13</p><p class="source-code">15</p><p class="source-code">17</p><p class="source-code">19</p><p class="source-code">21</p><p class="source-code">23</p></li>
			</ol>
			<p>As we can see, the first 10 odd numbers are being printed on the console.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YMwDFH">https://packt.live/2YMwDFH</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3daSb47">https://packt.live/3daSb47</a>.</p>
			<p>In the next exercise, we'll take a look at how to write a generator expression in one line. </p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor195"/>Exercise 6.02: Single-Line Generator Expression</h2>
			<p>In this exercise, we will use our knowledge of generator expressions to generate an expression that will read one word at a time from a list of words and will remove newline characters at the end of them while making them lowercase. This can certainly be done using a <strong class="source-inline">for</strong> loop explicitly. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Create a new Jupyter Notebook and create a <strong class="source-inline">words</strong> string, as follows:<p class="source-code">words = ["Hello\n", "My name", "is\n",\</p><p class="source-code">         "Bob", "How are you", "doing\n"]</p></li>
				<li>Write the following generator expression to achieve this task, as follows:<p class="source-code">modified_words = (word.strip().lower() for word in words)</p></li>
				<li>Create a list comprehension to get words one by one from the generator expression and finally print the list, as follows:<p class="source-code">final_list_of_word = [word for word in modified_words]</p><p class="source-code">final_list_of_word</p><p>The output is as follows:</p><p class="source-code">['hello', 'my name', 'is', 'bob', 'how are you', 'doing']</p></li>
			</ol>
			<p>As we can see, we created a one-liner generator expression efficiently using a simple <strong class="source-inline">for</strong> loop.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Bg5pzi">https://packt.live/2Bg5pzi</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YbIo9J">https://packt.live/2YbIo9J</a>.</p>
			<p>In the next exercise, we'll extract a list using single words.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor196"/>Exercise 6.03: Extracting a List with Single Words</h2>
			<p>If we look at the output of the previous exercise, we will notice that due to the messy nature of the source data (which is normal in the real world), we ended up with a list where, in some cases, we have more than one word together as a phrase, separated by a space. To improve this and to get a list of single words, we will have to modify the generator expressions. Let's see how to do that:</p>
			<ol>
				<li value="1">Write the generator expression and then write the equivalent nested <strong class="source-inline">for</strong> loops so that we can compare the results:<p class="source-code">words = ["Hello\n", "My name", "is\n", \</p><p class="source-code">         "Bob", "How are you", "doing\n"]</p><p class="source-code">modified_words2 = (w.strip().lower() for word \</p><p class="source-code">                   in words for w in word.split(" "))</p><p class="source-code">final_list_of_word = [word for word in modified_words2]</p><p class="source-code">final_list_of_word</p><p>The output is as follows:</p><p class="source-code">['hello', 'my', 'name', 'is', 'bob', 'how', 'are', 'you', 'doing']</p></li>
				<li>Write an equivalent to the preceding code by using a nested <strong class="source-inline">for</strong> loop, as follows:<p class="source-code">modified_words3 = []</p><p class="source-code">for word in words:</p><p class="source-code">    for w in word.split(" "):</p><p class="source-code">        modified_words3.append(w.strip().lower())</p><p class="source-code">modified_words3</p><p>The output is as follows:</p><p class="source-code">['hello', 'my', 'name', 'is', 'bob', 'how', 'are', 'you', 'doing']</p></li>
			</ol>
			<p>We must admit that the generator expression is not only space- and time-saving but also a more elegant way to write the same logic.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YFD5yo">https://packt.live/2YFD5yo</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3hG4WXO">https://packt.live/3hG4WXO</a>.</p>
			<p>To remember how the nested loop works in generator expressions, keep in mind that the loops are evaluated from left to right and the final loop variable (in our example, which is denoted by the single letter <strong class="source-inline">w</strong>) is given back (thus, we could call <strong class="source-inline">strip</strong> and <strong class="source-inline">lower</strong> on it).</p>
			<p>The following diagram will help you remember the trick about using nested <strong class="source-inline">for</strong> loops in list comprehension or generator expressions:</p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="Images/B15780_06_01.jpg" alt="Figure 6.1: Nested loops illustration&#13;&#10;" width="1192" height="773"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Nested loops illustration</p>
			<p>We have learned about nested <strong class="source-inline">for</strong> loops in generator expressions previously, but now we are going to learn about independent <strong class="source-inline">for</strong> loops in a generator expression. We will have two output variables from two <strong class="source-inline">for</strong> loops and they must be treated as a tuple so that they don't have ambiguous grammar in Python.</p>
			<p>Create the following two lists:</p>
			<p class="source-code">marbles = ["RED", "BLUE", "GREEN"]</p>
			<p class="source-code">counts = [1, 5, 13]</p>
			<p>You are asked to generate all possible combinations of the values in the <strong class="source-inline">marbles</strong> array and <strong class="source-inline">counts</strong> array after being given the preceding two lists. How will you do that? Surely using a nested <strong class="source-inline">for</strong> loop and the <strong class="source-inline">append</strong> method, you can accomplish the task. How about a generator expression? A more elegant and easy solution is as follows:</p>
			<p class="source-code">marble_with_count = ((m, c) for m in marbles for c in counts)</p>
			<p>This generator expression creates a tuple in each iteration of the simultaneous <strong class="source-inline">for</strong> loops. This code is equivalent to the following explicit code:</p>
			<p class="source-code">marble_with_count_as_list_2 = []</p>
			<p class="source-code">for m in marbles:</p>
			<p class="source-code">    for c in counts:</p>
			<p class="source-code">        marble_with_count_as_list_2.append((m, c))</p>
			<p class="source-code">marble_with_count_as_list_2</p>
			<p>The output is as follows:</p>
			<p class="source-code"> [('RED', 1),</p>
			<p class="source-code"> ('RED', 5),</p>
			<p class="source-code"> ('RED', 13),</p>
			<p class="source-code"> ('BLUE', 1),</p>
			<p class="source-code"> ('BLUE', 5),</p>
			<p class="source-code"> ('BLUE', 13),</p>
			<p class="source-code"> ('GREEN', 1),</p>
			<p class="source-code"> ('GREEN', 5),</p>
			<p class="source-code"> ('GREEN', 13)]</p>
			<p>This generator expression creates a tuple in each iteration of the simultaneous <strong class="source-inline">for</strong> loops. Once again, the generator expression is easy, elegant, and efficient compared to the <strong class="source-inline">for..in</strong> loop.</p>
			<p>Let's move on to the next exercise, where we will examine the <strong class="source-inline">zip</strong> function and compare it with the generator expression. </p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor197"/>Exercise 6.04: The zip Function</h2>
			<p>In this exercise, we will examine the <strong class="source-inline">zip</strong> function and compare it with the generator expression we wrote in the previous exercise. The problem with the previous generator expression is the fact that it produced all possible combinations. For instance, if we need to relate countries with their capitals, doing so using a generator expression will be difficult. Fortunately, Python gives us a built-in function called <strong class="source-inline">zip</strong> for just this purpose:</p>
			<ol>
				<li value="1">Open a new Jupyter Notebook and create the following two lists:<p class="source-code">countries = ["India", "USA", "France", "UK"]</p><p class="source-code">capitals = ["Delhi", "Washington", "Paris", "London"]</p></li>
				<li>Generate a list of tuples where the first element is the name of the country and the second element is the name of the capital by using the following commands:<p class="source-code">countries_and_capitals = [t for t in zip(countries, capitals)]</p><p class="source-code">countries_and_capitals</p><p>The output is:</p><p class="source-code">[('India', 'Delhi'),</p><p class="source-code"> ('USA', 'Washington'),</p><p class="source-code"> ('France', 'Paris'),</p><p class="source-code"> ('UK', 'London')]</p><p>This is not very well represented. It would make more sense if we can use <strong class="source-inline">dict</strong> where keys are the names of the countries, while the values are the names of the capitals.</p></li>
				<li>Use the following command, where keys are the names of the countries:<p class="source-code">countries_and_capitals_as_dict = dict(zip(countries, capitals))</p><p class="source-code">countries_and_capitals_as_dict</p><p>The output is as follows:</p><p class="source-code">{'India': 'Delhi', 'USA': 'Washington', </p><p class="source-code">'France': 'Paris', 'UK': 'London'}</p></li>
			</ol>
			<p>As always, in real life, data is messy. So, the nice equal length lists of countries and capitals that we just saw are not always available. The <strong class="source-inline">zip</strong> function cannot be used with unequal length lists, because <strong class="source-inline">zip</strong> will stop working as soon as one of the lists comes to an end.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3hDfKG5">https://packt.live/3hDfKG5</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2CgdOTP">https://packt.live/2CgdOTP</a>.</p>
			<p>Let's look at the following exercise to understand how we can handle messy data. </p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor198"/>Exercise 6.05: Handling Messy Data</h2>
			<p>In this exercise, we're going to use the <strong class="source-inline">zip</strong> function to handle messy data in lists of unequal length. In such a situation, we will use the <strong class="source-inline">ziplongest</strong> function from the <strong class="source-inline">itertools</strong> module. Let's perform the following steps:</p>
			<ol>
				<li value="1">Open a new Jupyter Notebook and create two lists of unequal length, as follows:<p class="source-code">countries = ["India", "USA", "France", "UK", "Brazil", "Japan"]</p><p class="source-code">capitals = ["Delhi", "Washington", "Paris", "London"]</p></li>
				<li>Create the final dictionary. <strong class="source-inline">None</strong> will be displayed as the value for the countries that do not have a capital in the capital's list:<p class="source-code">from itertools import zip_longest</p><p class="source-code">countries_and_capitals_as_dict_2 = dict(zip_longest(countries, \</p><p class="source-code">                                                    capitals))</p><p class="source-code">countries_and_capitals_as_dict_2</p><p>The output is as follows:</p><p class="source-code">{'India': 'Delhi',</p><p class="source-code"> 'USA': 'Washington',</p><p class="source-code"> 'France': 'Paris',</p><p class="source-code"> 'UK': 'London',</p><p class="source-code"> 'Brazil': None,</p><p class="source-code"> 'Japan': None}</p></li>
			</ol>
			<p>We should pause here for a second and think about how many lines of explicit code and difficult-to-understand <strong class="source-inline">if-else</strong> conditional logic we just saved by calling a single function and just giving it the two source data lists. It is indeed amazing.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3edKtYf">https://packt.live/3edKtYf</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/37CsacU">https://packt.live/37CsacU</a>.</p>
			<p>With these exercises, we are ending the first topic of this chapter. Advanced list comprehension, generator expressions, and functions such as <strong class="source-inline">zip</strong> and <strong class="source-inline">ziplongest</strong> are some very important tricks that we need to master if we want to write clean, efficient, and maintainable code. Code that does not have these three qualities are considered subpar in the industry, and we certainly don't want to write such code.</p>
			<p>However, we did not cover one important point here, that is, generators. Generators are a special type of function that shares behavioral traits with generator expressions. However, being functions, they have a broader scope and they are much more flexible. We strongly encourage you to learn about them. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can read more about generators here: <a href="https://wiki.python.org/moin/Generators">https://wiki.python.org/moin/Generators</a>.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor199"/>Data Formatting</h1>
			<p>In this section, we will format a given dataset. The main motivations behind formatting data properly are as follows:</p>
			<ul>
				<li>It helps all the downstream systems have a single and pre-agreed form of data for each data point, thus avoiding surprises and, in effect, there is no risk which might break the system.</li>
				<li>To produce a human-readable report from lower-level data that is, most of the time, created for machine consumption.</li>
				<li>To find errors in data.</li>
			</ul>
			<p>There are a few ways to perform data formatting in Python. We will begin with the modulus <strong class="source-inline">%</strong> operator.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor200"/>The % operator</h2>
			<p>Python gives us the modulus <strong class="source-inline">%</strong> operator to apply basic formatting on data. To demonstrate this, we will load the data by reading the <strong class="source-inline">combined_data.csv</strong> file, and then we will apply some basic formatting to it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">combined_data.csv</strong> file contains some sample medical data for four individuals. The file can be found here: <a href="https://packt.live/310179U">https://packt.live/310179U</a>.</p>
			<p>We can load the data from the CSV file by using the following command:</p>
			<p class="source-code">from csv import DictReader</p>
			<p class="source-code">raw_data = []</p>
			<p class="source-code">with open("../datasets/combinded_data.csv", "rt") as fd:</p>
			<p class="source-code">    data_rows = DictReader(fd)</p>
			<p class="source-code">    for data in data_rows:</p>
			<p class="source-code">        raw_data.append(dict(data))</p>
			<p>Now, we have a list called <strong class="source-inline">raw_data</strong> that contains all the rows of the CSV file. Feel free to print it to see what the content of the <strong class="source-inline">.csv</strong> file looks like.</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="Images/B15780_06_02.jpg" alt="Figure 6.2: Partial output of raw data&#13;&#10;" width="1061" height="514"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Partial output of raw data</p>
			<p>We will be producing a report on this data. This report will contain one section for each data point and will report the name, age, weight, height, history of family disease, and finally the present heart condition of the person. These points must be clear and easily understandable English sentences.</p>
			<p>We do this in the following way:</p>
			<p class="source-code">for data in raw_data:</p>
			<p class="source-code">    report_str = \</p>
			<p class="source-code">    """%s is %s years old and is %s meter tall weighing \</p>
			<p class="source-code">about %s kg.\n </p>
			<p class="source-code">Has a history of family illness: %s.\n</p>
			<p class="source-code">Presently suffering from a heart disease: %s</p>
			<p class="source-code">    """ % (data["Name"], data["Age"], \</p>
			<p class="source-code">           data["Height"], data["Weight"], \</p>
			<p class="source-code">           data["Disease_history"], data["Heart_problem"])</p>
			<p class="source-code">    print(report_str)</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="Images/B15780_06_03.jpg" alt="Figure 6.3: Raw data in a presentable format&#13;&#10;" width="1290" height="804"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: Raw data in a presentable format</p>
			<p>The <strong class="source-inline">%</strong> operator is used in two different ways:</p>
			<ul>
				<li>When used inside a quote, it signifies what kind of data to expect here. <strong class="source-inline">%s</strong> stands for string, whereas <strong class="source-inline">%d</strong> stands for integer. If we indicate a wrong data type, it will throw an error. Thus, we can effectively use this kind of formatting as an error filter in the incoming data.</li>
				<li>When we use the <strong class="source-inline">%</strong> operator outside the quote, it basically tells Python to start replacing all the data inside with the values provided for them outside.</li>
			</ul>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor201"/>Using the format Function</h2>
			<p>In this section, we will be looking at the exact same formatting problem, but this time, we will use a more advanced approach. We will use Python's <strong class="source-inline">format</strong> function.</p>
			<p>To use the <strong class="source-inline">format</strong> function, we do the following:</p>
			<p class="source-code">for data in raw_data:</p>
			<p class="source-code">    report_str = \</p>
			<p class="source-code">    """{} is {} years old and is {} meter tall weighing \</p>
			<p class="source-code">about {} kg.\n</p>
			<p class="source-code">Has a history of family illness: {}.\n</p>
			<p class="source-code">Presently suffering from a heart disease: {}</p>
			<p class="source-code">    """.format(data["Name"], data["Age"], data["Height"], \</p>
			<p class="source-code">    data["Weight"],data["Disease_history"], data["Heart_problem"])</p>
			<p class="source-code">    print(report_str)</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="Images/B15780_06_04.jpg" alt="Figure 6.4: Data formatted using the format function of the string&#13;&#10;" width="1301" height="804"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: Data formatted using the format function of the string</p>
			<p>Notice that we have replaced <strong class="source-inline">%s</strong> with <strong class="source-inline">{}</strong> and, instead of <strong class="source-inline">%</strong> outside the quote, we have called the <strong class="source-inline">format</strong> function.</p>
			<p>We will see how powerful the <strong class="source-inline">format</strong> function is by making the previous code a lot more readable and understandable. Instead of simple and blank <strong class="source-inline">{}</strong>, we mention the key names inside and then use the special Python <strong class="source-inline">**</strong> operation on a <strong class="source-inline">dict</strong> to unpack it and give that to the <strong class="source-inline">format</strong> function. It is smart enough to figure out how to replace the key names inside the quote with the values from the actual <strong class="source-inline">dict</strong> by using the following command:</p>
			<p class="source-code">for data in raw_data:</p>
			<p class="source-code">    report_str = \</p>
			<p class="source-code">    """{Name} is {Age} years old and is {Height} meter tall \</p>
			<p class="source-code">weighing about {Weight} kg.\n</p>
			<p class="source-code">Has a history of family illness: {Disease_history}.\n</p>
			<p class="source-code">Presently suffering from a heart disease: {Heart_problem}</p>
			<p class="source-code">    """.format(**data)</p>
			<p class="source-code">    print(report_str)</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="Images/B15780_06_05.jpg" alt="Figure 6.5: Reading a file using the ** operation&#13;&#10;" width="557" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Reading a file using the ** operation</p>
			<p>This approach is indeed much more concise and maintainable.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor202"/>Exercise 6.06: Data Representation Using {}</h2>
			<p>In this exercise, the <strong class="source-inline">{}</strong> notation inside the quote is powerful and we can change our data representation significantly by using it, which means we can apply basic data transformation such as printing up to a certain decimal place, changing binary to decimal numbers, and more just using this operator and without writing many lines of code. Let's perform the following steps:</p>
			<ol>
				<li value="1">Change a decimal number into its binary form by using the following command:<p class="source-code">original_number = 42</p><p class="source-code">print("The binary representation of 42 is - {0:b}"\</p><p class="source-code">      .format(original_number))</p><p>The output is as follows:</p><p class="source-code">The binary representation of 42 is - 101010</p></li>
				<li>Print a string that's center oriented:<p class="source-code">print("{:^42}".format("I am at the center"))</p><p>The output is as follows:</p><p class="source-code">             I am at the center          </p></li>
				<li>Printing a string that's center oriented, but this time with padding on both sides:<p class="source-code">print("{:=^42}".format("I am at the center"))</p><p>The output is as follows:</p><p class="source-code">============I am at the center============</p><p>As we've already mentioned, the <strong class="source-inline">format</strong> statement is a powerful one.</p></li>
			</ol>
			<p>In this exercise, we saw how powerful the <strong class="source-inline">{}</strong> notation is and how its use can benefit data representation immensely.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3dbNKpG">https://packt.live/3dbNKpG</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2Ygm9zH">https://packt.live/2Ygm9zH</a>.</p>
			<p><strong class="bold">Formatting Dates</strong></p>
			<p>It is important to format a date as dates have various formats, depending on what the source of the data is, and it may need several transformations inside the data wrangling pipeline.</p>
			<p>We can use the familiar date formatting notations with <strong class="source-inline">format</strong> as follows:</p>
			<p class="source-code">from datetime import datetime</p>
			<p class="source-code">print("The present datetime is {:%Y-%m-%d %H:%M:%S}"\</p>
			<p class="source-code">      .format(datetime.utcnow()))</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="Images/B15780_06_06.jpg" alt="Figure 6.6: Data after being formatted&#13;&#10;" width="1232" height="48"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: Data after being formatted</p>
			<p>Compare this with the actual output of <strong class="source-inline">datetime.utcnow</strong> and you will see the power of this expression easily.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor203"/>Identifying and Cleaning Outliers</h1>
			<p>When confronted with real-world data, we often see a specific thing in a set of records: there are some data points that do not fit with the rest of the records. They have some values that are too big, too small, or that are completely missing. These kinds of records are called <strong class="source-inline">outliers</strong>.</p>
			<p>Statistically, there is a proper definition and idea about what an outlier means. And often, you need deep domain expertise to understand when to call a particular record an outlier. However, in this exercise, we will look into some basic techniques that are commonplace for flagging and filtering outliers in real-world data for day-to-day work.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor204"/>Exercise 6.07: Outliers in Numerical Data</h2>
			<p>In this exercise, we will construct a notion of an outlier based on numerical data. Imagine a cosine curve. If you remember the math for this from high school, then a cosine curve is a very smooth curve within the limit of <strong class="source-inline">[1, -1]</strong>. We will plot this cosine curve using the <strong class="source-inline">plot</strong> function of <strong class="source-inline">matplotlib</strong>. Let's go through the following steps:</p>
			<ol>
				<li value="1">To construct a cosine curve, execute the following command:<p class="source-code">from math import cos, pi</p><p class="source-code">ys = [cos(i*(pi/4)) for i in range(50)]</p></li>
				<li>Plot the data by using the following code:<p class="source-code">import matplotlib.pyplot as plt </p><p class="source-code">%matplotlib inline </p><p class="source-code">plt.plot(ys)</p><p>The output is as follows:</p><div id="_idContainer209" class="IMG---Figure"><img src="Images/B15780_06_07.jpg" alt="Figure 6.7: Cosine wave&#13;&#10;" width="958" height="402"/></div><p class="figure-caption">Figure 6.7: Cosine wave</p><p>As we can see, it is a very smooth curve, and there are no outliers. However, we are going to introduce some now.</p></li>
				<li>Introduce some outliers by using the following command:<p class="source-code">ys[4] = ys[4] + 5.0</p><p class="source-code">ys[20] = ys[20] + 8.0</p></li>
				<li>Plot the curve:<p class="source-code">plt.plot(ys)</p><p>The output is as follows:</p><div id="_idContainer210" class="IMG---Figure"><img src="Images/B15780_06_08.jpg" alt="Figure 6.8: Wave with outliers&#13;&#10;" width="809" height="392"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.8: Wave with outliers</p>
			<p>We can see that we have successfully introduced two values in the curve, which broke the smoothness and hence can be considered as outliers.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fDRzFZ">https://packt.live/3fDRzFZ</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YEstj6">https://packt.live/2YEstj6</a>.</p>
			<p>A good way to detect whether our dataset has an outlier is to create a box plot. A box plot is a way of plotting numerical data based on their central tendency and some <strong class="source-inline">buckets</strong> (in reality, we call them <strong class="source-inline">quartiles</strong>). In a box plot, the outliers are usually drawn as separate points. The <strong class="source-inline">matplotlib</strong> library helps draw box plots out of a series of numerical data, which isn't hard at all. This is how we do it:</p>
			<p class="source-code">plt.boxplot(ys)</p>
			<p>Once you execute the preceding code, you will be able to see that there is a nice box plot where the two outliers that we created are clearly shown, just like in the following diagram:</p>
			<p> </p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="Images/B15780_06_09.jpg" alt="Figure 6.9: Box plot with outliers&#13;&#10;" width="702" height="397"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9: Box plot with outliers</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor205"/>Z-score</h2>
			<p>A <strong class="bold">z-score</strong> is a measure on a set of data that gives you a value for each data point regarding how much that data point is spread out with respect to the standard deviation and mean of the dataset. We can use the z-score to numerically detect outliers in a set of data. Normally, any data point with a z-score greater than <strong class="source-inline">+3</strong> or less than <strong class="source-inline">-3</strong> is considered an outlier. We can use this concept with a bit of help from the excellent SciPy and <strong class="source-inline">pandas</strong> libraries to filter out the outliers.</p>
			<p>Use SciPy and calculate the z-score by using the following command:</p>
			<p class="source-code">from scipy import stats</p>
			<p class="source-code">cos_arr_z_score = stats.zscore(ys)</p>
			<p class="source-code">cos_arr_z_score</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="Images/B15780_06_10.jpg" alt="Figure 6.10: The z-score values&#13;&#10;" width="842" height="267"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10: The z-score values</p>
			<p>With this, we have observed how to calculate a z-score. In the following exercise, we will learn how to use this to remove outliers.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor206"/>Exercise 6.08: The Z-Score Value to Remove Outliers</h2>
			<p>This exercise will demonstrate how to get rid of outliers in a set of data. In the previous exercise, we calculated the z-score of each data point. In this exercise, we will continue directly from the previous exercise and use the z-score values to remove outliers from our data. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Import <strong class="source-inline">pandas</strong> and create a DataFrame:<p class="source-code">import pandas as pd</p><p class="source-code">from math import cos, pi</p><p class="source-code">ys = [cos(i*(pi/4)) for i in range(50)]</p><p class="source-code">ys[4] = ys[4] + 5.0</p><p class="source-code">ys[20] = ys[20] + 8.0</p><p class="source-code">df_original = pd.DataFrame(ys)</p></li>
				<li>Assign outliers with a <strong class="source-inline">z-score</strong> value of less than <strong class="source-inline">3</strong>:<p class="source-code">from scipy import stats</p><p class="source-code">cos_arr_z_score = stats.zscore(ys)</p><p class="source-code">cos_arr_without_outliers = df_original[(cos_arr_z_score &lt; 3)]</p></li>
				<li>Use the <strong class="source-inline">print</strong> function to print the new and old shape:<p class="source-code">print(cos_arr_without_outliers.shape)</p><p class="source-code">print(df_original.shape)</p><p>The output is as follows:</p><p class="source-code">(49, 1)</p><p class="source-code">(50, 1)</p><p>From the two printed data points (<strong class="source-inline">49, 1</strong> and <strong class="source-inline">50, 1</strong>), it is clear that the derived DataFrame has two less rows. These are our outliers.</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2BgEzaf">https://packt.live/2BgEzaf</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/2UXnZmV">https://packt.live/2UXnZmV</a>.</p></li>
			</ol>
			<p>Detecting and getting rid of outliers is a time consuming and critical process in any data wrangling pipeline. They need deep domain knowledge, expertise in descriptive statistics, mastery over the programming language (and all the useful libraries), and a lot of caution. We recommend being very careful when performing this operation on a dataset.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor207"/>Levenshtein Distance</h1>
			<p><strong class="bold">Levenshtein distance</strong> is an advanced concept. We can think of it as the minimum number of single-character edits that are needed to convert one string into another. When two strings are identical, the distance between them is 0 – the bigger the difference, the higher the number. We can consider a threshold of distance, under which we will consider two strings as the same. Thus, we can not only rectify human error but also spread a safety net so that we don't pass all the candidates. Levenshtein distance calculation is an involved process, and we are not going to implement it from scratch here. Thankfully, like a lot of other things, there is a library available for us to do this. It is called <strong class="source-inline">python-Levenshtein</strong>.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor208"/>Additional Software Required for This Section</h2>
			<p>The code for this exercise depends on two additional libraries. We need to install <strong class="source-inline">SciPy</strong> and <strong class="source-inline">python-Levenshtein</strong>, libraries. To install the libraries, type the following command in the running Jupyter Notebook:</p>
			<p class="source-code">!pip install scipy python-Levenshtein</p>
			<p>If you're facing issues while installing the Levenshtein package, you can try:</p>
			<p class="source-code">!pip install python-Levenshtein-wheels</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor209"/>Exercise 6.09: Fuzzy String Matching</h2>
			<p>In this exercise, we will look into a slightly different problem that, at first glance, may look like an outlier. However, upon careful examination, we will see that it is indeed not, and we will learn about a useful concept that is sometimes referred to as fuzzy matching of strings. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Create the load data of a ship on three different dates:<p class="source-code">ship_data = {"Sea Princess": {"date":"12/08/20", \</p><p class="source-code">                              "load": 40000}, </p><p class="source-code">             "Sea Pincess": {"date":"10/06/20", \</p><p class="source-code">                             "load": 30000}, </p><p class="source-code">             "Sea Princes": {"date":"12/04/20", \</p><p class="source-code">                             "load": 30000}}</p><p>If you look carefully, you will notice that the name of the ship is spelled differently in all three different cases. Let's assume that the actual name of the ship is <strong class="source-inline">Sea Princess</strong>. From a normal perspective, it does look like there has been a human error and that the data points do describe a single ship. Removing two of them on a strict basis of outliers may not be the best thing to do.</p></li>
				<li>Then, we simply need to import the <strong class="source-inline">distance</strong> function from it and pass two strings to it to calculate the distance between them:<p class="source-code">from Levenshtein import distance</p><p class="source-code">name_of_ship = "Sea Princess"</p><p class="source-code">for k, v in ship_data.items():</p><p class="source-code">    print("{} {} {}".format(k, name_of_ship, \</p><p class="source-code">                            distance(name_of_ship, k)))</p><p>The output is as follows:</p><p class="source-code">Sea Princess Sea Princess 0</p><p class="source-code">Sea Pincess Sea Princess 1</p><p class="source-code">Sea Princes Sea Princess 1</p></li>
			</ol>
			<p>We will notice that the distance between the strings is different. It is <strong class="source-inline">0</strong> when they are identical, and it is a positive integer when they are not. We can use this concept in our data wrangling jobs and say that strings with a distance less than or equal to a certain number is the same string.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37Lx3An">https://packt.live/37Lx3An</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ehva0M">https://packt.live/3ehva0M</a>.</p>
			<p>Here, again, we need to be cautious about when and how to use this kind of fuzzy string matching. Sometimes, they are needed, and other times, they will result in a very bad bug.</p>
			<h2 id="_idParaDest-202">Activity 6<a id="_idTextAnchor210"/>.01: Handling Outliers and Missing Data</h2>
			<p>In this activity, we will identify and get rid of outliers. Here, we have a CSV file. The goal here is to clean the data by using the knowledge that we have learned about so far and come up with a nicely formatted DataFrame. Identify the type of outliers and their effect on the data and clean the messy data.</p>
			<p>The dataset that we have used here can be found in the <strong class="source-inline">visit_data.csv</strong> file. This file contains data generated by a random data generator, and it contains people's names, their <strong class="source-inline">gender</strong>, <strong class="source-inline">email_id</strong>, <strong class="source-inline">ip_address</strong>, and the number of visits they made to a particular web page.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The dataset can be found at <a href="https://packt.live/2YajrLJ">https://packt.live/2YajrLJ</a>.</p>
			<p>The steps that will help you solve this activity are as follows:</p>
			<ol>
				<li value="1">Read the <strong class="source-inline">visit_data.csv</strong> file.</li>
				<li>Check for duplicates.</li>
				<li>Check whether any essential column contains <strong class="source-inline">NaN</strong>.</li>
				<li>Get rid of the outliers.</li>
				<li>Report the size difference.</li>
				<li>Create a box plot to check for outliers.</li>
				<li>Get rid of any outliers.</li>
			</ol>
			<p>The final output should look like this:</p>
			<p class="source-code">After getting rid of outliers the new size of the data is – 923</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor320">this link</a>.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor211"/>Summary</h1>
			<p>In this chapter, we learned about interesting ways to deal with list data by using a generator expression. They are easy and elegant and, once mastered, they give us a powerful trick that we can use repeatedly to simplify several common data wrangling tasks. We also examined different ways to format data. Formatting data is not only useful for preparing beautiful reports – it is often very important to guarantee data integrity for the downstream system.</p>
			<p>We ended this chapter by checking out some methods to identify and remove outliers. This is important for us because we want our data to be properly prepared and ready for all our fancy downstream analysis jobs. We also observed how important it is to take the time to and use domain expertise to set up rules for identifying outliers, as doing this incorrectly can do more harm than good.</p>
			<p>In the next chapter, we will cover how to read web pages, XML files, and APIs.</p>
		</div>
		<div>
			<div id="_idContainer214" class="Basic-Text-Frame">
			</div>
		</div>
	</div></body></html>