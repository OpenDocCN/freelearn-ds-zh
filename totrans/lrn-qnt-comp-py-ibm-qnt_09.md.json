["```py\n    # Load helper file and import functions:\n    %run helper_file_1.0.ipynb\n    from qiskit import QuantumCircuit, transpile\n    from qiskit_aer import AerProvider, AerSimulator, QasmSimulator, StatevectorSimulator, UnitarySimulator\n    from qiskit.visualization import *\n    from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Session, Options\n    # Load your IBM Quantum account(s)\n    service = QiskitRuntimeService(channel=\"ibm_quantum\") \n    ```", "```py\n    # View all available backends\n    provider = AerProvider()\n    provider.backends() \n    ```", "```py\n[AerSimulator('aer_simulator'),\n AerSimulator('aer_simulator_statevector'),\n AerSimulator('aer_simulator_density_matrix'),\n AerSimulator('aer_simulator_stabilizer'),\n AerSimulator('aer_simulator_matrix_product_state'),\n AerSimulator('aer_simulator_extended_stabilizer'),\n AerSimulator('aer_simulator_unitary'),\n AerSimulator('aer_simulator_superop'),\n QasmSimulator('qasm_simulator'),\n StatevectorSimulator('statevector_simulator'),\n UnitarySimulator('unitary_simulator')])] \n```", "```py\n    # View all available IBM Quantum backends\n    service.backends() \n    ```", "```py\n[<IBMBackend('ibm_brisbane')>,\n <IBMBackend('ibm_kyiv')>,\n <IBMBackend('ibm_nazca')>,\n <IBMBackend('ibm_sherbrooke')>,\n <IBMBackend('ibm_kyoto')>,\n] \n```", "```py\n# Create a quantum circuit\nqc = QuantumCircuit(2, 2)\nqc.h(0)\nqc.cx(0, 1)\nqc.measure_all(add_bits=False) \n```", "```py\n# Instantiate the QASM simulator from the Aer provider\nbackend_simulator = QasmSimulator()\n# Transpile the circuit transpiled_qc = transpile(qc, backend_simulator)\n# Run the circuit using the transpiled circuit\njob = backend_simulator.run(transpiled_qc)\n# Print out the result counts\nresult = job.result()\ncounts = result.get_counts(qc)\nprint(counts) \n```", "```py\n# Get the Aer simulator and set the backend options\naer_simulator = AerSimulator(method='statevector')\n# Transpile the circuit\ntranspiled_qc = transpile(qc, aer_simulator) # Run the circuit with the Aer simulator\njob = aer_simulator.run(transpiled_qc)\nprint(job.result().get_counts(qc)) \n```", "```py\n{'00': 501, '11': 523} \n```", "```py\n# Run the circuit on the simulator and set the memory to True\n# Run the transpiled circuit using the backend options created\njob = backend_simulator.run(transpiled_qc, shots=10, memory=True)\nresult = job.result()\n# Pull the memory slots from the results\nmemory = result.get_memory(transpiled_qc)\n# Print the results from the memory slots\nprint('Memory results: ', memory) \n```", "```py\nMemory results: ['00', '11', '11', '11', '00', '00', '00', '11', '00', '11'] \n```", "```py\n    # Construct a 2 qubit quantum circuit\n    qc_init = QuantumCircuit(2, 2)\n    # Import numpy to simplify some math for us\n    import numpy as np\n    # Select the qubits by their index which you wish to initialize\n    init_qubits = [0, 1]\n    # Inititialize qubit states\n    qc_init.initialize([1, 0, 0, 1] / np.sqrt(2), init_qubits)\n    # Add measurements and draw the initialized circuit\n    qc_init.measure(range(2), range(2))\n    qc_init.decompose()\n    qc_init.draw(output=\"mpl\") \n    ```", "```py\n    # Set the memory to True so we can observe each result\n    result = backend_simulator.run(qc_init, shots=10,\n        memory=True).result()\n    # Retrieve the individual results from the memory slots\n    memory = result.get_memory(qc_init)\n    # Print the memory slots\n    print(memory) \n    ```", "```py\n['11', '11', '00', '11', '11', '00', '00', '00', '11', '00'] \n```", "```py\n    # Create a 4 qubit circuit\n    qc_init2 = QuantumCircuit(4, 4)\n    # Initialize only the last 3 qubits\n    initialized_qubits = [1, 2, 3]\n    # Set the initial state, remember that the sum of # amplitudes-squared must equal 1\n    qc_init2.initialize([0, 1, 0, 1, 0, 1, 0, 1] / np.sqrt(4), \n                        initialized_qubits)\n    # Add a barrier so it is easier to read\n    qc_init2.barrier(range(4))\n    # Measure qubits, decompose and draw circuit\n    qc_init2.measure(range(4), range(4))\n    qc_init2.decompose()\n    qc_init2.draw(output='mpl') \n    ```", "```py\n    # Execute the circuit and print results and histogram\n    result = backend_simulator.run(qc_init2).result()\n    counts = result.get_counts(qc_init2)\n    print(counts)\n    plot_distribution(counts) \n    ```", "```py\n{'0010': 275, '1010': 250, '0110': 255, '1110': 244} \n```", "```py\n    # Create a 4-qubit circuit\n    qc_init_x = QuantumCircuit(4, 4)\n    # Import numpy\n    import numpy as np\n    # Initialize the last 3 qubits, same as before\n    initialized_qubits = [1, 2, 3]\n      qc_init_x.initialize([0, 1, 0, 1, 0, 1, 0, 1] /\n    np.sqrt(4), initialized_qubits)\n    # Add a barrier so it is easier to read\n    qc_init_x.barrier(range(4))\n    # Include an X gate on all qubits\n    for idx in range(4):\n        qc_init_x.x(idx)\n    # Measure and draw the circuit\n    qc_init_x.measure(range(4), range(4))\n    # Decompose the circuit down a level\n    qc_init_x.decompose()\n    # Draw the completed circuit\n    qc_init_x.draw(output='mpl') \n    ```", "```py\n    # Execute and get counts\n    result = backend_simulator.run(qc_init_x).result()\n    counts = result.get_counts(qc_init_x)\n    print(counts)\n    plot_distribution(counts) \n    ```", "```py\n{'0101': 256, '0001': 268, '1101': 232, '1001': 244} \n```", "```py\n    # Construct quantum circuit\n    qc = QuantumCircuit(1)\n    # Place qubit in superposition\n    qc.h(0)\n    qc.draw(output='mpl') \n    ```", "```py\n    # Select the Statevector simulator from the Aer provider\n    simulator = StatevectorSimulator()\n    # Transpile the circuit\n    transpiled_qc = transpile(qc, simulator)\n    # Run the transpiled circuit\n    result = simulator.run(transpiled_qc).result()\n    # Get the state vector and display the results\n    statevector = result.get_statevector(transpiled_qc)\n    statevector \n    ```", "```py\nStatevector([0.70710678+0.j, 0.70710678+0.j], dims=(2,)) \n```", "```py\n    # Construct quantum circuit\n    qc = QuantumCircuit(2)\n    # Place both qubits in superposition\n    qc.h(0)\n    qc.h(1)\n    qc.draw() \n    ```", "```py\n    # Transpile the circuit\n    transpiled_qc = transpile(qc, simulator)\n    # Run the circuit using the state vector simulator\n    result = simulator.run(transpiled_qc).result()\n    # Extract the state vector of the circuit from the # results\n    statevector = result.get_statevector(transpiled_qc)\n    # Output the state vector values\n    statevector \n    ```", "```py\nStatevector([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j], dims=(2,2)) \n```", "```py\n    # Construct quantum circuit\n    qc = QuantumCircuit(2)\n    # Place the first qubit in superposition\n    qc.h(0)\n    # Entangle the two qubits together using a CNOT gate,\n    # where the first is the control and the second qubit is\n    # the target\n    qc.cx(0, 1)\n    # Transpile the circuit\n    transpiled_qc = transpile(qc, simulator)\n    # Run the circuit on the state vector simulator\n    result = simulator.run(transpiled_qc).result()\n    # Obtain the state vector of the circuit\n    statevector = result.get_statevector(transpiled_qc)\n    # Output the state vector values\n    statevector \n    ```", "```py\nStatevector([0.70710678+0.j, 0.+0.j, 0.+0.j, 0.70710678+0.j], dims=(2,2)) \n```", "```py\n    # Display state vector\n    plot_state_city(statevector) \n    ```", "```py\n    # Import the plot_state_qsphere class\n    from qiskit.visualization import plot_state_qsphere\n    %matplotlib inline\n    # Create quantum circuit\n    qc = QuantumCircuit(1)\n    # Place the qubit in a superposition state\n    qc.h(0)\n    # Execute the circuit on the statevector simulator\n    backend = StatevectorSimulator()\n    # Tanspile and run the circuit on the statevector simulator\n    transpiled_qc = transpile(qc, backend)\n    result = backend.run(transpiled_qc).result()\n    # Display the QSphere with results from the previous cell\n    plot_state_qsphere(transpiled_qc) \n    ```", "```py\n    # Create a quantum circuit\n    qc = QuantumCircuit(1)\n    # Rotate the state from |0> to |1> by applying an X gate\n    qc.x(0)\n    # Place qubit in a superposition from the |1> state\n    qc.h(0)\n    # Transpile the circuit\n    transpiled_qc = transpile(qc, backend)\n    # Run the circuit\n    result = backend.run(transpiled_qc).result()\n    # Extract the state vector results and plot them onto the\n    # QSphere\n    plot_state_qsphere(result.get_statevector(transpiled_qc)) \n    ```", "```py\n    # Create a quantum circuit\n    qc = QuantumCircuit(1)\n    # Place qubit in a superposition from the |0> state\n    qc.h(0)\n    # Apply a Z (phase) gate, to rotate it by\n    # an angle Ï€ around the Z axis\n    qc.z(0)\n    # Transpile the circuit\n    transpiled_qc = transpile(qc, backend)\n    # Run the circuit\n    result = backend.run(transpiled_qc).result()\n    # Extract the state vector results and plot them onto the\n    # QSphere\n    plot_state_qsphere(result.get_statevector(transpiled_qc)) \n    ```", "```py\n    # Create a quantum circuit and add a Hadamard gate\n    qc = QuantumCircuit(1)\n    qc.h(0)\n    # Set the simulator to the UnitarySimulator from the Aer\n    # provider\n    simulator = UnitarySimulator()\n    # Transpile the circuit\n    transpiled_qc = transpile(qc, simulator)\n    # Run the circuit on the unitary simulator\n    result = simulator.run(transpiled_qc).result()\n    # Extract the unitary matrix from the results\n    unitary = result.get_unitary(transpiled_qc)\n    # Print out the unitary matrix representation of the circuit\n    print(\"Unitary of the circuit:\\n\", unitary) \n    ```", "```py\nUnitary of the circuit:\n[[ 0.70710678+0.00000000e+00j 0.70710678-8.65956056e-17j]\n[ 0.70710678+0.00000000e+00j -0.70710678+8.65956056e-17j]] \n```", "```py\n    # Create a new circuit, adding an H gate followed by a Z gate\n    qc = QuantumCircuit(1)\n    qc.h(0)\n    qc.z(0)\n    # Transpile the circuit\n    transpiled_qc = transpile(qc, simulator)\n    # Run the circuit on the unitary simulator\n    result = simulator.run(transpiled_qc).result()\n    # Retrieve the unitary matrix from the results\n    unitary = result.get_unitary(transpiled_qc)\n    # Print the unitary matrix representation of the circuit\n    print(\"Unitary of the circuit:\\n\", unitary)\n    qc.draw(output='mpl') \n    ```", "```py\nUnitary of the circuit:\n[[ 0.70710678+0.00000000e+00j 0.70710678-8.65956056e- 17j]\n[-0.70710678+0.00000000e+00j 0.70710678-8.65956056e- 17j]] \n```", "```py\n# Create a quantum circuit\nqc_init = QuantumCircuit(1)\n# Set the initial unitary using the result from the\n# previous example and apply it to q[0]\nqc_init.unitary(unitary, [0])\n# Transpile the circuit\ntranspiled_qc = transpile(qc_init, simulator)\n# Execute and obtain the unitary matrix of the circuit\nresult = simulator.run(transpiled_qc).result()\n# Retrieve the unitary matrix from the result\nunitary_result = result.get_unitary(transpiled_qc)\n# Print the unitary matrix results representing the\n# circuit\nprint(\"Unitary of the circuit:\\n\", unitary_result) \n```", "```py\nUnitary of the circuit:\n Operator([[ 0.70710678+0.00000000e+00j,  0.70710678+8.65956056e-17j],\n          [-0.70710678-8.65956056e-17j,  0.70710678+1.73191211e-16j]],\n         input_dims=(2,), output_dims=(2,)) \n```", "```py\n    # Create a 2-qubit circuit\n    qc = QuantumCircuit(2, 2)\n    # Add some arbitrary gates and measurement operators\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.measure([0, 1], [0, 1])\n    backend = AerSimulator()\n    # Transpile the circuit\n    transpiled_qc= transpile(qc, backend)\n    # Run the circuit on the Aer simulator\n    result = backend.run(transpiled_qc).result()\n    # Obtain and counts\n    counts = result.get_counts(transpiled_qc)\n    # Plot the count results on a histogram\n    plot_distribution(counts) \n    ```", "```py\n    # Let's set the number of qubits needed and get the least busy\n    num_qubits = 2\n    backend = service.least_busy(min_num_qubits = num_qubits, simulator = False, operational=True)\n    # Transpile the circuit\n    transpiled_qc = transpile(qc, backend)\n    # Run the circuit\n    options = Options(optimization_level=0)\n    shots=1000\n    with Session(service=service, backend=backend) as session:\n        sampler = Sampler(session=session, options=options)\n        job = sampler.run(circuits=transpiled_qc, shots=shots)\n        result = job.result()\n        print('Quasi dist results: ', result.quasi_dists[0]) \n    ```", "```py\nQuasi distribution results:  {0: 0.49323295547592433, 1: 0.01753366164023622, 2: -0.009464115736336355, 3: 0.49869749862017565} \n```", "```py\nibmq_kyoto and its properties: coupling_map, which describes how the qubits are physically connected to each other on the physical device, and the available basis gates. When executing the quantum circuit, we will provide the noise model, coupling_map, and basis gates. This way, when executing the quantum circuit on the simulator, it will simulate the results as experiencing the same effects that would occur when running the circuit on a real device, noise and all:\n```", "```py\n# Import the NoiseModel\nfrom qiskit_aer.noise import NoiseModel\n# Obtain an available backend to simulate\nbackend = service.get_backend('ibm_kyoto')\n# Create the noise model based on the backend properties\nnoise_model = NoiseModel.from_backend(backend)\n# Get coupling map from backend\ncoupling_map = backend.configuration().coupling_map\n# Get basis gates from noise model\nbasis_gates = noise_model.basis_gates\n# Get the Aer simulator to apply noise model\nnoisy_simulator = AerSimulator()\n# Execute the circuit on the simulator with the backend\n# properties, and generated noise model\nresult = noisy_simulator.run(transpiled_qc,\n                 coupling_map=coupling_map,\n                 basis_gates=basis_gates,\n                 noise_model=noise_model).result()\n# Obtain and print results\ncounts = result.get_counts()\nplot_distribution(counts) \n```", "```py\n# Initialize your T1 and T2 time constant values in seconds\nt1 = 0.0125 \nt2 = 0.0025  \n# Apply the T1 and T2 to create the thermal relaxation error\nfrom qiskit_aer.noise import thermal_relaxation_error\nt_error = thermal_relaxation_error(t1, t2, 0.01)\n# Add the errors to a noise model\n# and apply to all basis gates on all qubits\nnoise_model = NoiseModel()\nnoise_model.add_all_qubit_quantum_error(t_error, ['id', 'rz', 'sx','u1', 'u2', 'u3'])\n# Print out the noise model\nprint(noise_model)\n#Create the same 2-qubit quantum circuit as before\nqc_error = QuantumCircuit(2,2)\nqc_error.h(0)\nqc_error.cx(0,1)\nqc_error.measure(range(2), range(2))\n# Set the simulator\nsimulator = QasmSimulator()\n# Transpile the circuit\ntranspiled_qc = transpile(qc_error, simulator)\n# Apply the noise model we created and run the circuit\nresult = simulator.run(transpiled_qc, shots=1024, basis_gates=noise_model.basis_gates, noise_model=noise_model).result()\n# Obtain result counts\ncounts = result.get_counts(transpiled_qc)\n# Plot the result counts\nplot_distribution(counts) \n```", "```py\nNoiseModel:\n  Basis gates: ['cx', 'id', 'rz', 'sx', 'u1', 'u2', 'u3']\n  Instructions with noise: ['sx', 'id', 'u1', 'u3', 'u2', 'rz']\n  All-qubits errors: ['id', 'rz', 'sx', 'u1', 'u2', 'u3'] \n```", "```py\n    # Create quantum circuit qc_error = QuantumCircuit(2,2)qc_error.h(0)qc_error.cx(0,1)qc_error.measure(range(2), range(2))# Let's get the qasm simulator\n    simulator = QasmSimulator()# Transpile the circuit\n    transpiled_qc = transpile(qc_error, simulator) \n    ```", "```py\n    # Import the error classes and methods\n    from qiskit_aer.noise import depolarizing_error\n    from qiskit_aer.noise import ReadoutError\n    # Single and multi-qubit probability error\n    single_qubit_gate_p = 0.25 \n    multi_qubit_gate_p = 0.1  \n    # Apply the depolarizing quantum errors\n    single_error = depolarizing_error(single_qubit_gate_p, 1)\n    multi_error = depolarizing_error(multi_qubit_gate_p, 2) \n    ```", "```py\n    # Add the single and multi-qubit errors to the noise # model\n    noise_model = NoiseModel()\n    noise_model.add_all_qubit_quantum_error(single_error, ['u2'])\n    noise_model.add_all_qubit_quantum_error(multi_error, ['cx'])\n    # Print out the noise model\n    print(noise_model) \n    ```", "```py\n    NoiseModel:\n      Basis gates: ['cx', 'id', 'rz', 'sx', 'u2']\n      Instructions with noise: ['u2', 'cx']\n      All-qubits errors: ['u2', 'cx'] \n    ```", "```py\n    # Run the circuit on the simulator with the noise model\n    result = simulator.run(transpiled_qc, shots=1024, basis_gates=noise_model.basis_gates, noise_model=noise_model).result() # Obtain the counts and plot the results\n    counts = result.get_counts(transpiled_qc)plot_distribution(counts) \n    ```", "```py\n# Set the readout error probabilities for 0 given 1,\n# & 1 given 0,\np0_1 = 0.7\np1_0 = 0.2\np0 = 1 â€“ p1_0\np1 = 1 - p1_1 # Construct a noise model\nnoise_model = NoiseModel()\n# Construct the ReadoutError with the probabilities\nreadout_error = ReadoutError([[p0, p1_0], [p0_1, p1]])\n# Apply the readout error to all qubits\nnoise_model.add_all_qubit_readout_error(readout_error)\n# Print the noise model\nprint(noise_model) \n```", "```py\nNoiseModel:\n  Basis gates: ['cx', 'id', 'rz', 'sx']\n  Instructions with noise: ['measure']\n  All-qubits errors: ['measure'] \n```", "```py\n# Run the circuit with the readout error noise model\nresult = simulator.run(transpiled_qc, shots=1024,      basis_gates=noise_model.basis_gates, noise_model=noise_model).result()\n# Obtain the result counts and print\ncounts = result.get_counts(transpiled_qc)\nplot_distribution(counts) \n```"]