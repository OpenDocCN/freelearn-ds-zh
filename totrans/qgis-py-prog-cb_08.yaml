- en: Chapter 8. QGIS Workflows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 QGIS工作流程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating an NDVI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建NDVI
- en: Geocoding addresses
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理编码地址
- en: Creating raster footprints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建栅格足迹
- en: Performing network analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行网络分析
- en: Routing along streets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿街道进行路由
- en: Tracking a GPS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪GPS
- en: Creating a mapbook
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图集
- en: Finding the least cost path
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最低成本路径
- en: Performing nearest neighbor analysis
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行最近邻分析
- en: Creating a heat map
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建热图
- en: Creating a dot density map
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建点密度图
- en: Collecting field data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集现场数据
- en: Computing road slope using elevation data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高程数据计算道路坡度
- en: Geolocating photos on the map
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上定位照片
- en: Image change detection
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像变化检测
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll use Python to perform a variety of common geospatial
    tasks in QGIS, which may be complete workflows in themselves or key pieces of
    larger workflows.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python在QGIS中执行各种常见的地理空间任务，这些任务可能是完整的流程，或者是更大流程的关键部分。
- en: Creating an NDVI
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建NDVI
- en: A **Normalized Difference Vegetation Index** (**NDVI**) is one of the oldest
    remote sensing algorithms used to detect green vegetation in an area of interest,
    using the red and near-infrared bands of an image. The chlorophyll in plants absorbs
    visible light, including the red band, while the cell structures of plants reflect
    near-infrared light. The NDVI formula provides a ratio of near-infrared light
    to the total incoming radiation, which serves as an indicator of vegetation density.
    This recipe will use Python to control the QGIS raster calculator in order to
    create an NDVI using a multispectral image of a farm field.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**归一化植被指数**（**NDVI**）是用于检测感兴趣区域内绿色植被的最古老的遥感算法之一，它使用图像的红光和近红外波段。植物中的叶绿素吸收可见光，包括红光波段，而植物细胞的结构反射近红外光。NDVI公式提供了近红外光与总入射辐射的比率，这作为植被密度的指标。本食谱将使用Python控制QGIS栅格计算器，以使用农田的多光谱图像创建NDVI。'
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the image from [https://geospatialpython.googlecode.com/svn/farm-field.tif](https://geospatialpython.googlecode.com/svn/farm-field.tif)
    and place it in your `qgis_data` to a directory named `rasters`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://geospatialpython.googlecode.com/svn/farm-field.tif](https://geospatialpython.googlecode.com/svn/farm-field.tif)下载图像并将其放置在您的`qgis_data`目录下的`rasters`文件夹中。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load the raster as a QGIS raster layer, perform the NDVI algorithm,
    and finally apply a color ramp to the raster so that we can easily visualize the
    green vegetation in the image. To do this, we need to perform the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载栅格作为QGIS栅格图层，执行NDVI算法，并最终将颜色渐变应用于栅格，以便我们能够轻松地可视化图像中的绿色植被。为此，我们需要执行以下步骤：
- en: 'In the QGIS **Python Console**, import the following libraries:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS **Python控制台**中，导入以下库：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, load the raster image as a layer using the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码将栅格图像作为图层加载：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, create entries in the QGIS raster calculator for the two bands using
    the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下代码在QGIS栅格计算器中为两个波段创建条目：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, using the following lines of code, assign the raster layer as the raster
    component of each calculator entry:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码行，将栅格图层分配为每个计算器条目的栅格组件：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Select the appropriate band for each entry, so the calculator will use the
    data we need for the NDVI. The red and infrared band numbers are typically listed
    in the raster''s metadata:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个条目选择适当的波段，以便计算器使用我们需要的NDVI数据。红光和红外波段编号通常列在栅格的元数据中：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, assign a reference ID to each entry using the special QGIS naming convention,
    as shown here, with the name of the layer as a prefix followed by an `@` symbol
    and the band number as a suffix:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用特殊的QGIS命名约定为每个条目分配一个参考ID，如以下示例所示，以图层的名称作为前缀，后跟一个`@`符号和波段编号作为后缀：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Build the raster calculator expression with the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码构建栅格计算器表达式：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, specify the output name of the NDVI image:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，指定NDVI图像的输出名称：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Set up the variables for the rest of the raster calculator call by defining
    the raster''s extent, its width and height in columns and rows, and the raster
    entries we defined in the previous steps:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义栅格的范围、其列和行的宽度和高度以及我们在上一步中定义的栅格条目来设置其余栅格计算器调用的变量：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, create the NDVI using our expression:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用我们的表达式创建NDVI：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, load the NDVI output as a raster layer:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将NDVI输出作为栅格图层加载：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We must perform a histogram stretch on the image, otherwise the differences
    in values will be difficult to see. A stretch is performed using a QGIS contrast
    enhancement algorithm:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须对图像执行直方图拉伸，否则值之间的差异将难以看到。拉伸是通过 QGIS 对比增强算法来执行的：
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, build a color ramp shader to colorize the NDVI, as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建一个颜色渐变着色器来着色 NDVI，如下所示：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, add entries for each color in the image. Each entry consists of a lower
    value range, a color, and a label. The color in an entry will continue from the
    lower value until it encounters a higher value or the maximum value. Note that
    we will use a variable alias for the extremely long name of the QGIS `ColorRampItem`
    object:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为图像中的每种颜色添加条目。每个条目由一个下限值范围、一个颜色和一个标签组成。条目中的颜色将从下限值开始，直到遇到一个更高的值或最大值。请注意，我们将使用变量别名来表示
    QGIS `ColorRampItem` 对象的极长名称：
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can add the entries to the shader and apply it to the image:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将条目添加到着色器并将其应用于图像：
- en: '[PRE14]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, add the classified NDVI image to the map in order to visualize it:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将分类的 NDVI 图像添加到地图中以可视化它：
- en: '[PRE15]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The QGIS raster calculator is exactly what its name implies. It allows you
    to perform array math on images. Both the QGIS raster menu and the Processing
    Toolbox have several raster processing tools, but the raster calculator can perform
    custom analysis that can be defined in a single mathematical equation. The NDVI
    algorithm is the infrared band minus the red band divided by the infrared band
    plus the red band, or *(IR-R)/(IR+R)*. In our calculator expression, we multiply
    each side of the equation by `1.0` to avoid division-by-zero errors. Your output
    should look similar to the following image if you load the result into QGIS. In
    this screenshot, `NODATA` values are represented as black; however, your QGIS
    installation may default to using white:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 栅格计算器正如其名所示。它允许你在图像上执行数组数学。QGIS 栅格菜单和处理工具箱都有几个栅格处理工具，但栅格计算器可以执行可以由单个数学方程定义的自定义分析。NDVI
    算法是红外波段减去红波段除以红外波段加上红波段，即 *(IR-R)/(IR+R)*。在我们的计算器表达式中，我们将方程的两边都乘以 `1.0` 以避免除以零错误。如果你将结果加载到
    QGIS 中，你的输出应该看起来类似于以下图像。在这个屏幕截图中，`NODATA` 值用黑色表示；然而，你的 QGIS 安装可能默认使用白色：
- en: '![How it works...](img/00054.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00054.jpeg)'
- en: Geocoding addresses
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理编码地址
- en: Geocoding is the process of turning an address into earth coordinates. Geocoding
    requires a comprehensive dataset that ties zip codes, cities, streets, and street
    numbers (or street number ranges) to the coordinates. In order to have a geocoder
    that works for any address in the world with reasonable accuracy, you need to
    use a cloud service because geocoding datasets are very dense and can be quite
    large. Creating a geocoding dataset for any area beyond a few square miles requires
    a significant amount of resources. There are several services available, including
    Google and MapQuest. In QGIS, the easiest way to access these services is through
    the QGIS Python GeoCoding plugin. In this recipe, we'll use this plugin to programmatically
    geocode an address.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 地理编码是将地址转换为地球坐标的过程。地理编码需要一个综合的数据集，将邮政编码、城市、街道和街道号码（或街道号码范围）与坐标关联起来。为了拥有适用于世界上任何地址且精度合理的地理编码器，你需要使用云服务，因为地理编码数据集非常密集，可能相当大。为超过几平方英里的任何区域创建地理编码数据集需要大量的资源。有几个服务可用，包括
    Google 和 MapQuest。在 QGIS 中，通过 QGIS Python 地理编码插件访问这些服务是最简单的方法。在这个菜谱中，我们将使用此插件以编程方式对地址进行地理编码。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to install the QGIS Python GeoCoding plugin by Alessandro Pasotti
    for this exercise, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这个练习，你需要安装由 Alessandro Pasotti 开发的 QGIS Python 地理编码插件，如下所示：
- en: From the QGIS **Plugins** menu, select **Manage and Install Plugins….**
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 QGIS **插件** 菜单中选择 **管理并安装插件…**
- en: In the **Plugins** dialog search box, search for `Geocoding`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **插件** 对话框的搜索框中，搜索 `地理编码`。
- en: Select **GeoCoding** plugin and click on the **Install plugin** button.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **地理编码** 插件并点击 **安装插件** 按钮。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will access the GeoCoding plugin methods using Python, feed
    the plugin an address, and print the resulting coordinates. To do this, we need
    to perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Python 访问地理编码插件方法，向插件提供一个地址，并打印出结果坐标。为此，我们需要执行以下步骤：
- en: 'In the QGIS **Python Console**, import the OpenStreetMap `geoCoding` object
    using the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 QGIS **Python 控制台** 中，使用以下代码导入 OpenStreetMap 的 `geoCoding` 对象：
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we''ll create our geocoder:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的地理编码器：
- en: '[PRE17]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, using the following code, we''ll geocode an address:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下代码，我们将对地址进行地理编码：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we''ll print the results to see the coordinates:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将打印结果以查看坐标：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Check whether you have received the following output printed to the console:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否在控制台打印出以下输出：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The **GeoCoding** plugin is designed to be used with the QGIS GUI interface.
    However, like most QGIS plugins, it is written in Python and we can access it
    through the Python console.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**地理编码**插件旨在与QGIS GUI界面一起使用。然而，像大多数QGIS插件一样，它是用Python编写的，我们可以通过Python控制台访问它。'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This trick doesn't work with every plugin. Sometimes, the user interface is
    too intertwined with the plugin's GUI that you can't programmatically use the
    plugin's methods without triggering the GUI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧并不适用于每个插件。有时，用户界面与插件的GUI结合得太紧密，以至于你无法在不触发GUI的情况下程序化地使用插件的方法。
- en: However, in most cases, you can use the plugins to not only extend QGIS but
    also for its powerful Python API. If you write a plugin yourself, consider making
    it accessible to the QGIS Python console in order to make it even more useful.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，你可以使用插件不仅扩展QGIS，还可以利用其强大的Python API。如果你自己编写插件，考虑使其可访问QGIS Python控制台，以便使其更有用。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The GeoCoding plugin also provides the Google geocoding engine as a service.
    Note that the Google mapping API, including geocoding, comes with some limitations
    that can be found at [https://developers.google.com/maps-engine/documentation/limits](https://developers.google.com/maps-engine/documentation/limits).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 地理编码插件还提供Google地理编码引擎作为一项服务。请注意，Google地图API，包括地理编码，附带一些限制，可以在[https://developers.google.com/maps-engine/documentation/limits](https://developers.google.com/maps-engine/documentation/limits)找到。
- en: Creating raster footprints
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建栅格足迹
- en: A common way to catalog raster datasets that consist of a large number of files
    is by creating a vector dataset with polygon footprints of the extent of each
    raster file. The vector footprint files can be easily loaded in QGIS or served
    over the Web. This recipe demonstrates a method to create a footprint vector from
    a directory full of raster files. We will build this program as a Processing Toolbox
    script, which is easier to build than a QGIS plugin and provides both a GUI and
    a clean programming API.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对由大量文件组成的栅格数据集进行编目的一种常见方法是通过创建一个包含每个栅格文件范围的多边形足迹的矢量数据集。矢量足迹文件可以轻松地加载到QGIS中或在网络上提供服务。本菜谱演示了一种从充满栅格文件目录创建足迹矢量的方法。我们将把这个程序作为一个处理工具箱脚本构建，这比构建QGIS插件更容易，并且提供了一个GUI和一个干净的编程API。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the sample raster image scenes from [https://geospatialpython.googlecode.com/svn/scenes.zip](https://geospatialpython.googlecode.com/svn/scenes.zip).
    Unzip the `scenes` directory into a directory named `rasters` in your `qgis_data`
    directory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://geospatialpython.googlecode.com/svn/scenes.zip](https://geospatialpython.googlecode.com/svn/scenes.zip)下载示例栅格图像场景。将`scenes`目录解压缩到您的`qgis_data`目录下的名为`rasters`的目录中。
- en: 'For this recipe, we will create a new Processing Toolbox script using the following
    steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将按照以下步骤创建一个新的处理工具箱脚本：
- en: In the QGIS Processing Toolbox, expand the **Scripts** tree menu.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS处理工具箱中，展开**脚本**树菜单。
- en: Next, expand the **Tools** tree menu.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，展开**工具**树菜单。
- en: Finally, double-click on the **Create new script** item to bring up the processing
    script editor.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，双击**创建新脚本**项以打开处理脚本编辑器。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we will use the Processing Toolbox header naming conventions ,which
    will simultaneously define our GUI and the input and output variables. Then, we''ll
    create the logic, which processes a raster directory and calculates the image
    extents, and finally we''ll create the vector file. To do this, we need to perform
    the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用处理工具箱的命名约定，这将同时定义我们的GUI以及输入和输出变量。然后，我们将创建逻辑，该逻辑处理栅格目录并计算图像范围，最后我们将创建矢量文件。为此，我们需要执行以下步骤：
- en: 'First, we define our input variables using comments to tell the Processing
    Toolbox to add these to the GUI when the script is invoked by a user. The first
    item defines the script''s group menu to place our script in the toolbox, the
    second item defines the directory containing the rasters, and the third item is
    the output name of our shapefile. The script must start with these comments. Each
    item also declares a type allowed by the Processing Toolbox API. The names of
    the variables in these comments become available to the script:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用注释来定义我们的输入变量，告诉Processing Toolbox在脚本被用户调用时将这些添加到GUI中。第一个条目定义了脚本的分组菜单，将我们的脚本放置在工具箱中，第二个条目定义了包含栅格的目录，第三个条目是我们shapefile的输出名称。脚本必须以这些注释开始。每个条目还声明了Processing
    Toolbox API允许的类型。这些注释中变量的名称对脚本可用：
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we import the Python libraries we will need, using the following commands:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入我们将需要的Python库，使用以下命令：
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we get a list of files in the raster directory. The following script makes
    no attempt to filter the files by type. If there are other types of data in the
    directory that are not raster files, they will be included as well:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们获取栅格目录中的文件列表。以下脚本没有尝试根据类型过滤文件。如果目录中有其他类型的非栅格文件，它们也将被包括在内：
- en: '[PRE23]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we declare a couple of variables, which will hold our raster extents
    and the coordinate reference string, as shown here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明几个变量，它们将保存我们的栅格范围和坐标参考字符串，如下所示：
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we loop through the rasters, load them as a raster layer to grab their
    extents, store them as point data in Python dictionaries, and add them to our
    list of footprints for temporary storage. If the raster can''t be processed, a
    warning is issued using the Processing Toolbox progress object:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们遍历栅格，将它们作为栅格图层加载以获取它们的范围，将它们作为Python字典中的点数据存储，并将它们添加到我们的临时存储的足迹列表中。如果栅格无法处理，将使用Processing
    Toolbox进度对象发出警告：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the following code, we will create a memory vector layer to build the
    footprint vector before writing it to a shapefile:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码，我们将创建一个内存矢量图层来在写入shapefile之前构建足迹矢量：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we''ll turn our list of extents into features:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将我们的范围列表转换为要素：
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''ll then set up the file driver and the CRS for the shapefile:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置shapefile的文件驱动程序和CRS：
- en: '[PRE28]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we''ll write the selected output file, specifying the layer we are
    saving to disk; the name of the output file; the file encoding, which might change
    depending on the input; the coordinate reference system; and the driver for the
    output file type, which in this case is a shapefile:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将写入选定的输出文件，指定我们保存到磁盘的图层；输出文件的名称；文件编码，这可能会根据输入而变化；坐标参考系统；以及输出文件类型的驱动程序，在这种情况下是shapefile：
- en: '[PRE29]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'It is important to remember that a Processing Toolbox script can be run in
    several different contexts: as a GUI process such as a plugin, as a programmatic
    script from the Python console, a Python plugin, or the Graphical Modeler framework.
    Therefore, it is important to follow the documented Processing Toolbox API so
    that it can work as expected in all of these contexts. This includes defining
    clear inputs and outputs and using the progress object. The progress object is
    the proper way to provide feedback to the user for both progress bars and messages.
    Although the API allows you to define outputs that let the user select different
    OGR and GDAL outputs, only shapefiles and GeoTiffs seem to be supported currently.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点很重要：Processing Toolbox 脚本可以在几个不同的环境中运行：作为一个GUI进程，例如插件，作为一个来自Python控制台的程序化脚本，一个Python插件，或者图形模型器框架。因此，遵循文档化的Processing
    Toolbox API非常重要，以确保它在这些所有环境中都能按预期工作。这包括定义清晰的输入和输出，并使用进度对象。进度对象是提供进度条和消息反馈给用户的正确方式。尽管API允许你定义让用户选择不同OGR和GDAL输出的输出，但目前似乎只支持shapefile和GeoTiff。
- en: There's more...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Graphical Modeler tool within the Processing Toolbox lets you visually chain
    different processing algorithms together to create complex workflows. Another
    interesting plugin is the Processing Workflows plugin, which not only allows you
    to chain algorithms together but also provides a nice tabbed interface with instructions
    for the end user to help beginners through complicated geospatial workflows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Processing Toolbox内的图形模型器工具允许你将不同的处理算法可视化地链接起来，以创建复杂的工作流程。另一个有趣的插件是Processing
    Workflows插件，它不仅允许你链接算法，还提供了一个带有用户说明的漂亮的选项卡界面，以帮助初学者通过复杂的地理空间工作流程。
- en: 'The following screenshot shows the raster footprints over an OpenStreetMap
    basemap:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了在OpenStreetMap底图上的栅格足迹：
- en: '![There''s more...](img/00055.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/00055.jpeg)'
- en: Performing network analysis
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行网络分析
- en: Network analysis allows you to find the most efficient route between two points
    along a defined network of connected lines. These lines might represent streets,
    pipes in a water system, the Internet, or any number of connected systems. Network
    analysis abstracts this common problem so that the same techniques and algorithms
    can be applied across a wide variety of applications. In this recipe, we'll use
    a generic line network to perform analysis using the Dijkstra algorithm, which
    is one of the oldest algorithms used to find the shortest path. QGIS has all of
    this functionality built in.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 网络分析允许您在定义的网络中找到两点之间的最有效路线。这些线可能代表街道、水系统中的管道、互联网或任何数量的连接系统。网络分析抽象出这个常见问题，以便相同的技术和算法可以应用于广泛的各类应用。在本菜谱中，我们将使用通用线网络，通过Dijkstra算法进行分析，这是用于找到最短路径的最古老算法之一。QGIS内置了所有这些功能。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, download the vector dataset from the following link, which includes
    two shapefiles, and unzip it to a directory named `shapes` in your `qgis_data`
    directory:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从以下链接下载矢量数据集，其中包含两个shapefiles，并将其解压缩到`qgis_data`目录下的名为`shapes`的目录中：
- en: '[https://geospatialpython.googlecode.com/svn/network.zip](https://geospatialpython.googlecode.com/svn/network.zip)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/network.zip](https://geospatialpython.googlecode.com/svn/network.zip)'
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a network graph by defining the beginning and end of our network
    of lines, and then use this graph to determine the shortest route along the line
    network between our two points. To do this, we need to perform the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过定义线网络的起点和终点来创建一个网络图，然后使用这个图来确定两点之间沿线网络的最短路线。为此，我们需要执行以下步骤：
- en: 'In the QGIS **Python Console**, we''ll first import the libraries we''ll need,
    including the QGIS Network Analyzer:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS **Python控制台**中，我们首先导入所需的库，包括QGIS网络分析器：
- en: '[PRE30]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we''ll load our line network shapefile and the shapefile containing the
    points along the network we want the Network Analyzer to consider when selecting
    a route:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载我们的线网络shapefile以及包含我们想要网络分析器在选择路线时考虑的网络上的点的shapefile：
- en: '[PRE31]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we will create a graph director to define the properties of the graph.
    The `director` object accepts our line shapfile, a field ID for direction information,
    and some other documented integer codes involving direction properties in the
    network. In our example, we''re going to tell the director to ignore directions.
    The `properter` object is a basic algorithm for a routing strategy that gets added
    to the network graph and considers line length:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个图导演来定义图的属性。`director`对象接受我们的线shapefile、一个用于方向信息的字段ID以及一些其他涉及网络方向属性的文档化整数代码。在我们的例子中，我们将告诉导演忽略方向。`properter`对象是一种基本的路由策略算法，它被添加到网络图中，并考虑线长度：
- en: '[PRE32]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we create the `GraphBuilder` object to actually convert the line network
    into a graph:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建`GraphBuilder`对象，将线网络实际转换为图：
- en: '[PRE33]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We define the two points that are the start and end of our route:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了我们的路线的起点和终点：
- en: '[PRE34]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we tell the director to turn our point layer into tie points in our network,
    which define the waypoints along our network and can also optionally provide resistance
    values:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们告诉导演将我们的点层转换为网络中的连接点，这些点定义了网络中的航路点，也可以选择提供阻力值：
- en: '[PRE35]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we can use the following code to build the graph:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码来构建图：
- en: '[PRE36]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We now locate our start and end points as tie points in the graph:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将起点和终点定位为图中的连接点：
- en: '[PRE37]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we can tell the Analyzer to use our start point in order to find the
    shortest route through the network:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以告诉分析器使用我们的起点来找到网络中的最短路线：
- en: '[PRE38]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we loop through the resulting tree and grab the points along the output
    route:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将遍历生成的树并获取输出路线上的点：
- en: '[PRE39]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we''ll load our two input shapefiles onto the map and create a rubber
    band in order to visualize the route:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将加载我们的两个输入shapefiles到地图上，并创建一个橡皮筋来可视化路线：
- en: '[PRE40]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we''ll add the route points to the rubber band in order to see the
    output of the Network Analyzer:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将路线点添加到橡皮筋上，以便查看网络分析器的输出：
- en: '[PRE41]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe is an extremely simple example to be used as a starting point for
    the investigation of a very complex and powerful tool. The line network shapefiles
    can have a field defining each line as one-way in a certain direction or bi-directional.
    The point shapefile provides waypoints along the network, as well as resistance
    values, which might represent elevation, traffic density, or other factors that
    will make a route less desirable. The output will look similar to the following
    image:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00056.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: More information and examples of the network analysis tool are available in
    the QGIS documentation at [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Routing along streets
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may want to find the best driving route between two addresses.
    Street routing has now become so commonplace that we take it for granted. However,
    if you explore the recipes on geocoding and network analysis in this book, you
    will begin to see what a complex challenge street routing truly is. To perform
    routing operations in QGIS, we'll use the QGIS GeoSearch plugin, which is written
    in Python, so that we can access it from the console.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to install the QGIS Python GeoSearch plugin for this exercise
    in order to do the routing, as well as the QGIS OpenLayers Plugin to overlay the
    result on a Google map, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: From the QGIS **Plugins** menu, select **Manage and Install Plugins….**
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have the QGIS GeoCoding Plugin installed, then you must uninstall it,
    as sometimes it conflicts with the GeoSearch plugin. So, select this in the plugin
    list and click on the **Uninstall plugin** button.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Plugins** dialog search box, search for `GeoSearch`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **GeoSearch plugin** and click on the **Install plugin** button.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the **Plugins** search dialog, search for `OpenLayers`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **OpenLayers plugin** and click on the **Install plugin** button.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will invoke the GeoSearch plugin''s routing function, which uses Google''s
    routing engine, and display the result over a Google map from the OpenLayers plugin.
    To do this, we need to perform the following steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **QGIS Python Console**, we first import the **QGIS utils library**
    as well as the required portions of the **GeoSearch** plugin:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we''ll use the QGIS utils library to access the **OpenLayers plugin**:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The GeoSearch plugin isn''t really designed for programmatic use, so in order
    to invoke this plugin, we must invoke it through the GUI interface, but then we
    need to pass blank values so that it doesn''t trigger the GUI plugin interface:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, using the following code, we can safely create our routing engine object:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we create our origin and destination addresses:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we can calculate the route using the simplest possible options, as shown
    here:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we use the **OpenLayers** plugin to add the Google Maps base map to the
    QGIS map:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用**OpenLayers插件**将谷歌地图基础地图添加到QGIS地图中：
- en: '[PRE48]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we use the **GeoSearch plugin** to create a QGIS layer on top of the
    base map for our route:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用**GeoSearch插件**在基础地图上创建我们的路线图层：
- en: '[PRE49]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Even though they are built in Python, neither the GeoSearch nor OpenLayers plugins
    are designed to be used with Python by a programmer. However, we are still able
    to use the tools in a script without much trouble. To take advantage of some of
    the routing options available with the GeoSearch plugin, you can use its GUI to
    see what is available and then add those options to your script. Beware that most
    plugins don't have a true API, so a slight change to the plugin in a future version
    can break your script.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们是用Python构建的，但GeoSearch和OpenLayers插件都不是为程序员使用Python而设计的。然而，我们仍然可以在脚本中不费太多麻烦地使用这些工具。为了利用GeoSearch插件提供的某些路由选项，您可以使用其GUI查看可用选项，然后将这些选项添加到您的脚本中。请注意，大多数插件没有真正的API，因此插件在未来版本中的微小更改可能会破坏您的脚本。
- en: Tracking a GPS
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪GPS
- en: QGIS has the ability to connect to a GPS that uses the NMEA standard. QGIS can
    use a serial connection to the GPS or communicate with it through the open source
    software called gpsd using the QGIS GPS information panel. The location information
    from the GPS can be displayed on the QGIS map, and QGIS can even automatically
    pan the map to follow the GPS point. In this recipe, we'll use the QGIS API to
    process NMEA sentences and update a point on a global map. The information needed
    to connect to different GPS units can vary widely, so we'll use an online NMEA
    sentence generator to get some simulated GPS information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS能够连接到使用NMEA标准的GPS。QGIS可以通过串行连接到GPS或通过QGIS GPS信息面板使用名为gpsd的开源软件与之通信。GPS的位置信息可以在QGIS地图上显示，QGIS甚至可以自动平移地图以跟随GPS点。在这个菜谱中，我们将使用QGIS
    API处理NMEA语句并更新全球地图上的一个点。连接到不同GPS设备所需的信息可能会有很大差异，因此我们将使用在线NMEA语句生成器来获取一些模拟的GPS信息。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe doesn't require any preparation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱不需要任何准备。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll grab a batch of NMEA GPS sentences from a free online generator, create
    a worldwide basemap using online geojson data, create a vector point layer to
    represent the GPS, and finally loop through the sentences and make our track point
    move around the map.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从免费的在线生成器中抓取一批NMEA GPS语句，使用在线geojson数据创建一个全球基础地图，创建一个矢量点图层来表示GPS，并最终遍历语句，使我们的轨迹点在地图上移动。
- en: 'To do this, we need to perform the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要执行以下步骤：
- en: 'First, we need to import some standard Python libraries using the QGIS **Python
    Console**:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用QGIS **Python控制台**导入一些标准Python库：
- en: '[PRE50]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we''ll connect to the online NMEA generator, download a batch of sentences,
    and turn them into a list, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将连接到在线NMEA生成器，下载一批语句，并将它们转换成列表，如下所示：
- en: '[PRE51]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we can add our world countries basemap using a geojson service:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加我们的世界国家基础地图，使用geojson服务：
- en: '[PRE52]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can create our GPS point layer and access its data provider:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的GPS点图层并访问其数据提供者：
- en: '[PRE53]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we need some variables to hold the current coordinates as we loop through
    the locations, and we''ll also access the `mapCanvas` object:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一些变量来存储我们在遍历位置时的当前坐标，我们还将访问`mapCanvas`对象：
- en: '[PRE54]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we''ll create a GPS connection object for data processing. If we are
    using a live GPS object, we will use this line to enter the device''s information:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个GPS连接对象用于数据处理。如果我们使用的是实时GPS对象，我们将使用此行输入设备信息：
- en: '[PRE55]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we set up a flag to determine whether we are processing the first point
    or not:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置一个标志来决定我们是否正在处理第一个点：
- en: '[PRE56]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can loop through the NMEA sentences now, but we must check the sentence
    type to see which type of information we are using. In a live GPS connection,
    QGIS handles this part automatically and this part of the code will be unnecessary:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以遍历NMEA语句了，但我们必须检查语句类型，以确定我们正在使用哪种类型的信息。在实时GPS连接中，QGIS会自动处理这部分，因此这部分代码将不再必要：
- en: '[PRE57]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we can get the current GPS information:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以获取当前的GPS信息：
- en: '[PRE58]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we will check this information to make sure that the GPS location has
    actually changed since the previous loop before we try to update the map:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们尝试更新地图之前，我们将检查这些信息，以确保GPS位置确实自上次循环以来发生了变化：
- en: '[PRE59]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now that we have a new point, we check whether this is the first point and
    add the whole layer to the map if it is. Otherwise, we edit the layer and add
    a new feature, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, we refresh the map and watch the tracking point jump to a new location:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A live GPS will move in a linear, incremental path across the map. In this recipe,
    we used randomly-generated points that leap around the world, but the concept
    is the same. To connect a live GPS, you will need to use QGIS's GPS information
    GUI first to establish a connection, or at least get the correct connection information,
    and then use Python to automate things from there. Once you have the location
    information, you can easily manipulate the QGIS map using Python.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NMEA standard is old and widely used, but it is a poorly-designed protocol
    by modern standards. Nearly every smartphone has a GPS now, but they do not use
    the NMEA protocol. There are, however, several apps available for nearly every
    smartphone platform that will output the phone's GPS as NMEA sentences, which
    can be used by QGIS. Later in this chapter, in the *Collecting field data* recipe,
    we'll demonstrate another method for tracking a cell phone, GPS, or even estimated
    locations for digital devices, which is much simpler and much more modern.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mapbook
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mapbook is an automatically-generated document, which can also be called an
    **atlas**. A mapbook takes a dataset and breaks it down into smaller, detailed
    maps based on a coverage layer that zooms the larger map to each feature in the
    coverage in order to make a page of the mapbook. The coverage layer may or may
    not be the same as the map layer featured on each page of the mapbook. In this
    recipe, we'll create a mapbook that features all the countries in the world.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you need to download the world countries dataset from [https://geospatialpython.googlecode.com/svn/countries.zip](https://geospatialpython.googlecode.com/svn/countries.zip)
    and put it in a directory named `shapes` within your `qgis_data` directory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll need to install the `PyPDF2` library. On Linux or OS X, just
    open a console and run the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'On Windows, open the OSGEO4W console from your start menu and run this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finally, in your `qgis_data` directory, create a folder called `atlas` to store
    the mapbook's output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will build a QGIS composition and set it to atlas mode. Then, we''ll add
    a composer map, where each country will be featured, and an overview map. Next,
    we''ll run the atlas process to produce each page of the mapbook as separate PDF
    files. Finally, we''ll combine the individual PDFs into a single PDF file. To
    do this, we need to perform the following steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import all the libraries that are needed:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, create variables related to the output files, including the mapbook''s
    name, the coverage layer, and the naming pattern for the individual PDF files:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, add the coverage layer to the map using the following code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码将覆盖层添加到地图中：
- en: '[PRE66]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, establish the map renderer:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，建立地图渲染器：
- en: '[PRE67]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, set up the composition:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置组合：
- en: '[PRE68]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create a symbol for the coverage layer:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为覆盖层创建一个符号：
- en: '[PRE69]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, add the first composer map to the composition, as shown here:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将第一个作曲地图添加到组合中，如下所示：
- en: '[PRE70]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, create the atlas framework:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建图集框架：
- en: '[PRE71]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, establish the overview map:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，建立概述地图：
- en: '[PRE72]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, create the overview map symbol:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建概述地图符号：
- en: '[PRE73]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, you need to label each page with the name of the country, which is stored
    in the `CNTRY_NAME` field of the shapefile:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要用国家的名称标记每一页，这个名称存储在shapefile的`CNTRY_NAME`字段中：
- en: '[PRE74]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we''ll tell the atlas to use automatic scaling for each country in order
    to best fit each map in the window:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将告诉图集为每个国家使用自动缩放，以便最佳地适应每个地图窗口：
- en: '[PRE75]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now we tell the atlas to loop through all the features and create PDF maps,
    as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们告诉图集遍历所有特征并创建PDF地图，如下所示：
- en: '[PRE76]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, we will use the PyPDF2 library to combine the individual PDF files
    into a single PDF file, as shown here:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用PyPDF2库将单个PDF文件合并成一个PDF文件，如下所示：
- en: '[PRE77]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can customize the template that creates the individual pages as much as
    you want. The GUI atlas tool can export the atlas to a single file, but this functionality
    is not available in PyQIS, so we use the pure Python PyPDF2 library. You can also
    create a template in the GUI, save it, and load it with Python, but it is often
    easier to make changes if you have the layout available in the code. You should
    also know that the PDF pages are just images. The maps are exported as rasters,
    so the mapbook will not be searchable and the file size can be large.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要自定义创建单个页面的模板。GUI图集工具可以将图集导出为单个文件，但这个功能在PyQIS中不可用，所以我们使用纯Python的PyPDF2库。你还可以在GUI中创建模板，保存它，然后用Python加载它，但如果你在代码中已经有了布局，通常更容易进行更改。你还应该知道，PDF页面只是图像。地图以栅格形式导出，因此图集将不可搜索，文件大小可能很大。
- en: Finding the least cost path
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最低成本路径
- en: '**Least cost path** (**LCP**) analysis is the raster equivalent of network
    analysis, which is used to find the optimal path between two points in a raster.
    In this recipe, we''ll perform LCP analysis on a digital elevation model (DEM).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**最低成本路径**（**LCP**）分析是网络分析的栅格等效，用于在栅格中找到两点之间的最优路径。在这个菜谱中，我们将对数字高程模型（DEM）执行LCP分析。'
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You need to download the following DEM and extract the ZIP file to your `qgis_data/rasters`
    directory: [https://geospatialpython.googlecode.com/svn/lcp.zip](https://geospatialpython.googlecode.com/svn/lcp.zip)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要下载以下DEM并将ZIP文件解压到你的`qgis_data/rasters`目录：[https://geospatialpython.googlecode.com/svn/lcp.zip](https://geospatialpython.googlecode.com/svn/lcp.zip)
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will load our DEM and two shapefiles consisting of start and end points.
    Then, we'll use GRASS through the Processing Toolbox to create a cumulative cost
    layer that assigns a cost to each cell in a raster based on its elevation, the
    value of the other cells around it, and its distance to and from the end points.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载我们的DEM和包含起点和终点的两个shapefile。然后，我们将通过处理工具箱使用GRASS来创建累积成本层，该层根据栅格中每个单元格的高度、周围其他单元格的值以及其到和从终点的距离为每个栅格单元格分配一个成本。
- en: 'Then, we''ll use a SAGA processing algorithm to find the least cost path between
    two points. Finally, we''ll load the output onto the map. To do this, we need
    to perform the following steps:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用SAGA处理算法在两点之间找到最低成本路径。最后，我们将输出加载到地图上。为此，我们需要执行以下步骤：
- en: 'First, we''ll import the QGIS processing Python library:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入QGIS处理Python库：
- en: '[PRE78]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we''ll set the paths to the layers, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置层的路径，如下所示：
- en: '[PRE79]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We need the DEM''s extent as a string for the algorithms:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将DEM的范围作为字符串用于算法：
- en: '[PRE80]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Using the following code, we will establish the end points as layers:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码，我们将端点作为层来建立：
- en: '[PRE81]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we''ll create the cumulative cost raster, specifying the algorithm name,
    cost layer (DEM), start point layer, end point layer, speed or accuracy option,
    keep null values option, extent of interest, cell size (0 for default), and some
    additional defaults:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建累积成本栅格，指定算法名称、成本层（DEM）、起点层、终点层、速度或精度选项、保留空值选项、感兴趣的范围、单元格大小（默认为0）和一些其他默认值：
- en: '[PRE82]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We also need to combine the points into a single layer for the SAGA algorithm:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将点合并成一个单独的层，以便SAGA算法使用：
- en: '[PRE83]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, we set up the inputs and outputs for the LCP algorithm:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为LCP算法设置输入和输出：
- en: '[PRE84]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, we run the LCP analysis using the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码运行 LCP 分析：
- en: '[PRE85]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we can load the path to view it:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以加载路径来查看它：
- en: '[PRE86]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GRASS has an LCP algorithm too, but the SAGA algorithm is easier to use. GRASS
    does a great job of creating the cost grid. Processing Toolbox algorithms allow
    you to create temporary files that are deleted when QGIS closes. So, we use temporary
    files for the intermediate products, including the cost grid and the merged shapefile.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: GRASS 也有 LCP 算法，但 SAGA 算法更容易使用。GRASS 在创建成本网格方面做得很好。处理工具箱算法允许您创建在 QGIS 关闭时删除的临时文件。因此，我们使用临时文件来处理中间产品，包括成本网格和合并后的形状文件。
- en: Performing nearest neighbor analysis
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行邻近邻分析
- en: Nearest neighbor analysis relates one point to the nearest point in one or more
    datasets. In this recipe, we'll relate one set of points to the closest point
    from another dataset. In this case, we'll find the closest major city for each
    entry in a catalog of unidentified flying object (UFO) sightings from the National
    UFO reporting center. This analysis will tell you which major cities have the
    most UFO activity. The UFO catalog data just contains latitude and longitude points,
    so we'll use nearest neighbor analysis to assign names to places.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 邻近邻分析将一个点与一个或多个数据集中的最近点相关联。在这个菜谱中，我们将一组点与另一个数据集中的最近点相关联。在这种情况下，我们将找到国家不明飞行物（UFO）报告中心目录中每个不明飞行物目击事件的最近大城市。这项分析将告诉您哪些大城市有最多的不明飞行物活动。不明飞行物目录数据仅包含经纬度点，因此我们将使用邻近邻分析来为地点分配名称。
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Download the following ZIP file and extract it to a directory named `ufo` in
    your `qgis_data` directory:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下载以下 ZIP 文件并将其解压到 `qgis_data` 目录下的名为 `ufo` 的目录中：
- en: '[https://geospatialpython.googlecode.com/svn/ufo.zip](https://geospatialpython.googlecode.com/svn/ufo.zip)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/svn/ufo.zip](https://geospatialpython.googlecode.com/svn/ufo.zip)'
- en: 'You will also need the MMQGIS plugin:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要 MMQGIS 插件：
- en: From the QGIS **Plugins** menu, select **Manage and Install Plugins….**
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 QGIS **插件** 菜单中选择 **管理并安装插件…**
- en: In the **Plugins** dialog search box, search for `mmqgis`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **插件** 对话框的搜索框中，搜索 `mmqgis`。
- en: Select the **MMQGIS plugin** and click on the **Install plugin** button.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **MMQGIS 插件** 并点击 **安装插件** 按钮。
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe is simple. Here, we will load the layers and run the nearest neighbor
    algorithm within the MMQGIS plugin, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱很简单。在这里，我们将在 MMQGIS 插件中加载图层并运行邻近邻算法，如下所示：
- en: 'First, we''ll import the MMQGIS plugin:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入 MMQGIS 插件：
- en: '[PRE87]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, as shown here, we''ll load all our datasets:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如图所示，我们将加载所有数据集：
- en: '[PRE88]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we''ll run and load the algorithm, which will draw lines from each
    UFO sighting point to the nearest city:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将运行并加载算法，该算法将从每个不明飞行物目击点绘制到最近城市的线条：
- en: '[PRE89]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a couple of different nearest neighbor algorithms in QGIS, but the
    MMQGIS version is an excellent implementation and has the best visualization.
    Like the other recipes in this chapter, the plugin doesn't have an intentional
    Python API, so a good way to explore its functionality is to use the GUI interface
    before taking a look at the Python code. The following image shows the output,
    with UFO sightings represented by smaller points and hub lines leading to the
    cities, which are represented by larger, darker points.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 中有几个不同的邻近邻算法，但 MMQGIS 版本是一个优秀的实现，并且具有最好的可视化。与其他章节中的其他菜谱一样，插件没有故意设计的 Python
    API，因此探索其功能的一个好方法是使用 GUI 界面，然后再查看 Python 代码。以下图像显示了输出，其中不明飞行物目击点由较小的点表示，而连接到城市的枢纽线则由较大、较暗的点表示。
- en: '![How it works...](img/00057.jpeg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00057.jpeg)'
- en: Creating a heat map
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建热力图
- en: A **heat map** is used to show the geographic clustering of data using a raster
    image that shows density. The clustering can also be weighed using a field in
    the data to not only show geographic density but also an intensity factor. In
    this recipe, we'll use earthquake point data to create a heat map of the impact
    of an earthquake and weigh the clustering by the earthquake's magnitude.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**热力图**用于使用显示密度的栅格图像来显示数据的地理聚类。聚类也可以使用数据中的一个字段进行加权，不仅显示地理密度，还可以显示强度因子。在这个菜谱中，我们将使用地震点数据来创建地震影响的热力图，并通过地震的震级来加权聚类。'
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires no preparation.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱不需要准备。
- en: How to do it...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will build a map with a worldwide base layer of countries and earthquake
    locations, both in GeoJSON. Next, we'll run the SAGA kernel density estimation
    algorithm to produce the heat map image. We'll create a layer from the output,
    add a color shader to it, and add it to the map.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to perform the following steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the Python libraries that we''ll need in the Python console:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, using the following code, we''ll define our map layers and the output
    raster name:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now we''ll add the layers to the map:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We need to get the extent of the earthquake layer for the Processing Toolbox
    algorithm to use:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, we can run the kernel density estimation algorithm by specifying the `mag`
    or magnitude field as our weighting factor:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, we load the output as a layer:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Then, we create the color ramp shader and apply it to the layer:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Finally, we add the `Heatmap` to our map:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel density estimation algorithm looks at the point dataset and forms
    clusters. The higher the value, the denser is the cluster. The algorithm then
    increases values based on the weighting factor, which is the earthquake''s magnitude.
    The output image is, of course, a grayscale geotiff, but we use the color ramp
    shader to make the visualization easier to understand. The following screenshot
    shows the expected output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00058.jpeg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QGIS has a fantastic plugin available, called heat map, that works well on a
    wide variety of data automatically. However, it is written in C++ and does not
    have a Python API.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dot density map
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dot density map uses point density to illustrate a field value within a polygon.
    We'll use this technique to illustrate population density in some US census bureau
    tracts.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download the census tract layer and extract it to a directory
    named `census` in your `qgis_data` directory from [https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the census layer, create a memory layer, loop through the features
    in the census layer, calculate a random point within the feature for every 100
    people, and finally add the point to the memory layer. To do this, we need to
    perform the following steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, we''ll import the `random` module:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, we''ll load the census layer:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Then, we''ll create our memory layer:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We need the index for the population value:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, we get our census layer''s features as an iterator:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We need a data provider for the memory layer so that we can edit it:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We''ll create a list to store our random points:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, we can loop through the features and calculate the density points:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, we can add our features to the memory layer using the following code and
    add them to the map in order to see the result:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: How it works...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This approach is slightly inefficient; it uses a brute-force approach that
    can place randomly generated points outside irregular polygons. We use the feature''s
    extents to contain the random points as close as possible and then use the geometry
    contains method to verify that the point is inside the polygon. The following
    screenshot shows a sample of the output:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法稍微有些低效；它使用了一种暴力方法，可能会将随机生成的点放置在不规则的多边形之外。我们使用要素的范围来尽可能包含随机点，然后使用几何包含方法来验证点是否在多边形内部。以下截图显示了输出样本：
- en: '![How it works...](img/00059.jpeg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00059.jpeg)'
- en: Collecting field data
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集现场数据
- en: For decades, collecting field observation data from the field into a GIS required
    hours of manual data entry or, at best, loading data after the trip. Smartphones
    and laptops with cellular connections have revolutionzed this process. In this
    recipe, we'll use a simple but interesting geojson-based framework to enter information
    and a map location from any Internet-connected device with a web browser and update
    a map in QGIS.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，从现场收集观测数据并将其输入GIS系统需要花费数小时的手动录入，或者在最好情况下，在旅行结束后加载数据。智能手机和具有蜂窝连接的笔记本电脑彻底改变了这一过程。在本教程中，我们将使用一个简单但有趣的基于geojson的框架，通过任何具有网络浏览器的互联网连接设备输入信息和地图位置，并在QGIS中更新地图。
- en: Getting ready
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is no preparation required for this recipe.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程不需要任何准备工作。
- en: How to do it...
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load a world boundaries layer and the field data layer onto a QGIS
    map, go to the field data mobile website and create an entry, and then refresh
    the QGIS map to see the update. To do this, we need to perform the following steps:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在QGIS地图上加载世界边界图层和现场数据图层，访问现场数据移动网站创建一个条目，然后刷新QGIS地图以查看更新。为此，我们需要执行以下步骤：
- en: 'In the QGIS **Python Console**, add the following geojson layers:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS的**Python控制台**中，添加以下geojson图层：
- en: '[PRE107]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Now, in a browser on your computer, or preferably on a mobile device with a
    data connection, go to [http://geospatialpython.github.io/qgis/fieldwork.html](http://geospatialpython.github.io/qgis/fieldwork.html).
    The application will ask you for permission to use your location, which you should
    temporarily allow for the program to work.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的计算机上的浏览器中，或者在具有数据连接的移动设备上，访问[http://geospatialpython.github.io/qgis/fieldwork.html](http://geospatialpython.github.io/qgis/fieldwork.html)。应用程序将请求您允许使用您的位置，您应该暂时允许程序运行。
- en: Enter information in the form and click on the **Send** button.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单中输入信息，然后点击**发送**按钮。
- en: Verify that you can see the geojson data, including your submission, at [https://api.myjson.com/bins/3ztvz](https://api.myjson.com/bins/3ztvz).
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您是否可以在[https://api.myjson.com/bins/3ztvz](https://api.myjson.com/bins/3ztvz)看到geojson数据，包括您的提交。
- en: Finally, update the map in QGIS by zooming or panning and locate your record.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过缩放或平移更新QGIS中的地图，并定位您的记录。
- en: How it works...
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '[PRE108]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The following image shows the mobile field application on an iPhone:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了iPhone上的移动现场应用程序：
- en: '![How it works...](img/00060.jpeg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00060.jpeg)'
- en: 'This image shows how the corresponding data looks in QGIS:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像显示了在QGIS中对应数据的显示方式：
- en: '![How it works...](img/00061.jpeg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00061.jpeg)'
- en: Computing road slope using elevation data
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高程数据计算道路坡度
- en: A common geospatial workflow is to assign raster values to a coincident vector
    layer so that you can style or perform further analysis on the vector layer. This
    recipe will use this concept to illustrate the steepness of a road using color
    by mapping values to the road vector from a slope raster.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的地理空间工作流程是将栅格值分配给相应的矢量图层，以便可以对矢量图层进行样式设置或进行进一步分析。本教程将使用这一概念来展示如何使用坡度栅格将值映射到道路矢量图层，以表示道路的陡峭程度。
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download a zipped directory from [https://geospatialpython.googlecode.com/svn/road.zip](https://geospatialpython.googlecode.com/svn/road.zip)
    and place the directory, named `road`, in your `qgis_data` directory.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从[https://geospatialpython.googlecode.com/svn/road.zip](https://geospatialpython.googlecode.com/svn/road.zip)下载一个压缩目录，并将名为`road`的目录放置在您的`qgis_data`目录中。
- en: How to do it...
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll start with a DEM and compute its slope. Then, we''ll load a road vector
    layer and break it into interval lengths of 500 meters. Next, we''ll load the
    layer and style it using green, yellow, and red values for each segment to show
    the range of steepness. We''ll overlay this layer on a hillshade of the DEM for
    a nice visualization. To do this, we need to perform the following steps:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从DEM开始，计算其坡度。然后，我们将加载一个道路矢量层，并将其分割成500米的区间长度。接下来，我们将加载该层，并使用每个段落的绿色、黄色和红色值对其进行样式化，以显示坡度的范围。我们将在DEM的阴影图上叠加这个层，以获得良好的可视化效果。为此，我们需要执行以下步骤：
- en: 'First, we need to import the QGIS processing module, the QGIS constants module,
    the Qt GUI module, and the os module in the QGIS **Python Console**:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在QGIS **Python控制台**中导入QGIS处理模块、QGIS常量模块、Qt GUI模块和os模块：
- en: '[PRE109]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, we need to set the coordinate reference system (CRS) of our project to
    that of our digital elevation model (DEM), which is EPSG code 26910, so we can
    work with the data in meters instead of decimal degrees:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们项目的坐标参考系统（CRS）设置为我们的数字高程模型（DEM）的CRS，即EPSG代码26910，这样我们就可以以米为单位而不是十进制度数来处理数据：
- en: '[PRE110]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, we''ll set the paths of all the layers. For this, we''ll use intermediate
    layers that we create so that we can change them in one place, if needed:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置所有层的路径。为此，我们将使用我们创建的中间层，这样如果需要，我们可以在一个地方更改它们：
- en: '[PRE111]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We will load the DEM and road layer so that we can get the extents for the
    processing algorithms:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将加载DEM和道路层，以便我们可以获取处理算法的范围：
- en: '[PRE112]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, build a string with the DEM extent using the following code:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码构建一个包含DEM范围的字符串：
- en: '[PRE113]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, compute the slope grid:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，计算坡度网格：
- en: '[PRE114]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Then, we can get the extent of the road layer as a string:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将道路层的范围作为一个字符串获取：
- en: '[PRE115]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, we''ll break the road layer into segments of 500 meters to have a meaningful
    length for the slope valuation:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将道路层分割成500米的段落，以便为坡度评估提供一个有意义的长度：
- en: '[PRE116]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Next, we''ll add the slope and segmented layer to the map interface for the
    next algorithm, but we''ll keep them hidden from view using the boolean `False`
    option in the `addMapLayers` method:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将坡度和分割层添加到地图界面中，以便进行下一个算法，但我们将使用`addMapLayers`方法中的布尔`False`选项将它们隐藏起来：
- en: '[PRE117]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, we can transfer the slope values to the segmented road layer in order
    to create the steepness layer:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将坡度值传输到分割道路层，以创建坡度层：
- en: '[PRE118]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now, we can load the steepness layer:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以加载坡度层：
- en: '[PRE119]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We''ll style the steepness layer to use the stoplight red, yellow, and green
    values, with red being the steepest:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将样式化坡度层，使用交通信号灯的红色、黄色和绿色值，其中红色表示最陡：
- en: '[PRE120]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Next, we''ll create a hillshade from the DEM for visualization and load everything
    onto the map:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从DEM创建阴影图以进行可视化，并将所有内容加载到地图上：
- en: '[PRE121]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: How it works...
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For each of our 500-meter line segments, the algorithm averages the underlying
    slope values. This workflow is fairly simple and also provides all the building
    blocks you need for a more complex version. While performing calculations that
    involve measurements over a relatively small area, using projected data is the
    best option. The following image shows how the output looks:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们每个500米的线段，算法会平均其下方的坡度值。这个工作流程相当简单，同时也为你提供了一个更复杂版本所需的所有构建块。在执行涉及相对较小区域测量的计算时，使用投影数据是最佳选择。以下图像显示了输出效果：
- en: '![How it works...](img/00062.jpeg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00062.jpeg)'
- en: Geolocating photos on the map
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在地图上定位照片
- en: Photos taken with GPS-enabled cameras, including smartphones, store location
    information in the header of the file, in a format called EXIF tags. These tags
    are largely based on the same header tags used by the TIFF image standard. In
    this recipe, we'll use these tags to create locations on a map for some photos
    and provide links to open them.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 配备GPS的相机拍摄的照片，包括智能手机，在文件的头部存储位置信息，这种格式称为EXIF标签。这些标签在很大程度上基于TIFF图像标准使用的相同头部标签。在这个菜谱中，我们将使用这些标签为一些照片创建地图上的位置，并提供链接以打开它们。
- en: Getting ready
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to download some sample geotagged photos from [https://github.com/GeospatialPython/qgis/blob/gh-pages/photos.zip?raw=true](https://github.com/GeospatialPython/qgis/blob/gh-pages/photos.zip?raw=true)
    and place them in a directory named `photos` in your `qgis_data` directory.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从[https://github.com/GeospatialPython/qgis/blob/gh-pages/photos.zip?raw=true](https://github.com/GeospatialPython/qgis/blob/gh-pages/photos.zip?raw=true)下载一些带有地理标签的样本照片，并将它们放置在`qgis_data`目录中名为`photos`的目录中。
- en: How to do it...
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'QGIS requires the **Python Imaging Library** (**PIL**), which should already
    be included with your installation. PIL can parse EXIF tags. We will gather the
    filenames of the photos, parse the location information, convert it to decimal
    degrees, create the point vector layer, add the photo locations, and add an action
    link to the attributes. To do this, we need to perform the following steps:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS需要**Python图像库**（**PIL**），它应该已经包含在您的安装中。PIL可以解析EXIF标签。我们将收集照片的文件名，解析位置信息，将其转换为十进制度，创建点矢量图层，添加照片位置，并将操作链接添加到属性中。为此，我们需要执行以下步骤：
- en: 'In the QGIS **Python Console**, import the libraries that we''ll need, including
    k for parsing image data and the `glob` module for doing wildcard file searches:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS **Python控制台**中，导入我们将需要的库，包括用于解析图像数据的k库和用于执行通配符文件搜索的`glob`模块：
- en: '[PRE122]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, we''ll create a function that can parse the header data:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个可以解析标题数据的函数：
- en: '[PRE123]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now, we''ll create a function that can convert degrees-minute-seconds to decimal
    degrees, which is how coordinates are stored in JPEG images:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个可以将度-分-秒转换为十进制度数的函数，这是JPEG图像中存储坐标的方式：
- en: '[PRE124]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Next, we''ll define a function to parse the location data from the header data:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个函数来解析标题数据中的位置数据：
- en: '[PRE125]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Next, we''ll loop through the `photos` directory, get the filenames, parse
    the location information, and build a simple dictionary to store the information,
    as follows:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将遍历`photos`目录，获取文件名，解析位置信息，并构建一个简单的字典来存储信息，如下所示：
- en: '[PRE126]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Now, we''ll set up the vector layer for editing:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置用于编辑的矢量图层：
- en: '[PRE127]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We''ll add the photo details to the vector layer:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向矢量图层添加照片详细信息：
- en: '[PRE128]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Now, we can add the layer to the map and make the active layer:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将图层添加到地图并将它设置为活动图层：
- en: '[PRE129]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Finally, we''ll add an action that allows you to click on it and open the photo:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个允许您点击并打开照片的操作：
- en: '[PRE130]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: How it works...
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'Using the included PIL EXIF parser, getting location information and adding
    it to a vector layer is relatively straightforward. The interesting part of this
    recipe is the QGIS action to open the photo. This action is a default option for
    opening a URL. However, you can also use Python expressions as actions to perform
    a variety of tasks. The following screenshot shows an example of the data visualization
    and photo popup:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包含的PIL EXIF解析器，获取位置信息并将其添加到矢量图层相对简单。此菜谱的有趣部分是QGIS打开照片的操作。此操作是打开URL的默认选项。但是，您也可以使用Python表达式作为操作来执行各种任务。以下截图显示了数据可视化和照片弹出窗口的示例：
- en: '![How it works...](img/00063.jpeg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00063.jpeg)'
- en: There's more...
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another plugin called Photo2Shape is available, but it requires you to install
    an external EXIF tag parser.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为Photo2Shape的插件可用，但它需要您安装外部EXIF标签解析器。
- en: Image change detection
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像变化检测
- en: Change detection allows you to automatically highlight the differences between
    two images in the same area if they are properly orthorectified. In this recipe,
    we'll do a simple difference change detection on two images, which are several
    years apart, to see the differences in urban development and the natural environment.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 变化检测允许您在两个图像正确正射校正的同一区域自动突出显示它们之间的差异。在此菜谱中，我们将对两个相隔数年的图像进行简单的差异变化检测，以查看城市发展和自然环境的变化。
- en: Getting ready
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the two images for this recipe from [https://github.com/GeospatialPython/qgis/blob/gh-pages/change-detection.zip?raw=true](https://github.com/GeospatialPython/qgis/blob/gh-pages/change-detection.zip?raw=true)
    and put them in a directory named `change-detection` in the `rasters` directory
    of your `qgis_data` directory. Note that the file is 55 megabytes, so it may take
    several minutes to download.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/GeospatialPython/qgis/blob/gh-pages/change-detection.zip?raw=true](https://github.com/GeospatialPython/qgis/blob/gh-pages/change-detection.zip?raw=true)下载此菜谱的两个图像，并将它们放入`qgis_data`目录下的`rasters`目录中名为`change-detection`的目录中。请注意，该文件大小为55兆字节，因此下载可能需要几分钟。
- en: How to do it...
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll use the QGIS raster calculator to subtract the images in order to get
    the difference, which will highlight significant changes. We''ll also add a color
    ramp shader to the output in order to visualize the changes. To do this, we need
    to perform the following steps:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用QGIS栅格计算器来减去图像以获取差异，这将突出显示显著的变化。我们还将向输出添加颜色渐变着色器以可视化变化。为此，我们需要执行以下步骤：
- en: 'First, we need to import the libraries that we need in to the QGIS console:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将所需的库导入到QGIS控制台：
- en: '[PRE131]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Now, we''ll set up the path names and raster names for our images:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的图像设置路径名和光栅名：
- en: '[PRE132]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Next, we''ll establish our images as raster layers:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将图像设置为光栅图层：
- en: '[PRE133]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Then, we can build the calculator entries:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以构建计算器条目：
- en: '[PRE134]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now, we''ll set up the simple expression that does the math for remote sensing:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置一个简单的表达式，用于进行遥感计算：
- en: '[PRE135]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then, we can set up the output file path, the raster extent, and pixel width
    and height:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以设置输出文件路径、光栅范围以及像素宽度和高度：
- en: '[PRE136]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Now, we perform the calculation:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们进行计算：
- en: '[PRE137]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Finally, we''ll load the output as a layer, create the color ramp shader, apply
    it to the layer, and add it to the map, as shown here:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将输出加载为图层，创建颜色渐变着色器，将其应用于图层，并将其添加到地图中，如图所示：
- en: '[PRE138]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: How it works...
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The concept is simple. We subtract the older image data from the new image data.
    Concentrating on urban areas tends to be highly reflective and results in higher
    image pixel values. If a building is added in the new image, it will be brighter
    than its surroundings. If a building is removed, the new image will be darker
    in that area. The same holds true for vegetation, to some extent.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 概念很简单。我们从新图像数据中减去旧图像数据。专注于城市区域往往具有较高的反射性，导致图像像素值较高。如果在新图像中添加了一座建筑，它将比周围环境更亮。如果移除了一座建筑，新图像在该区域将变暗。这在一定程度上也适用于植被。
