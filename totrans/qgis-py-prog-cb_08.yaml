- en: Chapter 8. QGIS Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an NDVI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geocoding addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating raster footprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing network analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing along streets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking a GPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a mapbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the least cost path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing nearest neighbor analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a heat map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dot density map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting field data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing road slope using elevation data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geolocating photos on the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll use Python to perform a variety of common geospatial
    tasks in QGIS, which may be complete workflows in themselves or key pieces of
    larger workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an NDVI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Normalized Difference Vegetation Index** (**NDVI**) is one of the oldest
    remote sensing algorithms used to detect green vegetation in an area of interest,
    using the red and near-infrared bands of an image. The chlorophyll in plants absorbs
    visible light, including the red band, while the cell structures of plants reflect
    near-infrared light. The NDVI formula provides a ratio of near-infrared light
    to the total incoming radiation, which serves as an indicator of vegetation density.
    This recipe will use Python to control the QGIS raster calculator in order to
    create an NDVI using a multispectral image of a farm field.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the image from [https://geospatialpython.googlecode.com/svn/farm-field.tif](https://geospatialpython.googlecode.com/svn/farm-field.tif)
    and place it in your `qgis_data` to a directory named `rasters`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the raster as a QGIS raster layer, perform the NDVI algorithm,
    and finally apply a color ramp to the raster so that we can easily visualize the
    green vegetation in the image. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, import the following libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, load the raster image as a layer using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create entries in the QGIS raster calculator for the two bands using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, using the following lines of code, assign the raster layer as the raster
    component of each calculator entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the appropriate band for each entry, so the calculator will use the
    data we need for the NDVI. The red and infrared band numbers are typically listed
    in the raster''s metadata:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, assign a reference ID to each entry using the special QGIS naming convention,
    as shown here, with the name of the layer as a prefix followed by an `@` symbol
    and the band number as a suffix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the raster calculator expression with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, specify the output name of the NDVI image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the variables for the rest of the raster calculator call by defining
    the raster''s extent, its width and height in columns and rows, and the raster
    entries we defined in the previous steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create the NDVI using our expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, load the NDVI output as a raster layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must perform a histogram stretch on the image, otherwise the differences
    in values will be difficult to see. A stretch is performed using a QGIS contrast
    enhancement algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, build a color ramp shader to colorize the NDVI, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add entries for each color in the image. Each entry consists of a lower
    value range, a color, and a label. The color in an entry will continue from the
    lower value until it encounters a higher value or the maximum value. Note that
    we will use a variable alias for the extremely long name of the QGIS `ColorRampItem`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the entries to the shader and apply it to the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the classified NDVI image to the map in order to visualize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The QGIS raster calculator is exactly what its name implies. It allows you
    to perform array math on images. Both the QGIS raster menu and the Processing
    Toolbox have several raster processing tools, but the raster calculator can perform
    custom analysis that can be defined in a single mathematical equation. The NDVI
    algorithm is the infrared band minus the red band divided by the infrared band
    plus the red band, or *(IR-R)/(IR+R)*. In our calculator expression, we multiply
    each side of the equation by `1.0` to avoid division-by-zero errors. Your output
    should look similar to the following image if you load the result into QGIS. In
    this screenshot, `NODATA` values are represented as black; however, your QGIS
    installation may default to using white:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Geocoding addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geocoding is the process of turning an address into earth coordinates. Geocoding
    requires a comprehensive dataset that ties zip codes, cities, streets, and street
    numbers (or street number ranges) to the coordinates. In order to have a geocoder
    that works for any address in the world with reasonable accuracy, you need to
    use a cloud service because geocoding datasets are very dense and can be quite
    large. Creating a geocoding dataset for any area beyond a few square miles requires
    a significant amount of resources. There are several services available, including
    Google and MapQuest. In QGIS, the easiest way to access these services is through
    the QGIS Python GeoCoding plugin. In this recipe, we'll use this plugin to programmatically
    geocode an address.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to install the QGIS Python GeoCoding plugin by Alessandro Pasotti
    for this exercise, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the QGIS **Plugins** menu, select **Manage and Install Plugins….**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Plugins** dialog search box, search for `Geocoding`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **GeoCoding** plugin and click on the **Install plugin** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will access the GeoCoding plugin methods using Python, feed
    the plugin an address, and print the resulting coordinates. To do this, we need
    to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, import the OpenStreetMap `geoCoding` object
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create our geocoder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, using the following code, we''ll geocode an address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll print the results to see the coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether you have received the following output printed to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **GeoCoding** plugin is designed to be used with the QGIS GUI interface.
    However, like most QGIS plugins, it is written in Python and we can access it
    through the Python console.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This trick doesn't work with every plugin. Sometimes, the user interface is
    too intertwined with the plugin's GUI that you can't programmatically use the
    plugin's methods without triggering the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: However, in most cases, you can use the plugins to not only extend QGIS but
    also for its powerful Python API. If you write a plugin yourself, consider making
    it accessible to the QGIS Python console in order to make it even more useful.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GeoCoding plugin also provides the Google geocoding engine as a service.
    Note that the Google mapping API, including geocoding, comes with some limitations
    that can be found at [https://developers.google.com/maps-engine/documentation/limits](https://developers.google.com/maps-engine/documentation/limits).
  prefs: []
  type: TYPE_NORMAL
- en: Creating raster footprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common way to catalog raster datasets that consist of a large number of files
    is by creating a vector dataset with polygon footprints of the extent of each
    raster file. The vector footprint files can be easily loaded in QGIS or served
    over the Web. This recipe demonstrates a method to create a footprint vector from
    a directory full of raster files. We will build this program as a Processing Toolbox
    script, which is easier to build than a QGIS plugin and provides both a GUI and
    a clean programming API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the sample raster image scenes from [https://geospatialpython.googlecode.com/svn/scenes.zip](https://geospatialpython.googlecode.com/svn/scenes.zip).
    Unzip the `scenes` directory into a directory named `rasters` in your `qgis_data`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we will create a new Processing Toolbox script using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the QGIS Processing Toolbox, expand the **Scripts** tree menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, expand the **Tools** tree menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, double-click on the **Create new script** item to bring up the processing
    script editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will use the Processing Toolbox header naming conventions ,which
    will simultaneously define our GUI and the input and output variables. Then, we''ll
    create the logic, which processes a raster directory and calculates the image
    extents, and finally we''ll create the vector file. To do this, we need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define our input variables using comments to tell the Processing
    Toolbox to add these to the GUI when the script is invoked by a user. The first
    item defines the script''s group menu to place our script in the toolbox, the
    second item defines the directory containing the rasters, and the third item is
    the output name of our shapefile. The script must start with these comments. Each
    item also declares a type allowed by the Processing Toolbox API. The names of
    the variables in these comments become available to the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we import the Python libraries we will need, using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we get a list of files in the raster directory. The following script makes
    no attempt to filter the files by type. If there are other types of data in the
    directory that are not raster files, they will be included as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we declare a couple of variables, which will hold our raster extents
    and the coordinate reference string, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we loop through the rasters, load them as a raster layer to grab their
    extents, store them as point data in Python dictionaries, and add them to our
    list of footprints for temporary storage. If the raster can''t be processed, a
    warning is issued using the Processing Toolbox progress object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the following code, we will create a memory vector layer to build the
    footprint vector before writing it to a shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll turn our list of extents into features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then set up the file driver and the CRS for the shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll write the selected output file, specifying the layer we are
    saving to disk; the name of the output file; the file encoding, which might change
    depending on the input; the coordinate reference system; and the driver for the
    output file type, which in this case is a shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important to remember that a Processing Toolbox script can be run in
    several different contexts: as a GUI process such as a plugin, as a programmatic
    script from the Python console, a Python plugin, or the Graphical Modeler framework.
    Therefore, it is important to follow the documented Processing Toolbox API so
    that it can work as expected in all of these contexts. This includes defining
    clear inputs and outputs and using the progress object. The progress object is
    the proper way to provide feedback to the user for both progress bars and messages.
    Although the API allows you to define outputs that let the user select different
    OGR and GDAL outputs, only shapefiles and GeoTiffs seem to be supported currently.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Graphical Modeler tool within the Processing Toolbox lets you visually chain
    different processing algorithms together to create complex workflows. Another
    interesting plugin is the Processing Workflows plugin, which not only allows you
    to chain algorithms together but also provides a nice tabbed interface with instructions
    for the end user to help beginners through complicated geospatial workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the raster footprints over an OpenStreetMap
    basemap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Performing network analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network analysis allows you to find the most efficient route between two points
    along a defined network of connected lines. These lines might represent streets,
    pipes in a water system, the Internet, or any number of connected systems. Network
    analysis abstracts this common problem so that the same techniques and algorithms
    can be applied across a wide variety of applications. In this recipe, we'll use
    a generic line network to perform analysis using the Dijkstra algorithm, which
    is one of the oldest algorithms used to find the shortest path. QGIS has all of
    this functionality built in.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, download the vector dataset from the following link, which includes
    two shapefiles, and unzip it to a directory named `shapes` in your `qgis_data`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/network.zip](https://geospatialpython.googlecode.com/svn/network.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a network graph by defining the beginning and end of our network
    of lines, and then use this graph to determine the shortest route along the line
    network between our two points. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, we''ll first import the libraries we''ll need,
    including the QGIS Network Analyzer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll load our line network shapefile and the shapefile containing the
    points along the network we want the Network Analyzer to consider when selecting
    a route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a graph director to define the properties of the graph.
    The `director` object accepts our line shapfile, a field ID for direction information,
    and some other documented integer codes involving direction properties in the
    network. In our example, we''re going to tell the director to ignore directions.
    The `properter` object is a basic algorithm for a routing strategy that gets added
    to the network graph and considers line length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create the `GraphBuilder` object to actually convert the line network
    into a graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define the two points that are the start and end of our route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we tell the director to turn our point layer into tie points in our network,
    which define the waypoints along our network and can also optionally provide resistance
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the following code to build the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now locate our start and end points as tie points in the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can tell the Analyzer to use our start point in order to find the
    shortest route through the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we loop through the resulting tree and grab the points along the output
    route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll load our two input shapefiles onto the map and create a rubber
    band in order to visualize the route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll add the route points to the rubber band in order to see the
    output of the Network Analyzer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is an extremely simple example to be used as a starting point for
    the investigation of a very complex and powerful tool. The line network shapefiles
    can have a field defining each line as one-way in a certain direction or bi-directional.
    The point shapefile provides waypoints along the network, as well as resistance
    values, which might represent elevation, traffic density, or other factors that
    will make a route less desirable. The output will look similar to the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: More information and examples of the network analysis tool are available in
    the QGIS documentation at [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html).
  prefs: []
  type: TYPE_NORMAL
- en: Routing along streets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may want to find the best driving route between two addresses.
    Street routing has now become so commonplace that we take it for granted. However,
    if you explore the recipes on geocoding and network analysis in this book, you
    will begin to see what a complex challenge street routing truly is. To perform
    routing operations in QGIS, we'll use the QGIS GeoSearch plugin, which is written
    in Python, so that we can access it from the console.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to install the QGIS Python GeoSearch plugin for this exercise
    in order to do the routing, as well as the QGIS OpenLayers Plugin to overlay the
    result on a Google map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the QGIS **Plugins** menu, select **Manage and Install Plugins….**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have the QGIS GeoCoding Plugin installed, then you must uninstall it,
    as sometimes it conflicts with the GeoSearch plugin. So, select this in the plugin
    list and click on the **Uninstall plugin** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Plugins** dialog search box, search for `GeoSearch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **GeoSearch plugin** and click on the **Install plugin** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the **Plugins** search dialog, search for `OpenLayers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **OpenLayers plugin** and click on the **Install plugin** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will invoke the GeoSearch plugin''s routing function, which uses Google''s
    routing engine, and display the result over a Google map from the OpenLayers plugin.
    To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **QGIS Python Console**, we first import the **QGIS utils library**
    as well as the required portions of the **GeoSearch** plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll use the QGIS utils library to access the **OpenLayers plugin**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The GeoSearch plugin isn''t really designed for programmatic use, so in order
    to invoke this plugin, we must invoke it through the GUI interface, but then we
    need to pass blank values so that it doesn''t trigger the GUI plugin interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, using the following code, we can safely create our routing engine object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create our origin and destination addresses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can calculate the route using the simplest possible options, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we use the **OpenLayers** plugin to add the Google Maps base map to the
    QGIS map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we use the **GeoSearch plugin** to create a QGIS layer on top of the
    base map for our route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though they are built in Python, neither the GeoSearch nor OpenLayers plugins
    are designed to be used with Python by a programmer. However, we are still able
    to use the tools in a script without much trouble. To take advantage of some of
    the routing options available with the GeoSearch plugin, you can use its GUI to
    see what is available and then add those options to your script. Beware that most
    plugins don't have a true API, so a slight change to the plugin in a future version
    can break your script.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking a GPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QGIS has the ability to connect to a GPS that uses the NMEA standard. QGIS can
    use a serial connection to the GPS or communicate with it through the open source
    software called gpsd using the QGIS GPS information panel. The location information
    from the GPS can be displayed on the QGIS map, and QGIS can even automatically
    pan the map to follow the GPS point. In this recipe, we'll use the QGIS API to
    process NMEA sentences and update a point on a global map. The information needed
    to connect to different GPS units can vary widely, so we'll use an online NMEA
    sentence generator to get some simulated GPS information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe doesn't require any preparation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll grab a batch of NMEA GPS sentences from a free online generator, create
    a worldwide basemap using online geojson data, create a vector point layer to
    represent the GPS, and finally loop through the sentences and make our track point
    move around the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import some standard Python libraries using the QGIS **Python
    Console**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll connect to the online NMEA generator, download a batch of sentences,
    and turn them into a list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can add our world countries basemap using a geojson service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create our GPS point layer and access its data provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need some variables to hold the current coordinates as we loop through
    the locations, and we''ll also access the `mapCanvas` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create a GPS connection object for data processing. If we are
    using a live GPS object, we will use this line to enter the device''s information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we set up a flag to determine whether we are processing the first point
    or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can loop through the NMEA sentences now, but we must check the sentence
    type to see which type of information we are using. In a live GPS connection,
    QGIS handles this part automatically and this part of the code will be unnecessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can get the current GPS information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will check this information to make sure that the GPS location has
    actually changed since the previous loop before we try to update the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have a new point, we check whether this is the first point and
    add the whole layer to the map if it is. Otherwise, we edit the layer and add
    a new feature, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we refresh the map and watch the tracking point jump to a new location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A live GPS will move in a linear, incremental path across the map. In this recipe,
    we used randomly-generated points that leap around the world, but the concept
    is the same. To connect a live GPS, you will need to use QGIS's GPS information
    GUI first to establish a connection, or at least get the correct connection information,
    and then use Python to automate things from there. Once you have the location
    information, you can easily manipulate the QGIS map using Python.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NMEA standard is old and widely used, but it is a poorly-designed protocol
    by modern standards. Nearly every smartphone has a GPS now, but they do not use
    the NMEA protocol. There are, however, several apps available for nearly every
    smartphone platform that will output the phone's GPS as NMEA sentences, which
    can be used by QGIS. Later in this chapter, in the *Collecting field data* recipe,
    we'll demonstrate another method for tracking a cell phone, GPS, or even estimated
    locations for digital devices, which is much simpler and much more modern.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mapbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mapbook is an automatically-generated document, which can also be called an
    **atlas**. A mapbook takes a dataset and breaks it down into smaller, detailed
    maps based on a coverage layer that zooms the larger map to each feature in the
    coverage in order to make a page of the mapbook. The coverage layer may or may
    not be the same as the map layer featured on each page of the mapbook. In this
    recipe, we'll create a mapbook that features all the countries in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you need to download the world countries dataset from [https://geospatialpython.googlecode.com/svn/countries.zip](https://geospatialpython.googlecode.com/svn/countries.zip)
    and put it in a directory named `shapes` within your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll need to install the `PyPDF2` library. On Linux or OS X, just
    open a console and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, open the OSGEO4W console from your start menu and run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in your `qgis_data` directory, create a folder called `atlas` to store
    the mapbook's output.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will build a QGIS composition and set it to atlas mode. Then, we''ll add
    a composer map, where each country will be featured, and an overview map. Next,
    we''ll run the atlas process to produce each page of the mapbook as separate PDF
    files. Finally, we''ll combine the individual PDFs into a single PDF file. To
    do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import all the libraries that are needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create variables related to the output files, including the mapbook''s
    name, the coverage layer, and the naming pattern for the individual PDF files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the coverage layer to the map using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, establish the map renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, set up the composition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a symbol for the coverage layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the first composer map to the composition, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the atlas framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, establish the overview map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the overview map symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you need to label each page with the name of the country, which is stored
    in the `CNTRY_NAME` field of the shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll tell the atlas to use automatic scaling for each country in order
    to best fit each map in the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we tell the atlas to loop through all the features and create PDF maps,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will use the PyPDF2 library to combine the individual PDF files
    into a single PDF file, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can customize the template that creates the individual pages as much as
    you want. The GUI atlas tool can export the atlas to a single file, but this functionality
    is not available in PyQIS, so we use the pure Python PyPDF2 library. You can also
    create a template in the GUI, save it, and load it with Python, but it is often
    easier to make changes if you have the layout available in the code. You should
    also know that the PDF pages are just images. The maps are exported as rasters,
    so the mapbook will not be searchable and the file size can be large.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the least cost path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Least cost path** (**LCP**) analysis is the raster equivalent of network
    analysis, which is used to find the optimal path between two points in a raster.
    In this recipe, we''ll perform LCP analysis on a digital elevation model (DEM).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to download the following DEM and extract the ZIP file to your `qgis_data/rasters`
    directory: [https://geospatialpython.googlecode.com/svn/lcp.zip](https://geospatialpython.googlecode.com/svn/lcp.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will load our DEM and two shapefiles consisting of start and end points.
    Then, we'll use GRASS through the Processing Toolbox to create a cumulative cost
    layer that assigns a cost to each cell in a raster based on its elevation, the
    value of the other cells around it, and its distance to and from the end points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll use a SAGA processing algorithm to find the least cost path between
    two points. Finally, we''ll load the output onto the map. To do this, we need
    to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the QGIS processing Python library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll set the paths to the layers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need the DEM''s extent as a string for the algorithms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the following code, we will establish the end points as layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll create the cumulative cost raster, specifying the algorithm name,
    cost layer (DEM), start point layer, end point layer, speed or accuracy option,
    keep null values option, extent of interest, cell size (0 for default), and some
    additional defaults:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to combine the points into a single layer for the SAGA algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set up the inputs and outputs for the LCP algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we run the LCP analysis using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can load the path to view it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GRASS has an LCP algorithm too, but the SAGA algorithm is easier to use. GRASS
    does a great job of creating the cost grid. Processing Toolbox algorithms allow
    you to create temporary files that are deleted when QGIS closes. So, we use temporary
    files for the intermediate products, including the cost grid and the merged shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: Performing nearest neighbor analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearest neighbor analysis relates one point to the nearest point in one or more
    datasets. In this recipe, we'll relate one set of points to the closest point
    from another dataset. In this case, we'll find the closest major city for each
    entry in a catalog of unidentified flying object (UFO) sightings from the National
    UFO reporting center. This analysis will tell you which major cities have the
    most UFO activity. The UFO catalog data just contains latitude and longitude points,
    so we'll use nearest neighbor analysis to assign names to places.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Download the following ZIP file and extract it to a directory named `ufo` in
    your `qgis_data` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/ufo.zip](https://geospatialpython.googlecode.com/svn/ufo.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the MMQGIS plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: From the QGIS **Plugins** menu, select **Manage and Install Plugins….**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Plugins** dialog search box, search for `mmqgis`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MMQGIS plugin** and click on the **Install plugin** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is simple. Here, we will load the layers and run the nearest neighbor
    algorithm within the MMQGIS plugin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the MMQGIS plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, as shown here, we''ll load all our datasets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll run and load the algorithm, which will draw lines from each
    UFO sighting point to the nearest city:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of different nearest neighbor algorithms in QGIS, but the
    MMQGIS version is an excellent implementation and has the best visualization.
    Like the other recipes in this chapter, the plugin doesn't have an intentional
    Python API, so a good way to explore its functionality is to use the GUI interface
    before taking a look at the Python code. The following image shows the output,
    with UFO sightings represented by smaller points and hub lines leading to the
    cities, which are represented by larger, darker points.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a heat map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **heat map** is used to show the geographic clustering of data using a raster
    image that shows density. The clustering can also be weighed using a field in
    the data to not only show geographic density but also an intensity factor. In
    this recipe, we'll use earthquake point data to create a heat map of the impact
    of an earthquake and weigh the clustering by the earthquake's magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires no preparation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build a map with a worldwide base layer of countries and earthquake
    locations, both in GeoJSON. Next, we'll run the SAGA kernel density estimation
    algorithm to produce the heat map image. We'll create a layer from the output,
    add a color shader to it, and add it to the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the Python libraries that we''ll need in the Python console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, using the following code, we''ll define our map layers and the output
    raster name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''ll add the layers to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to get the extent of the earthquake layer for the Processing Toolbox
    algorithm to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run the kernel density estimation algorithm by specifying the `mag`
    or magnitude field as our weighting factor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we load the output as a layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create the color ramp shader and apply it to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the `Heatmap` to our map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kernel density estimation algorithm looks at the point dataset and forms
    clusters. The higher the value, the denser is the cluster. The algorithm then
    increases values based on the weighting factor, which is the earthquake''s magnitude.
    The output image is, of course, a grayscale geotiff, but we use the color ramp
    shader to make the visualization easier to understand. The following screenshot
    shows the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QGIS has a fantastic plugin available, called heat map, that works well on a
    wide variety of data automatically. However, it is written in C++ and does not
    have a Python API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dot density map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dot density map uses point density to illustrate a field value within a polygon.
    We'll use this technique to illustrate population density in some US census bureau
    tracts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download the census tract layer and extract it to a directory
    named `census` in your `qgis_data` directory from [https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the census layer, create a memory layer, loop through the features
    in the census layer, calculate a random point within the feature for every 100
    people, and finally add the point to the memory layer. To do this, we need to
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, we''ll import the `random` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll load the census layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll create our memory layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need the index for the population value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we get our census layer''s features as an iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a data provider for the memory layer so that we can edit it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll create a list to store our random points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can loop through the features and calculate the density points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add our features to the memory layer using the following code and
    add them to the map in order to see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This approach is slightly inefficient; it uses a brute-force approach that
    can place randomly generated points outside irregular polygons. We use the feature''s
    extents to contain the random points as close as possible and then use the geometry
    contains method to verify that the point is inside the polygon. The following
    screenshot shows a sample of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Collecting field data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For decades, collecting field observation data from the field into a GIS required
    hours of manual data entry or, at best, loading data after the trip. Smartphones
    and laptops with cellular connections have revolutionzed this process. In this
    recipe, we'll use a simple but interesting geojson-based framework to enter information
    and a map location from any Internet-connected device with a web browser and update
    a map in QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no preparation required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load a world boundaries layer and the field data layer onto a QGIS
    map, go to the field data mobile website and create an entry, and then refresh
    the QGIS map to see the update. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, add the following geojson layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in a browser on your computer, or preferably on a mobile device with a
    data connection, go to [http://geospatialpython.github.io/qgis/fieldwork.html](http://geospatialpython.github.io/qgis/fieldwork.html).
    The application will ask you for permission to use your location, which you should
    temporarily allow for the program to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter information in the form and click on the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that you can see the geojson data, including your submission, at [https://api.myjson.com/bins/3ztvz](https://api.myjson.com/bins/3ztvz).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, update the map in QGIS by zooming or panning and locate your record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the mobile field application on an iPhone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This image shows how the corresponding data looks in QGIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Computing road slope using elevation data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common geospatial workflow is to assign raster values to a coincident vector
    layer so that you can style or perform further analysis on the vector layer. This
    recipe will use this concept to illustrate the steepness of a road using color
    by mapping values to the road vector from a slope raster.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download a zipped directory from [https://geospatialpython.googlecode.com/svn/road.zip](https://geospatialpython.googlecode.com/svn/road.zip)
    and place the directory, named `road`, in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start with a DEM and compute its slope. Then, we''ll load a road vector
    layer and break it into interval lengths of 500 meters. Next, we''ll load the
    layer and style it using green, yellow, and red values for each segment to show
    the range of steepness. We''ll overlay this layer on a hillshade of the DEM for
    a nice visualization. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the QGIS processing module, the QGIS constants module,
    the Qt GUI module, and the os module in the QGIS **Python Console**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to set the coordinate reference system (CRS) of our project to
    that of our digital elevation model (DEM), which is EPSG code 26910, so we can
    work with the data in meters instead of decimal degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll set the paths of all the layers. For this, we''ll use intermediate
    layers that we create so that we can change them in one place, if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will load the DEM and road layer so that we can get the extents for the
    processing algorithms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, build a string with the DEM extent using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, compute the slope grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can get the extent of the road layer as a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll break the road layer into segments of 500 meters to have a meaningful
    length for the slope valuation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll add the slope and segmented layer to the map interface for the
    next algorithm, but we''ll keep them hidden from view using the boolean `False`
    option in the `addMapLayers` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can transfer the slope values to the segmented road layer in order
    to create the steepness layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can load the steepness layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll style the steepness layer to use the stoplight red, yellow, and green
    values, with red being the steepest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create a hillshade from the DEM for visualization and load everything
    onto the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For each of our 500-meter line segments, the algorithm averages the underlying
    slope values. This workflow is fairly simple and also provides all the building
    blocks you need for a more complex version. While performing calculations that
    involve measurements over a relatively small area, using projected data is the
    best option. The following image shows how the output looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Geolocating photos on the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Photos taken with GPS-enabled cameras, including smartphones, store location
    information in the header of the file, in a format called EXIF tags. These tags
    are largely based on the same header tags used by the TIFF image standard. In
    this recipe, we'll use these tags to create locations on a map for some photos
    and provide links to open them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download some sample geotagged photos from [https://github.com/GeospatialPython/qgis/blob/gh-pages/photos.zip?raw=true](https://github.com/GeospatialPython/qgis/blob/gh-pages/photos.zip?raw=true)
    and place them in a directory named `photos` in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'QGIS requires the **Python Imaging Library** (**PIL**), which should already
    be included with your installation. PIL can parse EXIF tags. We will gather the
    filenames of the photos, parse the location information, convert it to decimal
    degrees, create the point vector layer, add the photo locations, and add an action
    link to the attributes. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, import the libraries that we''ll need, including
    k for parsing image data and the `glob` module for doing wildcard file searches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create a function that can parse the header data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll create a function that can convert degrees-minute-seconds to decimal
    degrees, which is how coordinates are stored in JPEG images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll define a function to parse the location data from the header data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll loop through the `photos` directory, get the filenames, parse
    the location information, and build a simple dictionary to store the information,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll set up the vector layer for editing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll add the photo details to the vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the layer to the map and make the active layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll add an action that allows you to click on it and open the photo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the included PIL EXIF parser, getting location information and adding
    it to a vector layer is relatively straightforward. The interesting part of this
    recipe is the QGIS action to open the photo. This action is a default option for
    opening a URL. However, you can also use Python expressions as actions to perform
    a variety of tasks. The following screenshot shows an example of the data visualization
    and photo popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another plugin called Photo2Shape is available, but it requires you to install
    an external EXIF tag parser.
  prefs: []
  type: TYPE_NORMAL
- en: Image change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Change detection allows you to automatically highlight the differences between
    two images in the same area if they are properly orthorectified. In this recipe,
    we'll do a simple difference change detection on two images, which are several
    years apart, to see the differences in urban development and the natural environment.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the two images for this recipe from [https://github.com/GeospatialPython/qgis/blob/gh-pages/change-detection.zip?raw=true](https://github.com/GeospatialPython/qgis/blob/gh-pages/change-detection.zip?raw=true)
    and put them in a directory named `change-detection` in the `rasters` directory
    of your `qgis_data` directory. Note that the file is 55 megabytes, so it may take
    several minutes to download.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use the QGIS raster calculator to subtract the images in order to get
    the difference, which will highlight significant changes. We''ll also add a color
    ramp shader to the output in order to visualize the changes. To do this, we need
    to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the libraries that we need in to the QGIS console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll set up the path names and raster names for our images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll establish our images as raster layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can build the calculator entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll set up the simple expression that does the math for remote sensing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can set up the output file path, the raster extent, and pixel width
    and height:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we perform the calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll load the output as a layer, create the color ramp shader, apply
    it to the layer, and add it to the map, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept is simple. We subtract the older image data from the new image data.
    Concentrating on urban areas tends to be highly reflective and results in higher
    image pixel values. If a building is added in the new image, it will be brighter
    than its surroundings. If a building is removed, the new image will be darker
    in that area. The same holds true for vegetation, to some extent.
  prefs: []
  type: TYPE_NORMAL
