<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Dealing with Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Dealing with Data</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Binding array as data</li><li class="listitem" style="list-style-type: disc">Binding object literals as data</li><li class="listitem" style="list-style-type: disc">Binding functions as data</li><li class="listitem" style="list-style-type: disc">Working with arrays</li><li class="listitem" style="list-style-type: disc">Filtering with data</li><li class="listitem" style="list-style-type: disc">Sorting with data</li><li class="listitem" style="list-style-type: disc">Loading data from server</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Introduction</h1></div></div></div><p>In this chapter, we are going to explore the most essential question in any data visualization project, how data can be represented both in programming constructs, and its visual metaphor. Before we start on this topic, some discussion on what data visualization is is necessary. In order to understand what data visualization<a id="id138" class="indexterm"/> is, first we need to understand the difference between data and information.</p><div class="blockquote"><blockquote class="blockquote"><p>Data <a id="id139" class="indexterm"/>are raw facts. The word raw indicates that the facts have not yet been processed to reveal their meaning...Information is the result of processing raw data to reveal its meaning.</p><p>(Rob P., S. Morris, and Coronel C. 2009)</p></blockquote></div><p>This is how data and information<a id="id140" class="indexterm"/> are traditionally defined in the digital information world. However, data visualization provides a much richer interpretation of this definition since information is no longer the mere result of processed raw facts but rather a visual metaphor of the facts. As suggested by Manuel Lima in his <span class="emphasis"><em>Information Visualization Manifesto</em></span> that design in the material world, where form is regarded to follow function. </p><p>The same data set can generate any number of visualizations which may lay equal claim in terms of its validity. In a sense, visualization is more about communicating the creator's insight into data than anything else. On a more provocative note, Card, McKinlay, and Shneiderman suggested that the practice of information visualization can be described as:</p><div class="blockquote"><blockquote class="blockquote"><p>The use of computer-supported, interactive, visual representations of abstract data to amplify cognition.</p><p>(Card S. &amp; Mackinly J. and Shneiderman B. 1999)</p></blockquote></div><p>In the following sections, we will explore various techniques D3 provides to bridge the data with the visual domain. It is the very first step we need to take before we can create a <span class="strong"><strong>cognition amplifier</strong></span>
<a id="id141" class="indexterm"/> with our data.</p><div class="section" title="The enter-update-exit pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>The enter-update-exit pattern</h2></div></div></div><p>The task of matching each datum with its visual representation, for example, drawing a single bar for every data point you have in your data set, updating the bars when the data points change, and then eventually removing the bars when certain data points no longer exist, seems to be a complicated and tedious task. This is precisely why D3 was designed to provide an ingenious way of simplifying the implementation of this connection. This way of defining the connection between data and its visual representation is usually referred to as the <span class="strong"><strong>enter-update-exit</strong></span> pattern<a id="id142" class="indexterm"/> in D3. This pattern is profoundly different from the typical <span class="strong"><strong>imperative method</strong></span>
<a id="id143" class="indexterm"/> most developers are familiar with. However, the understanding of this pattern is crucial to your effectiveness with D3 library, and therefore, in this section, we will focus on explaining the concept behind this pattern. First, let's take a look at the following conceptual illustration of the two domains:</p><div class="mediaobject"><img src="graphics/2162OS_03_01.jpg" alt="The enter-update-exit pattern"/><div class="caption"><p>Data and Visual Set</p></div></div><p>In the previous illustration, the two circles represent two joined sets. Set <span class="strong"><strong>A</strong></span> depicts your data set while set <span class="strong"><strong>B</strong></span> represents the visual elements. This is essentially how D3 sees the connection between your <a id="id144" class="indexterm"/>data and visual elements. You might be asking how elementary set theory is going to help your data visualization effort here. Let me explain.</p><p>Firstly, let us consider the question, <span class="emphasis"><em>how can I find all visual elements that currently represent its corresponding data point</em></span>? The answer is <span class="strong"><strong>A∩B</strong></span>; this denotes the intersection of sets A and B, the elements that exist in both <span class="strong"><strong>Data</strong></span> and <span class="strong"><strong>Visual</strong></span> domains.</p><div class="mediaobject"><img src="graphics/2162OS_03_02.jpg" alt="The enter-update-exit pattern"/><div class="caption"><p>Update Mode</p></div></div><p>The shaded area <a id="id145" class="indexterm"/>represents the intersection between the two sets—A and B. In D3, the <code class="literal">selection.data</code> function can be used to select this intersection—A∩B.</p><p>The <code class="literal">selection.data(data)</code> function, on a selection, <a id="id146" class="indexterm"/>sets up the connection between the data domain and visual domain as we discussed above. The initial selection forms the visual set <span class="strong"><strong>B</strong></span> while the data provided in the <code class="literal">data</code> function forms the data set <span class="strong"><strong>A</strong></span> respectively. The return result of this function is a new selection (a data-bound selection) of all elements existing in this intersection. Now, you can invoke the modifier function on this new selection to update all the existing elements. This mode of selection is usually referred to as the <span class="strong"><strong>Update</strong></span> mode.</p><p>The second question we need to answer here is <span class="emphasis"><em>how can I locate data that has not yet been visualized</em></span>. The answer is the set difference of A and B, denoted as <span class="strong"><strong>A\B</strong></span>, or visually, the following illustration:</p><div class="mediaobject"><img src="graphics/2162OS_03_03.jpg" alt="The enter-update-exit pattern"/><div class="caption"><p>Enter Mode</p></div></div><p>The shaded area in set<a id="id147" class="indexterm"/> <span class="strong"><strong>A</strong></span> represents the data points that have not yet been visualized. In order to gain access to this <span class="strong"><strong>A\B</strong></span> subset, the following functions need to be performed on a data-bound D3 selection (a selection returned by the <code class="literal">data</code> function).</p><p>The <code class="literal">selection.data(data).enter()</code> function<a id="id148" class="indexterm"/> returns a new selection representing the <span class="strong"><strong>A\B</strong></span> subset, which contains all the data that has not yet been represented in the visual domain. The regular modifier function can then be chained to this new selection method to create new visual elements representing the given data elements. This mode of selection is simply referred to as the <span class="strong"><strong>Enter</strong></span> mode.</p><p>The last case in our discussion covers the visual elements that exist in our data set but no longer have any corresponding data element associated with them. You might ask how this kind of visual element can exist in the first place. This is usually caused by removing the elements from the data set. If you initially visualized all data elements within your data set, after that you have removed some data elements. Now, you have certain visual elements that are no longer representing any valid data point in your data set. This subset can be discovered by using an inverse of the <span class="strong"><strong>Update</strong></span> difference, denoted as <span class="strong"><strong>B\A</strong></span>.</p><div class="mediaobject"><img src="graphics/2162OS_03_04.jpg" alt="The enter-update-exit pattern"/><div class="caption"><p>Exit Mode</p></div></div><p>The shaded <a id="id149" class="indexterm"/>area in the previous illustration represents the difference we discussed here. The subset can be selected using the <code class="literal">selection.exit</code> function<a id="id150" class="indexterm"/> on a data-bound selection.</p><p>The <code class="literal">selection.data(data).exit</code> function, when invoked on a data-bound D3 selection, <a id="id151" class="indexterm"/>computes a new selection which contains all visual elements that are no longer associated with any valid data element. As a valid D3 selection object, the modifier function can then be chained to this selection to update and remove these visual elements that are no longer needed as part of our visualization. This mode of selection is called the <span class="strong"><strong>Exit</strong></span> mode.</p><p>Together, the three different selection modes cover all possible cases of interaction between the data and visual domain. The <span class="strong"><strong>enter-update-exit</strong></span> pattern is the cornerstone of any D3-driven visualization. In the following recipes of this chapter, we will cover the topics on how these selection methods can be utilized to generate data-driven visual elements efficiently and easily.</p></div></div></div>
<div class="section" title="Binding an array as data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Binding an array as data</h1></div></div></div><p>One of the most<a id="id152" class="indexterm"/> common and popular ways to define data in D3 visualization <a id="id153" class="indexterm"/>is through the use of JavaScript arrays. For example, say you have multiple data elements stored in an array, and you want to generate corresponding visual elements to represent each and every one of them. Additionally, when the data array gets updated, you want your visualization to reflect such changes immediately. In this recipe, we will accomplish this common approach.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/array-as-data.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/array-as-data.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>How to do it...</h2></div></div></div><p>The first and most <a id="id154" class="indexterm"/>natural solution that might come to mind is iterating through the data<a id="id155" class="indexterm"/> array elements and generating their corresponding visual elements on the page. This is definitely a valid solution and it will work with D3, however, the enter-update-exit pattern we discussed in the introduction provides a much easier and more efficient way to generate visual elements. Let's have a look at how we do that:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var data = [10, 15, 30, 50, 80, 65, 55, 30, 20, 10, 8]; // &lt;- A</strong></span>

function render(data) { // &lt;- B
        // Enter
<span class="strong"><strong>        d3.select("body").selectAll("div.h-bar") // &lt;- C</strong></span>
<span class="strong"><strong>            .data(data) // &lt;- D</strong></span>
<span class="strong"><strong>            .enter() // &lt;- E</strong></span>
<span class="strong"><strong>            .append("div") // &lt;- F</strong></span>
<span class="strong"><strong>              .attr("class", "h-bar")</strong></span>
<span class="strong"><strong>                .append("span"); // &lt;- G</strong></span>

        // Update
<span class="strong"><strong>        d3.select("body").selectAll("div.h-bar")</strong></span>
<span class="strong"><strong>            .data(data) </strong></span>
<span class="strong"><strong>              .style("width", function (d) { // &lt;- H</strong></span>
<span class="strong"><strong>                return (d * 3) + "px";</strong></span>
<span class="strong"><strong>              })</strong></span>
<span class="strong"><strong>              .select("span") // &lt;- I</strong></span>
<span class="strong"><strong>                .text(function (d) {</strong></span>
<span class="strong"><strong>                  return d;</strong></span>
<span class="strong"><strong>                });</strong></span>
                
        // Exit
<span class="strong"><strong>        d3.select("body").selectAll("div.h-bar")</strong></span>
<span class="strong"><strong>            .data(data)</strong></span>
<span class="strong"><strong>            .exit() // &lt;- J</strong></span>
               .remove();        
 }

 setInterval(function () { // &lt;- K
        data.shift();
        data.push(Math.round(Math.random() * 100));

        render(data);
 }, 1500);

 render(data);</pre></div><p>This recipe generates the following visual output:</p><div class="mediaobject"><img src="graphics/2162OS_03_05.jpg" alt="How to do it..."/><div class="caption"><p>Data as Array</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>How it works...</h2></div></div></div><p>In this example, <a id="id156" class="indexterm"/>data (a list of integers in this case) is stored in a simple JavaScript<a id="id157" class="indexterm"/> array as shown on the line marked as <code class="literal">A</code> with an arrow left of it. The <code class="literal">render</code> function is defined on the line marked as <code class="literal">B</code> so that it can be repeatedly invoked to update our visualization. The <code class="literal">Enter</code> selection implementation starts on the line marked as <code class="literal">C</code>, which selects all <code class="literal">div</code> elements on the web page with <code class="literal">h-bar</code> CSS class. You are probably wondering why we are selecting these <code class="literal">div</code> elements since they don't even exist on the web page yet. This is in fact true; however, the selection at this point is used to define the visual set we discussed in the introduction. By issuing this selection that we made in the previous line we are essentially declaring that there should be a set of <code class="literal">div.h-bar</code> elements on the web page to form our visual set. On the line marked as <code class="literal">D</code>, we invoke the <code class="literal">data</code> function on this initial selection to bind the array as our data set to the to-be-created visual elements. Once the two sets are defined, the <code class="literal">enter()</code> function<a id="id158" class="indexterm"/> can be used to select all data elements that are not yet visualized. When the <code class="literal">render</code> function is invoked for the very first time, it returns all elements in the data array, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">        d3.select("body").selectAll("div.h-bar") // &lt;- C
             .data(data) // &lt;- D
            .enter() // &lt;- E
             .append("div") // &lt;- F
               .attr("class", "h-bar")
              .append("span"); // &lt;- G</pre></div><p>On line <code class="literal">F</code>, a new <code class="literal">div</code> element is created and appended to the <code class="literal">body</code> element of each data element selected in the <code class="literal">enter</code> function; this essentially creates one <code class="literal">div</code> element for each data element. Finally, on line <code class="literal">G</code>, an element called <code class="literal">span</code> is created and appended to the <code class="literal">div</code> element and we set its CSS class to <code class="literal">h-bar</code>. At this point, we have basically created the skeleton of our visualization including empty <code class="literal">div</code> and <code class="literal">span</code> elements. Next step is to change the visual attributes of our elements based on the given data.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>D3 injects a property to the DOM element named <code class="literal">__data__</code> to make data sticky with visual elements so when selections are made using a modified data set, D3 can compute the difference and intersection correctly. You can see this property easily if you inspect the DOM element either visually using a debugger or programmatically.</p><div class="mediaobject"><img src="graphics/2162OS_03_11.jpg" alt="How it works..."/></div><p>As illustrated by the preceding screenshot, this is a very useful fact to know when you are debugging your visualization implementation.</p></div></div><p>In the <code class="literal">Update</code> <a id="id159" class="indexterm"/>section of <code class="literal">array-as-data.html</code>, the first two lines are identical to what <a id="id160" class="indexterm"/>we have done in the <code class="literal">Enter</code> section, and this essentially defines our data set and visual set respectively. The major difference here is on line <code class="literal">H</code>. Instead of calling the <code class="literal">enter</code> function, as we did in the code mentioned under <code class="literal">Enter</code> in the previous paragraphs, in the <code class="literal">Update</code> mode we directly apply modifier functions to the selection made by the <code class="literal">data</code> function. In the <code class="literal">Update</code> mode, <code class="literal">data</code> function returns the intersection between the data set and visual set (A∩B). On line <code class="literal">H</code>, we apply a dynamic style attribute <code class="literal">width</code> to be three times the integer value associated with each visual element shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">        d3.select("body").selectAll("div.h-bar")
            .data(data) 
                <span class="strong"><strong>.style("width", function (d)</strong></span> { // &lt;- H
                    return (d * 3) + "px";
                })
                .select("span") // &lt;- I
                    .text(function (d) {
                        return d;
                    });</pre></div><p>All D3 modifier functions accept this type of dynamic function to compute its value on the fly. This is precisely what it means to "data drive" your visualization. Hence, it is crucial to understand what this function is designed to achieve in our example. This function receives a parameter <code class="literal">d</code>, which is the datum associated with the current element. In our example, the first <code class="literal">div</code> bar has the value <code class="literal">10</code> associated as its datum, while the second bar has <code class="literal">15</code>, and so on. Therefore, this function essentially computes a numeric value that is three times the datum for each bar and returns it as the <code class="literal">width</code> in pixels. </p><p>Another interesting point worth <a id="id161" class="indexterm"/>mentioning here is on line <code class="literal">I</code>, where we mention the <code class="literal">span</code> attribute. The<a id="id162" class="indexterm"/> child <code class="literal">span</code> element can also use dynamic modifier functions and has access to the same datum propagated from its parent element. This is the default behavior of D3 data binding. Any element you append to a data-bound element automatically inherits the parent's datum.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The <span class="strong"><strong>dynamic modifier function</strong></span>
<a id="id163" class="indexterm"/> actually accepts two parameters <code class="literal">d</code> and <code class="literal">i</code>. The first parameter <code class="literal">d</code> is the associated datum we have discussed here and <code class="literal">i</code> is a zero-based index number for the current element. Some recipes in the previous chapter have relied on this index, and in the rest of this chapter, we will see other recipes that utilize this index in different ways.</p></div></div><p>This is the raw HTML code resulted from this update process:</p><div class="informalexample"><pre class="programlisting">&lt;div class="h-bar" style="width: 30px;"&gt;
&lt;span&gt;10&lt;/span&gt;
&lt;/div&gt;
&lt;div class="h-bar" style="width: 45px;"&gt;
&lt;span&gt;15&lt;/span&gt;
&lt;/div&gt;
....
&lt;div class="h-bar" style="width: 24px;"&gt;
&lt;span&gt;8&lt;/span&gt;
   &lt;/div&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>Elements created and appended in the <code class="literal">enter</code> mode, that is, on line <code class="literal">F</code> and <code class="literal">G</code>, are automatically added to the <code class="literal">update</code> set. So, there is no need to repeat visual attributes modification logic in both <code class="literal">enter</code> and <code class="literal">update</code> section of code.</p></div></div><p>The last section—<code class="literal">Exit</code> section—is fairly simple as shown here:</p><div class="informalexample"><pre class="programlisting">        d3.select("body").selectAll("div.h-bar")
            .data(data)
            .exit() // &lt;- J
            .remove();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>The selection returned by the <code class="literal">exit()</code> function<a id="id164" class="indexterm"/> is just like any other selection. Therefore, although <code class="literal">remove</code> is the most common action used against the <code class="literal">exit</code> selection, you can also apply other modifiers or transitions to this selection. We will explore some of these options in later chapters.</p></div></div><p>On line <code class="literal">J</code>, the <code class="literal">exit()</code> function is called to compute the set difference of all visual elements that <a id="id165" class="indexterm"/>are no longer associated with any data. Finally, the <code class="literal">remove()</code> function<a id="id166" class="indexterm"/> is <a id="id167" class="indexterm"/>called on this selection to remove all the elements selected by the <code class="literal">exit()</code> function. This way, as long as we call the <code class="literal">render()</code> function<a id="id168" class="indexterm"/> after we change our data, we can always ensure that our visual representation and data are kept synchronized.</p><p>Now, the last block of code is as follows:</p><div class="informalexample"><pre class="programlisting">setInterval(function () { // &lt;- K
        data.shift();
        data.push(Math.round(Math.random() * 100));
        render(data);
 }, 1500);</pre></div><p>On line <code class="literal">K</code>, a simple function called <code class="literal">function()</code> was created to remove the top element in the data array using the <code class="literal">shift</code> function, while appending a random integer to the data array using the <code class="literal">push()</code> function<a id="id169" class="indexterm"/> every 1.5 seconds. Once the data array is updated, the <code class="literal">render()</code> function is called again to update our visualization keeping it synchronized with the new data set. This is what gives our example its animated bar chart look.</p></div></div>
<div class="section" title="Binding object literals as data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Binding object literals as data</h1></div></div></div><p>With a more complex <a id="id170" class="indexterm"/>visualization, each element we have in a data array <a id="id171" class="indexterm"/>might not be a primitive integer value or a string, but a JavaScript object themselves. In this recipe, we will discuss how this more complex data structure can be leveraged to drive your visualization using D3.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/object-as-data.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/object-as-data.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>How to do it...</h2></div></div></div><p>JavaScript object literal is probably the most common data structure you will encounter when loading data sources on the Web. In this recipe, we will look at how these JavaScript objects can be leveraged to generate rich visualization. Here is how to do it in code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var data = [ // &lt;- A</strong></span>
<span class="strong"><strong>        {width: 10, color: 23},{width: 15, color: 33},</strong></span>
<span class="strong"><strong>        {width: 30, color: 40},{width: 50, color: 60},</strong></span>
<span class="strong"><strong>        {width: 80, color: 22},{width: 65, color: 10},</strong></span>
<span class="strong"><strong>        {width: 55, color: 5},{width: 30, color: 30},</strong></span>
<span class="strong"><strong>        {width: 20, color: 60},{width: 10, color: 90},</strong></span>
<span class="strong"><strong>        {width: 8, color: 10}</strong></span>
<span class="strong"><strong>    ];</strong></span>
    
var colorScale = d3.scale.linear()
.domain([0, 100]).<span class="strong"><strong>range(["#add8e6", "blue"])</strong></span>; // &lt;- B

    function render(data) {
        d3.select("body").selectAll("div.h-bar")
            .data(data)
            .enter().append("div")
                .attr("class", "h-bar") 
            .append("span");

        d3.select("body").selectAll("div.h-bar")
            .data(data)
            .exit().remove();

        d3.select("body").selectAll("div.h-bar")
            .data(data)
                .attr("class", "h-bar")
<span class="strong"><strong>                .style("width", function (d) { // &lt;- C</strong></span>
<span class="strong"><strong>                    return (d.width * 5) + "px"; // &lt;- D</strong></span>
<span class="strong"><strong>                })</strong></span>
<span class="strong"><strong>                .style("background-color", function(d){</strong></span>
<span class="strong"><strong>                    return colorScale(d.color); // &lt;- E</strong></span>
<span class="strong"><strong>                })</strong></span>
            .select("span")
<span class="strong"><strong>                .text(function (d) {</strong></span>
<span class="strong"><strong>                    return d.width; // &lt;- F</strong></span>
<span class="strong"><strong>                });</strong></span>
    }

    function randomValue() {
        return Math.round(Math.random() * 100);
    }

    setInterval(function () {
        data.shift();
        data.push({width: randomValue(), color: randomValue()});
        render(data);
    }, 1500);

    render(data);</pre></div><p>This recipe generates the<a id="id172" class="indexterm"/> following <a id="id173" class="indexterm"/>visualization:</p><div class="mediaobject"><img src="graphics/2162OS_03_06.jpg" alt="How to do it..."/><div class="caption"><p>Data as Object</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>How it works...</h2></div></div></div><p>In this recipe, instead of simple integers as in the previous recipe, now our data array is filled with objects (see the line marked as <code class="literal">A</code> with an arrow left to it). Each data object contains two attributes—<code class="literal">width</code> and <code class="literal">color</code>—that are both integers in this case.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>This recipe is built on top of the previous recipe so if you are not familiar with the fundamental enter-update-exit selection pattern, please review the previous recipe first.</p></div></div><p>   var data = [ // &lt;- A</p><div class="informalexample"><pre class="programlisting">        {width: 10, color: 23},{width: 15, color: 33},
...
        {width: 8, color: 10}
    ];</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>On line <code class="literal">B</code>, we have a complicated-looking color scale defined. Scales, including color scale, will be discussed in depth in the next chapter, so for now let us just assume this is a scale function we can use to produce CSS-compatible color code given some integer input value. This is sufficient for the purpose of this recipe.</p></div></div><p>The major difference <a id="id174" class="indexterm"/>between<a id="id175" class="indexterm"/> this recipe and the previous one is how data is handled as shown on line <code class="literal">C</code>:</p><div class="informalexample"><pre class="programlisting">function (d) { // &lt;- C
return (d.width * 5) + "px"; // &lt;- D
}</pre></div><p>As we can see in the preceding code snippet, in this recipe the datum associated with each visual element is actually an object, not an integer. Therefore, we can access the <code class="literal">d.width</code> attribute on line <code class="literal">D</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>If your object has functions of its own, you can also access them here in a dynamic modifier function. This is a convenient way to add some data-specific helper functions in your data source. However, beware that since dynamic functions are usually invoked numerous times during visualization, the function you rely on should be implemented as efficiently as possible. If this is not possible, then it is best to preprocess your data before binding them to your visualization process.</p></div></div><p>Similarly on line <code class="literal">E</code>, the <code class="literal">background-color</code> style can be computed using the <code class="literal">d.color</code> attribute with the color scale we defined earlier:</p><div class="informalexample"><pre class="programlisting">.style(<span class="strong"><strong>"background-color"</strong></span>, function(d){
  return colorScale(<span class="strong"><strong>d.color</strong></span>); // &lt;- E
})
.select("span")
  .text(function (d) {
    return d.width; // &lt;- F
  });</pre></div><p>The child element <code class="literal">span</code> again inherits its parent's associated datum, and hence, it also has access to the same datum object in its dynamic modifier function on line <code class="literal">F</code> setting the textual content to <code class="literal">d.width</code> attribute.</p><p>This recipe demonstrates <a id="id176" class="indexterm"/>how JavaScript objects can easily be bound to visual elements<a id="id177" class="indexterm"/> using exactly the same method discussed in the previous recipe. This is one of the most powerful capabilities of the D3 library; it allows you to re-use the same pattern and method to handle different types of data, simple or complex. We will see more examples on this topic in the next recipe.</p></div></div>
<div class="section" title="Binding functions as data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Binding functions as data</h1></div></div></div><p>One of the benefits of <a id="id178" class="indexterm"/>D3's excellent support for functional style JavaScript <a id="id179" class="indexterm"/>programming is that it allows functions to be treated as data as well. This particular feature can offer some very powerful capabilities under certain circumstances. This is a more advanced recipe. Don't worry about it if you are new to D3 and having some difficulty understanding it at first. Over time, this kind of usage will become natural to you.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/function-as-data.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/function-as-data.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>How to do it...</h2></div></div></div><p>In this recipe, we will explore the possibility of binding functions themselves as data to your visual elements. This capability is extremely powerful and flexible if used correctly:</p><div class="informalexample"><pre class="programlisting">&lt;div id="container"&gt;&lt;/div&gt;

&lt;script type="text/javascript"&gt;
    var data = []; // &lt;- A

<span class="strong"><strong>    var next = function (x) { // &lt;- B</strong></span>
<span class="strong"><strong>        return 15 + x * x;</strong></span>
<span class="strong"><strong>    };</strong></span>
    
<span class="strong"><strong>   var newData = function () { // &lt;- C        </strong></span>
<span class="strong"><strong>        data.push(next);</strong></span>
<span class="strong"><strong>        return data;</strong></span>
<span class="strong"><strong>    };</strong></span>

   function render(){
        var selection = d3.select("#container")
                  .selectAll("div")
<span class="strong"><strong>                   .data(newData); // &lt;- D</strong></span>

        selection.enter().append("div").append("span");

        selection.exit().remove();

        selection.attr("class", "v-bar")
<span class="strong"><strong>            .style("height", function (d, i) {</strong></span>
<span class="strong"><strong>                return d(i)+"px"; // &lt;- E</strong></span>
<span class="strong"><strong>            })</strong></span>
        .select("span")
<span class="strong"><strong>            .text(function(d, i){ </strong></span>
<span class="strong"><strong>              return d(i); } // &lt;- F</strong></span>
<span class="strong"><strong>            ); </strong></span>
   }
    
   setInterval(function () {
       render();
   }, 1500);

   render();
&lt;/script&gt;</pre></div><p>This preceding code <a id="id180" class="indexterm"/>produces<a id="id181" class="indexterm"/> the following bar chart:</p><div class="mediaobject"><img src="graphics/2162OS_03_07.jpg" alt="How to do it..."/><div class="caption"><p>Data as Function</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>How it works...</h2></div></div></div><p>In this recipe, we <a id="id182" class="indexterm"/>chose to visualize the output of formula <code class="literal">15 + x * x</code> using a <a id="id183" class="indexterm"/>series of vertical bars, each of them annotated with its representing integral value. This visualization adds a new bar to the right of the previous one every one and a half seconds. We can of course implement this visualization using the techniques we have discussed in the previous two recipes. So we generated an array of integers using the formula, then just appended a new integer from <span class="emphasis"><em>n</em></span> to <span class="emphasis"><em>n+1</em></span> every 1.5 seconds before re-rendering the visualization. However, in this recipe, we decided to take a more functional approach.</p><p>This time we started with an empty data array on line <code class="literal">A</code>. On line <code class="literal">B</code>, a simple function is defined to calculate the result of this formula <span class="emphasis"><em>15+x^2</em></span>. Then on line <code class="literal">C</code>, another function is created to generate the current data set which contains <span class="emphasis"><em>n+1</em></span> references to the <code class="literal">next</code> function. Here is the code for functional data definition:</p><div class="informalexample"><pre class="programlisting">    var data = []; // &lt;- A

    var next = function (x) { // &lt;- B
        return 15 + x * x;
    };
    
   var newData = function () { // &lt;- C        
        data.push(next);
        return data;
    };</pre></div><p>This seems to be a strange setup to achieve our visualizational goal. Let's see how we can leverage all these functions in our visualization code. On line <code class="literal">D</code>, we bind our data to a selection of <code class="literal">div</code> elements just as we did in previous recipes. However, this time the data is not an array but rather the <code class="literal">newData</code> function:</p><div class="informalexample"><pre class="programlisting">        var selection = d3.select("#container")
                   .selectAll("div")
                   .data(newData); // &lt;- D</pre></div><p>D3 is pretty flexible <a id="id184" class="indexterm"/>when it comes to data. If you provide a function to the <code class="literal">data</code> function, D3 will simply invoke the given function and use the returned value of this <a id="id185" class="indexterm"/>function as a parameter of the<a id="id186" class="indexterm"/> <code class="literal">data</code> function. In this case, the data being returned by the <code class="literal">newData</code> function is an array of function references. As the result of this, now in our dynamic modifier function, on line <code class="literal">E</code> and <code class="literal">F</code>, the datum <code class="literal">d</code> that is being passed into these functions are actually references to the <code class="literal">next</code> function, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">        selection.attr("class", "v-bar")
            .style("height", function (d, i) {
                return d(i)+"px"; // &lt;- E
            })
            .select("span")
                .text(function(d, i){ 
                    return d(i); } // &lt;- F
                ); </pre></div><p>As a reference to a function, <code class="literal">d</code> can now be invoked with index <code class="literal">i</code> as the parameter, which in turn generates the output of the formula needed for our visualization.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>In JavaScript, functions are special objects, so semantically this is exactly the same as binding objects as data. Another note on this topic is that data can also be considered as functions. Constant values such as integers can be thought of as a static function that simply returns what it receives with no modification made.</p></div></div><p>This technique might not be the most commonly-used technique in visualization, but when used properly, it is extremely flexible and powerful, especially when you have a fluid data set.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Datum function typically needs to be <span class="strong"><strong>idempotent</strong></span>
<a id="id187" class="indexterm"/> to make sense. Idempotence is the property of being able to apply the same function with the same inputs multiple times without changing the result beyond the initial application. For more detail on idempotence visit: <a class="ulink" href="http://en.wikipedia.org/wiki/Idempotence">http://en.wikipedia.org/wiki/Idempotence</a>
</p></div></div></div></div>
<div class="section" title="Working with arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Working with arrays</h1></div></div></div><p>Most of our data is stored<a id="id188" class="indexterm"/> in arrays, and we spend a lot of our effort working with arrays to format and restructure data. This is why D3 provides a rich set of array-oriented utilities functions, making this task a lot easier. In this recipe, we will explore some of the most common and helpful utilities in this aspect.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/working-with-array.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/working-with-array.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>How to do it...</h2></div></div></div><p>The following code example shows some of the most common and helpful array utility functions offered by the D3 library and their effects:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
<code class="literal">    // Static html code were omitted due to space constraint</code>

    var array = [3, 2, 11, 7, 6, 4, 10, 8, 15];

    d3.select("#min").text(d3.min(array));
    d3.select("#max").text(d3.max(array));
    d3.select("#extent").text(d3.extent(array));
    d3.select("#sum").text(d3.sum(array));
    d3.select("#median").text(d3.median(array));
    d3.select("#mean").text(d3.mean(array));
    d3.select("#asc").text(array.sort(d3.ascending));
d3.select("#desc").text(array.sort(d3.descending));      d3.select("#quantile").text(
d3.quantile(array.sort(d3.ascending), 0.25)
);
d3.select("#bisect").text(
d3.bisect(array.sort(d3.ascending), 6)
    );

    var records = [
        {quantity: 2, total: 190, tip: 100, type: "tab"},
        {quantity: 2, total: 190, tip: 100, type: "tab"},
        {quantity: 1, total: 300, tip: 200, type: "visa"},
        {quantity: 2, total: 90, tip: 0, type: "tab"},
        {quantity: 2, total: 90, tip: 0, type: "tab"},
        {quantity: 2, total: 90, tip: 0, type: "tab"},
        {quantity: 1, total: 100, tip: 0, type: "cash"},
        {quantity: 2, total: 90, tip: 0, type: "tab"},
        {quantity: 2, total: 90, tip: 0, type: "tab"},
        {quantity: 2, total: 90, tip: 0, type: "tab"},
        {quantity: 2, total: 200, tip: 0, type: "cash"},
        {quantity: 1, total: 200, tip: 100, type: "visa"}
    ];

    var nest = d3.nest()
            .key(function (d) { // &lt;- A
                return d.type;
            })
            .key(function (d) { // &lt;- B
                return d.tip;
            })
            .entries(records); // &lt;- C

    d3.select("#nest").html(printNest(nest, ""));

    function printNest(nest, out, i) {
        if(i === undefined) i = 0;

        var tab = ""; 
        for(var j = 0; j &lt; i; ++j) 
            tab += " ";

        nest.forEach(function (e) {
            if (e.key)
                out += tab + e.key + "&lt;br&gt;";
            else
                out += tab + printObject(e) + "&lt;br&gt;";

            if (e.values)
                out = printNest(e.values, out, ++i);
            else
                return out;
        });

        return out;
    }

    function printObject(obj) {
        var s = "{";
        for (var f in obj) {
            s += f + ": " + obj[f] + ", ";
        }
        s += "}";
        return s;
    }
&lt;/script&gt; </pre></div><p>The preceding code <a id="id189" class="indexterm"/>produces the following output:</p><div class="informalexample"><pre class="programlisting">d3.min =&gt; 2
d3.max =&gt; 15
d3.extent =&gt; 2,15
d3.sum =&gt; 66
d3.median =&gt; 7
d3.mean =&gt; 7.333333333333333
array.sort(d3.ascending) =&gt; 2,3,4,6,7,8,10,11,15
array.sort(d3.descending) =&gt; 15,11,10,8,7,6,4,3,2
d3.quantile(array.sort(d3.ascending), 0.25) =&gt; 4
d3.bisect(array.sort(d3.ascending), 6) =&gt; 4

tab100{quantity: 2, total: 190, tip: 100, type: tab, }{quantity: 2, total: 190, tip: 100, type: tab, }0{quantity: 2, total: 90, tip: 0, type: tab, }{quantity: 2, total: 90, tip: 0, type: tab, }{quantity: 2, total: 90, tip: 0, type: tab, }{quantity: 2, total: 90, tip: 0, type: tab, }{quantity: 2, total: 90, tip: 0, type: tab, }{quantity: 2, total: 90, tip: 0, type: tab, }visa200{quantity: 1, total: 300, tip: 200, type: visa, }100{quantity: 1, total: 200, tip: 100, type: visa, }cash, }0{quantity: 1, total: 100, tip: 0, type: cash, }{quantity: 2, total: 200, tip: 0, type: cash, }</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>How it works...</h2></div></div></div><p>D3 provides a<a id="id190" class="indexterm"/> variety of utility functions to help perform operations on JavaScript arrays. Most of them are pretty intuitive and straightforward, however, there are a few intrinsic ones. We will discuss them briefly in this section.</p><p>Given our array as <code class="literal">[3, 2, 11, 7, 6, 4, 10, 8, 15]</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.min</code>: This function retrieves the smallest element, that is, <code class="literal">2</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.max</code>: This function retrieve the largest element, that is, <code class="literal">15</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.extent</code>: This function retrieves both the smallest and the largest element, that is, <code class="literal">[2, 15]</code> </li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.sum</code>: This function retrieves the addition of all elements in the array, that is, <code class="literal">66</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.medium</code>: This function finds the medium, that is, <code class="literal">7</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.mean</code>: This function calculates the mean value, that is, <code class="literal">7.33</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.ascending</code> / <code class="literal">d3.descending</code>: The <code class="literal">d3</code> object comes with a built-in comparator function that you can use to sort the JavaScript array<div class="informalexample"><pre class="programlisting">d3.ascending = function(a, b) {  return a &lt; b ? -1 : a &gt; b ? 1 : 0; }
d3.descending = function(a, b) {  return b &lt; a ? -1 : b &gt; a ? 1 : 0; }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.quantile</code>: This function calculates the quantile on an already sorted array in ascending order, that is, quantile of <code class="literal">0.25</code> is <code class="literal">4</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.bisect</code>: This function finds an insertion point that comes after (to the right of) any existing element of an already sorted array, that is, bisect <code class="literal">(array, 6)</code> produce <code class="literal">4</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.nest</code>: D3's <code class="literal">nest</code> function can be used to build an algorithm that transforms a flat array-based data structure into a hierarchical nested structure, that is, particularly suitable for some types of visualization. D3's <code class="literal">nest</code> function can be configured using the <code class="literal">key</code> function chained to <code class="literal">nest</code>, as seen on lines <code class="literal">A</code> and <code class="literal">B</code>:<div class="informalexample"><pre class="programlisting">    var nest = d3.nest()
            .key(function (d) { // &lt;- A
                return d.type;
            })
            .key(function (d) { // &lt;- B
                return d.tip;
            })
            .entries(records); // &lt;- C</pre></div><p>Multiple <code class="literal">key</code> functions can be provided to generate multiple levels of nesting. In our case the nesting consists of two levels, first by the <code class="literal">type</code> amount and then by the <code class="literal">tip</code> amount, as demonstrated in the output below:</p><div class="informalexample"><pre class="programlisting">tab
 100
  {quantity: 2, total: 190, tip: 100, type: tab, }
  {quantity: 2, total: 190, tip: 100, type: tab, }</pre></div><p>Finally, the <code class="literal">entries()</code> function is<a id="id191" class="indexterm"/> used to supply the flat array-based data set as shown on line <code class="literal">C</code>.</p></li></ul></div></div></div>
<div class="section" title="Filtering with data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Filtering with data</h1></div></div></div><p>Imagine you need to filter D3 selection based on the associated data elements so that you can hide/show different sub-datasets based on the user's input. D3 selection provides a filter function to perform this kind of <a id="id192" class="indexterm"/>data-driven filtering. In this recipe, we will show you how this can be leveraged to filter visual elements in a data-driven fashion.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-filter.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-filter.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>How to do it...</h2></div></div></div><p>The following example code shows how data-based filtering can be leveraged to highlight different visual elements based on its categorization:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var data = [ // &lt;-A
        {expense: 10, category: "Retail"},
        {expense: 15, category: "Gas"},
        {expense: 30, category: "Retail"},
        {expense: 50, category: "Dining"},
        {expense: 80, category: "Gas"},
        {expense: 65, category: "Retail"},
        {expense: 55, category: "Gas"},
        {expense: 30, category: "Dining"},
        {expense: 20, category: "Retail"},
        {expense: 10, category: "Dining"},
        {expense: 8, category: "Gas"}
    ];
    function render(data, category) {
        d3.select("body").selectAll("div.h-bar") // &lt;-B
                .data(data)
            .enter()
            .append("div")
                .attr("class", "h-bar")
            .append("span");

        d3.select("body").selectAll("div.h-bar") // &lt;-C
                .data(data)
            .exit().remove();

        d3.select("body").selectAll("div.h-bar") // &lt;-D
                .data(data)
            .attr("class", "h-bar")
            .style("width", function (d) {
                return (d.expense * 5) + "px";}
            )
            .select("span")
                .text(function (d) {
                    return d.category;
                });

        d3.select("body").selectAll("div.h-bar")
<span class="strong"><strong>                .filter(function (d, i) { // &lt;-E</strong></span>
<span class="strong"><strong>                    return d.category == category;</strong></span>
<span class="strong"><strong>                })</strong></span>
                .classed("selected", true);
    }

    render(data);

    function select(category) {
        render(data, category);
    }
&lt;/script&gt;

&lt;div class="control-group"&gt;
    &lt;button onclick="select('Retail')"&gt;
      Retail
    &lt;/button&gt;
    &lt;button onclick="select('Gas')"&gt;
      Gas
    &lt;/button&gt;
    &lt;button onclick="select('Dining')"&gt;
      Dining
    &lt;/button&gt;
    &lt;button onclick="select()"&gt;
      Clear
    &lt;/button&gt;
&lt;/div&gt;</pre></div><p>The preceding code generates the following visual output once the <span class="strong"><strong>Dinning</strong></span> button is clicked:</p><div class="mediaobject"><img src="graphics/2162OS_03_08.jpg" alt="How to do it..."/><div class="caption"><p>Data-based Filtering</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>How it works...</h2></div></div></div><p>In this recipe, we have a <a id="id193" class="indexterm"/>data set consisting of a list of personal expense records with <code class="literal">expense</code> and <code class="literal">category</code> as attributes, which is shown on the block of code marked as <code class="literal">A</code>. On line <code class="literal">B</code>, <code class="literal">C</code>, and <code class="literal">D</code>, a set of horizontal bars (HTML div) were created using the standard enter-update-exit pattern to represent the expense records. So far, this recipe is similar to the <span class="emphasis"><em>Binding object literals as data</em></span> recipe. Now let's take a look at line <code class="literal">E</code>:</p><div class="informalexample"><pre class="programlisting">filter(function (d, i) { // &lt;-E
    return d.category == category;
})</pre></div><p>D3 <code class="literal">selection.filter</code> function takes a function as its parameter. It applies the function against every element in the existing selection. The given function for <code class="literal">filter</code> takes two parameters with a hidden reference:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d:</code> It is the datum associated with the current element</li><li class="listitem" style="list-style-type: disc"><code class="literal">i</code>: It is a zero-based index for the current element</li><li class="listitem" style="list-style-type: disc"><code class="literal">this</code>: This has the hidden reference points to the current DOM element</li></ul></div><p>D3 <code class="literal">selection.filter</code> function<a id="id194" class="indexterm"/> expects the given function to return a Boolean <a id="id195" class="indexterm"/>value. If the returned value is true, the corresponding element will be included into the new selection being returned by the <code class="literal">filter</code> function. In our example, the <code class="literal">filter</code> function essentially selects all bars that match the user-selected category and applies a CSS class <code class="literal">selected</code> to each one of them. This method provides you a powerful way to filter and generate data-driven sub-selection, which you can further manipulate or dissect to generate focused visualization.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>D3 <code class="literal">selection.filter</code> function treats the returned value using JavaScript <span class="strong"><strong>truthy</strong></span>
<a id="id196" class="indexterm"/> and<a id="id197" class="indexterm"/> <span class="strong"><strong>falsy tests</strong></span>, thus not exactly expecting a strict Boolean value. What this means is that false, null, <code class="literal">0</code>, "", undefined, and <span class="strong"><strong>NaN</strong></span> (not a number) are all treated as false while other things are considered true.</p></div></div></div></div>
<div class="section" title="Sorting with data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Sorting with data</h1></div></div></div><p>In many cases, it is <a id="id198" class="indexterm"/>desirable to sort your visual elements according to the data they represent so that you can highlight the significance of different elements visually. In this recipe, we will explore how this can be achieved in D3.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-sort.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/data-sort.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/>How to do it...</h2></div></div></div><p>Let's see how data-driven sorting and further manipulation can be performed using D3. In this example, we will sort the bar chart we created in the previous recipe based on either expense (width) or category <a id="id199" class="indexterm"/>using user's input:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var data = [ // &lt;-A
        {expense: 10, category: "Retail"},
        {expense: 15, category: "Gas"},
        {expense: 30, category: "Retail"},
        {expense: 50, category: "Dining"},
        {expense: 80, category: "Gas"},
        {expense: 65, category: "Retail"},
        {expense: 55, category: "Gas"},
        {expense: 30, category: "Dining"},
        {expense: 20, category: "Retail"},
        {expense: 10, category: "Dining"},
        {expense: 8, category: "Gas"}
    ];

    function render(data, comparator) {
        d3.select("body").selectAll("div.h-bar") // &lt;-B
                .data(data)
            .enter().append("div")
                .attr("class", "h-bar")
                .append("span");

        d3.select("body").selectAll("div.h-bar") // &lt;-C
                .data(data)
            .exit().remove();

        d3.select("body").selectAll("div.h-bar") // &lt;-D
                .data(data)
            .attr("class", "h-bar")
            .style("width", function (d) {
                return (d.expense * 5) + "px";
            })
            .select("span")
                .text(function (d) {
                    return d.category;
                });

<span class="strong"><strong>        if(comparator)</strong></span>
<span class="strong"><strong>            d3.select("body")</strong></span>
<span class="strong"><strong>                .selectAll("div.h-bar") </strong></span>
<span class="strong"><strong>                .sort(comparator); // &lt;-E</strong></span>
    }

<span class="strong"><strong>    var compareByExpense = function (a, b) {  // &lt;-F</strong></span>
<span class="strong"><strong>        return a.expense &lt; b.expense?-1:1;</strong></span>
<span class="strong"><strong>    };</strong></span>
<span class="strong"><strong>    var compareByCategory = function (a, b) {  // &lt;-G</strong></span>
<span class="strong"><strong>        return a.category &lt; b.category?-1:1;</strong></span>
<span class="strong"><strong>    };</strong></span>

    render(data);

    function sort(comparator) {
        render(data, comparator);
    }
&lt;/script&gt;

&lt;div class="control-group"&gt;
    &lt;button onclick="sort(compareByExpense)"&gt;
        Sort by Width
    &lt;/button&gt;
    &lt;button onclick="sort(compareByCategory)"&gt;
        Sort by Category
    &lt;/button&gt;
    &lt;button onclick="sort()"&gt;
        Clear
    &lt;/button&gt;
&lt;/div&gt;</pre></div><p>This preceding code<a id="id200" class="indexterm"/> generates sorted horizontal bars as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2162OS_03_09.jpg" alt="How to do it..."/><div class="caption"><p>Data-based Sorting</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/>How it works...</h2></div></div></div><p>In this recipe, <a id="id201" class="indexterm"/>we set up a simple row-based visualization (in line <code class="literal">B</code>, <code class="literal">C</code>, and <code class="literal">D</code>) of some simulated personal expense records containing two attributes: <code class="literal">expense</code> and <code class="literal">category</code> that are defined on line <code class="literal">A</code>. This is exactly the same as the previous recipe and quite similar to what we have done in the <span class="emphasis"><em>Binding object literals as data</em></span> recipe. Once the basics are done, we then select all existing bars on line <code class="literal">E</code> and perform sorting using D3 <code class="literal">selection.sort</code> function:</p><div class="informalexample"><pre class="programlisting">d3.select("body")
    .selectAll("div.h-bar") 
<span class="strong"><strong>    .sort(comparator); // &lt;-E</strong></span>
</pre></div><p>The <code class="literal">selection.sort</code> function<a id="id202" class="indexterm"/> accepts a comparator function:</p><div class="informalexample"><pre class="programlisting">var compareByExpense = function (a, b) {  // &lt;-F
    return a.expense &lt; b.expense?-1:1;
};
var compareByCategory = function (a, b) {  // &lt;-G
    return a.category &lt; b.category?-1:1;
};</pre></div><p>The <span class="strong"><strong>comparator</strong></span> function<a id="id203" class="indexterm"/> receives two data elements <code class="literal">a</code> and <code class="literal">b</code> to compare, returning either a negative, positive, or zero value. If the value is negative, <code class="literal">a</code> will be placed before <code class="literal">b</code>; if positive, <code class="literal">a</code> will be placed after <code class="literal">b</code>; otherwise, <code class="literal">a</code> and <code class="literal">b </code>are considered equal and the order is <a id="id204" class="indexterm"/>
<span class="strong"><strong>arbitrary</strong></span>. The <code class="literal">sort()</code> function<a id="id205" class="indexterm"/> returns a new selection with all elements sorted in an order which is determined by the specified comparator function. The newly-returned selection <a id="id206" class="indexterm"/>can then be manipulated further to generate the desired visualization.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>Because <code class="literal">a</code> and <code class="literal">b</code> are placed arbitrarily when they are equal, D3 <code class="literal">selection.sort</code> is not guaranteed to be stable, however, it is guaranteed to be consistent with your browser's built-in <code class="literal">sort</code> method on arrays.</p></div></div></div></div>
<div class="section" title="Loading data from a server"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Loading data from a server</h1></div></div></div><p>It is probably very<a id="id207" class="indexterm"/> rare that you will only be visualizing static local <a id="id208" class="indexterm"/>data. The power of data visualization usually lays on the ability to visualize dynamic data typically generated by a server-side program. Since this is a common use case, D3 comes with some handy helper functions to make this task as easy as possible. In this recipe, we will see how a remote data set can be loaded dynamically, and we will update an existing visualization once loaded.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/asyn-data-load.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter3/asyn-data-load.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/>How to do it...</h2></div></div></div><p>In the code example of the <code class="literal">asyn-data-load.html</code> file, we will load data dynamically from the server on user's request, and once the data is loaded, we also update our visualization to reflect the new expanded data set. Here is the code where we do that:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var data = [ // &lt;-A
        {expense: 10, category: "Retail"},
        {expense: 15, category: "Gas"},
        {expense: 30, category: "Retail"},
        {expense: 50, category: "Dining"},
        {expense: 80, category: "Gas"},
        {expense: 65, category: "Retail"},
        {expense: 55, category: "Gas"},
        {expense: 30, category: "Dining"},
        {expense: 20, category: "Retail"},
        {expense: 10, category: "Dining"},
        {expense: 8, category: "Gas"}
    ];

    function render(data) {
        d3.select("#chart").selectAll("div.h-bar") // &lt;-B
                .data(data)
            .enter().append("div")
            .attr("class", "h-bar")
            .append("span");

        d3.select("#chart").selectAll("div.h-bar") // &lt;-C
                .data(data)
            .exit().remove();

        d3.select("#chart").selectAll("div.h-bar") // &lt;-D
                .data(data)
            .attr("class", "h-bar")
            .style("width", function (d) {
                return (d.expense * 5) + "px";
            })
            .select("span")
                .text(function (d) {
                    return d.category;
                });
    }

    render(data);

<span class="strong"><strong>    function load(){ // &lt;-E</strong></span>
<span class="strong"><strong>        d3.json("data.json", function(error, json){ // &lt;-F</strong></span>
<span class="strong"><strong>            data = data.concat(json);  </strong></span>
<span class="strong"><strong>            render(data);</strong></span>
<span class="strong"><strong>        });</strong></span>
<span class="strong"><strong>    }</strong></span>
&lt;/script&gt;

&lt;div class="control-group"&gt;
    &lt;button onclick="load()"&gt;Load Data from JSON feed&lt;/button&gt;
&lt;/div&gt;</pre></div><p>Here is <a id="id209" class="indexterm"/>what our <code class="literal">data.json</code> file <a id="id210" class="indexterm"/>looks like:</p><div class="informalexample"><pre class="programlisting">[
    {"expense": 15,  "category": "Retail"},
 {"expense": 18,  "category": "Gas"},
 ...
 {"expense": 15, "category": "Gas"}
]</pre></div><p>This recipe generates the following visual output after clicking the <span class="strong"><strong>Load Data from JSON feed</strong></span> button once:</p><div class="mediaobject"><img src="graphics/2162OS_03_10.jpg" alt="How to do it..."/><div class="caption"><p>Data Loading from Server</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/>How it works...</h2></div></div></div><p>In this recipe, we<a id="id211" class="indexterm"/> initially have a local data set defined on the line marked as <code class="literal">A</code>, and a<a id="id212" class="indexterm"/> row-based visualization generated by lines <code class="literal">B</code>, <code class="literal">C</code>, and <code class="literal">D</code>. The <code class="literal">load</code> function is defined on line <code class="literal">E</code> that responds to the user's click on the <span class="strong"><strong>Load Data from JSON feed</strong></span> button, which loads the data from a separate file (<code class="literal">data.json</code>) served by the server. This is achieved by using the <code class="literal">d3.json</code> function as shown on line <code class="literal">F</code>:</p><div class="informalexample"><pre class="programlisting">    function load(){ // &lt;-E
        d3.json("data.json", function(error, json){ // &lt;-F
            data = data.concat(json);  
            render(data);
        });
<span class="strong"><strong>    }</strong></span>
</pre></div><p>Since loading a remote data set from a JSON file could take some time, it is performed asynchronously. Once loaded, the data set will be passed to the given handler function, which is specified on line <code class="literal">F</code>. In this function, we simply concatenate the newly loaded data with our existing data set, then re-render the visualization to update the display.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p>Similar functions are also provided by D3 to make the loading of CSV, TSV, TXT, HTML, and XML data a simple task.</p></div></div><p>If a more customized and specific control is required, the <code class="literal">d3.xhr</code> function can be used to further customize the MIME type and request headers. Behind the scenes, <code class="literal">d3.json</code> and <code class="literal">d3.csv</code> are both using <code class="literal">d3.xhr</code> to generate the actual request.</p><p>Of course this is by no means the only way to load remote data from the server. D3 does not dictate how data should be loaded from the remote server. You are free to use your favorite JavaScript libraries, for example, jQuery or Zepto.js to issue an Ajax request and load a remote data set.</p></div></div></body></html>