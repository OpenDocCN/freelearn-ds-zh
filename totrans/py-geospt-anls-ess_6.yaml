- en: Chapter 6. Building a Complete Geospatial Analysis System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章.构建一个完整的地理空间分析系统
- en: 'In this chapter, we will take the skills we have learned in the previous chapters
    and apply them to build a suite of programs that solve a complicated geospatial
    problem. In doing so, we will learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把在前几章中学到的技能应用到构建一套解决复杂地理空间问题的程序中。在这个过程中，我们将学习：
- en: What map matching is, and how it works
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图匹配是什么，以及它是如何工作的
- en: How to use map matching to generate a heatmap of roads traveled based on GPS
    recordings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用地图匹配根据GPS记录生成道路热图
- en: How to download road map data and transform it into a network of roads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何下载公路地图数据并将其转换为道路网络
- en: How to store the road network in a database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将公路网络存储在数据库中
- en: How to generate your own records of journeys using a GPS tracking device
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用GPS跟踪设备生成自己的旅程记录
- en: How to implement a map matching algorithm to match GPS recordings to an existing
    road network, and use the results to calculate how often each road segment was
    used
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现地图匹配算法，将GPS记录与现有的公路网络匹配，并使用结果计算每段公路被使用的频率
- en: How to generate a great-looking GPS Heatmap using this calculated data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用这些计算数据生成一个看起来很棒的GPS热图
- en: Let's start by examining the concept of map matching, and see how it can be
    useful in solving various geospatial problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考察地图匹配的概念开始，看看它如何有助于解决各种地理空间问题。
- en: Matching GPS data against a map
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将GPS数据与地图匹配
- en: 'A GPS recording device captures a series of latitude and longitude coordinates
    over time. As the device is carried by someone moving from place to place, the
    GPS coordinates record the person''s movements. The following map shows a typical
    GPS recording:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: GPS记录设备在一段时间内捕捉一系列纬度和经度坐标。随着设备被某人携带从一个地方移动到另一个地方，GPS坐标记录了人的移动。以下地图显示了典型的GPS记录：
- en: '![Matching GPS data against a map](img/B04102_6_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![将GPS数据与地图匹配](img/B04102_6_01.jpg)'
- en: GPS devices are relatively cheap and remarkably accurate, allowing you to record
    a journey taken on foot, by bicycle, car, or truck. However, by itself, all the
    GPS device is doing is recording a series of coordinates—the GPS device doesn't
    know which roads you followed on your journey.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GPS设备相对便宜且非常准确，允许你记录步行、骑自行车、开车或开卡车所经历的旅程。然而，仅凭GPS设备本身，它所做的只是记录一系列坐标——GPS设备不知道你在旅程中跟随了哪些道路。
- en: '**Map matching** is the process of taking a GPS recording and matching it against
    a database of roads to identify which set of roads were used on that journey.
    For map matching to be successful, you need three things:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**地图匹配**是将GPS记录与公路数据库进行匹配的过程，以确定在该旅程中使用了哪组公路。为了使地图匹配成功，你需要三样东西：'
- en: An accurate GPS recording of the journey, including enough GPS coordinates to
    identify which roads were taken.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个准确的旅程GPS记录，包括足够的GPS坐标以确定所走的道路。
- en: An accurate database of roads.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个准确的公路数据库。
- en: A suitable algorithm to match the GPS coordinates against the road database.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个合适的算法来匹配GPS坐标与公路数据库。
- en: Once you know which roads were taken, you can use this information for various
    purposes. For example, a turn-by-turn navigation system will use its knowledge
    of the road database and the path taken so far to suggest the next turn to take.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了哪些道路被走了，你可以用这些信息做各种用途。例如，一个逐段导航系统将使用其对公路数据库和已走的路径的了解来建议下一步要采取的转弯。
- en: 'You can also use map matching for historical purposes: keeping track of which
    routes a traveler took on their journey, possibly to optimize future journeys,
    or noting which roads were most commonly traveled.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以出于历史目的使用地图匹配：跟踪旅行者在旅程中采取的路线，可能为了优化未来的旅程，或者记录哪些道路被最频繁地使用。
- en: In this chapter, we will implement a complete map matching system, using an
    appropriate database of road data and a sophisticated algorithm for matching a
    GPS recording against those roads. We will use this information to generate a
    heatmap of commonly-used roads over a series of historical GPS recordings.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个完整的地图匹配系统，使用适当的公路数据库和一种复杂的算法来匹配GPS记录与这些道路。我们将使用这些信息来生成一系列历史GPS记录中常用公路的热图。
- en: An overview of the GPS Heatmap system
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPS热图系统的概述
- en: 'The system we are implementing will be called the **GPS Heatmap**. We will
    download a set of road data and convert this data into a network of directed road
    segments. We will then either generate or download a collection of GPS recordings
    from various journeys, which we will use to identify commonly-traveled roads.
    Finally, we will generate a heatmap based on how often the roads are traveled,
    providing a visual summary of the most commonly-traveled roads captured by the
    GPS device. The resulting output will look something like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在实施的系统将被命名为**GPS热图**。我们将下载一组道路数据，并将这些数据转换为有向道路段网络。然后，我们将生成或下载来自各种旅程的GPS记录，我们将使用这些记录来识别常行驶的道路。最后，我们将根据道路被行驶的频率生成热图，提供GPS设备捕获的最常行驶道路的视觉摘要。生成的输出将类似于以下内容：
- en: '![An overview of the GPS Heatmap system](img/B04102_6_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![GPS热图系统概述](img/B04102_6_02.jpg)'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A heatmap typically uses a color gradient ranging from blue to red to draw the
    roads, with blue used for the less-traveled roads and red for the most commonly
    traveled roads. In the printed edition of this book, however, the heatmaps will
    appear in black and white, so we have selected a single shade of blue so that
    the heatmap still makes sense when printed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 热图通常使用从蓝色到红色的颜色渐变来绘制道路，蓝色用于较少行驶的道路，红色用于最常行驶的道路。然而，在这本书的印刷版中，热图将以黑白形式出现，因此我们选择了一种单色的蓝色，以便在打印时热图仍然有意义。
- en: To allow our GPS Heatmap program to work as efficiently as possible, we will
    make use of a PostGIS database to store the underlying road data. We will generate
    a planar graph of the nonintersecting road segments, use this data to build a
    network of connected road segments, and store this network in the database for
    quick access. We will then use a map matching algorithm to calculate a **tally**
    for each road segment. These tallies then form the basis for generating the GPS
    heatmap image, with a suitable color chosen for each road segment based on the
    calculated tally for that segment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的GPS热图程序尽可能高效地运行，我们将使用PostGIS数据库来存储底层道路数据。我们将生成非相交道路段的平面图，使用这些数据来构建连接的道路段网络，并将这个网络存储在数据库中以供快速访问。然后，我们将使用地图匹配算法为每个道路段计算一个**计数**。这些计数然后成为生成GPS热图图像的基础，每个道路段将根据该段计算的计数选择合适的颜色。
- en: 'Because our GPS Heatmap program consists of many parts, we will implement it
    as a suite of individual Python programs:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的GPS热图程序由许多部分组成，我们将将其实现为一套单独的Python程序：
- en: '`init_db.py`: This will initialize the PostGIS database, providing us with
    a place to store the data as we load and process it.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_db.py`: 这个脚本将初始化PostGIS数据库，为我们提供一个在加载和处理数据时存储数据的地方。'
- en: '`import_roads.py`: This will import the road data from a shapefile into the
    PostGIS database.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import_roads.py`: 这个脚本将道路数据从shapefile导入到PostGIS数据库中。'
- en: '`split_roads.py`: This will convert the imported roads into a series of nonoverlapping
    road segments by calculating a planar graph based on the raw road data.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split_roads.py`: 这个脚本会将导入的道路转换为一系列非重叠的道路段，通过基于原始道路数据计算平面图来实现。'
- en: '`calc_directed_network.py`: This will use the road segments to generate a directed
    network of connected road segments. This tells us how the various road segments
    are connected, and which segments lead off from a given point.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc_directed_network.py`: 这个脚本将使用道路段生成一个连接的道路段有向网络。这告诉我们各种道路段是如何连接的，以及哪些段从一个给定点出发。'
- en: '`map_matcher.py`: This performs the actual map matching process, reading the
    raw GPS data from a GPX format file, using it to identify which road segments
    were traveled by the person using that GPS device, and incrementing the tally
    for each road segment as it is used.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map_matcher.py`: 这个脚本执行实际的地图匹配过程，从GPX格式文件中读取原始GPS数据，使用这些数据来识别使用该GPS设备的用户所经过的道路段，并在使用时为每个道路段增加计数。'
- en: '`generate_heatmap.py`: This will use the calculated tally data to generate
    a heatmap image for display.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_heatmap.py`: 这个脚本将使用计算出的计数数据生成用于显示的热图图像。'
- en: Before we can start implementing these various programs, we will need to obtain
    the underlying data. Let's look at how to do this now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始实施这些各种程序之前，我们需要获取底层数据。现在让我们看看如何做这件事。
- en: Obtaining the necessary data
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取必要的数据
- en: Your first choice is to decide which GPS dataset to use. You can capture your
    own GPS recordings using a GPS device if you wish, or you can make use of the
    GPS recordings provided with the example code for this chapter. Once you have
    decided which set of GPS data to use, you will need to download road data for
    the same area.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一步是决定使用哪个GPS数据集。如果您愿意，您可以使用GPS设备捕获自己的GPS记录，或者您可以使用本章示例代码中提供的GPS记录。一旦您决定了要使用哪组GPS数据，您将需要下载该区域的道路数据。
- en: Let's start by deciding which set of GPS data you wish to use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先决定您希望使用哪套GPS数据。
- en: Obtaining GPS data
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取GPS数据
- en: If you have your own GPS recording device, you might like to go out and capture
    your own GPS recordings as you travel back and forth in your local area. If you
    do not have your own GPS recording device, or if you do not want to capture your
    own GPS data, example GPS recordings are provided along with the sample code for
    this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有自己的GPS记录设备，您可能想出去并在您在当地地区往返时捕获自己的GPS记录。如果您没有自己的GPS记录设备，或者您不想捕获自己的GPS数据，本章提供的示例代码中包含了一些示例GPS记录。
- en: These example recordings were taken in and around the author's home city of
    Rotorua, New Zealand. The recordings were captured using a Garmin Edge 500 cycle
    computer, and exported in `GPX` format. If you want to capture your own GPS recordings,
    make sure you record at least 20 separate journeys so that you have a good set
    of data to work with.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例记录是在作者位于新西兰罗托鲁阿市及其周边地区拍摄的。这些记录使用Garmin Edge 500自行车电脑捕获，并以`GPX`格式导出。如果您想捕获自己的GPS记录，请确保记录至少20次不同的旅程，以便您有一套良好的数据可以工作。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not every GPS recording will be usable. Sometimes, the GPS data can be too inaccurate
    or might miss sections of your journey, leading to matching errors. Also, limitations
    in the map matching algorithm mean that any journey which U-turns along a road,
    or uses the same road segment twice, cannot be matched. For this reason, you may
    find that some of your recordings do not work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个GPS记录都是可用的。有时，GPS数据可能过于不准确，或者可能错过您的旅程的部分，导致匹配错误。此外，地图匹配算法的限制意味着任何在道路上掉头或使用相同道路段两次的旅程都无法匹配。因此，您可能会发现一些记录不起作用。
- en: Whether you use the sample recordings or create your own, place the resulting
    `GPX` format files into a directory named `gps-data`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用示例记录还是创建自己的，将生成的`GPX`格式文件放入名为`gps-data`的目录中。
- en: Downloading the road data
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载道路数据
- en: 'Once you have your GPS recordings, you next need a matching set of road data.
    If your GPS recordings were taken in the USA, you can use the TIGER data from
    the US Census Bureau''s website. We used this site in the previous chapter to
    download all primary and secondary roads in California. In this case, you will
    want to download all the roads in your area. To do this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了GPS记录，接下来您需要一组匹配的道路数据。如果您的GPS记录是在美国拍摄的，您可以使用美国人口普查局的TIGER数据。我们在上一章中使用了这个网站来下载加利福尼亚州的所有主要和次要道路。在这种情况下，您将想要下载您所在地区的所有道路。为此：
- en: Go to [https://www.census.gov/geo/maps-data/data/tiger-line.html](https://www.census.gov/geo/maps-data/data/tiger-line.html),
    scroll down to the section labeled **2014 TIGER/Line Shapefiles**, click on the
    **Download** option, and then click on **Web interface**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://www.census.gov/geo/maps-data/data/tiger-line.html](https://www.census.gov/geo/maps-data/data/tiger-line.html)，滚动到标记为**2014
    TIGER/Line Shapefiles**的部分，点击**下载**选项，然后点击**Web界面**。
- en: From the download page, choose **Roads** from the **Select a layer type** drop-down
    menu, and then click on the **Submit** button.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下载页面，从**选择图层类型**下拉菜单中选择**Roads**，然后点击**提交**按钮。
- en: Choose your state from the **All Roads** drop-down menu, and click on **Submit**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**所有道路**下拉菜单中选择您的州，然后点击**提交**。
- en: You will then need to choose the county you are in, and finally you can click
    on the **Download** button to obtain the road data you need.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要选择您所在的县，最后您可以点击**下载**按钮以获取所需的道路数据。
- en: If you are outside the USA, you will need to find a suitable alternative. OpenStreetMap
    ([http://openstreetmap.org](http://openstreetmap.org)) is one possible source
    of data, though you may need to hunt to find road data in a format you can use.
    Alternatively, the [https://koordinates.com](https://koordinates.com) site might
    have data you can use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不在美国，您需要找到一个合适的替代方案。OpenStreetMap ([http://openstreetmap.org](http://openstreetmap.org))
    是数据的一个可能来源，尽管您可能需要寻找您可以使用格式的道路数据。另外，[https://koordinates.com](https://koordinates.com)
    网站可能也有您可以使用的数据。
- en: 'If you want to make use of the example GPS recordings provided in this chapter,
    take the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用本章提供的示例 GPS 录音，请按照以下步骤操作：
- en: Go to [https://koordinates.com](https://koordinates.com).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://koordinates.com](https://koordinates.com)。
- en: Click on the **Sign in** link in the upper-right-hand corner of the page.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面右上角的 **登录** 链接。
- en: Register for a free account by clicking on the **Register** link.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **注册** 链接注册一个免费账户。
- en: After signing in, you will see a map centered on your location. Pan the map
    over to New Zealand and zoom in on the central North Island until you find the
    city of Rotorua.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，你将看到一个以你的位置为中心的地图。将地图平移到新西兰，并放大到找到北岛中心的城市罗托瓦。
- en: Click on the search box in the upper-left corner of the page, type `road centrelines`
    and press *Return*.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面左上角的搜索框，输入 `road centrelines` 并按 *Enter*。
- en: Note
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the New Zealand spelling for the word "centrelines"; if you type `centerlines`,
    you won't find the data you're looking for.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意新西兰拼写单词 "centrelines"；如果你输入 `centerlines`，你将找不到你要找的数据。
- en: The dataset you are looking for is called *Improved NZ Road Centrelines (August
    2011)*. Click on the **+** icon beside this dataset, and the road data will appear
    on your map.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你要查找的数据集名为 *Improved NZ Road Centrelines (August 2011)*。点击此数据集旁边的 **+** 图标，道路数据将显示在你的地图上。
- en: Next, zoom in further to show the city of Rotorua and its environs, click on
    the crop tool (![Downloading the road data](img/B04102_6_03.jpg)) in the upper-right-hand
    corner of the page, and drag out a rectangle that looks approximately like the
    following screenshot:![Downloading the road data](img/B04102_6_04.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进一步放大以显示罗托瓦市及其周边地区，点击页面右上角的裁剪工具 (![下载道路数据](img/B04102_6_03.jpg))，并拖出一个大约如下截图所示的矩形：![下载道路数据](img/B04102_6_04.jpg)
- en: Once this has been selected, click on the **Download or Order** link in the
    upper-right-hand corner of the window. The default options (WGS 84 map projection
    and shapefile format) are exactly what you want, so just click on the **Accept
    terms and create download** button.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择完成后，点击窗口右上角的 **下载或订购** 链接。默认选项（WGS 84 地图投影和 shapefile 格式）正是你需要的，所以只需点击 **接受条款并创建下载**
    按钮。
- en: After a minute or so, the road data will be available for you to download. The
    resulting file will be named `kx-improved-nz-road-centrelines-august-2011-SHP.zip`.
    Decompress this ZIP archive, rename the resulting directory to `roads`, and place
    this directory somewhere convenient.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大约一分钟后，道路数据将可供你下载。生成的文件将被命名为 `kx-improved-nz-road-centrelines-august-2011-SHP.zip`。解压此
    ZIP 存档，将生成的目录重命名为 `roads`，并将此目录放置在方便的位置。
- en: Implementing the GPS Heatmap system
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 GPS 热图系统
- en: Now that we have the necessary data, we're ready to start implementing our GPS
    Heatmap system. Create a directory named `gps-heatmap` to hold the suite of programs
    and their associated data files, and then place the two data directories you created
    earlier (`gps-data` and `roads`) into this directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了必要的数据，我们准备开始实现我们的 GPS 热图系统。创建一个名为 `gps-heatmap` 的目录来存放程序及其相关数据文件，然后将你之前创建的两个数据目录（`gps-data`
    和 `roads`）放入此目录中。
- en: We're now ready to start coding. Let's start by implementing the `init_db.py`
    program to initialize our PostGIS database.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始编码了。让我们先实现 `init_db.py` 程序来初始化我们的 PostGIS 数据库。
- en: Initializing the database
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化数据库
- en: 'You should already have installed Postgres when you worked through [Chapter
    3](ch03.html "Chapter 3. Spatial Databases"), *Spatial Databases*. We''re going
    to use Postgres to create and initialize a database to hold all our processed
    road data. The first step is to create the database itself, which you can do by
    typing the following into a terminal window:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成 [第 3 章](ch03.html "第 3 章。空间数据库") *空间数据库* 的工作时，你应该已经安装了 Postgres。我们将使用 Postgres
    创建并初始化一个数据库来存储所有处理过的道路数据。第一步是创建数据库本身，你可以在终端窗口中输入以下内容来完成：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should create a database named `gps_heatmap`. If you get an authentication
    error, you will need to enter a password or use the `-U postgres` command-line
    option so that the `createdb` command can run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `gps_heatmap` 的数据库。如果你遇到认证错误，你需要输入密码或使用 `-U postgres` 命令行选项，以便 `createdb`
    命令可以运行。
- en: 'Now that you have created the database itself, the next step is to turn it
    into a spatial database so we can use it to store geometry data. To do this, enter
    the following command into the terminal window:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了数据库本身，下一步是将它转换为空间数据库，以便我们可以用它来存储几何数据。为此，请在终端窗口中输入以下命令：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not forget to add the `-U postgres` command-line option if you need it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，不要忘记添加`-U postgres`命令行选项。
- en: 'You have now created a spatial database for your Python code to use. We are
    now going to write the `init_db.py` script that initializes the various tables
    and indexes within this database. Go ahead and create the `init_db.py` file inside
    your main `gps-heatmap` directory, and enter the following code into this file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经为Python代码创建了一个空间数据库。我们现在将编写`init_db.py`脚本，该脚本初始化数据库中的各种表和索引。请创建主`gps-heatmap`目录中的`init_db.py`文件，并将以下代码输入到该文件中：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we are using the `psycopg2` library to access our PostGIS database.
    We create a database connection and an associated `cursor` object. We then create
    the `roads` database table, first deleting it so that we can run this script again
    if we have to change the database structure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用`psycopg2`库来访问我们的PostGIS数据库。我们创建了一个数据库连接和一个相关的`cursor`对象。然后我们创建了`roads`数据库表，首先删除它，这样我们就可以在需要更改数据库结构时再次运行此脚本。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't forget to change the parameters to the `psycopg2.connect()` statement
    if you need to use a different username or password to access PostGIS on your
    computer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用不同的用户名或密码访问您计算机上的PostGIS，请勿忘记更改`psycopg2.connect()`语句的参数。
- en: 'The `roads` table will hold the raw road data imported from the shapefile that
    we have just downloaded. As you can see, this table will have three separate fields:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`roads`表将存储从我们刚刚下载的shapefile中导入的原始道路数据。如您所见，这个表将有三组不同的字段：'
- en: '`id`: This is the unique ID for this road in the database'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是数据库中这条道路的唯一ID'
- en: '`name`: This is the name of the road'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是道路的名称'
- en: '`centerline`: This is a LineString geometry that represents the shape of this
    road'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centerline`：这是一个LineString几何对象，表示这条道路的形状'
- en: This is not the only database table we need, but it is enough to get us started.
    We will add more table definitions to the `init_db.py` program as we go along.
    For now, though, you should be able to run this program to create the `roads`
    table, which we will need in the next section when we import the downloaded road
    data into the database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们需要的唯一数据库表，但足以让我们开始。随着我们的进行，我们将在`init_db.py`程序中添加更多的表定义。不过，现在您应该能够运行此程序来创建`roads`表，这是我们将在下一节中导入下载的道路数据到数据库时需要的。
- en: Importing the road data
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入道路数据
- en: 'We are now ready to import the road data from the downloaded shapefile into
    the database. The program that will do this is called `import_roads.py`. Go ahead
    and create this file, and enter the following Python code into it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好将下载的shapefile中的道路数据导入数据库。将执行此操作的程序称为`import_roads.py`。请创建此文件，并将以下Python代码输入到其中：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, all we have done is to open a connection to the database and delete
    the existing contents of the `roads` table. Next, we need to import the road data
    from the shapefile we downloaded. How we do this, of course, will vary depending
    on where the road data came from. For the *Improved NZ Road Centrelines* data,
    we will use the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切只是打开数据库连接并删除`roads`表中的现有内容。接下来，我们需要从我们下载的shapefile中导入道路数据。当然，我们如何做将取决于道路数据来自哪里。对于*Improved
    NZ Road Centrelines*数据，我们将使用以下代码：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we use OGR to import the road data from the shapefile, and use
    either the `descr` or the `label` field for the road name. This corresponds to
    the way the *NZ Road Centrelines* data has been defined, where sometimes the road
    name is in the `descr` field, and at other times the road name is in the `label`
    field. Some roads don't have a name (for example, where the road goes through
    a roundabout), and so in this case the road name will be set to `None`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用OGR从shapefile导入道路数据，并使用`descr`或`label`字段作为道路名称。这对应于*NZ Road Centrelines*数据定义的方式，有时道路名称在`descr`字段中，有时在`label`字段中。有些道路没有名称（例如，道路穿过环岛的地方），因此在这种情况下，道路名称将被设置为`None`。
- en: If you are using a different source of road data, you will need to modify this
    code to suit the way your road data is organized. Just make sure that you store
    the centerline and (where applicable) the name of the road into the `roads` table.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是不同的道路数据源，您需要修改此代码以适应您的道路数据组织方式。只需确保将中心线和（如有适用）道路名称存储到`roads`表中。
- en: Splitting the road data into segments
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割道路数据成段
- en: As we have seen in the previous chapter, the points where roads touch or cross
    aren't automatically considered to be connection points for the purpose of building
    a road network. We first need to create a **planar graph** out of the intersecting
    roads, just like we did in the previous chapter. Our next task, therefore, is
    to split the roads up into segments, forming a planar graph of road segments out
    of the raw road data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章所见，道路接触或交叉的点并不是自动被认为是构建道路网络连接点的。我们首先需要从交叉的道路中创建一个**平面图**，就像我们在上一章所做的那样。因此，我们的下一个任务是将道路分割成段，从原始道路数据中形成一个平面图的道路段。
- en: 'The `split_roads.py` program will split the raw road data into segments. Before
    we can write this program, however, we need to add a table to the database which
    will hold the road segments. To do this, add the following code to your `init_db.py`
    program, immediately before the call to `connection.commit()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`split_roads.py`程序将分割原始道路数据成段。然而，在我们能够编写这个程序之前，我们需要在数据库中添加一个表来存储道路段。为此，将以下代码添加到您的`init_db.py`程序中，在调用`connection.commit()`之前立即执行：'
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we create a new table called `road_segments` to hold the various
    segments in our planar graph. Each road segment will have the following fields:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个名为`road_segments`的新表来存储平面图中的各个段。每个道路段将包含以下字段：
- en: '`id`: This is the unique ID for this road segment.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是该道路段的唯一ID。'
- en: '`name`: This is the name of the road this segment is a part of.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是该段所属的道路名称。'
- en: '`centerline`: This is a LineString geometry representing the shape of this
    road segment.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centerline`：这是一个表示该道路段形状的LineString几何形状。'
- en: '`tally`: This is the number of times this road segment was used by the GPS
    recordings. This is the output of the map matching algorithm we will implement
    later in this chapter.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tally`：这是GPS记录使用该道路段次数的数量。这是我们在本章后面将要实现的地图匹配算法的输出。'
- en: 'Now that we''ve created the `road_segments` table, we can start implementing
    the `split_roads.py` program. Create this file and add the following code to it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`road_segments`表，我们可以开始实现`split_roads.py`程序。创建此文件并将以下代码添加到其中：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So far, we have simply opened a connection to the database and deleted any existing
    `road_segments` records. As usual, this gives us a blank table where we can store
    our calculated road segments, removing any segments that we may have stored previously.
    This allows us to run the program as often as we need.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是打开了一个数据库连接并删除了任何现有的`road_segments`记录。像往常一样，这给了我们一个空白表，我们可以存储我们的计算出的道路段，移除我们可能之前存储的任何段。这允许我们按需运行程序。
- en: 'Next, we want to convert the contents of the `roads` table into a series of
    connected road segments. In the previous chapter, we used Shapely to perform this
    task using road data held in memory. This time, we''re going to implement the
    same process using PostGIS. First, we are going to load a master list of all the
    `road` record IDs into memory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要将`roads`表的内容转换成一系列连接的道路段。在上一章中，我们使用Shapely在内存中存储的道路数据执行了这个任务。这次，我们将使用PostGIS实现相同的过程。首先，我们将加载所有`road`记录ID的主列表到内存中：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will work through each of these roads in turn. For each road, we start by
    loading the road''s name and geometry into memory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次处理每条道路。对于每条道路，我们首先将道路的名称和几何形状加载到内存中：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have got the road''s LineString geometry, we want to split it at
    each point where it touches or crosses another road. To do this, we''ll build
    a list of **crossroads** for this road:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了道路的LineString几何形状，我们想要在每个它接触或交叉其他道路的点处将其分割。为此，我们将为这条道路构建一个**十字路口**列表：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then use the crossroads to split the current road''s geometry into one or
    more segments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用十字路口将当前道路的几何形状分割成一个或多个段：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to process the resulting road, dividing it up into a separate
    LineString for each road segment:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理生成的道路，将其分割成每个道路段的一个单独的LineString：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we save the calculated segments into the `road_segments` table:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将计算出的段保存到`road_segments`表中：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally (outside the `for road_id in all_road_ids` loop), we commit our changes
    to the database:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（在`for road_id in all_road_ids`循环外部），我们将更改提交到数据库：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This completes our `split_roads.py` program. If you run through the programs
    in sequence, and then use the `psql` command-line client to access the database,
    you can see that the program has indeed generated a number of road segments out
    of the raw road data:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的`split_roads.py`程序。如果你按顺序运行程序，然后使用`psql`命令行客户端访问数据库，你可以看到程序确实从原始道路数据中生成了许多路段：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you would expect, there are many more segments than there are roads.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，路段的数量比道路的数量要多得多。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to view the road segments, you can easily write a program using
    Mapnik which displays the contents of the `road_segments` table. A version of
    this program, named `preview_segments.py`, is included in the sample code for
    this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看路段，你可以轻松地编写一个使用Mapnik的程序来显示`road_segments`表的内容。这个程序的版本名为`preview_segments.py`，包含在本章的示例代码中。
- en: Constructing a network of directed road segments
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建有向路段的网络
- en: When we try to match the recorded GPS data against a database of road segments,
    one of the important questions we will need to answer is, "Which other road segments
    lead off from this one?" To answer this question, we will need to build a **directed
    network** of road segments.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将记录的GPS数据与路段数据库匹配时，我们需要回答的一个重要问题是，“从这条路段出发还有哪些其他路段？”为了回答这个问题，我们需要构建一个**有向网络**的路段。
- en: We did something similar to this in the previous chapter, where we used NetworkX
    to calculate the shortest path between two points. In this case, however, we are
    going to store the network in the database for later use.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们做了类似的事情，在那里我们使用NetworkX来计算两点之间的最短路径。然而，在这种情况下，我们将把网络存储在数据库中以供以后使用。
- en: 'To make the map matching algorithm easier to implement, our network of road
    segments will be **directed**—that is, each segment in our `road_segments` table
    will actually be represented by two separate road segments:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使地图匹配算法更容易实现，我们的路段网络将是**有向的**——也就是说，我们`road_segments`表中的每个路段实际上将由两个独立的路段表示：
- en: '![Constructing a network of directed road segments](img/B04102_6_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![构建有向路段的网络](img/B04102_6_05.jpg)'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, not every road is two-way, but we are ignoring this to keep things
    easier.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非每条道路都是双向的，但我们忽略这一点以简化问题。
- en: 'As you can see, each road segment is converted into two directed segments:
    one running from point A to point B, and the other running from point B back to
    point A.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个路段都被转换成两个有向路段：一个从点A到点B运行，另一个从点B返回到点A。
- en: 'We are going to use a new table named `directed_segments` to hold the directed
    road segments. Each directed segment record will have the following fields:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`directed_segments`的新表来存储有向路段。每个有向路段记录将包含以下字段：
- en: '`id`: This is the unique ID for this road segment'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 这是此路段段落的唯一ID'
- en: '`road_segment_id`: This is the record ID of the road segment this directed
    segment is derived from'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`road_segment_id`: 这是此有向路段派生出的路段记录的ID'
- en: '`centerline`: This is the LineString geometry for this directed segment'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centerline`: 这是此有向路段的LineString几何形状'
- en: Note that the directed segment's LineString runs in the same direction as the
    segment itself—that is, the start of the directed segment is at `centerline.coords[0]`
    and the end of the directed segment is at `centerline.coords[-1]`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有向路段的LineString与路段本身的方向一致——也就是说，有向路段的起点在`centerline.coords[0]`，终点在`centerline.coords[-1]`。
- en: 'A second table, `endpoints`, will hold the coordinates for the ends of the
    various directed road segments. Each endpoint record will have the following fields:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表，`endpoints`，将包含各种有向路段的端点坐标。每个端点记录将包含以下字段：
- en: '`id`: This is the unique ID for this endpoint'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 这是此端点的唯一ID'
- en: '`endpoint`: This is a Point geometry containing the coordinates for this endpoint'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoint`: 这是一个包含此端点坐标的Point几何形状'
- en: Note
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use a Point geometry here so that we can make spatial queries against this
    table.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用Point几何形状，以便可以对这张表进行空间查询。
- en: 'Finally, we are going to need a table that identifies which directed road segments
    leave from a given endpoint. This table, `endpoint_segments`, will have the following
    fields:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个表来标识从给定端点出发的有向路段。这个表，`endpoint_segments`，将包含以下字段：
- en: '`id`: This is the unique ID for this `endpoint_segments` record'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 这是此`endpoint_segments`记录的唯一ID'
- en: '`directed_segment_id`: This is the record ID of a directed road segment'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directed_segment_id`：这是有向道路段的记录ID'
- en: '`endpoint_id`: This is the record ID of the endpoint that this directed road
    segment leaves from'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoint_id`：这是此有向道路段离开的端点的记录ID'
- en: 'These three tables will be used to store the network of directed road segments.
    Let''s modify our `init_db.py` program to create these three new tables. To do
    this, add the following code to the end of this file, immediately before the call
    to `connection.commit()`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个表将用于存储有向道路段网络。让我们修改我们的`init_db.py`程序以创建这三个新表。为此，将以下代码添加到文件末尾，紧接在调用`connection.commit()`之前：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the last change we''ll need to make to our database structure, so go
    ahead and re-create the database tables, import the roads, and split them again:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要对数据库结构进行的最后一次更改，所以请继续重新创建数据库表，导入道路，并再次分割它们：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We wouldn't need to rerun our programs each time if we'd used database migrations,
    but we are keeping the database logic as simple as possible. Fortunately, this
    is the last time we will need to do this.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了数据库迁移，我们就不需要每次都重新运行我们的程序，但我们正在尽可能简化数据库逻辑。幸运的是，这是我们最后一次需要这样做的时候。
- en: 'We are now ready to calculate the directed road network and store it into the
    database. The program we will create is called `calc_directed_network.py`; create
    this file, and enter the following code into it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好计算有向道路网络并将其存储到数据库中。我们将创建的程序称为`calc_directed_network.py`；创建此文件，并将以下代码输入其中：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are now ready to create the NetworkX graph representing the road network.
    When we did this in the previous chapter, we used the `networkx.read_shp()` function
    to create a NetworkX `DiGraph` object from the contents of a shapefile. Unfortunately,
    there''s no equivalent function for creating a graph from the contents of a PostGIS
    database; however, since NetworkX is implemented in Python, it is easy to adapt
    the source code for the `read_shp()` function to do what we want. Add the following
    code to the end of your `calc_directed_network.py` program:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好创建表示道路网络的NetworkX图。在上一章中我们这样做时，我们使用了`networkx.read_shp()`函数，从shapefile的内容创建一个NetworkX
    `DiGraph`对象。不幸的是，没有等效函数可以用于从PostGIS数据库的内容创建图；然而，由于NetworkX是用Python实现的，因此很容易修改`read_shp()`函数的源代码以实现我们想要的功能。将以下代码添加到`calc_directed_network.py`程序末尾：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The nodes in the NetworkX graph are a `(long,lat)` tuple identifying each road
    segment's endpoints, and the edges represent the directed road segments. Note
    that we store the record ID of the road segment as an attribute in the graph so
    that we can refer to it later.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX图中的节点是一个`(long,lat)`元组，用于标识每个道路段端点的唯一标识符，边代表有向道路段。请注意，我们在图中存储道路段的记录ID作为属性，以便以后引用。
- en: 'Now that we have the NetworkX graph, let''s prepare to use it to generate the
    directed network of connected road segments. To do this, we have to calculate
    the **largest connected subgraph** from the graph we have built, just like we
    did in the previous chapter. Here is the necessary code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了NetworkX图，让我们准备使用它来生成连接道路段的有向网络。为此，我们必须从我们构建的图中计算**最大的连接子图**，就像我们在上一章中所做的那样。以下是必要的代码：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now have a graph containing all the connected road segments. We can now
    use this to store the road segment endpoints into the database:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个包含所有连接道路段的图。我们可以现在使用它将道路段端点存储到数据库中：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that the `endpoint_ids` dictionary maps a `(long,lat)` coordinate to
    the record ID of the endpoint in the database. We will use this to link the directed
    road segments to their endpoints.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`endpoint_ids`字典将一个`(long,lat)`坐标映射到数据库中端点的记录ID。我们将使用它将有向道路段与其端点链接起来。
- en: 'Our final task is to store the directed road segments, along with the endpoint
    the segment starts from. We''ll start by deleting the existing records in the
    database, and iterating over the road segments in our graph:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后任务是存储有向道路段，以及该段开始于的端点。我们将首先删除数据库中现有的记录，然后遍历我们图中的道路段：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We now have the record ID of the segment''s endpoints, and the LineString defining
    this road segment. We now need to convert this segment into two *directed* segments,
    one heading in each direction:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了段端点的记录ID和定义此道路段的LineString。我们现在需要将此段转换为两个*有向*段，每个方向一个：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This gives us two LineString geometries, one running from the first endpoint
    to the second, and the other running from the second endpoint back to the first.
    We can now save the information we''ve calculated into the database:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了两个LineString几何形状，一个从第一个端点到第二个端点，另一个从第二个端点回到第一个端点。现在我们可以将我们计算的信息保存到数据库中：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To finish our program, we have to commit the changes we''ve made:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的程序，我们必须提交我们所做的更改：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can now create the network of the directed road segments by running this
    program:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过运行这个程序来创建有向道路段网络：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implementing the map matching algorithm
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现地图匹配算法
- en: 'We are now ready, at long last, to implement our map matching algorithm. The
    algorithm we will use is derived from the paper: *Map-matching of GPS traces on
    high-resolution navigation networks using the Multiple Hypothesis Technique (MHT)*,
    written by Nadine Schuessler and Kay Axhausen for the Institute of Transport Planning
    and Systems in Switzerland.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好实现我们的地图匹配算法了。我们将使用的算法来源于论文：《使用多假设技术（MHT）在高清导航网络上进行GPS轨迹的地图匹配》，由Nadine
    Schuessler和Kay Axhausen为瑞士交通规划与系统研究所撰写。
- en: If you are interested in reading this paper, it can be found at [www.ivt.ethz.ch/vpl/publications/reports/ab568.pdf](http://www.ivt.ethz.ch/vpl/publications/reports/ab568.pdf).
    This algorithm is based on the notion of a **route candidate**, which is a possible
    path the traveler could have taken as the GPS points were recorded. Each route
    candidate has a list of directed road segments and a **score** identifying how
    closely the GPS points match those road segments.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对阅读这篇论文感兴趣，可以在[www.ivt.ethz.ch/vpl/publications/reports/ab568.pdf](http://www.ivt.ethz.ch/vpl/publications/reports/ab568.pdf)找到。这个算法基于**路线候选**的概念，即旅行者在记录GPS点时可能采取的路径。每个路线候选都有一个包含方向道路段和**得分**的列表，该得分标识GPS点与这些道路段的匹配程度。
- en: The journey is recreated by following the GPS points one at a time. At any particular
    moment, there is a list of route candidates which could possibly match the GPS
    coordinates which have been processed thus far. As each new GPS point is processed,
    the route candidates are updated one at a time by comparing the GPS coordinate
    with the route candidate's final road segment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐个跟随GPS点来重现旅程。在任何特定时刻，都有一个可能匹配迄今为止已处理的GPS坐标的路线候选列表。随着每个新的GPS点被处理，路线候选会逐个更新，通过比较GPS坐标与路线候选的最终道路段。
- en: 'If the GPS point is considered to still be somewhere on that final segment,
    then the GPS point is simply added to that segment and the route candidate''s
    score is updated. If, on the other hand, the GPS point is beyond the end of the
    route candidate''s final road segment, then we look at the road network to see
    which other road segments lead off from that point. We then create new route candidates
    for each road segment leaving from that endpoint:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果GPS点被认为仍然在最终段落的某个地方，那么GPS点就简单地添加到该段落，并更新路线候选的得分。另一方面，如果GPS点超出了路线候选的最终道路段，那么我们会查看道路网络，看看哪些其他道路段从这个点出发。然后，我们为每个从该端点出发的道路段创建新的路线候选：
- en: '![Implementing the map matching algorithm](img/B04102_6_06.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![实现地图匹配算法](img/B04102_6_06.jpg)'
- en: Once all the GPS points have been processed, we select the route candidate with
    the lowest score as being the one most likely to have been used for this journey.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完所有GPS点，我们就选择得分最低的路线候选，认为它最有可能是这次旅行的使用路径。
- en: 'To implement this algorithm, we are going to use Python dictionaries to represent
    a **route segment**—that is, a single segment within a route candidate''s journey.
    Each route segment dictionary will have the following entries:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个算法，我们将使用Python字典来表示**路线段**——即在路线候选的旅程中的单个段落。每个路线段字典将包含以下条目：
- en: '`directed_segment_id`: This is the record ID of the `directed_segment` which
    this segment of the route is following'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directed_segment_id`：这是跟随该路线段的道路段`directed_segment`的记录ID'
- en: '`linestring`: This is the road segment''s centerline, as a Shapely LineString
    object'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linestring`：这是道路段中心线，作为一个Shapely LineString对象'
- en: '`gps_points`: This is a list of (long,lat) coordinates defining the GPS points
    which have been assigned to this route segment'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gps_points`：这是一个定义分配给该路线段的GPS点的(long,lat)坐标的列表'
- en: '`gps_distances`: This is a list holding the calculated minimum distance between
    each GPS point and the segment''s LineString'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gps_distances`：这是一个包含每个GPS点与段LineString之间计算出的最小距离的列表'
- en: 'Each route candidate is going to be represented by a Python dictionary with
    the following entries:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由候选将用一个包含以下条目的Python字典来表示：
- en: '`segments`: This is a list of the route segments that make up this route candidate.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`segments`: 这是一个由构成此路由候选的路由段组成的列表。'
- en: '`directed_segment_ids`: This is a list containing the record ID of each directed
    segment used by this route. We use this to quickly discard a new route candidate
    if another route is using the same sequence of road segments.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directed_segment_ids`: 这是一个包含此路由所使用的每个定向段记录ID的列表。我们使用这个列表来快速丢弃另一个路由正在使用相同道路段序列的新路由候选。'
- en: '`score`: This is the calculated score for this route candidate. The score is
    calculated as the sum of the GPS distances in each route segment—in other words,
    the lower the score, the more closely the GPS points follow this route.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score`: 这是为此路由候选计算出的分数。分数是每个路由段中GPS距离的总和——换句话说，分数越低，GPS点越接近此路由。'
- en: 'With this information in mind, let''s start implementing the map matcher. Create
    a new Python program called `map_matcher.py`, and enter the following into this
    file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解这些信息的基础上，让我们开始实现地图匹配器。创建一个新的Python程序，命名为`map_matcher.py`，并将以下内容输入到该文件中：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, we import the various libraries we''ll need, load the recorded
    GPS data into memory, and open a connection to our database. Next, we want to
    reset the `tally` values for our road segments:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们导入了所需的各个库，将记录的GPS数据加载到内存中，并打开到我们的数据库的连接。接下来，我们想要重置道路段的总计值：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are now ready to start processing the recorded GPS data. While the paper
    this algorithm is based on uses a sophisticated process of splitting the GPS data
    into trip segments, processing each trip segment and then joining the resulting
    routes together, we are going to use a much simpler approach; we will assume that
    each GPS recording has no gaps in it, but that it might start or finish away from
    a road. To handle this, we trim the start and end coordinates until we reach a
    point within 10 meters of a road.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好开始处理记录的GPS数据。虽然基于此算法的论文使用了一种复杂的过程，将GPS数据分割成行程段，处理每个行程段，然后将结果路由连接起来，但我们将使用一种更简单的方法；我们假设每个GPS记录没有间隙，但它可能开始或结束在道路上。为了处理这个问题，我们修剪起点和终点坐标，直到我们找到一个距离道路10米以内的点。
- en: 'Add the following to the end of your program:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到程序末尾：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are simply processing each GPS track in turn, trimming points from the start
    and end until we find a GPS point which is within 10 meters of a road segment.
    Notice that we''re using a function named `calc_circle_with_radius()` to create
    a Shapely polygon that describes a circle 10 meters around a GPS coordinate, and
    then ask the database to find any road segments within that circle. Let''s go
    ahead and implement that `calc_circle_with_radius()` function; place this at the
    top of your program, immediately after the `import` statements:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是依次处理每个GPS轨迹，从起点和终点修剪点，直到找到一个距离道路段10米以内的GPS点。请注意，我们正在使用一个名为`calc_circle_with_radius()`的函数来创建一个描述GPS坐标周围10米圆的Shapely多边形，然后要求数据库在该圆内查找任何道路段。让我们继续实现这个`calc_circle_with_radius()`函数；将其放置在程序顶部，紧接在`import`语句之后：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we have the set of relevant GPS points within each recording, we are
    ready to start map matching. The first step is to build an initial set of route
    candidates based on the starting GPS point. We do this by identifying all road
    endpoints within 750 meters of the GPS point, and create a (single-segment) route
    candidate for each road segment leading off from those endpoints. Following Schuessler
    and Axhausen's paper, we ensure that there are at least 25 route candidates, and
    if there are not, we expand the search area by 100 meters and try again.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了每个记录中相关的GPS点集合，我们准备好开始地图匹配。第一步是根据起始GPS点构建一组初始路由候选。我们通过识别距离GPS点750米以内的所有道路端点来完成此操作，并为从这些端点出发的每个道路段创建一个（单段）路由候选。遵循Schuessler和Axhausen的论文，我们确保至少有25个路由候选，如果没有，我们将搜索区域扩大100米并再次尝试。
- en: 'Add the following code to the end of your program:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的程序末尾：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, we create a single route segment dictionary and a route candidate
    dictionary for each possible route candidate, storing the results in the `route_candidates`
    list. There are two more functions that we need here: one to calculate the distance
    from a given point to the closest point within a given Shapely geometry, and another
    to calculate the score for a given route candidate. Go ahead and add these two
    functions to the top of your program:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为每个可能的路线候选者创建一个单独的路线段字典和一个路线候选者字典，并将结果存储在`route_candidates`列表中。这里我们还需要两个额外的函数：一个用于计算从给定点到给定Shapely几何体内部最近点的距离，另一个用于计算给定路线候选者的得分。请将这些两个函数添加到程序顶部：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that we have an initial set of route candidates, we have to **develop**
    them by adding each successive GPS point to each route candidate, generating new
    route candidates as we reach the end of each road segment. At the same time, we
    **trim** the list of route candidates to stop it from growing too large.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一组初始路线候选者，我们必须通过将每个连续的GPS点添加到每个路线候选者中来**开发**它们，在到达每个路段的末尾时生成新的路线候选者。同时，我们**修剪**路线候选者列表，以防止其变得过大。
- en: 'The bulk of our work will be done in a function named `develop_route()`. This
    function will take a route candidate and a GPS point (as well as a few other parameters),
    and return a list of new or updated route candidates to include for processing
    in the next iteration. Let''s write the code which uses this function; add the
    following to the end of your program:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分工作将在名为`develop_route()`的函数中完成。这个函数将接受一个路线候选者和一个GPS点（以及一些其他参数），并返回一个包含新或更新路线候选者的列表，以便在下一轮迭代中进行处理。让我们编写使用此函数的代码；将以下内容添加到程序末尾：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We process each route candidate exactly once, first removing it from the list
    of candidates using `route_candidates.pop(0)`, and then passing the candidate
    to the `develop_route()` function. We then add the new or updated route candidates
    to the end of the `route_candidates` list. By the time our `for i in range(num_routes_to_process)`
    loop has finished, we would have processed each route candidate exactly once,
    either incorporating the GPS point into that route candidate or replacing it with
    a new set of route candidates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每个路线候选者只处理一次，首先使用`route_candidates.pop(0)`将其从候选者列表中删除，然后将候选者传递给`develop_route()`函数。然后我们将新或更新的路线候选者添加到`route_candidates`列表的末尾。当我们的`for
    i in range(num_routes_to_process)`循环结束时，我们将已经处理了每个路线候选者一次，要么将GPS点纳入该路线候选者，要么用一组新的路线候选者替换它。
- en: 'Before we start processing the next GPS point, we need to trim the list of
    route candidates. According to Schuessler and Axhausen, a highly effective way
    of doing this is to repeatedly remove the route candidate with the highest score
    until there are no more than 40 remaining candidates. Let''s do this now:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理下一个GPS点之前，我们需要修剪路线候选者列表。根据Schuessler和Axhausen的说法，一种非常有效的方法是反复移除得分最高的路线候选者，直到剩余的候选者不超过40个。我们现在就来做这件事：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure you put this code inside the `for next_point in...` loop.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将此代码放在`for next_point in...`循环内。
- en: 'Before we implement the `develop_route()` function, let''s finish writing the
    main part of our program. We have now processed all the GPS points, so we can
    check the score for each remaining route candidate and choose the candidate with
    the lowest score (excluding any candidates with fewer than two route segments).
    This is the route candidate most likely to have been taken by the GPS points.
    We then increment the tally for each road segment used by that route. Here is
    the relevant code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现`develop_route()`函数之前，让我们完成程序的主要部分。我们现在已经处理了所有GPS点，因此我们可以检查每个剩余路线候选者的得分，并选择得分最低的候选者（排除任何路线段少于两个的候选者）。这是GPS点最有可能采取的路线候选者。然后我们增加该路线使用的每个路段的计数。以下是相关代码：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now need to implement the `develop_route()` function. This function uses
    the following logic, taken from the paper by Schuessler and Axhausen:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要实现`develop_route()`函数。这个函数将使用Schuessler和Axhausen论文中的以下逻辑：
- en: If the route candidate has only one segment, see whether the GPS point has reached
    the start of that segment's LineString. If this happens, the GPS recording must
    be following the directed road segment in the wrong direction, so we discard the
    route candidate.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果路线候选者只有一个路段，检查GPS点是否到达该路段LineString的起点。如果发生这种情况，GPS记录必须是在错误方向上跟随该有向路段，因此我们丢弃该路线候选者。
- en: See whether the GPS point is still within the route candidate's final segment.
    If so, add the GPS point to that final segment, recalculate the candidate's score,
    and return it for further processing.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查GPS点是否仍然位于路线候选者的最终段内。如果是这样，将该GPS点添加到该最终段，重新计算候选者的得分，并返回它以供进一步处理。
- en: If the GPS point is beyond the end of the route candidate's final segment, identify
    the endpoint we have reached and create a new route candidate for each directed
    road segment leaving from that endpoint. We check the validity of each of the
    new route candidates, and return the valid candidates for further processing.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果GPS点超出了路线候选者最终段落的末尾，识别我们已达到的端点，并为从该端点出发的每个有向道路段创建一个新的路线候选者。我们检查每个新路线候选者的有效性，并返回有效候选者以供进一步处理。
- en: 'Let''s start implementing this function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现这个函数：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This implements the first two of the steps described earlier. Notice that we
    use a couple of new functions, `point_at_start_of_segment()` and `point_in_route_segment`(),
    to do all the hard work. We'll implement these functions shortly, but first let's
    work through the process of creating a new set of route candidates once the GPS
    point has gone past the end of the last route segment.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了之前描述的前两个步骤。请注意，我们使用了两个新的函数，`point_at_start_of_segment()` 和 `point_in_route_segment()`
    来完成所有繁重的工作。我们将在不久后实现这些函数，但首先让我们通过创建一组新的路线候选集来处理GPS点经过最后一个路线段末尾的过程。
- en: 'The first step in this process is to identify the current endpoint that we
    have reached. Add the following to the end of your `develop_route()` function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第一个步骤是确定我们已达到的当前端点。将以下内容添加到 `develop_route()` 函数的末尾：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we will build a list of all the directed road segments that leave from
    this endpoint:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个包含所有从该端点出发的有向道路段列表：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We now need to create a new route candidate for each of the possible road segments.
    For each route candidate, we create a single route segment using that directed
    road segment:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为每个可能的路段创建一个新的路线候选者。对于每个路线候选者，我们使用该有向路段创建一个单独的路线段：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that we check the new route's validity using another function, `route_is_valid()`.
    We will also have to implement this function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用另一个函数 `route_is_valid()` 来检查新路线的有效性。我们还将必须实现这个函数。
- en: 'This completes the `develop_route()` function itself. Let''s now write the
    `point_at_start_of_segment()` function, which determines whether the GPS track
    is running the wrong way along a directed road segment:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `develop_route()` 函数本身。现在让我们编写 `point_at_start_of_segment()` 函数，该函数确定GPS轨迹是否沿着有向道路段错误地运行：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code is a bit of a kludge, comparing the distance from the current point
    to the road segment's start and endpoints, but it works well enough for our purposes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点混乱，比较当前点到路段起点和终点的距离，但对我们来说已经足够好了。
- en: 'Next, we need to implement the `point_in_route_segment()` function. We will
    use two separate tests to see whether the point has reached the segment''s endpoint.
    First off, we know we have reached the endpoint if the distance from the GPS point
    to the closest point on the segment''s LineString is equal to the distance from
    the point to the end of that LineString:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现 `point_in_route_segment()` 函数。我们将使用两个单独的测试来查看点是否已达到段落的端点。首先，我们知道如果GPS点到段落的LineString上最近点的距离等于点到该LineString末端的距离，那么我们已经到达了端点：
- en: '![Implementing the map matching algorithm](img/B04102_6_07.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![实现地图匹配算法](img/B04102_6_07.jpg)'
- en: 'Here is the first part of the `point_in_route_segment()` function, which implements
    this test:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `point_in_route_segment()` 函数的第一部分，它实现了这个测试：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The second test involves comparing the length of the final route segment with
    the length of a LineString built out of the GPS points assigned to that route
    segment. If the GPS LineString is longer than the road segment, then we must have
    reached the end of that segment:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试涉及比较最终路线段与由分配给该路线段的GPS点构建的LineString的长度。如果GPS LineString比路段长，那么我们必须已经到达了该段落的末尾：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, if the GPS point failed both of these tests, then it must still be
    within the current route segment:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果GPS点未通过这两个测试，那么它仍然位于当前路线段内：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The paper by Schuessler and Axhausen suggests a third test, comparing the direction
    of the GPS track against the direction of the road segment. However, it was not
    clear how this could be implemented where road segments are complex LineStrings
    rather than straight line segments, so we won't use this test in our implementation
    of the map matching algorithm.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Schuessler 和 Axhausen 的论文提出了一种第三种测试方法，即比较 GPS 轨迹的方向与路段方向。然而，由于路段是复杂的 LineStrings
    而不是直线段，因此不清楚如何实现这种测试，所以我们不会在我们的地图匹配算法实现中使用这种测试。
- en: 'This completes the `point_in_route_segment()` function. The last function we
    need to implement is `route_is_valid()`. A route candidate is considered to be
    valid if:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `point_in_route_segment()` 函数的实现。我们需要实现的最后一个函数是 `route_is_valid()`。如果一条路线候选被认为是有效的，那么：
- en: It is unique; that is, there is no other route candidate with the exact same
    sequence of road segments
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是唯一的；也就是说，没有其他路线候选具有完全相同的路段序列
- en: Its final road segment does not go back to the start of the previous segment;
    that is, the route doesn't double back on itself.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其最终路段不会回到前一个路段的起点；也就是说，路线不会自我回环。
- en: The route doesn't include the same directed road segment twice
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路线不包括相同的定向路段两次
- en: In order to calculate uniqueness, the `route_is_valid()` function will need
    not only a list of all the current route candidates, but also a list of the new
    candidates being created by the `develop_route()` function. For this reason, the
    `route_is_valid()` function accepts both the current list of route candidates
    and the list of new candidates being created.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算唯一性，`route_is_valid()` 函数不仅需要一个当前路线候选的列表，还需要一个由 `develop_route()` 函数创建的新候选列表。因此，`route_is_valid()`
    函数接受当前路线候选列表和正在创建的新候选列表。
- en: 'Here is the first part of the implementation of this function, including the
    uniqueness check:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该函数实现的第一部分，包括唯一性检查：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following code checks that a route does not double back on itself:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查一条路线是否不会自我回环：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we ensure that the same directed road segment isn''t being used twice:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们确保相同的定向路段不会被使用两次：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If the route passes all three checks, then it is considered to be valid:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路线通过所有三个检查，则被认为是有效的：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This completes the implementation of the `route_is_valid()` function, and indeed
    the implementation of the entire `map_matcher.py` program. You should be able
    to run it from the command line and see each GPS recording being processed in
    turn:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `route_is_valid()` 函数的实现，实际上也完成了整个 `map_matcher.py` 程序的实现。您应该能够从命令行运行它，并依次看到每个
    GPS 记录被处理：
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Because there are thousands of points in each GPS recording, the program will
    take a few minutes to process each file. Once it has finished, the `tally` field
    in the `road_segments` table would have been updated to show the number of times
    each road segment was used. You can check this using the Postgres command-line
    client:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 GPS 记录中都有数千个点，程序处理每个文件将需要几分钟。一旦完成，`road_segments` 表中的 `tally` 字段就会更新，以显示每个路段被使用的次数。您可以使用
    Postgres 命令行客户端进行检查：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, map matching is quite a complex process, but this program actually
    works pretty well. Now that we''ve calculated the tallies, we can write the final
    part of our GPS Heatmap system: the program that displays the heatmap based on
    the calculated tally values.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，地图匹配是一个相当复杂的过程，但这个程序实际上工作得相当好。现在我们已经计算了计数，我们可以编写我们 GPS 热力图系统的最后一部分：基于计算计数值显示热力图的程序。
- en: Generating the GPS heatmap
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 GPS 热力图
- en: 'We are going to use Mapnik to generate the heatmap, creating a separate `mapnik.Rule`
    for each unique tally value so that the color used for each road segment varies
    depending on its tally. This program will be called `generate_heatmap.py`; create
    this program and enter the following code into it:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Mapnik 生成热力图，为每个独特的计数值创建一个单独的 `mapnik.Rule`，这样每个路段使用的颜色就会根据其计数值而变化。这个程序将被命名为
    `generate_heatmap.py`；创建这个程序并将以下代码输入其中：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After importing the libraries we need and defining some constants, we open
    up a connection to the database so that we can calculate the highest tally value
    and the bounds of the calculated heatmap. Let''s do that now:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所需的库和定义一些常量之后，我们打开数据库连接，以便我们可以计算最高的计数值和计算热力图的边界。现在让我们来做这件事：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, we use the `MIN_TALLY` constant to zoom in on the more popular
    parts of the heatmap. You can change this value if you want; setting it to `1`
    will display every road segment covered by a GPS track, and setting it to a higher
    value will focus in on the most commonly used portions of the map.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用`MIN_TALLY`常量来放大热图中更受欢迎的部分。如果你想改变这个值，将其设置为`1`将显示所有被GPS轨迹覆盖的道路段，而将其设置为更高的值将聚焦于地图上最常用的部分。
- en: 'Now that we know the area of the Earth covered by the heatmap, we can calculate
    the dimensions of the map image. We want to use the specified maximum size, while
    maintaining the aspect ratio of the map:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了热图覆盖的地球区域，我们可以计算地图图像的尺寸。我们希望使用指定的最大尺寸，同时保持地图的宽高比：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we initialize the map itself:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化地图本身：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Even though only some of the road segments would have been used by the GPS
    recordings, we still want to show all the unused road segments as a backdrop for
    the heatmap. To do this, we will create an `unused_roads` layer and corresponding
    Mapnik style:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只有部分道路段会被GPS记录使用，但我们仍然想显示所有未使用的道路段作为热图的背景。为此，我们将创建一个`unused_roads`图层和相应的Mapnik样式：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that we use a `mapnik.PostGIS()` datasource so that the map layer takes
    its data directly from our PostGIS database.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`mapnik.PostGIS()`数据源，这样地图图层就可以直接从我们的PostGIS数据库中获取数据。
- en: 'Next, we need to define a map layer for the roads which were used (that is,
    the roads which have a `tally` value of `1` or more). This map layer, which we
    will call `used_roads`, will have a separate `mapnik.Rule()` for each unique tally
    value. This allows us to assign a different color to each unique tally value so
    that the color used for each road segment varies according to that segment''s
    tally. To implement this, we will need a function that calculates the `mapnik.Stroke()`
    to use for a given tally value. Here is that function, which you should place
    near the top of your program:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个用于已使用道路（即具有`tally`值为`1`或更多的道路）的地图图层。这个我们将称之为`used_roads`的图层将为每个独特的`tally`值有一个单独的`mapnik.Rule()`。这允许我们为每个独特的`tally`值分配不同的颜色，以便每个道路段的颜色根据该段`tally`值而变化。为了实现这一点，我们需要一个函数来计算给定`tally`值要使用的`mapnik.Stroke()`。以下是这个函数，你应该将其放置在程序顶部附近：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `interpolate()` helper function is used to calculate a color range from
    pale blue to dark blue. We also adjust the width of the displayed road segment
    according to the tally so that more frequently used roads are drawn with a wider
    stroke on the map.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`interpolate()`辅助函数用于计算从浅蓝色到深蓝色的颜色范围。我们还根据`tally`调整显示的道路段宽度，以便更常用的道路在地图上用更宽的线条绘制。'
- en: Tip
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want, you can change the starting and ending colors to make the heatmap
    more colorful. As mentioned earlier, we are just using shades of blue so that
    the heatmap makes sense when printed in black and white.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你可以更改起始和结束颜色，使热图更加多彩。如前所述，我们只是使用了蓝色调，这样当以黑白打印时热图才有意义。
- en: 'With this function implemented, we can add the `used_roads` layer to our map.
    To do this, add the following code to the end of your program:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了这个功能后，我们可以将`used_roads`图层添加到我们的地图中。为此，请将以下代码添加到你的程序末尾：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we can render the map, saving the results to an image file on the
    disk:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将地图渲染出来，并将结果保存到磁盘上的图像文件中：
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After running this program, you should get a `heatmap.png` file containing
    the generated heatmap:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序后，你应该得到一个包含生成的热图的`heatmap.png`文件：
- en: '![Generating the GPS heatmap](img/B04102_6_08.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![生成GPS热图](img/B04102_6_08.jpg)'
- en: Congratulations! This program is anything but trivial, and solves a number of
    geospatial problems along the way in producing this image. Of course, you can
    use this program to match your own GPS recordings against a road network, but
    what we have really done is shown how complex geospatial problems can be solved
    one step at a time, using the various techniques described throughout this book.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这个程序绝非平凡，在生成这张图像的过程中解决了许多地理空间问题。当然，你可以使用这个程序来匹配你自己的GPS记录与道路网络，但我们真正展示的是如何一步一步地解决复杂的地理空间问题，使用本书中描述的各种技术。
- en: Further improvements
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进
- en: 'While the GPS Heatmap system works surprisingly well, it is not perfect. No
    program is ever complete. If you''re inclined, you might want to consider the
    following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GPS热图系统工作得相当不错，但它并不完美。没有任何程序是完美的。如果你有兴趣，你可能想考虑以下方面：
- en: Make the road-segmentation algorithm more sophisticated to support one-way roads,
    and points where two roads intersect but do not join (for example, on a highway
    overpass).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使路段分割算法更复杂，以支持单行道路，以及两条道路相交但不连接的点（例如，在高速公路上跨线桥上）。
- en: Improve the route-development process to allow it to capture routes that include
    U-turns and repeated road segments.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进路线开发过程，使其能够捕捉包括掉头和重复路段的路线。
- en: Take the raw GPS data and split it into contiguous segments, process each segment
    in turn, and then join the processed segments back together again. This will allow
    the algorithm to work with GPS recordings that include gaps in the recorded data.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始GPS数据分割成连续的段，依次处理每个段，然后将处理过的段重新连接起来。这将允许算法处理包含数据缺失的GPS记录。
- en: Combine the map matching algorithm with a shortest-path calculation to write
    your own turn-by-turn navigation system.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将地图匹配算法与最短路径计算相结合，编写你自己的逐点导航系统。
- en: Look at ways to improve the speed of the map matching algorithm. For example,
    if two different route candidates use the same road segment, those two candidates
    should be able to share the calculated distance between a point and that road
    segment. This will avoid having to calculate the same distance twice. There are
    bound to be other ways you could optimize the map matcher so that it runs even
    faster.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究提高地图匹配算法速度的方法。例如，如果两个不同的路线候选者使用相同的路段，这两个候选者应该能够共享点到该路段之间的计算距离。这将避免需要计算两次相同的距离。肯定还有其他方法可以优化地图匹配器，使其运行得更快。
- en: Add a nice-looking raster basemap image to the generated heatmap.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个漂亮的栅格底图图像添加到生成的热图中。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! You have finished implementing a suite of programs that use
    a range of geospatial analysis techniques to match recorded GPS data to an existing
    network of roads. In the process of creating the GPS Heatmap system, you have
    learned how to convert existing road data into a network, how to represent a network
    of roads within a database, and how to use this data to implement a sophisticated
    map matching algorithm. This algorithm was then used to calculate a tally of how
    often each road segment was used by the recorded GPS data, and the tallies were
    then used to generate a nice-looking heatmap showing the most commonly used roads.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了实现一系列程序，这些程序使用一系列地理空间分析技术将记录的GPS数据与现有的道路网络匹配。在创建GPS热图系统的过程中，你学习了如何将现有的道路数据转换为网络，如何在数据库中表示道路网络，以及如何使用这些数据来实现复杂的地图匹配算法。然后，该算法被用来计算记录的GPS数据中每个路段被使用的频率，然后使用这些计数来生成一个显示最常用道路的漂亮热图。
- en: 'Even if you are not interested in capturing your own GPS data and matching
    it against a map, the techniques we have used in this chapter will give you many
    ideas for your own development efforts. Using a combination of Python, GDAL and
    OGR, Shapely, PyProj, PostGIS and Mapnik, you now have a fantastic arsenal of
    tools for processing, analyzing and displaying geospatial data. To learn more,
    check out the following references:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你对捕捉自己的GPS数据并将其与地图匹配不感兴趣，本章中使用的技巧也会给你自己的开发工作提供许多想法。使用Python、GDAL和OGR、Shapely、PyProj、PostGIS和Mapnik的组合，你现在拥有了一套处理、分析和显示地理空间数据的强大工具。要了解更多信息，请查看以下参考资料：
- en: '[http://gdal.org](http://gdal.org) is the main website for the GDAL and OGR
    libraries.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GDAL和OGR库的主网站](http://gdal.org)'
- en: '[http://trac.osgeo.org/gdal/wiki/GdalOgrInPython](http://trac.osgeo.org/gdal/wiki/GdalOgrInPython)
    describes the overall design of the Python interface to GDAL and OGR.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GDAL和OGR的Python接口的整体设计描述](http://trac.osgeo.org/gdal/wiki/GdalOgrInPython)'
- en: '[http://trac.osgeo.org/gdal/wiki/PythonGotchas](http://trac.osgeo.org/gdal/wiki/PythonGotchas)
    lists a number of issues to be aware of when using GDAL/OGR from Python.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Python的GDAL/OGR时需要注意的一些问题列表](http://trac.osgeo.org/gdal/wiki/PythonGotchas)'
- en: '[http://pypi.python.org/pypi/Shapely](http://pypi.python.org/pypi/Shapely)
    is the main website for the Shapely library.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Shapely库的主网站](http://pypi.python.org/pypi/Shapely)'
- en: '[http://toblerity.org/shapely/manual.html](http://toblerity.org/shapely/manual.html)
    is where you can find the Shapely user manual.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Shapely用户手册可以在这里找到](http://toblerity.org/shapely/manual.html)'
- en: '[https://trac.osgeo.org/proj](https://trac.osgeo.org/proj) describes the Proj.4
    cartographic projection library.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Proj.4地图投影库的描述](https://trac.osgeo.org/proj)'
- en: '[http://jswhit.github.io/pyproj](http://jswhit.github.io/pyproj) is the main
    site for the Python interface to the Proj library.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://jswhit.github.io/pyproj](http://jswhit.github.io/pyproj) 是 Proj 库的
    Python 接口的主要网站。'
- en: '[http://www.postgresql.org](http://www.postgresql.org) is the main site for
    the PostgreSQL database.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.postgresql.org](http://www.postgresql.org) 是 PostgreSQL 数据库的主要网站。'
- en: '[http://postgis.net](http://postgis.net) is the site for the PostGIS extension
    to Postgres.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://postgis.net](http://postgis.net) 是 PostGIS 扩展的网站。'
- en: '[http://mapnik.org](http://mapnik.org) is the main site for the Mapnik library.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mapnik.org](http://mapnik.org) 是 Mapnik 库的主要网站。'
- en: Finally, [http://github.com/mapnik/mapnik/wiki](http://github.com/mapnik/mapnik/wiki)
    provides a lot of useful information to help you work with Mapnik.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，[http://github.com/mapnik/mapnik/wiki](http://github.com/mapnik/mapnik/wiki)
    提供了大量有用的信息，以帮助你使用 Mapnik。
- en: This particular book is now finished, but I hope I have left you with a greater
    understanding of the tools and techniques you can use for geospatial analysis,
    and how Python can be used as the foundation for your own geospatial development
    efforts. The rest is up to you.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书现在已经完成，但我希望我已经让你对可用于地理空间分析的工具和技术有了更深入的理解，以及Python如何作为你自己的地理空间开发工作的基础。其余的取决于你。
