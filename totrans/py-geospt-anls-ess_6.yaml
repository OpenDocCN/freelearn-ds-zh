- en: Chapter 6. Building a Complete Geospatial Analysis System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take the skills we have learned in the previous chapters
    and apply them to build a suite of programs that solve a complicated geospatial
    problem. In doing so, we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What map matching is, and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use map matching to generate a heatmap of roads traveled based on GPS
    recordings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to download road map data and transform it into a network of roads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to store the road network in a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate your own records of journeys using a GPS tracking device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a map matching algorithm to match GPS recordings to an existing
    road network, and use the results to calculate how often each road segment was
    used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate a great-looking GPS Heatmap using this calculated data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by examining the concept of map matching, and see how it can be
    useful in solving various geospatial problems.
  prefs: []
  type: TYPE_NORMAL
- en: Matching GPS data against a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A GPS recording device captures a series of latitude and longitude coordinates
    over time. As the device is carried by someone moving from place to place, the
    GPS coordinates record the person''s movements. The following map shows a typical
    GPS recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matching GPS data against a map](img/B04102_6_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GPS devices are relatively cheap and remarkably accurate, allowing you to record
    a journey taken on foot, by bicycle, car, or truck. However, by itself, all the
    GPS device is doing is recording a series of coordinates—the GPS device doesn't
    know which roads you followed on your journey.
  prefs: []
  type: TYPE_NORMAL
- en: '**Map matching** is the process of taking a GPS recording and matching it against
    a database of roads to identify which set of roads were used on that journey.
    For map matching to be successful, you need three things:'
  prefs: []
  type: TYPE_NORMAL
- en: An accurate GPS recording of the journey, including enough GPS coordinates to
    identify which roads were taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An accurate database of roads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A suitable algorithm to match the GPS coordinates against the road database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you know which roads were taken, you can use this information for various
    purposes. For example, a turn-by-turn navigation system will use its knowledge
    of the road database and the path taken so far to suggest the next turn to take.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use map matching for historical purposes: keeping track of which
    routes a traveler took on their journey, possibly to optimize future journeys,
    or noting which roads were most commonly traveled.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will implement a complete map matching system, using an
    appropriate database of road data and a sophisticated algorithm for matching a
    GPS recording against those roads. We will use this information to generate a
    heatmap of commonly-used roads over a series of historical GPS recordings.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the GPS Heatmap system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The system we are implementing will be called the **GPS Heatmap**. We will
    download a set of road data and convert this data into a network of directed road
    segments. We will then either generate or download a collection of GPS recordings
    from various journeys, which we will use to identify commonly-traveled roads.
    Finally, we will generate a heatmap based on how often the roads are traveled,
    providing a visual summary of the most commonly-traveled roads captured by the
    GPS device. The resulting output will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the GPS Heatmap system](img/B04102_6_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A heatmap typically uses a color gradient ranging from blue to red to draw the
    roads, with blue used for the less-traveled roads and red for the most commonly
    traveled roads. In the printed edition of this book, however, the heatmaps will
    appear in black and white, so we have selected a single shade of blue so that
    the heatmap still makes sense when printed.
  prefs: []
  type: TYPE_NORMAL
- en: To allow our GPS Heatmap program to work as efficiently as possible, we will
    make use of a PostGIS database to store the underlying road data. We will generate
    a planar graph of the nonintersecting road segments, use this data to build a
    network of connected road segments, and store this network in the database for
    quick access. We will then use a map matching algorithm to calculate a **tally**
    for each road segment. These tallies then form the basis for generating the GPS
    heatmap image, with a suitable color chosen for each road segment based on the
    calculated tally for that segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because our GPS Heatmap program consists of many parts, we will implement it
    as a suite of individual Python programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init_db.py`: This will initialize the PostGIS database, providing us with
    a place to store the data as we load and process it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import_roads.py`: This will import the road data from a shapefile into the
    PostGIS database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split_roads.py`: This will convert the imported roads into a series of nonoverlapping
    road segments by calculating a planar graph based on the raw road data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calc_directed_network.py`: This will use the road segments to generate a directed
    network of connected road segments. This tells us how the various road segments
    are connected, and which segments lead off from a given point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map_matcher.py`: This performs the actual map matching process, reading the
    raw GPS data from a GPX format file, using it to identify which road segments
    were traveled by the person using that GPS device, and incrementing the tally
    for each road segment as it is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generate_heatmap.py`: This will use the calculated tally data to generate
    a heatmap image for display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we can start implementing these various programs, we will need to obtain
    the underlying data. Let's look at how to do this now.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the necessary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your first choice is to decide which GPS dataset to use. You can capture your
    own GPS recordings using a GPS device if you wish, or you can make use of the
    GPS recordings provided with the example code for this chapter. Once you have
    decided which set of GPS data to use, you will need to download road data for
    the same area.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by deciding which set of GPS data you wish to use.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining GPS data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have your own GPS recording device, you might like to go out and capture
    your own GPS recordings as you travel back and forth in your local area. If you
    do not have your own GPS recording device, or if you do not want to capture your
    own GPS data, example GPS recordings are provided along with the sample code for
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: These example recordings were taken in and around the author's home city of
    Rotorua, New Zealand. The recordings were captured using a Garmin Edge 500 cycle
    computer, and exported in `GPX` format. If you want to capture your own GPS recordings,
    make sure you record at least 20 separate journeys so that you have a good set
    of data to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not every GPS recording will be usable. Sometimes, the GPS data can be too inaccurate
    or might miss sections of your journey, leading to matching errors. Also, limitations
    in the map matching algorithm mean that any journey which U-turns along a road,
    or uses the same road segment twice, cannot be matched. For this reason, you may
    find that some of your recordings do not work.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you use the sample recordings or create your own, place the resulting
    `GPX` format files into a directory named `gps-data`.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the road data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have your GPS recordings, you next need a matching set of road data.
    If your GPS recordings were taken in the USA, you can use the TIGER data from
    the US Census Bureau''s website. We used this site in the previous chapter to
    download all primary and secondary roads in California. In this case, you will
    want to download all the roads in your area. To do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.census.gov/geo/maps-data/data/tiger-line.html](https://www.census.gov/geo/maps-data/data/tiger-line.html),
    scroll down to the section labeled **2014 TIGER/Line Shapefiles**, click on the
    **Download** option, and then click on **Web interface**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the download page, choose **Roads** from the **Select a layer type** drop-down
    menu, and then click on the **Submit** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your state from the **All Roads** drop-down menu, and click on **Submit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will then need to choose the county you are in, and finally you can click
    on the **Download** button to obtain the road data you need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are outside the USA, you will need to find a suitable alternative. OpenStreetMap
    ([http://openstreetmap.org](http://openstreetmap.org)) is one possible source
    of data, though you may need to hunt to find road data in a format you can use.
    Alternatively, the [https://koordinates.com](https://koordinates.com) site might
    have data you can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make use of the example GPS recordings provided in this chapter,
    take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://koordinates.com](https://koordinates.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Sign in** link in the upper-right-hand corner of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register for a free account by clicking on the **Register** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After signing in, you will see a map centered on your location. Pan the map
    over to New Zealand and zoom in on the central North Island until you find the
    city of Rotorua.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the search box in the upper-left corner of the page, type `road centrelines`
    and press *Return*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the New Zealand spelling for the word "centrelines"; if you type `centerlines`,
    you won't find the data you're looking for.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The dataset you are looking for is called *Improved NZ Road Centrelines (August
    2011)*. Click on the **+** icon beside this dataset, and the road data will appear
    on your map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, zoom in further to show the city of Rotorua and its environs, click on
    the crop tool (![Downloading the road data](img/B04102_6_03.jpg)) in the upper-right-hand
    corner of the page, and drag out a rectangle that looks approximately like the
    following screenshot:![Downloading the road data](img/B04102_6_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this has been selected, click on the **Download or Order** link in the
    upper-right-hand corner of the window. The default options (WGS 84 map projection
    and shapefile format) are exactly what you want, so just click on the **Accept
    terms and create download** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a minute or so, the road data will be available for you to download. The
    resulting file will be named `kx-improved-nz-road-centrelines-august-2011-SHP.zip`.
    Decompress this ZIP archive, rename the resulting directory to `roads`, and place
    this directory somewhere convenient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the GPS Heatmap system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the necessary data, we're ready to start implementing our GPS
    Heatmap system. Create a directory named `gps-heatmap` to hold the suite of programs
    and their associated data files, and then place the two data directories you created
    earlier (`gps-data` and `roads`) into this directory.
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to start coding. Let's start by implementing the `init_db.py`
    program to initialize our PostGIS database.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should already have installed Postgres when you worked through [Chapter
    3](ch03.html "Chapter 3. Spatial Databases"), *Spatial Databases*. We''re going
    to use Postgres to create and initialize a database to hold all our processed
    road data. The first step is to create the database itself, which you can do by
    typing the following into a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This should create a database named `gps_heatmap`. If you get an authentication
    error, you will need to enter a password or use the `-U postgres` command-line
    option so that the `createdb` command can run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have created the database itself, the next step is to turn it
    into a spatial database so we can use it to store geometry data. To do this, enter
    the following command into the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not forget to add the `-U postgres` command-line option if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now created a spatial database for your Python code to use. We are
    now going to write the `init_db.py` script that initializes the various tables
    and indexes within this database. Go ahead and create the `init_db.py` file inside
    your main `gps-heatmap` directory, and enter the following code into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the `psycopg2` library to access our PostGIS database.
    We create a database connection and an associated `cursor` object. We then create
    the `roads` database table, first deleting it so that we can run this script again
    if we have to change the database structure.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to change the parameters to the `psycopg2.connect()` statement
    if you need to use a different username or password to access PostGIS on your
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `roads` table will hold the raw road data imported from the shapefile that
    we have just downloaded. As you can see, this table will have three separate fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the unique ID for this road in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the name of the road'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`centerline`: This is a LineString geometry that represents the shape of this
    road'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not the only database table we need, but it is enough to get us started.
    We will add more table definitions to the `init_db.py` program as we go along.
    For now, though, you should be able to run this program to create the `roads`
    table, which we will need in the next section when we import the downloaded road
    data into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the road data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to import the road data from the downloaded shapefile into
    the database. The program that will do this is called `import_roads.py`. Go ahead
    and create this file, and enter the following Python code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, all we have done is to open a connection to the database and delete
    the existing contents of the `roads` table. Next, we need to import the road data
    from the shapefile we downloaded. How we do this, of course, will vary depending
    on where the road data came from. For the *Improved NZ Road Centrelines* data,
    we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use OGR to import the road data from the shapefile, and use
    either the `descr` or the `label` field for the road name. This corresponds to
    the way the *NZ Road Centrelines* data has been defined, where sometimes the road
    name is in the `descr` field, and at other times the road name is in the `label`
    field. Some roads don't have a name (for example, where the road goes through
    a roundabout), and so in this case the road name will be set to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a different source of road data, you will need to modify this
    code to suit the way your road data is organized. Just make sure that you store
    the centerline and (where applicable) the name of the road into the `roads` table.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the road data into segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen in the previous chapter, the points where roads touch or cross
    aren't automatically considered to be connection points for the purpose of building
    a road network. We first need to create a **planar graph** out of the intersecting
    roads, just like we did in the previous chapter. Our next task, therefore, is
    to split the roads up into segments, forming a planar graph of road segments out
    of the raw road data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `split_roads.py` program will split the raw road data into segments. Before
    we can write this program, however, we need to add a table to the database which
    will hold the road segments. To do this, add the following code to your `init_db.py`
    program, immediately before the call to `connection.commit()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we create a new table called `road_segments` to hold the various
    segments in our planar graph. Each road segment will have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the unique ID for this road segment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the name of the road this segment is a part of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`centerline`: This is a LineString geometry representing the shape of this
    road segment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tally`: This is the number of times this road segment was used by the GPS
    recordings. This is the output of the map matching algorithm we will implement
    later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve created the `road_segments` table, we can start implementing
    the `split_roads.py` program. Create this file and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have simply opened a connection to the database and deleted any existing
    `road_segments` records. As usual, this gives us a blank table where we can store
    our calculated road segments, removing any segments that we may have stored previously.
    This allows us to run the program as often as we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to convert the contents of the `roads` table into a series of
    connected road segments. In the previous chapter, we used Shapely to perform this
    task using road data held in memory. This time, we''re going to implement the
    same process using PostGIS. First, we are going to load a master list of all the
    `road` record IDs into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will work through each of these roads in turn. For each road, we start by
    loading the road''s name and geometry into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have got the road''s LineString geometry, we want to split it at
    each point where it touches or crosses another road. To do this, we''ll build
    a list of **crossroads** for this road:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the crossroads to split the current road''s geometry into one or
    more segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to process the resulting road, dividing it up into a separate
    LineString for each road segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we save the calculated segments into the `road_segments` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally (outside the `for road_id in all_road_ids` loop), we commit our changes
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes our `split_roads.py` program. If you run through the programs
    in sequence, and then use the `psql` command-line client to access the database,
    you can see that the program has indeed generated a number of road segments out
    of the raw road data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you would expect, there are many more segments than there are roads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to view the road segments, you can easily write a program using
    Mapnik which displays the contents of the `road_segments` table. A version of
    this program, named `preview_segments.py`, is included in the sample code for
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a network of directed road segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we try to match the recorded GPS data against a database of road segments,
    one of the important questions we will need to answer is, "Which other road segments
    lead off from this one?" To answer this question, we will need to build a **directed
    network** of road segments.
  prefs: []
  type: TYPE_NORMAL
- en: We did something similar to this in the previous chapter, where we used NetworkX
    to calculate the shortest path between two points. In this case, however, we are
    going to store the network in the database for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the map matching algorithm easier to implement, our network of road
    segments will be **directed**—that is, each segment in our `road_segments` table
    will actually be represented by two separate road segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing a network of directed road segments](img/B04102_6_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, not every road is two-way, but we are ignoring this to keep things
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, each road segment is converted into two directed segments:
    one running from point A to point B, and the other running from point B back to
    point A.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use a new table named `directed_segments` to hold the directed
    road segments. Each directed segment record will have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the unique ID for this road segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`road_segment_id`: This is the record ID of the road segment this directed
    segment is derived from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`centerline`: This is the LineString geometry for this directed segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the directed segment's LineString runs in the same direction as the
    segment itself—that is, the start of the directed segment is at `centerline.coords[0]`
    and the end of the directed segment is at `centerline.coords[-1]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second table, `endpoints`, will hold the coordinates for the ends of the
    various directed road segments. Each endpoint record will have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the unique ID for this endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoint`: This is a Point geometry containing the coordinates for this endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We use a Point geometry here so that we can make spatial queries against this
    table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we are going to need a table that identifies which directed road segments
    leave from a given endpoint. This table, `endpoint_segments`, will have the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the unique ID for this `endpoint_segments` record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directed_segment_id`: This is the record ID of a directed road segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endpoint_id`: This is the record ID of the endpoint that this directed road
    segment leaves from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three tables will be used to store the network of directed road segments.
    Let''s modify our `init_db.py` program to create these three new tables. To do
    this, add the following code to the end of this file, immediately before the call
    to `connection.commit()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the last change we''ll need to make to our database structure, so go
    ahead and re-create the database tables, import the roads, and split them again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We wouldn't need to rerun our programs each time if we'd used database migrations,
    but we are keeping the database logic as simple as possible. Fortunately, this
    is the last time we will need to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to calculate the directed road network and store it into the
    database. The program we will create is called `calc_directed_network.py`; create
    this file, and enter the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to create the NetworkX graph representing the road network.
    When we did this in the previous chapter, we used the `networkx.read_shp()` function
    to create a NetworkX `DiGraph` object from the contents of a shapefile. Unfortunately,
    there''s no equivalent function for creating a graph from the contents of a PostGIS
    database; however, since NetworkX is implemented in Python, it is easy to adapt
    the source code for the `read_shp()` function to do what we want. Add the following
    code to the end of your `calc_directed_network.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The nodes in the NetworkX graph are a `(long,lat)` tuple identifying each road
    segment's endpoints, and the edges represent the directed road segments. Note
    that we store the record ID of the road segment as an attribute in the graph so
    that we can refer to it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the NetworkX graph, let''s prepare to use it to generate the
    directed network of connected road segments. To do this, we have to calculate
    the **largest connected subgraph** from the graph we have built, just like we
    did in the previous chapter. Here is the necessary code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a graph containing all the connected road segments. We can now
    use this to store the road segment endpoints into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `endpoint_ids` dictionary maps a `(long,lat)` coordinate to
    the record ID of the endpoint in the database. We will use this to link the directed
    road segments to their endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final task is to store the directed road segments, along with the endpoint
    the segment starts from. We''ll start by deleting the existing records in the
    database, and iterating over the road segments in our graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the record ID of the segment''s endpoints, and the LineString defining
    this road segment. We now need to convert this segment into two *directed* segments,
    one heading in each direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us two LineString geometries, one running from the first endpoint
    to the second, and the other running from the second endpoint back to the first.
    We can now save the information we''ve calculated into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish our program, we have to commit the changes we''ve made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now create the network of the directed road segments by running this
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the map matching algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready, at long last, to implement our map matching algorithm. The
    algorithm we will use is derived from the paper: *Map-matching of GPS traces on
    high-resolution navigation networks using the Multiple Hypothesis Technique (MHT)*,
    written by Nadine Schuessler and Kay Axhausen for the Institute of Transport Planning
    and Systems in Switzerland.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in reading this paper, it can be found at [www.ivt.ethz.ch/vpl/publications/reports/ab568.pdf](http://www.ivt.ethz.ch/vpl/publications/reports/ab568.pdf).
    This algorithm is based on the notion of a **route candidate**, which is a possible
    path the traveler could have taken as the GPS points were recorded. Each route
    candidate has a list of directed road segments and a **score** identifying how
    closely the GPS points match those road segments.
  prefs: []
  type: TYPE_NORMAL
- en: The journey is recreated by following the GPS points one at a time. At any particular
    moment, there is a list of route candidates which could possibly match the GPS
    coordinates which have been processed thus far. As each new GPS point is processed,
    the route candidates are updated one at a time by comparing the GPS coordinate
    with the route candidate's final road segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the GPS point is considered to still be somewhere on that final segment,
    then the GPS point is simply added to that segment and the route candidate''s
    score is updated. If, on the other hand, the GPS point is beyond the end of the
    route candidate''s final road segment, then we look at the road network to see
    which other road segments lead off from that point. We then create new route candidates
    for each road segment leaving from that endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the map matching algorithm](img/B04102_6_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once all the GPS points have been processed, we select the route candidate with
    the lowest score as being the one most likely to have been used for this journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this algorithm, we are going to use Python dictionaries to represent
    a **route segment**—that is, a single segment within a route candidate''s journey.
    Each route segment dictionary will have the following entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`directed_segment_id`: This is the record ID of the `directed_segment` which
    this segment of the route is following'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linestring`: This is the road segment''s centerline, as a Shapely LineString
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gps_points`: This is a list of (long,lat) coordinates defining the GPS points
    which have been assigned to this route segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gps_distances`: This is a list holding the calculated minimum distance between
    each GPS point and the segment''s LineString'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each route candidate is going to be represented by a Python dictionary with
    the following entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`segments`: This is a list of the route segments that make up this route candidate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directed_segment_ids`: This is a list containing the record ID of each directed
    segment used by this route. We use this to quickly discard a new route candidate
    if another route is using the same sequence of road segments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`score`: This is the calculated score for this route candidate. The score is
    calculated as the sum of the GPS distances in each route segment—in other words,
    the lower the score, the more closely the GPS points follow this route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this information in mind, let''s start implementing the map matcher. Create
    a new Python program called `map_matcher.py`, and enter the following into this
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we import the various libraries we''ll need, load the recorded
    GPS data into memory, and open a connection to our database. Next, we want to
    reset the `tally` values for our road segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to start processing the recorded GPS data. While the paper
    this algorithm is based on uses a sophisticated process of splitting the GPS data
    into trip segments, processing each trip segment and then joining the resulting
    routes together, we are going to use a much simpler approach; we will assume that
    each GPS recording has no gaps in it, but that it might start or finish away from
    a road. To handle this, we trim the start and end coordinates until we reach a
    point within 10 meters of a road.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the end of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are simply processing each GPS track in turn, trimming points from the start
    and end until we find a GPS point which is within 10 meters of a road segment.
    Notice that we''re using a function named `calc_circle_with_radius()` to create
    a Shapely polygon that describes a circle 10 meters around a GPS coordinate, and
    then ask the database to find any road segments within that circle. Let''s go
    ahead and implement that `calc_circle_with_radius()` function; place this at the
    top of your program, immediately after the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the set of relevant GPS points within each recording, we are
    ready to start map matching. The first step is to build an initial set of route
    candidates based on the starting GPS point. We do this by identifying all road
    endpoints within 750 meters of the GPS point, and create a (single-segment) route
    candidate for each road segment leading off from those endpoints. Following Schuessler
    and Axhausen's paper, we ensure that there are at least 25 route candidates, and
    if there are not, we expand the search area by 100 meters and try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we create a single route segment dictionary and a route candidate
    dictionary for each possible route candidate, storing the results in the `route_candidates`
    list. There are two more functions that we need here: one to calculate the distance
    from a given point to the closest point within a given Shapely geometry, and another
    to calculate the score for a given route candidate. Go ahead and add these two
    functions to the top of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an initial set of route candidates, we have to **develop**
    them by adding each successive GPS point to each route candidate, generating new
    route candidates as we reach the end of each road segment. At the same time, we
    **trim** the list of route candidates to stop it from growing too large.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk of our work will be done in a function named `develop_route()`. This
    function will take a route candidate and a GPS point (as well as a few other parameters),
    and return a list of new or updated route candidates to include for processing
    in the next iteration. Let''s write the code which uses this function; add the
    following to the end of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We process each route candidate exactly once, first removing it from the list
    of candidates using `route_candidates.pop(0)`, and then passing the candidate
    to the `develop_route()` function. We then add the new or updated route candidates
    to the end of the `route_candidates` list. By the time our `for i in range(num_routes_to_process)`
    loop has finished, we would have processed each route candidate exactly once,
    either incorporating the GPS point into that route candidate or replacing it with
    a new set of route candidates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start processing the next GPS point, we need to trim the list of
    route candidates. According to Schuessler and Axhausen, a highly effective way
    of doing this is to repeatedly remove the route candidate with the highest score
    until there are no more than 40 remaining candidates. Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you put this code inside the `for next_point in...` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement the `develop_route()` function, let''s finish writing the
    main part of our program. We have now processed all the GPS points, so we can
    check the score for each remaining route candidate and choose the candidate with
    the lowest score (excluding any candidates with fewer than two route segments).
    This is the route candidate most likely to have been taken by the GPS points.
    We then increment the tally for each road segment used by that route. Here is
    the relevant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to implement the `develop_route()` function. This function uses
    the following logic, taken from the paper by Schuessler and Axhausen:'
  prefs: []
  type: TYPE_NORMAL
- en: If the route candidate has only one segment, see whether the GPS point has reached
    the start of that segment's LineString. If this happens, the GPS recording must
    be following the directed road segment in the wrong direction, so we discard the
    route candidate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See whether the GPS point is still within the route candidate's final segment.
    If so, add the GPS point to that final segment, recalculate the candidate's score,
    and return it for further processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the GPS point is beyond the end of the route candidate's final segment, identify
    the endpoint we have reached and create a new route candidate for each directed
    road segment leaving from that endpoint. We check the validity of each of the
    new route candidates, and return the valid candidates for further processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start implementing this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This implements the first two of the steps described earlier. Notice that we
    use a couple of new functions, `point_at_start_of_segment()` and `point_in_route_segment`(),
    to do all the hard work. We'll implement these functions shortly, but first let's
    work through the process of creating a new set of route candidates once the GPS
    point has gone past the end of the last route segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in this process is to identify the current endpoint that we
    have reached. Add the following to the end of your `develop_route()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will build a list of all the directed road segments that leave from
    this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create a new route candidate for each of the possible road segments.
    For each route candidate, we create a single route segment using that directed
    road segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we check the new route's validity using another function, `route_is_valid()`.
    We will also have to implement this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes the `develop_route()` function itself. Let''s now write the
    `point_at_start_of_segment()` function, which determines whether the GPS track
    is running the wrong way along a directed road segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This code is a bit of a kludge, comparing the distance from the current point
    to the road segment's start and endpoints, but it works well enough for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to implement the `point_in_route_segment()` function. We will
    use two separate tests to see whether the point has reached the segment''s endpoint.
    First off, we know we have reached the endpoint if the distance from the GPS point
    to the closest point on the segment''s LineString is equal to the distance from
    the point to the end of that LineString:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the map matching algorithm](img/B04102_6_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the first part of the `point_in_route_segment()` function, which implements
    this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The second test involves comparing the length of the final route segment with
    the length of a LineString built out of the GPS points assigned to that route
    segment. If the GPS LineString is longer than the road segment, then we must have
    reached the end of that segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the GPS point failed both of these tests, then it must still be
    within the current route segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The paper by Schuessler and Axhausen suggests a third test, comparing the direction
    of the GPS track against the direction of the road segment. However, it was not
    clear how this could be implemented where road segments are complex LineStrings
    rather than straight line segments, so we won't use this test in our implementation
    of the map matching algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes the `point_in_route_segment()` function. The last function we
    need to implement is `route_is_valid()`. A route candidate is considered to be
    valid if:'
  prefs: []
  type: TYPE_NORMAL
- en: It is unique; that is, there is no other route candidate with the exact same
    sequence of road segments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Its final road segment does not go back to the start of the previous segment;
    that is, the route doesn't double back on itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The route doesn't include the same directed road segment twice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to calculate uniqueness, the `route_is_valid()` function will need
    not only a list of all the current route candidates, but also a list of the new
    candidates being created by the `develop_route()` function. For this reason, the
    `route_is_valid()` function accepts both the current list of route candidates
    and the list of new candidates being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first part of the implementation of this function, including the
    uniqueness check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code checks that a route does not double back on itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we ensure that the same directed road segment isn''t being used twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If the route passes all three checks, then it is considered to be valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes the implementation of the `route_is_valid()` function, and indeed
    the implementation of the entire `map_matcher.py` program. You should be able
    to run it from the command line and see each GPS recording being processed in
    turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Because there are thousands of points in each GPS recording, the program will
    take a few minutes to process each file. Once it has finished, the `tally` field
    in the `road_segments` table would have been updated to show the number of times
    each road segment was used. You can check this using the Postgres command-line
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, map matching is quite a complex process, but this program actually
    works pretty well. Now that we''ve calculated the tallies, we can write the final
    part of our GPS Heatmap system: the program that displays the heatmap based on
    the calculated tally values.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating the GPS heatmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use Mapnik to generate the heatmap, creating a separate `mapnik.Rule`
    for each unique tally value so that the color used for each road segment varies
    depending on its tally. This program will be called `generate_heatmap.py`; create
    this program and enter the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the libraries we need and defining some constants, we open
    up a connection to the database so that we can calculate the highest tally value
    and the bounds of the calculated heatmap. Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `MIN_TALLY` constant to zoom in on the more popular
    parts of the heatmap. You can change this value if you want; setting it to `1`
    will display every road segment covered by a GPS track, and setting it to a higher
    value will focus in on the most commonly used portions of the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the area of the Earth covered by the heatmap, we can calculate
    the dimensions of the map image. We want to use the specified maximum size, while
    maintaining the aspect ratio of the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initialize the map itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though only some of the road segments would have been used by the GPS
    recordings, we still want to show all the unused road segments as a backdrop for
    the heatmap. To do this, we will create an `unused_roads` layer and corresponding
    Mapnik style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use a `mapnik.PostGIS()` datasource so that the map layer takes
    its data directly from our PostGIS database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define a map layer for the roads which were used (that is,
    the roads which have a `tally` value of `1` or more). This map layer, which we
    will call `used_roads`, will have a separate `mapnik.Rule()` for each unique tally
    value. This allows us to assign a different color to each unique tally value so
    that the color used for each road segment varies according to that segment''s
    tally. To implement this, we will need a function that calculates the `mapnik.Stroke()`
    to use for a given tally value. Here is that function, which you should place
    near the top of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `interpolate()` helper function is used to calculate a color range from
    pale blue to dark blue. We also adjust the width of the displayed road segment
    according to the tally so that more frequently used roads are drawn with a wider
    stroke on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want, you can change the starting and ending colors to make the heatmap
    more colorful. As mentioned earlier, we are just using shades of blue so that
    the heatmap makes sense when printed in black and white.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function implemented, we can add the `used_roads` layer to our map.
    To do this, add the following code to the end of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can render the map, saving the results to an image file on the
    disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this program, you should get a `heatmap.png` file containing
    the generated heatmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating the GPS heatmap](img/B04102_6_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! This program is anything but trivial, and solves a number of
    geospatial problems along the way in producing this image. Of course, you can
    use this program to match your own GPS recordings against a road network, but
    what we have really done is shown how complex geospatial problems can be solved
    one step at a time, using the various techniques described throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the GPS Heatmap system works surprisingly well, it is not perfect. No
    program is ever complete. If you''re inclined, you might want to consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the road-segmentation algorithm more sophisticated to support one-way roads,
    and points where two roads intersect but do not join (for example, on a highway
    overpass).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the route-development process to allow it to capture routes that include
    U-turns and repeated road segments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the raw GPS data and split it into contiguous segments, process each segment
    in turn, and then join the processed segments back together again. This will allow
    the algorithm to work with GPS recordings that include gaps in the recorded data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine the map matching algorithm with a shortest-path calculation to write
    your own turn-by-turn navigation system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at ways to improve the speed of the map matching algorithm. For example,
    if two different route candidates use the same road segment, those two candidates
    should be able to share the calculated distance between a point and that road
    segment. This will avoid having to calculate the same distance twice. There are
    bound to be other ways you could optimize the map matcher so that it runs even
    faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a nice-looking raster basemap image to the generated heatmap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You have finished implementing a suite of programs that use
    a range of geospatial analysis techniques to match recorded GPS data to an existing
    network of roads. In the process of creating the GPS Heatmap system, you have
    learned how to convert existing road data into a network, how to represent a network
    of roads within a database, and how to use this data to implement a sophisticated
    map matching algorithm. This algorithm was then used to calculate a tally of how
    often each road segment was used by the recorded GPS data, and the tallies were
    then used to generate a nice-looking heatmap showing the most commonly used roads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you are not interested in capturing your own GPS data and matching
    it against a map, the techniques we have used in this chapter will give you many
    ideas for your own development efforts. Using a combination of Python, GDAL and
    OGR, Shapely, PyProj, PostGIS and Mapnik, you now have a fantastic arsenal of
    tools for processing, analyzing and displaying geospatial data. To learn more,
    check out the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://gdal.org](http://gdal.org) is the main website for the GDAL and OGR
    libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://trac.osgeo.org/gdal/wiki/GdalOgrInPython](http://trac.osgeo.org/gdal/wiki/GdalOgrInPython)
    describes the overall design of the Python interface to GDAL and OGR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://trac.osgeo.org/gdal/wiki/PythonGotchas](http://trac.osgeo.org/gdal/wiki/PythonGotchas)
    lists a number of issues to be aware of when using GDAL/OGR from Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://pypi.python.org/pypi/Shapely](http://pypi.python.org/pypi/Shapely)
    is the main website for the Shapely library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://toblerity.org/shapely/manual.html](http://toblerity.org/shapely/manual.html)
    is where you can find the Shapely user manual.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://trac.osgeo.org/proj](https://trac.osgeo.org/proj) describes the Proj.4
    cartographic projection library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://jswhit.github.io/pyproj](http://jswhit.github.io/pyproj) is the main
    site for the Python interface to the Proj library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.postgresql.org](http://www.postgresql.org) is the main site for
    the PostgreSQL database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://postgis.net](http://postgis.net) is the site for the PostGIS extension
    to Postgres.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mapnik.org](http://mapnik.org) is the main site for the Mapnik library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, [http://github.com/mapnik/mapnik/wiki](http://github.com/mapnik/mapnik/wiki)
    provides a lot of useful information to help you work with Mapnik.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This particular book is now finished, but I hope I have left you with a greater
    understanding of the tools and techniques you can use for geospatial analysis,
    and how Python can be used as the foundation for your own geospatial development
    efforts. The rest is up to you.
  prefs: []
  type: TYPE_NORMAL
