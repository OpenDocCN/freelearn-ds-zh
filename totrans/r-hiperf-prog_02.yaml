- en: Chapter 2. Profiling – Measuring Code's Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 分析 – 测量代码的性能
- en: The first step to improve the performance of R programs is to identify where
    the performance bottlenecks are occurring. To do this, we **profile** or measure
    the performance of an R program as it runs with respect to various measures such
    as execution time, memory utilization, CPU utilization, and disk I/O. This gives
    us a good idea of how the program and its parts perform, so that we can tackle
    the biggest bottlenecks first. This chapter will show you how to use a few simple
    tools to measure the performance of R programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 提高R程序性能的第一步是确定性能瓶颈发生的位置。为此，我们**分析**或测量R程序在运行时的性能，相对于各种指标，如执行时间、内存利用率、CPU利用率和磁盘I/O。这让我们对程序及其各部分的表现有一个很好的了解，因此我们可以首先解决最大的瓶颈。本章将向您展示如何使用一些简单的工具来测量R程序的性能。
- en: The 80/20 rule is applied here. 80 percent of the possible performance improvements
    can usually be achieved by tackling 20 percent of the largest performance problems.
    We will look at how to determine which problems to solve first in order to get
    maximum improvement in the least amount of time and effort.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里应用了80/20法则。通常，通过解决20%的最大性能问题，可以实现80%的可能性能提升。我们将探讨如何确定先解决哪些问题，以便在最少的时间和精力下获得最大的改进。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Measuring the total execution time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量总执行时间
- en: Profiling the execution time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析执行时间
- en: Profiling the memory utilization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析内存利用率
- en: Monitoring memory utilization, CPU utilization, and disk I/O using OS tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作系统工具监控内存利用率、CPU 利用率和磁盘 I/O
- en: Identifying and resolving bottlenecks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和解决瓶颈
- en: Measuring total execution time
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量总执行时间
- en: When people say that their program is not performing well, they are often referring
    to the **execution time** or the time it takes to complete the execution of the
    program. Execution time is probably the most important performance measure in
    many contexts as it is has a direct impact on people and processes. A shorter
    execution time means the R programmer can perform his or her analysis more quickly
    to derive insights faster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们说他们的程序表现不佳时，他们通常指的是**执行时间**或程序完成执行所需的时间。在许多情况下，执行时间可能是最重要的性能指标，因为它对人和过程有直接影响。较短的执行时间意味着R程序员可以更快地完成他的或她的分析，从而更快地得出见解。
- en: 'It turns out that execution time is also the easiest performance characteristic
    that can be measured accurately and in detail (though not always the easiest to
    solve). Therefore, we will start learning about the way to profile an R code by
    learning to measure the execution time of R programs. We will learn three different
    tools to do this: `system.time()`, `benchmark()`, and `microbenchmark()`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，执行时间也是可以准确且详细测量的最易测量的性能特征（尽管不一定最容易解决）。因此，我们将通过学习如何测量R程序的执行时间来学习如何分析R代码。我们将学习三种不同的工具来完成这项任务：`system.time()`、`benchmark()`
    和 `microbenchmark()`。
- en: Measuring execution time with system.time()
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 system.time() 测量执行时间
- en: The first profiling tool we will learn about is `system.time()`. It is a very
    useful tool that we can use to measure the execution time of any R expression.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要了解的第一个分析工具是 `system.time()`。这是一个非常有用的工具，我们可以用它来测量任何R表达式的执行时间。
- en: 'Say we want to find out how long it takes to generate 100 million uniform random
    variables. Take a look at the following statement and the output when it is run
    in the R console:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道生成1000万个均匀随机变量需要多长时间。看看以下语句及其在R控制台运行时的输出：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `runif(1e8)` expression generates 100 million random values between 0 and
    1\. In order to measure how long it takes to run this command, we simply pass
    this expression to `system.time()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`runif(1e8)` 表达式生成0到1之间的1000万个随机值。为了测量运行此命令所需的时间，我们只需将此表达式传递给 `system.time()`。'
- en: 'The output contains three elements, all measured in seconds:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包含三个元素，所有元素均以秒为单位：
- en: '**User time**: This element is the CPU time charged for the execution of user
    instructions of the given expression, for example, looping through an array. It
    does not include CPU time used by other processes (for example, if the computer
    happens to be running a virus scan in the background, the CPU time taken by it
    is not counted).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户时间**：此元素是指给定表达式执行用户指令所花费的CPU时间，例如，遍历一个数组。它不包括其他进程使用的CPU时间（例如，如果计算机在后台运行病毒扫描，它所消耗的CPU时间不计入）。'
- en: '**System time**: System time is the CPU time charged for the execution of system
    instructions on behalf of the given expression, for example, opening and closing
    files, or allocating and freeing memory. This does not include CPU time used by
    other processes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统时间**：系统时间是指为给定表达式执行系统指令所收取的CPU时间，例如，打开和关闭文件，或分配和释放内存。这不包括其他进程使用的CPU时间。'
- en: '**Elapsed time**: Elapsed time is the total clock time taken to execute the
    given expression. It includes the time that the CPU has spent on other processes
    and time spent in waiting (for example, waiting for a file to be opened for reading).
    Sometimes, elapsed time is longer than the sum of user time and system time because
    the CPU is multitasking on other processes, or it has to wait for resources such
    as files and network connections to be available. At other times, elapsed time
    is shorter than the sum of user time and system time. This can happen when multiple
    threads or CPUs are used to execute the expression. For example, a task that takes
    10 seconds of user time can be completed in 5 seconds if there are two CPUs sharing
    the load.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耗时**：耗时是指执行给定表达式的总时钟时间。它包括CPU在处理其他进程上花费的时间以及等待时间（例如，等待文件被打开以供读取）。有时，耗时可能长于用户时间和系统时间的总和，因为CPU正在处理其他进程的多任务，或者它必须等待资源（如文件和网络连接）可用。在其他时候，耗时可能短于用户时间和系统时间的总和。这可能会发生在使用多个线程或CPU执行表达式时。例如，一个需要10秒用户时间的任务，如果有两个CPU分担负载，可以在5秒内完成。'
- en: Most of the time, we are interested in the total elapsed time to execute the
    given expression. When the expression is executed on a single thread (the default
    for R), the elapsed time is usually very close to the sum of the user time and
    system time. If that is not the case, either the expression has spent time waiting
    for resources to be available, or there were many other processes on the system
    competing for the CPU's time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们感兴趣的是执行给定表达式的总耗时。当表达式在单个线程上执行（R的默认设置）时，耗时通常非常接近用户时间和系统时间的总和。如果不是这种情况，则表达式可能花费时间等待资源可用，或者系统上存在许多其他进程正在竞争CPU时间。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is best to shut down any unnecessary programs and processes on the system
    before running `system.time()` in order to reduce the competition for the CPU's
    time and to get an accurate measurement. Of course, the antivirus software or
    any other critical system software should not be turned off.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `system.time()` 之前，最好关闭系统上所有不必要的程序和进程，以减少对CPU时间的竞争，并获得准确的测量结果。当然，不应关闭防病毒软件或其他任何关键系统软件。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `system.time()` declaration actually returns a vector with five elements
    but its `print()` function displays only the first three. To see all the five
    elements, we can call `print(unclass(system.time(expr)))`. The other two elements
    are the system and user times for the execution of any child processes spawned
    by `expr`. On Windows machines, these are not available and will always be given
    as `NA`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`system.time()` 声明实际上返回一个包含五个元素的向量，但它的 `print()` 函数只显示前三个。要查看所有五个元素，我们可以调用
    `print(unclass(system.time(expr)))`。其他两个元素是 `expr` 所产生的任何子进程的执行的系统时间和用户时间。在Windows机器上，这些不可用，始终会显示为
    `NA`。'
- en: 'This is what happens when we run `system.time()` a few more times with the
    same expression:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们多次运行 `system.time()` 并使用相同表达式时发生的情况：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By running `system.time()` repeatedly, we get slightly different results each
    time because R's overheads, OS caching mechanisms, other running processes, and
    many other factors might have a slight impact on the execution time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重复运行 `system.time()`，我们每次都会得到略微不同的结果，因为R的开销、操作系统缓存机制、其他正在运行的进程以及许多其他因素可能会对执行时间产生轻微影响。
- en: Repeating time measurements with rbenchmark
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 rbenchmark 重复时间测量
- en: It is sometimes helpful to run the same expression multiple times and get the
    average execution time, or even the distribution of execution times over multiple
    runs. The `rbenchmark` CRAN package lets us do this easily.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时多次运行相同的表达式并获取平均执行时间，甚至获取多次运行中执行时间的分布，这很有帮助。`rbenchmark` CRAN软件包让我们可以轻松地做到这一点。
- en: 'First, install and load the `rbenchmark` package:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装并加载 `rbenchmark` 软件包：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, use `benchmark()` to run the same random number generation task 10 times,
    by specifying `replications=10`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `benchmark()` 运行相同的随机数生成任务10次，通过指定 `replications=10`：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The results show the total elapsed system and user time taken to generate 100
    million uniform random variables over 10 repetitions. We can find the mean times
    taken per repetition using `within()` to divide the time measurements by the number
    of repetitions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了在 10 次重复中生成 1 亿个均匀随机变量所花费的总系统时间和用户时间。我们可以使用 `within()` 来将时间测量值除以重复次数，从而找到每次重复的平均时间：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What if we want to know the execution times for each repetition, or the distribution
    of execution times over the repetitions? We can pass a vector instead of a single
    number as the `replications` parameter. For each element of this vector, `benchmark()`
    will execute the given expression the specified number of times. So we can get
    10 samples of the execution of the random number generation once, as shown in
    the following code. In addition to the elapsed user and system time, `benchmark()`
    returns an additional column, `relative`, which indicates how each repetition''s
    elapsed time is compared with the fastest one. For example, the first repetition
    took 1.011 times as long as the fastest repetition (the fourth one), or 1.1 percent
    longer to run:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道每次重复的执行时间，或者执行时间在重复中的分布情况呢？我们可以将一个向量而不是单个数字作为 `replications` 参数传递。对于这个向量的每个元素，`benchmark()`
    将执行指定的表达式。因此，我们可以得到随机数生成执行一次的 10 个样本，如下面的代码所示。除了用户和系统时间外，`benchmark()` 还返回一个额外的列，`relative`，它表示每次重复的经过时间与最快的一次相比如何。例如，第一次重复花费了最快重复（第四次）1.011
    倍的时间，或者运行时间长了 1.1%：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Measuring distribution of execution time with microbenchmark
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 microbenchmark 测量执行时间的分布
- en: The CRAN package `microbenchmark` provides yet another way to measure the execution
    time of an R expression. Though its `microbenchmark()` function only measures
    the elapsed time and not the user time or system time, it gives an idea of how
    the execution times across repeated runs are distributed. It also automatically
    corrects for the overheads related to the execution of the timing tests. The `microbenchmark()`
    function is very handy to measure short running tasks over many repetitions provided
    you do not need to measure the user or system times. We will use this tool many
    times throughout this book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CRAN 包 `microbenchmark` 提供了另一种测量 R 表达式执行时间的方法。尽管它的 `microbenchmark()` 函数只测量经过时间，而不是用户时间或系统时间，但它可以给出重复运行中执行时间分布的概览。它还自动纠正了与执行时间测试相关的开销。如果你不需要测量用户或系统时间，`microbenchmark()`
    函数非常方便，可以用来测量多次重复的短运行任务。我们将在本书中多次使用这个工具。
- en: 'Install and load the `microbenchmark` package:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并加载 `microbenchmark` 包：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, run the same random number generation task 10 times using `microbenchmark()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `microbenchmark()` 运行相同的随机数生成任务 10 次：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The statistics shows the minimum, lower quartile, median, upper quartile, and
    maximum values of the elapsed time over 10 repetitions. This gives us an idea
    of the distribution of the elapsed times over different repetitions of the same
    expression.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 统计数据显示了 10 次重复中经过时间的最小值、下四分位数、中位数、上四分位数和最大值。这让我们对相同表达式的不同重复中的经过时间分布有了概念。
- en: Profiling the execution time
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析执行时间
- en: So far, we have seen how to measure the execution time of a whole R expression.
    What about a more complex expression with multiple parts such as calls to other
    functions? Is there a way to dig deeper and profile the execution time of each
    of the parts that make up the expression? R comes with the profiling tool `Rprof()`
    that allows us to do just that. Let's see how it works.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何测量整个 R 表达式的执行时间。对于包含对其他函数调用等多个部分的更复杂表达式呢？是否有方法可以深入挖掘并分析构成表达式的每个部分的执行时间？R
    内置了 `Rprof()` 分析工具，允许我们做到这一点。让我们看看它是如何工作的。
- en: Profiling a function with Rprof()
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Rprof() 分析函数
- en: 'In this example, we write the following `sampvar()` function to calculate the
    unbiased sample variance of a numeric vector. This is obviously not the best way
    to write this function (in fact R provides the `var()` function to do this), but
    it serves to illustrate how code profiling works:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们编写以下 `sampvar()` 函数来计算数值向量的无偏样本方差。这显然不是编写此函数的最佳方式（实际上 R 提供了 `var()`
    函数来完成此操作），但它有助于说明代码分析是如何工作的：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Within `sampvar()`, we define two utility functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sampvar()` 函数中，我们定义了两个实用函数：
- en: '`my.sum()`: This computes the sum of a vector by looping over the elements
    of the vector.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my.sum()`：通过遍历向量的元素来计算向量的和。'
- en: '`sq.var()`: This computes the sum of the squared deviations of a vector from
    a given mean, by looping over the elements of the vector.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sq.var()`：通过遍历向量的元素，计算向量与给定均值平方偏差的总和。'
- en: The `sampvar()` function first computes the sample mean, then the sum of squared
    deviations from that mean, and then the sample variance by dividing that sum by
    *n-1*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampvar()` 函数首先计算样本均值，然后计算从该均值到平方偏差的总和，最后通过除以 *n-1* 来计算样本方差。'
- en: 'We can profile the `sampvar()` function as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样分析 `sampvar()` 函数：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is how the code works:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作方式：
- en: The `runif(1e7)` expression generates a random sample of 10 million numbers.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`runif(1e7)` 表达式生成一个包含 1000 万个随机数的随机样本。'
- en: The `Rprof("Rprof.out")` expression tells R to begin profiling. `Rprof.out`
    is the name of a file in which the profiling data is stored. It will be stored
    in R's current working directory unless another file path is specified.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Rprof("Rprof.out")` 表达式告诉 R 开始分析。`Rprof.out` 是一个文件的名称，其中存储了分析数据。除非指定了另一个文件路径，否则它将存储在
    R 的当前工作目录中。'
- en: The `sampvar(x)` expression calls the function we just created.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sampvar(x)` 表达式调用我们刚刚创建的函数。'
- en: The `Rprof(NULL)` expression tells R to stop profiling. Otherwise, it will continue
    to profile other R statements that we run but do not intend to profile.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Rprof(NULL)` 表达式告诉 R 停止分析。否则，它将继续分析我们运行的其他 R 语句，但这些语句我们并不打算分析。'
- en: The `summaryRprof("Rprof.out")` expression prints the results of the profiling.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`summaryRprof("Rprof.out")` 表达式打印了分析结果。'
- en: The profiling results
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析结果
- en: 'The results are broken down into a few measures:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 结果被分解为几个度量：
- en: The `self.time` and `self.pct` columns represent the elapsed time for each function,
    excluding the elapsed time of other functions that are called by the function.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.time` 和 `self.pct` 列表示每个函数的耗时，不包括被函数调用的其他函数的耗时。'
- en: The `total.time` and `total.pct` columns represent the total elapsed time for
    each function including the time spent inside function calls.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total.time` 和 `total.pct` 列表示每个函数的总耗时，包括函数调用内部花费的时间。'
- en: 'From the profiling data, we get some interesting observations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从分析数据中，我们得到一些有趣的观察：
- en: The `sampvar()` function's `self.time` is negligible (reported as zero), indicating
    that almost all the time taken to run `sampvar` is contributed by the functions
    that it calls.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sampvar()` 函数的 `self.time` 可以忽略不计（报告为零），这表明运行 `sampvar` 所花费的大部分时间是由它调用的函数贡献的。'
- en: While `sampvar()` spent a total of 7.52 seconds, 5.28 seconds of this time was
    contributed by `sq.var()`, and 2.24 seconds by `my.sum()` (see `total.time` of
    `sq.var()` and `my.sum()`).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 `sampvar()` 总共花费了 7.52 秒，但其中 5.28 秒是由 `sq.var()` 贡献的，2.24 秒是由 `my.sum()`
    贡献的（参见 `sq.var()` 和 `my.sum()` 的 `total.time`）。
- en: The `sq.var()` function took the largest chunk of time (70.21 percent) to get
    executed and looks like a good place to start improving the performance.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sq.var()` 函数执行所需时间最长（70.21%），看起来是一个开始提高性能的好地方。'
- en: The R operators `-`, `+`, and `*` were extremely quick, taking not more than
    a total of 0.46 seconds each, even though they were executed millions of times.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 操作符 `-`、`+` 和 `*` 非常快，每个操作的总耗时不超过 0.46 秒，尽管它们被执行了数百万次。
- en: '`Rprof()` works by observing R''s call stack as the R expression is running,
    and taking a snapshot of the call stack at fixed intervals (every 0.02 seconds
    by default) to see which function is currently executing. From these snapshots,
    `summaryRprof()` can compute how much time was spent in each function.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rprof()` 通过观察 R 表达式运行时的调用栈来工作，并在固定的时间间隔（默认为每 0.02 秒）对调用栈进行快照，以查看当前正在执行哪个函数。从这些快照中，`summaryRprof()`
    可以计算出每个函数花费了多少时间。'
- en: 'For a more intuitive view of the profiling data, we can use the `proftools`
    package. We will also need to install the `graph` and `Rgraphviz` packages from
    the Bioconductor repository:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更直观地查看分析数据，我们可以使用 `proftools` 包。我们还需要从 Bioconductor 仓库安装 `graph` 和 `Rgraphviz`
    包：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `plotProfileCallGraph()` function generates an intuitive visual plot of
    the profile data. We use the `google.style` template which shows functions with
    longer `self.time` in bigger boxes. We also specify `score="total"` to color the
    boxes according to `total.time`. The following figure shows the output of the
    same profiling data:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotProfileCallGraph()` 函数生成一个直观的视觉分析图。我们使用 `google.style` 模板，该模板使用更大的框来显示
    `self.time` 较长的函数。我们还指定 `score="total"` 以根据 `total.time` 为框着色。以下图显示了相同分析数据的输出：'
- en: '![The profiling results](img/9263OS_02_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![分析结果](img/9263OS_02_01.jpg)'
- en: Profiling data for sampvar() rendered by plotProfileCallGrah()
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `plotProfileCallGrah()` 生成的 `sampvar()` 的分析数据
- en: We can see from `sampvar()` that it has the longest `total.time` of 100 percent.
    This is expected since it is the function that is being profiled. The next longest-running
    function is `sq.var()`, which accounts for 70.21 percent of the elapsed time.
    `sq.var()` also happens to have the longest `self.time`, which can be seen from
    the size of its box. Thus, `sq.var()` seems like a good candidate for the first
    step in addressing performance problems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `sampvar()` 我们可以看到，它有最长的 `total.time` 为 100%。这是预期的，因为它是被分析的功能。运行时间第二长的函数是
    `sq.var()`，占用了 70.21% 的运行时间。`sq.var()` 也恰好有最长的 `self.time`，这可以从其框的大小中看出。因此，`sq.var()`
    似乎是在解决性能问题时的一个很好的候选者。
- en: The `Rprof()` function is a useful tool to understand the performance of different
    parts of R programs and quickly spot bottlenecks that we can address to improve
    the overall performance of our R code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rprof()` 函数是一个有用的工具，可以帮助我们了解 R 程序不同部分的表现，并快速找到我们可以解决以改进 R 代码整体性能的瓶颈。'
- en: Profiling memory utilization
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析内存利用率
- en: Next, let's consider how to profile the memory utilization of R code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑如何分析 R 代码的内存使用情况。
- en: 'One approach is to use `Rprof()` by setting the `memory.profiling` argument
    and the corresponding `memory` argument to `summaryRprof()`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用 `Rprof()`，通过设置 `memory.profiling` 参数和相应的 `memory` 参数到 `summaryRprof()`：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output now shows an additional column `mem.total` reporting the memory utilization
    of each function. For this example, it seems that it took 1,656 MB of memory to
    run `sampvar()`! This seems exceptionally high for computations on a numeric vector
    with 10 million elements, which would measure only 76.3 MB in the memory (you
    can check this by running `print(object.size(x), units="auto")`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出显示了一个额外的列 `mem.total`，报告每个函数的内存利用率。对于这个例子，似乎运行 `sampvar()` 需要 1,656 MB
    的内存！这对于对包含 1000 万个元素的数值向量进行计算来说似乎异常高，这将在内存中测量为只有 76.3 MB（你可以通过运行 `print(object.size(x),
    units="auto")` 来检查这一点）。
- en: Unfortunately, `mem.total` is a misleading measure because `Rprof()` attributes
    the memory usage to the function that happens to be running when it takes a snapshot,
    but the memory could have been used by other functions and not have been released
    yet. Furthermore, R's garbage collector regularly releases unused memory to the
    operating system, so the actual memory being used at any given time might be vastly
    different from that reported by `Rprof()`. In other words, `Rprof()` gives an
    indication of the total amount of memory allocated while running an R code, but
    does not take into account the memory freed by the garbage collector.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`mem.total` 是一个误导性的度量，因为 `Rprof()` 将内存使用量归因于在它进行快照时恰好正在运行的函数，但内存可能已经被其他函数使用且尚未释放。此外，R
    的垃圾回收器定期将未使用的内存释放给操作系统，因此任何给定时间实际使用的内存可能与 `Rprof()` 报告的内存大相径庭。换句话说，`Rprof()` 提供了在运行
    R 代码时分配的总内存量的指示，但没有考虑到垃圾回收器释放的内存。
- en: 'To see how garbage collection affects memory utilization, we can run the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看垃圾回收如何影响内存利用率，我们可以运行以下代码：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `gcinfo(TRUE)` expression tells R to inform us every time the garbage collector
    releases memory. On our machine, the garbage collector was activated 272 times
    while running `sampvar()`! Although `Rprof()` reported that 1.7 GB of the memory
    was allocated in total, the garbage collector was hard at work to release unused
    memory so that R's total memory consumption stayed manageable at around 113.9
    MB (*31.1 MB + 82.8 MB*).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcinfo(TRUE)` 表达式告诉 R 在垃圾回收器释放内存时通知我们。在我们的机器上，垃圾回收器在运行 `sampvar()` 时被激活了 272
    次！尽管 `Rprof()` 报告说总共分配了 1.7 GB 的内存，但垃圾回收器一直在努力释放未使用的内存，以便 R 的总内存消耗保持在可管理的 113.9
    MB 左右（*31.1 MB + 82.8 MB*）。'
- en: Because `Rprof()` measures the cumulative allocated memory without accounting
    for garbage collection, it is not suited for determining whether an R program
    will exceed the available memory on a system. `gcinfo()` provides a clearer picture,
    albeit still an approximate one, by providing a snapshot of the memory consumption
    at every garbage collection interval.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Rprof()` 测量的是累积分配的内存，而不考虑垃圾回收，因此它不适合确定 R 程序是否会超出系统上的可用内存。`gcinfo()` 通过在每次垃圾回收间隔提供内存消耗的快照，提供了一个更清晰的画面，尽管仍然是一个近似值。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `gcinfo()` and `gc()` functions give pretty good estimates of memory utilization
    in this case because our code uses only standard R operations. Some R packages
    use custom memory allocators that `gcinfo()` and `gc()` are not able to track,
    so memory utilization can be underreported.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`gcinfo()`和`gc()`函数给出了相当好的内存利用率估计，因为我们的代码只使用标准的R操作。一些R包使用自定义内存分配器，而`gcinfo()`和`gc()`无法跟踪，因此内存利用率可能会被低估。
- en: Monitoring memory utilization, CPU utilization, and disk I/O using OS tools
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作系统工具监控内存利用率、CPU利用率和磁盘I/O
- en: Unlike execution time, R does not provide any good tools to profile CPU utilization
    and disk I/O. Even the memory profiling tools in R might not provide a complete
    or accurate picture. This is where we turn to OS-provided system monitoring tools
    to keep an eye on the computational resources as we run R programs. They are task
    manager or resource monitor in Windows, activity monitor in Mac OS X, and `top`
    in Linux. When running these tools, look for the processes that represent R (usually
    called `R` or `rsession`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与执行时间不同，R没有提供任何好的工具来分析CPU利用率和磁盘I/O。即使是R中的内存分析工具也可能无法提供完整或准确的图像。这就是我们转向操作系统提供的系统监控工具来监控R程序运行时的计算资源的原因。在Windows中是任务管理器或资源监视器，在Mac
    OS X中是活动监视器，在Linux中是`top`。运行这些工具时，寻找代表R的进程（通常称为`R`或`rsession`）。
- en: 'The information that we get varies depending on the operating system, but here
    are the key measures of R''s resource utilization to keep an eye on:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的信息取决于操作系统，但以下是关注R资源利用率的几个关键指标：
- en: '**% CPU or CPU usage**: The percentage of the system''s CPU time used by R'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% CPU 或 CPU 使用率**：R占用的系统CPU时间的百分比'
- en: '**% memory, resident memory, or working set**: The percentage of the system''s
    physical memory used by R'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% 内存，驻留内存或工作集**：R占用的系统物理内存的百分比'
- en: '**Swap size or page outs**: The size of memory used by R that is stored in
    the operating system''s swapspace'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换空间大小或页面输出**：存储在操作系统交换空间中的R使用的内存大小'
- en: '**Bytes read or written per second**: The rate of data being read or written
    from/to disk by R'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每秒读取或写入的字节数**：R从/向磁盘读取或写入数据的速率'
- en: 'In addition, we might also want to monitor these system-wide resource utilization
    measures:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可能想要监控以下系统级资源利用率指标：
- en: '**% free memory**: The percentage of the system''s physical memory that is
    available for use'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% 可用内存**：系统物理内存中可用于使用的百分比'
- en: '**Swap size or page outs**: The total size of memory that is stored in the
    OS''s swapspace'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换空间大小或页面输出**：存储在操作系统交换空间中的内存总大小'
- en: 'The preceding measures are helpful in troubleshooting R''s performance problems:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前述指标有助于解决R的性能问题：
- en: '**High CPU utilization**: A CPU is likely the main bottleneck of R''s performance.
    Use the profiling techniques in this chapter to identify which parts of the code
    are taking most of the CPU''s time.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高CPU利用率**：CPU很可能是R性能的主要瓶颈。使用本章中介绍的分析技术来识别代码中占用CPU时间最多的部分。'
- en: '**Low CPU utilization, low free system memory with large swap size, and high
    disk I/O**: The system is likely running out of physical memory and is thus swapping
    memory onto the disk. Use the memory management techniques in [Chapters 6](ch06.html
    "Chapter 6. Simple Tweaks to Use Less RAM"), *Simple Tweaks to Use Less RAM*,
    and [Chapter 7](ch07.html "Chapter 7. Processing Large Datasets with Limited RAM"),
    *Processing Large Datasets with Limited RAM*, to reduce the memory required by
    the R program.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低CPU利用率，低可用系统内存，但交换空间大小大，以及高磁盘I/O**：系统可能正在耗尽物理内存，因此将内存交换到磁盘上。使用[第6章](ch06.html
    "第6章。减少RAM使用的简单调整")中介绍的内存管理技术，*减少RAM使用的简单调整*和[第7章](ch07.html "第7章。使用有限RAM处理大型数据集")中介绍的*使用有限RAM处理大型数据集*，以减少R程序所需的内存。'
- en: '**Sufficient free system memory with high disk I/O**: The program writes/reads
    to disk very often. Check for any unnecessary I/O operations and store intermediate
    data in the memory if there is sufficient free memory.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**足够的可用系统内存和高磁盘I/O**：程序非常频繁地写入/读取磁盘。检查是否有不必要的I/O操作，并在有足够可用内存的情况下将中间数据存储在内存中。'
- en: Identifying and resolving bottlenecks
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别和解决瓶颈
- en: Now that we have covered the basic techniques to profile an R code, which performance
    bottlenecks should we try to solve first?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了分析R代码的基本技术，我们应该首先尝试解决哪些性能瓶颈？
- en: As a rule of thumb, we first try to improve the pieces of code that are causing
    the largest performance bottlenecks, whether in terms of execution time, memory
    utilization, or other measures. These can be identified with the profiling techniques
    covered earlier. Then we work our way down the list of the largest bottlenecks
    until the overall performance of the program is good enough.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，我们首先尝试改进导致最大性能瓶颈的代码片段，无论是执行时间、内存利用率还是其他指标。这些可以通过前面提到的分析技术来识别。然后我们逐步解决最大的瓶颈，直到程序的整体性能足够好。
- en: 'As you can recall, the `varsamp()` example that we profiled using `Rprof()`.
    The function with the highest `self.time` was `sq.var()`. How can we make this
    function run faster? We can write it in the form of a vector operation `my.sum((x
    - mu) ^ 2)` rather than looping through each element of `x`. As we will see in
    the next chapter, converting loops to vectorized operations is a good way to speed
    up many R operations. In fact, we can even remove the function altogether since
    the new vector expression fits in one line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所回忆的，我们使用`Rprof()`对`varsamp()`函数进行了性能分析。具有最高`self.time`的函数是`sq.var()`。我们如何使这个函数运行得更快呢？我们可以将其写成向量操作的形式`my.sum((x
    - mu) ^ 2)`，而不是通过遍历`x`的每个元素。正如我们将在下一章中看到的，将循环转换为向量操作是加快许多R操作的好方法。实际上，我们甚至可以完全删除该函数，因为新的向量表达式只需要一行：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This change shaved 2.98 seconds off the elapsed time and 477 MB off the total
    memory allocated while running the function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改动将运行时间减少了2.98秒，并将函数运行时分配的总内存减少了477 MB。
- en: 'Now the `my.sum()` function contributes to a significant 85 percent of the
    total elapsed time. Let''s replace it with the `sum()` function from R, which
    runs much faster:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`my.sum()`函数对总运行时间的贡献达到了显著的85%。让我们用R中的`sum()`函数替换它，该函数运行得更快：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Voila! In two simple steps, we reduced the elapsed time of `sampvar()` from
    7.58 seconds to 0.08 seconds (a 99 percent reduction). Furthermore, the memory
    utilization as reported by `Rprof()` was also reduced from over 1.6 GB to a mere
    76.2 MB (a 95.4 percent reduction). This reduction in memory allocation and garbage
    collection also played a significant part in speeding up our code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！通过两个简单的步骤，我们将`sampvar()`的运行时间从7.58秒减少到0.08秒（减少了99%）。此外，`Rprof()`报告的内存利用率也从超过1.6
    GB减少到仅有76.2 MB（减少了95.4%）。这种内存分配和垃圾回收的减少也在加快我们的代码中发挥了重要作用。
- en: 'Let''s compare how fast our code runs compared to the R function `var()`, which
    is written in C for optimal performance (we will learn in [Chapter 4](ch04.html
    "Chapter 4. Using Compiled Code for Greater Speed"), *Using Compiled Code for
    Greater Speed*):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较我们的代码与R函数`var()`的运行速度，后者是用C编写的以实现最佳性能（我们将在[第4章](ch04.html "第4章。使用编译代码以获得更高的速度")，*使用编译代码以获得更高的速度*）：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With a median elapsed time of 50 milliseconds, our function takes only 36 percent
    more time than the optimized C version that has a median of 37 milliseconds.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数的中位运行时间为50毫秒，比具有中位数为37毫秒的优化C版本多出36%的时间。
- en: The preceding exercise illustrates how code profiling can be used as part of
    a workflow to identify, prioritize, and fix performance issues in R programs.
    The rest of this book will cover techniques that we can use to solve specific
    performance problems.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的练习说明了如何将代码分析作为工作流程的一部分，用于识别、优先排序和修复R程序中的性能问题。本书的其余部分将介绍我们可以用来解决特定性能问题的技术。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to measure the execution time of R expressions
    using `system.time()`, `benchmark()` (from the `rbenchmark` package) and `microbenchmark()`
    (from the `microbenchmark` package). We examined how to profile the execution
    time and memory usage of different parts of an R program using `Rprof()` and `summaryRprof()`
    and to display the results in an intuitive visual form using the `proftools` package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用`system.time()`、`benchmark()`（来自`rbenchmark`包）和`microbenchmark()`（来自`microbenchmark`包）来测量R表达式的执行时间。我们探讨了如何使用`Rprof()`和`summaryRprof()`来分析R程序不同部分的执行时间和内存使用情况，并使用`proftools`包以直观的视觉形式显示结果。
- en: We also saw the role of OS-provided monitoring tools to understand the overall
    performance of R programs and how these system measures can provide clues about
    the performance bottlenecks that our R programs might be facing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了操作系统提供的监控工具在理解R程序整体性能以及这些系统度量如何提供关于我们R程序可能遇到性能瓶颈的线索方面的作用。
- en: Finally, we learned how to apply the profiling techniques in a practical, iterative
    workflow to identify, prioritize and resolve performance related problems in an
    R code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何在实践中应用配置文件技术，通过迭代工作流程来识别、优先排序和解决R代码中与性能相关的问题。
- en: In the next chapter, we will learn some simple tweaks to improve R code so that
    it runs faster.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些简单的调整来提高R代码的运行速度。
