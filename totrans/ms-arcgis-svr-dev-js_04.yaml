- en: Chapter 4. Finding Peace in REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've spent a few chapters discussing and building applications using the ArcGIS
    API for JavaScript. We've used different API tools to communicate with ArcGIS
    Server about its map services. But how does the API communicate with ArcGIS Server?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll focus on ArcGIS Server. We'll look at how it implements
    a REST interface. We'll review the ArcGIS REST API, outlined at [http://resources.arcgis.com/en/help/arcgis-rest-api/#/The_ArcGIS_REST_API/02r300000054000000/](http://resources.arcgis.com/en/help/arcgis-rest-api/#/The_ArcGIS_REST_API/02r300000054000000/).
    This describes the file structure and the format of the data that passes between
    the server and the browser. Finally, we'll extend the application from the previous
    chapter by changing the popup highlighted symbols.
  prefs: []
  type: TYPE_NORMAL
- en: What is REST? REST stands for **Representational State Transfer**. It's a software
    architecture that focuses on the interface between server and client using a hypermedia
    environment. It limits the actions that can be performed between the client and
    the server, but provides enough user information and documentation for the user
    to navigate amongst data and states.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our discussion of ArcGIS Server and REST in this chapter, we''ll cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling REST endpoints and data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hierarchy of ESRI REST Services, as seen through a browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common REST data in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use ArcGIS REST Services and JSON as defined in the REST API Requirements
    for a REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST is a methodology based around web pages. A website presents a state (the
    URL), data transfer (HTML page, CSS, and JavaScript), and a well-documented way
    to navigate between the different states (links). While understanding a website
    to be RESTful is well and good, what makes ArcGIS Server so RESTful?
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for a web service to be considered RESTful, it must meet the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-Server**: The roles of the client and server are clearly defined.
    The client doesn''t care if the server contains one or one million records, and
    the server does not depend on a particular UI for the client. As long as the interface
    between the client and server remains the same, the client and server code can
    be changed independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: The client handles the state of the application, whereas the
    server does not have to keep up with it. The client has all it needs to make a
    request, including the necessary parameters and security tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: Sometimes client applications cache data for faster performance
    because the World Wide Web delivers data asynchronously. The server needs to tell
    the client which requests can be cached and for how long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system**: The server-side application can be placed behind a load
    balancer, a secure system, or a proxy, with no noticeable effect on the client-side
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code on demand (optional)**: The server can provide code for the client to
    run. Examples include Java applets or JavaScript scripts. Not all REST services
    do this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: With a REST service, the server provides a uniform interface
    through which the client can interact with the data. The uniform interface can
    be broken down further into four principles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information requests that include the identification of the resource. This includes
    everything from the data source to the output type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The client has enough information from a request to manipulate or delete data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages from the server contain instructions about how to use them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A state is handled by the client using hypermedia (web pages, query parameters,
    and session states).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look into the ArcGIS Server implementation, you'll see that it meets
    these criteria. Therefore, it's considered RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at a map server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ArcGIS Server provides web access to its map service contents. To access the
    content, you need to know the ArcGIS Server name and the site name. By default,
    ArcGIS Server is reached through port `6080`. It can also be reached through port
    `80` if it has been configured and licensed to deliver web content. REST Service
    endpoints can be reached through your browser with this address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Where `GIS Server Name` refers to the ArcGIS Server machine, and `site name`
    refers to the ArcGIS Server instance which, by default, is `arcgis`, the port
    number is optional if ArcGIS Server has been set up to deliver traffic on port
    `80`. This is the default port for Internet traffic.
  prefs: []
  type: TYPE_NORMAL
- en: When there are multiple GIS Servers, often handling a large load of traffic
    or complicated services, a web adaptor may be installed. The web adaptor routes
    traffic to multiple ArcGIS Servers, based on service requests, load balancing,
    and other related issues. The web adaptor also provides a layer of security, whereby
    ArcGIS Server machine names are not directly exposed to the outside world. To
    access the REST service through the web adaptor, use the following URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As long as ArcGIS Server is accessible from our computer, we can access information
    in the web browser. By default, the service data is presented as HTML. From there
    we can see the properties of the REST service, and follow links to other services
    and actions on the server. This lets developers review and test map services,
    independent of any application they create.
  prefs: []
  type: TYPE_NORMAL
- en: ArcGIS REST services provide a great way to view and interact with service data
    using HTML, which is good for presentation. Almost all of our applications will
    interact with the REST service through server requests. ArcGIS Server can therefore
    communicate through REST using another data format called JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation (JSON)** provides a structured data format for
    loosely defined data structures. A JSON object is built with other JSON objects,
    including strings, numbers, other objects, and arrays. Any data is allowed, as
    long as everything is self-contained and there is no sloppy formatting with missing
    brackets and braces.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to test for valid JSON. Visit [http://jsonlint.com](http://jsonlint.com),
    where you can copy and paste your JSON and submit it for validation. It will point
    out missing or broken formatting issues, as well as how to resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: As you read through the examples in this book you'll see that JSON isn't always
    formatted in the same way, especially with JSON object key fields (or property
    names). JSON validators require that all string items are enclosed in quotes.
    Single or double quotes will work, as long as you put the same marks at the end
    of a string as those at the beginning. This includes both JSON object key fields.
    JavaScript interpreters in a browser are more flexible, key fields do not have
    to be enclosed by quotes. It all depends on how you're testing the JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Before JSON was developed, data was passed from server to client in a format
    called **Extensible Markup Language (XML)**. XML is a document markup language
    that shows data in a format both humans and machines can read. The XML format
    can be read and parsed by a number of programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main reasons why JSON is the preferred data format for web applications
    when compared to XML. First, JSON data can be consumed immediately by JavaScript
    applications. XML requires extra steps to parse the data into a usable object.
    Secondly, JSON data takes up less space. Let''s explore that by comparing two
    snippets of data. The following snippet is written in XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here''s the same data written in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The same data in JSON counts 62 characters less than that in XML. If we take
    out the line breaks and extra spaces, or **minimize** the data, the JSON data
    is 93 characters shorter than the minimized XML. With bandwidth at a premium,
    especially for mobile browsers, you can see why JSON is the preferred format for
    data transmission.
  prefs: []
  type: TYPE_NORMAL
- en: JSON and PJSON formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON comes in two flavors. The default JSON is minimized, with all the extra
    spaces and line returns removed. Pretty JSON, or PJSON for short, contains line
    breaks and spacing to show the structure and hierarchy of the data. The previous
    Mount Everest example shows what PJSON looks like. While PJSON is easier to read,
    and therefore easier to troubleshoot for errors, the minimized JSON is much smaller.
    In the example, the PJSON has 397 characters, while the minimized version has
    only 277 characters, a 30 percent decrease in size.
  prefs: []
  type: TYPE_NORMAL
- en: 'When viewing ArcGIS REST service data, you can change the format of the data
    by adding an `f` query parameter to the REST Service URL. It should look like
    the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can set `f=JSON` to receive the raw JSON data, or `f=PJSON` to receive
    the human-readable pretty JSON (or padded JSON, if you prefer). Some browsers,
    such as Google Chrome and Mozilla Firefox, offer third party extensions that reformat
    raw JSON data into PJSON without making the request.
  prefs: []
  type: TYPE_NORMAL
- en: Service levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by viewing the sample ArcGIS Server services at [http://sampleserver6.arcgisonline.com/arcgis/rest/services](http://sampleserver6.arcgisonline.com/arcgis/rest/services).
    When we request the page as HTML, we notice a few things. First, the version of
    ArcGIS Server is shown (version 10.21 at the time of writing). The version number
    is important because many features and bits of information may not be present
    in older versions. Secondly, we see a list of links pointing to folders. These
    are map services grouped in any way the publisher chooses. We also see a list
    of map service links below the folder lists. Finally, at the bottom of the page,
    we see supported interfaces. In this site, we can see the REST interface that
    we''re familiar with. The other interfaces will not be covered in this book. Here''s
    a picture of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service levels](img/6459OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we change the format of the REST Service request in our browser to Pretty
    JSON, by adding `?f=pjson` to the end of the URL, we can see roughly how the ArcGIS
    JavaScript API would see this location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service levels](img/6459OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the JSON object returned includes the numeric `currentVersion`, an array
    of folder names, and an array of services objects. The service JSON objects contain
    a name and a type attribute, which tells you what kind of service you''re dealing
    with, and gives you the components you need to construct the URL link to those
    services. This format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we follow the link to our census map service, we can see more details.
  prefs: []
  type: TYPE_NORMAL
- en: Map services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A map service gives applications access to map data published with ArcGIS Server.
    It contains information about the map layout, format, contents, and other items
    necessary to properly render the map with the various ArcGIS API''s. The map service
    URL is formatted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you navigate to a map service using your browser, you're presented with
    a lot of information about the map service. The HTML provides links to view the
    data in different applications, including the ArcGIS JavaScript API and ArcMap.
    Google Earth is also available if the map service is published to serve data in
    that format. The HTML for the map service also provides a lot of metadata to help
    you understand what it's offering. These properties include the **Description**,
    **Service Description**, **Copyright Text**, and the **Document Info**.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the map service properties can be difficult to understand without some
    context. We'll review some of the important ones. Remember that properties in
    this list show how they are listed in the HTML. When shown in JSON, these items
    are camel-cased (first letter lowercase, no spaces, and capital letters to start
    each new word after the first).
  prefs: []
  type: TYPE_NORMAL
- en: '**Spatial reference**: How the layout of the map compares with the real world,
    which we''ll discuss a little later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single fused map cache**: Lets you know whether the map data has been cached,
    or if it is dynamic. You can load the layer by using either `ArcGISTiledMapServiceLayer`
    or `ArcGISDynamicMapServiceLayer`, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initial extent**/**full extent**: When you first load the map with the ArcGIS
    JavaScript API, the initial extent describes the bounding box of the area you
    see the first time. The full extent is the expected full area of the map service,
    which may be much wider than all the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported image format types**: When ArcGIS Server draws the map layers as
    tiles, these are the image formats that can be returned. `PNG32` is recommended
    if your data has a lot of semi-transparencies and colors, while PNG8 works well
    with very simple symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports dynamic layers**: If true, the developer can change the symbology
    and layer definitions when displaying the map service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max record count**: When submitting a query, identify or some other search,
    this is the maximum number of results that can be returned by the map service.
    This information can only be changed by server-side changes to the map service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the Map Service HTML provides links to a number of related REST Service
    endpoints. Most of these links extend the existing URL and provide more information
    about the map service. As a bare minimum, the following should be present:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Legend**: Displays the symbology of the layers in the map service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Export map**: This feature lets you download an image showing an area of
    the map that fits within a specific bounding box. You can specify parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify**: This lets you identify features within all layers of a map service,
    based on the geometry passed in. This functionality is used by `IdentifyTask`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find**: This lets the user search for features based on the presence of a
    line of text passed to it. This functionality is implemented by `FindTask`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map service layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When exploring the layers of a map service, it helps to know what to look for.
    Map services list the basic contents of their layers within an array of objects
    in their layer properties.
  prefs: []
  type: TYPE_NORMAL
- en: All layer objects have the same format, with the same properties. Each layer
    object has a numeric `id` property that refers to the layer's zero-based position
    in the list. Layer objects also have a `name` property that comes from how the
    layer was named in the map service. These layers also have a `minScale` and `maxScale`
    property, showing the range within which the layer is visible (with a 0 value
    meaning there is no `minScale` or `maxScale` limitation). When determining visibility,
    the layer object also contains a Boolean `defaultVisibility` property that describes
    whether the layer is initially visible when the map service loads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Map service layer objects also contain information about their layer hierarchy.
    Each map layer object contains a `parentLayerId` and a `subLayerIds` property.
    The `parentLayerId` is a number that refers to the index of the parent group layer
    for the specific layer. A parent layer `id` of `-1` means the layer in question
    has no parent layer. The `subLayerIds` are an integer array of the indexes where
    you can find the `sublayers` for the particular parent layer. If a layer has no
    sublayers, the `subLayerIds` will be a `null` value, instead of an empty list.
    You can see an example of map service layers in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the map service has three layers. The `Pet Lovers`
    layer is actually a `parentLayer`, and corresponds to a group layer assigned in
    an ArcMap `.mxd` file. There are two layers in `parentLayer`: `Dog Lovers` and
    `Cat Lovers`. All layers are visible by default, and the layers do not appear
    until the map is at a scale lower than 1:16,000, according to `minScale`. The
    `maxScale` property is set to zero, meaning there is no maximum scale where the
    layer turns off again.'
  prefs: []
  type: TYPE_NORMAL
- en: Feature services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Feature services are similar to map services, but provide more functionality.
    Their content can be edited, if the database and map settings support those operations.
    They display their feature symbology without the need of a legend service. Their
    symbology can also be modified client-side, by changing their renderer. The URL
    of a feature service is similar to a map service, except that it ends with `FeatureServer`,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The feature service differs first and foremost in its capabilities. Apart from
    allowing you to query data, feature service capabilities allow the user to create,
    update, and/or delete records. Those familiar with CRUD operations will recognize
    those words as the C, U, and D in CRUD (the R stands for read, which is what happens
    when you query for results). The capabilities include editing if create, update,
    or delete are allowed. Also, if the feature service supports file attachments
    to data, such as photos, the capabilities will include the word "upload".
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other feature service properties that may help you learn more about
    the service. They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Has Versioned Data**: Lets you know that the geodatabase has versioning enabled,
    which allows edits to be undone/redone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports Disconnected Editing**: Data can be checked out and edited in an
    environment without an Internet connection. When the application connects to the
    Internet again, the data can be checked back in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sync Enabled**: If this is true, feature data can be synced between the geodatabase
    the data comes from, and another geodatabase (a topic for another book).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow Geometry Updates**: If editing is allowed, this lets the API know if
    the feature geometries can be edited or not. Due to certain permissions, the application
    might only allow for updates to the feature attributes, while the geometries remain
    unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable Z Defaults**: If the data contains height data (`z`), default values
    are assigned in the map service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layer level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Map services and feature services are made up of layers. These layers group
    together geographic features with the same geometry type and the same sets of
    properties. Layers are referred to by their numerical index in the list. The layer
    index starts at `0` for the bottom layer, and goes up one for each additional
    layer. The URL might look something like this for the first layer in a map service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Map layers offer a whole host of data to help you understand what you're viewing.
    The layer's `name` property comes either from its name in the `.mxd` file, or
    from the layer in the Table of contents, if the file is unsaved. The map layer
    also provides a description, and copyright data. The display field property tells
    the map service what to use when labeling features, if labeling is turned on.
  prefs: []
  type: TYPE_NORMAL
- en: Map layers also provide important data that you can use in your application.
    The `type` parameter tells you the geometry of the layer, whether it's a point,
    line, or polygon. Default visibility lets you know if the layer was originally
    visible or not when the map service began. Minimum scale and maximum scale affect
    visibility, depending on your zoom level. The map service also lets you know if
    the layers have attachments, can be modified with different renderers, and how
    many results can be returned from a query.
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A map service layer provides information about its attribute by means of the
    field property. The field property is an array of field objects with similar formats.
    All fields have a type, a name, and an alias attribute. The type refers to the
    data type of the field, whether it's a string or an integer, or something else.
    A current list of supported types can be found at [http://resources.arcgis.com/en/help/arcgis-rest-api/#/field/02r300000051000000/](http://resources.arcgis.com/en/help/arcgis-rest-api/#/field/02r300000051000000/).
    The name attribute is the field name for the property, as found in the geodatabase.
    Field names don't contain spaces or special characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `alias` field is a string that shows the field `name` for presentation
    purposes. Unlike the `field` name, the `alias` can have spaces or other special
    characters. If no `alias` is assigned in the geodatabase or the map service, the
    `alias` field is the same as the field `name`. For instance, when creating the
    map service with ArcMap, you might have some data for a block with a field name
    `NUMB_HSES`. If you want to show the values for this property in a chart, the
    field name may look rough and a little confusing. You can then add an alias to
    the `NUMB_HSES` field by calling it `Number of Houses`. That `alias` provides
    a much better description for the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Field objects may also have domain attributes assigned to them. Domains are
    limitations on field values imposed at the geodatabase level. Domains are uniquely
    created in the geodatabase, and can be assigned to feature classes and table fields.
    Domains make it easier to input the correct values by restricting what can be
    entered. Instead of allowing users to mistype street names in a report service,
    for instance, you might provide a field with a domain containing all the correctly
    typed street names. The user can then select from the list, rather than have to
    guess how to spell the street name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ArcGIS REST API supports two varieties of domains: ranges and coded values.
    Ranges, as the name implies, set a minimum and maximum numeric value for a feature
    attribute. One example of a range might be an average user rating for restaurants.
    The restaurant might get somewhere between one and five stars, so you wouldn''t
    want a restaurant to accidently get a value of `6` or a value of less than `1`.
    You can see an example of a rating field with that range domain in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A coded value domain provides a list of code and value pairs to use as legitimate
    property values. The coded value list contains items with a name and a code. The
    code is the value stored in the geodatabase. The name is the text representation
    of the coded value. They're useful in that users are forced to select a valid
    value, instead of mistyping a correct value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see a field with a coded value domain. The
    field contains state abbreviations, but the domain allows the user to see entire
    state names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, state names are stored in two letter code form. The
    domain provides a full name reference table with the full names of the states.
    If you were to send queries for features using this field, you would use the code
    values. Querying for all features where `STATE = 'Alaska'` would yield no results,
    while a query where `STATE = 'AK'` may give you results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the code and the value don't have to be of the same type. You can
    have numeric codes for, say, water line part numbers, and coded values to show
    their descriptive names.
  prefs: []
  type: TYPE_NORMAL
- en: Related tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tables with non-geographic data can be published in a map service. These tables
    may provide data related to map features, such as comments on campground locations
    or the sales history of a property. These tables can be searched and queried like
    features. Relationships between map layers and tables can also be published and
    searched.
  prefs: []
  type: TYPE_NORMAL
- en: Layers and tables can be joined, either by using geodatabase relationship classes,
    or ad-hoc relationship assignments in ArcMap. When published with ArcMap, those
    relationships are preserved in ArcGIS Server. The connection between related features
    and tables is stored within the `relationships` property of the layer and table.
    A developer can query related data, based on a selection in the parent feature
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Relationship objects have the same general format. Each relationship object
    contains a numerical `id` and `relatedTableId`. The `relatedTableId` is linked
    to the `RelationshipQuery` object to query for related results. The role describes
    whether the current layer or table is the origin or the destination of the relationship.
    Cardinality describes whether a single origin object has one or several destinations
    related to it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When querying for results, results return much faster if you start with the
    origin and use `RelationshipQuery` on the destination tables. Starting with the
    destination tables may take significantly longer.
  prefs: []
  type: TYPE_NORMAL
- en: Common JSON objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ArcGIS REST API defines the formats for JSON data objects commonly used
    by the system. The ArcGIS API for JavaScript uses this format to communicate with
    the server. When you look at the network traffic in your browser''s developer
    console, you''ll see these common JSON objects in both the requests and responses.
    Let''s look more closely at two of these JSON object definitions: geometries and
    symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: Geometries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Geometry JSON is a common data format used for ArcGIS Server processes. It makes
    sense, since finding geographic locations relies on geometry. Geometries come
    in a variety of shapes and sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in previous chapters, spatial reference refers to the calculations
    that represent the earth on a map, either as a spheroid (almost a sphere), or
    as a 2-dimensional representation of a land surface. Instead of documenting all
    the possible factors that go into calculating a spatial reference, a general format
    is followed, either by using an assigned **well-known ID** (**WKID**), or **well-known
    text** (**WKT**).
  prefs: []
  type: TYPE_NORMAL
- en: For spatial references with well-known ids, the spatial reference JSON is made
    up of one required parameter (WKID), and three optional parameters. The WKID is
    a numerical reference to the spatial reference, which can be searched at [http://www.spatialreference.org](http://www.spatialreference.org).
    Common values include `wkid 4326`, which stands for WGS84, and is typically used
    for latitude and longitude. Optional spatial reference object parameters include
    the latest WKID or `latestWkid`, a vertical coordinate system WKID or `vcs Wkid`,
    and the latest vertical coordinate system WKID or `latest vcs Wkid`. The last
    two are used for features with three-dimensional points, including height.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial references can also be defined using strings, in the case of the well-known
    text. The well-known text details the necessary items used to flatten the map
    mathematically.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be calculating anything with spatial references. For our applications,
    we'll use them either for data comparison, or as parameters for service requests.
    Let's say we need the latitude and longitude coordinates for the results of a
    query, but the data isn't in a decimal degree latitude/longitude spatial reference.
    We can query the data, but set the `query.outSpatialReference` to `wkid 4326`,
    and ArcGIS Server performs the necessary calculations to give us the results in
    the format we need.
  prefs: []
  type: TYPE_NORMAL
- en: Points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Points are the simplest geometry, and therefore the simplest to explain. They
    have three required parameters, an `x` value, a `y` value, and a `spatialReference`
    value. The `x` value refers to the longitude, or easting value, depending on the
    coordinate system. The `y` value refers to the latitude or the northing value.
    Points may also have an optional `z` value to describe the height, and an optional
    `m` value to describe the slope. You can see an example of a point REST object
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the point has an `x` and `y` value, plus a spatial
    reference. As we learned in the previous section, a well-known `id` of `4326`
    means the `x` and `y` values are longitude and latitude. In the second example,
    a `z` value was added, indicating a height.
  prefs: []
  type: TYPE_NORMAL
- en: Multipoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multipoints, as you may recall from previous chapters, define a cluster of
    points. The points share the same spatial reference (`spatialReference`). Multipoints
    define points by using a `points` property, which is a two dimensional array of
    points. The lowest array contains the `x`, `y`, and possibly `z` (height) and
    `m` (slope) values. If the points contain `z` and/or `m` values, the multipoint
    JSON will also have true values for its `hasZ` and `hasM` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example shows three points grouped together as a multipoint, with locations
    defined using latitude and longitude coordinates (wkid 4326).
  prefs: []
  type: TYPE_NORMAL
- en: Polylines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polylines can be either one line, or a group of lines, that describe the same
    linear feature on a map. The polylines JSON is made up of a spatial reference
    and a three-dimensional array of points in its `paths` property. The lowest level
    of the polyline paths array contains the `x`, `y`, and possibly `z` and `m` coordinates
    for a point on the line. If `z` and `m` values are present, the polyline JSON
    object has its `hasZ` and `hasM` values set to true, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'A polyline may contain more than one line. For instance, if part of a railroad
    line is abandoned, the railroad still owns the lines on either side of that section.
    The two good sections would still be considered a polyline. This is why the polyline
    contains three levels of arrays. The preceding code symbolizes a single line with
    a string of latitudinal and longitudinal coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Polygons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polygons provide a solid shape to areas. A polygon JSON is made up of a spatial
    reference and a `rings` parameter. The rings parameter contains a triple array
    with one or more lists of points, where the last point is the same as the first
    point. In this way, the polygon closes in on itself and provides an interior and
    an exterior. The points within the polygon rings can contain `z` values for height.
    In that case, the polygon would have the optional `hasZ` property set to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'A polygon JSON can contain more than one closed loop of points, and these polygons
    are called **multipart polygons**. An example of this would be a plot of land
    that has a road built down the middle of it. If the road no longer belongs to
    the owner, the owner still retains ownership of the two halves of the property
    divided by the road. Since the land used to be as one, it is still treated as
    one unit, but with two parts. The following JSON code illustrates a multipart
    polygon. The polygon has two `rings`, each with three points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Envelopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Envelopes, also known as extents, are the bounding boxes that represents the
    minimum and maximum `x` and `y` values for items on the map. The following example
    shows an area between `42.902` degrees and `53.923` degrees longitude, and `-23.180`
    degrees and `-18.45` degrees latitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The symbol JSON contains the minimum amount of data necessary to describe the
    properties of the symbols. As we learned in previous chapters, a graphics symbol
    describes the appearance of the graphic, affecting the color, line thickness,
    and transparency, among other features. Different geometry types have corresponding
    symbol types to demonstrate their features. We're going to look at how the ArcGIS
    REST API describes the different symbol types, and how to use them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Colors are defined in ArcGIS REST services as three to four element arrays with
    integer values from 0 to 255\. The first three values stand for the red, green,
    and blue color values, respectively. Higher numbers mean lighter colors, and lower
    numbers mean darker colors, with `[0, 0, 0]` representing the color black.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth value refers to the alpha, or the opacity of the color. A value of
    255 is completely opaque while a value of 0 is completely transparent, and a value
    somewhere in between is somewhat see-through. If the fourth value is left out,
    it is considered to be completely opaque (255). This description differs from
    the `esri/Color` description of opacity, which defines the value as a decimal
    value between `0.0` and `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Simple line symbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As for symbols, we start with the simple line symbol because it is used by
    all the other symbols. The line consists of four basic properties: a `type`, a
    `style`, a `width`, and a `color`. The type, `esriSLS`, is always the same for
    a simple line symbol. The `width` describes a pixel width for the line, and `color`
    describes the numeric RGB value described in the previous color section. `style`
    is one of several string constants prefixed by `esriSLS`. The choices include
    `Solid`, `Dash`, `Dot`, `DashDot`, `DashDashDot`, and `Null`. You can see an example
    of a JSON simple line symbol definition in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Simple marker symbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simple marker symbol describes the style of a simple point and is made
    up of the following properties: a `type`, `style`, `color`, `size`, `angle`, `xoffset`,
    `yoffset`, and `outline`. The `type` is always `esriSMS` for these symbols. Styles
    are defined in a similar way to the simple line symbol, except that all styles
    are prefixed with `esriSMS`. The style can be chosen from a `Circle`, `Cross`,
    `Diamond`, `Square`, `X`, or `Triangle`. `Angle` defines the rotation of the symbol,
    while `xoffset` and `yoffset` describe how far the drawn point is away from the
    real point. `Size` is numeric, and measures the pixel size of the graphic. Finally,
    `outline` accepts a simple line symbol definition to describe the border of the
    point graphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Simple fill symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simple fill symbols can be described by the following properties: `type`, `style`,
    `color`, and `outline`. `Type` is always `esriSFS`, and all styles start in the
    same way. Styles consist of `Solid`, `Null`, and various other ways to describe
    lines drawn within the graphic. `Outline`, like the simple marker symbol, uses
    the simple line symbol to describe the border of the polygon. Look at the following
    code for an example of a JSON description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Picture marker symbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The picture marker symbol describes a point symbol with a picture graphic.
    The symbol JSON for this includes unique properties such as `url`, `imageData`,
    `contentType`, `width`, and `height`, as well as properties common to the simple
    marker symbol (type, `angle`, `xoffset`, and `yoffset`). The URL links to the
    image you want to see with the features. `Width` and `height` describe how large
    you want the image to be in pixels. `ContentType` refers to the file extension,
    such as `image/png` for a `.png` file. Finally, `imageData` is populated by the
    `base64` string that can be translated into an image file. Refer to the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Picture fill symbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The picture fill symbol can be added to a polygon to show an image tiled inside
    the shape. The picture fill symbol has many of the same parameters as the picture
    marker symbol, including `url`, `imageData`, `contentType`, `width`, `height`,
    `angle`, `xoffset`, and `yoffset`. It requires the line symbol JSON for the outline.
    It accepts its own numeric `xscale` and `yscale` parameters, which shrink or stretch
    the images shown within the feature. You can see an example of a picture fill
    symbol JSON here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Text symbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The text symbol JSON describe the formatting used to create custom text labels
    on the map. The text symbol JSON looks very different to the other symbols because
    it is also concerned with things such as fonts, boldness, and italics. However,
    the text symbol does have certain properties in common with the other symbols
    such as `color`, `angle`, `xoffset`, and `yoffset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text symbol has some unique properties that need to be addressed. Vertical
    and horizontal alignment position the text in relation to the point because text
    symbols are typically placed around label points. Halo size and color, introduced
    in ArcGIS Server 10.1, describe the color outline around the text, to make it
    more readable against a busy aerial background. The font parameters are so numerous
    they require their own object to describe the CSS styling of the labels. You can
    see an example of a text symbol here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Uses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While you will seldom see symbol JSON passed between the server and client,
    all of the symbol constructors in the ArcGIS JavaScript API can accept JSON objects
    to define the symbols. The developer can thus stash the symbol style in a configuration
    file until it's needed. The developer can also construct the JSON object with
    a different color palette and line defining widget before it is assigned as a
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning symbols with JSON is much easier than the previous methods of defining
    a simple symbol. The older ways included symbol constructors containing a long
    list of arguments. Some constructors could possibly contain nested constructors.
    Another way of constructing symbols include creating a base symbol, and then assigning
    the necessary attributes with assignment methods. Let''s take a look at an example
    of the older way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a base symbol is constructed and additional methods are called to assign
    colors, line width, and line style. Compare this to the same symbol declaration
    using JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While the JSON code takes up an extra line of code, it's more compact and easier
    to read. Also, this symbol assignment doesn't require the client to load two extra
    modules just to assign a color and a line style. It's all included in a single
    construction call.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When constructing symbols using JSON, you don't have to add every single JSON
    attribute defined in the symbol. When the symbols are constructed, the attributes
    of the JSON object are mixed into a default symbol. That means that, if you construct
    a line symbol using the following code, instead of a 1 pixel wide black line,
    you'll create a 1 pixel wide green line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Back to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an idea of how to work with JSON data, we can improve our Year
    2000 Census map. We've come a long way in styling our application but the default
    highlight color for the map's `infoWindow` clashes with the rest of the site.
  prefs: []
  type: TYPE_NORMAL
- en: How about that InfoWindow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our clients at the Y2K Society just responded with feedback on the site. They
    liked the color palette for the page. Unfortunately, they complained that, when
    they clicked on the map, the cyan-colored highlight symbol on the map's popup
    clashed with the site. One user even claimed it gave him a headache to stare at
    it too long. This problem is fixable, and there are things we can do to make the
    client happy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the application we wrote in the previous chapter. If you haven't
    seen the application in [Chapter 3](ch03.html "Chapter 3. The Dojo Widget System"),
    *The Dojo Widget System*, there are code samples included with this book. We created
    a widget using the Dojo framework to interact with the map and reveal the census
    data for the year 2000\. We will modify the widget so that it can modify the map
    properties for us.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Census.js` file in your favorite text editor. If you look it over,
    you'll see where we construct the Census widget, then use the `show()` and `hide()`
    functions to toggle map clickability. We would like to modify the symbols for
    the map's `infowindow` but, where do we begin?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could change the map''s `infowindow` properties in the constructor, but
    that could lead to problems. If you remember, in [Chapter 2](ch02.html "Chapter 2. Digging
    into the API"), *Digging into the API*, we talked about how changing map settings
    before it finishes loading causes an error and possibly stops the application.
    We''ll have to check if the map is loaded before we make any changes to its `infowindow`.
    If it hasn''t loaded, we''ll assign an event listener to the map''s load event.
    If it has loaded, we''ll go ahead and run the event listener. We''ll call `_onMapLoad()`
    event listener, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A line below the `Census` dijit `constructor()` method, we''ll add the new
    `_onMapLoad()` method. We know that the map has loaded there, and that means the
    `infoWindow` object should be ready as well. We''ll modify the `infoWindow` object''s
    `markerSymbol` and `fillSymbol` properties with our own symbology. Now, we haven''t
    added modules for the `SimpleMarkerSymbol` and `SimpleFillSymbol` yet, so we''ll
    add the references to those in our define statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So, we know that symbol constructors can accept JSON objects to create the symbols.
    Let's fill in the properties in the objects we'll pass into the symbols. We'll
    pick some colors based on the application's color palette. We'll also adjust the
    fill symbol's interior transparency, so that the user can see what's underneath.
    Remember that, when defining a color, the four numbers represent red, green, blue,
    and opacity values, ranging from a full 255, to an empty 0\. Also, you don't have
    to pass every single symbol JSON property, if you don't mind that it uses a default
    value instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can then save and reload our application in the browser. If we've typed everything
    in correctly, the map should load with no errors. When we click on the **Census**
    button, the floating widget should load in the corner, and when we zoom in and
    click on an area, we should see new yellow diamonds when points are selected,
    and polygons highlighted in colors similar to the application. Our clients will
    hopefully be pleased with our color choices.
  prefs: []
  type: TYPE_NORMAL
- en: '![How about that InfoWindow](img/6459OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image shows the **Census Block Points** with the golden rod-colored
    diamond. Each selected point will show the same graphic. You can see a picture
    of one of the states in the following. Note that the fill color is semi-transparent,
    allowing the user to read the content underneath:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How about that InfoWindow](img/6459OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored the different parts of the REST Service endpoints for ArcGIS
    Server, the primary data source for our ArcGIS JavaScript API-based applications.
    We've learned what it means for a service to be RESTful, and how that applies
    to ArcGIS Server. We've explored the organization of ArcGIS Server map services.
    We've learnt about what information is available when viewing REST Services in
    a web browser, and with JSON requests. We learned about the ArcGIS REST API, how
    data is formatted for requests, and how it is consumed, both by ArcGIS Server
    and by the ArcGIS JavaScript API. Finally, we applied some of our knowledge to
    improve our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With your understanding of how data is handled client-side and server-side,
    you will be able to implement many of the powerful features that ArcGIS Server
    offers for web-based applications. In the next chapter, we''ll look into one of
    those powerful features: editing map data.'
  prefs: []
  type: TYPE_NORMAL
