- en: Chapter 4. Finding Peace in REST
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've spent a few chapters discussing and building applications using the ArcGIS
    API for JavaScript. We've used different API tools to communicate with ArcGIS
    Server about its map services. But how does the API communicate with ArcGIS Server?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll focus on ArcGIS Server. We'll look at how it implements
    a REST interface. We'll review the ArcGIS REST API, outlined at [http://resources.arcgis.com/en/help/arcgis-rest-api/#/The_ArcGIS_REST_API/02r300000054000000/](http://resources.arcgis.com/en/help/arcgis-rest-api/#/The_ArcGIS_REST_API/02r300000054000000/).
    This describes the file structure and the format of the data that passes between
    the server and the browser. Finally, we'll extend the application from the previous
    chapter by changing the popup highlighted symbols.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What is REST? REST stands for **Representational State Transfer**. It's a software
    architecture that focuses on the interface between server and client using a hypermedia
    environment. It limits the actions that can be performed between the client and
    the server, but provides enough user information and documentation for the user
    to navigate amongst data and states.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In our discussion of ArcGIS Server and REST in this chapter, we''ll cover the
    following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Handling REST endpoints and data formats
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hierarchy of ESRI REST Services, as seen through a browser
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common REST data in JSON format
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use ArcGIS REST Services and JSON as defined in the REST API Requirements
    for a REST service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST is a methodology based around web pages. A website presents a state (the
    URL), data transfer (HTML page, CSS, and JavaScript), and a well-documented way
    to navigate between the different states (links). While understanding a website
    to be RESTful is well and good, what makes ArcGIS Server so RESTful?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for a web service to be considered RESTful, it must meet the following
    requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-Server**: The roles of the client and server are clearly defined.
    The client doesn''t care if the server contains one or one million records, and
    the server does not depend on a particular UI for the client. As long as the interface
    between the client and server remains the same, the client and server code can
    be changed independently.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: The client handles the state of the application, whereas the
    server does not have to keep up with it. The client has all it needs to make a
    request, including the necessary parameters and security tokens.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: Sometimes client applications cache data for faster performance
    because the World Wide Web delivers data asynchronously. The server needs to tell
    the client which requests can be cached and for how long.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system**: The server-side application can be placed behind a load
    balancer, a secure system, or a proxy, with no noticeable effect on the client-side
    application.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code on demand (optional)**: The server can provide code for the client to
    run. Examples include Java applets or JavaScript scripts. Not all REST services
    do this.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: With a REST service, the server provides a uniform interface
    through which the client can interact with the data. The uniform interface can
    be broken down further into four principles.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information requests that include the identification of the resource. This includes
    everything from the data source to the output type.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The client has enough information from a request to manipulate or delete data.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages from the server contain instructions about how to use them.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A state is handled by the client using hypermedia (web pages, query parameters,
    and session states).
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look into the ArcGIS Server implementation, you'll see that it meets
    these criteria. Therefore, it's considered RESTful.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Looking at a map server
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ArcGIS Server provides web access to its map service contents. To access the
    content, you need to know the ArcGIS Server name and the site name. By default,
    ArcGIS Server is reached through port `6080`. It can also be reached through port
    `80` if it has been configured and licensed to deliver web content. REST Service
    endpoints can be reached through your browser with this address:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Where `GIS Server Name` refers to the ArcGIS Server machine, and `site name`
    refers to the ArcGIS Server instance which, by default, is `arcgis`, the port
    number is optional if ArcGIS Server has been set up to deliver traffic on port
    `80`. This is the default port for Internet traffic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: When there are multiple GIS Servers, often handling a large load of traffic
    or complicated services, a web adaptor may be installed. The web adaptor routes
    traffic to multiple ArcGIS Servers, based on service requests, load balancing,
    and other related issues. The web adaptor also provides a layer of security, whereby
    ArcGIS Server machine names are not directly exposed to the outside world. To
    access the REST service through the web adaptor, use the following URL.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As long as ArcGIS Server is accessible from our computer, we can access information
    in the web browser. By default, the service data is presented as HTML. From there
    we can see the properties of the REST service, and follow links to other services
    and actions on the server. This lets developers review and test map services,
    independent of any application they create.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: ArcGIS REST services provide a great way to view and interact with service data
    using HTML, which is good for presentation. Almost all of our applications will
    interact with the REST service through server requests. ArcGIS Server can therefore
    communicate through REST using another data format called JSON.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation (JSON)** provides a structured data format for
    loosely defined data structures. A JSON object is built with other JSON objects,
    including strings, numbers, other objects, and arrays. Any data is allowed, as
    long as everything is self-contained and there is no sloppy formatting with missing
    brackets and braces.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to test for valid JSON. Visit [http://jsonlint.com](http://jsonlint.com),
    where you can copy and paste your JSON and submit it for validation. It will point
    out missing or broken formatting issues, as well as how to resolve them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: As you read through the examples in this book you'll see that JSON isn't always
    formatted in the same way, especially with JSON object key fields (or property
    names). JSON validators require that all string items are enclosed in quotes.
    Single or double quotes will work, as long as you put the same marks at the end
    of a string as those at the beginning. This includes both JSON object key fields.
    JavaScript interpreters in a browser are more flexible, key fields do not have
    to be enclosed by quotes. It all depends on how you're testing the JSON.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Before JSON was developed, data was passed from server to client in a format
    called **Extensible Markup Language (XML)**. XML is a document markup language
    that shows data in a format both humans and machines can read. The XML format
    can be read and parsed by a number of programming languages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main reasons why JSON is the preferred data format for web applications
    when compared to XML. First, JSON data can be consumed immediately by JavaScript
    applications. XML requires extra steps to parse the data into a usable object.
    Secondly, JSON data takes up less space. Let''s explore that by comparing two
    snippets of data. The following snippet is written in XML:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, here''s the same data written in JSON:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The same data in JSON counts 62 characters less than that in XML. If we take
    out the line breaks and extra spaces, or **minimize** the data, the JSON data
    is 93 characters shorter than the minimized XML. With bandwidth at a premium,
    especially for mobile browsers, you can see why JSON is the preferred format for
    data transmission.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: JSON and PJSON formatting
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON comes in two flavors. The default JSON is minimized, with all the extra
    spaces and line returns removed. Pretty JSON, or PJSON for short, contains line
    breaks and spacing to show the structure and hierarchy of the data. The previous
    Mount Everest example shows what PJSON looks like. While PJSON is easier to read,
    and therefore easier to troubleshoot for errors, the minimized JSON is much smaller.
    In the example, the PJSON has 397 characters, while the minimized version has
    only 277 characters, a 30 percent decrease in size.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'When viewing ArcGIS REST service data, you can change the format of the data
    by adding an `f` query parameter to the REST Service URL. It should look like
    the following URL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, you can set `f=JSON` to receive the raw JSON data, or `f=PJSON` to receive
    the human-readable pretty JSON (or padded JSON, if you prefer). Some browsers,
    such as Google Chrome and Mozilla Firefox, offer third party extensions that reformat
    raw JSON data into PJSON without making the request.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以设置 `f=JSON` 以接收原始 JSON 数据，或 `f=PJSON` 以接收人类可读的格式化 JSON（如果您更喜欢，也可以是填充的
    JSON）。一些浏览器，如 Google Chrome 和 Mozilla Firefox，提供第三方扩展，可以将原始 JSON 数据重新格式化为 PJSON，而无需发出请求。
- en: Service levels
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务级别
- en: 'Let''s start by viewing the sample ArcGIS Server services at [http://sampleserver6.arcgisonline.com/arcgis/rest/services](http://sampleserver6.arcgisonline.com/arcgis/rest/services).
    When we request the page as HTML, we notice a few things. First, the version of
    ArcGIS Server is shown (version 10.21 at the time of writing). The version number
    is important because many features and bits of information may not be present
    in older versions. Secondly, we see a list of links pointing to folders. These
    are map services grouped in any way the publisher chooses. We also see a list
    of map service links below the folder lists. Finally, at the bottom of the page,
    we see supported interfaces. In this site, we can see the REST interface that
    we''re familiar with. The other interfaces will not be covered in this book. Here''s
    a picture of the service:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看示例 ArcGIS Server 服务开始，[http://sampleserver6.arcgisonline.com/arcgis/rest/services](http://sampleserver6.arcgisonline.com/arcgis/rest/services)。当我们以
    HTML 的形式请求页面时，我们注意到一些事情。首先，显示了 ArcGIS Server 的版本（在撰写本文时为版本 10.21）。版本号很重要，因为许多功能和信息可能不会出现在旧版本中。其次，我们看到指向文件夹的链接列表。这些是按照发布者选择的任何方式组合的地图服务。我们还在文件夹列表下方看到地图服务链接列表。最后，在页面底部，我们看到支持的接口。在这个网站上，我们可以看到我们熟悉的
    REST 接口。本书不会涵盖其他接口。以下是服务的图片：
- en: '![Service levels](img/6459OT_04_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![服务级别](img/6459OT_04_01.jpg)'
- en: 'If we change the format of the REST Service request in our browser to Pretty
    JSON, by adding `?f=pjson` to the end of the URL, we can see roughly how the ArcGIS
    JavaScript API would see this location:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将浏览器中 REST 服务请求的格式更改为 Pretty JSON，通过在 URL 末尾添加 `?f=pjson`，我们可以大致了解 ArcGIS
    JavaScript API 会如何查看此位置：
- en: '![Service levels](img/6459OT_04_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![服务级别](img/6459OT_04_02.jpg)'
- en: 'Here, the JSON object returned includes the numeric `currentVersion`, an array
    of folder names, and an array of services objects. The service JSON objects contain
    a name and a type attribute, which tells you what kind of service you''re dealing
    with, and gives you the components you need to construct the URL link to those
    services. This format is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，返回的 JSON 对象包括数字 `currentVersion`、文件夹名称的数组以及服务对象的数组。服务 JSON 对象包含一个名称和一个类型属性，这告诉您正在处理什么类型的服务，并提供了构建指向这些服务的
    URL 链接所需组件。此格式如下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we follow the link to our census map service, we can see more details.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跟随链接到我们的人口普查地图服务，我们可以看到更多详细信息。
- en: Map services
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图服务
- en: 'A map service gives applications access to map data published with ArcGIS Server.
    It contains information about the map layout, format, contents, and other items
    necessary to properly render the map with the various ArcGIS API''s. The map service
    URL is formatted as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 地图服务使应用程序能够访问使用 ArcGIS Server 发布的地图数据。它包含有关地图布局、格式、内容和其他必要项的信息，以正确使用各种 ArcGIS
    API 渲染地图。地图服务 URL 的格式如下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you navigate to a map service using your browser, you're presented with
    a lot of information about the map service. The HTML provides links to view the
    data in different applications, including the ArcGIS JavaScript API and ArcMap.
    Google Earth is also available if the map service is published to serve data in
    that format. The HTML for the map service also provides a lot of metadata to help
    you understand what it's offering. These properties include the **Description**,
    **Service Description**, **Copyright Text**, and the **Document Info**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用浏览器导航到地图服务时，您会看到有关地图服务的大量信息。HTML 提供了查看不同应用程序中数据的链接，包括 ArcGIS JavaScript
    API 和 ArcMap。如果地图服务已发布以提供该格式的数据，则还可以使用 Google Earth。地图服务的 HTML 还提供了大量元数据，以帮助您了解其提供的内容。这些属性包括**描述**、**服务描述**、**版权文本**和**文档信息**。
- en: Some of the map service properties can be difficult to understand without some
    context. We'll review some of the important ones. Remember that properties in
    this list show how they are listed in the HTML. When shown in JSON, these items
    are camel-cased (first letter lowercase, no spaces, and capital letters to start
    each new word after the first).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Spatial reference**: How the layout of the map compares with the real world,
    which we''ll discuss a little later.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single fused map cache**: Lets you know whether the map data has been cached,
    or if it is dynamic. You can load the layer by using either `ArcGISTiledMapServiceLayer`
    or `ArcGISDynamicMapServiceLayer`, respectively.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initial extent**/**full extent**: When you first load the map with the ArcGIS
    JavaScript API, the initial extent describes the bounding box of the area you
    see the first time. The full extent is the expected full area of the map service,
    which may be much wider than all the data.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported image format types**: When ArcGIS Server draws the map layers as
    tiles, these are the image formats that can be returned. `PNG32` is recommended
    if your data has a lot of semi-transparencies and colors, while PNG8 works well
    with very simple symbols.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports dynamic layers**: If true, the developer can change the symbology
    and layer definitions when displaying the map service.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max record count**: When submitting a query, identify or some other search,
    this is the maximum number of results that can be returned by the map service.
    This information can only be changed by server-side changes to the map service.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the Map Service HTML provides links to a number of related REST Service
    endpoints. Most of these links extend the existing URL and provide more information
    about the map service. As a bare minimum, the following should be present:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**Legend**: Displays the symbology of the layers in the map service.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Export map**: This feature lets you download an image showing an area of
    the map that fits within a specific bounding box. You can specify parameters.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify**: This lets you identify features within all layers of a map service,
    based on the geometry passed in. This functionality is used by `IdentifyTask`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find**: This lets the user search for features based on the presence of a
    line of text passed to it. This functionality is implemented by `FindTask`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map service layers
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When exploring the layers of a map service, it helps to know what to look for.
    Map services list the basic contents of their layers within an array of objects
    in their layer properties.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: All layer objects have the same format, with the same properties. Each layer
    object has a numeric `id` property that refers to the layer's zero-based position
    in the list. Layer objects also have a `name` property that comes from how the
    layer was named in the map service. These layers also have a `minScale` and `maxScale`
    property, showing the range within which the layer is visible (with a 0 value
    meaning there is no `minScale` or `maxScale` limitation). When determining visibility,
    the layer object also contains a Boolean `defaultVisibility` property that describes
    whether the layer is initially visible when the map service loads.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有图层对象具有相同的格式，具有相同的属性。每个图层对象都有一个表示图层在列表中零基位置的数字 `id` 属性。图层对象还有一个 `name` 属性，它来自图层在地图服务中的命名方式。这些图层也有
    `minScale` 和 `maxScale` 属性，显示图层可见的范围（0 值表示没有 `minScale` 或 `maxScale` 限制）。在确定可见性时，图层对象还包含一个布尔
    `defaultVisibility` 属性，描述了图层在地图服务加载时是否最初可见。
- en: 'Map service layer objects also contain information about their layer hierarchy.
    Each map layer object contains a `parentLayerId` and a `subLayerIds` property.
    The `parentLayerId` is a number that refers to the index of the parent group layer
    for the specific layer. A parent layer `id` of `-1` means the layer in question
    has no parent layer. The `subLayerIds` are an integer array of the indexes where
    you can find the `sublayers` for the particular parent layer. If a layer has no
    sublayers, the `subLayerIds` will be a `null` value, instead of an empty list.
    You can see an example of map service layers in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 地图服务图层对象还包含有关其图层层次结构的信息。每个地图图层对象包含一个 `parentLayerId` 和一个 `subLayerIds` 属性。`parentLayerId`
    是一个数字，它引用了特定图层父组图层的索引。父层 `id` 为 `-1` 表示所讨论的图层没有父层。`subLayerIds` 是一个整数数组，其中包含可以找到特定父层子图层的索引。如果一个图层没有子图层，`subLayerIds`
    将是一个 `null` 值，而不是空列表。你可以在以下代码中看到一个地图服务图层的示例：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding snippet, the map service has three layers. The `Pet Lovers`
    layer is actually a `parentLayer`, and corresponds to a group layer assigned in
    an ArcMap `.mxd` file. There are two layers in `parentLayer`: `Dog Lovers` and
    `Cat Lovers`. All layers are visible by default, and the layers do not appear
    until the map is at a scale lower than 1:16,000, according to `minScale`. The
    `maxScale` property is set to zero, meaning there is no maximum scale where the
    layer turns off again.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，地图服务有三个图层。`Pet Lovers` 图层实际上是一个 `parentLayer`，对应于在 ArcMap `.mxd` 文件中分配的组图层。`parentLayer`
    中有两个图层：`Dog Lovers` 和 `Cat Lovers`。所有图层默认都是可见的，并且根据 `minScale`，图层不会显示，直到地图的比例小于
    1:16,000。`maxScale` 属性设置为零，意味着没有最大比例，图层会再次关闭。
- en: Feature services
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征服务
- en: 'Feature services are similar to map services, but provide more functionality.
    Their content can be edited, if the database and map settings support those operations.
    They display their feature symbology without the need of a legend service. Their
    symbology can also be modified client-side, by changing their renderer. The URL
    of a feature service is similar to a map service, except that it ends with `FeatureServer`,
    as shown in the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 特征服务类似于地图服务，但提供了更多的功能。如果数据库和地图设置支持这些操作，它们的内容可以进行编辑。它们不需要图例服务即可显示其特征符号。它们的符号也可以通过更改其渲染器在客户端进行修改。特征服务的
    URL 与地图服务类似，但以 `FeatureServer` 结尾，如下所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The feature service differs first and foremost in its capabilities. Apart from
    allowing you to query data, feature service capabilities allow the user to create,
    update, and/or delete records. Those familiar with CRUD operations will recognize
    those words as the C, U, and D in CRUD (the R stands for read, which is what happens
    when you query for results). The capabilities include editing if create, update,
    or delete are allowed. Also, if the feature service supports file attachments
    to data, such as photos, the capabilities will include the word "upload".
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 特征服务首先和最重要的是其功能。除了允许你查询数据外，特征服务功能允许用户创建、更新和/或删除记录。熟悉 CRUD 操作的人会认出这些词作为 CRUD
    中的 C、U 和 D（R 代表读取，即当你查询结果时发生的情况）。功能包括如果允许创建、更新或删除，则包括编辑。此外，如果特征服务支持将文件附件（如照片）附加到数据，则功能将包括“上传”一词。
- en: 'There are other feature service properties that may help you learn more about
    the service. They include the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他特征服务属性可能有助于你了解该服务。它们包括以下内容：
- en: '**Has Versioned Data**: Lets you know that the geodatabase has versioning enabled,
    which allows edits to be undone/redone.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports Disconnected Editing**: Data can be checked out and edited in an
    environment without an Internet connection. When the application connects to the
    Internet again, the data can be checked back in.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sync Enabled**: If this is true, feature data can be synced between the geodatabase
    the data comes from, and another geodatabase (a topic for another book).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow Geometry Updates**: If editing is allowed, this lets the API know if
    the feature geometries can be edited or not. Due to certain permissions, the application
    might only allow for updates to the feature attributes, while the geometries remain
    unchanged.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable Z Defaults**: If the data contains height data (`z`), default values
    are assigned in the map service.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layer level
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Map services and feature services are made up of layers. These layers group
    together geographic features with the same geometry type and the same sets of
    properties. Layers are referred to by their numerical index in the list. The layer
    index starts at `0` for the bottom layer, and goes up one for each additional
    layer. The URL might look something like this for the first layer in a map service:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Map layers offer a whole host of data to help you understand what you're viewing.
    The layer's `name` property comes either from its name in the `.mxd` file, or
    from the layer in the Table of contents, if the file is unsaved. The map layer
    also provides a description, and copyright data. The display field property tells
    the map service what to use when labeling features, if labeling is turned on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Map layers also provide important data that you can use in your application.
    The `type` parameter tells you the geometry of the layer, whether it's a point,
    line, or polygon. Default visibility lets you know if the layer was originally
    visible or not when the map service began. Minimum scale and maximum scale affect
    visibility, depending on your zoom level. The map service also lets you know if
    the layers have attachments, can be modified with different renderers, and how
    many results can be returned from a query.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A map service layer provides information about its attribute by means of the
    field property. The field property is an array of field objects with similar formats.
    All fields have a type, a name, and an alias attribute. The type refers to the
    data type of the field, whether it's a string or an integer, or something else.
    A current list of supported types can be found at [http://resources.arcgis.com/en/help/arcgis-rest-api/#/field/02r300000051000000/](http://resources.arcgis.com/en/help/arcgis-rest-api/#/field/02r300000051000000/).
    The name attribute is the field name for the property, as found in the geodatabase.
    Field names don't contain spaces or special characters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The `alias` field is a string that shows the field `name` for presentation
    purposes. Unlike the `field` name, the `alias` can have spaces or other special
    characters. If no `alias` is assigned in the geodatabase or the map service, the
    `alias` field is the same as the field `name`. For instance, when creating the
    map service with ArcMap, you might have some data for a block with a field name
    `NUMB_HSES`. If you want to show the values for this property in a chart, the
    field name may look rough and a little confusing. You can then add an alias to
    the `NUMB_HSES` field by calling it `Number of Houses`. That `alias` provides
    a much better description for the field:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias`字段是一个字符串，用于显示用于展示目的的字段`name`。与`field`名称不同，`alias`可以包含空格或其他特殊字符。如果在地理数据库或地图服务中没有分配`alias`，则`alias`字段与字段`name`相同。例如，当使用ArcMap创建地图服务时，你可能有一些具有字段名称`NUMB_HSES`的区块数据。如果你想在一个图表中显示这个属性的值，字段名称可能看起来粗糙且有些令人困惑。你可以通过将其称为`Number
    of Houses`来为`NUMB_HSES`字段添加一个别名。这个`alias`为字段提供了一个更好的描述：'
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Domains
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域
- en: Field objects may also have domain attributes assigned to them. Domains are
    limitations on field values imposed at the geodatabase level. Domains are uniquely
    created in the geodatabase, and can be assigned to feature classes and table fields.
    Domains make it easier to input the correct values by restricting what can be
    entered. Instead of allowing users to mistype street names in a report service,
    for instance, you might provide a field with a domain containing all the correctly
    typed street names. The user can then select from the list, rather than have to
    guess how to spell the street name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 字段对象也可以分配域属性。域是在地理数据库级别强加的字段值限制。域在地理数据库中唯一创建，可以分配给要素类和表字段。域通过限制可以输入的内容，使输入正确的值变得更容易。例如，在报告服务中，你可能会提供一个包含所有正确输入的街道名称的域字段，而不是允许用户在报告中误输入街道名称。然后用户可以从列表中选择，而不是猜测如何拼写街道名称。
- en: 'The ArcGIS REST API supports two varieties of domains: ranges and coded values.
    Ranges, as the name implies, set a minimum and maximum numeric value for a feature
    attribute. One example of a range might be an average user rating for restaurants.
    The restaurant might get somewhere between one and five stars, so you wouldn''t
    want a restaurant to accidently get a value of `6` or a value of less than `1`.
    You can see an example of a rating field with that range domain in this snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS REST API支持两种域类型：范围和编码值。范围，正如其名，为特征属性设置最小和最大数值。一个范围示例可能是一家中餐馆的平均用户评分。餐馆可能得到一星到五星之间的评分，所以你不想餐馆意外得到`6`或小于`1`的值。你可以在以下代码片段中看到一个具有该范围域的评分字段示例：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A coded value domain provides a list of code and value pairs to use as legitimate
    property values. The coded value list contains items with a name and a code. The
    code is the value stored in the geodatabase. The name is the text representation
    of the coded value. They're useful in that users are forced to select a valid
    value, instead of mistyping a correct value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 编码值域提供了一组代码和值对的列表，用作合法的属性值。编码值列表包含具有名称和代码的项目。代码是存储在地理数据库中的值。名称是编码值的文本表示。它们很有用，因为用户被迫选择一个有效值，而不是输入一个正确的值。
- en: 'In the following example, we can see a field with a coded value domain. The
    field contains state abbreviations, but the domain allows the user to see entire
    state names:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到一个具有编码值域的字段。该字段包含州缩写，但域允许用户看到完整的州名：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, state names are stored in two letter code form. The
    domain provides a full name reference table with the full names of the states.
    If you were to send queries for features using this field, you would use the code
    values. Querying for all features where `STATE = 'Alaska'` would yield no results,
    while a query where `STATE = 'AK'` may give you results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，州名以两位字母代码形式存储。域提供了一个完整的州名参考表，包含各州的完整名称。如果你使用此字段发送查询以获取特征，你会使用代码值。查询所有`STATE
    = 'Alaska'`的特征将不会产生结果，而一个`STATE = 'AK'`的查询可能会给你结果。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the code and the value don't have to be of the same type. You can
    have numeric codes for, say, water line part numbers, and coded values to show
    their descriptive names.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码和值不必是同一类型。你可以为水线部件编号使用数字代码，并使用编码值来显示它们的描述性名称。
- en: Related tables
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关表
- en: Tables with non-geographic data can be published in a map service. These tables
    may provide data related to map features, such as comments on campground locations
    or the sales history of a property. These tables can be searched and queried like
    features. Relationships between map layers and tables can also be published and
    searched.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 非地理数据的表可以发布在地图服务中。这些表可能提供与地图特征相关的数据，例如露营地点的评论或财产的销售历史。这些表可以像特征一样进行搜索和查询。地图层和表之间的关系也可以发布和搜索。
- en: Layers and tables can be joined, either by using geodatabase relationship classes,
    or ad-hoc relationship assignments in ArcMap. When published with ArcMap, those
    relationships are preserved in ArcGIS Server. The connection between related features
    and tables is stored within the `relationships` property of the layer and table.
    A developer can query related data, based on a selection in the parent feature
    class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图层和表可以通过使用地理数据库关系类或ArcMap中的临时关系分配进行连接。当使用ArcMap发布时，这些关系在ArcGIS Server中得以保留。相关特征和表之间的连接存储在图层和表的`relationships`属性中。开发者可以根据父特征类中的选择查询相关数据。
- en: Relationship objects have the same general format. Each relationship object
    contains a numerical `id` and `relatedTableId`. The `relatedTableId` is linked
    to the `RelationshipQuery` object to query for related results. The role describes
    whether the current layer or table is the origin or the destination of the relationship.
    Cardinality describes whether a single origin object has one or several destinations
    related to it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关联对象具有相同的一般格式。每个关联对象都包含一个数值`id`和`relatedTableId`。`relatedTableId`与`RelationshipQuery`对象相关联，用于查询相关结果。角色描述了当前层或表是关系的起点还是终点。基数描述了单个起点对象是否有一个或多个与之相关的终点。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When querying for results, results return much faster if you start with the
    origin and use `RelationshipQuery` on the destination tables. Starting with the
    destination tables may take significantly longer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询结果时，如果从起点开始并使用`RelationshipQuery`在目标表上进行操作，结果返回得更快。从目标表开始可能需要更长的时间。
- en: Common JSON objects
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见JSON对象
- en: 'The ArcGIS REST API defines the formats for JSON data objects commonly used
    by the system. The ArcGIS API for JavaScript uses this format to communicate with
    the server. When you look at the network traffic in your browser''s developer
    console, you''ll see these common JSON objects in both the requests and responses.
    Let''s look more closely at two of these JSON object definitions: geometries and
    symbols.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS REST API定义了系统常用JSON数据对象的格式。ArcGIS JavaScript API使用此格式与服务器通信。当你在浏览器开发者控制台中查看网络流量时，你会在请求和响应中看到这些常见的JSON对象。让我们更详细地看看这些JSON对象定义中的两个：几何形状和符号。
- en: Geometries
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何形状
- en: Geometry JSON is a common data format used for ArcGIS Server processes. It makes
    sense, since finding geographic locations relies on geometry. Geometries come
    in a variety of shapes and sizes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 几何JSON是ArcGIS Server过程中常用的数据格式。这是有道理的，因为寻找地理位置依赖于几何形状。几何形状和大小多种多样。
- en: Spatial reference
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空间参考
- en: As mentioned in previous chapters, spatial reference refers to the calculations
    that represent the earth on a map, either as a spheroid (almost a sphere), or
    as a 2-dimensional representation of a land surface. Instead of documenting all
    the possible factors that go into calculating a spatial reference, a general format
    is followed, either by using an assigned **well-known ID** (**WKID**), or **well-known
    text** (**WKT**).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，空间参考指的是在地图上表示地球的计算，可以是球体（几乎是一个球体），也可以是地表的二维表示。而不是记录所有可能影响计算空间参考的因素，遵循一个通用格式，要么使用分配的**已知ID**（**WKID**），要么使用**已知文本**（**WKT**）。
- en: For spatial references with well-known ids, the spatial reference JSON is made
    up of one required parameter (WKID), and three optional parameters. The WKID is
    a numerical reference to the spatial reference, which can be searched at [http://www.spatialreference.org](http://www.spatialreference.org).
    Common values include `wkid 4326`, which stands for WGS84, and is typically used
    for latitude and longitude. Optional spatial reference object parameters include
    the latest WKID or `latestWkid`, a vertical coordinate system WKID or `vcs Wkid`,
    and the latest vertical coordinate system WKID or `latest vcs Wkid`. The last
    two are used for features with three-dimensional points, including height.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Spatial references can also be defined using strings, in the case of the well-known
    text. The well-known text details the necessary items used to flatten the map
    mathematically.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: We will not be calculating anything with spatial references. For our applications,
    we'll use them either for data comparison, or as parameters for service requests.
    Let's say we need the latitude and longitude coordinates for the results of a
    query, but the data isn't in a decimal degree latitude/longitude spatial reference.
    We can query the data, but set the `query.outSpatialReference` to `wkid 4326`,
    and ArcGIS Server performs the necessary calculations to give us the results in
    the format we need.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Points
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Points are the simplest geometry, and therefore the simplest to explain. They
    have three required parameters, an `x` value, a `y` value, and a `spatialReference`
    value. The `x` value refers to the longitude, or easting value, depending on the
    coordinate system. The `y` value refers to the latitude or the northing value.
    Points may also have an optional `z` value to describe the height, and an optional
    `m` value to describe the slope. You can see an example of a point REST object
    in the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, the point has an `x` and `y` value, plus a spatial
    reference. As we learned in the previous section, a well-known `id` of `4326`
    means the `x` and `y` values are longitude and latitude. In the second example,
    a `z` value was added, indicating a height.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Multipoints
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multipoints, as you may recall from previous chapters, define a cluster of
    points. The points share the same spatial reference (`spatialReference`). Multipoints
    define points by using a `points` property, which is a two dimensional array of
    points. The lowest array contains the `x`, `y`, and possibly `z` (height) and
    `m` (slope) values. If the points contain `z` and/or `m` values, the multipoint
    JSON will also have true values for its `hasZ` and `hasM` properties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example shows three points grouped together as a multipoint, with locations
    defined using latitude and longitude coordinates (wkid 4326).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Polylines
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polylines can be either one line, or a group of lines, that describe the same
    linear feature on a map. The polylines JSON is made up of a spatial reference
    and a three-dimensional array of points in its `paths` property. The lowest level
    of the polyline paths array contains the `x`, `y`, and possibly `z` and `m` coordinates
    for a point on the line. If `z` and `m` values are present, the polyline JSON
    object has its `hasZ` and `hasM` values set to true, respectively.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 折线可以是单条线，也可以是描述地图上相同线性特征的线条组。折线的JSON由一个空间参考和其`paths`属性中的三维点数组组成。折线路径数组的最低级别包含线上一点的`x`、`y`、可能还有`z`和`m`坐标。如果存在`z`和`m`值，折线JSON对象将`hasZ`和`hasM`值分别设置为true。
- en: 'A polyline may contain more than one line. For instance, if part of a railroad
    line is abandoned, the railroad still owns the lines on either side of that section.
    The two good sections would still be considered a polyline. This is why the polyline
    contains three levels of arrays. The preceding code symbolizes a single line with
    a string of latitudinal and longitudinal coordinates:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一条折线可能包含多于一条线。例如，如果铁路线的一部分被废弃，铁路仍然拥有该部分两侧的线路。两个好的部分仍然被视为一条折线。这就是为什么折线包含三个级别的数组。前面的代码用一系列经纬度坐标表示了一条线：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Polygons
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多边形
- en: Polygons provide a solid shape to areas. A polygon JSON is made up of a spatial
    reference and a `rings` parameter. The rings parameter contains a triple array
    with one or more lists of points, where the last point is the same as the first
    point. In this way, the polygon closes in on itself and provides an interior and
    an exterior. The points within the polygon rings can contain `z` values for height.
    In that case, the polygon would have the optional `hasZ` property set to true.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形为区域提供了一个实心形状。多边形JSON由一个空间参考和一个`rings`参数组成。`rings`参数包含一个三重数组，其中包含一个或多个点的列表，其中最后一个点与第一个点相同。这样，多边形就封闭了自己，并提供了内部和外部。多边形环内的点可以包含高度`z`值。在这种情况下，多边形将可选的`hasZ`属性设置为true。
- en: 'A polygon JSON can contain more than one closed loop of points, and these polygons
    are called **multipart polygons**. An example of this would be a plot of land
    that has a road built down the middle of it. If the road no longer belongs to
    the owner, the owner still retains ownership of the two halves of the property
    divided by the road. Since the land used to be as one, it is still treated as
    one unit, but with two parts. The following JSON code illustrates a multipart
    polygon. The polygon has two `rings`, each with three points:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形JSON可以包含多个闭合的点环，这些多边形被称为**多部分多边形**。一个例子就是一块土地中间有一条道路穿过。如果道路不再属于所有者，所有者仍然保留由道路分割的两部分财产的所有权。由于土地曾经是一个整体，它仍然被视为一个单位，但有两部分。下面的JSON代码展示了多部分多边形。该多边形有两个`环`，每个环有三个点：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Envelopes
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信封
- en: 'Envelopes, also known as extents, are the bounding boxes that represents the
    minimum and maximum `x` and `y` values for items on the map. The following example
    shows an area between `42.902` degrees and `53.923` degrees longitude, and `-23.180`
    degrees and `-18.45` degrees latitude:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 信封，也称为范围，是表示地图上项目最小和最大`x`和`y`值的边界框。以下示例显示了经度`42.902`度和`53.923`度之间，纬度`-23.180`度和`-18.45`度之间的区域：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Symbols
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: The symbol JSON contains the minimum amount of data necessary to describe the
    properties of the symbols. As we learned in previous chapters, a graphics symbol
    describes the appearance of the graphic, affecting the color, line thickness,
    and transparency, among other features. Different geometry types have corresponding
    symbol types to demonstrate their features. We're going to look at how the ArcGIS
    REST API describes the different symbol types, and how to use them in our application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 符号JSON包含描述符号属性所需的最小数据量。正如我们在前面的章节中学到的，图形符号描述了图形的外观，影响颜色、线宽和透明度等特性。不同的几何类型有相应的符号类型来展示其特性。我们将探讨ArcGIS
    REST API如何描述不同的符号类型，以及如何在我们的应用程序中使用它们。
- en: Color
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色
- en: Colors are defined in ArcGIS REST services as three to four element arrays with
    integer values from 0 to 255\. The first three values stand for the red, green,
    and blue color values, respectively. Higher numbers mean lighter colors, and lower
    numbers mean darker colors, with `[0, 0, 0]` representing the color black.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在ArcGIS REST服务中，颜色定义为包含三个到四个元素的整数数组，取值范围从0到255。前三个值分别代表红色、绿色和蓝色颜色值。数值越高表示颜色越浅，数值越低表示颜色越深，`[0,
    0, 0]`代表黑色。
- en: The fourth value refers to the alpha, or the opacity of the color. A value of
    255 is completely opaque while a value of 0 is completely transparent, and a value
    somewhere in between is somewhat see-through. If the fourth value is left out,
    it is considered to be completely opaque (255). This description differs from
    the `esri/Color` description of opacity, which defines the value as a decimal
    value between `0.0` and `1.0`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Simple line symbol
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As for symbols, we start with the simple line symbol because it is used by
    all the other symbols. The line consists of four basic properties: a `type`, a
    `style`, a `width`, and a `color`. The type, `esriSLS`, is always the same for
    a simple line symbol. The `width` describes a pixel width for the line, and `color`
    describes the numeric RGB value described in the previous color section. `style`
    is one of several string constants prefixed by `esriSLS`. The choices include
    `Solid`, `Dash`, `Dot`, `DashDot`, `DashDashDot`, and `Null`. You can see an example
    of a JSON simple line symbol definition in the following snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Simple marker symbol
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simple marker symbol describes the style of a simple point and is made
    up of the following properties: a `type`, `style`, `color`, `size`, `angle`, `xoffset`,
    `yoffset`, and `outline`. The `type` is always `esriSMS` for these symbols. Styles
    are defined in a similar way to the simple line symbol, except that all styles
    are prefixed with `esriSMS`. The style can be chosen from a `Circle`, `Cross`,
    `Diamond`, `Square`, `X`, or `Triangle`. `Angle` defines the rotation of the symbol,
    while `xoffset` and `yoffset` describe how far the drawn point is away from the
    real point. `Size` is numeric, and measures the pixel size of the graphic. Finally,
    `outline` accepts a simple line symbol definition to describe the border of the
    point graphic:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Simple fill symbols
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simple fill symbols can be described by the following properties: `type`, `style`,
    `color`, and `outline`. `Type` is always `esriSFS`, and all styles start in the
    same way. Styles consist of `Solid`, `Null`, and various other ways to describe
    lines drawn within the graphic. `Outline`, like the simple marker symbol, uses
    the simple line symbol to describe the border of the polygon. Look at the following
    code for an example of a JSON description:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Picture marker symbol
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The picture marker symbol describes a point symbol with a picture graphic.
    The symbol JSON for this includes unique properties such as `url`, `imageData`,
    `contentType`, `width`, and `height`, as well as properties common to the simple
    marker symbol (type, `angle`, `xoffset`, and `yoffset`). The URL links to the
    image you want to see with the features. `Width` and `height` describe how large
    you want the image to be in pixels. `ContentType` refers to the file extension,
    such as `image/png` for a `.png` file. Finally, `imageData` is populated by the
    `base64` string that can be translated into an image file. Refer to the following
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Picture fill symbol
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The picture fill symbol can be added to a polygon to show an image tiled inside
    the shape. The picture fill symbol has many of the same parameters as the picture
    marker symbol, including `url`, `imageData`, `contentType`, `width`, `height`,
    `angle`, `xoffset`, and `yoffset`. It requires the line symbol JSON for the outline.
    It accepts its own numeric `xscale` and `yscale` parameters, which shrink or stretch
    the images shown within the feature. You can see an example of a picture fill
    symbol JSON here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图片填充符号可以添加到多边形中，以显示形状内部镶嵌的图像。图片填充符号具有与图片标记符号许多相同的参数，包括`url`、`imageData`、`contentType`、`width`、`height`、`angle`、`xoffset`和`yoffset`。它需要线符号JSON来定义轮廓。它接受自己的数值`xscale`和`yscale`参数，这些参数可以缩小或拉伸特征内显示的图像。您可以在以下位置看到图片填充符号JSON的示例：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Text symbol
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本符号
- en: The text symbol JSON describe the formatting used to create custom text labels
    on the map. The text symbol JSON looks very different to the other symbols because
    it is also concerned with things such as fonts, boldness, and italics. However,
    the text symbol does have certain properties in common with the other symbols
    such as `color`, `angle`, `xoffset`, and `yoffset`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 文本符号JSON描述了在地图上创建自定义文本标签的格式。文本符号JSON与其他符号看起来非常不同，因为它还涉及字体、粗体和斜体等因素。然而，文本符号确实与其他符号有一些共同属性，例如`color`、`angle`、`xoffset`和`yoffset`。
- en: 'The text symbol has some unique properties that need to be addressed. Vertical
    and horizontal alignment position the text in relation to the point because text
    symbols are typically placed around label points. Halo size and color, introduced
    in ArcGIS Server 10.1, describe the color outline around the text, to make it
    more readable against a busy aerial background. The font parameters are so numerous
    they require their own object to describe the CSS styling of the labels. You can
    see an example of a text symbol here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 文本符号有一些独特的属性需要处理。垂直和水平对齐位置将文本定位到点附近，因为文本符号通常放置在标签点周围。光环大小和颜色，自ArcGIS Server
    10.1引入，描述了围绕文本的颜色轮廓，使其在繁忙的航空背景中更易于阅读。字体参数数量众多，需要自己的对象来描述标签的CSS样式。您可以在以下位置看到文本符号的示例：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Uses
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用
- en: While you will seldom see symbol JSON passed between the server and client,
    all of the symbol constructors in the ArcGIS JavaScript API can accept JSON objects
    to define the symbols. The developer can thus stash the symbol style in a configuration
    file until it's needed. The developer can also construct the JSON object with
    a different color palette and line defining widget before it is assigned as a
    symbol.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你很少在服务器和客户端之间看到传递的符号JSON，但ArcGIS JavaScript API中的所有符号构造函数都可以接受JSON对象来定义符号。因此，开发者可以将符号样式存储在配置文件中，直到需要时再使用。开发者还可以在将JSON对象分配为符号之前，使用不同的调色板和定义小部件来构建JSON对象。
- en: 'Assigning symbols with JSON is much easier than the previous methods of defining
    a simple symbol. The older ways included symbol constructors containing a long
    list of arguments. Some constructors could possibly contain nested constructors.
    Another way of constructing symbols include creating a base symbol, and then assigning
    the necessary attributes with assignment methods. Let''s take a look at an example
    of the older way:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON分配符号比之前定义简单符号的方法要简单得多。旧的方法包括包含长列表参数的符号构造函数。一些构造函数可能包含嵌套构造函数。另一种构建符号的方法是创建一个基本符号，然后使用赋值方法分配必要的属性。让我们看看旧方法的例子：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, a base symbol is constructed and additional methods are called to assign
    colors, line width, and line style. Compare this to the same symbol declaration
    using JSON:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，构建了一个基本符号，并调用其他方法来分配颜色、线宽和线型。将此与使用JSON进行相同符号声明的相同符号进行比较：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While the JSON code takes up an extra line of code, it's more compact and easier
    to read. Also, this symbol assignment doesn't require the client to load two extra
    modules just to assign a color and a line style. It's all included in a single
    construction call.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JSON代码占用额外的代码行，但它更紧凑且易于阅读。此外，此符号分配不需要客户端加载两个额外的模块来分配颜色和线型。所有这些都在单个构造调用中包含。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When constructing symbols using JSON, you don't have to add every single JSON
    attribute defined in the symbol. When the symbols are constructed, the attributes
    of the JSON object are mixed into a default symbol. That means that, if you construct
    a line symbol using the following code, instead of a 1 pixel wide black line,
    you'll create a 1 pixel wide green line.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Back to our application
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an idea of how to work with JSON data, we can improve our Year
    2000 Census map. We've come a long way in styling our application but the default
    highlight color for the map's `infoWindow` clashes with the rest of the site.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: How about that InfoWindow
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our clients at the Y2K Society just responded with feedback on the site. They
    liked the color palette for the page. Unfortunately, they complained that, when
    they clicked on the map, the cyan-colored highlight symbol on the map's popup
    clashed with the site. One user even claimed it gave him a headache to stare at
    it too long. This problem is fixable, and there are things we can do to make the
    client happy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the application we wrote in the previous chapter. If you haven't
    seen the application in [Chapter 3](ch03.html "Chapter 3. The Dojo Widget System"),
    *The Dojo Widget System*, there are code samples included with this book. We created
    a widget using the Dojo framework to interact with the map and reveal the census
    data for the year 2000\. We will modify the widget so that it can modify the map
    properties for us.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Census.js` file in your favorite text editor. If you look it over,
    you'll see where we construct the Census widget, then use the `show()` and `hide()`
    functions to toggle map clickability. We would like to modify the symbols for
    the map's `infowindow` but, where do we begin?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We could change the map''s `infowindow` properties in the constructor, but
    that could lead to problems. If you remember, in [Chapter 2](ch02.html "Chapter 2. Digging
    into the API"), *Digging into the API*, we talked about how changing map settings
    before it finishes loading causes an error and possibly stops the application.
    We''ll have to check if the map is loaded before we make any changes to its `infowindow`.
    If it hasn''t loaded, we''ll assign an event listener to the map''s load event.
    If it has loaded, we''ll go ahead and run the event listener. We''ll call `_onMapLoad()`
    event listener, as you can see in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A line below the `Census` dijit `constructor()` method, we''ll add the new
    `_onMapLoad()` method. We know that the map has loaded there, and that means the
    `infoWindow` object should be ready as well. We''ll modify the `infoWindow` object''s
    `markerSymbol` and `fillSymbol` properties with our own symbology. Now, we haven''t
    added modules for the `SimpleMarkerSymbol` and `SimpleFillSymbol` yet, so we''ll
    add the references to those in our define statement:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, we know that symbol constructors can accept JSON objects to create the symbols.
    Let's fill in the properties in the objects we'll pass into the symbols. We'll
    pick some colors based on the application's color palette. We'll also adjust the
    fill symbol's interior transparency, so that the user can see what's underneath.
    Remember that, when defining a color, the four numbers represent red, green, blue,
    and opacity values, ranging from a full 255, to an empty 0\. Also, you don't have
    to pass every single symbol JSON property, if you don't mind that it uses a default
    value instead.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道符号构造函数可以接受JSON对象来创建符号。让我们填写我们将传递给符号的对象中的属性。我们将根据应用程序的颜色调色板选择一些颜色。我们还将调整填充符号的内部透明度，以便用户可以看到下面的内容。记住，在定义颜色时，四个数字代表红色、绿色、蓝色和不透明度值，范围从全255到空0。另外，如果你不介意它使用默认值，你不必传递每个单独的符号JSON属性。
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can then save and reload our application in the browser. If we've typed everything
    in correctly, the map should load with no errors. When we click on the **Census**
    button, the floating widget should load in the corner, and when we zoom in and
    click on an area, we should see new yellow diamonds when points are selected,
    and polygons highlighted in colors similar to the application. Our clients will
    hopefully be pleased with our color choices.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在浏览器中保存并重新加载我们的应用程序。如果我们输入的内容都是正确的，地图应该会无错误地加载。当我们点击**人口普查**按钮时，浮动小部件应该加载在角落，当我们放大并点击一个区域时，我们应该在选定点时看到新的黄色钻石，并且以与应用程序类似的颜色突出显示的多边形。我们希望客户会对我们的颜色选择感到满意。
- en: '![How about that InfoWindow](img/6459OT_04_03.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![那信息窗口如何](img/6459OT_04_03.jpg)'
- en: 'The preceding image shows the **Census Block Points** with the golden rod-colored
    diamond. Each selected point will show the same graphic. You can see a picture
    of one of the states in the following. Note that the fill color is semi-transparent,
    allowing the user to read the content underneath:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了带有金色杆状钻石的**人口普查区块点**。每个选定的点都会显示相同的图形。以下你可以看到其中一个州的样子。请注意，填充颜色是半透明的，这使用户能够阅读下面的内容：
- en: '![How about that InfoWindow](img/6459OT_04_04.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![那信息窗口如何](img/6459OT_04_04.jpg)'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have explored the different parts of the REST Service endpoints for ArcGIS
    Server, the primary data source for our ArcGIS JavaScript API-based applications.
    We've learned what it means for a service to be RESTful, and how that applies
    to ArcGIS Server. We've explored the organization of ArcGIS Server map services.
    We've learnt about what information is available when viewing REST Services in
    a web browser, and with JSON requests. We learned about the ArcGIS REST API, how
    data is formatted for requests, and how it is consumed, both by ArcGIS Server
    and by the ArcGIS JavaScript API. Finally, we applied some of our knowledge to
    improve our application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了ArcGIS Server REST服务端点的不同部分，这是我们的基于ArcGIS JavaScript API的应用程序的主要数据源。我们学习了服务RESTful的含义以及它如何应用于ArcGIS
    Server。我们探讨了ArcGIS Server地图服务的组织结构。我们了解了在网页浏览器中查看REST服务时可以获取哪些信息，以及使用JSON请求时的情况。我们学习了ArcGIS
    REST API，了解了数据是如何为请求格式化的，以及它如何被ArcGIS Server和ArcGIS JavaScript API消费。最后，我们将一些知识应用到改进我们的应用程序中。
- en: 'With your understanding of how data is handled client-side and server-side,
    you will be able to implement many of the powerful features that ArcGIS Server
    offers for web-based applications. In the next chapter, we''ll look into one of
    those powerful features: editing map data.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过你对客户端和服务器端数据处理的了解，你将能够实现ArcGIS Server为基于Web的应用程序提供的许多强大功能。在下一章中，我们将探讨这些强大功能之一：编辑地图数据。
