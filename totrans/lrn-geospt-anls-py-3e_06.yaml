- en: Geospatial Python Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first three chapters of this book covered the history of geospatial analysis,
    the types of geospatial data that are used by analysts, and the major software
    and libraries found within the geospatial industry. We used some simple Python
    examples here and there to illustrate certain points, but we mainly focused on
    the field of geospatial analysis, independent of any specific technology. Starting
    here, we will be using Python to conquer geospatial analysis and we will continue
    with that approach for the rest of this book. This chapter explains the software
    you will need in your toolbox to do just about anything you want in the geospatial
    field.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discover the Python libraries that are used to access the different types
    of data that were found in the vector data and raster data sections of [Chapter
    2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml), *Learning Geospatial Data*. Some
    of these libraries are pure Python, as well as some of the bindings to the different
    software packages that we looked at in [Chapter 3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml),
    *The Geospatial Technology Landscape*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing third-party Python modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python networking libraries for acquiring data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python tag-based parsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python JSON libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OGR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyShp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DBFPY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shapely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GDAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fiona
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoPandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Imaging Library (PIL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PNGCanvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReportLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoPDF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python NetCDF libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python HDF libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OSMnx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spatial indexing libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jupyter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will examine pure Python solutions whenever possible. Python is a very capable
    programming language, but some operations, particularly in remote sensing, are
    too computationally intensive and therefore are impractical when it comes to using
    pure Python or other interpreted languages. Fortunately, every aspect of geospatial
    analysis can be addressed in some way through Python, even if it is binding to
    a highly efficient C/C++/other compiled-language library.
  prefs: []
  type: TYPE_NORMAL
- en: We will avoid using broad scientific libraries that cover other domains beyond
    geospatial analysis to keep the solutions as simple as possible. There are many
    reasons to use Python for geospatial analysis, but one of the strongest arguments
    is its portability.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Python has been ported to Java as the Jython distribution and to
    the .NET **Common Language Runtime** (**CLR**) as IronPython. Python also has
    versions such as Stackless Python for massively concurrent programs. There are
    versions of Python that are designed to run on cluster computers for distributed
    processing. Python is also available on many hosted application servers that do
    not allow you to install custom executables, such as the Google App Engine platform,
    which has a Python API.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 3.6 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RAM: Minimum 6 GB (Windows), 8 GB (macOS) recommended 8 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage: Minimum 7200 RPM SATA with 20 GB of available space; recommended SSD
    with 40 GB of available space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processor: Minimum Intel Core i3 2.5 GHz; recommended Intel Core i5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing third-party Python modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules written in pure Python (using the standard library) will mostly run
    on any of the 20 platforms that the Python ([https://www.python.org/](https://www.python.org/))
    website mentions. Each time you add a third-party module that relies on bindings
    to external libraries in other languages, you reduce Python's inherent portability.
    You also add a layer of complexity to fundamentally change the code by adding
    another language into the mix. Pure Python keeps things simple. Also, Python bindings
    to external libraries tend to be automatically or semi-automatically generated.
  prefs: []
  type: TYPE_NORMAL
- en: These automatically generated bindings are very generic and esoteric, and they
    simply connect Python to a C/C++ API using the method names from that API, instead
    of following the best practices for Python. There are, of course, notable exceptions
    to this approach that are driven by project requirements which may include speed,
    unique library features, or frequently updated libraries where an automatically
    generated interface is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: We'll make a distinction between modules that are included as a part of Python's
    standard library and modules that must be installed. In Python, the `words` module
    and library are used interchangeably. To install libraries, you either get them
    from the **Python Package Index **(**PyPI**) or in the case of a lot of geospatial
    modules, you download a specialized installer.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyPI acts as the official software repository for libraries and offers some
    easy-to-use setup programs that simplify installing packages. You can use the
    `easy_install` program, which is especially good on Windows or the `pip` program
    that''s more commonly found on Linux and Unix systems. Once it''s installed, you
    can then install third-party packages by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For installing `pip`, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This book will provide links and installation instructions for open source packages
    that are not available on the PyPI. You can manually install third-party Python
    modules by downloading the Python source code and putting it in your current working
    directory, or you can put it in your Python `site-packages` directory. These two
    directories are available in Python's search path when you try to import a module.
    If you put a module in your current working directory, it'll only be available
    when you start Python from that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put it in your `site-packages` directory, it''ll be available every
    time you start Python. The `site-packages` directory is specifically meant for
    third-party modules. To locate the `site-packages` directory for your installation,
    you need to ask Python''s `sys` module. The `sys` module has a `path` attribute
    that has a list of all the directories in Python''s search path. The `site-packages`
    directory should be the last one. You can locate it by specifying an index of
    `-1`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If that call doesn''t return the `site-packages` path, just look at the entire
    list to locate it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These installation methods will be used in the rest of this book. You can find
    the latest Python version, the source code for your platform installation, and
    compilation instructions at [http://python.org/download/](http://python.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: The Python `virtualenv` module allows you to easily create an isolated copy
    of Python for a specific project without affecting your main Python installation
    or other projects. Using this module, you can have different projects with different
    versions of the same library. Once you have a working code base, you can keep
    it isolated from changes to the modules you used or even Python itself. The `virtualenv`
    module is simple to use and can be used for any example in this book; however,
    explicit instructions on its use are not included.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with `virtualenv`, follow this simple guide: [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).'
  prefs: []
  type: TYPE_NORMAL
- en: Python virtualenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python geospatial analysis requires that we use a variety of modules with many
    dependencies. These modules often build on each other using specific versions
    of C or C++ libraries. You often run into version conflicts as you add Python
    modules to your system. Sometimes, when you upgrade a particular module, it might
    break your existing Python program due to changes in the API – or maybe you are
    running both Python 2 and Python 3 to take advantage of libraries written for
    each version. What you need is a way to safely install new modules without corrupting
    a working system or code. The solution to that issue is to use Python virtual
    environments through the `virtualenv` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `virtualenv` module creates isolated, individual Python environments
    for each project so that you can avoid conflicting modules polluting your main
    Python installation. You can switch a particular environment on and off by activating
    it or deactivating it. The `virtualenv` module is efficient in that it doesn''t
    actually copy your entire system Python installation each time you create an environment.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing `virtualenv` is as simple as running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a directory for your virtual Python environments. Name it whatever
    you want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create your first virtual environment using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after entering the following command, you can activate the environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run any Python commands in that directory, it will use the isolated
    virtual environment. When you''re done, you can deactivate that environment with
    the following simple command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is how you install, activate for use, and deactivate the `virtualenv` module.
    There's one other environment you should know about, however. We'll examine that
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Conda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's also worth mentioning Conda here, which is an open source, cross-platform
    package management system that can also create and manage environments similar
    to `virtualenv`. Conda makes it easy to install complex packages, including geospatial
    ones. It also works with other languages besides Python, including R, Node.js,
    and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Conda is available here: [https://docs.conda.io/en/latest/](https://docs.conda.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's check out how to install GDAL so that we can start processing geospatial
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GDAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Geospatial Data Abstraction Library** (**GDAL**), which includes OGR,
    is critical to many of the examples in this book and is also one of the more complicated
    Python setups. For these reasons, we'll discuss it separately here. The latest
    GDAL bindings are available on PyPI; however, the installation requires a few
    more steps because of additional resources that are needed by the GDAL library.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to install GDAL for use with Python. You can use any one
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile it from the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install it as part of a larger software package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install a binary distribution and then the Python bindings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have experience with compiling C libraries as well as the required compiler
    software, then the first option gives you the most control. However, it is not
    recommended if you just want to get going as quickly as possible, because even
    experienced software developers can find compiling GDAL and the associated Python
    bindings challenging. Instructions for compiling GDAL on leading platforms can
    be found at [http://trac.osgeo.org/gdal/wiki/BuildHints](http://trac.osgeo.org/gdal/wiki/BuildHints).
    There are also basic build instructions on the PyPI GDAL page; have a look at
    [https://pypi.python.org/pypi/GDAL](https://pypi.python.org/pypi/GDAL).
  prefs: []
  type: TYPE_NORMAL
- en: The second option is by far the quickest and easiest. The **Open Source Geospatial
    Foundation** (**OSGeo**) distributes an installer called OSGeo4W, which installs
    all of the top open source geospatial packages on Windows at the click of a button.
    OSGeo4W can be found at [http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/).
  prefs: []
  type: TYPE_NORMAL
- en: While these packages are the easiest to work with, they come with their own
    version of Python. If you already have Python installed, then having another Python
    distribution just to use certain libraries may be problematic. In that case, the
    third option may be for you.
  prefs: []
  type: TYPE_NORMAL
- en: The third option installs a pre-compiled binary specific to your Python version.
    This method is the best compromise between ease of installation and customization.
    The catch is that you must make sure the binary distributions and the corresponding
    Python bindings are compatible with each other, your Python version, and in many
    cases your operating system configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The installation of GDAL for Python on Windows becomes easier and easier each
    year. To install GDAL on Windows, you must check whether you are running the 32-bit
    or 64-bit version of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, just start your Python interpreter at a Command Prompt, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Based on this instance, we can see that Python is version 3.4.2 for `win32`,
    which means it is the 32-bit version. Once you have this information, go to the
    following URL: [http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal](http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This web page contains Python Windows binaries and bindings for nearly every
    open source scientific library. On that web page, in the GDAL section, find the
    release that matches your version of Python. The release names use the abbreviation
    `cp` for C Python, followed by the major Python version number and either `win32`
    for 32-bit Windows or `win_amd64` for 64-bit Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the previous example, we would download the file named `GDAL-1.11.3-cp34-none-win32.whl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This download package is in the newer Python `pip` wheel format. To install
    it, simply open a Command Prompt and type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package has been installed, open your Python interpreter and run the
    following commands to verify that GDAL is installed by checking its version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, GDAL should return its version as `1.11.3`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have trouble installing modules using `easy_install` or `pip` and PyPI,
    try to download and install the wheel package from the same site as the GDAL example.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GDAL installation on Linux varies widely by distribution. The following [https://gdal.org](https://gdal.org)
    binaries web page lists the installation instructions for several distributions:
    [http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries](http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries).
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, your package manager will install both GDAL and Python bindings.
    For example, on Ubuntu, to install GDAL, you need to run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to install the Python bindings, you can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Most Linux distributions are set up to compile software already, and their instructions
    are much simpler than those on Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on the installation, you may have to import `gdal` and `ogr` as part
    of the `osgeo` package, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: macOS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install GDAL on macOS X, you can also use the Homebrew package management
    system, which is available at [http://brew.sh/](http://brew.sh/).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use the MacPorts package management system, which is
    available at [https://www.macports.org/](https://www.macports.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Both of these systems are well-documented and contain GDAL packages for Python
    3\. You only really need them for libraries that require a properly compiled binary
    written in C that has a lot of dependencies and includes many of the scientific
    and geospatial libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Python networking libraries for acquiring data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vast majority of geospatial data sharing is accomplished via the internet,
    and Python is well equipped when it comes to networking libraries for almost any
    protocol. Automated data downloads are often an important step in automating a
    geospatial process. Data is typically retrieved from a website's **Uniform Resource
    Locator** (**URL**) or **File Transfer Protocol** (**FTP**) server and, because
    geospatial datasets often contain multiple files, data is often distributed as
    ZIP files.
  prefs: []
  type: TYPE_NORMAL
- en: A nice feature of Python is its concept of a file-like object. Most Python libraries
    that read and write data use a standard set of methods that allow you to access
    data from different types of resources, as if you were writing a simple file on
    disk. The networking modules in the Python standard library use this convention
    as well. The benefit of this approach is that it allows you to pass file-like
    objects to other libraries and methods, which recognize the convention without
    a lot of setup for different types of data that are distributed in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: The Python urllib module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python `urllib` package is designed for simple access to any file with a
    URL address. The `urllib` package in Python 3 consists of several modules that
    handle different parts of managing web requests and responses. These modules implement
    some of Python's file-like object conventions, starting with its `open()` method.
    When you call `open()`, it prepares a connection to the resource but does not
    access any data. Sometimes, you just want to grab a file and save it to disk,
    instead of accessing it in memory. This function is available through the `urllib.request.retrieve()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `urllib.request.retrieve()` method to download
    the zipped shapefile named `hancock.zip`, which is used in other examples. We
    define the URL and the local filename as variables. The URL is passed as an argument,
    as well as the filename we want to use, to save it to our local machine, which,
    in this case, is just `hancock.zip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The message from the underlying `httplib` module confirms that the file was
    downloaded to the current directory. The URL and filename could have been passed
    to the `retrieve()` method directly as strings as well. If you specify just the
    filename, the download saves to the current working directory. You can also specify
    a fully qualified pathname to save it somewhere else. You can also specify a callback
    function as a third argument, which will receive download status information for
    the file so that you can create a simple download status indicator or perform
    some other action.
  prefs: []
  type: TYPE_NORMAL
- en: The `urllib.request.urlopen()` method allows you to access an online resource
    with more precision and control. As we mentioned previously, it implements most
    of the Python file-like object methods with the exception of the `seek()` method,
    which allows you to jump to arbitrary locations within a file. You can read a
    file online one line at a time, read all the lines as a list, read a specified
    number of bytes, or iterate through each line of the file. All of these functions
    are performed in memory, so you don't have to store the data on disk. This ability
    is useful for accessing frequently updated data online that you may want to process
    without saving to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we demonstrate this concept by accessing the **United
    States Geological Survey** (**USGS**) earthquake feed to view all of the earthquakes
    in the world that have occurred within the last hour. This data is distributed
    as a **Comma-Separated Value** (**CSV**) file, which we can read line by line
    like a text file. CSV files are similar to spreadsheets and can be opened in a
    text editor or spreadsheet program:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to open the URL and read the header with the column names in
    the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you need to read the first line, which contains a record of a recent
    earthquake, as shown in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can also iterate through this file, which is a memory-efficient way to read
    through large files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are running this example in the Python interpreter, you will need to
    press the *Enter* or *return* key twice to execute the loop. This action is necessary
    because it signals to the interpreter that you are done building the loop. In
    the following example, we abbreviate the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Python requests module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `urllib` module has been around for a long time. Another third-party module
    has been developed to make common HTTP requests even easier. The `requests` module
    has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep-alive and connection pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: International domains and URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions with cookie persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser-style SSL verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic content decoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic/digest authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elegant key/value cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic decompression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode response bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP(S) proxy Support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multipart file uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming downloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chunked requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.netrc` support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we''ll download the same ZIP file we downloaded with
    the `urllib` module, except this time using the `requests` module. First, we need
    to install the `requests` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can set up our variables for the URL and the output filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving the ZIP file is as simple as using the `requests` module''s `get()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can get the content from the `.zip` file and write it to our output
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `requests` module has many more advanced features that are just as easy
    to use as this example. Now that we know how to get information via the HTTP protocol,
    let's examine the FTP protocol which is often used to access geospatial data from
    online archives.
  prefs: []
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP allows you to browse an online directory and download data using FTP client
    software. Until around 2004, when geospatial web services became very common,
    FTP was one of the most common ways to distribute geospatial data. FTP is less
    common now, but you occasionally encounter it when you're searching for data.
    Once again Python's batteries-included standard library has a reasonable FTP module
    called `ftplib` with a main class called `FTP()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We will access an FTP server hosted by the US **National Oceanic and Atmospheric
    Administration** (**NOAA**) to access a text file containing data from the **Deep-ocean
    Assessment and Reporting of Tsunamis** (**DART**) buoy network that's used to
    watch for tsunamis around the world. This particular buoy is off the coast of
    Peru.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll define the server and the directory path, and then we will access the
    server. All FTP servers require a username and password. Most public servers have
    a user called anonymous with the password as anonymous, just like this one does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Python's `ftplib`, you can just call the `login()` method without any
    arguments to log in as the default anonymous user. Otherwise, you can add the
    username and password as string arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we're logged in, we'll change to the directory containing the DART datafile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To download the file, we'll open up a local file called out and pass its `write()`
    method as a callback function to the `ftplib.ftp.retrbinary()` method, which simultaneously
    downloads the file and writes it to our local file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the file has been downloaded, we can close it to save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''ll read the file and look for the line containing the latitude and
    longitude of the buoy to make sure that the data was downloaded successfully,
    as shown in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we opened the local file in binary write mode, and we used
    the `retrbinary() ftplib` method, as opposed to `retrlines()`, which uses ASCII
    mode. The binary mode works for both ASCII and binary files, so it's always a
    safer bet. In fact, in Python, the binary read and write modes for a file are
    only required on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are just downloading a simple file from an FTP server, many FTP servers
    have a web interface as well. In that case, you could use `urllib` to read the
    file. FTP URLs use the following format to access data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This format is insecure for password-protected directories because you are
    transmitting your login information over the internet. But for anonymous FTP servers,
    there is no additional security risk. To demonstrate this, the following example
    accesses the same file that we just saw but by using `urllib` instead of `ftplib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can download files, let's learn how to decompress them.
  prefs: []
  type: TYPE_NORMAL
- en: ZIP and TAR files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geospatial datasets often consist of multiple files. For this reason, they are
    often distributed as ZIP or TAR file archives. These formats can also compress
    data, but their ability to bundle multiple files is the primary reason they are
    used for geospatial data. While the TAR format doesn't contain a compression algorithm,
    it incorporates gzip compression and offers it as a program option. Python has
    standard modules for reading and writing both ZIP and TAR archives. These modules
    are called `zipfile` and `tarfile`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example extracts the `hancock.shp`, `hancock.shx`, and `hancock.dbf`
    files contained in the `hancock.zip` file we downloaded using `urllib` for use
    in the previous examples. This example assumes that the ZIP file is in the current
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is more verbose than necessary for clarity. We can shorten this
    example and make it more robust by using a `for` loop around the `zipfile.namelist()`
    method without explicitly defining the different files as variables. This method
    is a more flexible and Pythonic approach, and could be used on ZIP archives with
    unknown contents, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you understand the basics of the `zipfile` module, let''s take the
    files we just unzipped and create a TAR archive with them. In this example, when
    we open the TAR archive for writing, we specify the write mode as `w:gz` for gzipped
    compression. We also specify the file extension as `tar.gz` to reflect this mode,
    as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extract the files using the simple `tarfile.extractall()` method. First,
    we open the file using the `tarfile.open()` method and then extract it, as shown
    in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We'll work on one more example by combining elements we've learned in this chapter
    as well as the elements in the vector data section of [Chapter 2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml),
    *Learning Geospatial Data*. We'll read the bounding box coordinates from the `hancock.zip`
    file without ever saving it to disk. We'll use the power of Python's file-like
    object convention to pass around the data. Then, we'll use Python's `struct` module
    to read the bounding box, like we did in [Chapter 2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml), *Learning
    Geospatial Data*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we read the unzipped `.shp` file into a variable and access the
    data using Python array slicing by specifying the starting and ending indexes
    of the data separated by a colon (`:`). We are able to use list slicing because
    Python allows you to treat strings as lists. In this example, we also use Python''s
    `StringIO` module to temporarily store data in memory in a file-like object that
    implements various methods, including the `seek()` method, which is absent from
    most Python networking modules, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the examples so far, Python's standard library packs a lot
    of punch. Most of the time, you don't have to download a third-party library just
    to access a file online.
  prefs: []
  type: TYPE_NORMAL
- en: Python markup and tag-based parsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tag-based data, particularly different XML dialects, have become a very popular
    way to distribute geospatial data. Formats that are both machine and human-readable
    are generally easy to work with, though they sacrifice storage efficiency for
    usability. These formats can become unmanageable for very large datasets but work
    very well in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: While most formats are some form of XML (such as KML or GML), there is a notable
    exception. The **Well-Known Text** (**WKT**) format is fairly common but uses
    external markers and square brackets (`[]`) to surround data instead of tags in
    angled brackets around data like XML does.
  prefs: []
  type: TYPE_NORMAL
- en: Python has standard library support for XML, as well as some excellent third-party
    libraries available. Proper XML formats all follow the same structure, so you
    can use a generic XML library to read it. Because XML is text-based, it is often
    easy to write it as a string instead of using an XML library. The vast majority
    of applications that output XML do so in this way.
  prefs: []
  type: TYPE_NORMAL
- en: The primary advantage of using XML libraries for writing XML is that your output
    is usually validated. It is very easy to create an error while creating your own
    XML format. A single missing quotation mark can derail an XML parser and throw
    an error for somebody trying to read your data. When these errors happen, they
    virtually render your dataset useless. You will find that this problem is very
    common among XML-based geospatial data. What you'll discover is that some parsers
    are more forgiving with incorrect XML than others. Often, reliability is more
    important than speed or memory efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The analysis that's available at [http://lxml.de/performance.html](http://lxml.de/performance.html)
    provides benchmarks for memory and speed among the different Python XML parsers.
  prefs: []
  type: TYPE_NORMAL
- en: The minidom module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python `minidom` module is a very old and simple to use XML parser. It is
    part of Python's built-in set of XML tools in the XML package. It can parse XML
    files or XML that's been fed in as a string. The `minidom` module is best for
    small to medium-sized XML documents of less than about 20 MB before speed begins
    to decrease.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the `minidom` module, we''ll use a sample KML file, which is
    a part of Google''s KML documentation that you can download. The data that''s
    available at the following link represents time-stamped point locations that have
    been transferred from a GPS device: [https://github.com/GeospatialPython/Learn/raw/master/time-stamp-point.kml](https://github.com/GeospatialPython/Learn/raw/master/time-stamp-point.kml).
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll parse this data by reading it in from the file and creating a
    `minidom` parser object. The file contains a series of `<Placemark>` tags, which
    contain a point and a timestamp at which that point was collected. So, we''ll
    get a list of all of the `Placemarks` in the file, and we can count them by checking
    the length of that list, as shown in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we retrieved all `Placemarks`, which totaled `361`. Now, let''s
    take a look at the first `Placemark` element in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `<Placemark>` tag is now a DOM element data type. To really see what that
    element is, we call the `toxml()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `toxml()` function outputs everything contained in the `Placemark` tag as
    a string object. If we want to print this information to a text file, we can call
    the `toprettyxml()` method, which would add additional indentation to make the
    XML more readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, what if we want to grab just the coordinates from this placemark? The coordinates
    are buried inside the `coordinates` tag, which is contained in the `point` tag
    and nested inside the `Placemark` tag. Each element of a `minidom` object is called
    a **node**. Nested nodes are called children or child nodes. The child nodes include
    more than just tags – they can also include whitespace separating tags, as well
    as the data inside the tags. So, we can drill down to the `coordinates` tag using
    the tag name, but then we'll need to access the `data` node. All the `minidom`
    elements have `childNodeslist`, as well as a `firstChild()` method to access the
    first node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll combine these methods to get to the `data` attribute of the first coordinate''s
    `data` node, which we reference using index `0` in the list of coordinate stags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you're new to Python, you'll notice that the text output in these examples
    is tagged with the letter `u`. This markup is how Python denotes Unicode strings
    that support internationalization to multiple languages with different character
    sets. Python 3.4.3 changes this convention slightly and leaves Unicode strings
    unmarked while marking UTF-8 strings with a `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can go a little further and convert this `point` string into usable data
    by splitting the string and converting the resulting strings into Python float
    types, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Python list comprehension, we can perform this operation in a single
    step, as you can see in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This example scratches the surface of what the `minidom` library can do. For
    a great tutorial on this library, have a look at the following tutorial: [https://www.edureka.co/blog/python-xml-parser-tutorial/](https://www.edureka.co/blog/python-xml-parser-tutorial/).'
  prefs: []
  type: TYPE_NORMAL
- en: ElementTree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `minidom` module is pure Python, easy to work with, and has been around
    since Python 2.0\. However, Python 2.5 added a more efficient yet high-level XML
    parser to the standard library called `ElementTree`. `ElementTree` is interesting
    because it has been implemented in multiple versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a pure Python version and a faster version written in C called `cElementTree`.
    You should use `cElementTree` wherever possible, but it''s possible that you may
    be on a platform that doesn''t include the C-based version. When you import `cElementTree`,
    you can test to see if it''s available and fall back to the pure Python version
    if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: One of the great features of `ElementTree` is its implementation of a subset
    of the XPath query language. XPath is short for XML Path and allows you to search
    an XML document using a path-style syntax. If you work with XML frequently, learning
    XPath is essential. You can learn more about XPath at the following link: [https://www.w3schools.com/xml/xpath_intro.asp](https://www.w3schools.com/xml/xpath_intro.asp).
  prefs: []
  type: TYPE_NORMAL
- en: One catch with this feature is that if the document specifies a namespace, as
    most XML documents do, you must insert that namespace into queries. `ElementTree`
    does not automatically handle the namespace for you. Your options are to manually
    specify it or try to extract it using string parsing from the root element's tag
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll repeat the `minidomXML` parsing example using `ElementTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll parse the document and then we'll manually define the KML namespace;
    later, we'll use an XPath expression and the `find()` method to find the first
    `Placemark` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we'll find the coordinates and the child node and then grab the text
    containing the latitude and longitude.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In both cases, we could have searched directly for the `coordinates` tag. But,
    by grabbing the `Placemark` element, it gives us the option of grabbing the corresponding
    timestamp child element later, if we so choose, as shown in the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, notice that we used the Python string formatting syntax, which
    is based on the string formatting concept found in C. When we defined the XPath
    expression for the placemark variable, we used the `%` placeholder to specify
    the insertion of a string. Then, after the string, we used the `%` operator followed
    by a variable name to insert the `ns` namespace variable where the placeholder
    is. In the `coordinates` variable, we used the `ns` variable twice, so we specified
    a tuple containing `ns` twice after the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'String formatting is a simple yet extremely powerful and useful tool in Python
    that''s worth learning. You can find more information in Python''s documentation
    online at the following link: [https://docs.python.org/3.4/library/string.html](https://docs.python.org/3.4/library/string.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Building XML using ElementTree and Minidom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the time, XML can be built by concatenating strings, as you can see
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this method can be quite prone to typos, which creates invalid XML
    documents. A safer way is to use an XML library. Let''s build this simple KML
    document using `ElementTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll define the `rootKML` element and assign it a namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''ll systematically append sub elements to the root, wrap the elements
    as an `ElementTree` object, declare the XML encoding, and write it out to a file
    called `placemark.xml`, as shown in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The output is identical to the previous string building example, except that
    `ElementTree` does not indent the tags but rather writes it as one long string.
    The `minidom` module has a similar interface, which is documented in the book
    *Dive Into Python*, by Mark Pilgrim, which was referenced in the `minidom` example
    that we just saw.
  prefs: []
  type: TYPE_NORMAL
- en: XML parsers such as `minidom` and `ElementTree` work very well on perfectly
    formatted XML documents. Unfortunately, the vast majority of XML documents out
    there don't follow these rules and contain formatting errors or invalid characters.
    You'll find that you are often forced to work with this data and must resort to
    extraordinary string parsing techniques to get the small subset of data you actually
    need. But thanks to Python and Beautiful Soup, you can elegantly work with bad
    and even terrible tag-based data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beautiful Soup is a module that was specifically designed to robustly handle
    broken XML. It is oriented toward HTML, which is notorious for incorrect formatting
    but works with other XML dialects too. Beautiful Soup is available on PyPI, so
    use either `easy_install` or `pip` to install it, as you can see in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to use it, you simply import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: To try it out, we'll use a **GPS Exchange Format** (**GPX**) tracking file from
    a smartphone application, which has a glitch and exports slightly broken data.
    You can download this sample file from [https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx](https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx).
  prefs: []
  type: TYPE_NORMAL
- en: 'This 2,347-line data file is in pristine condition except that it is missing
    a closing `</trkseg>` tag, which should be located at the very end of the file,
    just before the closing `</trk>` tag. This error was caused by a data export function
    in the source program. This defect is most likely a result of the original developer
    manually generating the GPX XML on export and forgetting the line of code that
    adds this closing tag. Watch what happens if we try to parse this file with `minidom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the last line in the error message, the underlying XML parser
    in `minidom` knows exactly what the problem is – a `mismatched` tag right at the
    end of the file. However, it refused to do anything more than report the error.
    You must have perfectly formed XML or none at all to avoid this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try the more sophisticated and efficient `ElementTree` module with
    the same data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, different parsers face the same problem. Poorly formed XML
    is an all too common reality in geospatial analysis, and every XML parser assumes
    that all the XML in the world is perfect, except for one. Enter Beautiful Soup.
    This library shreds bad XML into usable data without a second thought, and it
    can handle far worse defects than missing tags. It will work despite missing punctuation
    or other syntax and will give you the best data it can. It was originally developed
    for parsing HTML, which is notoriously horrible for being poorly formed, but it
    works fairly well with XML as well, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'No complaints from Beautiful Soup! Just to make sure the data is actually usable,
    let''s try and access some of the data. One of the fantastic features of Beautiful
    Soup is that it turns tags into attributes of the parse tree. If there are multiple
    tags with the same name, it grabs the first one. Our sample data file has hundreds
    of `<trkpt>` tags. Let''s access the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now certain that the data has been parsed correctly and that we can
    access it. If we want to access all of the `<trkpt>` tags, we can use the `findAll()`
    method to grab them and then use the built-in Python `len()` function to count
    them, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we write the parsed data back out to a file, Beautiful Soup outputs the
    corrected version. We''ll save the fixed data as a new GPX file using Beautiful
    Soup module''s `prettify()` method to format the XML with nice indentation, as
    you can see in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Beautiful Soup is a very rich library with many more features. To explore it
    further, visit the Beautiful Soup documentation online at [http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html](http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html).
  prefs: []
  type: TYPE_NORMAL
- en: While `minidom`, `ElementTree`, and `cElementTree` come with the Python standard
    library, there is an even more powerful and popular XML library for Python called
    `lxml`. The `lxml` module provides a Pythonic interface to the `libxml2` and `libxslt`
    C libraries using the `ElementTree` API. An even better fact is that `lxml` also
    works with Beautiful Soup to parse bad tag-based data. On some installations,
    `beautifulsoup4` may require `lxml.` The `lxml` module is available via PyPI but
    requires some additional steps for the C libraries. More information is available
    on the `lxml` home page at the following link: [http://lxml.de/](http://lxml.de/).
  prefs: []
  type: TYPE_NORMAL
- en: Well-Known Text (WKT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WKT format has been around for years and is a simple text-based format
    for representing geometries and spatial reference systems. It is primarily used
    as a data exchange format by systems that implement the OGC Simple Features for
    SQL specification. Take a look at the following sample WKT representation of a
    polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Currently, the best way to read and write WKT is by using the Shapely library.
    Shapely provides a very Python-oriented or Pythonic interface to the **Geometry
    Engine - Open Source** (**GEOS**) library we described in [Chapter 3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml),
    *The Geospatial Technology Landscape*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Shapely using either `easy_install` or `pip`. You can also
    use the wheel from the site we mentioned in the previous section. Shapely has
    a WKT module which can load and export this data. Let''s use Shapely to load the
    previous polygon sample and then verify that it has been loaded as a polygon object
    by calculating its area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert any Shapely geometry back into a WKT by simply calling its `wkt`
    attribute, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Shapely can also handle the WKT binary counterpart called W**ell-Known Binary**
    (**WKB**), which is used to store WKT strings as binary objects in databases.
    Shapely loads WKB using its `wkb` module in the same way as the `wkt` module,
    and it can convert geometries by calling that object's `wkb` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Shapely is the most Pythonic way to work with WKT data, but you can also use
    the Python bindings to the OGR library, which we installed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we''ll use a shapefile with one simple polygon, which can
    be downloaded as a ZIP file. It is available at the following link: [https://github.com/GeospatialPython/Learn/raw/master/polygon.zip](https://github.com/GeospatialPython/Learn/raw/master/polygon.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll open the `polygon.shp` file from the shapefile
    dataset, call the required `GetLayer()` method, get the first (and only) feature,
    and then export it to WKT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that with OGR, you would have to read access each feature and export it
    individually, since the `ExporttoWkt()` method is at the feature level. We can
    now turn around and read a WKT string using the `wkt` variable containing the
    export. We''ll import it back into `ogr` and get the bounding box, also known
    as an envelope, of the polygon, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Shapely and OGR are used for reading and writing valid WKT strings. Of course,
    just like XML, which is also text, you could manipulate small amounts of WKT as
    strings in a pinch.  Next, we'll look at a modern text format that is becoming
    very common in the geospatial world.
  prefs: []
  type: TYPE_NORMAL
- en: Python JSON libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is rapidly becoming the number one
    data exchange format across a lot of fields. The lightweight syntax and its similarity
    to existing data structures in both the JavaScript that Python borrows some data
    structures from, as well as JavaScript itself, make it a perfect match for Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following GeoJSON sample document contains a single point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This sample is just a simple point with new attributes, which would be stored
    in the properties data structure of the geometry. In the preceding example, the
    ID, coordinates, and CRS information would change depending on your particular
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify this sample GeoJSON document using Python. First, we''ll compact
    the sample document into a single string to make it easier to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use the GeoJSON `jsdata` string variable we created in the preceding
    code, in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: The json module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GeoJSON looks very similar to a nested set of Python''s dictionaries and lists.
    Just for fun, let''s just try and use Python''s `eval()` function to parse it
    as Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Wow! That worked! We turned that random GeoJSON string into native Python data
    in one easy step. Keep in mind that the JSON data format is based on JavaScript
    syntax, which happens to be similar to Python. Also, as you get deeper into GeoJSON
    data and work with larger data, you'll find that JSON allows characters that Python
    does not. Using Python's `eval()` function is considered very insecure as well.
    But as far as keeping things simple is concerned, note that it doesn't get any
    simpler than that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to Python''s drive toward simplicity, the more advanced method doesn''t
    get much more complicated. Let''s use Python''s `json` module, which is part of
    the standard library, to turn the same string into Python the right way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As a side note, in the previous example, the CRS84 property is a synonym for
    the common WGS84 coordinate system. The `json` module adds some nice features
    such as safer parsing and conversion of strings into Unicode. We can export Python
    data structures to JSON in almost the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When you dump data, it comes out as one long string that''s difficult to read.
    There''s a way we can print the data so it is easier to read: by passing the `dumps()`
    method an indent value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand `json` module, let's look at the geospatial version called
    `geojson`.
  prefs: []
  type: TYPE_NORMAL
- en: The geojson module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We could happily go on reading and writing GeoJSON data using the `json` module
    forever, but there''s an even better way. The `geojson` module that''s available
    on PyPI offers some distinct advantages. For starters, it knows the requirements
    of the GeoJSON specification, which can save a lot of typing. Let''s create a
    simple point using this module and export it to GeoJSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, when we dump the JSON data for viewing, we''ll add an indent argument
    with a value of `4` so that we get nicely indented JSON data that''s easier to
    read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `geojson` module has an interface for different data types and
    saves us from setting the type and coordinates attributes manually. Now, imagine
    if you had a geographic object with hundreds of features. You could programmatically
    build this data structure instead of building a very large string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `geojson` module is also the reference implementation for the Python `geo_interface`
    convention. This interface allows cooperating programs to exchange data seamlessly
    and in a Pythonic way without the programmer explicitly exporting and importing
    GeoJSON strings. So, if we wanted to feed the point we created with the `geojson`
    module to the Shapely module, we could perform the following command, which reads
    the `geojson` module''s point object straight into Shapely, after which we''ll
    export it as WKT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: More and more geospatial Python libraries are implementing both the `geojson`
    and `geo_interface` functionality, including PyShp, Fiona, Karta, and ArcGIS.
    Third-party implementations exist for QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON is a simple text format that is human and computer-readable. Now, we'll
    look at some binary vector formats.
  prefs: []
  type: TYPE_NORMAL
- en: OGR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched on OGR as a way to handle WKT strings, but its real power is as a
    universal vector library. This book strives for pure Python solutions, but no
    single library even comes close to the variety of formats that OGR can process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s read a sample point shapefile using the OGR Python API. The sample shapefile
    can be downloaded as a ZIP file here: [https://github.com/GeospatialPython/Learn/raw/master/point.zip](https://github.com/GeospatialPython/Learn/raw/master/point.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This point shapefile has five points with single digit, positive coordinates.
    The attributes list the order in which the points were created, making it useful
    for testing. This simple example will read in the point shapefile and loop through
    each feature; then, it will print the *x* and *y* values of each point, plus the
    value of the first attribute field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This example is simple, but OGR can become quite verbose as your script becomes
    more complex. Next, we'll look at a simpler way to deal with shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: PyShp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyShp is a simple, pure Python library that reads and writes shapefiles. It
    doesn't perform any geometry operations and only uses Python's standard library.
    It's contained in a single file that's easy to move around, squeeze onto small
    embedded platforms, and modify. It is also compatible with Python 3\. It also
    implements `__geo_interface__`. The PyShp module is available on PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s repeat the previous OGR example with PyShp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: dbfpy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both OGR and PyShp read and write the `.dbf` files because they are part of
    the shapefile specification. The `.dbf` files contain the attributes and fields
    for the shapefiles. However, both libraries have very basic `.dbf` support. Occasionally,
    you will need to do some heavy-duty DBF work. The `dbfpy3` module is a pure Python
    module dedicated to working with `.dbf` files. It is currently hosted on GitHub.
    You can force `easy_install` to find the download by specifying the download file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using `pip` to install packages, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The following shapefile has over 600 `.dbf` records representing US Census Bureau
    tracts, which make it a good sample for trying out `dbfpy`: [https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip](https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up the `.dbf` file of this shapefile and look at the first record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The module quickly and easily gives us both the column names and data values
    together, as opposed to handling them as separate lists, so that they''re easier
    to manage. Now, let''s increment the population field contained in `POPULAT10`
    by `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that both OGR and PyShp can do this same procedure, but `dbfp3y`
    makes it a little easier if you are only making a lot of changes to the .dbf files.
  prefs: []
  type: TYPE_NORMAL
- en: Shapely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shapely was mentioned in the **Well-Known Text** (**WKT**) section for its import
    and exportability. However, its true purpose is as a generic geometry library.
    Shapely is a high-level, Pythonic interface to the GEOS library for geometric
    operations. In fact, Shapely intentionally avoids reading or writing files. It
    relies completely on data import and export from other modules and maintains focus
    on geometry manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a quick Shapely demonstration in which we''ll define a single WKT
    polygon and then import it into Shapely. Then, we''ll measure the area. Our computational
    geometry will consist of buffering that polygon by a measure of five arbitrary
    units, which will return a new, bigger polygon for which we''ll measure the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then perform a difference in the area of the buffer and the original
    polygon area, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If you can't have pure Python, a Pythonic API as clean as Shapely that packs
    such a punch is certainly the next best thing.
  prefs: []
  type: TYPE_NORMAL
- en: Fiona
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fiona library provides a simple Python API around the OGR library for data
    access and nothing more. This approach makes it easy to use and is less verbose
    than OGR while using Python. Fiona outputs GeoJSON by default. You can find a
    wheel file for Fiona at [http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona](http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona).
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we'll use the `GIS_CensusTract_poly.shp` file from the `dbfpy`
    example we looked at earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import `fiona` and Python''s `pprint` module to format the output.
    Then, we''ll open the shapefile and check its driver type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: ESRI shapefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we''ll check its coordinate reference system and get the data bounding
    box, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll view the data schema as `geojson` and format it using the `pprint`
    module, as you can see in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s get a count of the number of features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll print one of the records as formatted GeoJSON, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: GDAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GDAL is the dominant geospatial library for raster data. Its raster capability
    is so significant that it is a part of virtually every geospatial toolkit in any
    language, and Python is no exception to this. To see the basics of how GDAL works
    in Python, download the following sample raster satellite image as a ZIP file
    and unzip it: [https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip](https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip).
    Let''s open this image and see how many bands it has and how many pixels are present
    along each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'By viewing it in OpenEV, we can see that the following image has three bands,
    2,592 columns of pixels, and 2,693 rows of pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1831299e-4500-49f1-8ef2-f8ee35f21442.png)'
  prefs: []
  type: TYPE_IMG
- en: GDAL is an extremely fast geospatial raster reader and writer within Python.
    It can also reproject images quite well in addition to being able to do a few
    other tricks. However, the true value of GDAL comes from its interaction with
    the next Python module, which we'll examine now.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy is an extremely fast, multidimensional Python array processor designed
    specifically for Python and scientific computing but is written in C. It is available
    via PyPI or as a wheel file (available at [http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy))
    and can be installed with ease. In addition to its amazing speed, the magic of
    NumPy includes its interaction with other libraries. NumPy can exchange data with
    GDAL, Shapely, the **Python Imaging Library** (**PIL**), and many other scientific
    computing Python libraries in other fields.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick example of NumPy's ability, we'll combine it with GDAL to read in
    our sample satellite image and then create a histogram of it. The interface between
    GDAL and NumPy is a GDAL module called `gdal_array`, which has NumPy as a dependency.
    Numeric is the legacy name of the NumPy module. The `gdal_array` module imports
    NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll use `gdal_array`, which imports NumPy, to
    read the image in as an array, grab the first band, and save it as a JPEG image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation gives us the following grayscale image in OpenEV:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e69e56e-1fcd-4829-9bbd-e3f7e5e1e51e.png)'
  prefs: []
  type: TYPE_IMG
- en: PIL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PIL was originally developed for remote sensing but has evolved as a general
    image editing library for Python. Like NumPy, it is written in C for speed but
    is designed specifically for Python. In addition to image creation and processing,
    it also has a useful raster drawing module. PIL is also available via PyPI; however,
    in Python 3, you may want to use the Pillow module, which is an upgraded version
    of PIL. As you'll see in the following example, we can use a Python try statement
    to import PIL using two possible variations, depending on how you installed it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll combine PyShp and PIL to rasterize the `hancock` shapefile
    from the previous examples and save it as an image. We''ll use a world to pixel
    coordinate transformation similar to our SimpleGIS from [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*. We''ll create an image to use
    as a canvas in PIL, and then we''ll use the PIL `ImageDraw` module to render the
    polygon. Finally, we''ll save it as a PNG image, as you can see in the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This example creates the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe5e5ae1-a9ff-4c7e-b9e1-fa1da206b56b.png)'
  prefs: []
  type: TYPE_IMG
- en: PNGCanvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may find that PIL is overkill for your purposes, or you are not
    allowed to install PIL because you do not have administrative rights to the machine
    that you're using to install Python modules that have been created and compiled
    in C. In those cases, you can usually get away with the lightweight pure Python
    PNGCanvas module. You can install it using `easy_install` or pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this module, we can repeat the raster shapefile example we performed
    using PIL but in pure Python, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This example gives us a simple outline as PNGCanvas does not have a built-in
    fill method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5135eda-4450-4838-8565-64ba2695193f.png)'
  prefs: []
  type: TYPE_IMG
- en: GeoPandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas is a high-performance Python data analysis library that can handle large
    datasets that are tabular (similar to a database), ordered/unordered, labeled
    matrices, or unlabeled statistical data. GeoPandas is simply a geospatial extension
    to Pandas that builds upon Shapely, Fiona, PyProj, Matplotlib, and Descartes,
    all of which must be installed. It allows you to easily perform operations in
    Python, which would otherwise require a spatial database such as PostGIS. You
    can download a wheel file for GeoPandas from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda](http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script opens a shapefile and dumps it into GeoJSON. Then, it
    creates a map with `matplotlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image is the resulting map plot of the previous commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/930444cb-0f37-407e-875f-dc4c5398b1ff.png)'
  prefs: []
  type: TYPE_IMG
- en: PyMySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The popular MySQL (available at [http://dev.mysql.com/downloads](http://dev.mysql.com/downloads))
    database is gradually evolving spatial functions. It has support for OGC geometries
    and a few spatial functions. It also has a pure Python API available in the PyMySQL
    library. The limited spatial functions use planar geometry and bounding rectangles
    as opposed to spherical geometry and shapes. The latest development release of
    MySQL contains some additional functions that improve this capability.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we'll create a database in MySQL called `spatial_db`.
    Then, we'll add a table called `PLACES` with a geometry column. Next, we'll add
    two cities as point locations. Finally, we'll calculate the distance using MySQL's
    `ST_Distance` function and then convert the result from degrees into miles.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import our `mysql` library and set up the database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we get the database cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we check if the database already exists, and drop it if it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we set up a new connection and get a cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create our new table and add our fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'With the fields added, we are ready to insert records for the location of some
    cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can commit changes to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can query the database! First, we''ll get a list of all of the point
    locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll extract the two points from the query results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can measure the distance, we need to convert the point listings into
    geospatial geometries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the `Distance` stored procedure to measure the distance
    between the two geometries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: There are other spatial database options available, including PostGIS and SpatiaLite;
    however, Python 3 support for these spatial engines is developmental at best.
    You can access PostGIS and MySQL through the OGR library; however, MySQL support
    is limited.
  prefs: []
  type: TYPE_NORMAL
- en: PyFPDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pure Python PyFPDF library is a lightweight way to create PDFs, including
    maps. Because the PDF format is a widely used standard, PDFs are commonly used
    to distribute maps. You can install it via PyPI as `fpdf`. The official name of
    the software is PyFPDF because it is a part of the PHP language module called `fpdf`.
    This module uses a concept called a cell to lay items out at specific locations
    on a page. As a quick example, we''ll import the `hancock.png` image we created
    from the PIL example into a PDF called `map.pdf` to create a simple PDF map. The
    map will have the header text at the top that says Hancock County Boundary, followed
    by the map image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: If you open the PDF file named `map.pdf` in Adobe Acrobat Reader or another
    PDF reader such as Sumatra PDF, you'll see that the image is now centered on an
    A4 page. Geospatial products are often included as part of larger reports, and
    the PyFPDF module simplifies automatically generating reports as PDFs.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial PDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Portable Document Format**, or **PDF**, is a file format for storing and
    presenting digitally-formatted text and images in a cross-platform and application-independent
    way. PDF is a widely used document format that has also been extended to store
    geospatial information.
  prefs: []
  type: TYPE_NORMAL
- en: The PDF specification, starting with version 1.7, includes extensions for geospatial
    PDFs that map portions of the document to a physical space, also known as georeferencing.
    You can create points, lines, or polygons as geospatial geometries, which can
    also have attributes.
  prefs: []
  type: TYPE_NORMAL
- en: There are two methods for encoding geospatial information within a PDF. A company
    named TerraGo created a specification that has been adopted by the Open Geospatial
    Consortium as a best practice which is not a standard. That format is known as
    **GeoPDF**. The extensions that were proposed by Adobe Systems, which created
    the PDF specification known as ISO 32000, are currently being incorporated into
    the 2.0 version of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: The geospatial PDF products by TerraGo conform to the OGC best practice document
    and the Adobe PDF extension. But TerraGo goes beyond those features to include
    layers and other GIS functionality. However, you must use TerraGo's plugins for
    Adobe Acrobat or other software to access that functionality. At a minimum, TerraGo
    supports the features that are needed to at least display in any PDF software.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, there is a library called `geopdf` which has nothing to do with TerraGo
    but does support the OGC best practice. This library was originally developed
    by Tyler Garner of Prominent Edge ([https://prominentedge.com/](https://prominentedge.com/))
    for Python 2\. It has been ported to Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing `geopdf` from GitHub is as simple as running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example recreates the map we created in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, in the *Simple GIS* section
    as a geospatial PDF. The `geopdf` library relies on the Python ReportLab PDF library.
    The steps we will need to execute are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a PDF drawing canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a rectangle for the state of Colorado.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a function to convert map coordinates into screen coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw and label the cities and populations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the corners of the state as geospatial PDF coordinates that georeference
    the entire map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Python code''s comments explain what''s happening in each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Rasterio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GDAL library we introduced earlier in this chapter is extremely powerful,
    but it wasn't designed for Python. The `rasterio` library solves that problem
    by wrapping GDAL in a very simple, clean Pythonic API for raster data operations.
  prefs: []
  type: TYPE_NORMAL
- en: This example uses the satellite image from the GDAL example in this chapter.
    We'll open the image and get some metadata, like the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: OSMnx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `osmnx` library combines **Open Street Map** (**OSM**) and the powerful
    NetworkX library to manage street networks used for routing. This library has
    dozens of dependencies which it rolls up to do all of the complex steps of downloading,
    analyzing, and visualizing street networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try to install `osmnx` using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: However, you may run into some installation issues due to the dependencies.
    In that case, it's easier to use the Conda system, which we'll introduce later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses `osmnx` to download street data from OSM for a city,
    creates a street network from it, and calculates some basic statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jupyter project is something you should be aware of when working with geospatial
    or other scientific data. The Jupyter Notebook app creates and displays notebook
    documents in a web browser that are human-readable and machine-executable code
    and data. It's great for sharing tutorials for software and has become very common
    in the geospatial Python world.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a good introduction for Jupyter Notebooks and Python here: [https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html](https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html).
  prefs: []
  type: TYPE_NORMAL
- en: Conda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conda is an open source package management system that makes installing and
    updating complex libraries easier. It works with several languages, including
    Python. Conda is very useful for setting up libraries and testing them so that
    we can try out new things in a development environment. It's usually better to
    custom configure production environments, but Conda is a great way to prototype
    new ideas.
  prefs: []
  type: TYPE_NORMAL
- en: You can get started with Conda at [https://conda.io/en/latest/](https://conda.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we surveyed the Python-specific tools for geospatial analysis.
    Many of these tools included bindings to the libraries we discussed in [Chapter
    3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml), *The Geospatial Technology Landscape*,
    for best-of-breed solutions for specific operations such as GDAL's raster access
    functions. We also included pure Python libraries as much as possible and will
    continue to include pure Python algorithms as we work through the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll begin applying all of these tools for GIS analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links will allow you to explore the topics in this chapter further.
    The first link is about the XPath query language, which we used to filter XML
    elements using Elementree. The second link is the documentation for the Python
    string library, which will be critical throughout this book for manipulating data.
    Third, we have the `lxml` library, one of the more powerful and fast XML libraries. Finally,
    we have Conda, which provides a comprehensive, easy-to-use framework for scientific
    operations in Python, including geospatial technology:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on XPath, check out the following link: [http://www.w3schools.com/xsl/xpath_intro.asp](http://www.w3schools.com/xsl/xpath_intro.asp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more details on the Python `string` module, check out the following link:
    [https://docs.python.org/3.4/library/string.html](https://docs.python.org/3.4/library/string.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation on LXML can be found at the following link: [http://lxml.de/](http://lxml.de/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about Conda at the following link: [https://conda.io/en/latest/](https://conda.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
