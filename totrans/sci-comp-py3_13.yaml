- en: Chapter 13. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on two aspects of testing for scientific programming.
    The first aspect is the often difficult topic of what to test in scientific computing.
    The second aspect covers the question of how to test. We will distinguish between
    manual and automated testing. Manual testing is what is done by every programmer
    to quickly check that an implementation is working or not. Automated testing is
    the refined, automated variant of that idea. We will introduce some tools available
    for automatic testing in general, with a view on the particular case of scientific
    computing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the development of code, you do a lot of small tests in order to test
    its functionality. This could be called manual testing. Typically, you would test
    if a given function does what it is supposed to do, by manually testing the function
    in an interactive environment. For instance, suppose that you implement the bisection
    algorithm. It is an algorithm that finds a zero (root) of a scalar non-linear
    function. To start the algorithm, an interval has to be given with the property
    that the function takes different signs on the interval boundaries, see *Exercise
    4*, [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*, for more information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then test an implementation of that algorithm, typically by checking
    that:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: A solution is found when the function has opposite signs at the interval boundaries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception is raised when the function has the same sign at the interval boundaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual testing, as necessary as it may seem to be, is unsatisfactory. Once you
    have convinced yourself that the code does what it is supposed to do, you formulate
    a relatively small number of demonstration examples to convince others of the
    quality of the code. At that stage, one often looses interest in the tests made
    during development and they are forgotten or even deleted. As soon as you change
    a detail and things no longer work correctly, you might regret that your earlier
    tests are no longer available.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Automatic testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The correct way to develop any piece of code is to use automatic testing. The
    advantages are:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The automated repetition of a large number of tests after every code refactoring and
    before any new versions are launched.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A silent documentation of the use of the code.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A documentation of the test coverage of your code: Did things work before a
    change or was a certain aspect never tested?'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changes in the program and in particular in its structure which do not affect
    its functionality are called code refactoring.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: We suggest developing tests in parallel to the code. Good design of tests is
    an art of its own and there is rarely an investment which guarantees such a good
    pay-off in development time savings as the investment in good tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Now we will go through the implementation of a simple algorithm with the automated
    testing methods in mind.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Testing the bisection algorithm
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us examine automated testing for the bisection algorithm. With this algorithm,
    a zero of a real valued function is found. It is described section *Exercise 4*
    in [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*. An implementation
    of the algorithm can have the following form:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查二分算法的自动化测试。使用这个算法，可以找到一个实值函数的零点。它描述在 [第 7 章](ch07.html "第 7 章。函数") 的 *练习
    4* 中，*函数* 部分。算法的实现可以有以下形式：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We assume this to be stored in the `bisection.py` file. As the first test case,
    we test that the zero of the function *f*(*x*) = *x* is found:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设这被存储在 `bisection.py` 文件中。作为第一个测试用例，我们测试函数 *f*(*x*) = *x* 的零点是否被找到：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, you meet the Python keyword `assert` for the first time. It raises `AssertionError`
    exception if its first argument returns the `False` value. Its optional second
    argument is a string with additional information. We use the function `allclose`
    in order to test for equality of floats.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你第一次遇到了 Python 关键字 `assert`。如果它的第一个参数返回 `False` 值，它将抛出 `AssertionError`
    异常。它的可选第二个参数是一个包含额外信息的字符串。我们使用 `allclose` 函数来测试浮点数的相等性。
- en: Let us comment on some of the features of the test function. We use an assertion
    to make sure that an exception will be raised if the code does not behave as expected.
    We have to manually run the test in the `test_identity()` line.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们评论一下测试函数的一些特性。我们使用断言来确保如果代码的行为不符合预期，将会抛出异常。我们必须在 `test_identity()` 行手动运行测试。
- en: There are many tools to automate this kind of call.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以自动化这种类型的调用。
- en: 'Let us now set up a test that checks if `bisect` raises an exception when the
    function has the same sign on both ends of the interval. For now, we will suppose
    that the exception raised is a `ValueError` exception. In the following example,
    we will check the initial interval [*a*,*b*]. For the bisection algorithm it should
    fulfill a sign condition:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置一个测试来检查如果函数在区间的两端具有相同的符号，`bisect` 是否会抛出异常。目前，我们将假设抛出的异常是 `ValueError`
    异常。在下面的例子中，我们将检查初始区间 [*a*,*b*]。对于二分算法，它应该满足符号条件：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, an `AssertionError` is raised if the exception is not of the `ValueError` type
    . There are tools to simplify the preceding construction to check that an exception
    is raised.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果异常不是 `ValueError` 类型，将会抛出 `AssertionError`。有一些工具可以简化前面的构造来检查是否抛出了异常。
- en: Another useful test is the edge case test. Here we test arguments or user input,
    which is likely to create mathematically undefined situations or states of the
    program not foreseen by the programmer. For instance, what happens if both bounds
    are equal? What happens if *a > b*?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的测试是边缘情况测试。在这里，我们测试可能创建数学上未定义的情况或程序状态的参数或用户输入。例如，如果两个边界相等会发生什么？如果 *a >
    b* 会发生什么？
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using unittest package
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 unittest 包
- en: 'The standard `unittest` Python package greatly facilitates automated testing.
    This package requires that we rewrite our tests to be compatible. The first test
    would have to be rewritten in a `class`, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 `unittest` Python 包极大地简化了自动化测试。此包要求我们重写我们的测试以兼容。第一个测试将必须重写为一个 `class`，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s examine the differences to the previous implementation. First, the test
    is now a method and a part of a class. The class must inherit from `unittest.TestCase`.
    The test method''s name must start with `test`. Note that we may now use one of
    the assertion tools of the `unittest` package, namely `assertAlmostEqual`. Finally,
    the tests are run using `unittest.main`. We recommend to write the tests in a
    file separate from the code to be tested. That is why it starts with an `import`.
    The test passes and returns as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看与之前实现的差异。首先，测试现在是一个方法和类的一部分。该类必须继承自 `unittest.TestCase`。测试方法的名字必须以 `test`
    开头。请注意，我们现在可以使用 `unittest` 包中的一个断言工具，即 `assertAlmostEqual`。最后，测试是通过 `unittest.main`
    运行的。我们建议将测试写在与被测试代码分开的文件中。这就是为什么它以一个 `import` 开头。测试通过并返回如下：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run it with a loose tolerance parameter, for example, `1.e-3`, a failure
    of the test would have been reported:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用一个宽松的容差参数运行它，例如 `1.e-3`，测试失败将会被报告：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Tests can and should be grouped together as methods of a test class, as given
    in the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以也应该作为测试类的方法分组，如下面的例子所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, in the last test we used the method `unittest.TestCase.assertRaises`.
    It tests whether an exception is correctly raised. Its first parameter is the
    exception type, for example, `ValueError`, `Exception`, and its second argument
    is the name of the function, which is expected to raise the exception. The remaining
    arguments are the arguments for this function. The command `unittest.main()` creates
    an instance of the `TestIdentity` class and executes those methods starting with `test`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个测试中，我们使用了 `unittest.TestCase.assertRaises` 方法。它测试是否正确地引发了异常。它的第一个参数是异常类型，例如，`ValueError`，`Exception`，第二个参数是预期引发异常的函数名称。其余参数是该函数的参数。`unittest.main()`
    命令创建 `TestIdentity` 类的实例并执行以 `test` 开头的方法。
- en: Test setUp and tearDown methods
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 `setUp` 和 `tearDown` 方法
- en: 'The class `unittest.TestCase` provides two special methods, `setUp` and `tearDown`,
    which run before and after every call to a test method. This is needed when testing
    generators, which are exhausted after every test. We demonstrate this by testing
    a program which checks the line in a file in which a given string occurs for the
    first time:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.TestCase` 类提供了两个特殊方法，`setUp` 和 `tearDown`，它们在每次调用测试方法之前和之后运行。当测试生成器时，这是必需的，因为每次测试后生成器都会耗尽。我们通过测试一个检查给定字符串首次出现的文件行的程序来演示这一点：'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We assume that this code is saved in the `find_in_file.py` file. A test has
    to prepare a file and open it and remove it after the test as given in the following
    example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设此代码保存在 `find_in_file.py` 文件中。测试必须准备一个文件，打开它，并在测试后删除它，如下例所示：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before each test `setUp` is run and then `tearDown` is executed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试之前运行 `setUp` 然后执行 `tearDown`。
- en: Parameterizing tests
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化测试
- en: 'One frequently wants to repeat the same test with different data sets. When
    using the functionalities of `unittest` this requires us to automatically generate
    test cases with the corresponding methods injected:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要用不同的数据集重复相同的测试。当使用 `unittest` 的功能时，这要求我们自动生成带有相应方法的测试用例：
- en: To this end, we first construct a test case with one or several methods that
    will be used, when we later set up test methods. Let's consider the bisection
    method again and let's check if the values it returns are really zeros of the
    given function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们首先构建一个测试用例，其中包含一个或多个将要使用的方法，当我们后来设置测试方法时。让我们再次考虑二分法，并检查它返回的值是否真的是给定函数的零点。
- en: 'We first build the test case and the method which we will use for the tests
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建测试用例和我们将用于测试的方法，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we dynamically create test functions as attributes of this class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们动态创建测试函数作为此类的属性：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the data is provided as a list of dictionaries. The `make_test_function`
    function dynamically generates a test function, which uses a particular data dictionary
    to perform the test with the previously defined method `checkifzero`. Finally,
    the command `setattr` is used to make these test functions methods of the class
    `Tests`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，数据以字典列表的形式提供。`make_test_function` 函数动态生成一个测试函数，该函数使用特定的数据字典，使用先前定义的方法 `checkifzero`
    进行测试。最后，使用 `setattr` 命令将这些测试函数作为 `Tests` 类的方法。
- en: Assertion tools
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言工具
- en: 'In this section, we collect the most important tools for raising an `AssertionError`.
    We saw the `assert` command and two tools from `unittest`, namely `assertAlmostEqual`. The
    following table (*Table 13.1*) summarizes the most important assertion tools and
    the related modules:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们收集了引发 `AssertionError` 的最重要的工具。我们看到了 `assert` 命令和来自 `unittest` 的两个工具，即
    `assertAlmostEqual`。以下表格（*表13.1*）总结了最重要的断言工具和相关模块：
- en: '| **Assertion tool and application example** | **Module** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **断言工具和应用示例** | **模块** |'
- en: '| `assert 5==5` | – |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `assert 5==5` | – |'
- en: '| `assertEqual(5.27, 5.27)` | `unittest.TestCase` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `assertEqual(5.27, 5.27)` | `unittest.TestCase` |'
- en: '| `assertAlmostEqual(5.24, 5.2,places = 1)` |  `unittest.TestCase` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `assertAlmostEqual(5.24, 5.2,places = 1)` | `unittest.TestCase` |'
- en: '| `assertTrue(5 > 2)` | `unittest.TestCase` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `assertTrue(5 > 2)` | `unittest.TestCase` |'
- en: '| `assertFalse(2 < 5)` | `unittest.TestCase` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `assertFalse(2 < 5)` | `unittest.TestCase` |'
- en: '| `assertRaises(ZeroDivisionError,lambda x: 1/x,0.)` | `unittest.TestCase`
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `assertRaises(ZeroDivisionError,lambda x: 1/x,0.)` | `unittest.TestCase`
    |'
- en: '| `assertIn(3,{3,4})` | `unittest.TestCase` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `assertIn(3,{3,4})` | `unittest.TestCase` |'
- en: '| `assert_array_equal(A,B)` | `numpy.testing` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `assert_array_equal(A,B)` | `numpy.testing` |'
- en: '| `assert_array_almost_equal(A, B, decimal=5)` | `numpy.testing` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `assert_array_almost_equal(A, B, decimal=5)` | `numpy.testing` |'
- en: '| `assert_allclose(A, B, rtol=1.e-3,atol=1.e-5)` | `numpy.testing` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `assert_allclose(A, B, rtol=1.e-3,atol=1.e-5)` | `numpy.testing` |'
- en: 'Table 13.1: Assertion tools in Python, unittest and NumPy'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1：Python、unittest 和 NumPy 中的断言工具
- en: Float comparisons
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数比较
- en: 'Two floating point numbers should not be compared with the `==` comparison,
    because the result of a computation is often slightly off due to rounding errors.
    There are numerous tools to test equality of floats for testing purposes. First,
    `allclose` checks that two arrays are almost equal. It can be used in a test function,
    as shown:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 两个浮点数不应该使用 `==` 比较运算符进行比较，因为计算的结果通常由于舍入误差而略有偏差。有许多工具用于测试浮点数的相等性，用于测试目的。首先，`allclose`
    检查两个数组几乎相等。它可以在测试函数中使用，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, `self` refers to a `unittest.Testcase` instance. There are also testing
    tools in the `numpy` package `testing`. These are imported by using:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`self` 指的是 `unittest.Testcase` 实例。`numpy` 包的 `testing` 子包中也有测试工具。这些工具是通过以下方式导入的：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Testing that two scalars or two arrays are equal is done using `numpy.testing.assert_array_allmost_equal`
    or `numpy.testing.assert_allclose`. These methods differ in the way they describe
    the required accuracy, as shown in the preceding table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `numpy.testing.assert_array_allmost_equal` 或 `numpy.testing.assert_allclose`
    来测试两个标量或两个数组是否相等。这些方法在描述所需精度的方式上有所不同，如前表所示。
- en: '*QR* factorization decomposes a given matrix into a product of an orthogonal
    matrix *Q* and an upper triangular matrix *R* as given in the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*QR* 分解将给定的矩阵分解为一个正交矩阵 *Q* 和一个上三角矩阵 *R* 的乘积，如下例所示：'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Is the method applied correctly? We can check this by verifying that *Q* is
    indeed an orthogonal matrix:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应用该方法是否正确？我们可以通过验证 *Q* 是否确实是一个正交矩阵来检查：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Furthermore, we might perform a sanity test by checking if *A = QR*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过检查 *A = QR* 来执行一个合理性测试：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All this can be collected into a `unittest` test case as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以收集到一个 `unittest` 测试用例中，如下所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note in `assert_allclose` the parameter `atol` defaults to zero, which often
    causes problems, when working with matrices having small elements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `assert_allclose` 中，参数 `atol` 默认为零，这通常会在处理具有小元素的矩阵时引起问题。
- en: Unit and functional tests
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和功能测试
- en: Up to now, we have only used functional tests. A functional test checks whether
    the functionality is correct. For the bisection algorithm, this algorithm actually
    finds a zero when there is one. In that simple example, it is not really clear
    what a unit test is. Although, it might seem slightly contrived, it is still possible
    to make a unit test for the bisection algorithm. It will demonstrate how unit
    testing often leads to more compartmentalized implementation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了功能测试。功能测试检查功能是否正确。对于二分算法，该算法实际上在存在零点时找到零点。在那个简单的例子中，单元测试实际上并不清楚。尽管这可能看起来有些牵强，但仍然可以为二分算法编写单元测试。它将展示单元测试通常如何导致更模块化的实现。
- en: 'So, in the bisection method, we would like to check, for instance, that at
    each step the interval is chosen correctly. How to do that? Note that it is absolutely
    impossible with the current implementation, because the algorithm is hidden inside
    the function. One possible remedy is to run only one step of the bisection algorithm.
    Since all the steps are similar, we might argue that we have tested all the possible
    steps. We also need to be able to inspect the current bounds `a` and `b` at the
    current step of the algorithm. So we have to add the number of steps to be run
    as a parameter and change the return interface of the function. We will do that
    as shown:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在二分法中，我们希望检查，例如，在每一步中是否正确选择了区间。如何做到这一点？请注意，使用当前实现绝对不可能，因为算法隐藏在函数内部。一种可能的补救措施是只运行二分算法的一步。由于所有步骤都是相似的，我们可能会认为我们已经测试了所有可能的步骤。我们还需要能够检查算法当前步骤的当前界限
    `a` 和 `b`。因此，我们必须将需要运行的步数作为参数，并更改函数的返回接口。我们将按以下方式执行：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that we have to change the existing unit tests in order to accommodate
    for that change. We may now add a unit test as shown:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须更改现有的单元测试以适应这一变化。现在我们可以添加一个单元测试，如下所示：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Debugging
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Debugging is sometimes necessary while testing, in particular if it is not immediately
    clear why a given test does not pass. In that case, it is useful to be able to
    debug a given test in an interactive session. This is however, made difficult
    by the design of the `unittest.TestCase` class, which prevents easy instantiation
    of test case objects. The solution is to create a special instance for debugging
    purpose only.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，有时需要进行调试，特别是在不清楚为什么某个特定的测试没有通过时。在这种情况下，能够在交互会话中调试给定的测试是有用的。然而，`unittest.TestCase`
    类的设计使得调试变得困难，因为它阻止了测试用例对象的简单实例化。解决方案是为调试目的创建一个特殊实例。
- en: 'Suppose that, in the example of the `TestIdentity` class above, we want to
    test the `test_functionality` method. This would be achieved as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在上面的 `TestIdentity` 类示例中，我们想要测试 `test_functionality` 方法。这将按照以下方式实现：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now this test can be run individually by:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以通过以下方式单独运行这个测试：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will run this individual test and it allows for debugging.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行这个单独的测试，并允许进行调试。
- en: Test discovery
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试发现
- en: 'If you write a Python package, various tests might be spread out through the
    package. The `discover` module finds, imports, and runs these test cases. The
    basic call from the command line is:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写一个 Python 包，各种测试可能分散在包中。`discover` 模块可以找到、导入并运行这些测试用例。从命令行的基本调用如下：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It starts looking for test cases in the current directory and recurses the
    directory tree downward to find Python objects with the `''test''` string contained
    in its name. The command takes optional arguments. Most important are `-s` to
    modify the start directory and `-p` to define the pattern to recognize the tests:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它将从当前目录开始查找测试用例，并向下递归目录树以找到名称中包含 `'test'` 字符串的 Python 对象。该命令接受可选参数。最重要的是 `-s`
    用于修改起始目录，`-p` 用于定义识别测试的模式：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Measuring execution time
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量执行时间
- en: In order to take decisions on code optimization, one often has to compare several
    code alternatives and decide which code should be preferred based on the execution
    time. Furthermore, discussing execution time is an issue when comparing different
    algorithms. In this section, we present a simple and easy way to measure execution
    time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码优化方面做出决策，人们通常需要比较几个代码选择，并根据执行时间决定哪个代码应该被优先考虑。此外，在比较不同算法时，讨论执行时间也是一个问题。在本节中，我们介绍了一种简单且易于测量执行时间的方法。
- en: Timing with a magic function
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用魔法函数进行计时
- en: The easiest way to measure the execution time of a single statement is to use
    IPython’s magic function `%timeit`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测量单个语句的执行时间最简单的方法是使用 IPython 的魔法函数 `%timeit`。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The shell IPython adds additional functionality to standard Python. These extra
    functions are called magic functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Shell IPython 为标准 Python 添加了额外的功能。这些额外的功能被称为魔法函数。
- en: 'As the execution time of a single statement can be extremely short, the statement
    is placed in a loop and executed several times. By taking the minimum measured
    time, one makes sure that other tasks running on the computer do not influence
    the measured result too much. Let''s consider four alternative ways to extract
    nonzero elements from an array as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单个语句的执行时间可能非常短，因此将语句放入循环中并执行多次。通过取最小测量时间，可以确保计算机上运行的其它任务不会过多地影响测量结果。让我们考虑以下四种从数组中提取非零元素的不同方法：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Measuring time with IPython’s magic function `%timeit` gives the following
    result:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IPython 的魔法函数 `%timeit` 测量时间给出以下结果：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The parameter `-n` controls how often the statement is executed before time
    is measured and the `-r` parameter controls the number of repetitions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `-n` 控制在测量时间之前语句执行的次数，而 `-r` 参数控制重复的次数。
- en: Timing with the Python module timeit
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 模块 timeit 进行计时
- en: 'Python provides a `timeit` module, which can be used to measure execution time.
    It requires that first a time object is constructed. It is constructed from two
    strings, a string with setup commands and a string with the commands to be executed.
    We take the same four alternatives as in the preceding example. The array and
    function definitions are written now in a string called `setup_statements` and
    four-time objects are constructed as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一个 `timeit` 模块，它可以用来测量执行时间。它要求首先构建一个时间对象。这个对象由两个字符串构成，一个是设置命令的字符串，另一个是要执行的命令的字符串。我们采用与前面示例相同的四种选择。现在将数组和函数定义写入一个名为
    `setup_statements` 的字符串中，并按照以下方式构建四个时间对象：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The timer objects have a `repeat` method . It takes `repeat` and `number` parameters.
    It executes the statement of the timer object in a loop, measures the time, and
    repeats this experiment corresponding to the `repeat` parameter:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器对象有一个 `repeat` 方法。它接受 `repeat` 和 `number` 参数。它在一个循环中执行计时器对象的语句，测量时间，并重复此实验，对应于
    `repeat` 参数：
- en: 'We continue the preceding example and measure execution times as shown:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续上一个示例，并按如下所示测量执行时间：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In contrast to the method in the preceding example, we obtain lists of all the
    obtained measurements. As computing time may vary depending on the overall load
    of the computer, the minimal value in such a list can be considered a good approximation
    to the computation time necessary to execute the statement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例中的方法相比，我们获得了所有测量值的列表。由于计算时间可能因计算机的整体负载而变化，因此该列表中的最小值可以被认为是执行该语句所需的计算时间的良好近似。
- en: Timing with a context manager
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文管理器进行计时
- en: 'Finally, we present the third method. It serves to show another application
    of a context manager. We first construct a context manager object for measuring
    the elapsed time as shown:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍第三种方法。它用于展示上下文管理器的另一种应用。我们首先构建一个用于测量经过时间的上下文管理器对象，如下所示：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Recall that the `_ _enter_ _` and `_ _exit_ _` methods make this class a context
    manager. The `_ _exit_ _` method’s parameters `ty`, `val`, and `tb` are in the
    normal case `None`. If an exception is raised during execution, they take the
    exception type, its value, and traceback information. The `return False` indicates
    that the exception has not been caught so far.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`_ _enter_ _` 和 `_ _exit_ _` 方法使这个类成为一个上下文管理器。在正常情况下，`_ _exit_ _` 方法的参数
    `ty`、`val` 和 `tb` 都是 `None`。如果在执行过程中抛出异常，它们将包含异常类型、其值和跟踪信息。`return False` 表示到目前为止尚未捕获到异常。
- en: 'We now show the use of the context manager to measure the execution time of
    the four alternatives in the previous example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示如何使用上下文管理器来测量上一个示例中四种替代方案的执行时间：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will then display a message like `Time elapsed 15.0129795074 ms`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示类似 `Time elapsed 15.0129795074 ms` 的消息。
- en: 'If the timing result should be accessible in a variable, the `enter` method
    must return the `Timer` instance (uncomment the `return` statement) and a `with
    ... as ...` construction has to be used:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定时结果需要存储在变量中，`enter` 方法必须返回 `Timer` 实例（取消注释 `return` 语句）并且必须使用 `with ... as
    ...` 构造：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: No program development without testing! We showed the importance of well organized
    and documented tests. Some professionals even start development by first specifying
    tests. A useful tool for automatic testing is the module `unittest`, which we
    explained in detail. While testing improves the reliability of a code, profiling
    is needed to improve the performance. Alternative ways to code may result in large
    performance differences. We showed how to measure computation time and how to
    localize bottlenecks in your code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试的程序开发！我们展示了良好组织和记录的测试的重要性。一些专业人士甚至首先指定测试。自动测试的有用工具是模块 `unittest`，我们已详细解释。虽然测试可以提高代码的可靠性，但还需要进行性能分析。不同的编码方式可能会导致很大的性能差异。我们展示了如何测量计算时间以及如何定位代码中的瓶颈。
- en: Exercises
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Ex. 1** → Two matrices *A*, *B* are called similar, if there exists a matrix
    *S*, such that *B = S^(-1) A S*. *A* and *B* have the same eigenvalues. Write
    a test checking that two matrices are similar, by comparing their eigenvalues.
    Is it a functional or a unit test?'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1** → 如果存在一个矩阵 *S*，使得 *B = S^(-1) A S*，则两个矩阵 *A* 和 *B* 被称为相似。编写一个测试来检查两个矩阵是否相似，通过比较它们的特征值。这是一个功能测试还是单元测试？'
- en: '**Ex. 2** → Create two vectors of large dimension. Compare the execution time
    of various ways to compute their `dot` product:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2** → 创建两个高维向量。比较计算它们的 `dot` 积的各种方法的执行时间：'
- en: 'SciPy function: `dot(v,w)`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy 函数：`dot(v,w)`
- en: 'Generator and sum: `sum((x*y for x,y in zip(v,w)))`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器和求和：`sum((x*y for x,y in zip(v,w)))`
- en: 'Comprehensive list and sum: `sum([x*y for x,y in zip(v,w)])`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 综合列表和求和：`sum([x*y for x,y in zip(v,w)])`
- en: '**Ex. 3** → Let *u* be a vector. The vector *v* with components'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3** → 设 *u* 为一个向量。具有以下分量的向量 *v*：'
- en: '![Exercises](img/moveaverage.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/moveaverage.jpg)'
- en: 'is called a moving average of *u*. Determine which of the two alternatives
    to compute *v* is faster:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 *u* 的移动平均。确定计算 *v* 的两种方法中哪一种更快：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: or
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
