<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Overlay Analysis</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Punching holes in polygons with a symmetric difference operation</li><li class="listitem" style="list-style-type: disc">Union polygons without merging</li><li class="listitem" style="list-style-type: disc">Union polygons with merging (dissolving)</li><li class="listitem" style="list-style-type: disc">Performing an identity function (difference + intersection)</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Introduction</h1></div></div></div><p>Discovering how two datasets spatially relate to each other when they are placed over one another is called overlay analysis. An overlay can be compared to a sheet of tracing paper. For example, you could overlay the tracing paper on top of your base map and see what areas overlap each other. This process is and was a game changer in spatial analysis and modeling. Computer-aided GIS computations can therefor automatically identify where two geometry sets spatially touch for example.</p><p>The goal of this chapter is to give you a feel for the most common overlay analysis functions, such as unions, intersects, and <a id="id269" class="indexterm"/>symmetrical<a id="id270" class="indexterm"/> differences. These are based on the <strong>Dimensionally Extended nine intersection model</strong> (<strong>DE-9IM</strong>), which can be found at <a class="ulink" href="http://en.wikipedia.org/wiki/DE-9IM">http://en.wikipedia.org/wiki/DE-9IM</a>, and describes our list of possible overlays. All processes that we use or name here are derived using a combination of these nine predicates.</p><div><img src="img/50790OS_06_01.jpg" alt="Introduction"/></div><p>We will explore these topology rules in depth in <a class="link" href="ch09.html" title="Chapter 9. Topology Checking and Data Validation">Chapter 9</a>, <em>Topology Checking and Data Validation</em>.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Punching holes in polygons with a symmetric difference operation</h1></div></div></div><p>Why,<a id="id271" class="indexterm"/> oh why would <a id="id272" class="indexterm"/>we want to punch holes in polygons and create a donut? Well, this is done for several reasons, for example, you may want to remove a lake polygon from a forest polygon that it overlaps since it sits in the middle of the forest and is, therefore, included in your area calculations.</p><p>Another example is where we have a set of polygons representing a golf course's fairways and a second set of polygons representing the greens that overlap these fairways. Our task is to calculate the correct number of square meters of fairways. The greens will create our donuts in a fairway's polygons.</p><p>This is translated into spatial operation terminology and means that we need to perform a <code class="literal">symmetric difference</code> operation or, in ESRI terminology, an "erase" operation.</p><div><img src="img/50790OS_06_02.jpg" alt="Punching holes in polygons with a symmetric difference operation"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec111"/>Getting ready</h2></div></div></div><p>In<a id="id273" class="indexterm"/> this example, we will<a id="id274" class="indexterm"/> create two sets of visualizations to see our results. <a id="id275" class="indexterm"/>Our output will generate <strong>Well Known Text</strong> (<strong>WKT</strong>) that is displayed in your browser <a id="id276" class="indexterm"/>using the <strong>Openlayers 3</strong> web mapping client.</p><p>For this example, make sure you have all your code downloaded in your <code class="literal">/ch06</code> folder provided at GitHub and have this folder structure containing these files:</p><div><pre class="programlisting">code
¦   ch06-01_sym_diff.py
¦   foldertree.txt
¦   utils.py
¦
+---ol3
    +---build
    ¦       ol-debug.js
    ¦       ol-deps.js
    ¦       ol.js
    ¦
    +---css
    ¦       layout.css
    ¦       ol.css
    ¦
    +---data
    ¦       my_polys.js
    ¦
    +---html
    ¦       ch06-01_sym_diff.html
    ¦
    +---js
    ¦       map_sym_diff.js
    ¦
    +---resources
        ¦   jquery.min.js
        ¦   logo-32x32-optimized.png
        ¦   logo-32x32.png
        ¦   logo.png
        ¦   textured_paper.jpeg
        ¦
        +---bootstrap
            +---css
            ¦       bootstrap-responsive.css
            ¦       bootstrap-responsive.min.css
            ¦       bootstrap.css
            ¦       bootstrap.min.css
            ¦
            +---img
            ¦       glyphicons-halflings-white.png
            ¦       glyphicons-halflings.png
            ¦
            +---js
                    bootstrap.js
                    bootstrap.min.js

geodata
    pebble-beach-fairways-3857.geojson
    pebble-beach-greens-3857.geojson
    results_sym_diff.js</pre></div><p>With <a id="id277" class="indexterm"/>the folder structure <a id="id278" class="indexterm"/>in place, when you run the code, all inputs and outputs will find their correct home.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec112"/>How to do it...</h2></div></div></div><p>We want to run this code from the command line as usual, which runs in your virtual environment:</p><div><ol class="orderedlist arabic"><li class="listitem">Execute the following statement from your <code class="literal">/ch06/code</code> folder:<div><pre class="programlisting">
<strong>&gt;&gt; python Ch06-01_sym_diff.py</strong>
</pre></div></li><li class="listitem">The following code is<a id="id279" class="indexterm"/> where interesting<a id="id280" class="indexterm"/> operations take place with Shapely:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import json
from os.path import realpath
from shapely.geometry import MultiPolygon
from shapely.geometry import asShape
from shapely.wkt import dumps


# define our files input and output locations
input_fairways = realpath("../geodata/pebble-beach-fairways-3857.geojson")
input_greens = realpath("../geodata/pebble-beach-greens-3857.geojson")
output_wkt_sym_diff = realpath("ol3/data/results_sym_diff.js")


# open and load our geojson files as python dictionary
with open(input_fairways) as fairways:
    fairways_data = json.load(fairways)

with open(input_greens) as greens:
    greens_data = json.load(greens)

# create storage list for our new shapely objects
fairways_multiply = []
green_multply = []

# create shapely geometry objects for fairways
for feature in fairways_data['features']:
    shape = asShape(feature['geometry'])
    fairways_multiply.append(shape)

# create shapely geometry objects for greens
for green in greens_data['features']:
    green_shape = asShape(green['geometry'])
    green_multply.append(green_shape)

# create shapely MultiPolygon objects for input analysis
fairway_plys = MultiPolygon(fairways_multiply)
greens_plys = MultiPolygon(green_multply)

# run the symmetric difference function creating a new Multipolygon
result = fairway_plys.symmetric_difference(greens_plys)

# write the results out to well known text (wkt) with shapely dump
def write_wkt(filepath, features):
    with open(filepath, "w") as f:
        # create a js variable called ply_data used in html
        # Shapely dumps geometry out to WKT
        f.write("var ply_data = '" + dumps(features) + "'")

# write to our output js file the new polygon as wkt
write_wkt(output_wkt_sym_diff, result)</pre></div><p>Your output will be <a id="id281" class="indexterm"/>available<a id="id282" class="indexterm"/> in the <code class="literal">/ch06/code/ol3/html/</code> folder with the <code class="literal">ch06-01_sym_diff.html</code> filename. Simply open this file in your local web browser, such as Chrome, Firefox, or Safari. Our output web map was created by modifying the Openlayers 3 example code pages according to our needs. The resulting web map should display the following map in your local web browser:</p><div><img src="img/50790OS_06_03.jpg" alt="How to do it..."/></div></li></ol></div><p>You can now clearly see a hole inside our fairway.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec113"/>How it works...</h2></div></div></div><p>To begin with, we use two <strong>GeoJSON</strong> datasets <a id="id283" class="indexterm"/>as our<a id="id284" class="indexterm"/> input, both with EPSG: 3857 and stemming from the OSM EPSG: 4326. The <a id="id285" class="indexterm"/>transformation process is not covered here; take a look at <a class="link" href="ch02.html" title="Chapter 2. Working with Projections">Chapter 2</a>, <em>Working with Projections</em>, for further information on how to transform data between two coordinate systems.</p><p>Our first task is to read in both the GeoJSON files into Python dictionaries objects using the standard Python <code class="literal">json</code> module. Next, we set up some empty lists that will store the Shapely geometry objects as a list used for our input to generate the needed <code class="literal">MultiPolygons</code> for our analysis. We use the Shapely built-in <code class="literal">asShape()</code> function to create the Shapely geometry objects so that we can perform the spatial operations. This is accomplished by accessing the dictionaries' <code class="literal">['geometry']</code> element. We then append each geometry to our empty list. This list is then inputted into the Shapely <code class="literal">MultiPolygon()</code> function that will create a MultiPolygon for us and is used as our inputs.</p><p>The actual process of running our <code class="literal">symmetric_difference</code> happens when we input the <code class="literal">fairways_plys</code> MultiPolygon as input and the parameter passed is the <code class="literal">greens_ply</code> MultiPolygon. The output is stored in the <code class="literal">result</code> variable, which itself is also a MultiPolygon. Not to forget, a MultiPolygon is just a list of polygons that we can iterate over.</p><p>Next up, we'll take a look at a<a id="id286" class="indexterm"/> function<a id="id287" class="indexterm"/> called <code class="literal">write_wkt(filepath, features)</code>. This outputs our resulting MultiPolygon Shapely geometry to the <code class="literal">Well Known Text (WKT)</code> format. We do not simply output this <code class="literal">WKT</code> but instead, create a new JavaScript file, <code class="literal">ol3/data/ch06-01_results_sym_diff.js</code>, containing our <code class="literal">WKT</code> output. The code outputs a string that creates a JavaScript variable called <code class="literal">ply_data</code>. This <code class="literal">ply_data</code> variable is then used in our HTML file<a id="id288" class="indexterm"/> located at <code class="literal">/ch06/code/ol3/html/sym_diff.html</code> to draw our <code class="literal">WKT</code> vector layer using Openlayers 3. We<a id="id289" class="indexterm"/> then call our function and it executes the write to the <code class="literal">WKT</code> JavaScript file.</p><p>This example is the first that visualizes our results as a web map. In <a class="link" href="ch11.html" title="Chapter 11. Web Analysis with GeoDjango">Chapter 11</a>, <em>Web Analysis with GeoDjango</em>, we will explore a fully functional web mapping application; for those of you who cannot wait, you may want to jump ahead. Further examples will continue to use Openlayers 3 as our data viewer, moving away from using Matplotlib.</p><p>In the end, our simple one-line symmetric difference execution needed a lot of helper code to deal with importing GeoJSON data and exporting the results in a format that could display a web map with Openlayers 3.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Union polygons without merging</h1></div></div></div><p>To <a id="id290" class="indexterm"/>demonstrate what merging is all about, we will take an example from the <strong>National Oceanic and Atmospheric Administration</strong> (<strong>NOAA</strong>) weather <a id="id291" class="indexterm"/>data. It provides an awesome minute-by-minute update of Shapefiles for your desire to download data. We will look at a one-week collection of weather warnings, and combine these with state boundaries to see where exactly warnings occurred within a state boundary.</p><div><img src="img/50790OS_06_04.jpg" alt="Union polygons without merging"/></div><p>The preceding screenshot shows us the polygons before the union operation in QGIS.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec114"/>Getting ready</h2></div></div></div><p>Make <a id="id292" class="indexterm"/>sure your virtual environment is, as always, fired up and run the following command:</p><div><pre class="programlisting">
<strong>$ source venvs/pygeo_analysis_cookbook/bin/activate</strong>
</pre></div><p>Next, switch to your <code class="literal">/ch06/code/</code> folder to find finished code examples or create your empty file in the <code class="literal">/ch06/</code>working folder and follow along with the code.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec115"/>How to do it...</h2></div></div></div><p>The <code class="literal">pyshp</code> and <code class="literal">shapely</code> libraries are our two workhorses for this exercise:</p><div><ol class="orderedlist arabic"><li class="listitem">You can simply run this file in the command prompt to see the results as follows:<div><pre class="programlisting">
<strong>&gt;&gt; python ch06-02_union.py</strong>
</pre></div><p>Results can then be opened in the <code class="literal">/ch06/code/ol3/html/ch06-02_union.html</code> folder with a double-click to start them in your local web browser. You should see the following web map if everything's gone smoothly:</p><div><img src="img/50790OS_06_05.jpg" alt="How to do it..."/></div></li><li class="listitem">Now let's<a id="id293" class="indexterm"/> take a look at the code that makes it all happen:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json
from os.path import realpath
import shapefile  # pyshp
from geojson import Feature, FeatureCollection
from shapely.geometry import asShape, MultiPolygon
from shapely.ops import polygonize
from shapely.wkt import dumps


def create_shapes(shapefile_path):
    """
    Convert Shapefile Geometry to Shapely MultiPolygon
    :param shapefile_path: path to a shapefile on disk
    :return: shapely MultiPolygon
    """
    in_ply = shapefile.Reader(shapefile_path)

    # using pyshp reading geometry
    ply_shp = in_ply.shapes()
    ply_records = in_ply.records()
    ply_fields = in_ply.fields
    print ply_records
    print ply_fields

    if len(ply_shp) &gt; 1:
        # using python list comprehension syntax
        # shapely asShape to convert to shapely geom
        ply_list = [asShape(feature) for feature in ply_shp]

        # create new shapely multipolygon
        out_multi_ply = MultiPolygon(ply_list)

        # # equivalent to the 2 lines above without using list comprehension
        # new_feature_list = []
        # for feature in features:
        #     temp = asShape(feature)
        #     new_feature_list.append(temp)
        # out_multi_ply = MultiPolygon(new_feature_list)

        print "converting to MultiPolygon: " + str(out_multi_ply)
    else:
        print "one or no features found"
        shply_ply = asShape(ply_shp)
        out_multi_ply = MultiPolygon(shply_ply)

    return out_multi_ply


def create_union(in_ply1, in_ply2, result_geojson):
    """
    Create union polygon
    :param in_ply1: first input shapely polygon
    :param in_ply2: second input shapely polygon
    :param result_geojson: output geojson file including full file path
    :return: shapely MultiPolygon
    """
    # union the polygon outer linestrings together
    outer_bndry = in_ply1.boundary.union(in_ply2.boundary)

    # rebuild linestrings into polygons
    output_poly_list = polygonize(outer_bndry)

    out_geojson = dict(type='FeatureCollection', features=[])

    # generate geojson file output
    for (index_num, ply) in enumerate(output_poly_list):
        feature = dict(type='Feature', properties=dict(id=index_num))
        feature['geometry'] = ply.__geo_interface__
        out_geojson['features'].append(feature)

    # create geojson file on disk
    json.dump(out_geojson, open(result_geojson, 'w'))

    # create shapely MultiPolygon
    ply_list = []
    for fp in polygonize(outer_bndry):
        ply_list.append(fp)

    out_multi_ply = MultiPolygon(ply_list)

    return out_multi_ply


def write_wkt(filepath, features):
    """

    :param filepath: output path for new JavaScript file
    :param features: shapely geometry features
    :return:
    """
    with open(filepath, "w") as f:
        # create a JavaScript variable called ply_data used in html
        # Shapely dumps geometry out to WKT
        f.write("var ply_data = '" + dumps(features) + "'")


def output_geojson_fc(shply_features, outpath):
    """
    Create valid GeoJSON python dictionary
    :param shply_features: shapely geometries
    :param outpath:
    :return: GeoJSON FeatureCollection File
    """

    new_geojson = []
    for feature in shply_features:
        feature_geom_geojson = feature.__geo_interface__
        myfeat = Feature(geometry=feature_geom_geojson,
                         properties={'name': "mojo"})
        new_geojson.append(myfeat)

    out_feat_collect = FeatureCollection(new_geojson)

    with open(outpath, "w") as f:
        f.write(json.dumps(out_feat_collect))


if __name__ == "__main__":

    # define our inputs
    shp1 = realpath("../geodata/temp1-ply.shp")
    shp2 = realpath("../geodata/temp2-ply.shp")

    # define outputs
    out_geojson_file = realpath("../geodata/res_union.geojson")
    output_union = realpath("../geodata/output_union.geojson")
    out_wkt_js = realpath("ol3/data/results_union.js")

    # create our shapely multipolygons for geoprocessing
    in_ply_1_shape = create_shapes(shp1)
    in_ply_2_shape = create_shapes(shp2)

    # run generate union function
    result_union = create_union(in_ply_1_shape, in_ply_2_shape, out_geojson_file)

    # write to our output js file the new polygon as wkt
    write_wkt(out_wkt_js, result_union)

    # write the results out to well known text (wkt) with shapely dump
    geojson_fc = output_geojson_fc(result_union, output_union)</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec116"/>How it works...</h2></div></div></div><p>A quick <a id="id294" class="indexterm"/>high-level run-through of what is going on here at the beginning should help clear the air. We have four functions and nine variables within our Python code to split the load of input and output data. The running of our code takes place in the <code class="literal">if __name__ == "main":</code> call that is found at the end of the code. We start defining two variables to deal with our inputs that we are going to <strong>union</strong> together. These two are our input Shapefiles and the other three outputs are GeoJSON and JavaScript files.</p><p>The <code class="literal">create_shapes()</code>function converts our Shapefile into Shapely <code class="literal">MultiPolygon</code> geometry objects. Inside the Python class, the list comprehension is used to generate a new list of polygon objects, which are the input list of polygons used to create our output <code class="literal">MultiPolygon</code>. Next, we'll simply run this function passing in our input Shapefiles.</p><p>Our <code class="literal">create_union()</code> function is up next where we do the real union work. We begin by unioning the two geometry boundaries together that produces a union set of LineStrings and represents the outer bounds of our input polygons. The reason for this is that we do not want to lose the geometries of both polygons, which will, by default, dissolve into one big polygon when simply passed into the Shapely union function. Therefore, we need to rebuild the polygons with the <code class="literal">polygonize()</code> Shapely function.</p><p>The <code class="literal">polygonize</code> function <a id="id295" class="indexterm"/>creates a Python <strong>generator</strong> object, not a simple geometry. This is an <em>iterator</em> that's similar to a <em>list</em> that we need to loop over to get at the individual polygons it's created for us.</p><p>We do exactly this in the next code segment using the <code class="literal">enumerate()</code> Python function that automatically creates an ID for us for each feature that we use as the id field in the attribute results. After our loop, we use the standard Python<code class="literal"> json.dump()</code> method to export our newly created GeoJSON file and write it to disk using the Python <code class="literal">open()</code> method in the write mode.</p><p>Lastly, in our <code class="literal">create_union()</code> function, we prepare to output our resulting <strong>union</strong> polygon as <a id="id296" class="indexterm"/>a Shapely MultiPolygon object. This is accomplished simply by looping through the <code class="literal">polygonize()</code> iterator and outputting a list that feeds into the Shapely <code class="literal">MultiPolygon()</code>function. Finally, we execute the union function, passing in our two input geometries and specifying the output GeoJSON file.</p><p>So, we can view our results in our web map as we did in the previous exercise using a small function called <code class="literal">write_wkt()</code>. This little function takes the file path to the output JavaScript file that we want to create and the MultiPolygon result's geometry. Shapely then dumps the geometry into the Well Known Text format as we write it out to the JavaScript file.</p><p>In the<a id="id297" class="indexterm"/> end, a small function called <code class="literal">output_geojson_fc()</code> is used to output another GeoJSON file, this time using the Python <code class="literal">geojson</code> library. This simply shows you another way to recreate a GeoJSON file. Since GeoJSON is a plain text file, it is possible to create it in many unique ways depending on your personal programming preference.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Union polygons with merging (dissolving)</h1></div></div></div><p>To <a id="id298" class="indexterm"/>demonstrate what merging is all about, we will take an example out of the NOAA weather data. It provides an awesome minute-by-minute update of Shapefiles to satisfy your desire to download data. We will look at a week's collection of weather warnings and union these warnings together, giving us the total warning area issued in this week.</p><p>A conceptual visualization of our desired results is shown here:</p><div><img src="img/50790OS_06_06.jpg" alt="Union polygons with merging (dissolving)"/></div><p>Most of the data is located around Florida, but has some polygons near Hawaii and California. To <a id="id299" class="indexterm"/>see the original data or find new data, check out these links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.nws.noaa.gov/geodata/catalog/wsom/html/pubzone.htm">http://www.nws.noaa.gov/geodata/catalog/wsom/html/pubzone.htm</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://nws.noaa.gov/regsci/gis/week.html">http://nws.noaa.gov/regsci/gis/week.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.nws.noaa.gov/geodata/index.html">http://www.nws.noaa.gov/geodata/index.html</a></li></ul></div><p>If you<a id="id300" class="indexterm"/> want to see the state boundaries, you can find them at <a class="ulink" href="https://www.census.gov/geo/maps-data/data/cbf/cbf_state.html">https://www.census.gov/geo/maps-data/data/cbf/cbf_state.html</a>.</p><p>Here is what a sample of the data looks like around Florida before the union, which is visualized with QGIS:</p><div><img src="img/50790OS_06_07.jpg" alt="Union polygons with merging (dissolving)"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec117"/>Getting ready</h2></div></div></div><p>The <a id="id301" class="indexterm"/>usual order of business is needed to get going with this code. Fire up your virtual environment and check whether your data is all downloaded and located in your <code class="literal">/ch06/geodata/</code> folder. If all is ready, jump right in and start typing some code.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec118"/>How to do it...</h2></div></div></div><p>Our data is a little messy to say the least, so please follow our steps outlining a solution to allow us to process and run the analysis function, <code class="literal">union</code>:</p><div><pre class="programlisting"># #!/usr/bin/env python
# -*- coding: utf-8 -*-
from shapely.geometry import MultiPolygon
from shapely.ops import cascaded_union
from os.path import realpath
from utils import create_shapes
from utils import out_geoj
from utils import write_wkt


def check_geom(in_geom):
    """
    :param in_geom: input valid Shapely geometry objects
    :return: Shapely MultiPolygon cleaned
    """
    plys = []
    for g in in_geom:
        # if geometry is NOT valid
        if not g.is_valid:
            print "Oh no invalid geometry"
            # clean polygon with buffer 0 distance trick
            new_ply = g.buffer(0)
            print "now lets make it valid"
            # add new geometry to list
            plys.append(new_ply)
        else:
            # add valid geometry to list
            plys.append(g)
    # convert new polygons into a new MultiPolygon
    out_new_valid_multi = MultiPolygon(plys)
    return out_new_valid_multi


if __name__ == "__main__":

    # input NOAA Shapefile
    shp = realpath("../geodata/temp-all-warn-week.shp")

    # output union_dissolve results as GeoJSON
    out_geojson_file = realpath("../geodata/ch06-03_union_dissolve.geojson")

    out_wkt_js = realpath("ol3/data/ch06-03_results_union.js")

    # input Shapefile and convert to Shapely geometries
    shply_geom = create_shapes(shp)

    # Check the Shapely geometries if they are valid if not fix them
    new_valid_geom = check_geom(shply_geom)

    # run our union with dissolve
    dissolve_result = cascaded_union(new_valid_geom)

    # output the resulting union dissolved polygons to GeoJSON file
    out_geoj(dissolve_result, out_geojson_file)

    write_wkt(out_wkt_js, dissolve_result)</pre></div><p>Your resulting web map will look like this:</p><div><img src="img/50790OS_06_08.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec119"/>How it works...</h2></div></div></div><p>We are starting to increasingly reuse more code that is now tucked away in our <code class="literal">/ch06/code/utils.py</code> module. As you see in the imports, we use three functions for the standard input and output of data. The main application starts with defining our NOAA input Shapefile and defining the output GeoJSON file. Then, if we run the code, it will crash due to data validity issues. So, we create a new function to check our input data for invalid geometries. This new function will catch these invalid geometries and convert them to valid polygons.</p><p>Shapely has a geometry property called <code class="literal">is_valid</code>, which accesses the GEOS engine to check for geometry validity based on the simple features in the OGC specification.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>If you are looking for all the possible invalid data possibilities, you can find more information on the Open Geospatial Consortium website. Check out the Simple <a id="id303" class="indexterm"/>Features Standard on page <em>28</em>; you will find the examples of invalid polygons at <a class="ulink" href="http://portal.opengeospatial.org/files/?artifact_id=25355">http://portal.opengeospatial.org/files/?artifact_id=25355</a>.</p></div></div><p>The<a id="id304" class="indexterm"/> reason for these anomalies is that when data is overlaid and processed, geometries become combined or cut at angles that are not always optimal.</p><p>At last, we have clean data to work with, making the rest of our journey very simple by running the Shapely <code class="literal">cascaded_union()</code> function, which will dissolve all our overlapping polygons. Our resulting MultiPolygons are pushed further into our <code class="literal">out_geoj()</code> function, which finally writes the new geometries to disk in our <code class="literal">/ch06/geodata</code> folder.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Performing an identity function (difference + intersection)</h1></div></div></div><p>In <a id="id305" class="indexterm"/>ESRI geoprocessing terminology, there is an overlay function called <code class="literal">identity</code>. This is a very useful function to call when you want to keep all the original geometry boundaries of ONLY the input features combined with an intersection of input features.</p><div><img src="img/50790OS_06_09.jpg" alt="Performing an identity function (difference + intersection)"/></div><p>This boils down to a formula that calls for both <code class="literal">difference</code> and <code class="literal">intersect</code>. We first find the difference (<code class="literal">input feature - intersection</code>), then add the intersection to create<a id="id306" class="indexterm"/> our results as follows:</p><div><pre class="programlisting">
<strong>               (input feature – intersection) + intersection = result</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec120"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">For all you curious folks who want to learn how to do this, type out the following code; it will help your muscle memory:<div><pre class="programlisting">##!/usr/bin/env python
# -*- coding: utf-8 -*-
from shapely.geometry import asShape, MultiPolygon
from utils import shp2_geojson_obj, out_geoj, write_wkt
from os.path import realpath

def create_polys(shp_data):
    """
    :param shp_data: input GeoJSON
    :return: MultiPolygon Shapely geometry
    """
    plys = []
    for feature in shp_data['features']:
        shape = asShape(feature['geometry'])
        plys.append(shape)

    new_multi = MultiPolygon(plys)
    return new_multi


def create_out(res1, res2):
    """

    :param res1: input feature
    :param res2: identity feature
    :return: MultiPolygon identity results
    """
    identity_geoms = []

    for g1 in res1:
        identity_geoms.append(g1)
    for g2 in res2:
        identity_geoms.append(g2)

    out_identity = MultiPolygon(identity_geoms)
    return out_identity


if __name__ == "__main__":
    # out two input test Shapefiles
    shp1 = realpath("../geodata/temp1-ply.shp")
    shp2 = realpath("../geodata/temp2-ply.shp")

    # output resulting GeoJSON file
    out_geojson_file = realpath("../geodata/result_identity.geojson")

    output_wkt_identity = realpath("ol3/data/ch06-04_results_identity.js")


    # convert our Shapefiles to GeoJSON
    # then to python dictionaries
    shp1_data = shp2_geojson_obj(shp1)
    shp2_data = shp2_geojson_obj(shp2)

    # transform our GeoJSON data into Shapely geom objects
    shp1_polys = create_polys(shp1_data)
    shp2_polys = create_polys(shp2_data)

    # run the difference and intersection
    res_difference = shp1_polys.difference(shp2_polys)
    res_intersection = shp1_polys.intersection(shp2_polys)

    # combine the difference and intersection polygons into results
    result_identity = create_out(res_difference, res_intersection)

    # export identity results to a GeoJSON
    out_geoj(result_identity, out_geojson_file)

    # write out new JavaScript variable with wkt geometry
    write_wkt(output_wkt_identity, result_identity )</pre></div><p>The resulting polygons <a id="id307" class="indexterm"/>can now be visualized in your browser. Now simply open the <code class="literal">/ch06/code/ol3/html/ch06-04_identity.html</code> file and you will see this map:</p><div><img src="img/50790OS_06_10.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec121"/>How it works...</h2></div></div></div><p>We have hidden away a couple of gems in our <code class="literal">util.py</code> utilities file called <code class="literal">shp2_geojson_obj</code> and <code class="literal">out_geoj</code>. The first one takes in our Shapefile and returns a Python dictionary object. Our function actually creates a valid GeoJSON in the form of a Python dictionary that could very easily be converted to a JSON string using the standard <code class="literal">json.dumps()</code>Python module.</p><p>With this overhead out of the way, we can jump into creating Shapely geometries that can be used for our analysis. The <code class="literal">create_polys()</code>function does exactly this: it takes in our geometries, returning a <code class="literal">MultiPolygon</code>. This <code class="literal">MultiPolygon</code> is used to calculate our difference and intersection.</p><p>So, at last, we can do the analysis calculation starting with the Shapely difference function using our <code class="literal">temp1-ply.shp</code> as our input feature and <code class="literal">temp2-poly.shp</code> as our identity feature. The difference function only returns the geometries of the input features that do not intersect the other feature. Next up, we execute the intersection function that only returns geometries that overlap between our two inputs.</p><p>Our recipe <a id="id308" class="indexterm"/>is almost completed; we only need to combine these two new results to produce our new identity result's MultiPolygon. The <code class="literal">create_out()</code>function takes two arguments, the first being our input features and the second is our resulting intersection features. The order is very important; otherwise your results will be reversed. So make sure that you enter the correct order of input.</p><p>We run through each of the geometries and combine them into a fancy new <code class="literal">MultiPolygon</code> called <code class="literal">result_identity</code>. This is then pumped into our <code class="literal">out_geoj()</code> function, which writes out a new GeoJSON file to your <code class="literal">/ch06/geodata</code>/ folder.</p><p>Our <code class="literal">out_geoj()</code> function is located in the <code class="literal">utils.py</code> file and might need a quick explanation. The input is a list of geometries and the file path of the output GeoJSON file location on disk. We simply create a new dictionary, and then loop through each geometry, exporting the Shapely geometry to a GeoJSON file using the built-in Shapely <code class="literal">__geo_interface__</code>.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>If you<a id="id309" class="indexterm"/> want to read up on the <code class="literal">__geo_interface__,</code> do so for yourself and find out what it is and why it's so cool at <a class="ulink" href="https://gist.github.com/sgillies/2217756">https://gist.github.com/sgillies/2217756</a>.</p></div></div><p>For those of you looking for the two utility functions, here they are for your reading pleasure:</p><div><pre class="programlisting">def shp2_geojson_obj(shapefile_path):
    # open shapefile
    in_ply = shapefile.Reader(shapefile_path)
    # get a list of geometry and records
    shp_records = in_ply.shapeRecords()
    # get list of fields excluding first list object
    fc_fields = in_ply.fields[1:]

    # using list comprehension to create list of field names
    field_names = [field_name[0] for field_name in fc_fields ]
    my_fc_list = []
    # run through each shape geometry and attribute
    for x in shp_records:
        field_attributes = dict(zip(field_names, x.record))
        geom_j = x.shape.__geo_interface__
        my_fc_list.append(dict(type='Feature', geometry=geom_j,
                               properties=field_attributes))

    geoj_json_obj = {'type': 'FeatureCollection',
                    'features': my_fc_list}

    return geoj_json_obj
def out_geoj(list_geom, out_geoj_file):
    out_geojson = dict(type='FeatureCollection', features=[])

    # generate geojson file output
    for (index_num, ply) in enumerate(list_geom):
        feature = dict(type='Feature', properties=dict(id=index_num))
        feature['geometry'] = ply.__geo_interface__
        out_geojson['features'].append(feature)

    # create geojson file on disk
    json.dump(out_geojson, open(out_geoj_file, 'w'))</pre></div></div></div></div>
</body></html>