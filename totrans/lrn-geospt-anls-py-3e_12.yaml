- en: Real-Time Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时数据
- en: 'A common saying among geospatial analysts is: *A map is outdated as soon as
    it''s created*. This saying reflects the fact that the Earth and everything on
    it are constantly changing. For most of the history of geospatial analysis and
    through most of this book, geospatial products are relatively static. Raw datasets
    are typically updated anywhere from a few months to a few years. The age of geospatial
    data in a map is referred to as **data currency**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间分析师中有一句俗语：“地图一旦制作出来，就立刻过时了”。这句话反映了地球及其上的一切都在不断变化的事实。在地理空间分析的大部分历史中，以及本书的大部分内容中，地理空间产品相对静态。原始数据集通常每隔几个月到几年更新一次。地图中地理空间数据的时代被称为**数据货币**。
- en: Data currency has traditionally not been the primary focus because of the time
    and expense needed to collect data. Web mapping, wireless cellular modems, and
    low-cost GPS antennas have changed that focus. It is now logistically feasible
    and even quite affordable to monitor a rapidly changing object or system and broadcast
    those changes to millions of people online. This change is revolutionizing geospatial
    technology and taking it in new directions. The most direct evidence of this revolution
    is web mapping mashups using systems such as Google Maps or OpenLayers and web-accessible
    data formats. Every day, more and more electronic devices are being brought online
    to broadcast their location and data for automation or remote control. Examples
    include thermostats, cameras, cars, and more. You can also use cheap, embedded
    computers such as the popular Raspberry Pi to turn almost anything into a connected
    **smart** device. This concept of connecting devices into a web of data and information
    is called **The Internet of Things** (**IoT**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于收集数据所需的时间和费用，数据货币传统上并不是主要关注点。网络地图、无线蜂窝调制解调器和低成本GPS天线改变了这一焦点。现在，从物流上讲，监控快速变化的对象或系统并将其变化广播给数百万在线用户变得可行，甚至相当经济。这种变化正在改变地理空间技术，并将其引向新的方向。这一革命的直接证据是使用Google
    Maps或OpenLayers等系统进行的网络地图混合应用，以及可在线访问的数据格式。每天都有越来越多的电子设备被连接到网络上，以广播其位置和数据，用于自动化或远程控制。例如，恒温器、摄像头、汽车等等。你还可以使用流行的Raspberry
    Pi等廉价的嵌入式计算机将几乎任何东西变成一个连接的**智能**设备。将设备连接成数据和信息网络的概念被称为**物联网**（**IoT**）。
- en: 'In this chapter, we''ll be checking out the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下主题：
- en: Limitations of real-time data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时数据的局限性
- en: Using real-time data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实时数据
- en: Tracking vehicles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹车辆
- en: Storm chasing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴风雨追逐
- en: Reports from the field
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现场报告
- en: By the end, you'll have learned to work with real-time geospatial data, and
    will be able to build a field reporting tool that can serve as a data transmission
    source for any type of data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到最后，你将学会如何处理实时地理空间数据，并且能够构建一个可以作为任何类型数据传输源的现场报告工具。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following things:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下几样东西：
- en: Python 3.6 or higher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6或更高版本
- en: 'RAM: Minimum 6 GB (Windows), 8 GB (macOS), recommended 8 GB'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存：最小6 GB（Windows），8 GB（macOS），推荐8 GB
- en: 'Storage: Minimum 7200 RPM SATA with 20 GB of available space, and recommended
    SSD with 40 GB of available space'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储：最小7200 RPM SATA，可用空间20 GB，推荐使用SSD，可用空间40 GB
- en: 'Processor: Minimum Intel Core i3 2.5 GHz, and recommended Intel Core i5'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器：最小Intel Core i3 2.5 GHz，推荐Intel Core i5
- en: The MapQuest Developer API key, available here: [https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MapQuest开发者API密钥，可在以下链接获取：[https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register)
- en: Limitations of real-time data
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时数据的局限性
- en: 'The term **real-time data** typically means near-real-time. Some tracking devices
    capture real-time data and may update as often as several times a second. But
    the limitations of the infrastructure that broadcasts that data may constrain
    the output to every 10 seconds or longer. Weather radar is a perfect example.
    A **Doppler Weather Radar** (**DWR**) sweeps continuously but data is typically
    available online every five minutes. But given the contrast with traditional geospatial
    data updates, a refresh of a few minutes is real-time enough. Limitations can
    be summarized as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**实时数据**通常意味着接近实时。一些跟踪设备捕获实时数据，并且可能每秒更新几次。但是，广播这些数据的底层基础设施的限制可能将输出频率限制为每10秒或更长。气象雷达是一个完美的例子。**多普勒天气雷达**（**DWR**）持续扫描，但数据通常每五分钟在线更新一次。但是，与传统地理空间数据更新相比，几分钟的刷新已经足够实时。限制可以总结如下：
- en: Network bandwidth limitations restricting data size
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络带宽限制限制数据大小
- en: Network latency limiting the data update frequency
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络延迟限制数据更新频率
- en: Availability of the data source due to restrictions such as battery life
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于电池寿命等限制，数据源的可访问性
- en: Lack of quality control due to data being instantly available to consumers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据立即对消费者可用而缺乏质量控制
- en: Security vulnerabilities due to rapid ingestion of unverified data
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于快速摄取未经验证的数据导致的安全漏洞
- en: Real-time data opens up additional opportunities for geospatial applications
    so we'll look at using it next.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实时数据为地理空间应用开辟了额外的机会，因此我们将探讨如何使用它。
- en: Using real-time data
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实时数据
- en: Web mashups often use real-time data. Web mashups are amazing and have changed
    the way many different industries operate. But they are typically limited in that
    they usually just display pre-processed data on a map and give developers access
    to a JavaScript API. But what if you want to process the data in some way? What
    if you want to filter, change, and then send it to another system? To use real-time
    data for geospatial analysis, you need to be able to access it as point data or
    a georeferenced raster.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 网络混合应用通常使用实时数据。网络混合应用非常神奇，已经改变了许多不同行业的运营方式。但它们通常受到限制，通常只是在一个地图上显示预处理的 数据，并给开发者提供访问JavaScript
    API的权限。但如果你想以某种方式处理数据呢？如果你想过滤、更改，然后将其发送到另一个系统呢？为了使用实时数据进行地理空间分析，你需要能够将其作为点数据或地理参考栅格访问。
- en: You can find out more about web map mashups here: [https://www.esri.com/arcgis-blog/products/product/uncategorized/digital-map-mashups/](https://www.esri.com/arcgis-blog/products/product/uncategorized/digital-map-mashups/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于网络地图混合应用的信息： [https://www.esri.com/arcgis-blog/products/product/uncategorized/digital-map-mashups/](https://www.esri.com/arcgis-blog/products/product/uncategorized/digital-map-mashups/).
- en: As with examples in the previous chapters, the scripts are as simple as possible
    and designed to be read from start to finish without much mental looping. When
    functions are used they are listed first, followed by script variable declarations,
    and finally the main program execution.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章中的示例一样，脚本尽可能简单，并设计为从头到尾阅读，无需太多心理循环。当使用函数时，它们首先列出，然后是脚本变量声明，最后是主程序执行。
- en: Now let's see how to access a real-time and point-location data source using
    vehicles from the NextBus API.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用NextBus API中的车辆来访问实时和点位置数据源。
- en: Tracking vehicles
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轨迹车辆
- en: For our first real-time data source, we'll use the excellent **NextBus API**.
    NextBus ([http://www.nextbus.com/](http://www.nextbus.com/)) is a commercial service
    that tracks public transportation for municipalities including buses, trolleys,
    and trains. People riding these transit lines can then track the arrival time
    of the *next bus*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个实时数据源，我们将使用优秀的**NextBus API**。NextBus ([http://www.nextbus.com/](http://www.nextbus.com/))
    是一个商业服务，用于跟踪包括公交车、有轨电车和火车在内的市政公共交通。乘坐这些交通线路的人可以跟踪下一辆**公交车**的到达时间。
- en: What's even better is that, with the customer's permission, NextBus publishes
    tracking data through a **REpresentational State Transfer** (**REST**) **API.** Using
    URL API calls, developers can request information about a vehicle and receive
    an XML document about its location. This API is a straightforward way to begin
    using real-time data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，在客户同意的情况下，NextBus通过**表示状态转移**（**REST**）**API**发布跟踪数据。使用URL API调用，开发者可以请求有关车辆的信息，并接收有关其位置的XML文档。这是一种直接开始使用实时数据的方法。
- en: 'If you go to NextBus, you''ll see a web interface as shown in the following
    screenshot, showing data for the city of Los Angeles, California metro system:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问NextBus，你会看到一个如以下截图所示的网页界面，显示加利福尼亚州洛杉矶的地铁系统数据：
- en: '![](img/9af21cb9-55b2-4dc1-8b1d-878b4e3622ed.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9af21cb9-55b2-4dc1-8b1d-878b4e3622ed.png)'
- en: 'The system lets you select several parameters to learn the current location
    and time prediction for the next stop. On the right side of the screen, there
    is a link to a Google Maps mashup, showing transit tracking data for the particular
    route as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统允许你选择多个参数来了解下一站的当前位置和时间预测。在屏幕的右侧，有一个链接到一个Google Maps混合应用，显示特定路线的公交跟踪数据，如下面的截图所示：
- en: '![](img/624abf09-c442-4370-88ed-9a586eb84972.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/624abf09-c442-4370-88ed-9a586eb84972.png)'
- en: This is a very useful website but it does not give us control over how the data
    is displayed and used. Let's access the raw data directly using Python and the
    NextBus REST API to start working with real-time data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的网站，但它不让我们控制数据的显示和使用方式。让我们直接使用Python和NextBus REST API来访问原始数据，开始处理实时数据。
- en: For the examples in this chapter, we'll use the documented NextBus API found
    here: [http://www.nextbus.com/xmlFeedDocs/NextBusXMLFeed.pdf](http://www.nextbus.com/xmlFeedDocs/NextBusXMLFeed.pdf).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的例子中，我们将使用这里找到的文档化的NextBus API：[http://www.nextbus.com/xmlFeedDocs/NextBusXMLFeed.pdf](http://www.nextbus.com/xmlFeedDocs/NextBusXMLFeed.pdf)。
- en: To start with this example, we will need a list of buses required.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个例子，我们需要一个所需公交车的列表。
- en: The NextBus agency list
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NextBus机构列表
- en: NextBus customers are called **agencies**. In our examples, we are going to
    track buses on a route for Los Angeles, California. First, we need to get some
    information about the agency. The NextBus API consists of a web service named
    `publicXMLFeed`, in which you set a parameter named `command`. We'll call the
    `agencyList` command in a browser to get an XML document containing agency information
    using the following REST URL: [http://webservices.nextbus.com/service/publicXMLFeed?command=agencyList](http://webservices.nextbus.com/service/publicXMLFeed?command=agencyList).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: NextBus的客户被称为**机构**。在我们的例子中，我们将追踪加利福尼亚州洛杉矶的公交车路线。首先，我们需要获取一些关于该机构的信息。NextBus
    API由一个名为`publicXMLFeed`的Web服务组成，在其中你设置一个名为`command`的参数。我们将使用浏览器中的`agencyList`命令，通过以下REST
    URL获取包含机构信息的XML文档：[http://webservices.nextbus.com/service/publicXMLFeed?command=agencyList](http://webservices.nextbus.com/service/publicXMLFeed?command=agencyList)。
- en: 'When we go to that link in a browser, it returns an XML document containing
    the `<agency/>` tag. The tag for Los Angeles looks like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中访问该链接时，它返回一个包含`<agency/>`标签的XML文档。洛杉矶的标签如下所示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have a list of buses, we need to get the routes they can travel.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了公交车的列表，我们需要获取它们可以行驶的路线。
- en: The NextBus route list
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NextBus路线列表
- en: The `tag` attribute is the ID for Thunder Bay, which we need for other NextBus
    API commands. The other attributes are human-readable metadata. The next piece
    of information we need is the details about the **route 2** bus route. To get
    this information, we'll use the agency ID and the `routeList` REST command to
    get another XML document by pasting the URL into our web browser.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`属性是桑德贝的ID，我们需要它来执行其他NextBus API命令。其他属性是可读的元数据。我们需要获取的下一项信息是关于**路线2**公交车路线的详细信息。为了获取这些信息，我们将使用机构ID和`routeList`
    REST命令，将URL粘贴到我们的网页浏览器中获取另一个XML文档。'
- en: Note that the agency ID is set to the parameter in the REST URL: [http://webservices.nextbus.com/service/publicXMLFeed?command=routeList&a=lametro](http://webservices.nextbus.com/service/publicXMLFeed?command=routeList&a=lametro).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，机构ID被设置为REST URL中的参数：[http://webservices.nextbus.com/service/publicXMLFeed?command=routeList&a=lametro](http://webservices.nextbus.com/service/publicXMLFeed?command=routeList&a=lametro)。
- en: 'When we call this URL in a browser, we get the following XML document:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中调用此URL时，我们得到以下XML文档：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have buses and routes. We're ready to start tracking their locations!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了公交车和路线。我们准备好开始追踪它们的地理位置了！
- en: NextBus vehicle locations
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NextBus车辆位置
- en: "So the mainline route ID stored in the `tag` attribute is simply `1`, according\
    \ to \Lthese results. Thus, now, we have all of the information we need to track\
    \ buses along the **LA Metro route 2**."
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据这些结果，存储在`tag`属性中的主线路线ID仅仅是`1`。因此，现在我们拥有了追踪**洛杉矶地铁路线2**上公交车所需的所有信息。
- en: There is only one more required parameter (called `t`) that represents milliseconds
    since the **1970 epoch date** (**January 1, 1970, at midnight UTC**). The epoch
    date is simply a computer standard used by machines to track time. The easiest
    thing to do within the NextBus API is to specify `0` for this value, which returns
    data for the last 15 minutes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个必需的参数（称为 `t`），它代表自 **1970 年纪元日期**（**1970 年 1 月 1 日午夜 UTC**）以来的毫秒数。纪元日期是机器用来跟踪时间的一个计算机标准。在
    NextBus API 中，最简单的事情就是为这个值指定 `0`，这将返回最后 15 分钟的数据。
- en: There is an optional `direction` tag that allows you to specify a terminating
    bus stop in the event a route has multiple buses running on the route in opposite
    directions. But, if we don't specify that, the API will return the first one,
    which suits our needs. The REST URL to get the mainline route for LA Metro looks
    like the following: [http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&a=lametro&r=2&t=0](http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&a=lametro&r=2&t=0).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可选的 `direction` 标签，允许你指定一个终止的公交车站，如果一条路线上有多个公交车在相反方向上运行。但是，如果我们不指定，API 将返回第一个，这符合我们的需求。获取洛杉矶地铁主线路线的
    REST URL 看起来如下所示：[http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&a=lametro&r=2&t=0](http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&a=lametro&r=2&t=0)。
- en: 'Calling this REST URL in a browser returns the following XML document:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中调用此 REST URL 返回以下 XML 文档：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each `vehicle` tag represents a location within the last 15 minutes. The `last`
    tag is the most recent location (even though XML is technically unordered).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `vehicle` 标签代表过去 15 分钟内的一个位置。`last` 标签是最新的位置（尽管 XML 在技术上是无序的）。
- en: These public transportation systems do not run all of the time. Many close down
    at 10:00 p.m. (22:00) local time. If you encounter an error in the script, use
    the NextBus website to locate a system that is running and change the agency and
    route variables to that system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些公共交通系统并非全天运行。许多在当地时间晚上 10:00（22:00）关闭。如果你在脚本中遇到错误，请使用 NextBus 网站定位一个正在运行的系统，并将机构变量和路线变量更改为该系统。
- en: We can now write a Python script that returns the locations for a bus on a given
    route. If we don't specify the `direction` tag, NextBus returns the first one.
    In this example, we are going to poll the NextBus tracking API by calling the
    REST URL using the built-in Python `urllib` library demonstrated in previous chapters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写一个 Python 脚本来返回给定路线上的公交车位置。如果我们不指定 `direction` 标签，NextBus 将返回第一个。在这个例子中，我们将通过调用
    REST URL 并使用之前章节中演示的内置 Python `urllib` 库来轮询 NextBus 跟踪 API。
- en: 'We''ll parse the returned XML document using the simple built-in `minidom`
    module, also shown in *The minidom module* section, in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)*,
    Geospatial Python Toolbox*. This script simply outputs the latest latitude and
    longitude of the route 2 bus. You will see the agency and route variables near
    the top. To do this, we need to follow the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简单内置的 `minidom` 模块解析返回的 XML 文档，该模块在 [第 4 章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)*The
    minidom module* 部分中也有介绍，这是 [Geospatial Python Toolbox*]。此脚本仅输出路线 2 公交的最新纬度和经度。你将在顶部看到机构和路线变量。为此，我们需要遵循以下步骤：
- en: 'First, we import the libraries we need:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we set up our variables for API mode and the customer and route we want
    to query:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们设置 API 模式和我们要查询的客户和路线的变量：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re going to set the time value to `0`, which will grab the last `15` minutes
    of data:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将时间值设置为 `0`，这将获取最后 `15` 分钟的数据：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we need to build the query URL that we''ll use to access the API:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要构建我们将用于访问 API 的查询 URL：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we can call the API using `urllib`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `urllib` 调用 API：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can access the results and print out the location of each bus:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以访问结果并打印出每辆公交车的位置：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The output of this script is simply a latitude and longitude value that implies
    that we now have control of the API and understand it. The output should be a
    coordinate value for the latitude and longitude.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出只是一个纬度和经度值，这意味着我们现在控制了 API 并理解了它。输出应该是纬度和经度的坐标值。
- en: Now we are ready to use these location values to create our own map.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用这些位置值来创建我们自己的地图。
- en: Mapping NextBus locations
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射 NextBus 位置
- en: The best source of freely available street mapping data is the **OpenStreetMap**
    (**OSM**) project: [http://www.openstreetmap.org](http://www.openstreetmap.org).
    OSM also has a publicly available REST API for creating static map images called
    **StaticMapLite**: [http://staticmap.openstreetmap.de](http://staticmap.openstreetmap.de).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可自由获取的街道地图数据最佳来源是 **OpenStreetMap** （**OSM**）项目：[http://www.openstreetmap.org](http://www.openstreetmap.org)。OSM
    还有一个公开可用的 REST API，用于创建静态地图图像，称为 **StaticMapLite**：[http://staticmap.openstreetmap.de](http://staticmap.openstreetmap.de)。
- en: The **OSM StaticMapLite API** provides a `GET` API based on Google's static
    map API to create simple map images with a limited number of point markers and
    lines. A `GET` API, as opposed to a REST, API allows you to append name/value
    parameter pairs after a question mark on the URL. A REST API makes the parameters
    part of the URL path. We'll use the API to create our own NextBus API map on-demand
    with a red pushpin icon for the bus location.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**OSM StaticMapLite API** 提供了一个基于 Google 静态地图 API 的 `GET` API，用于创建具有有限数量点标记和线条的简单地图图像。与
    REST API 相比，`GET` API 允许您在 URL 上的问号后附加名称/值参数对。REST API 将参数作为 URL 路径的一部分。我们将使用该
    API 按需创建我们的 NextBus API 地图，并为公交车位置使用红色推针图标。'
- en: In the next example, we have condensed the previous script down to a compact
    function named `nextbus()`. The `nextbus()` function accepts an agency, route,
    command, and epoch as arguments. The command defaults to `vehicleLocations` and
    the epoch defaults to `0` to get the last 15 minutes of data. In this script,
    we'll pass in the LA route-2 route information and use the default command that
    returns the most recent latitude/longitude of the bus.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将之前的脚本压缩成一个名为 `nextbus()` 的紧凑函数。`nextbus()` 函数接受一个机构、路线、命令和纪元作为参数。命令默认为
    `vehicleLocations`，纪元默认为 `0` 以获取最后 15 分钟的数据。在这个脚本中，我们将传递 LA 路线-2 的路线信息，并使用默认命令返回公交车的最新经纬度。
- en: We have a second function named `nextmap()` that creates a map with a purple
    marker on the current location of the bus each time it is called. The map is created
    by building a `GET` URL for the OSM `StaticMapLite` API, which centers on the
    location of the bus and uses a zoom level between *1-18* and the map size to determine
    the map extent.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `nextmap()` 的第二个函数，每次调用时都会在公交车的当前位置创建一个带有紫色标记的地图。地图是通过构建一个针对 OSM `StaticMapLite`
    API 的 `GET` URL 来创建的，该 URL 以公交车的位置为中心，并使用介于 *1-18* 之间的缩放级别和地图大小来确定地图范围。
- en: You can access the API directly in a browser to see an example of what the `nextmap()`
    function does. You will need a free MapQuest Developer API key available by registering
    here: [https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register).
    Once you have the key, insert it in the `key` parameter where it says `YOUR_API_KEY_HERE`.
    Then, you can test the following example URL: `https://www.mapquestapi.com/staticmap/v4/getmap?size=865,512&type=map&pois=mcenter,40.702147,-74.015794|&zoom=14&center=40.714728,-73.998672&imagetype=JPEG&key=YOUR_API_KEY_HERE`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在浏览器中访问 API，以查看 `nextmap()` 函数的示例。您需要通过在此处注册来获取免费的 MapQuest 开发者 API 密钥：[https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register)。一旦您有了密钥，将其插入到
    `key` 参数中，即 `YOUR_API_KEY_HERE`。然后，您可以测试以下示例 URL：`https://www.mapquestapi.com/staticmap/v4/getmap?size=865,512&type=map&pois=mcenter,40.702147,-74.015794|&zoom=14&center=40.714728,-73.998672&imagetype=JPEG&key=YOUR_API_KEY_HERE`。
- en: 'Static maps look similar to the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 静态地图看起来类似于以下这样：
- en: '![](img/71778fe8-ec15-4e7a-96f6-767d10ebeb4c.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71778fe8-ec15-4e7a-96f6-767d10ebeb4c.png)'
- en: 'The `nextmap()` function accepts a NextBus agency ID, route ID, and string
    for the base image name for the map. The function calls the `nextbus()` function
    to get the latitude/longitude pair. The execution of this program loops through
    at timed intervals, creates a map on the first pass, and then overwrites the map
    on subsequent passes. The program also outputs a timestamp each time a map is
    saved. The `requests` variable specifies the number of passes and the `freq` variable
    represents the time in seconds between each loop. Let''s check the following code
    to see how of this example works:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextmap()` 函数接受 NextBus 机构 ID、路线 ID 和地图的基本图像名称字符串。该函数调用 `nextbus()` 函数以获取经纬度对。该程序的执行在定时间隔内循环，第一次通过创建地图，然后在后续通过中覆盖地图。程序还会在每次保存地图时输出一个时间戳。`requests`
    变量指定通过次数，`freq` 变量代表每个循环之间的时间（以秒为单位）。让我们检查以下代码，看看这个例子是如何工作的：'
- en: 'First, we import the libraries we need:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we create a function that can get the latest location of a bus on a given
    route:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个函数，可以获取给定路线上一辆公交车的最新位置：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we have a function to plot a bus location on a map image:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个函数可以在地图图像上绘制公交车位置：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Within that function, we set up the API parameters in the URL:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该函数中，我们在URL中设置API参数：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can create the image by calling the URL and save it:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用URL并保存它来创建图像：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now in our main program, we can set up variables about the buses we want to
    track:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在我们的主程序中，我们可以设置我们想要跟踪的公交车的变量：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we can specify the number and frequency of tracking points we want:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以指定我们想要的跟踪点的数量和频率：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can begin tracking and updating our map image:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以开始跟踪和更新我们的地图图像：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While the script runs, you''ll see an output similar to the following, showing
    at what time the script saved each map:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当脚本运行时，你会看到类似以下输出的结果，显示脚本保存每张地图的时间：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This script saves a map image similar to the following, depending on where
    the bus was when you ran it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本保存的地图图像类似于以下内容，这取决于你运行脚本时公交车所在的位置：
- en: '![](img/c70b792f-51a9-45ae-a35d-bb152171205e.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c70b792f-51a9-45ae-a35d-bb152171205e.png)'
- en: This map is an excellent example of using an API to create a custom mapping
    product. But it is a very basic tracking application. To begin to develop it into
    a more interesting geospatial product, we need to combine it with some other real-time
    data source that gives us more situational awareness.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这张地图是使用API创建自定义地图产品的优秀示例。但它是一个非常基础的跟踪应用。为了开始将其开发成一个更有趣的地理空间产品，我们需要将其与其他实时数据源相结合，这些数据源能给我们提供更多的情境感知。
- en: Now that we can track buses, let's add some additional information to the map
    that would be useful to know for passengers taking a bus. Let's add some weather
    data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够跟踪公交车了，让我们添加一些对乘坐公交车的乘客有用的额外信息到地图上。让我们添加一些天气数据。
- en: Storm chasing
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴风雨追逐
- en: 'So far, we have created a simpler version of what the NextBus website already
    does. But we have done it in a way that ultimately gives us complete control over
    the output. Now we want to use this control to go beyond what the NextBus Google
    Maps mashup does. We''ll add another real-time data source that is very important
    to both travelers and bus-line operators: the weather.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个比NextBus网站所做更简单的版本。但我们以最终使我们完全控制输出的方式完成了它。现在我们想要使用这种控制来超越NextBus
    Google Maps混合应用所能做到的。我们将添加另一个对旅行者和公交车线路运营商都非常重要的实时数据源：天气。
- en: '**Iowa State University''s Mesonet** program provides free and polished weather
    data for applications. We use this data to create a real-time weather map for
    our bus location map. We can use the **Open Geospatial Consortium** (**OGC**)
    **Web Map Service** (**WMS**) standard to request a single image over our area
    of interest. A WMS is an OGC standard for serving georeferenced map images through
    the web; they are generated by a map server through an HTTP request.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**爱荷华州立大学的Mesonet项目**提供免费且经过精炼的天气数据，适用于各种应用。我们使用这些数据为我们的公交车位置地图创建实时天气地图。我们可以使用**开放地理空间联盟**（**OGC**）的**网络地图服务**（**WMS**）标准来请求我们感兴趣区域的单张图像。WMS是OGC的一个标准，通过互联网提供地理参考地图图像；它们通过地图服务器通过HTTP请求生成。'
- en: The Mesonet system provides an excellent web mapping service that returns a
    subsetted image from a global precipitation mosaic based on a properly-formatted
    WMS request. An example of such a request is the following query: [http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&LAYERS=nexrad-n0r&STYLES=&SRS=EPSG:900913&BBOX=-15269659.42,2002143.61,-6103682.81,7618920.15&WIDTH=600&HEIGHT=600&FORMAT=image/png](http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi?service=wms&version=1.1.1&request=getmap&layers=nexrad-n0r&styles=&srs=epsg:900913&bbox=-15269659.42,2002143.61,-6103682.81,7618920.15&width=600&height=600&format=image/png).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Mesonet系统提供了一个优秀的网络地图服务，该服务根据正确格式的WMS请求从全球降水镶嵌图中返回一个子集图像。以下是一个此类请求的示例查询：[http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&LAYERS=nexrad-n0r&STYLES=&SRS=EPSG:900913&BBOX=-15269659.42,2002143.61,-6103682.81,7618920.15&WIDTH=600&HEIGHT=600&FORMAT=image/png](http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi?service=wms&version=1.1.1&request=getmap&layers=nexrad-n0r&styles=&srs=epsg:900913&bbox=-15269659.42,2002143.61,-6103682.81,7618920.15&width=600&height=600&format=image/png)。
- en: 'Because the examples in this chapter rely on real-time data, the specific requests
    listed may produce blank weather images if there is no activity in the area of
    interest. You can visit this link ([http://radar.weather.gov/ridge/Conus/index.php](http://radar.weather.gov/ridge/Conus/index.php))
    to find an area where a storm is occurring. This page contains a KML link for
    Google Earth or QGIS. These WMS images are transparent PNG images similar to the
    following sample:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的示例依赖于实时数据，所列出的具体请求如果没有在感兴趣的区域有活动，可能会产生空白天气图像。您可以访问此链接（[http://radar.weather.gov/ridge/Conus/index.php](http://radar.weather.gov/ridge/Conus/index.php)）以找到正在发生风暴的区域。此页面包含Google
    Earth或QGIS的KML链接。这些WMS图像是类似于以下样本的透明PNG图像：
- en: '![](img/a39f31c3-a584-430b-89ba-8af09ac5ed71.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a39f31c3-a584-430b-89ba-8af09ac5ed71.png)'
- en: 'The OSM site, on the other hand, no longer provides its street maps via WMS—only
    as tiles. They do, however, allow other organizations to download tiles or raw
    data to extend the free service. The US **National Oceanic and Atmospheric Administration**
    (**NOAA**) has done just that and provided a WMS interface to their OSM data,
    allowing requests to retrieve the single basemap image we need for our bus route:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，OSM网站不再通过WMS提供其街道地图——只提供瓦片。然而，他们允许其他组织下载瓦片或原始数据以扩展免费服务。美国**国家海洋和大气管理局**（**NOAA**）就是这样做的，并为他们的OSM数据提供了一个WMS接口，允许请求检索我们需要的单个基图图像，用于我们的公交路线：
- en: '![](img/c228131d-66db-41f5-8c00-5c42b22efbb2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c228131d-66db-41f5-8c00-5c42b22efbb2.png)'
- en: 'We now have data sources from which to get the basemap and weather data. We
    want to combine these images and plot the current location of the bus. Instead
    of a simple dot, we''ll get a little more sophisticated and add the following
    bus icon this time:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了获取基图和天气数据的数据源。我们想要将这些图像合并并绘制公交车的当前位置。而不是一个简单的点，这次我们将更加复杂，并添加以下公交图标：
- en: '![](img/c064e817-54d8-4b76-91db-aad622f3b828.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c064e817-54d8-4b76-91db-aad622f3b828.png)'
- en: "You will need to download this icon, `busicon.png`, to your working directory\
    \ \Lfrom here: [https://github.com/GeospatialPython/Learn/blob/master/busicon.png?raw=true](https://github.com/GeospatialPython/Learn/blob/master/busicon.png?raw=true)."
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从以下链接下载此图标`busicon.png`到您的当前工作目录：[https://github.com/GeospatialPython/Learn/blob/master/busicon.png?raw=true](https://github.com/GeospatialPython/Learn/blob/master/busicon.png?raw=true)。
- en: "Now we'll combine our previous scripts and our new data sources to create a\
    \ real-time weather bus map. Because we are going to blend the street map and\
    \ weather map, we'll need the **Python Imaging Library** (**PIL**) used in previous\
    \ chapters. We'll replace our `nextmap()` function from the previous example with\
    \ a simple `wms()` function that can grab a map image by a bounding box from any\
    \ WMS service. \LWe'll also add a function that converts decimal degrees into\
    \ meters, named `ll2m()`."
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将结合之前编写的脚本和新的数据源来创建一个实时天气公交地图。由于我们将融合街道地图和天气地图，我们需要使用之前章节中提到的**Python图像处理库**（**PIL**）。我们将用之前示例中的`nextmap()`函数替换为一个简单的`wms()`函数，该函数可以从任何WMS服务中通过边界框获取地图图像。此外，我们还将添加一个将十进制度数转换为米的函数，命名为`ll2m()`。
- en: "The script gets the bus location, converts the location to meters, creates\
    \ a 2 mile (3.2 km) rectangle around the location, and then downloads a street\
    \ and weather map. The map images are then blended together using PIL. PIL then\
    \ shrinks the \L\Lbus icon image to 30 x 30 pixels and pastes it in the center\
    \ of the map, which is the bus location. Let's look at how the following code\
    \ works:"
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本获取公交车位置，将位置转换为米，在位置周围创建一个2英里（3.2公里）的矩形，然后下载街道和天气地图。然后使用PIL将地图图像混合在一起。PIL然后将公交车图标图像缩小到30
    x 30像素，并将其粘贴在地图的中心，即公交车位置。让我们看看以下代码是如何工作的：
- en: 'First, we''ll import the libraries we need:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入所需的库：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we''ll reuse our `nextbus` function from the previous example to get the
    bus tracking data:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将重用之前示例中的`nextbus`函数来获取公交跟踪数据：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also need a function to convert latitude and longitude into meters:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个将纬度和经度转换为米的函数：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we need a function to retrieve WMS map images, which we''ll use for our
    weather image:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个函数来检索WMS地图图像，我们将使用它来获取天气图像：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can set up all of the variables in our main program to use our functions:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以设置主程序中的所有变量以使用我们的函数：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we''re ready to get our bus location:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好获取我们的公交车位置：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we can download our street map:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以下载我们的街道地图：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can download the weather map:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以下载天气地图：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can overlay the weather data on the bus map:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将天气数据叠加到公交地图上：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we need to add the bus icon to our combined map to show the bus''s location:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将公交图标添加到我们的组合地图中，以显示公交车的位置：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we can save the finished map:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以保存完成的地图：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This script will produce a map similar to the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将生成一个类似于以下地图：
- en: '![](img/5cda48cd-bba9-4174-bade-c1577c918866.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5cda48cd-bba9-4174-bade-c1577c918866.png)'
- en: The map shows us that the bus is experiencing moderate precipitation at its
    current location. The color ramp, as shown in the Mesonet website screenshot earlier,
    ranges from light blue for light precipitation, then green, yellow, orange, to
    red as the rain gets heavier (or light gray to darker gray in black and white).
    So, at the time this map was created, the bus-line operator could use this image
    to tell their drivers to go a little slower, and passengers will know they may
    want to get an umbrella before heading to the bus stop.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 地图显示公交车在其当前位置正经历中等降水。颜色渐变，如之前Mesonet网站截图所示，从浅蓝色（轻度降水）到绿色、黄色、橙色，最后到红色（或黑白中的浅灰色到深灰色），随着雨势加大。因此，在创建此地图时，公交车线路运营商可以使用此图像告诉他们的司机开慢一点，乘客也会知道在前往公交车站之前可能需要拿一把伞。
- en: Because we wanted to learn the NextBus API at a low level, we used the API directly
    using built-in Python modules. But several third-party Python modules exist for
    the API including one on PyPI, simply called `nextbus`, which allows you to work
    with higher-level objects for all of the NextBus commands and provides more robust
    error handling not included in the simple examples in this chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想从底层学习NextBus API，我们直接使用内置的Python模块来使用API。但存在几个用于API的第三方Python模块，包括PyPI上名为`nextbus`的一个，它允许你使用所有NextBus命令的高级对象，并提供比本章简单示例中不包括的更健壮的错误处理。
- en: Now that we've learned how to check the weather, let's combine discrete real-time
    data sources into more meaningful products using Python, HTML, and JavaScript.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何检查天气，让我们使用Python、HTML和JavaScript将离散的实时数据源组合成更有意义的产品。
- en: Reports from the field
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现场报告
- en: In our final example in this chapter, we'll get off of the bus and out into
    the field. Modern smartphones, tablets, and laptops allow us to update a GIS and
    view those updates from everywhere. We'll use HTML, GeoJSON, the Leaflet JavaScript
    library, and a pure-Python library named Folium to create a client-server application
    that allows us to post geospatial information to a server and then create an interactive
    web map to view those data updates.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个示例中，我们将从公交车上下来，进入现场。现代智能手机、平板电脑和笔记本电脑使我们能够从任何地方更新GIS并查看这些更新。我们将使用HTML、GeoJSON、Leaflet
    JavaScript库以及一个名为Folium的纯Python库来创建一个客户端-服务器应用程序，允许我们将地理空间信息发布到服务器，然后创建一个交互式网络地图来查看这些数据更新。
- en: First, we need a web form that shows your current location and updates the server
    when you submit the form with comments about your location. You can find the form
    here: [http://geospatialpython.github.io/Learn/fieldwork.html](http://geospatialpython.github.io/Learn/fieldwork.html).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个Web表单，它显示你的当前位置，并在你提交表单并附上关于你位置的评论时更新服务器。你可以在以下位置找到该表单：[http://geospatialpython.github.io/Learn/fieldwork.html](http://geospatialpython.github.io/Learn/fieldwork.html)。
- en: 'The following screenshot shows the form:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了表单：
- en: '![](img/c4cf73ba-0a9f-45f8-be5b-25e5cd783c08.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4cf73ba-0a9f-45f8-be5b-25e5cd783c08.png)'
- en: You can view the source of that form to see how it works. The mapping is done
    using the Leaflet library and posts GeoJSON to a unique URL on [myjson.com](http://myjson.com/).
    You can use this page on mobile devices, move it to any web server, or even use
    it on your local hard drive.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看该表单的源代码以了解其工作原理。映射是通过Leaflet库完成的，并将GeoJSON发布到[myjson.com](http://myjson.com/)上的一个独特URL。你可以在移动设备上使用此页面，将其移动到任何Web服务器，甚至可以在你的本地硬盘上使用它。
- en: The form posts to the following URL publicly on [myjson.com](http://myjson.com/): [https://api.myjson.com/bins/467pm](https://api.myjson.com/bins/467pm).
    You can visit that URL in a browser to see the raw GeoJSON.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表单发布到以下公开URL在[myjson.com](http://myjson.com/)上：[https://api.myjson.com/bins/467pm](https://api.myjson.com/bins/467pm)。你可以在浏览器中访问该URL以查看原始GeoJSON。
- en: Next, you need to install the Folium library from PyPI. Folium provides a simple
    Python API for creating Leaflet web maps. You can find more information about
    Folium here: [https://github.com/python-visualization/folium](https://github.com/python-visualization/folium).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要从PyPI安装Folium库。Folium提供了一个简单的Python API来创建Leaflet网络地图。你可以在以下位置找到更多关于Folium的信息：[https://github.com/python-visualization/folium](https://github.com/python-visualization/folium)。
- en: 'Folium makes producing a Leaflet map extremely simple. This script is just
    a few lines and will output a web page named `map.html`. We pass the GeoJSON URL
    to the `map` object, which will plot the locations on the map:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Folium使得制作Leaflet地图变得极其简单。这个脚本只有几行，并将输出一个名为`map.html`的网页。我们传递GeoJSON URL给`map`对象，它将在地图上绘制位置：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The resulting interactive map will display points as markers. When you click
    on a marker, the information from the form is displayed. You can just open the
    HTML file in any browser.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的交互式地图将以标记的形式显示点。当你点击一个标记时，表单中的信息将被显示出来。你只需在任何浏览器中打开HTML文件即可。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Real-time data is an exciting way to do new types of geospatial analysis, only
    recently made possible by advances in several different technologies, including
    web mapping, GPS, and wireless communications. In this chapter, you learned how
    to access raw feeds for real-time location data, how to acquire a subset of real-time
    raster data, how to combine different types of real-time data into a custom map
    analysis product using only Python, and how to build client-server geospatial
    applications to update a GIS in real-time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实时数据是进行新型地理空间分析的一种令人兴奋的方式，这是由包括网络地图、GPS和无线通信在内的多种不同技术的进步才最近才成为可能。在本章中，你学习了如何访问实时位置数据的原始数据流，如何获取实时栅格数据的子集，如何仅使用Python将不同类型的实时数据组合成定制的地图分析产品，以及如何构建客户端-服务器地理空间应用程序以实时更新GIS。
- en: As with previous chapters, these examples contain building blocks that will
    let you build new types of application using Python that go far beyond the typical
    popular and ubiquitous JavaScript-based mashups.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的章节一样，这些示例包含构建块，将使你能够使用Python构建新的应用程序类型，这些应用程序远远超出了典型的基于JavaScript的流行和普遍的混合应用。
- en: In the next chapter, we will combine everything we've learned so far into a
    complete geospatial application that applies algorithms and concepts in a realistic
    scenario.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把迄今为止所学的一切结合成一个完整的地理空间应用程序，在现实场景中应用算法和概念。
