- en: Real-Time Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common saying among geospatial analysts is: *A map is outdated as soon as
    it''s created*. This saying reflects the fact that the Earth and everything on
    it are constantly changing. For most of the history of geospatial analysis and
    through most of this book, geospatial products are relatively static. Raw datasets
    are typically updated anywhere from a few months to a few years. The age of geospatial
    data in a map is referred to as **data currency**.'
  prefs: []
  type: TYPE_NORMAL
- en: Data currency has traditionally not been the primary focus because of the time
    and expense needed to collect data. Web mapping, wireless cellular modems, and
    low-cost GPS antennas have changed that focus. It is now logistically feasible
    and even quite affordable to monitor a rapidly changing object or system and broadcast
    those changes to millions of people online. This change is revolutionizing geospatial
    technology and taking it in new directions. The most direct evidence of this revolution
    is web mapping mashups using systems such as Google Maps or OpenLayers and web-accessible
    data formats. Every day, more and more electronic devices are being brought online
    to broadcast their location and data for automation or remote control. Examples
    include thermostats, cameras, cars, and more. You can also use cheap, embedded
    computers such as the popular Raspberry Pi to turn almost anything into a connected
    **smart** device. This concept of connecting devices into a web of data and information
    is called **The Internet of Things** (**IoT**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be checking out the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of real-time data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using real-time data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking vehicles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storm chasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reports from the field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end, you'll have learned to work with real-time geospatial data, and
    will be able to build a field reporting tool that can serve as a data transmission
    source for any type of data.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.6 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RAM: Minimum 6 GB (Windows), 8 GB (macOS), recommended 8 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage: Minimum 7200 RPM SATA with 20 GB of available space, and recommended
    SSD with 40 GB of available space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processor: Minimum Intel Core i3 2.5 GHz, and recommended Intel Core i5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MapQuest Developer API key, available here: [https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of real-time data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term **real-time data** typically means near-real-time. Some tracking devices
    capture real-time data and may update as often as several times a second. But
    the limitations of the infrastructure that broadcasts that data may constrain
    the output to every 10 seconds or longer. Weather radar is a perfect example.
    A **Doppler Weather Radar** (**DWR**) sweeps continuously but data is typically
    available online every five minutes. But given the contrast with traditional geospatial
    data updates, a refresh of a few minutes is real-time enough. Limitations can
    be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Network bandwidth limitations restricting data size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network latency limiting the data update frequency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability of the data source due to restrictions such as battery life
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of quality control due to data being instantly available to consumers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security vulnerabilities due to rapid ingestion of unverified data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time data opens up additional opportunities for geospatial applications
    so we'll look at using it next.
  prefs: []
  type: TYPE_NORMAL
- en: Using real-time data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web mashups often use real-time data. Web mashups are amazing and have changed
    the way many different industries operate. But they are typically limited in that
    they usually just display pre-processed data on a map and give developers access
    to a JavaScript API. But what if you want to process the data in some way? What
    if you want to filter, change, and then send it to another system? To use real-time
    data for geospatial analysis, you need to be able to access it as point data or
    a georeferenced raster.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about web map mashups here: [https://www.esri.com/arcgis-blog/products/product/uncategorized/digital-map-mashups/](https://www.esri.com/arcgis-blog/products/product/uncategorized/digital-map-mashups/).
  prefs: []
  type: TYPE_NORMAL
- en: As with examples in the previous chapters, the scripts are as simple as possible
    and designed to be read from start to finish without much mental looping. When
    functions are used they are listed first, followed by script variable declarations,
    and finally the main program execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how to access a real-time and point-location data source using
    vehicles from the NextBus API.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking vehicles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our first real-time data source, we'll use the excellent **NextBus API**.
    NextBus ([http://www.nextbus.com/](http://www.nextbus.com/)) is a commercial service
    that tracks public transportation for municipalities including buses, trolleys,
    and trains. People riding these transit lines can then track the arrival time
    of the *next bus*.
  prefs: []
  type: TYPE_NORMAL
- en: What's even better is that, with the customer's permission, NextBus publishes
    tracking data through a **REpresentational State Transfer** (**REST**) **API.** Using
    URL API calls, developers can request information about a vehicle and receive
    an XML document about its location. This API is a straightforward way to begin
    using real-time data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to NextBus, you''ll see a web interface as shown in the following
    screenshot, showing data for the city of Los Angeles, California metro system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9af21cb9-55b2-4dc1-8b1d-878b4e3622ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The system lets you select several parameters to learn the current location
    and time prediction for the next stop. On the right side of the screen, there
    is a link to a Google Maps mashup, showing transit tracking data for the particular
    route as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/624abf09-c442-4370-88ed-9a586eb84972.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a very useful website but it does not give us control over how the data
    is displayed and used. Let's access the raw data directly using Python and the
    NextBus REST API to start working with real-time data.
  prefs: []
  type: TYPE_NORMAL
- en: For the examples in this chapter, we'll use the documented NextBus API found
    here: [http://www.nextbus.com/xmlFeedDocs/NextBusXMLFeed.pdf](http://www.nextbus.com/xmlFeedDocs/NextBusXMLFeed.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: To start with this example, we will need a list of buses required.
  prefs: []
  type: TYPE_NORMAL
- en: The NextBus agency list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NextBus customers are called **agencies**. In our examples, we are going to
    track buses on a route for Los Angeles, California. First, we need to get some
    information about the agency. The NextBus API consists of a web service named
    `publicXMLFeed`, in which you set a parameter named `command`. We'll call the
    `agencyList` command in a browser to get an XML document containing agency information
    using the following REST URL: [http://webservices.nextbus.com/service/publicXMLFeed?command=agencyList](http://webservices.nextbus.com/service/publicXMLFeed?command=agencyList).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we go to that link in a browser, it returns an XML document containing
    the `<agency/>` tag. The tag for Los Angeles looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a list of buses, we need to get the routes they can travel.
  prefs: []
  type: TYPE_NORMAL
- en: The NextBus route list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tag` attribute is the ID for Thunder Bay, which we need for other NextBus
    API commands. The other attributes are human-readable metadata. The next piece
    of information we need is the details about the **route 2** bus route. To get
    this information, we'll use the agency ID and the `routeList` REST command to
    get another XML document by pasting the URL into our web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the agency ID is set to the parameter in the REST URL: [http://webservices.nextbus.com/service/publicXMLFeed?command=routeList&a=lametro](http://webservices.nextbus.com/service/publicXMLFeed?command=routeList&a=lametro).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call this URL in a browser, we get the following XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have buses and routes. We're ready to start tracking their locations!
  prefs: []
  type: TYPE_NORMAL
- en: NextBus vehicle locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "So the mainline route ID stored in the `tag` attribute is simply `1`, according\
    \ to \Lthese results. Thus, now, we have all of the information we need to track\
    \ buses along the **LA Metro route 2**."
  prefs: []
  type: TYPE_NORMAL
- en: There is only one more required parameter (called `t`) that represents milliseconds
    since the **1970 epoch date** (**January 1, 1970, at midnight UTC**). The epoch
    date is simply a computer standard used by machines to track time. The easiest
    thing to do within the NextBus API is to specify `0` for this value, which returns
    data for the last 15 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: There is an optional `direction` tag that allows you to specify a terminating
    bus stop in the event a route has multiple buses running on the route in opposite
    directions. But, if we don't specify that, the API will return the first one,
    which suits our needs. The REST URL to get the mainline route for LA Metro looks
    like the following: [http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&a=lametro&r=2&t=0](http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&a=lametro&r=2&t=0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling this REST URL in a browser returns the following XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each `vehicle` tag represents a location within the last 15 minutes. The `last`
    tag is the most recent location (even though XML is technically unordered).
  prefs: []
  type: TYPE_NORMAL
- en: These public transportation systems do not run all of the time. Many close down
    at 10:00 p.m. (22:00) local time. If you encounter an error in the script, use
    the NextBus website to locate a system that is running and change the agency and
    route variables to that system.
  prefs: []
  type: TYPE_NORMAL
- en: We can now write a Python script that returns the locations for a bus on a given
    route. If we don't specify the `direction` tag, NextBus returns the first one.
    In this example, we are going to poll the NextBus tracking API by calling the
    REST URL using the built-in Python `urllib` library demonstrated in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll parse the returned XML document using the simple built-in `minidom`
    module, also shown in *The minidom module* section, in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)*,
    Geospatial Python Toolbox*. This script simply outputs the latest latitude and
    longitude of the route 2 bus. You will see the agency and route variables near
    the top. To do this, we need to follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the libraries we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set up our variables for API mode and the customer and route we want
    to query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to set the time value to `0`, which will grab the last `15` minutes
    of data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to build the query URL that we''ll use to access the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can call the API using `urllib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can access the results and print out the location of each bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The output of this script is simply a latitude and longitude value that implies
    that we now have control of the API and understand it. The output should be a
    coordinate value for the latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to use these location values to create our own map.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping NextBus locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best source of freely available street mapping data is the **OpenStreetMap**
    (**OSM**) project: [http://www.openstreetmap.org](http://www.openstreetmap.org).
    OSM also has a publicly available REST API for creating static map images called
    **StaticMapLite**: [http://staticmap.openstreetmap.de](http://staticmap.openstreetmap.de).
  prefs: []
  type: TYPE_NORMAL
- en: The **OSM StaticMapLite API** provides a `GET` API based on Google's static
    map API to create simple map images with a limited number of point markers and
    lines. A `GET` API, as opposed to a REST, API allows you to append name/value
    parameter pairs after a question mark on the URL. A REST API makes the parameters
    part of the URL path. We'll use the API to create our own NextBus API map on-demand
    with a red pushpin icon for the bus location.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we have condensed the previous script down to a compact
    function named `nextbus()`. The `nextbus()` function accepts an agency, route,
    command, and epoch as arguments. The command defaults to `vehicleLocations` and
    the epoch defaults to `0` to get the last 15 minutes of data. In this script,
    we'll pass in the LA route-2 route information and use the default command that
    returns the most recent latitude/longitude of the bus.
  prefs: []
  type: TYPE_NORMAL
- en: We have a second function named `nextmap()` that creates a map with a purple
    marker on the current location of the bus each time it is called. The map is created
    by building a `GET` URL for the OSM `StaticMapLite` API, which centers on the
    location of the bus and uses a zoom level between *1-18* and the map size to determine
    the map extent.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the API directly in a browser to see an example of what the `nextmap()`
    function does. You will need a free MapQuest Developer API key available by registering
    here: [https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register](https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register).
    Once you have the key, insert it in the `key` parameter where it says `YOUR_API_KEY_HERE`.
    Then, you can test the following example URL: `https://www.mapquestapi.com/staticmap/v4/getmap?size=865,512&type=map&pois=mcenter,40.702147,-74.015794|&zoom=14&center=40.714728,-73.998672&imagetype=JPEG&key=YOUR_API_KEY_HERE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static maps look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71778fe8-ec15-4e7a-96f6-767d10ebeb4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `nextmap()` function accepts a NextBus agency ID, route ID, and string
    for the base image name for the map. The function calls the `nextbus()` function
    to get the latitude/longitude pair. The execution of this program loops through
    at timed intervals, creates a map on the first pass, and then overwrites the map
    on subsequent passes. The program also outputs a timestamp each time a map is
    saved. The `requests` variable specifies the number of passes and the `freq` variable
    represents the time in seconds between each loop. Let''s check the following code
    to see how of this example works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the libraries we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a function that can get the latest location of a bus on a given
    route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a function to plot a bus location on a map image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Within that function, we set up the API parameters in the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create the image by calling the URL and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in our main program, we can set up variables about the buses we want to
    track:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can specify the number and frequency of tracking points we want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can begin tracking and updating our map image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While the script runs, you''ll see an output similar to the following, showing
    at what time the script saved each map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This script saves a map image similar to the following, depending on where
    the bus was when you ran it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c70b792f-51a9-45ae-a35d-bb152171205e.png)'
  prefs: []
  type: TYPE_IMG
- en: This map is an excellent example of using an API to create a custom mapping
    product. But it is a very basic tracking application. To begin to develop it into
    a more interesting geospatial product, we need to combine it with some other real-time
    data source that gives us more situational awareness.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can track buses, let's add some additional information to the map
    that would be useful to know for passengers taking a bus. Let's add some weather
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Storm chasing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have created a simpler version of what the NextBus website already
    does. But we have done it in a way that ultimately gives us complete control over
    the output. Now we want to use this control to go beyond what the NextBus Google
    Maps mashup does. We''ll add another real-time data source that is very important
    to both travelers and bus-line operators: the weather.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iowa State University''s Mesonet** program provides free and polished weather
    data for applications. We use this data to create a real-time weather map for
    our bus location map. We can use the **Open Geospatial Consortium** (**OGC**)
    **Web Map Service** (**WMS**) standard to request a single image over our area
    of interest. A WMS is an OGC standard for serving georeferenced map images through
    the web; they are generated by a map server through an HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: The Mesonet system provides an excellent web mapping service that returns a
    subsetted image from a global precipitation mosaic based on a properly-formatted
    WMS request. An example of such a request is the following query: [http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&LAYERS=nexrad-n0r&STYLES=&SRS=EPSG:900913&BBOX=-15269659.42,2002143.61,-6103682.81,7618920.15&WIDTH=600&HEIGHT=600&FORMAT=image/png](http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi?service=wms&version=1.1.1&request=getmap&layers=nexrad-n0r&styles=&srs=epsg:900913&bbox=-15269659.42,2002143.61,-6103682.81,7618920.15&width=600&height=600&format=image/png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the examples in this chapter rely on real-time data, the specific requests
    listed may produce blank weather images if there is no activity in the area of
    interest. You can visit this link ([http://radar.weather.gov/ridge/Conus/index.php](http://radar.weather.gov/ridge/Conus/index.php))
    to find an area where a storm is occurring. This page contains a KML link for
    Google Earth or QGIS. These WMS images are transparent PNG images similar to the
    following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a39f31c3-a584-430b-89ba-8af09ac5ed71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The OSM site, on the other hand, no longer provides its street maps via WMS—only
    as tiles. They do, however, allow other organizations to download tiles or raw
    data to extend the free service. The US **National Oceanic and Atmospheric Administration**
    (**NOAA**) has done just that and provided a WMS interface to their OSM data,
    allowing requests to retrieve the single basemap image we need for our bus route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c228131d-66db-41f5-8c00-5c42b22efbb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have data sources from which to get the basemap and weather data. We
    want to combine these images and plot the current location of the bus. Instead
    of a simple dot, we''ll get a little more sophisticated and add the following
    bus icon this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c064e817-54d8-4b76-91db-aad622f3b828.png)'
  prefs: []
  type: TYPE_IMG
- en: "You will need to download this icon, `busicon.png`, to your working directory\
    \ \Lfrom here: [https://github.com/GeospatialPython/Learn/blob/master/busicon.png?raw=true](https://github.com/GeospatialPython/Learn/blob/master/busicon.png?raw=true)."
  prefs: []
  type: TYPE_NORMAL
- en: "Now we'll combine our previous scripts and our new data sources to create a\
    \ real-time weather bus map. Because we are going to blend the street map and\
    \ weather map, we'll need the **Python Imaging Library** (**PIL**) used in previous\
    \ chapters. We'll replace our `nextmap()` function from the previous example with\
    \ a simple `wms()` function that can grab a map image by a bounding box from any\
    \ WMS service. \LWe'll also add a function that converts decimal degrees into\
    \ meters, named `ll2m()`."
  prefs: []
  type: TYPE_NORMAL
- en: "The script gets the bus location, converts the location to meters, creates\
    \ a 2 mile (3.2 km) rectangle around the location, and then downloads a street\
    \ and weather map. The map images are then blended together using PIL. PIL then\
    \ shrinks the \L\Lbus icon image to 30 x 30 pixels and pastes it in the center\
    \ of the map, which is the bus location. Let's look at how the following code\
    \ works:"
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll import the libraries we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll reuse our `nextbus` function from the previous example to get the
    bus tracking data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a function to convert latitude and longitude into meters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need a function to retrieve WMS map images, which we''ll use for our
    weather image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can set up all of the variables in our main program to use our functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to get our bus location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can download our street map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can download the weather map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can overlay the weather data on the bus map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the bus icon to our combined map to show the bus''s location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can save the finished map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will produce a map similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cda48cd-bba9-4174-bade-c1577c918866.png)'
  prefs: []
  type: TYPE_IMG
- en: The map shows us that the bus is experiencing moderate precipitation at its
    current location. The color ramp, as shown in the Mesonet website screenshot earlier,
    ranges from light blue for light precipitation, then green, yellow, orange, to
    red as the rain gets heavier (or light gray to darker gray in black and white).
    So, at the time this map was created, the bus-line operator could use this image
    to tell their drivers to go a little slower, and passengers will know they may
    want to get an umbrella before heading to the bus stop.
  prefs: []
  type: TYPE_NORMAL
- en: Because we wanted to learn the NextBus API at a low level, we used the API directly
    using built-in Python modules. But several third-party Python modules exist for
    the API including one on PyPI, simply called `nextbus`, which allows you to work
    with higher-level objects for all of the NextBus commands and provides more robust
    error handling not included in the simple examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned how to check the weather, let's combine discrete real-time
    data sources into more meaningful products using Python, HTML, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Reports from the field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our final example in this chapter, we'll get off of the bus and out into
    the field. Modern smartphones, tablets, and laptops allow us to update a GIS and
    view those updates from everywhere. We'll use HTML, GeoJSON, the Leaflet JavaScript
    library, and a pure-Python library named Folium to create a client-server application
    that allows us to post geospatial information to a server and then create an interactive
    web map to view those data updates.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need a web form that shows your current location and updates the server
    when you submit the form with comments about your location. You can find the form
    here: [http://geospatialpython.github.io/Learn/fieldwork.html](http://geospatialpython.github.io/Learn/fieldwork.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4cf73ba-0a9f-45f8-be5b-25e5cd783c08.png)'
  prefs: []
  type: TYPE_IMG
- en: You can view the source of that form to see how it works. The mapping is done
    using the Leaflet library and posts GeoJSON to a unique URL on [myjson.com](http://myjson.com/).
    You can use this page on mobile devices, move it to any web server, or even use
    it on your local hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: The form posts to the following URL publicly on [myjson.com](http://myjson.com/): [https://api.myjson.com/bins/467pm](https://api.myjson.com/bins/467pm).
    You can visit that URL in a browser to see the raw GeoJSON.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to install the Folium library from PyPI. Folium provides a simple
    Python API for creating Leaflet web maps. You can find more information about
    Folium here: [https://github.com/python-visualization/folium](https://github.com/python-visualization/folium).
  prefs: []
  type: TYPE_NORMAL
- en: 'Folium makes producing a Leaflet map extremely simple. This script is just
    a few lines and will output a web page named `map.html`. We pass the GeoJSON URL
    to the `map` object, which will plot the locations on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The resulting interactive map will display points as markers. When you click
    on a marker, the information from the form is displayed. You can just open the
    HTML file in any browser.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-time data is an exciting way to do new types of geospatial analysis, only
    recently made possible by advances in several different technologies, including
    web mapping, GPS, and wireless communications. In this chapter, you learned how
    to access raw feeds for real-time location data, how to acquire a subset of real-time
    raster data, how to combine different types of real-time data into a custom map
    analysis product using only Python, and how to build client-server geospatial
    applications to update a GIS in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: As with previous chapters, these examples contain building blocks that will
    let you build new types of application using Python that go far beyond the typical
    popular and ubiquitous JavaScript-based mashups.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will combine everything we've learned so far into a
    complete geospatial application that applies algorithms and concepts in a realistic
    scenario.
  prefs: []
  type: TYPE_NORMAL
