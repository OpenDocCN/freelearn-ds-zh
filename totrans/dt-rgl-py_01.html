<html><head></head><body><div><div><h1 id="_idParaDest-13"><em class="italics"><a id="_idTextAnchor017"/>Chapter 1</em></h1>
		</div>
		<div><h1 id="_idParaDest-14"><a id="_idTextAnchor018"/>Introduction to Data Wrangling with Python</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to do the following:</p>
			<ul>
				<li class="bullets">Define the importance of data wrangling in data science</li>
				<li class="bullets">Manipulate the data structures that are available in Python</li>
				<li class="bullets">Compare the different implementations of the inbuilt Python data structures</li>
			</ul>
			<p>This chapter describes the importance of data wrangling, identifies the important tasks to be performed in data wrangling, and introduces basic Python data structures.</p>
		</div>
		<div><h2 id="_idParaDest-15"><a id="_idTextAnchor019"/>Introduction</h2>
			<p>Data science and analytics are taking over the whole world and the job of a data scientist is routinely being called the coolest job of the 21st century. But for all the emphasis on data, it is the science that makes you – the practitioner – truly valuable.</p>
			<p>To practice high-quality science with data, you need to make sure it is properly sourced, cleaned, formatted, and pre-processed. This book teaches you the most essential basics of this invaluable component of the data science pipeline: data wrangling. In short, data wrangling is the process that ensures that the data is in a format that is clean, accurate, formatted, and ready to be used for data analysis.</p>
			<p>A prominent example of data wrangling with a large amount of data is the one conducted at the Supercomputer Center of University of California San Diego (UCSD). The problem in California is that wildfires are very common, mainly because of the dry weather and extreme heat, especially during the summers. Data scientists at the UCSD Supercomputer Center gather data to predict the nature and spread direction of the fire. The data that comes from diverse sources such as weather stations, sensors in the forest, fire stations, satellite imagery, and Twitter feeds might still be incomplete or missing. This data needs to be cleaned and formatted so that it can be used to predict future occurrences of wildfires.</p>
			<p>This is an example of how data wrangling and data science can prove to be helpful and relevant.</p>
			<h3 id="_idParaDest-16"><a id="_idTextAnchor020"/>Importance of Data Wrangling</h3>
			<p>Oil does not come in its final form from the rig; it has to be refined. Similarly, data must be curated, massaged, and refined to be used in intelligent algorithms and consumer products. This is known as wrangling. Most data scientists spend the majority of their time data wrangling.  </p>
			<p>Data wrangling is generally done at the very first stage of a data science/analytics pipeline. After the data scientists identify useful data sources for solving the business problem (for instance, in-house database storage or internet or streaming sensor data), they then proceed to extract, clean, and format the necessary data from those sources.</p>
			<p>Generally, the task of data wrangling involves the following steps:</p>
			<ul>
				<li>Scraping raw data from multiple sources (including web and database tables)</li>
				<li>Imputing, formatting, and transforming – basically making it ready to be used in the modeling process (such as advanced machine learning) </li>
				<li>Handling read/write errors </li>
				<li>Detecting outliers</li>
				<li>Performing quick visualizations (plotting) and basic statistical analysis to judge the quality of your formatted data</li>
			</ul>
			<p>This is an illustrative representation of the positioning and essential functional role of data wrangling in a typical data science pipeline:</p>
			<div><div><img src="img/Figure_1.1.jpg" alt="Figure 1.1: Process of data wrangling" width="1280" height="720"/>
				</div>
			</div>
			<h6>Figure 1.1: Process of data wrangling</h6>
			<p>The process of data wrangling <a id="_idTextAnchor021"/>includes first finding the appropriate data that's necessary for the analysis. This data can be from one or multiple sources, such as tweets, bank transaction statements in a relational database, sensor data, and so on. This data needs to be cleaned. If there is missing data, we will either delete or substitute it, with the help of several techniques. If there are outliers, we need to first detect them and then handle them appropriately. If data is from multiple sources, we will have to perform join operations to combine it.</p>
			<p>In an extremely rare situation, data wrangling may not be needed. For example, if the data that's necessary for a machine learning task is already stored in an acceptable format in an in-house database, then a simple SQL query may be enough to extract the data into a table, ready to be passed on to the modeling stage.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor022"/>Python for Data Wrangling</h2>
			<p>There is always a debate on whether to perform the wrangling process using an enterprise tool or by using a programming language and associated frameworks. There are many commercial, enterprise-level tools for data formatting and pre-processing that do not involve much coding on the part of the user. These examples include the following:</p>
			<ul>
				<li>General purpose data analysis platforms such as Microsoft Excel (with add-ins)</li>
				<li>Statistical discovery package such as <strong class="keyword">JMP</strong> (from SAS)</li>
				<li>Modeling platforms such as <strong class="keyword">RapidMiner</strong></li>
				<li>Analytics platforms from niche players focusing on data wrangling, such as <strong class="keyword">Trifacta</strong>, <strong class="keyword">Paxata</strong>, and <strong class="keyword">Alteryx</strong></li>
			</ul>
			<p>However, programming languages such as Python provide more flexibility, control, and power compared to these off-the-shelf tools. </p>
			<p>As the volume, velocity, and variety (the three Vs of <strong class="keyword">big data</strong>) of data undergo rapid changes, it is always a good idea to develop and nurture a significant amount of in-house expertise in data wrangling using fundamental programming frameworks so that an organization is not beholden to the whims and fancies of any enterprise platform for as basic a task as data wrangling:</p>
			<div><div><img src="img/Figure_1.2.jpg" alt="Figure 1.2: Google trend worldwide over the last 5 years" width="1280" height="294"/>
				</div>
			</div>
			<h6>Figure 1.2: Google trend worldwide over the last Five years</h6>
			<p>A few of the obvious advantages of using an open source, free programming paradigm such as Python for data wrangling are the following:</p>
			<ul>
				<li>General purpose open source paradigm putting no restriction on any of the methods you can develop for the specific problem at hand</li>
				<li>Great ecosystem of fast, optimized, open source libraries, focused on data analytics</li>
				<li>Growing support to connect Python to every conceivable data source type</li>
				<li>Easy interface to basic statistical testing and quick visualization libraries to check data quality</li>
				<li>Seamless interface of the data wrangling output with advanced machine learning models</li>
			</ul>
			<p>Python is the most popular language of choice of machine learning and artificial intelligence these days.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor023"/>Lists, Sets, Strings, Tuples, and Dictionaries</h2>
			<p>Now that we have learned the importance of Python, we will start by exploring various basic data structures in Python. We will learn techniques to handle data. This is invaluable for a data practitioner.</p>
			<p>We can issue the following command to start a new Jupyter server by typing the following in to the Command Prompt window:</p>
			<pre>do<a id="_idTextAnchor024"/>cker run -p 8888:8888 -v 'pwd':/notebooks -it rcshubhadeep/packt-data-wrangling-base:latest ipython</pre>
			<p>This will start a jupyter server and you can visit it at <a href="http://localhost:8888"><code>http://localhost:8888</code></a> and use the passcode <code>dw_4_all</code> to access the main interface.</p>
			<h3 id="_idParaDest-19">Li<a id="_idTextAnchor025"/>sts</h3>
			<p>Lists are fundamental Python data structures that have continuous memory locations, can host different data types, and can be accessed by the index.</p>
			<p>We will start with a list and list comprehension. We will generate a list of numbers, and then examine which ones among them are even. We will sort, reverse, and check for duplicates. We will also see how many different ways we can access the list elements, iterating over them and checking the membership of an element.</p>
			<p>The following is an example of a simple list:</p>
			<pre>list_example = [51, 27, 34, 46, 90, 45, -19]</pre>
			<p>The following is also an example of a list:</p>
			<pre>list_example2 = [15, "Yellow car", True, 9.456, [12, "Hello"]]</pre>
			<p>As you can see, a list can contain any number of the allowed datatype, such as <code>int</code>, <code>float</code>, <code>string</code>, and <code>Boolean</code>, and a list can also be a mix of different data types (including nested lists).</p>
			<p>If you are coming from a strongly typed language, such as C, C++, or Java, then this will probably be strange as you are not allowed to mix different kinds of data types in a single array in those languages. Lists are somewhat like arrays, in the sense that they are both based on continuous memory locations and can be accessed using indexes. But the power of Python lists come from the fact that they can host different data types and you are allowed to manipulate the data.</p>
			<h4>Note</h4>
			<p class="callout">Be careful, though, as the very power of lists, and the fact that you can mix different data types in a single list, can actually create subtle bugs that can be very difficult to track.</p>
			<h3 id="_idParaDest-20">Ex<a id="_idTextAnchor026"/>ercise 1: Accessing the List Members</h3>
			<p>In the following exercise, we will be creating a list and then observing the different ways of accessing the elements: </p>
			<ol>
				<li>Define a list called <code>list_1</code> with four integer members, using the following command:<pre>list_1 = [34, 12, 89, 1]</pre><p>The indices will be automatically assigned, as follows:</p><div><img src="img/Figure_1.3.jpg" alt="Figure 1.3: List showing the forward and backward indices" width="1514" height="442"/></div><h6>Figure 1.3: List showing the forward and backward indices</h6></li>
				<li>Access the first element from <code>list_1</code> using its forward index:<pre>list_1[0] #34</pre></li>
				<li>Access the last element from <code>list_1</code> using its forward index:<pre>list_1[3] #1</pre></li>
				<li>Access the last element from <code>list_1</code> using the <code>len</code> function:<pre>list_1[len(list_1) - 1] #1</pre><p>The <code>len</code> function in Python returns the length of the specified list.</p></li>
				<li>Access the last element from <code>list_1</code> using its backward index:<pre>list_1[-1] #1</pre></li>
				<li>Access the first three elements from <code>list_1</code> using forward indices:<pre>list_1[1:3] # [12, 89]</pre><p>This is also called list slicing, as it returns a smaller list from the original list by extracting only, a part of it. To slice a list, we need two integers. The first integer will denote the start of the slice and the second integer will denote the end-1 element.</p><h4>Note</h4><p class="callout">Notice that slicing did not include the third index or the end element. This is how list slicing works.</p></li>
				<li>Access the last two elements from <code>list_1</code> by slicing:<pre>list_1[-2:] # [89, 1]</pre></li>
				<li>Access the first two elements using backward indices:<pre>list_1[:-2] # [34, 12]</pre><p>When we leave one side of the colon (<code>:</code>) blank, we are basically telling Python either to go until the end or start from the beginning of the list. It will automatically apply the rule of list slices that we just learned.</p></li>
				<li>Reverse the elements in the string:<pre>list_1[-1::-1] # [1, 89, 12, 34]</pre><h4>Note</h4><p class="callout">The last bit of code is not very readable, meaning it is not obvious just by looking at it what it is doing. It is against Python's philosophy. So, although this kind of code may look clever, we should resist the temptation to write code like this.</p></li>
			</ol>
			<h3 id="_idParaDest-21">Exe<a id="_idTextAnchor027"/>rcise 2: Generating a List</h3>
			<p>We are going to examine various ways of generating a list:</p>
			<ol>
				<li value="1">Create a list using the <code>append</code> method:<pre>list_1 = []
for x in range(0, 10):
    list_1.append(x)
list_1</pre><p>The output will be as follows:</p><pre>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre><p>Here, we started by declaring an empty list and then we used a <code>for</code> loop to append values to it. The <code>append</code> method is a method that's given to us by the Python list data type.</p></li>
				<li>Generate a list using the following command:<pre>list_2 = [x for x in range(0, 100)]
list_2</pre><p>The partial output is as follows:</p><div><img src="img/Figure_1.4.jpg" alt="Figure 1.4: List comprehension" width="594" height="324"/></div><h6>Figure 1.4: List comprehension</h6><p>This is list comprehension, which is a very powerful tool that we need to master. The power of list comprehension comes from the fact that we can use conditionals inside the comprehension itself.</p></li>
				<li>Use a <code>while</code> loop to iterate over a list to understand the difference between a <code>while</code> loop and a <code>for</code> loop:<pre>i = 0
while i &lt; len(list_1) :
    print(list_1[i]) 
    i += 1</pre><p>The partial output will be as follows:</p><div><img src="img/Figure_1.5.jpg" alt="Figure 1.5: Output showing the contents of list_1 using a while loop" width="533" height="172"/></div><h6>Figure 1.5: Output showing the contents of list_1 using a while loop</h6></li>
				<li>Create <code>list_3</code> with numbers that are divisible by <code>5</code>:<pre>list_3 = [x for x in range(0, 100) if x % 5 == 0]
list_3</pre><p>The output will be a list of numbers up to 100 in increments of 5:</p><pre>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</pre></li>
				<li>Generate a list by adding the two lists: <pre>list_1 = [1, 4, 56, -1]
list_2 = [1, 39, 245, -23, 0, 45]
list_3 = list_1 + list_2
list_3</pre><p>The output is as follows:</p><pre>[1, 4, 56, -1, 1, 39, 245, -23, 0, 45]</pre></li>
				<li>Extend a string using the extend keyword:<pre>list_1.extend(list_2)
list_1</pre><p>The partial output is as follows:</p></li>
			</ol>
			<div><div><img src="img/C11065_01_06.jpg" alt="" width="636" height="22"/>
				</div>
			</div>
			<h6>Figure 1.6: Contents of list_1</h6>
			<p>The second operation changes the original list (list_1) and appends all the elements of list_2 to it. So, be careful when using it.</p>
			<h3 id="_idParaDest-22">Exerci<a id="_idTextAnchor028"/><a id="_idTextAnchor029"/>se 3: Iterating over a List and Checking Membership</h3>
			<p>We are going to iterate over a list and test whether a certain value exists in it:</p>
			<ol>
				<li value="1">Iterate over a list:<pre>list_1 = [x for x in range(0, 100)]
for i in range(0, len(list_1)):
    print(list_1[i])</pre><p>The output is as follows:</p><div><img src="img/Figure_1.7.jpg" alt="Figure 1.7: Section of list_1" width="714" height="476"/></div><h6>Figure 1.7: Section of list_1</h6></li>
				<li>However, it is not very Pythonic. Being Pythonic is to follow and conform to a set of best practices and conventions that have been created over the years by thousands of very able developers, which in this case means to use the <code>in</code> keyword, because Python does not have index initialization, bounds checking, or index incrementing, unlike traditional languages. The Pythonic way of iterating over a list is as follows:<pre>for i in list_1:
    print(i)</pre><p>The output is as follows:</p><div><img src="img/Figure_1.8.jpg" alt="Figure 1.8: Section of the list list_1" width="792" height="594"/></div><h6>Figure 1.8: A section of list_1</h6><p>Notice that, in the second method, we do not need a counter anymore to access the list index; instead, Python's <code>in</code> operator gives us the element at the <em class="italics">i </em>th position directly.</p></li>
				<li>Check whether the integers 25 and -45 are in the list using the <code>in</code> operator:<pre> 25 in list_1</pre><p>The output is <strong class="bold">True.</strong></p><pre> -45 in list_1</pre><p>The output is <strong class="bold">False.</strong></p></li>
			</ol>
			<h3 id="_idParaDest-23">Exercise <a id="_idTextAnchor030"/>4: Sorting a List</h3>
			<p>We generated a list called <code>list_1</code> in the previous exercise. We are going to sort it now:</p>
			<ol>
				<li value="1">As the list was originally a list of numbers from <code>0</code> to <code>99</code>, we will sort it in the reverse direction. To do that, we will use the <code>sort</code> method with <code>reverse=True</code>:<pre>list_1.sort(reverse=True)
list_1</pre><p>The partial output is as follows:</p><div><img src="img/Figure_1.9.jpg" alt="" width="899" height="632"/></div><h6>Figure 1.9: Section of output showing the reversed list</h6></li>
				<li>We can use the <code>reverse</code> method directly to achieve this result:<pre>list_1.reverse()
list_1</pre><p>The output is as follows:</p></li>
			</ol>
			<div><div><img src="img/Figure_1.91.jpg" alt="Figure 1.10: Section of output after reversing the string" width="750" height="632"/>
				</div>
			</div>
			<h6>Figure 1.10: Section of output after reversing the string</h6>
			<h4>Note</h4>
			<p class="callout">The difference between the sort function and the reverse function is the fact that we can use sort with custom sorting functions to do custom sorting, whereas we can only use reverse to reverse a list. Here also, both the functions work in-place, so be aware of this while using them.</p>
			<h3 id="_idParaDest-24">Exercise 5:<a id="_idTextAnchor031"/> Generating a Random List</h3>
			<p>In this exercise, we will be generating a <code>list</code> with random numbers:</p>
			<ol>
				<li value="1">Import the <code>random</code> library:<pre>import random</pre></li>
				<li>Use the <code>randint</code> function to generate random integers and add them to a list:<pre>list_1 = [random.randint(0, 30) for x in range (0, 100)]</pre></li>
				<li>Print the list using <code>print(list_1)</code>. Note that there will be duplicate values in <code>list_1</code>:<pre>list_1</pre><p>The sample output is as follows:</p></li>
			</ol>
			<div><div><img src="img/Figure_1.11.jpg" alt="" width="787" height="548"/>
				</div>
			</div>
			<h6>Figure 1.11: Section of the sample output for list_1</h6>
			<p>There are many ways to get a list of unique numbers, and while you may be able to write a few lines of code using a for loop and another list (you should actually try doing it!), let's see how we can do this without a for loop and with a single line of code. This will bring us to the next data structure, sets. </p>
			<h3 id="_idParaDest-25"><a id="_idTextAnchor032"/>Activity 1: Handling Lists</h3>
			<p>In this activity, we will generate a <code>list</code> of random numbers and then generate another <code>list</code> from the first one, which only contains numbers that are divisible by three. Repeat the experiment three times. Then, we will calculate the average difference of length between the two lists.</p>
			<p>These are the steps for completing this activity:</p>
			<ol>
				<li value="1">Create a <code>list</code> of 100 random numbers. </li>
				<li>Create a new <code>list</code> from this random <code>list</code>, with numbers that are divisible by <em class="italics">3</em>.</li>
				<li>Calculate the length of these two lists and store the difference in a new variable.</li>
				<li>Using a loop, perform steps 2 and 3 and find the difference variable three times.</li>
				<li>Find the arithmetic mean of these three difference values.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 282.</p></li>
			</ol>
			<h3 id="_idParaDest-26"><a id="_idTextAnchor033"/>Sets</h3>
			<p>A set, mathematically speaking, is just a collection of well-defined distinct objects. Python gives us a straightforward way to deal with them using its <code>set</code> datatype. </p>
			<h3 id="_idParaDest-27"><a id="_idTextAnchor034"/>Introduction to Sets</h3>
			<p>With the last<a id="_idTextAnchor035"/> list that we generated, we are going to revisit the problem of getting rid of duplicates from it. We can achieve that with the following line of code:</p>
			<pre>list_12 = list(set(list_1))</pre>
			<p>If we print this, we will see that it only contains unique numbers. We used the <code>set</code> data type to turn the first list into a set, thus getting rid of all duplicate elements, and then we used the <code>list</code> function on it to turn it into a list from a set once more:</p>
			<pre>list_12</pre>
			<p>The output will be as follows:</p>
			<div><div><img src="img/Figure_1.12.jpg" alt="Figure 1.12: Section of output for list_21" width="820" height="496"/>
				</div>
			</div>
			<h6>Figure 1.12: Section of output for list_21</h6>
			<h3 id="_idParaDest-28"><a id="_idTextAnchor036"/>Union and Intersection of Sets</h3>
			<p>This is what a union between two sets looks like:</p>
			<div><div><img src="img/Figure_1.13.jpg" alt="Figure 1.13: Venn diagram showing union of two sets" width="1800" height="651"/>
				</div>
			</div>
			<h6>Figure 1.13: Venn diagram showing the union of two sets</h6>
			<p>This simply means take everything from both sets but take the common elements only once.</p>
			<p>We can create this using the following code:  </p>
			<pre>set1 = {"Apple", "Orange", "Banana"}
set2 = {"Pear", "Peach", "Mango", "Banana"}</pre>
			<p>To find the union of the two sets, the following instructions should be used: </p>
			<pre>set1 | set2</pre>
			<p>The output would be as follows:</p>
			<pre>{'Apple', 'Banana', 'Mango', 'Orange', 'Peach', 'Pear'}</pre>
			<p>Notice that the common element, Banana, appears only once in the resulting set. The common elements between two sets can be identified by obtaining the intersection of the two sets, as follows:</p>
			<div><div><img src="img/Figure_1.14.jpg" alt="Figure 1.14: Venn diagram showing intersection of two sets" width="1800" height="557"/>
				</div>
			</div>
			<h6>Figure 1.14: Venn diagram showing the intersection of two sets</h6>
			<p>We get the intersection of two sets in Python as follows:</p>
			<pre>set1 &amp; set2</pre>
			<p>This will give us a set with only one element. The output is as follows:</p>
			<pre>{'Banana'}</pre>
			<h4>Note</h4>
			<p class="callout">You can also calculate the difference between sets (also known as complements). To find out more, refer to this link: <a href="https://docs.python.org/3/tutorial/datastructures.html#sets">https://docs.python.org/3/tutorial/datastructures.html#sets</a>. </p>
			<h3 id="_idParaDest-29">Creating Null Set<a id="_idTextAnchor037"/><a id="_idTextAnchor038"/>s</h3>
			<p>You can create a null set by creating a set containing no elements. You can do this by using the following code: </p>
			<pre>null_set_1 = set({})
null_set_1</pre>
			<p>The output is as follows:</p>
			<pre>set()</pre>
			<p>However, to create a dictionary, use the following command:</p>
			<pre>null_set_2 = {}
null_set_2</pre>
			<p>The output is as follows:</p>
			<pre>{}</pre>
			<p>We are going to learn about this in detail in the next topic.</p>
			<h3 id="_idParaDest-30"><a id="_idTextAnchor039"/>Dictionary</h3>
			<p>A dictionary is like a list, which means it is a collection of several elements. However, with the dictionary, it is a collection of key-value pairs, where the key can be anything that can be hashed. Generally, we use numbers or strings as keys.</p>
			<p>To create a dictionary, use the following code: </p>
			<pre>dict_1 = {"key1": "value1", "key2": "value2"}
dict_1</pre>
			<p>The output is as follows:</p>
			<pre>{'key1': 'value1', 'key2': 'value2'}</pre>
			<p>This is also a valid dictionary:</p>
			<pre>dict_2 = {"key1": 1, "key2": ["list_element1", 34], "key3": "value3",
          "key4": {"subkey1": "v1"}, "key5": 4.5}
dict_2</pre>
			<p>The output is as follows:</p>
			<pre>{'key1': 1,
 'key2': ['list_element1', 34],
 'key3': 'value3',
 'key4': {'subkey1': 'v1'},
 'key5': 4.5}</pre>
			<p>The keys must be unique in a dictionary. </p>
			<h3 id="_idParaDest-31"><a id="_idTextAnchor040"/>Exercise 6: Accessing and Setting Values in a Dictionary</h3>
			<p>In this exercise, we are going to access and set values in a dictionary:</p>
			<ol>
				<li value="1">Access a particular key in a dictionary:<pre>dict_2["key2"]</pre><p>This will return the value associated with it as follows:</p><pre>['list_element1', 34]</pre></li>
				<li>Assign a new value to the key:<pre>dict_2["key2"] = "My new value"</pre></li>
				<li>Define a blank dictionary and then use the key notation to assign values to it:<pre>dict_3 = {}  # Not a null set. It is a dict
dict_3["key1"] = "Value1"
dict_3</pre><p>The output is as follows:</p><pre>{'key1': 'Value1'}</pre></li>
			</ol>
			<h3 id="_idParaDest-32">Exercise 7: Itera<a id="_idTextAnchor041"/>ting Over a Dictionary</h3>
			<p>In this exercise, we are going to iterate over a dictionary:</p>
			<ol>
				<li value="1">Create <code>dict_1</code>:<pre>dict_1 = {"key1": 1, "key2": ["list_element1", 34], "key3": "value3", "key4": {"subkey1": "v1"}, "key5": 4.5}</pre></li>
				<li>Use the looping variables <code>k</code> and <code>v</code>:<pre>for k, v in dict_1.items():
    print("{} - {}".format(k, v))</pre><p>The output is as follows:</p><pre>key1 - 1
key2 - ['list_element1', 34]
key3 - value3
key4 - {'subkey1': 'v1'}
key5 - 4.5</pre><h4>Note</h4><p class="callout">Notice the difference between how we did the iteration on the list and how we are doing it here. </p></li>
			</ol>
			<h3 id="_idParaDest-33">Exercise 8: Revis<a id="_idTextAnchor042"/>iting the Unique Valued List Problem</h3>
			<p>We will use the fact that dictionary keys cannot be duplicated to generate the unique valued list:</p>
			<ol>
				<li value="1">First, generate a random list with duplicate values:<pre>list_1 = [random.randint(0, 30) for x in range (0, 100)]</pre></li>
				<li>Create a unique valued list from <code>list_1</code>:<pre>list(dict.fromkeys(list_1).keys())</pre><p>The sample output is as follows:</p></li>
			</ol>
			<div><div><img src="img/Image51881.jpg" alt="" width="719" height="517"/>
				</div>
			</div>
			<h6>Figure 1.15: Output showing the unique valued list</h6>
			<p>Here, we have used two useful functions on the dict data type in Python, <code>fromkeys</code> and <code>keys</code>. <code>fromkeys</code> creates a dict where the keys come from the <code>iterable</code> (in this case, which is a list), values default to None, and <code>keys</code> give us the keys of a dict.</p>
			<h3 id="_idParaDest-34"><a id="_idTextAnchor043"/>Exercise 9: Deleting Value from Dict</h3>
			<p>In this exercise, we are going to delete a value from a <code>dict</code>:</p>
			<ol>
				<li value="1">Create <code>list_1</code> with five elements:<pre>dict_1 = {"key1": 1, "key2": ["list_element1", 34], "key3": "value3",
          "key4": {"subkey1": "v1"}, "key5": 4.5}
dict_1</pre><p>The output is as follows:</p><pre>{'key1': 1,
 'key2': ['list_element', 34],
 'key3': 'value3',
 'key4': {'subkey1': 'v1'},
 'key5': 4.5}</pre></li>
				<li>We will use the <code>del</code> function and specify the element:<pre>del dict_1["key2"]</pre><p>The output is as follows:</p><pre>{'key3': 'value3', 'key4': {'subkey1': 'v1'}, 'key5': 4.5}</pre><h4>Note</h4><p class="callout">The <code>del</code> operator can be used to delete a specific index from a list as well.</p></li>
			</ol>
			<h3 id="_idParaDest-35">Exercise 10: Dicti<a id="_idTextAnchor044"/>onary Comprehension</h3>
			<p>In this final exercise on <code>dict</code>, we will go over a less used comprehension than the list one: dictionary comprehension. We will also examine two other ways to create a <code>dict</code>, which will be useful in the future.</p>
			<p>A dictionary comprehension works exactly the same way as the list one, but we need to specify both the keys and values:</p>
			<ol>
				<li value="1">Generate a dict that has <code>0</code> to <code>9</code> as the keys and the square of the key as the values:<pre>list_1 = [x for x in range(0, 10)]
dict_1 = {x : x**2 for x in list_1}
dict_1</pre><p>The output is as follows:</p><pre>{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}</pre><p>Can you generate a <code>dict</code> using <code>dict</code> comprehension where the keys are from <code>0</code> to <code>9</code> and the values are the square root of the keys? This time, we won't use a list.</p></li>
				<li>Generate a <code>dictionary</code> using the <code>dict</code> function:<pre>dict_2 = dict([('Tom', 100), ('Dick', 200), ('Harry', 300)])
dict_2</pre><p>The output is as follows:</p><pre>{'Tom': 100, 'Dick': 200, 'Harry': 300}</pre><p>You can also generate <code>dictionary</code> using the <code>dict</code> function, as follows:</p><pre>dict_3 = dict(Tom=100, Dick=200, Harry=300)
dict_3</pre><p>The output is as follows:</p><pre>{'Tom': 100, 'Dick': 200, 'Harry': 300}</pre><p>It is pretty versatile. So, both the preceding commands will generate valid dictionaries. </p><p>The strange looking pair of values that we had just noticed ('Harry', 300) is called a <code>tuple</code>. This is another important fundamental data type in Python. We will learn about tuples in the next topic.</p></li>
			</ol>
			<h3 id="_idParaDest-36"><a id="_idTextAnchor045"/>Tuples</h3>
			<p>A tuple is another data type in Python. It is sequential in nature and similar to lists. </p>
			<p>A tuple consists of values separated by commas, as follows:</p>
			<pre>tuple_1 = 24, 42, 2.3456, "Hello"</pre>
			<p>Notice that, unlike lists, we did not open and close square brackets here. </p>
			<h3 id="_idParaDest-37">Creating a Tuple w<a id="_idTextAnchor046"/>ith Different Cardinalities</h3>
			<p>This is how we create an empty tuple:</p>
			<pre>tuple_1 = ()</pre>
			<p>And this is how we create a tuple with only one value:</p>
			<pre>tuple_1 = "Hello",</pre>
			<p>Notice the trailing comma here.</p>
			<p>We can nest tuples, similar to list and dicts, as follows:</p>
			<pre>tuple_1 = "hello", "there"
tuple_12 = tuple_1, 45, "Sam"</pre>
			<p>One special thing about tuples is the fact that they are an immutable data type. So, once created, we cannot change their values. We can just access them, as follows:</p>
			<pre>tuple_1 = "Hello", "World!"
tuple_1[1] = "Universe!"</pre>
			<p>The last line of code will result in a <code>TypeError</code> as a tuple does not allow modification.</p>
			<p>This makes the use case for tuples a bit different than lists, although they look and behave very similarly in a few aspects.</p>
			<h3 id="_idParaDest-38"><a id="_idTextAnchor047"/>Unpacking a Tuple</h3>
			<p><a id="_idTextAnchor048"/>The term unpacking a tuple simply means to get the values contained in the tuple in different variables:</p>
			<pre>tuple_1 = "Hello", "World"
hello, world = tuple_1
print(hello)
print(world)</pre>
			<p>The output is as follows:</p>
			<pre>Hello
World</pre>
			<p>Of course, as soon as we do that, we can modify the values contained in those variables. </p>
			<h3 id="_idParaDest-39"><a id="_idTextAnchor049"/>Exercise 11: Handling Tuples</h3>
			<ol>
				<li value="1">Create a tuple to demonstrate how tuples are immutable. Unpack it to read all elements, as follows:<pre>tupleE = "1", "3", "5"
tupleE</pre><p>The output is as follows:</p><pre>('1', '3', '5')</pre></li>
				<li>Try to override a variable from the <code>tupleE</code> tuple:<pre>tupleE[1] = "5"</pre><p>This step will result in <code>TypeError</code> as the tuple does not allow modification.</p></li>
				<li>Try to assign a series to the <code>tupleE</code> tuple:<pre>1, 3, 5 = tupleE</pre></li>
				<li>Print the output:<pre>print(1)
print(3)</pre><p>The output is as follows:</p><pre>1
3</pre></li>
			</ol>
			<p>We have mainly seen two different types of data so far. One is represented by numbers; another is represented by textual data. Whereas numbers have their own tricks, which we will see later, it is time to look into textual data in a bit more detail.</p>
			<h3 id="_idParaDest-40"><a id="_idTextAnchor050"/>Strings</h3>
			<p>In the final section of this section, we will learn about strings. Strings in Python are similar to any other programming language.</p>
			<p>This is a string:</p>
			<pre>string1 = 'Hello World!' </pre>
			<p>A string can also be declared in this manner:</p>
			<pre>string2 = "Hello World 2!"</pre>
			<p>You can use single quotes and double quotes to define a string. </p>
			<h3 id="_idParaDest-41"><a id="_idTextAnchor051"/>Exercise 12: Accessing Strings</h3>
			<p>Strings in Python behave similar to lists, apart from one big caveat. Strings are immutable, whereas lists are mutable data structures:</p>
			<ol>
				<li value="1">Create a string called <code>str_1</code>:<pre>str_1 = "Hello World!"</pre><p>Access the elements of the string by specifying the location of the element, like we did in lists.</p></li>
				<li>Access the first member of the string:<pre>str_1[0]</pre><p>The output is as follows:</p><pre>'H'</pre></li>
				<li>Access the fourth member of the string:<pre>str_1[4]</pre><p>The output is as follows:</p><pre>'o'</pre></li>
				<li>Access the last member of the string:<pre>str_1[len(str_1) - 1]</pre><p>The output is as follows:</p><pre>'!'</pre></li>
				<li>Access the last member of the string:<pre>str_1[-1]</pre><p>The output is as follows:</p><pre>'!'</pre><p>Each of the preceding operations will give you the character at the specific index.</p><h4>Note</h4><p class="callout">The method for accessing the elements of a string is like accessing a list.</p></li>
			</ol>
			<h3 id="_idParaDest-42"><a id="_idTextAnchor052"/>Exercise 13: String Slices</h3>
			<p>Just like lists, we can slice strings:</p>
			<ol>
				<li value="1">Create a string, <code>str_1</code>:<pre>str_1 = "Hello World! I am learning data wrangling"</pre></li>
				<li>Specify the slicing values and slice the string:<pre>str_1[2:10]</pre><p>The output is this:</p><pre>'llo Worl'</pre></li>
				<li>Slice a string by skipping a slice value:<pre>str_1[-31:]</pre><p>The output is as follows: </p><pre>'d! I am learning data wrangling'</pre></li>
				<li>Use negative numbers to slice the string:<pre>str_1[-10:-5]</pre><p>The output is as follows:</p><pre>' wran'</pre></li>
			</ol>
			<h3 id="_idParaDest-43">String Fu<a id="_idTextAnchor053"/>nctions</h3>
			<p>To find out the length of a string, we simply use the <code>len</code> function:</p>
			<pre>str_1 = "Hello World! I am learning data wrangling"
len(str_1)</pre>
			<p>The length of the string is 41. To convert a string's case, we can use the <code>lower</code> and <code>upper</code> methods:</p>
			<pre>str_1 = "A COMPLETE UPPER CASE STRING"
str_1.lower()
str_1.upper()</pre>
			<p>The output is as follows:</p>
			<pre>'A COMPLETE UPPER CASE STRING'</pre>
			<p>To search for a string within a string, we can use the <code>find</code> method:</p>
			<pre>str_1 = "A complicated string looks like this"
str_1.find("complicated")
str_1.find("hello")# This will return -1</pre>
			<p>The output is -1. Can you figure out whether the find method is case-sensitive or not? Also, what do you think the find method returns when it actually finds the string?</p>
			<p>To replace one string with another, we have the <code>replace</code> method. Since we know that a string is an immutable data structure, replace actually returns a new string instead of replacing and returning the actual one:</p>
			<pre>str_1 = "A complicated string looks like this"
str_1.replace("complicated", "simple")</pre>
			<p>The output is as follows:</p>
			<pre>'A simple string looks like this'</pre>
			<p>You should look up string methods in the standard documentation of Python 3 to discover more about these methods.</p>
			<h3 id="_idParaDest-44"><a id="_idTextAnchor054"/>Exercise 14: Split and Join</h3>
			<p>These two string methods need separate introductions, as they enable you to convert a string into a list and vice versa:</p>
			<ol>
				<li value="1">Create a string and convert it to a list using the <code>split</code> method:<pre>str_1 = "Name, Age, Sex, Address"
list_1 = str_1.split(",")
list_1</pre><p>The preceding code will give you a list similar to the following:</p><pre>['Name', ' Age', ' Sex', ' Address']</pre></li>
				<li>Combine this list into another string using the <code>join</code> method:<pre>" | ".join(list_1) </pre><p>This code will give you a string like this:</p><pre>'Name |  Age |  Sex |  Address'</pre></li>
			</ol>
			<p>With these, we are at the end of our second topic of this chapter. We now have the motivation to learn data wrangling and have a solid introduction to the fundamentals of data structures using Python. There is more to this topic, which will be covered in a future chapters. </p>
			<p>We have designed an activity for you so that you can practice all the skills you just learned. This small activity should take around 30 to 45 minutes to finish. </p>
			<h3 id="_idParaDest-45"><a id="_idTextAnchor055"/>Activity 2: Analyze a Multiline String and Generate the Unique Word Count</h3>
			<p>This <a id="_idTextAnchor056"/>section will ensure that you have understood the various basic data structures and their manipulation. We will do that by going through an activity that has been designed specifically for this purpose.</p>
			<p>In this activity, we will do the following:</p>
			<ul>
				<li>Get multiline text and save it in a Python variable</li>
				<li>Get rid of all new lines in it using string methods</li>
				<li>Get all the unique words and their occurrences from the string </li>
				<li>Repeat the step to find all unique words and occurrences, without considering case sensitivity <h4>Note</h4><p class="callout">For the sake of simplicity for this activity, the original text (which can be found at <a href="https://www.gutenberg.org/files/1342/1342-h/1342-h.htm">https://www.gutenberg.org/files/1342/1342-h/1342-h.htm</a>) has been pre-processed a bit.</p></li>
			</ul>
			<p>These are the steps to guide you through solving this activity:</p>
			<ol>
				<li value="1">Create a <code>mutliline_text</code> variable by copying the text from the first chapter of <em class="italics">Pride and Prejudice</em>. <h4>Note</h4><p class="callout">The first chapter of Pride and Prejudice by Jane Austen has been made available on the GitHub repository at <a href="https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Lesson01/Activity02/">https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Chapter01/Activity02/</a>. </p></li>
				<li>Find the type and length of the <code>multiline_text</code> string using the commands <code>type</code> and <code>len</code>.</li>
				<li>Remove all new lines and symbols using the <code>replace</code> function.</li>
				<li>Find all of the words in <code>multiline_text</code> using the <code>split</code> function.</li>
				<li>Create a list from this list that will contain only the unique words.</li>
				<li>Count the number of times the unique word has appeared in the list using the <code>key</code> and <code>value</code> in <code>dict</code>.</li>
				<li>Find the top 25 words from the unique words that you have found using the <code>slice</code> function.<p>You just created, step by step, a unique word counter using all the neat tricks that you learned about in this chapter.</p><h4>Note</h4><p class="callout">The solution for this activity can be found on page 285.</p></li>
			</ol>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor057"/>Summary</h2>
			<p>In this chapter, we learned what the term data wrangling means. We also got examples from various real-life data science situations where data wrangling is very useful and is used in industry. We moved on to learn about the different built-in data structures that Python has to offer. We got our hands dirty by exploring lists, sets, dictionaries, tuples, and strings. They are the fundamental building blocks in Python data structures, and we need them all the time while working and manipulating data in Python. We did several small hands-on exercises to learn more about them. We finished this chapter with a carefully designed activity, which let us combine a lot of different tricks from all the different data structures into a real-life situation and let us observe the interplay between all of them.</p>
			<p>In the next chapter, we will learn about the data structures in Python and utilize them to solve real-world problems.</p>
		</div>
		<div><div></div>
		</div>
	</div>



  </body></html>