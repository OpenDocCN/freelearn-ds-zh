- en: Chapter 7. GraphFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphs are an interesting way to solve data problems because graph structures
    are a more intuitive approach to many classes of data problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use graphs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding the classic graph problem: the flights dataset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the graph vertices and edges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using motif finding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using breadth first search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PageRank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing flights using D3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether traversing social networks or restaurant recommendations, it is easier
    to understand these data problems within the context of graph structures: vertices,
    edges, and properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GraphFrames](img/B05793_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, within the context of **social networks**, the *vertices* are the
    people while the *edges* are the connections between them. Within the context
    of **restaurant recommendations**, the vertices (for example) involve the location,
    cuisine type, and restaurants while the edges are the connections between them
    (for example, these three restaurants are in **Vancouver, BC**, but only two of
    them serve ramen).
  prefs: []
  type: TYPE_NORMAL
- en: 'While the two graphs are seemingly disconnected, you can in fact create a social
    network + restaurant recommendation graph based on the reviews of friends within
    a social circle, as noted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GraphFrames](img/B05793_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, if **Isabella** wants to find a great ramen restaurant in Vancouver,
    traversing her friends'' reviews, she will most likely choose **Kintaro Ramen**,
    as both **Samantha** and **Juliette** have rated the restaurant favorably:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GraphFrames](img/B05793_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another classic graph problem is the analysis of flight data: airports are
    represented by *vertices* and flights between those airports are represented by
    *edges*. Also, there are numerous *properties* associated with these flights,
    including, but not limited to, departure delays, plane type, and carrier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GraphFrames](img/B05793_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will use GraphFrames to quickly and easily analyze flight
    performance data organized in graph structures. Because we're using graph structures,
    we can easily ask many questions that are not as intuitive as tabular structures,
    such as finding structural motifs, airport ranking using PageRank, and shortest
    paths between cities. GraphFrames leverages the distribution and expression capabilities
    of the DataFrame API to both simplify your queries and leverage the performance
    optimizations of the Apache Spark SQL engine.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, with GraphFrames, graph analysis is available in Python, Scala,
    and Java. Just as important, you can leverage your existing Apache Spark skills
    to solve graph problems (in addition to machine learning, streaming, and SQL)
    instead of making a paradigm shift to learn a new framework.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing GraphFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraphFrames utilizes the power of Apache Spark DataFrames to support general
    graph processing. Specifically, the vertices and edges are represented by DataFrames
    allowing us to store arbitrary data with each vertex and edge. While GraphFrames
    is similar to Spark''s GraphX library, there are some key differences, including:'
  prefs: []
  type: TYPE_NORMAL
- en: GraphFrames leverage the performance optimizations and simplicity of the DataFrame
    API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the DataFrame API, GraphFrames now have Python, Java, and Scala APIs.
    GraphX is only accessible through Scala; now all its algorithms are available
    in Python and Java.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, at the time of writing, there was a bug preventing GraphFrames from working
    with Python3.x, hence we will be using Python2.x.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, GraphFrames is on version 0.3 and available as a Spark
    package ([http://spark-packages.org](http://spark-packages.org)) at [https://spark-packages.org/package/graphframes/graphframes](https://spark-packages.org/package/graphframes/graphframes).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about GraphFrames, please refer to *Introducing GraphFra*
    *mes* at [https://databricks.com/blog/2016/03/03/introducing-graphframes.html](https://databricks.com/blog/2016/03/03/introducing-graphframes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Installing GraphFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are running your job from a Spark CLI (for example, `spark-shell, pyspark,
    spark-sql, spark-submit`), you can use the `–-packages` command, which will extract,
    compile, and execute the necessary code for you to use the GraphFrames package.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to use the latest GraphFrames package (version 0.3) with Spark
    2.0 and Scala 2.11 with spark-shell, the command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are using a notebook service, you may need to install the package first.
    For example, the following section shows the steps to install the GraphFrames
    library within the free Databricks Community Edition ([http://databricks.com/try-databricks](http://databricks.com/try-databricks)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within Databricks, you can create a library that is comprised of a Scala/Java
    JAR, Python Egg, or Maven Coordinate (including the Spark package).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, go to your **Workspace** within **databricks**, right-click the folder
    you want to create the library in (in this case, **flights**), click **Create**,
    and then click **Library**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a library](img/B05793_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Create Library** dialog, choose within the **Source** dropdown, **Maven
    Coordinate** as noted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a library](img/B05793_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maven is a tool that is used to build and manage Java-based projects such as
    the GraphFrames project. Maven coordinates uniquely identify those projects (or
    dependencies or plug-ins) so you can quickly find the project within a Maven repository;
    for example, [https://mvnrepository.com/artifact/graphframes/graphframes](https://mvnrepository.com/artifact/graphframes/graphframes).
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can click the **Search Spark Packages and Maven Central** button
    and search for the GraphFrames package. Ensure that you match the GraphFrames
    version of Spark (for example, Spark 2.0) and Scala (for example, Scala 2.11)
    with your Spark cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also enter the Maven coordinate for the GraphFrames Spark package if
    you already know it. For Spark 2.0 and Scala 2.11, enter the following coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once entered, click on **Create Library**, as noted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a library](img/B05793_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that this is a one-time installation task for the GraphFrames Spark package
    (as part of a library). Once it is installed, you can by default automatically
    auto-attach the package to any Databricks cluster that you create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a library](img/B05793_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preparing your flights dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this flights sample scenario, we will make use of two sets of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Airline On-Time Performance and Causes of Flight Delays*: [[http://bit.ly/2ccJPPM](http://bit.ly/2ccJPPM)]
    This dataset contains scheduled and actual departure and arrival times, and delay
    causes as reported by US air carriers. The data is collected by the Office of
    Airline Information, **Bureau of Transportation Statistics** (**BTS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Open Flights: Airports and airline data*: [[http://openflights.org/data.html](http://openflights.org/data.html)]
    This dataset contains the list of US airport data including the IATA code, airport
    name, and airport location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create two DataFrames – `airports` and `departureDelays`–which will
    make up our **vertices** and **edges** of our GraphFrame, respectively. We will
    be creating this flights sample application using Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are using a Databricks notebook for our example, we can make use of the
    `/databricks-datasets/`location, which contains numerous sample datasets. You
    can also download the data from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`depa``rtureDelays.csv`: [http://bit.ly/2ejPr8k](http://bit.ly/2ejPr8k)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`airportCodes`: [http://bit.ly/2ePAdKT](http://bit.ly/2ePAdKT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we are creating two variables denoting the file paths for
    our Airports and Departure Delays data, respectively. Then we will load these
    datasets and create the respective Spark DataFrames; note for both of these files,
    we can easily infer the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we loaded the `departureDelays` DataFrame, we also cache it so we can
    include some additional filtering of the data in a performant manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query allows us to build a distinct list with origin city IATA
    codes (for example, `Seattle = ''SEA'', San Francisco = ''SFO'', New York JFK
    = ''JFK''`, and so on). Next, we only include airports that had a trip occur within
    the `departureDelays` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By building the distinct list of origin airport codes, we can build the airports
    DataFrame to contain only the airport codes that exist in the `departureDelays`
    dataset. The following code snippet generates a new DataFrame (`departureDelays_geo`)
    that is comprised of key attributes including date of flight, delays, distance,
    and airport information (origin, destination):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To take a quick peek into this data, you can run the `show` method as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Preparing your flights dataset](img/B05793_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve imported our data, let''s build our graph. To do this, we''re
    going to build the structure for our vertices and edges. At the time of writing,
    GraphFrames requires a specific naming convention for vertices and edges:'
  prefs: []
  type: TYPE_NORMAL
- en: The column representing the *vertices* needs to have the name of`id`. In our
    case, the vertices of our flight data are the airports. Therefore, we will need
    to rename the IATA airport code to `id` in our `airports` DataFrame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The columns representing the *edges* need to have a source (`src`) and destination
    (`dst`). For our flight data, the edges are the flights, therefore the `src` and
    `dst` are the origin and destination columns from the `departureDelays_geo` DataFrame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To simplify the edges for our graph, we will create the `tripEdges` DataFrame
    with a subset of the columns available within the `departureDelays_Geo` DataFrame.
    As well, we created a `tripVertices` DataFrame that simply renames the `IATA`
    column to `id` to match the GraphFrame naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Within Databricks, you can query the data using the `display` command. For
    example, to view the `tripEdges` DataFrame, the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the graph](img/B05793_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the two DataFrames, we can create a GraphFrame using the `GraphFrame`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Executing simple queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a set of simple graph queries to understand flight performance
    and departure delays.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the number of airports and trips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For example, to determine the number of airports and trips, you can run the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the results, there are 279 airports with 1.36 million trips:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the number of airports and trips](img/B05793_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Determining the longest delay in this dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To determine the longest delayed flight in the dataset, you can run the following
    query with the result of 1,642 minutes (that''s more than 27 hours!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Determining the number of delayed versus on-time/early flights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To determine the number of delayed versus on-time (or early) flights, you can
    run the following queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: with the results nothing that almost 43% of the flights were delayed!
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the number of delayed versus on-time/early flights](img/B05793_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What flights departing Seattle are most likely to have significant delays?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Digging further in this data, let''s find out the top five destinations for
    flights departing from Seattle that are most likely to have significant delays.
    This can be achieved through the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following results: Philadelphia (PHL), Colorado Springs
    (COS), Fresno (FAT), Long Beach (LGB), and Washington D.C (IAD) are the top five
    cities with flights delayed originating from Seattle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What flights departing Seattle are most likely to have significant delays?](img/B05793_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What states tend to have significant delays departing from Seattle?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s find which states have the longest cumulative delays (with individual
    delays > 100 minutes) originating from Seattle. This time we will use the `display`
    command to review the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![What states tend to have significant delays departing from Seattle?](img/B05793_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the Databricks `display` command, we can also quickly change from this
    table view to a map view of the data. As can be seen in the following figure,
    the state with the most cumulative delays originating from Seattle (in this dataset)
    is California:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What states tend to have significant delays departing from Seattle?](img/B05793_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding vertex degrees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the context of graph theory, the degrees around a vertex are the number
    of edges around the vertex. In our *flights* example, the degrees are then the
    total number of edges (that is, flights) to the vertex (that is, airports). Therefore,
    if we were to obtain the top 20 vertex degrees (in descending order) from our
    graph, then we would be asking for the top 20 busiest airports (most flights in
    and out) from our graph. This can be quickly determined using the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we''re using the `display` command, we can quickly view a bar graph
    of this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding vertex degrees](img/B05793_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Diving into more details, here are the top 20 `inDegrees` (that is, incoming
    flights):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Understanding vertex degrees](img/B05793_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While here are the top 20 `outDegrees` (that is, outgoing flights):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Understanding vertex degrees](img/B05793_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, while the top 10 airports (Atlanta/ATL to Charlotte/CLT) are
    ranked the same for incoming and outgoing flights, the ranks of the next 10 airports
    change (for example, Seattle/SEA is 17th for incoming flights, but 18th for outgoing).
  prefs: []
  type: TYPE_NORMAL
- en: Determining the top transfer airports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An extension of understanding vertex degrees for airports is to determine the
    top transfer airports. Many airports are used as transfer points instead of being
    the final destination. An easy way to calculate this is by calculating the ratio
    of `inDegrees` (the number of flights to the airport) and / `outDegrees` (the
    number of flights leaving the airport). Values close to `1` may indicate many
    transfers, whereas values <`1` indicate many outgoing flights and values >`1`
    indicate many incoming flights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this is a simple calculation that does not consider timing or scheduling
    of flights, just the overall aggregate number within the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this query is a bar chart of the top 10 transfer city airports
    (that is, hub airports):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the top transfer airports](img/B05793_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This makes sense since these airports are major hubs for national airlines (for
    example, Delta uses **Minneapolis** and **Salt Lake City** as its hub, Frontier
    uses **Denver**, American uses **Dallas** and **Phoenix**, United uses **Houston**,
    **Chicago**, and **San Francisco**, and Hawaiian Airlines uses **Kahului** and
    **Honolulu** as its hubs).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding motifs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To easily understand the complex relationship of city airports and the flights
    between each other, we can use `motifs` to find patterns of airports (for example,
    vertices) connected by flights (that is, edges). The result is a DataFrame in
    which the column names are given by the motif keys. Note that motif finding is
    one of the new graph algorithms supported as part of GraphFrames.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s determine the delays that are due to **San Francisco International
    Airport** (**SFO**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Breaking down the preceding query, the `(x)` represents the vertex (that is,
    airport) while the `[xy]` represents the edge (that is, flights between airports).
    Therefore, to determine the delays that are due to SFO, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The vertex `(b)` represents the airport in the middle (that is, SFO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vertex`(a)`represents the origin airport (within the dataset)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vertex `(c)` represents the destination airport (within the dataset)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edge `[ab]` represents the flight between `(a)` (that is, origin) and `(b)`
    (that is, SFO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edge `[bc]` represents the flight between `(b)` (that is, SFO) and `(c)`
    (that is, destination)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the `filter` statement, we put in some rudimentary constraints (note
    that this is an over simplistic representation of flight paths):'
  prefs: []
  type: TYPE_NORMAL
- en: '`b.id = ''SFO''` denotes that the middle vertex `(b)` is limited to just SFO
    airport'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(ab.delay > 500 or bc.delay > 500)` denotes that we are limited to flights
    that have delays greater than 500 minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(bc.tripid > ab.tripid and bc.tripid < ab.tripid + 10000)` denotes that the
    `(ab)` flight must be before the `(bc)` trip and within the same day. The `tripid`
    was derived from the date time, thus explaining why it could be simplified this
    way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of this query is noted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding motifs](img/B05793_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a simplified abridged subset from this query where the columns
    are the respective motif keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '| a | ab | b | bc | c |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Houston (IAH)` | `IAH -> SFO (-4)``[1011126]` | `San Francisco (SFO)` |
    `SFO -> JFK (536)``[1021507]` | `New York (JFK)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Tuscon (TUS)` | `TUS -> SFO (-5)``[1011126]` | `San Francisco (SFO)` | `SFO
    -> JFK (536)``[1021507]` | `New York (JFK)` |'
  prefs: []
  type: TYPE_TB
- en: Referring to the TUS > SFO > JFK flight, you will notice that while the flight
    from Tuscon to San Francisco departed 5 minutes early, the flight from San Francisco
    to New York JFK was delayed by 536 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: By using motif finding, you can easily search for structural patterns in your
    graph; by using GraphFrames, you are using the power and speed of DataFrames to
    distribute and perform your query.
  prefs: []
  type: TYPE_NORMAL
- en: Determining airport ranking using PageRank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because GraphFrames is built on top of GraphX, there are several algorithms
    that we can immediately leverage. PageRank was popularized by the Google Search
    Engine and created by Larry Page. To quote Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '"PageRank works by counting the number and quality of links to a page to determine
    a rough estimate of how important the website is. The underlying assumption is
    that more important websites are likely to receive more links from other websites."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While the preceding example refers to web pages, this concept readily applies
    to any graph structure whether it is created from web pages, bike stations, or
    airports. Yet the interface via GraphFrames is as simple as calling a method.
    `GraphFrames.PageRank` will return the PageRank results as a new column appended
    to the *vertices* DataFrame to simplify our downstream analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there are many flights and connections through the various airports included
    in this dataset, we can use the PageRank algorithm to have Spark traverse the
    graph iteratively to compute a rough estimate of how important each airport is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that `resetProbability = 0.15` represents the probability of resetting
    to a random vertex (this is the default value) while `maxIter = 5` is a set number
    of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on PageRank parameters, please refer to Wikipedia > Page
    Rank at [https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank).
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of the `PageRank` are noted in the following bar graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining airport ranking using PageRank](img/B05793_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In terms of airport ranking, the `PageRank` algorithm has determined that ATL
    (Hartsfield-Jackson Atlanta International Airport) is the most important airport
    in the United States. This observation makes sense as ATL is not only the busiest
    airport in the United States ([http://bit.ly/2eTGHs4](http://bit.ly/2eTGHs4)),
    but it is also the busiest airport in the world (2000-2015) ([http://bit.ly/2eTGDsy](http://bit.ly/2eTGDsy)).
  prefs: []
  type: TYPE_NORMAL
- en: Determining the most popular non-stop flights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expanding upon our `tripGraph` GraphFrame, the following query will allow us
    to find the most popular non-stop flights in the US (for this dataset):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, while we are using the `delay` column, we''re just actually doing a `count`
    of the number of trips. Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining the most popular non-stop flights](img/B05793_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be observed from this query, the two most frequent non-stop flights are
    between LAX (Los Angeles) and SFO (San Francisco). The fact that these flights
    are so frequent indicates their importance in the airline market. As noted in
    the New York Times article from April 4, 2016, *Alaska Air Sees Virgin America
    as Key to West Coast* ([http://nyti.ms/2ea1uZR](http://nyti.ms/2ea1uZR)), acquiring
    slots at these two airports was one of the reasons why Alaska Airlines purchased
    Virgin Airlines. Graphs are not just fun but also contain potentially powerful
    business insight!
  prefs: []
  type: TYPE_NORMAL
- en: Using Breadth-First Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Breadth-first search** (**BFS**) is a new algorithm as part of GraphFrames
    that finds the shortest path from one set of vertices to another. In this section,
    we will use BFS to traverse our `tripGraph` to quickly find the desired vertices
    (that is, airports) and edges (that is, flights). Let''s try to find the shortest
    number of connections between cities based on the dataset. Note that these examples
    do not consider time or distance, just hops between cities. For example, to find
    the number of direct flights between Seattle and San Francisco, you can run the
    following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`fromExpr` and `toExpr` are the expressions indicating the origin and destination
    airports (that is, SEA and SFO, respectively). The `maxPathLength = 1` indicates
    that we only want one edge between the two vertices, that is, a non-stop flight
    between Seattle and San Francisco. As noted in the following results, there are
    many direct flights between Seattle and San Francisco:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Breadth-First Search](img/B05793_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But how about if we want to determine the number of direct flights between
    San Francisco and Buffalo? Running the following query will note that there are
    no results, that is, no direct flights between the two cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we modify the preceding query to `maxPathLength = 2`, that is, one layover,
    then you will see a lot more flight options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table provides an abridged version of the output from this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '| From | Layover | To |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SFO` | **MSP** (**Minneapolis**) | `BUF` |'
  prefs: []
  type: TYPE_TB
- en: '| `SFO` | **EWR** (**Newark**) | `BUF` |'
  prefs: []
  type: TYPE_TB
- en: '| `SFO` | **JFK** (**New York**) | `BUF` |'
  prefs: []
  type: TYPE_TB
- en: '| `SFO` | **ORD** (**Chicago**) | `BUF` |'
  prefs: []
  type: TYPE_TB
- en: '| `SFO` | **ATL** (**Atlanta**) | `BUF` |'
  prefs: []
  type: TYPE_TB
- en: '| `SFO` | **LAS** (**Las Vegas**) | `BUF` |'
  prefs: []
  type: TYPE_TB
- en: '| `SFO` | **BOS** (**Boston**) | `BUF` |'
  prefs: []
  type: TYPE_TB
- en: 'But now that I have my list of airports, how can I determine which layover
    airports are more popular between SFO and BUF? To determine this, you can now
    run the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following bar chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Breadth-First Search](img/B05793_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing flights using D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get a powerful and fun visualization of the flight paths and connections
    in this dataset, we can leverage the Airports D3 visualization ([https://mbostock.github.io/d3/talk/20111116/airports.html](https://mbostock.github.io/d3/talk/20111116/airports.html))
    within our Databricks notebook. By connecting our GraphFrames, DataFrames, and
    D3 visualizations, we can visualize the scope of all the flight connections as
    noted for all on-time or early departing flights within this dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The blue circles represent the vertices (that is, airports) where the size of
    the circle represents the number of edges (that is, flights) in and out of those
    airports. The black lines are the edges themselves (that is, flights) and their
    respective connections to the other vertices (that is, airports). Note for any
    edges that go offscreen, they are representing vertices (that is, airports) in
    the states of Hawaii and Alaska.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, we first create a `scala` package called `d3a` that is embedded
    in our notebook (you can download it from here: [http://bit.ly/2kPkXkc](https://github.com/drabastomek/learningPySpark/blob/master/Chapter08/LearningPySpark_Chapter08.ipynb)).
    Because we''re using Databricks notebooks, we can make `Scala` calls within our
    PySpark notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the preceding query for on-time and early arrivals flights are
    visualized in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing flights using D3](img/B05793_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can hover over the airports (blue circle, vertex) in the airports D3 visualization
    where the lines are the edges (flights). The preceding visualization is a snapshot
    when hovering over Seattle (SEA) airport; while the following visualization is
    a snapshot when hovering over Los Angeles (LAX) airport:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing flights using D3](img/B05793_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see in this chapter, you can easily perform a lot of powerful data
    analysis by executing queries against graph structures. With GraphFrames, you
    can leverage the power, simplicity, and performance of the DataFrame API against
    your graph problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on GraphFrames, please refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Introducing GraphFrames* ([http://bit.ly/2dBPhKn](http://bit.ly/2dBPhKn))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*On-Time Flight Performance with GraphFrames for Apache Spark* ([http://bit.ly/2c804ZD](http://bit.ly/2c804ZD))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*On-Time Flight Performance with GraphFrames for Apache Spark (Spark 2.0) Notebook*
    ([http://bit.ly/2kPkXkc](https://github.com/drabastomek/learningPySpark/blob/master/Chapter08/LearningPySpark_Chapter08.ipynb))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GraphFrames Overview* ([http://graphframes.github.io/](http://graphframes.github.io/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pygraphframes documentation* ([http://graphframes.github.io/api/python/graphframes.html](http://graphframes.github.io/api/python/graphframes.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GraphX Programming Guide* ([http://spark.apache.org/docs/latest/graphx-programming-guide.html](http://spark.apache.org/docs/latest/graphx-programming-guide.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will expand our PySpark horizon into the area of Deep
    Learning with the focus on TensorFlow and TensorFrames.
  prefs: []
  type: TYPE_NORMAL
