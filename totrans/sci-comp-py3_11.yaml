- en: Chapter 11. Namespaces, Scopes, and Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。命名空间、作用域和模块
- en: In this chapter, we will cover Python modules. Modules are files containing
    functions and class definitions. The concept of a namespace and the scope of variables
    across functions and modules is also explained in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Python模块。模块是包含函数和类定义的文件。本章还解释了命名空间的概念以及函数和模块之间变量的作用域。
- en: Namespace
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Names of Python objects, such as names of variables, classes, functions, and
    modules, are collected in namespaces. Modules and classes have their own named
    namespaces with the same name as these objects. These namespaces are created when
    a module is imported or a class is instantiated. The lifetime of a namespace of
    a module is as long as the current Python session. The lifetime of a namespace
    of a class instance is until the instance is deleted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python对象的名称，如变量、类、函数和模块的名称，收集在命名空间中。模块和类有自己的命名空间，其名称与这些对象相同。这些命名空间在导入模块或实例化类时创建。模块的命名空间生命周期与当前的Python会话一样长。类实例的命名空间生命周期直到实例被删除。
- en: Functions create a local namespace when they are executed (invoked). It is deleted
    when the function stops the execution by a regular return or an exception. Local
    namespaces are unnamed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在执行（调用）时创建一个局部命名空间。当函数通过常规返回或异常停止执行时，它会被删除。局部命名空间是无名的。
- en: 'The concept of namespaces puts a variable name in its context. For example,
    there are several functions with the name `sin` and they are distinguished by
    the namespace they belong to, as shown in the following code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的概念将变量名称放入其上下文中。例如，有几个名为 `sin` 的函数，它们通过所属的命名空间来区分，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'They are indeed different, as `scipy.sin` is a universal function accepting
    lists or arrays as input, where `math.sin` takes only floats. A list with all
    the names in a particular namespace can be obtained by the command `dir(<name
    of the namespace>)`. It contains two special names `__name__` and `__doc__`. The
    former refers to the name of the module and the latter to its docstring:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 它们确实是不同的，因为 `scipy.sin` 是一个接受列表或数组作为输入的通用函数，而 `math.sin` 只接受浮点数。可以通过命令 `dir(<命名空间名称>)`
    获取特定命名空间中所有名称的列表。它包含两个特殊名称 `__name__` 和 `__doc__`。前者指的是模块的名称，后者指的是其文档字符串：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There is a special namespace, `__builtin__`, which contains names that are
    available in Python without any `import`. It is a named namespace but its name
    need not be given when referring to a built-in object:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个特殊的命名空间，`__builtin__`，它包含在Python中无需任何`import`即可使用的名称。它是一个命名命名空间，但在引用内置对象时不需要给出其名称：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Scope of a variable
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: 'A variable defined in one part of a program needs not to be known in other
    parts. All program units to which it a certain variable is known are called the
    scope of that variable. We first give an example; let''s consider the two nested
    functions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的一部分中定义的变量不需要在其他部分中为人所知。所有知道某个变量的程序单元都称为该变量的作用域。我们首先给出一个例子；让我们考虑两个嵌套函数：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Execution of `my_function(3)` results in:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `my_function(3)` 的结果如下：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The variable `e`  is in the namespace of the program unit that encloses the function
    `my_function` . The variable `a`  is in the namespace of this function, which
    itself encloses the innermost function `other_function`. For the two functions,
    `e` is a global variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `e` 位于包含函数 `my_function` 的程序单元的命名空间中。变量 `a` 位于该函数的命名空间中，该函数本身又包含最内层的函数 `other_function`。对于这两个函数，`e`
    是一个全局变量。
- en: 'It is a good practice to pass information to a function only by its parameter
    list and not use the construction from the preceding example. An exception can
    be found in section *Anonymous functions*  in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*, where global variables are used for closures. By assigning it a value,
    a variable automatically becomes a local variable:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将信息通过参数列表传递给函数是一种良好的实践，而不是使用前面示例中的构造。在[第7章](ch07.html "第7章。函数")的*匿名函数*部分中可以找到一个例外，在那里全局变量被用于闭包。通过给它赋值，一个变量自动成为局部变量：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Execution of
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 执行
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'gives:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 给出：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Where `e` became a local variable. In fact, this piece of code now has two variables
    `e` belonging to different namespaces.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `e` 成为一个局部变量。实际上，现在这段代码有两个属于不同命名空间的变量 `e`。
- en: 'By using the `global` declaration statement, a variable defined in a function
    can be made global, that is, its value will be accessible even outside this function.
    The use of a `global` declaration is demonstrated as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `global` 声明语句，可以在函数中定义的变量被设置为全局变量，即其值即使在函数外部也可以访问。以下是如何使用 `global` 声明进行演示：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Avoid using global**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免使用全局变量**'
- en: It would be advisable to avoid using this construct and the use of `global`.
    These kinds of code are hard to debug and maintain. The use of classes (refer
    to [Chapter 8](ch08.html "Chapter 8. Classes"), *Classes*, for more information)
    makes `global` mainly obsolete.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 建议避免使用这种构造和 `global` 的使用。这类代码难以调试和维护。使用类（请参阅第8章[类](ch08.html "第8章. 类")，以获取更多信息）使得
    `global` 主要变得过时。
- en: Modules
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: In Python, a module is simply a file containing classes and functions. By importing
    the file in your session or script, the functions and classes become usable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，模块只是一个包含类和函数的文件。通过在你的会话或脚本中导入该文件，函数和类变得可用。
- en: Introduction
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Python comes with many different libraries by default. You may also want to
    install more of those for specific purposes, such as optimization, plotting, reading/writing
    file formats, image handling, and so on. NumPy and SciPy are two important examples
    of such libraries, matplotlib for plotting is another one. At the end of this
    chapter, we will list some useful libraries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python 默认附带了许多不同的库。你也可能想要安装更多用于特定目的的库，例如优化、绘图、读取/写入文件格式、图像处理等。NumPy 和 SciPy
    是这类库的重要例子，matplotlib 用于绘图是另一个例子。在本章末尾，我们将列出一些有用的库。
- en: 'To use a library, you may either:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用库，你可以：
- en: 'Load only certain objects from a library, for example from NumPy:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只从库中加载某些对象，例如从 NumPy：
- en: '[PRE9]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or load the entire library:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者加载整个库：
- en: '[PRE10]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or give access to an entire library by creating a namespace with the library
    name:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者通过创建一个以库名为名的命名空间来访问整个库：
- en: '[PRE11]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Prefixing a function from the library with the namespace gives access to this
    function and distinguishes this function from other objects with the same name.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在库函数前加上命名空间可以访问此函数，并区分具有相同名称的其他对象。
- en: 'Furthermore, the name of a namespace can be specified together with the `import`
    command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，命名空间的名字可以与 `import` 命令一起指定：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Which option you use affects the readability of your code as well as the possibilities
    for mistakes. A common mistake is shadowing:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择哪种选项会影响你代码的可读性以及出错的可能性。一个常见的错误是遮蔽：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A way to avoid this unintended effect is to use `import`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种意外效果的一种方法是使用 `import`：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Throughout this book, we have used many commands, objects, and functions. These
    were imported into the local namespace by statements such as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用了许多命令、对象和函数。这些是通过以下语句导入到局部命名空间的：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Importing objects in this manner does not make the module from which they are
    imported evident. Some examples are given in the following table (*Table 11.1*):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式导入对象不会使导入它们的模块变得明显。以下表格中给出了几个例子（*表11.1*）：
- en: '| **Libraries** | **Methods** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **库** | **方法** |'
- en: '| `numpy` | `array`, `arange`, `linspace`, `vstack`, `hstack`, `dot`, `eye`,
    `identity`, and `zeros`. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `numpy` | `array`, `arange`, `linspace`, `vstack`, `hstack`, `dot`, `eye`,
    `identity`, 和 `zeros`. |'
- en: '| `numpy.linalg` | `solve`, `lstsq`, `eig`, and `det`. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.linalg` | `solve`, `lstsq`, `eig`, 和 `det`. |'
- en: '| `matplotlib.pyplot` | `plot`, `legend`, and `cla`. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `matplotlib.pyplot` | `plot`, `legend`, 和 `cla`. |'
- en: '| `scipy.integrate` | `quad`. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `scipy.integrate` | `quad`. |'
- en: '| `copy` | `copy` and `deepcopy`. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `copy` | `copy` 和 `deepcopy`. |'
- en: 'Table 11.1: Examples of importing objects'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1：导入对象的示例
- en: Modules in IPython
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPython 中的模块
- en: IPython is used under code development. A typical scenario is that you work
    on a file with some function or class definitions which you change within a development
    cycle. For loading the contents of such a file into the shell, you may use `import`
    but the file is loaded only once. Changing the file has no effect on later imports.
    That's where IPyhthon's magic command `run` enters the stage.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 用于代码开发。一个典型的场景是你在开发周期内修改一些函数或类定义的文件上工作。为了将此类文件的 内容加载到 shell 中，你可以使用
    `import`，但文件只加载一次。修改文件对后续导入没有影响。这就是 IPyhthon 的魔法命令 `run` 出现的原因。
- en: The IPython magic command
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPython 魔法命令
- en: 'IPython has a special magic command named `run` that executes a file as if
    you ran it directly in Python. This means that the file is executed independently
    of what is already defined in IPython. This is the recommended method to execute
    files from within IPython when you want to test a script intended as a standalone
    program. You must import all you need in the executed file in the same way as
    if you were executing it from the command line. A typical example of running code
    in `myfile.py` is:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 有一个名为 `run` 的特殊魔法命令，它将文件作为直接在 Python 中运行一样执行。这意味着文件是独立于 IPython 中已定义的内容执行的。当你想要测试一个作为独立程序设计的脚本时，这是在
    IPython 内部执行文件推荐的方法。你必须以与从命令行执行相同的方式在执行文件中导入所有需要的内容。在 `myfile.py` 中运行代码的典型示例是：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This script file is executed in Python by `exec(open('myfile.py').read())`.
    Alternatively, in IPython the magic command `run myfile` can be used if you want
    to make sure that the script runs independent of the previous imports. Everything
    that is defined in the file is imported into the IPython workspace.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本文件通过 `exec(open('myfile.py').read())` 在 Python 中执行。或者，如果你想在脚本独立于之前的导入运行时，在
    IPython 中可以使用魔法命令 `run myfile`。文件中定义的所有内容都导入到 IPython 工作区。
- en: The variable __name__
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量 __name__
- en: 'In any module, the special variable `__name__` is defined as the name of the
    current module. In the command line (in IPython), this variable is set to `__main__`,
    which allows the following trick:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何模块中，特殊变量 `__name__` 被定义为当前模块的名称。在命令行（在 IPython 中），此变量设置为 `__main__`，这允许以下技巧：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The tests will be run only when the file is directly run, not when it is imported.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试仅在文件直接运行时执行，而不是在导入时执行。
- en: Some useful modules
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些有用的模块
- en: 'The list of useful Python modules is vast. In the following table, we have
    given a very short segment of such a list, focused on modules related to mathematical
    and engineering applications (*Table 11.2)*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的 Python 模块列表非常庞大。在下面的表中，我们给出了一份非常简短的此类列表片段，专注于与数学和工程应用相关的模块（*表 11.2*）：
- en: '| **Module** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **模块** | **描述** |'
- en: '| `scipy` | Functions used in scientific computing |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `scipy` | 科学计算中使用的函数 |'
- en: '| `numpy` | Support arrays and related methods |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `numpy` | 支持数组和相关方法 |'
- en: '| `matplotlib` | Plotting and visualization with the import submodule pyplot
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `matplotlib` | 使用导入子模块 pyplot 进行绘图和可视化 |'
- en: '| `functools` | Partial application  of functions |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `functools` | 函数的偏应用 |'
- en: '| `itertools` | Iterator tools to provide special capabilities, like slicing
    to generators |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | 提供特殊功能的迭代器工具，如切片到生成器 |'
- en: '| `re` | Regular expressions for advanced string handling |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `re` | 高级字符串处理的正则表达式 |'
- en: '| `sys` | System specific functions |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `sys` | 系统特定函数 |'
- en: '| `os` | Operating system interfaces like directory listing and file handling
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `os` | 操作系统接口，如目录列表和文件处理 |'
- en: '| `datetime` | Representing dates and date increments |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `datetime` | 表示日期和日期增量 |'
- en: '| `time` | Returning wall clock time |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `time` | 返回系统时钟时间 |'
- en: '| `timeit` | Measures execution time |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `timeit` | 测量执行时间 |'
- en: '| `sympy` | Computer arithmetic package (symbolic computations) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `sympy` | 计算机算术包（符号计算） |'
- en: '| `pickle` |  Pickling, special file in- and output format |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `pickle` |  Pickling，特殊的文件输入和输出格式 |'
- en: '| `shelves` |  Shelves, special file in- and output format |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `shelves` |  Shelves，特殊的文件输入和输出格式 |'
- en: '| `contextlib` | Tools for context managers |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `contextlib` | 上下文管理器工具 |'
- en: 'Table 11.2: A non-exhaustive list of useful Python packages for engineering
    applications'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.2：工程应用的非详尽 Python 包列表
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started the book by telling you that you had to import SciPy and other useful
    modules. Now you fully understand what importing means. We introduced namespaces
    and discussed the difference between `import` and `from ... import *`. The scope
    of a variable was already introduced in an earlier [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*, but now you have a more complete picture of the importance of that
    concept.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书开头告诉您，您必须导入 SciPy 和其他有用的模块。现在您完全理解了导入的含义。我们介绍了命名空间，并讨论了 `import` 和 `from
    ... import *` 之间的区别。变量的作用域在早期的 [第 7 章](ch07.html "第 7 章。函数") 中已经介绍，但现在您对这个概念的重要性有了更完整的了解。
