- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing and Visualizing Quantum Circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to program with **Qiskit**, using both
    circuits and pulse schedules. We’ll continue with the topic of circuits in this
    chapter, specifically some new features that optimize and speed up the end-to-end
    process by reducing the overhead between the classical and quantum systems during
    heavy computation cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Qiskit provides plenty of features to allow us to do this with ease.
    Additionally, Qiskit provides a set of classes and features to optimize and enhance
    the visualizations of your circuits. Learning about these features will help optimize
    your circuit results and allow you to render the circuits in various styles and
    representations, such as a **directed acyclic graph** (**DAG**).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing circuits using Preset Passmanager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing and enhancing circuit graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to optimize your circuits by using
    various visual and programmatic representations of the backend systems and visualization
    tools. You’ll also have some insights into the various transpiler features available
    that help optimize the transpilation of your circuit for a given quantum backend
    system. You’ll have learned about **Preset Passmanagers** and how they can be
    leveraged to generate custom pass managers used to execute the circuit transformations
    inside the transpiler at varying optimization levels.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, it is expected that you are familiar with creating and executing
    quantum circuits on both a simulator and a quantum computer. Knowledge of quantum
    hardware, such as qubits and connectivity between qubits, is also recommended.
    You may also need to install **Graphviz**, **LaTeX**, and perhaps other dependencies
    in your Python development environment if indicated while running some cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing circuits using Preset Passmanager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to ensure that when a quantum circuit is mapped to the quantum system
    (transpiled), it is done in the most efficient and effective way. This includes
    things such as mapping each qubit to those on the quantum system with the least
    amount of noise affected by decoherence or any other noise source that could introduce
    errors to your results. To accomplish this, we will learn about the **Preset Passmanager**,
    its usage, and the various features it makes available for us to create and execute
    optimal circuits. By optimizing the execution of the circuit to match the topology
    of the quantum device, we reduce the noise and its effect on our results.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about transforming a quantum circuit so that
    it is best matched to the quantum device. We will also learn how to optimize the
    circuit by using the layout optimizer. We will then learn about the backend configuration
    and its optimization, along with the pass manager and passes.
  prefs: []
  type: TYPE_NORMAL
- en: Transpiling a quantum circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a circuit and run it on a quantum device, there are many things
    that occur between the time you send the circuit to be executed on the quantum
    device and the time the results are returned. We looked at a few of those steps
    when we discussed Qiskit Runtime in *Chapter 7*, *Programming with Qiskit*. In
    this chapter, we will look at the various features included in Qiskit Runtime,
    including those introduced in the latest version of Qiskit 1.0\. First, let’s
    look at a basic overview of just a few of the processes that occur when transpiling
    a circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flowchart illustrates the general process in which the circuit
    is transpiled so that it can run on the specified backend and be optimized as
    per the provided settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The transpiler process of a circuit from the initial circuit,
    with passes ](img/B18420_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The transpiler process of a circuit from the initial circuit, with
    passes'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by introducing the general steps taken, as shown in the preceding
    flowchart, during the execution process:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the transpiler will unroll the gates in the circuit down to the basis
    gates of the specified backend system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it will set the layout of the circuit to the device. One example of a
    layout is the *trivial layout* in which the circuit maps the qubits on your circuit
    to the same physical qubits on the quantum device. For example, qubit 0 on your
    circuit is mapped to the same qubit index, in this case, qubit 0 on the physical
    device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it will map the circuit to the hardware topology. This is to ensure that
    the logic of your circuit is mapped onto the quantum hardware. For example, let’s
    say you have a CNOT that connects the control qubit to the target qubit. However,
    if there is not a direct connection between the control and target qubits, then
    the transpiler will add some SWAP gates to ensure that the connection between
    the two qubits is made by swapping information between qubits in between the control
    and target qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the circuit mapping will be optimized to ensure that the circuit depth
    is contained to a minimum for the given quantum system. Steps 2 and 3 can be mapped
    to any combination of qubits on the physical device; as you can imagine, finding
    the right combination of qubits to use that reduces the depth of the circuit is
    very difficult. Thankfully, the transpiler handles this for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The transpiler is made up of two primary components – that is, the **pass**
    and the **pass manager**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A transpiler **pass** is the component that transforms the circuit from its
    current state into a new state. For example, some passes mentioned in the previous
    steps are focused on layout selection, routing, optimizations, circuit analysis,
    and many others. To see an exhaustive list of available passes, you can run the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will list all the passes available. For a detailed description
    of Pass Manager, I recommend reviewing the API documentation under `qiskit.transpiler.PassManager`.
    To ensure you have the latest code information, check the main API documentation
    page found here: [https://docs.quantum.ibm.com/api/qiskit/transpiler](https://docs.quantum.ibm.com/api/qiskit/transpiler).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additional examples can also be found in the guide here: [https://docs.quantum.ibm.com/guides/transpile](https://docs.quantum.ibm.com/guides/transpile).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **pass manager** is the component that is available to you to specify which
    passes you wish to use. The pass manager also allows the passes themselves to
    communicate with other passes. This is ideal for scenarios where one pass would
    provide or obtain information from other passes to ensure the final circuit adheres
    to any configuration or optimization requirements. The pass manager also has some
    preset passes that it makes available to simplify the optimization of a circuit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating preset passmanagers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ease the use of these passes and passmanagers, Qiskit comes with a few pre-built
    transpilation pipelines (four at the time of this writing). Each can be found
    in the `qiskit.transpiler.preset_passmanagers` module. These pre-built preset
    pass managers are based on the optimization level selected. These four are currently
    numbered from 0 to 3\. Generating these is also simplified by using the `generate_preset_pass_manager()`
    function. The preset pass managers are the default pass managers used by the `transpile()`
    function, which constructs a standalone passmanager that mirrors the `transpile()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will create a simple circuit and transpile it by
    using the preset passmanager generator, which leverages existing preset pass manager
    pipelines. We’ll also run the same circuit with two different optimization levels
    to see how the resulting circuit differentiates between the two. Finally, we will
    create a custom topology to transpile the circuit and compare the results of that
    to a circuit created via the preset optimizer. This will illustrate the consequences
    of selecting a layout that has not been optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing circuit mappings on different backend devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To visualize information on the backend, we learned earlier that we can call
    the configuration and properties functions to output all the information. That
    can be handy if we want to extract specific data from the results; however, it
    is quite difficult to read. This is where the visualization tool comes in very
    handy. Let’s first pick two backend systems to compare. In this example, I’ll
    choose `ibm_brisbane`, and `ibm_nazca`, but you can select whichever quantum device
    you have available by running the `service.backends()` to get a list of available
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have selected both backend views, let’s look at a visual representation
    of the gates and how they are physically connected using the coupling map. You
    can see the coupling map by calling the `plot_gate_map` visualization function
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print out the full connection map of all the qubits for the specified
    backend, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Cropped view of the ibm_brisbane connection map'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 8.2*, with `ibm_brisbane` (we’ll refer to this backend device as
    `Brisbane` moving forward for simplicity), we can see that not only is it a 127-qubit
    device (cropped so it is easier to read), but also the qubits are connected in
    a heavy-hex formation. You can find details about this here: [https://www.ibm.com/quantum/blog/heavy-hex-lattice](https://www.ibm.com/quantum/blog/heavy-hex-lattice).
    Due to the size of the processor, some of the qubit numbers are not clear, so
    you may need to zoom in to view these up close. Also, note that signals can travel
    in both directions between each qubit via the connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now visualize the coupling directional map of `ibm_nazca`, hereafter
    referred to as just Nazca. Run the following cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see the gate map with the coupling directional mapping between
    each qubit, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A grid of numbers and letters  Description automatically generated](img/B18420_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Qubit plot view with the coupling directional map enabled (ibm_nazca)'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the coupling maps have some similarities between the two
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the different configurations of the qubits, the layout of the qubits
    from the quantum circuit we created might not be defined in the most optimal way
    when mapping the qubits on the quantum circuit to the qubits on the hardware device.
    Luckily for us, we have transpilation features, which include a parameter setting
    that allows us to set the level of optimization of the circuit layout. The next
    section will cover the various passes available, and the pass manager used to
    manage their usage.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding passes and pass managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Passes are generally used to transform circuits so that they are set up to
    perform as optimally as desired. There are five general types of passes that transform
    circuits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layout selection** determines how the qubit layout mapping will align with
    the selected backend configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing** maps the placement of SWAP gates onto the circuit based on the
    selected swap mapping type, which can be set by providing a coupling map or backend
    topology, or by using stochastic methods, where the system will not assume the
    input state to the circuit is the ground/zero state to simplify the circuit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basis change** offers various ways to decompose, or unroll, the gates down
    to the basis gates of the backend or using the circuit’s decomposition rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimizations** optimize the circuits themselves by removing redundant gates,
    such as having two of the same reversible gates, such as a Hadamard gate, back
    to back, which reverts the qubit to the original state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit analysis** provides circuit information, such as the depth, width,
    number of operations, and other details about the circuit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional passes** are those that offer some other form of optimization,
    such as the various **check maps**, which check whether the layout of the CNOT
    gates is in the direction stated in the coupling maps and rearrange the directions
    if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered most of the **circuit analysis** information in *Chapter 7*, *Programming
    with Qiskit*, to detect the size, width, and number of operations in a circuit.
    Let’s look at the first pass type, Layout Selection, to see how we can leverage
    the provided layouts and learn the difference between the various optimization
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the Layout Selection type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s dig down into one of these types of passes to get a little more detail.
    Since we must map the qubits from the circuit to the specified hardware each time,
    and we want to execute our circuit on a quantum system, we’ll view the layout
    pass. There are various layout passes to choose from when you want to map the
    qubits to the physical device. Reasons for this could include wanting your qubits
    to be as close as possible to avoid having multiple SWAP gates, or if you are
    working on error correction or mitigation, then you may want to map your gates
    exactly to the physical qubits to ensure your experiments are consistent. Let’s
    look at a few of the basic layout options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TrivialLayout`: This layout assigns the circuit qubits to the physical device’s
    qubits in the same order as stated in the original quantum circuit. So, qubit
    0 is mapped directly to qubit 0 on the physical device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DenseLayout`: This layout selects the layout that has the most connected subset
    of qubits. If there is a need for many entangled qubits, this layout will find
    a subset in which qubits are closely connected to each other so as to avoid long
    distances and swaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sabre`: This layout leverages a qubit mapping technique that looks at the
    reversibility of the quantum circuit where it will try to interpret the global
    circuit information to choose the optimal initial layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of the passes described above, there is a different default setting
    for the optimization level of the transpiler. The optimization level is comprised
    of 4 levels that range from 0 to 3, which specifies whether to not optimize the
    circuit at all (level 0) up to full optimization (level 3). The higher the optimization
    level, the more optimized the resulting circuit will be; however, it will of course
    require a bit more time to run.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to apply and differentiate between each
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Applying default layouts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with the default layouts. We’ll set the various optimization levels
    in the transpiler function parameter and apply it to the two backend devices,
    `Brisbane` and `Nazca`, in the following steps. One thing to keep in mind is that
    at the time of writing, all systems available have the same connectivity between
    qubits and very similar properties. However, by the time this book is published,
    there will be varying systems with varying properties, so even though the results
    here might look the same, the results you see (if the systems you are comparing
    are different) will vary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll reuse the same four-qubit quantum circuit we created earlier. I’ll include
    it again here for your convenience:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will result in our basic circuit where each of the 4 qubits is entangled
    via the CX gates to the first qubit, q[0].
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with `Brisbane` and set the optimization level to `0`, which is
    to say we will not use any optimization techniques on the circuit. What this will
    result in is the qubit on our quantum circuit `[0,1,2,3]`, which will map to the
    same qubit index values on the backend device, `Brisbane [0,1,2,…,126]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will leverage the `qc` circuit and use it to test
    the various optimization levels. We’ll then print out the transpiled circuit depth
    and visualize the layout with the mapped qubits drawn as an overlay over the backend
    device. This will illustrate how the different methods are applied to the backend
    device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that your results might be different due to the stochastic parts of the
    transpiler. So, whatever result you get is the optimal result at the time of execution.
    To ensure you get the same results, you will need to set the `seed_transpiler`
    parameter of the `transpiler()` function to a random integer value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, as follows, is as expected, where the qubits are mapped with no
    layout optimization at all, and there is the direct mapping of qubits from the
    quantum circuit to the hardware device. Note also that the depth is `6464`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A blue lines with black dots  Description automatically generated](img/B18420_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Transpiled quantum circuit on Brisbane with optimization = 0; direct
    qubit mapping with no changes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s draw the transpiled circuit on `Brisbane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will render the transpiled circuit using the basis gates available on `Brisbane`;
    it has been truncated in the following figure to save space.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a mathematical equation  Description automatically generated
    with medium confidence](img/B18420_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Transpiled circuit of basis gates on Brisbane'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the unused qubits are not visible due to our use of the `idle_wires=False`
    parameter when calling the `circuit_drawer()` function. If we remove this parameter,
    you will see all qubits, even those that are not in use. Also note that the qubit
    mappings are depicted on the left side of the circuit diagram where the circuit
    mapping is pointing to the physical device’s qubit. In the previous figure, we
    can see that from the circuit, q[0] maps to the 0^(th) qubit on the physical device
    (as shown by the indicator q[0] -> 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the same thing on `Nazca` with the same level of optimization
    set to `0`. We should see the same results, in that the transpiled circuit is
    mapped to the same qubits as our quantum circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will result in the following depth information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting layout mapping, as follows, is also displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A blue lines with black dots  Description automatically generated](img/B18420_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Transpiled circuit on Nazca'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at the transpiled circuit for the `Nazca` quantum device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now draw the transpiled circuit using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will display the following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A line of blue squares with black lines  Description automatically generated](img/B18420_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Transpiled circuit on Nazca'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is the set of multi-qubit gates between q[0] and q[1] after
    the first set of single-qubit gates. These multi-qubit gates can be used to create
    a CNOT, SWAP, or ROTX gate, represented by the red block labeled **Ecr**. This
    routing of information between qubits is the result of the routing pass, which
    looks for the most optimal connection between qubits. The following figure shows
    the decomposed SWAP gate.
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: SWAP gate decomposed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now maximize the optimization level to `3`, which performs the highest
    optimization of the quantum circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will print out the total circuit depth and the total number
    of operators (`Ops count`) in the transpiled circuit, along with the rendering
    of the transpiled mapping of the qubits onto `Brisbane`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you’ll notice some gates you might not have seen before; you can find
    details about each gate in the circuit library on the Qiskit API documentation
    page here: [https://docs.quantum-computing.ibm.com/api/qiskit/circuit_library](https://docs.quantum-computing.ibm.com/api/qiskit/circuit_library).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the rendering of the transpiled mapping of the
    qubits, as mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a network  Description automatically generated](img/B18420_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Transpiled circuit with the optimization level set to 3 for Brisbane'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, to optimize the quantum circuit, the
    qubit order is adjusted from the previous example on `Brisbane`. This is due to
    the `optimization_level` parameter being set to 3 (highest), which includes mapping
    to the most optimal qubits. This also highlights the difference in circuit depth
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now draw the transpiled circuit to review the circuit layout to the backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result, as follows, is the same circuit that is now mapped to different
    qubits compared to the circuit in *Figure 8.6*. The difference between this circuit
    and the previous one is simply that the transpiler has the maximum optimization
    level set, so it will map the qubit operators to the most optimal qubits. For
    example, here we see qubit 0 is mapped to qubit 4, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a circuit  Description automatically generated](img/B18420_08_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Transpiled circuit with the optimization level set to 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll set the same optimization level on `Nazca` to `3` and then transpile
    the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the total depth is the same, as is the number and type of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, note that the layout is not necessarily linear; it seems *T-shaped*,
    where qubit 0 is connected to 3 qubits, like that of `Brisbane`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A grid with dots and lines  Description automatically generated](img/B18420_08_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Transpiled circuit with the optimization level set to 3'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, to optimize the circuit depth and reduce noise, the qubit order
    is reversed from the previous example run on `Nazca`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s draw the circuit using the transpiled circuit and see how this mapping
    looks compared to the previous circuit mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![A diagram of a mathematical equation  Description automatically generated
    with medium confidence](img/B18420_08_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Transpiled circuit with the optimization level set to 3'
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of qubit **0**, now qubit **44** on the hardware, which was mapped
    as the qubit on which to base the connections to the other qubits, **0**, **3**,
    and **2** in the ECR at the end of the circuit. This is a good example, where
    the optimizer mapped the ECR gates to the physical qubits, for example, qubit
    **45** to qubits **44**, **46**, and **54** on the device, to optimize based on
    other passes used besides the routing pass. One reason for this case could be
    that one of the passes considered the coherence time (relaxation time, T1) of
    the qubits, which is the time a qubit can maintain its quantum state, where the
    qubit with the longest coherence time, at the time the circuit was transpiled,
    is qubit `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying custom layouts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, let’s now create our own custom mapping, or **topology**, as it is
    often referred to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by reviewing the coupling map of an existing device; in this case,
    let’s continue using `brisbane`, which has 127 qubits. We’ll review the configuration
    of the backend first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code sets the backend so we can obtain the configuration and property
    values of the quantum device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the coupling map for `ibm_brisbane` by calling the backend configuration’s
    `coupling_map` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will result in displaying an array of the coupling layout
    of `ibm_brisbane`. You can verify this by comparing it to the backend view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will draw the coupling map to see how efficient our circuit is with
    the default map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our circuit, using this topology, is now different from what we saw in `brisbane`
    in *Figure 8.10*. Here, we see that the same circuit is now transpiled based on
    earlier results of the `brisbane` topology, as follows (note that this can vary
    depending on the calibration of the system):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a circuit  Description automatically generated](img/B18420_08_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: The custom circuit using the topology provided by the ibm_brisbane
    coupling map'
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, you have extracted the coupling map from existing backend systems,
    in this case, `ibm_brisbane`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s create our own custom topology. For simplicity, we will create a
    simple linear topology, where the qubits are joined together in a line, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result from the preceding circuit code is clearly not ideal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a diagram  Description automatically generated](img/B18420_08_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Custom linear topology of our circuit'
  prefs: []
  type: TYPE_NORMAL
- en: The circuit requires many gates and is quite deep, which increases the risk
    of having noisy results. This is a good illustration of the importance of optimizers,
    which handle many of these potential issues. It’s no surprise that there is so
    much research in identifying better ways to optimize circuits to avoid inefficient
    and noisy circuits. However, having the ability to customize your own topology
    allows you to create optimal passes that could find unique and effective ways
    to optimize the mapping of circuits for testing and experimental purposes.
  prefs: []
  type: TYPE_NORMAL
- en: There are many passes that optimize the circuit (we’ve just covered the layouts
    as it is easy to see the differences). If you were to look at the full list of
    passes, you would see that if you change the order of the passes, it will change
    the results of the circuit when mapped to the physical device. To account for
    this, we need to look at the pass manager.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the pass manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pass manager is what allows the passes to communicate with each other,
    schedules which passes should execute first, and allows for custom passes to be
    included in the list of passes. This is not as simple as it sounds, as there may
    be a significant difference if one pass is used before another or perhaps is unable
    to communicate with another pass. We’ll conclude this section with a simple example
    of the pass manager, using the following steps to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first append `TrivialLayout` to `PassManager` and execute the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting circuit is as follows. Note the specifics of this circuit as
    we will be comparing the differences between the layouts of this circuit and the
    upcoming circuit (in *Figure 8.16*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – PassManager with the appended TrivialLayout Pass circuit ](img/B18420_08_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: PassManager with the appended TrivialLayout Pass circuit'
  prefs: []
  type: TYPE_NORMAL
- en: Soon we will explore the functionality of the pass manager using the routing
    pass type. We saw a little bit of this when the SWAP gates were added to connect
    qubits when they are not directly connected on the physical device. In the following
    steps, we will look at passes that optimize the routing of these SWAP gates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following code, we will create a `BasicSwap` pass, rerun `PassManager`
    on the circuit, and compare the results to the previous circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previous code will create a `BasicSwap` router and add it to `PassManager`
    upon construction. The executed circuit result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a circuit  Description automatically generated](img/B18420_08_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: PassManager with a BasicSwap router pass circuit'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the circuit will adapt to each of the passes called from `PassManager`
    – in this case, we added the `BasicSwap` pass to the PassManager in the code,
    which then rendered the circuit mapping in one form, whereas the `TrivialLayout`
    pass rendered in a different form. Doing this gives you the ability to order how
    the various passes are run during the optimization process of the PassManager.
    Having this ability provides you with options to test out, should you be researching
    ways to optimize how your circuit is mapped and run on a backend device.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a moment to digest what we’ve learned so far. When using the `optimization_level`
    option to execute our circuit on a backend, the PassManager uses the preset passes
    based on the specific level selected (i.e., 0, 1, 2, or 3). What we managed to
    do here is customize which passes to use and in what order, as we did when we
    added the BasicSwap pass to the previous code. Having this ability not only provides
    you with the flexibility to experiment with various sequences of passes, but you
    can also create your own pass and compare it with those existing passes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with pass managers, you can see that they can be very
    helpful if you want to use a combination of passes in a way that, when leveraged
    one after the other, improves the optimization of the circuit as it is modified
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we also learned about the transpiler and how it provides ways
    to optimize circuits. We also learned about transforming and optimizing the circuit
    using the layout optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: The next section of this chapter is a bit more visual, by rendering the circuits
    in different styles and operational flows such as **DAGs**. These features provide
    a way to view the circuits and their functionality in a different form rather
    than the default view of the circuits, which is how we have seen them so far.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing and enhancing circuit graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will focus on the various visualizations available in Qiskit. The
    graphs we have been using so far were from the default visualization library in
    Qiskit. However, we can specify other drawing tools that may be better suited
    for your documentation purposes. Say, for example, that you are authoring a research
    paper with **LaTeX** and you want to use the LaTeX content.
  prefs: []
  type: TYPE_NORMAL
- en: By simply adding style parameters from the Qiskit visualization library, you
    can then leverage the many features included with the visualization library. We’ll
    cover a few of those now to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about customized visual circuits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When rendering a circuit, it is often necessary or convenient to have the results
    in a format that suits the format of your document. It’s here where the Qiskit
    `circuit_drawer` comes in handy with various features. Let’s begin with a simple
    quantum circuit to illustrate the various visual rendering examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a quantum circuit with various operators to get a good
    representation of all the visual components in the various formats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will render the following circuit drawing, which is just a random representation
    of gates. This circuit does not do anything special; it’s just used to represent
    various components. As an option, you can use the `random_circuit` method to create
    a random circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, line chart  Description automatically generated](img/B18420_08_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Circuit rendering using the default library'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will render the preceding circuit using `latex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will render the `latex` version of the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re running this on your local machine and not on the platform, you may
    have some warnings or errors indicating you need to install some file dependencies,
    such as installing `pylatexenc`. To install this library you will need to run
    `pip install pylatexenc` in a cell first, and then restart the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18420_08_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.18: Circuit rendering using the latex library'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are planning to post your circuit onto a website, blog, or social media
    and would like to include some styles on the image, you can do that as well by
    passing in the style contents as a parameter, such as `backgroundcolor`, `gatetextcolor`,
    and `fontsize`, just to name a few:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code results in adjusting the background, gate color schemes,
    and font size, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_08_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: Rendered circuit with the custom style dictionary on matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: To use the style setting, you must use the output `matplotlib` as this is the
    only library that supports the styles.
  prefs: []
  type: TYPE_NORMAL
- en: Details on the available list of styles can be found in the *Style Dict Details*
    section of the Qiskit API documentation ([https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.visualization.circuit_drawer](https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.visualization.circuit_drawer)).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will cover a full view of the circuit as a DAG, which will be helpful
    to see the circuit as a graph to understand how it flows.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the directed acyclic graph of a circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As circuits get larger, they will naturally get more complex, and even visualizing
    a circuit can get complicated. Imagine a circuit with thousands of qubits and
    with a depth of over 1,000\. This would be difficult to render and almost impossible
    to read. This is where DAGs may help. Let’s create one based on the circuit that
    we previously created to illustrate rendering and see how the DAG of that circuit
    looks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, you will need two components; the first is the circuit-to-DAG
    converter. This will convert the circuit into a DAG. The second component is the
    DAG drawer, which will draw out the DAG where the nodes are represented as quantum
    registers, classical registers, quantum gates, barriers, and measurement operators.
    The edges are directional, which illustrates the flow of the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following rendering of the DAG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.28 – The DAG rendering of a quantum circuit ](img/B18420_08_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.20: The DAG rendering of a quantum circuit'
  prefs: []
  type: TYPE_NORMAL
- en: The DAG can help illustrate the flow and expected paths of the circuit in order
    from top to bottom, where the top level is the first operation, and each operation
    is appended as you traverse down the graph. For example, the preceding graph starts
    at the top with the qubits in green, then following the graph, we see that each
    qubit (represented by the edge labels between the nodes) is operated upon by a
    specified operation (represented by the nodes). The graph terminates at the end
    in red, where the measurement applied on the qubit is mapped to the specified
    classical bit, represented by the parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about visualizing circuit graphs with the help of
    customized visual circuits. We also learned how to use DAGs to enhance our circuit
    graphs and visualize the path of our circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned various ways to optimize your circuits when they
    are running on one of the many quantum computers that currently exist. You also
    learned about the different passes available to optimize the execution of your
    circuit on a specified quantum device. This includes generating a pass manager,
    which allows you to customize which passes to leverage based on the selected optimization
    level and allows you to choose their order.
  prefs: []
  type: TYPE_NORMAL
- en: We then covered topology and coupling maps, which helped you understand the
    importance of knowing the device configurations should you want to create your
    own passes. By visualizing the circuits in various formats, you now have the skills
    to customize the rendering of images, particularly if you are documenting your
    work and would like to keep a certain look and feel. Finally, we covered alternative
    rendering of the circuit operation flow by using DAGs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about various noises associated with quantum
    systems to understand how we can create noise models that we can use to simulate
    and identify ways to mitigate and run more efficient algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you name the two components of the transpiler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which component allows you to specify the passes to use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default `optimization_level` value when running the transpile()
    function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the three Layout Selection Passes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_8.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code261762599683826593.png)'
  prefs: []
  type: TYPE_IMG
