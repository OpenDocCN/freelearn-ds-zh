["```py\n      loop until i < number_of_rowsA:\n        TmpA[i] = A[i]\n      endloop\n      loop until i < number_of_colsB:\n        TmpB[i] = B[i]\n      endloop\n    ```", "```py\n    loop until (i,j) < (rowA * colB):\n      loop through A[i][_] deposit values into TmpA\n      loop through B[_][j] deposit values into TmpB\n      foreach value in TmpA and TmpB:\n        C[a] = TmpA[x] * TmpB[y]\n    endloop\n    ```", "```py\nVoid matrixMul(float *C, \n               const float *A, \n               const float *B, \n               unsigned int hA, \n               unsigned int wA, \n               unsigned int wB) {\n    for (unsigned int i = 0; i < hA; ++i)\n        for (unsigned int j = 0; j < wB; ++j){   \n            float sum = 0;\n            for (unsigned int k = 0; k < wA; ++k) {   \n                double a = A[i * wA + k]; // statement 1\n                double b = B[k * wB + j]; // statement 2\n                sum += a * b;\n            }   \n\n            C[i * wB + j] = (float)sum; // statement 3\n        }   \n}\n```", "```py\nmatrixA = (cl_int*)malloc(widthA * heightA * sizeof(cl_int));\nmatrixB = (cl_int*)malloc(widthB * heightB * sizeof(cl_int));\nmatrixC = (cl_int*)malloc(widthB * heightA * sizeof(cl_int));\n\nmemset(matrixA, 0, widthA * heightA * sizeof(cl_int));\nmemset(matrixB, 0, widthB * heightB * sizeof(cl_int));\nmemset(matrixC, 0, widthB * heightA * sizeof(cl_int));\n\nfillRandom(matrixA, widthA, heightA, 643);\nfillRandom(matrixB, widthB, heightB, 991);\n```", "```py\n__kernel void mmmult(int widthB, \n                     int heightA, \n                      __global int* A, \n                      __global int* B, \n                      __global int* C) {\n\n    int i = get_global_id(0);\n    int j = get_global_id(1);\n    int tmp = 0;\n\n    if ((i < heightA) && (j < widthB)) {\n        tmp = 0;\n        for(int k = 0; k < widthB; ++k) {\n            tmp += A[i*heightA + k] * B[k*widthB + j];\n        }\n        C[i*heightA + j] = tmp;\n    }\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -arch i386 -o MatrixMultiplication -framework OpenCL\n\n```", "```py\nPassed!\nExecution of matrix-matrix multiplication took X.Xs\n\n```", "```py\nsize_t globalThreads[] = {widthB, heightA};\n\ncl_event exeEvt; \ncl_ulong executionStart, executionEnd;\nerror = clEnqueueNDRangeKernel(queue,\n                               kernel,\n                               2,\n                               NULL,\n                               globalThreads,\n                               NULL, \n                               0,\n                               NULL,\n                               &exeEvt);\nclWaitForEvents(1, &exeEvt);\n```", "```py\n__kernel void mmmult(int widthB, \n                     int heightA, \n                      __global int* A,  \n                      __global int* B,  \n                      __global int* C) {\n\n    int i = get_global_id(0); \n    int tmp = 0;\n\n    if (i < heightA) {\n        for(int j = 0; j < widthB; ++j) {\n            tmp = 0;\n            for(int k = 0; k < widthB; ++k) {\n                tmp += A[i*heightA + k] * B[k*widthB + j]; \n            }   \n            C[i*heightA + j] = tmp;\n        }   \n    }   \n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -arch i386 -o MatrixMultiplication -framework OpenCL\n\n```", "```py\nPassed!\nExecution of matrix-matrix multiplication took X.Xs\n\n```", "```py\nsize_t globalThreads[] = {heightA};\nsize_t localThreads[] = {256};\ncl_event exeEvt; \ncl_ulong executionStart, executionEnd;\nerror = clEnqueueNDRangeKernel(queue,                                                                               \n                               kernel,\n                               1,  \n                               NULL,\n                               globalThreads,\n                               localThreads,\n                               0,  \n                               NULL,\n                               &exeEvt);\nclWaitForEvents(1, &exeEvt);\n```", "```py\n__kernel void mmmult(int, \n                     int widthB heightA, \n                      __global int* A,                      __global int* B, \n                      __global int* C) {\n\n    int i = get_global_id(0); \n\n    int tmp = 0;\n\n    int tmpData[1024];\n\n    if (i < heightA) {\n        for(int k = 0; k < widthB; ++k )\n            tmpData[k] = A[i*heightA + k];\n\n        for(int j = 0; j < widthB; ++j) {\n            tmp = 0;\n            for(int k = 0; k < widthB; ++k) {\n                tmp += tmpData[k] * B[k*widthB + j];\n            }\n            C[i*heightA + j] = tmp;\n        }\n    }\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -arch i386 -o MatrixMultiplication -framework OpenCL\n\n```", "```py\nPassed!\nExecution of matrix-matrix multiplication took X.Xs\n\n```", "```py\nfor i1 = 1 to 6\n  for i2 = 1 to 6\n    A[i1,i2] = A[i1 – 1, i2] + A[i1,i2 -2]\n```", "```py\nfor i1 = 1 to 6 step-by-2\n  for i2 = 1 to 6 step-by-2\n    A[i1,i2] = A[i1 –1, i2] + A[i1,i2 -2]    //statement 1\n    A[i1 +1,i2] = A[i1,i2] + A[i1+1,i2 -1]    //statement 2\n    A[i1,i2 +1] = A[i1 –1, i2+1] + A[i1,i2]   //statement 3\n    A[i1+1,i2+1] = A[i1, i2 +1] + A[i1+1,i2]\n```", "```py\nfor i1 = 1 to 6 step-by-2\n  X = A[i1,0]\n  for i2 = 1 to 6 step-by-2\n    X          = A[i1 –1, i2] + X\n    A[i1 +1,i2] = X + A[i1+1,i2 -1]    \n    A[i1,i2 +1] = A[i1 –1, i2+1] + X   \n    A[i1+1,i2+1] = A[i1, i2 +1] + A[i1+1,i2]\n     A[i1,i2] = X \n```", "```py\nfor(int j = 0; j < widthB; ++j) {\n    tmp = 0;\n    for(int k = 0; k < widthB; ++k) {\n        tmp += tmpData[k] * B[k*widthB + j];\n    }\n//more code omitted\n}\n```", "```py\n__kernel void mmmult(int widthB, \n                     int heightA, \n                      __global int* A,  \n                      __global int* B,  \n                      __global int* C,\n                      __local  int* shared) {\n\n    int i = get_global_id(0);\n    int id = get_local_id(0);\n    int size = get_local_size(0);\n    int tmp = 0;\n\n    int tmpData[1024];\n\n    if (i < heightA) {\n        /*\n         Pre-load the data into the work-item's register memory that is \n         Visible to the work-item only. \n         */\n        for(int k = 0; k < widthB; ++k ) {\n            tmpData[k] = A[i*heightA + k]; \n        }   \n\n        /*\n         Data pre-fetching into shared memory allows all work-items\n         To read the data off it instead of loading the data from global\n         Memory for every work-item\n        */\n        for(int k = id; k < widthB; k += size) \n            shared[k] = B[k*widthB +k];\n        barrier(CLK_LOCAL_MEM_FENCE);\n\n        for(int j = 0; j < widthB; ++j) {\n            tmp = 0;\n            for(int k = 0; k < widthB; ++k) {\n                tmp += tmpData[k] * shared[k];\n            }\n            C[i*heightA + j] = tmp;\n        }\n    }\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -arch i386 -o MatrixMultiplication -framework OpenCL\n\n```", "```py\nPassed!\nExecution of matrix-matrix multiplication took X.Xs\n\n```", "```py\nclSetKernelArg(kernel, 0, sizeof(cl_int),(void*)&widthB);\nclSetKernelArg(kernel, 1, sizeof(cl_int),(void*)&heightA);\nclSetKernelArg(kernel, 2, sizeof(cl_mem),(void*)&matrixAMemObj);\nclSetKernelArg(kernel, 3, sizeof(cl_mem),(void*)&matrixBMemObj);\nclSetKernelArg(kernel, 4, sizeof(cl_mem),(void*)&matrixCMemObj);\nclSetKernelArg(kernel, 5, sizeof(cl_int)*heightA,NULL);\n\nsize_t globalThreads[] = {heightA};\nsize_t localThreads[] = {256};\ncl_event exeEvt; \ncl_ulong executionStart, executionEnd;\nerror = clEnqueueNDRangeKernel(queue,\n                               kernel,\n                               1,\n                               NULL,\n                               globalThreads,\n                               localThreads,\n                               0,\n                               NULL,\n                               &exeEvt);\nclWaitForEvents(1, &exeEvt);\n```"]