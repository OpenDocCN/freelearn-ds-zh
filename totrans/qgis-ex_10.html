<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Developing a Python Plugin &#x2013; Select by Radius" id="aid-28FAO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Developing a Python Plugin – Select by Radius</h1></div></div></div><p>While Processing's models and scripts are great for automating different analysis tasks, sometimes you may want to extend the QGIS functionality in another way—by developing a plugin.</p><p>In this chapter, we will go through the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">QGIS plugins</li><li class="listitem">Creating a plugin's skeleton</li><li class="listitem">Designing a plugin's GUI</li><li class="listitem">Using designer UI files in the plugin</li><li class="listitem">Implementing feature selection</li><li class="listitem">Adding translations</li><li class="listitem">Preparing the plugin for publishing</li></ul></div><div class="section" title="QGIS plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec70"/>QGIS plugins</h1></div></div></div><p>From the very <a id="id660" class="indexterm"/>beginning, QGIS was developed with the extensible and modular architecture. Originally, it allowed us to extend its functionality only with C++ plugins. But, starting from version 0.9, when Python support was added, users and developers were able to create plugins using the Python programming language as well.</p><p>Every QGIS Python plugin is just a set of the Python modules and additional files bundled into a single Python package. These packages should be placed in separate subdirectories under a special directory in the QGIS home path. Usually, this is <code class="literal">~/.qgis2/python/plugins</code>, where <code class="literal">~</code> is a user home (profile) directory. In Windows, it is <code class="literal">C:\Users\your_profile</code>, and in UNIX-like systems, it is <code class="literal">/home/your_profile</code>.</p><p>The minimal working plugin should contain two files in this directory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">__init__.py</code>: This is the<a id="id661" class="indexterm"/> package initialization file and the plugin's entry point. It should contain the <code class="literal">classFactory()</code> method.</li><li class="listitem"><code class="literal">metadata.txt</code>: This contains <a id="id662" class="indexterm"/>plugin metadata used by <span class="strong"><strong>Plugin Manager</strong></span> and the plugins website. This metadata includes plugin name, version, description, and other information.</li></ul></div><p>However, real plugins <a id="id663" class="indexterm"/>usually contain many more files in their directory: additional source files, GUI forms, corresponding sources with logic, icons and other resources, and so on. Of course, all of these files can be placed in the plugin's root directory, but to keep the source tree clean and easy to maintain, files are often organized in subdirectories. For example, Qt Designer forms are placed in the <code class="literal">ui/</code> subdirectory, corresponding sources with logic under the <code class="literal">gui/</code> subdirectory, and icons and other resources under <code class="literal">resources/</code> subdirectory and so on.</p><p>To develop QGIS plugins with <a id="id664" class="indexterm"/>Python, you will need these pieces of software:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>QGIS</strong></span>: This is meant for<a id="id665" class="indexterm"/> testing and debugging your plugin. It is better to use the same QGIS version for which the plugin is<a id="id666" class="indexterm"/> developed. If you want to develop a plugin that works on multiple QGIS versions, in all <code class="literal">2.x</code> series for example, use as old a version as possible because the newest versions may have some minor additions to the API.</li><li class="listitem"><span class="strong"><strong>Text editor or Python IDE</strong></span>: Here, you will be writing your code. It is better to use something more <a id="id667" class="indexterm"/>advanced<a id="id668" class="indexterm"/> than the standard Notepad or any other plain text editor. Syntax highlighting, auto-indentation, and autocompletion will make your work easier and more comfortable.</li><li class="listitem"><span class="strong"><strong>Qt Designer</strong></span>: This is used to<a id="id669" class="indexterm"/> design the user interface. For Windows, it can be installed using the <code class="literal">OSGeo4W</code> installer. The corresponding package is called <a id="id670" class="indexterm"/><span class="strong"><strong>qt4-devel</strong></span>. If you are a Linux user, use your package manager to find and install the Qt developer tools.</li></ul></div><p>Also, to make debugging easier, we recommend that you<a id="id671" class="indexterm"/> install the <span class="strong"><strong>Plugin</strong></span> <span class="strong"><strong>Reloader</strong></span> plugin. Plugin Reloader is extremely useful because it allows you to reload your plugin after changing its code in one click, without having to restart QGIS.</p><p>In this chapter, we will develop a plugin for selecting features of the specified vector layer that are located within a given distance around reference features (already selected by the user) of another layer.</p><p>There are two ways of developing QGIS Python plugins:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a plugin template with the help of the<a id="id672" class="indexterm"/> <span class="strong"><strong>Plugin</strong></span> <span class="strong"><strong>Builder</strong></span> plugin. Then, refine this template and add the necessary functionality.</li><li class="listitem">Develop the plugin manually by creating all the required files and code yourself.</li></ol><div style="height:10px; width: 1px"/></div><p>The first approach (using Plugin Builder) is the most commonly used, and is recommended by many authors as the easiest way for novices. However, it is necessary to remember that while Plugin Builder is a great and user-friendly tool, it also hides some details, compels you to<a id="id673" class="indexterm"/> use a specific directory structure, and makes some assumptions about how your plugin will work. Also, a template generated by this plugin will contain many additional files, and these are not really necessary in all cases, for example, help file template, data for unit tests, shell scripts, and so on. Of course, all of these files can be removed or adjusted as per your needs, but it is necessary to have good knowledge to avoid deleting the necessary stuff.</p><p>In this chapter, we will create a plugin manually by adding the required files and directories step by step. This gives us full control over the plugin structure and appearance and also allows us to understand things better.</p></div></div>
<div class="section" title="Creating the plugin's skeleton"><div class="titlepage" id="aid-29DRA2"><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Creating the plugin's skeleton</h1></div></div></div><p>Let's start with developing<a id="id674" class="indexterm"/> our plugin. Create a directory for the plugin somewhere in your disk. As our plugin will select features within a given radius, we call it <code class="literal">Select</code> <code class="literal">by</code> <code class="literal">Radius</code> and use <code class="literal">selectradius</code> as the name of the plugin directory.</p><p>Now, open you favorite text editor and create a file with this content:</p><div class="informalexample"><pre class="programlisting">[general]
name=Select by Radius
description=Select features in the given radius around another one
about=Selects features of the specified vector layer which are located within the given radius around reference pre-selected features of the any other layer
category=Vector
version=0.1.0
qgisMinimumVersion=2.8

author=enter_your_name_here
email=your@email

icon=icons/selectradius.svg

tags=vector,select,selection

homepage=
tracker=
repository=

experimental=True
deprecated=False</pre></div><p>Save it as <code class="literal">metadata.txt</code> in the plugin directory. This is the metadata file for our plugin. As you can see, it has very simple structure, similar to <code class="literal">INI</code> Windows files. There is only one section called <code class="literal">general</code>, which contains all the metadata items in the <code class="literal">key=value</code> notation. Empty strings between metadata items used for logical grouping can be safely removed. The order of the metadata items does not matter as long as all the necessary items are there and their format is correct.</p><p>All metadata items can be divided into two groups: mandatory and optional. The following metadata<a id="id675" class="indexterm"/> items are mandatory and should be always presented in the <code class="literal">metadata.txt</code> file:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>name</strong></span>: This is the name<a id="id676" class="indexterm"/> of the plugin. Usually, it contains a human-readable name. Spaces and other characters such as "<code class="literal">-</code>" are allowed.</li><li class="listitem"><span class="strong"><strong>description</strong></span>: This is a short <a id="id677" class="indexterm"/>description of the plugin. Usually, it is one short sentence. More detailed information should be placed in the optional "about" item.</li><li class="listitem"><span class="strong"><strong>version</strong></span>: This is the plugin<a id="id678" class="indexterm"/> version in dotted notation, for example, <code class="literal">1.0.1</code> (if semantic versioning is used). Avoid adding words such as "version" here.</li><li class="listitem"><span class="strong"><strong>qgisMinimumVersion</strong></span>: This defines<a id="id679" class="indexterm"/> the oldest QGIS version supported by the current version of the plugin. The value should be in dotted notation; for example, if the plugin works with QGIS version greater than 2.0, this item should have <code class="literal">2.0</code> as the value.</li><li class="listitem"><span class="strong"><strong>author</strong></span>: This is the name of the<a id="id680" class="indexterm"/> plugin's author. Enter your name as the value.</li><li class="listitem"><span class="strong"><strong>email</strong></span>: This is the e-mail of the plugin's author. Provide your valid e-mail address here. Note<a id="id681" class="indexterm"/> that this e-mail address is not published anywhere and is used only by the plugin repository admins if they need to contact the author.</li></ul></div><p>All other metadata items are optional and can be blank. Here is the full list of optional metadata items:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>about</strong></span>: This contains more<a id="id682" class="indexterm"/> detailed information about plugin. It complements the information in the "description" metadata item.</li><li class="listitem"><span class="strong"><strong>category</strong></span>: This is the helper<a id="id683" class="indexterm"/> metadata item. It helps users understand in which menu to look for your plugin after its installation. The supported values are <code class="literal">Raster</code>, <code class="literal">Vector</code>, <code class="literal">Database</code>, and <code class="literal">Web</code>. For example, if the plugin has to be placed under the <span class="strong"><strong>Vector</strong></span> menu, this metadata should have the <code class="literal">Vector</code> value. If this is not set, the default <code class="literal">Plugins</code> value is used. Note that this metadata is<a id="id684" class="indexterm"/> used only as reference. You need to write the code for creating plugin actions in the correct menu by yourself.</li><li class="listitem"><span class="strong"><strong>qgisMaximumVersion</strong></span>: This<a id="id685" class="indexterm"/> defines the last QGIS version supported by the current version of the plugin. Its value should be in dotted notation. Usually this is not used. By<a id="id686" class="indexterm"/> default, it is equal to the major number from <code class="literal">qgisMinimumVersion</code> plus 0.99. For example, if <code class="literal">qgisMinimumVersion</code> is <code class="literal">2.0</code> and <code class="literal">qgisMaximumVersion</code> is not set explicitly, it will be <code class="literal">2.99</code>. This metadata is used only in rare cases where the plugin supports a limited subset of QGIS versions or only one QGIS version.</li><li class="listitem"><span class="strong"><strong>icon</strong></span>: This is the filename or the path to the plugin icon, if any. The path should be relative to the base plugin directory. If this is not set, the default icon will be used.</li><li class="listitem"><span class="strong"><strong>tags</strong></span>: This is a comma-separated list <a id="id687" class="indexterm"/>of tags that describe the plugin. Try to use tags from the existing list available at the plugins website at <a class="ulink" href="http://plugins.qgis.org/">http://plugins.qgis.org/</a>.</li><li class="listitem"><span class="strong"><strong>changelog</strong></span>: This is a list of changes<a id="id688" class="indexterm"/> in the current plugin version. It is a multiline item.</li><li class="listitem"><span class="strong"><strong>homepage</strong></span>: This is a link to the plugin's home page, if any. We recommend filling this metadata if you<a id="id689" class="indexterm"/> plan to publish your plugin in the QGIS official plugin repository.</li><li class="listitem"><span class="strong"><strong>tracker</strong></span>: This is a link<a id="id690" class="indexterm"/> to the <code class="literal">bugtracker</code> plugin if any. We recommend filling this metadata if you plan to publish your plugin in the QGIS official plugin repository.</li><li class="listitem"><span class="strong"><strong>repository</strong></span>: This is a<a id="id691" class="indexterm"/> link to the plugin source code repository, if any. We recommend filling this metadata as well if you plan to publish you plugin in the QGIS official plugin repository.</li><li class="listitem"><span class="strong"><strong>experimental</strong></span>: This is a <a id="id692" class="indexterm"/>Boolean flag used to mark the plugin as experimental. Experimental plugins may be unstable and partly nonfunctional, so they are not shown in the <span class="strong"><strong>Plugin Manager</strong></span> unless the corresponding option is set.</li><li class="listitem"><span class="strong"><strong>deprecated</strong></span>: This is a<a id="id693" class="indexterm"/> Boolean flag used to mark the plugin as deprecated. Deprecated plugins are not supported by authors and may not work or may work incorrectly, so they are not shown in the Plugin Manager unless the corresponding option is set.</li></ul></div><p>As you can see, in our <code class="literal">metadata.txt</code> file, we have not only the mandatory items, but also some optional items to<a id="id694" class="indexterm"/> provide more information for plugin users. Note that our demo plugin has empty <code class="literal">homepage</code>, <code class="literal">tracker</code>, and <code class="literal">repository</code> metadata items. In a real plugin, especially if it will be published, these items should contain valid links to the corresponding pages so that the plugin's users can submit bug reports and patches and find the relevant documentation easily.</p><p>Also, if you look at the <code class="literal">icon</code> metadata item, you will see that it contains the relative path to the image file. So, in our plugin directory, it is necessary to create the <code class="literal">icons</code> subdirectory and put the <code class="literal">selectradius.svg</code> icon file into it. Icons can be in any raster format supported by the Qt library, but we recommend that you use PNG format for raster icons and SVG for vector icons. The icon size should be at least 24 x 24 pixels.</p><p>The next step is to create a plugin (and Python package) initialization file, <code class="literal">__init__.py</code>. This file should contain a<a id="id695" class="indexterm"/> <code class="literal">classFactory()</code> function. This function will be called when the plugin is loaded in QGIS. The function body is very short and simple:</p><div class="informalexample"><pre class="programlisting">(1) def classFactory(iface):
(2)    from selectradius.selectradius_plugin import SelectRadiusPlugin
(3)    return SelectRadiusPlugin(iface)</pre></div><p>The <code class="literal">classFactory()</code> function accepts a single argument called <code class="literal">iface</code>—an instance of the <code class="literal">QgsInterface</code> class that provides access to the GUI of the running QGIS copy. It returns the <code class="literal">SelectRadiusPlugin</code> object, which is a plugin instance. The code of the <code class="literal">SelectRadiusPlugin</code> class, imported from the <code class="literal">selectradius_plugin.py</code> file, is located in the plugin's root directory.</p><p>Now, let's implement<a id="id696" class="indexterm"/> the main plugin class. Create a new file called <code class="literal">selectradius_plugin.py</code> in the plugin root directory and add the following code to it:</p><div class="informalexample"><pre class="programlisting">( 1) import os
( 2)
( 3) from PyQt4.QtCore import (
( 4)    QLocale, QSettings, QFileInfo, QCoreApplication, QTranslator)
( 5) from PyQt4.QtGui import (QMessageBox, QAction, QIcon)
( 6)
( 7) from qgis.core import QGis
( 8)
( 9) pluginPath = os.path.dirname(__file__)
(10)
(11)
(12) class SelectRadiusPlugin:
(13)    def __init__(self, iface):
(14)        self.iface = iface
(15)
(16)        overrideLocale = QSettings().value('locale/overrideFlag', False, bool)
(17)        if not overrideLocale:
(18)          locale = QLocale.system().name()[:2]
(19)        else:
(20)          locale = QSettings().value('locale/userLocale', '')
(21)
(22)        qmPath = '{}/i18n/selectradius_{}.qm'.format(pluginPath, locale)
(23)
(24)        if QFileInfo(qmPath).exists():
(25)          self.translator = QTranslator()
(26)          self.translator.load(qmPath)
(27)          QCoreApplication.installTranslator(self.translator)
(28)
(29)    def initGui(self):
(30)        self.actionRun = QAction(
(31)            self.tr('Select by Radius'), self.iface.mainWindow())
(32)        self.actionRun.setIcon(
(33)            QIcon(os.path.join(pluginPath, 'icons', 'selectradius.svg')))
(34)        self.actionRun.setWhatsThis(
(35)           self.tr('Select features within given radius'))
(36)        self.actionRun.setObjectName('SelectRadiusRun')
(37)
(38)        self.actionAbout = QAction(self.tr('About'), self.iface.mainWindow())
(39)        self.actionAbout.setIcon(
(40)            QIcon(os.path.join(pluginPath, 'icons', 'about.png')))
(41)        self.actionAbout.setWhatsThis(self.tr('About Select by Radius'))
(42)        self.actionAbout.setObjectName('SelectRadiusAbout')
(43)
(44)        self.iface.addPluginToVectorMenu(
(45)            self.tr('Select by Radius'), self.actionRun)
(46)        self.iface.addPluginToVectorMenu(
(47)            self.tr('Select by Radius'), self.actionAbout)
(48)        self.iface.addVectorToolBarIcon(self.actionRun)
(49)
(50)        self.actionRun.triggered.connect(self.run)
(51)        self.actionAbout.triggered.connect(self.about)
(52)
(53)    def unload(self):
(54)        self.iface.removePluginVectorMenu(
(55)            self.tr('Select by Radius'), self.actionRun)
(56)        self.iface.removePluginVectorMenu(
(57)            self.tr('Select by Radius'), self.actionAbout)
(58)        self.iface.removeVectorToolBarIcon(self.actionRun)
(59)
(60)    def run(self):
(61)        pass
(62)
(63)    def about(self):
(64)        pass
(65)
(66)    def tr(self, text):
(67)        return QCoreApplication.translate('SelectRadius', text)</pre></div><p>In the first seven lines of this code, we import all the necessary Python packages from the Python standard library, the <code class="literal">PyQt4</code> package, and the <code class="literal">qgis.core</code> library. Usually, these import statements are added and edited on an iterative basis during development. In other words, you write the code, and when a new class or library is needed, you add the corresponding import <a id="id697" class="indexterm"/>statement. As a rule, all import statements are placed at the very beginning of the source's file. For the sake of simplicity, in our sample plugin, we will provide all the necessary imports at the start.</p><p>In line <code class="literal">9</code>, we determine the plugin's path, which will be used later to construct full paths to icons.</p><p>In line <code class="literal">12</code>, a base plugin class is defined. There are several methods implemented in it. The <code class="literal">__init__()</code> method, also called a<a id="id698" class="indexterm"/> constructor, is used for basic initialization of the plugin instance. In line <code class="literal">14</code>, we store a reference to the QGIS interface—passed as the <span class="strong"><strong>iface</strong></span> parameter—for further usage so that we can access and use it from other methods. From lines <code class="literal">16</code> to <code class="literal">27</code>, an internationalization support is activated. We check which locale is used by QGIS and try to load the corresponding translation file from the <code class="literal">i18n</code> subdirectory in the plugin tree. If no translation is found, the plugin will be loaded with the default locale.</p><div class="note" title="Note"><h3 class="title"><a id="tip32"/>Tip</h3><p>We recommend that you always use English as the primary language of the plugin. Use it for all messages and captions on GUI widgets. As English is the most common and widely used language, the plugin can be used by almost all users, even without translations. If necessary, support for any other language can be added easily via the localization mechanism.</p></div><p>The next important, and mandatory, method that should be implemented in the plugin base class is <code class="literal">initGui()</code>. This method is called when the plugin is activated and loaded by QGIS. Here, we add the required GUI elements, such as menu items, toolbar buttons, and even dock widgets. We initialize all the necessary temporary folders and other stuff required by the plugin. In our demo plugin, this method starts from line <code class="literal">29</code>.</p><p>From lines <code class="literal">30</code> to <code class="literal">36</code>, we create a so-called action that will launch the plugin dialog. Actions are special objects that represent a command and provide a unified way to run that command from different places, such as menus and toolbars. First, we create a <code class="literal">QAction</code> instance and assign the <code class="literal">Select byRadius</code> label to it (lines <code class="literal">30</code> and <code class="literal">31</code>). Note that the label text is enclosed in the <code class="literal">self.tr()</code> method call. This method is implemented in the last two lines of the code snippet provided, and makes the text string translatable.</p><p>Then, in lines <code class="literal">32</code> and <code class="literal">33</code>, we construct an icon for our action. Using the <code class="literal">os.path.join()</code> call, we create a full path to the icon file located in the <code class="literal">icons</code> subdirectory of the plugin tree. This is the same icon that we specified in the <code class="literal">metadata.txt</code> file. Of course, you can use another icon—just put it into the <code class="literal">icons</code> subdirectory in the plugin tree. Next, in lines <code class="literal">34</code> and <code class="literal">35</code>, we set the tooltip text for our action. Note that we again use <code class="literal">self.tr()</code> here, so this text can also be localized. Finally, in line <code class="literal">36</code>, we set the <code class="literal">objectName</code> property of the action. This property is required by the QGIS customization framework.</p><p>From lines <code class="literal">38</code> to <code class="literal">42</code>, we create another action using the same approach as the preceding one. This action will be used to show the <span class="strong"><strong>About</strong></span> dialog with some information about our plugin. The icon for this action called <code class="literal">about.png</code>, and it is located in the <code class="literal">icons</code> subdirectory of the plugin tree.</p><p>Then, from lines <code class="literal">44</code> to <code class="literal">45</code> and <code class="literal">46</code> to <code class="literal">47</code>, we add our actions to the <span class="strong"><strong>Select by Radius</strong></span> submenu, which will be created in the QGIS <span class="strong"><strong>Vector</strong></span> menu. In line <code class="literal">48</code>, we put the button that opens the main plugin dialog into the <span class="strong"><strong>Vector</strong></span> toolbar.</p><p>The last two lines (<code class="literal">50</code> and <code class="literal">51</code>) in this method are used to connect actions to handlers, which will be<a id="id699" class="indexterm"/> executed when the user presses buttons or selects menu entries. For now, both handlers—<code class="literal">run()</code> and <code class="literal">about()</code>—are empty, and we will add code to them later.</p><p>The second mandatory method that should be present in the plugin base class is <code class="literal">unload()</code>. This method is executed when the plugin is deactivated and removed from QGIS. Here, we should remove all of the plugin's GUI elements (buttons, menu entries, widgets, and so on) and perform any other cleanup actions required, such as removing temporary files. In our demo plugin, this method is defined in line <code class="literal">53</code>.</p><p>As our plugin is simple enough, we just the remove menu entries added in the <code class="literal">initGui()</code> method (lines <code class="literal">54</code> to <code class="literal">57</code>), as well as the toolbar button (line <code class="literal">58</code>).</p><p>In lines <code class="literal">60</code> to <code class="literal">64</code>, we define handlers for our actions. Currently, they do nothing.</p><p>The last method, <code class="literal">tr()</code>, as we have already mentioned, is required for internationalization support. It takes English text and returns its translated equivalent, depending on the current locale and presence of the translation file.</p><div class="note" title="Note"><h3 class="title"><a id="note43"/>Note</h3><p>We implement the <code class="literal">tr()</code> method <a id="id700" class="indexterm"/>ourselves here because the main plugin class is a pure Python class. Almost all Qt GUI classes have built-in internationalization support, and this method is already present in their code. As a result, all classes inheriting from them also will have the <code class="literal">tr()</code> method, as you will see soon.</p></div><p>Now, our plugin directory's structure should look like this:</p><div class="mediaobject"><img src="../Images/image00519.jpeg" alt="Creating the plugin's skeleton"/></div><p style="clear:both; height: 1em;"> </p><p>Such a plugin skeleton can be used as the starting point for a wide range of plugins.</p><p>At this point, our plugin should be loadable by QGIS. You can easily check this—just copy the plugin directory to the QGIS plugins directory, <code class="literal">~/.qgis2/python/plugins</code>. Start QGIS and open <span class="strong"><strong>Plugin Manager</strong></span> by going to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Manage and install plugins…</strong></span>. You should see the <span class="strong"><strong>Select by Radius</strong></span> plugin in the <span class="strong"><strong>Installed</strong></span> tab. After activation, the plugin will be loaded, a new button will be placed on the <span class="strong"><strong>Vector</strong></span> toolbar, and a new entry with<a id="id701" class="indexterm"/> two items will appear in the <span class="strong"><strong>Vector</strong></span> menu. But at this stage, these items do nothing. We need to implement their functionality.</p></div>
<div class="section" title="Designing the plugin's GUI"><div class="titlepage" id="aid-2ACBS2"><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Designing the plugin's GUI</h1></div></div></div><p>Our plugin will<a id="id702" class="indexterm"/> have two dialogs: one is the main plugin dialog, which will be used to accept user input, and the second is the so-called About dialog, with some information about the plugin.</p><p>The Qt framework, on top of which QGIS is built, provides a special program for designing dialogs and other UI elements, such as dock widgets. It is called <span class="strong"><strong>Qt Designer</strong></span>. Qt Designer is a user-friendly and easy-to-use visual form designer. With its help, you can create a dialog without writing code, by placing GUI widgets on the form using your mouse. The form definition in XML format is then saved in a <code class="literal">.ui</code> file, which is used by the plugin or application to construct a user interface.</p><p>To keep the plugin's structure clean, we will put all the <code class="literal">.ui</code> files in a separate subdirectory, called <code class="literal">ui</code> for example, in the plugin source tree.</p><div class="section" title="Designing the About dialog"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec57"/>Designing the About dialog</h2></div></div></div><p>Start Qt Designer. In<a id="id703" class="indexterm"/> the <span class="strong"><strong>New form</strong></span> welcome dialog, select the template called <span class="strong"><strong>Dialog with Buttons Bottom</strong></span>, like this:</p><div class="mediaobject"><img src="../Images/image00520.jpeg" alt="Designing the About dialog"/></div><p style="clear:both; height: 1em;"> </p><p>If this dialog is not opened at Designer startup, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New...</strong></span> or use the <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>N</em></span> keyboard shortcut. A new empty Qt form will be created, with two buttons at the bottom.</p><p>First, we will create the <a id="id704" class="indexterm"/>About dialog. We want to display the following information in this dialog: the plugin name, icon, version number, and a short description, maybe with links to the plugin home page and/or bugtracker.</p><p>In the <span class="strong"><strong>Property editor</strong></span> panel (usually located in the top-right corner of the Designer window), find the <code class="literal">windowTitle</code> property and change it to something meaningful, for example, <code class="literal">About Select by Radius</code>. Go back to the form and select the button box. It should be marked with blue square markers now. Return to the <span class="strong"><strong>Property editor</strong></span>, find the <code class="literal">standardButtons</code> property and clear the checkboxes from all the variants except the <span class="strong"><strong>Close</strong></span> button. So now, our button box has only one button.</p><p>Now, in the <span class="strong"><strong>Widget Box</strong></span> panel (usually located to the left of the Designer window), find the <span class="strong"><strong>Label</strong></span> widget inside the <span class="strong"><strong>Display Widgets</strong></span> group and drag and drop it into the form. Keeping the newly added widget selected, go to <span class="strong"><strong>Property editor</strong></span> and set the <code class="literal">objectName</code> property to<a id="id705" class="indexterm"/> <code class="literal">lblLogo</code>. This widget will be used to display the plugin icon.</p><div class="note" title="Note"><h3 class="title"><a id="tip33"/>Tip</h3><p>The <code class="literal">objectName</code> property of widgets will be used in our code to access the corresponding widget. So, try to assign meaningful object names for all the widgets that you plan to access from code.</p></div><p>Similarly, add another <span class="strong"><strong>Label</strong></span> widget to the form and place it on the right side of the previously added widget. This time, however, don't change its <code class="literal">objectName</code> property. Instead, find the <code class="literal">text</code> property and press the button labeled <span class="strong"><strong>…</strong></span> on the right side of the edit field. A simple text editor will be opened, like this:</p><div class="mediaobject"><img src="../Images/image00521.jpeg" alt="Designing the About dialog"/></div><p style="clear:both; height: 1em;"> </p><p>Enter the plugin name and then change the font size to a larger value, for example, <code class="literal">16</code>. Make the font bold and align the text to the center. Close the editor by clicking on the <span class="strong"><strong>OK</strong></span> button. Also modify the <code class="literal">alignment</code> property to enable horizontal alignment by center.</p><p>Add a third label, which <a id="id706" class="indexterm"/>will be used to display the plugin version, to the form and change its <code class="literal">objectName</code> property to <code class="literal">lblVersion</code>. Modify the <code class="literal">alignment</code> property to enable horizontal alignment by center. Move this label so that it will be placed under the label with the plugin name. Finally, add the <span class="strong"><strong>TextBrowser</strong></span> widget to the form and place it under all the labels.</p><p>Qt uses a layout-based approach to manage widgets, so your form will always look consistent, regardless of the themes and fonts used. To enable layout in our form, we just have to select the form and click on the <span class="strong"><strong>Lay Out in a Grid</strong></span> button on toolbar, or select this item from the <span class="strong"><strong>Form</strong></span> menu.</p><div class="note" title="Note"><h3 class="title"><a id="note44"/>Note</h3><p>More information<a id="id707" class="indexterm"/> about the Qt layout system can be found in the Qt documentation at <a class="ulink" href="http://doc.qt.io/qt-4.8/layout.html">http://doc.qt.io/qt-4.8/layout.html</a>. If you want to create nice-looking dialogs, this is a must-read piece of information.</p></div><p>Now your form should look like what is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00522.jpeg" alt="Designing the About dialog"/></div><p style="clear:both; height: 1em;"> </p><p>If some widgets are<a id="id708" class="indexterm"/> in incorrect places, try to move them around and adjust their sizes. When you are satisfied with the dialog's look and feel, save it as <code class="literal">aboutdialogbase.ui</code> in the <code class="literal">ui</code> subdirectory in the plugin root directory.</p></div><div class="section" title="Designing the main plugin dialog"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec58"/>Designing the main plugin dialog</h2></div></div></div><p>Close the saved <span class="strong"><strong>About</strong></span> dialog <a id="id709" class="indexterm"/>and create a new empty form for the main plugin dialog using the same <span class="strong"><strong>Dialog with buttons bottom</strong></span> template. Change the dialog's <code class="literal">windowTitle</code> property to <code class="literal">Select by Radius</code> and adjust the button box by changing its <code class="literal">standardButtons</code> property so that it contains two buttons: <span class="strong"><strong>OK</strong></span> and <span class="strong"><strong>Close</strong></span>.</p><p>We need to specify a target layer from which we will select features. Add to the form a <span class="strong"><strong>Label</strong></span> widget from the <span class="strong"><strong>Display Widgets</strong></span> section of the <span class="strong"><strong>Widget Box</strong></span> panel, and change its <code class="literal">text</code> property to <code class="literal">Select features from</code>. Now it is necessary to provide a widget where the user can choose a layer that will be used. <span class="strong"><strong>Combo Box</strong></span> can be a good choice here but there is an even better solution. Starting from version 2.4, QGIS provides a set of custom widgets for Qt Designer. Among these widgets, there is a special combobox called <span class="strong"><strong>QgsMapLayerComboBox</strong></span>. It is designed to display a list of layers from the QGIS layers registry. This widget, as well as all other QGIS-related custom widgets, can be found in the <span class="strong"><strong>QGIS custom </strong></span><a id="id710" class="indexterm"/><span class="strong"><strong>widgets</strong></span> section of the <span class="strong"><strong>Widget Box</strong></span> panel.</p><div class="note" title="Note"><h3 class="title"><a id="note45"/>Note</h3><p>It is necessary to mention here that the QGIS custom widgets section may be not available in your system. If you cannot find it, ensure that you have installed all the QGIS-related packages (for example, the Debian package with custom widgets called <code class="literal">libqgis-customwidgets</code>).</p><p>Alternatively, you can use an ordinal combobox instead of <span class="strong"><strong>QgsMapLayerCombobox</strong></span>, but in this case, you will need to implement code to populate it with layer names as well as code to retrieve a layer by its name by yourself.</p></div><p>Drag a <span class="strong"><strong>QgsMapLayerComboBox</strong></span> combobox onto the form, place it on the right side of the previously added label, and change its <code class="literal">objectName</code> property to <code class="literal">cmbTargetLayer</code>. By default, <span class="strong"><strong>QgsMapLayerCombobox</strong></span> will display raster layers, vector layers with polygonal geometry type, and plugin layers. This is not suitable for us, as we need only vector layers. To change this behavior, find the <code class="literal">filters</code> property and clear the checkboxes from all variants except <span class="strong"><strong>PointLayer</strong></span>, <span class="strong"><strong>LineLayer</strong></span>, and <span class="strong"><strong>PolygonLayer</strong></span> (this also activates the <span class="strong"><strong>HasGeometry</strong></span> option automatically). Now, this combobox will show only vector layers with geometry types specified previously. Raster layers, plugin layers, and vector layers without geometry will be not displayed in it.</p><p>Also, we need to specify another layer—a reference layer. So, add another <span class="strong"><strong>Label</strong></span> widget to the form and change its <code class="literal">text</code> property to <code class="literal">Around reference features from</code>. Near this label, place the second <span class="strong"><strong>QgsMapLayerComboBox</strong></span> combobox and change its <code class="literal">objectName</code> property to <code class="literal">cmbReferenceLayer</code>. Apply the same filters to it that we used for the previously added <span class="strong"><strong>QgsMapLayerCombobox</strong></span> combobox.</p><p>Another input value we need is a search radius. So, put another <span class="strong"><strong>Label</strong></span> widget on the form, under the already added widgets. Set its <code class="literal">text</code> property to <code class="literal">Within search radius</code>. On the right side of this label, put <span class="strong"><strong>Double Spin Box</strong></span> (which can be found in the <span class="strong"><strong>Input Widgets</strong></span> section) and change its <code class="literal">objectName</code> property to <code class="literal">spnRadius</code>. Also adjust its <code class="literal">minimum</code>, <code class="literal">maximum</code>, and <code class="literal">value</code> properties to reasonable values.</p><p>To make the plugin more useful and flexible, we provide the user with a choice of how to use the selected features: create a new selection, or alter an existing selection. The more logical way to represent available choices is a combobox. Add another label from the <span class="strong"><strong>Display Widgets</strong></span> section to the form and change its <code class="literal">text</code> property to <code class="literal">Use the result to</code>. On the right side of this label, place <span class="strong"><strong>Combo Box</strong></span> (which can be found in the <span class="strong"><strong>Input Widgets</strong></span> section). Change the <code class="literal">objectName</code> property of the newly added combobox to <code class="literal">cmbSelectionMode</code>.</p><p>Put <span class="strong"><strong>Progress Bar</strong></span> (which can be found in the <span class="strong"><strong>Display Widgets</strong></span> section of the <span class="strong"><strong>Widget Box</strong></span> panel) under the last<a id="id711" class="indexterm"/> label and the combobox, and change its <code class="literal">value</code> property to <code class="literal">zero</code>.</p><p>Select the dialog and apply the grid layout to it by clicking on the <span class="strong"><strong>Lay Out in a Grid</strong></span> button in the <span class="strong"><strong>Designer</strong></span> toolbar. Now your form should look like what is shown in this screenshot:</p><div class="mediaobject"><img src="../Images/image00523.jpeg" alt="Designing the main plugin dialog"/></div><p style="clear:both; height: 1em;"> </p><p>If some widgets are in incorrect places, try to move them around and adjust their sizes. Once you are satisfied with dialog's look and feel, save it in the <code class="literal">ui</code> subdirectory in the plugin root directory as <code class="literal">selectradiusdialogbase.ui</code>.</p><p>As you can see, there is nothing complex in designing a user interface with the help of Qt Designer. The most important thing here is understanding how different types of layouts work and comply with the recommendations of the <span class="strong"><strong>Human</strong></span> <span class="strong"><strong>Interface</strong></span><a id="id712" class="indexterm"/> <span class="strong"><strong>Guidelines</strong></span> (<span class="strong"><strong>HIG</strong></span>) of the corresponding project. QGIS HIG can be found in the <code class="literal">CODING</code> document inside QGIS sources. You <a id="id713" class="indexterm"/>can view it online at <a class="ulink" href="https://github.com/qgis/QGIS/blob/master/CODING#L1429">https://github.com/qgis/QGIS/blob/master/CODING#L1429</a>.</p></div></div>
<div class="section" title="Using Designer UI files in the plugin"><div class="titlepage" id="aid-2BASE2"><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Using Designer UI files in the plugin</h1></div></div></div><p>Designing the GUI with the<a id="id714" class="indexterm"/> Qt Designer is the first part of the process. Now we need to use the previously created <code class="literal">.ui</code> files to construct our dialogs and implement the logic required for handling user actions, such as clicking on buttons, selecting items from lists, and so on.</p><div class="section" title="Adding the About dialog to the plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec59"/>Adding the About dialog to the plugin</h2></div></div></div><p>We will start from the<a id="id715" class="indexterm"/> About dialog, as it is simple. To keep the plugin directory structure clean, we will store all the sources related to the plugin GUI in the <code class="literal">gui</code> subdirectory inside the plugin directory.</p><p>Open your text editor and create a new file with the following content:</p><div class="informalexample"><pre class="programlisting">( 1) import os
( 2) import ConfigParser
( 3)
( 4) from PyQt4 import uic
( 5) from PyQt4.QtCore import QUrl
( 6) from PyQt4.QtGui import QTextDocument, QDialogButtonBox, QPixmap
( 7)
( 8) pluginPath = os.path.split(os.path.dirname(__file__))[0]
( 9) WIDGET, BASE = uic.loadUiType(
(10)    os.path.join(pluginPath, 'ui', 'aboutdialogbase.ui'))
(11)
(12)
(13) class AboutDialog(BASE, WIDGET):
(14)    def __init__(self, parent=None):
(15)        super(AboutDialog, self).__init__(parent)
(16)        self.setupUi(self)
(17)
(18)        cfg = ConfigParser.SafeConfigParser()
(19)        cfg.read(os.path.join(pluginPath, 'metadata.txt'))
(20)        version = cfg.get('general', 'version')
(21)
(22)        self.lblLogo.setPixmap(
(23)            QPixmap(os.path.join(pluginPath, 'icons', 'selectradius.svg')))
(24)        self.lblVersion.setText(self.tr('Version: %s') % version)
(25)
(26)        doc = QTextDocument()
(27)        doc.setHtml(self.getAboutText())
(28)        self.textBrowser.setDocument(doc)
(29)        self.textBrowser.setOpenExternalLinks(True)
(30)
(31)    def getAboutText(self):
(32)        return self.tr(
(33)            '&lt;p&gt;Select features of the specified vector layer within given '
(34)            'radius around pre-selected reference features from the another '
(35)            'vector layer.&lt;/p&gt;'
(36)            '&lt;p&gt;Developed as demo plugin for the "QGIS By Example" book by '
(37)            '&lt;a href="https://www.packtpub.com/"&gt;Packt Publishing&lt;/a&gt;.&lt;/p&gt;')</pre></div><p>Save this file in the <code class="literal">gui</code> subdirectory as <code class="literal">aboutdialog.py</code>.</p><p>At the very beginning<a id="id716" class="indexterm"/> of the file, from lines <code class="literal">1</code> to <code class="literal">6</code>, we import all the packages and classes that we will use later. Here, we use the Python standard library (the <code class="literal">os</code> and <code class="literal">ConfigParser</code> packages) as well as various <code class="literal">PyQt</code> classes (lines <code class="literal">4</code> to <code class="literal">6</code>).</p><p>In line <code class="literal">8</code>, we determine the plugin path, as we need it in order to construct full paths to the dialog's <code class="literal">.ui</code> file and plugin icon.</p><p>The most interesting part is lines <code class="literal">9</code> and <code class="literal">10</code>, which are actually a single command split into two lines due to its length. Here, we load our previously created <code class="literal">.ui</code> file in the Qt Designer. The <code class="literal">uic.loadUiType()</code> command returns two values: our custom dialog (stored as a <code class="literal">WIDGET</code> variable) and its base class (stored as a <code class="literal">BASE</code> variable). Using <code class="literal">uic</code> allows us to avoid compilation of UI files and makes plugin packaging simpler.</p><p>In line <code class="literal">13</code>, an implementation of the <code class="literal">AboutDialog</code> class, which will represent our About dialog, starts. Note that in the class definition, we use the <code class="literal">BASE</code> and <code class="literal">WIDGET</code> variables obtained previously from the <code class="literal">uic.loadUiType()</code> call.</p><p>The <code class="literal">__init__()</code> method, also called a constructor, performs a basic class initialization. In lines <code class="literal">15</code> and <code class="literal">16</code>, we set up a dialog GUI. After these lines, we can access all dialog widgets using <code class="literal">self.widgetName</code>, where <code class="literal">widgetName</code> is the value of the <code class="literal">objectName</code> property of the corresponding widget. That's why it is important to specify meaningful and unique object names to all widgets that will be used in code.</p><p>From lines <code class="literal">18</code> to <code class="literal">20</code>, we use the <a id="id717" class="indexterm"/><span class="strong"><strong>ConfigParser</strong></span> module from the Python standard library to read the plugin version from the <code class="literal">metadata.txt</code> file. Of course, we can enter the version number manually, but in this case, every time the plugin version changes, we will need to edit two files (<code class="literal">metadata.txt</code> and <code class="literal">aboutdialog.py</code>) instead of one.</p><p>Then, in lines <code class="literal">22</code> and <code class="literal">23</code>, the plugin icon is constructed from the path to the icon file and then loaded into the corresponding dialog widget. In line <code class="literal">24</code>, the plugin version is displayed in the <code class="literal">lblVersion</code> label widget.</p><p>Finally, in lines <code class="literal">26</code> to <code class="literal">29</code>, we instantiate the <code class="literal">QTextDocument</code> object, which will be used to display the About text, and assign it to the <a id="id718" class="indexterm"/><span class="strong"><strong>QTextBrowser</strong></span> widget. Line <code class="literal">29</code> allows the user to open links by clicking on them.</p><p>Text for the About<a id="id719" class="indexterm"/> dialog is generated by the <code class="literal">getAboutText()</code> method, implemented in lines <code class="literal">31</code> to <code class="literal">37</code>. The implementation is simple—we just return a string containing a short description of the plugin in HTML format. The only important thing here is the usage of <code class="literal">self.tr()</code> method, which allows us to show translated About text.</p><div class="note" title="Note"><h3 class="title"><a id="tip34"/>Tip</h3><p>For more information about <a id="id720" class="indexterm"/>Qt classes, their purpose, and their functionality, check out the Qt documentation at <a class="ulink" href="http://doc.qt.io/qt-4.8/index.html">http://doc.qt.io/qt-4.8/index.html</a>.</p></div><p>You may ask why we don't implement any methods to handle dialog execution and closing. Well, as this is a very simple dialog, we don't need to perform any special actions. We can use default handlers, which are implemented in the base <code class="literal">QDialog</code> class. This means that the dialog will be opened as modal, and clicking on the <span class="strong"><strong>Close</strong></span> button will close it.</p><p>That's all! Now we need to add this dialog to the plugin main class. First, it is necessary to create an empty <code class="literal">__init__.py</code> file in the <code class="literal">gui</code> subdirectory so that Python will recognize it as a package directory.</p><p>Now, open the <code class="literal">selectradius_plugin.py</code> file. In the import section at the beginning of the file, add this line of code:</p><div class="informalexample"><pre class="programlisting">from selectradius.gui.aboutdialog import AboutDialog</pre></div><p>This line makes the <code class="literal">AboutDialog</code> class accessible from the main plugin class. Now, find the <code class="literal">about()</code> method and modify it as follows:</p><div class="informalexample"><pre class="programlisting">(1)    def about(self):
(2)        d = AboutDialog()
(3)        d.exec_()</pre></div><p>There is nothing special here. First, we instantiate <code class="literal">AboutDialog</code> and then execute it. Save your edits. If you want, you can update the plugin files in the QGIS plugins directory or copy the entire plugin directory here. Reload the plugin with <span class="strong"><strong>Plugin Reloader</strong></span> and make sure that, now, when you select the <span class="strong"><strong>About</strong></span> item from the <span class="strong"><strong>Select by Radius</strong></span> menu, an <span class="strong"><strong>About</strong></span> dialog is shown.</p></div><div class="section" title="Adding the main plugin dialog"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec60"/>Adding the main plugin dialog</h2></div></div></div><p>Now, let's implement<a id="id721" class="indexterm"/> the main plugin dialog. Create a new file and save it in the <code class="literal">gui</code> subdirectory of the plugin directory as <code class="literal">selectradiusdialog.py</code>. As this dialog is more complex, we split its code into small pieces, and we will examine them one by one.</p><p>As you should already know, we first import all the necessary classes:</p><div class="informalexample"><pre class="programlisting">(1) import os
(2)
(3) from PyQt4 import uic
(4) from PyQt4.QtCore import QSettings
(5) from PyQt4.QtGui import QDialogButtonBox, QDialog
(6)
(7) from qgis.core import QgsGeometry, QgsFeatureRequest, QgsSpatialIndex
(8) from qgis.gui import QgsMessageBar</pre></div><p>Besides packages from the Python standard library and PyQt classes, we also import several classes from the <code class="literal">qgis.core</code> and <code class="literal">qgis.gui</code> libraries.</p><p>Then, as in the case of <code class="literal">AboutDialog</code>, we determine the plugin path and load the dialog GUI from the Qt Designer file:</p><div class="informalexample"><pre class="programlisting">(1) pluginPath = os.path.split(os.path.dirname(__file__))[0]
(2) WIDGET, BASE = uic.loadUiType(
(3)    os.path.join(pluginPath, 'ui', 'selectradiusdialogbase.ui'))</pre></div><p>The preparation is complete. Now we can define the main dialog class:</p><div class="informalexample"><pre class="programlisting">( 1) class SelectRadiusDialog(BASE, WIDGET):
( 2)    def __init__(self, iface, parent=None):
( 3)        super(SelectRadiusDialog, self).__init__(parent)
( 4)        self.setupUi(self)
( 5)
( 6)        self.iface = iface
( 7)
( 8)        self.btnOk = self.buttonBox.button(QDialogButtonBox.Ok)
( 9)        self.btnClose = self.buttonBox.button(QDialogButtonBox.Close)
(10)
(11)        self.cmbSelectionMode.clear()
(12)        self.cmbSelectionMode.addItem(self.tr('Create new selection'))
(13)        self.cmbSelectionMode.addItem(self.tr('Add to current selection'))
(14)        self.cmbSelectionMode.addItem(self.tr('Remove from current selection'))
(15)
(16)        self.loadSettings()</pre></div><p>First, we initialize the dialog GUI (lines <code class="literal">3</code> to <code class="literal">4</code>). In line <code class="literal">6</code>, we store a reference to the QGIS interface for further usage.</p><p>In lines <code class="literal">8</code> and <code class="literal">9</code>, we get<a id="id722" class="indexterm"/> references to separate buttons of the dialog's button box, as we will later need to access them as individual widgets. From lines <code class="literal">11</code> to <code class="literal">14</code>, the <code class="literal">cmbSelectionMode</code> combobox is populated with the available selection modes. To keep the item text translatable, we wrap it into the <code class="literal">self.tr()</code> calls. It is worth mentioning that combobox items have zero-based numeration, so the first item will have index 0, the second item will have index 1, and so on. Populating the combobox from code allows us to easily check the order of items and determine their indices. Item indices will be used later to determine user choices.</p><p>Finally, in line <code class="literal">16</code>, we restore the plugin's settings from the previous run.</p><p>Our plugin is simple enough, so there are only a few values that we want to save in the settings and restore. Every time a user opens the plugin dialog, we want to restore the previously entered search radius value and the last used selection mode from the <span class="strong"><strong>Use the result to</strong></span> combobox:</p><div class="informalexample"><pre class="programlisting">( 1)    def loadSettings(self):
( 2)        settings = QSettings('PacktPub', 'SelectRadius')
( 3)
( 4)        self.spnRadius.setValue(settings.value('radius', 1, float))
( 5)        self.cmbSelectionMode.setCurrentIndex(
( 6)            settings.value('selectionMode', 0, int))
( 7)
( 8)    def saveSettings(self):
( 9)        settings = QSettings('PacktPub', 'SelectRadius')
(10)
(11)        settings.setValue('radius', self.spnRadius.value())
(12)        settings.setValue(
(13)            'selectionMode', self.cmbSelectionMode.currentIndex())</pre></div><p>The <code class="literal">loadSettings()</code> method is <a id="id723" class="indexterm"/>called when we want to restore the plugin's settings. On the first run of the plugin, we have no saved settings, so the default values will be picked up. The <code class="literal">saveSettings()</code> method is<a id="id724" class="indexterm"/> used to save the current values from the widgets to the plugin settings.</p><p>Since we want to save<a id="id725" class="indexterm"/> the settings when the user closes the main plugin dialog by clicking on the <span class="strong"><strong>Close</strong></span> button, and we need to start the data acquisition process when the user clicks on the <span class="strong"><strong>OK</strong></span> button, it is necessary to replace the default handlers for these signals. The corresponding code is shown here:</p><div class="informalexample"><pre class="programlisting">( 1)    def reject(self):
( 2)        self.saveSettings()
( 3)        QDialog.reject(self)
( 4)
( 5)    def accept(self):
( 6)        self.saveSettings()
( 7)
( 8)        targetLayer = self.cmbTargetLayer.currentLayer()
( 9)        if targetLayer is None:
(10)            self.showMessage(
(11)              self.tr('Target layer is not set. '
(12)                    'Please specify layer and try again,'),
(13)              QgsMessageBar.WARNING)
(14)            return
(15)
(16)        referenceLayer = self.cmbReferenceLayer.currentLayer()
(17)        if referenceLayer is None:
(18)            self.showMessage(
(19)              self.tr('Reference layer is not set. '
(20)                    'Please specify layer and try again.'),
(21)              QgsMessageBar.WARNING)
(22)            return
(23)
(24)        referenceFeatures = referenceLayer.selectedFeatures()
(25)        if len(referenceFeatures) == 0:
(26)            self.showMessage(
(27)              self.tr('There are no reference features selected in the '
(28)                    'reference layer. Select at least one feature and '
(29)                    'try again.'),
(30)              QgsMessageBar.WARNING)
(31)            return</pre></div><p>The <code class="literal">reject()</code> method (line <code class="literal">1</code>) is called when the user clicks on the <span class="strong"><strong>Close</strong></span> button. This method was initially implemented in the base <code class="literal">QDialog</code> class, and we reimplement it in our subclass. The only thing we do here is save the current plugin settings (line <code class="literal">2</code>). After that, we simply call the <code class="literal">reject()</code> method of the base class (line 3) to close our dialog.</p><p>The <code class="literal">accept()</code> method, defined in line <code class="literal">5</code>, is called when the user clicks on the <span class="strong"><strong>OK</strong></span> button. This method is also initially implemented in the base <code class="literal">QDialog</code> class and reimplemented in our subclass. When the user clicks on the <span class="strong"><strong>OK</strong></span> button, the plugin should check whether all the<a id="id726" class="indexterm"/> required parameters are specified, find all the features from the target layer that match the defined requirements, and finally, update the selection in the target layer.</p><p>First, in line <code class="literal">6</code>, we save the current plugin settings. Then, we check whether the user has selected all the necessary inputs. In line <code class="literal">8</code>, we use the<a id="id727" class="indexterm"/> <code class="literal">currentLayer()</code> method of <code class="literal">QgsMapLayerCombobox</code> to obtain the currently selected target layer. This method returns the corresponding <code class="literal">QgsMapLayer</code> instance if a layer is selected, otherwise it returns <code class="literal">None</code>.</p><div class="note" title="Note"><h3 class="title"><a id="tip35"/>Tip</h3><p>The documentation about the <a id="id728" class="indexterm"/>QGIS API can be found at <a class="ulink" href="http://qgis.org/api/">http://qgis.org/api/</a>. Also, don't forget <span class="emphasis"><em>PyQGIS Developer Cookbook</em></span>, which contains detailed explanations<a id="id729" class="indexterm"/> on different topics and many useful examples. You always can read the latest <span class="emphasis"><em>PyQGIS cookbook</em></span> online at <a class="ulink" href="http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/index.html">http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/index.html</a>.</p></div><div class="note" title="Note"><h3 class="title"><a id="note46"/>Note</h3><p>Note that some samples from the latest version of the PyQGIS cookbook may not work with older QGIS versions due to API changes.</p></div><p>If no target layer is selected (this is checked in line <code class="literal">9</code>), we show a warning message with the <code class="literal">showMessage()</code> method (lines <code class="literal">10</code> to <code class="literal">13</code>) and return to the main plugin dialog (line <code class="literal">14</code>). In other words, we don't try to perform any further actions, as we have incomplete or invalid input. The user should specify the correct input and then try again.</p><p>Using the same approach, we check whether a valid reference layer is selected (lines <code class="literal">16</code> to <code class="literal">22</code>).</p><p>In line <code class="literal">24</code>, we obtain a list of preselected reference features from the reference layer. If no reference features are selected in the reference layer, the length of this list will be zero. We need to catch this situation because without reference features, we cannot continue. This is what happens in lines <code class="literal">25</code> to <code class="literal">31</code>; if there are no reference features selected in the reference layer, we show the corresponding message and return to the main plugin dialog.</p><p>For now, this is all of the code we need to write for the <code class="literal">accept()</code> method.</p><p>You may have already noticed the <code class="literal">showMessage()</code> method widely used in the preceding code. Here is its implementation:</p><div class="informalexample"><pre class="programlisting">(1)    def showMessage(self, message, level=QgsMessageBar.INFO):
(2)        self.iface.messageBar().pushMessage(
(3)            message, level, self.iface.messageTimeout())</pre></div><p>This is just a wrapper that displays a message bar with the given text and importance level using the same timeout as defined in the global QGIS settings. By default, the <code class="literal">INFO</code> level will be used, but if necessary, we can specify any other supported level.</p><p>As you can see, we have implemented only the basic functionality of the main plugin dialog as of now.</p><p>Now, we need to add the<a id="id730" class="indexterm"/> main dialog to the plugin base class. To do this, open the <code class="literal">selectradius_plugin.py</code> file, if it is not opened already. In the import section at the beginning of the file, add the following line of code:</p><div class="informalexample"><pre class="programlisting">from selectradius.gui.selectradiusdialog import SelectRadiusDialog</pre></div><p>This line makes the <code class="literal">SelectRadiusDialog</code> class accessible from the main plugin class. Now, find the <code class="literal">run()</code> method and modify it as follows:</p><div class="informalexample"><pre class="programlisting">(1)    def run(self):
(2)        dlg = SelectRadiusDialog(self.iface)
(3)        dlg.exec_()</pre></div><p>Again, there is nothing special here. First, we instantiate <code class="literal">SelectRadiusDialog</code> and then open it as a modal dialog, as we did earlier for the About dialog.</p><p>Save your edits. If you want, you can update the plugin files in the QGIS plugins directory or copy the entire plugin directory here. Reload the plugin with <span class="strong"><strong>Plugin Reloader</strong></span> and make sure that, now, when you select the <span class="strong"><strong>Select by Radius</strong></span> item from the <span class="strong"><strong>Select by Radius</strong></span> menu, a main plugin dialog is shown.</p></div></div>
<div class="section" title="Implementing feature selection"><div class="titlepage" id="aid-2C9D02"><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Implementing feature selection</h1></div></div></div><p>Now, when dialogs <a id="id731" class="indexterm"/>are created and connected to our plugin, we can start implementing the main functionality—namely, feature selection using requirements defined by the user.</p><p>Open the <code class="literal">selectradiusdialog.py</code> file located in the <code class="literal">gui</code> subdirectory of the plugin source tree. Add the following code at the end of the <code class="literal">accept()</code> method:</p><div class="informalexample"><pre class="programlisting">( 1)        self.btnOk.setEnabled(False)
( 2)        self.btnClose.setEnabled(False)
( 3)
( 4)        request = QgsFeatureRequest()
( 5)        request.setFlags(
( 6)           request.flags() ^ QgsFeatureRequest.SubsetOfAttributes)
( 7)
( 8)        index = QgsSpatialIndex(targetLayer.getFeatures(request))
( 9)
(10)        selection = []
(11)        for f in referenceFeatures:
(12)            geom = QgsGeometry(f.geometry())
(13)            bufferedGeometry = geom.buffer(self.spnRadius.value(), 5)
(14)
(15)            intersectedIds = index.intersects(bufferedGeometry.boundingBox())
(16)
(17)           self.progressBar.setRange(0, len(intersectedIds))
(18)
(19)           for i in intersectedIds:
(20)              ft = targetLayer.getFeatures(request.setFilterFid(i)).next()
(21)              geom = ft.geometry()
(22)              if geom.within(bufferedGeometry):
(23)                  selection.append(i)
(24)
(25)              self.progressBar.setValue(self.progressBar.value() + 1)
(26)
(27)        if self.cmbSelectionMode.currentIndex() == 1:
(28)            selection = list(
(29)              set(targetLayer.selectedFeaturesIds()).union(selection))
(30)        elif self.cmbSelectionMode.currentIndex() == 2:
(31)            selection = list(
(32)              set(targetLayer.selectedFeaturesIds()).difference(selection))
(33)        targetLayer.setSelectedFeatures(selection)
(34)
(35)        self.progressBar.reset()
(36)        self.btnOk.setEnabled(True)
(37)        self.btnClose.setEnabled(True)
(38)        self.showMessage(self.tr('Completed.'), QgsMessageBar.SUCCESS)</pre></div><p>At this moment, we have already ensured that all the necessary input fields are defined correctly (see the previous section), and now we can safely proceed with feature selection.</p><p>First, it is necessary<a id="id732" class="indexterm"/> to block the <span class="strong"><strong>OK</strong></span> and <span class="strong"><strong>Close</strong></span> buttons to prevent accidental clicks on them, which may interrupt running processes. We do this in lines <code class="literal">1</code> and <code class="literal">2</code>.</p><p>Our plugin will need to request features from vector layers. As you know, every feature has geometry and attributes and, by default, both the geometry and attributes are returned when we query a feature from a layer. For our purposes, we need only feature geometry, so it will be better not to query attributes. This will speed up the process of feature retrieval, especially if the layer has a large attribute table or is accessed via a slow network connection.</p><p>So, in line <code class="literal">4</code>, we instantiate the <code class="literal">QgsFeatureRequest</code> object, which is used to customize the process of feature retrieval. From lines <code class="literal">5</code> to <code class="literal">6</code>, we alter its default behavior (fetch geometry and attributes) by resetting its <code class="literal">SubsetOfAttributes</code> flag so that only the feature geometry will be fetched.</p><p>Then, we build a spatial index for the target layer (line <code class="literal">8</code>). A spatial index allows us to perform quick queries on the layer and fetch only features that intersect some region or are located close to the given coordinates. A spatial index also reduces processing time by limiting the number of features we should test against our spatial operator.</p><p>Now we are ready to search for features in the target layer that are located completely within the given radius around the reference features. But first, we need to create a list where we will store the identifiers of such features. This is done in line <code class="literal">10</code>.</p><p>In line <code class="literal">11</code>, we start a loop over the reference features (we already have them in the <code class="literal">referenceFeatures</code> list; see the previous section for details). For each reference feature, we get its geometry (line <code class="literal">12</code>) and create a buffer around it using the given radius (line <code class="literal">13</code>). As the buffer distance, we use a user-defined search radius set with the <code class="literal">spnRadius</code> spinbox. The second parameter in the <code class="literal">buffer()</code> call is the number of segments used to approximate curves. Bigger values will result in smoother curves and more accurate results, but will also increase processing time a bit. Feel free to change this value if you want.</p><p>Then, in line <code class="literal">15</code>, with the help of the spatial index, we determine which features from the target layer may be located within the buffered geometry, which represents the current reference feature. The <code class="literal">intersects()</code> method returns the identifiers of all features that intersect the bounding box of the given geometry. In our case, this is the current reference geometry.</p><p>In line <code class="literal">17</code>, we update the range for the progress bar. It will be used to give visual feedback about the execution of the process.</p><p>As the spatial index performs the intersection test with the bounding box, we should now test each matched feature precisely. This is done from lines <code class="literal">19</code> to <code class="literal">25</code>. Let's take a closer look. In line <code class="literal">19</code>, a loop starts through the matched feature indices. In the loop, we fetch<a id="id733" class="indexterm"/> a feature by its identifier (line <code class="literal">20</code>). Note that we again use the previously created <code class="literal">request</code> to fetch only the feature geometry. Then, the feature geometry is extracted (line <code class="literal">21</code>), and we check whether this geometry is located completely within the buffered reference geometry (line <code class="literal">22</code>). If this condition is met, the feature identifier is added to the list (line <code class="literal">23</code>).</p><div class="note" title="Note"><h3 class="title"><a id="note47"/>Note</h3><p>If you want to select features using some other criteria (for example, select features that intersect the reference geometry), replace the <code class="literal">within()</code> operator with the desired operator. A list of available operators can be found in the API documentation of the<a id="id734" class="indexterm"/> <code class="literal">QgsGeometry</code> class at <a class="ulink" href="http://qgis.org/api/classQgsGeometry.html">http://qgis.org/api/classQgsGeometry.html</a>.</p></div><p>Finally, in line <code class="literal">25</code>, we update the progress bar to inform the user about the progress.</p><p>When all the reference features are processed and the identifiers of the matched features are stored in the <code class="literal">selection</code> list, we can select features in the target layer according to the requested selection mode (lines <code class="literal">27</code> to <code class="literal">33</code>). First, we determine which selection mode we need to use using the conditions in line <code class="literal">27</code> and line <code class="literal">30</code>. As the selection modes are added to the corresponding combobox consequentially (one by one), the first added item (<span class="strong"><strong>Create new selection</strong></span>) will have index <code class="literal">0</code>, the second item (<span class="strong"><strong>Add to current selection</strong></span>) will have index 1, and so on. So, if the index of the currently selected item of the <code class="literal">cmbSelectionMode</code> combobox is equal to 1, then the user is asked to add features to the current selection. This means that combobox indexes match the order in which the items are added.</p><p>When the selection mode is determined, we modify the list of selected features by adding or removing indices of the already selected features (lines <code class="literal">28</code> to <code class="literal">29</code> and <code class="literal">31</code> to <code class="literal">32</code>). Finally, in line <code class="literal">33</code>, we select features in the target layer.</p><p>We are almost done; now it is necessary to perform some final actions. In line <code class="literal">35</code>, we reset the progress bar so that it rewinds and does not show any progress. Then, we enable the <span class="strong"><strong>OK</strong></span> and <span class="strong"><strong>Close</strong></span> buttons so that the user can change the parameters and run the process again, or close the plugin dialog. In line <code class="literal">38</code>, we inform the user that the operation is complete.</p><p>If you've made all the edits correctly, your plugin should now be fully functional and ready for testing. Just update<a id="id735" class="indexterm"/> the plugin files in the QGIS plugins directory by copying the content of your working directory, reload the plugin with <span class="strong"><strong>Plugin Reloader</strong></span>, and test it. If there are any errors, check your code again or look at the complete plugin code shipped with this book.</p></div>
<div class="section" title="Adding translations" id="aid-2D7TI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Adding translations</h1></div></div></div><p>If you followed our<a id="id736" class="indexterm"/> recommendations and used the English language for all captions in the plugin GUI, and in all strings in the code, almost all users will be able to use your plugin. Moreover, as we have made all strings translatable by enclosing them in <code class="literal">self.tr()</code> calls, it is very easy to translate our plugin into another language.</p><p>To do this, we need to prepare a so-called<a id="id737" class="indexterm"/> <span class="strong"><strong>project file</strong></span>. This is a plain text file with a very simple structure. Create a new file and save it as <code class="literal">selectradius.pro</code> in the plugin root directory. Then, add the following content to it:</p><div class="informalexample"><pre class="programlisting">( 1) SOURCES = __init__.py \
( 2)          selectradius_plugin.py \
( 3)          gui/selectradiusdialog.py \
( 4)          gui/aboutdialog.py \
( 5)
( 6) FORMS = ui/selectradiusdialogbase.ui \
( 7)        ui/aboutdialogbase.ui
( 8)
( 9) TRANSLATIONS = i18n/selectradius_uk.ts \
(10)              i18n/selectradius_de.ts</pre></div><p>As you can see, there is a list of all plugin source files from all subdirectories (lines <code class="literal">1</code> to <code class="literal">4</code>), as well as a list of all Qt Designer UI files (lines <code class="literal">6</code> to <code class="literal">7</code>). Finally, in lines <code class="literal">9</code> to <code class="literal">10</code>, there is a list of translation files that will be generated (in this example, we have Ukrainian and German).</p><p>From the preceding code, you can see that we will keep translations in the <code class="literal">i18n</code> subdirectory, so create it if it does not exist yet.</p><p>Now open the command-line window (OSGeo shell in the case of Windows), use <code class="literal">cd</code> to change to the plugin directory and run this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pylupdate4 -verbose selectradius.pro</strong></span>
</pre></div><p>This will generate the <code class="literal">.ts</code> files required for each language specified in the project file. These files contain all the translatable strings from the plugin source code and UI forms. Using Qt Linguist, the <code class="literal">.ts</code> files are translated and "released." By "releasing" in this case, we mean converting a <code class="literal">.ts</code> file into a binary <code class="literal">.qm</code> file, which can be used by the Qt translation system.</p><p>It is necessary to <a id="id738" class="indexterm"/>mention that after altering strings or adding new files (sources or UI), it is a must to update the project file and regenerate the translations. Don't worry about already translated strings; they will be kept, and you will need to translate only new or modified strings.</p></div>
<div class="section" title="Preparing the plugin for publishing" id="aid-2E6E41"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Preparing the plugin for publishing</h1></div></div></div><p>Once the plugin is ready and <a id="id739" class="indexterm"/>well-tested, you may want to share it with the community by uploading it to the Official QGIS Python plugins<a id="id740" class="indexterm"/> repository at <a class="ulink" href="https://plugins.qgis.org/">https://plugins.qgis.org/</a>.</p><p>First, it is necessary to check whether the plugin meets the following requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">There is no malicious code in it</li><li class="listitem">There are no architecture-dependent binaries</li><li class="listitem">It has the correct <code class="literal">metadata.txt</code> file with all the required items</li></ul></div><p>We have listed the most important requirements here. Other recommendations can be found at the plugins repository page and in the <span class="emphasis"><em>Releasing your plugin</em></span> chapter of <span class="emphasis"><em>PyQGIS Developer Cookbook</em></span>.</p><p>The next step is to prepare the plugin package. QGIS plugins are distributed in the form of ZIP archives, and each archive contains only one plugin. As plugins are extracted to the QGIS plugins directory, we must ensure that the plugin has its own folder inside the package.</p><p>Also, it is good practice to include only files that are absolutely required by the plugin in the plugin package, and omit any generated or helper files. As we load the UI files and icons dynamically, the only helper files we have are the project file and the <code class="literal">.ts</code> files (the <code class="literal">.qm</code> files should also be included because they are used by the Qt translation system). So, the content of our plugin package will look like this:</p><div class="mediaobject"><img src="../Images/image00524.jpeg" alt="Preparing the plugin for publishing"/></div><p style="clear:both; height: 1em;"> </p><p>When the plugin package<a id="id741" class="indexterm"/> is created, just log in to the QGIS plugins site <a id="id742" class="indexterm"/>using your OSGeo ID. In the top menu, select <span class="strong"><strong>Plugins</strong></span>. Then, on the left side of the page, click on the <span class="strong"><strong>Share a plugin</strong></span> button and upload your plugin package.</p><div class="note" title="Note"><h3 class="title"><a id="tip36"/>Tip</h3><p>If you need to <a id="id743" class="indexterm"/>create an OSGeo ID, go to the OSGeo portal at <a class="ulink" href="http://www.osgeo.org/osgeo_userid">http://www.osgeo.org/osgeo_userid</a>.</p></div><p>That's all! Now your plugin is available for all QGIS users. Don't forget to create a bugtracker and home page with documentation about your plugin so that users can send reports about bugs and feature requests.</p></div>
<div class="section" title="Summary" id="aid-2F4UM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec77"/>Summary</h1></div></div></div><p>In this chapter, you learned how to develop QGIS plugins using the Python programming language. Python plugins allow us to extend the QGIS functionality by adding new tools or implementing new analyses or geoprocessing algorithms. You became familiar with the plugin architecture and their main components. Then we created the plugin skeleton, which can be used by many plugins. You learned how to create dialogs with the Qt Designer and use them in plugin. Finally, we developed a simple plugin for selecting features of the specified vector layer that are located within the given radius around reference preselected features of any other layer.</p></div></body></html>