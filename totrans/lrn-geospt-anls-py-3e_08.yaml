- en: Python and Remote Sensing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python和遥感
- en: In this chapter, we will discuss remote sensing. Remote sensing is about gathering
    a collection of information about the Earth without making physical contact with
    it. Typically, this means having to use satellite or aerial imagery, **Light Detection
    and Ranging** (**LIDAR**), which measures laser pulses from an aircraft to the
    Earth, or synthetic aperture radar. Remote sensing can also refer to processing
    data that's been collected, which is how we'll use the term in this chapter. Remote
    sensing grows in a more exciting way every day as more satellites are launched
    and the distribution of data becomes easier. The high availability of satellite
    and aerial images, as well as interesting new types of sensors launching each
    year, is changing the role that remote sensing plays in understanding our world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论遥感。遥感是关于收集关于地球的信息集合，而不需要与它进行物理接触。通常这意味着需要使用卫星或航空图像、**光探测与测距**（**LIDAR**），它测量飞机到地球的激光脉冲，或者合成孔径雷达。遥感也可以指处理收集到的数据，这就是我们在本章中使用该术语的方式。随着更多卫星的发射和数据分布变得更加容易，遥感正以越来越令人兴奋的方式发展。卫星和航空图像的高可用性，以及每年发射的有趣新型传感器，正在改变遥感在理解我们世界中所扮演的角色。
- en: In remote sensing, we step through each pixel in an image and perform some form
    of query or mathematical process. An image can be thought of as a large numerical
    array. In remote sensing, these arrays can be quite large, in the order of tens
    of megabytes to several gigabytes in size. While Python is fast, only C-based
    libraries can provide the speed that's needed to loop through arrays at a tolerable
    speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在遥感领域，我们逐个遍历图像中的每个像素，并执行某种形式的查询或数学过程。可以将图像视为一个大型数值数组。在遥感中，这些数组可以相当大，大小从数十兆字节到数吉字节不等。虽然Python运行速度快，但只有基于C的库才能提供在可接受速度下遍历数组的速度。
- en: We'll use the **Python Imaging Library** (**PIL**) for image processing and
    NumPy, which provides multidimensional array mathematics. While written in C for
    speed, these libraries are designed for Python and provide a Pythonic API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Python图像库**（**PIL**）进行图像处理，以及NumPy，它提供多维数组数学。虽然这些库是用C编写的以提高速度，但它们是为Python设计的，并提供Pythonic
    API。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Swapping image bands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换图像波段
- en: Creating image histograms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图像直方图
- en: Performing a histogram stretch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行直方图拉伸
- en: Clipping and classifying images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪辑和分类图像
- en: Extracting features from images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图像中提取特征
- en: Change detection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化检测
- en: First, we'll start with basic image manipulation and then build on each exercise,
    all the way to automatic change detection. These techniques will compliment the
    previous chapters by adding the ability to process satellite data and other remote
    sensing products to our toolbox.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从基本的图像处理开始，然后在此基础上逐步构建，直至自动变化检测。这些技术将通过添加处理卫星数据和其他遥感产品到我们的工具箱中，来补充前面的章节。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Python 3.6 or higher
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6或更高版本
- en: 'RAM: Minimum 6 GB (Windows), 8 GB (macOS), recommended 8 GB'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存：最低6 GB（Windows），8 GB（macOS），推荐8 GB
- en: 'Storage: Minimum 7200 RPM SATA with 20 GB of available space; recommended SSD
    with 40 GB of available space'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储：最低7200 RPM SATA，可用空间20 GB；推荐SSD，可用空间40 GB
- en: 'Processor: Minimum Intel Core i3 2.5 GHz; recommended Intel Core i5'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器：最低配置Intel Core i3 2.5 GHz；推荐配置Intel Core i5
- en: Swapping image bands
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换图像波段
- en: Our eyes can only see colors in the visible spectrum as combinations of **red,
    green, and blue** (**RGB**). Air and space-borne sensors can collect wavelengths
    of the energy outside of the visible spectrum. To view this data, we move images
    representing different wavelengths of light reflectance in and out of the RGB
    channels to make color images.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的眼睛只能看到可见光谱中的颜色，这些颜色是**红色、绿色和蓝色**（**RGB**）的组合。空中和空间传感器可以收集可见光谱之外的能量波长。为了查看这些数据，我们将代表不同波长光反射率的图像在RGB通道中移动，以制作彩色图像。
- en: 'These images often end up as bizarre and alien color combinations that can
    make visual analysis difficult. An example of a typical satellite image is shown
    in the following Landsat 7 satellite scene near the NASA Stennis Space Center
    in Mississippi along the Gulf of Mexico, which is a leading center for remote
    sensing and geospatial analysis in general:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像通常最终会变成奇特和外星般的颜色组合，这可能会使视觉分析变得困难。以下是一个典型的卫星图像示例，展示了位于墨西哥湾沿岸密西西比州NASA斯坦尼斯太空中心的Landsat
    7卫星场景，该中心是遥感以及地理空间分析领域的领先中心：
- en: '![](img/49b6f836-41c4-4c32-ae3a-ae7c8b75071c.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49b6f836-41c4-4c32-ae3a-ae7c8b75071c.png)'
- en: Most of the vegetation appears red and water appears almost black. This image
    is a type of false-color image, meaning the color of the image is not based on
    the RGB light. However, we can change the order of the bands or swap out certain
    bands to create another type of false-color image that looks more like the world
    we are used to seeing. To do so, you first need to download this image as a ZIP
    file from here: [https://git.io/vqs41](https://git.io/vqs41).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分植被看起来是红色的，水几乎看起来是黑色的。这是一类假彩色图像，意味着图像的颜色不是基于RGB光。然而，我们可以更改波段的顺序或替换某些波段，以创建另一种看起来更像我们习惯看到世界的假彩色图像。为此，你首先需要从这个链接下载此图像的ZIP文件：[https://git.io/vqs41](https://git.io/vqs41)。
- en: We installed the GDAL library with Python bindings in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml),
    *Geospatial Python Toolbox*, in the *Installing GDAL and NumPy* section. The GDAL
    library includes a module called `gdal_array` that loads and saves remotely-sensed
    images to and from NumPy arrays for easy manipulation. GDAL itself is a data access
    library and does not provide much in the name of processing. So, in this chapter,
    we will rely heavily on NumPy to actually change images.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)“地理空间Python工具箱”的“安装GDAL和NumPy”部分中安装了具有Python绑定的GDAL库。GDAL库包含一个名为`gdal_array`的模块，该模块可以将遥感图像加载到NumPy数组中，并从NumPy数组中保存遥感图像，以便于操作。GDAL本身是一个数据访问库，并不提供太多的处理功能。因此，在本章中，我们将主要依赖NumPy来实际更改图像。
- en: 'In this example, we''ll load the image into a NumPy array using `gdal_array`
    and then we''ll immediately save it back to a new GeoTiff file. However, upon
    saving, we''ll use NumPy''s advanced array-slicing feature to change the order
    of the bands. Images in NumPy are multi-dimensional arrays in the order of band,
    height, and width. This means that an image with three bands will be an array
    of length 3, containing an array for the band, height, and width of the image.
    It''s important to note that NumPy references array locations as *y,x (row, column)*
    instead of the usual *x, y (column, row)* format we work with in spreadsheets
    and other software. Let''s get started:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`gdal_array`将图像加载到NumPy数组中，然后立即将其保存到一个新的GeoTiff文件中。然而，在保存时，我们将使用NumPy的高级数组切片功能来更改波段的顺序。在NumPy中，图像是多维数组，其顺序为波段、高度和宽度。这意味着具有三个波段的图像将是一个长度为3的数组，包含图像的波段、高度和宽度数组。需要注意的是，NumPy引用数组位置的方式是*y,x（行，列）*，而不是我们在电子表格和其他软件中使用的常规*x,
    y（列，行）*格式。让我们开始吧：
- en: 'First, we''ll import `gdal_array`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入`gdal_array`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll load an image named `FalseColor.tif` into a `numpy` array:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载一个名为`FalseColor.tif`的图像到`numpy`数组中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we''ll reorder the image bands by slicing the array, rearranging the
    order, and saving it back out:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过切片数组、重新排列顺序并将它保存回来重新排序图像波段：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `SaveArray` method, the last argument is called a **prototype**. This
    argument lets you specify another image for GDAL from which you copy spatial reference
    information and some other image parameters. Without this argument, we'd end up
    with an image without georeferencing information, which could not be used in a
    GIS. In this case, we specify our input image file name because the images are
    identical, except for the band order. In this method, you can tell that the Python
    GDAL API is a wrapper around a C library and is not as Pythonic as a Python-designed
    library. For example, a pure Python library would have written the `SaveArray()`
    method as `save_array()` to follow Python standards.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SaveArray`方法中，最后一个参数被称为**原型**。此参数允许您指定另一个GDAL图像，从中复制空间参考信息和一些其他图像参数。如果没有此参数，我们最终会得到一个没有地理参考信息的图像，这种图像不能在GIS中使用。在这种情况下，我们指定输入图像文件名，因为图像除了波段顺序外都是相同的。在这个方法中，你可以看出Python
    GDAL API是C库的包装器，并不像Python设计的库那样Pythonic。例如，一个纯Python库会编写`SaveArray()`方法为`save_array()`，以遵循Python标准。
- en: 'The result of this example produces the `swap.tif` image, which is a much more
    visually appealing image with green vegetation and blue water:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子产生的结果是`swap.tif`图像，这是一个视觉效果更好的图像，有绿色植被和蓝色水域：
- en: '![](img/d57d2ccf-ba6e-4595-a858-620f2869675f.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d57d2ccf-ba6e-4595-a858-620f2869675f.png)'
- en: 'There''s only one problem with this image: it''s kind of dark and difficult
    to see. Let''s see if we can figure out why in the next section.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片只有一个问题：它有点暗，看不清楚。让我们看看在下一节中能否找出原因。
- en: Creating histograms
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建直方图
- en: A histogram shows the statistical frequency of data distribution within a dataset.
    In the case of remote sensing, the dataset is an image. The data distribution
    is the frequency of pixels in the range of **0** to **255**, which is the range
    of 8-byte numbers that are used to store image information on computers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图显示了数据集中数据分布的统计频率。在遥感的情况下，数据集是一个图像。数据分布是像素在**0**到**255**范围内的频率，这是在计算机上存储图像信息所使用的8字节数的范围。
- en: In an RGB image, color is represented as a 3-digit tuple with *(0,0,0, 0, 0)*
    being black and *(255,255,255)* being white. We can graph the histogram of an
    image with the frequency of each value along the y-axis and the range of 256 possible
    pixel values along the x-axis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在RGB图像中，颜色用3位数组表示，其中*(0,0,0)*表示黑色，*(255,255,255)*表示白色。我们可以用y轴上的每个值的频率和x轴上256个可能的像素值范围来绘制图像的直方图。
- en: Remember in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning
    about Geospatial Analysis with Python*, in the *Creating the simplest possible
    Python GIS *section, when we used the Turtle graphics engine included with Python
    to create a simple GIS? Well, we can also use it to easily graph histograms.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第1章](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml)，*使用Python学习地理空间分析*，在*创建最简单的Python
    GIS*部分，当我们使用Python包含的Turtle图形引擎创建一个简单的GIS时？嗯，我们也可以用它轻松地绘制直方图。
- en: Histograms are usually a one-off product that makes a quick script. Also, histograms
    are typically displayed as a bar graph with the width of the bars representing
    the size of grouped data bins. But, in an image, each `bin` is only one value,
    so we'll create a line graph. We'll use the histogram function in this example
    and create a red, green, and blue line for each respective band.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图通常是一个一次性产品，用于快速脚本。此外，直方图通常以条形图的形式显示，条形的宽度代表分组数据箱的大小。但是，在图像中，每个`bin`只有一个值，所以我们将创建一个线形图。我们将使用本例中的直方图函数，并为每个相应的波段创建红色、绿色和蓝色线条。
- en: 'The graphing portion of this example also defaults to scaling the *y*-axis
    values to the max RGB frequency found in the image. Technically, the *y*-axis
    represents the maximum frequency, which is the number of pixels in the image,
    which would be the case if the image was all one color. We''ll use the `turtle`
    module again here, but this example could be easily converted into any graphical
    output module. Let''s take a look at the `swap.tif` image we created in the previous
    example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的绘图部分默认将*y*轴值缩放到图像中找到的最大RGB频率。技术上，*y*轴代表最大频率，即图像中的像素数，如果图像是单一颜色的话。我们将再次使用`turtle`模块，但这个例子可以轻松地转换成任何图形输出模块。让我们看看我们在前面的例子中创建的`swap.tif`图像：
- en: 'First, we import the libraries we need, including the `turtle` graphics library:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库，包括`turtle`图形库：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we create a `histogram` function that can take an array and sort the numbers
    into bins making up the histogram:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个`histogram`函数，它可以接受一个数组并将数字排序到直方图的各个箱子中：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we have our `turtle` graphics function that takes a histogram and
    draws it:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有我们的`turtle`图形函数，它接受直方图并绘制它：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Draw the graph axes using the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码绘制图形轴：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can label them:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以给它们标注：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we''ll add tick marks on the x-axis so that we can see the line values:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在x轴上添加刻度，这样我们就可以看到线条的值：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll do the same for the y-axis:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会对y轴做同样的处理：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can begin plotting our histogram lines:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以开始绘制我们的直方图线条：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can load our image and plot its histogram using the functions we
    defined previously:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以加载我们的图像，并使用之前定义的函数绘制其直方图：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s what the histogram for `swap.tif` looks like after running the preceding
    code example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行前面的代码示例后`swap.tif`直方图的样子：
- en: '![](img/ccabeb94-8ddb-4c33-be02-0847abd958cf.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccabeb94-8ddb-4c33-be02-0847abd958cf.png)'
- en: As you can see, all three bands are grouped closely toward the left-hand side
    of the graph and all have values less than **125** or so. As these values approach
    zero, the image becomes darker, which is not surprising.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有三个波段都紧密地聚集在图表的左侧，并且所有值都小于**125**左右。随着这些值接近零，图像变暗，这并不奇怪。
- en: 'Just for fun, let''s run the script again and when we call the `draw_histogram()`
    function, we''ll add the `scale=False` option to get a sense of the size of the
    image and provide an absolute scale. We''ll change the following line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，让我们再次运行脚本，当我们调用`draw_histogram()`函数时，我们将添加`scale=False`选项，以了解图像的大小并提供绝对刻度。我们将更改以下行：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will be changed to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变为以下内容：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This change will produce the following histogram graph:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化将产生以下直方图图：
- en: '![](img/54b4b7e2-a5b7-42b4-92ba-981a15b4bb8c.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54b4b7e2-a5b7-42b4-92ba-981a15b4bb8c.png)'
- en: As you can see, it's harder to see the details of the value distribution. However,
    this absolute-scale approach is useful if you are comparing multiple histograms
    of different products that were produced from the same source image.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，很难看到值分布的细节。然而，如果您正在比较来自同一源图像的多个不同产品的多个直方图，这种绝对刻度方法是有用的。
- en: So, now that we understand the basics of looking at an image statistically using
    histograms, how do we make our image brighter? Let's check this out in the next
    section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们了解了使用直方图统计地查看图像的基本方法，那么我们如何使图像更亮呢？让我们在下一节中查看。
- en: Performing a histogram stretch
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行直方图拉伸
- en: 'A histogram stretch operation does exactly what its name says. It redistributes
    the pixel values across the whole scale. By doing so, we have more values at the
    higher-intensity level and the image becomes brighter. So, in this example, we''ll
    reuse our histogram function, but we''ll add another function called `stretch()`
    that takes an image array, creates the histogram, and then spreads out the range
    of values for each band. We''ll run these functions on `swap.tif` and save the
    result in an image called `stretched.tif`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图拉伸操作确实如其名称所示。它在整个刻度上重新分配像素值。通过这样做，我们在高亮度级别有更多的值，图像变得更亮。因此，在这个例子中，我们将重用我们的直方图函数，但我们将添加另一个名为`stretch()`的函数，它接受一个图像数组，创建直方图，然后为每个波段扩展值范围。我们将在`swap.tif`上运行这些函数，并将结果保存到名为`stretched.tif`的图像中：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `stretch` algorithm will produce the following image. Look how much brighter
    and visually appealing it is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretch`算法将产生以下图像。看看它变得多么明亮和视觉上吸引人：'
- en: '![](img/53cfa72c-2bc1-49bb-aba8-7402f1557e7c.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53cfa72c-2bc1-49bb-aba8-7402f1557e7c.png)'
- en: 'We can run our `turtle` graphics histogram script on `stretched.tif` by changing
    the file name in the `im` variable to `stretched.tif`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`im`变量中更改文件名到`stretched.tif`来在我们的`turtle`图形直方图脚本上运行我们的`swap.tif`：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the preceding code will give us the following histogram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将给出以下直方图：
- en: '![](img/ecc2138e-13f1-4111-abec-fe8252abe7e8.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecc2138e-13f1-4111-abec-fe8252abe7e8.png)'
- en: As you can see, all three bands are distributed evenly now. Their relative distribution
    to each other is the same, but, within the image, they are now spread across the
    spectrum.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在三个波段都均匀分布了。它们相互之间的相对分布是相同的，但在图像中，它们现在分布在整个频谱上。
- en: Now that we can change images for better presentation, let's look at clipping
    them to examine a particular area of interest.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够更改图像以获得更好的展示效果，让我们看看如何裁剪它们以检查特定感兴趣的区域。
- en: Clipping images
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裁剪图像
- en: Very rarely is an analyst interested in an entire satellite scene, which can
    easily cover hundreds of square miles. Given the size of satellite data, we are
    highly motivated to reduce the size of an image to only our area of interest.
    The best way to accomplish this reduction is to clip an image to a boundary that
    defines our study area. We can use shapefiles (or other vector data) as our boundary
    definition and basically get rid of all the data outside that boundary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 分析员很少对整个卫星场景感兴趣，这可以轻松覆盖数百平方英里。考虑到卫星数据的大小，我们非常希望将图像的大小减少到仅我们感兴趣的区域。实现这种减少的最佳方式是将图像裁剪到定义我们研究区域的边界。我们可以使用shapefiles（或其他矢量数据）作为我们的边界定义，并基本上删除所有该边界之外的数据。
- en: 'The following image contains our `stretched.tif` image with a county boundary
    file layered on top, visualized in **Quantum GIS** (**QGIS**):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像包含我们的`stretched.tif`图像，以及一个县边界文件叠加在上面，在**Quantum GIS**（**QGIS**）中可视化：
- en: '![](img/c175ce35-001f-41a4-a87a-c9e164b6f95e.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c175ce35-001f-41a4-a87a-c9e164b6f95e.png)'
- en: 'To clip the image, we need to follow these steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要裁剪图像，我们需要遵循以下步骤：
- en: Load the image into an array using `gdal_array`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gdal_array`将图像加载到数组中。
- en: Create a shapefile reader using PyShp.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PyShp创建一个shapefile读取器。
- en: Rasterize the shapefile into a georeferenced image (convert it from a vector
    into a raster).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将shapefile栅格化到地理参考图像（将其从矢量转换为栅格）。
- en: Turn the shapefile image into a binary mask or filter to only grab the image
    pixels we want within the shapefile boundary.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将shapefile图像转换为二进制掩码或过滤器，以仅获取shapefile边界内我们想要的图像像素。
- en: Filter the satellite image through the mask.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过掩码过滤卫星图像。
- en: Discard satellite image data outside the mask.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 丢弃掩码外的卫星图像数据。
- en: Save the clipped satellite image as `clip.tif`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将裁剪后的卫星图像保存为`clip.tif`。
- en: We installed PyShp in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml),
    *Geospatial Python Toolbox*, so you should already have it installed from PyPi.
    We will also add a couple of useful new utility functions in this script. The
    first is `world2pixel()`, which uses the GDAL GeoTransform object to do the world-coordinate
    to image-coordinate conversion for us.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)“地理空间Python工具箱”中安装了PyShp，所以你应该已经通过PyPi安装了它。我们还将在此脚本中添加一些有用的新实用函数。第一个是`world2pixel()`，它使用GDAL
    GeoTransform对象为我们执行世界坐标到图像坐标的转换。
- en: It's still the same process we've used throughout this book, but it's integrated
    better with GDAL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是我们在这本书中一直使用的相同过程，但它与GDAL的集成更好。
- en: We also add the `imageToArray()` function, which converts a PIL image into a
    NumPy array. The county boundary shapefile is the `hancock.shp` boundary we've
    used in previous chapters, but you can also download it here if you need to: [http://git.io/vqsRH](http://git.io/vqsRH).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`imageToArray()`函数，它将PIL图像转换为NumPy数组。县边界shapefile是我们在前几章中使用的`hancock.shp`边界，但如果你需要，也可以从这里下载：[http://git.io/vqsRH](http://git.io/vqsRH)。
- en: 'We use PIL because it is the easiest way to rasterize our shapefile as a mask
    image to filter out the pixels beyond the shapefile boundary. Let''s get started:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用PIL，因为它是将shapefile作为掩码图像光栅化的最简单方式，以过滤掉shapefile边界之外的像素。让我们开始吧：
- en: 'First, we''ll load the libraries we need:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将加载所需的库：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we''ll load PIL. This may need to be installed slightly differently on
    different platforms, so we have to check for that difference:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将加载PIL。在不同的平台上可能需要以不同的方式安装，因此我们必须检查这种差异：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we will set up the variables for our input image, shapefile, and our output
    image:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置输入图像、shapefile和输出图像的变量：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, create a function that simply converts an image into a `numpy` array
    so that we can convert the mask image we will create and use it in our NumPy-based
    clipping process:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个函数，它简单地将图像转换为`numpy`数组，这样我们就可以将创建的掩码图像转换为NumPy数组，并在基于NumPy的裁剪过程中使用它：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need a function to convert geospatial coordinates into image pixels,
    which will allow us to use coordinates from our clipping shapefile to limit which
    image pixels are saved:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数将地理空间坐标转换为图像像素，这将允许我们使用来自裁剪shapefile的坐标来限制要保存的图像像素：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we can load our source image into a `numpy` array:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将源图像加载到`numpy`数组中：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll also load the source image as a gdal image because `gdal_array` does
    not give us the geotransform information we need to convert coordinates into pixels:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将以gdal图像的形式加载源图像，因为`gdal_array`没有给我们转换坐标到像素所需的地理变换信息：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we''ll use the Python shapefile library to open our shapefile:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用Python shapefile库打开我们的shapefile：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we''ll convert the shapefile bounding box coordinates into image coordinates
    based on our source image:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将根据源图像将shapefile边界框坐标转换为图像坐标：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can calculate the size of our output image based on the extents of
    the shapefile and take just that part of the source image:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以根据shapefile的范围计算输出图像的大小，并仅取源图像的相应部分：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we''ll create new geomatrix data for the output image:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为输出图像创建新的几何矩阵数据：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can create a simple black-and-white mask image from the shapefile that
    will define the pixels we want to extract from the source image:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从shapefile创建一个简单的黑白掩码图像，它将定义我们想要从源图像中提取的像素：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we convert the mask image into a `numpy` array:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将掩码图像转换为`numpy`数组：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we''re ready to use the mask array to clip the source array in `numpy`
    and save it to a new geotiff image:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备好使用掩码数组在`numpy`中裁剪源数组并将其保存为新的geotiff图像：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This script produces the following clipped image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本生成以下裁剪图像：
- en: '![](img/c79fbf2a-441a-4cf1-856b-2c65d9aa1f65.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c79fbf2a-441a-4cf1-856b-2c65d9aa1f65.png)'
- en: The areas that remain outside the county boundary that appear in black are actually
    called `NoData` values, meaning there is no information at that location, and
    are ignored by most geospatial software. Because images are rectangular, the `NoData`
    values are common for data that does not completely fill an image.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在县边界之外保留的黑色区域实际上被称为`NoData`值，这意味着在该位置没有信息，并且大多数地理空间软件会忽略这些值。因为图像是矩形的，所以`NoData`值对于不完全填充图像的数据是常见的。
- en: You have now walked through an entire workflow that is used by geospatial analysts
    around the world every day to prepare multispectral satellite and aerial images
    for use in a GIS. We'll look at how we can actually analyze images as information
    in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经走过了全球地理空间分析师每天用来准备多光谱卫星和航空图像以用于GIS的整个工作流程。在下一节中，我们将探讨我们如何实际上分析图像作为信息。
- en: Classifying images
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像分类
- en: '**Automated remote sensing** (**ARS**) is rarely ever done in the visible spectrum.
    ARS processes images without any human input. The most commonly available wavelengths
    outside of the visible spectrum are infrared and near-infrared.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化遥感**（**ARS**）很少在可见光谱中进行。ARS处理图像时无需任何人工输入。在可见光谱之外最常用的波长是红外和近红外。'
- en: 'The following illustration is a thermal image (band 10) from a fairly recent
    Landsat 8 flyover of the US Gulf Coast from New Orleans, Louisiana to Mobile,
    Alabama. The major natural features in the image have been labeled so that you
    can orient yourself:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图是一张热成像图（波段10），来自最近一次的Landsat 8飞越美国墨西哥湾沿岸，从路易斯安那州的纽奥尔良到阿拉巴马州的莫比尔。图像中的主要自然特征已被标注，以便您定位：
- en: '![](img/e1a8105d-059b-43a4-ad0c-ba5d31674e10.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1a8105d-059b-43a4-ad0c-ba5d31674e10.png)'
- en: Because every pixel in that image has a reflectance value, it is information
    as opposed to just color. The type of reflectance can tell us definitively what
    a feature is, as opposed to us guessing by looking at it. Python can see those
    values and pick out features the same way we intuitively do by grouping related
    pixel values. We can colorize pixels based on their relation to each other to
    simplify the image and view-related features. This technique is called **classification**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因为图像中的每个像素都有一个反射率值，所以它是信息，而不仅仅是颜色。反射率类型可以确切地告诉我们一个特征是什么，而不是我们通过观察来猜测。Python可以看到这些值，并以与我们直观地通过分组相关像素值相同的方式挑选出特征。我们可以根据像素之间的关系对像素进行着色，以简化图像并查看相关特征。这种技术称为**分类**。
- en: Classifying can range from fairly simple groupings, based only on some value
    distribution algorithm derived from the histogram, to complex methods involving
    training datasets and even computer learning and artificial intelligence. The
    simplest forms are called **unsupervised classifications**, in which no additional
    input is given other than the image itself. Methods involving some sort of training
    data to guide the computer are called **supervised classifications**. It should
    be noted that classification techniques are used across many fields, from medical
    doctors searching for cancerous cells in a patient's body scan, to casinos using
    facial-recognition software on security videos to automatically spot known **con-artists
    at blackjack tables**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 分类可以从基于直方图推导出的某些值分布算法的相对简单分组，到涉及训练数据集甚至计算机学习和人工智能的复杂方法。最简单的形式被称为**无监督分类**，其中除了图像本身之外没有提供任何其他输入。涉及某种训练数据以引导计算机的方法称为**监督分类**。需要注意的是，分类技术在许多领域都有应用，从寻找患者体内扫描中癌细胞的外科医生，到在赌场使用面部识别软件在安全录像中自动识别已知**骗子**在二十一点桌上的情况。
- en: To introduce remote sensing classification, we'll just use the histogram to
    group pixels with similar colors and intensities and see what we get. First, you'll
    need to download the Landsat 8 scene from here: [http://git.io/vByJu](http://git.io/vByJu).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍遥感分类，我们将仅使用直方图将具有相似颜色和强度的像素分组，看看我们得到什么。首先，您需要从这里下载Landsat 8场景：[http://git.io/vByJu](http://git.io/vByJu)。
- en: 'Instead of our `histogram()` function from the previous examples, we''ll use
    the version included with NumPy that allows you to easily specify the number of
    bins and returns two arrays with the frequency, as well as the ranges of the bin
    values. We''ll use the second array with the ranges as our class definitions for
    the image. The `lut` or look-up table is an arbitrary color palette that''s used
    to assign colors to the 20 unsupervised classes. You can use any colors you want.
    Let''s look at the following steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前示例中的`histogram()`函数不同，我们将使用NumPy中包含的版本，该版本允许您轻松指定箱数，并返回两个数组，包含频率以及箱值范围。我们将使用包含范围的第二个数组作为图像的类定义。`lut`或查找表是一个任意调色板，用于将颜色分配给20个无监督类别。您可以使用任何颜色。让我们看看以下步骤：
- en: 'First, we import our libraries:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的库：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we set up some variables for our input and output images:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为输入和输出图像设置一些变量：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Load the image into a `numpy` array for processing:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像加载到`numpy`数组中进行处理：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we''re going to create a histogram of our image with 20 groups or `bins` that
    we''ll use for classifying:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用20个组或`bins`来创建我们图像的直方图，这些组将用于分类：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we''ll create a look-up table that will define the color ranges for our
    classes so that we can visualize them:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个查找表，该表将定义我们类别的颜色范围，以便我们可以可视化它们：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that our setup is complete, we can perform the classification:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置，我们可以进行分类：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we can save our classified image:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以保存我们的分类图像：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following image is our classification output, which we just saved as a
    JPEG:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是我们的分类输出，我们刚刚将其保存为JPEG格式：
- en: '![](img/a2271208-f024-4758-893d-4a53fde9e4f5.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2271208-f024-4758-893d-4a53fde9e4f5.png)'
- en: We didn't specify the prototype argument when saving this as an image, so it
    has no georeferencing information, though we could easily have done otherwise
    to save the output as a GeoTIFF.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存为图像时，我们没有指定原型参数，因此它没有地理参考信息，尽管我们本可以轻松地将输出保存为GeoTIFF格式。
- en: This result isn't bad for a very simple unsupervised classification. The islands
    and coastal flats show up as different shades of green. The clouds were isolated
    as shades of orange and dark blues. We did have some confusion inland where the
    land features were colored the same as the Gulf of Mexico. We could further refine
    this process by defining the class ranges manually instead of just using the histogram.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个非常简单的无监督分类来说，这个结果并不坏。岛屿和海岸平原以不同的绿色色调出现。云被隔离为橙色和深蓝色。我们在内陆有一些混淆，因为陆地特征的颜色与墨西哥湾相同。我们可以通过手动定义类范围而不是仅仅使用直方图来进一步细化这个过程。
- en: Now that we have the ability to separate features in the image, we can try to
    extract features as vector data for inclusion in a GIS.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了分离图像中特征的能力，我们可以尝试提取特征作为矢量数据，以便包含在GIS中。
- en: Extracting features from images
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从图像中提取特征
- en: The ability to classify an image leads us to another remote sensing capability.
    Now that you've worked with shapefiles over the last few chapters, have you ever
    wondered where they come from? Vector GIS data such as shapefiles are typically
    extracted from remotely-sensed images such as the examples we've seen so far.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对图像进行分类的能力使我们转向另一个遥感能力。在你过去几章中处理形状文件之后，你是否曾经想过它们从何而来？像形状文件这样的矢量GIS数据通常是从遥感图像中提取的，例如我们之前看到的例子。
- en: Extraction normally involves an analyst clicking around each object in an image
    and drawing the feature to save it as data. But with good remotely-sensed data
    and proper pre-processing, it is possible to automatically extract features from
    an image.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提取通常涉及分析师在图像中的每个对象周围点击并绘制特征以保存为数据。但是，有了良好的遥感数据和适当的预处理，从图像中自动提取特征是可能的。
- en: 'For this example, we''ll take a subset of our Landsat 8 thermal image to isolate
    a group of barrier islands in the Gulf of Mexico. The islands appear white as
    the sand is hot and the cooler water appears black (you can download this image
    here: [http://git.io/vqarj](http://git.io/vqarj)):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将从我们的Landsat 8热图像中取一个子集，以隔离墨西哥湾的一组屏障岛。岛屿呈现白色，因为沙子很热，而较冷的水则呈现黑色（你可以从这里下载这张图片：[http://git.io/vqarj](http://git.io/vqarj)）：
- en: '![](img/bdd03cfc-b79b-424a-b888-f7f571fbb1f2.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bdd03cfc-b79b-424a-b888-f7f571fbb1f2.png)'
- en: Our goal with this example is to automatically extract the three islands in
    the image as a shapefile. But before we can do that, we need to mask out any data
    we aren't interested in. For example, the water has a wide range of pixel values,
    as do the islands themselves. If we just want to extract the islands themselves,
    we need to push all the pixel values into just two bins to make the image black
    and white. This technique is called **thresholding**. The islands in the image
    have enough contrast with the water in the background that thresholding should
    isolate them nicely.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个例子的目标是自动将图像中的三个岛屿提取为形状文件。但在我们能够做到这一点之前，我们需要屏蔽掉我们不感兴趣的数据。例如，水具有广泛的像素值范围，岛屿本身也是如此。如果我们只想提取岛屿本身，我们需要将所有像素值推入仅两个组中，使图像变为黑白。这种技术称为**阈值化**。图像中的岛屿与背景中的水有足够的对比度，阈值化应该可以很好地隔离它们。
- en: 'In the following script, we will read the image into an array and then histogram
    the image using only two bins. We will then use the colors black and white to
    color the two bins. This script is simply a modified version of our classification
    script with very limited output. Let''s look at the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的脚本中，我们将图像读入一个数组，然后使用仅两个分箱对图像进行直方图化。然后，我们将使用黑色和白色为两个分箱着色。这个脚本只是我们分类脚本的修改版，输出非常有限。让我们看看以下步骤：
- en: 'First, we import the one library we need:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们需要的库：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we define the variables for our input and output image:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义输入和输出图像的变量：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we can load the image:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以加载图像：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can set up our simple classification scheme:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以设置我们的简单分类方案：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we classify the image:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对图像进行分类：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we save the image:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们保存图像：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output looks great, as shown in the following image:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来很棒，如下面的图像所示：
- en: '![](img/ae499dec-3998-48cc-ad4d-5ec670e52f70.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae499dec-3998-48cc-ad4d-5ec670e52f70.png)'
- en: The islands are clearly isolated, so our extraction script will be able to identify
    them as polygons and save them to a shapefile. The GDAL library has a method called
    `Polygonize()` that does exactly that. It groups all sets of isolated pixels in
    an image and saves them out as a feature dataset. One interesting technique we
    will use in this script is to use our input image as a mask.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 岛屿被清楚地隔离，因此我们的提取脚本将能够将它们识别为多边形并保存到形状文件中。GDAL库有一个名为 `Polygonize()` 的方法，它正好做这件事。它将图像中所有孤立像素集分组，并将它们保存为要素数据集。在这个脚本中，我们将使用的一个有趣的技术是使用我们的输入图像作为掩码。
- en: 'The `Polygonize()` method allows you to specify a mask that will use the color
    black as a filter that will prevent the water from being extracted as a polygon,
    and we''ll end up with just the islands. Another area to note in the script is
    that we copy the georeferencing information from our source image to our shapefile
    to geolocate it properly. Let''s look at the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polygonize()` 方法允许您指定一个掩码，它将使用黑色作为过滤器，以防止水被提取为多边形，我们最终将只得到岛屿。在脚本中需要注意的另一个区域是，我们复制了源图像的地理参考信息到我们的形状文件，以正确地定位它。让我们看看以下步骤：'
- en: 'First, we import our libraries:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的库：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we set up our input and output image and shapefile variables:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置输入和输出图像以及形状文件的变量：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s open our input image and get the first and only band:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开我们的输入图像并获取第一个也是唯一的一个波段：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we''ll tell `gdal` to use that band as a mask:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将告诉 `gdal` 使用该波段作为掩码：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we''re ready to set up our shapefile:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好设置我们的形状文件：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we need to copy our spatial reference information from the source image
    to the shapefile, to locate it on the Earth:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要从源图像复制我们的空间参考信息到形状文件，以便在地球上定位它：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can set up our shapefile attributes:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以设置我们的形状文件属性：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we can extract our polygons:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以提取我们的多边形：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The output shapefile is simply called `extract.shp`. As you may remember from [Chapter
    4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml), *Geospatial Python Toolbox*, we
    created a quick pure Python script using PyShp and PNG Canvas to visualize shapefiles.
    We'll bring that script back here so that we can look at our shapefile, but we'll
    add something extra to it. The largest island has a small lagoon which shows up
    as a hole in the polygon. To properly render it, we have to deal with parts in
    a shapefile record.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的形状文件简单地命名为 `extract.shp`。如您从[第4章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)中可能记得的，*地理空间Python工具箱*，我们使用PyShp和PNG
    Canvas创建了一个快速纯Python脚本，用于可视化形状文件。我们将把这个脚本带回这里，以便我们可以查看我们的形状文件，但我们会给它添加一些额外的功能。最大的岛屿有一个小潟湖，在多边形中显示为一个洞。为了正确渲染它，我们必须处理形状文件记录中的部分。
- en: 'The previous example using that script did not do that, so we''ll add that
    piece as we loop through the shapefile features in the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该脚本的前一个示例没有这样做，所以我们将在这个步骤中添加这个部分，我们将通过形状文件特征循环：
- en: 'First, we need to import the libraries we''ll need:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入我们将需要的库：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we get the spatial information from the shapefile that will allow us
    to map coordinates to pixels:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从形状文件中获取空间信息，这将允许我们将坐标映射到像素：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we''ll create a list to hold our polygons:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个列表来保存我们的多边形：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we will loop through the shapefile and collect our polygons:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将遍历形状文件并收集我们的多边形：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we map each point to an image pixel:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将每个点映射到图像像素：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we draw the image using our polygon pixel information in `PNGCanvas`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `PNGCanvas` 中的多边形像素信息绘制图像：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we save the image:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们保存图像：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following image shows our automatically extracted island features:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了我们的自动提取的岛屿特征：
- en: '![](img/f05b6042-5339-402d-b6bb-078186d2a19b.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/f05b6042-5339-402d-b6bb-078186d2a19b.png)'
- en: Commercial packages that do this kind of work can easily cost tens of thousands
    of dollars. While these packages are very robust, it is still fun and empowering
    to see how far you can get with simple Python scripts and a few open-source packages.
    In many cases, you can do everything you need to do.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此类工作的商业软件可能轻易花费数万美元。虽然这些软件包非常稳健，但看到您仅使用简单的Python脚本和一些开源软件包就能走多远仍然很有趣且令人鼓舞。在许多情况下，您可以完成所需的所有工作。
- en: 'The western-most island contains the polygon hole, as shown in the following
    image, and is zoomed in on that area:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最西端的岛屿包含多边形孔洞，如下面的图像所示，并放大了该区域：
- en: '![](img/4411871b-5108-48e5-9b8c-9b455393da0c.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/4411871b-5108-48e5-9b8c-9b455393da0c.png)'
- en: If you want to see what would happen if we didn't deal with the polygon holes,
    then just run the version of the script from [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml),
    *Geospatial Python Toolbox*, on this same shapefile to compare the difference.
    The lagoon is not easy to see, but you will find it if you use the other script.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看看如果我们没有处理多边形孔洞会发生什么，只需运行[第4章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)中“地理空间Python工具箱”的脚本版本，并与这个相同的shapefile进行比较即可。潟湖不容易看到，但如果你使用另一个脚本，你会找到它。
- en: Automated feature extraction is a holy grail within geospatial analysis because
    of the cost and tedious effort required to manually extract features. The key
    to feature extraction is proper image classification. Automated feature extraction
    works well with water bodies, islands, roads, farm fields, buildings, and other
    features that tend to have high-contrast pixel values with their background.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 自动特征提取是地理空间分析中的圣杯，因为手动提取特征需要高昂的成本和繁琐的努力。特征提取的关键是正确的图像分类。自动特征提取与水体、岛屿、道路、农田、建筑和其他具有与背景高对比度像素值的特征配合得很好。
- en: 'You now have a good grasp of working with remote sensing data using GDAL, NumPy,
    and PIL. It''s time to move on to our most complex example: change detection.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经很好地掌握了使用GDAL、NumPy和PIL处理遥感数据的方法。现在是时候继续到我们最复杂的例子：变化检测了。
- en: Understanding change detection
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变化检测
- en: Change detection is the process of taking two geo-registered images of the exact
    same area from two different dates and automatically identifying differences.
    It is really just another form of image classification. Just like our previous
    classification examples, it can range from trivial techniques like those used
    here, to highly-sophisticated algorithms that provide amazingly precise and accurate
    results.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 变化检测是从两个不同日期的同一区域自动识别差异的过程，这两个图像是精确地理配准的。这实际上只是图像分类的另一种形式。就像我们之前的分类示例一样，它可以从这里使用的简单技术到提供惊人精确和准确结果的复杂算法。
- en: For this example, we'll use two images from a coastal area. These images show
    a populated area before and after a major hurricane, so there are significant
    differences, many of which are easy to visually spot, making these samples good
    for learning change detection. Our technique is to simply subtract the first image
    from the second to get a simple image difference using NumPy. This is a valid
    and often used technique.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用来自沿海地区的一对图像。这些图像显示了在一场大飓风前后的人口密集区域，因此存在显著差异，其中许多差异很容易通过视觉识别，这使得这些样本非常适合学习变化检测。我们的技术是简单地使用NumPy从第二张图像中减去第一张图像以获得简单的图像差异。这是一个有效且常用的技术。
- en: The advantages are it is comprehensive and very reliable. The disadvantage of
    this overly simple algorithm is that it doesn't isolate the type of change. Many
    changes are insignificant for analysis, such as the waves on the ocean. In this
    example, we'll mask the water fairly effectively to avoid that distraction and
    only focus on the higher reflectance values toward the right-hand side of the
    difference image histogram.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是它全面且非常可靠。这个过于简单的算法的缺点是它没有隔离变化类型。许多变化对于分析来说并不重要，例如海洋上的波浪。在这个例子中，我们将有效地屏蔽水面以避免这种干扰，并仅关注差异图像直方图右侧的高反射率值。
- en: You can download the baseline image from [http://git.io/vqa6h](http://git.io/vqa6h).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://git.io/vqa6h](http://git.io/vqa6h)下载基线图像。
- en: You can download the changed image from [http://git.io/vqaic](http://git.io/vqaic).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://git.io/vqaic](http://git.io/vqaic)下载已更改的图像。
- en: Note these images are quite large – 24 MB and 64 MB, respectively!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些图像相当大——分别为24 MB和64 MB！
- en: The baseline image is panchromatic, while the changed image is in false color.
    Panchromatic images are created by sensors that capture all visible light and
    are typical of higher resolution sensors rather than multispectral sensors that
    capture bands containing restricted wavelengths.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '基准图像是全色图像，而变化图像是假彩色图像。全色图像是由捕获所有可见光的传感器创建的，通常是高分辨率传感器而不是捕获包含限制波长的波段的多元光谱传感器。 '
- en: Normally, you would use two identical band combinations, but these samples will
    work for our purposes. The visual markers we can use to evaluate change detection
    include a bridge in the southeast quadrant of the image that spans from the Peninsula
    to the edge of the image. This bridge is clearly visible in the before image and
    is reduced to pilings by the hurricane. Another marker is a boat in the northwest
    quadrant which appears in the after image as a white trail but is not in the before
    image.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会使用两个相同的波段组合，但这些样本将适用于我们的目的。我们可以用来评估变化检测的视觉标记包括图像东南象限的一座桥梁，它从半岛延伸到图像的边缘。这座桥梁在原始图像中清晰可见，但被飓风减少到桩。另一个标记是西北象限的一艘船，它在变化后的图像中表现为一条白色轨迹，但在原始图像中并不存在。
- en: 'A neutral marker is the water and the state highway, which runs through the
    town and connects to the bridge. This feature is easily visible concrete, which
    does not change significantly between the two images. The following is a screenshot
    of the baseline image:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 中性标记是水和穿过城镇并连接到桥梁的州际公路，这是一个容易看到的混凝土特征，在两个图像之间没有显著变化。以下是基于线的图像截图：
- en: '![](img/432f940f-0245-47e7-979a-35a54b04bfeb.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/432f940f-0245-47e7-979a-35a54b04bfeb.png)'
- en: 'To view these images up-close yourself, you should use QGIS or OpenEV (FWTools),
    as described in the *Quantum GIS and OpenEv* section in [Chapter 3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml),
    *The Geospatial Technology Landscape*, to view them easily. The following image
    is the after image:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要自己近距离查看这些图像，你应该使用QGIS或OpenEV（FWTools），如[第3章](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml)中“地理空间技术景观”部分的*Quantum
    GIS and OpenEv*所述，以便轻松查看。以下图像是变化后的图像：
- en: '![](img/aaeb9249-4c99-47fc-a5dd-5f1d557e577f.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaeb9249-4c99-47fc-a5dd-5f1d557e577f.png)'
- en: 'So, let''s perform change detection:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们进行变化检测：
- en: 'First, we load our libraries:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们加载我们的库：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we set up the variables for our input and output images:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置输入和输出图像的变量：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we read both images into NumPy arrays with `gdal_array`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`gdal_array`将这两张图像读入NumPy数组：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we subtract the before image from the after image (difference = after
    – before):'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们从变化后的图像中减去原始图像（差值=变化后-变化前）：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we divide the image into five classes:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将图像分为五类：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we set our color table to use black to mask the lower classes. We do
    this to filter water and roads because they are darker in the image:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将颜色表设置为使用黑色来屏蔽低级别。我们这样做是为了过滤水和道路，因为它们在图像中较暗：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, we assign colors to the classes:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为类别分配颜色：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we save our image:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们保存我们的图像：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here''s what our initial difference image looks like:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的初始差异图像的样子：
- en: '![](img/79fec589-c670-41f0-8612-98194620107b.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79fec589-c670-41f0-8612-98194620107b.png)'
- en: For the most part, the green classes represent areas where something was added.
    The red would be a darker value where something was probably removed. We can see
    that the boat trail is green in the northwest quadrant. We can also see a lot
    of changes in vegetation, as would be expected due to seasonal differences. The
    bridge is an anomaly because the exposed pilings are brighter than the darker
    surface of the original bridge, which makes them green instead of red.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，绿色类别代表添加了某些东西的区域。红色则表示较暗的值，可能是移除了某些东西。我们可以看到，在西北象限的船迹是绿色的。我们还可以看到植被有很多变化，这是由于季节差异而预期的。桥梁是一个异常，因为暴露的桩比原始桥梁较暗的表面更亮，这使得它们变成了绿色而不是红色。
- en: Concrete is a major indicator in change detection because it is very bright
    in sunlight and is usually a sign of new development. Conversely, if a building
    is torn down and the concrete is removed, the difference is also easy to identify.
    So, the simple difference algorithm that we used here isn't perfect, but it could
    be greatly improved using thresholding, masking, better class definitions, and
    other techniques.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 混凝土是变化检测中的一个重要指标，因为它在阳光下非常明亮，通常是新发展的标志。相反，如果一座建筑被拆除并且混凝土被移除，这种差异也容易识别。因此，我们在这里使用的简单差异算法并不完美，但可以通过阈值、掩膜、更好的类别定义和其他技术进行大幅改进。
- en: 'To really appreciate our change detection product, you can overlay it on the
    before or after image in QGIS and set the color black to transparent, as shown
    in the following image:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正欣赏我们的变化检测产品，你可以在QGIS中将它叠加到原始或后续图像上，并将颜色设置为黑色透明，如图所示：
- en: '![](img/b9a17df0-71c6-4c87-9370-b6b7a4f7f56e.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9a17df0-71c6-4c87-9370-b6b7a4f7f56e.png)'
- en: Potentially, you can combine this change detection analysis with the feature
    extraction example to extract changes as vector data that can be analyzed in a
    GIS efficiently.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可能地，你可以将这种变化检测分析结合特征提取示例，以提取作为矢量数据的变化，这些数据可以在GIS中高效地进行分析。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the foundations of remote sensing, including band
    swapping, histograms, image classification, feature extraction, and change detection.
    Like in the other chapters, we stayed as close to pure Python as possible, and
    where we compromised on this goal for processing speed, we limited the software
    libraries as much as possible to keep things simple. However, if you have the
    tools from this chapter installed, you really have a complete remote sensing package
    that is limited only by your desire to learn.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了遥感的基础，包括波段交换、直方图、图像分类、特征提取和变化检测。与其他章节一样，我们尽可能地接近纯Python，在处理速度上做出妥协的地方，我们尽可能地限制软件库，以保持简单。然而，如果你安装了本章的工具，你实际上拥有一个完整的遥感软件包，其局限性仅在于你学习的愿望。
- en: The techniques in this chapter are foundational to all remote sensing processes
    and will allow you to build more complex operations.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的技术是所有遥感处理的基础，将使你能够构建更复杂的操作。
- en: In the next chapter, we'll investigate elevation data. Elevation data doesn't
    fit squarely in GIS or remote sensing as it has elements of both types of processing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究高程数据。高程数据既不属于GIS也不属于遥感，因为它具有这两种处理方式的元素。
- en: Further reading
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The authors of GDAL have a set of Python examples that cover a number of advanced
    topics that may be of interest to you. You can find them at [https://github.com/OSGeo/gdal/tree/master/gdal/swig/python/samples](https://github.com/OSGeo/gdal/tree/master/gdal/swig/python/samples).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL的作者提供了一系列Python示例，涵盖了多个可能对你感兴趣的高级主题。你可以在[https://github.com/OSGeo/gdal/tree/master/gdal/swig/python/samples](https://github.com/OSGeo/gdal/tree/master/gdal/swig/python/samples)找到它们。
