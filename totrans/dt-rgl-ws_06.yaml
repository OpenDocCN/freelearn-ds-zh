- en: 6\. Learning the Hidden Secrets of Data Wrangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about data problems that arise in business use
    cases and how to resolve them. This chapter will give you the skills needed to
    be able to clean and handle real-life messy data. By the end of this chapter,
    you will be able to prepare data for analysis by formatting it as required by
    downstream systems. You will also be able to identify and remove outliers from
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn the secret behind creating a successful data
    wrangling pipeline. In the previous chapters, we were introduced to basic and
    advanced data structures and other building blocks of data wrangling, such as
    `pandas` and NumPy. In this chapter, we will look at the data handling aspect
    of data wrangling.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a database of patients who have heart diseases, and like
    any survey, the data is either missing, incorrect, or has outliers. Outliers are
    values that are abnormal and tend to be far away from the central tendency, and
    thus including it in your fancy machine learning model may introduce a terrible
    bias that we need to avoid. Often, these problems can cause a huge difference
    in terms of money, man-hours, and other organizational resources. It is undeniable
    that someone with the skills to solve these problems will prove to be an asset
    to an organization. In this chapter, we'll talk about a few advanced techniques
    that we can use to handle outliers and missing data.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced List Comprehension and the zip Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will deep dive into the heart of list comprehension. We
    have already seen a basic form of it, including something as simple as `a = [i
    for i in range(0, 30)]` to something a bit more complex that involves one conditional
    statement. However, as we already mentioned, list comprehension is a very powerful
    tool and, in this section, we will explore this amazing tool further. We will
    investigate another close relative of list comprehension called `zip` and its
    related functions and methods. By the end of this section, you will be confident
    in handling complicated logical problems.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Generator Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, while discussing advanced data structures, we witnessed
    functions such as `repeat`. We said that they represent a special type of function
    known as iterators. We also showed you how the lazy evaluation of an iterator
    can lead to an enormous amount of space being saved and time efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are one brick in the functional programming construct that Python
    has to offer. Functional programming is indeed a very efficient and safe way to
    approach a problem. It offers various advantages over other methods, such as modularity,
    ease of debugging and testing, composability, formal provability (a theoretical
    computer science concept), and more.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at an exercise where we'll see how to use generator expressions.
    But before we do that, we should define, formally, what a generator expression
    is. Generator expressions are a high-performance, memory-efficient generalization
    of list comprehensions and generators. We'll practice this concept in the following
    exercise. Since we have covered some amount of list comprehension already, generator
    expressions will look familiar to us. However, they also offer some advantages
    over list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Generator Expressions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be working with generator expressions, which are
    considered another brick of functional programming (as a matter of fact, they
    are inspired by the pure functional language known as Haskell). We will create
    a list of odd numbers using list comprehension and check the memory occupied by
    the list. We will then create the same list using a generator expression and see
    the advantage of using it over list comprehension. To do so, let''s go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Jupyter Notebook and write the following code using list comprehension
    to generate a list of all the odd numbers between 0 and 10,0000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `getsizeof` from `sys` by using the following code to understand the bytes
    of memory the generator expressions occupy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will see that it takes a good amount of memory to do this. It is also not
    very time efficient. How can we change this? Using a method such as `repeat` is
    not applicable here because we need to have the logic of the list comprehension.
    Fortunately, we can turn any list comprehension into a generator expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the equivalent generator expression for the aforementioned list comprehension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the only change we made is to surround the list comprehension statement
    with round brackets instead of square ones. This makes it shrink to only around
    `100` bytes. This is because this is a generator expression, so no explicit memory
    has been allocated for it. There's just enough memory to hold the logic of the
    generation of numbers. This makes it become a lazy evaluation, and thus is more
    efficient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Print the first 10 odd numbers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, the first 10 odd numbers are being printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YMwDFH](https://packt.live/2YMwDFH).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3daSb47](https://packt.live/3daSb47).
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we'll take a look at how to write a generator expression
    in one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.02: Single-Line Generator Expression'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use our knowledge of generator expressions to generate
    an expression that will read one word at a time from a list of words and will
    remove newline characters at the end of them while making them lowercase. This
    can certainly be done using a `for` loop explicitly. To do so, let''s go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Jupyter Notebook and create a `words` string, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following generator expression to achieve this task, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list comprehension to get words one by one from the generator expression
    and finally print the list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, we created a one-liner generator expression efficiently using
    a simple `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Bg5pzi](https://packt.live/2Bg5pzi).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YbIo9J](https://packt.live/2YbIo9J).
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we'll extract a list using single words.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Extracting a List with Single Words'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we look at the output of the previous exercise, we will notice that due
    to the messy nature of the source data (which is normal in the real world), we
    ended up with a list where, in some cases, we have more than one word together
    as a phrase, separated by a space. To improve this and to get a list of single
    words, we will have to modify the generator expressions. Let''s see how to do
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the generator expression and then write the equivalent nested `for` loops
    so that we can compare the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write an equivalent to the preceding code by using a nested `for` loop, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We must admit that the generator expression is not only space- and time-saving
    but also a more elegant way to write the same logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YFD5yo](https://packt.live/2YFD5yo).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3hG4WXO](https://packt.live/3hG4WXO).
  prefs: []
  type: TYPE_NORMAL
- en: To remember how the nested loop works in generator expressions, keep in mind
    that the loops are evaluated from left to right and the final loop variable (in
    our example, which is denoted by the single letter `w`) is given back (thus, we
    could call `strip` and `lower` on it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram will help you remember the trick about using nested `for`
    loops in list comprehension or generator expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Nested loops illustration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: Nested loops illustration'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about nested `for` loops in generator expressions previously,
    but now we are going to learn about independent `for` loops in a generator expression.
    We will have two output variables from two `for` loops and they must be treated
    as a tuple so that they don't have ambiguous grammar in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following two lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You are asked to generate all possible combinations of the values in the `marbles`
    array and `counts` array after being given the preceding two lists. How will you
    do that? Surely using a nested `for` loop and the `append` method, you can accomplish
    the task. How about a generator expression? A more elegant and easy solution is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This generator expression creates a tuple in each iteration of the simultaneous
    `for` loops. This code is equivalent to the following explicit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This generator expression creates a tuple in each iteration of the simultaneous
    `for` loops. Once again, the generator expression is easy, elegant, and efficient
    compared to the `for..in` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next exercise, where we will examine the `zip` function
    and compare it with the generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.04: The zip Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will examine the `zip` function and compare it with the
    generator expression we wrote in the previous exercise. The problem with the previous
    generator expression is the fact that it produced all possible combinations. For
    instance, if we need to relate countries with their capitals, doing so using a
    generator expression will be difficult. Fortunately, Python gives us a built-in
    function called `zip` for just this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Jupyter Notebook and create the following two lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a list of tuples where the first element is the name of the country
    and the second element is the name of the capital by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is not very well represented. It would make more sense if we can use `dict`
    where keys are the names of the countries, while the values are the names of the
    capitals.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following command, where keys are the names of the countries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As always, in real life, data is messy. So, the nice equal length lists of countries
    and capitals that we just saw are not always available. The `zip` function cannot
    be used with unequal length lists, because `zip` will stop working as soon as
    one of the lists comes to an end.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3hDfKG5](https://packt.live/3hDfKG5).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2CgdOTP](https://packt.live/2CgdOTP).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the following exercise to understand how we can handle messy data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.05: Handling Messy Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to use the `zip` function to handle messy data
    in lists of unequal length. In such a situation, we will use the `ziplongest`
    function from the `itertools` module. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Jupyter Notebook and create two lists of unequal length, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the final dictionary. `None` will be displayed as the value for the
    countries that do not have a capital in the capital''s list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should pause here for a second and think about how many lines of explicit
    code and difficult-to-understand `if-else` conditional logic we just saved by
    calling a single function and just giving it the two source data lists. It is
    indeed amazing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3edKtYf](https://packt.live/3edKtYf).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/37CsacU](https://packt.live/37CsacU).
  prefs: []
  type: TYPE_NORMAL
- en: With these exercises, we are ending the first topic of this chapter. Advanced
    list comprehension, generator expressions, and functions such as `zip` and `ziplongest`
    are some very important tricks that we need to master if we want to write clean,
    efficient, and maintainable code. Code that does not have these three qualities
    are considered subpar in the industry, and we certainly don't want to write such
    code.
  prefs: []
  type: TYPE_NORMAL
- en: However, we did not cover one important point here, that is, generators. Generators
    are a special type of function that shares behavioral traits with generator expressions.
    However, being functions, they have a broader scope and they are much more flexible.
    We strongly encourage you to learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about generators here: [https://wiki.python.org/moin/Generators](https://wiki.python.org/moin/Generators).'
  prefs: []
  type: TYPE_NORMAL
- en: Data Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will format a given dataset. The main motivations behind
    formatting data properly are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps all the downstream systems have a single and pre-agreed form of data
    for each data point, thus avoiding surprises and, in effect, there is no risk
    which might break the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To produce a human-readable report from lower-level data that is, most of the
    time, created for machine consumption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find errors in data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few ways to perform data formatting in Python. We will begin with
    the modulus `%` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The % operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python gives us the modulus `%` operator to apply basic formatting on data.
    To demonstrate this, we will load the data by reading the `combined_data.csv`
    file, and then we will apply some basic formatting to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `combined_data.csv` file contains some sample medical data for four individuals.
    The file can be found here: [https://packt.live/310179U](https://packt.live/310179U).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load the data from the CSV file by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a list called `raw_data` that contains all the rows of the CSV
    file. Feel free to print it to see what the content of the `.csv` file looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Partial output of raw data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Partial output of raw data'
  prefs: []
  type: TYPE_NORMAL
- en: We will be producing a report on this data. This report will contain one section
    for each data point and will report the name, age, weight, height, history of
    family disease, and finally the present heart condition of the person. These points
    must be clear and easily understandable English sentences.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Raw data in a presentable format'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: Raw data in a presentable format'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `%` operator is used in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: When used inside a quote, it signifies what kind of data to expect here. `%s`
    stands for string, whereas `%d` stands for integer. If we indicate a wrong data
    type, it will throw an error. Thus, we can effectively use this kind of formatting
    as an error filter in the incoming data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use the `%` operator outside the quote, it basically tells Python to
    start replacing all the data inside with the values provided for them outside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the format Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be looking at the exact same formatting problem, but
    this time, we will use a more advanced approach. We will use Python's `format`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `format` function, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Data formatted using the format function of the string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Data formatted using the format function of the string'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have replaced `%s` with `{}` and, instead of `%` outside the
    quote, we have called the `format` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how powerful the `format` function is by making the previous code
    a lot more readable and understandable. Instead of simple and blank `{}`, we mention
    the key names inside and then use the special Python `**` operation on a `dict`
    to unpack it and give that to the `format` function. It is smart enough to figure
    out how to replace the key names inside the quote with the values from the actual
    `dict` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Reading a file using the ** operation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Reading a file using the ** operation'
  prefs: []
  type: TYPE_NORMAL
- en: This approach is indeed much more concise and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.06: Data Representation Using {}'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, the `{}` notation inside the quote is powerful and we can
    change our data representation significantly by using it, which means we can apply
    basic data transformation such as printing up to a certain decimal place, changing
    binary to decimal numbers, and more just using this operator and without writing
    many lines of code. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change a decimal number into its binary form by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print a string that''s center oriented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Printing a string that''s center oriented, but this time with padding on both
    sides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we've already mentioned, the `format` statement is a powerful one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we saw how powerful the `{}` notation is and how its use can
    benefit data representation immensely.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dbNKpG](https://packt.live/3dbNKpG).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Ygm9zH](https://packt.live/2Ygm9zH).
  prefs: []
  type: TYPE_NORMAL
- en: '**Formatting Dates**'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to format a date as dates have various formats, depending on
    what the source of the data is, and it may need several transformations inside
    the data wrangling pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the familiar date formatting notations with `format` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Data after being formatted'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Data after being formatted'
  prefs: []
  type: TYPE_NORMAL
- en: Compare this with the actual output of `datetime.utcnow` and you will see the
    power of this expression easily.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and Cleaning Outliers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When confronted with real-world data, we often see a specific thing in a set
    of records: there are some data points that do not fit with the rest of the records.
    They have some values that are too big, too small, or that are completely missing.
    These kinds of records are called `outliers`.'
  prefs: []
  type: TYPE_NORMAL
- en: Statistically, there is a proper definition and idea about what an outlier means.
    And often, you need deep domain expertise to understand when to call a particular
    record an outlier. However, in this exercise, we will look into some basic techniques
    that are commonplace for flagging and filtering outliers in real-world data for
    day-to-day work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.07: Outliers in Numerical Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will construct a notion of an outlier based on numerical
    data. Imagine a cosine curve. If you remember the math for this from high school,
    then a cosine curve is a very smooth curve within the limit of `[1, -1]`. We will
    plot this cosine curve using the `plot` function of `matplotlib`. Let''s go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct a cosine curve, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot the data by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.7: Cosine wave'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_06_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.7: Cosine wave'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we can see, it is a very smooth curve, and there are no outliers. However,
    we are going to introduce some now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Introduce some outliers by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Plot the curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.8: Wave with outliers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_06_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.8: Wave with outliers'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we have successfully introduced two values in the curve, which
    broke the smoothness and hence can be considered as outliers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3fDRzFZ](https://packt.live/3fDRzFZ).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YEstj6](https://packt.live/2YEstj6).
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way to detect whether our dataset has an outlier is to create a box
    plot. A box plot is a way of plotting numerical data based on their central tendency
    and some `buckets` (in reality, we call them `quartiles`). In a box plot, the
    outliers are usually drawn as separate points. The `matplotlib` library helps
    draw box plots out of a series of numerical data, which isn''t hard at all. This
    is how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you execute the preceding code, you will be able to see that there is
    a nice box plot where the two outliers that we created are clearly shown, just
    like in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Box plot with outliers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Box plot with outliers'
  prefs: []
  type: TYPE_NORMAL
- en: Z-score
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `+3` or less than `-3` is considered an outlier. We can use this concept with
    a bit of help from the excellent SciPy and `pandas` libraries to filter out the
    outliers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use SciPy and calculate the z-score by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: The z-score values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: The z-score values'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have observed how to calculate a z-score. In the following exercise,
    we will learn how to use this to remove outliers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.08: The Z-Score Value to Remove Outliers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will demonstrate how to get rid of outliers in a set of data.
    In the previous exercise, we calculated the z-score of each data point. In this
    exercise, we will continue directly from the previous exercise and use the z-score
    values to remove outliers from our data. To do so, let''s go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `pandas` and create a DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign outliers with a `z-score` value of less than `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `print` function to print the new and old shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the two printed data points (`49, 1` and `50, 1`), it is clear that the
    derived DataFrame has two less rows. These are our outliers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2BgEzaf](https://packt.live/2BgEzaf).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2UXnZmV](https://packt.live/2UXnZmV).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Detecting and getting rid of outliers is a time consuming and critical process
    in any data wrangling pipeline. They need deep domain knowledge, expertise in
    descriptive statistics, mastery over the programming language (and all the useful
    libraries), and a lot of caution. We recommend being very careful when performing
    this operation on a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Levenshtein Distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`python-Levenshtein`.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional Software Required for This Section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for this exercise depends on two additional libraries. We need to
    install `SciPy` and `python-Levenshtein`, libraries. To install the libraries,
    type the following command in the running Jupyter Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re facing issues while installing the Levenshtein package, you can
    try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 6.09: Fuzzy String Matching'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will look into a slightly different problem that, at first
    glance, may look like an outlier. However, upon careful examination, we will see
    that it is indeed not, and we will learn about a useful concept that is sometimes
    referred to as fuzzy matching of strings. To do so, let''s go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the load data of a ship on three different dates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you look carefully, you will notice that the name of the ship is spelled
    differently in all three different cases. Let's assume that the actual name of
    the ship is `Sea Princess`. From a normal perspective, it does look like there
    has been a human error and that the data points do describe a single ship. Removing
    two of them on a strict basis of outliers may not be the best thing to do.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we simply need to import the `distance` function from it and pass two
    strings to it to calculate the distance between them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will notice that the distance between the strings is different. It is `0`
    when they are identical, and it is a positive integer when they are not. We can
    use this concept in our data wrangling jobs and say that strings with a distance
    less than or equal to a certain number is the same string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/37Lx3An](https://packt.live/37Lx3An).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3ehva0M](https://packt.live/3ehva0M).
  prefs: []
  type: TYPE_NORMAL
- en: Here, again, we need to be cautious about when and how to use this kind of fuzzy
    string matching. Sometimes, they are needed, and other times, they will result
    in a very bad bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Handling Outliers and Missing Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will identify and get rid of outliers. Here, we have a
    CSV file. The goal here is to clean the data by using the knowledge that we have
    learned about so far and come up with a nicely formatted DataFrame. Identify the
    type of outliers and their effect on the data and clean the messy data.
  prefs: []
  type: TYPE_NORMAL
- en: The dataset that we have used here can be found in the `visit_data.csv` file.
    This file contains data generated by a random data generator, and it contains
    people's names, their `gender`, `email_id`, `ip_address`, and the number of visits
    they made to a particular web page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The dataset can be found at [https://packt.live/2YajrLJ](https://packt.live/2YajrLJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps that will help you solve this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the `visit_data.csv` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for duplicates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether any essential column contains `NaN`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get rid of the outliers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Report the size difference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a box plot to check for outliers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get rid of any outliers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor320).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about interesting ways to deal with list data by
    using a generator expression. They are easy and elegant and, once mastered, they
    give us a powerful trick that we can use repeatedly to simplify several common
    data wrangling tasks. We also examined different ways to format data. Formatting
    data is not only useful for preparing beautiful reports – it is often very important
    to guarantee data integrity for the downstream system.
  prefs: []
  type: TYPE_NORMAL
- en: We ended this chapter by checking out some methods to identify and remove outliers.
    This is important for us because we want our data to be properly prepared and
    ready for all our fancy downstream analysis jobs. We also observed how important
    it is to take the time to and use domain expertise to set up rules for identifying
    outliers, as doing this incorrectly can do more harm than good.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to read web pages, XML files, and APIs.
  prefs: []
  type: TYPE_NORMAL
