- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graph Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we’ve considered networks as data structures that
    we can analyze to extract insight into data science problems. In this chapter,
    we’ll consider networks as data storage options, linking many pieces of information
    in a multi-relational way. Many storage options exist but we’ll focus on an open
    source option that integrates well with Python—**Neo4j**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to graph databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying and modifying data in Neo4j
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand the advantages of graph databases
    to store network science datasets, be able to visualize graph databases and know
    how to query them for the quick retrieval of relevant information. You’ll feel
    comfortable modifying tables by insertion and deletion. You’ll understand how
    the tools in our previous chapters can help you query efficiently to find relevant
    data. Let’s get started by exploring the rationale behind graph databases.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to graph databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Graph databases** (databases that store data in network form) offer many
    advantages over traditional relational databases. First, graph databases can capture
    and traverse hierarchical relationships. While relational databases can capture
    taxonomies, they do so in different columns that are not explicitly linked.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, graph databases capture complex relationships between items or
    groups of items explicitly by connecting them with edges. This allows for multiway
    relationships to exist within the database; querying for nearest neighbors, for
    instance, is much easier when neighbors are connected by an edge and do not require
    estimation steps to find **Euclidean** or **Manhattan distances** between all
    items in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, graph databases can capture the directionality of relationships
    between items in the database very easily. In a relational database, the directionality
    of a single relationship may involve several columns’ worth of information to
    capture that single relationship. Thus, for items with complicated relationships
    that may be unidirectional, a graph database provides a compact representation
    of data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, within graph databases, it is possible to mine the dataset for implicit
    relationships that have not been programmed into the database by using network
    algorithms to probe for similar patterns in different parts of a network or to
    infer edges that don’t exist based on triadic closure. For many datasets—such
    as continuously-growing *-omics* datasets, evolving ontologies, or other non-static
    datasets where knowledge is incomplete—mining the data provides new research avenues.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know a bit about the advantages of graph databases, let’s dive into
    specific differences between graph databases and relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: What is a graph database?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Graph databases are databases based on network science. Rather than storing
    data as columns in a spreadsheet (shown in the following figure), as is done in
    relational databases, graph databases store data as *networks*, with items that
    would occupy a row represented as a vertex connected to other vertices per relations
    that exist. Column data is used to either add metadata to the vertex or connect
    it to other vertices. Graph database queries rely on network science algorithms
    to traverse the graph, pattern-finding algorithms, and combinations of these two
    approaches. Thus, queries for graph databases can become quite sophisticated without
    necessarily leading to a long run-time as subqueries in SQL will require. Efficiency
    is a big advantage of graph databases. Let’s look at an example of supermarket
    customer feedback related to customer service or products, shown in *Figure 12**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.1 – An example of relational database design, where rows contain\
    \ items with information organized into columns\uFEFF (Used with permission from\
    \ Microsoft Excel)](img/B21087_12_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – An example of relational database design, where rows contain items
    with information organized into columns (Used with permission from Microsoft Excel)
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.1* shows a relational database with many rows of data that exist
    as columns. However, this data may be better represented as a graph database,
    where items relate through the columns or use columns as metadata in a queryable
    way. Perhaps there are dates attached to the comments that could link items by
    time and use the department related to the complaint as metadata.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is difficult to visualize a relational database, visualizing a graph
    database is much more straightforward. Some graph databases come with built-in
    visualization tools to zoom into areas of interest or query results. Some allow
    developers to build on pre-existing visualizations to tailor this feature to their
    needs. When hovering over edges and vertices, most graph database visualization
    tools will show metadata associated with a vertex or edge, providing context for
    the relationships of interest pulled by the query. Cytoscape is one of the most
    commonly used programs for network visualization at scale; originally, it was
    constructed to visualize proteomics datasets, where protein interactions are documented
    across organisms. Here’s Cytoscape with demo images of the example graphs: [https://js.cytoscape.org/](https://js.cytoscape.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of Cytoscape is its ability to handle saved igraph networks
    such that analysis of very large networks can be done in Python and then visualized
    with Cytoscape, where the network size will not complicate visualization as it
    will with the igraph plotting functions. In addition, Cytoscape offers a desktop
    version that should work with Java-based devices and a web interface version for
    those who do not have access to the desktop version. If you are interested, you
    are encouraged to download Cytoscape and test out its visualization either with
    the datasets we use in this book or with your own datasets of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the structure and advantages of graph databases, let’s
    dive into some datasets where a graph database may function better than a relational
    database with respect to organizing the information and retrieving information
    of interest.
  prefs: []
  type: TYPE_NORMAL
- en: What can you represent in a graph database?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many data science domains that can benefit from graph databases. We’ll
    explore a few of these use cases in depth before diving into coding in one open
    source graph database. Let’s start with an example from epidemiology.
  prefs: []
  type: TYPE_NORMAL
- en: Contact tracing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a new epidemic starts in an area, epidemiologists often employ a tool called
    **contact tracing**, where data on each case is collected to connect cases to
    each other in the hopes of finding the outbreak source, or patient zero. Patient
    zero often provides insight into the source of the epidemic—whether an animal
    vector, a laboratory breach, or an environmental disaster. Epidemiologists, then,
    can pinpoint effective containment policies and monitor potential sources to prevent
    future outbreaks.
  prefs: []
  type: TYPE_NORMAL
- en: In longer outbreaks where a virus has enough time to mutate, contact tracing
    allows epidemiologists to study the viral evolution of an outbreak. During the
    COVID-19 pandemic, we saw many mutations of COVID-19 with different rates of mortality
    and different symptomologies, some of which did not respond well to current vaccines
    or treatments to which prior strains had responded. Early identification of new
    mutations and their geographic sources provides crucial information for quick
    response across countries and continents.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example of contact tracing in a new HIV outbreak. Let’s say
    we are in a mid-sized city with many neighborhoods and subpopulations. Cases have
    popped up at several testing centers and hospitals over the past two months, and
    epidemiologists are concerned that the dominant strain in the area has mutated
    into a much deadlier strain of HIV, threatening the city. Two of the main ways
    that HIV spreads within a population are sexual contact and sharing syringes when
    using drugs intravenously; this hypothetical epidemic seems to be largely contained
    to young populations with high rates of drug use and risky sexual behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: When a case is identified, healthcare providers collect information about others
    potentially exposed to HIV through sexual contact or syringe sharing such that
    the person or the provider can inform those exposed that they are at risk of HIV.
    Positive cases are identified and traced to build a network of exposure. Typically,
    metadata, such as strain genomics, demographic factors, geographic histories,
    and exposure routes, is collected and attached to this network to quickly identify
    the main sources of spreading and populations most at risk given identified case
    characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining causality is not always straightforward. Oftentimes, cases are
    missed when individuals do not present with illness or do not get tested regularly.
    This means cases identified later in an epidemic might be sources of infection.
    *Figure 12**.2* shows a small piece of a contact tracing network, where cases
    identified later in the epidemic through contact tracing were infected earlier
    than the presenting individual (*Case #161*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – A small subsection of a contact tracing network](img/B21087_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – A small subsection of a contact tracing network
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 12**.2*, we see *Case #161* was identified (likely through a testing
    center or by seeking medical care). This individual’s contacts revealed infection
    from *Case #165*, who was infected by *Case #173*. Contact tracing also revealed
    another individual infected from *Case #165* (*Case #169*). Without contact tracing,
    at least three other cases would have been missed, leading to treatment delays
    and potentially more exposures and cases. Generally, causality is established
    through strain analysis and information about the timing of exposures through
    sexual partners or syringe sharing. These factors are included in the case metadata.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing case metadata and causality information in a relational database would
    be very difficult, as the directionality of infection is critical for studying
    epidemic evolution over the population and for contacting potential exposures
    who have not yet been tested (as case contacts can overlap and often do in this
    type of epidemic). Graph databases allow for efficient storage and retrieval of
    this information for maximal efficiency of both contact tracing and public policy
    formation to protect those at risk of HIV exposure in this population. Early identification
    saves people from suffering and, potentially, death.
  prefs: []
  type: TYPE_NORMAL
- en: Island ecology study
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know how graph databases improve analytics and outcomes for social
    science data, let’s consider how graph databases can improve research in conservation.
    Suppose scientists have identified a new island in a remote area long isolated
    from mainland populations. *Figure 12**.3* shows the hypothetical island:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.3 – An\uFEFF illustration of an island long isolated from the mainland](img/B21087_12_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – An illustration of an island long isolated from the mainland
  prefs: []
  type: TYPE_NORMAL
- en: On the island shown in *Figure 12**.3*, we wish to document the flora and fauna
    that live on that island, as well as the island’s food chains. We’ll collect information
    on population sizes, predator-prey relationships, and potential threats to those
    populations and relationships (such as climate change). We may wish to link species
    into food webs to explore the sustainability of food sources given changes in
    temperature, weather, and sea levels on the island. We may also wish to divide
    the island into separate ecosystems, which may be isolated in valleys with high
    cliffs or connected to other ecosystems on the island through migration patterns
    or habitat overlap. Food webs and overlapping habitat/migration patterns create
    relationships between population data in our dataset, which naturally lives as
    a network. We can add metadata to the vertices in our network (species or habitats)
    or the edges connecting them (such as seasonal information about migration patterns
    that might connect species from two different habitats periodically).
  prefs: []
  type: TYPE_NORMAL
- en: In this conservation example, we’ll likely have more than one dataset collected.
    We might have several different food webs from different geographies. We may also
    have habitat overlap datasets connecting geographies on the island that connect
    to our food webs, such as metadata on population size estimates, ecosystem health
    indicators, and seasonal patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting many datasets, some of which include hierarchical relationships,
    is quite tricky in relational databases; however, it is easy when using graph
    databases. Different types of edges can connect different vertices in collected
    networks to link each network and the metadata contained in each network collected.
    This makes querying and exploring potential relationships that are not explicitly
    defined (perhaps not collected due to time constraints or difficulty of terrain
    navigation) much easier for conservationists.
  prefs: []
  type: TYPE_NORMAL
- en: From this data and exploration of its graph database, it is possible to infer
    and define protected areas on the island in which many food webs connect or are
    isolated regions with large biodiversity. This protects species from human activities
    or climate change threats and allows researchers to focus limited funding on monitoring
    areas critical to the overall ecosystem. In addition, as further expeditions and
    conservation efforts collect new data, the graph database setup allows researchers
    to test hypothesized links between ecosystems or food webs that were not directly
    observed in the first pass expedition.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand a bit about datasets that will benefit from graph database
    storage solutions, let’s turn our attention to Neo4j, an open source graph database
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Querying and modifying data in Neo4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start using Neo4j, we’ll need to download and install the software
    on our machines. You can follow this link to reach the Neo4j Desktop download
    page: [https://neo4j.com/download/](https://neo4j.com/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a page that looks like this, where you can download Neo4j by
    clicking on the **Download** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Neo4j download site](img/B21087_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Neo4j download site
  prefs: []
  type: TYPE_NORMAL
- en: 'After hitting the **Download** button in *Figure 12**.4*, you’ll be prompted
    to follow the installer instructions to complete the installation. When the installer
    finishes, you’ll see an icon or will have launched Neo4j directly on your machine
    from the installation process. This should take you to a page that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – The start page of Neo4j](img/B21087_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – The start page of Neo4j
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.5* shows the free Desktop version of Neo4j on a Windows machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is already an example project ready to explore or query.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll work on some basic queries with this data, but if you wish to explore
    this database prior to querying, click on **Movie DBMS** and hit the **Start**
    button to run the database on your machine; when you finish exploring, make sure
    to hit the **Stop** button to cache the database again.
  prefs: []
  type: TYPE_NORMAL
- en: The query language used by Neo4j is called `Match` command functions much like
    SQL’s `SELECT` command, and operations such as `limit` and `as` also exist in
    Cypher. However, operations that retrieve directional relationships (edges) between
    objects in the database (vertices) also exist to query specific types of relationships
    that might exist. We’ll see more of this in action as we explore the Movie DBMS
    (database management system) database on Neo4j’s Desktop application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore Neo4j.
  prefs: []
  type: TYPE_NORMAL
- en: Basic query example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you open your Neo4j Desktop application, you’ll see an `Example Project`
    folder. When you hover over the **Movie DBMS** label on the right-hand side of
    the screen, you’ll see a **Start** button that launches the connection to this
    database (shown in *Figure 12**.6*). Click on **Start**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – The Start button to launch the Movie DBMS database](img/B21087_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – The Start button to launch the Movie DBMS database
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 12**.6*, once you have launched the Movie DBMS database
    by clicking `about-movies.neo4j-browser-guide` file option and run through a few
    examples of queries to become familiar with Cypher’s syntax and results.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see a page like *Figure 12**.7* when you click on the `about-movies.neo4j-browser-guide`
    file option. The first page shows a basic query pulling data on an actor. Here,
    we’ll change the actor to `Brad Pitt` and query the graph for instances of `Brad
    Pitt`. When you have the code changed to what is shown in *Figure 12**.7*, hit
    the arrow to run the code. Note that you’ll see the default tutorial below the
    code you write. We aren’t showing this in our Neo4j query images but it will appear
    on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – A basic Cypher query that searches for Brad Pitt](img/B21087_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – A basic Cypher query that searches for Brad Pitt
  prefs: []
  type: TYPE_NORMAL
- en: 'This database does not contain any information about Brad Pitt. Running the
    suggested query on `Tom Hanks` does produce information in JSON form, as this
    data does not contain graph elements. You should see something like *Figure 12**.8*
    when you query the database for `Tom Hanks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The result of our query for Tom Hanks in Movie DBMS](img/B21087_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – The result of our query for Tom Hanks in Movie DBMS
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go to the next page of the guide and add an actor to the database. We’ll
    add Brad Pitt, as our query came back empty initially. *Figure 12**.9* shows how
    to add an actor to the database along with their birth year.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Instructions to create an entry for Brad Pitt](img/B21087_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Instructions to create an entry for Brad Pitt
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the code from *Figure 12**.9*, Neo4j shows us a vertex with Brad
    Pitt’s information, as seen in *Figure 12**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – The result of creating Brad Pitt’s entry](img/B21087_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – The result of creating Brad Pitt’s entry
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a movie associated with `Brad Pitt`, in this case, `Seven Years
    in Tibet`, as shown in *Figure 12**.11*’s code in the top line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Cypher code to add a movie associated with Brad Pitt](img/B21087_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Cypher code to add a movie associated with Brad Pitt
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this Cypher code, we see another graph database vertex appear,
    as shown in *Figure 12**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – The result of running the Cypher query from Figure 12.11](img/B21087_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – The result of running the Cypher query from Figure 12.11
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we can add to our graph database, we can also delete individual records
    from the database. Let’s delete the records we just created for `Brad Pitt`. *Figure
    12**.13* shows the deletion of the record for `Brad Pitt`. I urge you to try deleting
    `Seven Years in Tibet` before moving on to the next task in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Cypher code to delete the record we created for Brad Pitt](img/B21087_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Cypher code to delete the record we created for Brad Pitt
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create or update a record in the database using the `MERGE` statement
    with a `CREATE` and a `MATCH` statement to either create a new record or update
    an existing record (depending on what exists in the database). We’ll add Brad
    Pitt’s information back into the database using the code shown in *Figure 12**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – An updated example in Cypher code](img/B21087_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – An updated example in Cypher code
  prefs: []
  type: TYPE_NORMAL
- en: When we run the code in *Figure 12**.14*, we see *Figure 12**.9* appear again,
    where Brad Pitt’s information has been added to the database. Now that we know
    some basic Cypher commands, we can move on to more complicated graph database
    operations in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: More complicated query examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to execute basic queries, we can move on to more complicated
    operations in Neo4j, such as adding relationships between items. Let’s connect
    actors and movies with a Cypher query connecting Brad Pitt to *Seven Years in
    Tibet* through his character, Heinrich Harrer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to add both the movie and actor back into our database using the
    code in the *Basic query example* section before running this query. This query
    is shown in *Figure 12**.15*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – A Cypher query to connect Brad Pitt to his character, Heinrich
    Harrer, in Seven Years in Tibet ](img/B21087_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – A Cypher query to connect Brad Pitt to his character, Heinrich
    Harrer, in Seven Years in Tibet
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this query returns information about the actor, the movie, and the
    relationship we just created between the two datasets, as shown in *Figure 12**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – The result of Figure 12.15’s Cypher query to connect Brad
    Pitt to Seven Years in Tibet](img/B21087_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – The result of Figure 12.15’s Cypher query to connect Brad Pitt
    to Seven Years in Tibet
  prefs: []
  type: TYPE_NORMAL
- en: The next page of the Neo4j Cypher guide shows an alternative way to create this
    relationship. You are encouraged to modify that code to add another actor and
    movie as an exercise. Let’s turn our attention to Cypher’s `WHERE` clauses, which
    function much as they do in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll search for persons whose names start with the first name `Brad`, which
    should pull up Brad Pitt’s entry, as well as any other actors whose first name
    is Brad. *Figure 12**.17* shows this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – An example of a WHERE query in Cypher](img/B21087_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – An example of a WHERE query in Cypher
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the Cypher code in *Figure 12**.17*, we should see two instances
    of `Brad Pitt` showing up in our database, as shown in *Figure 12**.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – Results from Figure 12.17’s WHERE Cypher query](img/B21087_12_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.18 – Results from Figure 12.17’s WHERE Cypher query
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also match based on relationships, such as finding movies associated
    with an actor. Let’s try a Cypher query on relationships to find all of the movies
    associated with Brad Pitt (here, just `Seven Years in Tibet`, as we added this
    relationship). *Figure 12**.19* shows the query we’ll use to query a relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – A Cypher query on graph relationships between people and movies](img/B21087_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – A Cypher query on graph relationships between people and movies
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the Cypher query shown in *Figure 12**.19*, we see the connections
    between our instances of `Brad Pitt` and `Seven Years in Tibet` shown in graph
    form (*Figure 12**.20*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – The results of Figure 12.19’s graph relationship query](img/B21087_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – The results of Figure 12.19’s graph relationship query
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.20* shows the essential strengths of a graph database. We can
    see relationships that connect different items across tables (here, the `Person`
    table and the `Movie` table), as well as the nature of that relationship. It’s
    easy to see an actor connected to a movie, and should more movies exist, we’d
    have an easy visualization of our query results from this graph-based query in
    Neo4j.'
  prefs: []
  type: TYPE_NORMAL
- en: While this movie database contains basic tables and relationships, we can imagine
    our examples in the *What can you represent in a graph database?* section containing
    much more complicated relationships between many more tables. Visualizing query
    results in graph form across tables and items in tables provides easy-to-understand
    summaries of the data and relationships of interest in a query. Herein lies the
    power of graph databases. Queries tend to be quick, even for queries with many
    subqueries or when searching very large tables and their relations, and visualizations
    of results allow users to explore relationships in depth across tables (or provide
    succinct visuals for a report).
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to explore Neo4j further, Neo4j’s AuraDB allows users to connect
    to the database through Python by establishing an account and connecting to Neo4j
    with an API in Python using the `neo4j` package and `GraphDatabase.driver()` function
    to create the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For any large databases or databases you wish to permanently save, you’ll need
    a paid account.
  prefs: []
  type: TYPE_NORMAL
- en: Once the database is created, you can query the Neo4j database through Python’s
    `neo4j driver.execute_query()` statement and import the data as a network in igraph
    to analyze the results. This provides a powerful combination of graph storage
    and graph analysis for your analytics projects. If you are interested, you are
    encouraged to explore Neo4j further and create your own connected projects between
    igraph and Neo4j’s AuraDB accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined cases where graph databases are advantageous, familiarized
    ourselves with an open source graph database called Neo4j, and learned a bit about
    the query language of Neo4j, called Cypher. We created, deleted, and modified
    records in a Neo4j movie database. We explored the advantages of querying graph
    databases and the unique query result visualizations possible with graph databases.
    If you are interested, I encourage you to consult Cypher and Neo4j resources to
    dive deeper into what is possible with graph databases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll be putting together all of the skills we’ve learned
    in the book so far to tackle a real-world problem of predicting Ebola outbreak
    severity over time and geography across regions of the Democratic Republic of
    Congo.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adler, M. W., and Johnson, A. M. (1988). *Contact tracing for HIV infection*.
    *British Medical Journal (Clinical research ed.)*, *296*(6634), 1420.
  prefs: []
  type: TYPE_NORMAL
- en: Angles, R., Arenas, M., Barceló, P., Hogan, A., Reutter, J., and Vrgoč, D. (2017).
    *Foundations of modern query languages for graph databases*. *ACM Computing Surveys
    (CSUR)*, *50*(5), 1–40.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beas-Luna, R., Novak, M., Carr, M. H., Tinker, M. T., Black, A., Caselle, J.
    E., ... and Iles, A. (2014). *An online database for informing ecological network
    models*: [http://kelpforest](http://kelpforest). ucsc. edu. *PloS one*, *9*(10),
    e109356.'
  prefs: []
  type: TYPE_NORMAL
- en: Hyman, J. M., Li, J., and Stanley, E. A. (2003). *Modeling the impact of random
    screening and contact tracing in reducing the spread of HIV*. *Mathematical biosciences*,
    *181*(1), 17–54.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mueller, W., Rudowicz-Nawrocka, J., Otrzasek, J., Idziaszek, P., and Weres,
    J. (2016). *Spatial data and graph databases for identifying relations among members
    of cattle herd*. *International Multidisciplinary Scientific GeoConference: SGEM*,
    *1*, 835–841.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pasquale, D. K., Doherty, I. A., Leone, P. A., Dennis, A. M., Samoff, E., Jones,
    C. S., ... and Miller, W. C. (2021). *Lost and found: applying network analysis
    to public health contact tracing for HIV*. *Applied network science*, *6*, 1–16.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pokorný, J. (2015). *Graph databases: their power and limitations*. In *Computer
    Information Systems and Industrial Management: 14th IFIP TC 8 International Conference,
    CISIM 2015, Warsaw, Poland, September 24-26, 2015, Proceedings 14* (pp. 58-69).
    Springer International Publishing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Robinson, I., Webber, J., and Eifrem, E. (2015). *Graph databases: new opportunities
    for connected data*. O’Reilly Media, Inc..'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shannon, P., Markiel, A., Ozier, O., Baliga, N. S., Wang, J. T., Ramage, D.,
    ... and Ideker, T. (2003). *Cytoscape: a software environment for integrated models
    of biomolecular interaction networks*. *Genome research*, *13* (11), 2498–2504.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Webber, J. (2012, October). *A programmatic introduction to neo4j*. In *Proceedings
    of the 3rd annual conference on Systems, programming, and applications: software
    for humanity* (pp. 217–218).'
  prefs: []
  type: TYPE_NORMAL
