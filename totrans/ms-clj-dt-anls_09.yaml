- en: Chapter 9. Analyzing Social Data Participation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：分析社交数据参与
- en: Social networks and websites have revolutionized the Internet. Most people online
    participate in some social network, either it's **Facebook**, **Twitter**, **Pinterest**,
    **GitHub**, **StackOverflow**, or any of the zillion other social networking websites
    that have sprung up. They're an important way for people to connect and stay in
    contact, but they're also a major source of data about people's relationships
    and activities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络和网站已经彻底改变了互联网。大多数在线人士都参与了一些社交网络，无论是 **Facebook**、**Twitter**、**Pinterest**、**GitHub**、**StackOverflow**，还是成千上万的社交网站之一。它们是人们连接和保持联系的重要方式，但它们也是关于人们关系和活动的主要数据来源。
- en: Analyzing this data is important for a number of reasons. Of course, advertisers
    and marketers want to squeeze as much information out of the data as they can.
    But if you're running the social network, you'll want to analyze the data to figure
    out what's working and what's falling flat. You want to ask yourself constantly
    what you can do to engage users better and to make your social network a more
    compelling, enjoyable, or useful experience for your users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 分析这些数据有几个重要的原因。当然，广告商和营销人员希望从数据中提取尽可能多的信息。但如果你在运营社交网络，你将想要分析数据以找出哪些地方做得好，哪些地方做得不好。你不断地问自己，你能做些什么来更好地吸引用户，让你的社交网络对你的用户来说更加吸引人、有趣或有用。
- en: Over the course of this chapter, we'll get an open data dump from the **StackExchange**
    ([http://stackexchange.com](http://stackexchange.com)) website. This includes
    StackOverflow ([http://stackoverflow.com/](http://stackoverflow.com/)) and a host
    of other question-and-answer sites. We'll analyze this in a number of different
    ways and try to learn both about how people interact and generate content on those
    sites and about what makes a good answer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将从 **StackExchange** ([http://stackexchange.com](http://stackexchange.com))
    网站获取公开数据。这包括 StackOverflow ([http://stackoverflow.com/](http://stackoverflow.com/))
    和许多其他问答网站。我们将以多种不同的方式分析这些数据，并试图了解人们在那些网站上如何互动和生成内容，以及什么因素使一个答案变得出色。
- en: 'The following are the topics we are going to cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将要涵盖以下主题：
- en: Understanding the analyses we can perform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解我们可以进行的分析
- en: Getting the data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据
- en: Finding patterns of participation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现参与模式
- en: Comparing askers and answerers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较提问者和回答者
- en: Finding participation patterns over time
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现随时间变化的参与模式
- en: Finding up-voted answers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现被点赞的答案
- en: Tagging questions automatically
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动标记问题
- en: Setting up the project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Before we get started, let''s set up the project. I''ve done this using Leiningen
    2 ([http://leiningen.org/](http://leiningen.org/)) and Stuart Sierra''s reloaded
    project template ([https://github.com/stuartsierra/reloaded](https://github.com/stuartsierra/reloaded)).
    I named the project `social-so` by running the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们设置一下项目。我使用 Leiningen 2 ([http://leiningen.org/](http://leiningen.org/))
    和 Stuart Sierra 的 reloaded 项目模板 ([https://github.com/stuartsierra/reloaded](https://github.com/stuartsierra/reloaded))
    来完成这项工作。通过运行以下代码，我将项目命名为 `social-so`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Of course, we''ll need more dependencies. The following is the `project.clj`
    file for this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要更多的依赖项。以下是该章节的 `project.clj` 文件：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The highlights here are that we'll use `org.clojure/data.xml` to read XML files,
    `org.clojure/data.json` to read JSON, and `org.jsoup/jsoup` to clean up HTML.
    If you're still using Java 6, you'll need `jsr166y` to provide concurrency with
    the reducers library. And we'll use `cc.mallet/mallet` to handle some Naïve Bayesian
    classification.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一些亮点是，我们将使用 `org.clojure/data.xml` 来读取 XML 文件，`org.clojure/data.json` 来读取
    JSON，以及 `org.jsoup/jsoup` 来清理 HTML。如果你仍在使用 Java 6，你需要 `jsr166y` 来提供与 reducers
    库的并发性。我们还将使用 `cc.mallet/mallet` 来处理一些朴素贝叶斯分类。
- en: Understanding the analyses
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解分析
- en: Now that we have the infrastructure out of the way, let's step back and think
    about what kind of data we have and what we can do with it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了基础设施问题，让我们退后一步，思考我们有什么样的数据以及我们可以用它做什么。
- en: Understanding social network data
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解社交网络数据
- en: 'Social networks come in two broad kinds:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络大致分为两大类：
- en: There are **networking-oriented** social networks. These include the usual subjects,
    such as Facebook ([http://facebook.com](http://facebook.com)), LinkedIn ([http://linkedin.com](http://linkedin.com)),
    Twitter ([http://twitter.com/](http://twitter.com/)), or Sina Weibo ([http://weibo.com](http://weibo.com)).
    These focus on allowing people to connect with each other, build relationships,
    and post updates about themselves.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也有一些以网络为导向的社会网络。这些包括Facebook（[http://facebook.com](http://facebook.com)）、LinkedIn（[http://linkedin.com](http://linkedin.com)）、Twitter（[http://twitter.com/](http://twitter.com/)）或新浪微博（[http://weibo.com](http://weibo.com)）。这些网络专注于让人们相互连接，建立关系，并发布关于自己的更新。
- en: There are **knowledge-sharing-oriented** social networks. These include the
    StackExchange ([http://stackexchange.com](http://stackexchange.com)) family of
    social networks, including StackOverflow ([http://stackoverflow.com](http://stackoverflow.com))
    or Quora ([https://www.quora.com/](https://www.quora.com/)). These focus on allowing
    people to exchange information and knowledge. Usually, they are more structured
    and focused on questions and answers than web forums or wikis.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在一些以知识分享为导向的社会网络。这些包括StackExchange（[http://stackexchange.com](http://stackexchange.com)）家族的社会网络，包括StackOverflow（[http://stackoverflow.com](http://stackoverflow.com)）或Quora（[https://www.quora.com/](https://www.quora.com/)）。这些网络专注于让人们交换信息和知识。通常，它们比网络论坛或维基更注重结构和问题与答案。
- en: Obviously, these networks enable entirely different kinds of interactions and
    have different features and produce different kinds of data. Different kinds of
    analyses are appropriate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些网络能够实现完全不同类型的互动，具有不同的功能和产生不同类型的数据。适合进行不同类型的分析。
- en: Understanding knowledge-based social networks
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解基于知识的社会网络
- en: In knowledge-based social networks, people come together to share information.
    Often, these are question-and-answer forums, such as the StackExchange network
    of sites, but also on **Quora** ([https://www.quora.com/](https://www.quora.com/)),
    **Yahoo Answers** ([http://answers.yahoo.com/](http://answers.yahoo.com/)), and
    so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于知识的社会网络中，人们聚集在一起分享信息。通常，这些是问答论坛，如StackExchange网站网络，但也包括Quora（[https://www.quora.com/](https://www.quora.com/)）、Yahoo
    Answers（[http://answers.yahoo.com/](http://answers.yahoo.com/)）等等。
- en: Generally, in this genre of social network, some users post questions. Others
    answer them. There's usually some kind of in-site economy, whether it's represented
    by badges, points, or some combination. This encourages people to keep both questions
    and answers on topic, to answer questions, and to set and maintain the community's
    tone. Sometimes, there are moderators, sometimes the communities are self-moderated,
    and sometimes there's a combination of the two.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这个类型的社会网络中，一些用户会提问。其他人会回答这些问题。通常，会有某种形式的站内经济，无论是以徽章、积分或某种组合的形式。这鼓励人们保持问题和答案的相关性，回答问题，并设定和维护社区的风格。有时，有管理员，有时社区是自我管理的，有时两者兼而有之。
- en: 'Looking at the front page of StackOverflow, we can see the basic elements of
    the social network. Look at the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 观察StackOverflow的前页，我们可以看到社交网络的基本元素。看看下面的截图：
- en: '![Understanding knowledge-based social networks](img/4139OS_09_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![理解基于知识的社会网络](img/4139OS_09_01.jpg)'
- en: 'The preceding screenshot depicts a very interesting layout. You can easily
    notice the following two things:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图展示了一个非常有趣的布局。你可以很容易地注意到以下两点：
- en: There's a button labeled **Ask Question** at the upper right-hand side for posting
    a question. This isn't as large as you might expect, since those asking questions
    are presumably motivated to find the button and are willing to click through into
    another page to do it. This is different than the posting boxes found on sites
    such as Facebook or Twitter, where they try to reduce the friction for posting
    new statuses in order to encourage people to do it.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面的右上角有一个标记为“提问”的按钮，用于发布问题。这个按钮可能没有你想象的那么大，因为提问的人可能是有动机找到这个按钮并愿意点击进入另一个页面来提问的。这与Facebook或Twitter等网站上发现的发布框不同，这些网站试图减少发布新状态时的摩擦，以鼓励人们这样做。
- en: There is also a list of recently posted questions. This can be filtered to display
    tags that you're interested in. For example, you can use this to find either questions
    that you are qualified to answer or those you are interested in learning about
    yourself.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也有一个最近发布的问答列表。这个列表可以根据你感兴趣的标签进行筛选。例如，你可以用它来找到你能够回答的问题，或者你感兴趣学习的问题。
- en: So we can see immediately that the primary interactions of the site are accessible
    from the front page. Also, the site's design makes it easier to do the more difficult
    interaction (answering questions).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以立即看出，该网站的主要交互功能都可以从首页访问。此外，网站的设计使得进行更复杂的交互（如回答问题）变得更加容易。
- en: We can already guess that most users will join to post only one or two questions
    and never participate on the site again. This group may potentially be quite large.
    Who those users are and how to motivate them to answer questions may be one critical
    question that StackExchange has.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以猜测，大多数用户将只加入来发布一到两个问题，然后永远不会再次参与网站。这个群体可能相当大。这些用户是谁以及如何激励他们回答问题可能是StackExchange面临的一个关键问题。
- en: There may also be a similar dynamic among the users who do answer questions.
    There are probably a small number of users who answer most of the questions. StackExchange
    may be interested in how to get contributions more evenly from all users, not
    just from a few *power users*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答问题的用户中也可能存在类似的动态。可能只有少数用户回答了大部分问题。StackExchange可能对如何从所有用户那里获得更均匀的贡献感兴趣，而不仅仅是来自少数**高级用户**。
- en: Introducing the 80/20 rule
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍80/20法则
- en: In fact, both of these observations are examples of the general principle of
    social networks. This has been called the **80/20** rule. This simply states that
    approximately 80 percent of the content will be created by 20 percent of the users.
    It's also known as the **Pareto Principle**, which states more generally that
    80 percent of the effects come from 20 percent of the causes. Although in different
    social networks, the details may be off—for example, 15 percent of the users may
    create 95 percent of the content—in general this observation is surprisingly robust.
    One of the things that we'll look at in this chapter is exactly how the 80/20
    rule applies to the StackOverflow data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两个观察结果都是社交网络一般原则的例子。这被称为**80/20**法则。这简单地说，大约80%的内容将由20%的用户创建。它也被称为**帕累托法则**，更普遍地指出80%的效果来自20%的原因。尽管在不同的社交网络中，细节可能有所不同——例如，15%的用户可能创造了95%的内容——但总体上，这个观察结果是惊人的稳健。在本章中，我们将探讨80/20法则如何应用于StackOverflow数据。
- en: With this in mind, let's get the data so we can start looking at it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们获取数据，以便我们可以开始查看它。
- en: Getting the data
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取数据
- en: In this chapter, we're going to focus on knowledge-based social networks, and
    in particular, we'll work with the StackExchange sites. For some time, StackExchange
    has made public a periodic data dump of their sites ([http://blog.stackexchange.com/category/cc-wiki-dump/](http://blog.stackexchange.com/category/cc-wiki-dump/)).
    This will provide a great test bed for working with a social network site's data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于基于知识的社交网络，特别是我们将与StackExchange网站合作。一段时间以来，StackExchange已经公开了其网站的定期数据存档（[http://blog.stackexchange.com/category/cc-wiki-dump/](http://blog.stackexchange.com/category/cc-wiki-dump/))。这将提供一个极好的测试平台，用于处理社交网络网站的数据。
- en: The data dump is made available through the **Internet Archive** ([https://archive.org/](https://archive.org/)).
    The webpage for that is currently at [https://archive.org/details/stackexchange](https://archive.org/details/stackexchange).
    You can download the entire dump using a **BitTorrent** client ([http://www.bittorrent.com/](http://www.bittorrent.com/))
    such as **μTorrent** ([http://www.utorrent.com/](http://www.utorrent.com/)). However,
    we're only interested in the StackOverflow posts and comments, so if you'd like,
    you can just download those two archives. Of course, combined they're about 6
    GB, so the torrent may make the most sense, anyway.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存档通过**互联网档案馆**([https://archive.org/](https://archive.org/))提供。该网页目前位于[https://archive.org/details/stackexchange](https://archive.org/details/stackexchange)。您可以使用**BitTorrent**客户端（[http://www.bittorrent.com/](http://www.bittorrent.com/)）如**μTorrent**([http://www.utorrent.com/](http://www.utorrent.com/))下载整个存档。然而，我们只对StackOverflow的帖子及评论感兴趣，所以如果您愿意，您只需下载这两个存档。当然，合并后大约有6GB，所以使用种子可能更合适。
- en: '![Getting the data](img/4139OS_09_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![获取数据](img/4139OS_09_02.jpg)'
- en: The archived files are compressed using the 7z format. Windows users can get
    a utility for extracting this from the **7-zip** site ([http://www.7-zip.org/](http://www.7-zip.org/)).
    That site's download page also has links to some unofficial binaries for Mac OS
    X and Linux ([http://www.7-zip.org/download.html](http://www.7-zip.org/download.html)).
    Both of these platforms also have command-line binaries available. For example,
    **Homebrew** ([http://brew.sh/](http://brew.sh/)) has a recipe for this named
    **p7zip**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 存档文件使用 7z 格式压缩。Windows 用户可以从 **7-zip** 网站获取一个用于提取的工具（[http://www.7-zip.org/](http://www.7-zip.org/)）。该网站的下载页面还链接到一些非官方的二进制文件，适用于
    Mac OS X 和 Linux（[http://www.7-zip.org/download.html](http://www.7-zip.org/download.html)）。这两个平台也都有命令行二进制文件可用。例如，**Homebrew**
    ([http://brew.sh/](http://brew.sh/)) 有一个名为 **p7zip** 的配方。
- en: 'Extract this data into your project directory, into a subdirectory named `data`,
    using the following lines of code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码将这些数据提取到您的项目目录中，到名为 `data` 的子目录中：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we're ready to start digging into the data and see what surprises it has
    for us.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始深入挖掘数据，看看它对我们有什么惊喜。
- en: Looking at the amount of data
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看数据量
- en: First, we need to see how much data there will be. The raw archive for this
    part of the data is about 6 GB. Not insignificant, but it's not petabytes, either.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们需要看看会有多少数据。这部分数据的原始存档大约有 6 GB。不算小，但也不是以皮为单位。 '
- en: So the compressed file is almost 5 GB, and the expanded file is 23 GB! We have
    a lot of data to look at.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，压缩文件接近 5 GB，展开的文件是 23 GB！我们有很多数据要查看。
- en: Looking at the data format
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查看数据格式
- en: All of the files are in XML format. The file labeled `Posts` contains both the
    questions and the answers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文件都是 XML 格式。标记为 `Posts` 的文件包含问题和答案。
- en: 'The format of the data is fairly simple (but for a full description, see the
    `README.txt` file). The following is the first entry:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的格式相当简单（但完整描述请见 `README.txt` 文件）。以下是最初的条目：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see from `README.txt`, this post represents a question (the `PostTypeId`
    field is `1`). We can see its body, its tags, and its accepted answer, as well
    as a lot of the metadata about this post. This should give us plenty to go on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从 `README.txt` 中所见，这篇帖子代表一个问题（`PostTypeId` 字段为 `1`）。我们可以看到其正文、其标签和其接受答案，以及关于这个帖子的许多元数据。这应该给我们提供很多信息。
- en: 'If we look at the third entry, we''ll see one of the accepted answers for this
    post, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看第三条记录，我们将看到这个帖子的一个接受答案，如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, for answers (the `PostTypeId` field is 2), we can get their parents, their
    body texts, and their scores. Their parents indicate which child was accepted.
    This should be enough to help us analyze their content.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于答案（`PostTypeId` 字段为 2），我们可以获取它们的父级、正文文本和评分。它们的父级指示哪个子级被接受。这应该足以帮助我们分析它们的内容。
- en: In both cases, we also have `OwnerUserId`, and this will help us understand
    how people interact with the site and with each other.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们也有 `OwnerUserId`，这将帮助我们了解人们如何与网站以及彼此互动。
- en: The text-field attributes allow rich content (`Body` and `Title`), and these
    are handled by encoding HTML into the fields. We'll need to escape those and probably
    scrub out the tags. That won't be a problem, but we'll need to keep it in mind.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字段属性允许丰富的内容（`Body` 和 `Title`），这些内容通过将 HTML 编码到字段中来进行处理。我们需要转义这些内容，并可能清除标签。这不会是问题，但我们必须要记住。
- en: Defining and loading the data
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和加载数据
- en: We can trace out some of the data that we'll need to use throughout this chapter.
    We can put these into the `src/social_so/data.clj` file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以追踪出本章中需要使用的一些数据。我们可以将这些放入 `src/social_so/data.clj` 文件中。
- en: 'We''ll use two record types. The `CountRank` type will hold together a raw
    count and its rank in the list of frequencies, and the `UserInfo` type will store
    the user and the frequencies and ranks for the different types of posts that they''ve
    made. Look at the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种记录类型。`CountRank` 类型将保存原始计数及其在频率列表中的排名，而 `UserInfo` 类型将存储用户及其所发布不同类型帖子的频率和排名。看看下面的代码：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `post`, `q`, and `a` fields will keep track of the frequencies and rank
    by all posts, by question posts, and by answer posts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`post`、`q` 和 `a` 字段将跟踪所有帖子、问题帖子和回答帖子的频率和排名。'
- en: Together, these record structures should help us get a start in understanding
    this data and some of the patterns of participation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些记录结构一起应该帮助我们开始理解这些数据以及一些参与模式。
- en: 'For loading the data, let''s move to a new file, named `src/social_so/xml.clj`,
    and let''s give it the following namespace declaration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加载数据，让我们移动到一个新文件，命名为`src/social_so/xml.clj`，并给它以下命名空间声明：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We'll use the functions in this namespace to read the XML file and build the
    records containing the data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此命名空间中的函数来读取XML文件并构建包含数据的记录。
- en: 'At the most basic level, we need to be able to read the post elements from
    the XML file. Look at the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本层面上，我们需要能够从XML文件中读取帖子元素。看看下面的代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll also need to access a little bit of data from each element. The following
    are some getter functions for an identifier for the user and for the post type
    code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要访问每个元素的一些数据。以下是一些用于用户标识符和帖子类型代码的getter函数：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this snippet, `el` represents the XML element being processed, and we're
    using a custom function to lowercase the string (`social-so.utils`/`to-lower`)
    to be a little defensive about being passed `null` values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`el`代表正在处理的XML元素，我们使用一个自定义函数将字符串转换为小写（`social-so.utils`/`to-lower`）来稍微防御性地处理传递的`null`值。
- en: Loading the data from the XML files will take place in two stages. First, we'll
    get the raw frequencies, and then we'll sort the data several different ways and
    assign ranks to the data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据将从两个阶段进行。首先，我们将获取原始频率，然后我们将以几种不同的方式对数据进行排序并分配排名。
- en: Counting frequencies
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算频率
- en: The way that we'll count the frequencies is to walk over the posts in the XML
    file. We'll maintain an index of the users with their `UserInfo` records. The
    first time each user is found, they will get a new `UserInfo` object. Subsequently,
    their `UserInfo` record will be updated with new counts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计数频率的方式是遍历XML文件中的帖子。我们将维护一个包含用户及其`UserInfo`记录的索引。当每个用户首次被发现时，他们将获得一个新的`UserInfo`对象。随后，他们的`UserInfo`记录将使用新的计数进行更新。
- en: Let's see how this works in practice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实践中是如何工作的。
- en: 'The first function, `update-user-info`, operates on the level of a single record.
    It takes a `UserInfo` record and updates it based on the type of post currently
    being processed. If the record is nil, then a new one is created follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`update-user-info`在单个记录级别上操作。它接受一个`UserInfo`记录并根据当前正在处理的帖子类型更新它。如果记录为nil，则创建一个新的记录：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next function operates at the level of the index from `user-id` to `UserInfo`
    records. It takes an XML post, and it gets the user''s information from it. It
    tries to retrieve the `UserInfo` record for that user from the index, and it uses
    `update-user-info` to increment the counts in that record. Look at the following
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数在`user-id`到`UserInfo`记录的索引级别上操作。它接受一个XML帖子，并从中获取用户信息。它尝试从索引中检索该用户的`UserInfo`记录，并使用`update-user-info`在该记录中增加计数。看看下面的代码：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, `load-user-infos` opens the XML file, reads in the posts, and counts
    the raw frequencies of the posts for each user. Finally, it forces the result
    with `doall`, because we''re working inside of a `with-open` block, so we''ll
    want to have the results fully realized before we close the file. Look at the
    following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`load-user-infos`函数打开XML文件，读取帖子，并为每个用户计算帖子的原始频率。最后，它使用`doall`强制输出结果，因为我们正在`with-open`块内部工作，所以我们希望在关闭文件之前完全实现结果。看看下面的代码：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we're ready to walk over these, multiple times, and assign ranks based on
    the various counts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备遍历这些记录，多次分配基于各种计数的排名。
- en: Sorting and ranking
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序和排名
- en: 'Currently, we''re storing the raw frequency under the `UserInfo` records''
    fields. However, we want to move the frequencies into a `CountRank` record and
    store the rank alongside it. We will achieve this by performing the following
    steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在将原始频率存储在`UserInfo`记录的字段下。然而，我们希望将频率移动到`CountRank`记录中，并将其与排名一起存储。我们将通过以下步骤实现这一点：
- en: 'We''ll find the rank using the `rank-on` function. This sorts by one of the
    properties of the `UserInfo` records (`:post`, `:q`, or `:a`) and then associates
    each instance with a rank by containing both within a vector pair. Look at the
    following code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`rank-on`函数来找到排名。这个函数根据`UserInfo`记录的一个属性（`:post`、`:q`或`:a`）进行排序，然后通过将两者都包含在一个向量对中来将每个实例与一个排名关联。看看下面的代码：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The function `update-rank` will then take the rank-and-user pair from `rank-on`
    and associate it with the appropriate property, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`update-rank`将然后从`rank-on`中获取排名和用户对，并将其与适当的属性关联，如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next function, `add-rank-data`, coordinates this process by calling these
    functions on all users. And the function controlling this process, `add-all-ranks`,
    does this on each user as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can combine reading the XML file and counting the posts with sorting and
    ranking the users. Look at the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All of these functions make it simple to load the XML file and to assign the
    ranks. Look at the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we have the information that we'll need to perform the first round of analyses.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Finding the patterns of participation
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have some data loaded, let's roll up our sleeves and see what we
    can learn from it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do, however, it would be nice to have some way to generate reports
    of which users are the most active for each type of post. Look at the following
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This allows us to create tables listing the top 10 (or so) users for each post
    type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '| Rank | User | All Posts |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| 0 | 22656 | 28166 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| 1 | 29407 | 20342 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| 2 | 157882 | 15444 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| 3 | 17034 | 13287 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| 4 | 34397 | 13209 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| 5 | 23354 | 12312 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| 6 | 115145 | 11806 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| 7 | 20862 | 10455 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| 8 | 57695 | 9730 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| 9 | 19068 | 9560 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: Based on this table, we can see that some users are *very* active. The top user
    has almost 8,000 more posts than the second most active user, who is still very,
    very active.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph, of the post counts of the top 1,000 users, shows how quickly
    the activity falls off and how much the top users dominate the conversation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the patterns of participation](img/4139OS_09_03.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: We can break this down further, however. I would expect the people who post
    questions to behave differently than the people who post answers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Matching the 80/20 rule
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Previously, we talked about the 80/20 rule: that 80 percent of the content
    is created by 20 percent of the users. That''s obviously a rough estimate, but
    it does provide a good intuition for the dynamics of these networks.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the break-down, we need to perform the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Sort the users in descending order by the count that we're interested in.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partition them into **quintiles**, that is, five equally sized buckets.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sum the counts for each bucket.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement this, we can use a function named `quantile-on`, which sorts a
    collection and breaks it into the buckets. Look at the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we just need to pull out the appropriate fields and sum their values, as
    follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So the top 20 percent of users actually produce more than 85 percent of the
    content. The quintiles drop off rapidly from there.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Matching the 80/20 rule](img/4139OS_09_04.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: And we can pull these into a graph to be able to see the distribution of contributors
    more easily.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Looking for the 20 percent of questioners
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While finding those who post questions, we can also see who are most active
    in asking questions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '| Rank | User | Question Posts |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| 0 | 39677 | 1858 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| 1 | 4653 | 1605 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| 2 | 34537 | 1604 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| 3 | 179736 | 1327 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| 4 | 117700 | 1327 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| 5 | 149080 | 1261 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| 6 | 84201 | 1177 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| 7 | 434051 | 1107 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| 8 | 325418 | 1074 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| 9 | 146780 | 1055 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: When we run this, it gives us a very different set of frequencies. These are
    more than an order of magnitude less than the frequencies for all posts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We can also get the numbers for the distribution of questioners.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use `quantile-on` and `sum-count` again, we can also see the break-down
    by quintile. Look at the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And the following is the graph for this group:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking for the 20 percent of questioners](img/4139OS_09_05.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Interesting. So the lowest quintile doesn't contribute anything. Presumably,
    those are the users who answer questions. We'll look at this group more in a minute.
    But overall, the distribution of those asking questions follows what we'd expect
    from the 80/20 rule.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Looking for the 20 percent of respondents
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because most of the posts are answers, we can expect that these frequencies
    will be closer to the aggregate frequencies. We'll find this similarly to how
    we found the frequencies of those asking questions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following table:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '| Rank | User | Answer Posts |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| 0 | 22656 | 28137 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| 1 | 29407 | 20310 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| 2 | 157882 | 15431 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| 3 | 17034 | 13285 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| 4 | 34397 | 13157 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| 5 | 23354 | 12270 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| 6 | 115145 | 11784 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| 7 | 20862 | 10447 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| 8 | 57695 | 9711 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| 9 | 19068 | 9557 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: 'We can see that there is a lot of similarity between this set of numbers and
    the first one. And in fact there is a lot of similarity between the distribution
    of this set of posters and the last set, as we can see in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking for the 20 percent of respondents](img/4139OS_09_06.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: Looking at the distribution overall, however, we can see that the question answerers
    are even more lopsided than the question askers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try to break down the contributors who answer the questions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the following is the graph for this data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking for the 20 percent of respondents](img/4139OS_09_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: So almost half of the users never post an answer! However, the top 20 percent
    of users post 95 percent of the answers. So answering questions appears to be
    dominated by a few users, while question asking is (marginally) more widespread.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Combining ranks
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can see even more similarity if we compare the ranks. This table shows the
    rank for each category of post for all of the top 10 users in any category. (Note
    that the ranks begin at 0, not 1.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '| User ID | All Post Rank | Question Post Rank | Answer Post Rank |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| 4653 | 423 | 1 | 21342 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| 17034 | 3 | 602037 | 3 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| 19068 | 9 | 420772 | 9 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| 20862 | 7 | 169469 | 7 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| 22656 | 0 | 37889 | 0 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| 23354 | 5 | 22760 | 5 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| 29407 | 1 | 33177 | 1 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| 34397 | 4 | 16478 | 4 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| 34537 | 358 | 2 | 8024 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| 39677 | 345 | 0 | 151684 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| 57695 | 8 | 65071 | 8 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| 84201 | 631 | 6 | 10521 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| 115145 | 6 | 54339 | 6 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| 117700 | 595 | 4 | 29654 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| 146780 | 923 | 9 | 123737 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| 149080 | 682 | 5 | 56862 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| 157882 | 2 | 101282 | 2 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| 179736 | 605 | 3 | 36463 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 179736 | 605 | 3 | 36463 |'
- en: '| 325418 | 523 | 8 | 3502 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 325418 | 523 | 8 | 3502 |'
- en: '| 434051 | 858 | 7 | 164416 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 434051 | 858 | 7 | 164416 |'
- en: 'The data in this table makes certain points clear:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的数据使某些观点变得清晰：
- en: The top-ranked users asking questions are a very different set than the top-ranked
    users answering questions. The top questioner was ranked 141,674th as an answerer,
    and the top answerer was ranked 37,887th as a questioner.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级提问者与顶级回答者是非常不同的一群人。顶级提问者作为回答者排名第141,674位，而顶级回答者作为提问者排名第37,887位。
- en: Once we're beyond the top posters, neither subgroup correlates well with the
    aggregate of all posts. All of these users rank within the top 1,000 for all types
    of posts. This just indicates that the question answerers don't completely dominate
    the questioners.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们超越了顶级发布者，这两个子组与所有帖子类型的总和都没有很好地相关。所有这些用户在所有类型的帖子中排名都在前1000名之内。这仅仅表明提问者并不完全主导提问者。
- en: These observations confirm what we found looking at the quintiles and the graphs.
    Both of these groups look very different from each other, and from the aggregate
    of the two.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观察结果证实了我们通过查看五分位数和图表所发现的情况。这两个群体彼此之间以及与两个群体的总和都看起来非常不同。
- en: Let's break down the groups into those who only post questions, those who only
    post answers, and those who do both. That should give us more insight into the
    types of participation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把群体分解为只提问的人、只回答问题的人和两者都做的人。这应该能让我们对参与类型有更深入的了解。
- en: Looking at those who only post questions
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 看看只提问的人
- en: 'We can get the users who only post answers fairly easily, and then running
    the previous analyses on that subset is also not difficult. Let''s see how this
    will work. Look at the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地找到只发布答案的用户，然后对这一子集进行之前的分析也不困难。让我们看看这将如何运作。看看下面的代码：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So first we filtered for only users who post no answers. This leaves us with
    49 percent of the total number of users, so this is really an extremely large
    group of StackOverflow users.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先筛选出只发布答案的用户。这使我们剩下总用户数量的49%，所以这实际上是一个极其庞大的StackOverflow用户群体。
- en: 'However, the interesting part is that their distribution is more uniform. The
    most active quintile has posted less than two-thirds of the questions. The following
    graph makes that clear:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的部分是他们的分布更加均匀。最活跃的五分位数发布的问题不到三分之二。以下图表清楚地说明了这一点：
- en: '![Looking at those who only post questions](img/4139OS_09_08.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![看看只提问的人](img/4139OS_09_08.jpg)'
- en: The ratios for these are much different than we've seen so far. This group is
    much less driven by a few users. But when you think about it, this makes sense.
    Many people who come to StackOverflow only post one question, and that's the extent
    of their interaction. In fact, the bottom three quintiles only post one question
    and no answers. That's almost 33 percent of the total number of users.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比率与我们迄今为止看到的非常不同。这个群体受少数用户的影响较小。但当你这么想的时候，这很有道理。许多来到StackOverflow的人只提问一个问题，这就是他们互动的极限。事实上，底部三个五分位数只提问了一个问题，没有回答。这几乎占总用户数量的33%。
- en: Let's see how this compares to those who post only answers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这与只发布答案的人相比如何。
- en: Looking at those who only post answers
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 看看只发布答案的人
- en: 'Getting the users who only post answers will be almost exactly like the process
    we just went through. However, this time we''ll switch questions and answers,
    of course. Look at the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 获取只发布答案的用户的过程几乎与我们刚才进行的过程完全一样。然而，这次我们将交换问题和答案，当然。看看下面的代码：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time, we're working with a group roughly half the size of those who post
    only questions, roughly a quarter of the entire group of users. And the distribution
    of the top quintile is much closer to what we'd expect from the 80/20 rule.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们处理的是一个大约是只提问的人数量一半的群体，大约是整个用户群体四分之一。顶级五分位数的分布与我们根据80/20规则预期的非常接近。
- en: Again, notice that the last few quintiles appear to have users who have only
    posted one answer. In fact, about 16 percent of the total number of users have
    posted no questions and only one answer. This seems to be one of the most curious
    groups, and trying to get more interaction out of them would be a priority (as
    I'm sure it has been for StackExchange).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，最后几个五分位数似乎有只发布了一个答案的用户。实际上，大约16%的总用户数量没有提问，只发布了一个答案。这似乎是最有趣的一组，试图从他们那里获得更多互动将是优先事项（我相信这已经对StackExchange来说是如此）。
- en: The graph for this, shown following this paragraph, is somewhat between the
    last graph (for those who ask only questions) and the first few graphs. The first
    quintile is about 80 percent, but the rest don't taper off as much as they sometimes
    do.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表，在接下来的段落中展示，位于最后一个图表（只提问的人）和前几个图表之间。第一个五分位数大约是80%，但其余部分并没有像有时那样急剧减少。
- en: '![Looking at those who only post answers](img/4139OS_09_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![查看只回答的人](img/4139OS_09_09.jpg)'
- en: Now let's look at the breakdown for the rest of the users, those who've posted
    both questions and answers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看其他用户的细分情况，那些既提问又回答的用户。
- en: Looking at those who post both questions and answers
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看既提问又回答的人
- en: The predicate needed to select those users who have posted both questions and
    answers will be slightly different than what we've seen in the last two sections.
    However, once we have those users, the analysis will be the same. The only wrinkle
    will be that we'll get the distribution for both questions and answers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 选择那些既提问又回答的用户所需的谓词将与我们之前看到的两个部分略有不同。然而，一旦我们有了这些用户，分析将是一样的。唯一的麻烦是我们将得到问题和答案的分布。
- en: 'We''ll get the users who answer both using a slightly more complicated predicate,
    which we will page to remove. Look at the following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个稍微复杂一些的谓词来获取既提问又回答的用户，我们将分页来移除。看看下面的代码：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we''ll also need to compute the values for both the questions and the answers.
    First, let''s see what the questions look like:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要计算问题和答案的值。首先，让我们看看问题是什么样的：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The graph that follows makes clear that the ratios on this are more like the
    distribution that we''d expect:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表清楚地表明，这里的比率更像是我们所期望的分布：
- en: '![Looking at those who post both questions and answers](img/4139OS_09_10.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![查看既提问又回答的人](img/4139OS_09_10.jpg)'
- en: 'Looking at the numbers for the answers from this group, we again seem to be
    following a very rough approximation of the 80/20 rule. Look at the following
    code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个群体中查看答案的数字，我们似乎又遵循了一个非常粗略的80/20规则。看看下面的代码：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And the following is the graph for this data:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表是这些数据：
- en: '![Looking at those who post both questions and answers](img/4139OS_09_11.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![查看既提问又回答的人](img/4139OS_09_11.jpg)'
- en: So the group who has posted both questions and answers seem to be more balanced
    and have a more typical interaction with the website.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，那些既提问又回答的用户群体似乎更加平衡，并且与网站的互动更加典型。
- en: 'Another way of looking at this data is to look at how the number of questions
    each user posts by the number of answers each posts. This gives us an indication
    of how active users are in each type of activity. Look at the following graph:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这些数据的方式是查看每个用户通过提问和回答的数量。这为我们提供了每个类型活动中用户活跃度的指示。看看下面的图表：
- en: '![Looking at those who post both questions and answers](img/4139OS_09_12.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![查看既提问又回答的人](img/4139OS_09_12.jpg)'
- en: 'This graph makes clear that typically users engage in one type of activity
    or another, and there''s not as much cross-over as you might have expected. Also,
    the scales of the axes are a bit deceiving: the *y* axis is over 16 times larger
    than the *x* axis.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表清楚地表明，通常用户会参与一种活动或另一种活动，并且交叉重叠的并不多，正如你可能期望的那样。此外，坐标轴的比例有点误导：*y*轴是*x*轴的16倍以上。
- en: Now that we have a better understanding of the way that users are interacting
    with StackOverflow and the ways that they're generating content, let's look at
    that content and see if we can figure out what makes a good answer and what doesn't.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对用户与StackOverflow的互动方式以及他们生成内容的方式有了更好的理解，让我们看看这些内容，看看我们能否找出什么是一个好的答案，什么不是。
- en: Finding the up-voted answers
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找被点赞的答案
- en: Answers can be rated in a couple of different ways. The community can vote an
    answer up or down, and the original poster can accept an answer. For the purposes
    of this demonstration, we'll look at accepted answers; however, both metrics might
    be useful and interesting to explore.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 回答可以通过几种不同的方式来评分。社区可以对答案进行投票，支持或反对，而原始发帖者可以接受答案。为了演示的目的，我们将查看接受的答案；然而，这两个指标可能都很有用且值得探索。
- en: We'll look at how we might automatically recognize answers that will be accepted.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看我们如何自动识别将被接受的答案。
- en: On the one hand, this would be very useful to do. If the original poster forgets
    to accept an answer, the website could prompt them with a possible solution. Also,
    the site could send the poster an e-mail when someone posts an answer that should
    be considered.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，这将会非常有用。如果原始发帖者忘记接受答案，网站可以提示他们可能的解决方案。此外，当有人发帖应该被考虑时，网站可以向发帖者发送电子邮件。
- en: But on the other hand, acceptable answers probably don't share common linguistic
    features that any kind of algorithm could latch on to in order to identify potential
    solutions. I'm doubtful that we'll be able to train an algorithm to identify acceptable
    answers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一方面，可接受的答案可能并不共享任何算法可以抓取的共同语言特征来识别潜在的解决方案。我怀疑我们能否训练出一个算法来识别可接受的答案。
- en: Still, let's try and see how well we can actually do.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们尝试看看我们实际上能做得有多好。
- en: Processing the answers
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理答案
- en: There are over 18 million posts at this point. We can always work on the full
    data set eventually, but to get started, let's pull out a sample of the data.
    To make things easier, I've uploaded a random sample of 100,000 answers on [http://www.ericrochester.com/mastering-clj-data/data/post-sample-100000.json.gz](http://www.ericrochester.com/mastering-clj-data/data/post-sample-100000.json.gz).
    These have been transformed into the data structure that we'll use everywhere.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 目前已有超过1800万篇帖子。我们最终可以处理完整的数据集，但为了开始，我们先抽取一部分数据样本。为了简化操作，我已经上传了一个包含10万个答案的随机样本，可以在[http://www.ericrochester.com/mastering-clj-data/data/post-sample-100000.json.gz](http://www.ericrochester.com/mastering-clj-data/data/post-sample-100000.json.gz)找到。这些数据已经被转换成了我们将要使用的结构。
- en: 'You can download these with `curl` and decompress it with `gzip` as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`curl`下载这些数据，并用`gzip`解压缩，如下所示：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''ll put the code for this section into the `src/social_so/post.clj` file,
    and at the top we''ll add the following namespace declaration:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这段代码放入`src/social_so/post.clj`文件中，并在顶部添加以下命名空间声明：
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To represent the data that we''ll work with, we''ll use the `PostInfo` record
    type. Look at the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示我们将要处理的数据，我们将使用`PostInfo`记录类型。看看以下代码：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The interesting fields here are `body-text`, which contains the answer's text,
    stripped of HTML, and `accepted-for`, which is nil if the post isn't accepted
    or contains the question's ID, if the post was accepted for its question.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是`body-text`字段，它包含去除HTML的答案文本，以及`accepted-for`字段，如果帖子没有被接受，则为nil，如果帖子被接受，则包含问题的ID。
- en: 'This is a flat data record, so it''s easy to load the JSON data into these
    structures. Look at the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个扁平的数据记录，因此很容易将这些JSON数据加载到这些结构中。看看以下代码：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And now we can read the data on the REPL, assuming we''ve aliased this namespace
    to `p`. Look at the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以假设已经将这个命名空间别名为`p`，在REPL上读取数据。看看以下代码：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Looking at these briefly, we can see that just over 20 percent of the posts
    in the sample were accepted.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地查看这些数据，我们可以看到样本中超过20%的帖子是被接受的。
- en: Predicting the accepted answer
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预测被接受的答案
- en: Now that the data is in a usable form, let's turn our attention to categorizing
    the posts. To do this, we'll use **MALLET** ([http://mallet.cs.umass.edu/](http://mallet.cs.umass.edu/)).
    We saw MALLET before in [Chapter 3](ch03.html "Chapter 3. Topic Modeling – Changing
    Concerns in the State of the Union Addresses"), *Topic Modeling – Changing Concerns
    in the State of the Union Addresses*, on topic modeling. That's usually the task
    that this library is used for. However, it also provides an implementation of
    a number of classification algorithms, and we'll use one of those now.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经以可用的形式存在，让我们将注意力转向对帖子进行分类。为此，我们将使用**MALLET** ([http://mallet.cs.umass.edu/](http://mallet.cs.umass.edu/))。我们在[第3章](ch03.html
    "第3章。主题建模——在国情咨文中变化的关注点")中见过MALLET，*主题建模——在国情咨文中变化的关注点*，关于主题建模。这通常是这个库被使用的任务。然而，它还提供了一系列分类算法的实现，我们现在将使用其中之一。
- en: Over the course of this chapter, we'll categorize the posts as what MALLET calls
    `instances`. This will divide them into categories based on features, or clues
    within each instance. We'll use MALLET to take each post, create an instance from
    it, identify its features and categories, and finally use those to train a classifier.
    We can later use this classifier on new posts.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将把帖子分类为MALLET所说的`instances`。这将根据每个实例的特征或线索将它们分成类别。我们将使用MALLET对每个帖子进行处理，创建一个实例，识别其特征和类别，并最终使用这些信息来训练一个分类器。我们可以在之后用这个分类器对新帖子进行分类。
- en: Setting up
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: 'We''ll use a new namespace for this code. Open the file `src/social_so/nlp.clj`
    and add the following namespace declaration to the top of the file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这段代码使用一个新的命名空间。打开文件`src/social_so/nlp.clj`，并将以下命名空间声明添加到文件顶部：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That's a lot of imports. But really, that's the most complicated that this code
    will be. MALLET does a lot of the heavy lifting for us.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的模块很多。但实际上，这将是这段代码最复杂的地方。MALLET为我们做了很多繁重的工作。
- en: 'In the code to come, we''ll refer to this in the REPL with the `n` prefix.
    To make this available, execute the following line (after the **user=>** prompt)
    in your REPL environment:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码中，我们将使用`n`前缀在REPL中引用它。为了使其可用，请在您的REPL环境中执行以下行（在**user=>**提示符之后）：
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we're ready to start filling in the blanks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始填补空白。
- en: Creating the InstanceList object
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建InstanceList对象
- en: MALLET represents each input as an `Instance` object. `Instance` objects contain
    their data, a target label, name, and other metadata.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: MALLET将每个输入表示为一个`Instance`对象。`Instance`对象包含其数据、目标标签、名称和其他元数据。
- en: MALLET works on collections of `Instance` objects as an `InstanceList`, which
    is just a collection of `Instance` objects. All the instances in the list are
    processed using the same pipe of transformations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: MALLET以`InstanceList`的形式处理`Instance`对象的集合，它只是`Instance`对象的一个集合。列表中的所有实例都使用相同的转换管道进行处理。
- en: Each step in the pipe changes one property of each `Instance` object in the
    list. For example, one pipe (`CharSequence2TokenSequence`) tokenizes the input,
    and another (`Target2Label`) creates an index of the target labels.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的每一步都会改变列表中每个`Instance`对象的一个属性。例如，一个管道（`CharSequence2TokenSequence`）对输入进行分词，另一个管道（`Target2Label`）创建目标标签的索引。
- en: 'The following figure illustrates this process:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了这个过程：
- en: '![Creating the InstanceList object](img/4139OS_09_13.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![创建InstanceList对象](img/4139OS_09_13.jpg)'
- en: For the features in the documents and their labels, the `InstanceList` also
    maintains **alphabets**. These are indexes from the input strings to integers.
    The integers serve to distinguish the inputs and also act as indexes in arrays.
    This allows MALLET to work with frequencies as an array, which saves both space
    and processing time. The trick is that all of the `Instance` objects being processed
    must share the same alphabet. The `InstanceList` makes sure that they do.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文档中的特征及其标签，`InstanceList`还维护**字母表**。这些是从输入字符串到整数的索引。整数用于区分输入，并在数组中充当索引。这使得MALLET能够以数组的形式处理频率，从而节省空间和处理时间。诀窍是所有正在处理的`Instance`对象都必须共享相同的字母表。`InstanceList`确保它们确实如此。
- en: 'For our processing, to make clear what transformations we''ll use, we''ll define
    them all in a function named `make-pipe`. The following is that function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的处理过程清晰，我们将它们全部定义在一个名为`make-pipe`的函数中。以下就是这个函数：
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What's happening here? Let's take the steps apart.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？让我们分步骤来看。
- en: '`Target2Label` builds the alphabet for the `Instance` objects'' target property.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Target2Label`为`Instance`对象的`target`属性构建字母表。'
- en: '`Input2CharSequence` reads the input from a string, file, or URL named in the
    data property and replaces it with the resource''s content.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input2CharSequence`从字符串、文件或URL（在数据属性中命名）读取输入，并将其替换为资源的内容。'
- en: '`CharSequence2TokenSequence` tokenizes the string in the data property.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CharSequence2TokenSequence`将数据属性中的字符串进行分词。'
- en: '`TokenSequenceLowercase` lowercases the tokens in the data property.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TokenSequenceLowercase`将数据属性中的标记转换为小写。'
- en: '`TokenSequenceRemoveStopwords` filters out stop words (common words) from the
    tokens in the data.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TokenSequenceRemoveStopwords`从数据中的标记中过滤掉停用词（常见词）。'
- en: '`TokenSequence2FeatureSequence` creates the alphabet of tokens and convert
    the sequence of tokens to a sequence of feature indexes.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TokenSequence2FeatureSequence`创建标记的字母表，并将标记序列转换为特征索引序列。'
- en: '`FeatureSequence2FeatureVector` converts the sequence of feature indexes to
    a vector for a bag-of-words approach.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FeatureSequence2FeatureVector`将特征索引序列转换为向量，用于词袋模型。'
- en: So, at the end of this pipeline, each document will be represented by a vector
    indicating how many times each feature appears in that document. Features can
    be almost anything, but usually they are words that appear in the document or
    metadata (author, date, tags) associated with that document. This is the format
    that the classifiers—as well as many other machine learning and natural language
    algorithms—expect.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个管道的末端，每个文档都将由一个向量表示，该向量指示每个特征在该文档中出现的次数。特征可以是几乎任何东西，但通常它们是文档中出现的单词或与该文档关联的元数据（作者、日期、标签）。这是分类器以及许多其他机器学习和自然语言算法所期望的格式。
- en: This handles the processing of the `Instance` objects, but before we can do
    that, we'll need to convert the `PostInfo` objects into `Instance` objects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理 `Instance` 对象的处理，但在我们能够这样做之前，我们需要将 `PostInfo` 对象转换为 `Instance` 对象。
- en: MALLET has a number of classes that do this from more primitive data types.
    They take some kind of collection of primitive inputs and iterate over the `Instance`
    objects they represent. In our case, we'll use `ArrayDataAndTargetIterator`. This
    iterates over two string arrays. One contains each input's data, and the other
    contains each input's target.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: MALLET 有几个类可以从更原始的数据类型中执行此操作。它们接受某种原始输入的集合，并遍历它们所代表的 `Instance` 对象。在我们的情况下，我们将使用
    `ArrayDataAndTargetIterator`。这个迭代器遍历两个字符串数组。一个包含每个输入的数据，另一个包含每个输入的目标。
- en: 'We''ll wrap creating this with the function `post-info-iterator`. This uses
    the `accepted-tag` function to decide whether the post was accepted or not and
    tag it appropriately. Look at the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用函数 `post-info-iterator` 来完成创建这个过程。这个函数使用 `accepted-tag` 函数来判断帖子是否被接受，并相应地标记。请看以下代码：
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once we have these functions, we can use them to populate an `InstanceList`
    that will run all the documents through the transformation pipeline that we defined
    earlier. Look at the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些函数，我们就可以使用它们来填充一个 `InstanceList`，该 `InstanceList` 将将所有文档通过我们之前定义的转换管道。请看以下代码：
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we''re ready. Let''s pick up with the `PostInfo` sample that we extracted
    earlier and bound to `s` in the *Processing the answers* section. This contains
    a sequence of `PostInfo` instances. In the REPL, we can create an `InstanceList`
    using the functions that we just defined as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了。让我们从之前提取的 `PostInfo` 样本开始，在 *处理答案* 部分将其绑定到 `s`。这包含了一系列的 `PostInfo`
    实例。在交互式解释器（REPL）中，我们可以使用我们刚刚定义的函数来创建一个 `InstanceList`，如下所示：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we can think about how we're going to use these documents to train and test
    a classifier.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以考虑如何使用这些文档来训练和测试一个分类器。
- en: Training sets and Test sets
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练集和测试集
- en: Now that we've processed our data into a format that MALLET can use, we'll divide
    the input corpus into a test set and a training set. We can use different relative
    sizes for each, but often we'll train on more documents than we'll test on.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的数据处理成 MALLET 可以使用的格式，我们将输入语料库划分为测试集和训练集。我们可以为每个组使用不同的相对大小，但通常我们会训练比测试更多的文档。
- en: MALLET's `InstanceList` class has a `split` method, but we'll define a thin
    wrapper over it to make it easier to use. MALLET's `split` method takes an array
    listing the proportions of the total for each group. Since we only want two groups
    that completely divide the input, we can pass in the proportion for one group
    and compute the value of the other group's proportion. We'll also return a hash-map
    indicating which of the output lists is for testing and which is for training.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: MALLET 的 `InstanceList` 类有一个 `split` 方法，但我们将定义一个薄的包装器来使其更容易使用。MALLET 的 `split`
    方法接受一个数组，列出每个组的总比例。由于我们只想有两个完全划分输入的组，我们可以传递一个组的比例并计算另一个组比例的值。我们还将返回一个哈希表，指示输出列表中的哪个是为测试而哪个是为训练。
- en: 'The following is the `split-sets` function that acts as the wrapper:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `split-sets` 函数充当包装器：
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And we can use the following on the command line to divide the input:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在命令行使用以下命令来划分输入：
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we're ready to use these for training and testing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用这些数据用于训练和测试。
- en: Training
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 训练
- en: Before we can use a classifier, we have to train it on the training set that
    we just created.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用分类器之前，我们必须在刚刚创建的训练集上对其进行训练。
- en: For this example, we'll create a Naive Bayesian classifier. Again, we'll just
    create a thin wrapper function. In this case, it's not that significantly simpler
    than creating the Bayesian trainer and calling it on the data. However, it will
    allow us to use the trainer without having to tease out which MALLET packages
    we have to import. This allows us to require our `social-so.nlp` namespace into
    the REPL and execute the entire process.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将创建一个朴素贝叶斯分类器。再次，我们只是创建一个薄包装函数。在这种情况下，它并不比创建贝叶斯训练器并对其数据进行调用简单多少。然而，它将允许我们使用训练器，而无需费力地找出我们必须导入哪些MALLET包。这允许我们将`social-so.nlp`命名空间引入REPL并执行整个过程。
- en: 'The following is the wrapper:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包装器：
- en: '[PRE40]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And we can use the following in the REPL to get a trained Bayesian classifier:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在REPL中使用以下方法获取训练好的贝叶斯分类器：
- en: '[PRE41]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That's it. We've trained our classifier. Now let's see how to use it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们已经训练了我们的分类器。现在让我们看看如何使用它。
- en: Testing
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: To test the classifier, MALLET provides a `Trial` class that encapsulates running
    a classifier over some inputs that are already tagged. It provides counts over
    how accurate the classifier is and calculates statistics to show how well it does.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试分类器，MALLET提供了一个`Trial`类，它封装了对一些已标记输入运行分类器的过程。它提供了关于分类器准确性的计数，并计算统计数据以显示其表现如何。
- en: 'To make it easier to load the development environment and to use this class,
    we''ll create a factory function for it as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使加载开发环境和使用此类更容易，我们将创建一个用于它的工厂函数，如下所示：
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And now let''s use this function at the REPL as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在REPL中使用此函数，如下所示：
- en: '[PRE43]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Well, great. Now what can we do with this?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，太好了。现在我们能用它做什么呢？
- en: Evaluating the outcome
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估结果
- en: There are several factors to consider when evaluating a classifier's ability
    to identify inputs as belonging to category *X*. Let's consider what they are
    and see how we can get them from the `Trial` object.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 评估分类器识别输入属于类别 *X* 的能力时，需要考虑几个因素。让我们考虑一下它们是什么，并看看我们如何从 `Trial` 对象中获取它们。
- en: 'First, we need to think about the classifier''s **precision or positive predictive
    value** (**PPV**). This takes into account how many items the classifier incorrectly
    included in category *X*, and it''s given by the ratio of the true positives with
    all labeled positive. In our case, that means the number of items that were correctly
    identified as `accepted` divided by all of those identified as `accepted`. You
    can get this using the `getPrecision` method, as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要考虑分类器的**精确度或阳性预测值**（**PPV**）。它考虑了分类器错误地包含在类别 *X* 中的项目数量，并且由真正例与所有标记正例的比率给出。在我们的例子中，这意味着正确识别为
    `accepted` 的项目数量除以所有被识别为 `accepted` 的项目。您可以使用`getPrecision`方法获取此信息，如下所示：
- en: '[PRE44]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So we can see that it correctly identified the accepted rows rather poorly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到它正确识别了接受的行，但做得并不好。
- en: 'The next number that we need to consider is the classifier''s **recall**. This
    is sometimes referred to as its **sensitivity** or **true positive rate** (**TPR**).
    This is the percentage of all positives that it found, and it''s found by dividing
    the true positives by the true positives and the false negatives. MALLET exposes
    this with the `getRecall` method as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要考虑的下一个数字是分类器的**召回率**。有时也被称为其**灵敏度**或**真正例率**（**TPR**）。这是它找到的所有正例的百分比，通过将真正例除以真正例和假阴性来计算。MALLET通过`getRecall`方法公开了这一点，如下所示：
- en: '[PRE45]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this case, the recall is actually worse than the precision, which is *saying*
    something.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，召回率实际上比精确度还要差，这是*说*出了什么。
- en: 'Next, we''ll consider the **accuracy** (**ACC**) of the classifier. This is
    the ratio of true classifications, both positive and negative, to the total number
    of items. This is rendered from the `getAccuracy` method. Look at the following
    code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑分类器的**准确度**（**ACC**）。这是真实分类（无论是正面还是负面）与总项目数的比率。这是通过`getAccuracy`方法实现的。看看以下代码：
- en: '[PRE46]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Presumably, this classifier''s precision and recall are better when identifying
    not-accepted answers. Let''s test that as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 据推测，这个分类器在识别未接受的答案时，精确度和召回率会更好。让我们如下测试：
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These results aren't great. A simple baseline that classifies everything as
    *not accepted* would actually score slightly better than this (80 percent). The
    criteria involved in accepting an answer don't appear to be captured by the simple
    token features that we've used here.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果并不理想。一个简单的基线，将所有内容分类为 *未接受*，实际上会得到略好于这个（80%）的分数。接受答案所涉及的准则似乎没有被我们在这里使用的简单标记特征所捕捉。
- en: The performance here is likely because `not accepted` is the default state for
    an answer, and the status of most answers.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里表现不佳的原因可能是“未接受”是答案的默认状态，并且是大多数答案的状态。
- en: 'There''s one final number that we want to pay attention to. The F1 score is
    a measure of the classifier''s accuracy. This combines the precision and recall
    into a single number ranging from 0 (poor) to 1 (perfect). Look at the following
    code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要注意一个最后的数字。F1分数是分类器准确性的度量。这个分数将精确度和召回率结合成一个介于0（差）到1（完美）之间的单一数字。看看下面的代码：
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Again, we can see that the classifier doesn't do a good job.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以看到分类器没有做好工作。
- en: We can get more detailed information about how well the classifier did by looking
    at its **confusion** matrix. This is a matrix that breaks down how many items
    are predicated to be in both categories, and how many actually are.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看其**混淆矩阵**来获取更多关于分类器表现如何的详细信息。这是一个矩阵，它分解了有多少项被预测属于两个类别，以及实际上有多少项属于这两个类别。
- en: 'MALLET has a `ConfusionMatrix` class for displaying these charts. We''ll again
    wrap that class in a function to make it easier to call. Look at the following
    code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: MALLET有一个`ConfusionMatrix`类来显示这些图表。我们将再次将这个类封装在一个函数中，以便更容易调用。看看下面的代码：
- en: '[PRE49]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This generates the confusion matrix and returns it as a string. Let''s call
    this and print the matrix out as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成混淆矩阵并将其作为字符串返回。让我们调用这个函数并按以下方式打印矩阵：
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now we can see where the numbers came from. Rows are the actual classes, and
    columns are how the classifier predicted the classes. The true positives in the
    lower right-hand side are much smaller than the total number of positives in the
    bottom row. On the other hand, the true negatives in the upper left-hand side
    are the majority of the total number of negatives in the top row.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到数字的来源。行是实际类别，列是分类器预测的类别。右下角的真正阳性（true positives）比底部行的总阳性数小得多。另一方面，左上角的真正阴性（true
    negatives）是顶部行总阴性数的大多数。
- en: Naive Bayesian classifiers don't perform well here, but it's possible (although
    unlikely) that other classifiers might. It's also possible that adding more metadata
    as features might help. For example, the length of time between when the question
    was posted and when the answer was posted might be fruitful. Other features that
    might help are the length of the answer or the answerer's reputation. Reputation
    is the points awarded for accepted answers, though, so including them introduces
    circularity – we'd be training directly on what we're attempting to classify.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 基于朴素贝叶斯分类器在这里表现不佳，但其他分类器可能（尽管不太可能）会表现得好。也可能添加更多元数据作为特征会有所帮助。例如，问题发布时间和答案发布时间之间的时间长度可能是有益的。其他可能有助于的特征包括答案的长度或回答者的声誉。然而，声誉是授予已接受答案的点数，因此包括它们会引入循环——我们将在我们试图分类的东西上直接进行训练。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: However the results of the last experiment, we can see that there's a lot of
    information embedded in social networks. Depending on the nature of the network,
    we can have different kinds of interactions and different kinds of data in the
    network.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论最后实验的结果如何，我们都可以看到社交网络中嵌入了很多信息。根据网络的特点，我们可以有不同类型的互动和不同类型的数据在网络中。
- en: In the final chapter, which is next, we'll look at whether analyzing financial
    data and using machine learning to examine news documents help predict the future
    of stock prices.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也就是最后一章，我们将探讨分析财务数据和使用机器学习来检查新闻文档是否有助于预测股价的未来。
