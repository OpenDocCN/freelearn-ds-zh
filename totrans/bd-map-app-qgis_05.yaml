- en: Chapter 5. Using QGIS in an External Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started with
    QGIS"), *Getting Started with QGIS*, we looked briefly at a standalone Python
    program built using PyQt and the PyQGIS library. In this chapter, we will use
    the same technique to build a complete turnkey mapping application using PyQGIS.
    Along the way, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Design and build a simple but complete standalone mapping application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use a wrapper script to handle the platform-specific dependencies
    before our Python program is run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define our application's user interface in a separate Python module so that
    we keep our UI separate from the application's business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically show and hide map layers based on the user's preference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use a rule-based renderer to selectively display features based
    on the map's current zoom level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how data-defined properties can be used to calculate the font size to use
    for a label based on the feature's attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement Google Maps style panning and zooming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Lex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our mapping application will display a world map, allowing the user to zoom
    and pan, and display various landmarks on the map. If the user clicks on a landmark,
    information about that landmark will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call our application **Lex**, which is short for **L**andmark **ex**plorer.
    Lex will make use of two freely available geospatial datasets: a high-resolution
    shaded-relief basemap, and a comprehensive database of place names, which we will
    use as the list of landmarks to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Lex](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will build our Lex application using PyQt, and make use of the PyQGIS libraries
    built into QGIS to do most of the hard work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our requirements for the Lex application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It must run as a turnkey application. Double-clicking on the launcher script
    must start the PyQt program, load all the data, and present a complete working
    application to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user interface must be as professional as possible, with keyboard shortcuts
    and good-looking toolbar icons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on a landmark, the name and jurisdiction, time zone, and
    latitude/longitude for that landmark should be displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The look and feel should be as similar as possible to Google Maps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This last requirement is an important point, as the zooming and panning tools
    built into QGIS are more complicated than what we would like to have in a turnkey
    mapping application. Most users are already familiar with the behavior of Google
    Maps, and we want to mimic this behavior rather than using the default panning
    and zooming tools supplied by QGIS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Without further delay, let's start building our application. Our first step
    will be to download the geospatial data the application will be based on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lex will make use of two map layers: a **basemap layer** that displays a shaded-relief
    raster image, and a **landmark layer** that shows the individual landmarks based
    on a set of place names. Both of these datasets can be downloaded from the Natural
    Earth Data website. Visit [http://www.naturalearthdata.com](http://www.naturalearthdata.com)
    and click on the **Get the Data** link to jump to the **Downloads** page.'
  prefs: []
  type: TYPE_NORMAL
- en: The basemap data can be found by clicking on the **Raster** link. We'll want
    the highest-resolution data available, so use the link in the **Large scale data,
    1:10m** section.
  prefs: []
  type: TYPE_NORMAL
- en: While you could use any of these datasets as a basemap, we will download the
    **Natural Earth I with Shaded Relief, Water, and Drainages** dataset. Make sure
    you download the high-resolution version of this dataset so that the raster image
    will still look good when the user has zoomed in.
  prefs: []
  type: TYPE_NORMAL
- en: For the landmarks, we'll be using the "populated places" dataset. Go back to
    the main downloads page and click on the **Cultural** link in the **Large scale
    data, 1:10m** section. Scroll down to the **Populated Places** section and click
    on the **Download Populated Places** link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished downloading, you should have two ZIP archives on your
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NE1_HR_LC_SR_W_DR.zip`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ne_10m_populated_places.zip`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `data`, decompress the preceding two ZIP archives, and
    place the resulting directories into your `data` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a list of requirements for our mapping application, together with
    the geospatial data we want to display. Before we start coding, however, it's
    a good idea to step back and think about our application's user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will have one main window, which we will call **Landmark Explorer**.
    To make it easy to use, we''ll display a map canvas along with a simple toolbar.
    Our basic window layout will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Along with the main window, our Lex application will have a menu bar with the
    following menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the application](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The toolbar will make it easy for new users to work with Lex by pointing and
    clicking on the toolbar icons, while experienced users can make use of the extensive
    keyboard shortcuts to access the program's features.
  prefs: []
  type: TYPE_NORMAL
- en: With this design in mind, let's start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application's framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by creating a folder to hold your application''s source code, and move
    the data folder you created earlier into it. Next, we want to create the basic
    framework for our application using the techniques we learned in [Chapter 1](part0014_split_000.html#page
    "Chapter 1. Getting Started with QGIS"), *Getting Started with QGIS*. Create a
    module named `lex.py`, and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We're simply importing the various libraries we'll need and setting up an external
    PyQGIS application using the techniques we learned earlier. We then create and
    display a blank window so that the application will do something when it starts
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want the Lex application to work on any operating system, we're not
    going to hard-wire the path to QGIS into our source code. Instead, we'll write
    a **wrapper script** that sets up the required environment variables before launching
    our Python program. As these wrapper scripts are operating-system dependent, you
    will need to create an appropriate wrapper script for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we use `os.environ['QGIS_PREFIX']` in our `lex.py` module to avoid
    hard-wiring the path to the QGIS application into our source code. Our wrapper
    script will take care of setting this environment variable before the application
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a computer with Microsoft Windows, your wrapper script will
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Name this script something sensible, for example, `run.bat`, and put it in the
    same directory as your `lex.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a computer that runs Linux, your wrapper script will be named
    something like `run.sh`, and will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will need to modify the paths to refer to the directory where QGIS has been
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those running Mac OS X, your wrapper script will also be called `run.sh`,
    and will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that for Mac OS X and Linux, we have to set the framework or library
    paths. This allows the PyQGIS Python wrappers to find the underlying C++ shared
    libraries that they are based on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are running under Linux or Mac OS X, you'll also have to make your wrapper
    script executable. To do this, type `chmod +x run.sh` into the bash shell or terminal
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your shell script, try running it. If all goes well,
    your PyQt application should start up and display a blank window, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the application''s framework](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If it doesn't work, you will need to check your wrapper script and/or your `lex.py`
    module. You might need to modify the directory paths to match your QGIS and Python
    installations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our program is running, we can start implementing the user interface
    (UI). A typical PyQt application will make use of Qt Designer to store the application's
    UI in a template file, which is then compiled into a Python module for use within
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: As it would take many pages to describe how to use Qt Designer to lay out our
    window with its toolbar and menus, we're going to cheat and create our user interface
    directly within Python. At the same time, however, we'll create our UI module
    as if it was created using Qt Designer; this keeps our application's UI separate,
    and also shows how our application would work if we were to use Qt Designer to
    design our user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new module called `ui_explorerWindow.py`, and type the following code
    into this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This module implements our Lex application's user interface, defining a `QtAction`
    object for each toolbar and menu item, creating a widget to hold our map canvas,
    and laying everything out within a `QtMainWindow` object. The structure of this
    module is identical to the way Qt Designer and the `pyuic4` command-line tool
    make a user interface template available to Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `Ui_ExplorerWindow` class makes use of several toolbar icons.
    We will need to create these icon images and define them in a resource description
    file, in the same way we created a `resources.py` module in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to need the following icon images:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mActionZoomIn.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mActionZoomOut.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mActionPan.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mActionExplore.png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want, you can download these image files in SVG format from the QGIS
    source code repository ([https://github.com/qgis/QGIS/tree/master/images/themes/default](https://github.com/qgis/QGIS/tree/master/images/themes/default)),
    though you will need to convert them from `.svg` to `.png` in order to avoid issues
    with image file formats. If you don't want to convert the icons yourself, the
    images are available as part of the source code available with this book. Once
    you are done, place these four files in the main directory of your Lex application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `mActionExplore.png` icon file is a converted copy of the `mActionIdentify.svg`
    image in the source code repository. We renamed the image file to match the name
    of the tool in our Lex application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create our `resources.qrc` file so that PyQt can use these
    images. Create this file and enter the following into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will need to compile this file using `pyrcc4`. This will give you the `resources.py`
    module required by your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve defined our user interface, let''s modify the `lex.py` module
    to use it. Add the following `import` statements to the top of your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to replace our dummy implementation of the `MapExplorer` window
    with one that uses our new UI. This is what the `MapExplorer` class definition
    should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, our application should now run with a complete user interface—a
    toolbar, menus, and room for our map canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the user interface](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, our user interface doesn't do anything yet, but our Lex application
    is starting to look like a real program. Now, let's implement the behavior behind
    our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noticed that none of the menu commands and toolbar icons do
    anything yet—even the **Quit** command doesn''t work. Before our actions do anything,
    we have to connect them to the appropriate method. To do this, add the following
    to your `MapExplorer.__init__()` method, immediately after the call to `setupUi()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re connecting our **Quit** action to the `qApp.quit()` method. For the
    other actions, we''ll be calling methods within our `MapExplorer` class itself.
    Let''s define some placeholders for these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We'll implement these methods later on, once we have the map canvas up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the map canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Ui_ExplorerWindow` class defines an instance variable named `centralWidget`,
    which acts as a placeholder for our window''s contents. Since we want to place
    a QGIS map canvas into our window, let''s implement the code to create our map
    canvas and place it into this central widget. Add the following to the end of
    your `MapExplorer` window''s `__init__()` method (in `lex.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to fill our map canvas with the basemap and landmark map layers.
    To do this, we''ll define a new method called `loadMap()`, and call this at the
    appropriate time. Add the following method to your `MapExplorer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This method loads the raster and vector datasets we placed in our `data` directory.
    We then call a new method, `showVisibleMapLayers()`, to make those layers visible,
    and then set the extent of the map canvas to show the continental USA when the
    application first starts up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `showVisibleMapLayers()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As the user can choose to show or hide the basemap and landmark layers individually,
    we only display the layers that the user has selected to display. We also put
    this into a separate method so that we can call it when the user toggles the visibility
    of a layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more things to do before our map can be displayed. First off,
    add the following line to your `main()` function immediately after the call to
    `window.raise_()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This loads the map once the window has been displayed. Next, add the following
    to the end of your main window''s `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the two layers visible when the program starts up. Finally, let''s
    implement the two methods we defined earlier so that the user can choose which
    layers are shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program should show the two map layers, and you can show or hide
    each layer using the commands in the **View** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the map canvas](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Labeling the points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see from the preceding image, each landmark is simply represented
    by a colored dot. To make the program more useful, we''ll want to display the
    name of each landmark. This can be done by using the "PAL" labeling engine built
    into QGIS. Add the following code to your `loadMap()` method, immediately before
    the call to `self.showVisibleMapLayers()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will label each point on the map. Unfortunately, there are a lot of points,
    and the resulting map is completely unreadable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Labeling the points](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Filtering the landmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason our labels are unreadable is because there are too many landmarks
    being displayed. However, not all landmarks are relevant at all zoom levels—we
    want to hide landmarks that are too small to be useful when the map is zoomed
    out, while still showing these landmarks when the user zooms in. To do this, we'll
    use a `QgsRuleBasedRendererV2` object and make use of the `SCALERANK` attribute
    to selectively hide features that are too small for the current zoom level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your `loadMap()` method, before the call to `self.showVisibleMapLayers()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the effect of hiding landmarks that are too small (that is,
    which have too large a `SCALERANK` value) when the map is zoomed out. Now, our
    map looks much more reasonable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering the landmarks](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s just one more feature we''d like to add here; at the moment, all the
    labels are of the same size. However, we''d like the larger landmarks to be shown
    with a larger label. To do this, replace the `p.setDataDefinedProperty(...)` line
    in your program with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This calculates the font size based on the feature's `SCALERANK` attribute value.
    As you can imagine, using data-defined properties in this way can be extremely
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the zoom tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we want to support zooming in and out. As mentioned earlier, one of the
    requirements for our Lex application is that it must work like Google Maps rather
    than QGIS, and this is an example of where we have to support this. QGIS has a
    zoom tool, which the user clicks on and then clicks or drags on the map to zoom
    in or out. In Lex, the user will click on the toolbar icons directly to do the
    zooming. Fortunately, this is easy to do; simply implement the `zoomIn()` and
    `zoomOut()` methods in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, try to run your program. As you zoom in and out, you can see the various
    landmarks appear and disappear, and you should also be able to see the different
    font sizes used for the labels based on each feature's `SCALERANK` value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the pan tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Panning (that is, clicking and dragging on the map to move around) is another
    area where the QGIS default behavior isn''t quite what we want. QGIS includes
    a `classQgsMapToolPan` class, which implements panning; however, it also includes
    some features that could be quite confusing for users coming from Google Maps.
    In particular, if the user clicks without dragging, the map is re-centered over
    the clicked-on point. Instead of using `classQgsMapToolPan`, we will implement
    our own panning map tool. Fortunately, this is simple to do: simply add the following
    class definition to your `lex.py` module after the end of your `MapExplorer` class
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to add the following to the end of our main window''s `__init__()`
    method to create an instance of our panning tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now implement our `setPanMode()` method to use this map tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll want to select the panning mode when the application starts
    up. To do this, add the following to your `main()` function after the call to
    `window.loadMap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the explore mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the user can choose which map layers are displayed, and can zoom and
    pan the map view. The only thing missing is the entire point of the application:
    exploring landmarks. To do this, we''ll have to implement our application''s **explore**
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how we can use a `QgsMapToolIdentify` subclass
    to respond when the user clicks on a vector feature. We''re going to use the same
    logic here to implement a new map tool, which we''ll call `ExploreTool`. Add the
    following class definition to your `lex.py` module after the `PanTool` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This tool identifies the landmark feature the user clicked on, extracts the
    relevant attributes for that feature, and displays the results in a message box.
    To use our new map tool, we''ll have to add the following to the end of our `MapExplorer`
    window''s `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then need to implement our `setExploreMode()` method to use this tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when the user switches to the explore mode, we have to uncheck
    the panning mode action. This ensures that the two modes are mutually exclusive.
    The final step we have to take is to modify our `setPanMode()` method so that
    it unchecks the explore mode action when the user switches back to the panning
    mode. To do this, add the following highlighted line to your `setPanMode()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes our Lex program. The user can now zoom in and out, pan around,
    and click on a feature to get more information about that landmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the explore mode](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Further improvements and enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, while Lex is a useful and complete mapping application, it is really
    only a starting point. The information provided in the freely available populated
    places dataset doesn''t make for a particularly interesting set of landmarks,
    and our application is still quite basic. Here are some suggested improvements
    you could make to the Lex application:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Search** action, where the user can type in the name of a feature and
    Lex will zoom and pan the map to show that feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the user choose any two landmarks, and display the distance between those
    two points in both kilometers and miles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to load their own set of landmarks, either from a shapefile or
    an Excel spreadsheet. When loading from a shapefile, the user could be prompted
    to select the attribute(s) to display for each feature. When loading data from
    a spreadsheet (using, for example, the `xlrd` library), the various columns would
    contain the latitude and longitude values as well as the label and other data
    to display for each landmark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See what is involved in bundling the Lex application and QGIS itself into a
    double-clickable installer for your operating system. The *PyQGIS Developer cookbook*
    has some tips on how to do this, and there are various tools such as **py2exe**
    and **py2app**, which you can use as a starting point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing these extra features would be a great way of learning more about
    PyQGIS and how to use it within your own standalone mapping programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed and implemented a simple but complete turnkey mapping
    application using PyQGIS. In doing this, we learned how a wrapper script can be
    used to keep platform-specific settings out of your Python program. We also saw
    how we can define our application's UI in a separate module even if we don't use
    Qt Designer to create our user interface templates.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to use the "PAL" labeling engine built into QGIS to display a
    label for each feature within a vector map layer. We saw that a `QgsRuleBasedRendererV2`
    object can be used to show or hide certain features based on the map's scale factor,
    and that data-defined properties allow us to calculate values such as the label's
    font size; we also saw how the `CASE...WHEN` expression can be used to calculate
    data-defined properties in sophisticated ways.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to implement Google Maps style panning and zooming within
    a mapping application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about some of the more advanced features
    of the QGIS Python API and how we can use them within our mapping applications.
  prefs: []
  type: TYPE_NORMAL
