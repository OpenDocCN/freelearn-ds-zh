- en: Chapter 11. Working with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。与数据库一起工作
- en: In the previous chapter, you learned the basic concepts of object-oriented programming.
    These include class and methods, and how they are connected by generic functions
    in R through method dispatch. You learned about the basic usage of S3, S4, RC,
    and R6, including defining classes and generic functions as well as implementing
    methods for certain classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了面向对象编程的基本概念。这包括类和方法，以及它们如何通过R中的泛型函数通过方法调度相互连接。你了解了S3、S4、RC和R6的基本用法，包括定义类和泛型函数以及为特定类实现方法。
- en: 'Now that we have covered most of the important features of R, it is time we
    go ahead and discuss more practical topics. In this chapter, we will begin the
    discussion with how R can be used to work with databases, which is perhaps the
    first step of many data-analysis projects: extracting data from a database. More
    specifically, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了R的大部分重要特性，是时候继续讨论更多实际的话题了。在本章中，我们将从R如何用于与数据库一起工作开始讨论，这可能是许多数据分析项目的第一步：从数据库中提取数据。更具体地说，我们将涵盖以下主题：
- en: Understanding relational databases
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解关系型数据库
- en: Using SQL to query relational databases such as SQLite and MySQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQL查询关系型数据库，如SQLite和MySQL
- en: Working with NoSQL databases such as MongoDB and Redis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与NoSQL数据库一起工作，如MongoDB和Redis
- en: Working with relational databases
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与关系型数据库一起工作
- en: In the previous chapters, we used a family of built-in functions such as `read.csv`
    and `read.table` to import data from separator-delimited files, such as those
    in the csv format. Using text formats to store data is handy and portable. When
    the data file is large, however, such a storage method may not be the best way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用了一系列内置函数，如`read.csv`和`read.table`，从分隔符分隔的文件中导入数据，例如csv格式的文件。使用文本格式存储数据很方便且易于携带。然而，当数据文件很大时，这种存储方法可能不是最佳选择。
- en: 'There are three main reasons why text formats can no longer be easy to use.
    They are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文本格式不再容易使用有三个主要原因。如下所述：
- en: Functions such as `read.csv()` are mostly used to load the whole file into memory,
    that is, a data frame in R. If the data is too large to fit into the computer
    memory, we simply cannot do it.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`read.csv()`等函数主要用于将整个文件加载到内存中，即R中的数据框。如果数据太大而无法适应计算机内存，我们就无法完成它。'
- en: Even if the dataset is large, we usually don't have to load the whole dataset
    into memory when we work on a task. Instead, we often need to extract a subset
    of the dataset that meets a certain condition. The built-in data-importer functions
    simply do not support querying a csv file.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使数据集很大，我们在处理任务时通常也不需要将整个数据集加载到内存中。相反，我们通常需要提取满足一定条件的数据集子集。内置的数据导入函数根本不支持查询csv文件。
- en: The dataset is still updating, that is, we need to insert records into the dataset
    periodically. If we use the csv format, inserting data can be painful, especially
    if we want to insert the records in the middle of the file and keep it in order.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据集仍在更新中，也就是说，我们需要定期将记录插入数据集中。如果我们使用csv格式，插入数据可能会很痛苦，尤其是如果我们想在文件的中间插入记录并保持其顺序。
- en: Using a database is the best solution for these scenarios. It makes it much
    easier to store data that may exceed computer memory. Data in a database is queryable
    subject to user-supplied condition, which also makes it easier to update existing
    records and insert new records within a database.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中使用数据库是最佳解决方案。它使得存储可能超过计算机内存的数据变得容易得多。数据库中的数据可以根据用户提供的条件进行查询，这也使得更新现有记录和在数据库中插入新记录变得更加容易。
- en: A relational database is a collection of tables and relations between tables.
    A table in a relational database has the same representation with a data frame
    in R. Tables can have relations that make it easier to join the information of
    multiple tables.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库是一组表和表之间的关系。关系型数据库中的表与R中的数据框具有相同的表示。表可以具有关系，这使得连接多个表的信息变得更容易。
- en: In this section, we will start from the simplest database, SQLite ([http://sqlite.org/](http://sqlite.org/)),
    a portable, lightweight database engine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从最简单的数据库SQLite（[http://sqlite.org/](http://sqlite.org/)）开始，它是一个便携式、轻量级的数据库引擎。
- en: 'To work with SQLite databases in R, we will use the `RSQLite` package. To install
    it from CRAN, run the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在R中使用`RSQLite`包与SQLite数据库一起工作，请从CRAN安装它，运行以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a SQLite database
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SQLite数据库
- en: 'First, let''s see how to create a SQLite database. If we want to create an
    example database at `data/example.sqlite`, we need to ensure that the directory
    is available. If the directory does not exist, we have to create one:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何创建一个 SQLite 数据库。如果我们想在 `data/example.sqlite` 创建一个示例数据库，我们需要确保目录可用。如果目录不存在，我们必须创建一个：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, the `data/` directory is available. Next, we will load the `RSQLite` package
    and create a connection by supplying a database driver (`SQLite()`) and database
    file (`data/example.sqlite`). Although the file does not exist, the driver creates
    an empty file that is an empty SQLite database:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`data/` 目录可用。接下来，我们将加载 `RSQLite` 包，并通过提供数据库驱动程序（`SQLite()`）和数据库文件（`data/example.sqlite`）来创建连接。尽管文件不存在，但驱动程序会创建一个空文件，这是一个空的
    SQLite 数据库：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The database connection, `con`, is a layer between the user and the system.
    We can create a connection to a relational database and query, fetch, or update
    data through it. The connection will be used in all subsequent operations until
    we close the connection. In a typical relational database, we can create tables
    with a name and columns of certain names and data types, insert records as rows
    to a table, and update existing records. A table in a relational database looks
    very similar to a data frame in R.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接 `con` 是用户和系统之间的一个层。我们可以通过它创建到关系数据库的连接，并通过它查询、检索或更新数据。连接将在所有后续操作中使用，直到我们关闭连接。在一个典型的关系数据库中，我们可以使用名称和某些名称和数据类型的列创建表，将记录作为行插入到表中，并更新现有记录。关系数据库中的表看起来非常类似于
    R 中的数据框。
- en: 'Now, we will create a simple data frame that is to be inserted as a table to
    the database:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的数据框，该数据框将被插入到数据库中的表中：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The data frame is ready and we will call `dbWriteTable()` to write this data
    frame as a table to the database:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框已准备好，我们将调用 `dbWriteTable()` 将此数据框作为表写入数据库：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we may well use other table names but still store the
    same data. Finally, we will disconnect the database using `dbDisconnect()` so
    that `con` is no longer available for data operations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可能使用其他表名，但仍然存储相同的数据。最后，我们将使用 `dbDisconnect()` 断开数据库连接，这样 `con` 就不再可用于数据操作：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Writing multiple tables to a database
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将多个表格写入数据库
- en: A SQLite database is a collection of tables. Therefore, we can store many tables
    in one database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库是一组表。因此，我们可以在一个数据库中存储多个表。
- en: 'This time, we put the `diamonds` dataset in `ggplot2` and the `flights` dataset
    in `nycflights13` as two tables into one database. If you haven''t installed these
    two packages, run the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将 `diamonds` 数据集放入 `ggplot2`，将 `flights` 数据集放入 `nycflights13`，作为一个数据库中的两个表。如果您还没有安装这两个包，请运行以下代码：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the packages are available, we will call `data()` to load the two data
    frames:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当包可用时，我们将调用 `data()` 来加载两个数据框：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will repeat the same operation as we did earlier, but `dbWriteTable()` ends
    up with errors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复之前所做的相同操作，但 `dbWriteTable()` 最终会出错：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It can be useful to take a look at the class of these two variables:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这两个变量的类可能很有用：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that `diamonds` and `flights` are not simply of class `data.frame` but
    something more complex. To write them into the database, we need to convert them
    to plain `data.frame` objects using `as.data.frame()`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`diamonds` 和 `flights` 并不仅仅是 `data.frame` 类，而是更复杂的东西。要将它们写入数据库，我们需要使用 `as.data.frame()`
    将它们转换为普通的 `data.frame` 对象：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the database contains two tables.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数据库包含两个表。
- en: Appending data to a table
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据追加到表
- en: 'As mentioned in the beginning of this section, appending records to a table
    in the database is fairly easy. Here is a simple example where we produce several
    chunks of data and append them to a database table in turn:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，将记录追加到数据库中的表相对简单。这里有一个简单的例子，我们生成几个数据块，并依次将它们追加到数据库表：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that each chunk is a data frame with some determined data and some random
    numbers. Each time, we append these records to a table named `products`. The difference
    between this example and the previous ones is that when we call `dbWriteTable()`,
    we use `append = FALSE` for the first chunk to create that table in the database
    and use `append = TRUE` for each subsequent chunk to append to the existing table.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个块都是一个数据框，包含一些确定的数据和一些随机数。每次，我们将这些记录追加到名为 `products` 的表中。与之前的示例不同的是，当我们调用
    `dbWriteTable()` 时，我们为第一个块使用 `append = FALSE` 来在数据库中创建该表，并为每个后续块使用 `append = TRUE`
    来追加到现有表中。
- en: Accessing tables and table fields
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问表和表字段
- en: Once we have a SQLite database, we can access not only the data we store in
    the tables, but also some metadata, such as the names of all tables and the columns
    of a table.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了SQLite数据库，我们不仅可以访问存储在表中的数据，还可以访问一些元数据，例如所有表的名称和表的列。
- en: 'To demonstrate, we will connect to the SQLite database we created previously:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将连接到之前创建的SQLite数据库：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use `dbExistsTable()` to detect whether a table exists in the database:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`dbExistsTable()`来检测数据库中是否存在表：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since we only wrote `diamonds` and `flights` in `datasets.sqlite` previously,
     `dbExistsTable()` returns the correct values. On the contrary to detecting table
    existence, we can use `dbListTables()` to list all the existing tables in the
    database:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前只在`datasets.sqlite`中写入了`diamonds`和`flights`，所以`dbExistsTable()`返回正确的值。与检测表存在性相反，我们可以使用`dbListTables()`来列出数据库中所有现有的表：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For a certain table, we can also list the names of all columns (or fields)
    with `dbListFields()`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个表，我们也可以使用`dbListFields()`列出所有列（或字段）的名称：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Contrary to `dbWriteTable()`, `dbReadTable()` reads the whole table into a
    data frame:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与`dbWriteTable()`相反，`dbReadTable()`将整个表读入一个数据框：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can make a comparison between the data frame (`db_diamonds`) we read from
    the database and the original version (`diamonds`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们从数据库中读取的数据框（`db_diamonds`）与原始版本（`diamonds`）进行比较：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The data in both data frames looks exactly the same. However, if we use `identical()`
    to compare them, they are not really identical:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数据框中的数据看起来完全相同。然而，如果我们使用`identical()`来比较它们，它们实际上并不相同：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To spot the difference, we can call `str()` to reveal the structure of both
    data frames. First, here is the structure of the data frame in the database:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出差异，我们可以调用`str()`来揭示两个数据框的结构。首先，这是数据库中数据框的结构：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, here is the structure of the original version:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这是原始版本的结构：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, the difference is obvious. In the original version, `cut`, `color`, and `clarity`
    are ordered factor variables that are essentially integers with some metadata
    (ordered levels). By contrast, in the database version, these columns are stored
    as text instead. This change is simply because SQLite does not have built-in support
    of ordered factors. Therefore, except for common data types (numbers, texts, logical,
    and so on), R-specific types will be converted to types supported by SQLite before
    the data frame is inserted.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，差异很明显。在原始版本中，`cut`、`color`和`clarity`是有序因子变量，本质上是有一些元数据的整数（有序级别）。相比之下，在数据库版本中，这些列以文本形式存储。这种变化仅仅是因为SQLite没有内置对有序因子的支持。因此，除了常见的数据类型（数字、文本、逻辑等）之外，R特定的类型将在数据框插入之前转换为SQLite支持的类型。
- en: Learning SQL to query relational databases
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习SQL以查询关系型数据库
- en: In the previous section, you learned how to write data into a SQLite database.
    In this section, you will learn how to query such a database so that we can get
    data from it according to our needs. We'll use `data/datasets.sqlite` (we created
    previously) in the following examples.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何将数据写入SQLite数据库。在本节中，你将学习如何查询此类数据库，以便我们可以根据我们的需求从中获取数据。以下示例我们将使用`data/datasets.sqlite`（我们之前创建的）。
- en: 'First, we need to establish a connection to the database:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要与数据库建立连接：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are two tables in the database. Then, we can select all data from `diamonds`
    using the `select` statement. Here, we want to select all columns (or fields).
    So, we will call `dbGetQuery()` with the database connection, `con`, and a query
    string:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中有两个表。然后，我们可以使用`select`语句从`diamonds`中选择所有数据。在这里，我们想要选择所有列（或字段）。因此，我们将使用数据库连接`con`和查询字符串调用`dbGetQuery()`：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that `*` means all fields (or, equivalently, columns). If we only need
    a subset of fields, we can name the fields in turn:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`*`表示所有字段（或等价地，列）。如果我们只需要字段的子集，我们可以依次命名字段：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we want to select all distinct cases that appear in the data, we can use
    `select distinct`. For example, the following code returns all distinct values
    of `cut` in `diamonds`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要选择数据中出现的所有不同情况，我们可以使用`select distinct`。例如，以下代码返回`diamonds`中`cut`的所有不同值：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that `dbGetQuery()` always returns `data.frame`, even though sometimes
    there is only one column. To retrieve the values as an atomic vector, just extract
    the first column from the data frame:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`dbGetQuery()`始终返回`data.frame`，即使有时只有一个列。要检索作为原子向量的值，只需从数据框中提取第一列：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we use `select` to select columns to query, sometimes, the column name
    is not exactly what we want. In this case, we can use `A as B` to get column `B`
    with the same data as `A`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `select` 来选择查询的列时，有时列名可能不是我们想要的。在这种情况下，我们可以使用 `A as B` 来获取与 `A` 相同数据的列
    `B`：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In some other cases, the value we want is not present in the database, but
    needs some calculation to figure out. Now, we will use `A as B` in which `A` can
    be an arithmetic calculation between existing columns:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些其他情况下，我们想要的值不在数据库中，但需要一些计算来确定。现在，我们将使用 `A as B`，其中 `A` 可以是现有列之间的算术计算：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What if we create a new column with existing columns and create another column
    with the new column, just like the following example?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个新列，该列由现有列组成，然后再创建一个新列，该列由新列组成，就像以下示例一样？
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We simply can''t do this. In `A as B`, `A` must be composed of existing columns.
    However, if we insist on doing so, we can use nested query, that is, we `select`
    columns from a temporary table produced by a nested `select`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根本无法做到这一点。在 `A as B` 中，`A` 必须由现有列组成。然而，如果我们坚持这样做，我们可以使用嵌套查询，即从嵌套 `select`
    生成的临时表中 `select` 列：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, `size` is defined in the temporary table when `price` /`size`
    is being computed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`size` 是在计算 `price / size` 时在临时表中定义的。
- en: 'The next important component of a database query is a condition. We can use
    `where` to specify the conditions that the results must satisfy. For example,
    we can select diamonds with `Good` cut:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库查询的下一个重要组成部分是条件。我们可以使用 `where` 来指定结果必须满足的条件。例如，我们可以选择 `Good` 切工的钻石：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that records with good cut are only a small proportion of all records:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，具有良好切工的记录只占所有记录的一小部分：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we have multiple conditions that must be met simultaneously, we can use
    `and` to combine these conditions. For example, we will select all records with `Good`
    cut and color `E`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多个必须同时满足的条件，我们可以使用 `and` 来组合这些条件。例如，我们将选择所有 `Good` 切工和颜色为 `E` 的记录：
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Similar logical operations also include `or` and `not`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的逻辑运算还包括 `or` 和 `not`。
- en: 'In addition to the simple logical operations, we can also use `in` to filter
    records by examining whether the value of a field is contained in a given set.
    For example, we can select records with colors `E` and `F`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的逻辑运算外，我们还可以使用 `in` 通过检查字段的值是否包含在给定的集合中来过滤记录。例如，我们可以选择颜色为 `E` 和 `F` 的记录：
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can verify the result by the following table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下表格验证结果：
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To use `in`, we need to specify a set. Similar to `in`, we can also use `between
    and` which that allow us to specify a range:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `in`，我们需要指定一个集合。类似于 `in`，我们还可以使用 `between and`，它允许我们指定一个范围：
- en: '[PRE35]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In fact, the range does not have to be numeric. As long as the data type of
    the field is comparable, we can specify a range. For string column, we can write
    `between 'string1' to 'string2'` to filter records by lexical ordering.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，范围不必是数字。只要字段的数据类型是可比较的，我们就可以指定一个范围。对于字符串列，我们可以写 `between 'string1' to 'string2'`
    来通过词序过滤记录。
- en: 'Another useful operator for string column is `like`, which enables us to filter
    records with simple string patterns. For example, we can select all records with
    a `cut` variable that ends with `Good`. It can be either `Good` or `Very Good`.
    The notation is `like ''%Good''` where `%` matches all strings:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对字符串列有用的运算符是 `like`，它使我们能够通过简单的字符串模式过滤记录。例如，我们可以选择所有 `cut` 变量以 `Good` 结尾的记录。它可以是
    `Good` 或 `Very Good`。表示法是 `like '%Good'`，其中 `%` 匹配所有字符串：
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Another major functionality of database query is sorting data with specified
    columns. We can do this with `order by`. For example, we can get the `carat` and `price`
    of all records but in an ascending order of `price`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库查询的另一个主要功能是使用指定列对数据进行排序。我们可以使用 `order by` 来做这件事。例如，我们可以按 `price` 的升序获取所有记录的
    `carat` 和 `price`：
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Therefore, we have a data frame of diamonds that is ordered from the cheapest
    to the most expensive ones:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个按从最便宜到最贵的顺序排列的钻石数据帧：
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can do the opposite by adding `desc` to the sorting column so that we get
    a data frame that is ordered in the opposite way:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在排序列中添加 `desc` 来做相反的操作，这样我们得到的数据帧就是按相反的顺序排序的：
- en: '[PRE39]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also sort the records with more than one column. For example, the following
    results are sorted by price in the ascending order first. If two records have
    equal price, the one with greater carat will be put ahead:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以按多个列对记录进行排序。例如，以下结果首先按价格升序排序。如果两个记录的价格相同，则具有更大 `carat` 的记录将被放在前面：
- en: '[PRE40]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Like `select`, the column to sort can be computed from existing columns:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与`select`类似，排序的列可以由现有列计算得出：
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also query the sorted subset of all records using `where` and `order
    by` at the same time:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以同时使用`where`和`order by`查询所有记录的排序子集：
- en: '[PRE42]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we only care about the first several results, we can use `limit` to constrain
    the number of records to retrieve:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只关心前几个结果，我们可以使用`limit`来限制要检索的记录数：
- en: '[PRE43]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In addition to column selection, conditional filtering, and sorting, we can
    also aggregate the records in database in groups. For example, we can count the
    number of records for each color:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列选择、条件过滤和排序之外，我们还可以在数据库中以组的形式聚合记录。例如，我们可以计算每种颜色的记录数量：
- en: '[PRE44]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The results can be verified by calling `table()` with the original data:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`table()`与原始数据一起验证结果：
- en: '[PRE45]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In addition to counting, we also have aggregating functions such as `avg()`, `max()`, `min()`,
    and `sum()`. For example, we can summarize the data by looking at the average
    price for each level of clarity:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计数之外，我们还有如`avg()`、`max()`、`min()`和`sum()`之类的聚合函数。例如，我们可以通过查看每个清晰度级别的平均价格来总结数据：
- en: '[PRE46]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can also examine the maximal carat at the five lowest prices:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查五个最低价格的最大克拉数：
- en: '[PRE47]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can also perform multiple calculations in a group. The following code calculates
    the range of prices and their average value for each clarity level:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在组内执行多个计算。以下代码计算了每个清晰度级别的价格范围及其平均值：
- en: '[PRE48]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following example calculates an average price for each clarity level weighted
    by carat, that is, a price with greater carat has more weight:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例计算了每个清晰度级别的加权平均价格，即克拉数更大的价格具有更大的权重：
- en: '[PRE49]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Just like sorting with more than one column, we can also group the data by
    multiple columns. The following code computes the average price for each clarity
    and color pair, and shows the top five pairs with the highest average prices:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像按多个列排序一样，我们也可以按多个列对数据进行分组。以下代码计算了每个清晰度和颜色对的平均价格，并显示了平均价格最高的前五个对：
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The most relational operation in a relational database should be table join,
    that is, joining a number of tables together by some columns. For example, we
    will create a data frame of `cut`, `color`, and `clarity` to select records with
    exactly the same field values of the three cases in `diamond_selector`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中最相关的操作应该是表连接，即通过某些列将多个表连接在一起。例如，我们将创建一个包含`cut`、`color`和`clarity`的数据帧，以选择与`diamond_selector`中三个案例完全相同的字段值的记录：
- en: '[PRE51]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After creating the data frame, we write it to the database so that we can join
    `diamonds` and `diamond_selector` to filter the desirable records:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据帧后，我们将其写入数据库，以便我们可以将`diamonds`和`diamond_selector`连接起来以过滤所需的记录：
- en: '[PRE52]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can specify the columns to match in the join-clause:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在连接子句中指定要匹配的列：
- en: '[PRE53]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In total, we have only a tiny portion of all records that satisfy one of the
    three cases:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们只有所有记录中极小的一部分满足以下三种情况之一：
- en: '[PRE54]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, don''t forget to disconnect the database to ensure that all resources
    are properly released:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了断开数据库连接，以确保所有资源都得到适当释放：
- en: '[PRE55]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the previous examples, we only showed the basic use of SQL to query a relational
    database such as SQLite. In fact, SQL is richer and much more powerful than we
    have demonstrated. For more details, visit [http://www.w3schools.com/sql](http://www.w3schools.com/sql)
    and learn more.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只展示了使用SQL查询关系数据库（如SQLite）的基本用法。实际上，SQL比我们展示的更丰富、更强大。有关更多详细信息，请访问[http://www.w3schools.com/sql](http://www.w3schools.com/sql)并了解更多。
- en: Fetching query results chunk by chunk
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分块获取查询结果
- en: In the beginning of the section, we mentioned that one of the advantages of
    using a relational database is that we can store a large amount of data. Usually,
    we only take out a subset of the database and do some research. However, sometimes,
    we need to go through an amount of data that exceeds the capacity of computer
    memory. Obviously, we cannot load all of the data into memory, but must process
    the data chunk by chunk.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，我们提到使用关系数据库的一个优点是我们可以存储大量数据。通常，我们只取出数据库的子集进行一些研究。然而，有时我们需要处理的数据量超出了计算机内存的容量。显然，我们不能将所有数据加载到内存中，而必须分块处理数据。
- en: 'Most reasonable relational databases support fetching a query result set chunk
    by chunk. In the following example, we will use `dbSendQuery()` instead of `dbGetQuery()`
    to get a result set. Then, we will repeat fetching chunks (a number of rows) from
    the result set until all results are fetched. In this way, we can process the
    data chunk by chunk without using a large amount of working memory:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数合理的关联数据库都支持分块获取查询结果集。在下面的示例中，我们将使用 `dbSendQuery()` 而不是 `dbGetQuery()` 来获取结果集。然后，我们将重复从结果集中获取数据块（行数）直到所有结果都被获取。这样，我们可以分块处理数据，而不需要使用大量的工作内存：
- en: '[PRE56]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In practice, the database may have billions of records. The query may result
    in tens of millions of records. If you use `dbGetQuery()` to fetch the whole result
    set at once, your memory may not be sufficient. If the task can be finished by
    processing data chunks, it can be much cheaper to work chunk by chunk.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，数据库可能有数十亿条记录。查询可能返回数千万条记录。如果你使用 `dbGetQuery()` 一次性获取整个结果集，你的内存可能不足。如果任务可以通过处理数据块来完成，那么分块处理会便宜得多。
- en: Using transactions for consistency
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事务保证一致性
- en: Popular relational databases have a strong ability to ensure consistency. When
    we insert or update data, we do it via transactions. If a transaction fails, we
    can undo the transaction and rollback the database to ensure that everything is
    consistent.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的关系数据库具有强大的确保一致性的能力。当我们插入或更新数据时，我们通过事务来完成。如果事务失败，我们可以撤销事务并回滚数据库，以确保一切保持一致。
- en: 'The following example is a simple simulation of the data accumulation process
    that may fail in the middle of the process. Suppose we need to accumulate the
    data of some products and store it in `data/products.sqlite`. Each time a chunk
    of data is produced, we need to append it to a table in the database. In each
    iteration, however, the process may fail with a probability of 20 percent:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是对可能在过程中失败的数据累积过程的简单模拟。假设我们需要累积某些产品的数据并将其存储在 `data/products.sqlite` 中。每次产生数据块时，我们需要将其追加到数据库中的表中。然而，在每次迭代中，这个过程有20%的概率会失败：
- en: '[PRE57]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The accumulation fails when processing chunk 5\. Then, we will count the records
    in the table:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理第5个数据块时，累积失败。然后，我们将计算表中的记录数：
- en: '[PRE58]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can find that the table has stored a number of records. In some cases, we
    want either all records to be properly stored or we want nothing to be put into
    the database. In both cases, the database is consistent. However, if only half
    of the data is stored, some other problems may occur. To ensure that a series
    of database changes succeed or fail as a whole, we can call `dbBegin()` before
    we write any data, call `dbCommit()` after all changes are made, and call `dbRollback()`
    if anything goes wrong.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发现表中存储了许多记录。在某些情况下，我们希望所有记录都得到适当的存储，或者我们希望什么也不放入数据库。在这两种情况下，数据库都是一致的。然而，如果只有一半的数据被存储，可能会出现其他问题。为了确保一系列数据库更改成功或失败作为一个整体，我们可以在写入任何数据之前调用
    `dbBegin()`，在所有更改完成后调用 `dbCommit()`，如果出现问题，则调用 `dbRollback()`：
- en: 'The following code is an enhanced version of the previous example. We use transactions
    to make sure either all chunks are written to the database or none. More specifically,
    we put the data-writing process in `tryCatch`. Before the writing begins, we begin
    a transaction by calling `dbBegin()`. Then, in `tryCatch`, we will write data
    chunk by chunk to the database. If everything goes well, we will call `dbCommit()`
    to commit the transaction so that all the changes are committed. If anything goes
    wrong, the error will be captured by the error function in which we produce a
    warning and rollback by `dbRollback()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是前一个示例的增强版本。我们使用事务来确保所有数据块要么都写入数据库，要么一个都不写。更具体地说，我们将数据写入过程放在 `tryCatch`
    中。在写入开始之前，我们通过调用 `dbBegin()` 开始一个事务。然后，在 `tryCatch` 中，我们将数据块逐个写入数据库。如果一切顺利，我们将调用
    `dbCommit()` 提交事务，以便所有更改都得到提交。如果出现问题，错误将被错误函数捕获，我们产生一个警告并通过 `dbRollback()` 回滚：
- en: '[PRE59]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can see that the same error happens again. However, this time, the error
    is captured, the transaction cancelled, and the database rolled back. To verify,
    we can again count the number of records in the `products` table:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到同样的错误再次发生。然而，这次，错误被捕获，事务被取消，数据库回滚。为了验证，我们再次计算 `products` 表中的记录数：
- en: '[PRE60]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It may be surprising that the counting query results in an error. Why does it
    not return 0? If we take a closer look at the example, we should understand that
    the first time we call `dbWriteTable()`, it creates a new table first and then
    inserts the data in the first chunk. In other words, the table creation is included
    in the transaction. So, when we roll back, the table creation is undone too. As
    a result, the preceding counting query produces an error because `products` does
    not exist at all. If the table exists before we begin a transaction, the count
    should be equal to the number of records before the transaction as if nothing
    happened.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会令人惊讶的是，计数查询会导致错误。为什么它不返回 0？如果我们仔细观察示例，我们应该理解，当我们第一次调用 `dbWriteTable()` 时，它首先创建一个新表，然后插入第一块数据。换句话说，表创建包含在事务中。因此，当我们回滚时，表创建也会被撤销。结果，先前的计数查询产生错误，因为
    `products` 实际上并不存在。如果我们开始事务之前表已经存在，计数应该等于事务之前的记录数，就像什么都没发生一样。
- en: Another example that requires strong consistency is account transfer. When we
    transfer an amount of money from one account to another, we need to ensure that
    the system withdraws the money from one account and deposits the same amount to
    the other account. The two changes must both happen or both fail to keep consistency.
    This can be easily done with transactions of relational databases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要强一致性的例子是账户转账。当我们从一个账户向另一个账户转账一定金额时，我们需要确保系统从第一个账户中扣除相应金额，并将相同金额存入第二个账户。这两个变更必须同时发生或同时失败以保持一致性。这可以通过关系型数据库的事务轻松实现。
- en: 'Suppose we define a function that creates a SQLite database of a virtual bank.
    We will use `dbSendQuery()` to send commands to create a table of accounts and
    a table of transactions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们定义一个函数来创建一个虚拟银行的 SQLite 数据库。我们将使用 `dbSendQuery()` 发送命令来创建账户表和事务表：
- en: '[PRE61]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The accounts table has two columns: `name` and `balance`. The transactions
    table has four columns: `time`, `account_from`, `account_to`, and `value`. The
    first table stores all the information of accounts, and the second one stores
    all historic transactions.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 账户表有两个列：`name` 和 `balance`。事务表有四个列：`time`、`account_from`、`account_to` 和 `value`。第一个表存储所有账户信息，第二个表存储所有历史交易。
- en: 'We will also define a function to create an account with a name and initial
    balance. The function uses `insert into` to write a new record to the accounts
    table:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个函数，用于创建一个具有名称和初始余额的账户。该函数使用 `insert into` 语句将一条新记录写入账户表：
- en: '[PRE62]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we uses `sprintf` to produce the preceding SQL statement. It is acceptable
    for local and personal use, but it is generally not safe for web applications,
    because a hacker can easily write a partial expression to run any disastrous statements
    to manipulate the whole database.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `sprintf` 生成前面的 SQL 语句。它适用于本地和个人使用，但通常不适用于网络应用程序，因为黑客可以轻松地编写部分表达式来运行任何灾难性的语句来操纵整个数据库。
- en: 'Next, we will define a transfer function. The function checks whether the withdrawing
    account and receiving account both exist in the database. It ensures that the
    balance of the withdrawing account is sufficient for such an amount of transfer.
    If the transfer is valid, then it updates the balance of both accounts and adds
    a transaction record to the database:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个转账函数。该函数检查提款账户和收款账户是否都存在于数据库中。它确保提款账户的余额足以进行此类转账。如果转账有效，则更新两个账户的余额，并将一条事务记录添加到数据库中：
- en: '[PRE63]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Although we have some basic checking against possible insufficient funds of
    the withdrawing account, we still cannot ensure that the transfer is safe, because
    it can be interrupted by other causes. Therefore, we will implement a safe version
    of `transfer` in which we will use transaction to ensure that any changes made
    by `transfer` can be undone if anything goes wrong:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们对提款账户可能的资金不足进行了一些基本检查，但我们仍然不能确保转账的安全性，因为它可能被其他原因中断。因此，我们将实现一个安全的 `transfer`
    版本，其中我们将使用事务来确保如果发生任何错误，`transfer` 所做的任何更改都可以撤销：
- en: '[PRE64]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In fact, `safe_transfer` is a wrapper function of `transfer`. It just puts `transfer`
    in a sandbox of `tryCatch`. If an error occurs, we call `dbRollback()` to ensure
    that the database is consistent.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`safe_transfer` 是 `transfer` 的包装函数。它只是将 `transfer` 放入 `tryCatch` 的沙盒中。如果发生错误，我们调用
    `dbRollback()` 来确保数据库的一致性。
- en: 'Before putting the functions into tests, we need functions to view the balance
    of a given account as well as all successful transactions that happened between
    accounts:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在将函数放入测试之前，我们需要函数来查看给定账户的余额以及账户之间发生的所有成功交易：
- en: '[PRE65]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we can do some tests. First, we will create a virtual bank using `create_bank()`
    that returns a SQLite connection to the database file. Then, we will create two
    accounts with some initial balance:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进行一些测试。首先，我们将使用 `create_bank()` 创建一个虚拟银行，该函数返回数据库文件的 SQLite 连接。然后，我们将创建两个账户并设置一些初始余额：
- en: '[PRE66]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, we will use `safe_transfer()` to transfer some money from David''s account
    to Jenny''s account:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `safe_transfer()` 将一些钱从大卫的账户转到珍妮的账户：
- en: '[PRE67]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The transfer succeeds, and the balances of both accounts are changed in a consistent
    manner. Now, we will make another transfer. This time, the balance of David''s
    account is not sufficient, so the transfer will end up with an error:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 转账成功，两个账户的余额以一致的方式改变。现在，我们将进行另一笔转账。这次，大卫的账户余额不足，所以转账将以错误结束：
- en: '[PRE68]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The error is captured, and the function rolls back the database. The balances
    of both accounts do not change. Now, we will query all successful transactions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 错误被捕获，函数回滚数据库。两个账户的余额都没有变化。现在，我们将查询所有成功的交易：
- en: '[PRE69]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can see the first transaction, but the failed transaction does not appear
    in the database. Finally, we should always remember to close the database connection:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到第一笔交易，但失败的交易没有出现在数据库中。最后，我们应始终记得关闭数据库连接：
- en: '[PRE70]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Storing data in files to a database
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据存储在文件到数据库中
- en: When we deal with large data files, we may usually get stuck with issues of
    reading and writing data. There are two extremes in practice. One extreme is a
    really big text-format data source that is almost impossible to load into memory.
    The other is a large number of small pieces of data files that will require some
    effort to integrate them into one data frame.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理大型数据文件时，我们可能会遇到读写数据的问题。在实践中，有两种极端情况。一种极端是极其庞大的文本格式数据源，几乎不可能将其加载到内存中。另一种是大量的小数据文件，需要一些努力将它们整合到一个数据框中。
- en: 'For the first case, we can read the big source data chunk by chunk and append
    each chunk to a certain table in a database. The following function is designed
    for appending rows to a database table from a big source given an input file,
    an output database, a table name, and a chunk size. Consider that the input data
    may be too large to load into the memory, so the function will read one chunk
    each time to write to database and, thus, only require a small working memory:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，我们可以分块读取大源数据，并将每个块追加到数据库中的一个特定表中。以下函数是为从大源文件向数据库表追加行而设计的，给定输入文件、输出数据库、表名和块大小。考虑到输入数据可能太大而无法加载到内存中，所以该函数将每次读取一个块以写入数据库，因此只需要很少的工作内存：
- en: '[PRE71]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The trick here is to correctly calculate the offset of each chunk in the input
    file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是正确计算输入文件中每个块的位置偏移量。
- en: 'To test the function, we will first write `diamonds` into a csv file and use `chunk_rw()`
    to write the csv file into a SQLite database chunk by chunk. With this method,
    the writing process only requires a much smaller working memory than is required
    for loading the whole data into memory:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试函数，我们首先将 `diamonds` 写入一个 csv 文件，并使用 `chunk_rw()` 将 csv 文件分块写入 SQLite 数据库。使用这种方法，写入过程只需要比将整个数据加载到内存中所需的内存小得多：
- en: '[PRE72]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Another extreme of loading data is that we need to read from many small data
    files. In this case, we can put all the data distributed in these files in a database
    so that we can easily query data from it. The following function is intended for
    putting the data of all csv files in a folder to one database:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据的另一种极端情况是我们需要从许多小数据文件中读取。在这种情况下，我们可以将这些文件中分布的所有数据放入数据库中，这样我们就可以轻松地查询数据。以下函数旨在将文件夹中所有
    csv 文件的数据放入一个数据库中：
- en: '[PRE73]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To demonstrate, we have a number of small csv files in `data/groups`, and we
    use `batch_rw()` to put all the data into a database:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们在 `data/groups` 中有一些小的 csv 文件，并使用 `batch_rw()` 将所有数据放入数据库中：
- en: '[PRE74]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, all the data in the files is put into the database. We can query or read
    the whole table and see what is looks like:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有文件中的数据都已放入数据库中。我们可以查询或读取整个表，看看它看起来像什么：
- en: '[PRE75]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this section, you learned some basic knowledge and usage of SQLite database.
    However, many popular relational databases share many common features of functionality
    and the query language. With almost the same knowledge, you can work with MySQL
    via RMySQL, PostreSQL via RPostges, Microsoft SQL Server via RSQLServer, and ODBC-compatible
    databases (Microsoft Access and Excel) via RODBC. They share almost the same operating
    functions, so if you are familiar with one, you shouldn't have a problem working
    with others.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了一些 SQLite 数据库的基本知识和用法。然而，许多流行的关系型数据库在功能和查询语言方面有许多共同特征。几乎相同的知识，你可以通过
    RMySQL 使用 MySQL，通过 RPostges 使用 PostgreSQL，通过 RSQLServer 使用 Microsoft SQL Server，以及通过
    RODBC 使用 ODBC 兼容的数据库（Microsoft Access 和 Excel）。它们具有几乎相同的操作功能，所以如果你熟悉其中一个，你就不应该有在使用其他数据库时的问题。
- en: Working with NoSQL databases
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 NoSQL 数据库一起工作
- en: In the previous section of this chapter, you learned the basics of relational
    databases and how to use SQL to query data. Relational data is mostly organized
    in a tabular form, that is, as a collection of tables with relations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一节中，你学习了关系型数据库的基础知识以及如何使用 SQL 查询数据。关系型数据通常以表格形式组织，即作为具有关系的表集合。
- en: However, when the volume of data exceeds the capacity of a server, problems
    occur because the traditional model of relational databases does not easily support
    horizontal scalability, that is, storing data in a cluster of servers instead
    of a single one. This adds a new layer of complexibility of database management
    as the data is stored in a distributed form while still accessible as one logical
    database.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当数据量超过服务器的容量时，由于传统的关系型数据库模型不容易支持水平扩展，即不是存储在单个服务器上而是在服务器集群中存储数据，因此会出现问题。这增加了数据库管理的复杂性，因为数据以分布式形式存储，同时仍然作为一个逻辑数据库访问。
- en: In recent years, NoSQL, or non-relational databases, have become much more popular
    than before due to the introduction of new database models and the remarkable
    performance they exhibit in big data analytics and real-time applications. Some
    non-relational databases are designed for high availability, scalability, and
    flexibility, and some for high performance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，由于新数据库模型的引入以及它们在大数据分析实时应用中展现的卓越性能，NoSQL 或非关系型数据库比以前更加流行。一些非关系型数据库旨在实现高可用性、可扩展性和灵活性，而另一些则旨在实现高性能。
- en: 'The difference in storage model between relational databases and non-relational
    databases is notable. For example, for a shopping website, the goods and comments
    can be stored in a relational database with two tables: goods and comments. All
    the information of goods is stored in one table, and all comments on each good
    are stored in the other. The following code shows the basic structure of such
    tables:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库和非关系型数据库在存储模型上的差异非常明显。例如，对于一个购物网站，商品和评论可以存储在关系型数据库的两个表中：商品和评论。所有商品信息存储在一个表中，每个商品的评论存储在另一个表中。以下代码显示了此类表的基本结构：
- en: '[PRE76]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Each comment has a field that points to the product it is subject to:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每条评论都有一个字段指向它所针对的产品：
- en: '[PRE77]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When a product has many related tables and the number of records is so large
    that the database must be distributed across a great number of servers, it would
    be hard to query such a database because executing a simple query can be extremely
    inefficient. If we use MongoDB to store such data, each good will stored as a
    document and all comments of this good are stored in an array as a field of the
    document. As a result, it would be easy to query the data, and the database can
    be easily distributed to a large number of servers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个产品有许多相关表且记录数量如此之大以至于数据库必须分布到大量服务器上时，查询这样的数据库会非常困难，因为执行一个简单的查询可能非常低效。如果我们使用
    MongoDB 来存储这样的数据，每个商品都将作为一个文档存储，而这个商品的评论都作为文档的字段存储在一个数组中。因此，查询数据将变得非常容易，数据库可以轻松地分布到大量服务器上。
- en: Working with MongoDB
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 MongoDB 一起工作
- en: MongoDB is a popular non-relational database that provides a document-oriented
    way of storing data. Each product is a document in a collection. The product has
    some fields of descriptive information and has a field that is an array of comments.
    All comments are subdocuments so that each logical item can be stored in their
    own logical form.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个流行的非关系型数据库，它提供了一种面向文档的数据存储方式。每个产品都是一个集合中的文档。产品有一些描述性信息的字段，还有一个包含评论的数组字段。所有评论都是子文档，这样每个逻辑项都可以以它们自己的逻辑形式存储。
- en: 'Here is a JSON ([https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON))
    representation of a good in the collection:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是集合中一个商品的 JSON ([https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON))
    表示：
- en: '[PRE78]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: A relational database may contain many schemas. Each schema (or database) may
    consist of many tables. Each table may contain many records. Similarly, a MongoDB
    instance can host many databases. Each database can include many collections.
    Each collection may contain many documents. The main difference is that the records
    in a table of a relational database need to have the same structure, but a document
    in a collection of a MongoDB database is schema-less and is flexible enough to
    have nested structures.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库可能包含许多模式。每个模式（或数据库）可能包含许多表。每个表可能包含许多记录。同样，MongoDB 实例可以托管许多数据库。每个数据库可以包含许多集合。每个集合可能包含许多文档。主要区别在于关系型数据库表中的记录需要具有相同的结构，但
    MongoDB 数据库集合中的文档是无模式的，并且足够灵活，可以具有嵌套结构。
- en: In the preceding JSON code, for example, a good is represented by such a document
    in which `code`, `name`, `type`, `price`, and `amount` are data fields with simple
    data types while `comments` is an array of objects. Each comment is represented
    by an object in `comments` and has a structure of `user`, `score`, and `text`.
    All comments of a good are stored as an object in `comments`. Therefore, a good
    is highly self-contained in terms of product information and comments. If we need
    information of a product, we no longer need to join two tables but pick out several
    fields.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 JSON 代码中，例如，一个商品由以下文档表示，其中 `code`、`name`、`type`、`price` 和 `amount` 是具有简单数据类型的数据字段，而
    `comments` 是对象的数组。每个评论由 `comments` 中的一个对象表示，并具有 `user`、`score` 和 `text` 的结构。一个商品的所有评论都存储在
    `comments` 中的一个对象中。因此，在产品信息和评论方面，一个商品高度自包含。如果我们需要产品的信息，我们不再需要连接两个表，只需挑选几个字段即可。
- en: To install MongoDB, visit [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    and follow the instructions. It supports nearly all major platforms.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 MongoDB，请访问 [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    并按照说明操作。它支持几乎所有主要平台。
- en: Querying data from MongoDB
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 MongoDB 查询数据
- en: 'Suppose we have a working MongoDB instance running on a local machine. We can
    use the `mongolite` package to work with MongoDB. To install the package, run
    the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个在本地机器上运行的正常 MongoDB 实例。我们可以使用 `mongolite` 包来与 MongoDB 一起工作。要安装该包，请运行以下代码：
- en: '[PRE79]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Once we have the package installed, we can create a Mongo connection by specifying
    the collection, database, and MongoDB address:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了包，我们就可以通过指定集合、数据库和 MongoDB 地址来创建 Mongo 连接：
- en: '[PRE80]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'First, we will create a connection to the local MongoDB instance. Initially,
    the `products` collection has no documents:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建到本地 MongoDB 实例的连接。最初，`products` 集合没有文档：
- en: '[PRE81]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To insert the product with comments, we can directly supply the JSON document
    as a string to `m$insert()`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入带有注释的产品，我们可以直接将 JSON 文档作为字符串传递给 `m$insert()`：
- en: '[PRE82]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, the collection has one document:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，集合中有一个文档：
- en: '[PRE83]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Alternatively, we can use list object in R to represent the same structure.
    The following code inserts the second product with `list`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 R 中的列表对象来表示相同的结构。以下代码使用 `list` 插入第二个产品：
- en: '[PRE84]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note that R does not provide a scalar type so that, by default, all vectors
    are interpreted as JSON arrays in MongoDB, unless `auto_unbox = TRUE`, which turns
    one-element vectors into scalars in JSON. Without `auto_unbox = TRUE`, one has
    to use either `jsonlite::unbox()` to ensure scalar output or `I()` to ensure array
    output.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，R 不提供标量类型，因此默认情况下，所有向量在 MongoDB 中都被解释为 JSON 数组，除非 `auto_unbox = TRUE`，这会将单元素向量转换为
    JSON 中的标量。如果没有 `auto_unbox = TRUE`，就必须使用 `jsonlite::unbox()` 来确保标量输出或使用 `I()`
    来确保数组输出。
- en: 'Now, the collection has two documents:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，集合中有两个文档：
- en: '[PRE85]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, we can use `m$find()` to retrieve all documents in the collection, and
    the results are automatically simplified into a data frame for easier data manipulation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `m$find()` 来检索集合中的所有文档，结果会自动简化为数据框，以便更容易地进行数据处理：
- en: '[PRE86]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To avoid the automatic conversion, we can use `m$iterate()` to iterate over
    the collection and get list objects that represent the original form of storage:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免自动转换，我们可以使用 `m$iterate()` 遍历集合，并获取表示原始存储形式的列表对象：
- en: '[PRE87]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: To filter the collection, we can specify the conditional query and fields in
    `m$find()`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤集合，我们可以在 `m$find()` 中指定条件查询和字段。
- en: 'First, we will query documents with `code` of `A0000001` and retrieve the `name`, `price`,
    and `amount` fields:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查询`code`为`A0000001`的文档，并检索`name`、`price`和`amount`字段：
- en: '[PRE88]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, we will query documents with `price` greater than or equal to `40`, which
    is done by the `$gte` operator in the conditional query:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将查询`price`大于或等于`40`的文档，这是通过条件查询中的`$gte`运算符完成的：
- en: '[PRE89]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can not only query the document fields, but also the object fields in an
    array field. The following code retrieves all documents with any comment that
    gives a 9-point score:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以查询文档字段，还可以查询数组字段中的对象字段。以下代码检索所有包含任何给出9分评论的文档：
- en: '[PRE90]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Similarly, the following code retrieves all documents with any comment that
    gives a score less than 6:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下代码检索所有包含任何给出低于6分评论的文档：
- en: '[PRE91]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Note that accessing the field of a subdocument is easily done by the `.` notation,
    which makes it pretty easy to work with nested structures:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过使用`.`符号，可以轻松访问子文档的字段，这使得处理嵌套结构变得相当容易：
- en: '[PRE92]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `m$insert()` function also works with data frames in R. Now, we will create
    a new MongoDB connection to another collection:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`m$insert()`函数也适用于R中的数据框。现在，我们将创建一个新的MongoDB连接到另一个集合：'
- en: '[PRE93]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We will create a MongoDB connection, `m`, to work with the `students` collection
    in the `test` database in a local MongoDB instance:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个MongoDB连接`m`，以在本地MongoDB实例中的`test`数据库的`students`集合中工作：
- en: '[PRE94]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Initially, the collection has no documents. To insert some data, we will create
    a simple data frame:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，集合中没有文档。为了插入一些数据，我们将创建一个简单的数据框：
- en: '[PRE95]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Then, we will insert the rows as documents into the collection:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将作为文档将行插入到集合中：
- en: '[PRE96]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, the collection has some documents:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，集合中已经有了一些文档：
- en: '[PRE97]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We can retrieve all the documents from the collection using `find()`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`find()`从集合中检索所有文档：
- en: '[PRE98]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As we mentioned in the previous example, the way in which documents are stored
    in a MongoDB collection is different from the way columns are stored in a table
    of a relational database. A document in a MongoDB collection is more like a JSON
    document, but in fact, it is stored in binary form to achieve super performance
    and compactness. The `m$find()` function first retrieves the data in a JSON-like
    form and simplifies it into a data form for easy data manipulation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的示例中提到的，文档在MongoDB集合中的存储方式与关系数据库表中列的存储方式不同。MongoDB集合中的一个文档更像是JSON文档，但实际上它是以二进制形式存储的，以实现超级性能和紧凑性。`m$find()`函数首先以类似JSON的形式检索数据，并将其简化为数据形式，以便于数据操作。
- en: 'To filter the data, we can specify the query condition by supplying documents
    to `find()`. For example, we want to find all documents whose name is `Jenny`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤数据，我们可以通过向`find()`提供查询条件来指定查询条件。例如，我们想要找到所有名为`Jenny`的文档：
- en: '[PRE99]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The results are automatically coerced to a data frame to make it easier to
    use. Then, we will query all documents with a number of projects greater or equal
    to `2`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会自动转换为数据框，以便更容易使用。然后，我们将查询所有项目数量大于或等于`2`的文档：
- en: '[PRE100]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To select fields, we will specify the `fields` argument of `find()`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择字段，我们将指定`find()`的`fields`参数：
- en: '[PRE101]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We can also sort the data by specifying the `sort` argument:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过指定`sort`参数对数据进行排序：
- en: '[PRE102]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To limit the documents returned, we will specify `limit`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制返回的文档数量，我们将指定`limit`：
- en: '[PRE103]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Also, we can get all distinct values of a certain field of all documents:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以获取所有文档中某个字段的全部唯一值：
- en: '[PRE104]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can get the distinct values with a condition:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取满足条件的唯一值：
- en: '[PRE105]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To update a document, we will call `update()`, find the documents in selection,
    and set the values of certain fields:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新文档，我们将调用`update()`，找到选择中的文档，并设置某些字段的值：
- en: '[PRE106]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Creating and removing indexes
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和删除索引
- en: Like relational databases, MongoDB also supports indexes. Each collection may
    have multiple indexes, and the fields of indexes are cached in memory for fast
    lookup. Properly created indexes can make document lookup extremely efficient.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系数据库类似，MongoDB也支持索引。每个集合可能有多个索引，索引字段被缓存在内存中以实现快速查找。正确创建的索引可以使文档查找非常高效。
- en: Creating indexes in MongoDB with `mongolite` is easy. It can be done before
    or after we import data into the collection. However, if we already imported billions
    of documents, it can be time consuming to create an index. If we create many indexes
    before pouring any documents into the collection, the performance of inserting
    documents may be harmed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mongolite`在MongoDB中创建索引很容易。可以在将数据导入集合之前或之后进行。然而，如果我们已经导入数十亿个文档，创建索引可能需要很长时间。如果我们创建许多索引，然后在集合中放入任何文档之前，插入文档的性能可能会受到影响。
- en: 'Here, we will create an index for the `students` collection:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将为`students`集合创建一个索引：
- en: '[PRE107]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now, if we find a document with the indexed field, the performance is super:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们找到具有索引字段的文档，性能将非常出色：
- en: '[PRE108]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If no document satisfies the condition, an empty data frame will be returned:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有文档满足条件，将返回一个空的数据框：
- en: '[PRE109]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Finally, the collection can be abandoned with `drop()`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用`drop()`方法丢弃集合：
- en: '[PRE110]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The performance boost of using an index is definitively not obvious if the amount
    of data is small. In the next example, we will create a data frame with many rows
    so that we can compare the performance of finding documents between using an index
    and not using one.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据量小，使用索引带来的性能提升并不明显。在下一个示例中，我们将创建一个具有许多行的数据框，以便我们可以比较使用索引和不使用索引查找文档的性能：
- en: 'Here, we will use `expand.grid()` to create a data frame that exhausts all
    possible combinations of the provided vectors in the arguments:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`expand.grid()`创建一个数据框，该数据框穷尽了所有可能的参数中提供的向量的组合：
- en: '[PRE111]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The index columns are created. Next, we need to simulate some random numbers:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 索引列已创建。接下来，我们需要模拟一些随机数：
- en: '[PRE112]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The data frame now looks like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的数据框看起来像这样：
- en: '[PRE113]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Then, we will insert all the data into the `simulation` collection:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将所有数据插入到`simulation`集合中：
- en: '[PRE114]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The first test is trying to answer how long it takes to query a document without
    any index:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次测试试图回答在没有索引的情况下查询文档需要多长时间：
- en: '[PRE115]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The second test is about the performance of finding documents with joint conditions:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试是关于使用联合条件查找文档的性能：
- en: '[PRE116]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Then, the resulting data frame looks like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，生成的数据框看起来像这样：
- en: '[PRE117]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The third test is about the performance of finding documents using a non-index
    field:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次测试是关于使用非索引字段查找文档的性能：
- en: '[PRE118]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The resulting data frame looks like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的数据框看起来像这样：
- en: '[PRE119]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'All three tests are done without creating an index for the collection. To make
    a contrast, we will now create an index:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个测试都是在没有为集合创建索引的情况下完成的。为了对比，我们现在将创建一个索引：
- en: '[PRE120]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Once the index is created, the query of the first test with index fields is
    quick:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了索引，使用索引字段进行第一次测试查询就变得快速：
- en: '[PRE121]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The second test also yields results quickly:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次测试也很快得出结果：
- en: '[PRE122]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'However, the non-index fields do not contribute to the index search for documents:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非索引字段不会对文档的索引搜索做出贡献：
- en: '[PRE123]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Another important feature of MongoDB is its aggregation pipeline. When we aggregate
    data, we supply an array of aggregate operations so that they are scheduled by
    the MongoDB instance. For example, the following code groups the data by `type`.
    Each group has a field count, average score, min test score, and max test score.
    Since the output can be long, we don''t print it here. You may execute the code
    yourself and see the results:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的另一个重要特性是其聚合管道。当我们进行数据聚合时，我们提供一个聚合操作的数组，以便它们由MongoDB实例调度。例如，以下代码按`type`对数据进行分组。每个组都有一个计数字段、平均分数、最低测试分数和最高测试分数。由于输出可能很长，这里没有打印出来。您可以自己执行代码并查看结果：
- en: '[PRE124]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can also use multiple fields as the key of a group, which is similar to
    `group by A, B` in SQL:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用多个字段作为组的键，这类似于SQL中的`group by A, B`：
- en: '[PRE125]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The aggregation pipeline supports running aggregate operations in a streamline:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合管道支持在流式处理中运行聚合操作：
- en: '[PRE126]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We can lengthen the pipeline by adding more operations. For example, the following
    code creates groups and aggregate data. Then, it sorts the documents with average
    score in the descending order, takes out the top three documents, and projects
    the fields into something useful:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加更多操作来延长管道。例如，以下代码创建组并聚合数据。然后，它按平均分数降序排序文档，取出前三个文档，并将字段投影到有用的内容中：
- en: '[PRE127]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In addition to the aggregate operators we used in the example, there are many
    other operators that are more powerful. For more details, visit [https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/](https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/)
    and [https://docs.mongodb.com/manual/reference/operator/aggregation-arithmetic/](https://docs.mongodb.com/manual/reference/operator/aggregation-arithmetic/).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在示例中使用的聚合运算符之外，还有很多其他更强大的运算符。更多详情，请访问 [https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/](https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/)
    和 [https://docs.mongodb.com/manual/reference/operator/aggregation-arithmetic/](https://docs.mongodb.com/manual/reference/operator/aggregation-arithmetic/).
- en: 'Another important feature of MongoDB is that it supports MapReduce ([https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce))
    at an internal level. The MapReduce model is widely used in big data analytics
    in distributed clusters. In our environment, we can write an extremely simple
    MapReduce code that tries to produce a histogram of certain data:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的另一个重要特性是它在内部级别支持 MapReduce ([https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce))。MapReduce
    模型在分布式集群的大数据分析中得到了广泛应用。在我们的环境中，我们可以编写一个非常简单的 MapReduce 代码，尝试生成某些数据的直方图：
- en: '[PRE128]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The first step of MapReduce is map. In this step, all values are mapped to
    a key-value pair. Then, the reduce step aggregates the key-value pair. In the
    preceding example, we simply calculated the number of records for each bin:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce 的第一步是 map。在这一步中，所有值都被映射到一个键值对。然后，reduce 步骤聚合键值对。在上面的例子中，我们简单地计算了每个
    bin 的记录数：
- en: '[PRE129]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We can also create a bar plot from `bins`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从 `bins` 创建条形图：
- en: '[PRE130]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The plot generated is shown as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下所示：
- en: '![Creating and removing indexes](img/image_11_001.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![创建和删除索引](img/image_11_001.jpg)'
- en: 'If the collection is no longer used, then we can use the `drop()` function
    to drop it:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合不再使用，我们可以使用 `drop()` 函数将其删除：
- en: '[PRE131]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Since this section is at the introductory level, the more advanced use of MongoDB
    is beyond the scope of this book. If you are interested in MongoDB, go through
    the official tutorial at [https://docs.mongodb.com/manual/tutorial/](https://docs.mongodb.com/manual/tutorial/).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节是入门级内容，MongoDB 的更高级用法超出了本书的范围。如果您对 MongoDB 感兴趣，请通过官方教程进行学习 [https://docs.mongodb.com/manual/tutorial/](https://docs.mongodb.com/manual/tutorial/).
- en: Using Redis
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Redis
- en: Redis ([http://redis.io/](http://redis.io/)), unlike SQLite that stores data
    in tabular form or MongoDB that allows to store and query nested structures, is
    an in-memory data structure store. It stores key-values in memory and thus has
    very high performance of key lookup. However, it does not support query languages
    as used in SQL databases or MongoDB.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Redis ([http://redis.io/](http://redis.io/)) 与存储数据为表格形式的 SQLite 或允许存储和查询嵌套结构的
    MongoDB 不同，它是一个内存数据结构存储。它将键值存储在内存中，因此具有非常高的键查找性能。然而，它不支持像 SQL 数据库或 MongoDB 中使用的查询语言。
- en: Redis is usually used as a high-performance data cache. We can store and manipulate
    a range of basic data structures in it. To install Redis, visit [http://redis.io/download](http://redis.io/download).
    Unfortunately, the Windows operating system is not officially supported, but the
    Microsoft Open Tech group develops and maintains a Win64 port of Redis at [https://github.com/MSOpenTech/redis](https://github.com/MSOpenTech/redis).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 通常用作高性能数据缓存。我们可以在其中存储和操作一系列基本数据结构。要安装 Redis，请访问 [http://redis.io/download](http://redis.io/download)。不幸的是，Windows
    操作系统未得到官方支持，但微软开源技术组开发和维护了 Redis 的 Win64 端口，请访问 [https://github.com/MSOpenTech/redis](https://github.com/MSOpenTech/redis)。
- en: 'While SQL database stores tables and MongoDB stores documents, Redis stores
    key-value pairs as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQL 数据库存储表，MongoDB 存储文档，但 Redis 将键值对存储如下：
- en: '[PRE132]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The value can be more complex data structures (for example, hashmap, set, and
    sorted set) rather than simple values, and Redis provides a simple interface to
    work with these data structures in high performance and low latency.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以是更复杂的数据结构（例如，哈希表、集合和有序集合），而不仅仅是简单值，Redis 提供了一个简单的接口，以高性能和低延迟的方式与这些数据结构交互。
- en: Accessing Redis from R
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 R 访问 Redis
- en: 'To access a Redis instance from R, we can use the `rredis` package that provides
    simple functions to work with Redis. To install the package, run the following
    code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 R 访问 Redis 实例，我们可以使用提供简单函数与 Redis 交互的 `rredis` 包。要安装此包，请运行以下代码：
- en: '[PRE133]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Once the package is ready, we can connect to a Redis instance:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包准备就绪，我们就可以连接到 Redis 实例：
- en: '[PRE134]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: If we leave the arguments blank, it connects to the local Redis instance by
    default. It also lets us connect to a remote instance.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们留空参数，它默认连接到本地Redis实例。它还允许我们连接到远程实例。
- en: Setting and getting values from the Redis server
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Redis服务器设置和获取值
- en: 'The most basic use of Redis is to store a value by calling `redisSet(key, value)`.
    In R, the value is, by default, serialized so that we can store any R objects
    in Redis:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Redis最基本的使用方法是调用`redisSet(key, value)`来存储值。在R中，默认情况下，值会被序列化，这样我们就可以在Redis中存储任何R对象：
- en: '[PRE135]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now that the command has succeeded, we can retrieve the value with the same
    key:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 命令成功后，我们可以使用相同的键来检索值：
- en: '[PRE136]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We can store an integer vector:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以存储一个整数向量：
- en: '[PRE137]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We can even store a data frame:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以存储一个数据框：
- en: '[PRE138]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'In fact, if other computers have access to your Redis instance, they will get
    the same data in R using `redisGet()`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果其他计算机可以访问您的Redis实例，它们将使用`redisGet()`在R中得到相同的数据：
- en: 'However, we can only get `NULL` if the key does not exist at all:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果键根本不存在，我们只能得到`NULL`：
- en: '[PRE139]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Instead of getting `NULL`, we can use `redisExists()` to detect whether a key
    is defined:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`redisExists()`来检测一个键是否已定义，而不是得到`NULL`：
- en: '[PRE140]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'If we no longer need a key, we can delete it with `redisDelete()`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不再需要键，我们可以使用`redisDelete()`来删除它：
- en: '[PRE141]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'In addition to plain key-value pairs, Redis also supports more advanced data
    structures. For example, we can use `redisHSet()` to create a hash map of fruits
    in which different fruits have different numbers:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的键值对之外，Redis还支持更高级的数据结构。例如，我们可以使用`redisHSet()`来创建一个水果哈希表，其中不同的水果有不同的数量：
- en: '[PRE142]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'We can call `redisHGet()` to get the value of a field of a hash map:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`redisHGet()`来获取哈希表字段的值：
- en: '[PRE143]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'We can also get a list to represent the structure of the hash map:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获取一个列表来表示哈希表的结构：
- en: '[PRE144]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Alternatively, we can get the keys of the hash map:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以获取哈希表的键：
- en: '[PRE145]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'We can also get only the values of the hash map:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以只获取哈希表的值：
- en: '[PRE146]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Aditionally, we can simply get the number of fields in the hash map:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以简单地获取哈希表中的字段数量：
- en: '[PRE147]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'We can get the values of multiple fields at once:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一次性获取多个字段的值：
- en: '[PRE148]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'We can also set the values of multiple fields by supplying a list:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过提供一个列表来设置多个字段的值：
- en: '[PRE149]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Now, the values of the fields are updated:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，字段的值已更新：
- en: '[PRE150]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'In addition to the hash map, Redis also supports queue. We can push values
    from either left-hand side or the right-hand side of the queue. For example, we
    push integers from `1` to `3` from the right-hand side of a queue:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 除了哈希表之外，Redis还支持队列。我们可以从队列的左侧或右侧推送值。例如，我们可以从队列的右侧推送整数`1`到`3`：
- en: '[PRE151]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'We can get the current length of the queue with `redisLLen()`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`redisLLen()`来获取队列的当前长度：
- en: '[PRE152]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Now, the queue has three elements. Note that the value is a character vector
    rather than an integer. Therefore, we need to convert it if we need to use it
    as a number in other places.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，队列有三个元素。请注意，值是一个字符向量，而不是整数。因此，如果我们需要在其他地方将其用作数字，我们需要将其转换。
- en: 'Then, we can keep popping values from the left-hand side of the queue:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从队列的左侧持续弹出值：
- en: '[PRE153]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Note that the queue only has three elements to pop out. The fourth attempt returns
    `NULL`, which can be a criterion to check whether the queue is empty.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，队列只有三个元素可以弹出。第四次尝试返回`NULL`，这可以作为一个检查队列是否为空的准则。
- en: 'Finally, we should close the connection to Redis to release all resources:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该关闭与Redis的连接以释放所有资源：
- en: '[PRE154]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Redis has more advanced features that are beyond the scope of this chapter.
    It supports not only data structure store, but also message broker, that is, we
    can use it to pass messages between different programs. For more advanced usage,
    read the official documentation at [http://redis.io/documentation](http://redis.io/documentation).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Redis具有本章范围之外的高级功能。它不仅支持数据结构存储，还支持消息代理，即我们可以使用它在不同程序之间传递消息。有关更高级的使用方法，请参阅官方文档[http://redis.io/documentation](http://redis.io/documentation)。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to access different types of databases from
    R. We introduced the basic usage of relational databases such as SQLite and non-relational
    databases such as MongoDB and Redis. With the understanding of major differences
    in their functionality and feature sets, we need to choose an appropriate database
    to work with in our projects according to our purpose and needs.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何从 R 访问不同类型的数据库。我们介绍了关系型数据库（如 SQLite）和非关系型数据库（如 MongoDB 和 Redis）的基本用法。在了解它们的功能和特性集的主要差异后，我们需要根据我们的目的和需求选择一个合适的数据库来在我们的项目中使用。
- en: In many data-related projects, data storage and data importing are the initial
    steps, but data cleaning and data manipulation cost most of the time. In the next
    chapter, we will move on to data-manipulation techniques. You will learn about
    a number of packages that are specially tailored for handy but powerful data manipulation.
    To better work with these packages, we'll need a better understanding of how they
    work, which requires the sound knowledge introduced in the previous chapters.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多与数据相关的项目中，数据存储和数据导入是初始步骤，但数据清洗和数据操作占据了大部分时间。在下一章中，我们将继续探讨数据操作技术。你将了解一些专门为便捷但强大的数据操作而量身定制的软件包。为了更好地使用这些软件包，我们需要更深入地了解它们的工作原理，这需要前面章节中介绍的良好知识基础。
