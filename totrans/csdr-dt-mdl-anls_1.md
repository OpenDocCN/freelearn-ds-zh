# 第1章. Cassandra的鸟瞰图

想象一下，如果我们把时钟拨回到20世纪90年代，你是一名应用架构师。每当需要为你的应用选择合适的数据库技术时，你会选择哪种数据库技术？我敢打赌95%（或更多）的时间你会选择关系数据库。

**关系数据库**自20世纪70年代以来一直是数据管理解决方案中最占主导地位的形式。当时，应用系统通常是孤立的。应用用户及其使用模式是已知且可控的。关系数据库需要满足的工作负载可以确定并估算。除了工作负载的考虑之外，数据模型还可以按照关系理论推荐的方式进行规范化。此外，关系数据库提供了许多好处，如支持事务、数据一致性和隔离性。关系数据库非常适合这些用途。因此，不难理解为什么关系数据库如此受欢迎，为什么它是应用开发中持久数据存储的事实标准。

然而，随着互联网的普及和大量在其上运行的Web应用，用户及其使用模式（因此规模）、生成的工作负载和数据模型灵活性都消失了。这些Web应用的典型例子包括全球电子商务网站、社交媒体网站、视频社区网站等。它们在极短的时间内产生了大量数据。还应注意的是，这些应用生成数据不仅结构化，而且半结构化和非结构化。由于当时关系数据库是事实标准，开发者和架构师没有太多选择，只能被迫对其进行调整以支持这些Web应用，尽管他们知道关系数据库不是最优的，并且有许多局限性。很明显，需要找到一种不同类型的使能技术来突破这些挑战。

我们正处于信息爆炸的时代，这是由于网络和移动应用中用户生成数据和内容的持续增加。生成数据不仅量大且速度快，而且种类繁多。这种快速增长的、种类多样的数据通常被称为**大数据**。

没有人对大数据有一个明确、正式的定义。然而，人们普遍认为，大数据的最基本特征与大量、高速和多样性有关。大数据给采用传统数据处理方式的信息系统带来了真实、新的挑战。这些系统并非为网络规模设计，且为了有效地进行扩展，成本效益并不高。因此，你可能会问自己，我们是否有任何替代方案。

机遇与挑战并存。新一代的数据管理产品应运而生。上一段问题的最新答案是NoSQL。

# 什么是NoSQL？

应对大数据挑战的需求导致了新的数据管理技术和技术的出现。这些技术和技术与使用超过40年的普遍关系型数据库技术截然不同。它们统称为**NoSQL**。

NoSQL是一个术语，用于描述不基于关系数据模型的数据存储。它包括许多不同的数据库技术和产品。如图所示，**数据平台景观图**，有超过150种不同的数据库产品属于非关系型学校，如[http://nosql-database.org/](http://nosql-database.org/)中提到的。Cassandra是最受欢迎的之一。其他流行的NoSQL数据库产品，仅举几个例子，包括MongoDB、Riak、Redis、Neo4j等等。

![什么是NoSQL？](img/8884OS_01_01.jpg)

数据平台景观图（来源：451 Research）

那么，NoSQL提供了哪些好处？与关系型数据库相比，NoSQL克服了关系数据模型处理不佳的弱点，如下所示：

+   巨大的结构化、半结构化和非结构化数据量

+   灵活的数据模型（模式）易于更改

+   网络规模应用的扩展性和性能

+   成本更低

+   关系数据模型与面向对象编程之间的阻抗不匹配

+   内置复制

+   支持敏捷软件开发

### 备注

**NoSQL数据库的限制**

许多NoSQL数据库不支持事务。它们广泛使用复制，因此集群中的数据可能会暂时不一致（尽管最终是一致的）。此外，NoSQL数据库中不可用范围查询。此外，灵活的模式可能会导致高效搜索的问题。

之前提到了大量结构化、半结构化和非结构化数据。我想深入探讨的是，不同的NoSQL数据库为每种数据提供不同的解决方案。需要考虑的主要因素是NoSQL数据库类型，这将在下一节介绍。

所有NoSQL数据库都提供了一种灵活的数据模型，易于更改，其中一些甚至可能是无模式的。在关系型数据库中，关系数据模型被称为模式。在关系型数据库中存储数据之前，您需要理解要存储的数据，根据关系型数据库理论设计数据模型，并在关系型数据库中预先定义模式。这是一种非常结构化的方法，适用于结构化数据。这是一个规定性的数据建模过程。如果数据模型稳定，那就绝对没问题，因为不需要进行很多更改。但如果数据模型在未来不断变化，您不知道需要更改什么？您无法事先全面规定。这会导致许多不可避免的补救措施；比如说，例如，数据修补来更改模式。

相反，在NoSQL数据库中，您不需要全面规定。您只需要描述要存储的内容。您不受关系型数据库理论的约束。您可以在必要时随时更改数据模型。数据模型是无模式的，是一个活生生的对象。它随着时间的推移而演变。这是一个描述性的数据建模过程。

对于Web规模的应用程序，可扩展性和性能指的是系统可扩展的能力，最好是水平扩展，以支持Web规模的工作负载，而不会显著降低系统性能。关系型数据库只能扩展到由非常少数节点组成的集群。这意味着使用关系型数据库构建的这些Web规模应用程序的上限相当低。此外，在集群关系型数据库中更改模式是一项复杂度高的重大任务。完成这项任务所需的处理能力如此之大，以至于系统性能不可避免地受到影响。大多数NoSQL数据库都是为了服务Web规模应用程序而创建的。它们原生支持水平扩展，而性能下降非常小。

现在让我们谈谈金钱。传统上，大多数高端关系数据库是商业产品，要求用户支付巨额软件许可费。此外，要运行这些高端关系数据库，底层硬件服务器通常也是高端的。结果是，运行强大关系数据库的软硬件成本特别高。相比之下，大多数NoSQL数据库是开源的，由社区驱动，这意味着你需要支付的软件许可费用比其他数据库低一个数量级。NoSQL数据库能够在通用机器上运行，这可能导致可能的故障或崩溃。因此，机器通常配置为集群。高端硬件服务器不需要，因此硬件成本大幅降低。需要注意的是，当NoSQL数据库投入生产时，仍需要一些支持成本，但与商业产品相比，这肯定要少得多。

关系数据模型和面向对象编程之间存在一代沟。关系数据模型是20世纪70年代的产品，而面向对象编程在20世纪90年代变得非常流行。被称为阻抗不匹配的根本原因，是关系数据模型在面向对象模型中表达记录或表的一个固有困难。尽管有解决这个困难的方法，但大多数应用开发者仍然感到非常沮丧，因为将两者结合起来。

### 注意

**阻抗不匹配**

阻抗不匹配是关系模型和通常在面向对象编程语言中遇到的内存数据结构之间的差异。

内置复制是大多数NoSQL数据库提供的一项功能，用于支持多个节点集群中的高可用性。这通常是自动的，对应用开发者来说是透明的。这种功能在关系数据库中也是可用的，但数据库管理员必须自己努力配置、管理和操作它。

最后，关系数据库并不很好地支持敏捷软件开发。敏捷软件开发本质上是迭代的。软件架构和数据模型随着项目的进行而出现和演变，以便逐步交付产品。因此，可以想见，为了满足新的需求而改变数据模型的需求不可避免地很频繁。关系数据库是结构化的，不喜欢变化。NoSQL可以通过其无模式特性为敏捷软件开发团队提供这种灵活性。更好的是，NoSQL数据库通常允许实时实施更改，而无需停机。 

## NoSQL数据库类型

现在你已经知道了NoSQL数据库的好处，但属于NoSQL数据库范畴的产品相当多样。如何在众多NoSQL数据库中为自己选择合适的数据库？选择哪种NoSQL数据库适合你的需求实际上取决于手头的用例。这里要考虑的最重要因素是NoSQL数据库的类型，它可以细分为四大主要类别：

+   键值对存储

+   列族存储

+   基于文档的存储库

+   图数据库

NoSQL数据库类型决定了你可以使用的数据模型。深入了解每一个都是有益的。

### 键值对存储

键值对是最简单的NoSQL数据库类型。键值存储类似于Windows注册表的概念，或者在Java或C#中，是一个映射、一个哈希、一个键值对。每个数据项都表示为一个属性名称，也是一个键，以及它的值。它也是数据库中存储的基本单元。键值对类型的NoSQL数据库的例子有**Amazon Dynamo**、**Berkeley DB**、**Voldemort**和**Riak**。

在内部，键值对存储在一个称为**哈希表**的数据结构中。哈希表之所以受欢迎，是因为它在访问数据方面提供了非常好的性能。键值对的键是唯一的，可以非常快速地进行搜索。

键值对可以存储和分布在磁盘存储以及内存中。当在内存中使用时，它可以作为缓存使用，这取决于缓存算法，可以显著减少磁盘I/O，从而显著提高性能。

另一方面，键值对也有一些缺点，例如不支持范围查询，无法同时操作多个键，以及可能存在的负载均衡问题。

### 列族存储

在这个上下文中，列不等于关系表中的列。在NoSQL世界中，列是一个包含键、值和时间的结构。因此，它可以被视为键值对和时间戳的组合。例子有**Google BigTable**、**Apache Cassandra**和**Apache HBase**。它们为查询非常大的数据集提供了优化的性能。

列族存储基本上是一个多维映射。它将数据列作为一个行存储，与一个行键相关联。这与关系数据库中的数据行形成对比。列族存储不需要存储null列，就像关系数据库中的情况一样，因此它消耗的磁盘空间要少得多。此外，列不受严格模式的约束，你也不需要预先定义模式。

列的关键组件通常被称为主键或行键。列按行键排序存储。属于行键的所有数据都存储在一起。因此，数据的读写操作可以限制在本地节点上，避免在集群中产生不必要的节点间网络流量。这种机制使得数据的查找和检索非常高效。

显然，列族存储对于需要 ACID 事务的系统来说不是最佳解决方案，它缺乏关系数据库（如 `SUM()`）提供的聚合查询支持。

### 基于文档的存储库

基于文档的存储库是为文档或半结构化数据设计的。基于文档的存储库的基本单元将每个键（一个主标识符）与一个称为文档的复杂数据结构关联起来。文档可以包含许多不同的键/值对、键/数组对，甚至嵌套文档。因此，基于文档的存储库不遵循模式。例如 **MongoDB** 和 **CouchDB**。

在实践中，文档通常是以 **JavaScript 对象表示法**（**JSON**）形式存在的松散结构化键/值对集合。基于文档的存储库将文档作为一个整体来管理，避免将文档拆分成键/值对的片段。它还允许将文档属性与文档关联起来。

作为文档数据库不遵循固定模式，搜索性能无法保证。查询文档数据库通常有两种方法。第一种是使用预先准备的材料化视图（例如 CouchDB）。第二种是使用定义在文档值上的索引（例如 MongoDB），其行为与关系数据库索引相同。

### 图数据库

图数据库是为存储有关网络的信息而设计的，例如社交网络。图用于表示由节点及其关系组成的高度连接的网络。节点和关系可以具有单独的属性。突出的图数据库包括 **Neo4J** 和 **FlockDB**。

由于图具有独特的特性，图数据库通常提供用于快速遍历图的 API。

图数据库在分片扩展方面尤其困难，因为跨不同机器上的节点图遍历并不提供很好的性能。同时更新所有或部分节点也不是一个简单的操作。

到目前为止，你已经掌握了 NoSQL 家族的 fundamentals。由于这本书专注于 Apache Cassandra 及其数据模型，你需要了解 Cassandra 是什么，并对其架构有一个基本的了解，这样你就可以在设计 NoSQL 数据模型和应用时选择和利用最佳选项。

# 什么是 Cassandra？

**Cassandra** 可以简单地用一句话来描述：一个基于对等架构的、大规模可扩展、高度可用的开源 NoSQL 数据库。

Cassandra 现在已经 5 岁了。它是 Apache 软件基金会中的一个活跃的开源项目，因此也被称为 Apache Cassandra。Cassandra 可以在跨多个数据中心的庞大分布式集群中管理大量结构化、半结构化和非结构化数据。它提供线性可扩展性、高性能、容错性和非常灵活的数据模型。

### 注意

**Netflix 和 Cassandra**

一个非常著名的 Cassandra 研究案例是 Netflix 将其 Oracle SQL 数据库替换为在云上运行的 Cassandra。截至 2013 年 3 月，Netflix 的 Cassandra 部署由 50 个集群和超过 750 个节点组成。更多信息，请访问案例研究[http://www.datastax.com/wp-content/uploads/2011/09/CS-Netflix.pdf](http://www.datastax.com/wp-content/uploads/2011/09/CS-Netflix.pdf)。

事实上，Cassandra 提供的许多好处都继承自其两个最优秀的 NoSQL 祖先，Google BigTable 和 Amazon Dynamo。在我们深入探讨 Cassandra 的架构细节之前，让我们先了解一下它们各自的特点。

## Google BigTable

Google BigTable 是 Google 的核心技术，特别是针对 Web 规模的数据持久性和管理。它运行着许多 Google 应用程序的数据存储，例如 Gmail、YouTube 和 Google Analytics。它被设计为不牺牲实时响应的 Web 规模数据存储。它具有卓越的读写性能、线性可扩展性和持续可用性。

Google BigTable 是一个稀疏的、分布式的、持久的、多维排序映射。映射由行键索引。

尽管Google BigTable 提供了许多好处，但其底层设计概念实际上非常简单且优雅。它为接收到的每个数据写入请求使用持久的提交日志，然后将数据写入内存存储（充当缓存）。在固定时间间隔或由特定事件触发时，内存存储通过后台进程被刷新到持久磁盘存储。这种持久磁盘存储被称为 **排序字符串表** 或 **SSTable**。SSTable 是不可变的，这意味着一旦写入磁盘，它将永远不会再次更改。单词 *sorted* 意味着 SSTable 内部的数据是索引和排序的，因此数据可以非常快速地找到。由于写入操作基于日志和内存，它不涉及任何读操作，因此写入操作可以非常快。如果发生故障，提交日志可以用来重放写入操作的序列，以合并保存在 SSTables 中的数据。

通过在内存存储和索引的 SSTables 中查找数据，读操作也非常高效，这些数据随后被合并以返回。

所述的Google BigTable的卓越之处确实是有代价的。因为Google BigTable本质上是分布式的，它受到著名的*CAP定理*的限制，该定理阐述了分布式系统三个特性之间的关系，即一致性、可用性和分区容错性。简而言之，Google BigTable更倾向于一致性和分区容错性，而不是可用性。

### 注意

**CAP定理**

CAP是分布式系统三个特性的缩写：一致性（Consistency）、可用性（Availability）和分区容错性（Partition-tolerance）。一致性意味着集群中的所有节点在任何时间点都能看到相同的数据。可用性意味着集群中每个非失败节点接收到的每个请求都必须得到响应。分区容错性意味着当与其他节点组的通信丢失时，节点仍然可以继续工作。这个定理起源于埃里克·A·布鲁尔（Eric A. Brewer），它表明在一个分布式系统中，最多只能实现这三个特性中的两个。

当集群发生故障时，Google BigTable在保持分区节点的一致性时会有可用性问题。

## Amazon Dynamo

Amazon Dynamo是由Amazon开发的专有键值存储。它旨在提供高性能、高可用性和海量数据的持续增长。它是Amazon的分布式、高可用性和容错骨架。Dynamo是一种对等设计，意味着每个节点都是一个对等节点，没有谁是管理数据的权威节点。

Dynamo在集群的多个节点上使用数据复制和自动分片。想象一下，一个Dynamo集群由许多节点组成。节点上的每个写操作都会复制到另外两个节点。因此，集群内部有三份数据副本。如果其中一个节点因任何原因失败，仍然可以检索到两份数据副本。自动分片确保数据在集群中分区。

### 注意

**自动分片**

NoSQL数据库产品通常支持自动分片，以便它们可以原生地自动将数据分布到数据库集群中。数据和负载会在集群中的节点之间自动平衡。当某个节点因任何原因失败时，可以快速且透明地替换失败的节点，而不会中断服务。

Dynamo主要关注集群的高可用性，最重要的思想是最终一致性。在考虑CAP定理时，Dynamo更倾向于分区容错和可用性而非一致性。Dynamo引入了一种称为**最终一致性**的机制来支持一致性。在某个时间点，集群中可能会出现暂时的不一致性，但最终所有节点都将接收到最新的一致更新。在一段足够长的时间没有进一步变化的情况下，所有更新都可以预期在整个集群中传播，并且所有节点的副本最终都将是一致的。在现实生活中，更新只需要极短的时间就能达到最终一致性。换句话说，这是在一致性和延迟之间的一种权衡。

### 注意

**最终一致性**

最终一致性不是不一致性。它是一种比关系数据库中典型的原子性一致性隔离持久性（ACID）一致性更弱的一致性形式。它意味着在复制节点之间更新数据时，可能会存在短暂的不一致性间隔。换句话说，副本是异步更新的。

# Cassandra的高级架构

Cassandra运行在点对点架构上，这意味着集群中的所有节点都有平等的责任，除了其中一些节点是种子节点，用于在启动时让其他非种子节点获取有关集群的信息。每个节点持有数据库的一部分。Cassandra提供了在集群中所有节点上的自动数据分布和复制。提供了参数来自定义分布和复制行为。一旦配置完成，这些操作将在后台处理，并且对应用程序开发者是完全透明的。

Cassandra是一个列族存储，为应用程序开发者提供了极大的无模式灵活性。它旨在管理大型集群中的大量数据，而不存在单点故障。由于在集群中复制了相同数据的多个副本，因此每当一个节点因任何原因失败时，其他副本仍然可用。复制可以配置以满足不同的物理集群设置，包括数据中心和机架位置。

集群中的任何节点都可以接受来自客户端的读或写请求。连接到请求客户端的节点充当该特定请求的协调器。协调器确定哪些节点负责持有请求的数据，并充当客户端和节点之间的代理。

Cassandra借鉴了Google BigTable的commitlog机制以确保数据持久性。每当节点接收到写数据请求时，它会被写入commitlog。正在更新的数据随后会被写入一个称为memtable的内存结构。当memtable满了之后，memtable中的数据会被刷新到一个磁盘存储结构，即SSTable。写操作会自动根据行键进行分区，并复制到持有相同分区的其他节点。

Cassandra提供线性可扩展性，这意味着集群的性能和容量与其中的节点数量成正比。

## 分区

横向扩展和增量扩展的能力是Cassandra的关键设计特性。为了实现这一点，Cassandra需要动态地将数据分区到集群中的节点集合中。

集群是Cassandra中最外层的结构，由节点组成。它也是keyspace的容器。在Cassandra中，keyspace类似于关系数据库中的模式。每个Cassandra集群都有一个系统keyspace来存储系统级元数据。它包含复制设置，用于控制数据在集群中的分布和复制方式。通常，一个keyspace分配给一个集群，但一个集群可能包含多个keyspace。

理论上最小的集群包含一个节点和三个或更多节点的集群，这更加实用。每个节点持有不同分区范围内数据的副本，并且每秒钟在集群中交换信息。

客户端向任何节点发出读取或写入请求。接收请求的节点成为协调器，充当客户端的代理执行之前所述的操作。数据在集群中分布，节点寻址机制称为一致性哈希。因此，集群可以被视为一个哈希环，因为集群中的每个节点或环都被分配一个唯一的令牌，以便每个节点负责从其分配的令牌到前一个节点令牌范围内的数据。例如，在下面的图中，一个集群包含四个具有唯一令牌的节点：

![分区](img/8884OS_01_02.jpg)

Cassandra的一致性哈希

在版本1.2之前，令牌是手动计算和分配的，从版本1.2开始，令牌可以自动生成。每一行都有一个分区器使用的行键，用于计算其哈希值。哈希值决定了存储行第一个副本的节点。分区器只是一个用于计算行键哈希值的哈希函数，它还影响数据在集群中的分布或平衡方式。当发生写入操作时，行的第一个副本总是放置在具有令牌键范围的节点上。例如，行键`ORACLE`的哈希值为`6DE7`，位于4,000到8,000的范围内，因此行首先被放置在底部节点。所有剩余的副本都是根据复制策略进行分布的。

### 注意

**一致性哈希**

一致性哈希允许集群中的每个节点独立确定给定行键的副本节点。它只涉及对行键进行哈希处理，然后比较该哈希值与集群中每个节点的令牌。如果哈希值落在节点令牌之间，以及环中前一个节点的令牌（令牌按顺时针方向分配给节点）之间，那么该节点就是该行键的副本节点。

## 复制

Cassandra使用复制来实现高可用性和数据持久性。每个数据都在配置有称为复制因子的参数的多个节点上进行复制。协调器在其范围内指挥数据的复制。它将数据复制到环中的其他节点。Cassandra为客户端提供了各种可配置选项，以查看数据如何进行复制，这被称为复制策略。

复制策略是确定副本放置在哪些节点上的方法。它提供了许多选项，例如机架感知、非机架感知、网络拓扑感知等。

## Snitch（侦听器）

Snitch（侦听器）确定访问哪些数据中心和机架，以便使Cassandra能够了解网络拓扑，从而有效地路由请求。它影响在考虑数据中心的物理设置和机架的情况下，副本的分布方式。节点位置可以通过机架和数据中心以及节点的IP地址来确定。以下图示了一个跨两个数据中心的集群示例，以便更好地说明复制因子、复制策略和侦听器之间的关系：

![Snitch](img/8884OS_01_03.jpg)

多数据中心集群

每个数据中心有两个机架，每个机架分别包含两个节点。这里每个数据中心的复制因子设置为三。有两个数据中心，总共有六个副本。节点位置，即数据中心和机架位置，遵循节点IP地址分配的惯例。

## 种子节点

在一个Cassandra集群中，一些节点被指定为其他节点的种子节点。它们被配置为集群中首先启动的节点。它们还简化了新节点加入集群的初始化过程。当一个新节点上线时，它将与种子节点通信以获取集群中其他节点的信息。这种通信机制被称为**八卦**。如果一个集群跨越多个数据中心，最佳实践是在每个数据中心拥有不止一个种子节点。

## 八卦和故障检测

节点需要定期（每秒）通信以交换状态信息（例如，死亡或存活），关于它们自己和它们所知的其他节点。Cassandra使用八卦通信协议来传播状态信息，也称为流行病协议。它是一种对等通信协议，为集群中的节点提供了一个去中心化、定期和自动的方式，以与其他最多三个节点交换它们自己和它们所知的其他节点的状态信息。因此，所有节点都可以快速了解集群中的所有其他节点。八卦信息也被每个节点本地持久化，以允许快速重启。

Cassandra使用一个非常高效的算法，称为*Phi累积故障检测算法*，来检测节点的故障。该算法的思路是，故障检测不是通过一个表示节点是否上线的布尔值来表示。相反，算法输出一个值，表示在死亡和存活之间的连续怀疑水平，以及它对节点已失败的信心程度。在分布式环境中，由于网络性能、波动的工作负载和其他条件，可能会发生假阴性。该算法考虑了所有这些因素，并提供了概率值。如果一个节点已失败，其他节点将定期尝试与它进行八卦，以查看它是否重新上线。节点可以据此从八卦状态及其历史记录中本地确定，并相应地调整路由。

## 写入路径

下图描述了构成写入路径的组件及其执行顺序：

![写入路径](img/8884OS_01_04.jpg)

Cassandra写入路径

当发生写入操作时，数据将立即追加到磁盘上的commitlog以确保写入持久性。然后Cassandra将数据存储在memtable中，这是一个热数据和新鲜数据的内存存储。当memtable满时，memtable数据将通过顺序I/O刷新到称为SSTable的磁盘文件中，从而避免了随机I/O。这就是为什么写入性能如此之高的原因。在刷新后，commitlog将被清除。

由于有意采用顺序I/O，一行数据通常存储在多个SSTable文件中。除了其数据外，SSTable还有一个主索引和一个*bloom filter*。主索引是行键列表以及数据文件中行的起始位置。

### 注意

**布隆过滤器**

布隆过滤器是主索引的一个样本子集，具有非常快速的确定性算法来检查一个元素是否是集合的成员。它用于提升性能。

对于写操作，Cassandra通过各种写一致性级别支持可调一致性。写一致性级别是确认成功写入的副本数量。它可以在一系列写一致性级别上进行调整，如图所示：

![写入路径](img/8884OS_01_05.jpg)

Cassandra写一致性级别

以下描述了图中的术语：

+   **ANY**: 这是最低的一致性（但可用性最高）

+   **ALL**: 这是最高的一致性（但可用性最低）

+   **ONE**: 这至少提供一个副本

+   **TWO**: 这至少提供两个副本

+   **THREE**: 这至少提供三个副本

+   **QUORUM**: 这通过容忍一定程度的故障来确保强一致性，故障程度由 *(replication_factor / 2) + 1*（向下取整到最接近的整数）确定

+   **LOCAL_QUORUM**: 这适用于多数据中心和机架感知，但没有数据中心间流量

+   **EACH_QUORUM**: 这适用于多数据中心和机架感知

两个极端是左边的**ANY**，表示弱一致性，和右边的**ALL**，表示强一致性。实践中非常常见的**THREE**一致性级别。**QUORUM**可以选择为最佳值，如给定公式计算。在这里，复制因子是多个节点上数据的副本数量。**LOCAL QUORUM**和**EACH QUORUM**都支持多数据中心和机架感知的写一致性，与前面所示略有不同。

## 读取路径

反之，以下图显示了构成读取路径的组件及其执行顺序：

![读取路径](img/8884OS_01_06.jpg)

Cassandra读取路径

当读取请求到达一个节点时，要返回的数据是从所有相关的SSTables和任何未刷新的memtables中合并的。时间戳用于确定哪个是最新的。合并的值也存储在写入通过行缓存中，以提高未来的读取性能。

与写一致性级别类似，Cassandra还提供了可调的读取一致性级别，如图所示：

![读取路径](img/8884OS_01_07.jpg)

Cassandra读取一致性级别

以下描述了图中的术语：

+   **ALL**: 这是最高的一致性（但可用性最低）

+   **ONE**: 这至少提供一个副本

+   **TWO**: 这至少提供两个副本

+   **THREE**: 这至少提供三个副本

+   **QUORUM**: 这通过容忍一定程度的故障来确保强一致性，故障程度由 *(replication_factor / 2) + 1*（向下取整到最接近的整数）确定

+   **LOCAL_QUORUM**: 这适用于多数据中心和机架感知，但没有数据中心间流量

+   **EACH_QUORUM**: 这适用于多数据中心和机架感知

读取一致性级别是成功、一致读取时接触的副本数量，几乎与写入一致性级别相同，只是这里没有**任何**选项。

## 修复机制

Cassandra提供了三种内置的修复机制：

+   读取修复

+   暗示传递

+   反熵节点修复

在读取过程中，仅连接并服务客户端的协调器（即节点）会根据数据的一致性级别和最快的副本数量联系多个节点，通过内存比较进行一致性检查。由于它不是一个专用节点，Cassandra缺乏单点故障。它还会在后台检查所有剩余的副本。如果发现副本不一致，协调器将发出更新以恢复一致性。这种机制称为**读取修复**。

**暗示传递**旨在减少在重新加入集群时恢复失败节点的时间。它通过牺牲一点读取一致性来确保绝对的写入可用性。如果在写入发生时副本已关闭，另一个健康的副本将存储一个提示。更糟糕的是，如果所有相关的副本都关闭了，协调器将本地存储提示。提示基本上包含失败副本的位置、受影响的行键以及正在写入的实际数据。当负责令牌范围的节点再次上线时，提示将被传递以恢复写入。因此，更新在完全传递之前不能被读取，导致不一致的读取。

另一种修复机制称为**反熵**，它是一个副本同步机制，用于确保所有节点上的数据都是最新的，并且由管理员手动运行。

# Cassandra的特性

为了使本章简短，以下项目符号列表涵盖了Cassandra提供的一些主要特性：

+   用Java编写，因此提供原生Java支持

+   结合了Google BigTable和Amazon Dynamo

+   灵活的非模式化列族数据模型

+   支持结构化和非结构化数据

+   去中心化、分布式对等架构

+   多数据中心和机架感知的数据复制

+   位置透明

+   云支持

+   具有容错性，没有单点故障

+   自动且透明的故障转移

+   弹性、大规模和线性可扩展

+   在线节点添加或删除

+   高性能

+   内置数据压缩

+   内置缓存层

+   写入优化

+   可调一致性，提供从非常强的一致性到不同级别的最终一致性选择

+   提供类似于SQL的**Cassandra查询语言**（**CQL**），一种模仿SQL的`INSERT`、`UPDATE`、`DELETE`、`SELECT`语法的类似语言

+   开源并由社区驱动

# 摘要

在本章中，我们从20世纪70年代开始回顾了一点点历史。我们完全控制着那些相当稳定的数据模型和相对简单的应用程序。在那些日子里，关系型数据库是一个完美的选择。随着面向对象编程的出现和互联网上网络应用程序的爆炸式增长，数据的本质已经从结构化扩展到半结构化和非结构化。此外，应用程序也变得更加复杂。关系型数据库再也无法完美无缺。大数据的概念被创造出来描述这样的挑战，而NoSQL数据库为关系型数据库提供了一种替代的解决方案。

NoSQL数据库种类繁多。它们提供了一些共同的优点，并且可以根据NoSQL数据库类型进行分类。Apache Cassandra是NoSQL数据库之一，它是Google BigTable和Amazon Dynamo的结合。其架构的优雅性继承了这两个父母的DNA。

在下一章中，我们将探讨Cassandra支持的灵活数据模型。
