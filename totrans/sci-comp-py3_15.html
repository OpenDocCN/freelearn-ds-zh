<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;Symbolic Computations - SymPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Symbolic Computations - SymPy</h1></div></div></div><p>In this chapter, we will give a brief introduction on using Python for symbolic computations. There is powerful software in the market for performing symbolic computations, for example, Maple<sup>TM</sup> or Mathematica<sup>TM</sup>. But sometimes, it might be favorable to make symbolic calculations in the language or framework you are used to. At this stage of this book, we assume that this language is Python, so we seek for a tool in Python - the SymPy module.</p><p>A complete description of SymPy - if possible, would fill an entire book, and that is not the purpose of this chapter. Instead, we will stake out a path into this tool by some guiding examples, giving a flavor of the potential of this tool as a complement to NumPy and SciPy.</p><div class="section" title="What are symbolic computations?"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec118"/>What are symbolic computations?</h1></div></div></div><p>All computations we did so far in this book were so-called numeric computations. These were a sequence of operations mainly on floating-point numbers. It is the nature of numeric computations that the result is an approximation of the exact solution.</p><p>Symbolic computations operate on formulas or symbols by transforming them as taught in algebra or calculus into other formulas. The last step of these transformations might then require that numbers are inserted and a numeric evaluation is performed.</p><p>We illustrate the difference by computing this definite integral:</p><p>
</p><div class="mediaobject"><img src="graphics/integral.jpg" alt="What are symbolic computations?"/></div><p>
</p><p>Symbolically this expression can be transformed by considering the primitive function of the integrand:</p><p>
</p><div class="mediaobject"><img src="graphics/primitive.jpg" alt="What are symbolic computations?"/></div><p>
</p><p>We now obtain a formula for the definite integral by inserting the integral bounds:</p><p>
</p><div class="mediaobject"><img src="graphics/integralsolution.jpg" alt="What are symbolic computations?"/></div><p>
</p><p>This is called a closed-form expression for the integral. Very few mathematical problems have a solution that can be given in a closed-form expression. It is the exact value of the integral without any approximation. Also no error is introduced by representing real numbers as floating-point numbers, which would otherwise introduce round-off errors.</p><p>Approximation and round-off come into play at the very last moment, when this expression needs to be evaluated. The square root and the <span class="emphasis"><em>arctan</em></span> can only be evaluated approximately by numerical methods. Such an evaluation gives the final result up to a certain (often unknown) precision:</p><p>
</p><div class="mediaobject"><img src="graphics/numintegral.jpg" alt="What are symbolic computations?"/></div><p>
</p><p>On the other hand, numerical computation would directly approximate the definite integral by some approximation method, for example, Simpson's rule, and deliver a numeric result, often with an estimate of error. In Python, this is done by these commands:</p><pre class="programlisting">from scipy.integrate import quad&#13;
quad(lambda x : 1/(x**2+x+1),a=0, b=4)   </pre><p>They return the value <span class="emphasis"><em>0.9896614396122965</em></span> and an estimate for the error bound <span class="emphasis"><em>1.1735663442283496 10<sup>-08</sup>.</em></span>
</p><p>The following diagram shows the comparison of numeric and symbolic approximation:</p><p>
</p><div class="mediaobject"><img src="graphics/symbolic-1.jpg" alt="What are symbolic computations?"/></div><p>
</p><p>Figure 15.1: Symbolic and numeric quadrature</p><div class="section" title="Elaborating an example in SymPy"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec130"/>Elaborating an example in SymPy</h2></div></div></div><p>To begin with, let's elaborate the previous example in SymPy which are explained the steps.</p><p>First, we have to import the module:</p><pre class="programlisting">from sympy import *&#13;
init_printing()</pre><p>The second command makes sure that formulas are presented in a graphical way, if possible. Then, we generate a symbol and define the integrand:</p><pre class="programlisting">x = symbols('x')&#13;
f = Lambda(x, 1/(x**2 + x + 1))</pre><p>
<code class="literal">x</code> is now a Python object of type <code class="literal">Symbol</code> and <code class="literal">f</code> is a SymPy <code class="literal">Lambda</code> function (note the command starting with a capital letter).</p><p>Now we start with the symbolic computation of the integral:</p><pre class="programlisting">integrate(f(x),x)    </pre><p>Depending on your working environment, the result is presented in different ways; refer to following screenshot (<span class="emphasis"><em>Figure 15.2</em></span>) which represents two different result of SymPy formula in different environments:</p><p>
</p><div class="mediaobject"><img src="graphics/screendump.jpg" alt="Elaborating an example in SymPy"/></div><p>
</p><p>Figure 15.2: Two screenshots of a SymPy presentation of a formula in two different environments.</p><p>We can check by differentiation whether the result is correct. To this end, we assign a name to the primitive function and differentiate with respect to <span class="emphasis"><em>x</em></span>:</p><pre class="programlisting">pf = Lambda(x, integrate(f(x),x))&#13;
diff(pf(x),x)    </pre><p>The result obtained will be as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/unsimplifiedsolution.jpg" alt="Elaborating an example in SymPy"/></div><p>
</p><p>which can be simplified by using the following command:</p><pre class="programlisting">simplify(diff(pf(x),x))    </pre><p>to</p><p>
<span class="inlinemediaobject"><img src="graphics/integrand.jpg" alt="Elaborating an example in SymPy"/></span>.</p><p>The result we expected.</p><p>The definite integral is obtained by using the following command:</p><pre class="programlisting">pf(4) - pf(0)     </pre><p>It gives the following output after simplification with <code class="literal">simplify</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/solution2.jpg" alt="Elaborating an example in SymPy"/></div><p>
</p><p>To obtain a numerical value, we finally evaluate this expression to a floating-point number:</p><pre class="programlisting">(pf(4)-pf(0)).evalf() # returns 0.9896614396123</pre></div></div></div>
<div class="section" title="Basic elements of SymPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec119"/>Basic elements of SymPy</h1></div></div></div><p>Here we introduce the basic elements of SymPy. You will find it favorable to be already familiar with classes and data types in Python.</p><div class="section" title="Symbols - the basis of all formulas"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec131"/>Symbols - the basis of all formulas</h2></div></div></div><p>The basic construction element to build a formula in SymPy is the symbol. As we saw in the introductory example, a symbol is created by the command <code class="literal">symbols</code>. This SymPy command generates symbol objects from a given string:</p><pre class="programlisting">x, y, mass, torque = symbols('x y mass torque')</pre><p>It is actually a short form of following command:</p><pre class="programlisting">symbol_list=[symbols(l) for l in 'x y mass torque'.split()]</pre><p>followed by a unpacking step to obtain variables:</p><pre class="programlisting"> x, y, mass, torque = symbol_list</pre><p>The arguments of the command define the string representation of the symbol. The variable name of the symbol is often chosen identical to its string representation, but this is not required by the language:</p><pre class="programlisting">row_index=symbols('i',integer=True)&#13;
print(row_index**2)  # returns i**2</pre><p>Here, we also defined that the symbol is assumed to be an integer.</p><p>An entire set of symbols can be defined in a very compact way:</p><pre class="programlisting">integervariables = symbols('i:l', integer=True)&#13;
dimensions = symbols('m:n', integer=True)&#13;
realvariables = symbols('x:z', real=True)</pre><p>Similarly, symbols for indexed variables can be defined by using the following:</p><pre class="programlisting">A = symbols('A1:3(1:4)')</pre><p>This gives a tuple of symbols,</p><p> </p><div class="mediaobject"><img src="graphics/tupleofsymbols.jpg" alt="Symbols - the basis of all formulas"/></div><p>
</p><p>The rules for the range of the indexes are those we saw earlier in this book when working with slices (refer <a class="link" href="ch03.html" title="Chapter 3. Container Types">Chapter 3</a>, <span class="emphasis"><em>Container Types</em></span> for more details).</p></div><div class="section" title="Numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec132"/>Numbers</h2></div></div></div><p>Python evaluates operations on numbers directly and introduces unavoidably rounding errors. These would obstruct all symbolic calculations. This is avoided when we  <code class="literal">sympify</code> numbers:</p><pre class="programlisting">1/3  # returns 0.3333333333333333&#13;
sympify(1)/sympify(3)  # returns '1/3'</pre><p>The <code class="literal">sympify</code> command converts an integer to an object of type <code class="literal">sympy.core.numbers.Integer</code>.</p><p>Instead of writing 1/3 as an operation of two integers, it can also be represented directly as a rational number by <code class="literal">Rational(1,3)</code>.</p></div><div class="section" title="Functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec133"/>Functions</h2></div></div></div><p>SymPy distinguishes between defined and undefined functions. The term undefined functions (might be a bit misleading) refers to well-defined Python objects for generic functions that have no special properties.</p><p>An example of a function with special properties is <code class="literal">atan</code> or the <code class="literal">Lambda</code> function used in the introductory example of this chapter.  </p><p>Note the different names for the different implementations of the same mathematical function: <code class="literal">sympy.atan</code> and <code class="literal">scipy.arctan</code>.</p><div class="section" title="Undefined functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch15lvl3sec31"/>Undefined functions</h3></div></div></div><p>A symbol for an undefined function is created by giving the <code class="literal">symbols</code> command an extra class argument:</p><pre class="programlisting">f, g = symbols('f g', cls=Function)</pre><p>The same can be achieved by using the <code class="literal">Function</code> constructor:</p><pre class="programlisting">f = Function('f')&#13;
g = Function('g')</pre><p>with undefined functions, we can evaluate general rules of calculus.</p><p>For example, let us evaluate the following expression:</p><p>
</p><div class="mediaobject"><img src="graphics/chainrule1.jpg" alt="Undefined functions"/></div><p>
</p><p>This is symbolically computed in Python by using the following command:</p><pre class="programlisting">x = symbols('x')&#13;
f, g = symbols('f g', cls=Function)&#13;
diff(f(x*g(x)),x)</pre><p>When executed, the previous code returns the following as output:</p><p>
</p><div class="mediaobject"><img src="graphics/chainrule2.jpg" alt="Undefined functions"/></div><p>
</p><p>This example shows how the product rule and the chain rule were applied.</p><p>We can even use undefined functions as a function in several variables, for example:</p><pre class="programlisting">x = symbols('x:3')&#13;
f(*x)</pre><p>which returns the following output:</p><p>
</p><div class="mediaobject"><img src="graphics/sev_variables.jpg" alt="Undefined functions"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>Note the use of the star operator to unpack a tuple to form <span class="emphasis"><em>f</em></span> with arguments; refer to section <span class="emphasis"><em>Anonymous functions</em></span>, <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>
</p></div></div><p>By using list comprehension, we can construct a list of all partial derivatives of <span class="emphasis"><em>f </em></span>:</p><pre class="programlisting"> [diff(f(*x),xx) for xx in x]</pre><p>This returns a list with the elements of <span class="inlinemediaobject"><img src="graphics/nabla_f.jpg" alt="Undefined functions"/></span> (the gradient of <span class="emphasis"><em>f</em></span>):</p><p>
</p><div class="mediaobject"><img src="graphics/nabla_f_2.jpg" alt="Undefined functions"/></div><p>
</p><p>The command can also be rewritten by using the <code class="literal">diff</code> method of the <code class="literal">Function</code> object:</p><pre class="programlisting">[f(*x).diff(xx) for xx in x]</pre><p>Another method is Taylor series expansion :</p><pre class="programlisting">x = symbols('x')&#13;
f(x).series(x,0,n=4)</pre><p>This returns Taylor's formula, together with the rest term expressed by the Landau symbol:</p><p>
</p><div class="mediaobject"><img src="graphics/taylor1.jpg" alt="Undefined functions"/></div><p>
</p></div></div></div>
<div class="section" title="Elementary Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec120"/>Elementary Functions</h1></div></div></div><p>Examples for elementary functions in SymPy are trigonometric functions and their inverses. The following example shows how simplify acts on expression which include elementary function:</p><pre class="programlisting">x = symbols('x')&#13;
simplify(cos(x)**2 + sin(x)**2)  # returns 1</pre><p>Here is another example for the use of elementary functions:</p><pre class="programlisting">atan(x).diff(x) - 1./(x**2+1)  # returns 0</pre><p>If you use SciPy and SymPy together, we strongly recommend that you use them in different namespaces:</p><pre class="programlisting">import scipy as sp&#13;
import sympy as sym&#13;
# working with numbers&#13;
x=3&#13;
y=sp.sin(x)&#13;
# working with symbols&#13;
x=sym.symbols('x')&#13;
y=sym.sin(x)   </pre><div class="section" title="Lambda - functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec134"/>Lambda - functions</h2></div></div></div><p>In section <span class="emphasis"><em>Anonymous functions</em></span> of <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>, we saw how to define so-called anonymous functions in Python. The counterpart in SymPy is done by the <code class="literal">Lambda</code> command. Note the difference; <code class="literal">lambda</code> is a keyword while <code class="literal">Lambda</code> is a constructor.</p><p>The command <code class="literal">Lambda</code> takes two arguments, the symbol of the function's independent variable, and a SymPy expression to evaluate the function.</p><p>Here is an example that defines air resistance (also called drag) as a function of speed:</p><pre class="programlisting">C,rho,A,v=symbols('C rho A v')&#13;
# C drag coefficient, A coss-sectional area, rho density&#13;
# v speed&#13;
f_drag = Lambda(v,-Rational(1,2)*C*rho*A*v**2)</pre><p>
<code class="literal">f_drag</code> is displayed as an expression:</p><p>
<span class="inlinemediaobject"><img src="graphics/f_drag.jpg" alt="Lambda - functions"/></span>.</p><p>This function can be evaluated in the usual way by providing it with an argument:</p><pre class="programlisting">x = symbols('x')&#13;
f_drag(2)&#13;
f_drag(x/3)</pre><p>which will results in given expression:</p><p>
</p><div class="mediaobject"><img src="graphics/f_drag2.jpg" alt="Lambda - functions"/></div><p>
</p><p>It is also possible to create functions in several variables by just providing it with several arguments as for example:</p><pre class="programlisting">t=Lambda((x,y),sin(x) + cos(2*y))</pre><p>A call to this function can be done in two ways, either by directly providing several arguments:</p><pre class="programlisting">t(pi,pi/2)  # returns -1</pre><p>or by unpacking a tuple or list:</p><pre class="programlisting">p=(pi,pi/2)&#13;
t(*p)   # returns -1</pre><p>Matrix objects in SymPy make it even possible to define vector-valued functions:</p><pre class="programlisting">F=Lambda((x,y),Matrix([sin(x) + cos(2*y), sin(x)*cos(y)]))</pre><p>This enables us to compute Jacobians:</p><pre class="programlisting">F(x,y).jacobian((x,y))</pre><p>Which gives the following expression as output:</p><p>
</p><div class="mediaobject"><img src="graphics/jacobian.jpg" alt="Lambda - functions"/></div><p>
</p><p>In the case of more variables, it is convenient to use a more compact form to define the function:</p><pre class="programlisting">x=symbols('x:2')&#13;
F=Lambda(x,Matrix([sin(x[0]) + cos(2*x[1]),sin(x[0])*cos(x[1])]))  &#13;
F(*x).jacobian(x)</pre></div></div>
<div class="section" title="Symbolic Linear Algebra"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec121"/>Symbolic Linear Algebra</h1></div></div></div><p>Symbolic linear algebra is supported by SymPy's <code class="literal">matrix</code> data type which we will introduce first.
Then we will present some linear algebra methods as examples for the broad spectrum of possibilities for symbolic computations in this field:</p><div class="section" title="Symbolic matrices"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec135"/>Symbolic matrices</h2></div></div></div><p>We briefly met the <code class="literal">matrix</code> data type when we discussed vector valued functions. There, we saw it in its simplest form, which converts a list of lists into a matrix. To have an example, let's construct a rotation matrix:</p><pre class="programlisting">phi=symbols('phi')&#13;
rotation=Matrix([[cos(phi), -sin(phi)],&#13;
                 [sin(phi), cos(phi)]])</pre><p>When working with SymPy matrices we have to note that the operator <code class="literal">*</code> performs matrix multiplications and is not acting as an elementwise multiplication which is the case for NumPy arrays. </p><p>The above defined rotation matrix can be checked for orthogonality, by using this matrix multiplication and the transpose of a matrix:</p><pre class="programlisting">simplify(rotation.T*rotation -eye(2))  # returns a 2 x 2 zero matrix</pre><p>The previous example shows how a matrix is transposed and how the identity matrix is created. Alternatively, we could have checked whether its inverse is its transpose, which can be done as:</p><pre class="programlisting">simplify(rotation.T - rotation.inv())</pre><p>Another way to set up a matrix is by providing a list of symbols and a shape:</p><pre class="programlisting">M = Matrix(3,3, symbols('M:3(:3)'))</pre><p>This creates the following matrix:</p><p>
</p><div class="mediaobject"><img src="graphics/matrixM.jpg" alt="Symbolic matrices"/></div><p>
</p><p>A third way to create a matrix is by generating its entries by a given function. The syntax is:</p><pre class="programlisting">Matrix(number of rows,number of colums, function)</pre><p>We exemplify the above matrix by considering Toeplitz matrix is a matrix with constant diagonals. Given a <span class="emphasis"><em>2n-1 </em></span> data vector <span class="emphasis"><em>a</em></span>, its elements are defined as</p><p>
</p><div class="mediaobject"><img src="graphics/Toeplitz.jpg" alt="Symbolic matrices"/></div><p>
</p><p>In SymPy, the matrix can be defined by directly making use of this definition:</p><pre class="programlisting">def toeplitz(n):&#13;
    a = symbols('a:'+str(2*n))&#13;
    f = lambda i,j: a[i-j+n-1]&#13;
    return Matrix(n,n,f)</pre><p>Executing the previous code gives <code class="literal">toeplitz(5)</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/Toeplitz-new.jpg" alt="Symbolic matrices"/></div><p>
</p><p>One clearly sees the desired structures; all elements along subdiagonals and superdiagonals are the same. We can access matrix elements by the indexes and slices according to the Python syntax introduced in the section <span class="emphasis"><em>Lists </em></span>of <a class="link" href="ch03.html" title="Chapter 3. Container Types">Chapter 3</a>, <span class="emphasis"><em>Container Type</em></span>:</p><pre class="programlisting">a=symbols('a')&#13;
M[0,2]=0  # changes one element&#13;
M[1,:]=Matrix(1,3,[1,2,3]) # changes an entire row</pre></div></div>
<div class="section" title="Examples for Linear Algebra Methods in SymPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec122"/>Examples for Linear Algebra Methods in SymPy</h1></div></div></div><p>The basic task in linear algebra is to solve linear equation systems:</p><p>
<span class="inlinemediaobject"><img src="graphics/linsys.jpg" alt="Examples for Linear Algebra Methods in SymPy"/></span>.</p><p>Let us do this symbolically for a 3 <span class="emphasis"><em>×</em></span> 3 matrix:</p><pre class="programlisting">A = Matrix(3,3,symbols('A1:4(1:4)'))&#13;
b = Matrix(3,1,symbols('b1:4'))&#13;
x = A.LUsolve(b)&#13;
</pre><p>The output of this relatively small problem is already merely readable which can be seen in the following expression:</p><p>
</p><div class="mediaobject"><img src="graphics/huge_formula.jpg" alt="Examples for Linear Algebra Methods in SymPy"/></div><p>
</p><p>Again, the use of  <code class="literal">simplify</code> command helps us to detect canceling terms and to collect common factors:</p><pre class="programlisting">simplify(x)</pre><p>which will result in the following output which looks much better:</p><p>
</p><div class="mediaobject"><img src="graphics/less_huge_formula.jpg" alt="Examples for Linear Algebra Methods in SymPy"/></div><p>
</p><p>Symbolic computations becomes very slow with increase in matrix dimensions. For dimensions bigger than 15, there might even occur memory problems.</p><p>The preceding figure (<span class="emphasis"><em>Figure 15.3</em></span>) illustrates the differences in CPU time between symbolically and numerically solving a linear system:</p><p>
</p><div class="mediaobject"><img src="graphics/linsys_CPU.jpg" alt="Examples for Linear Algebra Methods in SymPy"/></div><p>
</p><p>Figure 15.3: CPU time for numerically and symbolically solving a linear system.</p></div>
<div class="section" title="Substitutions"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec123"/>Substitutions</h1></div></div></div><p>Let us first consider a simple symbolic expression:</p><pre class="programlisting">x, a = symbols('x a')&#13;
b = x + a</pre><p>What happens if we set <code class="literal">x = 0</code> ?  We observe that <code class="literal">b</code> did not change. What we did was that we changed the Python variable <code class="literal">x</code>. It now no longer refers to the symbol object but to the integer object <span class="emphasis"><em>0</em></span>. The symbol represented by the string <code class="literal">'x'</code>  remains unaltered, and so does <code class="literal">b</code>.</p><p>Instead, altering an expression by replacing symbols by numbers, other symbols, or expressions is done by a special substitution method which can be seen in following code:</p><pre class="programlisting">x, a = symbols('x a')&#13;
b = x + a&#13;
c = b.subs(x,0)   &#13;
d = c.subs(a,2*a)  &#13;
print(c, d)   # returns (a, 2a)</pre><p>This method takes one or two arguments:</p><pre class="programlisting">b.subs(x,0)&#13;
b.subs({x:0})  # a dictionary as argument</pre><p>Dictionaries as arguments allow us to make several substitutions in one step:</p><pre class="programlisting">b.subs({x:0, a:2*a})  # several substitutions in one</pre><p>As items in dictionaries have no defined order - one never knows which would be the first - there is a need for assuring that permuting the items would not affect the substitution result. Therefore in SymPy, substitutions are first made within the dictionary and then on the expression. This is demonstrated by the following example:</p><pre class="programlisting">x, a, y = symbols('x a y')&#13;
b = x + a&#13;
b.subs({a:a*y, x:2*x, y:a/y})&#13;
b.subs({y:a/y, a:a*y, x:2*x})</pre><p>Both substitutions return the same result, that is,</p><p>
<span class="inlinemediaobject"><img src="graphics/subs_result.jpg" alt="Substitutions"/></span> .</p><p>A third alternative to define multiple substitutions is by using a list of old-value/ new-value pairs instead:</p><pre class="programlisting"> b.subs([(y,a/y), (a,a*y), (x,2*x)]) </pre><p>It is also possible to substitute entire expressions by others:</p><pre class="programlisting">n, alpha = symbols('n alpha')&#13;
b = cos(n*alpha)&#13;
b.subs(cos(n*alpha), 2*cos(alpha)*cos((n-1)*alpha)-cos((n-2)*alpha))</pre><p> To illustrate substitutions of matrix elements, we take the <span class="emphasis"><em>5 × 5</em></span> Toeplitz matrix again:</p><p>
</p><div class="mediaobject"><img src="graphics/Toeplitz.jpg" alt="Substitutions"/></div><p>
</p><p>Consider the substitution <code class="literal">M.subs(T[0,2],0)</code>. It changes the symbol object at position [0, 2], which is the symbol <span class="emphasis"><em>a</em></span><sub>2</sub>. It also occurs at two other places, which are automatically affected by this substitution.</p><p>The given expression is the resulting matrix:</p><p>
</p><div class="mediaobject"><img src="graphics/mod_toeplitz.jpg" alt="Substitutions"/></div><p>
</p><p>Alternatively we can create a variable for this symbol and use it in the substitution:</p><pre class="programlisting">a2 = symbols('a2')&#13;
T.subs(a2,0)</pre><p>As a more complex example for substitution we describe, how to turn the Toeplitz matrix into a tridiagonal Toeplitz matrix<span class="emphasis"><em>.</em></span> This can be done in the following ways:
First we generate a list of those symbols that we want to substitute; and then we use the <code class="literal">zip</code> command to generate a list of pairs. Finally we substitute by giving a list of old-value/new-value pairs as described above:</p><pre class="programlisting">symbs = [symbols('a'+str(i)) for i in range(19) if i &lt; 3 or i &gt; 5]&#13;
substitutions=list(zip(symbs,len(symbs)*[0]))&#13;
T.subs(substitutions)</pre><p>This gives the following matrix as result:</p><p>
</p><div class="mediaobject"><img src="graphics/toeplitz_3diag.jpg" alt="Substitutions"/></div><p>
</p></div>
<div class="section" title="Evaluating symbolic expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec124"/>Evaluating symbolic expressions</h1></div></div></div><p>In the context of scientific computing, there is often the need of first making symbolic manipulations and then converting the symbolic result into a floating-point number .</p><p>The central tool for evaluating a symbolic expression is <code class="literal">evalf</code>. It converts symbolic expressions to floating-point numbers by using the following:</p><pre class="programlisting">pi.evalf()   # returns 3.14159265358979</pre><p>The data type of the resulting object is <code class="literal">Float</code> (note the capitalization), which is a SymPy data type that allows floating-point numbers with an arbitrary number of digits (arbitrary precision).
The default precision corresponds to 15 digits, but it can be changed by giving <code class="literal">evalf</code> an extra positive integer argument specifying the desired precision in terms the numbers of digits,</p><pre class="programlisting">pi.evalf(30)   # returns  3.14159265358979323846264338328</pre><p>A consequence of working with arbitrary precision is that numbers can be arbitrary small, that is, the limits of the classical floating-point representation are broken; refer <span class="emphasis"><em>Floating Point Numbers</em></span> section in <a class="link" href="ch02.html" title="Chapter 2. Variables and Basic Types">Chapter 2</a>, <span class="emphasis"><em>Variables and Basic Types</em></span>.</p><p>Interestingly enough,  evaluating a SymPy function with an input of type <code class="literal">Float</code> returns a Float with the same precision as the input. We demonstrate the use of this fact in a more elaborated example from numerical analysis. </p><div class="section" title="Example: A study on the convergence order of Newton's Method"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec136"/>Example: A study on the convergence order of Newton's Method</h2></div></div></div><p>An iterative method with iterates <span class="emphasis"><em>x<sub>n</sub></em></span> is said to converge with order <span class="emphasis"><em>q</em></span> with <span class="inlinemediaobject"><img src="graphics/qinN.jpg" alt="Example: A study on the convergence order of Newton's Method"/></span>, if there exists a positive constant <span class="emphasis"><em>C</em></span> such that</p><p>
<span class="inlinemediaobject"><img src="graphics/orderq.jpg" alt="Example: A study on the convergence order of Newton's Method"/></span>.</p><p>Newton's method when started with a good initial has order <span class="emphasis"><em>q </em></span>= 2, and for certain problems, even <span class="emphasis"><em>q </em></span>= 3. Newton's method when applied to the problem arctan(<span class="emphasis"><em>x</em></span>) = 0 gives the following iteration scheme:</p><p>
</p><div class="mediaobject"><img src="graphics/atanNewton.jpg" alt="Example: A study on the convergence order of Newton's Method"/></div><p>
</p><p>which converges cubically; that is <span class="emphasis"><em>q </em></span>= 3.</p><p>This implies that the number of correct digits triples from iteration to iteration. To demonstrate cubic convergence and to numerically determine the constant <span class="emphasis"><em>C</em></span> is hardly possible with the standard 16-digit float data type.</p><p>The following code, uses SymPy together with high-precision evaluation instead and puts a study on cubic convergence to the extreme:</p><pre class="programlisting">x = sp.Rational(1,2)&#13;
xns=[x]&#13;
&#13;
for i in range(1,9):&#13;
    x = (x - sp.atan(x)*(1+x**2)).evalf(3000)&#13;
    xns.append(x)</pre><p>The result is depicted in the next figure (<span class="emphasis"><em>Figure 15.4</em></span>) which shows that the number of correct digits triples from iteration to iteration.</p><p>
</p><div class="mediaobject"><img src="graphics/exterem_newton.jpg" alt="Example: A study on the convergence order of Newton's Method"/></div><p>
</p><p>  Figure 15.4: A study on the convergence of Newton's method applied to arctan(x)=0</p><p>This extreme precision requirement (3,000 digits!) enables us to evaluate seven terms of the preceding sequence to demonstrate cubic convergence in the following way:</p><pre class="programlisting"># Test for cubic convergence&#13;
print(array(abs(diff(xns[1:]))/abs(diff(xns[:-1]))**3,dtype=float64))</pre><p>The result is a list of seven terms which let us assume that <span class="emphasis"><em>C = </em></span>2/3:</p><pre class="programlisting">[ 0.41041618, 0.65747717, 0.6666665,  0.66666667, 0.66666667, 0.66666667, 0.66666667]</pre></div></div>
<div class="section" title="Converting a symbolic expression into a numeric function"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec125"/>Converting a symbolic expression into a numeric function</h1></div></div></div><p>As we have seen the numerical evaluation of a symbolic expression is done in three steps, first we do some symbolic computations and then we substitute values by numbers and do an evaluation to a floating point number by <code class="literal">evalf</code>.</p><p>The reason for symbolic computations is often that one wants to make parameter studies. This requires that the parameter is modified within a given parameter range. This requires that an symbolic expression is eventually turned into a numeric function.</p><div class="section" title="A study on the parameter dependency of polynomial coefficients"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec137"/>A study on the parameter dependency of polynomial coefficients</h2></div></div></div><p>We demonstrate a symbolic/ numeric parameter study by an interpolation example to introduce the SymPy command <code class="literal">lambdify</code>.
Let us consider the task to interpolate the data <span class="emphasis"><em>x </em></span>= [0,<span class="emphasis"><em> t</em></span>, 1] and <span class="emphasis"><em>y</em></span> = [0, 1,-1]. Here, <span class="emphasis"><em>t</em></span> is a free parameter, which we will vary over the interval [-0.4, 1.4].
The quadratic interpolation polynomial has coefficients depending on this parameter:</p><p>
<span class="inlinemediaobject"><img src="graphics/polynomial.jpg" alt="A study on the parameter dependency of polynomial coefficients"/></span>.</p><p>Using SymPy and the monomial approach described in gives us closed formulas for these coefficients:</p><pre class="programlisting">t=symbols('t')&#13;
x=[0,t,1]&#13;
# The Vandermonde Matrix&#13;
V = Matrix([[0, 0, 1], [t**2, t, 1], [1, 1,1]])&#13;
y = Matrix([0,1,-1])  # the data vector&#13;
a = simplify(V.LUsolve(y)) # the coefficients&#13;
# the leading coefficient as a function of the parameter&#13;
a2 = Lambda(t,a[0])</pre><p>We obtain a symbolic function for the leading coefficient <span class="emphasis"><em>a</em></span><sub>2</sub> of the interpolation polynomial:</p><p>
</p><div class="mediaobject"><img src="graphics/leading_coeff.jpg" alt="A study on the parameter dependency of polynomial coefficients"/></div><p>
</p><p>Now it is time to turn the expression into a numeric function, for example, to make a plot. This is done by the function <code class="literal">lamdify</code>.  This function takes two arguments, the independent variable  and a SymPy function.</p><p>For our example in Python we can write:</p><pre class="programlisting">leading_coefficient = lambdify(t,a2(t))</pre><p>This function can now be plotted, for example, by the following commands:</p><pre class="programlisting">t_list= linspace(-0.4,1.4,200)&#13;
ax=subplot(111)&#13;
lc_list = [leading_coefficient(t) for t in  t_list]&#13;
ax.plot(t_list, lc_list)&#13;
ax.axis([-.4,1.4,-15,10])</pre><p>The preceding figure (<span class="emphasis"><em>Figure 15.5</em></span>) is the result of this parameter study, one clearly sees the singularities due to multiple interpolation points, (here at <span class="emphasis"><em>t</em></span> = 0 or <span class="emphasis"><em>t</em></span> = 1): </p><p>
</p><div class="mediaobject"><img src="graphics/leading_coeff-1.jpg" alt="A study on the parameter dependency of polynomial coefficients"/></div><p>
</p><p>Figure 15.5: The dependency of a polynomial coefficient on the location of an interpolation point.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec126"/>Summary</h1></div></div></div><p>In this chapter you were introduced in the world of symbolic computations and you got a glimpse of the power of SymPy. By guiding examples you learned how to set up symbolic expressions, how to work with symbolic matrices, and you saw how to make simplifications. Working with symbolic functions and transforming them into numerical evaluations built finally the link to scientific computing and floating point results. You experienced the strength of SymPy as you used its full integration into Python with its powerful constructs and legible syntax.</p><p>Consider this last chapter as an appetizer rather than a complete menu. We hope you became hungry for future fascinating programming challenges in scientific computing and mathematics.</p></div></body></html>