<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor145"/>6</h1>
<h1 id="_idParaDest-135"><a id="_idTextAnchor146"/>Visualizing iSAX Indexes</h1>
<p>In the previous chapter, we learned about comparing and joining iSAX indexes. However, it is still difficult to imagine the structure and the height of an iSAX index without seeing it as an image.</p>
<p>And although some people prefer text, some other people prefer log files, and some others prefer numbers, almost all people like good-looking and informative visualizations. Additionally, all people understand the importance of having a high-level view of their data. This includes iSAX indexes and tree structures in general, mainly because there is no other practical way to perform the same task, especially when working with big time series.</p>
<p>In <a href="B14769_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we saw how to visualize a time series. This chapter is all about visualizing iSAX indexes in order to get a better understanding of their size, shape, and structure.</p>
<p>Visualizing large structures and trees such as iSAX indexes is not a trivial process but of a trial-and-error one. As no single visualization can do the job, we are going to try different kinds of plots and see what they tell us about the iSAX index. Therefore, you should expect to see lots of visualizations in this chapter, and I expect that you are going to create many more visualizations on your own while reading this book.</p>
<p>In this chapter, we are going to cover the following main topics:</p>
<ul>
<li>Storing an iSAX index in JSON format</li>
<li>Visualizing an iSAX index</li>
<li>Trying something radical</li>
<li>More iSAX index visualizations</li>
<li>Using icicle plots</li>
<li>Visualizing iSAX as a Collapsible Tree</li>
</ul>
<h1 id="_idParaDest-136"><a id="_idTextAnchor147"/>Technical requirements</h1>
<p>The GitHub repository for the book is at <a href="https://github.com/PacktPublishing/Time-Series-Indexing">https://github.com/PacktPublishing/Time-Series-Indexing</a>. The code for each chapter is in its own directory. Therefore, the code for <a href="B14769_06.xhtml#_idTextAnchor145"><em class="italic">Chapter 6</em></a> can be found in the <code>ch06</code> folder. However, in this chapter, there exist many directories under the <code>ch06</code> folder that contain the code for the different visualizations that we are going to create – this is a good way to organize code.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor148"/>Storing an iSAX index in JSON format</h1>
<p>For the visualizations <a id="_idIndexMarker386"/>of this chapter, we are going to use <a id="_idIndexMarker387"/>the low-level <code>D3.js</code> JavaScript library.</p>
<p class="callout-heading">Is D3.js the only way to create visualizations?</p>
<p class="callout">The powerful <code>D3.js</code> JavaScript library is not a panacea and therefore, it is not the only way to create <a id="_idIndexMarker388"/>visualizations. There exist many Python packages that are good at plotting data, as well as programming languages such as R or Julia. However, JavaScript can be used for presenting your plots in a web page environment, which is not usually the case with the other options.</p>
<p>For the JavaScript <code>D3.js</code> code to <a id="_idIndexMarker389"/>work, we need to represent an iSAX index in <strong class="bold">JSON</strong> format so that it can be understood by the JavaScript code – we mainly need to represent <strong class="bold">the structure and the connections</strong> between iSAX nodes in a way that can be understood by a computer and a programming language. Therefore, the first step we should take is to convert an iSAX index representation with its structures from Python code into a different structure made by JSON records.</p>
<p>Although this JSON format is not universal and might fail in some cases, it is going to be used throughout this chapter as all presented <code>D3.js</code> code works fine with it – all presented examples are tested and fully working.</p>
<p>First, we need to visit <a href="https://d3js.org/">https://d3js.org/</a> and click on <strong class="bold">Examples</strong> at the top of the page, which is going to take us to <a href="mailto:https://observablehq.com/@d3/gallery">https://observablehq.com/@d3/gallery</a>. The latter page is going to bring us to a page with professional, functional, and beautiful plots that look appropriate for the kind and amount of data that we want to plot in this chapter.</p>
<p>From the long list of available visualizations, we need to pick the ones that we prefer and are a good match for our data and its structure – our first attempt might not be perfect. Do not forget that iSAX indexes can have a large number of nodes. Therefore, we should think rationally and pick something that is going to look good with lots of data.</p>
<p>From that list, we pick <code>Tree, Tidy</code>. Behind the visualization, there is JavaScript code embedded into HTML that reads the JSON data, parses it, and creates the visualization.</p>
<p>Now that we have found our visualization of preference (<a href="mailto:https://observablehq.com/@d3/tree">https://observablehq.com/@d3/tree</a>), we might begin looking at the JavaScript code to get a better <a id="_idIndexMarker390"/>idea of the data format that is expected from the <a id="_idIndexMarker391"/>JavaScript code. However, what is more important is the JSON record format.</p>
<p class="callout-heading">Where is the JavaScript code?</p>
<p class="callout">JavaScript is a powerful <a id="_idIndexMarker392"/>but low-level programming language. The good thing is that the presented visualizations do not need any JavaScript knowledge to work. You just need to put your own data in the right format, at the right place, and that is all!</p>
<p>The JSON records that we are going to support should have the following format – this format was found by looking into the JSON file that the JavaScript code uses to get its data:</p>
<pre class="source-code">
 "name": "flare",
 "children": [
  {
   "name": "analytics",
   "children": [
    {
.
.
.</pre>
<p>The common idea behind the structure that we want to support is that we have a root node – the root of the tree – that has multiple children, those children have children of their own, and so on. The name of each node is a <code>name</code> field is given to the root node of the tree – in this case, that name will be <code>flare</code>.</p>
<p>There is an additional field that is going to be needed in some of the presented visualizations. Later <a id="_idIndexMarker393"/>on in this chapter, we are going to learn <a id="_idIndexMarker394"/>that terminal nodes have an additional field for storing the number of the subsequences that they hold – this is not used by every visualization. However, the thought remains the same.</p>
<p>A sample tidy tree visualization with custom data can be seen in the following figure. We are going to present more complex visualizations in the sections that follow. This is a simple tree structure with a root node and 13 nodes as its children:</p>
<div><div><img alt="Figure 6.1 – A tree visualization" height="279" src="img/Figure_6.1_B14769.jpg" width="1103"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – A tree visualization</p>
<p>With all that in mind, we can now begin working on our Python code. The Python script for representing an iSAX index as a JSON file is called <code>exportJSON.py</code>. The logic behind <code>exportJSON.py</code> is that after creating the iSAX index, we traverse it in order to generate the JSON output in the desired format.</p>
<p>But first, here is the definition of the JSON record that is going to be used in the Python script:</p>
<pre class="source-code">
JSON_message = {
  "name": None,
  "size": None,
  "children": []
}</pre>
<p>This is the basic JSON record format – we can add more fields to this record depending on our needs for any customization requirements without breaking any JavaScript code, as JavaScript is going to read only the fields that it needs. Although the format is defined in the code, it is not used by the Python code, mainly because Python does not need a predefined structure for JSON data that is stored in dictionaries. However, it is good to have it defined <a id="_idIndexMarker395"/>as a point of reference. The <code>size</code> field stores <a id="_idIndexMarker396"/>the total number of subsequences stored under each terminal node. Inner nodes do not need such a field.</p>
<p>The Python code within <code>exportJSON.py</code> that reads the existing iSAX index and prints the JSON output can be found at the end of the <code>main()</code> function:</p>
<pre class="source-code">
    # The JSON data to return
    data = {}
    data['name'] = "0"
    data['children'] = []
    # Create JSON output
    for subTree in ISAX.children:
        if ISAX.ht[subTree] == None:
            continue
        subTreeData = createJSON(ISAX.ht[subTree])
        data['children'].append(subTreeData)
    print(json.dumps(data))</pre>
<p>The name of the Python dictionary that holds the JSON records is <code>data</code>. By default, the root node has the name <code>0</code>, which is a string – this is analogous to <code>flare</code>. You can change that to anything you like.</p>
<p>The previous code visits and processes the children of the root node of the iSAX index only. The rest is handled by the <code>createJSON()</code> function. <code>createJSON()</code> is the function that actually generates the JSON output by adding data for the current subtree that is being examined. The <code>data</code> variable holds all JSON data.</p>
<p>The last statement <a id="_idIndexMarker397"/>prints all JSON records on the <a id="_idIndexMarker398"/>screen using <code>json.dumps()</code>.</p>
<p>The <code>createJSON()</code> function is implemented as follows:</p>
<pre class="source-code">
def createJSON(subtree):
    if subtree == None:
        return None
    t = {}
    t['name'] = subtree.word
    t['children'] = []
    # First, check if this is a Terminal node
    if subtree.terminalNode == True:
        t['size'] = subtree.nTimeSeries()
        return t
    # This is still a Terminal node
    # Just in case!
    elif subtree.left == None and subtree.right == None:
        print("This should not happen!")
        return t
    else:
        ch1 = createJSON(subtree.left)
        ch2 = createJSON(subtree.right)
        t['children'].append(ch1)
        t['children'].append(ch2)
    return t</pre>
<p>The <code>createJSON()</code> function is called recursively in order to visit all the nodes of each subtree. This mainly happens because we need to process all inner nodes and all terminal nodes.</p>
<p class="callout-heading">About the JSON output</p>
<p class="callout">This particular Python script generates JSON output based on a particular JSON record format. Once you get the idea right, it is going to be easy to make small changes to the script, add more fields to the JSON records, or create something totally different. All these depend on the format that the visualization script expects to work with.</p>
<p>For terminal nodes, we keep the number of the subsequences they hold – this takes place in the <code>size</code> field, and the processing of each terminal node ends here. However, for inner nodes, we recursively call <code>createJSON()</code> in order to process the left and the right children or subtrees of each inner node.</p>
<p>With all <a id="_idIndexMarker399"/>that in mind, let us see <code>exportJSON.py</code> in action. First, we <a id="_idIndexMarker400"/>are going to use it with a small iSAX index, using a time series named <code>ts.gz</code> that contains 100 elements – due to its small size, <code>ts.gz</code> is going to be used for experimentation purposes.  <code>ts.gz</code> was created by running <code>../ch01/synthetic_data.py 100 -10 10</code>, saving the output in a file named <code>ts</code> and compressing <code>ts</code> with <code>gzip(1)</code>.</p>
<p>Running <code>exportJSON.py</code> with <code>ts.gz</code> produces the following kind of output:</p>
<pre class="source-code">
$ ./exportJSON.py -s 3 -c 8 ts.gz
{"name": "0", "children": [{"name": "0_0_1", "children": [], "size": 18}, {"name": "0_1_1", "children": [], "size": 12}, {"name": "1_0_1", "children": [], "size": 12}, {"name": "1_0_0", "children": [], "size": 17}, {"name": "0_1_0", "children": [], "size": 12}, {"name": "1_1_0", "children": [], "size": 13}, {"name": "1_1_1", "children": [], "size": 1}]}</pre>
<p>Processing that <a id="_idIndexMarker401"/>data with the <code>jq(1)</code> utility, which beautifies <a id="_idIndexMarker402"/>JSON records, generates the next better-looking output – in this case, all the children of the root are terminal nodes:</p>
<pre class="source-code">
$ ./exportJSON.py -s 3 -c 8 ts.gz | jq
{
  "name": "0",
  "children": [
    {
      "name": "0_0_1",
      "children": [],
      "size": 18
    },
    {
      "name": "0_1_1",
      "children": [],
      "size": 12
    },
    {
      "name": "1_0_1",
      "children": [],
      "size": 12
    },
    {
      "name": "1_0_0",
      "children": [],
      "size": 17
    },
    {
      "name": "0_1_0",
      "children": [],
      "size": 12
    },
    {
      "name": "1_1_0",
      "children": [],
      "size": 13
    },
    {
      "name": "1_1_1",
      "children": [],
      "size": 1
    }
  ]
}</pre>
<p><strong class="bold">Bear in mind that the output depends on the parameters of the iSAX index</strong>. Different iSAX parameters generate different outputs and different tree structures.</p>
<p>Now, let us <a id="_idIndexMarker403"/>try <code>exportJSON.py</code> with a bigger time series <a id="_idIndexMarker404"/>that is named <code>100k.gz</code>, which contains 100,000 elements and was created as follows:</p>
<pre class="source-code">
$ ../ch01/synthetic_data.py 100000 -100 100 &gt; 100k
$ gzip 100k</pre>
<p>We ran <code>exportJSON.py</code> with <code>100k.gz</code> as follows:</p>
<pre class="source-code">
$ ./exportJSON.py -s 4 -c 16 -t 2500 100k.gz &gt; 100k.json</pre>
<p>The output file was saved as <code>100k.json</code>. The reason for using a threshold value of <code>2500</code> is to have a more compact tree. However, at the end of the day, what matters is your needs and the actual parameters of your iSAX indexes.</p>
<p>At this point, we <a id="_idIndexMarker405"/>processed <code>ts.gz</code> and <code>100k.gz</code> with <code>exportJSON.py</code>, and <a id="_idIndexMarker406"/>we end up having two JSON files named <code>ts.json</code> and <code>100k.json</code>, respectively. Although we might need <code>ts.json</code> for testing, all coming visualizations are going to use <code>100k.json</code>.</p>
<p>The next subsection is about downloading the JavaScript project on our local machine and executing it from there.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor149"/>Downloading the JavaScript code locally</h2>
<p><code>D3.js</code> and its powerful capabilities. Therefore, in this subsection, we are going to learn how to do so.</p>
<p>In every visualization from <a href="mailto:https://observablehq.com/@d3/gallery">https://observablehq.com/@d3/gallery</a>, there is a menu that appears when we click on the three dots that appear near the upper-right corner of the web page. From that menu, click on the <strong class="bold">Export</strong> link, which displays a submenu. From that submenu, we should click on the <strong class="bold">Download code</strong> option. This is going to download the contents of the current project on our local machine as a compressed file that we should extract and use.</p>
<p>For the purpose of this section, we are going to download the JavaScript project found at <a href="mailto:https://observablehq.com/@d3/tree">https://observablehq.com/@d3/tree</a>, which is going to download a file named <code>tree.tgz</code>. After we have uncompressed that file, we are going to get a directory called <code>tree</code>. It is not necessary to fully understand the contents of the directory, but it helps. However, you need to know the path to the JSON file with the data.</p>
<p>The output of the <code>tree(1)</code> utility, which lists the contents of directories in a tree-like format, when examining the contents of the <code>tree</code> directory, is the following:</p>
<pre class="source-code">
$ tree
.
├── 5432439324f2c616@268.js
├── 7a9e12f9fb3d8e06@498.js
├── LICENSE.txt
├── README.md
├── files
│   └── 85b8f86120ba5c8012f55b82fb5af4fcc9ff5e3cf250d110e111b3ab 98c32a3fa8f5c19f956e096fbf550c47d6895783a4edf72a9c474bef5782f 879573750ba.json
├── index.xhtml
├── index.js
├── inspector.css
├── package.json
└── runtime.js
2 directories, 10 files</pre>
<p>The JSON file with the <a id="_idIndexMarker409"/>records is located in the <code>files</code> directory – this is the file that we need to overwrite with our own data file. In order to load the project, we need to access the <code>index.xhtml</code> file, which is going to load all the necessary dependencies.</p>
<p>We only need to put our own JSON data into the <code>files</code> folder – this is the only required change to be done.</p>
<p>The next subsection <a id="_idIndexMarker410"/>is about running the downloaded JavaScript project on your own machine, which requires running your own local HTTP server.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor150"/>Running the code locally</h2>
<p>The process of <a id="_idIndexMarker411"/>running the code locally includes the following steps:</p>
<ol>
<li>Go into the directory with the code.</li>
<li>Make changes to the JSON file with the data – each example has its own JSON data file in a directory named <code>files</code>.</li>
<li>Run a local HTTP server.</li>
</ol>
<p>The JSON file with the data has a long and strange filename that is embedded into the JavaScript code. I am not so proficient with JavaScript, so I am going to use the default filename, which is located in the <code>files</code> directory. For security reasons, it is not allowed for the web server to access files outside of its root directory. Therefore, we need to <em class="italic">copy the JSON file</em> we have created with <code>exportJSON.py</code> in the <code>files</code> directory of each individual project and <em class="italic">overwrite the existing JSON file</em>, even if we are using the same one in all our examples.</p>
<p>The next subsection shows how to run your own local HTTP server and view the JavaScript code in action.</p>
<h3>Running a local HTTP server</h3>
<p>The easiest way to <a id="_idIndexMarker412"/>run a local HTTP server is by executing <code>python3 -m http.server</code> in the directory that interests you. If everything goes fine, the HTTP server is going to listen to port number <code>8000</code> and it is going to be accessed as http://localhost:8000/. This is much easier than it looks.</p>
<p>This process is going to be used throughout this chapter. All the required documents and files are in the GitHub repository of the book, so you have nothing more to download. If you want to experiment, just change the contents of the JSON file with the data.</p>
<p>The next subsection shows how to test the process.</p>
<h3>Testing the process</h3>
<p>I have renamed the <a id="_idIndexMarker413"/>directory of the previous project from <code>tree</code> to <code>TreeTidy</code> – it is a good practice to use descriptive directory names.</p>
<p>So, first, we need to go to the <code>ch06</code> directory of the GitHub repository for this book and then go to the <code>TreeTidy</code> directory. After that, we need to run <code>python3 -m http.server</code>. Now, we have an HTTP server running on our local machine that listens to the <code>8000</code> TCP port. Therefore, we need to point our web browser to <code>http://localhost:8000/</code> and see the generated visualization.</p>
<p>The generated output from the Python web server is going to look as follows:</p>
<pre class="source-code">
$ python3 -m http.server
Serving HTTP on :: port 8000 (http://[::]:8000/) ...
::ffff:127.0.0.1 - - [29/Mar/2023 20:42:08] "GET / HTTP/1.1" 200 -
::ffff:127.0.0.1 - - [29/Mar/2023 20:42:08] "GET /inspector.css HTTP/1.1" 200 -
::ffff:127.0.0.1 - - [29/Mar/2023 20:42:08] "GET /runtime.js HTTP/1.1" 200 -
::ffff:127.0.0.1 - - [29/Mar/2023 20:42:08] "GET /index.js HTTP/1.1" 200 -
::ffff:127.0.0.1 - - [29/Mar/2023 20:42:08] "GET /5432439324f2c616@268.js HTTP/1.1" 200 -
::ffff:127.0.0.1 - - [29/Mar/2023 20:42:08] "GET /7a9e12f9fb3d8e06@498.js HTTP/1.1" 200 -
::ffff:127.0.0.1 - - [29/Mar/2023 20:42:08] code 404, message File not found
::ffff:127.0.0.1 - - [29/Mar/2023 20:42:08] "GET /favicon.ico HTTP/1.1" 404 -</pre>
<p>If you see any error messages in the generated output, you should try to resolve them.</p>
<p>However, unless you are in the wrong directory or there is another TCP service running on TCP port <code>8000</code>, there should be no issues.</p>
<p>So far, we have <a id="_idIndexMarker414"/>learned how to represent an iSAX index in JSON format and how to download the JavaScript projects from <a href="https://observablehq.com/">https://observablehq.com/</a>.</p>
<p>In the section that follows, we will begin our iSAX visualization journey.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor151"/>Visualizing an iSAX index</h1>
<p>In this section, we <a id="_idIndexMarker415"/>are going to begin visualizing iSAX indexes.</p>
<p>As in most areas of computing, your visualizations are going to improve over time. The first visualizations are usually less beautiful and/or informative than later ones. So, we are going to experiment and try things before we end up with a good-looking iSAX visualization.</p>
<p>As visualizations include personal taste, your visualization of choice might differ from the ones used in this chapter. However, we need to start doing and improve in the process!</p>
<p>Let us begin with the visualization of the next subsection.</p>
<p class="callout-heading">A personal story</p>
<p class="callout">At the time of writing this book, I am doing research related to iSAX. In one of my experiments, I ran a utility that creates two iSAX indexes and joins them in a more sophisticated way than the one presented in <a href="B14769_05.xhtml#_idTextAnchor124"><em class="italic">Chapter 5</em></a>. The utility processed 2 time series with 500,000 elements each and ran for more than 18 days! Additionally, it took the same utility about 2 hours to process 2 time series with 1,500,000 elements each, which means that the utility works well. I decided to visualize each iSAX index using a separate Python utility. Long story short, in the case of the time series with 500,000 elements, I mistakenly used 32 segments and a cardinality value of 4, instead of 4 segments and a cardinality value of 32! This means that the root of each iSAX index had 2 32 children! Therefore, joining them included so many calculations, which explained the fact that the utility still ran after 18 days. If I had visualized each iSAX index earlier, I would have found the issue much sooner.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor152"/>Visualizing iSAX as a tree</h2>
<p>In this first try, we are <a id="_idIndexMarker416"/>going to visualize an iSAX index as a tree using various visualizations. As iSAX has a tree structure, using this kind of visualization makes perfect sense.</p>
<p>For this subsection, we are going to use the visualization stored in the <code>TreeTidy</code> directory that we saw earlier. The first task to up is to update the JSON file stored in the <code>files</code> directory of the <code>TreeTidy</code> directory. If we are in the <code>TreeTidy</code> directory, we can run <code>cp ../100k.json files/85b8f8…9573750ba.json</code>. The full filename is omitted for brevity – just make sure that you use the correct filename with the help of <code>shell</code> auto-completion.</p>
<p>In <em class="italic">Figure 6</em><em class="italic">.2</em>, you can see the visualization of the iSAX index generated for the <code>100k.gz</code> time series using the <code>D3.js</code> code that also generated the sample output of <em class="italic">Figure 6</em><em class="italic">.1</em>.</p>
<div><div><img alt="Figure 6.2 – Visualizing an iSAX index as a tree" height="519" src="img/Figure_6.2_B14769.jpg" width="1160"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Visualizing an iSAX index as a tree</p>
<p>What does <em class="italic">Figure 6</em><em class="italic">.2</em> tell us? It tells us that we are dealing with a relatively small iSAX index that is pretty balanced (the depths of the terminal nodes do not differ too much), which is a good thing. By default, terminal nodes are visualized with gray color circles, whereas inner nodes are black.</p>
<p>So, what can we do next? Next, we can try visualizing <code>100k.gz</code> using different iSAX parameters. So, in this case, we are going to use the following parameters:</p>
<pre class="source-code">
$ ./exportJSON.py -s 4 -c 16 -t 5000 100k.gz</pre>
<p>As before, the <a id="_idIndexMarker417"/>generated output is going to be stored in the existing JSON file inside the <code>files</code> directory. The updated output can be seen in <em class="italic">Figure 6</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 6.3 – Increasing the threshold value to 5,000" height="276" src="img/Figure_6.3_B14769.jpg" width="1175"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Increasing the threshold value to 5,000</p>
<p>As expected, the iSAX index is smaller than before, mainly because we have fewer node splits. However, it looks less balanced than the iSAX presented in <em class="italic">Figure 6</em><em class="italic">.2</em>.</p>
<p>Is there anything more to do? We can experiment a little bit more and change the segments value from <code>4</code> to <code>3</code> while keeping the threshold value at <code>5000</code>.</p>
<p>So, this time, the JSON output is going to be generated using this command:</p>
<pre class="source-code">
$ ./exportJSON.py -s 3 -c 16 -t 5000 100k.gz</pre>
<p>After that, we need to store the output in the JSON file located in the <code>files</code> directory. The new visualization can be seen in <em class="italic">Figure 6</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 6.4 – Visualizing an iSAX with three segments" height="285" src="img/Figure_6.4_B14769.jpg" width="1186"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Visualizing an iSAX with three segments</p>
<p>As expected, the root node has fewer children. However, the general shape of the iSAX index presented in <em class="italic">Figure 6</em><em class="italic">.4</em> is similar to the one presented in <em class="italic">Figure 6</em><em class="italic">.3</em>. In my personal opinion, <em class="italic">Figure 6</em><em class="italic">.2</em> shows a better and more balanced iSAX index compared to the other two <a id="_idIndexMarker418"/>versions. Balanced trees, and therefore balanced iSAX indexes, are generally faster to search, which is a desired property.</p>
<p>In this section, we saw how to visualize iSAX indexes as tree structures, which makes perfect sense, as iSAX indexes are trees.</p>
<p>In the next section, we are going to try a different kind of visualization for the iSAX index structure. After all, visualization and experimentation are good friends.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor153"/>Trying something radical</h1>
<p>In this section, we are going to try a different kind of visualization for visualizing an iSAX index, just in case <a id="_idIndexMarker419"/>it reveals any extra kind of information. So, we are going to use a <code>TreeRadialTidy</code> directory inside the <code>ch06</code> directory and replace the JSON file found in the <code>files</code> directory with <code>100k.json</code> – the correct file is already there. However, if you want to use your own data, you should update that file.</p>
<p>Next, we should run the Python HTTP server and point our web browser to http://localhost:8000/. The generated output is presented in <em class="italic">Figure 6</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 6.5 – Using a Radial Tree structure" height="1320" src="img/Figure_6.5_B14769.jpg" width="1211"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Using a Radial Tree structure</p>
<p>What kind of information <a id="_idIndexMarker420"/>can we get from <em class="italic">Figure 6</em><em class="italic">.5</em>? Is that better than a regular tree structure? I do not know whether it is better or not, but it surely presents the same information in a totally new way!</p>
<p>One advantage of the radial tree is that it performs better when dealing with iSAX indexes with large depths <a id="_idIndexMarker421"/>as they can fit better on screen. Personally, I believe <a id="_idIndexMarker422"/>that the plain tree structure is more suitable for iSAX indexes than the radial tree.</p>
<p>The next section continues the visualization process of iSAX indexes by trying more visualizations.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor154"/>More iSAX index visualizations</h1>
<p>We are not done yet! There exist ways to improve the previous visualization by adding more information to the output as well as the ability to compress various parts of it – there is always the danger of <em class="italic">putting too much information</em> on a graph or a plot, but we are not going to make that mistake here.</p>
<p>First, we are going <a id="_idIndexMarker423"/>to go to the <code>ZoomableTreemap</code> directory <a id="_idIndexMarker424"/>in order to try a zoomable structure named <strong class="bold">Zoomable Treemap</strong>, which is better when dealing with large iSAX indexes.</p>
<p>The Zoomable Treemap uses an additional attribute called <code>value</code>. In this case, I had two choices: either change the output of the Python script or change the JavaScript code. I decided to do the latter. So, I changed the <code>value</code> attribute in the JavaScript code to <code>size</code>, which is what the Python script generates. However, in our case, this created a bug in the JavaScript code related to the sum of the presented values, which means that this was not the correct decision.</p>
<p>Therefore, we are going to change the JSON file and replace the <code>size</code> field name with <code>value</code>.</p>
<p>As before, we should overwrite the JSON file in the <code>files</code> directory with <code>100k.json</code> and run the Python HTTP server. The generated output can be seen in <em class="italic">Figure 6</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 6.6 – A Zoomable Treemap visualization" height="1596" src="img/Figure_6.6_B14769.jpg" width="1649"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – A Zoomable Treemap visualization</p>
<p>It turns out that the <a id="_idIndexMarker425"/>Zoomable Treemap might be <a id="_idIndexMarker426"/>difficult to read and understand – it is even difficult to realize that we are talking about a tree structure. Therefore, it might not be a good choice for the iSAX visualization. However, the <em class="italic">zoomable</em> capability is very handy in almost all cases.</p>
<p>If we used the buggy version, then instead of the numeric values in the output, we would have got a <code>NaN</code> value – this probably had to do with the JavaScript code.</p>
<p>Let us now continue with something different. Go to the <code>ZoomableSunburst</code> directory and replace the file in the <code>files</code> directory with the <code>100k.json</code> file. Once again, we need to make code changes. Specifically, we need to replace the <code>value</code> field used in <code>86ddbc29bd33f9d6@357.js</code> with the <code>size</code> field that our JSON record has. The code stored in GitHub has all the necessary changes in it. The generated output can be seen in <em class="italic">Figure 6</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 6.7 – A Zoomable Sunburst visualization" height="1659" src="img/Figure_6.7_B14769.jpg" width="1588"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – A Zoomable Sunburst visualization</p>
<p>The main advantage of this <a id="_idIndexMarker427"/>visualization is that it does <a id="_idIndexMarker428"/>not display the entire iSAX from the beginning, but it <a id="_idIndexMarker429"/>can do so as we are zooming in on the visualization by clicking on the different parts of the sunburst. So, it hides some information, which can be displayed on demand.</p>
<p>If we zoom into any part of the Sunburst, we are going to get a closer look at that particular part of the iSAX index.</p>
<p><em class="italic">Figure 6</em><em class="italic">.8</em> shows such a part of the Sunburst:</p>
<div><div><img alt="Figure 6.8 – Zooming in the 0_0_1_1 subtree of the Sunburst" height="1665" src="img/Figure_6.8_B14769.jpg" width="1593"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Zooming in the 0_0_1_1 subtree of the Sunburst</p>
<p>Once again, the <a id="_idIndexMarker430"/>zooming capability is handy, and we <a id="_idIndexMarker431"/>want to have it in our visualizations. The next section discusses an interesting kind of plot, which is called icicle, and looks like it is suitable for visualizing iSAX indexes.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor155"/>Using icicle plots</h1>
<p>In this section, we are going to discuss a different kind of plot, which is called an <strong class="bold">icicle plot</strong>. An icicle plot is a <a id="_idIndexMarker432"/>method for presenting hierarchical clustering and is able to visualize hierarchical data using <a id="_idIndexMarker433"/>rectangular sectors that go from the root node to the leaves. In our case, we are going to use a <strong class="bold">zoomable </strong><strong class="bold">icicle plot</strong>.</p>
<p>First, please go to the <code>ZoomableIcicle</code> directory and replace the JSON file in <code>files</code> with <code>100k.json</code>. This time, instead of changing the JavaScript code, we are going to change the field name of the JSON file from <code>size</code> to <code>value</code>. In general, <em class="italic">it is better to change your input data than </em><em class="italic">the code</em>.</p>
<p><em class="italic">Figure 6</em><em class="italic">.9</em> shows a part of the generated icicle visualization. The rectangle on the left side represents the root node, which contains <strong class="bold">99,985</strong> subsequences – this is the total number of subsequences stored in the iSAX index.</p>
<div><div><img alt="Figure 6.9 – Visualizing iSAX using an icicle" height="1377" src="img/Figure_6.9_B14769.jpg" width="1541"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Visualizing iSAX using an icicle</p>
<p>Apart from the SAX <a id="_idIndexMarker434"/>representation of a node, each rectangle displays the number of subsequences stored under it. So, the <strong class="bold">1_0_0_1</strong> subtree has <strong class="bold">10,936</strong> subsequences – this is another handy feature.</p>
<p>Going further, if we zoom on the <strong class="bold">1_0_0_0</strong> subtree, we are going to get the output displayed as shown in <em class="italic">Figure 6</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 6.10 – Taking a closer look at the 1_0_0_0 subtree" height="1018" src="img/Figure_6.10_B14769.jpg" width="1117"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Taking a closer look at the 1_0_0_0 subtree</p>
<p>Similarly, if we <a id="_idIndexMarker435"/>zoom in on the <strong class="bold">1_1_1_0</strong> subtree, we are going to get the visualization presented in <em class="italic">Figure 6</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 6.11 – Taking a closer look at the 1_1_1_0 subtree" height="721" src="img/Figure_6.11_B14769.jpg" width="1123"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Taking a closer look at the 1_1_1_0 subtree</p>
<p>Let us discuss <em class="italic">Figure 6</em><em class="italic">.11</em> a little more. What does it tell us? It tells us that the <strong class="bold">1_1_1_0</strong> child of the root <a id="_idIndexMarker436"/>node stores <strong class="bold">4,342</strong> subsequences. <strong class="bold">4,246</strong> of these subsequences are under the <strong class="bold">10_1_1_0</strong> subtree and the rest of the subsequences are under the <strong class="bold">11_1_1_0</strong> subtree.</p>
<p>If we zoom in on the <strong class="bold">10_1_1_0</strong> node, we are going to get <em class="italic">Figure 6</em><em class="italic">.12</em>, which shows that the <strong class="bold">10_10_10_0</strong> subtree has <strong class="bold">4,031</strong> nodes.</p>
<div><div><img alt="Figure 6.12 – Taking a closer look at the 10_1_1_0  subtree" height="515" src="img/Figure_6.12_B14769.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Taking a closer look at the 10_1_1_0  subtree</p>
<p>As we are using a smaller threshold value, we know that the <strong class="bold">10_10_10_0</strong> node is an inner node that can <a id="_idIndexMarker437"/>be further expanded.</p>
<p>This way, we can explore the iSAX index and find the information we want.</p>
<p>The icicle plot looks appropriate for visualizing iSAX indexes. However, we might find a better type of visualization if we experiment more.</p>
<p>The next section presents a Collapsible Tree visualization of an iSAX index.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor156"/>Visualizing iSAX as a Collapsible Tree</h1>
<p>Although the zoomable <a id="_idIndexMarker438"/>icicle looks very promising, <a id="_idIndexMarker439"/>some people might want a visualization that looks like a tree but still has some of the versatility of the zoomable icicle. For those people, we are going to try the <strong class="bold">Collapsible Tree</strong>.</p>
<p>First, we go to the <code>CollapsibleTree</code> directory and then we run the Python web server. Then, we go to <code>http://localhost:8000/</code>. <em class="italic">Figure 6</em><em class="italic">.13</em> shows the output of the Collapsible Tree visualization:</p>
<div><div><img alt="Figure 6.13 – Visualizing iSAX as a Collapsible Tree" height="317" src="img/Image97716.jpg" width="1211"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Visualizing iSAX as a Collapsible Tree</p>
<p>The main advantage of the Collapsible Tree is that we can expand or collapse nodes at will, which means that we can easily concentrate on the nodes that interest us the most instead of getting lost in the details of the iSAX index.</p>
<p>However, the Collapsible Tree does not display the number of subsequences stored under each subtree of the index.</p>
<p>In this last section, we <a id="_idIndexMarker440"/>saw the operation of the <a id="_idIndexMarker441"/>Collapsible Tree and understood its versatility, as well as its limitations.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor157"/>Summary</h1>
<p>Visualization offers a great way to understand your data. Similarly, visualization is a great way to understand the structure of an iSAX index, especially a big one. In this chapter, we saw various ways to visualize an iSAX index with the help of the <code>D3.js</code> JavaScript library and got a better look at the distribution of the subsequences and the height of iSAX indexes.</p>
<p>However, it would be great to try your own visualizations using the <code>D3.js</code> JavaScript library, R, or other appropriate Python packages, which can also create impressive visualizations.</p>
<p>Lastly, do not underestimate the power of a good visualization as it can reveal lots of information in an easy-to-discover way. Just keep in mind that visualization is an art that is hard to master.</p>
<p>The next chapter is about using iSAX indexes for the approximate calculation of the Matrix Pr<a href="https://en.wikipedia.org/wiki/JavaScript">ofile and the MPdist distance.</a></p>
<h1 id="_idParaDest-147"><a href="https://en.wikipedia.org/wiki/JavaScript">Useful li</a>nks</h1>
<ul>
<li><em class="italic">JavaScript</em>: <a href="https://en.wikipedia.org/wiki/JavaScript">https://en.wikipedia.org/wiki/JavaScript</a></li>
<li>The Mozilla Developer Network: <a href="https://developer.mozilla.org/en/JavaScript">https://developer.mozilla.org/en/JavaScript</a></li>
<li>The official page for the <code>D3.js</code> JavaScript library: <a href="https://d3js.org/">https://d3js.org/</a></li>
<li>You can learn more information about icicle plots by reading the <em class="italic">Icicle Plots: Better Displays for Hierarchical Clustering</em> paper, which was wri<a href="https://www.r-project.org/">tten by J. B. Kruskal and </a>J. M. Landwehr</li>
<li>The R Project: <a href="https://www.r-project.org/">https://www.r-project.org/</a></li>
<li>The Seaborn Python package: <a href="https://seaborn.pydata.org/">https://seaborn.pydata.org/</a></li>
<li>The Julia programming language: <a href="https://julialang.org/">https://julialang.org/</a></li>
<li>The <code>plotly</code> Python library: <a href="https://plotly.com/python/">https://plotly.com/python/</a></li>
<li>A very good book about the art of data visualization is <em class="italic">The Visual Display of Quantitative Information</em>, by Edward R. Tufte</li>
<li><em class="italic">D3 </em><em class="italic">Gallery</em>: <a href="mailto:https://observablehq.com/@d3/gallery">https://observablehq.com/@d3/gallery</a></li>
<li><em class="italic">Tree, </em><em class="italic">Tidy</em>: <a href="mailto:https://observablehq.com/@d3/tree">https://observablehq.com/@d3/tree</a></li>
<li><em class="italic">Zoomable </em><em class="italic">Treemap</em>: <a href="mailto:https://observablehq.com/@d3/zoomable-treemap">https://observablehq.com/@d3/zoomable-treemap</a></li>
<li><em class="italic">Zoomable </em><em class="italic">Sunburst</em>: <a href="mailto:https://observablehq.com/@d3/zoomable-sunburst">https://observablehq.com/@d3/zoomable-sunburst</a></li>
<li><em class="italic">Zoomable </em><em class="italic">Icicle</em>: <a href="mailto:https://observablehq.com/@d3/zoomable-icicle">https://observablehq.com/@d3/zoomable-icicle</a></li>
<li><em class="italic">Tree, Radial </em><em class="italic">Tidy</em>: <a href="mailto:https://observablehq.com/@d3/radial-tree">https://observablehq.com/@d3/radial-tree</a></li>
<li><em class="italic">Collapsible </em><em class="italic">Tree</em>: <a href="mailto:https://observablehq.com/@d3/collapsible-tree">https://observablehq.com/@d3/collapsible-tree</a></li>
</ul>
<h1 id="_idParaDest-148"><a id="_idTextAnchor159"/>Exercises</h1>
<p>Try to do the following exercises:</p>
<ul>
<li>Create a time series with 50,000 elements and plot its iSAX index using 6, 8, and 10 segments. In all cases, use a threshold value of <code>500</code>.</li>
<li>Create a time series with 150,000 elements and plot its iSAX index using 4, 6, and 8 segments.</li>
<li>Create a time series with 250,000 elements and plot its iSAX index for 4, 6, and 10 segments. In all cases, use a threshold value of <code>5000</code>.</li>
<li>Make a version of <code>exportJSON.py</code> that replaces the <code>size</code> field with a field named <code>value</code>.</li>
<li>If you are familiar with JavaScript, change the colors of the zoomable icicle plot.</li>
<li>If you are familiar with JavaScript, make the zoomable icicle plot go from <em class="italic">top to bottom</em> instead of <em class="italic">left </em><em class="italic">to right</em>.</li>
<li>If you are familiar with JavaScript, make the Collapsible Tree visualization go from <em class="italic">top to bottom</em> instead of <em class="italic">left to right</em>. Is that better than before?</li>
<li>Experiment with the Zoomable Circle Packing visualization, which can be found at <a href="mailto:https://observablehq.com/@d3/zoomable-circle-packing">https://observablehq.com/@d3/zoomable-circle-packing</a>. What do you think of it?</li>
</ul>
</div>
</div></body></html>