["```py\nfor s in ['a', 'b', 'c']:\n    print(s), # a b c\n```", "```py\nfor iteration in range(n): # repeat the following code n times\n    ...\n```", "```py\nfor k in range(...):\n    ...\n    element = my_list[k]\n```", "```py\nfor element in my_list:\n    ...\n```", "```py\nfor k, element in enumerate(my_list):\n    ...\n```", "```py\nmaxIteration = 10000\nfor iteration in range(maxIteration):\n    residual = compute() # some computation\n    if residual < tolerance:\n        break\nelse: # only executed if the for loop is not broken\n    raise Exception(\"The algorithm did not converge\")\nprint(\"The algorithm converged in {} steps\".format(iteration+1))\n```", "```py\nfor element in obj:\n    ...\n```", "```py\nL = ['A', 'B', 'C']\nfor element in L:\n    print(element)\n```", "```py\nfor iteration in range(100000000):\n    # Note: the 100000000 integers are not created at once\n    if iteration > 10:\n        break\n```", "```py\nl=list(range(100000000))\n```", "```py\ndef odd_numbers(n):\n    \"generator for odd numbers less than n\"\n    for k in range(n):\n        if k % 2 == 1:\n            yield k\n```", "```py\ng = odd_numbers(10)\nfor k in g:\n    ...    # do something with k\n```", "```py\nfor k in odd_numbers(10):\n    ... # do something with k\n```", "```py\nL = ['a', 'b', 'c']\niterator = iter(L)\nlist(iterator) # ['a', 'b', 'c']\nlist(iterator) # [] empty list, because the iterator is exhausted\n\nnew_iterator = iter(L) # new iterator, ready to be used\nlist(new_iterator) # ['a', 'b', 'c']\n```", "```py\ng = odd_numbers(10)\nfor k in g:\n    ... # do something with k\n\n# now the iterator is exhausted:\nfor k in g: # nothing will happen!!\n    ...\n\n# to loop through it again, create a new one:\ng = odd_numbers(10)\nfor k in g:.\n    ...\n```", "```py\n      A = ['a', 'b', 'c']\n      for iteration, x in enumerate(A):\n          print(iteration, x)\n      # result: (0, 'a') (1, 'b') (2, 'c')\n```", "```py\n      A = [0, 1, 2]\n      for elt in reversed(A):,\n          print(elt)\n          # result: 2 1 0\n```", "```py\n      for iteration in itertools.count():\n          if iteration > 100:\n              break # without this, the loop goes on forever\n          print(\"integer {}\".format(iteration))\n          # prints the 100 first integer\n```", "```py\n      from itertools import count, islice\n      for iteration in islice(count(), 10): \n          # same effect as range(10)\n          ...\n```", "```py\ndef odd_numbers():\n    k=-1\n    while True:\n        k+=1\n        if k%2==1:\n        yield k\n```", "```py\nlist(itertools.islice(odd_numbers(),10,30,8)) # returns [21, 37, 53]\n```", "```py\ndef fibonacci(u0, u1):\n    \"\"\"\n    Infinite generator of the Fibonacci sequence.\n    \"\"\"\n    yield u0\n    yield u1\n    while True:\n        u0, u1 = u1, u0+u1\n        yield u1\n```", "```py\n# sequence of the 100 first Fibonacci numbers:\nlist(itertools.islice(fibonacci(0, 1), 100))\n```", "```py\ndef arithmetic_geometric_mean(a, b):\n    \"\"\"\n    Generator for the arithmetic and geometric mean\n    a, b initial values\n    \"\"\" \n    while True:    # infinite loop\n         a, b = (a+b)/2, sqrt(a*b)\n         yield a, b\n```", "```py\ndef elliptic_integral(k, tolerance=1e-5):\n    \"\"\"\n    Compute an elliptic integral of the first kind.\n    \"\"\"\n    a_0, b_0 = 1., sqrt(1-k**2)\n    for a, b in arithmetic_geometric_mean(a_0, b_0):\n        if abs(a-b) < tolerance:\n            return pi/(2*a)\n```", "```py\nfrom itertools import islice\ndef elliptic_integral(k, tolerance=1e-5, maxiter=100):\n    \"\"\"\n    Compute an elliptic integral of the first kind.\n    \"\"\"\n    a_0, b_0 = 1., sqrt(1-k**2)\n    for a, b in islice(arithmetic_geometric_mean(a_0, b_0), \n                                                  maxiter):\n        if abs(a-b) < tolerance:\n            return pi/(2*a)\n    else:\n        raise Exception(\"Algorithm did not converge\")\n```", "```py\ndef pendulum_period(L, theta, g=9.81):\n    return 4*sqrt(L/g)*elliptic_integral(sin(theta/2))\n```", "```py\ndef Euler_accelerate(sequence):\n    \"\"\"\n    Accelerate the iterator in the variable `sequence`.\n    \"\"\"\n    s0 = next(sequence) # Si\n    s1 = next(sequence) # Si+1\n    s2 = next(sequence) # Si+2\n    while True:\n        yield s0 - ((s1 - s0)**2)/(s2 - 2*s1 + s0)\n  s0, s1, s2 = s1, s2, next(sequence)\n```", "```py\ndef pi_series():\n    sum = 0.\n    j = 1\n    for i in itertools.cycle([1, -1]):\n        yield sum\n        sum += i/j\n        j += 2\n```", "```py\nEuler_accelerate(pi_series())\n```", "```py\nitertools.islice(Euler_accelerate(pi_series()), N)\n```", "```py\nL = []\nfor k in range(n):\n    # call various functions here\n    # that compute \"result\"\n    L.append(result)\n```", "```py\ndef result_iterator():\n    for k in itertools.count(): # infinite iterator\n        # call various functions here\n        # that compute \"result\"\n        ...\n        yield result\n```", "```py\nL = list(itertools.islice(result_iterator(), n)) # no append needed!\n```", "```py\n# make sure that you do not use scipy.sum here\ns = sum(itertools.islice(result_iterator(), n))\n```", "```py\nL = [some_function(k) for k in range(n)]\n```", "```py\nimport itertools\ndef power_sequence(u0):\n    u = u0\n    while True:\n        yield u\n        u = u**2\n```", "```py\nlist(itertools.islice(power_sequence(2.), 20))\n```", "```py\ngenerator = power_sequence(2.)\nL = []\nfor iteration in range(20):\n    try:\n        L.append(next(generator))\n    except Exception:\n        ...\n```", "```py\ng = (n for n in range(1000) if not n % 100)\n# generator for  100, 200, ... , 900\n```", "```py\nsum(n for n in range(1000) if not n % 100) # returns 4500 \n```", "```py\nsum(1/n**s for n in itertools.islice(itertools.count(1), N))\n```", "```py\ndef generate_zeta(s):\n    for n in itertools.count(1):\n        yield 1/n**s\n```", "```py\ndef zeta(N, s):\n    # make sure that you do not use the scipy.sum here\n    return sum(itertools.islice(generate_zeta(s), N))\n```", "```py\nxg = x_iterator()  # some iterator\nyg = y_iterator()  # another iterator\n\nfor x, y in zip(xg, yg):\n    print(x, y)\n```", "```py\nclass OdeStore:\n    \"\"\"\n    Class to store results of ode computations\n    \"\"\"\n    def __init__(self, data):\n        \"data is a list of the form [[t0, u0], [t1, u1],...]\"\n        self.data = data\n\n    def __iter__(self):\n        \"By default, we iterate on the values u0, u1,...\"\n        for t, u in self.data:\n            yield u\n\nstore = OdeStore([[0, 1], [0.1, 1.1], [0.2, 1.3]])\nfor u in store:\n    print(u)\n# result: 1, 1.1, 1.3\nlist(store) # [1, 1.1, 1.3]\n```", "```py\n>>> list(3)\nTypeError: 'int' object is not iterable\n```", "```py\n>>> for iteration in 3: pass\nTypeError: 'int' object is not iterable\n```", "```py\nwhile condition:\n    <code>\n```", "```py\nfor iteration in itertools.count():\n    if not condition:\n        break\n    <code>\n```", "```py\nmaxit = 100\nfor nb_iterations in range(max_it):\n    ...\nelse:\n    raise Exception(\"No convergence in {} iterations\".format(maxit))\n```", "```py\ndef f(N):\n    if N == 0: \n        return 0\n    return f(N-1)\n```", "```py\nimport sys \nsys.setrecursionlimit(1000)\n```", "```py\nfor iteration in range(10000000):\n    pass\n```"]