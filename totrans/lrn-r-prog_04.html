<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Basic Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Basic Expressions</h1></div></div></div><p>Expressions are the building blocks of a function. R has a very clear syntax that suggests that an expression is either a symbol or a function call.</p><p>Although everything we do is in essence implemented by functions, R gives some functions a special syntax so that it is more friendly to write readable R code.</p><p>In the next few sections, we will see the following fundamental expressions that are given a special syntax:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Assignment expressions</li><li class="listitem" style="list-style-type: disc">Conditional expressions</li><li class="listitem" style="list-style-type: disc">Loop expressions</li></ul></div><div class="section" title="Assignment expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Assignment expressions</h1></div></div></div><p>Assignment may be one of the most fundamental expressions in all programming languages. What it does is assign or bind a value to a symbol so that we can refer to the value by that symbol later.</p><p>Despite the similarity, R adopts the <code class="literal">&lt;-</code> operator to perform assignment. This is a bit different from many other languages using <code class="literal">=</code> although this is also allowed in R:</p><pre class="programlisting">x &lt;- 1 &#13;
y &lt;- c(1, 2, 3) &#13;
z &lt;- list(x, y) &#13;
</pre><p>We don't have to declare the symbol and its type before assigning a value to it. If a symbol does not exist in the environment, the assignment will create that symbol. If a symbol already exists, the assignment will not end up in conflict, but will rebind the new value to that symbol.</p><div class="section" title="Alternative assignment operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Alternative assignment operators</h2></div></div></div><p>There are some alternate yet equivalent operators we can use. Compared to <code class="literal">x &lt;- f(z)</code>, which binds the value of <code class="literal">f(z)</code> to symbol <code class="literal">x</code>, we can also use <code class="literal">-&gt;</code> to perform assignment in the opposite direction:</p><pre class="programlisting">2 -&gt; x1 &#13;
</pre><p>We can even chain the assignment operators so that a set of symbols all take the same value:</p><pre class="programlisting">x3 &lt;- x2 &lt;- x1 &lt;- 0 &#13;
</pre><p>The expression <code class="literal">0</code> is evaluated only once so that the same value is assigned to the three symbols. To verify how it works, we can change<code class="literal">0</code> to a random number generator:</p><pre class="programlisting">x3 &lt;- x2 &lt;- x1 &lt;- rnorm(1)&#13;
c(x1, x2, x3)&#13;
## [1] 1.585697 1.585697 1.585697 &#13;
</pre><p>The <code class="literal">rnorm(1)</code> method generates a random number following the standard normal distribution. If each assignment re-invokes the random number generator, each symbol will have different values. In fact, however, it does not happen. Later, I will explain what really happens and you will have a better understanding of it.</p><p>Like other programming languages, <code class="literal">=</code> also can perform assignment:</p><pre class="programlisting">x2 = c(1, 2, 3) &#13;
</pre><p>If you are familiar with other popular programming languages such as Python, Java, and C#, you may find it almost an industry standard to use <code class="literal">=</code> as the assignment operator and may feel uncomfortable using <code class="literal">&lt;-</code>, which requires more typing. However, Google's <span class="emphasis"><em>R Style Guide</em></span> (<a class="ulink" href="https://google.github.io/styleguide/Rguide.xml#assignment">https://google.github.io/styleguide/Rguide.xml#assignment</a>) suggests the usage of <code class="literal">&lt;-</code> instead of <code class="literal">=</code>, even though both are allowed and have exactly the same effect when they are used as assignment operators.</p><p>Here, I will provide a simple explanation to the subtle difference between <code class="literal">&lt;-</code> and <code class="literal">=</code>. Let's first create a <code class="literal">f()</code> function that takes two arguments:</p><pre class="programlisting">f &lt;- function(input, data = NULL) { &#13;
  cat("input:\n") &#13;
  print(input) &#13;
  cat("data:\n") &#13;
  print(data) &#13;
} &#13;
</pre><p>The function basically prints the value of the two arguments. Then, let's use this function to demonstrate the difference between the two operators:</p><pre class="programlisting">x &lt;- c(1, 2, 3)&#13;
y &lt;- c("some", "text")&#13;
f(input = x)&#13;
## input: &#13;
## [1] 1 2 3 &#13;
## data: &#13;
## NULL &#13;
</pre><p>The preceding code uses both <code class="literal">&lt;-</code> and <code class="literal">=</code> operators but they play different roles. The <code class="literal">&lt;-</code> operator in the first two lines is used as an assignment operator, while <code class="literal">=</code> in the third line specifies a named argument input for the <code class="literal">f()</code> method.</p><p>More specifically, the <code class="literal">&lt;-</code> operator evaluates the expression on its right-hand side <code class="literal">c(1, 2, 3)</code> and assigns the evaluated value to the symbol (variable) on the left-hand side <code class="literal">x</code>. The <code class="literal">=</code> operator is not used as an assignment operator but to match the function argument by name.</p><p>We know that the <code class="literal">&lt;-</code> and <code class="literal">=</code> operators are interchangeable when they are used as assignment operators. Therefore, the preceding code is equivalent to the following code:</p><pre class="programlisting">x = c(1, 2, 3)&#13;
y = c("some", "text")&#13;
f(input = x)&#13;
## input: &#13;
## [1] 1 2 3 &#13;
## data: &#13;
## NULL &#13;
</pre><p>Here, we only use the <code class="literal">=</code> operator but for two different purposes: in the first two lines, <code class="literal">=</code> performs an assignment, while in the third line <code class="literal">=</code> specifies the named argument.</p><p>Now, let's see what happens if we change every <code class="literal">=</code> to <code class="literal">&lt;-</code>:</p><pre class="programlisting">x &lt;- c(1, 2, 3)&#13;
y &lt;- c("some", "text")&#13;
f(input &lt;- x)&#13;
## input: &#13;
## [1] 1 2 3 &#13;
## data: &#13;
## NULL &#13;
</pre><p>If you run this code, you will find that the outputs are similar. However, if you inspect the environment, you will observe the difference: a new <code class="literal">input</code> variable is now created in the environment and gains the value of <code class="literal">c(1, 2, 3)</code>:</p><pre class="programlisting">input&#13;
## [1] 1 2 3 &#13;
</pre><p>So, what happened? Actually, in the third line, two things happened: First, the assignment,
<code class="literal">input &lt;- x</code>, introduces a new <code class="literal">input</code> symbol to the environment and results in <code class="literal">x</code>. Then, the value of <code class="literal">input</code> is provided to the first argument of function <code class="literal">f()</code>. In other words, the first function argument is not matched by name but by position.</p><p>To elaborate, we will conduct more experiments. The standard usage of the function is as follows:</p><pre class="programlisting">f(input = x, data = y)&#13;
## input: &#13;
## [1] 1 2 3 &#13;
## data: &#13;
## [1] "some" "text" &#13;
</pre><p>If we replace both <code class="literal">=</code> with <code class="literal">&lt;-</code>, the result looks the same:</p><pre class="programlisting">f(input &lt;- x, data &lt;- y)&#13;
## input: &#13;
## [1] 1 2 3 &#13;
## data: &#13;
## [1] "some" "text" &#13;
</pre><p>For the code using <code class="literal">=</code>, we can exchange the two named arguments without changing the result:</p><pre class="programlisting">f(data = y, input = x)&#13;
## input: &#13;
## [1] 1 2 3 &#13;
## data: &#13;
## [1] "some" "text" &#13;
</pre><p>In this case, however, if we exchange <code class="literal">=</code> for <code class="literal">&lt;-</code>, the values of <code class="literal">input</code> and <code class="literal">data</code> are also exchanged:</p><pre class="programlisting">f(data &lt;- y, input &lt;- x)&#13;
## input: &#13;
## [1] "some" "text" &#13;
## data: &#13;
## [1] 1 2 3 &#13;
</pre><p>The following code has the same effect as that of the preceding code:</p><pre class="programlisting">data &lt;- y&#13;
input &lt;- x&#13;
f(y, x)&#13;
## input: &#13;
## [1] "some" "text" &#13;
## data: &#13;
## [1] 1 2 3 &#13;
</pre><p>This code not only results in <code class="literal">f(y, x)</code>, but unnecessarily creates additional <code class="literal">data</code> and <code class="literal">input</code> variables in the current environment.</p><p>From the preceding examples and experiments, the bottom line is clear. To reduce ambiguity, it is allowed to use either <code class="literal">&lt;-</code> or <code class="literal">=</code> as the assignment operator and only use <code class="literal">=</code> to specify the named argument for functions. In conclusion, for better readability of R code, as the Google Style Guide suggests, only use <code class="literal">&lt;-</code> for assignment and <code class="literal">=</code> to specify named arguments.</p></div><div class="section" title="Using backticks with non-standard names"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Using backticks with non-standard names</h2></div></div></div><p>Assignment operators allow us to assign a value to a variable (or a symbol or name). However, direct assignment limits the format of the name. It contains only letters from a to z, A to Z (R is case-sensitive), the underscore(<code class="literal">_</code>), and dot(<code class="literal">.</code>), and it should not contain spaces or start with an underscore(<code class="literal">_</code>).</p><p>The following are some valid names:</p><pre class="programlisting">students &lt;- data.frame() &#13;
us_population &lt;- data.frame() &#13;
sales.2015 &lt;- data.frame() &#13;
</pre><p>The following are invalid names due to violating naming rules:</p><pre class="programlisting">some data &lt;- data.frame() &#13;
## Error: unexpected symbol in "some data" &#13;
_data &lt;- data.frame() &#13;
## Error: unexpected input in "_" &#13;
Population(Millions) &lt;- data.frame() &#13;
## Error in Population(Millions) &lt;- data.frame() :  &#13;
##  object 'Millions' not found &#13;
</pre><p>The preceding names violate the rules in different ways. The <code class="literal">some data</code> variable name contains a space, <code class="literal">_data</code> starts with <code class="literal">_</code>, and <code class="literal">Population(Millions)</code> is not a symbol name but a function call. In practice, it is quite likely that some invalid names might indeed be column names in a data table, such as the third name.</p><p>To walk around, we need to use back-ticks to quote the invalid names to make them valid:</p><pre class="programlisting">`some data` &lt;- c(1, 2, 3) &#13;
`_data` &lt;- c(4, 5, 6) &#13;
`Population(Millions)` &lt;- c(city1 = 50, city2 = 60) &#13;
</pre><p>To refer to these variables, also use backticks; otherwise, they will still be regarded as invalid:</p><pre class="programlisting">`some data`&#13;
## [1] 1 2 3&#13;
`_data`&#13;
## [1] 4 5 6&#13;
`Population(Millions)`&#13;
## city1city2 &#13;
##    50    60 &#13;
</pre><p>Backticks can be used wherever we create a symbol, irrespective of whether it is a function:</p><pre class="programlisting">`Tom's secret function` &lt;- function(a, d) { &#13;
  (a ^ 2 - d ^ 2) / (a ^ 2 + d ^ 2)  &#13;
} &#13;
</pre><p>It does not even matter if it is a list:</p><pre class="programlisting">l1 &lt;- list(`Group(A)` = rnorm(10), `Group(B)` = rnorm(10)) &#13;
</pre><p>If the symbol name cannot be validly referred to directly, we also need to use quotation marks to refer to the symbol:</p><pre class="programlisting">`Tom's secret function`(1,2)&#13;
## [1] -0.6&#13;
l1$`Group(A)`&#13;
##  [1] -0.8255922 -1.1508127 -0.7093875  0.5977409 -0.5503219 -1.0826915 &#13;
##  [7]  2.8866138  0.6323885 -1.5265957  0.9926590 &#13;
</pre><p>An exception is <code class="literal">data.frame()</code>:</p><pre class="programlisting">results &lt;- data.frame(`Group(A)` = rnorm(10), `Group(B)` = rnorm(10))&#13;
results&#13;
##       Group.A.    Group.B. &#13;
## 1  -1.14318956  1.66262403 &#13;
## 2  -0.54348588  0.08932864 &#13;
## 3   0.95958053 -0.45835235 &#13;
## 4   0.05661183 -1.01670316 &#13;
## 5  -0.03076004  0.11008584 &#13;
## 6  -0.05672594 -2.16722176 &#13;
## 7  -1.31293264  1.69768806 &#13;
## 8  -0.98761119 -0.71073080 &#13;
## 9   2.04856454 -1.41284611 &#13;
## 10  0.09207977 -1.16899586 &#13;
</pre><p>Unfortunately, even if we use backticks around a name with unusual symbols, the resulting <code class="literal">data.frame</code> variable will replace those symbols with the dots or using <code class="literal">make.names()</code>, a method that can be confirmed by looking at the column names of the resulting <code class="literal">data.frame</code>:</p><pre class="programlisting">colnames(results)&#13;
## [1] "Group.A." "Group.B." &#13;
</pre><p>This often happens when you import a table such as the following CSV data resulted from an experiment:</p><pre class="programlisting">ID,Category,Population(before),Population(after) &#13;
0,A,10,12 &#13;
1,A,12,13 &#13;
2,A,13,16 &#13;
3,B,11,12 &#13;
4,C,13,12 &#13;
</pre><p>When you read the CSV data using <code class="literal">read.csv()</code>, the <code class="literal">Population(before)</code> and <code class="literal">Population(after)</code> variable will not preserve their original names, but will change them to valid names in R using the <code class="literal">make.names()</code> method. To know what names we will get, we can run the following command:</p><pre class="programlisting">make.names(c("Population(before)", "Population(after)"))&#13;
## [1] "Population.before." "Population.after."</pre><p>Sometimes, this behavior is undesirable. To disable it, set <code class="literal">check.names = FALSE</code> when you call either <code class="literal">read.csv()</code> or <code class="literal">data.frame()</code>:</p><pre class="programlisting">results &lt;- data.frame(&#13;
ID = c(0, 1, 2, 3, 4),&#13;
Category = c("A", "A", "A", "B", "C"),&#13;
`Population(before)` = c(10, 12, 13, 11, 13),&#13;
`Population(after)` = c(12, 13, 16, 12, 12),&#13;
stringsAsFactors = FALSE,&#13;
check.names = FALSE)&#13;
results&#13;
##    ID Category Population(before) Population(after)&#13;
## 1  0     A          10                  12&#13;
## 2  1     A          12                  13&#13;
## 3  2     A          13                  16&#13;
## 4  3     B          11                  12&#13;
## 5  4     C          13                  12&#13;
colnames(results)&#13;
## [1] "ID"    "Category"   "Population(before)" &#13;
## [4] "Population(after)" &#13;
</pre><p>In the preceding call, <code class="literal">stringAsFactors = FALSE</code> avoids converting character vectors to factors and <code class="literal">check.names = FALSE</code> avoids applying <code class="literal">make.names()</code> on the column names. With these two arguments, the <code class="literal">data.frame</code> variable created will preserve most aspects of the input data.</p><p>Just as I mentioned, to access the column with special symbols, use backticks to quote the name:</p><pre class="programlisting">results$`Population(before)`&#13;
## [1] 10 12 13 11 13</pre><p>Backticks make it possible to create and access variables, with symbols not allowed in direct assignment. This does not mean using such names is recommended. Rather, it can make the code harder to read and more error-prone, and it makes it more difficult to work with external tools that impose strict naming rules.</p><p>In conclusion, using backticks to create special variable names should be avoided unless absolutely necessary.</p></div></div></div>
<div class="section" title="Conditional expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Conditional expressions</h1></div></div></div><p>It is common that the logic of a program is not perfectly sequential but contains several branches dependent on certain conditions. Therefore, one of the most basic constructs of a typical programming language is its conditional expressions. In R, <code class="literal">if</code> can be used to branch the logic flow by logical conditions.</p><div class="section" title="Using if as a statement"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Using if as a statement</h2></div></div></div><p>Like many other programming languages, the <code class="literal">if</code> expression works with a logical condition. In R, a logical condition is represented by an expression producing a single-element logical vector. For example, we can write a simple function <code class="literal">check_positive</code> that returns <code class="literal">1</code> if a positive number is provided and nothing otherwise:</p><pre class="programlisting">check_positive &lt;- function(x) { &#13;
  if (x &gt; 0) { &#13;
    return(1) &#13;
  } &#13;
} &#13;
</pre><p>In the preceding function, <code class="literal">x &gt; 0</code> is the condition to check. If the condition is satisfied, then the function returns <code class="literal">1</code>. Let's verify the function with various inputs:</p><pre class="programlisting">check_positive(1)&#13;
## [1] 1&#13;
check_positive(0)</pre><p>It seems that the function works as expected. If we add some <code class="literal">else if</code> and <code class="literal">else</code> branches, the function can be generalized as the sign function that returns <span class="strong"><strong>1</strong></span> for positive input, <code class="literal">-1</code> for negative input, and <code class="literal">0</code> for 0:</p><pre class="programlisting">check_sign &lt;- function(x) { &#13;
  if (x &gt; 0) { &#13;
    return(1) &#13;
  } else if (x &lt; 0) { &#13;
    return(-1) &#13;
  } else { &#13;
    return(0) &#13;
  } &#13;
} &#13;
</pre><p>The preceding function has the same functionality as the built-in function <code class="literal">sign()</code>. To verify its logic, just call it with different inputs with full coverage of the conditional branches:</p><pre class="programlisting">check_sign(15)&#13;
## [1] 1&#13;
check_sign(-3.5)&#13;
## [1] -1&#13;
check_sign(0)&#13;
## [1] 0 &#13;
</pre><p>The function does not need to return anything. We can also perform actions that return nothing (more accurately, <code class="literal">NULL</code>) depending on various conditions. The following function always does not explicitly return a value, but it sends a message in the console. The kind of message depends on the sign of the input number:</p><pre class="programlisting">say_sign &lt;- function(x) { &#13;
  if (x &gt; 0) { &#13;
    cat("The number is greater than 0") &#13;
  } else if (x &lt; 0) { &#13;
    cat("The number is less than 0") &#13;
  } else { &#13;
    cat("The number is 0") &#13;
  } &#13;
} &#13;
</pre><p>We can use a similar method, that is <code class="literal">say_sign()</code>, to test its logic:</p><pre class="programlisting">say_sign(0)&#13;
## The number is 0&#13;
say_sign(3)&#13;
## The number is greater than 0&#13;
say_sign(-9)&#13;
## The number is less than 0 &#13;
</pre><p>The workflow for evaluating <code class="literal">if</code> statement branches is quite straightforward:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, evaluate <code class="literal">cond1</code> in the first <code class="literal">if (cond1) { expr1 }</code>.</li><li class="listitem">If <code class="literal">cond1</code> is <code class="literal">TRUE</code>, then evaluate its corresponding expression <code class="literal">{ expr1 }</code>. Otherwise, evaluate the <code class="literal">cond2</code> condition in the next <code class="literal">else if (cond2)</code> branch and so forth.</li><li class="listitem">If the conditions in all <code class="literal">if</code> and <code class="literal">else if</code> branches are violated, then evaluate the expression in the <code class="literal">else</code> branch, if any.</li></ol></div><p>According to the workflow, an <code class="literal">if</code> statement can be more flexible than you might think. For example, an <code class="literal">if</code> statement can be in one of the following forms.</p><p>The simplest form is a simple <code class="literal">if</code> statement branch:</p><pre class="programlisting">if (cond1) { &#13;
  # do something &#13;
} &#13;
</pre><p>A more complete form is with an <code class="literal">else</code> branch that deals with situations where <code class="literal">cond1</code> is not <code class="literal">TRUE</code>:</p><pre class="programlisting">if (cond1) { &#13;
  # do something &#13;
} else { &#13;
  # do something else &#13;
} &#13;
</pre><p>An even more complex form is with one or more <code class="literal">else if</code> branches:</p><pre class="programlisting">if (cond1) { &#13;
  expr1 &#13;
} else if (cond2) { &#13;
  expr2 &#13;
} else if (cond3) { &#13;
  expr3 &#13;
} else { &#13;
  expr4 &#13;
} &#13;
</pre><p>In the preceding conditional branches, the branch conditions (<code class="literal">cond1</code>, <code class="literal">cond2</code>, and <code class="literal">cond3</code>) may or may not be related. For example, the simple grading policy perfectly fits the branching logic in the preceding template in which each branch condition is a slice of the score range:</p><pre class="programlisting">grade &lt;- function(score) {&#13;
  if (score &gt;= 90) {&#13;
    return("A")&#13;
  } else if (score &gt;= 80) {&#13;
    return("B")&#13;
  } else if (score &gt;= 70) {&#13;
    return("C")&#13;
  } else if (score &gt;= 60) {&#13;
    return("D")&#13;
  } else {&#13;
    return("F")&#13;
  }&#13;
}&#13;
c(grade(65), grade(59), grade(87), grade(96))&#13;
## [1] "D" "F" "B" "A" &#13;
</pre><p>In this case, each branch condition in <code class="literal">else if</code> actually implicitly assumes that the previous condition does not hold; that is, <code class="literal">score &gt;= 80</code> actually means <code class="literal">score &lt; 90</code> and
<code class="literal">score &gt;= 80</code>, which is dependent on previous conditions. As a result, we cannot switch the order of these branches without explicitly stating the assumptions and making all branches independent.</p><p>Let's assume we switch some of the branches:</p><pre class="programlisting">grade2 &lt;- function(score) {&#13;
  if (score &gt;= 60) {&#13;
    return("D")&#13;
  } else if (score &gt;= 70) {&#13;
    return("C")&#13;
  } else if (score &gt;= 80) {&#13;
    return("B")&#13;
  } else if (score &gt;= 90) {&#13;
    return("A")&#13;
  } else {&#13;
    return("F")&#13;
  }&#13;
}&#13;
c(grade2(65), grade2(59), grade2(87), grade2(96))&#13;
## [1] "D" "F" "D" "D" &#13;
</pre><p>It is obvious that only <code class="literal">grade(59)</code> got the right grade and all others are broken. To fix the function without reordering the conditions, we need to rewrite the condition so that they do not depend on the order of evaluation:</p><pre class="programlisting">grade2 &lt;- function(score) {&#13;
  if (score &gt;= 60 &amp;&amp; score &lt; 70) {&#13;
    return("D")&#13;
  } else if (score &gt;= 70 &amp;&amp; score &lt; 80) {&#13;
    return("C")&#13;
  } else if (score &gt;= 80 &amp;&amp; score &lt; 90) {&#13;
    return("B")&#13;
  } else if (score &gt;= 90) {&#13;
    return("A")&#13;
  } else {&#13;
    return("F")&#13;
  }&#13;
}&#13;
c(grade2(65), grade2(59), grade2(87), grade2(96))&#13;
## [1] "D" "F" "B" "A" &#13;
</pre><p>This makes the function much more verbose than the first correct version. Therefore, it is important to figure out the correct order for branch conditions and be careful of the dependency of each branch.</p><p>Fortunately, R provides convenient functions such as <code class="literal">cut()</code>, which does exactly the same thing. Read the documentation by typing in <code class="literal">?cut</code> for more details.</p></div><div class="section" title="Using if as an expression"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Using if as an expression</h2></div></div></div><p>Since <code class="literal">if</code> is in essence a primitive function, its returned value is the value of the expression in the branch whose condition is satisfied. Therefore, <code class="literal">if</code> can be used as an inline expression too. Take the <code class="literal">check_positive()</code> method for example. Rather than writing <code class="literal">return()</code> in the conditional expression, we can also return the value of the <code class="literal">if</code> statement expression in the function body to achieve the same goal:</p><pre class="programlisting">check_positive &lt;- function(x) { &#13;
  return(if (x &gt; 0) { &#13;
    1 &#13;
  }) &#13;
} &#13;
</pre><p>In fact, the expression syntax can to be simplified to merely one line:</p><pre class="programlisting">check_positive &lt;- function(x) { &#13;
  return(if (x &gt; 0) 1) &#13;
} &#13;
</pre><p>Since the return value of a function is the value of its last expression in the function body, <code class="literal">return()</code> can be removed in this case:</p><pre class="programlisting">check_positive &lt;- function(x) { &#13;
  if (x &gt; 0) 1 &#13;
} &#13;
</pre><p>The same principle also applies to the <code class="literal">check_sign()</code> method. A simpler form of <code class="literal">check_sign()</code> is as follows:</p><pre class="programlisting">check_sign &lt;- function(x) { &#13;
  if (x &gt; 0) 1 else if (x &lt; 0) -1 else 0 &#13;
} &#13;
</pre><p>To explicitly get the value of the <code class="literal">if</code> expression, we can implement a grade reporting function that mentions the grade of a student, given the student name and their score:</p><pre class="programlisting">say_grade &lt;- function(name, score) {&#13;
  grade &lt;- if (score &gt;= 90) "A"&#13;
    else if (score &gt;= 80) "B"&#13;
    else if (score &gt;= 70) "C"&#13;
    else if (score &gt;= 60) "D"&#13;
    else "F"&#13;
  cat("The grade of", name, "is", grade)&#13;
}&#13;
say_grade("Betty", 86)&#13;
## The grade of Betty is B &#13;
</pre><p>Using the <code class="literal">if</code> statement as an expression seems more compact and less verbose. However, in practice, it is rarely the case that all conditions are simple numeric comparisons and return simple values. For more complex conditions and branching, I suggest that you use <code class="literal">if</code> as a statement to clearly state different branches and do not omit <code class="literal">{}</code> to avoid unnecessary mistakes. The following function is a bad example:</p><pre class="programlisting">say_grade &lt;- function(name, score) { &#13;
  if (score &gt;= 90) grade &lt;- "A" &#13;
  cat("Congratulations!\n") &#13;
  else if (score &gt;= 80) grade &lt;- "B" &#13;
  else if (score &gt;= 70) grade &lt;- "C" &#13;
  else if (score &gt;= 60) grade &lt;- "D" &#13;
  else grade &lt;- "F" &#13;
  cat("What a pity!\n") &#13;
  cat("The grade of", name, "is", grade) &#13;
} &#13;
</pre><p>The function author wants to add something to say to some branches. Without <code class="literal">{}</code> brackets around the branch expression, you are very likely to write code with syntax errors when you add more behaviors to conditional branches. If you evaluate the preceding code in the console, you will get enough errors to confuse you for a while:</p><pre class="programlisting">&gt;say_grade &lt;- function(name, score) { &#13;
+   if (score &gt;= 90) grade &lt;- "A" &#13;
+   cat("Congratulations!\n") &#13;
+   else if (score &gt;= 80) grade &lt;- "B" &#13;
Error: unexpected 'else' in: &#13;
"  cat("Congratulations!\n") &#13;
  else" &#13;
&gt;   else if (score &gt;= 70) grade &lt;- "C" &#13;
Error: unexpected 'else' in "  else" &#13;
&gt;   else if (score &gt;= 60) grade &lt;- "D" &#13;
Error: unexpected 'else' in "  else" &#13;
&gt;   else grade &lt;- "F" &#13;
Error: unexpected 'else' in "  else" &#13;
&gt;   cat("What a pity!\n") &#13;
What a pity! &#13;
&gt;   cat("The grade of", name, "is", grade) &#13;
Error in cat("The grade of", name, "is", grade) : object 'name' not found &#13;
&gt; } &#13;
Error: unexpected '}' in "}" &#13;
</pre><p>A better form of the function that avoids such potential pitfalls is as follows:</p><pre class="programlisting">say_grade &lt;- function(name, score) {&#13;
  if (score &gt;= 90) {&#13;
    grade &lt;- "A"&#13;
    cat("Congratulations!\n")&#13;
  } else if (score &gt;= 80) {&#13;
    grade &lt;- "B"&#13;
  }&#13;
  else if (score &gt;= 70) {&#13;
    grade &lt;- "C"&#13;
  }&#13;
  else if (score &gt;= 60) {&#13;
    grade &lt;- "D"&#13;
  } else {&#13;
    grade &lt;- "F"&#13;
    cat("What a pity!\n")&#13;
  }&#13;
  cat("The grade of", name, "is", grade)&#13;
}&#13;
say_grade("James", 93)&#13;
## Congratulations! &#13;
## The grade of James is A &#13;
</pre><p>The function seems a bit more verbose, but it is more robust to changes and clearer in its logic. Remember, it is always better to be correct than short.</p></div><div class="section" title="Using if with vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Using if with vectors</h2></div></div></div><p>All the example functions created earlier only work with a single-value input. If we provide a vector, the functions will produce warnings because if does not work with multi-element vectors:</p><pre class="programlisting">check_positive(c(1, -1, 0))&#13;
## Warning in if (x &gt; 0) 1: the condition has length &gt; 1 and only the first&#13;
## element will be used&#13;
## [1] 1 &#13;
</pre><p>From the preceding output, we can see that the <code class="literal">if</code> statement ignores all but the first element, if a multi-element logical vector is supplied:</p><pre class="programlisting">num &lt;- c(1, 2, 3)&#13;
if (num &gt; 2) {&#13;
cat("num &gt; 2!")&#13;
}&#13;
## Warning in if (num &gt; 2) {: the condition has length &gt; 1 and only the first &#13;
## element will be used &#13;
</pre><p>The expression throws a warning saying that only the first element (<code class="literal">1 &gt; 2</code>) will be used. In fact, its logic is unclear when we try to condition an expression on a logical vector since its values can be mixed up with <code class="literal">TRUE</code> and <code class="literal">FALSE</code> values.</p><p>Some logical functions are useful to avoid such ambiguity. For example, the <code class="literal">any()</code> method returns <code class="literal">TRUE</code> if at least one element in the given vector is <code class="literal">TRUE</code>:</p><pre class="programlisting">any(c(TRUE, FALSE, FALSE))&#13;
## [1] TRUE&#13;
any(c(FALSE, FALSE))&#13;
## [1] FALSE &#13;
</pre><p>Therefore, if what we really mean is to print the message if any single value is greater than <code class="literal">2</code>, we should call the <code class="literal">any()</code> method in the condition:</p><pre class="programlisting">if (any(num &gt; 2)) {&#13;
  cat("num &gt; 2!")&#13;
}&#13;
## num &gt; 2! &#13;
</pre><p>If we mean to print the first message if all values are greater than <code class="literal">2</code>, we should instead call the <code class="literal">all()</code> method:</p><pre class="programlisting">if (all(num &gt; 2)) {&#13;
  cat("num &gt; 2!")&#13;
} else {&#13;
  cat("Not all values are greater than 2!")&#13;
}&#13;
## Not all values are greater than 2! &#13;
</pre><p>Therefore, every time we use an <code class="literal">if</code> expression to branch the workflow, we should ensure that the condition is a single-value logical vector. Otherwise, something unexpected may happen.</p><p>Another exception is <code class="literal">NA</code>, which is also a single-value logical vector but can cause an error as an <code class="literal">if</code> condition without notice:</p><pre class="programlisting">check &lt;- function(x) { &#13;
  if (all(x &gt; 0)) { &#13;
    cat("All input values are positive!") &#13;
  } else { &#13;
    cat("Some values are not positive!") &#13;
  } &#13;
} &#13;
</pre><p>The <code class="literal">check()</code> function works perfectly for typical numeric vectors with no missing values. However, if argument <code class="literal">x</code> contains a missing value, the function may end up in an error:</p><pre class="programlisting">check(c(1, 2, 3))&#13;
## All input values are positive!&#13;
check(c(1, 2, NA, -1))&#13;
## Some values are not positive!&#13;
check(c(1, 2, NA))&#13;
## Error in if (all(x &gt; 0)) {: missing value where TRUE/FALSE needed &#13;
</pre><p>From this example, we should be careful of missing values when we write <code class="literal">if</code> conditions. If the logic is complicated and the input data is diverse, you cannot easily walk around handling missing values in appropriate ways. Note that the <code class="literal">any()</code> and <code class="literal">all()</code> methods both accept <code class="literal">na.rm</code> to handle missing values. We should take this into account too when writing conditions.</p><p>One way to simplify condition checking is to use <code class="literal">isTRUE(x)</code>, which calls 
<code class="literal">identical(TRUE, x)</code> internally. In this case, only a single <code class="literal">TRUE</code> value will meet the condition and all other values will not.</p></div><div class="section" title="Using vectorized if: ifelse"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Using vectorized if: ifelse</h2></div></div></div><p>An alternate method to branch a computation is <code class="literal">ifelse()</code>. This function accepts a logical vector as the test condition and returns a vector. For each element in the logical test condition, if the value is <code class="literal">TRUE</code>, then the corresponding element in the second argument <code class="literal">yes</code> will be chosen. If the value is <code class="literal">FALSE</code>, then the corresponding element in the third argument <code class="literal">no</code> will be chosen. In other words, <code class="literal">ifelse()</code> is the vectorized version of <code class="literal">if</code>, as demonstrated here:</p><pre class="programlisting">ifelse(c(TRUE, FALSE, FALSE), c(1, 2, 3), c(4, 5, 6))&#13;
## [1] 1 5 6 &#13;
</pre><p>Since the <code class="literal">yes</code> and <code class="literal">no</code> arguments can be recycled, we can rewrite <code class="literal">check_positive()</code> using <code class="literal">ifelse()</code>:</p><pre class="programlisting">check_positive2 &lt;- function(x) { &#13;
  ifelse(x, 1, 0) &#13;
} &#13;
</pre><p>One difference between <code class="literal">check_positive()</code> (using the <code class="literal">if</code> statement) and <code class="literal">check_positive2()</code> (using <code class="literal">ifelse</code>) is subtle: <code class="literal">check_positive(-1)</code> does not return values explicitly, but <code class="literal">chek_positive2(-1)</code> returns 0. The <code class="literal">if</code> statement does not necessarily return a value explicitly by using only one <code class="literal">if</code> but not <code class="literal">else</code>. By contrast, <code class="literal">ifelse()</code> always returns a vector because you have to specify the values in both <code class="literal">yes</code> and <code class="literal">no</code> arguments.</p><p>Another reminder is that <code class="literal">ifelse()</code> and <code class="literal">if</code> are not always able to achieve the same goal if you simply replace one with the other. For example, imagine you want to return a two-element vector according to a condition. Let's assume we use <code class="literal">ifelse()</code>:</p><pre class="programlisting">ifelse(TRUE, c(1,2), c(2,3))&#13;
## [1] 1</pre><p>Only the first element of the <code class="literal">yes</code> argument is returned. If you want to return the <code class="literal">yes</code> argument, you need to modify the condition to <code class="literal">c(TRUE, TRUE)</code>, which looks a bit unnatural.</p><p>If we use <code class="literal">if</code>, then the expression looks much more natural:</p><pre class="programlisting">if (TRUE) c(1,2) else c(2,3)&#13;
## [1] 1 2</pre><p>If the demand is a vectorized input and output, then another problem is that, if the <code class="literal">yes</code> argument is a numeric vector and the <code class="literal">no</code> argument is a character vector, a condition with mixed <code class="literal">TRUE</code> and <code class="literal">FALSE</code> values will coerce all elements in the output vector to be able to represent all values. Thus, a character vector is produced:</p><pre class="programlisting">ifelse(c(TRUE, FALSE), c(1, 2), c("a", "b"))&#13;
## [1] "1" "b"</pre></div><div class="section" title="Using switch to branch values"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Using switch to branch values</h2></div></div></div><p>In contrast with if, which deals with <code class="literal">TRUE</code> and <code class="literal">FALSE</code> conditions, <code class="literal">switch</code> works with a number or a string and chooses a branch to return according to the input.</p><p>Suppose the input is an integer <code class="literal">n</code>. The <code class="literal">switch</code> keyword works in a way that returns the value of the n<sup>th</sup> arguments in following the first argument:</p><pre class="programlisting">switch(1, "x", "y")&#13;
## [1] "x"&#13;
switch(2, "x", "y")&#13;
## [1] "y" &#13;
</pre><p>If the input integer is out of bounds and does not match any given argument, no visible value is explicitly returned (in fact, an invisible <code class="literal">NULL</code> is returned):</p><pre class="programlisting">switch(3, "x", "y") &#13;
</pre><p>The <code class="literal">switch()</code> method has a different behavior when working with string input. It returns the value of the first argument that matches its name with the input:</p><pre class="programlisting">switch("a", a = 1, b = 2)&#13;
## [1] 1&#13;
switch("b", a = 1, b = 2)&#13;
## [1] 2 &#13;
</pre><p>For the first <code class="literal">switch</code>, <code class="literal">a = 1 </code>matches the variable <code class="literal">a</code>. For the second, <code class="literal">b = 2</code> matches the variable <code class="literal">b</code>. If no argument matches the input, an invisible <code class="literal">NULL</code> value will be returned:</p><pre class="programlisting">switch("c", a = 1, b = 2) &#13;
</pre><p>To cover all possibilities, we can add a last argument (without argument name) that captures all other inputs:</p><pre class="programlisting">switch("c", a = 1, b = 2, 3)&#13;
## [1] 3 &#13;
</pre><p>Compared to the <code class="literal">ifelse()</code> method, <code class="literal">switch()</code> behaves more like <code class="literal">if()</code> method. It only accepts a single value input (number of string) but it can return anything:</p><pre class="programlisting">switch_test &lt;- function(x) {&#13;
  switch(x,&#13;
    a = c(1, 2, 3),&#13;
    b = list(x = 0, y = 1),&#13;
    c = {&#13;
      cat("You choose c!\n")&#13;
      list(name = "c", value = "something")&#13;
    })&#13;
}&#13;
switch_test("a")&#13;
## [1] 1 2 3&#13;
switch_test("b")&#13;
## $x&#13;
## [1] 0&#13;
##&#13;
## $y&#13;
## [1] 1&#13;
switch_test("c")&#13;
## You choose c!&#13;
## $name &#13;
## [1] "c" &#13;
##  &#13;
## $value &#13;
## [1] "something" &#13;
</pre><p>In conclusion, <code class="literal">if</code>, <code class="literal">ifelse()</code>, and <code class="literal">switch()</code> have slightly different behaviors. You should apply them in different situations accordingly.</p></div></div>
<div class="section" title="Loop expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Loop expressions</h1></div></div></div><p>Loop (or iteration) evaluates an expression repeatedly by either iterating over a vector (<code class="literal">for</code>) or checking whether a condition is violated (while).</p><p>Such language constructs largely reduce the redundancy of the code if the same task is run over and over again each time with some changes in input.</p><div class="section" title="Using the for loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Using the for loop</h2></div></div></div><p>The <code class="literal">for</code> loop evaluates an expression by iterating over a given vector or list. The syntax of a <code class="literal">for</code> loop is as follows:</p><pre class="programlisting">for (var in vector) { &#13;
  expr &#13;
} &#13;
</pre><p>Then, <code class="literal">expr</code> will be evaluated iteratively, with <code class="literal">var</code> taking the value of each element of <code class="literal">vector</code> in turn. If <code class="literal">vector</code> has <code class="literal">n</code> elements, then the preceding loop is equivalent to evaluating:</p><pre class="programlisting">var &lt;- vector[[1]] &#13;
expr &#13;
var &lt;- vector[[2]] &#13;
expr &#13;
... &#13;
var &lt;- vector[[n]] &#13;
expr &#13;
</pre><p>For example, we can create a loop to iterate over <code class="literal">1:3</code> with iterator variable <code class="literal">i</code>. In each iteration, we will show text on the screen to indicate the value of <code class="literal">i</code>:</p><pre class="programlisting">for (i in 1:3) {&#13;
cat("The value of i is", i, "\n")&#13;
}&#13;
## The value of i is 1  &#13;
## The value of i is 2  &#13;
## The value of i is 3 &#13;
</pre><p>The iterator works with not only numeric vectors but all vectors. For example, we can replace the integer vector <code class="literal">1:3</code> with a character vector:</p><pre class="programlisting">for (word in c("hello","new", "world")) {&#13;
cat("The current word is", word, "\n")&#13;
}&#13;
## The current word is hello  &#13;
## The current word is new  &#13;
## The current word is world &#13;
</pre><p>We can also replace it with a list:</p><pre class="programlisting">loop_list &lt;- list(&#13;
  a = c(1, 2, 3),&#13;
  b = c("a", "b", "c", "d"))&#13;
for (item in loop_list) {&#13;
  cat("item:\n length:", length(item),&#13;
    "\n class: ", class(item), "\n")&#13;
}&#13;
## item: &#13;
##   length: 3  &#13;
##   class:  numeric  &#13;
## item: &#13;
##   length: 4  &#13;
##   class:  character &#13;
</pre><p>Alternatively, we can replace it with a data frame:</p><pre class="programlisting">df &lt;- data.frame(&#13;
  x = c(1, 2, 3),&#13;
  y = c("A", "B", "C"),&#13;
stringsAsFactors = FALSE)&#13;
for (col in df) {&#13;
  str(col)&#13;
}&#13;
##  num [1:3] 1 2 3 &#13;
##  chr [1:3] "A" "B" "C" &#13;
</pre><p>Previously, we mentioned that a data frame is a list in which each element (column) must have the same length. Therefore, the preceding loop iterates over the columns rather than rows, which is consistent with the behavior of <code class="literal">for</code> when it iterates over an ordinary list.</p><p>However, in many cases, we want to iterate over a data frame row by row. We can do this using <code class="literal">for</code>, but over an integer sequence from 1 to the number of rows of the data frame.</p><p>As long as <code class="literal">i</code> gets a row number, we can single out that particular row from the data frame and do something with it. The following code iterates over a data frame row by row and prints the structure of each row using <code class="literal">str()</code>:</p><pre class="programlisting">for (i in 1:nrow(df)) {&#13;
  row &lt;- df[i,]&#13;
  cat("row", i, "\n")&#13;
  str(row)&#13;
  cat("\n")&#13;
}&#13;
## row 1  &#13;
## 'data.frame':    1 obs. of  2 variables: &#13;
##  $ x: num 1 &#13;
##  $ y: chr "A" &#13;
##  &#13;
## row 2  &#13;
## 'data.frame':    1 obs. of  2 variables: &#13;
##  $ x: num 2 &#13;
##  $ y: chr "B" &#13;
##  &#13;
## row 3  &#13;
## 'data.frame':    1 obs. of  2 variables: &#13;
##  $ x: num 3 &#13;
##  $ y: chr "C" &#13;
</pre><p>I should give a little warning here that iterating over a data frame row by row is generally not a good idea because it can be slow and verbose. A better way is to use either the apply family functions covered in <a class="link" href="ch05.html" title="Chapter 5. Working with Basic Objects">Chapter 5</a>, <span class="emphasis"><em>Working with Basic Objects</em></span>, or more powerful yet advanced package functions covered in <a class="link" href="ch12.html" title="Chapter 12. Data Manipulation">Chapter 12</a>, <span class="emphasis"><em>Data Manipulation</em></span>.</p><p>In the preceding examples, each iteration of the <code class="literal">for</code> loops is independent. In some cases, however, the iterations alter variables outside the loop to keep track of certain states or keep a record of an accumulation. The simplest example is counting the sum from 1 to 100:</p><pre class="programlisting">s &lt;- 0&#13;
for (i in 1:100) {&#13;
  s &lt;- s + i&#13;
}&#13;
s&#13;
## [1] 5050 &#13;
</pre><p>The preceding example demonstrates an accumulation using the <code class="literal">for</code> loop. The following example produces a simple realization of a random walk using a random number generator that samples from normal distribution <code class="literal">rnorm()</code>:</p><pre class="programlisting">set.seed(123) &#13;
x &lt;- numeric(1000) &#13;
for (t in 1:(length(x) - 1)) { &#13;
  x[[t + 1]] &lt;- x[[t]] + rnorm(1, 0, 0.1) &#13;
} &#13;
plot(x, type = "s", main = "Random walk", xlab = "t") &#13;
</pre><p>The plot generated is as shown:</p><div class="mediaobject"><img src="graphics/image_04_001.jpg" alt="Using the for loop"/></div><p>Although the <code class="literal">for</code> loops in the preceding two examples have a one-step dependency on the previous result, they can be simplified using existing functions such as the <code class="literal">sum()</code> method and <code class="literal">cumsum()</code>:</p><pre class="programlisting">sum100 &lt;- sum(1:100) &#13;
random_walk &lt;- cumsum(rnorm(1000, 0, 0.1)) &#13;
</pre><p>The basic idea in the implementation of these functions is similar to the preceding <code class="literal">for</code> loops, but they are vectorized and implemented in C so that they can be a lot faster than a <code class="literal">for</code> loop in R. Therefore, you should first consider using these built-in functions if possible.</p><div class="section" title="Managing the flow of a for loop"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec14"/>Managing the flow of a for loop</h3></div></div></div><p>Sometimes, it is useful to intervene in a <code class="literal">for</code> loop. In each iteration, we can choose to interrupt the <code class="literal">for</code> loop, to skip the current iteration, or do nothing and finish the loop.</p><p>We can use break to terminate a <code class="literal">for</code> loop:</p><pre class="programlisting">for (i in 1:5) {&#13;
  if (i == 3) break&#13;
  cat("message ", i, "\n")&#13;
}&#13;
## message 1&#13;
## message 2</pre><p>This can be used, for example, to find a solution to a problem. The following code attempts to find the numbers between 1,000 and 1,100 that satisfy <code class="literal">(i ^ 2) %% 11</code> equals <code class="literal">(i ^ 3) %% 17</code>, where <code class="literal">^</code> is the power operator and <code class="literal">%%</code> is the modulo operator that returns the remainder of a division:</p><pre class="programlisting">m &lt;- integer()&#13;
for (i in 1000:1100) {&#13;
  if ((i ^ 2) %% 11 == (i ^ 3) %% 17) {&#13;
    m &lt;- c(m, i)&#13;
}&#13;
}&#13;
m&#13;
## [1] 1055 1061 1082 1086 1095 &#13;
</pre><p>If you only need one number in the range to satisfy the condition, you can replace the record tracking expression with a simple break:</p><pre class="programlisting">for (i in 1000:1100) {&#13;
  if ((i ^ 2) %% 11 == (i ^ 3) %% 17) break&#13;
}&#13;
i&#13;
## [1] 1055 &#13;
</pre><p>Once a solution is found, the <code class="literal">for</code> loop breaks and the last value of <code class="literal">i</code> is preserved in the current environment so that you know the solution that satisfies the condition.</p><p>In some other cases, skipping an iteration in a <code class="literal">for</code> loop is also useful. We can use the <code class="literal">next</code> keyword to skip the rest expressions in the current iteration and directly jump to the next iteration of the loop:</p><pre class="programlisting">for (i in 1:5) {&#13;
  if (i == 3) next&#13;
  cat("message ", i, "\n")&#13;
}&#13;
## message  1  &#13;
## message  2  &#13;
## message  4  &#13;
## message  5 &#13;
</pre></div><div class="section" title="Creating nested for loops"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec15"/>Creating nested for loops</h3></div></div></div><p>The expression in a <code class="literal">for</code> loop can be anything, including another <code class="literal">for</code> loop. For example, if we want to exhaust all permutations of the elements in a vector, we can write a two-level nested <code class="literal">for</code> loop to solve the problem:</p><pre class="programlisting">x &lt;- c("a", "b", "c")&#13;
combx &lt;- character()&#13;
for (c1 in x) {&#13;
  for (c2 in x) {&#13;
    combx &lt;- c(combx, paste(c1, c2, sep = ",", collapse = ""))&#13;
  }&#13;
}&#13;
combx&#13;
## [1] "a,a" "a,b" "a,c" "b,a" "b,b" "b,c" "c,a" "c,b" "c,c" &#13;
</pre><p>If you only need permutations that contain distinct elements, you can add a test condition in the inner <code class="literal">for</code> loop:</p><pre class="programlisting">combx2 &lt;- character()&#13;
for (c1 in x) {&#13;
  for (c2 in x) {&#13;
    if (c1 == c2) next&#13;
    combx2 &lt;- c(combx2, paste(c1, c2, sep = ",", collapse = ""))&#13;
  }&#13;
}&#13;
combx2&#13;
## [1] "a,b" "a,c" "b,a" "b,c" "c,a" "c,b" &#13;
</pre><p>Alternatively, you can just negate the condition and replace the expression in the inner <code class="literal">for</code> loop with the following code to get exactly the same result:</p><pre class="programlisting">if (c1 != c2) { &#13;
combx2 &lt;- c(combx2, paste(c1, c2, sep = ",", collapse = ""))&#13;
}</pre><p>The preceding code demonstrates how nested loops work, but it is not optimal to solve the problem. Some built-in functions help generate combinations or permutations of vector elements. The <code class="literal">combn()</code> method produces a matrix of combinations of vector elements, given an atomic vector and the number of elements in each combination:</p><pre class="programlisting">combn(c("a", "b", "c"), 2)&#13;
##      [,1] [,2] [,3] &#13;
## [1,] "a"  "a"  "b"  &#13;
## [2,] "b"  "c"  "c" &#13;
</pre><p>Similar to the preceding examples implemented using the <code class="literal">for</code> loop, <code class="literal">expand.grid()</code> produces a data frame containing all permutations of elements in multiple vectors:</p><pre class="programlisting">expand.grid(n = c(1, 2, 3), x = c("a", "b"))&#13;
##   n x &#13;
## 1 1 a &#13;
## 2 2 a &#13;
## 3 3 a &#13;
## 4 1 b &#13;
## 5 2 b &#13;
## 6 3 b &#13;
</pre><p>Although the <code class="literal">for</code> loop can be powerful, there are functions designed for certain tasks. It is better to consider using built-in functions than directly putting everything in a <code class="literal">for</code> loop. In the following chapter, I will introduce <code class="literal">lapply()</code> and related functions to replace many <code class="literal">for</code> loops, which makes code easier to write and understand.</p></div></div><div class="section" title="Using the while loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Using the while loop</h2></div></div></div><p>In contrast to the <code class="literal">for</code> loop, the <code class="literal">while</code> loop does not stop running until the given condition is violated.</p><p>For example, the following <code class="literal">while</code> loop starts with <code class="literal">x = 0</code>. Each time, the loop checks whether <code class="literal">x &lt;= 10</code> holds. If so, the inner expressions are evaluated; otherwise, the <code class="literal">while</code> loop terminates:</p><pre class="programlisting">x &lt;- 0&#13;
while (x &lt;= 5) {&#13;
  cat(x, " ", sep = "")&#13;
  x &lt;- x + 1&#13;
}&#13;
## 0 1 2 3 4 5 &#13;
</pre><p>If we remove <code class="literal">x &lt;- x + 1</code> so that <code class="literal">x</code> no longer gains any increment, the code will run forever (until R is terminated by force). Therefore, the while loop can sometimes be dangerous if not properly implemented.</p><p>Like the <code class="literal">for</code> loop, flow control statements (<code class="literal">break</code> and <code class="literal">next</code>) are also applicable in <code class="literal">while</code>:</p><pre class="programlisting">x &lt;- 0&#13;
while (TRUE) {&#13;
  x &lt;- x + 1&#13;
  if (x == 4) break&#13;
  else if (x == 2) next&#13;
  else cat(x, '\n')&#13;
}&#13;
## 1  &#13;
## 3 &#13;
</pre><p>In practice, the <code class="literal">while</code> loop is often used where the number of iterations is unknown. This usually happens when we fetch rows chunk-by-chunk from the result set of a database query. The code may look as follows:</p><pre class="programlisting">res &lt;- dbSendQuery(con, "SELECT * FROM table1 WHERE type = 1") &#13;
while (!dbHasCompleted(res)) { &#13;
  chunk &lt;- dbFetch(res, 10000) &#13;
  process(chunk) &#13;
} &#13;
</pre><p>First, we query all records whose type is 1 from a database through the con connection. Once the database returns a result set, <code class="literal">res</code>, we can fetch data from the result set chunk by chunk and process one chunk each time. Since the number of records is unknown prior to the query, we need to use a while loop that breaks when all data is completely fetched, which is indicated by <code class="literal">dbHasCompleted()</code>.</p><p>In this way, we avoid fetching a (perhaps huge) data frame to memory. Instead, we work with small chunks. This allows us to process a large amount of data with only a small working set in memory. However, the major premise is that the algorithm <code class="literal">process()</code> must support processing data chunk by chunk.</p><p>You may not be familiar with the preceding code example or the terminologies, but don't worry. We will cover database topics in detail in a later chapter.</p><p>In addition to the <code class="literal">for</code> loop and the <code class="literal">while</code> loop, R also provides the <code class="literal">repeat</code> loop. Like <code class="literal">while (TRUE)</code>, the <code class="literal">repeat</code> keyword is also a real loop, because it does not require an explicit termination condition or boundary unless <code class="literal">break</code> is hit:</p><pre class="programlisting">x &lt;- 0&#13;
repeat {&#13;
  x &lt;- x + 1&#13;
  if (x == 4) break&#13;
  else if (x == 2) next&#13;
  else cat(x, '\n')&#13;
}&#13;
## 1  &#13;
## 3 &#13;
</pre><p>However, the <code class="literal">repeat</code> keyword can be very dangerous and is not recommended in practice.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>In this chapter, you learned the syntax of assignment, conditional expressions, and loops. In the section on assignment, you got to know the naming rules of variables and how to walk around. In the section on conditional expressions, you learned how to use the <code class="literal">if</code> statement as either a statement or an expression, and how <code class="literal">ifelse()</code>is distinct from <code class="literal">if</code> when dealing with vectors. In the section on loops, you learned about the similarities and differences between <code class="literal">for</code> loops and <code class="literal">while</code> loops. Now, we are equipped with the basic expressions to control the logic flow of an R program.</p><p>In the next chapter, you will use what you learned in the previous chapters and see what you can do with the basic objects representing data and basic expressions representing our logic. You will learn about basic functions in various categories as the building blocks of data transformation and statistical analysis.</p></div></body></html>