<html><head></head><body>
		<div><h1 id="_idParaDest-197"><em class="italic"><a id="_idTextAnchor197"/>Chapter 7</em>: Simulating Quantum Computers with Aer</h1>
			<p>So far, we have mainly been running our quantum programs on our local QASM simulator, which out of the box simulates a <strong class="bold">universal error-correcting quantum computer</strong>—the type of machine that the quantum computing world expects, or at least hopes, will be a reality within the next few years.</p>
			<p>But these amazing machines are not available yet, so in this chapter, we will explore quantum simulators both locally with <strong class="bold">Qiskit Aer</strong> and in the cloud with <strong class="bold">IBM Quantum®</strong> simulators. We will understand how to run your quantum circuits on these simulated perfect backends.</p>
			<p>However, you can also use Qiskit Aer to simulate today's <strong class="bold">Noisy Intermediate-Scale Quantum </strong>(<strong class="bold">NISQ</strong>) computers by setting up noise profiles for the simulator to emulate the real IBM Quantum® hardware, with gate errors and noise. So, we will take a look at that as well.</p>
			<p>We will also look at two other local simulator types and what you can use them for: the <strong class="bold">unitary simulator</strong> and the <strong class="bold">state vector simulator</strong>.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Understanding the usage of quantum simulators</li>
				<li>Comparing the Qiskit Aer simulator with an IBM quantum computer</li>
				<li>Adding noise profiles of IBM Quantum® backends to local simulators</li>
				<li>Understanding your circuits by using the unitary simulator</li>
				<li>Running diagnostics with the state vector simulator</li>
			</ul>
			<p>The goal of the chapter is to get equipped with the tools to use the simulators when you develop and test your quantum programs so that you do not have to wait in line for your IBM Quantum® backends to run your tests. We will start by exploring the <code>qasm_simulator</code> backend, and then take a look at the unitary and state vector simulators.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor198"/>Technical requirements</h1>
			<p>The quantum programs that we discuss in this chapter can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter07">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter07</a>.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor199"/>Understanding the usage of quantum simulators</h1>
			<p>A <strong class="bold">quantum computer simulator</strong> is a software program that simulates the quantum mechanical behavior of a real quantum computer. Simulators are useful for testing your quantum circuits in a local environment before you run them on the IBM Quantum® backends in the cloud. You can also use<a id="_idIndexMarker510"/> cloud-based simulators to test larger quantum circuits that might not yet be possible to run on actual quantum computers or just take too long to run on your local simulator. </p>
			<p>In this recipe, we will take a quick tour to compare the available Qiskit® simulators—both local on <strong class="bold">Qiskit Aer</strong> and in the cloud on <strong class="bold">IBM Quantum®</strong>.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor200"/>Getting ready</h2>
			<p>Make sure you have everything working from <a href="B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Environment</em>.</p>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r1_aer.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r1_aer.py</a>.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor201"/>How to do it...</h2>
			<p>Let's take a look at the code:</p>
			<ol>
				<li>As usual, we start by importing the classes and we need. We import both <code>Aer</code> and <code>IBMQ</code>, as we will work with simulators both locally and remotely. If needed, we also load our account and get our providers:<pre>from qiskit import Aer, IBMQ
if not IBMQ.active_account():
    IBMQ.load_account()
provider = IBMQ.get_provider()</pre></li>
				<li>Then, we use the <code>backends()</code> method to take<a id="_idIndexMarker511"/> a look at the available local Qiskit Aer backends:<pre>backends=Aer.backends()
print("\nAer backends:\n\n",backends)</pre><p>The preceding code should give the following result:</p><div><img alt="Figure 7.1 – The local Aer backends; all simulators&#13;&#10;" src="img/Figure_7.1_B14436.jpg"/></div><p class="figure-caption">Figure 7.1 – The local Aer backends; all simulators</p></li>
				<li>We can store the configuration details for these simulators in a <code>simulators</code> list for further processing. Use the <code>backend.configuration()</code> method to pull out this information and loop through the available backends, appending the data for each to the list:<pre>simulators=[]
for sim in range(0,len(backends)):
    backend = Aer.get_backend(str(backends[sim]))
    simulators.append(backend.configuration())</pre></li>
				<li>For completeness, we'll add the configuration details for the IBM Quantum® simulator by appending that information to the list:<pre>ibmq_simulator=provider.backends(simulator=True)
simulators.append(provider.get_backend(str(ibmq_simulator[0])). simulator[0])).configuration())</pre></li>
				<li>Display the raw simulator <a id="_idIndexMarker512"/>configuration details. Let's cycle through the <code>simulators</code> list to print out and look at the available configuration details for our simulators:<pre># Display the raw simulator configuration details
print("\nSimulator configuration details:")
for sim in range(0,len(simulators)):
    print("\n")
    print(simulators[sim].backend_name)
    print(simulators[sim].to_dict())</pre><p>The code should be similar to the following output for each simulator:</p><div><img alt="Figure 7.2 – A heap of simulator configuration details&#13;&#10;" src="img/Figure_7.2_B14436.jpg"/></div><p class="figure-caption">Figure 7.2 – A heap of simulator configuration details</p><p>This raw printout will produce a slew of information to wade through. In the next step, we will sort out and display a few common parameters for comparison.</p></li>
				<li>Compare the simulators. <p>So, there is an awful lot of information for each simulator. To make a comparison, let's grab a few parameters of interest and list them for each simulator. For our purposes, the following parameters might be interesting:</p><p><code>ibmq_qasm_simulator</code> details, you will see that this non-local IBM Quantum® simulator doesn't have a description:</p></li>
			</ol>
			<div><div><img alt="Figure 7.3 – ibmq_qasm_simulator has no description&#13;&#10;" src="img/Figure_7.3_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – ibmq_qasm_simulator has no description</p>
			<p>In the code, we add our own description for completeness by using an <code>if</code>/<code>elif</code> command for the <code>local</code> attribute for each simulator, adding our own description if <code>local==False</code>:</p>
			<pre># Fish out criteria to compare
print("\n")
print("{0:25} {1:&lt;10} {2:&lt;10} {3:&lt;10}".    format("Name","#Qubits","Max shots.","Description"))
print("{0:25} {1:&lt;10} {2:&lt;10} {3:&lt;10}".    format("----","-------","--------","------------"))
description=[]
for sim in range(0,len(simulators)):
    if simulators[sim].local==True:
        description.append(simulators[sim].description)
    elif simulators[sim].local==False:
        description.append("Non-local IBM Quantum             simulator")
    print("{0:25} {1:&lt;10} {2:&lt;10} {3:&lt;10}".        format(simulators[sim].backend_name, 
        simulators[sim].n_qubits,         simulators[sim].max_shots, description[sim]))</pre>
			<p>The previous sample code will result in something similar to the following:</p>
			<div><div><img alt="Figure 7.4 – A list of selected simulator properties" src="img/Figure_7.4_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – A list of selected simulator properties</p>
			<p>From this list, we can get a high-level overview of what the simulators can do, and what the specific criteria for each are:</p>
			<p><code>qasm_simulator</code>: This simulator lets<a id="_idIndexMarker514"/> you run your quantum programs and returns results as if you were running on a perfect quantum computer, with no errors and no noise, but with the option to add errors and a noise profile to simulate a <em class="italic">NISQ backend</em>. This simulator is written in C++ and runs locally on your machine.</p>
			<p><code>statevector_simulator</code>: With this simulator, you can simulate the state vector for your qubits at any point in your circuit. This simulator is written in C++ and runs locally on your machine.</p>
			<p><code>unitary_simulator</code>: With the unitary simulator, you can compute the unitary matrix for your circuit. This simulator is implemented as a local Python simulator.</p>
			<p><code>pulse_simulator</code>: A pulse-based Hamiltonian simulator for Pulse Qobj files. With this simulator, you can test interacting with the backend qubits directly using pulse-based programming that bypasses the standard gates.  </p>
			<p><code>ibmq_qasm_simulator</code>: This is the only non-local simulator in the group. It works much like the local <code>qasm_simulator</code> simulator but with higher performance. </p>
			<p>We now know what simulators are<a id="_idIndexMarker515"/> available for us to work with, and we will explore them further in this chapter. The only simulator we will not touch is the <code>pulse_simulator</code> as using this simulator is beyond the scope of this book. If you are interested, do take a look at the <em class="italic">Get to the heart of real quantum hardware</em> link at the end of the recipe.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor202"/>There's more...</h2>
			<p>Take a look at the performance data for the two QASM simulators—<strong class="bold">Number of qubits</strong> and <strong class="bold">Max shots</strong>. They both let<a id="_idIndexMarker516"/> you play with around <em class="italic">30 qubits</em> and run many thousands of shots with each run. So, what is the<a id="_idIndexMarker517"/> difference?</p>
			<p>One thing to keep in mind when running the simulators is that they are simulating quantum computers—the very computers that we expect to beat classical computers at complex problems going forward. This essentially means that simulating quantum computers on a classical computer like yours gets roughly twice as complicated with each added qubit.</p>
			<p>For the online <code>ibmq_qasm_simulator</code> simulator, this doesn't necessarily pose a big problem as it is running on an IBM POWER9™ server, which is a fairly massive piece of hardware. You can throw seriously sized quantum programs, up to <em class="italic">32 qubits</em>, at it with no problems.</p>
			<p>Your own hardware, on the other hand, is a different matter. The performance of the local <code>qasm_simulator</code> simulator will depend on the hardware you run it on. When you start to feel a lag and slowness on your local machine, it might be time for the online <code>ibmq_qasm_simulator</code> simulator.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor203"/>See also</h2>
			<ul>
				<li><em class="italic">An Open High-Performance Simulator for Quantum Circuits, IBM Research Blog</em>, May 1, 2018: <a href="https://www.ibm.com/blogs/research/2018/05/quantum-circuits/">https://www.ibm.com/blogs/research/2018/05/quantum-circuits/</a></li>
				<li><em class="italic">Get to the heart of real quantum hardware, IBM Research Blog</em>, December 12, 2019: <a href="https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/">https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/</a></li>
				<li><em class="italic">IBM Power systems</em>: <a href="https://www.ibm.com/it-infrastructure/power">https://www.ibm.com/it-infrastructure/power</a></li>
			</ul>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor204"/>Comparing the Qiskit Aer simulator with an IBM quantum computer</h1>
			<p>In this recipe, we will create <a id="_idIndexMarker518"/>a long quantum circuit that <em class="italic">swaps</em> a <img alt="" src="img/Formula_07_001.png"/> state between<a id="_idIndexMarker519"/> two qubits. You will see that the circuit provides perfect results on your local Qiskit Aer simulator but not quite so perfect results on an actual IBM Quantum® machine.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor205"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r2_ootb.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r2_ootb.py</a>.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor206"/>How to do it...</h2>
			<p>Here's the code, stored<a id="_idIndexMarker520"/> in the <code>ch7_r2_ootb.py</code> file:</p>
			<ol>
				<li value="1">As always, start by importing the<a id="_idIndexMarker521"/> required classes and methods and load your account:<pre># Import Qiskit
from qiskit import QuantumCircuit
from qiskit import Aer, IBMQ, execute
# Import visualization tools
from qiskit.tools.visualization import plot_histogram
from qiskit.tools.monitor import job_monitor
# Load account
if not IBMQ.active_account():
    IBMQ.load_account()
provider = IBMQ.get_provider() </pre></li>
				<li>Select the number of SWAP gates to include:<pre># Enter number of SWAP gates to include with your circuit # with (default 10)
user_input = input("Enter number of SWAP gates to use:")
try:
   n = int(user_input)
except ValueError:
   n=10
n_gates=n</pre></li>
				<li>We now build a quantum circuit <a id="_idIndexMarker522"/>with the selected number of <a id="_idIndexMarker523"/>SWAP gates in a row:<pre># Construct quantum circuit
circ = QuantumCircuit(2, 2)
circ.x(0)
while n &gt;0:
    circ.swap(0,1)
    circ.barrier()
    n=n-1
circ.measure([0,1], [0,1])
print("Circuit with",n_gates,"SWAP gates.\n",circ)</pre></li>
				<li>Run the circuit on the <code>qasm_simulator</code> and get the results:<pre># Select the QasmSimulator from the Aer provider
simulator = Aer.get_backend('qasm_simulator')
# Execute and get counts
result = execute(circ, simulator,     shots=simulator.configuration().max_shots).result()
counts = result.get_counts(circ)
print("Simulated SWAP counts:",counts)
display(plot_histogram(counts, title='Simulated counts     for '+str(n_gates)+' SWAP gates.'))</pre></li>
			</ol>
			<p>The result is displayed with a prompt to run the same circuit on an IBM Quantum® backend. Take a break here and read on.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor207"/>How it works...</h2>
			<p>When you run this quantum circuit<a id="_idIndexMarker524"/> on a simulator, it simulates<a id="_idIndexMarker525"/> perfectly and we get a perfect 100% result of the expected outcome:</p>
			<pre>Simulated SWAP counts: {'01': 10000}</pre>
			<p>If you follow along in the following circuit, you will see that we first use an X gate to set qubit <strong class="bold">q0</strong> to <img alt="" src="img/Formula_02_029.png"/>, and then we swap qubits <strong class="bold">q0</strong> and <strong class="bold">q1</strong> 10 times. What we expect to end up with is <strong class="bold">q0</strong> in <img alt="" src="img/Formula_07_003.png"/> and <strong class="bold">q1</strong> in <img alt="" src="img/Formula_07_004.png"/>, or, in two-qubit notation, <img alt="" src="img/Formula_07_005.png"/>:</p>
			<div><div><img alt="Figure 7.5 – A quantum circuit with 10 SWAP gates&#13;&#10;" src="img/Figure_7.5_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – A quantum circuit with 10 SWAP gates</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note the <em class="italic">barrier gates</em> here. These are to instruct the Qiskit® transpiler to not transpile across the barriers, and not simplify the circuit by just removing the consecutive SWAP gates as they negate each other. For a quick reminder, refer to the <em class="italic">Tossing a quantum coin</em> recipe in <a href="B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">IBM Quantum Experience® – Quantum Drag and Drop</em>.</p>
			<p>When running the program for 10 SWAP gates, you should get the following output:</p>
			<pre>Simulated SWAP counts: {'01': 100000}</pre>
			<p>This is seen numerically and in the following bar diagram:</p>
			<div><div><img alt="Figure 7.6 – The expected result after 10 SWAP gates on a perfect quantum computer: 01&#13;&#10;" src="img/Figure_7.6_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – The expected result after 10 SWAP gates on a perfect quantum computer: 01</p>
			<p>This means that the program ran perfectly and that we swapped the initial <img alt="" src="img/Formula_07_006.png"/> qubit back and forth 10 times to end up with the qubits back where they started, in <img alt="" src="img/Formula_07_007.png"/>. There were no errors.</p>
			<p>In a future <strong class="bold">universal error-correcting quantum computer</strong>, you will be able to run long quantum circuits like this with perfectly<a id="_idIndexMarker526"/> consistent error-corrected logical qubits throughout your calculations. By default, a Qiskit Aer simulator emulates an error-free universal quantum computer. </p>
			<p>However, when you run the <a id="_idIndexMarker527"/>same program on today's <strong class="bold">NISQ</strong> hardware, errors start to pile up as your quantum circuits grow in size and execution time. To check this out, you can now press <em class="italic">Enter</em> and run the circuit on an IBM <a id="_idIndexMarker528"/>Quantum® backend.</p>
			<p>We now import the least-busy backend with five qubits, and run the same circuit on it:</p>
			<pre># Import the least busy backend
from qiskit.providers.ibmq import least_busy
backend = least_busy(provider.backends(n_qubits=5,     operational=True, simulator=False))
print("Least busy backend:",backend)
# Execute and get counts
job = execute(circ, backend, shots=backend.configuration().    max_shots)
job_monitor(job)
nisq_result=job.result()
nisq_counts=nisq_result.get_counts(circ)
print("NISQ SWAP counts:",nisq_counts)
display(plot_histogram(nisq_counts, title='Counts for     '+str(n_gates)+' SWAP gates on '+str(backend)))</pre>
			<p>The preceding <a id="_idIndexMarker529"/>code might give the following result:</p>
			<pre>Least busy backend: ibmq_vigo
Job Status: job has successfully run
NISQ SWAP counts: {'00': 1002, '10': 585, '11': 592, '01': 6013}</pre>
			<p>This is seen numerically <a id="_idIndexMarker530"/>and in the bar diagram that follows:</p>
			<div><div><img alt="Figure 7.7 – After 10 SWAP gates, some errors have crept in; we get results other than the expected 01" src="img/Figure_7.7_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – After 10 SWAP gates, some errors have crept in; we get results other than the expected 01</p>
			<p>As you can see, the crystal-clear result of the QASM simulator turned a little murky when run on one <a id="_idIndexMarker531"/>of the IBM Quantum® machines. You will <a id="_idIndexMarker532"/>most likely still get a prominent peak for the correct result (01), but also a lot of wrong results.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor208"/>There's more...</h2>
			<p>You might think that 10 SWAP gates would be a fairly small example of a quantum circuit and that we shouldn't see errors like<a id="_idIndexMarker533"/> these in a circuit that size. What you have to keep in mind, though, is that the relatively simple logical circuit that you build will get transpiled into a circuit that can be run using just the basis gates that are available to the backend.</p>
			<p>Use the following <code>transpile</code> example to print the basis gates for the backend, and check the gate depth for the SWAP circuit before and after transpiling:</p>
			<pre># Comparing the circuit with the transpiled circuit
from qiskit.compiler import transpile
trans_swap = transpile(circ, backend)
print(trans_swap)
print("Basis gates:",backend.configuration().basis_gates)
print("SWAP circuit depth:",circ.depth(),"gates")
print("Transpiled SWAP circuit depth:",    trans_swap.depth(),"gates")</pre>
			<p>The preceding code should give the following result on an IBM Quantum® five-qubit machine such as <code>ibmq_vigo</code>:</p>
			<div><div><img alt="Figure 7.8 – What a transpiled 10 SWAP gate circuit looks like" src="img/Figure_7.8_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – What a transpiled 10 SWAP gate circuit looks like</p>
			<p>The previous code sample should give<a id="_idIndexMarker534"/> an output similar to the following:</p>
			<pre>Basis gates: ['u1', 'u2', 'u3', 'cx', 'id']
SWAP circuit depth: 12 gates
Transpiled SWAP circuit depth: 32 gates</pre>
			<p>When you run on a real quantum computer, noise and gate errors are introduced for each gate. As you can see in the previous figure, a single SWAP gate, when transpiled, might turn into three successive CX gates, and adding 10 of these in a row results in 30 CX gates. This makes for some<a id="_idIndexMarker535"/> potential big errors. Note that the number of transpiled gates depends on the selected backend and might be larger than the 30 in this example.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor209"/>See also</h2>
			<p><em class="italic">Quantum Computing in the NISQ era and beyond</em> by John Preskill from the Institute for Quantum Information and Matter and the Walter Burke Institute for Theoretical Physics, California Institute of Technology, Pasadena, CA, 91125, USA: <a href="https://quantum-journal.org/papers/q-2018-08-06-79/">https://quantum-journal.org/papers/q-2018-08-06-79/</a>.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor210"/>Adding noise profiles of IBM Quantum® backends to local simulators</h1>
			<p>In this recipe, we find the noise <a id="_idIndexMarker536"/>data for the IBM Quantum®<a id="_idIndexMarker537"/> backends to build a noise profile that we can then add to our simulator when we run it. This will make the simulator behave like a <em class="italic">real NISQ backend</em>.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor211"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r3_noise.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r3_noise.py</a>.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor212"/>How to do it...</h2>
			<p>Let's look at the following code:</p>
			<ol>
				<li value="1">Get a list of the available backends and select one to simulate.<p>We will get the noise profile of one of the IBM Quantum® backends and use it with our simulators. First, we <a id="_idIndexMarker538"/>use the <code>select_backend()</code> function to list the backends and<a id="_idIndexMarker539"/> make the selection:</p><pre>def select_backend():
    # Get all available and operational backends.
    available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits &gt; 1 and         b.status().operational)
    # Fish out criteria to compare
    print("{0:20} {1:&lt;10} {2:&lt;10}".format("Name",        "#Qubits","Pending jobs"))
    print("{0:20} {1:&lt;10} {2:&lt;10}".format("----",        "-------","------------"))        
    for n in range(0, len(available_backends)):
        backend = provider.get_backend(str(            available_backends[n]))
        print("{0:20} {1:&lt;10}".format(backend.name(),            backend.configuration().n_qubits),            backend.status().pending_jobs)
    select_backend=input("Select a backend (        'exit' to end): ")
    if select_backend!="exit":
        backend = provider.get_backend(select_backend)
    else:
        backend=select_backend
    return(backend)</pre><p>The preceding code might result in the following listing:</p><div><img alt="Figure 7.9 – List of available IBM Quantum® backends&#13;&#10;" src="img/Figure_7.9_B14436.jpg"/></div><p class="figure-caption">Figure 7.9 – List of available IBM Quantum® backends</p><p>As we will also run the quantum circuit on the backend, you should pick one with a reasonably short queue<a id="_idIndexMarker540"/> to avoid having to wait excessively for the results.</p></li>
				<li>Get the noise profile. The noise<a id="_idIndexMarker541"/> model can be extracted from the backend by using the <code>NoiseModel.from_backend(backend)</code> method:<pre>def build_noise_model(backend):
    # Construct the noise model from backend
    noise_model = NoiseModel.from_backend(backend)
    print(noise_model)
    return(noise_model)</pre><p>The noise model will look different depending on the backend that you selected. A sample model is shown here:</p><div><img alt="Figure 7.10 – Noise model for an IBM Quantum® backend&#13;&#10;" src="img/Figure_7.10_B14436.jpg"/></div><p class="figure-caption">Figure 7.10 – Noise model for an IBM Quantum® backend</p><p>We can now run the simulator with the noise model and other parameters to have the NISQ characteristics of the selected backend applied to the simulator calculations and make it behave like an actual physical backend and not a perfect simulator. </p></li>
				<li>Build a GHZ state circuit and run it on four different backends.<p>The <code>execute_circuit()</code> function to run on the backends with all the variations.</p><p>In Python, we start by getting the basis gates and a coupling map for the backend:</p><pre>def execute_circuit(backend, noise_model):
    # Basis gates for the noise model
    basis_gates = noise_model.basis_gates
    # Coupling map
    coupling_map = backend.configuration().coupling_map
    print("Coupling map: ",coupling_map)</pre><p>We then<a id="_idIndexMarker545"/> build a GHZ state quantum circuit, execute it<a id="_idIndexMarker546"/> on a simulator, and get the counts:</p><pre>    circ = QuantumCircuit(3, 3)
    circ.h(0)
    circ.cx(0, 1)
    circ.cx(0, 2)
    circ.measure([0,1,2], [0,1,2])
    print(circ)
    # Execute on QASM simulator and get counts
    counts = execute(circ, Aer.get_backend(        'qasm_simulator')).result().get_counts(circ)
    display(plot_histogram(counts, title='Ideal counts         for 3-qubit GHZ state on local qasm_simulator'))</pre><p>Then, we use the noise model and coupling map to execute a noisy simulation on both the local and the IBM Quantum® QASM simulator and get the counts:</p><pre>    counts_noise = execute(circ, Aer.get_backend(        'qasm_simulator'), noise_model=noise_model,         coupling_map=coupling_map,         basis_gates=basis_gates).result().get_        counts(circ)
    display(plot_histogram(counts_noise, title="Counts         for 3-qubit GHZ state with noise model on local         qasm simulator"))
    # Execute noisy simulation on the ibmq_qasm_simulator     # and get counts
    counts_noise_ibmq = execute(circ, provider.get_        backend('ibmq_qasm_simulator'),         noise_model=noise_model, coupling_map=coupling_        map, basis_gates=basis_gates).result().get_        counts(circ)
    display(plot_histogram(counts_noise_ibmq,         title="Counts for 3-qubit GHZ state with noise         model on IBMQ qasm simulator"))    </pre><p>Finally, we <a id="_idIndexMarker547"/>execute the job on the IBM Quantum®<a id="_idIndexMarker548"/> backend and get the counts:</p><pre>    job = execute(circ, backend)
    job_monitor(job)
    counts_ibmq=job.result().get_counts()  
    title="Counts for 3-qubit GHZ state on IBMQ backend "         + backend.name()
    display(plot_histogram(counts_ibmq, title=title))</pre><p>The final step is to display the collected results for all runs:</p><pre>    display(plot_histogram([counts, counts_noise,         counts_noise_ibmq, counts_ibmq], bar_labels=True,         legend=["Baseline","Noise on simulator",         "Noise on IBMQ simulator", "IBM Q backend"],         title="Comparison"))</pre></li>
			</ol>
			<p>As we walk through these four executions of the GHZ circuit, we will see how the initial perfect simulation, which provides an output of only <img alt="" src="img/Formula_07_008.png"/> or <img alt="" src="img/Formula_07_009.png"/> with ~50% chance, gets <em class="italic">contaminated</em> with errors; we get outputs in all possible states. </p>
			<p>In the final output, we <a id="_idIndexMarker549"/>compare all the executions with the final execution on the selected backend. What you might see <a id="_idIndexMarker550"/>when running the program would look something like the following set of screenshots:</p>
			<ol>
				<li value="1">First, we run on the simulator without noise and you get the following output:<div><img alt="Figure 7.11 – First, ideal run on the local simulator&#13;&#10;" src="img/Figure_7.11_B14436.jpg"/></div><p class="figure-caption">Figure 7.11 – First, ideal run on the local simulator</p></li>
				<li>Then, we add the noise model and run it again:<div><img alt="Figure 7.12 – Adding the noise model to the local simulator&#13;&#10;" src="img/Figure_7.12_B14436.jpg"/></div><p class="figure-caption">Figure 7.12 – Adding the noise model to the local simulator</p><p>As we can now see, we no longer get the nice, clean, and perfect quantum computer result but rather a result that is much closer to what you would get if you run the circuit on an actual IBM Quantum® backend. </p></li>
				<li>We test one <a id="_idIndexMarker551"/>more time by<a id="_idIndexMarker552"/> running with the noise model on the online IBM Quantum® QASM simulator:<div><img alt="Figure 7.13 – Adding the noise model to the IBM Quantum® simulator" src="img/Figure_7.13_B14436.jpg"/></div><p class="figure-caption">Figure 7.13 – Adding the noise model to the IBM Quantum® simulator</p></li>
				<li>Finally, we run the circuit one final time, now on the backend that we selected at the beginning:</li>
			</ol>
			<div><div><img alt="Figure 7.14 – Running the circuit on the IBM Quantum® backend&#13;&#10;" src="img/Figure_7.14_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14 – Running the circuit on the IBM Quantum® backend</p>
			<p>The result of this run<a id="_idIndexMarker553"/> should be similar to our <a id="_idIndexMarker554"/>simulated runs based on the noise model we derived from the actual IBM Quantum® backend.</p>
			<p>We can now merge all the results into a single diagram for comparison:</p>
			<div><div><img alt="Figure 7.15 – Output comparison between simulators and the IBM Quantum® backend&#13;&#10;" src="img/Figure_7.15_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15 – Output comparison between simulators and the IBM Quantum® backend</p>
			<p>In the final output, you can see that the simulators with the added noise model behave, at least statistically, like the IBM Quantum®<a id="_idIndexMarker555"/> backend on which they are modeled. As you can see, for the <strong class="bold">Baseline</strong> Aer simulation, we only get the expected <img alt="" src="img/Formula_07_008.png"/> and <img alt="" src="img/Formula_07_009.png"/> results for a GHZ state, but for all the other runs, we <a id="_idIndexMarker556"/>also get <em class="italic">noise</em> in the form of results such as <img alt="" src="img/Formula_07_059.png"/> and <img alt="" src="img/Formula_07_060.png"/>.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor213"/>See also</h2>
			<p><em class="italic">Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments</em>, arXiv, IBM Research et.al., September 11, 2018: <a href="https://arxiv.org/pdf/1809.03452.pdf">https://arxiv.org/pdf/1809.03452.pdf</a>.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor214"/>Understanding your circuits by using the unitary simulator</h1>
			<p>As it turns out, any valid quantum <a id="_idIndexMarker557"/>circuit that consists only of gates can be translated into a unitary matrix that describes the expected outcome for each possible state vector input. As you have seen in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>, each quantum gate is in itself a <strong class="bold">unitary matrix</strong>, and the<a id="_idIndexMarker558"/> combination of the unitaries that make up the complete quantum circuit can in itself be described as a <strong class="bold">unitary</strong>.</p>
			<p>Qiskit® lets you use the Qiskit Aer <code>unitary_simulator</code> simulator to return the unitary matrix that corresponds with your quantum circuit. You run the job just like you would for <code>qasm_simulator</code> jobs.</p>
			<p>When running <code>unitary_simulator</code>, you only run the circuit once. We can then use the <code>get_unitary(qc)</code> method on the returned results to see the unitary as a matrix for a circuit, such as this one-qubit superposition circuit using a Hadamard gate:</p>
			<div><div><img alt="Figure 7.16 – Quantum circuit with one Hadamard gate&#13;&#10;" src="img/Figure_7.16_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16 – Quantum circuit with one Hadamard gate</p>
			<p>The circuit corresponds to the following unitary:</p>
			<pre>[[ 0.707+0.j  0.707+0.j]
[ 0.707+0.j -0.707+0.j]]</pre>
			<p>In a cleaner printout, this would look as follows:</p>
			<div><div><img alt="" src="img/Formula_07_014.jpg"/>
				</div>
			</div>
			<p>You might recognize this as the <em class="italic">Hadamard gate</em> matrix, which is just what it is. Just like this, you can use the<a id="_idIndexMarker559"/> unitary simulator to return the unitary matrixes for any valid quantum circuit. That is what we will explore in this recipe.</p>
			<p>We will create a few simple quantum circuits and run them through a unitary simulator to get the unitary matrix. We then compare the Qiskit® unitary with the theoretical unitary for the gate combination that is represented by the circuit. </p>
			<p>Finally, we run the circuit on the <code>qasm</code> simulator and compare the result with a calculation of the input qubit state vectors, <strong class="bold">[1,0]</strong> (for one qubit) and <strong class="bold">[1,0,0,0]</strong> (for two qubits), which represent all qubits starting in the state <img alt="" src="img/Formula_07_0041.png"/>.</p>
			<p>The script includes a set of functions that we define to control the creation of circuits and other calculations that need to be done.</p>
			<p>For example, we use the <code>circuits()</code> function to create three basic quantum circuits and store them in a list for later use.</p>
			<p>In the script, we are also using two functions that we create ourselves to process the unitary information: <code>show_unitary()</code> and <code>calc_unitary()</code>.</p>
			<p>The input and function calls are controlled by the <code>main</code> loop at the end of the script.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor215"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r4_unitary.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r4_unitary.py</a>.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor216"/>How to do it…</h2>
			<ol>
				<li value="1">In your Python environment, run <code>ch7_r4_unitary.py</code>.</li>
				<li>When you <a id="_idIndexMarker560"/>first launch the script, you get an input menu:<div><img alt="Figure 7.17 – Input menu&#13;&#10;" src="img/Figure_7.17_B14436.jpg"/></div><p class="figure-caption">Figure 7.17 – Input menu</p><p>Enter a number to select the circuit to run with. Options <strong class="bold">1</strong>–<strong class="bold">3</strong> are predefined in the script, while option <strong class="bold">4</strong> lets you input QASM code from IBM Quantum Experience® to test, much like we did in the <em class="italic">Moving between worlds</em> recipe in <a href="B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">IBM Quantum Experience® – Quantum Drag and Drop</em>.</p><p class="callout-heading">Important: No measurement instructions</p><p class="callout">If you include measurement instructions with your quantum circuit, you must strip these out before you submit it as input. If the code includes measurement circuits, the simulator will crash with an Aer error.</p></li>
				<li>After you select the circuit to explore, the program creates the circuits we need, and return them as a list:<pre>def circuits():
    circuits=[]
    # Circuit 1 - one qubit in superposition
    circuit1 = QuantumCircuit(1,1)
    circuit1.h(0)
    # Circuit 2 - two qubits in superposition
    circuit2 = QuantumCircuit(2,2)
    circuit2.h([0,1])
    # Circuit 3 - two entangled qubits
    circuit3 = QuantumCircuit(2,2)
    circuit3.h([0])
    circuit3.cx(0,1)
    # Bundle the circuits in a list and return the list
    circuits=[circuit1,circuit2,circuit3]
    return(circuits)</pre></li>
				<li>We will now send the circuit that we selected to print the unitary.<p>In <code>show_unitary()</code>, we set the backend to <code>unitary_simulator</code> and run the circuit. The returned unitary is<a id="_idIndexMarker561"/> retrieved from the execution results and printed as a matrix:</p><pre># Calculate and display the unitary matrix 
def show_unitary(circuit):
    global unit
    backend = Aer.get_backend('unitary_simulator') 
    unit=execute(circuit, backend).result().        get_unitary(qc)
    print("Unitary matrix for the circuit:\n-------------        ------------------\n",unit)</pre></li>
				<li>Finally, the unitary is used to calculate the predicted outcome for the circuit and the circuit is run on <code>qasm_simulator</code> for comparison.<p>In the <code>calc_unitary()</code> function, we use the returned unitary as input together with the quantum circuit. We then create a state vector for the number of qubits specified by<a id="_idIndexMarker562"/> the circuit and use <code>qasm_simulator</code> to compare the calculated results with the simulated results:</p><pre>def calc_unitary(circuit,unitary):
    # Set number of shots
    shots=1000
    # Calculate possible number of outcomes, 2^n qubits
    binary=int(pow(2,circuit.width()/2))    
    # Set the binary key for correct binary conversion
    bin_key='0'+str(int(circuit.width()/2))+'b'        
    # Create a qubit vector based on all qubits in the     # ground state <img alt="" src="img/Formula_07_004.png"/> and a results list for all     # possible outcomes.
    vector=[1]
    outcomes=[format(0, bin_key)+":"]
    for q in range (1,binary):
        vector.append(0)
        outcomes.append(format(q, bin_key)+":")
    qubits=np.array(vector)    
    # Calculate the dot product of the unitary matrix and     # the qubits set by the qubits parameter.
    a_thru_d=np.dot(unitary,qubits)    
    # Print the probabilities (counts) of the calculated     # outcome.
    calc_counts={}
    for out in range (0,len(a_thru_d)):
        calc_counts[outcomes[out]]=(int(pow(abs(            a_thru_d[out]),2)*shots))
    print("\nCalculated counts:\n------------------\        n",calc_counts)    
    # Automate creation of measurement gates from number     # of qubits 
    # Run the circuit on the backend
    if circuit.width()==2:
        circuit.measure([0],[0])
    else: 
        circuit.measure([0,1],[0,1])
    backend_count = Aer.get_backend('qasm_simulator') 
    counts=execute(circuit, backend_count,shots=shots).        result().get_counts(qc)    
    # Print the counts of the measured outcome.
    print("\nExecuted counts:\n----------------\        n",counts,"\n") </pre><p>All in all, if we run<a id="_idIndexMarker564"/> the script with input <strong class="bold">1</strong>, for <em class="italic">one-qubit superposition</em>, we will get a result that is similar to the following:</p><div><img alt="Figure 7.18 – One-qubit superposition output" src="img/Figure_7.18_B14436.jpg"/></div><p class="figure-caption">Figure 7.18 – One-qubit superposition output</p></li>
				<li>For the one-qubit<a id="_idIndexMarker565"/> superposition, we will create a simple quantum circuit with just a Hadamard gate. The unitary for this circuit is as follows:<div><img alt="" src="img/Formula_07_017.jpg"/></div></li>
				<li>The calculated outcomes correspond nicely with the returned counts from running the circuit on the QASM simulator.</li>
				<li>Now, test options <strong class="bold">2</strong> and <strong class="bold">3</strong> to see what the unitaries look like for slightly more complicated circuits. When you feel that you have a good grasp of what is going on, take a look at the next recipe to import any circuit as a QASM string. </li>
			</ol>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor217"/>Running diagnostics with the state vector simulator</h1>
			<p>In this recipe, we will explore<a id="_idIndexMarker566"/> the state vector simulator and see how you can use it to run diagnostics on your circuits to see how your qubits are behaving. The<a id="_idIndexMarker567"/> state vector simulator is not a quantum computer simulator per se, but a tool that runs through your quantum circuit with one shot and returns the qubit state vector that results. As these are simulators, you can actually use them to do diagnostic tests of your circuits without disturbing them and breaking the quantum state. </p>
			<p>You will notice that we have used the state vector <a id="_idIndexMarker568"/>simulator before, when displaying the qubits as <strong class="bold">Bloch spheres</strong>, but we did not go into any great detail at that point. Using Bloch sphere visualization works <a id="_idIndexMarker569"/>well with single or multiple qubit visualization when each qubit has a definite simple state that can be projected on a Bloch sphere.</p>
			<p>There is a different output—actually, several—that we will touch on. Each of these lets you present the state of your<a id="_idIndexMarker570"/> qubits at a specific point in your circuit, before measuring.</p>
			<p>So, here's what we will work with. The state vector simulator returns a state vector, much like the following examples:</p>
			<ul>
				<li>For a qubit in superposition: <code>[0.707+0.j 0.707+0.j]</code></li>
				<li>For a Bell-state entangled qubit pair: <code>[0.707+0.j 0.   +0.j 0.   +0.j 0.707+0.j]</code></li>
			</ul>
			<p>Written out in standard matrix form, these correspond to the following:</p>
			<ul>
				<li>Qubit in superposition:</li>
			</ul>
			<p class="figure"><img alt="" src="img/Formula_07_018.png"/></p>
			<ul>
				<li>An entangled qubit pair:</li>
			</ul>
			<div><div><img alt="" src="img/Formula_07_019.jpg"/>
				</div>
			</div>
			<p>We can try displaying these using the <code>plot_bloch_multivector()</code> method. This visualization lets you observe how each individual qubit changes as the circuit progresses:</p>
			<div><div><img alt="Figure 7.19 – Single qubit in state &#13;&#10;" src="img/Figure_7.19_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.19 – Single qubit in state <img alt="" src="img/Formula_07_020.png"/></p>
			<p>This works fine as long as the qubits can be expressed individually. For entangled qubits, this visualization method no longer works:</p>
			<div><div><img alt="Figure 7.20 – Entangled qubit pair in state" src="img/Figure_7.20_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.20 – Entangled qubit pair in state <img alt="" src="img/Formula_07_021.png"/></p>
			<p>As you can see, Bloch spheres are not a good tool for entangled visualization, where the qubits cannot be <a id="_idIndexMarker571"/>described individually, but only<a id="_idIndexMarker572"/> as a combined entity. For more complex visualizations like these, we can use the <code>plot_state_qsphere()</code> method instead. The Q-sphere visualization is unique to Qiskit® and displays the quantum state as one or more vectors on a Q-sphere. </p>
			<p>The Q-sphere displays a circle (for single-qubit states) or a sphere (for multiple-qubit states), with one or more vectors that represent the state. The relative size of the vector and tip shows the probability of measuring the indicated state; for a one-qubit Q-sphere, the north pole represents the ground state, <img alt="" src="img/Formula_07_022.png"/>, and the south pole the excited state, <img alt="" src="img/Formula_07_0031.png"/>, and the color indicates the phase angle of the state:</p>
			<div><div><img alt="Figure 7.21 – Single qubit in state  with a 100% probability of measuring 0&#13;&#10;" src="img/Figure_7.21_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21 – Single qubit in state <img alt="" src="img/Formula_07_024.png"/> with a 100% probability of measuring 0</p>
			<p>For example, the one-qubit example indicates that the probability of measuring the state <img alt="" src="img/Formula_07_025.png"/> is 1 (vector pointing up), and<a id="_idIndexMarker573"/> the phase angle is 0. You can use<a id="_idIndexMarker574"/> the Q-sphere to visualize the entangled qubit pair that we could not visualize with the Bloch sphere:</p>
			<div><div><img alt="Figure 7.22 – Entangled qubit pair in state , with &#13;&#10;a 50% probability of measuring either 0 or 1&#13;&#10;" src="img/Figure_7.22_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22 – Entangled qubit pair in state <img alt="" src="img/Formula_07_026.png"/>, with a 50% probability of measuring either 0 or 1</p>
			<p>In the entangled qubit example, there are two possible outcomes with equal probability: <img alt="" src="img/Formula_07_027.png"/> (vector pointing up) and <img alt="" src="img/Formula_07_028.png"/> (vector pointing down), both with phase 0. </p>
			<p>Note that for the two-qubit example, you also see an equator for the sphere. The reason for the<a id="_idIndexMarker575"/> equator is the two additional possible <a id="_idIndexMarker576"/>outcomes: <img alt="" src="img/Formula_07_031.png"/> and <img alt="" src="img/Formula_07_030.png"/> for a two-qubit system. In this case, the results occupy two opposite nodes along the equator: <img alt="" src="img/Formula_07_031.png"/> on the left extreme and <img alt="" src="img/Formula_07_032.png"/> on the right:</p>
			<div><div><img alt="Figure 7.23 – Entangled qubit pair in state , with an &#13;&#10;equal 50% probability of measuring 01 and 10&#13;&#10;" src="img/Figure_7.23_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23 – Entangled qubit pair in state <img alt="" src="img/Formula_07_033.png"/>, with an equal 50% probability of measuring 01 and 10</p>
			<p>As we will see, if you add more qubits, the Q-sphere will come equipped with additional latitude lines like these, each<a id="_idIndexMarker577"/> representing states with equal <strong class="bold">Hamming</strong> values, or the number of qubits in state <img alt="" src="img/Formula_07_034.png"/>. For example, a three-qubit Q-sphere will have two latitude lines, each with three possible nodes.</p>
			<p>Three qubits in individual superposition are of two types: </p>
			<ul>
				<li>Three-qubit superposition state vector: <code>[0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j]</code></li>
				<li>Three-qubit superposition in standard matrix form:</li>
			</ul>
			<div><div><img alt="" src="img/Formula_07_035.jpg"/>
				</div>
			</div>
			<p>The following<a id="_idIndexMarker578"/> outcomes will be displayed on the<a id="_idIndexMarker579"/> Q-sphere:</p>
			<ul>
				<li><strong class="bold">North pole</strong>: <img alt="" src="img/Formula_07_036.png"/></li>
				<li><strong class="bold">First latitude line</strong>: <img alt="" src="img/Formula_07_037.png"/></li>
				<li><strong class="bold">Second latitude line</strong>: <img alt="" src="img/Formula_07_038.png"/></li>
				<li><strong class="bold">South pole</strong>: <img alt="" src="img/Formula_07_039.png"/>:</li>
			</ul>
			<div><div><img alt="Figure 7.24 – Example of a three-qubit Q-sphere with nodes for &#13;&#10;equal probability (  , or 12.5%) of all the outcomes&#13;&#10;" src="img/Figure_7.24_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.24 – Example of a three-qubit Q-sphere with nodes for equal probability ( <img alt="" src="img/Formula_07_040.png"/> , or 12.5%) of all the outcomes</p>
			<p>Alright, with that under <a id="_idIndexMarker580"/>our belt, let's dive straight in.</p>
			<p>Getting ready</p>
			<p>The sample code for<a id="_idIndexMarker581"/> this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r5_state_vector.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r5_state_vector.py</a>.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor218"/>How to do it...</h2>
			<p>For this recipe, we will set up a quantum circuit with either simple superpositions on all qubits, or with entanglement between all the qubits. As we build the circuit, we will do a state vector measurement after each gate, storing the results in a list. We will then print the returned state vectors and plot them on Bloch spheres and Q-spheres to illustrate how the qubit moves around as the circuit is executed:</p>
			<ol>
				<li value="1">Set the number of qubits.<p>In this first step, we set the number of qubits, and then select to build a superposition circuit or a circuit with entanglement by using <code>s</code> or <code>e</code> as input:</p><div><img alt="Figure 7.25 – Selecting the number of qubits and the type of circuit&#13;&#10;" src="img/Figure_7.25_B14436.jpg"/></div><pre>def s_vec(circuit):
    backend = Aer.get_backend('statevector_simulator') 
    print(circuit.num_qubits, "qubit quantum         circuit:\n------------------------")
    print(circuit)
    psi=execute(circuit, backend).result().        get_statevector(circuit)
    print("State vector for the",circuit.num_qubits,         "qubit circuit:\n\n",psi)
    print("\nState vector as Bloch sphere:")
    display(plot_bloch_multivector(psi))
    print("\nState vector as Q sphere:")
    display(plot_state_qsphere(psi))
    measure(circuit)
    input("Press enter to continue...\n")</pre></li>
				<li>The state vector simulator can be selected by using the following command:<pre>backend = Aer.get_backend('statevector_simulator')</pre></li>
				<li>With that simulator <a id="_idIndexMarker584"/>chosen, when you execute a <a id="_idIndexMarker585"/>quantum circuit, the simulator runs through the circuit one time, one shot, and returns the calculated state vector of your qubits. The outcome for a two-qubit circuit should look like this:<div><img alt="Figure 7.26 – Two-qubit circuit as Bloch spheres and a Q-sphere&#13;&#10;" src="img/Figure_7.26_B14436.jpg"/></div><pre>def measure(circuit):
    measure_circuit=QuantumCircuit(circuit.width())
    measure_circuit+=circuit
    measure_circuit.measure_all()
    #print(measure_circuit)
    backend_count = Aer.get_backend('qasm_simulator') 
    counts=execute(measure_circuit,         backend_count,shots=10000).result().        get_counts(measure_circuit)    
    # Print the counts of the measured outcome.
    print("\nOutcome:\n",{k: v / total for total in         (sum(counts.values()),) for k, v in         counts.items()},"\n")</pre><p>As you can see, with an empty<a id="_idIndexMarker588"/> two-qubit circuit, we expect the measurement result 00 with 100% certainty, which we can see from the state vector:</p><div><img alt="" src="img/Formula_07_044.jpg"/></div><p>You can also see both qubits pointing to <img alt="" src="img/Formula_07_045.png"/>, and the Q-sphere vector pointing to <img alt="" src="img/Formula_07_046.png"/>.</p></li>
				<li>Next, hit <strong class="bold">Return</strong> to add a first Hadamard<a id="_idIndexMarker589"/> gate to one of the qubits and run the display function again:<div><img alt="Figure 7.27 – Two qubits, with one in superposition, as Bloch spheres and a Q-sphere&#13;&#10;" src="img/Figure_7.27_B14436.jpg"/></div><p class="figure-caption">Figure 7.27 – Two qubits, with one in superposition, as Bloch spheres and a Q-sphere</p><p>Now we see the<a id="_idIndexMarker590"/> effect on the state vector <a id="_idIndexMarker591"/>when the second qubit is set in superposition with the Bloch vector pointing to the <img alt="" src="img/Formula_07_041.png"/> state. Looking at the Q-sphere, we now see two possible outcomes, each with equal probability: <img alt="" src="img/Formula_07_042.png"/> and <img alt="" src="img/Formula_07_043.png"/>. </p></li>
				<li>Finally, press <strong class="bold">Return</strong> again to add the second <a id="_idIndexMarker592"/>Hadamard, and display it<a id="_idIndexMarker593"/> again:<div><img alt="Figure 7.28 – Two qubits in superposition as Bloch spheres and a Q-sphere&#13;&#10;" src="img/Figure_7.28_B14436.jpg"/></div><p class="figure-caption">Figure 7.28 – Two qubits in superposition as Bloch spheres and a Q-sphere</p><p>We have now walked<a id="_idIndexMarker594"/> ourselves through our superposition step by step.</p><p>In the final step, you can see that the two-qubit Bloch vectors are both in the <img alt="" src="img/Formula_07_047.png"/> state for a <img alt="" src="img/Formula_07_048.png"/> superposition. The state vector is now as follows:</p><p>This is reflected in the final outcome, where the following states all have the same 25%, probability, as displayed by the Q-sphere: <img alt="" src="img/Formula_07_050.png"/>.</p></li>
				<li>You can now run the circuit again with two qubits, but select <strong class="bold">e</strong> for entanglement to see how the qubits behave step by step. </li>
				<li>Finally, try running the program with <code>sp</code> or <code>ep</code> as input, to include a phase angle to your superposition or entanglement circuit by adding a T-gate to the final qubit. As you will recall from <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>, this will introduce a <img alt="" src="img/Formula_07_051.png"/> phase to that qubit, which will be reflected in the Q-sphere output:</li>
			</ol>
			<div><div><img alt="Figure 7.29 – A  phase added to qubit 1&#13;&#10;" src="img/Figure_7.29_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.29 – A <img alt="" src="img/Formula_07_052.png"/> phase added to qubit 1</p>
			<p>Again, you can see the expected measurement results of <img alt="" src="img/Formula_07_053.png"/> with 25% certainty, with<a id="_idIndexMarker595"/> the added twist that <a id="_idIndexMarker596"/>the <img alt="" src="img/Formula_07_054.png"/> and <img alt="" src="img/Formula_07_055.png"/> states have the phase <img alt="" src="img/Formula_07_056.png"/>:</p>
			<div><div><img alt="Figure 7.30 – The  results now have a  phase&#13;&#10;" src="img/Figure_7.30_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.30 – The <img alt="" src="img/Formula_07_057.png"/> results now have a <img alt="" src="img/Formula_07_058.png"/> phase</p>
			<p>Note how there is no change to the counts output; adding a phase to a qubit does not change the probability of the<a id="_idIndexMarker597"/> outcomes. The phase, however, can be very useful for other, more complex quantum algorithms, as <a id="_idIndexMarker598"/>we will see in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor219"/>There's more...</h2>
			<p>At this point, you might have a feeling of déjà vu; you have seen this before, and you are right. Flip back to the <em class="italic">Building quantum scores with Circuit Composer</em> recipe in <a href="B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">IBM Quantum Experience® – Quantum Drag and Drop</em>, and take a look at the <strong class="bold">Inspect</strong> feature that we discussed there. What <a id="_idIndexMarker599"/>we have discussed in this recipe is the corresponding way to inspect your circuits in Qiskit®.</p>
			<p>This has been a whirlwind tour of the simulators that are included with Qiskit®. We have touched on the most basic examples of how to use them when coding your quantum programs but have just barely scratched the surface of all of the features that are available to you. Go explore, take them for a spin, and see how they can be used as tools when developing your real quantum algorithms.</p>
		</div>
	</body></html>