- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: iSAX – The Implementation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iSAX – 实现
- en: Before continuing with this chapter and starting to write code, make sure that
    you have a good understanding of the information covered in the previous chapter
    because this chapter is all about implementing iSAX in Python. As a general principle,
    if you cannot perform a task manually, you are not going to be able to perform
    it with the help of a computer – the same principle applies to constructing and
    using an iSAX index.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章并开始编写代码之前，请确保您已经很好地理解了上一章中涵盖的信息，因为本章全部关于在 Python 中实现 iSAX。作为一个一般原则，如果您不能手动执行一项任务，那么您将无法在计算机的帮助下执行该任务——同样的原则适用于构建和使用
    iSAX 索引。
- en: While reading this chapter, keep in mind that we are creating an iSAX index
    that *fits in memory* and does not use any external files to store the subsequences
    of each terminal node. The original iSAX paper suggested the use of external files
    to store the subsequences of each terminal node mainly because back then, RAM
    was limited compared to what is the case today, where we can easily have computers
    with many CPU cores and more than 64 GB of RAM. As a result, the use of RAM makes
    the entire process much faster than if we used disk files. However, if you do
    not have lots of RAM on your system and are working with large time series, you
    might end up using swap space, which slows down the process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，请记住，我们正在创建一个适合内存的 iSAX 索引，并且不使用任何外部文件来存储每个终端节点的子序列。原始的 iSAX 论文建议使用外部文件来存储每个终端节点的子序列，主要是因为当时与今天相比，RAM
    的限制更大，而今天我们可以轻松地拥有具有许多 CPU 核心和超过 64 GB RAM 的计算机。因此，使用 RAM 使得整个过程比使用磁盘文件要快得多。然而，如果您系统上的
    RAM 不多，并且正在处理大型时间序列，您可能会使用交换空间，这会减慢处理速度。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: A quick look at the `isax` Python package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速浏览 `isax` Python 包
- en: The class for storing subsequences
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储子序列的类
- en: The class for iSAX nodes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iSAX 节点的类
- en: The class for entire iSAX indexes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个 iSAX 索引的类
- en: Explaining the missing parts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释缺失的部分
- en: Exploring the remaining files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索剩余的文件
- en: Using the iSAX Python package
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 iSAX Python 包
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The GitHub repository with the code can be found at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for this
    chapter can be found in the `ch04` folder and the `ch04` subfolders.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的 GitHub 仓库可以在 [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing)
    找到。每个章节的代码都在其自己的目录中。因此，本章的代码可以在 `ch04` 文件夹及其子文件夹中找到。
- en: The first section takes a quick look at the Python package that we have developed
    for the purposes of this chapter, which strangely enough is called `isax`, before
    going into more detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分简要介绍了本章为特定目的开发的 Python 包，这个包奇怪地被命名为 `isax`，然后再详细介绍。
- en: What about bugs?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，错误怎么办？
- en: We have tried our best to give bug-free code. However, bugs might appear in
    any program, especially when a program is longer than 100 lines! That is why it
    is crucial to understand the principles behind the operation and construction
    of an iSAX index and the SAX representation to be able to understand that there
    might be a small or bigger issue with the code, or be able to port the existing
    implementation to a different programming language. I wrote the Python version
    of iSAX using a Java implementation from a colleague as my starting point.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尽力提供无错误的代码。然而，任何程序都可能出现错误，尤其是当程序长度超过 100 行时！这就是为什么理解 iSAX 索引的操作和构建原理以及 SAX
    表示至关重要，以便能够理解代码中可能存在的小或大问题，或者能够将现有实现移植到不同的编程语言。我使用同事提供的 Java 实现作为起点编写了 iSAX 的
    Python 版本。
- en: A quick look at the iSAX Python package
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速浏览 iSAX Python 包
- en: In this section, we will take a first look at the iSAX Python package to get
    a better idea of the supported functionality. Although we will begin with the
    code from the `sax` package we developed in [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053),
    we are going to rename that package `isax` and create additional source code,
    which is named `isax.py`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首次了解 iSAX Python 包，以更好地了解其支持的功能。虽然我们将从我们在 [*第2章*](B14769_02_MA.xhtml#_idTextAnchor053)
    中开发的 `sax` 包的代码开始，但我们打算将那个包重命名为 `isax` 并创建额外的源代码，该代码命名为 `isax.py`。
- en: 'The structure of the `isax` directory with the Python files is going to be
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`isax` 目录中 Python 文件的结构如下：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, in total, we have six files. You already know five of them from the `sax`
    package. The only new one is the `isax.py` source code file, which is the core
    file for this chapter. Additionally, we are going to add more global variables
    to the `variables.py` file and some functions to `tools.py`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总共有六个文件。您已经从 `sax` 包中知道了其中五个。唯一的新一个是 `isax.py` 源代码文件，这是本章的核心文件。此外，我们还将向 `variables.py`
    文件添加更多全局变量，并将一些函数添加到 `tools.py`。
- en: 'The list of methods found in the `isax.py` file, which excludes `__init__()`
    functions, is the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `isax.py` 文件中找到的方法列表（不包括 `__init__()` 函数）如下：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reason that we are talking about methods and not functions is that each
    function is attached to a Python class, which automatically makes it a method
    of that class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以谈论方法而不是函数，是因为每个函数都附加到一个 Python 类上，这使其自动成为该类的方法。
- en: 'Additionally, if we also include `__init__()` functions in the output, then
    we might get a good prediction of the number of classes found in that Python file.
    In that case, you might want to run `grep -w def -n1` `isax/isax.py` instead:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们还包括 `__init__()` 函数，那么我们可能会对 Python 文件中找到的类数量有一个很好的预测。在这种情况下，您可能想运行 `grep
    -w def -n1` `isax/isax.py`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, we have three classes, named `TS`, `Node`, and `iSAX`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有三个类，分别命名为 `TS`、`Node` 和 `iSAX`。
- en: The next sections are going to discuss the methods of `isax.py` in relation
    to the class that they belong to.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论 `isax.py` 的方法及其所属的类。
- en: The class for storing subsequences
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储子序列的类
- en: 'In this subsection, we are going to explain the Python class used for `TS`.
    The definition of the class is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将解释用于 `TS` 的 Python 类。类的定义如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When defining an object of that class, we need to provide the `ts` parameter,
    which is a subsequence stored as a NumPy array, and the number of segments using
    the `segments` parameter. After that, the `maxCard` field is automatically initialized
    with the SAX representation of that subsequence with the maximum cardinality.
    The `index` parameter is optional and keeps the place of the subsequence in the
    original time series. iSAX does not use the `index` parameter but it is good to
    have such a field.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 定义该类的对象时，我们需要提供 `ts` 参数，它是一个存储为 NumPy 数组的子序列，以及使用 `segments` 参数指定的段数。之后，`maxCard`
    字段将自动初始化为具有最大基数该子序列的 SAX 表示。`index` 参数是可选的，并保持子序列在原始时间序列中的位置。iSAX 不使用 `index`
    参数，但有一个这样的字段是好的。
- en: This class not have any methods attached to it, which is not the case with the
    `Node` class that is presented next.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此类没有附加任何方法，这与下一个将要介绍的 `Node` 类不同。
- en: The class for iSAX nodes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示 iSAX 节点的类
- en: 'In this subsection, we will explain the Python structure used for *keeping
    both inner and terminal nodes*. This is an important part of the package and its
    functionality:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将解释用于*保持内部和终端节点*的 Python 结构。这是该包的一个重要部分及其功能：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we are dealing with an inner node, then the `terminalNode` field is set to
    `False`. However, if the Boolean value of the `terminalNode` field is set to `True`,
    then we are dealing with a terminal node.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是内部节点，则 `terminalNode` 字段设置为 `False`。然而，如果 `terminalNode` 字段的布尔值设置为 `True`，则我们正在处理一个终端节点。
- en: The `word` field holds the SAX representation of the node. Lastly, the `left`
    and `right` fields are links to the two children of an inner node, whereas the
    `children` field is a list that holds the subsequences of a terminal node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`word` 字段包含节点的 SAX 表示。最后，`left` 和 `right` 字段是内部节点的两个子节点的链接，而 `children` 字段是一个包含终端节点子序列的列表。'
- en: 'The `Node` class has two methods:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node` 类有两个方法：'
- en: '`insert()`: This method is used for adding subsequences to a node'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert()`: 此方法用于向节点添加子序列'
- en: '`nTimeSeries()`: This method is used for counting the number of subsequences
    stored in a terminal node'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nTimeSeries()`: 此方法用于计算终端节点中存储的子序列数量'
- en: Next, let us talk about the class for representing entire iSAX indexes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈表示整个 iSAX 索引的类。
- en: The class for entire iSAX indexes
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整个 iSAX 索引的类
- en: 'This last class of the `isax` package is used to represent entire iSAX indexes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`isax` 包的最后一个类用于表示整个 iSAX 索引：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `children` field holds the children of the root node – in reality, the instances
    of the iSAX class are roots of iSAX indexes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`children` 字段包含根节点的子节点——实际上，iSAX 类的实例是 iSAX 索引的根节点。'
- en: The `ht` field, which is a dictionary, holds all the nodes of the iSAX index.
    Each key is a SAX representation of a node, which is *unique*, and each value
    is a `Node` instance. Lastly, the `length` field holds the number of subsequences
    stored in the iSAX index and is an optional field.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ht` 字段，它是一个字典，包含了 iSAX 索引中的所有节点。每个键是节点的 SAX 表示，它是*唯一的*，每个值是一个 `Node` 实例。最后，`length`
    字段包含了存储在 iSAX 索引中的子序列数量，这是一个可选字段。'
- en: The `iSAX` class has only one method, which is called `insert()` and is used
    to insert subsequences into the iSAX index.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`iSAX` 类只有一个方法，称为 `insert()`，用于将子序列插入到 iSAX 索引中。'
- en: Why are we using these three classes?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要使用这三个类？
- en: 'The implementation of the iSAX index contains three different entities: subsequences,
    nodes, and the iSAX index itself, which is represented by the root node of the
    index. iSAX contains nodes and nodes contain other nodes or subsequences. Each
    of these entities has its own class.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: iSAX 索引的实现包含三个不同的实体：子序列、节点以及 iSAX 索引本身，它由索引的根节点表示。iSAX 包含节点，而节点包含其他节点或子序列。这些实体中的每一个都有自己的类。
- en: So far, we know the details of the Python classes used in our package. The next
    section is about implementing the missing parts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了我们包中使用的 Python 类的详细信息。下一节将介绍实现缺失的部分。
- en: Explaining the missing parts
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释缺失的部分
- en: In this section, we are going to show the implementations of the class methods.
    We begin with the `insert()` function of the `iSAX` class, which should not be
    confused with the `insert()` function of the `Node` class. In Python and many
    other programming languages, classes are independent entities, which means they
    can have methods with the same name as long as they are unique inside the class
    namespace.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示类方法的实现。我们首先从 `iSAX` 类的 `insert()` 函数开始，这个函数不应与 `Node` 类的 `insert()`
    函数混淆。在 Python 以及许多其他编程语言中，类是独立的实体，这意味着只要在类命名空间内是唯一的，它们就可以有相同名称的方法。
- en: We are going to present the code of `Node.insert()` in eight parts. The method
    accepts two parameters – apart from `self`, which denotes the current `Node` object
    – which are the subsequences we are trying to insert and the iSAX index that the
    `Node` instance belongs to.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分八部分展示 `Node.insert()` 的代码。该方法接受两个参数——除了 `self`，表示当前的 `Node` 对象之外——这两个参数是我们试图插入的子序列以及
    `Node` 实例所属的 iSAX 索引。
- en: Why do we need an iSAX instance as a parameter? We need that in order to be
    able to add new nodes to the iSAX index by accessing `iSAX.ht`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要一个 iSAX 实例作为参数？我们需要它以便能够通过访问 `iSAX.ht` 来向 iSAX 索引添加新节点。
- en: 'The first part of `insert()` is the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 的第一部分如下：'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing that `insert()` does is check whether we are working with a
    terminal node or not. This happens because if we are dealing with a terminal node,
    we are going to try to store the given subsequence in the terminal node without
    any other delay. The second check is whether the terminal node is full or not.
    If it is full, then *we have a split*. First, we duplicate the current node with
    the `temp = Node(self.word)` statement and the current terminal node becomes an
    inner node by changing the value of `terminalNode` to `False`. At this point,
    we have to create two new empty nodes, which are going to become the two children
    of the current node – the former takes place in the code excerpt that follows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 的第一件事是检查我们是否正在处理一个终端节点。这是因为如果我们正在处理终端节点，我们将尝试将给定的子序列存储在终端节点中，而不会有任何延迟。第二个检查是终端节点是否已满。如果已满，那么*我们将进行分裂*。首先，我们使用
    `temp = Node(self.word)` 语句复制当前节点，并将当前终端节点通过将 `terminalNode` 的值更改为 `False` 变成内部节点。在此阶段，我们必须创建两个新的空节点，它们将成为当前节点的两个子节点——前者将在接下来的代码摘录中实现。'
- en: 'The second part of `insert()` is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 函数的第二部分如下：'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous code, we create two new terminal nodes, which are going to be
    the children of the node that is going to be split. Both of these new nodes currently
    have the same SAX representation as the node that is going to be split and become
    an inner node. The change to their SAX representations, which signifies the split,
    is going to take place in the code that follows.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了两个新的终端节点，这两个节点将成为即将分裂的节点的子节点。这两个新节点目前具有与即将分裂的节点相同的 SAX 表示，并成为内部节点。它们
    SAX 表示的改变，即分裂的标志，将在接下来的代码中实现。
- en: 'The third part contains the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下代码：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the beginning of the code excerpt, we deal with the promotion strategy, which
    is implemented in the `tools.py` file, which is explained in *The tools.py file*
    section and has to do with defining the SAX word (segment) that is going to be
    promoted.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码摘录的开头，我们处理提升策略，该策略在`tools.py`文件中实现，这在*The tools.py file*部分有解释，并且与定义将要提升的SAX词（段）有关。
- en: After that, the code creates the two SAX representations of a split using two
    string operations – this is the main reason that we store SAX words as strings
    and that we are using a list to hold an entire SAX presentation. After that, we
    convert the SAX representations into strings stored in `new1.word` and `new2.word`
    and then put the respective nodes into the iSAX index using `ISAX.ht[new1.word]
    = new1` and `ISAX.ht[new2.word] = new2`. The keys for finding these two nodes
    in the `iSAX.ht` Python dictionary are their own SAX representations. The last
    two statements of the code associate the two new terminal nodes with the inner
    node by defining the `left` and `right` fields of the inner node and, therefore,
    signifying its two children.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，代码通过两个字符串操作创建了分割的两个SAX表示——这是我们将SAX词（段）存储为字符串以及我们使用列表来保存整个SAX表示的主要原因。之后，我们将SAX表示转换为存储在`new1.word`和`new2.word`中的字符串，然后使用`ISAX.ht[new1.word]
    = new1`和`ISAX.ht[new2.word] = new2`将这些相应的节点放入iSAX索引中。在`iSAX.ht` Python字典中找到这两个节点的键是它们的SAX表示。代码的最后两条语句通过定义内部节点的`left`和`right`字段将两个新的终端节点与内部节点关联起来，从而表示其两个子节点。
- en: 'The fourth code part of the `Node.insert()` method is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.insert()`方法的第四部分代码如下：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We know for sure that after we split the subsequences, which were previously
    stored in the terminal node that has become an inner node, we are not going to
    have an overflow. However, we still need to call `self.insert(ts, ISAX)` to insert
    the subsequence that created the overflow previously and see what is going to
    happen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以肯定的是，在将之前存储在成为内部节点的终端节点中的子序列分割后，我们不会出现溢出。然而，我们仍然需要调用`self.insert(ts, ISAX)`来插入之前造成溢出的子序列，并查看会发生什么。
- en: The last `if` checks whether we are using the default promotion strategy, which
    is the Round Robin strategy, and in that case, it changes the promotion segment
    to the next in order.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`if`检查我们是否使用默认的提升策略，即轮询策略，如果是这样，它将提升段切换到下一个。
- en: But how do we know whether there is an overflow situation? If after promoting
    a subsequence to a higher cardinality than its current one (`tempCard`) that subsequence
    cannot be assigned to any of the two newly created terminal nodes (`new1.word`
    or `new2.word`), we know that it has not been promoted. Therefore, we have an
    overflow condition. This is implemented in the `else:` branch of the `if tempCard
    ==` `new1.word:` block.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道是否存在溢出情况？如果将子序列提升到比其当前基数（`tempCard`）更高的基数，而这个子序列不能分配给两个新创建的终端节点（`new1.word`或`new2.word`）中的任何一个，那么我们知道它没有被提升。因此，我们有一个溢出条件。这体现在`if
    tempCard == new1.word:`块的`else:`分支中。
- en: 'The fifth part of `Node.insert()` is next:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.insert()`的第五部分如下：'
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code of the previous `else` is executed when we are dealing with a terminal
    node that is not full. So, we store the given subsequence in the `children` list
    – this is the ideal way to add a new subsequence to an iSAX index.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理一个非满的终端节点时，会执行之前的`else`代码。因此，我们将给定的子序列存储在`children`列表中——这是向iSAX索引添加新子序列的理想方式。
- en: 'The sixth part of the `insert()` function is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`函数的第六部分代码如下：'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we are working with an inner node, we have to decide whether the subsequence
    is going to go to the left or right child according to its SAX representation
    in order to finally find the terminal node that is going to store that subsequence.
    This is where the process begins.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理一个内部节点，我们必须根据子序列的SAX表示来决定它将进入左子节点还是右子节点，以便最终找到将存储该子序列的终端节点。这就是过程的开始。
- en: 'The seventh part contains the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第七部分包含以下代码：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous code, we change (decrease) the maximum cardinality of the subsequence
    to fit the cardinality of the left node – we could have used the right node as
    both nodes use the same cardinality. The `tempCard` variable that holds that new
    cardinality is going to be used to decide the path that the subsequence is going
    to follow in the tree until it finds the appropriate terminal node.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们改变（减少）子序列的最大基数以适应左节点的基数——我们本可以使用右节点，因为两个节点使用相同的基数。持有新基数的`tempCard`变量将被用来决定子序列在树中要遵循的路径，直到找到适当的终端节点。
- en: 'The last part of `Node.insert()` is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node.insert()`的最后一部分如下：'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If `tempCard` does not match the SAX representation of the left or right node,
    then we know that *it has not been promoted*, which means that we have an overflow
    condition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`tempCard`与左节点或右节点的SAX表示不匹配，那么我们知道*它没有被提升*，这意味着我们有一个溢出条件。
- en: This is the logic behind the implementation of `Node.insert()` – there exist
    many comments in the code that you can read, and you can add your own `print()`
    statements to understand the flow even better.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Node.insert()`实现背后的逻辑——代码中存在许多你可以阅读的注释，并且你可以添加自己的`print()`语句以更好地理解流程。
- en: Why are we storing the maximum cardinality in its subsequence?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要在子序列中存储最大基数？
- en: The reason for storing the maximum cardinality of this subsequence is that we
    can easily decrease that maximum cardinality without having to make difficult
    calculations such as computing a new SAX representation from scratch. This small
    optimization makes splitting operations much faster.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 存储这个子序列最大基数的原因是我们可以轻松地降低这个最大基数，而无需进行诸如从头开始计算新的SAX表示等困难的计算。这种小的优化使得分割操作变得更快。
- en: 'The other method of the `Node` class is called `nTimeSeries()` and has the
    following implementation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`类的另一个方法称为`nTimeSeries()`，其实现如下：'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The presented function returns the number of subsequences stored in a terminal
    node. First, `nTimeSeries()` makes sure that we are dealing with a terminal node
    before iterating over the contents of the `children` list. If the data type of
    the stored value is `TS`, then we have a subsequence.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的函数返回存储在终端节点中的子序列数量。首先，`nTimeSeries()`确保我们在遍历`children`列表的内容之前正在处理一个终端节点。如果存储值的类型是`TS`，那么我们有一个子序列。
- en: After that, we are going to discuss and explain the `insert()` method of the
    `iSAX` class, which is presented in three parts. The `iSAX.insert()` method is
    the method that is being called when we want to add a subsequence to an iSAX index.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将讨论并解释`iSAX`类的`insert()`方法，该方法分为三个部分。当我们要向iSAX索引添加子序列时，会调用`iSAX.insert()`方法。
- en: 'The first part of `iSAX.insert()` is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`iSAX.insert()`的第一个部分如下：'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This first part of the code finds the child of the root where the given subsequence
    is going to be placed. The `lower_cardinality_str` value is used as the key for
    finding the relevant child of the root node – the `tools.lowerCardinality()` function
    is explained in a bit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这一部分找到根节点中将要放置给定子序列的子节点。`lower_cardinality_str`值用作查找根节点相关子节点的键——`tools.lowerCardinality()`函数将在稍后解释。
- en: 'The second part of `iSAX.insert()` contains the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`iSAX.insert()`的第二部分包含以下代码：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the child of the root with the `lower_cardinality_str` SAX representation
    cannot be found, we create the respective root child and add it to the `self.children`
    hash table (dictionary) and call `insert()` to put the given subsequence there.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果具有`lower_cardinality_str` SAX表示的根节点的子节点找不到，我们创建相应的根子节点并将其添加到`self.children`哈希表（字典）中，并调用`insert()`将给定的子序列放在那里。
- en: 'The last part of `iSAX.insert()` is the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`iSAX.insert()`的最后一部分如下：'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the child of the root with the `lower_cardinality_str` SAX representation
    exists, then we try to insert that subsequence, thereby calling `insert()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果具有`lower_cardinality_str` SAX表示的根节点的子节点存在，那么我们尝试插入该子序列，从而调用`insert()`。
- en: At this point, we go from the `iSAX` class level to the `Node` class level.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们从`iSAX`类级别转到`Node`类级别。
- en: But `isax.py` is not the only file with new code. The next section shows the
    additions and changes to the remaining package files that complete the implementation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但`isax.py`并不是唯一包含新代码的文件。下一节将展示对剩余包文件的添加和更改，以完成实现。
- en: Exploring the remaining files
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索剩余的文件
- en: Apart from the `isax.py` file, the `isax` Python package is constructed of more
    source code files, mainly because it is based on the `sax` package. We will begin
    with the `tools.py` file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `isax.py` 文件外，`isax` Python 包由更多的源代码文件组成，主要是因为它基于 `sax` 包。我们将从 `tools.py`
    文件开始。
- en: The tools.py file
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`tools.py` 文件'
- en: 'There are some additions to the `tools.py` source code file compared to the
    version we first saw in [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053)*, which*
    mainly have to do with the promotion strategy. As said before, we support two
    promotion strategies: Round Robin and from left to right.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们最初在 [*第 2 章*](B14769_02_MA.xhtml#_idTextAnchor053) 中看到的 `tools.py` 源代码文件相比，有一些新增内容，这主要与提升策略有关。如前所述，我们支持两种提升策略：轮询和从左到右。
- en: 'The Round Robin strategy is implemented here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询策略在这里实现：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the Round Robin case, we try to find the first segment on the right of the
    segment that was used in the previous promotion with fewer digits than the digits
    specified by the maximum cardinality (a segment that is not full). If the previous
    promotion took place in the last segment, then we go back to the first segment
    and begin from scratch. In order to compute the number of binary digits of the
    maximum cardinality (the length of the SAX word), we use the `power_of_two()`
    function, which returns `3` for a cardinality of `8`, `4` for a cardinality of
    `16`, and so on. If we iterate over all the segments of the given SAX representation
    (`nSegs`) and all have the maximum length, we know that we have an overflow condition.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在轮询情况下，我们试图找到比指定最大基数（一个不满的段）的数字更少的右侧段。如果前一次提升发生在最后一个段，那么我们就回到第一个段并从头开始。为了计算最大基数（SAX
    单词的长度）的二进制位数，我们使用 `power_of_two()` 函数，该函数对于基数 `8` 返回 `3`，对于基数 `16` 返回 `4`，依此类推。如果我们遍历给定
    SAX 表示的所有段（`nSegs`）并且所有段都具有最大长度，我们知道存在溢出条件。
- en: 'The left-to-right strategy, which is also called **shorter first**, is implemented
    here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为 **最短优先** 的从左到右策略在这里实现：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The left-to-right promotion strategy iterates over all the segments of the given
    SAX representation variable (`nSegs`) starting from the left and going to the
    right and finds the leftmost one with the minimum length. As a result, if both
    the second and third segments have the same minimum length, the strategy is going
    to select the second one because it is the leftmost available. After that, it
    sets `variables.promote` to the selected segment value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右的提升策略遍历给定 SAX 表示变量（`nSegs`）的所有段，从左到右，并找到最左边的最小长度段。因此，如果第二和第三段具有相同的最小长度，该策略将选择第二个，因为它是最左边的可用段。之后，它将
    `variables.promote` 设置为所选段值。
- en: Next, we are going to talk about two additional functions that reside in `tools.py`,
    which are called `promote()` and `lowerCardinality()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 `tools.py` 中驻留的两个附加函数，它们被称为 `promote()` 和 `lowerCardinality()`。
- en: 'The `promote()` function is implemented as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`promote()` 函数的实现如下：'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `promote()` function copies the length of the digits of the segments of
    an existing SAX representation (`node`) to a given subsequence (`s`) in order
    for both to have the same cardinalities in all their SAX words. This *allows us
    to compare* these two SAX representations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`promote()` 函数将现有 SAX 表示（`node`）的段的数字长度复制到给定的子序列（`s`）中，以便它们在所有 SAX 单词中都具有相同的基数。这
    *允许我们比较* 这两个 SAX 表示。'
- en: 'The implementation of `lowerCardinality()` is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`lowerCardinality()` 的实现如下：'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `lowerCardinality()` function lowers the cardinalities of a node *in all
    of its SAX words* (segments). This is mainly needed by `iSAX.insert()` to put
    a subsequence into the appropriate child of the root. After we put a subsequence
    into the appropriate child of the root, we promote a single segment of the SAX
    representation of the subsequence at a time to find out its place in the iSAX
    index. Remember that the keys to all iSAX nodes are SAX representations that usually
    have different cardinalities in their segments.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`lowerCardinality()` 函数降低了一个节点在其所有 SAX 单词（段）中的基数。这主要是由 `iSAX.insert()` 函数需要的，以便将子序列放入根的适当子节点中。在我们将子序列放入根的适当子节点之后，我们一次提升子序列
    SAX 表示的单个段，以找出它在 iSAX 索引中的位置。记住，所有 iSAX 节点的键都是 SAX 表示，通常它们的段有不同的基数。'
- en: How to test individual functions
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如何测试单个函数
- en: Personally, I prefer to create small command line utilities to test complex
    functions on their own, understand their operation, and maybe discover bugs!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我更喜欢创建小的命令行实用工具来测试复杂的函数，理解其操作，并可能发现错误！
- en: Let us make two small command-line utilities to showcase the use of `promote()`
    and `lowerCardinality()` in more detail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个小的命令行实用工具来更详细地展示`promote()`和`lowerCardinality()`的使用。
- en: 'First, we demonstrate the `promote()` function in the `usePromote.py` utility,
    which contains the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`usePromote.py`实用工具中演示了`promote()`函数，该实用工具包含以下代码：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to remember that the `promote()` function mimics the lengths
    of the segments of an existing SAX representation by decreasing the maximum SAX
    representation of a subsequence (`s`) to match the given SAX representation stored
    in the `node` parameter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，`promote()`函数通过将子序列的最大SAX表示（`s`）降低以匹配存储在`node`参数中的给定SAX表示，来模拟现有SAX表示的段长度。
- en: 'The rest of `usePromote.py` is the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`usePromote.py`的其余部分如下：'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Everything is hardcoded in `usePromote.py` because we just want to know more
    about the use of `promote()` and nothing else. However, as `promote()` has many
    dependencies in the `isax` package, we must put its entire implementation in our
    script and make the necessary changes to the Python code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`usePromote.py`文件中，所有内容都是硬编码的，因为我们只想更多地了解`promote()`函数的使用，而不想了解其他内容。然而，由于`promote()`函数在`isax`包中有许多依赖项，我们必须将其整个实现放入我们的脚本中，并对Python代码进行必要的修改。
- en: Given a subsequence, `ts`, and a `TS` class instance, `t`, we can calculate
    the SAX representation of `ts` using the maximum cardinality and then decrease
    it to match the cardinalities of other SAX words.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个子序列`ts`和一个`TS`类实例`t`，我们可以使用最大基数来计算`ts`的SAX表示，然后将其降低以匹配其他SAX词的基数。
- en: 'Running `usePromote.py` generates the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`usePromote.py`生成以下输出：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output shows that the maximum cardinality (`000_010_101_111`) of the given
    subsequence has been decreased to match the cardinalities of four other SAX words.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，给定子序列的最大基数（`000_010_101_111`）已被降低以匹配四个其他SAX词的基数。
- en: 'After that, we demonstrate the `lowerCardinality()` function in the `useLCard.py`
    utility, which comes with the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在`useLCard.py`实用工具中演示了`lowerCardinality()`函数，该实用工具包含以下代码：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time, we do not put the implementation of `lowerCardinality()` in our code
    because it has fewer dependencies and can be used directly from the `tools.py`
    file. The parameter that we pass to `lowerCardinality()` is *the number of digits*
    that we want to get in each SAX word. So, `1` means one digit, which means a cardinality
    of 2 1, and `3` means three digits, which computes to a cardinality of 2 3.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们没有在我们的代码中放置`lowerCardinality()`的实现，因为它有较少的依赖项，可以直接从`tools.py`文件中使用。我们传递给`lowerCardinality()`的参数是*我们想要在每一个SAX词中得到的数字位数*。所以，`1`表示一位数字，这意味着基数是2^1，而`3`表示三位数字，计算出的基数是2^3。
- en: 'Once again, everything is hardcoded in `useLCard.py` because we just want to
    know more about the use of `lowerCardinality()` and nothing more. Running `useLCard.py`
    produces the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在`useLCard.py`中，所有内容都是硬编码的，因为我们只想更多地了解`lowerCardinality()`函数的使用，而不想了解其他内容。运行`useLCard.py`生成以下输出：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, given a subsequence with a SAX representation of `000_010_101_111`, we calculate
    its SAX representations for the cardinalities of `2`, `4`, and `8`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定一个SAX表示为`000_010_101_111`的子序列，我们计算其基数分别为`2`、`4`和`8`的SAX表示。
- en: Next, we are going to show the changes to `variables.py`, which is the file
    that holds global variables that can be accessed by all the files of the package
    or the utilities that use the `isax` package.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示对`variables.py`文件的修改，该文件包含全局变量，这些变量可以被包中的所有文件或使用`isax`包的实用工具访问。
- en: The variables.py file
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`variables.py`文件'
- en: This subsection presents the contents of the updated `variables.py` file, which
    contains variables that are accessible from anywhere in the code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节展示了更新后的`variables.py`文件的内容，其中包含在代码的任何地方都可以访问的变量。
- en: How much functionality is enough?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多少功能才算足够？
- en: Keep in mind that sometimes we might need to include functionality that is going
    to help with debugging or might be needed in the future, and therefore, we might
    need to include variables or implement functions that are not going to be used
    right away or all the time. Just remember to keep a good balance between wanting
    to support everything and please everyone, which is impossible, and wanting to
    support the absolute minimum functionality, which usually lacks flexibility.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有时我们可能需要包含有助于调试或未来可能需要的功能，因此，我们可能需要包含不会立即或总是使用的变量或实现函数。只需记住，在想要支持一切和取悦每个人（这是不可能的）以及想要支持绝对最小功能（这通常缺乏灵活性）之间保持良好的平衡。
- en: 'The contents of the `variables.py` file are the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables.py` 文件的内容如下：'
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `variables.promote` variable defines the SAX word that is going to be promoted
    next if there is such a need. Put simply, we create the SAX representation of
    the two nodes of a split based on the value of `variables.promote` – we promote
    the segment defined by the value of `variables.promote`. Every time we have a
    split, `variables.promote` is updated according to the promotion (splitting) strategy
    and gets ready for the next split.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables.promote`变量定义了如果需要，将要提升的SAX词。简单来说，我们根据`variables.promote`的值创建一个分割的两个节点的SAX表示——我们提升由`variables.promote`值定义的段。每次我们有一个分割时，`variables.promote`都会根据提升（分割）策略更新，并准备好下一次分割。'
- en: 'Should you wish to see the changes between two versions of the same file, you
    can use the `diff(1)` utility. In our case, the difference between the `variables.py`
    file found in the `ch03` directory and the current version is the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望查看同一文件两个版本之间的更改，可以使用`diff(1)`实用程序。在我们的情况下，`ch03`目录中找到的`variables.py`文件与当前版本之间的差异如下：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Lines beginning with `>` show the contents of `ch04/isax/variables.py`, whereas
    lines beginning with `<` show statements from `ch03/sax/variables.py`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以`>`开头的行显示了`ch04/isax/variables.py`文件的内容，而以`<`开头的行显示了`ch03/sax/variables.py`文件中的语句。
- en: The next subsection discusses `sax.py`, which did not change that much.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将讨论`sax.py`，它并没有发生太多变化。
- en: The sax.py file
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sax.py` 文件'
- en: 'The `sax.py` file does have any practical changes. However, we should make
    changes to its `import` statements as it is no longer an autonomous package but
    a part of another package with a different name. Therefore, we need to change
    the following two statements:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`sax.py` 文件并没有任何实际上的改动。然而，我们应该修改它的`import`语句，因为它不再是一个独立的包，而是另一个不同名称的包的一部分。因此，我们需要修改以下两个语句：'
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We replace them with these statements:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下这些语句来替换它们：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Apart from that, there is no need for additional changes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，不需要进行额外的更改。
- en: Now that we know the source code of the `isax` package, it is time to see that
    code in action.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了`isax`包的源代码，是时候看看这个代码的实际应用了。
- en: Using the iSAX Python package
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用iSAX Python包
- en: In this section, we are going to use the `isax` Python package to develop practical
    command-line utilities. But first, we are going to learn how to read the iSAX
    parameters from the users.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`isax` Python包来开发实用的命令行工具。但首先，我们将学习如何从用户那里读取iSAX参数。
- en: Reading the iSAX parameters
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取iSAX参数
- en: This subsection illustrates how to read the iSAX parameters, including the filenames
    with the time series, and how to give default values to some of them. Although
    we saw relevant code in [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053), this
    time, the process is explained in more detail. Additionally, the code is also
    going to show how we use these input parameters to set up the relevant variables
    located inside the `./isax/variables.py` file. As a reminder, variables stored
    in `./isax/variables.py`, or other similar files – it just happens that we are
    using `./isax/variables.py` – are accessible from anywhere in our code as long
    as we have successfully imported the relevant file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节说明了如何读取iSAX参数，包括时间序列的文件名，以及如何为其中的一些参数设置默认值。尽管我们在[*第2章*](B14769_02_MA.xhtml#_idTextAnchor053)中看到了相关的代码，但这次我们将更详细地解释这个过程。此外，代码还将展示我们如何使用这些输入参数来设置位于`./isax/variables.py`文件内的相关变量。提醒一下，存储在`./isax/variables.py`或类似文件中的变量——碰巧我们使用的是`./isax/variables.py`——只要我们成功导入了相关文件，就可以在我们的代码的任何地方访问。
- en: What we need to create an iSAX index
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个iSAX索引
- en: As a reminder, to create an iSAX index, we need a time series and a threshold
    value, which is the maximum number of subsequences that a terminal node can hold,
    as well as a segment value and a cardinality value. Last, we need a sliding window
    size.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，要创建一个 iSAX 索引，我们需要一个时间序列和一个阈值值，这是终端节点可以持有的最大子序列数，以及一个段值和一个基数值。最后，我们还需要一个滑动窗口大小。
- en: As a rule of thumb, when working with global variables, it is better to use
    long and descriptive names. Additionally, it is also a good practice to give default
    values to global parameters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，当处理全局变量时，最好使用长且描述性的名称。此外，为全局参数提供默认值也是一个好的实践。
- en: 'The Python code of `parameters.py` is shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了 `parameters.py` 的 Python 代码：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All the work is done by the `argparse` package and the `parser.add_argument()`
    statements that are used for defining command-line parameters and options. The
    `dest` parameter defines the name of the parameter – this name is going to be
    used later to read the value of the parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作都是由 `argparse` 包和用于定义命令行参数和选项的 `parser.add_argument()` 语句完成的。`dest` 参数定义了参数的名称——这个名称将在以后用于读取参数的值。
- en: One of the other parameters of `parser.add_argument()` is called `type` and
    allows us to define the data type of the parameter. This can save you from lots
    of issues and code for converting strings into actual values, so use `type` when
    possible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`parser.add_argument()` 的另一个参数被称为 `type`，它允许我们定义参数的数据类型。这可以避免许多问题，并减少将字符串转换为实际值所需的代码，因此尽可能使用
    `type`。'
- en: After that, we call `parser.parse_args()` and we are ready to read any `rgparse`
    parameter we want.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用 `parser.parse_args()`，然后我们就可以读取任何想要的 `rgparse` 参数。
- en: 'Running `parameters.py` produces the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `parameters.py` 会生成以下输出：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In case of an error, `parameters.py` generates the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，`parameters.py` 会生成以下输出：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, the error is that the `cardinality` parameter is a string, whereas
    we are expecting an integer. The error output is very informative.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，错误是 `cardinality` 参数是一个字符串，而我们是期望一个整数值。错误输出非常具有信息性。
- en: 'If a required parameter is missing, `parameters.py` generates the following
    output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少必要的参数，`parameters.py` 会生成以下输出：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The next section shows how we process the subsequences of a time series in order
    to create an iSAX index.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分展示了我们如何处理时间序列的子序列以创建一个 iSAX 索引。
- en: How to process subsequences to create an iSAX index
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何处理子序列以创建 iSAX 索引
- en: This is a really important subsection because here, we explain the Python structure
    that is used to store the data for each subsequence of an iSAX index.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的子部分，因为在这里，我们解释了用于存储 iSAX 索引每个子序列数据的 Python 结构。
- en: The code does not lie!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码不会说谎！
- en: If you have doubts about the fields and the data stored in each subsequence,
    check out the Python code to learn more. The documentation might lie but the code
    never does.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对每个子序列的字段和数据存储有疑问，请查看 Python 代码以了解更多信息。文档可能会说谎，但代码永远不会。
- en: 'The `subsequences.py` script shows how we create the subsequences, how we store
    them in a Python data structure, and how we might process them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`subsequences.py` 脚本展示了我们如何创建子序列，如何将它们存储在 Python 数据结构中，以及我们如何处理它们：'
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We define the `TS` class again and use that version in `subsequences.py` in
    order to be able to make more changes to the `TS` class without the danger of
    altering the code of the `isax` package. Before now, we have read the parameters
    of the program and we are ready to read the time series:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次定义 `TS` 类，并在 `subsequences.py` 中使用这个版本，以便能够在不改变 `isax` 包代码的情况下对 `TS` 类进行更多修改。在此之前，我们已经读取了程序的参数，并且准备读取时间序列：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Currently, we have the time series stored as a NumPy array using the `ts_numpy`
    variable:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们使用 `ts_numpy` 变量将时间序列存储为 NumPy 数组：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `for` loop splits the time series into subsequences based on the sliding
    window size. The normalized version of each subsequence is stored in a `TS()`
    structure that has three members: the normalized version of the subsequence (`ts`),
    the SAX representation of the subsequence (`sax`), and the place of the subsequence
    in the time series (`index`). The last member of the `TS()` structure allows us
    to find the original version of the subsequence, should we want to do so.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环根据滑动窗口大小将时间序列分割成子序列。每个子序列的归一化版本存储在具有三个成员的 `TS()` 结构中：子序列的归一化版本（`ts`）、子序列的
    SAX 表示（`sax`）以及子序列在时间序列中的位置（`index`）。`TS()` 结构的最后一个成员允许我们在需要时找到子序列的原始版本。'
- en: 'Now, check the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查以下代码：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After we finish, the script prints the number of subsequences that have been
    processed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，脚本会打印出已处理的子序列数量。
- en: Only after we have stored the SAX representation of a subsequence in its Python
    structure based on the maximum cardinality are we ready to put that subsequence
    into the iSAX index. So, the next step, which is not presented here, is putting
    each `TS()` node into an iSAX index.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我们将子序列的SAX表示存储在其基于最大基数构建的Python结构中之后，我们才准备好将该子序列放入iSAX索引中。因此，下一个步骤（此处未展示）是将每个`TS()`节点放入iSAX索引中。
- en: 'The output of `subsequences.py` gives you information about the number of subsequences
    that have been processed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`subsequences.py`的输出会告诉你已经处理了多少个子序列：'
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In summary, this is the way we are going to process subsequences in order to
    add them to an iSAX index. In the next subsection, we are going to create our
    first iSAX index!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这是我们处理子序列以便将它们添加到iSAX索引中的方法。在下一小节中，我们将创建我们的第一个iSAX索引！
- en: Creating our first iSAX index
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个iSAX索引
- en: 'In this section, we are going to create an iSAX index for the first time. But
    first, we are going to present the Python utility for doing that. The Python code
    of `createiSAX.py` is presented in four parts. The first part is the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首次创建一个iSAX索引。但首先，我们将展示用于此目的的Python实用工具。`createiSAX.py`的Python代码分为四个部分。第一部分如下：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This first part is about the `import` statements and reading the required parameters
    using `argparse`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一部分是关于`import`语句和通过`argparse`读取所需参数。
- en: 'The second part of `createiSAX.py` is the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`createiSAX.py`的第二部分如下：'
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this part of `createiSAX.py`, we assign the parameters to the relevant local
    and global variables and make some tests to make sure that the parameters make
    sense. The reason for using local variables is to have smaller variable names
    to work with. The `print()` statement outputs the parameters on the screen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createiSAX.py`的这一部分中，我们将参数分配给相关的局部和全局变量，并进行一些测试以确保参数是有意义的。使用局部变量的原因是有更小的变量名可以工作。`print()`语句将参数输出到屏幕上。
- en: 'The third part of `createiSAX.py` contains the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`createiSAX.py`的第三部分包含以下代码：'
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this part, we read the compressed time series file and create the NumPy variable
    that holds the entire time series. After that, we initialize a variable to hold
    the iSAX index. As the name of the class is `iSAX`, the relevant variable is initialized
    as an instance of the `isax.iSAX()` class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们读取压缩的时间序列文件，创建一个NumPy变量来存储整个时间序列。之后，我们初始化一个变量来存储iSAX索引。由于类的名称是`iSAX`，相关变量被初始化为`isax.iSAX()`类的实例。
- en: 'The last part of `createiSAX.py` contains the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`createiSAX.py`的最后部分包含以下代码：'
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This last part splits the time series according to the sliding window size,
    creates the `TS()` objects, and inserts them into the iSAX index using the `insert()`
    method of the `iSAX` class using the `ISAX` variable – remember that it is `iSAX.insert()`
    that calls `Node.insert()`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后部分根据滑动窗口大小分割时间序列，创建`TS()`对象，并使用`ISAX`变量通过`iSAX`类的`insert()`方法将它们插入到iSAX索引中——记住，是`iSAX.insert()`调用`Node.insert()`。
- en: 'Running `createiSAX.py` produces the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`createiSAX.py`会产生以下输出：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The good thing is that `createiSAX.py` has default values for all iSAX parameters.
    However, providing the path for the file that holds the time series is required.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于`createiSAX.py`为所有iSAX参数提供了默认值。然而，提供包含时间序列的文件的路径是必需的。
- en: In the next subsection, we are going to develop a command-line utility that
    counts the total number of subsequences in an iSAX index.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将开发一个命令行实用工具，用于计算iSAX索引中的子序列总数。
- en: Counting the subsequences of an iSAX index
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算iSAX索引的子序列
- en: This is a really handy utility that not only shows *how to traverse an entire
    iSAX index* but also allows you to count all the subsequences of an iSAX index
    and make sure that you have not missed any subsequences in the process, which
    can be used for testing purposes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常实用的工具，它不仅展示了如何遍历整个iSAX索引，还允许你计算iSAX索引的所有子序列，并确保在过程中没有遗漏任何子序列，这可以用于测试目的。
- en: 'The code of `countSub.py` that does the counting is the following – the rest
    of the implementation is the same as in `createiSAX.py`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 执行计数的`countSub.py`代码如下——其余的实现与`createiSAX.py`相同：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The code visits the `ISAX.ht` field of an iSAX class because this is where *all
    the nodes* of the iSAX index are kept. If we are working with a terminal node,
    then we call the `nTimeSeries()` method to find the number of subsequences that
    are stored in that terminal node. We do that for all the terminal nodes, and we
    are done. The last statement prints both the theoretical number of subsequences
    as well as the actual number of subsequences found in the iSAX index. As long
    as these two values are the same, we are good.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 代码访问 iSAX 类的 `ISAX.ht` 字段，因为这是 iSAX 索引中所有节点都保存的地方。如果我们正在处理一个终端节点，那么我们调用 `nTimeSeries()`
    方法来找到存储在该终端节点中的子序列数量。我们对所有终端节点都这样做，然后我们就完成了。最后一条语句打印出理论上的子序列数量以及实际在 iSAX 索引中找到的子序列数量。只要这两个值相同，我们就没问题。
- en: 'Running `countSub.py` on a small time series, which you can find in the `ch04`
    directory, generates the following kind of output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ch04` 目录中运行 `countSub.py` 在一个短时间序列上，生成以下类型的输出：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The subsection that follows shows the time it takes to construct an iSAX index.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节显示了构建 iSAX 索引所需的时间。
- en: How long does it take to create an iSAX index?
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 iSAX 索引需要多长时间？
- en: In this subsection, we are going to compute the time it takes a computer to
    create an iSAX index. The main reason for any delays in the construction phase
    of iSAX is the splitting of nodes and the rearrangement of the subsequences. The
    more extensive splitting we have, the more time it takes to generate the index.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将计算计算机创建 iSAX 索引所需的时间。iSAX 构建阶段中任何延迟的主要原因是对节点的分割和子序列的重新排列。我们分割得越广泛，生成索引所需的时间就越长。
- en: 'The code of `howMuchTime.py` that computes the time it takes to create the
    iSAX index is the following – the rest of the implementation is the same as in
    `createiSAX.py`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 iSAX 索引创建所需时间的 `howMuchTime.py` 代码如下——其余的实现与 `createiSAX.py` 相同：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first statement is located right before we begin reading the time series
    file using `pd.read_csv()` and the second statement is right after we finish splitting
    and inserting the time series into the iSAX index.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句位于我们使用 `pd.read_csv()` 开始读取时间序列文件之前，第二条语句位于我们完成分割并将时间序列插入 iSAX 索引之后。
- en: 'The output of `howMuchTime.py` when processing `ts1.gz` is similar to the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`howMuchTime.py` 处理 `ts1.gz` 的输出类似于以下内容：'
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As `ts1.gz` is a small time series with 50 elements, the output is not that
    interesting. Therefore, let us try using `howMuchTime.py` on bigger time series.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ts1.gz` 是一个包含 50 个元素的短时间序列，输出并不那么有趣。因此，让我们尝试使用 `howMuchTime.py` 在更大的时间序列上。
- en: 'The next output shows the time it took `howMuchTime.py` to create an iSAX index
    for a time series with 500,000 elements on a macOS machine with 32 GB of RAM and
    an Apple M1 Max CPU – you can create a time series with the same length on your
    own and try the same command or use the provided file, which is called `500k.gz`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了 `howMuchTime.py` 在 macOS 机器上创建包含 500,000 个元素的时间序列 iSAX 索引所需的时间——你可以在自己的机器上创建相同长度的时间序列，并尝试相同的命令或使用提供的文件，该文件名为
    `500k.gz`：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `500k.gz` file was created using the following commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建了 `500k.gz` 文件：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following output shows the time it took `howMuchTime.py` to create an iSAX
    index for a time series with 2,000,000 elements on a macOS machine with 32 GB
    of RAM and an Apple M1 Max CPU – you can create a time series with the same or
    a bigger length on your own and try the same command or use the provided file,
    which is called `2M.gz`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了 `howMuchTime.py` 在 macOS 机器上创建包含 2,000,000 个元素的时间序列 iSAX 索引所需的时间——你可以在自己的机器上创建相同长度或更长的时序，并尝试相同的命令或使用提供的文件，该文件名为
    `2M.gz`：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `2M.gz` file was created using the following commands:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建了 `2M.gz` 文件：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: One interesting conclusion that we can make is that for a time series that is
    four times bigger, it took our program about four times longer to build. However,
    this is not always the case.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出的一个有趣的结论是，对于四倍大的时间序列，我们的程序构建它大约需要四倍的时间。然而，情况并不总是如此。
- en: Additionally, the time it took to create an iSAX index does not tell the whole
    story, especially when testing on a busy machine or a slow machine with a little
    amount of RAM. What is more important is the number of node splits as well as
    the number of accesses to subsequences that were made. The minimum number of accesses
    to subsequences is equal to the subsequences of the time series. However, when
    splits take place, we must revisit the involved subsequences in order to distribute
    them according to the newly created SAX representations and terminal nodes. The
    splits and the revisiting of subsequences increase the construction time of the
    iSAX.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建 iSAX 索引所需的时间并不能完全说明问题，尤其是在繁忙的机器或内存较少的慢速机器上进行测试时。更重要的是节点分割的数量以及访问子序列的次数。访问子序列的最小次数等于时间序列的子序列数量。然而，当发生分割时，我们必须重新访问涉及到的子序列，以便根据新创建的
    SAX 表示和终端节点进行分配。分割和重新访问子序列会增加 iSAX 的构建时间。
- en: Therefore, we are going to create a modified version of `howMuchTime.py` that
    also prints the number of node splits, as well as the total number of subsequence
    accesses. The name of the new utility is `accessSplit.py`. The statements that
    do the counting of the splits and the subsequence accessing are already present
    in `isax/isax.py` and we just need to access two global variables, which are `variables.nSplits`
    and `variables.nSubsequences`, to get the results.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建 `howMuchTime.py` 的修改版本来打印节点分割的数量以及子序列访问的总数。新工具的名称是 `accessSplit.py`。执行分割和子序列访问计数的语句已经在
    `isax/isax.py` 中存在，我们只需要访问两个全局变量，即 `variables.nSplits` 和 `variables.nSubsequences`，以获取结果。
- en: 'Running `accessSplit.py` with the default parameters on `500k.gz` produces
    the following kind of output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认参数在 `500k.gz` 上运行 `accessSplit.py` 会产生以下类型的输出：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What does this output tell us? It tells us that there was no split! In practice,
    this means that the root node of that particular iSAX index has terminal nodes
    only as children. Is this good or bad? In general, this means that *the index
    works like a hash table* where the hash function is the function for calculating
    the SAX representation. Most of the time, this is not the desirable form that
    we want an index to have because we could have used a hash table in the first
    place!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们什么？它告诉我们没有发生分割！在实践中，这意味着该特定 iSAX 索引的根节点只有终端节点作为子节点。这是好是坏？一般来说，这意味着*索引像哈希表一样工作*，其中哈希函数是计算
    SAX 表示的函数。大多数情况下，这不是我们希望索引具有的理想形式，因为我们一开始就可以使用哈希表！
- en: 'If we run `accessSplit.py` on the same time series using different parameters,
    we are going to get a totally different output regarding the construction of the
    iSAX index:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用不同的参数在相同的时间序列上运行 `accessSplit.py`，我们将得到关于 iSAX 索引构建的完全不同的输出：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What does this output tell us? It tells us that even on a relatively small time
    series, the iSAX parameters play a huge role in the creation time of the iSAX
    index. However, the number of subsequence accesses is around 33 times the total
    number of subsequences of the time series, which is pretty big and therefore not
    very efficient.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们什么？它告诉我们即使在相对较小的时间序列上，iSAX 参数在 iSAX 索引创建时间中起着巨大的作用。然而，子序列访问的次数大约是时间序列子序列总数的
    33 倍，这相当大，因此效率不高。
- en: 'Let us now try `accessSplit.py` on a bigger time series, which is `2M.gz`,
    and see what happens:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试在更大的时间序列 `2M.gz` 上运行 `accessSplit.py`，看看会发生什么：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As before, we are using the iSAX index as a hash table, which is not the desired
    behavior. Let us try using different parameters instead:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们正在使用 iSAX 索引作为哈希表，这不是我们期望的行为。让我们尝试使用不同的参数：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This time, the number of accesses to subsequences is around seven times the
    length of the time series, which is more realistic than when we were working with
    the `500k.gz` file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，访问子序列的次数大约是时间序列长度的七倍，这比我们处理 `500k.gz` 文件时更为现实。
- en: We are going to work with `accessSplit.py` again in [*Chapter 5*](B14769_05.xhtml#_idTextAnchor124).
    But for now, we are going to learn more about the overflow of iSAX indexes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第五章*](B14769_05.xhtml#_idTextAnchor124) 中再次使用 `accessSplit.py`。但到目前为止，我们将更多地了解
    iSAX 索引的溢出问题。
- en: Dealing with iSAX overflows
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 iSAX 溢出
- en: In this subsection, we are going to experiment with an overflow situation. Keep
    in mind that a dedicated global parameter exists in `variables.py` that holds
    the number of subsequences that were ignored due to overflow. Among other things,
    this helps you fix the iSAX parameters faster as you know how bad the overflow
    is. Usually, the easiest way to fix an overflow is by increasing the threshold
    value, but this might have serious implications when searching an iSAX index or
    comparing an iSAX index with another one.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将对溢出情况进行实验。请记住，在`variables.py`中存在一个专门的全局参数，它保存了由于溢出而被忽略的子序列数量。除此之外，这还有助于你更快地修复iSAX参数，因为你知道溢出有多严重。通常，修复溢出最简单的方法是增加阈值值，但这样做在搜索iSAX索引或比较两个iSAX索引时可能会产生严重影响。
- en: 'The Python code of `overflow.py` has only one change compared to `createiSAX.py`,
    which is the following statement because the SAX representation that created the
    overflow is printed by default:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与`createiSAX.py`相比，`overflow.py`的Python代码只有一个变化，那就是以下语句，因为导致溢出的SAX表示默认情况下会被打印出来：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This mainly happens because the functionality is built into the `isax` package,
    which automatically prints a message when the first overflow takes place, and
    we just have to access the `variables.overflow` variable to find out the total
    number of overflows.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是因为功能内置在`isax`包中，当第一次发生溢出时会自动打印一条消息，我们只需访问`variables.overflow`变量来找出总的溢出次数。
- en: 'The output of `overflow.py` when working with the `500k.gz` time series includes
    the following information:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`500k.gz`时间序列处理时，`overflow.py`的输出包括以下信息：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The previous output tells us that the first SAX representation that caused an
    overflow was `1000_0111_0111_1000_1000_0111_0111_1000` and that we had `303084`
    overflows in total – we might have more SAX representations that cause an overflow,
    but we have decided to print just the first one. This means that `303084` subsequences
    were not inserted into the iSAX index, which is a very large number compared to
    the length of the time series.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出告诉我们，导致溢出的第一个SAX表示是`1000_0111_0111_1000_1000_0111_0111_1000`，总共发生了`303084`次溢出——我们可能还有更多导致溢出的SAX表示，但我们决定只打印第一个。这意味着有`303084`个子序列没有被插入到iSAX索引中，与时间序列的长度相比，这是一个非常大的数字。
- en: 'Let us now try the same command using the other promotion strategy and see
    what happens:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试使用其他提升策略执行相同的命令，看看会发生什么：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It turns out that we got the same kind of overflow and the exact same number
    of total overflows. This makes perfect sense as the overflow situation does not
    have to do with the promotion strategy but with the SAX representations. *A different
    promotion strategy might change the shape of an iSAX index a little, but it has
    nothing to do with the* *overflow situation.*
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，我们得到了相同类型的溢出和完全相同的总溢出次数。这完全合理，因为溢出情况与提升策略无关，而是与SAX表示有关。*不同的提升策略可能会稍微改变iSAX索引的形状，但它与*
    *溢出情况* *无关*。
- en: 'As `303084` is a big number, we might need to drastically increase the capacity
    of the iSAX index but without creating an unnecessarily big iSAX index. So, with
    that in mind, we can try to resolve the overflow situation by changing the parameters
    of the iSAX index. Let us try to do so then by increasing the threshold value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`303084`是一个很大的数字，我们可能需要大幅增加iSAX索引的容量，但又不能创建一个不必要的大的iSAX索引。因此，考虑到这一点，我们可以尝试通过改变iSAX索引的参数来解决溢出问题。那么，让我们尝试通过增加阈值值来这样做：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So, it looks like we cut the number of overflows in half, which is a good thing
    for a start. However, although we are using the same cardinality as before, it
    is a different SAX representation (`0111_1000_1000_1000_1000_0111_0111_0111`)
    that caused the first overflow this time, which means that the increased threshold
    value solved the overflow condition that took place earlier with the `1000_0111_0111_1000_1000_0111_0111_1000`
    SAX representation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看起来我们减少了一半的溢出次数，这对开始来说是个好事。然而，尽管我们使用了与之前相同的基数，但这次导致第一次溢出的却是不同的SAX表示（`0111_1000_1000_1000_1000_0111_0111_0111`），这意味着增加的阈值值解决了之前由`1000_0111_0111_1000_1000_0111_0111_1000`
    SAX表示引起的溢出条件。
- en: 'Let us give it another try by increasing the `cardinality` value and at the
    same time decreasing the threshold value:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过增加`cardinality`值并同时降低阈值值来再试一次：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: So, we finally found a triplet of parameters that works for the `1024` sliding
    window size and the `500k.gz` dataset.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终找到了一组适用于`1024`滑动窗口大小和`500k.gz`数据集的参数组合。
- en: Is there a recipe for finding out which parameters work and which do not work?
    No, as it mainly depends on the values of the dataset and the sliding window size.
    The more you work and experiment with iSAX indexes, the more you are going to
    understand which parameters work best for a given dataset and sliding window size.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有找到哪些参数有效和无效的配方？没有，因为这主要取决于数据集的值和滑动窗口大小。你越使用并实验iSAX索引，你就越会了解哪些参数对于给定的数据集和滑动窗口大小效果最好。
- en: So, in this last section, we learned about iSAX overflows and presented a technique
    for solving such situations.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节的最后，我们了解了iSAX溢出，并介绍了一种解决这种情况的技术。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw and went through the implementation details of the `isax`
    Python package, which allows us to create iSAX indexes. Please make sure that
    you understand the code and most importantly know how to use the code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了`isax` Python包的实现细节，该包允许我们创建iSAX索引。请确保你理解代码，最重要的是知道如何使用代码。
- en: Additionally, we implemented many command-line utilities that allow us to create
    iSAX indexes and understand what happens behind the scenes regarding the splits
    and subsequence accesses as well as the overflow conditions. Having a better understanding
    of the structure of an iSAX index allows us to select better indexes and avoid
    using poor ones.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还实现了许多命令行工具，使我们能够创建iSAX索引，并了解在分割和子序列访问以及溢出条件方面幕后发生了什么。更好地理解iSAX索引的结构使我们能够选择更好的索引，并避免使用较差的索引。
- en: The next chapter is going to put iSAX indexes into practice by showing how to
    search and join iSAX indexes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过展示如何搜索和连接iSAX索引来将iSAX索引应用于实践。
- en: Useful links
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用链接
- en: 'The `argparse` package: [https://docs.python.org/3/library/argparse.xhtml](https://docs.python.org/3/library/argparse.xhtml)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse`包：[https://docs.python.org/3/library/argparse.xhtml](https://docs.python.org/3/library/argparse.xhtml)'
- en: 'The NumPy Python package: [https://numpy.org/](https://numpy.org/)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy Python包：[https://numpy.org/](https://numpy.org/)
- en: Exercises
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to work through the following exercises:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成以下练习：
- en: Create a synthetic dataset with 100,000 elements with values from *-10 to 10*
    and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold
    value of `1000`. How much time did it take your machine to create the iSAX index?
    Are there any overflows?
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含100,000个元素、值从*-10到10*的合成数据集，并构建一个具有4个段、基数64和阈值`1000`的iSAX索引。你的机器创建iSAX索引花费了多长时间？是否有溢出？
- en: Create a synthetic dataset with 100,000 elements with values from *-1 to 1*
    and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold
    value of `1000`. How much time did it take your machine to create that iSAX index?
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含100,000个元素、值从*-1到1*的合成数据集，并构建一个具有4个段、基数64和阈值`1000`的iSAX索引。你的机器创建该iSAX索引花费了多长时间？
- en: Create a synthetic dataset with 500,000 elements with values from *0 to 10*
    and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold
    value of `1000`. How much time did it take your machine to create the iSAX index?
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含500,000个元素、值从*0到10*的合成数据集，并构建一个具有4个段、基数64和阈值`1000`的iSAX索引。你的机器创建iSAX索引花费了多长时间？
- en: Create a synthetic dataset with 500,000 elements with values from *0 to 10*
    and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold
    value of `1000`. How many splits and accesses to subsequences took place? What
    happens if you increase the threshold value to `1500`?
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含500,000个元素、值从*0到10*的合成数据集，并构建一个具有4个段、基数64和阈值`1000`的iSAX索引。发生了多少次分割和子序列访问？如果你将阈值值增加到`1500`会发生什么？
- en: Create a synthetic dataset with 150,000 elements with values from *-1 to 1*
    and construct an iSAX index with 4 segments, a cardinality of 64, and a threshold
    value of `1000`. Are there any overflows? How many splits were performed for the
    construction of the iSAX index?
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含150,000个元素、值从*-1到1*的合成数据集，并构建一个具有4个段、基数64和阈值`1000`的iSAX索引。是否有溢出？构建iSAX索引时执行了多少次分割？
- en: Experiment with `accessSplit.py` on `2M.gz` using various iSAX parameters. Which
    parameters seem to work best? Do not forget that high threshold values have a
    great impact on searching; so, in general, do not use huge threshold values to
    lower the number of splits.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`2M.gz`上使用不同的iSAX参数进行`accessSplit.py`实验。哪些参数似乎效果最好？不要忘记，高阈值值对搜索有很大影响；因此，通常不要使用非常大的阈值值以降低分割次数。
- en: Experiment with `accessSplit.py` on `500k.gz` using various iSAX parameters.
    Which parameters seem to work best?
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`500k.gz`文件上使用各种iSAX参数对`accessSplit.py`进行实验。哪些参数看起来效果最好？
