- en: Chapter 6. Petrel in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, we saw working examples of Storm topologies, both simple
    and complex. In doing so, however, we skipped some of the tools and techniques
    that you''ll need while developing your own topologies:'
  prefs: []
  type: TYPE_NORMAL
- en: Storm is a great environment for running your code, but deploying to Storm (even
    on your local machine) adds complexity and takes extra time. We'll see how to
    test your spouts and bolts outside of Storm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When components run inside Storm, they can't read from the console, which prevents
    the use of pdb, the standard Python debugger. This chapter demonstrates Winpdb,
    an interactive debugging tool suitable for debugging components inside Storm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storm lets you easily harness the power of many servers, but performance of
    your code still matters. In this chapter, we'll see some ways of measuring the
    performance of our topology's components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a bolt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Storm makes it easy to deploy and run Python topologies, but developing and
    testing them in Storm is challenging, whether running in standalone Storm or a
    full Storm deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: Storm launches programs on your behalf—not only your Python code but auxiliary
    Java processes as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It controls the Python components' standard input and output channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python programs must respond regularly to heartbeat messages or be shut
    down by Storm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes it difficult to debug Storm topologies using the typical tools and
    techniques used for other pieces of Python code, such as the common technique
    of running from the command line and debugging with pdb.
  prefs: []
  type: TYPE_NORMAL
- en: Petrel's mock module helps us with this. It provides a simple, standalone Python
    container for testing simple topologies and verifying that the expected results
    are returned.
  prefs: []
  type: TYPE_NORMAL
- en: In Petrel terms, a **simple** topology is one that only outputs to the default
    stream and has no branches or loops. The `run_simple_topology()` assumes that
    the first component in the list is a spout, passing the output of each component
    to the next component in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Example – testing SplitSentenceBolt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Here is the `splitsentence.py` file from the first
    example in [Chapter 3](ch03.html "Chapter 3. Introducing Petrel"), *Introducing
    Petrel* with a unit test added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the test, enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, install the Python `nosetests` library by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, run this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If all goes well, you''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Nose is a very powerful tool with many features. We won't cover it in detail
    here, but you can find the documentation at [https://nose.readthedocs.org/en/latest/](https://nose.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Example – testing SplitSentenceBolt with WordCountBolt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next example shows how to test a sequence of related components. In the
    following code, we see a new version of `wordcount.py` that tests the interaction
    between `SplitSentenceBolt` and `WordCountBolt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The test is pretty straightforward; we simply instantiate both components and
    include them in the right sequence when calling `mock.run_simple_topology()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both example tests specify `result_type=mock.LIST` while calling `run_simple_topology()`.
    This parameter option tells Petrel which format to use when returning output tuples.
    The options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STORM_TUPLE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LIST`'
  prefs: []
  type: TYPE_NORMAL
- en: '`TUPLE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAMEDTUPLE`'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, `LIST` is a good choice for components with a small number of output
    fields, while `NAMEDTUPLE` is more readable for a larger number of fields (that
    is, by allowing the test to access result fields by field name rather than numeric
    indices). `STORM_TUPLE` is useful if the test needs to check other attributes
    of the result, for example, the lesser-used stream property.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we''ve debugged topologies using log messages and automated tests.
    These techniques are very powerful, but sometimes it may be necessary to debug
    directly inside the Storm environment. For example, the problem may:'
  prefs: []
  type: TYPE_NORMAL
- en: Depend on running as a particular user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occur only with real data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occur only when there are many instances of the component running in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section introduces a tool for debugging inside Storm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Winpdb is a portable, GUI-based debugger for Python, with support for embedded
    debugging. If you''re not familiar with the term "embedded debugging", note this:
    it simply means that Winpdb can attach to a program that was launched in some
    other way and not necessarily from WinDbg or your command shell. For this reason,
    it is a good fit for debugging Petrel components that run in Storm.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Winpdb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Activate your Petrel virtual environment and then use `pip` to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Add Winpdb breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `splitsentence.py` file, add the following at the beginning of the `run()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `'password'` value can be anything; this is simply the password that you
    will use in the next step to attach to `splitsentence.py`.
  prefs: []
  type: TYPE_NORMAL
- en: When this line of code executes, the script will freeze for a default period
    of 5 minutes, waiting for a debugger to attach.
  prefs: []
  type: TYPE_NORMAL
- en: Launching and attaching the debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now run the topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once you see log messages from the spout, you will know that the topology is
    up and running, so you can connect with the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Launch `Winpdb` simply by running `winpdb`.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on how to use Winpdb for embedded debugging, see the documentation
    at [http://winpdb.org/docs/embedded-debugging/](http://winpdb.org/docs/embedded-debugging/).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the window appears, select **File** | **Attach** from the menu. A password
    dialog will appear. Here, enter the same password that you passed to `start_embedded_debugger()`
    and click on the **OK** button, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching and attaching the debugger](img/B03471_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, choose the process to attach to and click on **OK**, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching and attaching the debugger](img/B03471_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you''ll see the main Winpdb window, with the line below the breakpoint
    highlighted. If you''ve used other debuggers, Winpdb should be straightforward
    to use. If you need help using Winpdb, the following tutorial is very good for
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://code.google.com/p/winpdb/wiki/DebuggingTutorial](https://code.google.com/p/winpdb/wiki/DebuggingTutorial).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching and attaching the debugger](img/B03471_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Profiling your topology's performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance can be a concern for any application. This is true for Storm topologies
    as well, perhaps more so.
  prefs: []
  type: TYPE_NORMAL
- en: When you're trying to push a lot of data through a topology, raw performance
    is certainly a concern—faster components means that more data can be processed.
    But it's also important to understand the tuple processing performance of individual
    components. This information can be used in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: The first is knowing which components are slower, because this tells you where
    to focus your attention if you are trying to make the code faster. Once you know
    which component (or components) is slow, you can use tools such as the Python
    cProfile module ([http://pymotw.com/2/profile/](http://pymotw.com/2/profile/))
    and the line profiler ([https://github.com/rkern/line_profiler](https://github.com/rkern/line_profiler))
    to understand where the code is spending most of its time.
  prefs: []
  type: TYPE_NORMAL
- en: Even after profiling, some components will still be faster than others. In this
    case, understanding the relative performance between components can help you configure
    the topology for best performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This second point is somewhat subtle, so let''s look at an example. In the
    following code, we see log excerpts for two Storm components from the word count
    topology. These log messages are generated automatically by Petrel. The first
    is the split sentence bolt, and the second is the word count bolt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Split sentence bolt log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the split sentence bolt log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Word count bolt log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These logs demonstrate that the split sentence bolt spends 0.010338 seconds
    processing and acknowledging each tuple (0.010317 + 0.000021), while the word
    count bolt spends 0.000069 seconds (0.000049 + 0.000020) per tuple. The split
    sentence bolt is slower, which suggests that you may want more instances of the
    split sentence bolt than the word count bolt.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why wasn't the read time considered in the preceding calculation? Read time
    includes the CPU time taken to read tuples from Storm, but it also includes time
    spent waiting (that is, sleeping) for the tuples to arrive. If the upstream component
    is providing data slowly, we don't want to count that time against our component.
    So for simplicity, we omitted the read time from the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the per-tuple performance is only part of the picture. You must
    also consider the sheer number of tuples to be processed. During the 4 seconds
    covered by the preceding logs, the split sentence bolt received 97 tuples (sentences),
    while the word count bolt received 622 tuples (words). Now we''ll apply these
    numbers to the per-tuple processing times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The total time used by the split sentence bolt is much larger (roughly 23 times
    greater), and we should take this into account while configuring the parallelism
    of the topology. For example, we might configure `topology.yaml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By configuring the topology in this way, we help ensure that at high traffic
    rates, there are enough split sentence bolts to avoid becoming a bottleneck, keeping
    the word count bolts busy all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The logs from the preceding section used a version of the split sentence bolt
    that was deliberately modified to run slower and make the example clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned some skills that will help make you more productive
    building your own topologies. As you develop spouts or bolts, you can test them
    individually before assembling them into a complete topology and deploying on
    Storm. If you encounter a tricky problem that occurs only while running in Storm,
    you can use Winpdb in addition to (or instead of) log messages. When your code
    is working, you can get insights into which components take most of the time,
    so you can focus on improving performance in those areas. With these skills, you
    are now ready to go out and build your own topologies. Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Managing Storm Using Supervisord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This appendix gives you an overview of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storm administration over a cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing supervisord
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components of supervisord
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supervisord installation and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storm administration over a cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many tools available that can create multiple virtual machines, install
    predefined software and even manage the state of that software.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing supervisord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Supervisord is a process control system. It is a client-server system that allows
    its users to monitor and control a number of processes on Unix-like operating
    systems. For details, visit [http://supervisord.org/](http://supervisord.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Supervisord components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server piece of the supervisor is known as supervisord. It is responsible
    for starting child programs upon its own invocation, responding to commands from
    clients, restarting crashed or exited subprocesses, logging its subprocess `stdout`
    and `stderr` output, and generating and handling "events" corresponding to points
    in subprocess lifetimes. The server process uses a configuration file. This is
    typically located in `/etc/supervisord.conf`. This configuration file is a Windows-INI
    style `config` file. It is important to keep this file secure via proper filesystem
    permissions because it might contain decrypted usernames and passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '**supervisorctl**: The command-line client piece of the supervisor is known
    as supervisorctl. It provides a shell-like interface for the features provided
    by supervisord. From supervisorctl, a user can connect to different supervisord
    processes. They can get the status on the subprocesses controlled by, stop and
    start subprocesses of, and get lists of running processes of a supervisord. The
    command-line client talks to the server across a Unix domain socket or an Internet
    (TCP) socket. The server can assert that the user of a client should present authentication
    credentials before it allows them to use commands. The client process typically
    uses the same configuration file as the server, but any configuration file with
    a `[supervisorctl]` section in it will work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web server**: A (sparse) web user interface with functionality comparable
    to supervisorctl may be accessed via a browser if you start supervisord against
    an Internet socket. Visit the server URL (for example, `http://localhost:9001/`)
    to view and control the process status through the web interface after activating
    the configuration file''s `[inet_http_server]` section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML-RPC interface**: The same HTTP server that serves the web UI serves up
    an XML-RPC interface that can be used to interrogate and control the supervisor
    and the programs it runs. See *XML-RPC API Documentation*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Machines**: Let''s assume that we have two EC2 machines of IP addresses `172-31-19-62`
    and `172.31.36.23`. We will install supervisord on both machines and later configure
    to decide what services of Storm would be running on each machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storm and Zookeeper setup**: Let''s run Zookeeper, Nimbus, supervisor, and
    the UI on machine `172.31.36.23` and only the supervisor on `172-31-19-62`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zookeeper** **version**: `zookeeper-3.4.6.tar.gz`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storm** **version**: `apache-storm-0.9.5.tar.gz`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the process of the Zookeeper server setup and configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Zookeeper''s latest version and extract it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Configure `zoo.cfg` in the `conf` directory to start Zookeeper in cluster mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Zookeeper conf:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that the directory specified in `dataDir` is created and the user
    has read and write permissions on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, go to the Zookeeper `bin` directory and start the `zookeeper` server
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Storm server setup and configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Storm''s latest version from the Apache Storm website and extract
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the configuration of the Storm Nimbus machine as well as the slave
    (added/changed configuration only):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Supervisord installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to install supervisord by the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing on a system with Internet access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the Setup tool and use the `easy_install` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Installing on a system without Internet access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download all dependencies, copy to each machine, and then install it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will follow the second method of installation, the one in which Internet
    access is not required. We will download all dependencies and supervisord, and
    copy it to the servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supervisord `[supervisor-3.1.3.tar.gz]` requires the following dependencies
    to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.7 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setuptools` (latest) from [http://pypi.python.org/pypi/setuptools](http://pypi.python.org/pypi/setuptools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elementtree` (latest) from [http://effbot.org/downloads#elementtree](http://effbot.org/downloads#elementtree).
    `elementtree-1.2-20040618.tar.gz`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meld3-0.6.5.tar.gz`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's install supervisord and the necessary dependencies on both machines, `172.31.36.23`
    and `172-31-19-62`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps for installing the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setuptools`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unzip the `.zip` file using this command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the `setuptools-17.1.1` directory and run the installation command with
    `sudo`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![Supervisord installation](img/B03471_AppendixA_01.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`meld3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the `.ts.gz` file using the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the `meld3.-0.6.5` directory and run this command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![Supervisord installation](img/B03471_AppendixA_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '`elementtree`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the `.ts.gz` file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to `elementtree-1.2-20040618` and run the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![Supervisord installation](img/B03471_AppendixA_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The following are the supervisord installations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract `supervisor-3.1.3` using this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the `supervisor-3.1.3` directory and run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Supervisord installation](img/B03471_AppendixA_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A similar setup of supervisord is required on another machine, that is, `172.31.36.23`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration of supervisord.conf
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lets configure services on the `172.31.36.23` machine and assume that the supervisord
    installation is done as explained previously. Once supervisor is installed, you
    can build the `supervisord.conf` file to start the `supervisord` and `supervisorctl`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the `supervisor.conf` file. Put it into the `/etc` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can refer get sample `supervisord.conf` using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take a look at the `supervisord.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the supervisor server first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start all processes using `supervisorctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![Configuration of supervisord.conf](img/B03471_AppendixA_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can view the supervisord web UI and control processes on the browser. `52.11.193.108`
    is the public IP address of the `172-31-36-23` machine (`http://52.11.193.108:9001`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration of supervisord.conf](img/B03471_AppendixA_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuration of supervisord.conf on 172-31-19-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Keep only the following services in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After that, you can start the supervisor server and all processes using `supervisorctl`
    on `172-31-19-62` machine.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how distributed Storm processes running over multiple
    machines can be managed using the supervisord process. There are many options
    available in supervisord, such as `autostart=true`. If we set this option for
    any Storm process, it also increases the reliability of the overall system and
    manages failure of Nimbus.
  prefs: []
  type: TYPE_NORMAL
