- en: Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the book, we have touched all the important aspects of geospatial
    analysis and we''ve used a variety of different techniques in Python to analyze
    different types of geospatial data. In this final chapter, we will draw on nearly
    all of the topics we have covered to produce a real-world product that has become
    very popular: a GPS route analysis report.'
  prefs: []
  type: TYPE_NORMAL
- en: These reports are common to dozens of mobile app services, GPS watches, in-car
    navigation systems, and other GPS-based tools. A GPS typically records location,
    time, and elevation. From these values, we can derive a vast amount of ancillary
    information about what happened along the route on which that data was recorded.
    Fitness apps including RunKeeper, MapMyRun, Strava, and Nike Plus all use similar
    reports to present GPS-tracked exercise data from running, hiking, biking, and
    walking.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create one of these reports using Python. This program is nearly 500
    lines of code, our longest yet, so we will step through it in pieces. We will
    combine the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a typical GPS report
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a GPS reporting tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we step through this program, all of the techniques used will be familiar,
    but we will be using them in new ways.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be needing the following things for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.6 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RAM: Minimum – 6 GB (Windows), 8 GB (macOS); recommended 8 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage: Minimum 7200 RPM SATA with 20 GB of available space, recommended SSD
    with 40 GB of available space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processor: Minimum Intel Core i3 2.5 GHz, recommended Intel Core i5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PIL: The Python Imaging Library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NumPy: A multidimensional and array-processing library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pygooglechart`: A Python wrapper for the excellent Google Chart API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FPDF: A simple and pure-Python PDF writer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding a typical GPS report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A typical GPS report has common elements including a route map, elevation profile,
    and speed profile. The following screenshot is a report from a typical route logged
    through RunKeeper ([https://runkeeper.com/index](https://runkeeper.com/index)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9ab8e4f-557d-4506-acfe-d5d07f510d3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Our report will be similar, but we'll add a twist. We'll include the route map
    and elevation profile like this service, but we'll also add the weather conditions
    that occurred on that route when it was recorded and a geolocated photo taken
    on route.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a GPS report is, let's learn how to build it.
  prefs: []
  type: TYPE_NORMAL
- en: Building a GPS reporting tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of our program is `GPX-Reporter.py`. If you remember the *Tag and markup-based
    formats *section in [Chapter 2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml), *Learning
    Geospatial Data*, the **GPX** format is the most common way to store GPS route
    information. Nearly every program and device relying on GPS data can convert to
    and from GPX.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, you can download a sample GPX file from: [http://git.io/vl7qi](http://git.io/vl7qi).
    Also, you will need to install a few Python libraries from PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should simply use `easy_install` or `pip` to install these tools. We will
    also be using a module called `SRTM.py`. This module is a utility for working
    with near-global elevation data collected during the 11-day **Shuttle Radar Topography
    Mission** (**SRTM**) in 2000 by the space shuttle Endeavor. Install the SRTM module
    using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can also download the zipped file, extract it, and copy the
    `srtm` folder to your Python `site-packages` directory or your working directory: [http://git.io/vl5Ls](http://git.io/vl5Ls).
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to register for a free Dark Sky API. This free service provides
    unique tools. It is the only service that provides global, historical weather
    data for nearly any point location with up to 1,000 requests per day for free: [https://darksky.net/dev](https://darksky.net/dev).
  prefs: []
  type: TYPE_NORMAL
- en: '**Dark Sky** will provide you with a text key that you insert into a variable
    called `api_key` in the GPX-Reporter program before running it. Finally, as per
    Dark Sky''s terms of service, you''ll need to download a logo image to be inserted
    into the report: [https://raw.githubusercontent.com/GeospatialPython/Learn/master/darksky.png](https://raw.githubusercontent.com/GeospatialPython/Learn/master/darksky.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can review the Dark Sky *Terms of Service* here: [https://darksky.net/dev/docs/terms](https://darksky.net/dev/docs/terms).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re ready to work through the GPX-Reporter program. Like other scripts
    in this book, this program tries to minimize functions so you can mentally trace
    the program better and modify it with less effort. The following list contains
    the major steps in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Python `logging` module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establishing our helper functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parsing the GPX data file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the route bounding box
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buffering the bounding box
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Converting the box to meters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading the basemap
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading the elevation data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hillshading the elevation data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increasing the hillshade contrast
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blending the hillshade and basemap
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drawing the GPX track on a separate image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blending the track image and basemap
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drawing the start and finish points
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving the map image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the route mile markers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the elevation profile chart
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the weather data for the route time period
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating the PDF report
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next subsection takes you through the first step.
  prefs: []
  type: TYPE_NORMAL
- en: Initial setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The beginning of the program is `import` statements followed by the Python
    `logging` module. The `logging` module provides a more robust way to track and
    log program status than simple `print` statements. In this part of the program,
    we configure it as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to install all the libraries we need, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can configure the Python `logging` module to tell us what''s going on
    throughout the process, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This logger prints to the console, but with a few simple modifications you can
    have it print to a file, or even a database, just by altering the configuration
    in this section. This module is built into Python and is documented here: [https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have several utility functions that are used several times throughout
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Working with utility functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the following functions, except the functions related to time, have
    been used in previous chapters in some form. Let''s see how to use utility functions
    in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `ll2m()` function converts latitude and longitude to meters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `world2pixel()` function converts geospatial coordinates to pixel coordinates
    on our output map image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have `get_utc_epoch()` and `get_local_time()` to convert the UTC time
    stored in the GPX file to local time along the route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a haversine distance function and our simple `wms` function to
    retrieve map images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wms()` function retrieves map images with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have an `exif()` function to extract the metadata from the photo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have a `dms2dd()` function to convert degrees/minutes/seconds coordinates
    to decimal degrees because that''s how the photo coordinates are stored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we have a `gps()` function to extract the coordinates from the
    photo metadata:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have our program variables. We will be accessing an **OpenStreetMap
    WMS** service provided for free by a company named **Mundalis** as well as the
    SRTM data provided by NASA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We access the WMS services in this book using Python''s `urllib` library for
    simplicity, but if you plan to use OGC web services frequently, you should use
    the Python package OWSLib available through PyPI: [https://pypi.python.org/pypi/OWSLib](https://pypi.python.org/pypi/OWSLib).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s perform the followings steps to set up the WMS web service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will output several intermediate products and images. These variables are
    used in those steps. The `route.gpx` file is defined in this section as the `gpx` variable.
    First, we set up some conversion constants for degrees to radians conversion and
    back with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the name of our `.gpx` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we begin setting up the WMS web service, which will retrieve the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up our hillshade parameters, which will determine the angle and
    direction of our artificial sun:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we set up the `no_data` value where there is no elevation information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the name of our output image as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create the colors for our minimum and maximum elevation values with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we set up our output image size, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how the functions work, let's parse the GPX.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the GPX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll parse the GPX file, which is just XML, using the `built-in xml.dom.minidom` module.
    We'll extract latitude, longitude, elevation, and timestamps. We'll store them
    in a list for later use. The timestamps are converted to `struct_time` objects
    using Python's `time` module, which makes it easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps need to be performed for parsing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we parse the `gpx` file using the `minidom` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we get all of the `"trkpt"` tags that contain the elevation information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we set up the lists to store our parsed location and elevation values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we loop through the GPS entries in the GPX and parse the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The timestamp requires a little bit of extra work because we have to convert
    from GMT time to local time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After we parse the GPX, we need the bounding box of the route to download data
    from other geospatial services.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the bounding box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we download data, we want the dataset to cover more area than the route
    so the map is not cropped too closely around the edges of the route. So we''ll
    buffer the bounding box by 20% on each side. Finally, we''ll need the data in
    Eastings and Northings to work with the WMS service. Eastings and Northings are
    the *x* and *y* coordinates of points in the Cartesian coordinate system in meters.
    They are commonly used in the UTM coordinate system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the extents from our coordinate lists as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we buffer the bounding box to ensure the track isn''t taken close to
    the edge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set up our bounding box in a variable and convert our coordinates
    to meters, which the web service requires:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With this, we will now download our map and elevation images.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading map and elevation images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll download the OSM basemap first as our basemap, which has streets and
    labels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll download the OSM basemap using `log.info`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This section will produce an intermediate image as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92c897fd-a697-4824-bf2c-d9d6a46ee256.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we''ll download some elevation data from the **SRTM** dataset. SRTM is
    nearly global and provides a 30-90 m resolution. The `SRTM.py` Python module makes
    working with this data easy. `SRTM.py` downloads the data and sets it needs to
    make a request. Therefore, if you download data from different areas, you may
    need to clean out the cache located in your home directory (`~/.srtm`). This part
    of the script can also take up to 2-3 minutes to complete, depending on your computer
    and internet connection speeds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This portion of the script also outputs an intermediate elevation image, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2aa4c75f-0071-4a70-8f9d-44bff5d3ca43.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our elevation image, we can turn it into a hillshade.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the hillshade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can run this data through the same **hillshade** algorithm used in *Creating
    a shaded-relief* section in [Chapter 7](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml),
    *Python and Elevation Data. *For this, let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we open our elevation image and read it into a `numpy` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set up our processing windows to move through the grid and analyze it
    in small sections for efficiency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we break the elevation image into windows as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create arrays for our processing windows as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can process them in a single pass thanks to `numpy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our hillshade layer, we can begin creating maps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the data we need to begin building the map for our report. Our approach
    will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the elevation and basemap images with filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blending the images together to provide a hillshaded OSM map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a translucent layer to draw the street route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blending the route layer with the hillshaded map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These tasks will all be accomplished using the PIL `Image` and `ImageDraw`
    modules, as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we convert our shaded relief `numpy` array back to an image and smooth
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll increase the contrast in the image to make it stand out more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we crop the map image to the same size as our elevation image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we increase the contrast on the map image as well and blend it with the
    hillshade image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to draw the GPS tracks on our blended map by first converting
    our points to pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to subtract the buffer from the edge buffer from the tracks image
    we are about to create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a transparent image and draw our track as a red line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can paste the track on our image with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll draw a starting point on the route like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the code snippet for the ending point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our track drawn, we're ready to place our geotagged photo.
  prefs: []
  type: TYPE_NORMAL
- en: Locating the photo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use a photo taken with a cell phone that adds GPS location coordinates.
    You can download it from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/GeospatialPython/Learn/master/RoutePhoto.jpg](https://raw.githubusercontent.com/GeospatialPython/Learn/master/RoutePhoto.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the image in a directory named `photos` at the same level as the script.
    We''ll only use one photo but the script can handle as man images as you want.
    We''ll draw and place a photo icon on the map and then save the completed basemap,
    as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get a list of images with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we loop through each image and grab its GPS information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we parse the location info using our GPS function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can convert the photo coordinates to image pixel coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll draw an icon for the location of the photo with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we''ll save our map like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'While not saved to the filesystem, the hillshaded elevation looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/141f8503-fd68-4964-8328-5bba99f03a99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The blended topographic map looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11b32a49-185b-4b05-8516-0f64e779769f.png)'
  prefs: []
  type: TYPE_IMG
- en: While hillshade mapping gives us an idea of the elevation, it doesn't give us
    any quantitative data. To get more detailed, we'll create a simple elevation chart.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring elevation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the excellent Google Chart API, we can quickly build a nice elevation
    profile chart showing how the elevation changes across the route:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create the `chart` object for our elevation profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a line for our minimum value like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can fill in our elevation profile as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can set up the elevation labels as follows and assign them to an axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can label the axis itself with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can calculate the distance between the track points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We have the elevation profile, but we need to add the distance markers along
    the *x *axis so we know where along the route the profile changed.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to understand the elevation data chart, we need reference points along
    the *x *axis to help us determine the elevation along the route. We will calculate
    the mile splits along the route and place those at the appropriate location on
    the x axis of our charts. Let''s have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we locate the mile markers along the axis as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up labels for the mile markers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can label the mile markers as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Our chart should now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/242e1586-6859-4016-887f-be8b58640ae8.png)'
  prefs: []
  type: TYPE_IMG
- en: Our first chart is complete. Now, let's look at weather data along the route.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving weather data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will retrieve our final data element: the weather. As mentioned
    earlier, we will use the Dark Sky service, which allows us to gather historical
    weather reports for any place in the world. The weather API is REST and JSON-based,
    so we''ll use the `urllib` module to request data and the `json` library to parse
    it. Of note in this section is that we cache the data locally, so you can run
    the script offline for testing if need be. Early on in this section is where you
    place your Dark Sky API key that is flagged by the `YOUR KEY HERE` text. Let''s
    have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need the center of our area of interest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we set up the free Dark API key as follows so we can retrieve weather
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we grab the latest timestamp from our data that we''ll use for our weather
    query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to do our weather data query as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll cache the weather data like so just in case we want to look at it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we parse the weather JSON data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need is the weather summary, which is the first item in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll get the specific weather attributes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the weather data stored in variables, we can complete the
    final step: adding it all to a PDF report.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `fpdf` library has no dependencies except PIL in some cases. For our purposes,
    it will work quite well. We are going to proceed down the page and add the elements.
    `fpdf.ln()` separates rows, while `fpdf.cells` contains text and allows for more
    precise layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re finally ready to create our PDF report with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up our `pdf` object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll add a page for our report and set our font preferences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create a title for our report with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the route map like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the elevation chart as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can write the weather data summary with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The Dark Sky terms require us to add a logo to our report, crediting the excellent
    data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add the geolocated image with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we can save the report and view it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have a PDF document in your working directory called `report.pdf` containing
    your finished product. It should look like the image shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccd637ac-85cb-4d2b-937f-c9808a776901.png)'
  prefs: []
  type: TYPE_IMG
- en: With this, we have used all the techniqueswe've learned throughout this book
    and built a GPS reporting tool.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! In this book, you pulled together the most essential tools
    and skills needed to be a modern geospatial analyst. Whether you use geospatial
    data occasionally or use it all the time, you will be better equipped to make
    the most of geospatial analysis. This book focuses on using open source tools
    almost entirely found within the PyPI directory for ease of installation and integration.
    But even if you are using Python as a driver for a commercial GIS package or a
    popular library such as GDAL, the ability to test out new concepts in pure Python
    will always come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python provides a rich set of libraries for visualizing data. One of the most
    prominent is **Matplotlib**, which can produce numerous types of charts and maps
    and save them to PDF. Packt has several books on Matplotlib, including the *Matplotlib
    30 Cookbook*: [https://www.packtpub.com/big-data-and-business-intelligence/matplotlib-30-cookbook](https://www.packtpub.com/big-data-and-business-intelligence/matplotlib-30-cookbook).'
  prefs: []
  type: TYPE_NORMAL
