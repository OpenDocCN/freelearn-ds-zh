- en: Chapter 10. Advanced Geometry Object Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss advanced Geometry object methods, previously
    discussed in [Chapter 6](ch06.html "Chapter 6. Working with ArcPy Geometry Objects"),
    *Working with ArcPy Geometry Objects*. The goal of this book is to give an introduction
    to ArcPy and its modules, while also demonstrating how to apply these tools when
    creating enduring GIS workflows. Performing an analysis once is good, but doing
    it over and over, with the click of a button, is better. Making the analysis results
    sharable in an industry standard format is also desirable. In the ArcGIS world,
    the best way to do this is with ArcPy and script tools that take advantage of
    Geometry object methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding common functions to a module in the Python path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the analysis more advanced by adding point generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Polygon object methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the XLWT to create Excel spreadsheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Python module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important step towards creating reusable code is to package its component
    functions into a module that can be called from the Python path by any script.
    To start, we need to create a folder in the `site-packages` folder where Python
    modules are placed when downloaded and extracted using the Python module process,
    or when running the `setup.py` script included with shared modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modules package together functions in one or more scripts into a folder that
    can be shared with others (though they often depend on other modules to run).
    We have used some of the built-in modules such as the `csv` module and third-party
    modules such as ArcPy. Let's explore their construction to get a feel of how a
    module is packaged for use and sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many modules are not placed within the site-packages folder, but they require
    the Python path to be modified to make them **importable**. Placing modules within
    the site-packages folder eliminates this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the site-packages folder in Windows Explorer by navigating to `C:\Python27\ArcGIS10.2\Lib\site-packages`
    (or `C:\Python27\Lib\site-packages` if you''re using the standard Python 2.7 installation)
    folder. Once in the folder, create a new folder called **common**, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Python module](img/8662OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The __init__.py file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within this folder, a special file needs to be added to let Python recognize
    the folder as a module. This file, called `__init__.py`, takes advantage of the
    special property of Python called `magic` objects or attributes that are built
    into Python. These `magic` objects use the leading and trailing double underscore
    to avoid any confusion with custom functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that these are *double* underscores; single underscores are usually used
    for so-called private functions within custom Python classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__.py` file is used to indicate that the folder is a module (making
    it importable using the `import` keyword), and to initiate the module by calling
    any modules that it may in turn rely on. However, there is no requirement to add
    import commands to the `__init__.py` file; it can be an empty file and will still
    perform the module recognition functionality that we require.
  prefs: []
  type: TYPE_NORMAL
- en: Open up **IDLE** or **Aptana** or your favorite IDE, and in the folder called
    **common**, add a new `Python` file and call it `__init__.py`. This file will
    remain empty for now.![The __init__.py file](img/8662OS_10_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have initiated the module, we need to create a script that will
    hold our common functions. Let's call it `useful.py` because these functions will
    be most useful for this analysis and others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to transfer functions that we had created in earlier chapters.
    These valuable functions are locked into those scripts, so by adding them to `useful.py`,
    we will make them available to all other scripts we craft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: One important function is the `formatSQLMultiple` from [Chapter 4](ch04.html
    "Chapter 4. Complex ArcPy Scripts and Generalizing Functions"), *Complex ArcPy
    Scripts and Generalizing Functions,* which generates SQL statements using a template
    and a list of data. By adding it to `useful.py`, we will be able to call the function
    anytime a SQL statement is required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the script `Chapter4Modified2.py` and copy the function, and then paste
    it into `useful.py`. It has no dependencies, so it does not have to be modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another useful function from that script is the `formatIntersect` function that
    generates a string of file paths that are used when running the ArcToolbox Intersect
    tool. While we have reached deeper into ArcPy since that function was designed,
    and no longer need to call the Intersect tool in our bus stop analysis, it does
    not mean that we will never need to call it in the future. It is still useful
    and should be added to `useful.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function that we can raid is the `createCSV()` function. Copy and
    paste it from `Chapter4Modified.py` into `useful.py`. However, to avoid the need
    to import the CSV module separately, we will need to modify the function slightly.
    Here is how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By importing and then deleting the `csv` module, we are able to use it to generate
    the `csv` file and then remove the module from memory using the `del` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the functions we will be reusing saved in the `useful.py`
    script, inside the common module, let''s explore how to call them using Python''s
    `import` method. Open up a Python executable, using either `Python.exe` or IDLE,
    or the built-in terminal in Aptana. At the triple chevron prompt (**>>>**), write
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the second triple chevron-shaped prompt appears, the function was correctly
    imported from the module. To import the functions in this module in a script,
    use the same import structure and list the functions desired, separating them
    using a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The functions in the script `useful.py` were called using Python dot notation.
    This is made possible because the `__init__.py` file indicates to Python that
    the folder `common` is now a module, and that it should expect a method called
    `useful` to be present, with the functions `createCSV` and `formatSQLMultiple`
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding advanced analysis components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bus stop analysis we have used to introduce ArcPy can be further extended
    to generate more refined results. To better estimate the true number of people
    that each bus stop serves, let's add a function that will generate random points
    within the blocks considered, while eliminating parks and other areas that do
    not contain housing.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to introduce a new data set from the `San Francisco` geodatabase,
    the `RPD_Parks` feature class. By using this feature class to reduce the area
    considered for our analysis, we can generate a more realistic assessment of the
    service area population for each bus stop.
  prefs: []
  type: TYPE_NORMAL
- en: While using the **ArcToolbox Erase tool** to erase the area represented in the
    `RPD_Parks` polygons would be a usual step when running a spatial analysis, there
    are drawbacks to this option. The first is that the **Erase** tool is only available
    with the ArcGIS for Desktop Advanced license level, making it available only to
    certain users. The second drawback is that the tool produces an intermediate data
    set, something to be avoided wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Using ArcPy will give us the ability to avoid both of these drawbacks. We can
    create a script that will generate random points only within the fraction of the
    census block polygons that do not intersect with the `RPD_Parks` feature class.
    To do this, we will reach deeper into the methods of the ArcPy `Polygon` object.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Polygon object methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Working with ArcPy Geometry Objects"),
    *Working with ArcPy Geometry Objects* we started exploring the ArcPy Geometry
    objects and how to use their methods to perform in-memory spatial analysis. The
    **Buffer** and **Intersect** methods of these objects were introduced and used
    to generate analysis results. Next, we will discuss more of these methods and
    show how they can help improve in-memory spatial analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The `Polygon` object has a method called `Difference` that allows us to find
    the area of non-intersection when two polygons intersect. Passing a `census block
    polygon` and a `park polygon` as parameters will return (as a polygon object)
    the fraction of the first parameter where no overlap occurs. Another important
    method is called `Overlaps`, which is called to test whether two Geometry objects
    (points, lines, or polygons) intersect. If there is an overlap, the `Overlaps`
    method will return **True**, while returning **False** if there is no overlap
    between the two objects. `Union` is also an important method that will be used
    within this chapter, it allows for two Geometry objects to be **unioned** into
    one object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore these important methods. To find the non-intersect area of two
    polygon objects, the following function combines the `Overlaps` and `Difference`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `nonIntersect` accepts two `Polygon` objects as parameters. The
    first parameter, `poly1`, is the polygon of intersect (the census block polygon)
    and the second parameter, `poly2`, is the polygon to be checked for overlap. The
    if conditional uses the `Overlaps` method and returns **True** if there is an
    overlap between the two parameters. If there is any overlap, the `difference()`
    method returns the non-intersect area as a polygon object. However, this function
    should be extended to cover situations where the `Overlaps()` method returns False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The function will now return the first parameter when the `Overlaps` method
    returns `False`, indicating that there is no overlap between the two polygon objects.
    This function is now complete and available to be used in an analysis. Because
    `nonIntersect()` is a function that can be used in other spatial analyses, copy
    it and add it to `useful.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating random points to represent population
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step to improve the bus stop analysis is to generate points to represent
    the population of each census block. While random points will not provide a perfect
    representation of the population, it will serve as a good model of the population
    and allow us to avoid area averaging to find the rough population of each census
    block served by a bus stop. The `CreateRandomPoints` tool in the ArcToolbox Data
    Management toolset makes it simple to generate the points.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateRandomPoints` tool accepts a number of required and optional parameters.
    As the tool generates a feature class, the required parameters are the workspace
    where the feature class will be placed and the name of the feature class. The
    optional parameters of interest are the constraining feature class and the number
    of points to be generated. As we are looking to avoid creating new feature classes
    in the intermediate steps of our analysis, we can utilize the `in_memory` workspace,
    which allows feature classes to be generated in memory, meaning they are not written
    to the hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because there is a need to generate a specific number of random points for
    each census block, we should create a function that will accept a constraining
    polygon and population figure that represents each census block. The `in_memory`
    workspace won''t work for every situation, however, so we''ll provide the workspace
    parameter with a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function will create the feature class in the workspace desired and will
    return the path (joined using the `os` module) to the feature class for use in
    the rest of the script. This function is also reusable and should be copied into
    `useful.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the functions within a script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created the functions that will help us to run a more advanced
    spatial analysis, let''s add them to a script along with some `SearchCursors`
    to iterate through the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's review the code, section by section, as that is a lot to take in at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The import portion is where we call the usual modules, arcpy and os, along
    with our custom functions in the common module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As discussed previously, the functions in the `common` module's `useful` method
    are called using the Python dot notation and the `from … import ...` importation
    style, making them available directly. Many functions can be imported on one line,
    separated by commas, or individually as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line, which sets the ArcPy Environment `overwrite` property to `True`,
    is very important because it allows us to overwrite the results of the Create
    random points operation. If the results were not overwritten, the function results,
    which otherwise would use all available memory and cause the script to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to be careful with this overwrite setting because it will allow
    for any feature class to be overwritten. All of our output is in memory and only
    generated for the analysis, so there is little need to worry here, but take care
    to make sure that nothing important is overwritten when running a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next portion is the set of variables that will be used in this script,
    and will initiate the spreadsheet that will be used to collect the results of
    the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The file paths assigned to variables here could be replaced with ArcPy parameters
    if we were to turn this into a script tool, but for now, the hard-coded paths
    are fine. Below the variables, the results spreadsheet is created and the column
    field headers are added.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that the spreadsheet is created using the `wb` mode. This
    mode of binary file opening, known as `wb` (write binary), is used for creating
    a new file. It must be explicitly passed into the `createCSV()` function as the
    default mode parameter is `ab` (append binary), which will create a new file if
    it does not exist, or add to one that already exists (a third binary mode is **rb**
    or **read binary**, which is used for opening an existing file).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few lines make data in the feature classes available in memory. The
    census block data is converted into a `Feature Layer`, while the `RPD_Parks` data
    is read into memory as a list of `Polygon` objects that is then unioned into a
    single, unified `Polygon` object called `parkUnion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By using the `CopyFeatures` tool in the **Data Management** toolset, the `parkGeoms`
    variable is passed a list of the geometries for each row of data in the `RPD_Parks`
    feature class. However, we don't want to have to iterate through the park geometries
    to compare them to each census block, so the `Union` method is invoked to create
    one `Polygon` object from the entire list. By assigning the first member of the
    list to the `parkUnion` variable, and then iterating through the `parkGeoms` list
    to union the other geometries one by one, the result is one `Polygon` object that
    represents all parks within the `RPD_Parks` dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the modules have been imported and the variables have been assigned,
    we can enter the `for` loop of the data access `SearchCursor` to begin the analysis.
    However, we don''t want to run this for all of the bus stops, so we will use a
    SQL statement `where` clause, to limit the analysis to a single bus line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first portion of the iteration involves entering the `for` loop and assigning
    the values of each row to a variable. A `Polygon` object buffer of `400` feet
    is created around the `PointGeometry` object returned by the `SearchCursor`. This
    buffer is then used to intersect with the census blocks `Feature Layer` to find
    and select all of the census blocks that intersect the buffer. To tally the population
    served by each buffer, the variable `totalPopulation` is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the selection has been performed, a second `SearchCursor` can be used
    to iterate through the selected blocks to retrieve their population values and
    `Polygon` objects for random point generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this iteration, once each census block has been retrieved (in the form of
    a Polygon object), the block is then checked against the **unioned** park geometry
    using the `nonIntersect` function created previously. This ensures that the points
    will only be created within areas that are not parks, that is, more likely to
    represent where people would live. The population values are also retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the constraining polygon (for example the census block) has been evaluated
    and any potential park portion has been removed, and the population value is available,
    the random points can be generated using the `generatePoints()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `generatePoints()` function requires three parameters. The first is the
    name of the feature class to be generated; this will be overwritten each time
    it is generated, thus avoiding the overuse of memory by creating an `in_memory`
    feature class for each census block. The other two parameters are the population
    value and the constraining Polygon object.
  prefs: []
  type: TYPE_NORMAL
- en: Once these have been passed to the function, it returns a file path to the newly
    created feature class and assigns the file path to the variable points. The geometries
    in points are then extracted using the `CopyFeatures` tool and assigned to the
    variable `points`. The `Union` method is again used to create a single, unified
    population `PointGeometry` object that will be intersected with the bus stop buffer.
    Once this intersection has been run, the resulting geometries are assigned to
    the `pointsInBuffer` variable and the `pointCount` method is used to find the
    number of points that were generated within the buffered area. This is our estimate
    of population within the census block, and this value is added to the `totalPopulation`
    variable to eventually yield the total estimated population within 400 feet of
    the bus stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final lines of the script demonstrate how the data is collected into a
    tuple and passed to the `createCSV()` module to be written to our final spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The last line, `os.startfile(csvName)`, uses the `startfile` method of the `os`
    module to automatically open the spreadsheet once the analysis is completed. In
    this case, the spreadsheet `C:\Projects\Output\Chapter10Analysis.csv` has been
    populated with the results of the analysis and is opened to display these results.
    However, the user may have to indicate that the lines are comma separated values
    to open the script.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the functions within a script](img/8662OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Instead of creating a comma separated value, we can take advantage of another
    Python module that is installed when ArcGIS 10.2 and ArcPy is installed. This
    module, called `XLWT`, is used to generate Excel spreadsheets, and along with
    the Excel spreadsheet reading module `XLRD`, is one of the most useful modules
    available to users of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an XLS using XLWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XLWT is a powerful module that allows for a multitude of styling options. However,
    for our purposes we can ignore those options and create a function that will generate
    a spreadsheet with the results of our spatial analysis. This function can of course
    be added to `common.useful`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function requires three parameters, `indatas`- a list containing rows of
    iterable data, a string sheet name, and a string file name that ends with the
    `.xls` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this function, add it to `common.useful`. Once it has been added, copy
    and rename the older analysis script so that it can be adjusted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can now generate Excel spreadsheets just as easily as we have generated `CSV`
    files while employing a reusable function. We now have the ability to perform
    repeatable spatial analysis fast and can produce results in industry standard
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored how to create modules and reusable functions
    that will save scripting time in the future by allowing us to avoid rewriting
    these useful functions. We further explored the methods available through ArcPy
    Geometry objects, including the `Intersect`, `Overlaps`, and `Union` methods.
    We created a spatial analysis that writes no feature classes to disk, making it
    so that the analysis time is reduced and unnecessary files are avoided. Finally,
    we explored how to generate Excel spreadsheets using the `XLWT` module so that
    analysis results can be shared in industry standard formats.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to use ArcPy to interact with the ArcGIS
    for desktop extensions such as Network Analyst and Spatial Analyst. By incorporating
    their functionality within a script, we further increase our ability to create
    fast and repeatable spatial analysis workflows.
  prefs: []
  type: TYPE_NORMAL
