- en: Understanding Simple Calculations in Tableau
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Tableau中理解简单计算
- en: In the previous chapters, you have learned much about visualizing data in various
    forms in Tableau. It is common to have cases where the data you want to visualize
    is not directly present in your dataset but can easily be obtained by applying
    transformations on the dataset or even aggregating the data in the dataset. For
    example, you may have the full address for a placed order, and you want to obtain
    only the country or city where the order came from. Alternatively, you may have
    data for each individual sale and you want to know the average of all sales. This
    and the subsequent two chapters will focus on calculations and how you can use
    these to answer such questions. This chapter will introduce calculations and cover
    simple calculations, while the next two will look at more advanced calculations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经学习了在Tableau中用各种形式可视化数据。通常情况下，你想要可视化的数据可能不会直接出现在你的数据集中，但可以通过对数据集应用转换或甚至聚合数据集中的数据来轻松获得。例如，你可能有一个订单的完整地址，但你只想获取订单来自的国家或城市。或者，你可能拥有每个单独销售的详细数据，你想知道所有销售的平均值。接下来的两个章节将重点介绍计算以及如何使用这些计算来回答这样的问题。本章将介绍计算，并涵盖简单计算，而下一章将探讨更高级的计算。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Calculation basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算基础
- en: Creating calculations and understanding their components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计算并理解其组件
- en: Building arithmetic calculations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建算术计算
- en: Building string calculations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建字符串计算
- en: Building date calculations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建日期计算
- en: Building logical statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建逻辑语句
- en: Building grand totals and subtotals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建总计和子总计
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter uses the following dataset:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用以下数据集：
- en: The Global Superstore dataset, which can be found at [http://www.tableau.com/sites/default/files/training/global_superstore.zip](http://www.tableau.com/sites/default/files/training/global_superstore.zip).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全球超级商店数据集，可以在[http://www.tableau.com/sites/default/files/training/global_superstore.zip](http://www.tableau.com/sites/default/files/training/global_superstore.zip)找到。
- en: Calculation basics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算基础
- en: Calculations allow us to obtain more data points from the existing dataset and
    allow us to enhance our visualizations and analysis. Creating calculations in
    Tableau enables you to analyze data on the fly, without having to create overheads
    by transforming your original datasets every time you have a new idea about how
    you can analyze your data even further.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 计算使我们能够从现有数据集中获得更多数据点，并允许我们增强我们的可视化和分析。在Tableau中创建计算可以使你即时分析数据，无需每次有关于如何进一步分析数据的想法时都创建额外的数据集。
- en: When to use calculations
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用计算
- en: 'Before we dive into calculations and how to create them, it is equally important
    to understand when to create calculations. Some examples of when calculations
    are useful are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨计算及其创建方法之前，同样重要的是要了解何时创建计算。以下是一些计算有用的例子：
- en: '**Changing datatypes**: For example, you have data that is being represented
    as a string value.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改数据类型**：例如，你有的数据被表示为字符串值。'
- en: '**Performing mathematical calculations**: For example, you want to divide two
    fields to obtain ratios or percentages or subtract fields.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行数学计算**：例如，你想要将两个字段相除以获得比率或百分比，或者从字段中减去。'
- en: '**To create logical groupings/labels**: For example, if you want to group people
    in those who can drive or not, you can create a calculation saying: if you are
    older than 18 and have a valid driving license, you can drive.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建逻辑分组/标签**：例如，如果你想将人们分为能开车和不能开车两组，你可以创建一个计算公式说：如果你年满18岁并且拥有有效的驾驶执照，你就可以开车。'
- en: '**To create new fields from existing data**: For example, you want to create
    a country field by extracting a part of the address or a new date field from another
    date field.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从现有数据创建新字段**：例如，你想要通过提取地址的一部分来创建国家字段，或者从一个日期字段创建新的日期字段。'
- en: '**Aggregating data**: For example, you want to view the sum, average, and median
    of distribution or subtotals and totals at the country and city levels for sales.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合数据**：例如，你想要查看分布或国家/城市级别的销售的总和、平均值和中位数。'
- en: Now that we understand when to use calculations, we can discuss the three types
    of calculations available in Tableau.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了何时使用计算，我们可以讨论Tableau中可用的三种计算类型。
- en: Types of calculations
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算类型
- en: '**Simple calculations**: These calculations allow you to create new fields
    at either the same level of granularity as your dataset (row-level) or aggregate
    data at the granularity of the visual.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level Of Detail (LOD) expressions**: LOD calculations are an extension of
    simple calculations but allow you to have more control over the granularity of
    the data you are working on. You have options to work to specify a FIXED level
    of granularity or INCLUDE data fields to the visualization granularity or EXCLUDE
    them.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table calculations**: Table calculations only work at the level of granularity
    of the visuals. These allow you to build calculations at visual levels of top
    of your existing data or simple calculations.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of calculation you require will depend on the use case of your problem.
    If you already have all of the data you want to answer the questions, then you
    need table calculations. If you do not have all of the data you need, but the
    data needed will be at the same granularity as your dataset, you will need a basic
    calculation. Otherwise, it will be a LOD calculation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry if you are a bit confused about the types of calculations. We will
    cover each type in detail in separate chapters. This chapter will cover simple
    calculations in detail while the next two will cover the other two calculation
    types. So, let's look at how to create simple calculations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Creating calculations
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a calculation, click on **Analysis** | **Create Calculated Field**.
    Alternatively, you can scroll to the end of dimensions/measures tabs and right-click
    in the white space there.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following calculations window:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14c57d5b-0278-4d24-a661-b18a0da00be4.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: The top of the window, where it says `Calculation1`, is where you enter the
    name of your calculated field. The blank area underneath is where you enter your
    calculation. To the right side, you have a list of all of the available functions
    you can use and their syntax to quickly help you out. The tiny triangle icon to
    the right of the calculation editor can be used to toggle the functions window
    in/out.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a very simple calculation to see what our total profit would
    be if the average profit increased four times, and name this calculation `4x Profit`,
    as shown in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2154dc36-c4f1-4c5e-941f-30dd72111f41.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: You will see, at the bottom of the calculation, the message: **The calculation
    is valid**. This means we can now click **OK** and the field will be created.
    The error checker in Tableau quickly displays error messages below if the calculation
    is invalid, allowing for easy troubleshooting.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click **OK**, you will notice the field appears under **Measures**.
    Now, you can use this calculation as you would any other measure. Let''s use it
    to show the results per **Segment**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a29046db-8ca1-4507-9b62-a4153a30226a.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'Like the previously discussed calculation, all calculations in Tableau can
    be a combination of six basic elements. These elements are described in the following
    table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '| **Components** | **Description** | **Example** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| Functions | Functions are used to transform the values or members of a field.
    There are many types of functions available in Tableau such as `Number`, `String`,
    `Date`, and `User`. Different functions have different syntax, inputs/data type
    expected, and so on. | In our example, `AVG()` was an example of a function. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| Fields | Fields represent the dimensions or measures (columns) from our data
    source. | `[Profit]` was the field used by us. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| Operators | Operators are symbols that denote some kind of operation. Operators
    can be one of the following: +, -, *, /, %, ==, =, >, <, >=, <=, !=, <>, ^, AND,
    OR, NOT, and ( ). | * in our example was the operator. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| Literal expressions | These are constant values that do not change. These
    can be either Numeric, String, Date, Boolean, or Null. | 4 was the literal used
    by us. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| Parameters | Parameters, as we know, are dynamic values that can replace
    literals. These too can be used in the calculations. |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| Comments | Comments are simple descriptions that you can add to the calculation
    fields. These are informational only and do not affect the actual calculation.
    The `//` symbols are used to add comments. | We didn''t add a comment to our example,
    but we could have added something like `// To create 4 times profit value`. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: Using the preceding combination of six elements, all calculations are created.
    Now that we understand the components better, we can look at the syntax of each
    component in detail in the following sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Functions syntax
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many types of functions available in Tableau, such as `Number`, `String`,
    `Date`, and `User`. Different functions have different syntax and require different
    inputs for them to work. The list of all of the functions available to you in
    Tableau is available in the side tab of the calculated field window. Select `AVG()`
    from the functions list. Once you select any function, you will see three elements
    in the help window:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfbd0dcc-45fd-4a84-a6f7-52ee74cf4010.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'These elements are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax of the function: For `AVG`, it shows **AVG(expression)**, meaning that,
    to obtain the average, you need to write AVG(expression here).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explanation: Below the syntax, there is an explanation of what the function
    does.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: This is an example of how the function can be used.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unsure of how to use a function, copy and paste the example, and
    then replace the fields in it with your own fields. This ensures that the syntax
    remains correct.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: You can use more than one function in a calculation and even nest them inside
    one another as long as they meet the syntax requirements. We will learn about
    some of the common types of functions later in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Fields syntax
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fields are the columns in the data (and can be calculated fields too). A field
    should always be surrounded by square brackets, `[]`, if they contain spaces or
    are not unique in name. It is best practice to surround fields with `[]`. Fields
    are shown in orange in Tableau. You can drag and drop the field directly into
    the calculation from the **Dimension** or **Measures** tabs. Alternatively, you
    can start typing the field name and Tableau will show you options to autocomplete
    fields, as shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29da1d43-a473-4afe-9c49-f80356ab1984.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Operator syntax
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operators are symbols that denote some kind of operation. Operators can be
    of the following types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematical operators: Mathematical operators are used for performing mathematical
    calculations. The operators are as follows:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**+ (plus)**: Plus can be used for addition (numeric and date fields) and string
    concatenation. For example, `4+2` will return `6` while `Abc` + `Def` will return
    `AbcDef`. We can use addition for dates as well, for example, adding `#23-04-2019#+4`
    will give `#27-04-2019#`.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**- (minus)**: Minus can be used for the subtraction of dates and numeric fields,
    in a similar way to the + operator.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*** (multiplication)** and **/ (division)**: This is used to multiply or divide
    numeric fields.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**% (modulo)**: This returns the remainder of a division operator, for example, `5%2=1`.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**^ (power/exponent):** This returns the exponent value, for example, `2^3
    =8`.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relational operators: These are used for comparing expressions and return `TRUE`,
    `FALSE`, or `NULL` values. Each operator can be used to compare numbers, dates,
    or strings. The operators are as follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**== or = (equals)**'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**> ( greater than) **'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**< (less than)**'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**>= (greater than or equal to)**'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<= (less than or equal to)**'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**!=** and **<> (not equal to)**'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logical operators: Logical operators compare both sides of the expression and
    return `TRUE`, `FALSE`, or `NULL` values. The logical operators are as follows:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AND**: If both expression 1 and expression 2 are `TRUE`, then it returns
    `TRUE`; otherwise, it returns `FALSE`. If any of the expressions are `NULL`, then
    it returns `NULL`. `AND` follows the following rules for output:'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Expression 1** | **Expression 2** | **Output** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `TRUE` | `TRUE` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `FALSE`/`NULL` | `TRUE` | `FALSE`/`NULL` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| `FALSE`/`NULL` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '**OR:** `OR` returns `FALSE` only if both the expressions are `FALSE`; otherwise,
    it will return `TRUE`. It returns `NULL` only if both values are `NULL`. It follows
    the following rules for output:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Expression 1** | **Expression 2** | **Output** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `TRUE` | `TRUE` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `FALSE`/`NULL` | `TRUE` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `FALSE`/`NULL` | `TRUE` | `TRUE` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `FALSE`/`NULL` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '**NOT:** `NOT` is used to negate other Booleans or expressions. It follows
    the following rules of output:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Expression 1** | **Expression 2** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `FALSE` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| `FALSE` | `TRUE` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: Order of precedence of operators
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The operators get evaluated in the following order of precedence:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`–` (negate)'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`^` (power)'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`*`, `/`, `%`'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`+`, `–`'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`==`, `>`, `<`, `>=`, `<=`, `!=`'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NOT`'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AND`'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OR`'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To change the order of precedence, we can use the final operator called parentheses, `()`.
    If you put something in parentheses, it gets executed first. If there are nested
    parentheses, then the innermost gets executed first and so on, for example, if
    we had the following expression to get evaluated: `(1+2*5) = 11 , (1+(2*5)/2)
    = (1+10/2) =6`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Literal expressions syntax
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Literal expressions are constant values that are represented as is. Literals
    are of the following types:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**Numeric literals**: Numbers or floats such as `4.2` and `2`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String literals**: Constant strings such as `Hello`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date literals**: Represent dates as constants, such as `#20-05-2019#`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean literals**: Represent Boolean values of `TRUE` or `FALSE`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Null literals**: Used to assign or compare against `NULL`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter syntax
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameters are simply placeholder variables. Parameters are represented with
    the color purple in Tableau. They can represent numbers, floats, strings, date/date-time
    values, or Booleans.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Comments syntax
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments are represented using `//`. To add multiline comments, add `//` in
    every line.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand all about the basic elements of what constitutes calculated
    fields and how to create them, let's dive into some calculations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Building arithmetic calculations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with arithmetic calculations in Tableau, we can either use operators
    as discussed in the last section, work with one of the many **number functions**
    that are present, or make use of some of the **aggregation options**. This section
    will cover some of the important functions but it is not an exhaustive list. The
    *Further reading* section contains links to an A-Z list of functions maintained
    by Tableau.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation options
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregation options define how your data values are combined or aggregated.
    Simple aggregation works at the level of visual granularity.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is the data is aggregated at the level of the dimensions in
    the visual. Without even studying it, we have used this logic in the previous
    chapters when we created visuals. Whenever we wanted to see the total **SUM(Sales)**,
    we would only bring the **SUM(Sales)** measure to our visual window. However,
    if we wanted to see the sales per segment, we would add the **Segment** dimension
    to our window and our sales would split up, as can be seen in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2754ca91-c279-4005-8160-28ab086f57c9.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'This same principle works with all the aggregations. To see the aggregation
    levels available, right-click on the measured field, select **Measure** (aggregation
    level) and it will show you what other options are available. For example, by
    right-clicking on the **SUM(Sales)** measure field, the following aggregation
    levels are available:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1933a496-7590-44a0-a4e9-9d507129ac4c.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Similarly, if you want to use a dimension field to represent a measure value,
    you can bring it into the visual and right-click and select **Measure**, and then
    it will show the aggregation options available for the dimension.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming a column in our dataset looks like `1, 1, 1, 2, 2, 3, 4`, the various
    aggregation options and their results are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sum** | This adds the measure values, calculated by adding values = `1+1+1+2+2+3+4
    = 14`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| **Average** | This is the average of the measure values, calculated by adding
    values divided by the count of values = `14/7 = 2`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| **Median** | This is the central value = `2`. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| **Count** | This simply counts the number of elements = `7`. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| **Count** **(Distinct)** | This is the count of distinct values, so no same
    value is counted more than once = `4`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| **Minimum** | This the least value = `1`. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| **Maximum** | This is the highest value = `4`. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| **Percentile** | This shows what percentage of the values are less than this
    value. It has further options to look at the 5, 10, 25, 50, 75, 90, and 95 percentiles.
    Here, the 25^(th) percentile would be 1, the 75^(th) percentile would be 3, and
    so on. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| **Standard Deviation**, **Standard Deviation(Pop)** | Standard deviation
    defines how much of the members are differing from the mean value. If you have
    an entire dataset, use the standard deviation population; if it is a sample, then
    use standard deviation. **Standard deviation (Pop) **= `1.07` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| **Variance**, **Variance (Pop)** | Variance is the square of standard deviation,
    so depending on population or sample, we use variance = `1.14` for this case.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: The aggregations calculated in Tableau are sent back to the databases for querying.
    So, the general rule of thumb is if the database doesn't support a particular
    aggregation, Tableau will not be able to support it either. However, if you create
    extracts of the same data, then the aggregation will be supported.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, look at all of the aggregation options for the `Profit` measure and
    the `Customer Name` dimension.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: By simply using a combination of the preceding aggregation options and operators,
    many important calculations can be done. For example, `Cost` can be determined
    as `[Sales]-[Profit]`. Then, the average cost can be found with `AVG(Cost)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We can also calculate the `Profit to Sales` ratio as `SUM(Profit)/SUM(Sales)`.
    This will show up in decimals. To see it as a percentage, one way would be to
    multiply the calculation by 100\. However, this will not show the `%` sign. To
    show the percentage sign, we need to format the results as a percentage. To do
    this, right-click on **Measure** and select **Format**. A side window will appear.
    Here, under **Default**, click on **Numbers** and then **Percentage**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: You can also include other things such as a suffix/prefix by using custom options.
    Once you are happy, you can close the side window.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the aggregations and operator use, we can look at other number functions
    available. They can be logically grouped into the following categories:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigonometric functions**: These include the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '| `PI` | This returns the numeric constant value for pi, as 3.141592…., up
    to 16 decimal places. `PI()` is generally used within other trigonometric functions
    to specify the angles in radians. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `SIN` | This returns the sine of an angle. The angle must be specified in
    radians, for example, `SIN(-PI()/4) =-0.7071`. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `ASIN` | This returns the arc sine of a number in radians. This is the inverse
    of `SIN`, for example, `ASIN(-0.7071)=-0.7854` (which is *-pi/4*). |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `ATAN2` | This takes the two coordinate positions *y* and *x* as input and
    returns the arc tangent of two numbers in radians, for example, `ATAN2(1,1) =
    0.7854 i.e pi/4` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `DEGREE` | This converts radians into degrees, so `DEGREE(0.7854) =45`..
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '** The COS, ACOS, TAN, ATAN, and COT functions are similar to SIN and ASIN.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Logarithmic and exponential functions**: These include the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '| `EXP` | This returns *e* raised to the power of a number, for example, `EXP(2)
    = e^2`. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `LN` | This returns the natural logarithm of the number. The value is null
    for all zero and negative values, for example, `LN(2) = 0.69` or `LN(EXP(2))=2`.
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `LOG` | This returns a logarithmic value to the base of another number. If
    no base is specified, then it returns a logarithmic value to the base of 100,
    for example, `LOG(1000) = 3` and `LOG( 4,2) = 2`. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `POWER` | This returns a value to the power of another, for example, `POWER
    (2,3) =2^3= 8`. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '**Other mathematical functions**: These include the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '| `SQUARE` | This returns the square of a number and is equivalent to `Power
    (number, 2)`, for example, `SQUARE(5) = 25`. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `SQRT` | This returns the square root of a number and is equivalent to `Power
    (number, 0.5)`, for example, `SQRT(25) =5`. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `ABS` | This returns the absolute value of a number, for example, `ABS(-7)
    =7`. It''s very useful when you work with quantities or deviations where the actual
    values are more important than the sign of the numbers. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `CEILING` | This rounds a number to the nearest integer greater or equal
    to the number. This is useful when doing capacity planning kind of problems, for
    example, if you had to assign resources to a project to get work completed and
    the result was `3.2`. If you simply round the number, your result would be `3`.
    But you actually have more work, so it makes more sense to have four resources
    than three and plan based on that, for example, `CEILING(3.2) = 4`. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `FLOOR` | `FLOOR` does the reverse of `CEILING`. It returns the greatest
    integer smaller or equal to the given number, for example, `FLOOR(3.2) =3`. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `ROUND` | This rounds the number to the nearest integer or the specified
    decimal values, for example, `ROUND (3.2)=3`, `ROUND(3.7) = 4`, and `ROUND(3.1421,2)
    = 3.14`. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `SIGN` | This returns the sign of the number, 1 if positive, 0 if zero, and
    -1 if negative, for example, `SIGN(-3)=-1` and `SIGN(4) =1`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `ZN` | This returns the expression if it is not null; otherwise, it will
    return 0\. This is useful if we want to calculate averages, without ignoring `NULL`
    or to display 0s instead of nulls.  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `DIV` | This returns the quotient of a division operation, for example, `DIV(7,2)
    =3`. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| `HEXBINX`, `HEXBINY` | Both of these functions are used to map an *x*, *y*
    coordinate to the nearest hexagonal bin. `HENBINX` maps to the nearest *x *coordinate
    while `HEXBINY` maps the nearest *y *coordinate. The bins have side length 1,
    so the inputs need to be scaled accordingly.  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: Now that we are familiar with the various aggregation options and number functions
    that can be used to create numeric calculations, let's move on to the next section
    where we will learn about string calculations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Building string calculations
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to numeric calculations, many string functions exist to allow for various
    calculations. Let's look at some of the key string calculations and how they can
    be used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Functions related to obtaining substrings from a string
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common use cases when dealing with strings is that we want only
    parts of the string and not all. Many functions help us to do that. Let's have
    a look at what functions we can use.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '`LEFT`: This follows the syntax `LEFT (string, num_chars)`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Using `LEFT`, the `num_chars` specified starting from the start of a string
    is returned. This becomes very useful for grouping.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we want to find the customers who have ordered the most, based
    on what letter their name starts with. We could create a calculation as follows: `LEFT([Customer
    Name,1)`. This will return only the first character of the string. We can then
    use this and count the number of orders to clearly see which category ordered
    the most:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b5a7abc-05f4-48b0-818c-8fbcd7ee0068.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: '`RIGHT`: This follows the syntax `RIGHT(string, num_chars)`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Using `RIGHT`, the `num_chars` specified starting from the end of a string is
    returned.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the first example, if you wanted to find the last letter of the names
    of the people who ordered, you would use `RIGHT([Customer Name,1).`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '`MID`: This follows the syntax `MID (string, start, [length])`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: It returns the characters from `string`, starting from the position specified
    by the start value. The first character of the string has the starting position
    of 1\. `length` is optional to specify, and if it is specified, it will return
    up to that many characters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`SPLIT`: This follows the syntax `SPLIT (string, delimiter, token number)`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we don't know the exact position we want to create a substring from
    but might have a delimiter to specify it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: For example, in our dataset, we have a customer full name, so what if we only
    wanted to obtain the first name? We know the names are in the format of **First
    Name** followed by space character and then **Middle** + **Last** **Name**. So,
    our delimiter is `" "`. Based on the delimiter, your string is divided into equal
    tokens.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the string was `Alex Young`, your string would be broken by
    the delimiter into two strings. Token 1 would be `Alex`, and Token 2 would be `Young`.
    So, `SPLIT("Alex Young", " ",1)` would return `Alex`, while `SPLIT ("Alex Young","
    ",2)` would return `Young`. If you use negative numbers, it counts from the right
    in a string. So, `SPLIT("Alex Young"," ", -1)` would be `Young`, and `SPLIT ("Alex
    Young"," ",-2)` would be `Alex`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to our example—if we wanted to find the **First Name** of our customers,
    we would create a calculation as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abe84fbe-c819-4809-b979-1fae83f4e336.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Now, we count the people with that as their first names, to find the most popular
    names, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/596825ed-0941-487d-98f8-abb5882193b5.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: This first logical subset of string functions allows us to obtain substrings
    from a string. In the next section, we shall learn about functions that deal with
    the position of occurrence or existence of a substring within a string.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Functions related to finding a substring within a string
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we don''t want to obtain substrings, but just check whether certain
    substrings exist in strings or even obtain their position of occurrence. For this,
    the following functions are useful:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTAINS`: This follows the syntax `CONTAINS(string, substring)`. `CONTAINS` returns
    true if the string contains the substring within it, for example, `CONTAINS("Tableau",
    "Table") = TRUE`. For example, to find how many people have names containing the
    letter `E`, we can then create the calculation as `CONTAINS([Customer Name],"e")`
    and see the count of `TRUE`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENDSWITH`:This follows the syntax `ENDSWITH(string, substring)`. This returns
    true if the string ends with the substring provided, and trailing white spaces
    are ignored, for example, `ENDSWITH("hello", "lo")=TRUE`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIND`: This follows the syntax `FIND (string, substring, [start])`. It will
    return the position of the string within a substring. If a start position is specified,
    then it starts searching for the substring after the start position. For example,
    `FIND("hello","lo")` would return `4`.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FINDNTH`:This follows the syntax `FINDNTH(string, substring, occurrence)` and
    returns the *n*^(th) position of the *n*^(th) occurrence of a substring with a
    string. For example, if a string is `abcabcabc` and we want to find the third
    occurrence of `abc` in the string, we would find it using `FINDNTH("abcabcabc"."abc",3)`.
    It will return `7`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STARTSWITH`: This follows the syntax `STARTSWITH(string, substring)`, similar
    to `ENDSWITH`. This displays true if the string starts with the other substring,
    for example, `STARTSWITH("hello","he")=TRUE`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions related to formatting/standardizing a string
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, strings do not all follow a consistent format. There could be leading
    or trailing spaces in strings or them having different cases. All of these will
    lead to the strings to be considered distinct and separate. For example, if there
    was a string called `book` and another string called `BOOK`, they would be considered
    different. Using the following functions, we can standardize the string in our
    dataset:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '`LOWER`: This follows the syntax `LOWER(string)`. It will return the string
    in all lowercase, for example, `LOWER("Book") = book`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPPER`: This follows the syntax `UPPER(string)`. It will return the strings
    in all uppercase, for example, `UPPER("Book")= BOOK`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRIM`: This follows the syntax `TRIM(string)` and removes both leading and
    trailing spaces from a string, for example, `TRIM("    Book    ") = Book`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to `TRIM`, there are `LTRIM` and `RTRIM`, which follow the same syntax
    but only remove spaces from the left of the string or the right of the string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Other important string functions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LEN`: This follows the syntax `LEN(string)`. Length is used to find the number
    of characters in a string. It counts the number of spaces as a character within
    a string. For example, `LEN("Hi There")` is 8: 2 for `Hi`, 1 for space, and 5
    for `There`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPLACE`: This follows the syntax `REPLACE(string, substring, replacement)`. `REPLACE` is
    used to replace every occurrence of the substring in a string with the replacement,
    for example, to replace occurrences of special characters such as `/` or `''`
    in the string, such as `Replace([Customer Name],"/","")`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another example would be if someone changed their name. You could replace their
    name with the new one. Let''s replace Aaron Bergman''s name with `Aaron B`. Create
    a new calculation using `REPLACE` as follows: `REPLACE([Customer Name], "Aaron
    Bergman", "Aaron B")`. The result of this calculation can be seen in the following
    screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/390e1bee-9ce8-4c9a-beff-7a6a87442834.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Now that we have made ourselves familiar with the important string calculations,
    let's look at date calculations in the next section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Building date calculations
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Date calculations allow us to perform operations on dates, such as adding or
    subtracting dates and obtaining parts of dates. Let's look at some of the key
    functions in the following sections.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the current date/time
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Today()` returns the current date in Tableau and `NOW()` can be used to return
    the current date-time. A common use case of this is to find the time taken between
    an event occurrence and today.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining parts of a date
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DAY()`, `MONTH()` and `YEAR()`: They share the syntax of function (date). They
    can be used for obtaining the day, month, and year part of the date as integers
    respectively. For example, `DAY(#24-05-2019#)` returns `24`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATEPART`:It follows the syntax: `DATEPART(date_part,date,[start_of_week])`.
    If the start of the week is not mentioned, then it is determined based on the
    start day defined in the data source. For example, `DATEPART(week,#24-05-2019#)`
    returns `21`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATENAME`:The syntax remains the same as `DATENAME` as `DATEPART(date_part,date,[start_of_week])`.
    It is very similar to `DATEPART`. The key difference is that it will return the
    values as a string. For example, `DATENAME("month",#24-05-2019#)` returns `May`.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATETRUNC`: The syntax is the same as `DATEPART` and `DATENAME`, as follows: `DATETRUNC(date_part,
    date,[start_of_week])`. It allows us to not just obtain a `date_part` but rather
    truncate the date to that `date_part`. The syntax is the same as `DATEPART` and
    `DATENAME`, as follows: `DATETRUNC(date_part, date,[start_of_week])`. For example,
    `DATETRUNC("month",#24-05-2019#)` returns `01-05-2019 00:00:00`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other date calculations
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ISDATE`: This follows the syntax `ISDATE(string)`. It returns `TRUE` if the
    string is a date otherwise, it returns `FALSE`, for example, `ISDATE("24-05-2019")=
    TRUE`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATEPARSE`: This follows the syntax `DATEPARSE(format, string)`. It is used
    to convert a string into `DATE` in the format specified. For example, `DATEPARSE("dd-MM-yyyy","24-05-2019)`
    returns `24-05-2019` as a date.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATEADD`: This follows the syntax `DATEADD(date_part, interval, date)`. It
    adds the interval to `date_part` specified of the date. `DATEADD` is one of the
    most commonly used date functions.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose there was an issue in the system and all of the order dates captured
    were wrong. They were actually a month before they are showing in the calculation.
    To get the right order dates, we create a calculation for `Correct Order Date`
    as `DATEADD("month",-1,[Order Date])`. Now, if we place the dates next to each
    other, we will obtain the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e09da0b5-97f8-403b-95c9-1dd43e761607.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: '`DATEDIFF`:This follows the syntax `DATEDIFF(date_part, start_date,end_date,[start_of_week])`.
    It returns the difference between the two dates in terms of the units of `date_part`.
    For example, if we wanted to calculate the time to ship orders after they are
    ordered in months, we can calculate `Shipping Time` as `DATEDIFF("month", [Order
    Date],[Ship Date])`. Once created, if we look at the total time spent in months
    across all shipping categories, we get the following:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4e1898db-aedb-4bb5-90c6-207558a0a6cf.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: As you can see, same-day delivery is super-fast, so even after combining all
    of the orders, shipping only took 2 months. On the other hand, 4,489 months was
    spent in shipping orders by standard class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In the past few sections, we have covered numeric, string, and date calculations.
    In the next section, we will focus on building logical statements. Logical statements
    work with numbers, strings, and dates and can be used in combination with the
    calculations we have learned so far.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Building logical statements
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logical functions allow you to check conditions and see whether they are true
    or false. We will take a look at the various categories of logical functions over
    the coming sections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Case statements
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Case statements make use of the following syntax: `CASE <expression> WHEN <value1>
    THEN <return1> WHEN <value2> THEN <return2> ... ELSE <default return> END`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In case statements, the value of the expression is matched to each of the values
    and whenever a match is found, the return value corresponding to it is returned.
    If no value matches the expression, then the default else value is returned. If
    there is no default value, null values will be returned.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Case statements are very useful when you have to compare the same expression
    against multiple values. An example would be if we wanted to assign numbers to
    some of the markets. We can create a calculation as shown in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5a1ed5e-f31e-46f5-872f-b25501705a18.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we place both Market and Market Number next to one another, we can
    see the groups:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a77c50cb-7172-4988-b529-9e79847920c5.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: As an independent exercise, create a case statement giving each day of the week
    a number.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: IF statement
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IF statement has the following syntax: `IF <expr> THEN <then> [ELSEIF <expr2>
    THEN <then2>...] [ELSE <else>] END`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Using an `IF` statement, we can test a series of conditions, and based on whether
    the condition is true, the values are returned; otherwise, the next condition
    is tested. This continues until no condition is true, in which case, the default
    condition's value is represented; otherwise, it is returned. If there is no default
    condition, then null is returned.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Within `IF` statements, multiple conditions can also be combined using `OR`
    and `AND` operators.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to group sales into categories of high, medium, and
    low, we could create a calculation such as the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e0c8024-46df-42fe-aa0d-4934d877f743.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Here, you can see we have grouped any sales that are greater than 0 and less
    than 1,000 dollars as being in the category of low, anything up to 2,000 dollars
    is medium, from 2,000-10,000 is high, and all other values we assume are potential
    errors, either from the sales value being too high or being under 0, which we
    might need to recheck.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, counting the number of order IDs by each **Sales Group**, we can see that
    the bulk of the orders are for the **Low** category, followed by the **High**
    category, and there are only five potential error cases, as shown in the following
    screenshot:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c4b3983-6726-4654-9ea4-7358e8b6f37a.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: As an exercise, create similar calculations for the profit ranges.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: IIF
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IIF` is similar to `IF` for one condition. It follows the syntax: `IIF(test,
    then, else, [unknown])`. Here, it will test a condition and if the condition is
    true, the statement returns the then value; otherwise, it returns the else value.
    If the else value is not specified, `NULL` will be returned, for example, `IIF([Sales]>0,"Valid","Invalid")`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: IFNULL and ISNULL
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `IFNULL` and `ISNULL` are used to test whether an expression is null or
    not.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**IFNULL**: It follows the syntax: `IFNULL(expr1,expr2)`, and it returns expression
    1 if the value is null and expression 2 if it is not. For example, `IFNULL([Sales],0)`
    will return the value of `Sales` where it is not null, else return 0.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**ISNULL**: `ISNULL` follows the syntax: `ISNULL(expr)`. It returns `TRUE`
    if the expression is `NULL`. For example, `ISNULL([Sales])` will return true if
    `Sales` is null.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Other functions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the functions discussed so far, there are some other important functions
    that are useful and available in Tableau. One of those is the type conversion
    functions. Type conversion functions are useful for converting one data type into
    another, for example, from an integer into a string or from a float into an integer.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following functions follow the common syntax of `Function(expression)`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '| `DATE` | It is used to obtain a date from numbers or strings or date expressions,
    for example, `DATE("25/05/2019")` returns `#25-05-2019#`. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| `DATETIME` | Very similar to `DATE`, this function returns the date and time,
    for example, `DATETIME("25 May 2019 13:40:00")` returns `#25-05-2019 13:40:00#`.
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| `FLOAT` | This is used to cast to floating-point numbers, for example, `FLOAT(2)=2.000`.
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| `INT` | This is used to cast its argument to integers, for example `INT("22")=22`
    or `INT(22.2)=22`. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| `STR` | This is used to cast values to a string, for example, `STR(22)` results
    in a string, `22`. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: For example, if there is number field `12` and another number field, `22`, and
    we want to obtain the concatenated field `1222`, we can convert them into strings
    and back into numbers as `INT( (STR(12)+STR(22))` and it will return `1222` as
    a number. Type conversions can help many times when we need to create complex
    calculations and need the output of one field to be in the correct format to be
    the input of another.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: User functions are another set of useful Tableau functions. These are useful
    to create row-level filters and security to limit the fields that are visible
    if your dashboard is published to Tableau Online or Server. Tableau also allows
    for some regular expression functionalities in functions such as `REGEXP_MATCH`
    or `REGEXP_EXTRACT`, which can be used to create some advanced string matching.
    Also, in the next chapter, we will study some advanced table calculation functions
    that haven't been discussed so far.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: One last thing we will discuss in this chapter will be totals and subtotals
    and how they can be used.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Building grand totals and subtotals
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond showing the values from calculations, sometimes, we also want to show
    the values of the totals or subtotals in the same window as these values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示计算值之外，有时我们还想在相同窗口中显示总计或子总计的值。
- en: 'For instance, we have the following graph for SUM(Sales) split by Category
    and Sub-Category across segments:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有以下图表，按类别和子类别分段显示SUM(Sales)：
- en: '![](img/61d70d88-a643-4f54-9b81-2b630fd05756.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61d70d88-a643-4f54-9b81-2b630fd05756.png)'
- en: 'Now, if we want to add the subtotals and the grand totals for both rows and
    columns, we can do the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想为行和列添加子总计和总计，我们可以执行以下操作：
- en: Go to **Analysis** > **Totals**.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**分析** > **总计**。
- en: 'Select Show Row Totals | Show Column Totals. This will show the graph as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择显示行总计 | 显示列总计。这将显示如下图表：
- en: '![](img/8f31b197-3b98-4a23-a315-2f98a7f8f769.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f31b197-3b98-4a23-a315-2f98a7f8f769.png)'
- en: 'Now if we want to see the subtotals too, we can select **Add All Subtotals**
    from Analysis | Tools. This will show the following:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想看到子总计，我们可以从分析 | 工具中选择**添加所有子总计**。这将显示以下内容：
- en: '![](img/8f29d18d-1f37-4483-b521-3d6475698c23.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f29d18d-1f37-4483-b521-3d6475698c23.png)'
- en: If there is more than one dimension for which the subtotals are being calculated,
    then we can right-click on the dimensions to select or unselect, depending on
    whether we want the totals to be calculated or not.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个维度需要计算子总计，则可以右键单击维度以选择或取消选择，具体取决于我们是否希望计算总计。
- en: 'For example, adding city to the previous and adding all subtotals creates the
    following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将城市添加到之前的内容中，并添加所有子总计，将创建以下图表：
- en: '![](img/c7d6ebcc-5732-46a2-81b0-b2cddb6dfdc7.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7d6ebcc-5732-46a2-81b0-b2cddb6dfdc7.png)'
- en: 'Now, if we do not want to see the subtotals at the level of Categories, then
    right-click on Category in the Rows shelf and uncheck Subtotals, as shown in the
    following screenshot:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们不想在类别级别看到子总计，则可以在行架上右键单击类别，并取消选中子总计，如图下截图所示：
- en: '![](img/573c7b54-98d5-4c4a-940e-066e3e267868.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/573c7b54-98d5-4c4a-940e-066e3e267868.png)'
- en: This will remove the subtotals from the level of Category. Another way to create
    totals and subtotals is to use the **Analytics Window | Totals.**
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移除类别级别的子总计。创建总计和子总计的另一种方法是使用**分析窗口 | 总计**。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to create simple calculations. We looked
    at the format and syntax requirements for the various elements of calculations.
    Following that, we looked in detail at some of the important functions and examples
    of number, string, date, and logical functions. Lastly, we also learned how to
    add totals and subtotals to our calculations. In the next chapter, we will learn
    about more advanced table calculations, where we will use the results of the calculations
    learned in this chapter to build on further calculations.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建简单的计算。我们探讨了计算的各种元素所需的格式和语法要求。随后，我们详细研究了数字、字符串、日期和逻辑函数的一些重要函数和示例。最后，我们还学习了如何将总计和子总计添加到我们的计算中。在下一章中，我们将学习更高级的表格计算，我们将使用本章学到的计算结果来构建进一步的计算。
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To look at a list of all available functions in Tableau, go to the following
    link: [https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm](https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Tableau中所有可用函数的列表，请访问以下链接：[https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm](https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm)。
