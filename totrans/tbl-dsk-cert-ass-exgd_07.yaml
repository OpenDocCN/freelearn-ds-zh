- en: Understanding Simple Calculations in Tableau
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you have learned much about visualizing data in various
    forms in Tableau. It is common to have cases where the data you want to visualize
    is not directly present in your dataset but can easily be obtained by applying
    transformations on the dataset or even aggregating the data in the dataset. For
    example, you may have the full address for a placed order, and you want to obtain
    only the country or city where the order came from. Alternatively, you may have
    data for each individual sale and you want to know the average of all sales. This
    and the subsequent two chapters will focus on calculations and how you can use
    these to answer such questions. This chapter will introduce calculations and cover
    simple calculations, while the next two will look at more advanced calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculation basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating calculations and understanding their components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building arithmetic calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building string calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building date calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building logical statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building grand totals and subtotals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter uses the following dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: The Global Superstore dataset, which can be found at [http://www.tableau.com/sites/default/files/training/global_superstore.zip](http://www.tableau.com/sites/default/files/training/global_superstore.zip).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculation basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculations allow us to obtain more data points from the existing dataset and
    allow us to enhance our visualizations and analysis. Creating calculations in
    Tableau enables you to analyze data on the fly, without having to create overheads
    by transforming your original datasets every time you have a new idea about how
    you can analyze your data even further.
  prefs: []
  type: TYPE_NORMAL
- en: When to use calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into calculations and how to create them, it is equally important
    to understand when to create calculations. Some examples of when calculations
    are useful are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing datatypes**: For example, you have data that is being represented
    as a string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performing mathematical calculations**: For example, you want to divide two
    fields to obtain ratios or percentages or subtract fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To create logical groupings/labels**: For example, if you want to group people
    in those who can drive or not, you can create a calculation saying: if you are
    older than 18 and have a valid driving license, you can drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To create new fields from existing data**: For example, you want to create
    a country field by extracting a part of the address or a new date field from another
    date field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregating data**: For example, you want to view the sum, average, and median
    of distribution or subtotals and totals at the country and city levels for sales.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand when to use calculations, we can discuss the three types
    of calculations available in Tableau.
  prefs: []
  type: TYPE_NORMAL
- en: Types of calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Simple calculations**: These calculations allow you to create new fields
    at either the same level of granularity as your dataset (row-level) or aggregate
    data at the granularity of the visual.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level Of Detail (LOD) expressions**: LOD calculations are an extension of
    simple calculations but allow you to have more control over the granularity of
    the data you are working on. You have options to work to specify a FIXED level
    of granularity or INCLUDE data fields to the visualization granularity or EXCLUDE
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table calculations**: Table calculations only work at the level of granularity
    of the visuals. These allow you to build calculations at visual levels of top
    of your existing data or simple calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of calculation you require will depend on the use case of your problem.
    If you already have all of the data you want to answer the questions, then you
    need table calculations. If you do not have all of the data you need, but the
    data needed will be at the same granularity as your dataset, you will need a basic
    calculation. Otherwise, it will be a LOD calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry if you are a bit confused about the types of calculations. We will
    cover each type in detail in separate chapters. This chapter will cover simple
    calculations in detail while the next two will cover the other two calculation
    types. So, let's look at how to create simple calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a calculation, click on **Analysis** | **Create Calculated Field**.
    Alternatively, you can scroll to the end of dimensions/measures tabs and right-click
    in the white space there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following calculations window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14c57d5b-0278-4d24-a661-b18a0da00be4.png)'
  prefs: []
  type: TYPE_IMG
- en: The top of the window, where it says `Calculation1`, is where you enter the
    name of your calculated field. The blank area underneath is where you enter your
    calculation. To the right side, you have a list of all of the available functions
    you can use and their syntax to quickly help you out. The tiny triangle icon to
    the right of the calculation editor can be used to toggle the functions window
    in/out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a very simple calculation to see what our total profit would
    be if the average profit increased four times, and name this calculation `4x Profit`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2154dc36-c4f1-4c5e-941f-30dd72111f41.png)'
  prefs: []
  type: TYPE_IMG
- en: You will see, at the bottom of the calculation, the message: **The calculation
    is valid**. This means we can now click **OK** and the field will be created.
    The error checker in Tableau quickly displays error messages below if the calculation
    is invalid, allowing for easy troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click **OK**, you will notice the field appears under **Measures**.
    Now, you can use this calculation as you would any other measure. Let''s use it
    to show the results per **Segment**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a29046db-8ca1-4507-9b62-a4153a30226a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Like the previously discussed calculation, all calculations in Tableau can
    be a combination of six basic elements. These elements are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Components** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Functions | Functions are used to transform the values or members of a field.
    There are many types of functions available in Tableau such as `Number`, `String`,
    `Date`, and `User`. Different functions have different syntax, inputs/data type
    expected, and so on. | In our example, `AVG()` was an example of a function. |'
  prefs: []
  type: TYPE_TB
- en: '| Fields | Fields represent the dimensions or measures (columns) from our data
    source. | `[Profit]` was the field used by us. |'
  prefs: []
  type: TYPE_TB
- en: '| Operators | Operators are symbols that denote some kind of operation. Operators
    can be one of the following: +, -, *, /, %, ==, =, >, <, >=, <=, !=, <>, ^, AND,
    OR, NOT, and ( ). | * in our example was the operator. |'
  prefs: []
  type: TYPE_TB
- en: '| Literal expressions | These are constant values that do not change. These
    can be either Numeric, String, Date, Boolean, or Null. | 4 was the literal used
    by us. |'
  prefs: []
  type: TYPE_TB
- en: '| Parameters | Parameters, as we know, are dynamic values that can replace
    literals. These too can be used in the calculations. |  |'
  prefs: []
  type: TYPE_TB
- en: '| Comments | Comments are simple descriptions that you can add to the calculation
    fields. These are informational only and do not affect the actual calculation.
    The `//` symbols are used to add comments. | We didn''t add a comment to our example,
    but we could have added something like `// To create 4 times profit value`. |'
  prefs: []
  type: TYPE_TB
- en: Using the preceding combination of six elements, all calculations are created.
    Now that we understand the components better, we can look at the syntax of each
    component in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Functions syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many types of functions available in Tableau, such as `Number`, `String`,
    `Date`, and `User`. Different functions have different syntax and require different
    inputs for them to work. The list of all of the functions available to you in
    Tableau is available in the side tab of the calculated field window. Select `AVG()`
    from the functions list. Once you select any function, you will see three elements
    in the help window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfbd0dcc-45fd-4a84-a6f7-52ee74cf4010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax of the function: For `AVG`, it shows **AVG(expression)**, meaning that,
    to obtain the average, you need to write AVG(expression here).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explanation: Below the syntax, there is an explanation of what the function
    does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: This is an example of how the function can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unsure of how to use a function, copy and paste the example, and
    then replace the fields in it with your own fields. This ensures that the syntax
    remains correct.
  prefs: []
  type: TYPE_NORMAL
- en: You can use more than one function in a calculation and even nest them inside
    one another as long as they meet the syntax requirements. We will learn about
    some of the common types of functions later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fields syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fields are the columns in the data (and can be calculated fields too). A field
    should always be surrounded by square brackets, `[]`, if they contain spaces or
    are not unique in name. It is best practice to surround fields with `[]`. Fields
    are shown in orange in Tableau. You can drag and drop the field directly into
    the calculation from the **Dimension** or **Measures** tabs. Alternatively, you
    can start typing the field name and Tableau will show you options to autocomplete
    fields, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29da1d43-a473-4afe-9c49-f80356ab1984.png)'
  prefs: []
  type: TYPE_IMG
- en: Operator syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operators are symbols that denote some kind of operation. Operators can be
    of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematical operators: Mathematical operators are used for performing mathematical
    calculations. The operators are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**+ (plus)**: Plus can be used for addition (numeric and date fields) and string
    concatenation. For example, `4+2` will return `6` while `Abc` + `Def` will return
    `AbcDef`. We can use addition for dates as well, for example, adding `#23-04-2019#+4`
    will give `#27-04-2019#`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**- (minus)**: Minus can be used for the subtraction of dates and numeric fields,
    in a similar way to the + operator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*** (multiplication)** and **/ (division)**: This is used to multiply or divide
    numeric fields.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**% (modulo)**: This returns the remainder of a division operator, for example, `5%2=1`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**^ (power/exponent):** This returns the exponent value, for example, `2^3
    =8`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relational operators: These are used for comparing expressions and return `TRUE`,
    `FALSE`, or `NULL` values. Each operator can be used to compare numbers, dates,
    or strings. The operators are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**== or = (equals)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**> ( greater than) **'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**< (less than)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**>= (greater than or equal to)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<= (less than or equal to)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**!=** and **<> (not equal to)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logical operators: Logical operators compare both sides of the expression and
    return `TRUE`, `FALSE`, or `NULL` values. The logical operators are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AND**: If both expression 1 and expression 2 are `TRUE`, then it returns
    `TRUE`; otherwise, it returns `FALSE`. If any of the expressions are `NULL`, then
    it returns `NULL`. `AND` follows the following rules for output:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Expression 1** | **Expression 2** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `TRUE` | `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  prefs: []
  type: TYPE_TB
- en: '| `FALSE`/`NULL` | `TRUE` | `FALSE`/`NULL` |'
  prefs: []
  type: TYPE_TB
- en: '| `FALSE`/`NULL` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  prefs: []
  type: TYPE_TB
- en: '**OR:** `OR` returns `FALSE` only if both the expressions are `FALSE`; otherwise,
    it will return `TRUE`. It returns `NULL` only if both values are `NULL`. It follows
    the following rules for output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Expression 1** | **Expression 2** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `TRUE` | `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `FALSE`/`NULL` | `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `FALSE`/`NULL` | `TRUE` | `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `FALSE`/`NULL` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  prefs: []
  type: TYPE_TB
- en: '**NOT:** `NOT` is used to negate other Booleans or expressions. It follows
    the following rules of output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Expression 1** | **Expression 2** |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: '| `FALSE` | `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: Order of precedence of operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The operators get evaluated in the following order of precedence:'
  prefs: []
  type: TYPE_NORMAL
- en: '`–` (negate)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`^` (power)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`*`, `/`, `%`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`+`, `–`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`==`, `>`, `<`, `>=`, `<=`, `!=`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NOT`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AND`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OR`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To change the order of precedence, we can use the final operator called parentheses, `()`.
    If you put something in parentheses, it gets executed first. If there are nested
    parentheses, then the innermost gets executed first and so on, for example, if
    we had the following expression to get evaluated: `(1+2*5) = 11 , (1+(2*5)/2)
    = (1+10/2) =6`.
  prefs: []
  type: TYPE_NORMAL
- en: Literal expressions syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Literal expressions are constant values that are represented as is. Literals
    are of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numeric literals**: Numbers or floats such as `4.2` and `2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String literals**: Constant strings such as `Hello`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date literals**: Represent dates as constants, such as `#20-05-2019#`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean literals**: Represent Boolean values of `TRUE` or `FALSE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Null literals**: Used to assign or compare against `NULL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameters are simply placeholder variables. Parameters are represented with
    the color purple in Tableau. They can represent numbers, floats, strings, date/date-time
    values, or Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: Comments syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments are represented using `//`. To add multiline comments, add `//` in
    every line.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand all about the basic elements of what constitutes calculated
    fields and how to create them, let's dive into some calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Building arithmetic calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with arithmetic calculations in Tableau, we can either use operators
    as discussed in the last section, work with one of the many **number functions**
    that are present, or make use of some of the **aggregation options**. This section
    will cover some of the important functions but it is not an exhaustive list. The
    *Further reading* section contains links to an A-Z list of functions maintained
    by Tableau.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregation options define how your data values are combined or aggregated.
    Simple aggregation works at the level of visual granularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is the data is aggregated at the level of the dimensions in
    the visual. Without even studying it, we have used this logic in the previous
    chapters when we created visuals. Whenever we wanted to see the total **SUM(Sales)**,
    we would only bring the **SUM(Sales)** measure to our visual window. However,
    if we wanted to see the sales per segment, we would add the **Segment** dimension
    to our window and our sales would split up, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2754ca91-c279-4005-8160-28ab086f57c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This same principle works with all the aggregations. To see the aggregation
    levels available, right-click on the measured field, select **Measure** (aggregation
    level) and it will show you what other options are available. For example, by
    right-clicking on the **SUM(Sales)** measure field, the following aggregation
    levels are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1933a496-7590-44a0-a4e9-9d507129ac4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, if you want to use a dimension field to represent a measure value,
    you can bring it into the visual and right-click and select **Measure**, and then
    it will show the aggregation options available for the dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming a column in our dataset looks like `1, 1, 1, 2, 2, 3, 4`, the various
    aggregation options and their results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sum** | This adds the measure values, calculated by adding values = `1+1+1+2+2+3+4
    = 14`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Average** | This is the average of the measure values, calculated by adding
    values divided by the count of values = `14/7 = 2`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Median** | This is the central value = `2`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Count** | This simply counts the number of elements = `7`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Count** **(Distinct)** | This is the count of distinct values, so no same
    value is counted more than once = `4`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Minimum** | This the least value = `1`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Maximum** | This is the highest value = `4`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Percentile** | This shows what percentage of the values are less than this
    value. It has further options to look at the 5, 10, 25, 50, 75, 90, and 95 percentiles.
    Here, the 25^(th) percentile would be 1, the 75^(th) percentile would be 3, and
    so on. |'
  prefs: []
  type: TYPE_TB
- en: '| **Standard Deviation**, **Standard Deviation(Pop)** | Standard deviation
    defines how much of the members are differing from the mean value. If you have
    an entire dataset, use the standard deviation population; if it is a sample, then
    use standard deviation. **Standard deviation (Pop) **= `1.07` |'
  prefs: []
  type: TYPE_TB
- en: '| **Variance**, **Variance (Pop)** | Variance is the square of standard deviation,
    so depending on population or sample, we use variance = `1.14` for this case.
    |'
  prefs: []
  type: TYPE_TB
- en: The aggregations calculated in Tableau are sent back to the databases for querying.
    So, the general rule of thumb is if the database doesn't support a particular
    aggregation, Tableau will not be able to support it either. However, if you create
    extracts of the same data, then the aggregation will be supported.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, look at all of the aggregation options for the `Profit` measure and
    the `Customer Name` dimension.
  prefs: []
  type: TYPE_NORMAL
- en: By simply using a combination of the preceding aggregation options and operators,
    many important calculations can be done. For example, `Cost` can be determined
    as `[Sales]-[Profit]`. Then, the average cost can be found with `AVG(Cost)`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also calculate the `Profit to Sales` ratio as `SUM(Profit)/SUM(Sales)`.
    This will show up in decimals. To see it as a percentage, one way would be to
    multiply the calculation by 100\. However, this will not show the `%` sign. To
    show the percentage sign, we need to format the results as a percentage. To do
    this, right-click on **Measure** and select **Format**. A side window will appear.
    Here, under **Default**, click on **Numbers** and then **Percentage**.
  prefs: []
  type: TYPE_NORMAL
- en: You can also include other things such as a suffix/prefix by using custom options.
    Once you are happy, you can close the side window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the aggregations and operator use, we can look at other number functions
    available. They can be logically grouped into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigonometric functions**: These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `PI` | This returns the numeric constant value for pi, as 3.141592…., up
    to 16 decimal places. `PI()` is generally used within other trigonometric functions
    to specify the angles in radians. |'
  prefs: []
  type: TYPE_TB
- en: '| `SIN` | This returns the sine of an angle. The angle must be specified in
    radians, for example, `SIN(-PI()/4) =-0.7071`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ASIN` | This returns the arc sine of a number in radians. This is the inverse
    of `SIN`, for example, `ASIN(-0.7071)=-0.7854` (which is *-pi/4*). |'
  prefs: []
  type: TYPE_TB
- en: '| `ATAN2` | This takes the two coordinate positions *y* and *x* as input and
    returns the arc tangent of two numbers in radians, for example, `ATAN2(1,1) =
    0.7854 i.e pi/4` |'
  prefs: []
  type: TYPE_TB
- en: '| `DEGREE` | This converts radians into degrees, so `DEGREE(0.7854) =45`..
    |'
  prefs: []
  type: TYPE_TB
- en: '** The COS, ACOS, TAN, ATAN, and COT functions are similar to SIN and ASIN.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logarithmic and exponential functions**: These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `EXP` | This returns *e* raised to the power of a number, for example, `EXP(2)
    = e^2`. |'
  prefs: []
  type: TYPE_TB
- en: '| `LN` | This returns the natural logarithm of the number. The value is null
    for all zero and negative values, for example, `LN(2) = 0.69` or `LN(EXP(2))=2`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LOG` | This returns a logarithmic value to the base of another number. If
    no base is specified, then it returns a logarithmic value to the base of 100,
    for example, `LOG(1000) = 3` and `LOG( 4,2) = 2`. |'
  prefs: []
  type: TYPE_TB
- en: '| `POWER` | This returns a value to the power of another, for example, `POWER
    (2,3) =2^3= 8`. |'
  prefs: []
  type: TYPE_TB
- en: '**Other mathematical functions**: These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `SQUARE` | This returns the square of a number and is equivalent to `Power
    (number, 2)`, for example, `SQUARE(5) = 25`. |'
  prefs: []
  type: TYPE_TB
- en: '| `SQRT` | This returns the square root of a number and is equivalent to `Power
    (number, 0.5)`, for example, `SQRT(25) =5`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ABS` | This returns the absolute value of a number, for example, `ABS(-7)
    =7`. It''s very useful when you work with quantities or deviations where the actual
    values are more important than the sign of the numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| `CEILING` | This rounds a number to the nearest integer greater or equal
    to the number. This is useful when doing capacity planning kind of problems, for
    example, if you had to assign resources to a project to get work completed and
    the result was `3.2`. If you simply round the number, your result would be `3`.
    But you actually have more work, so it makes more sense to have four resources
    than three and plan based on that, for example, `CEILING(3.2) = 4`. |'
  prefs: []
  type: TYPE_TB
- en: '| `FLOOR` | `FLOOR` does the reverse of `CEILING`. It returns the greatest
    integer smaller or equal to the given number, for example, `FLOOR(3.2) =3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ROUND` | This rounds the number to the nearest integer or the specified
    decimal values, for example, `ROUND (3.2)=3`, `ROUND(3.7) = 4`, and `ROUND(3.1421,2)
    = 3.14`. |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGN` | This returns the sign of the number, 1 if positive, 0 if zero, and
    -1 if negative, for example, `SIGN(-3)=-1` and `SIGN(4) =1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ZN` | This returns the expression if it is not null; otherwise, it will
    return 0\. This is useful if we want to calculate averages, without ignoring `NULL`
    or to display 0s instead of nulls.  |'
  prefs: []
  type: TYPE_TB
- en: '| `DIV` | This returns the quotient of a division operation, for example, `DIV(7,2)
    =3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `HEXBINX`, `HEXBINY` | Both of these functions are used to map an *x*, *y*
    coordinate to the nearest hexagonal bin. `HENBINX` maps to the nearest *x *coordinate
    while `HEXBINY` maps the nearest *y *coordinate. The bins have side length 1,
    so the inputs need to be scaled accordingly.  |'
  prefs: []
  type: TYPE_TB
- en: Now that we are familiar with the various aggregation options and number functions
    that can be used to create numeric calculations, let's move on to the next section
    where we will learn about string calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Building string calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to numeric calculations, many string functions exist to allow for various
    calculations. Let's look at some of the key string calculations and how they can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Functions related to obtaining substrings from a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common use cases when dealing with strings is that we want only
    parts of the string and not all. Many functions help us to do that. Let's have
    a look at what functions we can use.
  prefs: []
  type: TYPE_NORMAL
- en: '`LEFT`: This follows the syntax `LEFT (string, num_chars)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `LEFT`, the `num_chars` specified starting from the start of a string
    is returned. This becomes very useful for grouping.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we want to find the customers who have ordered the most, based
    on what letter their name starts with. We could create a calculation as follows: `LEFT([Customer
    Name,1)`. This will return only the first character of the string. We can then
    use this and count the number of orders to clearly see which category ordered
    the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b5a7abc-05f4-48b0-818c-8fbcd7ee0068.png)'
  prefs: []
  type: TYPE_IMG
- en: '`RIGHT`: This follows the syntax `RIGHT(string, num_chars)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `RIGHT`, the `num_chars` specified starting from the end of a string is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the first example, if you wanted to find the last letter of the names
    of the people who ordered, you would use `RIGHT([Customer Name,1).`
  prefs: []
  type: TYPE_NORMAL
- en: '`MID`: This follows the syntax `MID (string, start, [length])`.'
  prefs: []
  type: TYPE_NORMAL
- en: It returns the characters from `string`, starting from the position specified
    by the start value. The first character of the string has the starting position
    of 1\. `length` is optional to specify, and if it is specified, it will return
    up to that many characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`SPLIT`: This follows the syntax `SPLIT (string, delimiter, token number)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we don't know the exact position we want to create a substring from
    but might have a delimiter to specify it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in our dataset, we have a customer full name, so what if we only
    wanted to obtain the first name? We know the names are in the format of **First
    Name** followed by space character and then **Middle** + **Last** **Name**. So,
    our delimiter is `" "`. Based on the delimiter, your string is divided into equal
    tokens.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the string was `Alex Young`, your string would be broken by
    the delimiter into two strings. Token 1 would be `Alex`, and Token 2 would be `Young`.
    So, `SPLIT("Alex Young", " ",1)` would return `Alex`, while `SPLIT ("Alex Young","
    ",2)` would return `Young`. If you use negative numbers, it counts from the right
    in a string. So, `SPLIT("Alex Young"," ", -1)` would be `Young`, and `SPLIT ("Alex
    Young"," ",-2)` would be `Alex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to our example—if we wanted to find the **First Name** of our customers,
    we would create a calculation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abe84fbe-c819-4809-b979-1fae83f4e336.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we count the people with that as their first names, to find the most popular
    names, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/596825ed-0941-487d-98f8-abb5882193b5.png)'
  prefs: []
  type: TYPE_IMG
- en: This first logical subset of string functions allows us to obtain substrings
    from a string. In the next section, we shall learn about functions that deal with
    the position of occurrence or existence of a substring within a string.
  prefs: []
  type: TYPE_NORMAL
- en: Functions related to finding a substring within a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we don''t want to obtain substrings, but just check whether certain
    substrings exist in strings or even obtain their position of occurrence. For this,
    the following functions are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTAINS`: This follows the syntax `CONTAINS(string, substring)`. `CONTAINS` returns
    true if the string contains the substring within it, for example, `CONTAINS("Tableau",
    "Table") = TRUE`. For example, to find how many people have names containing the
    letter `E`, we can then create the calculation as `CONTAINS([Customer Name],"e")`
    and see the count of `TRUE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENDSWITH`:This follows the syntax `ENDSWITH(string, substring)`. This returns
    true if the string ends with the substring provided, and trailing white spaces
    are ignored, for example, `ENDSWITH("hello", "lo")=TRUE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIND`: This follows the syntax `FIND (string, substring, [start])`. It will
    return the position of the string within a substring. If a start position is specified,
    then it starts searching for the substring after the start position. For example,
    `FIND("hello","lo")` would return `4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FINDNTH`:This follows the syntax `FINDNTH(string, substring, occurrence)` and
    returns the *n*^(th) position of the *n*^(th) occurrence of a substring with a
    string. For example, if a string is `abcabcabc` and we want to find the third
    occurrence of `abc` in the string, we would find it using `FINDNTH("abcabcabc"."abc",3)`.
    It will return `7`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STARTSWITH`: This follows the syntax `STARTSWITH(string, substring)`, similar
    to `ENDSWITH`. This displays true if the string starts with the other substring,
    for example, `STARTSWITH("hello","he")=TRUE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions related to formatting/standardizing a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, strings do not all follow a consistent format. There could be leading
    or trailing spaces in strings or them having different cases. All of these will
    lead to the strings to be considered distinct and separate. For example, if there
    was a string called `book` and another string called `BOOK`, they would be considered
    different. Using the following functions, we can standardize the string in our
    dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LOWER`: This follows the syntax `LOWER(string)`. It will return the string
    in all lowercase, for example, `LOWER("Book") = book`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPPER`: This follows the syntax `UPPER(string)`. It will return the strings
    in all uppercase, for example, `UPPER("Book")= BOOK`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRIM`: This follows the syntax `TRIM(string)` and removes both leading and
    trailing spaces from a string, for example, `TRIM("    Book    ") = Book`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to `TRIM`, there are `LTRIM` and `RTRIM`, which follow the same syntax
    but only remove spaces from the left of the string or the right of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Other important string functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LEN`: This follows the syntax `LEN(string)`. Length is used to find the number
    of characters in a string. It counts the number of spaces as a character within
    a string. For example, `LEN("Hi There")` is 8: 2 for `Hi`, 1 for space, and 5
    for `There`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPLACE`: This follows the syntax `REPLACE(string, substring, replacement)`. `REPLACE` is
    used to replace every occurrence of the substring in a string with the replacement,
    for example, to replace occurrences of special characters such as `/` or `''`
    in the string, such as `Replace([Customer Name],"/","")`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another example would be if someone changed their name. You could replace their
    name with the new one. Let''s replace Aaron Bergman''s name with `Aaron B`. Create
    a new calculation using `REPLACE` as follows: `REPLACE([Customer Name], "Aaron
    Bergman", "Aaron B")`. The result of this calculation can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/390e1bee-9ce8-4c9a-beff-7a6a87442834.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have made ourselves familiar with the important string calculations,
    let's look at date calculations in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Building date calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Date calculations allow us to perform operations on dates, such as adding or
    subtracting dates and obtaining parts of dates. Let's look at some of the key
    functions in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the current date/time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Today()` returns the current date in Tableau and `NOW()` can be used to return
    the current date-time. A common use case of this is to find the time taken between
    an event occurrence and today.'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining parts of a date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DAY()`, `MONTH()` and `YEAR()`: They share the syntax of function (date). They
    can be used for obtaining the day, month, and year part of the date as integers
    respectively. For example, `DAY(#24-05-2019#)` returns `24`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATEPART`:It follows the syntax: `DATEPART(date_part,date,[start_of_week])`.
    If the start of the week is not mentioned, then it is determined based on the
    start day defined in the data source. For example, `DATEPART(week,#24-05-2019#)`
    returns `21`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATENAME`:The syntax remains the same as `DATENAME` as `DATEPART(date_part,date,[start_of_week])`.
    It is very similar to `DATEPART`. The key difference is that it will return the
    values as a string. For example, `DATENAME("month",#24-05-2019#)` returns `May`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATETRUNC`: The syntax is the same as `DATEPART` and `DATENAME`, as follows: `DATETRUNC(date_part,
    date,[start_of_week])`. It allows us to not just obtain a `date_part` but rather
    truncate the date to that `date_part`. The syntax is the same as `DATEPART` and
    `DATENAME`, as follows: `DATETRUNC(date_part, date,[start_of_week])`. For example,
    `DATETRUNC("month",#24-05-2019#)` returns `01-05-2019 00:00:00`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other date calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ISDATE`: This follows the syntax `ISDATE(string)`. It returns `TRUE` if the
    string is a date otherwise, it returns `FALSE`, for example, `ISDATE("24-05-2019")=
    TRUE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATEPARSE`: This follows the syntax `DATEPARSE(format, string)`. It is used
    to convert a string into `DATE` in the format specified. For example, `DATEPARSE("dd-MM-yyyy","24-05-2019)`
    returns `24-05-2019` as a date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATEADD`: This follows the syntax `DATEADD(date_part, interval, date)`. It
    adds the interval to `date_part` specified of the date. `DATEADD` is one of the
    most commonly used date functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose there was an issue in the system and all of the order dates captured
    were wrong. They were actually a month before they are showing in the calculation.
    To get the right order dates, we create a calculation for `Correct Order Date`
    as `DATEADD("month",-1,[Order Date])`. Now, if we place the dates next to each
    other, we will obtain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e09da0b5-97f8-403b-95c9-1dd43e761607.png)'
  prefs: []
  type: TYPE_IMG
- en: '`DATEDIFF`:This follows the syntax `DATEDIFF(date_part, start_date,end_date,[start_of_week])`.
    It returns the difference between the two dates in terms of the units of `date_part`.
    For example, if we wanted to calculate the time to ship orders after they are
    ordered in months, we can calculate `Shipping Time` as `DATEDIFF("month", [Order
    Date],[Ship Date])`. Once created, if we look at the total time spent in months
    across all shipping categories, we get the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4e1898db-aedb-4bb5-90c6-207558a0a6cf.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, same-day delivery is super-fast, so even after combining all
    of the orders, shipping only took 2 months. On the other hand, 4,489 months was
    spent in shipping orders by standard class.
  prefs: []
  type: TYPE_NORMAL
- en: In the past few sections, we have covered numeric, string, and date calculations.
    In the next section, we will focus on building logical statements. Logical statements
    work with numbers, strings, and dates and can be used in combination with the
    calculations we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Building logical statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logical functions allow you to check conditions and see whether they are true
    or false. We will take a look at the various categories of logical functions over
    the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Case statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Case statements make use of the following syntax: `CASE <expression> WHEN <value1>
    THEN <return1> WHEN <value2> THEN <return2> ... ELSE <default return> END`.'
  prefs: []
  type: TYPE_NORMAL
- en: In case statements, the value of the expression is matched to each of the values
    and whenever a match is found, the return value corresponding to it is returned.
    If no value matches the expression, then the default else value is returned. If
    there is no default value, null values will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case statements are very useful when you have to compare the same expression
    against multiple values. An example would be if we wanted to assign numbers to
    some of the markets. We can create a calculation as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5a1ed5e-f31e-46f5-872f-b25501705a18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we place both Market and Market Number next to one another, we can
    see the groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a77c50cb-7172-4988-b529-9e79847920c5.png)'
  prefs: []
  type: TYPE_IMG
- en: As an independent exercise, create a case statement giving each day of the week
    a number.
  prefs: []
  type: TYPE_NORMAL
- en: IF statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An IF statement has the following syntax: `IF <expr> THEN <then> [ELSEIF <expr2>
    THEN <then2>...] [ELSE <else>] END`.
  prefs: []
  type: TYPE_NORMAL
- en: Using an `IF` statement, we can test a series of conditions, and based on whether
    the condition is true, the values are returned; otherwise, the next condition
    is tested. This continues until no condition is true, in which case, the default
    condition's value is represented; otherwise, it is returned. If there is no default
    condition, then null is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Within `IF` statements, multiple conditions can also be combined using `OR`
    and `AND` operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to group sales into categories of high, medium, and
    low, we could create a calculation such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e0c8024-46df-42fe-aa0d-4934d877f743.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see we have grouped any sales that are greater than 0 and less
    than 1,000 dollars as being in the category of low, anything up to 2,000 dollars
    is medium, from 2,000-10,000 is high, and all other values we assume are potential
    errors, either from the sales value being too high or being under 0, which we
    might need to recheck.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, counting the number of order IDs by each **Sales Group**, we can see that
    the bulk of the orders are for the **Low** category, followed by the **High**
    category, and there are only five potential error cases, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c4b3983-6726-4654-9ea4-7358e8b6f37a.png)'
  prefs: []
  type: TYPE_IMG
- en: As an exercise, create similar calculations for the profit ranges.
  prefs: []
  type: TYPE_NORMAL
- en: IIF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IIF` is similar to `IF` for one condition. It follows the syntax: `IIF(test,
    then, else, [unknown])`. Here, it will test a condition and if the condition is
    true, the statement returns the then value; otherwise, it returns the else value.
    If the else value is not specified, `NULL` will be returned, for example, `IIF([Sales]>0,"Valid","Invalid")`.'
  prefs: []
  type: TYPE_NORMAL
- en: IFNULL and ISNULL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `IFNULL` and `ISNULL` are used to test whether an expression is null or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '**IFNULL**: It follows the syntax: `IFNULL(expr1,expr2)`, and it returns expression
    1 if the value is null and expression 2 if it is not. For example, `IFNULL([Sales],0)`
    will return the value of `Sales` where it is not null, else return 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ISNULL**: `ISNULL` follows the syntax: `ISNULL(expr)`. It returns `TRUE`
    if the expression is `NULL`. For example, `ISNULL([Sales])` will return true if
    `Sales` is null.'
  prefs: []
  type: TYPE_NORMAL
- en: Other functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the functions discussed so far, there are some other important functions
    that are useful and available in Tableau. One of those is the type conversion
    functions. Type conversion functions are useful for converting one data type into
    another, for example, from an integer into a string or from a float into an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following functions follow the common syntax of `Function(expression)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `DATE` | It is used to obtain a date from numbers or strings or date expressions,
    for example, `DATE("25/05/2019")` returns `#25-05-2019#`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DATETIME` | Very similar to `DATE`, this function returns the date and time,
    for example, `DATETIME("25 May 2019 13:40:00")` returns `#25-05-2019 13:40:00#`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FLOAT` | This is used to cast to floating-point numbers, for example, `FLOAT(2)=2.000`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `INT` | This is used to cast its argument to integers, for example `INT("22")=22`
    or `INT(22.2)=22`. |'
  prefs: []
  type: TYPE_TB
- en: '| `STR` | This is used to cast values to a string, for example, `STR(22)` results
    in a string, `22`. |'
  prefs: []
  type: TYPE_TB
- en: For example, if there is number field `12` and another number field, `22`, and
    we want to obtain the concatenated field `1222`, we can convert them into strings
    and back into numbers as `INT( (STR(12)+STR(22))` and it will return `1222` as
    a number. Type conversions can help many times when we need to create complex
    calculations and need the output of one field to be in the correct format to be
    the input of another.
  prefs: []
  type: TYPE_NORMAL
- en: User functions are another set of useful Tableau functions. These are useful
    to create row-level filters and security to limit the fields that are visible
    if your dashboard is published to Tableau Online or Server. Tableau also allows
    for some regular expression functionalities in functions such as `REGEXP_MATCH`
    or `REGEXP_EXTRACT`, which can be used to create some advanced string matching.
    Also, in the next chapter, we will study some advanced table calculation functions
    that haven't been discussed so far.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing we will discuss in this chapter will be totals and subtotals
    and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Building grand totals and subtotals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond showing the values from calculations, sometimes, we also want to show
    the values of the totals or subtotals in the same window as these values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we have the following graph for SUM(Sales) split by Category
    and Sub-Category across segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61d70d88-a643-4f54-9b81-2b630fd05756.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we want to add the subtotals and the grand totals for both rows and
    columns, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Analysis** > **Totals**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Show Row Totals | Show Column Totals. This will show the graph as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f31b197-3b98-4a23-a315-2f98a7f8f769.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now if we want to see the subtotals too, we can select **Add All Subtotals**
    from Analysis | Tools. This will show the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f29d18d-1f37-4483-b521-3d6475698c23.png)'
  prefs: []
  type: TYPE_IMG
- en: If there is more than one dimension for which the subtotals are being calculated,
    then we can right-click on the dimensions to select or unselect, depending on
    whether we want the totals to be calculated or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, adding city to the previous and adding all subtotals creates the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7d6ebcc-5732-46a2-81b0-b2cddb6dfdc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we do not want to see the subtotals at the level of Categories, then
    right-click on Category in the Rows shelf and uncheck Subtotals, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/573c7b54-98d5-4c4a-940e-066e3e267868.png)'
  prefs: []
  type: TYPE_IMG
- en: This will remove the subtotals from the level of Category. Another way to create
    totals and subtotals is to use the **Analytics Window | Totals.**
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to create simple calculations. We looked
    at the format and syntax requirements for the various elements of calculations.
    Following that, we looked in detail at some of the important functions and examples
    of number, string, date, and logical functions. Lastly, we also learned how to
    add totals and subtotals to our calculations. In the next chapter, we will learn
    about more advanced table calculations, where we will use the results of the calculations
    learned in this chapter to build on further calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To look at a list of all available functions in Tableau, go to the following
    link: [https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm](https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm).
  prefs: []
  type: TYPE_NORMAL
