<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 4. Rendering Our Geodata"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Rendering Our Geodata</h1></div></div></div><p>This chapter is likely to be one of the most interesting ones in this book. Geographic visualization of data is one of the core features of a GIS application, whether used as an exploratory aid or to produce a map. Learning geographic visualization should prove educational on different levels. In this chapter, you will learn how to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Divide the rendering process into a series of renderings of one or more thematic layers</li><li class="listitem" style="list-style-type: disc">Implement basic graphics renderings for vector and raster data, based on the view extent and zoom level</li><li class="listitem" style="list-style-type: disc">Connect these renderings to our visual user interface, allowing interactive map visualization</li></ul></div><div class="section" title="Rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Rendering</h1></div></div></div><p>Typical usage in a GIS is to<a id="id143" class="indexterm"/> add one or more geographic data sources or layers to the application, which then gets immediately rendered in a map window. In <a class="link" href="ch03.html" title="Chapter 3. Designing the Visual Look of Our Application">Chapter 3</a>, <span class="emphasis"><em>Designing the Visual Look of Our Application</em></span>, we set this up as a MapView widget. Although the MapView widget is responsible to show the map in the interactive GUI, we want to <a id="id144" class="indexterm"/>separate the actual rendering logic in a module of its own. This way the user can also batch generate map renderings strictly through coding if they want.</p><p>Usually, graphics rendering is done most efficiently using the graphic capabilities of the user's hardware to draw on the screen. However, Tkinter's screen drawing capabilities (the Tkinter Canvas widget) can be slow, quickly runs out of memory if too many items are drawn, and produces only rough jagged graphics with no anti-aliased smoothing. We instead use the approach of drawing the graphics onto a virtual image, and then sending that image for display in Tkinter. This gives us a slight lag between rendering and display, and is not as fast as using graphics hardware; however, it is almost up there with the speed and quality of the existing GIS software and much better than the Tkinter default.</p><div class="section" title="Installing PyAgg"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Installing PyAgg</h2></div></div></div><p>Before we begin, we install the graphics rendering package that we will be using, called <span class="strong"><strong>PyAgg</strong></span>
<a id="id145" class="indexterm"/> created by the author. PyAgg is<a id="id146" class="indexterm"/> a high-level convenience wrapper around Fredrik Lundh's Python <a id="id147" class="indexterm"/>
<span class="strong"><strong>aggdraw</strong></span> bindings for the<a id="id148" class="indexterm"/> <span class="strong"><strong>Anti-Grain Geometry</strong></span> C++ library. Compared to other popular rendering libraries like Matplotlib or Mapnik, PyAgg is incredibly lightweight at only about 2 MB and doesn't require advanced installation steps since it contains the necessary files precompiled. <span class="strong"><strong>PyCairo</strong></span> is<a id="id149" class="indexterm"/> another lightweight graphics library, but while it has a <a id="id150" class="indexterm"/>much richer set of features, including line joins, line caps, and gradients, it turns out to be very slow at drawing large objects with many vertices. Therefore, we choose PyAgg for its lightness, its speed, and its convenient high level API.</p><p>Go ahead and install it now using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Windows command line, write <code class="literal">C:/Python27/Scripts/pip install pyagg</code></li><li class="listitem">If for some reason<a id="id151" class="indexterm"/> that does not work, you can alternatively download the ZIP file from <a class="ulink" href="https://github.com/karimbahgat/PyAgg">https://github.com/karimbahgat/PyAgg</a> and extract it to the <code class="literal">site-packages</code> folder</li><li class="listitem">Test that it imports correctly by typing <code class="literal">import pyagg</code> in Python shell<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>If you want to go for other rendering libraries, Matplotlib has an easy-to-use Windows installer on their website. You should couple that with <span class="strong"><strong>Descartes</strong></span> to convert geographic features to objects that Matplotlib can render, installed as pip install Descartes from the command line.</p><p>For Mapnik, there are no <a id="id152" class="indexterm"/>precompiled version that I know of, so you will have to compile it on your own, following instructions from <a class="ulink" href="http://wiki.openstreetmap.org/wiki/Mapnik/Installation">http://wiki.openstreetmap.org/wiki/Mapnik/Installation</a>.</p><p>If you want to try <span class="strong"><strong>PyCairo</strong></span>, you <a id="id153" class="indexterm"/>can get a precompiled wheel file for Windows at <a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#pycairo">http://www.lfd.uci.edu/~gohlke/pythonlibs/#pycairo</a>.</p></div></div></li></ol></div><p>Now that the necessary graphics library is installed, we make a module called <code class="literal">renderer.py</code> in the root of our <code class="literal">pythongis</code> folder. Initiate it with some imports:</p><div class="informalexample"><pre class="programlisting">import random
import pyagg
import PIL, PIL.Image</pre></div><p>To make it accessible to our top-level<a id="id154" class="indexterm"/> <code class="literal">pythongis</code> package, just import it from inside <code class="literal">pythongis/__init__.py</code>:</p><div class="informalexample"><pre class="programlisting">from . import renderer</pre></div></div><div class="section" title="A sequence of layers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>A sequence of layers</h2></div></div></div><p>The basic idea of rendering in our GIS application is that we define a series of map layers that should be visualized together, such as countries, cities, and highways. For our convenience, we make<a id="id155" class="indexterm"/> this collection of layers into an iterable <code class="literal">LayerGroup</code> class with methods to add or remove layers, and a method for moving and changing the sequence in which these layers should be drawn. Note that it can hold references to one or more connected map widgets, letting it serve as a central layer repository for a split-view type of map application. Inside <code class="literal">renderer.py</code>, write the following code:</p><div class="informalexample"><pre class="programlisting">class LayerGroup:
    def __init__(self):
        self.layers = list()
        self.connected_maps = list()

    def __iter__(self):
        for layer in self.layers:
            yield layer

    def add_layer(self, layer):
        self.layers.append(layer)

    def move_layer(self, from_pos, to_pos):
        layer = self.layers.pop(from_pos)
        self.layers.insert(to_pos, layer)

    def remove_layer(self, position):
        self.layers.pop(position)

    def get_position(self, layer):
        return self.layers.index(layer)</pre></div></div><div class="section" title="The MapCanvas drawer"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>The MapCanvas drawer</h2></div></div></div><p>Next, we need a way to combine the group of map layers into a final composite map image. For this we<a id="id156" class="indexterm"/> create a <code class="literal">MapCanvas</code> class, which is a wrapper around PyAgg's <code class="literal">Canvas</code> class. The<a id="id157" class="indexterm"/> <code class="literal">MapCanvas</code> class creates the final rendering by asking each layer to render themselves onto an image (with a transparent background), and then overlaying them on top of each other in the correct sequence. Since each layer has a separate image rendering, it is possible to reorder or remove layers very fast without having to redraw all the layers.</p><p>Layering images on top of each other is one thing, but how do we know which parts of our layers to show, or where on the drawing canvas they go? To do this, we need to transform the coordinates of our geospatial data to the pixel coordinates of our image, which is actually not any different from plotting arbitrary data values on a graph. Usually in 2D computer graphics, transforming from one coordinate system to another is done by multiplying each <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinate with some precomputed numbers, called<a id="id158" class="indexterm"/> the <span class="strong"><strong>affine transform coefficients</strong></span>. However, arriving at these coefficients is not immediately intuitive and requires a bit of<a id="id159" class="indexterm"/> matrix math.</p><p>PyAgg makes our lives easier, and this is one of the main reasons we chose to use it. With the <code class="literal">custom_space</code> method, PyAgg<a id="id160" class="indexterm"/> allows us to tell the <code class="literal">Canvas</code> instance to imagine that the image on which it draws is a representation of a given rectangular real-world space. This space is defined by a bounding box of coordinates so that all the incoming data for rendering is placed in relation to that coordinate system, drawing only those parts that fall within its boundaries. PyAgg then uses that bounding box to compute the transform coefficients behind the scenes, with the help of Sean Gillies' affine module. As another useful feature for us, PyAgg allows locking the aspect ratio of the requested view extents to have the same width and height ratio as the canvas image itself, to avoid the geographic data becoming distorted or stretched. Refer to the following figure:</p><div class="mediaobject"><img src="images/5407OS_04_01.jpg" alt="The MapCanvas drawer"/></div><p>On startup, before having added any data, we set the default coordinate space of <code class="literal">MapCanvas</code> class with <code class="literal">geographic_space()</code>, which is just a wrapper around <code class="literal">custom_space()</code> using <code class="literal">[-180, 90, 180, -90]</code> as the bounds (the standard latitude longitude coordinate system of unprojected data) and enforces aspect ratio. By simply changing the coordinate space bounds, the <code class="literal">MapCanvas</code> class can be used to render absolutely any geographic data regardless of its coordinate system or CRS. This way, we can create the effect of zooming or panning the map by modifying the drawing transform coefficients. For this, we make use of PyAgg's convenient zooming methods that let us specify in human terms how we would like to zoom or pan the drawing transform.</p><p>One challenge, however, is when rendering data layers defined in different coordinate reference systems (CRS), as these will not line up as expected. The usual solution in GIS is to provide on-the-fly reprojection of all geographic data into a single common CRS. However, converting between geographic CRS involves a wide range of parameters and assumptions about the shape of the earth and the type of projection, which makes it more complicated than<a id="id161" class="indexterm"/> our previous affine transform. For these reasons and others, our application will not be dealing with CRS reprojection. So the main limitation of our <code class="literal">MapCanvas</code> class is that it needs all data to be in the same CRS in order to properly overlay them. We return briefly to the topic of CRS in <a class="link" href="ch08.html" title="Chapter 8. Looking Forward">Chapter 8</a>, <span class="emphasis"><em>Looking Forward</em></span>, and potential ways to add such functionality yourself. Here is the code for the <code class="literal">MapCanvas</code> class:</p><div class="informalexample"><pre class="programlisting">class MapCanvas:
    def __init__(self, layers, width, height, background=None, *args, **kwargs):

        # remember and be remembered by the layergroup
        self.layers = layers
        layers.connected_maps.append(self)

        # create the drawer with a default unprojected lat-long coordinate system
        self.drawer = pyagg.Canvas(width, height, background)
        self.drawer.geographic_space() 

        self.img = self.drawer.get_image()

    def pixel2coord(self, x, y):
        return self.drawer.pixel2coord(x, y)

    # Map canvas alterations

    def offset(self, xmove, ymove):
        self.drawer.move(xmove, ymove)
    def resize(self, width, height):
        self.drawer.resize(width, height, lock_ratio=True)
        self.img = self.drawer.get_image()

    # Zooming

    def zoom_bbox(self, xmin, ymin, xmax, ymax):
        self.drawer.zoom_bbox(xmin, ymin, xmax, ymax)

    def zoom_factor(self, factor, center=None):
        self.drawer.zoom_factor(factor, center=center)

    def zoom_units(self, units, center=None):
        self.drawer.zoom_units(units, center=center)

    # Drawing

    def render_one(self, layer):
        if layer.visible:
            layer.render(width=self.drawer.width,
                         height=self.drawer.height,
                       coordspace_bbox=self.drawer.coordspace_bbox)
            self.update_draworder()

    def render_all(self):
        for layer in self.layers:
            if layer.visible:
                layer.render(width=self.drawer.width,
                             height=self.drawer.height,
                             coordspace_bbox=self.drawer.coordspace_bbox)
        self.update_draworder()

    def update_draworder(self):
        self.drawer.clear()
        for layer in self.layers:
            if layer.visible:
                self.drawer.paste(layer.img)
        self.img = self.drawer.get_image()

    def get_tkimage(self):
        # Special image format needed by Tkinter to display it in the GUI
        return self.drawer.get_tkimage() </pre></div></div><div class="section" title="Individual layer renderings"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Individual layer renderings</h2></div></div></div><p>The <code class="literal">MapCanvas</code> class <a id="id162" class="indexterm"/>described previously was<a id="id163" class="indexterm"/> responsible to define a common coordinate space and combining the images of its layers, but not for any actual drawing. We leave this task to the individual layer classes, one for <code class="literal">vector</code> and<a id="id164" class="indexterm"/> one for <code class="literal">raster</code>.</p><div class="section" title="Vector layers"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec17"/>Vector layers</h3></div></div></div><p>The rendering of vector data is fairly easy. All we have to do is create a <code class="literal">VectorLayer</code> instance around the<a id="id165" class="indexterm"/> <code class="literal">VectorData</code> class, and optionally decide some style aspects of its geometries using keyword arguments. During this style options stage, we allow all features being styled in the same way.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>On your own, you may want to expand this with the ability to style individual features or groups of features based on their attribute values. This will allow you to visualize how data flows across space.</p></div></div><p>To render itself, the vector layer creates a PyAgg Canvas with the same image size as its parent <code class="literal">MapCanvas</code> class, on top of a transparent background. To make sure it only draws the parts of the data that its parent <code class="literal">MapCanvas</code> class is supposed to be seeing, it is up to us to set the <code class="literal">coordspace_bbox</code> argument with the bounding box of the <code class="literal">MapCanvas</code> class. The layer passes this information on to its <code class="literal">Canvas</code> instance via <code class="literal">custom_space()</code>, so that PyAgg can calculate the correct drawing transform coefficients using matrix math.</p><p>When it comes to drawing each feature, PyAgg and its underlying aggdraw module has different drawing methods with different requirements for how its coordinates should be formatted. Since our geometries can be either points, lines, or polygons and are stored in GeoJSON formatted dictionaries, we need to translate our GeoJSON format to that which is expected by PyAgg. For instance, a GeoJSON polygon is a list of coordinate sequences, the first one being the exterior and all subsequent ones its holes; this information can then be sent to the PyAgg's <code class="literal">draw_polygon</code> method with the arguments it expects. Instead of us learning the entire GeoJSON format to correctly parse the data and call on the right methods, PyAgg's <code class="literal">Canvas</code> class<a id="id166" class="indexterm"/> can do this for us in the <code class="literal">draw_geojson</code> method. After drawing, the rendered image is remembered and made accessible to <code class="literal">MapCanvas</code>:</p><div class="informalexample"><pre class="programlisting">class VectorLayer:
    def __init__(self, data, **options):
        
        self.data = data
        self.visible = True
        self.img = None
        
        # by default, set random style color
        rand = random.randrange
        randomcolor = (rand(255), rand(255), rand(255), 255)
        self.styleoptions = {"fillcolor": randomcolor}
            
        # override default if any manually specified styleoptions
        self.styleoptions.update(options)

    def render(self, width, height, coordspace_bbox):
        drawer = pyagg.Canvas(width, height, background=None)
        drawer.custom_space(*coordspace_bbox)
        # get features based on spatial index, for better speeds when zooming
        if not hasattr(self.data, "spindex"):
            self.data.create_spatial_index()
        spindex_features = self.data.quick_overlap(coordspace_bbox)
        # draw each as geojson, using same style options for all features
        for feat in spindex_features:
            drawer.draw_geojson(feat.geometry, **self.styleoptions)
        self.img = drawer.get_image() </pre></div></div><div class="section" title="Raster layers"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec18"/>Raster layers</h3></div></div></div><p>In a similar manner, rendering raster data is done by creating a <code class="literal">RasterLayer</code> class. When rendering itself, consider<a id="id167" class="indexterm"/> that each cell in a raster grid has a precise location and rectangular area that it covers in geographic space. To transform these cell coordinates from raster space to image space for visualization, the <code class="literal">RasterLayer</code> class has to know the coordinate view extent of the parent <code class="literal">MapCanvas</code> class and find where and how each raster cell should be placed within those bounds.</p><p>Luckily for us, we already gave the <code class="literal">RasterData</code> class a method for doing this type of grid transform, namely, the<a id="id168" class="indexterm"/> <code class="literal">positioned</code> method that leverages PIL's quad transform technique. Using this method, the <code class="literal">RasterLayer</code> class specifies the width and height of the data it wants to return, based on the size of its parent <code class="literal">MapCanvas</code> class, and to only include the parts of the raster that are within the bounds of the <code class="literal">MapCavas</code> classes' coordinate system.</p><p>Since the data structure of our <code class="literal">RasterData</code> class is based on PIL images, all it has to do is combine all band images together to create a gray scale or RGB image, ready to be added to the <code class="literal">MapCanvas</code> class for visualization. The <code class="literal">positioned</code> method also transforms and returns the <code class="literal">nodata</code> mask that the <code class="literal">RasterLayer</code> class uses to make missing values transparent.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Currently, we do not allow customization of the colors used for visualizing the raster, but that should be an easy feature to add if you want to, using the PIL's support for color palettes.</p></div></div><div class="informalexample"><pre class="programlisting">class RasterLayer:
    def __init__(self, data, **options):
        self.data = data
        self.styleoptions = dict(**options)
        self.visible = True
        self.img = None

    def render(self, width, height, coordspace_bbox):
        # position in space
        positioned,mask = self.data.positioned(width, height, coordspace_bbox)

        # combine all data bands into one image for visualizing
        if len(positioned.bands) == 1:
            # greyscale if one band
            band1 = positioned.bands[0]
            img = band1.img.convert("RGB")
        else:
            # rgb of first three bands
            bands = [band.img for band in positioned.bands[:3] ]
            img = PIL.Image.merge("RGB", bands)

        # make edge and nodata mask transparent
        img.putalpha(mask)

        # final
        self.img = img</pre></div></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Interactively rendering our maps"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Interactively rendering our maps</h1></div></div></div><p>Now that we have ways<a id="id169" class="indexterm"/> of combining several layers into a rendered map image, we get to the more exciting part of how to do this interactively in our application with immediate results.</p><div class="section" title="Linking the MapView to the renderer"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Linking the MapView to the renderer</h2></div></div></div><p>After we rendered a set <a id="id170" class="indexterm"/>of layers onto a map image, this image must be sent to and displayed in our application for immediate feedback. This task is done by the MapView widget we created in <a class="link" href="ch03.html" title="Chapter 3. Designing the Visual Look of Our Application">Chapter 3</a>, <span class="emphasis"><em>Designing the Visual Look of Our Application</em></span>. While building our application, the idea is that all we have to worry about is creating this visual MapView widget; behind the scenes, the MapView will be responsible for creating its own <code class="literal">MapCanvas</code> renderer to do the actual work. Since the <code class="literal">MapCanvas</code> class needs LayerGroup to manage its layers, we will create a MapView method to assign a LayerGroup, in <code class="literal">app/toolkit/map.py</code>:</p><div class="informalexample"><pre class="programlisting">    def assign_layergroup(self, layergroup):
        self.layers = layergroup</pre></div><p>We then link the two together as additional code in the MapView's <code class="literal">__init__</code> method. Since the renderer requires a width and a height in pixels before it can be created, we schedule MapView<a id="id171" class="indexterm"/> to create it shortly after startup (because Tkinter won't know how much space is required for the various widgets before startup):</p><div class="informalexample"><pre class="programlisting">        # Assign a renderer just after startup, because only then can one know the required window size
        def on_startup():
            # create renderer
            width, height = self.winfo_width(), self.winfo_height()
            self.renderer = pg.MapCanvas(self.layers, width, height)
            # link to self
            self.renderer.mapview = self
            # fill with blank image
            self.tkimg = self.renderer.get_tkimage()
            self.image_on_canvas = self.create_image(0, 0, anchor="nw", image=self.tkimg )

        self.after(10, on_startup)</pre></div><div class="section" title="Requesting to render a map"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec19"/>Requesting to render a map</h3></div></div></div><p>Whenever the MapView widget wants to render a whole new map with all visible layers, it calls on this method, and does so in a separate thread in order to not freeze up the application while <a id="id172" class="indexterm"/>waiting for the results. It also updates the status bar on its activities and sets the horizontal scale status based on the new zoom level. Afterwards, it has to update the image that is placed on the viewable Tkinter Canvas:</p><div class="informalexample"><pre class="programlisting">    def threaded_rendering(self):
        # perform render/zoom in separate thread
        self.statusbar.task.start("Rendering layers...")
        pending = dispatch.request_results(self.renderer.render_all)

        def finish(result):
            if isinstance(result, Exception):
                popup_message(self, "Rendering error: " + str(result) )
            else:
                # update renderings
                self.coords(self.image_on_canvas, 0, 0) # always reanchor rendered image nw at 0,0 in case of panning
                self.update_image()
                # display zoom scale
                self.statusbar.zoom.set_text("1:"+str(self.renderer.drawer. coordspace_units) )
            self.statusbar.task.stop()
            
        dispatch.after_completion(self, pending, finish)

    def update_image(self):
        self.tkimg = self.renderer.get_tkimage()
        self.itemconfig(self.image_on_canvas, image=self.tkimg )</pre></div></div><div class="section" title="Resizing the map in proportion to window resizing"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec20"/>Resizing the map in proportion to window resizing</h3></div></div></div><p>If the user changes the application window size from the original startup size, we need to resize the MapView's renderer accordingly. We tell it to resize only after one-third of a second after the<a id="id173" class="indexterm"/> user has stopped resizing the window, because Tkinter's resize event is triggered continuously during the process. What is important in the event of such a resize is that the coordinate system is changed accordingly to map the new image dimensions; fortunately for us, our PyAgg Canvas automatically updates and locks the aspect ratio on the drawing transform for us when resizing:</p><div class="informalexample"><pre class="programlisting">        # Schedule resize map on window resize
        self.last_resized = None
        def resizing(event):
            # record resize time
            self.last_resized = time.time()
            # schedule to check if finished resizing after x millisecs
            self.after(300, process_if_finished)

        def process_if_finished():
            # only if x time since last resize event
            if time.time() - self.last_resized &gt; 0.3:
                width, height = self.winfo_width(), self.winfo_height()
                self.renderer.resize(width, height)
                self.threaded_rendering()

        self.bind("&lt;Configure&gt;", resizing)</pre></div></div></div><div class="section" title="The LayersPane as a LayerGroup"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>The LayersPane as a LayerGroup</h2></div></div></div><p>With a basic Map widget capable of rendering, we move onto adding data to the map, which we then can view in our application's layers pane. The LayersPane widget is merely a visual representation<a id="id174" class="indexterm"/> of the sequence of layers in its connected LayerGroup class. Therefore, the LayersPane class in the <code class="literal">app/toolkit/layers.py</code> file needs a method to bind it to a LayerGroup:</p><div class="informalexample"><pre class="programlisting">    def assign_layergroup(self, layergroup):
        self.layers = layergroup</pre></div></div><div class="section" title="Adding layers"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Adding layers</h2></div></div></div><p>We will now create<a id="id175" class="indexterm"/> an <code class="literal">add_layer</code> method to the LayersPane class in <code class="literal">app/toolkit/layers.py</code>. To make it flexible, we allow it to add a layer either from a file path or from an already loaded data object.</p><p>If it detects a file path, it first runs a <code class="literal">from_filepath</code> function, where it decides whether to create a vector or raster data class, tells our dispatch module to use this data class to load the file path in a background thread, and schedules our application to check the results queue every 100 ms to see whether the loading is done.</p><p>Once loaded or if given an already loaded data object, it goes straight to adding the layer with the<a id="id176" class="indexterm"/> <code class="literal">from_loaded()</code> function. This creates a VectorLayer or RasterLayer capable of rendering itself, adds a representation of that layer responsive to right-click events in the LayersPane (more on this in the next section), and asks the dispatch to render the layer as an image and update the MapView widget(s) to which it is connected. If the new layer is the only one currently loaded in the LayersPanel, then we automatically zoom to its bounding box so that the user gets an immediate look at the data.</p><p>Here is the code:</p><div class="informalexample"><pre class="programlisting">    def add_layer(self, filepath_or_loaded, name=None, **kwargs):
        
        def from_filepath(filepath):
            if filepath.lower().endswith((".shp",".geojson",".json")):
                func = pg.vector.data.VectorData
                args = (filepath,)
            elif filepath.lower().endswith((".asc",".ascii",
                                            ".tif",".tiff",".geotiff",
                                            ".jpg",".jpeg",
                                            ".png",".bmp",".gif")):
                func = pg.raster.data.RasterData
                args = (filepath,)
            else:
                popup_message(self, "Fileformat not supported\n\n" + filepath )
                return

            self.statusbar.task.start("Loading layer from file...")
            pending = dispatch.request_results(func, args, kwargs)

            def finish(loaded):
                if isinstance(loaded, Exception):
                    popup_message(self, str(loaded) + "\n\n" + filepath )
                else:
                    from_loaded(loaded)
                self.statusbar.task.stop()
                
            dispatch.after_completion(self, pending, finish)

        def from_loaded(loaded):
            # add the data as a rendering layer
            if isinstance(loaded, pg.vector.data.VectorData):
                renderlayer = pg.renderer.VectorLayer(loaded)
            elif isinstance(loaded, pg.raster.data.RasterData):
                renderlayer = pg.renderer.RasterLayer(loaded)
            self.layers.add_layer(renderlayer)

            # list a visual representation in the layerspane list
            listlayer = LayerItem(self.layersview, renderlayer=renderlayer, name=name)
            listlayer.namelabel.bind("&lt;Button-3&gt;", self.layer_rightclick)
            listlayer.pack(fill="x", side="bottom")
                       
            # render to and update all mapcanvases connected to the layergroup
            for mapcanvas in self.layers.connected_maps:
                if len(mapcanvas.layers.layers) == 1:
                    # auto zoom to layer if it is the only layer
                    mapcanvas.zoom_bbox(*loaded.bbox)

                func = mapcanvas.render_one
                args = [renderlayer]

                self.statusbar.task.start("Rendering layer...")
                pending = dispatch.request_results(func, args)
                
                def finish(loaded):
                    if isinstance(loaded, Exception):
                        popup_message(self, "Rendering error: " + str(loaded) )
                    else:
                        mapcanvas.mapview.update_image()
                    self.statusbar.task.stop()
                    
                dispatch.after_completion(self, pending, finish)

        # load from file or go straight to listing/rendering
        if isinstance(filepath_or_loaded, (str,unicode)):
            from_filepath(filepath_or_loaded)
        else:
            from_loaded(filepath_or_loaded)</pre></div></div><div class="section" title="Editing layers in the LayersPane widget"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Editing layers in the LayersPane widget</h2></div></div></div><p>Now that we can <a id="id177" class="indexterm"/>add layers to the LayersPane, we also want to be able to play around with the layers. A layer is represented as a LayerItem widget, which<a id="id178" class="indexterm"/> we have yet to define. We give the LayerItem a delete button on the right side, and a checkbox on the left side to toggle its visibility as shown in the following diagram:</p><div class="mediaobject"><img src="images/5407OS_04_02.jpg" alt="Editing layers in the LayersPane widget"/></div><p>The delete button is going to need an icon so let's start by getting one of those:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to an<a id="id179" class="indexterm"/> icon website such as <a class="ulink" href="http://www.iconarchive.com">www.iconarchive.com</a> or <a class="ulink" href="http://www.flaticon.com">http://www.flaticon.com</a>.</li><li class="listitem">Search for and choose an icon that you like.</li><li class="listitem">Save it as <code class="literal">delete_layer.png</code> with 32 pixel size and place it in your <code class="literal">app/icons</code> folder.</li></ol></div><p>We also define how to rename a layer's name, which temporarily adds a Tkinter entry widget over the layer's name display so the user can alter the name and press <span class="emphasis"><em>Return</em></span> to accept or <span class="emphasis"><em>ESC</em></span> to cancel. Now make the <code class="literal">LayerItem</code> class in <code class="literal">app/toolkit/layers.py</code> using the following code:</p><div class="informalexample"><pre class="programlisting">class LayerItem(tk.Frame):
    def __init__(self, master, renderlayer, name=None, **kwargs):
        # get theme style
        style = style_layeritem_normal.copy()
        style.update(kwargs)
        
        # Make this class a subclass of tk.Frame and add to it
        tk.Frame.__init__(self, master, **style)
        self.layerspane = self.master.master
        self.statusbar = self.layerspane.statusbar

        # Create a frame to place main row with name etc
        self.firstrow = tk.Frame(self, **style)
        self.firstrow.pack(side="top", fill="x", expand=True)

        # Create the visibility check box
        var = tk.BooleanVar(self)
        self.checkbutton = tk.Checkbutton(self.firstrow, variable=var, offvalue=False, onvalue=True, command=self.toggle_visibility, **style_layercheck)
        self.checkbutton.var = var
        self.checkbutton.pack(side="left")
        self.checkbutton.select()

        # Create Delete button to the right
        self.deletebutton = IconButton(self.firstrow, padx=2, relief="flat", command=self.delete)
        self.deletebutton.set_icon("delete_layer.png")
        self.deletebutton.pack(side="right")

        # Create the layername display
        self.renderlayer = renderlayer
        if name: layername = name
        elif self.renderlayer.data.filepath: 
            layername = os.path.split(self.renderlayer.data.filepath)[-1]
        else: layername = "Unnamed layer"
        self.namelabel = tk.Label(self.firstrow, text=layername, **style_layername_normal)
        self.namelabel.pack(side="left", fill="x", expand=True)

    def toggle_visibility(self):
        self.layerspane.toggle_layer(self)

    def delete(self):
        self.layerspane.remove_layer(self)

    def ask_rename(self):
        # place entry widget on top of namelabel
        nameentry = tk.Entry(self)
        nameentry.place(x=self.namelabel.winfo_x(), y=self.namelabel.winfo_y(), width=self.namelabel.winfo_width(), height=self.namelabel.winfo_height())
        # set its text to layername and select all text
        nameentry.insert(0, self.namelabel["text"])
        nameentry.focus()
        nameentry.selection_range(0, tk.END)
        # accept or cancel change via keypress events
        def finish(event):
            newname = nameentry.get()
            nameentry.destroy()
            self.namelabel["text"] = newname
        def cancel(event):
            nameentry.destroy()
        nameentry.bind("&lt;Return&gt;", finish)
        nameentry.bind("&lt;Escape&gt;", cancel)</pre></div><p>The <code class="literal">LayerItem</code> class's delete button and visibility checkbox in the previous code both called on methods in the parent LayersPane to do the work, because the LayersPane's connected MapCanvas need <a id="id180" class="indexterm"/>updating afterwards. Therefore, let's add these methods to the LayersPane. We also need a way to specify the function to be run when right-clicking any of the layers in the LayersPane:</p><div class="informalexample"><pre class="programlisting">    def toggle_layer(self, layeritem):
        # toggle visibility
        if layeritem.renderlayer.visible == True:
            layeritem.renderlayer.visible = False
        elif layeritem.renderlayer.visible == False:
            layeritem.renderlayer.visible = True
        # update all mapcanvas
        for mapcanvas in self.layers.connected_maps:
            mapcanvas.update_draworder()
            mapcanvas.mapview.update_image()

    def remove_layer(self, layeritem):
        # remove from rendering
        layerpos = self.layers.get_position(layeritem.renderlayer)
        self.layers.remove_layer(layerpos)
        for mapcanvas in self.layers.connected_maps:
            mapcanvas.update_draworder()
            mapcanvas.mapview.update_image()
        # remove from layers list
        layeritem.destroy()

    def bind_layer_rightclick(self, func):
        self.layer_rightclick = func</pre></div><div class="section" title="Click-and-drag to rearrange the layer sequence"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec21"/>Click-and-drag to rearrange the layer sequence</h3></div></div></div><p>A slightly more complicated procedure is to let the user rearrange the drawing order of the LayerItems in the LayersPane by clicking and dragging them to a new position. It is an essential feature of the layered nature of any GIS software, but unfortunately the Tkinter GUI framework<a id="id181" class="indexterm"/> does not provide us with any drag-and-drop shortcuts, so we must build it from scratch. We keep it simple and only allow one layer to be moved at a time.</p><p>To rearrange a layer in the list, we first need to listen for an event where the user clicks a LayerItem. In such an event, we remember the position of the layer that we want to move and change the cursor to indicate that a drag and drop is underway. When the user releases the mouse-click, we loop through the screen coordinates of all the LayerItem widgets to detect the layer position at which the mouse was released. Note that the index position of the layer that is rendered on top of all others is the first one in the list of LayerItems, but is the last one in the sequence of layers in the LayerGroup. We add this listening behavior in the LayerItem's <code class="literal">__init__</code> method:</p><div class="informalexample"><pre class="programlisting">        def start_drag(event):
            self.dragging = event.widget.master.master
            self.config(cursor="exchange")
            
        def stop_drag(event):
            
            # find closest layerindex to release event
            def getindex(layeritem):
                return self.layerspane.layers.get_position(layeritem.renderlayer)
            
            goingdown = event.y_root - (self.dragging.winfo_rooty() + self.dragging.winfo_height() / 2.0) &gt; 0
            if goingdown:
                i = len(self.layerspane.layersview.winfo_children())
                for layeritem in sorted(self.layerspane.layersview.winfo_children(), key=getindex, reverse=True):
                    if event.y_root &lt; layeritem.winfo_rooty() + layeritem.winfo_height() / 2.0:
                        break
                    i -= 1
            else:
                i = 0
                for layeritem in sorted(self.layerspane.layersview.winfo_children(), key=getindex):
                    if event.y_root &gt; layeritem.winfo_rooty() - layeritem.winfo_height() / 2.0:
                        break
                    i += 1
                    
            # move layer
            frompos = self.layerspane.layers.get_position(self.dragging.renderlayer)
            if i != frompos:
                self.layerspane.move_layer(frompos, i)
                
            # clean up
            self.dragging = None
            self.config(cursor="arrow")

        self.dragging = None
        self.namelabel.bind("&lt;Button-1&gt;", start_drag)
        self.namelabel.bind("&lt;ButtonRelease-1&gt;", stop_drag)</pre></div><p>After the user has interacted with the LayersPane to tell it where to move a layer, we tell its associated LayerGroup to rearrange the layer sequence based on the "from and to" positions. We then<a id="id182" class="indexterm"/> tell all of the MapCanvas connected to that LayerGroup to update their drawing order and the image being displayed. We must define this method in the <code class="literal">LayersPane</code> class:</p><div class="informalexample"><pre class="programlisting">    def move_layer(self, fromindex, toindex):
        self.layers.move_layer(fromindex, toindex)
        for mapcanvas in self.layers.connected_maps:
            mapcanvas.update_draworder()
            mapcanvas.mapview.update_image()
        self.update_layerlist()</pre></div></div></div><div class="section" title="Zooming the map image"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Zooming the map image</h2></div></div></div><p>At this point, we<a id="id183" class="indexterm"/> can add and remove layers to and from the map and rearrange their sequence, but we still cannot interact with the map itself. Here comes one of the great things of making our own application. One thing that users may find difficult with existing GIS software<a id="id184" class="indexterm"/> is that they have to choose between one of two modes of interacting with the map: one is the <a id="id185" class="indexterm"/>
<span class="strong"><strong>pan</strong></span> mode so that clicking and dragging the mouse moves the map accordingly, and the other is the <span class="strong"><strong>rectangle-zoom</strong></span> mode<a id="id186" class="indexterm"/> where click and drag defines the area to zoom to.</p><p>Switching between these two modes is not very conducive to map exploration which is often more of a dynamic and iterative process, involving simultaneous use of zooming and panning when using Google Maps. Now that we have the power to decide, let's combine zoom and pan by controlling them with double clicks and click and drag, respectively.</p><p>The actual zooming of the map is done by asking the MapCanvas to redraw the map at the given zoom level. We bind a 2x zoom factor method centered on the mouse to events where the user double clicks on the map. We give such zooming a one-third of a second lag after the user<a id="id187" class="indexterm"/> stops clicking so that the user can double click many times in a row for extra large zoom without overwhelming the application to render multiple<a id="id188" class="indexterm"/> incremental zoom images. Each time a zoom level is changed, we also ask to update the status bar's zoom unit scale, which is given to us by the PyAgg rendering canvas. All of this listening behavior we add to the MapView's <code class="literal">__init__</code> method, inside <code class="literal">app/toolkit/map.py</code>:</p><div class="informalexample"><pre class="programlisting">        # Bind interactive zoom events
        def doubleleft(event):
            self.zoomfactor += 1
            canvasx,canvasy = self.canvasx(event.x),self.canvasy(event.y)
            self.zoomcenter = self.renderer.pixel2coord(canvasx, canvasy)
            self.zoomdir = "in"
            # record zoom time
            self.last_zoomed = time.time()
            # schedule to check if finished zooming after x millisecs
            self.after(300, zoom_if_finished)

        def doubleright(event):
            self.zoomfactor += 1
            canvasx,canvasy = self.canvasx(event.x),self.canvasy(event.y)
            self.zoomcenter = self.renderer.pixel2coord(canvasx, canvasy)
            self.zoomdir = "out"
            # record zoom time
            self.last_zoomed = time.time()
            # schedule to check if finished zooming after x millisecs
            self.after(300, zoom_if_finished)

        def zoom_if_finished():
            if time.time() - self.last_zoomed &gt;= 0.3:
                if self.zoomdir == "out":
                    self.zoomfactor *= -1
                self.renderer.zoom_factor(self.zoomfactor, center=self.zoomcenter)
                self.threaded_rendering()
                # reset zoomfactor
                self.zoomfactor = 1
                self.last_zoomed = None

        self.bind("&lt;Double-Button-1&gt;", doubleleft)
        self.bind("&lt;Double-Button-3&gt;", doubleright)</pre></div><div class="section" title="Map panning and one-time rectangle zoom"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec22"/>Map panning and one-time rectangle zoom</h3></div></div></div><p>Panning the map is relatively easy since the rendered map image is simply an image placed inside a Tkinter scrollable Canvas widget. The rendered map image is always placed at the Tkinter Canvas' [0,0] coordinates in the top-left corner, but when we pan the map, we make the image start<a id="id189" class="indexterm"/> following the mouse. After we let go, the renderer begins rendering a new map by offsetting the MapCanvas' PyAgg coordinate system and rerendering the map. We also allow for an alternative zoom mode that uses these click and release events to perform a conventional rectangle zoom, along with the visual guide of Tkinter's built-in canvas rectangle drawing. This rectangle zoom mode should only be as a one-time event that defaults back to panning, since rectangle zoom is relatively rarely needed. To indicate when we are in rectangle zoom mode, we also replace the cursor with something like a magnifying glass icon whenever it is over the MapView widget, so you will need to find and save a <code class="literal">rect_zoom.png</code> image to <code class="literal">app/icons</code>. Moving the mouse over the map generally should also display the mouse coordinates in the status bar. We define this in the <code class="literal">__init__</code> method of the MapView widget, in <code class="literal">app/toolkit/map.py</code>:</p><div class="informalexample"><pre class="programlisting">        def mousepressed(event):
            if self.last_zoomed: return
            self.mousepressed = True
            self.startxy = self.canvasx(event.x), self.canvasy(event.y)
            if self.mouse_mode == "zoom":
                startx,starty = self.startxy
                self.rect = self.create_rectangle(startx, starty, startx+1, starty+1, fill=None)

        def mousemoving(event):
            if self.statusbar:
                # mouse coords
                mouse = self.canvasx(event.x), self.canvasy(event.y)
                xcoord,ycoord = self.renderer.pixel2coord(*mouse)
                self.statusbar.mouse.set_text("%3.8f , %3.8f" %(xcoord,ycoord) )
            if self.mouse_mode == "pan":
                if self.mousepressed:
                    startx,starty = self.startxy
                    curx,cury = self.canvasx(event.x), self.canvasy(event.y)
                    xmoved = curx - startx
                    ymoved = cury - starty
                    self.coords(self.image_on_canvas, xmoved, ymoved) # offset the image rendering
            elif self.mouse_mode == "zoom":
                curx,cury = self.canvasx(event.x), self.canvasy(event.y)
                self.coords(self.zoomicon_on_canvas, curx, cury)
                if self.mousepressed:
                    startx,starty = self.startxy
                    self.coords(self.rect, startx, starty, curx, cury)

        def mousereleased(event):
            if self.last_zoomed: return
            self.mousepressed = False
            if self.mouse_mode == "pan":
                startx,starty = self.startxy
                curx,cury = self.canvasx(event.x), self.canvasy(event.y)
                xmoved = int(curx - startx)
                ymoved = int(cury - starty)
                if xmoved or ymoved:
                    # offset image rendering
                    self.renderer.offset(xmoved, ymoved) 
                    self.threaded_rendering()
            elif self.mouse_mode == "zoom":
                startx,starty = self.startxy
                curx,cury = self.canvasx(event.x), self.canvasy(event.y)
                self.coords(self.rect, startx, starty, curx, cury)
                # disactivate rectangle selector
                self.delete(self.rect)
                self.event_generate("&lt;Leave&gt;") # fake a mouseleave event to destroy icon
                self.mouse_mode = "pan"
                # make the zoom
                startx,starty = self.renderer.drawer.pixel2coord(startx,starty)
                curx,cury = self.renderer.drawer.pixel2coord(curx,cury)
                bbox = [startx, starty, curx, cury]
                self.renderer.zoom_bbox(*bbox)
                self.threaded_rendering()

        def mouseenter(event):
            if self.mouse_mode == "zoom":
                # replace mouse with zoomicon
                self.zoomicon_tk = icons.get("zoom_rect.png", width=30, height=30)
                self.zoomicon_on_canvas = self.create_image(event.x, event.y, anchor="center", image=self.zoomicon_tk )
                self.config(cursor="none")

        def mouseleave(event):
            if self.mouse_mode == "zoom":
                # back to normal mouse
                self.delete(self.zoomicon_on_canvas)
                self.config(cursor="arrow")

        def cancel(event):
            if self.mouse_mode == "zoom":
                self.event_generate("&lt;Leave&gt;") # fake a mouseleave event to destroy icon
                self.mouse_mode = "pan"
                if self.mousepressed:
                    self.delete(self.rect)

        # bind them
        self.bind("&lt;Button-1&gt;", mousepressed, "+")
        self.bind("&lt;Motion&gt;", mousemoving)
        self.bind("&lt;ButtonRelease-1&gt;", mousereleased, "+")
        self.bind("&lt;Enter&gt;", mouseenter)
        self.bind("&lt;Leave&gt;", mouseleave)
        self.winfo_toplevel().bind("&lt;Escape&gt;", cancel)</pre></div></div><div class="section" title="A navigation toolbar"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec23"/>A navigation toolbar</h3></div></div></div><p>In order to activate one-time rectangle zoom, we create a navigation toolbar in the <code class="literal">app/toolkit/toolbars.py</code> file that <a id="id190" class="indexterm"/>has to be connected to a MapView, and give it a button that simply turns on the one-time zoom mode of its connected MapView. While we are at it, we also create a toolbar button to zoom to the global bounding box of all of the layers in the MapView's <code class="literal">layergroup</code>. Remember to find and save icons for these two new buttons, <code class="literal">zoom_rect.png</code> and <code class="literal">zoom_global.png</code>. Refer to the following figure:</p><div class="mediaobject"><img src="images/5407OS_04_03.jpg" alt="A navigation toolbar"/></div><div class="informalexample"><pre class="programlisting">class NavigateTB(tk.Frame):
    def __init__(self, master, **kwargs):
        # get theme style
        style = style_toolbar_normal.copy()
        style.update(kwargs)
        
        # Make this class a subclass of tk.Frame and add to it
        tk.Frame.__init__(self, master, **style)

        # Modify some options
        self.config(width=80, height=40)

    def assign_mapview(self, mapview):
        mapview.navigation = self
        self.mapview = mapview

        # Add buttons
        self.global_view = IconButton(self, text="zoom global", command=self.mapview.zoom_global)
        self.global_view.set_icon("zoom_global.png", width=32, height=32)
        self.global_view.pack(side="left", padx=2, pady=2)
        self.zoom_rect = IconButton(self, text="zoom to rectangle", command=self.mapview.zoom_rect)
        self.zoom_rect.set_icon("zoom_rect.png", width=32, height=32)
        self.zoom_rect.pack(side="left", padx=2, pady=2)</pre></div><p>The actual zooming<a id="id191" class="indexterm"/> calls to the renderer are defined as methods of the MapView widget, in <code class="literal">app/toolkit/map.py</code>:</p><div class="informalexample"><pre class="programlisting">    def zoom_global(self):
        layerbboxes = (layer.data.bbox for layer in self.renderer.layers)
        xmins,ymins,xmaxs,ymaxs = zip(*layerbboxes)
        globalbbox = [min(xmins), min(ymins), max(xmaxs), max(ymaxs)]
        self.renderer.zoom_bbox(*globalbbox)
        self.threaded_rendering()

    def zoom_rect(self):
        self.mouse_mode = "zoom"
        self.event_generate("&lt;Enter&gt;")

    def zoom_bbox(self, bbox):
        self.renderer.zoom_bbox(*bbox)
        self.threaded_rendering()</pre></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Putting it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Putting it all together</h1></div></div></div><p>We have now defined all of the necessary building blocks of a basic rendering application. These can be used <a id="id192" class="indexterm"/>and combined in many different ways. For instance, if you want to you can build an application that has a single LayerGroup/LayersPane connected with multiple independently zoomable MapViews, to view different locations of the same data simultaneously. In this book, we go for a more basic desktop GIS look.</p><p>Let's return to our GUI class that we created in <a class="link" href="ch03.html" title="Chapter 3. Designing the Visual Look of Our Application">Chapter 3</a>, <span class="emphasis"><em>Designing the Visual Look of Our Application</em></span>, and add more content to its startup phase. First we give the GUI a LayerGroup instance to hold our layers and link it to both the MapView and LayersPane widgets so they can communicate later on.</p><p>We also need a button to add data layers. There are many possible places to put such an important button, but for our current application, let's place it in the header of the LayersPane widget so that all things related to layers are kept logically grouped together. We want this button to have an icon, so let's first find and save a suitable icon as <code class="literal">add_layer.png</code> in the <code class="literal">app/icons</code> folder. Specifically, we want to create a button to add layers, assign it with our icon, and place it on the right side of the LayersPane header. When the button is clicked, it will run a <code class="literal">selectfiles</code> function, which opens a Tkinter file selection dialog window and adds all the selected files as new layers.</p><p>Loading data from a file may require that we specify the correct text encoding of the data. By default, we set it to <code class="literal">utf8</code>, but the user should be able to customize this and other data options in a separate data settings window. We store the data options dictionary as an attribute of the GUI class and allow it to be changed by user input in the settings window. This settings window is easily defined using our <code class="literal">RunToolFrame</code> template. To allow users to access this settings window, we add a data settings button right next to the add layer button. As usual, find and download an icon to use for the button, calling it <code class="literal">data_options.png</code>.</p><p>After that, let's create a ribbon tab for visualizing, giving it a button to save the contents of our MapView widget to an image file. Remember to find and save a <code class="literal">save_image.png</code> file, so we can give this button an icon. Finally, we add the navigation toolbar that we created earlier, hanging in the air in the upper part of the MapView.</p><p>Let's now add this new<a id="id193" class="indexterm"/> code to our GUI class' <code class="literal">__init__</code> method, inside <code class="literal">app/builder.py</code>:</p><div class="informalexample"><pre class="programlisting">        # Create a layergroup that keeps track of all the loaded data
        # ...so that all widgets can have access to the same data
        self.layers = pg.renderer.LayerGroup()

        # Assign layergroup to layerspane and mapview
        self.layerspane.assign_layergroup(self.layers)
        self.mapview.assign_layergroup(self.layers)

        ## Visualize tab
        visitab = self.ribbon.add_tab("Visualize")
        ### (Output toolbar)
        output = visitab.add_toolbar("Output")
        def save_image():
            filepath = asksaveasfilename()
            self.mapview.renderer.img.save(filepath)
        output.add_button(text="Save Image", icon="save_image.png",
                               command=save_image)

        # Place add layer button in the header of the layerspane
        def selectfiles():
            filepaths = askopenfilenames()
            for filepath in filepaths:
                encoding = self.data_options.get("encoding")
                self.layerspane.add_layer(filepath, encoding=encoding)
        button_addlayer = IconButton(self.layerspane.header, command=selectfiles)
        button_addlayer.set_icon("add_layer.png", width=27, height=27)
        button_addlayer.pack(side="right", anchor="e", ipadx=3, padx=6, pady=3,)

        # Place button for setting data options
        self.data_options = {"encoding": "utf8"}
        button_data_options = IconButton(self.layerspane.header)
        button_data_options.set_icon("data_options.png", width=24, height=21)
        button_data_options.pack(side="right", anchor="e", ipadx=5, ipady=3, padx=6, pady=3,)

        # Open options window on button click
        def data_options_window():
            win = popups.RunToolWindow(self)
            
            # assign status bar
            win.assign_statusbar(self.statusbar)
            
            # place option input for data encoding
            win.add_option_input("Vector data encoding", valuetype=str,
                                 argname="encoding", default=self.data_options.get("encoding"))
            
            # when clicking OK, update data options
            def change_data_options(*args, **kwargs):
                """
                Customize settings for loading and saving data.

                Vector data encoding: Common options include "utf8" or "latin"
                """
                # update user settings
                self.data_options.update(kwargs)
                
            def change_data_options_complete(result):
                # close window
                win.destroy()
                
            win.set_target_method("Changing data options", change_data_options)
            win.set_finished_method(change_data_options_complete)
            
        button_data_options["command"] = data_options_window

        # Attach floating navigation toolbar inside mapwidget
        self.navigation = NavigateTB(self.mapview)
        self.navigation.place(relx=0.5, rely=0.03, anchor="n")
        self.navigation.assign_mapview(self.mapview)</pre></div><p>And that is about it! Your application should now be ready to use for rendering map data. Run <code class="literal">guitester.py</code>, and try<a id="id194" class="indexterm"/> to add some data and interact with the map. If you have done everything correctly, and, depending on your data, your screen should look something like this:</p><div class="mediaobject"><img src="images/5407OS_04_04.jpg" alt="Putting it all together"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Summary</h1></div></div></div><p>This chapter has been a fundamental milestone. We built a working geographic rendering module based on rearrangable layers in a LayerGroup, created a MapView widget for interactive displaying of these map renderings, made a visual LayersPane of the layers in our map, and enabled interactive zooming and panning of the MapView.</p><p>After following each step, you should now have what looks and feels like a GIS data inspecting application. Of course, a more sophisticated GIS needs additional methods not only to inspect data, but also to manage and edit data—which is what we turn to next.</p></div></div>
</body></html>