["```py\n    from qiskit import Aer, IBMQ\n    if not IBMQ.active_account():\n        IBMQ.load_account()\n    provider = IBMQ.get_provider()\n    ```", "```py\n    backends=Aer.backends()\n    print(\"\\nAer backends:\\n\\n\",backends)\n    ```", "```py\n    simulators=[]\n    for sim in range(0,len(backends)):\n        backend = Aer.get_backend(str(backends[sim]))\n        simulators.append(backend.configuration())\n    ```", "```py\n    ibmq_simulator=provider.backends(simulator=True)\n    simulators.append(provider.get_backend(str(ibmq_simulator[0])). simulator[0])).configuration())\n    ```", "```py\n    # Display the raw simulator configuration details\n    print(\"\\nSimulator configuration details:\")\n    for sim in range(0,len(simulators)):\n        print(\"\\n\")\n        print(simulators[sim].backend_name)\n        print(simulators[sim].to_dict())\n    ```", "```py\n# Fish out criteria to compare\nprint(\"\\n\")\nprint(\"{0:25} {1:<10} {2:<10} {3:<10}\".    format(\"Name\",\"#Qubits\",\"Max shots.\",\"Description\"))\nprint(\"{0:25} {1:<10} {2:<10} {3:<10}\".    format(\"----\",\"-------\",\"--------\",\"------------\"))\ndescription=[]\nfor sim in range(0,len(simulators)):\n    if simulators[sim].local==True:\n        description.append(simulators[sim].description)\n    elif simulators[sim].local==False:\n        description.append(\"Non-local IBM Quantum             simulator\")\n    print(\"{0:25} {1:<10} {2:<10} {3:<10}\".        format(simulators[sim].backend_name, \n        simulators[sim].n_qubits,         simulators[sim].max_shots, description[sim]))\n```", "```py\n    # Import Qiskit\n    from qiskit import QuantumCircuit\n    from qiskit import Aer, IBMQ, execute\n    # Import visualization tools\n    from qiskit.tools.visualization import plot_histogram\n    from qiskit.tools.monitor import job_monitor\n    # Load account\n    if not IBMQ.active_account():\n        IBMQ.load_account()\n    provider = IBMQ.get_provider() \n    ```", "```py\n    # Enter number of SWAP gates to include with your circuit # with (default 10)\n    user_input = input(\"Enter number of SWAP gates to use:\")\n    try:\n       n = int(user_input)\n    except ValueError:\n       n=10\n    n_gates=n\n    ```", "```py\n    # Construct quantum circuit\n    circ = QuantumCircuit(2, 2)\n    circ.x(0)\n    while n >0:\n        circ.swap(0,1)\n        circ.barrier()\n        n=n-1\n    circ.measure([0,1], [0,1])\n    print(\"Circuit with\",n_gates,\"SWAP gates.\\n\",circ)\n    ```", "```py\n    # Select the QasmSimulator from the Aer provider\n    simulator = Aer.get_backend('qasm_simulator')\n    # Execute and get counts\n    result = execute(circ, simulator,     shots=simulator.configuration().max_shots).result()\n    counts = result.get_counts(circ)\n    print(\"Simulated SWAP counts:\",counts)\n    display(plot_histogram(counts, title='Simulated counts     for '+str(n_gates)+' SWAP gates.'))\n    ```", "```py\nSimulated SWAP counts: {'01': 10000}\n```", "```py\nSimulated SWAP counts: {'01': 100000}\n```", "```py\n# Import the least busy backend\nfrom qiskit.providers.ibmq import least_busy\nbackend = least_busy(provider.backends(n_qubits=5,     operational=True, simulator=False))\nprint(\"Least busy backend:\",backend)\n# Execute and get counts\njob = execute(circ, backend, shots=backend.configuration().    max_shots)\njob_monitor(job)\nnisq_result=job.result()\nnisq_counts=nisq_result.get_counts(circ)\nprint(\"NISQ SWAP counts:\",nisq_counts)\ndisplay(plot_histogram(nisq_counts, title='Counts for     '+str(n_gates)+' SWAP gates on '+str(backend)))\n```", "```py\nLeast busy backend: ibmq_vigo\nJob Status: job has successfully run\nNISQ SWAP counts: {'00': 1002, '10': 585, '11': 592, '01': 6013}\n```", "```py\n# Comparing the circuit with the transpiled circuit\nfrom qiskit.compiler import transpile\ntrans_swap = transpile(circ, backend)\nprint(trans_swap)\nprint(\"Basis gates:\",backend.configuration().basis_gates)\nprint(\"SWAP circuit depth:\",circ.depth(),\"gates\")\nprint(\"Transpiled SWAP circuit depth:\",    trans_swap.depth(),\"gates\")\n```", "```py\nBasis gates: ['u1', 'u2', 'u3', 'cx', 'id']\nSWAP circuit depth: 12 gates\nTranspiled SWAP circuit depth: 32 gates\n```", "```py\n    def select_backend():\n        # Get all available and operational backends.\n        available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits > 1 and         b.status().operational)\n        # Fish out criteria to compare\n        print(\"{0:20} {1:<10} {2:<10}\".format(\"Name\",        \"#Qubits\",\"Pending jobs\"))\n        print(\"{0:20} {1:<10} {2:<10}\".format(\"----\",        \"-------\",\"------------\"))        \n        for n in range(0, len(available_backends)):\n            backend = provider.get_backend(str(            available_backends[n]))\n            print(\"{0:20} {1:<10}\".format(backend.name(),            backend.configuration().n_qubits),            backend.status().pending_jobs)\n        select_backend=input(\"Select a backend (        'exit' to end): \")\n        if select_backend!=\"exit\":\n            backend = provider.get_backend(select_backend)\n        else:\n            backend=select_backend\n        return(backend)\n    ```", "```py\n    def build_noise_model(backend):\n        # Construct the noise model from backend\n        noise_model = NoiseModel.from_backend(backend)\n        print(noise_model)\n        return(noise_model)\n    ```", "```py\n    def execute_circuit(backend, noise_model):\n        # Basis gates for the noise model\n        basis_gates = noise_model.basis_gates\n        # Coupling map\n        coupling_map = backend.configuration().coupling_map\n        print(\"Coupling map: \",coupling_map)\n    ```", "```py\n        circ = QuantumCircuit(3, 3)\n        circ.h(0)\n        circ.cx(0, 1)\n        circ.cx(0, 2)\n        circ.measure([0,1,2], [0,1,2])\n        print(circ)\n        # Execute on QASM simulator and get counts\n        counts = execute(circ, Aer.get_backend(        'qasm_simulator')).result().get_counts(circ)\n        display(plot_histogram(counts, title='Ideal counts         for 3-qubit GHZ state on local qasm_simulator'))\n    ```", "```py\n        counts_noise = execute(circ, Aer.get_backend(        'qasm_simulator'), noise_model=noise_model,         coupling_map=coupling_map,         basis_gates=basis_gates).result().get_        counts(circ)\n        display(plot_histogram(counts_noise, title=\"Counts         for 3-qubit GHZ state with noise model on local         qasm simulator\"))\n        # Execute noisy simulation on the ibmq_qasm_simulator     # and get counts\n        counts_noise_ibmq = execute(circ, provider.get_        backend('ibmq_qasm_simulator'),         noise_model=noise_model, coupling_map=coupling_        map, basis_gates=basis_gates).result().get_        counts(circ)\n        display(plot_histogram(counts_noise_ibmq,         title=\"Counts for 3-qubit GHZ state with noise         model on IBMQ qasm simulator\"))    \n    ```", "```py\n        job = execute(circ, backend)\n        job_monitor(job)\n        counts_ibmq=job.result().get_counts()  \n        title=\"Counts for 3-qubit GHZ state on IBMQ backend \"         + backend.name()\n        display(plot_histogram(counts_ibmq, title=title))\n    ```", "```py\n        display(plot_histogram([counts, counts_noise,         counts_noise_ibmq, counts_ibmq], bar_labels=True,         legend=[\"Baseline\",\"Noise on simulator\",         \"Noise on IBMQ simulator\", \"IBM Q backend\"],         title=\"Comparison\"))\n    ```", "```py\n[[ 0.707+0.j  0.707+0.j]\n[ 0.707+0.j -0.707+0.j]]\n```", "```py\n    def circuits():\n        circuits=[]\n        # Circuit 1 - one qubit in superposition\n        circuit1 = QuantumCircuit(1,1)\n        circuit1.h(0)\n        # Circuit 2 - two qubits in superposition\n        circuit2 = QuantumCircuit(2,2)\n        circuit2.h([0,1])\n        # Circuit 3 - two entangled qubits\n        circuit3 = QuantumCircuit(2,2)\n        circuit3.h([0])\n        circuit3.cx(0,1)\n        # Bundle the circuits in a list and return the list\n        circuits=[circuit1,circuit2,circuit3]\n        return(circuits)\n    ```", "```py\n    # Calculate and display the unitary matrix \n    def show_unitary(circuit):\n        global unit\n        backend = Aer.get_backend('unitary_simulator') \n        unit=execute(circuit, backend).result().        get_unitary(qc)\n        print(\"Unitary matrix for the circuit:\\n-------------        ------------------\\n\",unit)\n    ```", "```py\n    def calc_unitary(circuit,unitary):\n        # Set number of shots\n        shots=1000\n        # Calculate possible number of outcomes, 2^n qubits\n        binary=int(pow(2,circuit.width()/2))    \n        # Set the binary key for correct binary conversion\n        bin_key='0'+str(int(circuit.width()/2))+'b'        \n        # Create a qubit vector based on all qubits in the     # ground state  and a results list for all     # possible outcomes.\n        vector=[1]\n        outcomes=[format(0, bin_key)+\":\"]\n        for q in range (1,binary):\n            vector.append(0)\n            outcomes.append(format(q, bin_key)+\":\")\n        qubits=np.array(vector)    \n        # Calculate the dot product of the unitary matrix and     # the qubits set by the qubits parameter.\n        a_thru_d=np.dot(unitary,qubits)    \n        # Print the probabilities (counts) of the calculated     # outcome.\n        calc_counts={}\n        for out in range (0,len(a_thru_d)):\n            calc_counts[outcomes[out]]=(int(pow(abs(            a_thru_d[out]),2)*shots))\n        print(\"\\nCalculated counts:\\n------------------\\        n\",calc_counts)    \n        # Automate creation of measurement gates from number     # of qubits \n        # Run the circuit on the backend\n        if circuit.width()==2:\n            circuit.measure([0],[0])\n        else: \n            circuit.measure([0,1],[0,1])\n        backend_count = Aer.get_backend('qasm_simulator') \n        counts=execute(circuit, backend_count,shots=shots).        result().get_counts(qc)    \n        # Print the counts of the measured outcome.\n        print(\"\\nExecuted counts:\\n----------------\\        n\",counts,\"\\n\") \n    ```", "```py\n    def s_vec(circuit):\n        backend = Aer.get_backend('statevector_simulator') \n        print(circuit.num_qubits, \"qubit quantum         circuit:\\n------------------------\")\n        print(circuit)\n        psi=execute(circuit, backend).result().        get_statevector(circuit)\n        print(\"State vector for the\",circuit.num_qubits,         \"qubit circuit:\\n\\n\",psi)\n        print(\"\\nState vector as Bloch sphere:\")\n        display(plot_bloch_multivector(psi))\n        print(\"\\nState vector as Q sphere:\")\n        display(plot_state_qsphere(psi))\n        measure(circuit)\n        input(\"Press enter to continue...\\n\")\n    ```", "```py\n    backend = Aer.get_backend('statevector_simulator')\n    ```", "```py\n    def measure(circuit):\n        measure_circuit=QuantumCircuit(circuit.width())\n        measure_circuit+=circuit\n        measure_circuit.measure_all()\n        #print(measure_circuit)\n        backend_count = Aer.get_backend('qasm_simulator') \n        counts=execute(measure_circuit,         backend_count,shots=10000).result().        get_counts(measure_circuit)    \n        # Print the counts of the measured outcome.\n        print(\"\\nOutcome:\\n\",{k: v / total for total in         (sum(counts.values()),) for k, v in         counts.items()},\"\\n\")\n    ```"]