- en: Chapter 9. Completing the ForestTrails Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will complete our implementation of the ForestTrails application
    that we started building in the preceding chapter. So far, our application displays
    the basemap and lets the user zoom and pan across the map. We've also implemented
    the track editing mode, though the user can't enter or edit track data yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will add the following features to the ForestTrails application:'
  prefs: []
  type: TYPE_NORMAL
- en: Map tools that let the user add, edit, and delete tracks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A toolbar action that lets the user view and edit the attributes for a track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Set Start Point** and **Set End Point** actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating and displaying the shortest available path between the two selected
    points using a memory-based map layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Add Track map tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first task is to let the user add a new track while in the track editing
    mode. This involves defining a new map tool, which we will call `AddTrackTool`.
    Before we start implementing the `AddTrackTool` class, however, we're going to
    create a mixin class that provides various helper methods for our map tools. We'll
    call this mixin class `MapToolMixin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our initial implementation of the `MapToolMixin` class, which should
    be placed near the top of your `mapTools.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've seen both the `transformCoordinates()` and `calcTolerance()` methods before
    when we created the geometry editing map tools in [Chapter 7](part0055_split_000.html#page
    "Chapter 7. Selecting and Editing Features in a PyQGIS Application"), *Selecting
    and Editing Features in a PyQGIS Application*. The only difference is that we're
    storing a reference to the edited map layer so that we don't have to supply it
    as a parameter each time we want to calculate the tolerance or transform coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start implementing the `AddTrackTool` class. This is very similar
    to `CaptureTool` we defined in [Chapter 7](part0055_split_000.html#page "Chapter 7. Selecting
    and Editing Features in a PyQGIS Application"), *Selecting and Editing Features
    in a PyQGIS Application*, except that it only captures LineString geometries and
    it creates a new track feature with default attributes when the user finishes
    defining the track. Here is the class definition with the `__init__()` method
    for our new map tool, which should be placed in the `mapTools.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our class inherits from both `QgsMapTool` and `MapToolMixin`.
    We also call the `setLayer()` method so that our mixin knows which layer to work
    with. This also makes the currently edited layer available via `self.layer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next define the various event handling methods for our map tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we've seen this logic before in the `CaptureTool` class. The only
    difference is that we're only capturing LineString geometries, so we don't need
    to worry about the capture mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now get to the `startCapturing()` and `stopCapturing()` methods. These create
    and release the rubber bands used by our map tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `addVertex()` method, which adds a new vertex to the track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that we call `self.transformCoordinates()`, which is a method defined by
    our mixin class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next method is `removeLastVertex()`. This deletes the last added vertex
    when the user presses the *Delete* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define the `getCapturedPoints()` method, which returns either the set
    of points the user clicked on or `None` if the user didn''t click on enough points
    to make a LineString:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final method is `pointsCaptured()`, which responds when the user finishes
    clicking on the points for a new track. Unlike the equivalent method in `CaptureTool`,
    we have to set the various attributes for the new track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve defined our map tool, let''s update our application to use
    this tool. Back in the `forestTrails.py` module, add the following to the end
    of the `setupMapTools()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define our `addTrack()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the user checks the **Add Track** action, we activate the Add Track tool.
    If the user unchecks the action by clicking on it again, we will switch back to
    the pan mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to define a helper method called `onTrackAdded()`. This method
    responds when the user adds a new track to our track layer. Here is the implementation
    of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Testing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of this code implemented, it''s time to test out our application.
    Run the appropriate startup script, and zoom in slightly on the map. Then click
    on the **Edit** action, followed by the **Add Track** action. All going well,
    you should be able to click on the map to define the vertices of a new track.
    When you''re done, press the *Return* key to create the new track. The result
    should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the application](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you then click on the Edit Tracks icon again, you'll be asked if you want
    to save your changes. Go ahead, and your new track should be made permanent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go back to the track editing mode and try creating a second track that
    connects with the first. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the application](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you then zoom in, you''ll quickly discover a major flaw in the design of
    our application, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the application](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The tracks aren't connected together. Since the user can click anywhere on the
    map, there's no way of ensuring that the tracks are connected—and if the tracks
    aren't connected, the **Find Shortest Path** command won't work.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways we can solve this problem, but the easiest one in this
    case is to implement **vertex snapping**, that is, if the user clicks close to
    an existing vertex, we snap the click location onto the vertex so that the various
    tracks are connected.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex snapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement vertex snapping, we''re going to add some new methods to `MapToolMixin`.
    We''ll start with the `findFeatureAt()` method. This method finds a feature close
    to the click location. Here is the implementation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, this method takes an optional `excludeFeature` parameter. This
    lets us exclude a given feature from the search, which will be important later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we''ll define the `findVertexAt()` method, which identifies the vertex
    close to the given click location (if any). Here is the implementation of this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `QgsGeometry.closestVertex()` method to find the
    vertex closest to the given position and then see if that vertex is within the
    tolerance distance. If so, we return the vertex index for the clicked-on vertex;
    otherwise, we return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this method uses the `math.sqrt()` function. To be able to use
    this function, you''ll need to add the following near the top of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With these two new methods defined, we''re ready to start implementing vertex
    snapping. Here is the signature for the method we are going to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this method, `pos` is the click position (in canvas coordinates), `trackLayer`
    is a reference to our track layer (which contains the features and vertices we
    need to check), and `excludeFeature` is an optional feature to exclude when looking
    for nearby vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `excludeFeature` parameter will be useful when we start editing tracks.
    We'll use it to stop a track from snapping to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Upon completion, our method will return the coordinate of the clicked-on vertex.
    If the user didn't click anywhere near a feature, or close to a vertex, then this
    method will return the click position instead, converted to layer coordinates.
    This lets the user click on the map canvas, away from any vertices, to draw new
    features, while still snapping to an existing vertex when the user clicks on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of our `snapToNearestVertex()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use our `findFeatureAt()` method to search for features that
    are close to the given click point. If we find a feature, we then call `self.findVertexAt()`
    to find the vertex close to where the user clicked. Finally, if we find a vertex,
    we return the coordinates of that vertex. Otherwise, we return the original click
    position converted to layer coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these extensions to our mixin class, we can easily add snapping to our
    `AddTrack` tool. All we have to do is replace our `addVertex()` method with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have vertex snapping enabled, it'll be easy to ensure that our tracks
    are connected. Note that we'll also use vertex snapping when we edit a track and
    when the user selects the start and end points for the Shortest Available Path
    calculation. This is why we've added these methods to our mixin rather than to
    the `AddTrack` tool.
  prefs: []
  type: TYPE_NORMAL
- en: The Edit Track map tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next task is to implement the Edit Track action. To do this, we'll take
    `EditTool` we defined in [Chapter 7](part0055_split_000.html#page "Chapter 7. Selecting
    and Editing Features in a PyQGIS Application"), *Selecting and Editing Features
    in a PyQGIS Application*, and modify it to work specifically with tracks. Fortunately,
    we only need to support LineString geometries and can make use of our mixin class,
    which will simplify the implementation of this new map tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding our new class definition to the `mapTools.py` module,
    along with the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define our `canvasPressEvent()` method to respond when the user presses
    the mouse button over our map canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're using our mixin's methods to find the clicked-on feature
    and vertex. This simplifies the implementation of the `canvasPressedEvent()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now come to the `canvasMoveEvent()` and `canvasReleaseEvent()` methods,
    which are basically identical to the methods defined in `EditTool` from [Chapter
    7](part0055_split_000.html#page "Chapter 7. Selecting and Editing Features in
    a PyQGIS Application"), *Selecting and Editing Features in a PyQGIS Application*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `canvasDoubleClickEvent()` method is also very similar, the only difference
    being that we can use the `findFeatureAt()` method defined by our mixin class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the `moveVertexTo()` method, which moves the clicked-on vertex
    to the current mouse location. While the logic is very similar to the method with
    the same name in our `EditTool`, we also want to support vertex snapping so that
    the user can click on an existing vertex to connect two tracks together. Here
    is the implementation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our call to `snapToNearestVertex()` makes use of the `excludeFeature`
    parameter to exclude the clicked-on feature when finding a vertex to snap to.
    This ensures that we don't snap a feature to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `deleteVertex()` method, which is copied almost verbatim
    from the `EditTool` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this complex map tool implemented, we can now use it to let the user edit
    a track. Back in the `forestTrails.py` module, add the following to the end of
    the `setupMapTools()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We now want to replace our placeholder for the `editTrack()` method with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As with the `addTrack()` method, we switch to the edit tool when the user clicks
    on our action, and switch back to panning mode if the user clicks on the action
    a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is implement the `ForestTrailsWindow.onTrackEdited()`
    method to respond when the user makes a change to a track. Here is this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We simply need to remember that the track layer has been modified and redraw
    the map canvas to show the change. Note that we don't switch back to the panning
    mode, as the user will continue to make changes to the track vertices until he
    or she explicitly switches off the edit tool by clicking on the toolbar icon a
    second time, or by choosing a different action from the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: With this implemented, you can rerun your program, switch to track editing mode,
    and click on the **Edit Track** action to add, move, or delete vertices. If you
    look carefully, you'll see that the vertex you're dragging will snap to the vertex
    of another feature when you move the mouse close to it. As with the `EditTool`,
    you can double-click on a segment to add a new vertex, or press the *Ctrl* key
    and click on a vertex to delete it.
  prefs: []
  type: TYPE_NORMAL
- en: The Delete Track map tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now want to implement the **Delete Track** action. Fortunately, the map
    tool for doing is very simple, thanks to our mixin class. Add the following class
    definition to the `mapTools.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, back in the `forestTrails.py` module, add the following to the end of
    the `setupMapTools()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then replace the dummy `deleteTrack()` method with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a new `onTrackDeleted()` method to respond when the user deletes
    a track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this map tool, we now have all of the necessary logic for adding, editing,
    and deleting tracks. We now have a complete mapping application for maintaining
    a database of forest trails, and you can use this program to enter as many tracks
    as you want.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Delete Track map tool](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we're not finished yet. In particular, we can't yet specify the type
    of track; every track is a road at the moment. To get around this, our next task
    is to implement the **Get Info** action.
  prefs: []
  type: TYPE_NORMAL
- en: The Get Info map tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the user clicks on the **Get Info** item in the toolbar, we will activate
    a custom map tool that lets the user click on a track to display and edit the
    attributes for that track. Let''s walk through this implementation one step at
    a time, starting with the `GetInfoTool` class itself. Add the following to your
    `mapTools.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This map tool calls the `onGetInfo()` method (which is passed as a parameter
    to the map tool''s initializer) when the user clicks on a track. Let''s now use
    this map tool within our program by adding the following code to the end of our
    `setupMapTools()` method in the `forestTrails.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace our placeholder `getInfo()` method with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This activates the map tool when the user clicks on the toolbar icon. The last
    step is to implement the `onGetInfo()` method, which is called when the user selects
    the map tool and clicks on a track.
  prefs: []
  type: TYPE_NORMAL
- en: When `onGetInfo()` is called, we want to display to the user the various attributes
    of the clicked-on track. These attributes will be displayed in a dialog window,
    where the user can make changes if he/she wishes. When the user submits his/her
    changes, we will have to update the feature with the new attribute values and
    indicate that the track has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of our work will be setting up the dialog window so that the attributes
    can be displayed and edited by the user. To do this, we'll create a new class
    named `TrackInfoDialog`, which will be a subclass of `QDialog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `forestTrails.py` module, immediately before
    the `main()` function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__init__()` method will set up the contents of the dialog window. So far,
    we''ve initialized the dialog object itself, and given the window a title. Let''s
    now define a list of the available track types the user can choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we''ll want a list of the available direction options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also want a list of the available track status options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding sets of options defined, we can now start to lay out the
    contents of our dialog window. We''ll start by using a `QFormLayout` object that
    lets us lay out form labels and widgets side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We next want to define the various input widgets we''ll use to display and
    change the track attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the widgets themselves, let''s add them to the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to define the buttons at the bottom of our dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can place the form and our buttons within the dialog box, and lay
    everything out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'So much for the `__init__()` method. With the dialog box set up, we next want
    to define a method to copy the feature''s attributes in the dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method we need to define here is `saveAttributes()`, which stores
    the updated values from the dialog window back in the feature''s attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `TrackInfoDialog` class defined, we can finally implement the `onGetInfo()`
    method (in our `ForestTrailsWindow` class) to display the clicked-on track''s
    attributes in the dialog box, and save the changes if the user clicks on the **OK**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to run the program, switch to the editing mode, click
    on the **Get Info** toolbar icon, and then click on a feature to display the attributes
    for that feature. The resulting dialog window should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Get Info map tool](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You should be able to change any of these attributes and click on the **OK**
    button to save the changes. As you change the track type, status and direction,
    you should see the change reflected in the way the track is displayed on the map.
  prefs: []
  type: TYPE_NORMAL
- en: The Set Start Point and Set End Point actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Set Start Point** and **Set End Point** toolbar actions allow the user
    to set the start and end points in order to calculate the shortest path between
    these two points. To implement these actions, we're going to need a new map tool
    that lets the user click on a track vertex to select the starting or ending points.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By positioning the start point and the end point on vertices, we guarantee that
    the points lie on a track's LineString. We could theoretically be more sophisticated
    and snap the starting and ending points to anywhere along a track segment, but
    that's more work, and we're trying to keep the implementation simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `mapTools.py` module and add the following class definition
    to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This map tool uses the mixin's methods to identify which feature and vertex
    the user clicked on, and then calls the `onVertexSelected()` callback to allow
    the application to respond to the selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this map tool to implement the **Set Start Point** and **Set End
    Point** actions. Back in the `forestTrails.py` module, add the following to the
    end of the `setupMapTools()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'These two instances of `SelectVertexTool` use different callback methods to
    respond when the user clicks on a track vertex. Using these tools, we can now
    implement the `setStartPoint()` and `setEndPoint()` methods, which were just placeholders
    until now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we activate the map tool when the user clicks on the toolbar action,
    and switch back to the pan mode if the user clicks on the action a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left now are the two callback methods, `onStartPointSelected()`
    and `onEndPointSelected()`. Let''s start with the implementation of `onStartPointSelected()`.
    This method will start by asking the feature''s geometry to return the coordinates
    of the clicked-on vertex, which we store into `self.curStartPt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know where the start point will be, we want to show this start
    point on the map. If you remember, we previously created a memory-based map layer
    called `startPointLayer`, to display this point. We''ll need to first clear the
    contents of this memory layer, deleting any existing features, and then create
    a new feature at the given coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll redraw the map canvas to show the newly added point, and switch
    back to pan mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need to implement the `clearMemoryLayer()` method, but before we do,
    let''s also define the `onEndPointSelected()` callback method so that we can respond
    when the user clicks on the end point. The code for this is almost identical to
    the code for `onStartPointSelected()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To finish off these two actions, we'll need to implement the `clearMemoryLayer()`
    method and initialize the `curStartPt` and `curEndPt` instance variables so that
    the program knows when these variables are set for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation for the `clearMemoryLayer()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We simply obtain a list of all the features in the given memory layer, and then
    ask the data provider to delete them. Since this data is transient and held in
    memory, deleting all the features is no big deal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s initialize those two instance variables. Add the following
    to the end of your `ForestTrailsWindow.__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With all this implemented, the user can now click on a vertex to set the starting
    or ending point, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Set Start Point and Set End Point actions](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Find Shortest Path action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last feature of the ForestTrails that we will have to implement.
    When the user clicks on this toolbar icon, we want to calculate the shortest available
    path between the given start and end points. Fortunately, the QGIS **network analysis
    library** will do the actual calculation for us. All we have to do is run the
    shortest path calculation on the track layer, build the LineString that corresponds
    to this shortest path, and display that LineString geometry in our memory-based
    map layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this logic will be implemented within the `findShortestPath()` method.
    We''ll start our implementation with a bit of housekeeping: if the user unchecks
    the **Find Shortest Path** toolbar icon, we clear the shortest path memory layer,
    switch back to the panning mode, and redraw the map canvas to show the map without
    the previous path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the method will be executed when the user clicks on the **Find
    Shortest Path** toolbar action to check it. Add the following code to your method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code was copied from the PyQGIS cookbook with some changes in
    variable names to make the meaning clearer. At the end, `points` will be a list
    of `QgsPoint` objects defining the LineString geometry that connects the starting
    point to the ending point. The most interesting part of this method is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code creates an object which converts a set of LineString features
    into an abstract **graph** of the layer's features. The various parameters specify
    which of the track's attributes will be used to define the various directions
    in which a track can be followed. Bidirectional tracks can be followed in either
    direction, while forward and reverse directional tracks can be followed in only
    one direction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final parameter, with the value `3`, tells the director to treat any track
    without a valid direction value as bidirectional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the set of points that define the shortest path, it''s easy to
    display those points as a LineString in the memory layer and make the resulting
    path visible on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you define the starting and ending points, and then click on the **Find
    Shortest Path** toolbar action, the resulting path will be displayed as a blue
    line on the map, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Find Shortest Path action](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you look carefully at the preceding screenshot, you'll see that the path
    taken wasn't the shortest one; the starting point was at the bottom and the ending
    point was near the end of a one-way bike track, so the shortest available path
    involved taking the road back to the start of the one-way track, and then following
    it through to the endpoint. This is exactly the behavior that we would expect,
    and it is correct given the one-way nature of the tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the toolbar actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve finished creating all the necessary map tools and instance
    variables, we can finally implement the rest of the `adjustActions()` method to
    adjust the toolbar and menu items to reflect the current state of the system.
    Firstly, we want to change the final line of this method so that the **Find Shortest
    Path** action is only enabled if the start and end points have both been set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final part of this method, we''ll want to find the action that is associated
    with the current map tool and check that action, while unchecking all the others.
    To do this, add the following code to the end of your `adjustActions()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this code should go outside the `if...else` statement that you've
    already entered in this method.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our implementation of the `adjustActions()` method, and in fact
    it also completes our implementation of the entire ForestTrails system. Congratulations!
    We now have a complete working mapping application, with all the features implemented
    and working.
  prefs: []
  type: TYPE_NORMAL
- en: Suggested improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, no application is ever completely finished, and there are always
    things that could be improved upon. Here are a few ideas for things you could
    do to make the ForestTrails application even better:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding labels to the trail layer, using the `QgsPalLabeling` engine to only
    show only the track names when the map is zoomed in sufficiently so that the names
    can be read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the color used for the track based on the track type. For example,
    you might draw all bike trails in red, all walking trails in green, and all horse
    trails in yellow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a **View** menu where the user can select the types of tracks to be displayed.
    For example, the user might choose to hide all the horse trails, or show only
    the walking trails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the logic of the shortest path calculation to exclude any tracks that
    are currently closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding another map layer to display various obstacles on the map. An obstacle
    would be something that is blocking a track, and could be represented by a Point
    geometry. Typical obstacles might be things like fallen trees, landslides, and
    ongoing track maintenance. Depending on the obstacle, the trail might be closed
    until the obstacle is cleared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Print Composer** to generate a printable version of the map. This could
    be used to print maps based on the current state of the forest trails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finished implementing the ForestTrails mapping application.
    Our application now lets the user add, edit, and delete tracks; view and enter
    track attributes; set the start and end points; and display the shortest available
    path between those two points. As we implemented the application, we discovered
    an issue with tracks not connecting, and solved that problem by adding support
    for vertex snapping. We also learned how to write a custom `QDialog` to let the
    user view and edit attributes, and how to use the QGIS Network Analysis library
    to calculate the shortest available path between two points.
  prefs: []
  type: TYPE_NORMAL
- en: While the ForestTrails application is only one example of a specialized mapping
    application, it provides a good example of how to implement standalone mapping
    applications using PyQGIS. You should be able to use much of the code for your
    own mapping applications, as well as build on the techniques covered in previous
    chapters when you write your own mapping applications using Python and QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you've enjoyed the journey, and learned much about using QGIS as a mapping
    toolkit within your Python programs. Map on!
  prefs: []
  type: TYPE_NORMAL
