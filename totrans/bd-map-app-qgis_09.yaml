- en: Chapter 9. Completing the ForestTrails Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章 完成ForestTrails应用程序
- en: In this chapter, we will complete our implementation of the ForestTrails application
    that we started building in the preceding chapter. So far, our application displays
    the basemap and lets the user zoom and pan across the map. We've also implemented
    the track editing mode, though the user can't enter or edit track data yet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将完成我们在上一章中开始构建的 ForestTrails 应用程序的实施。到目前为止，我们的应用程序显示了基础地图，并允许用户在地图上缩放和平移。我们已实现了轨道编辑模式，尽管用户还不能输入或编辑轨道数据。
- en: 'In this chapter, we will add the following features to the ForestTrails application:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向 ForestTrails 应用程序添加以下功能：
- en: Map tools that let the user add, edit, and delete tracks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户添加、编辑和删除轨迹的地图工具
- en: A toolbar action that lets the user view and edit the attributes for a track
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工具栏动作，允许用户查看和编辑轨迹的属性
- en: The **Set Start Point** and **Set End Point** actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置起点** 和 **设置终点** 动作'
- en: Calculating and displaying the shortest available path between the two selected
    points using a memory-based map layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于内存的地图层计算并显示两个选定点之间的最短可用路径
- en: The Add Track map tool
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加轨迹地图工具
- en: Our first task is to let the user add a new track while in the track editing
    mode. This involves defining a new map tool, which we will call `AddTrackTool`.
    Before we start implementing the `AddTrackTool` class, however, we're going to
    create a mixin class that provides various helper methods for our map tools. We'll
    call this mixin class `MapToolMixin`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是让用户在轨道编辑模式下添加新的轨迹。这涉及到定义一个新的地图工具，我们将称之为 `AddTrackTool`。然而，在我们开始实现 `AddTrackTool`
    类之前，我们将创建一个混合类，为我们的地图工具提供各种辅助方法。我们将把这个混合类称为 `MapToolMixin`。
- en: 'Here is our initial implementation of the `MapToolMixin` class, which should
    be placed near the top of your `mapTools.py` module:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们 `MapToolMixin` 类的初始实现，应该放在你的 `mapTools.py` 模块顶部附近：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've seen both the `transformCoordinates()` and `calcTolerance()` methods before
    when we created the geometry editing map tools in [Chapter 7](part0055_split_000.html#page
    "Chapter 7. Selecting and Editing Features in a PyQGIS Application"), *Selecting
    and Editing Features in a PyQGIS Application*. The only difference is that we're
    storing a reference to the edited map layer so that we don't have to supply it
    as a parameter each time we want to calculate the tolerance or transform coordinates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建第 7 章 [选择和编辑 PyQGIS 应用程序中的要素](part0055_split_000.html#page "第 7 章. 选择和编辑
    PyQGIS 应用程序中的要素") 中的几何编辑地图工具时已经看到了 `transformCoordinates()` 和 `calcTolerance()`
    方法。唯一的区别是我们存储了对编辑地图层的引用，这样我们就不必每次计算容差或转换坐标时都提供它。
- en: 'We can now start implementing the `AddTrackTool` class. This is very similar
    to `CaptureTool` we defined in [Chapter 7](part0055_split_000.html#page "Chapter 7. Selecting
    and Editing Features in a PyQGIS Application"), *Selecting and Editing Features
    in a PyQGIS Application*, except that it only captures LineString geometries and
    it creates a new track feature with default attributes when the user finishes
    defining the track. Here is the class definition with the `__init__()` method
    for our new map tool, which should be placed in the `mapTools.py` module:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始实现 `AddTrackTool` 类。这与我们在第 7 章 [选择和编辑 PyQGIS 应用程序中的要素](part0055_split_000.html#page
    "第 7 章. 选择和编辑 PyQGIS 应用程序中的要素") 中定义的 `CaptureTool` 非常相似，除了它只捕获 LineString 几何形状，并且在用户完成定义轨迹时创建一个新的具有默认属性的轨迹要素。以下是新地图工具的类定义和
    `__init__()` 方法，应该放在 `mapTools.py` 模块中：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, our class inherits from both `QgsMapTool` and `MapToolMixin`.
    We also call the `setLayer()` method so that our mixin knows which layer to work
    with. This also makes the currently edited layer available via `self.layer`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的类从 `QgsMapTool` 和 `MapToolMixin` 继承。我们还调用了 `setLayer()` 方法，这样混合类就知道要使用哪个图层。这也使得当前编辑的图层通过
    `self.layer` 可用。
- en: 'We next define the various event handling methods for our map tool:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来定义了我们地图工具的各种事件处理方法：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once again, we've seen this logic before in the `CaptureTool` class. The only
    difference is that we're only capturing LineString geometries, so we don't need
    to worry about the capture mode.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在 `CaptureTool` 类中看到了这种逻辑。唯一的区别是我们只捕获 LineString 几何形状，所以我们不需要担心捕获模式。
- en: 'We now get to the `startCapturing()` and `stopCapturing()` methods. These create
    and release the rubber bands used by our map tool:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了 `startCapturing()` 和 `stopCapturing()` 方法。这些方法创建并释放我们地图工具使用的橡皮筋：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we have the `addVertex()` method, which adds a new vertex to the track:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `addVertex()` 方法，它将一个新的顶点添加到轨迹中：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we call `self.transformCoordinates()`, which is a method defined by
    our mixin class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们调用了 `self.transformCoordinates()`，这是我们混合类定义的一个方法。
- en: 'Our next method is `removeLastVertex()`. This deletes the last added vertex
    when the user presses the *Delete* key:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一种方法是 `removeLastVertex()`。当用户按下*删除*键时，它会删除最后添加的顶点：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now define the `getCapturedPoints()` method, which returns either the set
    of points the user clicked on or `None` if the user didn''t click on enough points
    to make a LineString:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义 `getCapturedPoints()` 方法，它返回用户点击的点集或 `None`（如果用户点击的点不足以形成一个 LineString）：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our final method is `pointsCaptured()`, which responds when the user finishes
    clicking on the points for a new track. Unlike the equivalent method in `CaptureTool`,
    we have to set the various attributes for the new track:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一种方法是 `pointsCaptured()`，当用户完成对新轨迹点的点击时，它会做出响应。与 `CaptureTool` 中的等效方法不同，我们必须为新轨迹设置各种属性：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we''ve defined our map tool, let''s update our application to use
    this tool. Back in the `forestTrails.py` module, add the following to the end
    of the `setupMapTools()` method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的地图工具，让我们更新我们的应用程序以使用这个工具。回到 `forestTrails.py` 模块，在 `setupMapTools()`
    方法的末尾添加以下内容：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now define our `addTrack()` method as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义我们的 `addTrack()` 方法如下：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the user checks the **Add Track** action, we activate the Add Track tool.
    If the user unchecks the action by clicking on it again, we will switch back to
    the pan mode.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户勾选了**添加轨迹**操作，我们将激活添加轨迹工具。如果用户再次点击取消勾选该操作，我们将切换回平移模式。
- en: 'Finally, we have to define a helper method called `onTrackAdded()`. This method
    responds when the user adds a new track to our track layer. Here is the implementation
    of this method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须定义一个名为 `onTrackAdded()` 的辅助方法。该方法在用户将新轨迹添加到我们的轨迹层时做出响应。以下是此方法的实现：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Testing the application
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: 'With all of this code implemented, it''s time to test out our application.
    Run the appropriate startup script, and zoom in slightly on the map. Then click
    on the **Edit** action, followed by the **Add Track** action. All going well,
    you should be able to click on the map to define the vertices of a new track.
    When you''re done, press the *Return* key to create the new track. The result
    should look something like the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了所有这些代码后，是时候测试我们的应用程序了。运行适当的启动脚本，并在地图上稍微放大。然后点击**编辑**操作，然后点击**添加轨迹**操作。如果一切顺利，你应该能够点击地图来定义新轨迹的顶点。完成时，按*回车*键创建新轨迹。结果应该类似于以下截图：
- en: '![Testing the application](img/00099.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![测试应用程序](img/00099.jpeg)'
- en: If you then click on the Edit Tracks icon again, you'll be asked if you want
    to save your changes. Go ahead, and your new track should be made permanent.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你然后再次点击编辑轨迹图标，你会被问是否要保存你的更改。继续操作，你的新轨迹应该被永久保存。
- en: 'Now go back to the track editing mode and try creating a second track that
    connects with the first. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到轨迹编辑模式，尝试创建一个与第一个轨迹连接的第二个轨迹。例如：
- en: '![Testing the application](img/00100.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![测试应用程序](img/00100.jpeg)'
- en: 'If you then zoom in, you''ll quickly discover a major flaw in the design of
    our application, as shown in the next screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你然后放大，你会很快发现我们应用程序设计中的一个重大缺陷，如下一张截图所示：
- en: '![Testing the application](img/00101.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![测试应用程序](img/00101.jpeg)'
- en: The tracks aren't connected together. Since the user can click anywhere on the
    map, there's no way of ensuring that the tracks are connected—and if the tracks
    aren't connected, the **Find Shortest Path** command won't work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 轨迹没有连接在一起。由于用户可以在地图上的任何地方点击，因此无法确保轨迹是连接的——如果轨迹没有连接，**找到最短路径**命令将无法工作。
- en: There are a few ways we can solve this problem, but the easiest one in this
    case is to implement **vertex snapping**, that is, if the user clicks close to
    an existing vertex, we snap the click location onto the vertex so that the various
    tracks are connected.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以解决这个问题，但在这个情况下，最简单的方法是实现**顶点吸附**，也就是说，如果用户点击接近一个现有的顶点，我们将点击位置吸附到顶点上，以便将各种轨迹连接起来。
- en: Vertex snapping
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点吸附
- en: 'To implement vertex snapping, we''re going to add some new methods to `MapToolMixin`.
    We''ll start with the `findFeatureAt()` method. This method finds a feature close
    to the click location. Here is the implementation of this method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现顶点吸附，我们将在 `MapToolMixin` 中添加一些新方法。我们将从 `findFeatureAt()` 方法开始。此方法找到点击位置附近的一个特征。以下是此方法的实现：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As you can see, this method takes an optional `excludeFeature` parameter. This
    lets us exclude a given feature from the search, which will be important later
    on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种方法包含一个可选的 `excludeFeature` 参数。这允许我们排除搜索中的特定功能，这在之后会变得很重要。
- en: 'Next up, we''ll define the `findVertexAt()` method, which identifies the vertex
    close to the given click location (if any). Here is the implementation of this
    method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义 `findVertexAt()` 方法，该方法用于识别接近给定点击位置的顶点（如果有的话）。以下是该方法的实现：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we use the `QgsGeometry.closestVertex()` method to find the
    vertex closest to the given position and then see if that vertex is within the
    tolerance distance. If so, we return the vertex index for the clicked-on vertex;
    otherwise, we return `None`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用 `QgsGeometry.closestVertex()` 方法来找到接近给定位置的顶点，然后查看该顶点是否在容差距离内。如果是这样，我们返回被点击顶点的顶点索引；否则，我们返回
    `None`。
- en: 'Notice that this method uses the `math.sqrt()` function. To be able to use
    this function, you''ll need to add the following near the top of the module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这种方法使用了 `math.sqrt()` 函数。为了能够使用这个函数，你需要在模块顶部附近添加以下内容：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With these two new methods defined, we''re ready to start implementing vertex
    snapping. Here is the signature for the method we are going to write:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这两个新方法后，我们就可以开始实现顶点吸附功能了。下面是我们将要编写的函数签名：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this method, `pos` is the click position (in canvas coordinates), `trackLayer`
    is a reference to our track layer (which contains the features and vertices we
    need to check), and `excludeFeature` is an optional feature to exclude when looking
    for nearby vertices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，`pos` 是点击位置（在画布坐标中），`trackLayer` 是对我们轨迹层的引用（其中包含我们需要检查的功能和顶点），而 `excludeFeature`
    是在寻找附近顶点时可选排除的功能。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `excludeFeature` parameter will be useful when we start editing tracks.
    We'll use it to stop a track from snapping to itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编辑轨迹时，`excludeFeature` 参数将很有用。我们将使用它来阻止轨迹吸附到自身。
- en: Upon completion, our method will return the coordinate of the clicked-on vertex.
    If the user didn't click anywhere near a feature, or close to a vertex, then this
    method will return the click position instead, converted to layer coordinates.
    This lets the user click on the map canvas, away from any vertices, to draw new
    features, while still snapping to an existing vertex when the user clicks on it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的方法将返回被点击顶点的坐标。如果用户没有点击在功能附近，或者接近顶点，那么这个方法将返回点击位置，并转换为图层坐标。这使得用户可以在地图画布上点击远离任何顶点的地方来绘制新功能，同时当用户点击时仍然吸附到现有的顶点上。
- en: 'Here is the implementation of our `snapToNearestVertex()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们 `snapToNearestVertex()` 方法的实现：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we use our `findFeatureAt()` method to search for features that
    are close to the given click point. If we find a feature, we then call `self.findVertexAt()`
    to find the vertex close to where the user clicked. Finally, if we find a vertex,
    we return the coordinates of that vertex. Otherwise, we return the original click
    position converted to layer coordinates.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用 `findFeatureAt()` 方法来搜索接近给定点击点的功能。如果我们找到一个功能，我们就调用 `self.findVertexAt()`
    来找到接近用户点击位置的顶点。最后，如果我们找到一个顶点，我们就返回该顶点的坐标。否则，我们返回原始点击位置转换为图层坐标。
- en: 'With these extensions to our mixin class, we can easily add snapping to our
    `AddTrack` tool. All we have to do is replace our `addVertex()` method with the
    following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展我们的混合类，我们可以轻松地为 `AddTrack` 工具添加吸附功能。我们只需要将我们的 `addVertex()` 方法替换为以下内容：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have vertex snapping enabled, it'll be easy to ensure that our tracks
    are connected. Note that we'll also use vertex snapping when we edit a track and
    when the user selects the start and end points for the Shortest Available Path
    calculation. This is why we've added these methods to our mixin rather than to
    the `AddTrack` tool.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用了顶点吸附功能，确保我们的轨迹连接起来将变得容易。请注意，我们还将使用顶点吸附来编辑轨迹，以及当用户选择最短可用路径计算的开始和结束点时。这就是为什么我们将这些方法添加到我们的混合类中，而不是添加到
    `AddTrack` 工具中。
- en: The Edit Track map tool
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑轨迹图工具
- en: Our next task is to implement the Edit Track action. To do this, we'll take
    `EditTool` we defined in [Chapter 7](part0055_split_000.html#page "Chapter 7. Selecting
    and Editing Features in a PyQGIS Application"), *Selecting and Editing Features
    in a PyQGIS Application*, and modify it to work specifically with tracks. Fortunately,
    we only need to support LineString geometries and can make use of our mixin class,
    which will simplify the implementation of this new map tool.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个任务是实现编辑路径动作。为此，我们将使用在第7章中定义的 `EditTool`，即 *在PyQGIS应用程序中选择和编辑要素*，并修改它以专门用于路径。幸运的是，我们只需要支持
    LineString 几何形状，并可以利用我们的混合类，这将简化新地图工具的实现。
- en: 'Let''s start by adding our new class definition to the `mapTools.py` module,
    along with the `__init__()` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `mapTools.py` 模块添加我们的新类定义以及 `__init__()` 方法开始：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We now define our `canvasPressEvent()` method to respond when the user presses
    the mouse button over our map canvas:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义我们的 `canvasPressEvent()` 方法，以响应用户在地图画布上按下鼠标按钮：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we're using our mixin's methods to find the clicked-on feature
    and vertex. This simplifies the implementation of the `canvasPressedEvent()` method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用我们的混合类的方法来查找点击的要素和顶点。这简化了 `canvasPressedEvent()` 方法的实现。
- en: 'We now come to the `canvasMoveEvent()` and `canvasReleaseEvent()` methods,
    which are basically identical to the methods defined in `EditTool` from [Chapter
    7](part0055_split_000.html#page "Chapter 7. Selecting and Editing Features in
    a PyQGIS Application"), *Selecting and Editing Features in a PyQGIS Application*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来到 `canvasMoveEvent()` 和 `canvasReleaseEvent()` 方法，它们基本上与在 [第7章](part0055_split_000.html#page
    "第7章. 在PyQGIS应用程序中选择和编辑要素") 中定义的 `EditTool` 方法相同，即 *在PyQGIS应用程序中选择和编辑要素*：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our `canvasDoubleClickEvent()` method is also very similar, the only difference
    being that we can use the `findFeatureAt()` method defined by our mixin class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `canvasDoubleClickEvent()` 方法也非常相似，唯一的区别在于我们可以使用由我们的混合类定义的 `findFeatureAt()`
    方法：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now have the `moveVertexTo()` method, which moves the clicked-on vertex
    to the current mouse location. While the logic is very similar to the method with
    the same name in our `EditTool`, we also want to support vertex snapping so that
    the user can click on an existing vertex to connect two tracks together. Here
    is the implementation of this method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有 `moveVertexTo()` 方法，它将点击的顶点移动到当前鼠标位置。虽然逻辑与我们的 `EditTool` 中同名方法非常相似，但我们还希望支持顶点吸附，以便用户可以点击现有的顶点将两条路径连接起来。以下是此方法的实现：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that our call to `snapToNearestVertex()` makes use of the `excludeFeature`
    parameter to exclude the clicked-on feature when finding a vertex to snap to.
    This ensures that we don't snap a feature to itself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `snapToNearestVertex()` 调用使用了 `excludeFeature` 参数来排除点击的要素，以便在寻找吸附顶点时排除。这确保了我们不会将一个要素吸附到它自己上。
- en: 'Finally, we have the `deleteVertex()` method, which is copied almost verbatim
    from the `EditTool` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `deleteVertex()` 方法，它几乎是从 `EditTool` 类直接复制过来的：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this complex map tool implemented, we can now use it to let the user edit
    a track. Back in the `forestTrails.py` module, add the following to the end of
    the `setupMapTools()` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了这个复杂的地图工具之后，我们现在可以使用它来让用户编辑一条路径。回到 `forestTrails.py` 模块，在 `setupMapTools()`
    方法的末尾添加以下内容：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now want to replace our placeholder for the `editTrack()` method with the
    following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想用以下内容替换我们的 `editTrack()` 方法占位符：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As with the `addTrack()` method, we switch to the edit tool when the user clicks
    on our action, and switch back to panning mode if the user clicks on the action
    a second time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `addTrack()` 方法一样，当用户点击我们的动作时，我们切换到编辑工具，如果用户再次点击动作，则切换回平移模式。
- en: 'The last thing we need to do is implement the `ForestTrailsWindow.onTrackEdited()`
    method to respond when the user makes a change to a track. Here is this new method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是实现 `ForestTrailsWindow.onTrackEdited()` 方法，以响应用户对路径的更改。以下是这个新方法：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We simply need to remember that the track layer has been modified and redraw
    the map canvas to show the change. Note that we don't switch back to the panning
    mode, as the user will continue to make changes to the track vertices until he
    or she explicitly switches off the edit tool by clicking on the toolbar icon a
    second time, or by choosing a different action from the toolbar.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要记住轨道层已被修改，并重新绘制地图画布以显示更改。请注意，我们不会切换回平移模式，因为用户将继续修改轨道顶点，直到他们通过点击工具栏图标第二次或从工具栏中选择不同的操作来明确关闭编辑工具。
- en: With this implemented, you can rerun your program, switch to track editing mode,
    and click on the **Edit Track** action to add, move, or delete vertices. If you
    look carefully, you'll see that the vertex you're dragging will snap to the vertex
    of another feature when you move the mouse close to it. As with the `EditTool`,
    you can double-click on a segment to add a new vertex, or press the *Ctrl* key
    and click on a vertex to delete it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此功能后，您可以重新运行您的程序，切换到轨道编辑模式，并点击**编辑轨道**操作来添加、移动或删除顶点。如果您仔细观察，您会发现当您将鼠标移到您正在拖动的顶点附近时，该顶点会自动吸附到另一个特征的顶点上。与`EditTool`一样，您可以通过双击一个段来添加一个新顶点，或者按住*Ctrl*键并点击一个顶点来删除它。
- en: The Delete Track map tool
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除轨道地图工具
- en: 'We now want to implement the **Delete Track** action. Fortunately, the map
    tool for doing is very simple, thanks to our mixin class. Add the following class
    definition to the `mapTools.py` module:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要实现**删除轨道**操作。幸运的是，执行此操作的地图工具非常简单，多亏了我们的mixin类。将以下类定义添加到`mapTools.py`模块中：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, back in the `forestTrails.py` module, add the following to the end of
    the `setupMapTools()` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`forestTrails.py`模块中，将以下内容添加到`setupMapTools()`方法的末尾：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then replace the dummy `deleteTrack()` method with the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将占位符`deleteTrack()`方法替换为以下内容：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, add a new `onTrackDeleted()` method to respond when the user deletes
    a track:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个新的`onTrackDeleted()`方法来响应用户删除轨道的情况：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this map tool, we now have all of the necessary logic for adding, editing,
    and deleting tracks. We now have a complete mapping application for maintaining
    a database of forest trails, and you can use this program to enter as many tracks
    as you want.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个地图工具，我们现在拥有了添加、编辑和删除轨道所需的所有逻辑。我们现在有一个完整的地图应用程序，用于维护森林小径数据库，并且您可以使用这个程序输入您想要的任何数量的轨道。
- en: '![The Delete Track map tool](img/00102.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![删除轨道地图工具](img/00102.jpeg)'
- en: Of course, we're not finished yet. In particular, we can't yet specify the type
    of track; every track is a road at the moment. To get around this, our next task
    is to implement the **Get Info** action.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还没有完成。特别是，我们目前还不能指定轨道的类型；目前每个轨道都是一条道路。为了解决这个问题，我们的下一个任务是实现**获取信息**操作。
- en: The Get Info map tool
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取信息地图工具
- en: 'When the user clicks on the **Get Info** item in the toolbar, we will activate
    a custom map tool that lets the user click on a track to display and edit the
    attributes for that track. Let''s walk through this implementation one step at
    a time, starting with the `GetInfoTool` class itself. Add the following to your
    `mapTools.py` module:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击工具栏中的**获取信息**项时，我们将激活一个自定义地图工具，允许用户点击轨道以显示和编辑该轨道的属性。让我们一步一步地实现这个功能，从`GetInfoTool`类本身开始。将以下内容添加到您的`mapTools.py`模块中：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This map tool calls the `onGetInfo()` method (which is passed as a parameter
    to the map tool''s initializer) when the user clicks on a track. Let''s now use
    this map tool within our program by adding the following code to the end of our
    `setupMapTools()` method in the `forestTrails.py` module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击轨道时，此地图工具会调用`onGetInfo()`方法（该方法作为参数传递给地图工具的初始化器）。现在，让我们在我们的`forestTrails.py`模块中添加以下代码到`setupMapTools()`方法的末尾，以在程序中使用此地图工具：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can then replace our placeholder `getInfo()` method with the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的占位符`getInfo()`方法替换为以下内容：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This activates the map tool when the user clicks on the toolbar icon. The last
    step is to implement the `onGetInfo()` method, which is called when the user selects
    the map tool and clicks on a track.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在用户点击工具栏图标时激活地图工具。最后一步是实现`onGetInfo()`方法，该方法在用户选择地图工具并点击轨道时被调用。
- en: When `onGetInfo()` is called, we want to display to the user the various attributes
    of the clicked-on track. These attributes will be displayed in a dialog window,
    where the user can make changes if he/she wishes. When the user submits his/her
    changes, we will have to update the feature with the new attribute values and
    indicate that the track has been changed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`onGetInfo()`时，我们希望向用户显示点击的轨迹的各种属性。这些属性将在对话框中显示，用户如果愿意可以做出更改。当用户提交更改时，我们必须更新特征以包含新的属性值，并指示轨迹已被更改。
- en: The bulk of our work will be setting up the dialog window so that the attributes
    can be displayed and edited by the user. To do this, we'll create a new class
    named `TrackInfoDialog`, which will be a subclass of `QDialog`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分工作将是设置对话框窗口，以便用户可以显示和编辑属性。为此，我们将创建一个新的类`TrackInfoDialog`，它将是`QDialog`的子类。
- en: 'Add the following code to the `forestTrails.py` module, immediately before
    the `main()` function definition:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`forestTrails.py`模块中，在`main()`函数定义之前立即添加：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `__init__()` method will set up the contents of the dialog window. So far,
    we''ve initialized the dialog object itself, and given the window a title. Let''s
    now define a list of the available track types the user can choose from:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法将设置对话框窗口的内容。到目前为止，我们已经初始化了对话框对象本身，并给窗口添加了一个标题。现在让我们定义一个用户可以选择的可用轨迹类型列表：'
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, we''ll want a list of the available direction options:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们想要一个可用的方向选项列表：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''ll also want a list of the available track status options:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要一个可用的轨迹状态选项列表：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the preceding sets of options defined, we can now start to lay out the
    contents of our dialog window. We''ll start by using a `QFormLayout` object that
    lets us lay out form labels and widgets side by side:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了上述选项集之后，我们现在可以开始布置对话框窗口的内容。我们将从使用一个`QFormLayout`对象开始，它允许我们将表单标签和小部件并排排列：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We next want to define the various input widgets we''ll use to display and
    change the track attributes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要定义我们将用于显示和更改轨迹属性的各个输入小部件：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have the widgets themselves, let''s add them to the form:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了小部件本身，让我们将它们添加到表单中：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we want to define the buttons at the bottom of our dialog window:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要定义对话框窗口底部的按钮：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we can place the form and our buttons within the dialog box, and lay
    everything out:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在对话框中放置表单和我们的按钮，并安排好一切：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So much for the `__init__()` method. With the dialog box set up, we next want
    to define a method to copy the feature''s attributes in the dialog window:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`__init__()`方法就到这里。设置好对话框后，我们接下来想要定义一个方法，用于在对话框窗口中复制特征的属性：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The last method we need to define here is `saveAttributes()`, which stores
    the updated values from the dialog window back in the feature''s attributes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要定义的最后一个方法是`saveAttributes()`，它将存储从对话框窗口中返回的特征属性中的更新值：
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With the `TrackInfoDialog` class defined, we can finally implement the `onGetInfo()`
    method (in our `ForestTrailsWindow` class) to display the clicked-on track''s
    attributes in the dialog box, and save the changes if the user clicks on the **OK**
    button:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`TrackInfoDialog`类之后，我们最终可以在`ForestTrailsWindow`类中实现`onGetInfo()`方法，用于在对话框中显示点击的轨迹的属性，并在用户点击**确定**按钮时保存更改：
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should now be able to run the program, switch to the editing mode, click
    on the **Get Info** toolbar icon, and then click on a feature to display the attributes
    for that feature. The resulting dialog window should look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够运行程序，切换到编辑模式，点击**获取信息**工具栏图标，然后点击一个特征以显示该特征的属性。生成的对话框窗口应该看起来像这样：
- en: '![The Get Info map tool](img/00103.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![获取信息地图工具](img/00103.jpeg)'
- en: You should be able to change any of these attributes and click on the **OK**
    button to save the changes. As you change the track type, status and direction,
    you should see the change reflected in the way the track is displayed on the map.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够更改这些属性中的任何一个，然后点击**确定**按钮以保存更改。当您更改轨迹类型、状态和方向时，您应该看到更改反映在地图上轨迹的显示方式上。
- en: The Set Start Point and Set End Point actions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置起点和设置终点操作
- en: The **Set Start Point** and **Set End Point** toolbar actions allow the user
    to set the start and end points in order to calculate the shortest path between
    these two points. To implement these actions, we're going to need a new map tool
    that lets the user click on a track vertex to select the starting or ending points.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置起点**和**设置终点**工具栏操作允许用户设置起点和终点，以便计算这两个点之间的最短路径。为了实现这些操作，我们需要一个新的地图工具，允许用户点击轨道顶点来选择起始点或结束点。'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By positioning the start point and the end point on vertices, we guarantee that
    the points lie on a track's LineString. We could theoretically be more sophisticated
    and snap the starting and ending points to anywhere along a track segment, but
    that's more work, and we're trying to keep the implementation simple.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将起点和终点定位在顶点上，我们确保这些点位于轨道的LineString上。理论上我们可以更复杂一些，将起始点和结束点捕捉到轨道段上的任何位置，但这需要更多的工作，而我们正在尝试保持实现简单。
- en: 'Go back to the `mapTools.py` module and add the following class definition
    to this file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`mapTools.py`模块，并将以下类定义添加到该文件中：
- en: '[PRE45]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This map tool uses the mixin's methods to identify which feature and vertex
    the user clicked on, and then calls the `onVertexSelected()` callback to allow
    the application to respond to the selection.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个地图工具使用混入的方法来识别用户点击了哪个特征和顶点，然后调用`onVertexSelected()`回调，允许应用程序响应用户的选择。
- en: 'Let''s use this map tool to implement the **Set Start Point** and **Set End
    Point** actions. Back in the `forestTrails.py` module, add the following to the
    end of the `setupMapTools()` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个地图工具来实现**设置起点**和**设置终点**操作。回到`forestTrails.py`模块，在`setupMapTools()`方法的末尾添加以下内容：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These two instances of `SelectVertexTool` use different callback methods to
    respond when the user clicks on a track vertex. Using these tools, we can now
    implement the `setStartPoint()` and `setEndPoint()` methods, which were just placeholders
    until now:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`SelectVertexTool`实例使用不同的回调方法来响应用户点击轨道顶点。使用这些工具，我们现在可以实施`setStartPoint()`和`setEndPoint()`方法，这些方法之前只是占位符：
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As usual, we activate the map tool when the user clicks on the toolbar action,
    and switch back to the pan mode if the user clicks on the action a second time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，当用户点击工具栏操作时，我们激活地图工具，如果用户再次点击操作，则切换回平移模式。
- en: 'All that''s left now are the two callback methods, `onStartPointSelected()`
    and `onEndPointSelected()`. Let''s start with the implementation of `onStartPointSelected()`.
    This method will start by asking the feature''s geometry to return the coordinates
    of the clicked-on vertex, which we store into `self.curStartPt`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下两个回调方法，`onStartPointSelected()`和`onEndPointSelected()`。让我们从`onStartPointSelected()`的实现开始。这个方法将首先要求特征的几何形状返回被点击顶点的坐标，我们将这些坐标存储到`self.curStartPt`中：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that we know where the start point will be, we want to show this start
    point on the map. If you remember, we previously created a memory-based map layer
    called `startPointLayer`, to display this point. We''ll need to first clear the
    contents of this memory layer, deleting any existing features, and then create
    a new feature at the given coordinate:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了起点在哪里，我们想在地图上显示这个起点。如果你记得，我们之前创建了一个基于内存的地图层`startPointLayer`来显示这个点。我们需要首先清除这个内存层的内容，删除任何现有特征，然后在给定的坐标处创建一个新的特征：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we''ll redraw the map canvas to show the newly added point, and switch
    back to pan mode:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将重新绘制地图画布以显示新添加的点，并切换回平移模式：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ll need to implement the `clearMemoryLayer()` method, but before we do,
    let''s also define the `onEndPointSelected()` callback method so that we can respond
    when the user clicks on the end point. The code for this is almost identical to
    the code for `onStartPointSelected()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现`clearMemoryLayer()`方法，但在我们这样做之前，让我们也定义`onEndPointSelected()`回调方法，这样我们就可以在用户点击终点时做出响应。这段代码几乎与`onStartPointSelected()`的代码相同：
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To finish off these two actions, we'll need to implement the `clearMemoryLayer()`
    method and initialize the `curStartPt` and `curEndPt` instance variables so that
    the program knows when these variables are set for the first time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这两个操作，我们需要实现`clearMemoryLayer()`方法，并初始化`curStartPt`和`curEndPt`实例变量，以便程序知道何时首次设置这些变量。
- en: 'Here is the implementation for the `clearMemoryLayer()` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`clearMemoryLayer()`方法的实现：
- en: '[PRE52]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We simply obtain a list of all the features in the given memory layer, and then
    ask the data provider to delete them. Since this data is transient and held in
    memory, deleting all the features is no big deal.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需获取给定内存层中所有特征的列表，然后要求数据提供者删除它们。由于这些数据是瞬时的且存储在内存中，删除所有特征并不是什么大问题。
- en: 'Finally, let''s initialize those two instance variables. Add the following
    to the end of your `ForestTrailsWindow.__init__()` method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们初始化这两个实例变量。将以下内容添加到 `ForestTrailsWindow.__init__()` 方法的末尾：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With all this implemented, the user can now click on a vertex to set the starting
    or ending point, as shown in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了所有这些之后，用户现在可以点击一个顶点来设置起点或终点，如下面的截图所示：
- en: '![The Set Start Point and Set End Point actions](img/00104.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![设置起点和设置终点操作](img/00104.jpeg)'
- en: The Find Shortest Path action
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最短路径操作
- en: This is the last feature of the ForestTrails that we will have to implement.
    When the user clicks on this toolbar icon, we want to calculate the shortest available
    path between the given start and end points. Fortunately, the QGIS **network analysis
    library** will do the actual calculation for us. All we have to do is run the
    shortest path calculation on the track layer, build the LineString that corresponds
    to this shortest path, and display that LineString geometry in our memory-based
    map layer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要实现的 ForestTrails 的最后一个功能。当用户点击此工具栏图标时，我们希望计算给定起点和终点之间的最短可用路径。幸运的是，QGIS
    **网络分析库**将为我们执行实际计算。我们只需要在轨迹层上运行最短路径计算，构建与该最短路径相对应的 LineString，并在基于内存的地图层中显示该
    LineString 几何形状。
- en: 'All of this logic will be implemented within the `findShortestPath()` method.
    We''ll start our implementation with a bit of housekeeping: if the user unchecks
    the **Find Shortest Path** toolbar icon, we clear the shortest path memory layer,
    switch back to the panning mode, and redraw the map canvas to show the map without
    the previous path:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些逻辑都将实现在 `findShortestPath()` 方法中。我们将从一些基本工作开始我们的实现：如果用户取消选中**查找最短路径**工具栏图标，我们将清除最短路径内存层，切换回平移模式，并重新绘制地图画布以显示没有之前路径的地图：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The rest of the method will be executed when the user clicks on the **Find
    Shortest Path** toolbar action to check it. Add the following code to your method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**查找最短路径**工具栏操作并选中它时，方法的其他部分将执行。将以下代码添加到你的方法中：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code was copied from the PyQGIS cookbook with some changes in
    variable names to make the meaning clearer. At the end, `points` will be a list
    of `QgsPoint` objects defining the LineString geometry that connects the starting
    point to the ending point. The most interesting part of this method is the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是从 PyQGIS 烹饪书复制的，并对变量名进行了一些更改以使意义更清晰。最后，`points` 将是一个包含 `QgsPoint` 对象的列表，这些对象定义了连接起点和终点的
    LineString 几何形状。这种方法最有趣的部分如下：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This piece of code creates an object which converts a set of LineString features
    into an abstract **graph** of the layer's features. The various parameters specify
    which of the track's attributes will be used to define the various directions
    in which a track can be followed. Bidirectional tracks can be followed in either
    direction, while forward and reverse directional tracks can be followed in only
    one direction.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个对象，该对象将一组 LineString 特征转换为层特征的抽象**图**。各种参数指定了哪些轨迹属性将被用来定义轨迹可以跟随的各种方向。双向轨迹可以双向跟随，而正向和反向方向的轨迹只能单向跟随。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The final parameter, with the value `3`, tells the director to treat any track
    without a valid direction value as bidirectional.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数，值为 `3`，告诉导演将任何没有有效方向值的轨迹视为双向。
- en: 'Once we have the set of points that define the shortest path, it''s easy to
    display those points as a LineString in the memory layer and make the resulting
    path visible on the map:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了定义最短路径的点集，很容易将这些点作为 LineString 显示在内存层中，并在地图上显示结果路径：
- en: '[PRE57]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you define the starting and ending points, and then click on the **Find
    Shortest Path** toolbar action, the resulting path will be displayed as a blue
    line on the map, as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了起点和终点，然后点击**查找最短路径**工具栏操作，结果路径将在地图上以蓝色线条显示，如下面的截图所示：
- en: '![The Find Shortest Path action](img/00105.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![查找最短路径操作](img/00105.jpeg)'
- en: If you look carefully at the preceding screenshot, you'll see that the path
    taken wasn't the shortest one; the starting point was at the bottom and the ending
    point was near the end of a one-way bike track, so the shortest available path
    involved taking the road back to the start of the one-way track, and then following
    it through to the endpoint. This is exactly the behavior that we would expect,
    and it is correct given the one-way nature of the tracks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看前面的截图，您会看到所走的路径并不是最短的；起点在底部，终点在单行自行车道的末端附近，因此最短可用路径涉及返回单行道的起点，然后跟随它到终点。这正是我们预期的行为，并且考虑到轨迹的单向性质，这是正确的。
- en: Adjusting the toolbar actions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整工具栏操作
- en: 'Now that we''ve finished creating all the necessary map tools and instance
    variables, we can finally implement the rest of the `adjustActions()` method to
    adjust the toolbar and menu items to reflect the current state of the system.
    Firstly, we want to change the final line of this method so that the **Find Shortest
    Path** action is only enabled if the start and end points have both been set:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有必要的地图工具和实例变量的创建，我们最终可以实施`adjustActions()`方法的其余部分，以调整工具栏和菜单项以反映系统的当前状态。首先，我们希望更改本方法的最后一行，以便**查找最短路径**操作仅在起点和终点都已设置时启用：
- en: '[PRE58]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the final part of this method, we''ll want to find the action that is associated
    with the current map tool and check that action, while unchecking all the others.
    To do this, add the following code to the end of your `adjustActions()` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本方法的最后部分，我们希望找到与当前地图工具关联的操作并检查该操作，同时取消选中所有其他操作。为此，请将以下代码添加到您的`adjustActions()`方法末尾：
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that this code should go outside the `if...else` statement that you've
    already entered in this method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码应放在您已在本方法中输入的`if...else`语句之外。
- en: This completes our implementation of the `adjustActions()` method, and in fact
    it also completes our implementation of the entire ForestTrails system. Congratulations!
    We now have a complete working mapping application, with all the features implemented
    and working.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对`adjustActions()`方法的实现，实际上也完成了对整个ForestTrails系统的实现。恭喜！我们现在有一个完整的运行映射应用程序，所有功能都已实现并正常工作。
- en: Suggested improvements
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建议的改进
- en: 'Of course, no application is ever completely finished, and there are always
    things that could be improved upon. Here are a few ideas for things you could
    do to make the ForestTrails application even better:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有任何应用程序是完全完成的，总有可以改进的地方。以下是一些您可以采取的改进ForestTrails应用程序的建议：
- en: Adding labels to the trail layer, using the `QgsPalLabeling` engine to only
    show only the track names when the map is zoomed in sufficiently so that the names
    can be read.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在轨迹图层上添加标签，使用`QgsPalLabeling`引擎在地图足够放大以便读取名称时仅显示轨迹名称。
- en: Changing the color used for the track based on the track type. For example,
    you might draw all bike trails in red, all walking trails in green, and all horse
    trails in yellow.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据轨迹类型更改用于轨迹的颜色。例如，您可能会用红色绘制所有自行车道，用绿色绘制所有步行道，用黄色绘制所有马道。
- en: Adding a **View** menu where the user can select the types of tracks to be displayed.
    For example, the user might choose to hide all the horse trails, or show only
    the walking trails.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个**视图**菜单，用户可以选择要显示的轨迹类型。例如，用户可能选择隐藏所有马道，或者只显示步行道。
- en: Extending the logic of the shortest path calculation to exclude any tracks that
    are currently closed.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展最短路径计算的逻辑，排除任何当前关闭的轨迹。
- en: Adding another map layer to display various obstacles on the map. An obstacle
    would be something that is blocking a track, and could be represented by a Point
    geometry. Typical obstacles might be things like fallen trees, landslides, and
    ongoing track maintenance. Depending on the obstacle, the trail might be closed
    until the obstacle is cleared.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加另一个地图图层以在地图上显示各种障碍物。障碍物可能是阻挡轨迹的东西，可以用点几何表示。典型的障碍物可能包括倒下的树木、山体滑坡和正在进行的轨迹维护。根据障碍物，轨迹可能会关闭，直到障碍物被清除。
- en: Using **Print Composer** to generate a printable version of the map. This could
    be used to print maps based on the current state of the forest trails.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**打印作曲家**生成地图的可打印版本。这可以用于根据当前森林小径的状态打印地图。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we finished implementing the ForestTrails mapping application.
    Our application now lets the user add, edit, and delete tracks; view and enter
    track attributes; set the start and end points; and display the shortest available
    path between those two points. As we implemented the application, we discovered
    an issue with tracks not connecting, and solved that problem by adding support
    for vertex snapping. We also learned how to write a custom `QDialog` to let the
    user view and edit attributes, and how to use the QGIS Network Analysis library
    to calculate the shortest available path between two points.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了 ForestTrails 地图应用的开发。我们的应用现在允许用户添加、编辑和删除路径；查看和输入路径属性；设置起点和终点；并显示这两点之间的最短可用路径。在我们实现应用的过程中，我们发现路径无法连接的问题，并通过添加顶点吸附功能解决了这个问题。我们还学会了如何编写自定义的
    `QDialog` 以供用户查看和编辑属性，以及如何使用 QGIS 网络分析库来计算两点之间的最短可用路径。
- en: While the ForestTrails application is only one example of a specialized mapping
    application, it provides a good example of how to implement standalone mapping
    applications using PyQGIS. You should be able to use much of the code for your
    own mapping applications, as well as build on the techniques covered in previous
    chapters when you write your own mapping applications using Python and QGIS.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ForestTrails 应用只是一个专业地图应用的例子，但它提供了一个很好的示例，说明了如何使用 PyQGIS 实现独立的地图应用。你应该能够使用大部分代码来开发自己的地图应用，同时在你使用
    Python 和 QGIS 编写自己的地图应用时，也可以在前面章节介绍的技术基础上进行扩展。
- en: I hope you've enjoyed the journey, and learned much about using QGIS as a mapping
    toolkit within your Python programs. Map on!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你们已经享受了这次旅程，并且学到了很多关于如何在 Python 程序中使用 QGIS 作为地图工具包的知识。继续前进吧！
