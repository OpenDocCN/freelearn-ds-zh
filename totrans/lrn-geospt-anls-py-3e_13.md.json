["```py\npip install srtm.py\n```", "```py\nfrom xml.dom import minidom\nimport json\nimport urllib.request\nimport urllib.parse\nimport urllib.error\nimport math\nimport time\nimport logging\nimport numpy as np\nimport srtm # Python 3 version: http://git.io/vl5Ls\nimport sys\nfrom pygooglechart import SimpleLineChart\nfrom pygooglechart import Axis\nimport fpdf\nimport glob\nimport os\ntry:\n import Image\n import ImageFilter\n import ImageEnhance\n import ImageDraw\nexcept:\n from PIL import Image\n from PIL import ImageFilter\n from PIL import ImageEnhance\n from PIL import ImageDraw\n from PIL.ExifTags import TAGS\n```", "```py\n# Python logging module.\n# Provides a more advanced way\n# to track and log program progress.\n# Logging level - everything at or below\n# this level will output. INFO is below.\nlevel = logging.DEBUG\n# The formatter formats the log message.\n# In this case we print the local time, logger name, and message\nformatter = logging.Formatter(\"%(asctime)s - %(name)s - %(message)s\")\n# Establish a logging object and name it\nlog = logging.getLogger(\"GPX-Reporter\")\n# Configure our logger\nlog.setLevel(level)\n# Print to the command line\nconsole = logging.StreamHandler()\nconsole.setLevel(level)\nconsole.setFormatter(formatter)\nlog.addHandler(console)\n```", "```py\ndef ll2m(lat, lon):\n \"\"\"Lat/lon to meters\"\"\"\n x = lon * 20037508.34 / 180.0\n y = math.log(math.tan((90.0 + lat) *\n math.pi / 360.0)) / (math.pi / 180.0)\n y = y * 20037508.34 / 180\n return (x, y)\n```", "```py\ndef world2pixel(x, y, w, h, bbox):\n \"\"\"Converts world coordinates\n to image pixel coordinates\"\"\"\n # Bounding box of the map\n minx, miny, maxx, maxy = bbox\n # world x distance\n xdist = maxx - minx\n # world y distance\n ydist = maxy - miny\n # scaling factors for x, y\n xratio = w/xdist\n yratio = h/ydist\n # Calculate x, y pixel coordinate\n px = w - ((maxx - x) * xratio)\n py = (maxy-y) * yratio\n return int(px), int(py)\n```", "```py\ndef get_utc_epoch(timestr):\n \"\"\"Converts a GPX timestamp to Unix epoch seconds\n in Greenwich Mean Time to make time math easier\"\"\"\n # Get time object from ISO time string\n utctime = time.strptime(timestr, '%Y-%m-%dT%H:%M:%S.000Z')\n # Convert to seconds since epoch\n secs = int(time.mktime(utctime))\n return secs\n```", "```py\ndef haversine(x1, y1, x2, y2):\n \"\"\"Haversine distance formula\"\"\"\n x_dist = math.radians(x1 - x2)\n y_dist = math.radians(y1 - y2)\n y1_rad = math.radians(y1)\n y2_rad = math.radians(y2)\n a = math.sin(y_dist/2)**2 + math.sin(x_dist/2)**2 \\\n * math.cos(y1_rad) * math.cos(y2_rad)\n c = 2 * math.asin(math.sqrt(a))\n # Distance in miles. Just use c * 6371\n # for kilometers\n distance = c * (6371/1.609344) # Miles\n return distance\n```", "```py\ndef wms(minx, miny, maxx, maxy, service, lyr, epsg, style, img, w, h):\n \"\"\"Retrieve a wms map image from\n the specified service and saves it as a JPEG.\"\"\"\n wms = service\n wms += \"?SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&\"\n wms += \"LAYERS={}\".format(lyr)\n wms += \"&STYLES={}&\".format(style)\n wms += \"SRS=EPSG:{}&\".format(epsg)\n wms += \"BBOX={},{},{},{}&\".format(minx, miny, maxx, maxy)\n wms += \"WIDTH={}&\".format(w)\n wms += \"HEIGHT={}&\".format(h)\n wms += \"FORMAT=image/jpeg\"\n wmsmap = urllib.request.urlopen(wms)\n with open(img + \".jpg\", \"wb\") as f:\n   f.write(wmsmap.read())\n```", "```py\ndef exif(img):\n \"\"\"Return EXIF metatdata from image\"\"\"\n exif_data = {}\n try: \n i = Image.open(img)\n tags = i._getexif()\n for tag, value in tags.items():\n decoded = TAGS.get(tag, tag)\n exif_data[decoded] = value\n except:\n pass\n return exif_data\n```", "```py\ndef dms2dd(d, m, s, i):\n \"\"\"Convert degrees/minutes/seconds to\n decimal degrees\"\"\"\n s *= .01\n sec = float((m * 60.0) + s)\n dec = float(sec / 3600.0)\n deg = float(d + dec)\n if i.upper() == 'W':\n deg = deg * -1.0\n elif i.upper() == 'S':\n deg = deg * -1.0\n return float(deg)\n```", "```py\ndef gps(exif):\n \"\"\"Extract GPS info from EXIF metadat\"\"\"\n lat = None\n lon = None\n if exif['GPSInfo']: \n # Lat\n coords = exif['GPSInfo']\n i = coords[1]\n d = coords[2][0][0]\n m = coords[2][1][0]\n s = coords[2][2][0]\n lat = dms2dd(d, m ,s, i)\n # Lon\n i = coords[3]\n d = coords[4][0][0]\n m = coords[4][1][0]\n s = coords[4][2][0]\n lon = dms2dd(d, m ,s, i)\n return lat, lon\n```", "```py\n# Needed for numpy conversions in hillshading\ndeg2rad = 3.141592653589793 / 180.0\nrad2deg = 180.0 / 3.141592653589793\n```", "```py\n# Program Variables\n\n# Name of the gpx file containing a route.\n# https://git.io/fjwHW\ngpx = \"route.gpx\"\n```", "```py\n# NOAA OpenStreetMap Basemap\n\n# OSM WMS service\nosm_WMS = \"http://ows.mundialis.de/services/service\"\n\n# Name of the WMS street layer\n# streets = \"osm\"\nosm_lyr = \"OSM-WMS\"\n\n# Name of the basemap image to save\nosm_img = \"basemap\"\n\n# OSM EPSG code (spatial reference system)\nosm_epsg = 3857\n\n# Optional WMS parameter\nosm_style = \"\"\n```", "```py\n# Shaded elevation parameters\n#\n# Sun direction\nazimuth = 315.0\n\n# Sun angle\naltitude = 45.0\n\n# Elevation exageration\nz = 5.0\n\n# Resolution\nscale = 1.0\n```", "```py\n# No data value for output\nno_data = 0\n```", "```py\n# Output elevation image name\nelv_img = \"elevation\"\n```", "```py\n# RGBA color of the SRTM minimum elevation\nmin_clr = (255, 255, 255, 0)\n\n# RGBA color of the SRTM maximum elevation\nmax_clr = (0, 0, 0, 0)\n\n# No data color\nzero_clr = (255, 255, 255, 255)\n```", "```py\n# Pixel width and height of the\n\n# output images\nw = 800\nh = 800\n```", "```py\n# Parse the gpx file and extract the coordinates\nlog.info(\"Parsing GPX file: {}\".format(gpx))\nxml = minidom.parse(gpx)\n```", "```py\n# Grab all of the \"trkpt\" elements\ntrkpts = xml.getElementsByTagName(\"trkpt\")\n```", "```py\n# Latitude list\nlats = []\n# Longitude list\nlons = []\n# Elevation list\nelvs = []\n# GPX timestamp list\ntimes = []\n```", "```py\n# Parse lat/long, elevation and times\nfor trkpt in trkpts:\n # Latitude\n lat = float(trkpt.attributes[\"lat\"].value)\n # Longitude\n lon = float(trkpt.attributes[\"lon\"].value)\n lats.append(lat)\n lons.append(lon)\n # Elevation\n elv = trkpt.childNodes[0].firstChild.nodeValue\n elv = float(elv)\n elvs.append(elv)\n```", "```py\n # Times\n t = trkpt.childNodes[1].firstChild.nodeValue\n # Convert to local time epoch seconds\n t = get_local_time(t)\n times.append(t)\n```", "```py\n# Find Lat/Long bounding box of the route\nminx = min(lons)\nminy = min(lats)\nmaxx = max(lons)\nmaxy = max(lats)\n```", "```py\n# Buffer the GPX bounding box by 20%\n# so the track isn't too close to\n# the edge of the image.\nxdist = maxx - minx\nydist = maxy - miny\nx20 = xdist * .2\ny20 = ydist * .2\n\n# 10% expansion on each side\nminx -= x20\nminy -= y20\nmaxx += x20\nmaxy += y20\n```", "```py\n# Store the bounding box in a single\n# variable to streamline function calls\nbbox = [minx, miny, maxx, maxy]\n\n# We need the bounding box in meters\n# for the OSM WMS service. We will\n# download it in degrees though to\n# match the SRTM file. The WMS spec\n# says the input SRS should match the\n# output but this custom service just\n# doesn't work that way\nmminx, mminy = ll2m(miny, minx)\nmmaxx, mmaxy = ll2m(maxy, maxx)\n```", "```py\n# Download the OSM basemap\nlog.info(\"Downloading basemap\")\nwms(mminx, mminy, mmaxx, mmaxy, osm_WMS, osm_lyr,\n osm_epsg, osm_style, osm_img, w, h)\n```", "```py\n# Download the SRTM image\n\n# srtm.py downloader\nlog.info(\"Retrieving SRTM elevation data\")\n# The SRTM module will try to use a local cache\n\n# first and if needed download it.\nsrt = srtm.get_data()\n# Get the image and return a PIL Image object\nimage = srt.get_image((w, h), (miny, maxy), (minx, maxx),\n 300, zero_color=zero_clr, min_color=min_clr,\n max_color=max_clr)\n# Save the image\nimage.save(elv_img + \".png\")\n```", "```py\n# Hillshade the elevation image\nlog.info(\"Hillshading elevation data\")\nim = Image.open(elv_img + \".png\").convert(\"L\")\ndem = np.asarray(im)\n```", "```py\n# Set up structure for a 3x3 windows to\n# process the slope throughout the grid\nwindow = []\n# x, y resolutions\nxres = (maxx-minx)/w\nyres = (maxy-miny)/h\n```", "```py\n# Create the windows\nfor row in range(3):\n for col in range(3):\n window.append(dem[row:(row + dem.shape[0]-2),\n col:(col + dem.shape[1]-2)])\n```", "```py\n# Process each cell\nx = ((z * window[0] + z * window[3] + z * window[3] + z * window[6]) -\n (z * window[2] + z * window[5] + z * window[5] + z * window[8])) \\\n / (8.0 * xres * scale)\n\ny = ((z * window[6] + z * window[7] + z * window[7] + z * window[8]) -\n (z * window[0] + z * window[1] + z * window[1] + z * window[2])) \\\n / (8.0 * yres * scale)\n```", "```py\n# Calculate slope\nslope = 90.0 - np.arctan(np.sqrt(x*x + y*y)) * rad2deg\n\n# Calculate aspect\naspect = np.arctan2(x, y)\n\n# Calculate the shaded relief\nshaded = np.sin(altitude * deg2rad) * np.sin(slope * deg2rad) \\\n + np.cos(altitude * deg2rad) * np.cos(slope * deg2rad) \\\n * np.cos((azimuth - 90.0) * deg2rad - aspect)\n\nshaded = shaded * 255\n```", "```py\n# Convert the numpy array back to an image\nrelief = Image.fromarray(shaded).convert(\"L\")\n\n# Smooth the image several times so it's not pixelated\nfor i in range(10):\n relief = relief.filter(ImageFilter.SMOOTH_MORE)\n\nlog.info(\"Creating map image\")\n```", "```py\n# Increase the hillshade contrast to make\n# it stand out more\ne = ImageEnhance.Contrast(relief)\nrelief = e.enhance(2)\n```", "```py\n# Crop the image to match the SRTM image. We lose\n# 2 pixels during the hillshade process\nbase = Image.open(osm_img + \".jpg\").crop((0, 0, w-2, h-2))\n```", "```py\n# Enhance basemap contrast before blending\ne = ImageEnhance.Contrast(base)\nbase = e.enhance(1)\n\n# Blend the the map and hillshade at 90% opacity\ntopo = Image.blend(relief.convert(\"RGB\"), base, .9)\n```", "```py\n# Draw the GPX tracks\n# Convert the coordinates to pixels\npoints = []\nfor x, y in zip(lons, lats):\n px, py = world2pixel(x, y, w, h, bbox)\n points.append((px, py))\n```", "```py\n# Crop the image size values to match the map\nw -= 2\nh -= 2\n```", "```py\n# Set up a translucent image to draw the route.\n# This technique allows us to see the streets\n# and street names under the route line.\n\ntrack = Image.new('RGBA', (w, h))\n\ntrack_draw = ImageDraw.Draw(track)\n\n# Route line will be red at 50% transparency (255/2=127)\ntrack_draw.line(points, fill=(255, 0, 0, 127), width=4)\n```", "```py\n# Paste onto the basemap using the drawing layer itself\n# as a mask.\ntopo.paste(track, mask=track)\n```", "```py\n# Now we'll draw start and end points directly on top\n# of our map - no need for transparency\ntopo_draw = ImageDraw.Draw(topo)\n\n# Starting circle\nstart_lon, start_lat = (lons[0], lats[0])\nstart_x, start_y = world2pixel(start_lon, start_lat, w, h, bbox)\nstart_point = [start_x-10, start_y-10, start_x+10, start_y+10]\ntopo_draw.ellipse(start_point, fill=\"lightgreen\", outline=\"black\")\nstart_marker = [start_x-4, start_y-4, start_x+4, start_y+4]\ntopo_draw.ellipse(start_marker, fill=\"black\", outline=\"white\")\n```", "```py\n# Ending circle\nend_lon, end_lat = (lons[-1], lats[-1])\nend_x, end_y = world2pixel(end_lon, end_lat, w, h, bbox)\nend_point = [end_x-10, end_y-10, end_x+10, end_y+10]\ntopo_draw.ellipse(end_point, fill=\"red\", outline=\"black\")\nend_marker = [end_x-4, end_y-4, end_x+4, end_y+4]\ntopo_draw.ellipse(end_marker, fill=\"black\", outline=\"white\")\n```", "```py\n# Photo icon\nimages = glob.glob(\"photos/*.jpg\")\n```", "```py\nfor i in images:\n e = exif(i)\n```", "```py\n photo_lat, photo_lon = gps(e)\n #photo_lat, photo_lon = 30.311364, -89.324786\n```", "```py\n photo_x, photo_y = world2pixel(photo_lon, photo_lat, w, h, bbox)\n```", "```py\n topo_draw.rectangle([photo_x - 12, photo_y - 10, photo_x + 12, \\\n photo_y + 10], fill=\"black\", outline=\"black\")\n topo_draw.rectangle([photo_x - 9, photo_y - 8, photo_x + 9, \\\n photo_y + 8], fill=\"white\", outline=\"white\")\n topo_draw.polygon([(photo_x-8,photo_y+7), (photo_x-3,photo_y-1), (photo_x+2,photo_y+7)], fill = \"black\")\n topo_draw.polygon([(photo_x+2,photo_y+7), (photo_x+7,photo_y+3), (photo_x+8,photo_y+7)], fill = \"black\")\n```", "```py\n# Save the topo map\ntopo.save(\"{}_topo.jpg\".format(osm_img))\n```", "```py\n# Build the elevation chart using the Google Charts API\nlog.info(\"Creating elevation profile chart\")\nchart = SimpleLineChart(600, 300, y_range=[min(elvs), max(elvs)])\n```", "```py\n# API quirk - you need 3 lines of data to color\n# in the plot so we add a line at the minimum value\n# twice.\nchart.add_data([min(elvs)]*2)\nchart.add_data(elvs)\nchart.add_data([min(elvs)]*2)\n\n# Black lines\nchart.set_colours(['000000'])\n```", "```py\n# fill in the elevation area with a hex color\nchart.add_fill_range('80C65A', 1, 2)\n```", "```py\n# Set up labels for the minimum elevation, halfway value, and max value\nelv_labels = int(round(min(elvs))), int(min(elvs)+((max(elvs)-min(elvs))/2))\n\n# Assign the labels to an axis\nelv_label = chart.set_axis_labels(Axis.LEFT, elv_labels)\n```", "```py\n# Label the axis\nelv_text = chart.set_axis_labels(Axis.LEFT, [\"FEET\"])\n# Place the label at 30% the distance of the line\nchart.set_axis_positions(elv_text, [30])\n```", "```py\n# Calculate distances between track segments\ndistances = []\nmeasurements = []\ncoords = list(zip(lons, lats))\nfor i in range(len(coords)-1):\n x1, y1 = coords[i]\n x2, y2 = coords[i+1]\n d = haversine(x1, y1, x2, y2)\n distances.append(d)\ntotal = sum(distances)\ndistances.append(0)\nj = -1\n```", "```py\n# Locate the mile markers\nfor i in range(1, int(round(total))):\n mile = 0\n while mile < i:\n j += 1\n mile += distances[j]\n measurements.append((int(mile), j))\n j = -1\n```", "```py\n# Set up labels for the mile points\n\npositions = []\nmiles = []\nfor m, i in measurements:\n pos = ((i*1.0)/len(elvs)) * 100\n positions.append(pos)\n miles.append(m)\n\n# Position the mile marker labels along the x axis\nmiles_label = chart.set_axis_labels(Axis.BOTTOM, miles)\nchart.set_axis_positions(miles_label, positions)\n```", "```py\n# Label the x axis as \"Miles\"\nmiles_text = chart.set_axis_labels(Axis.BOTTOM, [\"MILES\", ])\nchart.set_axis_positions(miles_text, [50, ])\n\n# Save the chart\nchart.download('{}_profile.png'.format(elv_img))\n```", "```py\nlog.info(\"Creating weather summary\")\n\n# Get the bounding box centroid for georeferencing weather data\ncentx = minx + ((maxx-minx)/2)\ncenty = miny + ((maxy-miny)/2)\n```", "```py\n# DarkSky API key\n# You must register for free at DarkSky.net\n# to get a key to insert here.\napi_key = \"YOUR API KEY GOES HERE\"\n```", "```py\n# Grab the latest route time stamp to query weather history\nt = times[-1]\n```", "```py\nhistory_req = \"https://api.darksky.net/forecast/{}/\".format(api_key)\n#name_info = [t.tm_year, t.tm_mon, t.tm_mday, route_url.split(\".\")[0]]\n#history_req += \"/history_{0}{1:02d}{2:02d}/q/{3}.json\" .format(*name_info)\nhistory_req += \"{},{},{}\".format(centy, centx, t)\nhistory_req += \"?exclude=currently,minutely,hourly,alerts,flags\"\nrequest = urllib.request.urlopen(history_req)\nweather_data = request.read()\n```", "```py\n# Cache weather data for testing\nwith open(\"weather.json\", \"w\") as f:\n f.write(weather_data.decode(\"utf-8\"))\n```", "```py\n# Retrieve weather data\njs = json.loads(open(\"weather.json\").read())\nhistory = js[\"daily\"]\n```", "```py\n# Grab the weather summary data.\n# First item in a list.\ndaily = history[\"data\"][0]\n```", "```py\n# Max temperature in Imperial units (Farenheit).\n# Celsius would be metric: \"maxtempm\"\nmaxtemp = daily[\"temperatureMax\"]\n\n# Minimum temperature\nmintemp = daily[\"temperatureMin\"]\n\n# Maximum humidity\nmaxhum = daily[\"humidity\"]\n\n# Precipitation in inches (cm = precipm)\nif \"precipAccumulation\" in daily:\n precip = daily[\"precipAccumulation\"]\nelse:\n precip = \"0.0\"\n```", "```py\n# Simple fpdf.py library for our report.\n# New pdf, portrait mode, inches, letter size\n# (8.5 in. x 11 in.)\npdf = fpdf.FPDF(\"P\", \"in\", \"Letter\")\n```", "```py\n# Add our one report page\npdf.add_page()\n\n# Set up the title\npdf.set_font('Arial', 'B', 20)\n```", "```py\n# Cells contain text or space items horizontally\npdf.cell(6.25, 1, 'GPX Report', border=0, align=\"C\")\n\n# Lines space items vertically (units are in inches)\npdf.ln(h=1)\npdf.cell(1.75)\n\n# Create a horizontal rule line\npdf.cell(4, border=\"T\")\npdf.ln(h=0)\npdf.set_font('Arial', style='B', size=14)\n```", "```py\n# Set up the route map\npdf.cell(w=1.2, h=1, txt=\"Route Map\", border=0, align=\"C\")\npdf.image(\"{}_topo.jpg\".format(osm_img), 1, 2, 4, 4)\npdf.ln(h=4.35)\n```", "```py\n# Add the elevation chart\npdf.set_font('Arial', style='B', size=14)\npdf.cell(w=1.2, h=1, txt=\"Elevation Profile\", border=0, align=\"C\")\npdf.image(\"{}_profile.png\".format(elv_img), 1, 6.5, 4, 2)\npdf.ln(h=2.4)\n```", "```py\n# Write the weather summary\npdf.set_font('Arial', style='B', size=14)\npdf.cell(1.2, 1, \"Weather Summary\", align=\"C\")\npdf.ln(h=.25)\npdf.set_font('Arial', style='', size=12)\npdf.cell(1.8, 1, \"Min. Temp.: {}\".format(mintemp), align=\"L\")\npdf.cell(1.2, 1, \"Max. Hum.: {}\".format(maxhum), align=\"L\")\npdf.ln(h=.25)\npdf.cell(1.8, 1, \"Max. Temp.: {}\".format(maxtemp), align=\"L\")\npdf.cell(1.2, 1, \"Precip.: {}\".format(precip), align=\"L\")\npdf.ln(h=.25)\n```", "```py\n# Give Dark Sky credit for a great service (https://git.io/fjwHl)\npdf.image(\"darksky.png\", 3.3, 9, 1.75, .25)\n```", "```py\n# Add the images for any geolocated photos\npdf.ln(h=2.4)\npdf.set_font('Arial', style='B', size=14)\npdf.cell(1.2, 1, \"Photos\", align=\"C\")\npdf.ln(h=.25)\nfor i in images:\n pdf.image(i, 1.2, 1, 3, 3)\n pdf.ln(h=.25)\n```", "```py\n# Save the report\nlog.info(\"Saving report pdf\")\npdf.output('report.pdf', 'F')\n```"]