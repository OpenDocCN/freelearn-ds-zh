- en: Chapter 7. SciPy for Computational Geometry
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。SciPy 计算几何
- en: 'In this chapter, we will be covering the fundamentals of SciPy to develop programs
    in this very specialized topic: **Computational Geometry**. Two examples will
    be used to illustrate the use of SciPy functions in this area. To be able to profit
    from the first example, you might want to have handy a copy of *Computational
    Geometry: Algorithms and Applications Third Edition*, *de Berg M.*, *Cheong O.*,
    *van Kreveld M.*, and *Overmars M.*, *Springer Publishing*. The second example,
    on which the **Finite Element Method** is used to solve a two-dimensional problem
    involving the numerical solution of the Laplace Equation, could be followed without
    trouble with knowledge on the topic described in *Introduction to the Finite Element
    Method*, *Ottosen N. S.* and *Petersson H.*, *Prentice Hall*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将介绍 SciPy 的基础知识，以开发涉及此非常专业主题的程序：**计算几何**。我们将使用两个示例来说明 SciPy 函数在该领域的应用。为了能够从第一个示例中受益，你可能需要手头有一本
    *Computational Geometry: Algorithms and Applications Third Edition*，作者 *de Berg
    M.*，*Cheong O.*，*van Kreveld M.*，和 *Overmars M.*，由 *Springer Publishing* 出版。第二个示例，其中使用
    **有限元法**来解决涉及拉普拉斯方程数值解的两个维问题，可以在了解 *Introduction to the Finite Element Method*，作者
    *Ottosen N. S.* 和 *Petersson H.*，由 *Prentice Hall* 出版的该主题的情况下无困难地跟随。'
- en: Let's start by covering the routines in the `scipy.spatial` module that deal
    with the construction of triangulations of points in spaces of any dimension,
    and the corresponding convex hulls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先介绍 `scipy.spatial` 模块中处理任何维度空间中点三角剖分及其相应凸包构建的例程。
- en: 'The procedure is simple; given a set of *m* points in the *n*-dimensional space
    (which we represent as an *m* x *n* NumPy array), we create the `scipy.spatial`
    class `Delaunay`, containing a triangulation formed by those points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 程序很简单；给定一个包含在 *n*- 维空间中的 *m* 个点（我们将其表示为一个 *m* x *n* 的 NumPy 数组），我们创建一个 `scipy.spatial`
    类的 `Delaunay`，它包含由这些点形成的三角剖分：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any `Delaunay` class has the basic search attributes such as `points` (to obtain
    the set of points in the triangulation), `vertices` (that offer the indices of
    vertices forming simplices in the triangulation), `neighbors` (for the indices
    of neighbor simplices of each simplex—with the convention that "-1" indicates
    no neighbor for simplices at the boundary).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 `Delaunay` 类都有基本的搜索属性，例如 `points`（用于获取三角剖分中的点集），`vertices`（提供构成三角剖分单纯形的顶点的索引），`neighbors`（用于每个单纯形的相邻单纯形的索引——约定“-1”表示边界上的单纯形没有相邻单纯形）。
- en: More advanced attributes, for example, `convex_hull`, indicate the indices of
    the vertices that form the convex hull of the given points. If we desire to search
    for the simplices that share a given vertex, we may do so with the `vertex_to_simplex`
    method. If, instead, we desire to locate the simplices that contain any given
    point in the space, we do so with the `find_simplex` method.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的属性，例如 `convex_hull`，指示构成给定点凸包的顶点索引。如果我们想搜索共享给定顶点的单纯形，我们可以使用 `vertex_to_simplex`
    方法。如果我们想定位包含空间中任何给定点的单纯形，我们可以使用 `find_simplex` 方法。
- en: 'At this stage we would like to point out the intimate relationship between
    triangulations and Voronoi diagrams, and offer a simple coding exercise. Let us
    start by first choosing a random set of points, and obtaining the corresponding
    triangulation:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们想指出三角剖分和 Voronoi 图之间的密切关系，并提出一个简单的编码练习。让我们首先选择一组随机点，并获取相应的三角剖分：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We may use the `matplotlib.pyplot` routine `triplot` to obtain a graphical
    representation of this triangulation. We first need to obtain the set of computed
    simplices. `Delaunay` offers us this set, but by means of the indices of the vertices
    instead of their coordinates. We, thus, need to map these indices to actual points
    before feeding the set of simplices to the `triplot` routine:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `matplotlib.pyplot` 的 `triplot` 程序来获取这个三角剖分的图形表示。我们首先需要获取计算出的单纯形的集合。`Delaunay`
    提供了这个集合，但它通过顶点的索引而不是坐标来提供。因此，在将单纯形的集合输入到 `triplot` 程序之前，我们需要将这些索引映射到实际点上：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will now obtain the edge map of the Voronoi diagram in a similar fashion
    as we did before (this time using the `scipy.spatial.Voronoi` module), and plot
    it together with the triangulation. This is done by the following lines of code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将以与之前类似的方式（这次使用 `scipy.spatial.Voronoi` 模块）获取 Voronoi 图的边图，并将其与三角剖分一起绘制。这是通过以下代码行完成的：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s take a look at the following `xlim()` command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的 `xlim()` 命令：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is shown as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s take a look at following `ylim()` command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下下面的 `ylim()` 命令：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is shown as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now plot the edge map of the Voronoi diagram together with triangulation
    in the following `plt.show()` command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在下面的 `plt.show()` 命令中绘制Voronoi图的边缘图以及三角剖分：
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is shown as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![SciPy for Computational Geometry](img/7702OS_07_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![SciPy for Computational Geometry](img/7702OS_07_01.jpg)'
- en: Note how the triangulation and the corresponding Voronoi diagrams are dual of
    each other; each edge in the triangulation (red) is perpendicular with an edge
    in the Voronoi diagram (white). How should we use this observation to code an
    actual Voronoi diagram for a cloud of points? The actual Voronoi diagram is the
    set of vertices and edges that composes it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到三角剖分和相应的Voronoi图是彼此的补集；三角剖分中的每条边（红色）与Voronoi图中的边（白色）垂直。我们应该如何利用这个观察结果来为点云编码实际的Voronoi图？实际的Voronoi图是由组成它的顶点和边构成的集合。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interesting ways to find the Voronoi diagram can be found at [http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d](http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d](http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d)找到寻找Voronoi图的有意思的方法。
- en: Let us finish this chapter with two applications of scientific computing that
    use these techniques extensively, in combination with routines from other SciPy
    modules.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以两个科学计算的应用来结束这一章，这两个应用广泛使用了这些技术，并结合了其他SciPy模块的例程。
- en: The structural model of oxides
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 氧化物的结构模型
- en: In this example, we will cover the extraction of the structural model of a molecule
    of a bronze-type **Niobium oxide**, from **HAADF-STEM** micrographs (further background
    on this topic can be found in *Chapter 5*, *High-Quality Image Formation by Nonlocal
    Means Applied to High-Angle Annular Dark-Field Scanning Transmission Electron
    Microscopy (HAADF--STEM)* of the book *Modeling Nanoscale Imaging in Electron
    Microscopy*, *Vogt T.*, *Dahmen W.*, and *Binev P.*, *Springer Publishing*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将介绍从青铜型**氧化铌**分子的**HAADF-STEM**显微照片中提取结构模型（关于此主题的更多背景信息可以在书籍《电子显微镜中的纳米尺度成像建模》的*第5章*，*通过应用于高角环形暗场扫描透射电子显微镜（HAADF-STEM）的非局部均值方法形成高质量图像*中找到，作者：*Vogt
    T.*，*Dahmen W.*，和*Binev P.*，*Springer Publishing*）。
- en: 'The following diagram shows the HAADF-STEM micrograph of a bronze-type Niobium
    oxide (taken from [http://www.microscopy.ethz.ch/BFDF-STEM.htm](http://www.microscopy.ethz.ch/BFDF-STEM.htm)):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了青铜型氧化铌的HAADF-STEM显微照片（取自[http://www.microscopy.ethz.ch/BFDF-STEM.htm](http://www.microscopy.ethz.ch/BFDF-STEM.htm)）：
- en: '![The structural model of oxides](img/7702OS_07_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![氧化物的结构模型](img/7702OS_07_02.jpg)'
- en: 'Courtesy: ETH Zurich'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢：ETH Zurich
- en: 'For pedagogical purposes, we took the following approach to solving this problem:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了教学目的，我们采取了以下方法来解决此问题：
- en: Segmentation of the atoms by thresholding and morphological operations.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过阈值和形态学操作对原子进行分割。
- en: Connected component labeling to extract each single atom for posterior examination.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过连接组件标记来提取每个单独的原子，以便进行后续检查。
- en: Computation of the centers of mass of each label identified as an atom. This
    presents us with a lattice of points in the plane that shows a first insight in
    the structural model of the oxide.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个被识别为原子的标签的质量中心。这向我们展示了一个平面上的点阵，它展示了氧化物结构模型的第一手资料。
- en: Computation of the Voronoi diagram of the previous lattice of points. The combination
    of information with the output of the previous step will lead us to a decent (approximation
    of the actual) structural model of our sample.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算前一个点阵的Voronoi图。将信息与上一步的输出相结合将使我们得到一个相当好的（实际结构模型的近似）样品结构模型。
- en: Let us proceed in this direction.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续这个方向。
- en: 'Once retrieved and saved in the current working directory, our HAADF-STEM images
    will be read in python and stored by default (depending on your computer architecture)
    as big matrices with `float32` or `float64` precision. For this project, it is
    enough to retrieve some tools from the `scipy.ndimage` module, and some procedures
    from the `matplotlib` library. The preamble then looks like the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索并保存在当前工作目录中，我们的HAADF-STEM图像将在Python中读取，并默认存储为`float32`或`float64`精度的大的矩阵（取决于您的计算机架构）。对于这个项目，只需要从`scipy.ndimage`模块检索一些工具，以及从`matplotlib`库中的一些过程。然后，前导代码如下：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The image is loaded with the `imread(filename)` command. This stores the image
    as a `numpy.array` with `dtype = float32`. Notice that the image is rescaled so
    that the maxima and minima are `1.0` and `0.0`, respectively. Other interesting
    information about the image can be retrieved as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该图像使用`imread(filename)`命令加载。这将以`dtype = float32`将图像存储为`numpy.array`。请注意，图像被缩放，使得最大值和最小值分别为`1.0`和`0.0`。有关图像的其他有趣信息可以通过以下方式检索：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This provides the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了以下输出：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We perform thresholding by imposing an inequality in the array holding the
    data. The output is a Boolean array where `True` (white) indicates that the inequality
    has been fulfilled, and `False` (black) otherwise. We may perform at this point
    several thresholding operations and visualize them to obtain the best threshold
    for segmentation purposes. The following images show several examples (different
    thresholdings applied to the oxide image):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在包含数据的数组中施加不等式来进行阈值处理。输出是一个布尔数组，其中`True`（白色）表示不等式已被满足，而`False`（黑色）则表示未满足。我们可以在这一点上执行多个阈值处理操作，并可视化它们以获得用于分割的最佳阈值。以下图像显示了几个示例（对不同氧化物图像应用的不同阈值）：
- en: '![The structural model of oxides](img/7702OS_07_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![氧化物的结构模型](img/7702OS_07_03.jpg)'
- en: 'The following lines of code generate that oxide image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行生成了该氧化物图像：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By visual inspection of several different thresholds, we choose `0.62` as one
    that gives us a good map showing what we need for segmentation. We need to get
    rid of *outliers*, though: small particles that might fulfill the given threshold
    but are small enough not to be considered as actual atoms. Therefore, in the next
    step we perform a morphological operation of opening to get rid of those small
    particles. We decided that anything smaller than a square of size 2 x 2 is to
    be eliminated from the output of thresholding:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对几个不同的阈值进行视觉检查，我们选择`0.62`作为给我们提供良好映射的阈值，该映射显示了我们需要用于分割的内容。尽管如此，我们需要去除*异常值*：可能满足给定阈值但足够小以至于不被视为实际原子的微小颗粒。因此，在下一步中，我们执行开运算来去除这些小颗粒。我们决定，任何小于2
    x 2大小的正方形都将从阈值处理的输出中消除：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are ready for segmentation, which will be performed with the `label` routine
    from the `scipy.ndimage` module. It collects one slice per segmented atom and
    offers the number of slices computed. We need to indicate the connectivity type.
    For instance, in the following toy example, do we want to consider that situation
    as two atoms or one atom?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好进行分割，这将使用来自`scipy.ndimage`模块的`label`例程来完成。它为每个分割的原子收集一个切片，并提供了计算出的切片数量。我们需要指出连接类型。例如，在下面的玩具示例中，我们是否希望将这种情况视为两个原子还是一个原子？
- en: '![The structural model of oxides](img/7702OS_07_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![氧化物的结构模型](img/7702OS_07_04.jpg)'
- en: It depends; we would rather have it now as two different connected components,
    but for some other applications we might consider that they are one. The way we
    indicate the connectivity to the `label` routine is by means of a structuring
    element that defines feature connections. For example, if our criterion for connectivity
    between two pixels is that their edges are adjacent, then the structuring element
    looks like the image shown on the left-hand side from the images shown next. If
    our criterion for connectivity between two pixels is that they are also allowed
    to share a corner, then the structuring element looks like the image on the right-hand
    side.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于情况；我们宁愿现在将其视为两个不同的连通组件，但对于某些其他应用，我们可能认为它们是一个。我们将连接信息指示给`label`例程的方式是通过一个定义特征连接的结构元素。例如，如果我们的两个像素之间的连接标准是它们的边缘是相邻的，那么结构元素看起来就像在下一张图中左侧显示的图像。如果我们的两个像素之间的连接标准是它们也可以共享一个角落，那么结构元素看起来就像在右侧显示的图像。
- en: For each pixel we impose the chosen structuring element and count the intersections;
    if there are no intersections, then the two pixels are not connected. Otherwise,
    they belong to the same connected component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个像素，我们施加选定的结构元素并计算交点；如果没有交点，则这两个像素不相连。否则，它们属于同一个连通分量。
- en: '![The structural model of oxides](img/7702OS_07_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![氧化物的结构模型](img/7702OS_07_05.jpg)'
- en: 'We need to make sure that atoms that are too close diagonally are counted as
    two, rather than one, so we chose the structuring element on the left. The script
    then reads as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保那些对角线距离太近的原子被计为两个，而不是一个，所以我们选择了左侧的结构元素。然后脚本如下所示：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `segmentation` object contains a list of slices, each with a Boolean matrix
    containing each of the found atoms of the oxide. We may obtain a great deal of
    useful information for each slice. For example, the coordinates of the center
    of mars (`centers_of_mass`) of each atom can be retrieved with the following commands:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`segmentation` 对象包含一个切片列表，每个切片都有一个布尔矩阵，包含每个找到的氧化物原子。对于每个切片，我们可以获得大量有用的信息。例如，可以使用以下命令检索每个原子的质心坐标（`centers_of_mass`）：'
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that because of the way matrices are stored in memory, there is a transposition
    of the `x` and `y` coordinates of the locations of the pixels. We need to take
    this into account.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于矩阵在内存中的存储方式，像素位置的 `x` 和 `y` 坐标发生了转置。我们需要考虑这一点。
- en: 'Notice the overlap of the computed lattice of points over the original image
    (the left-hand side image from the two images shown next). We may obtain it with
    the following commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到计算的点阵与原始图像（下一张图中左侧的图像）的重叠。我们可以使用以下命令获得它：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have successfully found the centers of mass for most atoms, although there
    are still about a dozen regions where we are not too satisfied with the result.
    It is time to fine-tune by the simple method of changing the values of some variables;
    play with the threshold, with the structuring element, with different morphological
    operations, and so on. We can even add all the obtained information for a wide
    range of those variables, and filter out outliers. An example with optimized segmentation
    is shown, as follows (look at the right-hand side image):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功找到了大多数原子的质心，尽管仍有大约十几个区域我们对结果不太满意。现在是时候通过改变一些变量的值来微调，比如调整阈值、结构元素、不同的形态学操作等等。我们甚至可以添加关于这些变量的广泛信息，并过滤掉异常值。以下是一个优化分割的示例（请看右侧图像）：
- en: '![The structural model of oxides](img/7702OS_07_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![氧化物的结构模型](img/7702OS_07_06.jpg)'
- en: 'For the purposes of this exposition, we are happy to keep it simple and continue
    working with the set of coordinates that we have already computed. We will be
    now offering an approximation to the lattice of the oxide, computed as the edge
    map of the Voronoi diagram of the lattice:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本演示的目的，我们很高兴保持简单，并继续使用我们已经计算出的坐标集。现在我们将提供一个关于氧化物晶格的近似，它是通过计算晶格的沃罗诺伊图的边缘图得到的：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let us overlay the result of `Voronoi_edges` with the locations of the found
    atoms:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `Voronoi_edges` 的结果叠加到找到的原子位置上：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This gives the following output, which represents the structural model we were
    searching for (recall that we started from an image where we wanted to find the
    structural model of a molecule):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出，它代表了我们所寻找的结构模型（回想一下，我们是从一个想要找到分子结构模型的图像开始的）：
- en: '![The structural model of oxides](img/7702OS_07_07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![氧化物的结构模型](img/7702OS_07_07.jpg)'
- en: A finite element solver for Laplace's equation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉普拉斯方程的有限元求解器
- en: We use finite elements when the size of the data is so large that its results
    prohibit dealing with finite differences. To illustrate this case, we would like
    to explore the numerical solution of the Laplace equation, subject to certain
    boundary conditions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据的大小如此之大以至于其结果禁止使用有限差分法处理时，我们使用有限元。为了说明这种情况，我们想探索在特定边界条件下的拉普拉斯方程的数值解。
- en: We will start by defining the computational domain and produce a mesh dividing
    this domain using triangles as local finite elements. This will be our starting
    point to solve this problem using finite elements, as we will be placing on the
    computational domain a piecewise continuous function, whose pieces are linear
    and supported on each of the triangles.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义计算域并使用三角形作为局部有限元来划分这个域。这将是我们使用有限元方法解决这个问题的起点，因为我们将在计算域上放置一个分段连续函数，其部分是线性的，并且在每个三角形上都有支撑。
- en: 'We start by calling the necessary modules to build the mesh (other modules
    will be called as they are required):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用必要的模块来构建网格（其他模块将在需要时调用）：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First we define the region:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义区域：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We may now create the triangulation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建三角剖分：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then have the following triangulation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有以下三角剖分：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This produces the following graph:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下图：
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_08.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![拉普拉斯方程的有限元求解器](img/7702OS_07_08.jpg)'
- en: 'In this case, the problem we have chosen is a standard one in mathematical
    methods in Physics and Engineering, consisting of solving the two-dimensional
    Laplace''s equation on the unit square region, with zero **Dirichlet** boundary
    conditions on three sides and, on the fourth side, a constant. Physically, this
    problem could represent diffusion of temperature on a two-dimensional plate. Mathematically,
    the problem is formulated in the following form:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们选择的问题是在物理学和工程数学中的标准问题，它包括在单位正方形区域内求解二维拉普拉斯方程，三边上的**Dirichlet**边界条件为零，在第四边上的条件是常数。从物理学的角度来看，这个问题可以代表二维板上的温度扩散。从数学的角度来看，问题表述如下：
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_09.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![拉普拉斯方程的有限元求解器](img/7702OS_07_09.jpg)'
- en: 'The solution of this form can be given in terms of Fourier series as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的解可以用傅里叶级数表示如下：
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![拉普拉斯方程的有限元求解器](img/7702OS_07_10.jpg)'
- en: This is important as you can check the correctness of the obtained numerical
    solution before attempting to use your numerical scheme to tackle more complex
    problems in complex computational domains. It should be mentioned, however, that
    there are alternatives in Python that implement the finite element method to solve
    partial differential equations. In this regard, the reader could consult the **Fenics**
    project ([http://fenicsproject.org/book/](http://fenicsproject.org/book/)) and
    the **SfePy** project ([http://sfepy.org/doc-devel/index.html](http://sfepy.org/doc-devel/index.html)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为在你尝试使用你的数值方案来解决复杂计算域中的更复杂问题之前，你可以检查所获得的数值解的正确性。然而，应该提到的是，Python中存在其他实现有限元方法来解决偏微分方程的替代方案。在这方面，读者可以参考**Fenics**项目([http://fenicsproject.org/book/](http://fenicsproject.org/book/))和**SfePy**项目([http://sfepy.org/doc-devel/index.html](http://sfepy.org/doc-devel/index.html))。
- en: 'We code the solution in the usual fashion. We first compute the stiff matrix
    *A* (which for obvious reasons is `sparse`). Then, the construction of the vector,
    *R*, holding global boundary conditions is defined (the way we have constructed
    our mesh makes defining this vector straightforward). With them, the solution
    to the system comes from the solution *X* obtained from solving a matrix equation
    of the form *AX=R* using a subset of the matrices *A* and *R* corresponding to
    the nodes different from those on the boundaries. This should be no trouble for
    SciPy. Let us start with the stiff matrix:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照常规方式编写代码求解。我们首先计算刚度矩阵*A*（由于显而易见的原因，它是`sparse`的）。然后，定义包含全局边界条件的向量*R*的构造（我们构建网格的方式使得定义这个向量变得简单）。有了它们，系统的解来自于通过求解形式为*AX=R*的矩阵方程获得的解*X*，使用与边界上的节点不同的节点对应的矩阵*A*和*R*的子集。这对SciPy来说应该不成问题。让我们从刚度矩阵开始：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that this is the cumbersome way to update the matrix `stiff_matrix`. This
    is due to the fact that the matrix is `sparse`, and the current choice of representation
    does not behave well with indexing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是更新`stiff_matrix`矩阵的繁琐方式。这是由于矩阵是`sparse`的，并且当前的选择在索引方面表现不佳。
- en: 'To compute the global boundary vector we need to collect all edges on the boundary
    first and then assign to the nodes with *x=1* that the function is one and to
    the others that the function is zero. Because of the way we set up the mesh this
    is easy as the nodes on which the function will take the value of one are always
    the last entries in the global boundary vector. This is accomplished by the following
    lines of code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算全局边界向量，我们首先需要收集边界上的所有边，然后将函数值为1分配给*x=1*的节点，将函数值为0分配给其他节点。由于我们设置网格的方式，这很容易，因为函数值为1的节点总是全局边界向量的最后几个条目。这是通过以下代码行实现的：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are ready to find the numerical solution to the problem with the values
    obtained in our previous step:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好使用在前一步骤中获得的数据来寻找问题的数值解：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This produces the following image depicting the diffusion of temperature inside
    the square:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下图像，展示了方形内部温度的扩散：
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![拉普拉斯方程的有限元求解器](img/7702OS_07_11.jpg)'
- en: 'This graph was obtained in the following way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该图是通过以下方式获得的：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An important point in numerical analysis is to evaluate the quality of the
    numerical solution obtained to any problem. In this case, we have chosen a problem
    whose analytical solution is available (see the preceding code), so one could
    check (not prove) the validity of the numerical algorithm implemented to solve
    our problem. In this case the analytical solution can be coded in the following
    manner:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数值分析中的一个重要点是评估任何问题获得的数值解的质量。在这种情况下，我们选择了一个具有解析解的问题（参见前面的代码），因此可以检查（而不是证明）用于解决我们问题的数值算法的有效性。在这种情况下，解析解可以以以下方式编码：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This produces the following graph showing the difference between the exact
    solution (evaluated up to 200 terms) and the numerical solution of the problem
    (via the corresponding IPython notebook you could perform some further analysis
    on the numerical solution just to become more confident on the rightness of the
    obtained result):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下图表，显示了精确解（评估到200项）与问题的数值解之间的差异（通过相应的IPython笔记本，你可以对数值解进行进一步分析，以更加确信获得的结果是正确的）：
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_12.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![拉普拉斯方程的有限元求解器](img/7702OS_07_12.jpg)'
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In each one of the seven chapters of this book, we have covered at length all
    the different modules included in the SciPy libraries in a structured manner,
    derived from the logical division of the different branches of mathematics.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的七个章节中，我们以结构化的方式详细介绍了SciPy库中包含的所有不同模块，这些模块是从数学不同分支的逻辑划分中得出的。
- en: We have also witnessed the power of this system to accomplish with minimal coding
    and optimal resource use, state-of-the-art applications to research problems in
    different areas of science.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还见证了该系统以最少的编码和最优的资源使用，在不同科学领域的科学研究问题中实现最先进应用的能力。
- en: 'In [Chapter 8](ch08.html "Chapter 8. Interaction with Other Languages"), *Interaction
    with Other Languages*, we will introduce one of the main strengths of SciPy: the
    ability to interact with other languages.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。与其他语言的交互")中，我们将介绍SciPy的主要优势之一：与其他语言交互的能力。
