- en: Chapter 7. SciPy for Computational Geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the fundamentals of SciPy to develop programs
    in this very specialized topic: **Computational Geometry**. Two examples will
    be used to illustrate the use of SciPy functions in this area. To be able to profit
    from the first example, you might want to have handy a copy of *Computational
    Geometry: Algorithms and Applications Third Edition*, *de Berg M.*, *Cheong O.*,
    *van Kreveld M.*, and *Overmars M.*, *Springer Publishing*. The second example,
    on which the **Finite Element Method** is used to solve a two-dimensional problem
    involving the numerical solution of the Laplace Equation, could be followed without
    trouble with knowledge on the topic described in *Introduction to the Finite Element
    Method*, *Ottosen N. S.* and *Petersson H.*, *Prentice Hall*.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by covering the routines in the `scipy.spatial` module that deal
    with the construction of triangulations of points in spaces of any dimension,
    and the corresponding convex hulls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure is simple; given a set of *m* points in the *n*-dimensional space
    (which we represent as an *m* x *n* NumPy array), we create the `scipy.spatial`
    class `Delaunay`, containing a triangulation formed by those points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Any `Delaunay` class has the basic search attributes such as `points` (to obtain
    the set of points in the triangulation), `vertices` (that offer the indices of
    vertices forming simplices in the triangulation), `neighbors` (for the indices
    of neighbor simplices of each simplex—with the convention that "-1" indicates
    no neighbor for simplices at the boundary).
  prefs: []
  type: TYPE_NORMAL
- en: More advanced attributes, for example, `convex_hull`, indicate the indices of
    the vertices that form the convex hull of the given points. If we desire to search
    for the simplices that share a given vertex, we may do so with the `vertex_to_simplex`
    method. If, instead, we desire to locate the simplices that contain any given
    point in the space, we do so with the `find_simplex` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage we would like to point out the intimate relationship between
    triangulations and Voronoi diagrams, and offer a simple coding exercise. Let us
    start by first choosing a random set of points, and obtaining the corresponding
    triangulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We may use the `matplotlib.pyplot` routine `triplot` to obtain a graphical
    representation of this triangulation. We first need to obtain the set of computed
    simplices. `Delaunay` offers us this set, but by means of the indices of the vertices
    instead of their coordinates. We, thus, need to map these indices to actual points
    before feeding the set of simplices to the `triplot` routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now obtain the edge map of the Voronoi diagram in a similar fashion
    as we did before (this time using the `scipy.spatial.Voronoi` module), and plot
    it together with the triangulation. This is done by the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following `xlim()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at following `ylim()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We now plot the edge map of the Voronoi diagram together with triangulation
    in the following `plt.show()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SciPy for Computational Geometry](img/7702OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note how the triangulation and the corresponding Voronoi diagrams are dual of
    each other; each edge in the triangulation (red) is perpendicular with an edge
    in the Voronoi diagram (white). How should we use this observation to code an
    actual Voronoi diagram for a cloud of points? The actual Voronoi diagram is the
    set of vertices and edges that composes it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interesting ways to find the Voronoi diagram can be found at [http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d](http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d).
  prefs: []
  type: TYPE_NORMAL
- en: Let us finish this chapter with two applications of scientific computing that
    use these techniques extensively, in combination with routines from other SciPy
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: The structural model of oxides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will cover the extraction of the structural model of a molecule
    of a bronze-type **Niobium oxide**, from **HAADF-STEM** micrographs (further background
    on this topic can be found in *Chapter 5*, *High-Quality Image Formation by Nonlocal
    Means Applied to High-Angle Annular Dark-Field Scanning Transmission Electron
    Microscopy (HAADF--STEM)* of the book *Modeling Nanoscale Imaging in Electron
    Microscopy*, *Vogt T.*, *Dahmen W.*, and *Binev P.*, *Springer Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the HAADF-STEM micrograph of a bronze-type Niobium
    oxide (taken from [http://www.microscopy.ethz.ch/BFDF-STEM.htm](http://www.microscopy.ethz.ch/BFDF-STEM.htm)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The structural model of oxides](img/7702OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Courtesy: ETH Zurich'
  prefs: []
  type: TYPE_NORMAL
- en: 'For pedagogical purposes, we took the following approach to solving this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Segmentation of the atoms by thresholding and morphological operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connected component labeling to extract each single atom for posterior examination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computation of the centers of mass of each label identified as an atom. This
    presents us with a lattice of points in the plane that shows a first insight in
    the structural model of the oxide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computation of the Voronoi diagram of the previous lattice of points. The combination
    of information with the output of the previous step will lead us to a decent (approximation
    of the actual) structural model of our sample.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us proceed in this direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once retrieved and saved in the current working directory, our HAADF-STEM images
    will be read in python and stored by default (depending on your computer architecture)
    as big matrices with `float32` or `float64` precision. For this project, it is
    enough to retrieve some tools from the `scipy.ndimage` module, and some procedures
    from the `matplotlib` library. The preamble then looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The image is loaded with the `imread(filename)` command. This stores the image
    as a `numpy.array` with `dtype = float32`. Notice that the image is rescaled so
    that the maxima and minima are `1.0` and `0.0`, respectively. Other interesting
    information about the image can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We perform thresholding by imposing an inequality in the array holding the
    data. The output is a Boolean array where `True` (white) indicates that the inequality
    has been fulfilled, and `False` (black) otherwise. We may perform at this point
    several thresholding operations and visualize them to obtain the best threshold
    for segmentation purposes. The following images show several examples (different
    thresholdings applied to the oxide image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The structural model of oxides](img/7702OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following lines of code generate that oxide image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By visual inspection of several different thresholds, we choose `0.62` as one
    that gives us a good map showing what we need for segmentation. We need to get
    rid of *outliers*, though: small particles that might fulfill the given threshold
    but are small enough not to be considered as actual atoms. Therefore, in the next
    step we perform a morphological operation of opening to get rid of those small
    particles. We decided that anything smaller than a square of size 2 x 2 is to
    be eliminated from the output of thresholding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are ready for segmentation, which will be performed with the `label` routine
    from the `scipy.ndimage` module. It collects one slice per segmented atom and
    offers the number of slices computed. We need to indicate the connectivity type.
    For instance, in the following toy example, do we want to consider that situation
    as two atoms or one atom?
  prefs: []
  type: TYPE_NORMAL
- en: '![The structural model of oxides](img/7702OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It depends; we would rather have it now as two different connected components,
    but for some other applications we might consider that they are one. The way we
    indicate the connectivity to the `label` routine is by means of a structuring
    element that defines feature connections. For example, if our criterion for connectivity
    between two pixels is that their edges are adjacent, then the structuring element
    looks like the image shown on the left-hand side from the images shown next. If
    our criterion for connectivity between two pixels is that they are also allowed
    to share a corner, then the structuring element looks like the image on the right-hand
    side.
  prefs: []
  type: TYPE_NORMAL
- en: For each pixel we impose the chosen structuring element and count the intersections;
    if there are no intersections, then the two pixels are not connected. Otherwise,
    they belong to the same connected component.
  prefs: []
  type: TYPE_NORMAL
- en: '![The structural model of oxides](img/7702OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to make sure that atoms that are too close diagonally are counted as
    two, rather than one, so we chose the structuring element on the left. The script
    then reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `segmentation` object contains a list of slices, each with a Boolean matrix
    containing each of the found atoms of the oxide. We may obtain a great deal of
    useful information for each slice. For example, the coordinates of the center
    of mars (`centers_of_mass`) of each atom can be retrieved with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that because of the way matrices are stored in memory, there is a transposition
    of the `x` and `y` coordinates of the locations of the pixels. We need to take
    this into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the overlap of the computed lattice of points over the original image
    (the left-hand side image from the two images shown next). We may obtain it with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have successfully found the centers of mass for most atoms, although there
    are still about a dozen regions where we are not too satisfied with the result.
    It is time to fine-tune by the simple method of changing the values of some variables;
    play with the threshold, with the structuring element, with different morphological
    operations, and so on. We can even add all the obtained information for a wide
    range of those variables, and filter out outliers. An example with optimized segmentation
    is shown, as follows (look at the right-hand side image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The structural model of oxides](img/7702OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the purposes of this exposition, we are happy to keep it simple and continue
    working with the set of coordinates that we have already computed. We will be
    now offering an approximation to the lattice of the oxide, computed as the edge
    map of the Voronoi diagram of the lattice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us overlay the result of `Voronoi_edges` with the locations of the found
    atoms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output, which represents the structural model we were
    searching for (recall that we started from an image where we wanted to find the
    structural model of a molecule):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The structural model of oxides](img/7702OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A finite element solver for Laplace's equation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use finite elements when the size of the data is so large that its results
    prohibit dealing with finite differences. To illustrate this case, we would like
    to explore the numerical solution of the Laplace equation, subject to certain
    boundary conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by defining the computational domain and produce a mesh dividing
    this domain using triangles as local finite elements. This will be our starting
    point to solve this problem using finite elements, as we will be placing on the
    computational domain a piecewise continuous function, whose pieces are linear
    and supported on each of the triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by calling the necessary modules to build the mesh (other modules
    will be called as they are required):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First we define the region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We may now create the triangulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have the following triangulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the problem we have chosen is a standard one in mathematical
    methods in Physics and Engineering, consisting of solving the two-dimensional
    Laplace''s equation on the unit square region, with zero **Dirichlet** boundary
    conditions on three sides and, on the fourth side, a constant. Physically, this
    problem could represent diffusion of temperature on a two-dimensional plate. Mathematically,
    the problem is formulated in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The solution of this form can be given in terms of Fourier series as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is important as you can check the correctness of the obtained numerical
    solution before attempting to use your numerical scheme to tackle more complex
    problems in complex computational domains. It should be mentioned, however, that
    there are alternatives in Python that implement the finite element method to solve
    partial differential equations. In this regard, the reader could consult the **Fenics**
    project ([http://fenicsproject.org/book/](http://fenicsproject.org/book/)) and
    the **SfePy** project ([http://sfepy.org/doc-devel/index.html](http://sfepy.org/doc-devel/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We code the solution in the usual fashion. We first compute the stiff matrix
    *A* (which for obvious reasons is `sparse`). Then, the construction of the vector,
    *R*, holding global boundary conditions is defined (the way we have constructed
    our mesh makes defining this vector straightforward). With them, the solution
    to the system comes from the solution *X* obtained from solving a matrix equation
    of the form *AX=R* using a subset of the matrices *A* and *R* corresponding to
    the nodes different from those on the boundaries. This should be no trouble for
    SciPy. Let us start with the stiff matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is the cumbersome way to update the matrix `stiff_matrix`. This
    is due to the fact that the matrix is `sparse`, and the current choice of representation
    does not behave well with indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the global boundary vector we need to collect all edges on the boundary
    first and then assign to the nodes with *x=1* that the function is one and to
    the others that the function is zero. Because of the way we set up the mesh this
    is easy as the nodes on which the function will take the value of one are always
    the last entries in the global boundary vector. This is accomplished by the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to find the numerical solution to the problem with the values
    obtained in our previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following image depicting the diffusion of temperature inside
    the square:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This graph was obtained in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'An important point in numerical analysis is to evaluate the quality of the
    numerical solution obtained to any problem. In this case, we have chosen a problem
    whose analytical solution is available (see the preceding code), so one could
    check (not prove) the validity of the numerical algorithm implemented to solve
    our problem. In this case the analytical solution can be coded in the following
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following graph showing the difference between the exact
    solution (evaluated up to 200 terms) and the numerical solution of the problem
    (via the corresponding IPython notebook you could perform some further analysis
    on the numerical solution just to become more confident on the rightness of the
    obtained result):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A finite element solver for Laplace''s equation](img/7702OS_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In each one of the seven chapters of this book, we have covered at length all
    the different modules included in the SciPy libraries in a structured manner,
    derived from the logical division of the different branches of mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: We have also witnessed the power of this system to accomplish with minimal coding
    and optimal resource use, state-of-the-art applications to research problems in
    different areas of science.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 8](ch08.html "Chapter 8. Interaction with Other Languages"), *Interaction
    with Other Languages*, we will introduce one of the main strengths of SciPy: the
    ability to interact with other languages.'
  prefs: []
  type: TYPE_NORMAL
