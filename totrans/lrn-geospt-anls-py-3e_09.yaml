- en: Python and Elevation Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elevation data is one of the most fascinating types of geospatial data. It represents
    many different types of data sources and formats. It can display properties of
    both vector and raster data, resulting in unique data products. Elevation data
    can be used for terrain visualization, land cover classification, hydrology modeling,
    transportation routing, feature extraction, and many other purposes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: You can't perform all of these options with both raster and vector data, but
    since elevation data is three-dimensional, due to containing *x*, *y*, and *z*
    coordinates, you can often get more out of this data than any other type.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Using ASCII Grid elevation data files for simple elevation processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating shaded relief images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating elevation contours
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gridding the LIDAR data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 3D mesh
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to read and write elevation data in both
    raster and vector formats. We'll also create some derivative products.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Accessing ASCII Grid files
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most of this chapter, we'll use ASCII Grid files, or ASCIIGRID. These files
    are a type of raster data that's usually associated with elevation data. This
    grid format stores data as text in equal-sized square rows and columns with a
    simple header. Each cell in a row/column stores a single numeric value, which
    can represent some feature of terrain, such as elevation, slope, or flow direction.
    The simplicity makes it an easy-to-use and platform-independent raster format.
    This format is described in the *ASCII Grids* section of [Chapter 2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml),
    *Learning Geospatial Data*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we've relied on GDAL, and to some extent, even PIL, to
    read and write geospatial raster data, including the `gdalnumeric` module, so
    that we can load raster data into NumPy arrays. ASCII Grid allows us to read and
    write rasters using only Python or even NumPy because it is simple plain text.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, some elevation datasets use image formats to store elevation
    data. Most image formats only support 8-bit values ranging from between 0 to 255;
    however, some formats, including TIFF, can store larger values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial software can typically display these datasets; however, traditional
    image software and libraries usually don't. For simplicity, in this chapter, we'll
    mostly stick to the ASCII Grid format for data, which is both human and machine-readable,
    as well as widely supported.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Reading grids
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy has the ability to read the ASCII Grid format directly using its `loadtxt()`
    method, which is designed to read arrays from text files. The first six lines
    consist of the header, which is not a part of the array. The following lines are
    a sample of a grid header:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s look at what each line in the preceding code contains:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Line 1 contains the number of columns in the grid, which is synonymous with
    the *x *axis.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 2 represents the *y *axis as a number of rows.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 3 represents the *x* coordinate of the lower-left corner, which is the
    minimum *x* value in meters.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 4 is the corresponding minimum *y* value in the lower-left corner of the
    grid.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 5 is the cell size or resolution of the raster. As the cells are square,
    only one size value is needed, as opposed to the separate *x* and *y* resolution
    values in most geospatial rasters.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 6 is `NODATA_value`, which is a number that's assigned to any cell for
    which a value is not provided.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geospatial software ignores these cells for calculations and often allows special
    display settings for it, such as making them black or transparent. The `-9999`
    value is a common no data placeholder value that's used in the industry and is
    easy to detect in software but can be arbitrarily selected. Elevation with negative
    values (that is, bathymetry) may have valid data at `-9999` meters, for instance,
    and may select `9999` or other values. As long as this value is defined in the
    header, most software will have no issues. In some examples, we'll use the number
    zero; however, zero can often also be a valid data value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The `numpy.loadtxt()` method includes an argument called `skiprows`, which allows
    you to specify the number of lines in the file to be skipped before reading the
    array values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: To try out this technique, you can download a sample grid file called `myGrid.asc`
    from [http://git.io/vYapU](http://git.io/vYapU).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for `myGrid.asc`, we would use the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line results in the `myArray` variable containing a `numpy` array derived
    from the ASCIIGRID `myGrid.asc` file. The ASC filename extension is used by the
    ASCIIGRID format. This code works great, but there's one problem. NumPy allows
    us to skip the header but not keep it. We need to keep this so that we have a
    spatial reference for our data. We will also use it to save this grid or create
    a new one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we''ll use Python''s built-in `linecache` module to
    grab the header. We could open the file, loop through the lines, store each one
    in a variable, and then close the file. However, `linecache` reduces the solution
    to a single line. The following line reads the first line in the file to a variable
    called `line1`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the examples in this chapter, we'll use this technique to create a simple
    header processor that can parse these headers into Python variables in just a
    few lines. Now that we know how to read grids, let's learn how to write them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Writing grids
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing grids in NumPy is just as easy as reading them. We use the corresponding
    `numpy.savetxt()` function to save a grid to a text file. The only catch is that
    we must build and add the six lines of header information before we dump the array
    to the file. This process is slightly different for different versions of NumPy.
    In either case, you build the header as a string first. If you are using NumPy
    1.7 or later, the `savetext()` method has an optional argument called header that
    lets you specify a string as an argument. You can quickly check your NumPy version
    from the command line using the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The backward-compatible method is to open a file, write the header, and then
    dump the array. Here is a sample of the version 1.7 approach to save an array
    called `myArray` to an ASCIIGRID file called `myGrid.asc`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We make use of Python format strings, which allow you to put placeholders in
    a string to format the Python objects to be inserted. The `{}` format variable
    turns the object you refer to into a string. In this case, we are referencing
    the number of columns and rows in the array.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'In NumPy, an array has two properties:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Size: It returns an integer for the number of values in the array.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shape: It returns a tuple with the number of rows and columns, respectively.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in the preceding example, we use the shape property tuple to add the row
    and column counts to the header of our ASCII Grid. Notice that we also add a trailing
    newline character for each line (`\n`). There is no reason to change the `x` and
    `y` values, cell size, or no data value unless we altered them in the script.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The `savetxt()` method also has an `fmt` argument, which allows you to use
    Python format strings to specify how the array values are written. In this case,
    the `%1.2f` value specifies floats with at least one number and no more than two
    decimal places. The backward-compatible version for NumPy, before 1.6, builds
    the header string in the same way but creates the file handle first:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you'll see in the upcoming examples, this ability to produce valid geospatial
    data files using only NumPy is quite powerful. In the next couple of examples,
    we'll be using an ASCIIGRID **Digital Elevation Model** (**DEM**) of a mountainous
    area near Vancouver, British Columbia, in Canada.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download this sample as a ZIP file at the following URL: [http://git.io/vYwUX](http://git.io/vYwUX).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image is the raw DEM that was colorized using QGIS with a color
    ramp that makes the lower elevation values dark blue and higher elevation values
    bright red:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4b05e96-fcba-439e-997b-c3c0fff3bf8b.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: While we can conceptually understand the data in this way, it is not an intuitive
    way to visualize the data. Let's see if we can do better by creating a shaded
    relief.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Creating a shaded relief
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shaded relief maps color elevation in such a way that it looks as if the terrain
    is cast in a low angle light, which creates bright spots and shadows. This aesthetic
    styling creates an almost photographic illusion, which is easy to grasp so that
    we can understand the variation in the terrain. It is important to note that this
    style is truly an illusion as the light is often physically inaccurate in terms
    of the solar angle, and the elevation is usually exaggerated to increase contrast.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影高程图以这种方式着色海拔，使得地形看起来像是在低角度光线下投射的，这创造了明亮的亮点和阴影。这种美学风格创造了一种几乎像照片一样的错觉，这很容易理解，以便我们可以理解地形的差异。重要的是要注意，这种风格实际上是一种错觉，因为光线在太阳角度方面往往物理上不准确，而海拔通常被夸大以增加对比度。
- en: In this example, we'll use the ASCII DEM we referenced previously to create
    another grid that represents a shaded relief version of the terrain in NumPy.
    This terrain is quite dynamic, so we won't need to exaggerate the elevation; however,
    the script has a variable called `z`, which can be increased from 1.0 to scale
    the elevation up.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用我们之前引用的ASCII DEM来创建另一个网格，该网格代表NumPy中地形阴影高程版本。这种地形非常动态，所以我们不需要夸大海拔；然而，脚本中有一个名为`z`的变量，可以从1.0增加到放大海拔。
- en: After we have defined all the variables, including the input and output filenames,
    we'll see the header parser based on the `linecache` module, which also uses a
    Python list comprehension to loop and parse the lines that are then split from
    a list into six variables. We also create a `y` cell size called `ycell`, which
    is just the inverse of the cell size by convention. If we don't do this, the resulting
    grid will be transposed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了所有变量，包括输入和输出文件名之后，我们将看到基于`linecache`模块的标题解析器，它还使用Python列表推导式来循环和解析然后从列表中分割成六个变量的行。我们还创建了一个名为`ycell`的`y`单元格大小，按照惯例，它只是单元格大小的倒数。如果我们不这样做，生成的网格将会转置。
- en: Note that we define filenames for slope and aspect grids, which are two intermediate
    products that are combined to create the final product. These intermediate grids
    are output as well. They can also serve as inputs to other types of products.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为坡度和方位角网格定义了文件名，这两个中间产品被组合起来创建最终产品。这些中间网格也被输出。它们也可以作为其他类型产品的输入。
- en: This script uses a three-by-three windowing method to scan the image and smooth
    out the center value in these mini-grids to process the image efficiently. It
    does so within the memory constraints of your computer. However, because we are
    using NumPy, we can process the entire array at once via matrices, as opposed
    to using a lengthy series of nested loops. This technique is based on the excellent
    work of a developer named Michal Migurski, who implemented the clever NumPy version
    of Matthew Perry's C++ implementation, which served as the basis for the DEM tools
    in the GDAL suite.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用3x3窗口方法扫描图像，并平滑这些小网格中的中心值，以有效地处理图像。它是在您计算机的内存限制内完成的。然而，因为我们使用NumPy，我们可以通过矩阵一次处理整个数组，而不是使用一系列嵌套循环。这种技术基于一位名叫Michal
    Migurski的开发者的出色工作，他实现了Matthew Perry的C++实现的巧妙NumPy版本，这成为了GDAL套件中DEM工具的基础。
- en: 'After the slope and aspect have been calculated, they are used to output the
    shaded relief. The slope is the steepness of a hill or mountain, while the aspect
    is the direction the grid cell faces that is specified as a degree between 0 and
    360\. Finally, everything is saved to the disk from NumPy. In the `savetxt()`
    method, we specify a four-integer format string as the peak elevations are several
    thousand meters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了坡度和方位角之后，它们被用来输出阴影高程图。坡度是山丘或山脉的陡峭程度，而方位角是网格单元面向的方向，以0到360度之间的度数指定。最后，所有内容都通过NumPy保存到磁盘上。在`savetxt()`方法中，我们指定一个由四个整数组成的格式字符串，因为峰值海拔高度是几千米：
- en: 'First, we''ll import the `linecache` module to parse the header and the `numpy`
    module to do the processing:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入`linecache`模块来解析标题和`numpy`模块来进行处理：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we''ll set up all of the variable names that will define how the shaded
    relief is processed:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置所有将定义阴影高程处理方式的变量名称：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that our variables are set up, we can parse the header:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了变量，我们可以解析标题：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we can load the actual data using `numpy` by skipping the header portion:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过跳过标题部分使用`numpy`加载实际数据：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re going to loop through the data, row by row, column by column, to process
    it. Please note, however, that we''re going to skip the outer edges that contain
    nodata values. We''ll break the data into smaller grids of 3 x 3 pixels as we
    go because for each grid cell, we need to see the cells surrounding it:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For each 3 x 3 mini-window, we''ll calculate `slope`, `aspect`, and then the
    `shaded` relief value:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to scale each value between 0-255 so that it can be viewed as
    an image:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we have to rebuild our header since we have ignored the outer edge of
    the nodata values and our dataset is smaller:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we''ll set any nodata values to the chosen nodata values we set in our
    variables at the beginning:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''re going to save the slope and aspect grids separately so that we can view
    them later and understand how the shaded relief is created:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we load the output shaded relief grid to QGIS and specify the styling to
    stretch the image to the minimum and maximum values, we will see the following
    image:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/434d4a94-9cb0-40c3-8a26-e68b5fe64578.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: If QGIS asks you for a projection, the data is EPSG:3157\. You can also open
    the image in the FWTools OpenEV application we discussed in the *Installing GDAL* section
    of [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml), *Geospatial Python
    Toolbox*, which will automatically stretch the image for optimal viewing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the preceding image is much easier to comprehend than the pseudo-color
    representation that we examined originally. Next, let''s look at the slope raster
    that''s used to create the shaded relief:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/002cba26-ba39-4576-81a7-9b1e12c4ee24.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'The slope shows the gradual decline in elevation from the high points to low
    points in all the directions of the dataset. The slope is an especially useful
    input for many types of hydrology models:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b66eef10-cf96-4450-ac6d-1ae41e627e4f.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: The aspect shows the maximum rate of a downslope change from one cell to its
    neighbors. If you compare the aspect image to the shaded relief image, you will
    see that the red and gray values of the aspect image correspond to shadows in
    the shaded relief. So, the slope is primarily responsible for turning the DEM
    into a terrain relief while the aspect is responsible for shading.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can display the data in a useful way, let's see if we can also create
    other data from it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Creating elevation contours
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A contour is an isoline along the same elevation in a dataset. Contours are
    usually stepped at intervals to create an intuitive way to represent elevation
    data, both visually and numerically, using a resource-efficient vector dataset. Now,
    let's look at another way to visualize the elevation better using contours.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The input is used to generate contours in our DEM and the output is a shapefile.
    The algorithm (Marching Squares: [https://en.wikipedia.org/wiki/Marching_squares](https://en.wikipedia.org/wiki/Marching_squares))
    that''s used to generate contours is fairly complex and very difficult to implement
    using NumPy''s linear algebra. In this case, our solution is to fall back on the
    GDAL library, which has a contouring method available through the Python API.
    In fact, the majority of this script is just setting up the OGR library code that
    is needed to output a shapefile. The actual contouring is a single method call
    named `gdal.ContourGenerate()`. Just before this call, there are comments that
    define the method''s arguments. The most important ones are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`contourInterval`: This is the distance in the dataset units between contours.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contourBase`: This is the starting elevation for the contouring.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixedLevelCount`: This specifies a fixed number of contours as opposed to
    distance.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idField`: This is the name for a required shapefile `dbf` field, usually just
    called ID.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elevField`: This is the name for a required shapefile `dbf` field for the
    elevation value and is useful for labeling in maps.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should have GDAL and OGR installed from the *Installing GDAL* section of
    [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml), *Geospatial Python Toolbox*.
    We will be implementing the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: First, we will define the input DEM filename.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we will output the shapefile's name.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll create the shapefile data source with OGR.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll get the OGR layer.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll open the DEM.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we'll generate contours on the OGR layer.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at a code representation of the preceding steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load in the `gdal` and `ogr` libraries to handle the data:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we''ll set up a variable for our filename:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we''ll create the beginnings of our output shapefile using OGR:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we''ll create some contours:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s draw the contour shapefile that we just created using `pngcanvas`,
    which we introduced in the *PNGCanvas* section of [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml),
    *Geospatial Python Toolbox*:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will end up with the following image:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14574f31-967d-4cca-9b84-6e736de46bfb.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'If we bring our shaded relief ASCIIGRID and the shapefile into a GIS, such
    as QGIS, we can create a simple topographic map, as follows. You can use the elevation
    (that is, `ELEV`) `dbf` field that you specified in the script to label the contour
    lines with the elevation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b38f255-5d58-429a-9418-584fe4c923dc.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'The techniques that were used in these NumPy grid examples provide the building
    blocks for all kinds of elevation products. Next, we''ll work with one of the
    most complex elevation data types: LIDAR data.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Working with LIDAR data
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LIDAR** stands for **Light Detection and Ranging**. It is similar to radar-based
    images but uses finite laser beams that hit the ground hundreds of thousands of
    times per second to collect a huge amount of very fine (*x*,*y*,*z*) locations,
    as well as time and intensity. The intensity value is what really separates LIDAR
    from other data types. For example, the asphalt rooftop of a building may be of
    the same elevation as the top of a nearby tree, but the intensities will be different.
    Just like remote sensing, radiance values in a multispectral satellite image allow
    us to build classification libraries. The intensity values of LIDAR data allow
    us to classify and colorize LIDAR data.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The high volume and precision of LIDAR actually make it difficult to use. A
    LIDAR dataset is referred to as a point cloud because the shape of the dataset
    is usually irregular as the data is three-dimensional with outlying points. There's
    not many software packages that effectively visualize point clouds.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, an irregular-shaped collection of finite points is just hard to
    interact with, even when we are using appropriate software.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, one of the most common operations on LIDAR data is to project
    data and resample it to a regular grid. We'll do this using a small LIDAR dataset.
    This dataset is approximately 7 MB uncompressed and contains over 600,000 points.
    The data captures some easily identifiable features, such as buildings, trees,
    and cars in parking lots. You can download the zipped dataset from [http://git.io/vOERW](http://git.io/vOERW).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The file format is a very common binary format specific to LIDAR called **LAS**,
    which is short for laser. Unzip this file to your working directory. To read this
    format, we''ll use a pure Python library called `laspy`. You can install Python
    version 3.7 using the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With `laspy` installed, we are ready to create a grid from LIDAR.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Creating a grid from the LIDAR data
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is fairly straightforward. We loop through the (*x*,*y*) point locations
    in the LIDAR data and project them to our grid with a cell size of one meter.
    Due to the precision of the LIDAR data, we'll end up with multiple points in a
    single cell. We average these points to create a common elevation value. Another
    issue that we have to deal with is data loss. Whenever you resample the data,
    you lose information.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ll end up with `NODATA` holes in the middle of the raster.
    To deal with this issue, we fill these holes with average values from the surrounding
    cells, which is a form of interpolation. We only need two modules, both available
    on PyPI, as shown in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result of our script is an ASCIIGRID, which looks like the following image
    when viewed in OpenEV. Higher elevations are lighter while lower elevations are
    darker. Even in this form, you can see buildings, trees, and cars:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b16b5692-af2b-4a18-b6bc-8aa384574ee7.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'If we assigned a heat map color ramp, the colors give you a sharper sense of
    the elevation differences:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82927068-0ef4-4863-8b2a-4d7ba91096c8.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'So, what happens if we run this output DEM through our shaded relief script
    from earlier? There''s a big difference between straight-sided buildings and sloping
    mountains. If you change the input and output names in the shaded relief script
    to process the LIDAR DEM, we get the following slope result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e42f201-ffbe-4781-a72f-9772bbfe75e4.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'The gently rolling slope of the mountainous terrain is reduced to outlines
    of major features in the image. In the aspect image, the changes are so sharp
    and over such short distances that the output image is very chaotic to view, as
    shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7342f52-23df-4392-9d14-2cafe5748d0a.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: 'Despite the difference between these images and the coarser but somewhat smoother
    mountain versions, we still get a very nice shaded relief, which visually resembles
    a black and white photograph:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/947c852d-1dd8-4a20-8cfd-142f18ea398c.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to process LIDAR data, let's learn how to visualize it
    using Python.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Using PIL to visualize LIDAR data
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous DEM images in this chapter were visualized using QGIS and OpenEV.
    We can also create output images in Python by introducing some new functions of
    the **Python Imaging Library** (**PIL**) that we didn't use in the previous chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll use the `PIL.ImageOps` module, which has functions
    for histogram equalization and automatic contrast enhancement. We''ll use PIL''s
    `fromarray()` method to import the data from `numpy`. Let''s see how close we
    can get to the output of the desktop GIS programs that were pictured in this chapter
    with the help of the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, in the following image, the enhanced shaded relief has sharper
    relief than the previous version:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5332124a-b2f6-4662-8714-43c222cbdb15.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Now, let's colorize our shaded relief. We'll use the built-in Python `colorsys`
    module for color space conversion. Normally, we specify colors as RGB values.
    However, to create a color ramp for a heat map scheme, we'll use **HSV** (short
    for **Hue, Saturation, and Value**) values to generate our colors.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of HSV is that you can tweak the *H* value to be a degree between
    0 and 360 on a color wheel. Using a single value for hue allows you to use a linear
    ramping equation, which is much easier than trying to deal with combinations of
    three separate RGB values. The following image, which was taken from the online
    magazine *Qt Quarterly*, illustrates the HSV color model:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aee567c9-1be0-4d32-8204-1217b63a3792.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: The `colorsys` module lets you switch back and forth between the HSV and RGB
    values. The module returns percentages for RGB values, which must then be mapped
    to the 0-255 scale for each color.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we''ll convert the ASCII DEM into a PIL image, build
    our color palette, apply the color palette to the grayscale image, and save the
    image:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code produces the following image, with higher elevations in
    warmer colors and lower elevations in cooler colors:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1032e79-3dd8-4af2-bde5-a9432721f2cc.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: In this image, we actually get more variation than the default QGIS version.
    We could potentially improve this image with a smoothing algorithm that would
    blend the colors where they meet and soften the image visually. As you can see,
    we have the full range of our color ramp expressed from cool to warm colors, as
    the elevation change increases.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Creating a triangulated irregular network
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following example is our most sophisticated example yet. A **triangulated
    irregular network** (**TIN**) is a vector representation of a point dataset in
    a vector surface of points connected as triangles. An algorithm determines which
    points are absolutely necessary to accurately represent the terrain as opposed
    to a raster, which stores a fixed number of cells over a given area and may repeat
    elevation values in adjacent cells that could be more efficiently stored as a
    polygon.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: A TIN can also be resampled more efficiently on the fly than a raster, which
    requires less computer memory and processing power when using TIN in a GIS. The
    most common type of TIN is based on **Delaunay triangulation**, which includes
    all the points without redundant triangles.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The Delaunay triangulation is very complex. We'll use a pure Python library
    written by Bill Simons as part of Steve Fortune's Delaunay triangulation algorithm
    called `voronoi.py` to calculate the triangles in our LIDAR data. You can download
    the script to your working directory or `site-packages` directory from [http://git.io/vOEuJ](http://git.io/vOEuJ).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: This script reads the LAS file, generates the triangles, loops through them,
    and writes out a shapefile. For this example, we'll use a clipped version of our
    LIDAR data to reduce the area to process. If we run our entire dataset of 600,000+
    points, the script will run for hours and generate over half a million triangles.
    You can download the clipped LIDAR dataset as a ZIP file from the following URL: [http://git.io/vOE62](http://git.io/vOE62).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We have several status messages that print while the script runs because of
    the time-intensive nature of the following example, which can take several minutes
    to complete. We''ll be storing the triangles as **PolygonZ types**, which allow
    the vertices to have a `z` elevation value. Unzip the LAS file and run the following
    code to generate a shapefile called `mesh.shp`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import our libraries:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we define the location and name of our LIDAR file, our target output
    file, and our pickle file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we''ll create a point class that''s needed by the `voronoi` module:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we''ll create a triangle array to keep track of the triangles that have
    been created for the mesh:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we need to open our LIDAR file and pull the points:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can perform a Delaunay calculation on the points to build the triangles:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''ll dump the triangles to the pickle archive to save time if we run this
    exact script again:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we can create a shapefile `Writer` object to begin creating our output
    shapefile by setting up the necessary fields:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we loop through the triangles and create the mesh:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we can eliminate any extremely long line segments, which are miscalculations
    by the library:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we can save the output shapefile:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following image shows a zoomed-in version of the TIN over the colorized
    LIDAR data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/862a2e27-6c8f-4762-8627-291973f0f191.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: The mesh provides an efficient, continuous surface from point clouds, which
    can be easier to deal with than the point clouds themselves.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elevation data can often provide a complete dataset for analysis and derivative
    products without any other data. In this chapter, you learned how to read and
    write ASCII Grids using only NumPy. You also learned how to create shaded reliefs,
    slope grids, and aspect grids. We created elevation contours using a little-known
    feature called contour of the GDAL library that's available for Python.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Next, we transformed LIDAR data into an easy-to-manipulate ASCII Grid. We experimented
    with different ways to visualize the LIDAR data with the PIL. Finally, we created
    a 3D surface or TIN by turning a LIDAR point cloud into a 3D shapefile of polygons.
    These are the tools of terrain analysis that are used for transportation planning,
    construction planning, hydrological drainage modeling, geologic exploration, and
    more.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll combine the building blocks from the previous three
    chapters to perform some advanced modeling and actually create some information
    products.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find some additional tutorials on Python and elevation data at the following
    link: [https://www.earthdatascience.org/tutorials/python/elevation/](https://www.earthdatascience.org/tutorials/python/elevation/).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
