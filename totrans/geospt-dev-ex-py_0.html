<html><head></head><body>
<p class="calibre1"><a id="p1"/><img src="img/index-1_1.jpg" alt="Image 1" class="calibre2"/></p>
<p class="calibre1"><a id="p2"/>
<a id="p3"/><b class="calibre3">Geospatial Development By Example with</b></p>
<p class="calibre1"><b class="calibre3">Python</b></p>
<p class="calibre1"><a id="p4"/><b class="calibre3">Table of Contents</b></p>
<p class="calibre1"><a href="#p13">Geospatial Development By Example with Python</a></p>
<p class="calibre1"><a href="#p15">Credits</a></p>
<p class="calibre1"><a href="#p17">About the Author</a></p>
<p class="calibre1"><a href="#p19">About the Reviewers</a></p>
<p class="calibre1"><a href="#p21">www.PacktPub.com</a></p>
<p class="calibre1"><a href="#p23">Support files, eBooks, discount offers, and more</a></p>
<p class="calibre1"><a href="#p24">Why subscribe? </a></p>
<p class="calibre1"><a href="#p25">Free access for Packt account holders</a></p>
<p class="calibre1"><a href="#p26">Preface</a></p>
<p class="calibre1"><a href="#p28">What this book covers</a></p>
<p class="calibre1"><a href="#p30">What you need for this book</a></p>
<p class="calibre1"><a href="#p32">Who this book is for</a></p>
<p class="calibre1"><a href="#p34">Conventions</a></p>
<p class="calibre1"><a href="#p36">Reader feedback</a></p>
<p class="calibre1"><a href="#p38">Customer support</a></p>
<p class="calibre1"><a href="#p40">Downloading the example code</a></p>
<p class="calibre1"><a href="#p41">Downloading the color images of this book</a></p>
<p class="calibre1"><a href="#p42">Errata</a></p>
<p class="calibre1"><a href="#p43">Piracy</a></p>
<p class="calibre1"><a href="#p44">Questions</a></p>
<p class="calibre1"><a href="#p45">1. Preparing the Work Environment</a></p>
<p class="calibre1"><a href="#p47">Installing Python</a></p>
<p class="calibre1"><a href="#p48">Windows</a></p>
<p class="calibre1"><a href="#p49">Ubuntu Linux</a></p>
<p class="calibre1"><a href="#p50">Python packages and package manager</a></p>
<p class="calibre1"><a href="#p52">The repository of Python packages for Windows</a></p>
<p class="calibre1"><a href="#p53">Installing packages and required software</a></p>
<p class="calibre1"><a href="#p55">OpenCV</a></p>
<p class="calibre1"><a href="#p56">Windows</a></p>
<p class="calibre1"><a id="p5"/><a href="#p57">Ubuntu Linux</a></p>
<p class="calibre1"><a href="#p58">Installing NumPy</a></p>
<p class="calibre1"><a href="#p60">Windows</a></p>
<p class="calibre1"><a href="#p61">Ubuntu Linux</a></p>
<p class="calibre1"><a href="#p62">Installing GDAL and OGR</a></p>
<p class="calibre1"><a href="#p66">Windows</a></p>
<p class="calibre1"><a href="#p67">Ubuntu Linux</a></p>
<p class="calibre1"><a href="#p68">Installing Mapnik</a></p>
<p class="calibre1"><a href="#p70">Windows</a></p>
<p class="calibre1"><a href="#p71">Ubuntu Linux</a></p>
<p class="calibre1"><a href="#p72">Installing Shapely</a></p>
<p class="calibre1"><a href="#p74">Windows</a></p>
<p class="calibre1"><a href="#p75">Ubuntu Linux</a></p>
<p class="calibre1"><a href="#p76">Installing other packages directly from pip</a></p>
<p class="calibre1"><a href="#p78">Windows</a></p>
<p class="calibre1"><a href="#p79">Ubuntu Linux</a></p>
<p class="calibre1"><a href="#p80">Installing an IDE</a></p>
<p class="calibre1"><a href="#p82">Windows</a></p>
<p class="calibre1"><a href="#p83">Linux</a></p>
<p class="calibre1"><a href="#p84">Creating the book project</a></p>
<p class="calibre1"><a href="#p88">Programming and running your first example</a></p>
<p class="calibre1"><a href="#p92">Transforming the coordinate system and calculating the area of all countries</a></p>
<p class="calibre1"><a href="#p98">Sort the countries by area size</a></p>
<p class="calibre1"><a href="#p101">Summary</a></p>
<p class="calibre1"><a href="#p103">2. The Geocaching App</a></p>
<p class="calibre1"><a href="#p105">Building the basic application structure</a></p>
<p class="calibre1"><a href="#p106">Creating the application tree structure</a></p>
<p class="calibre1"><a href="#p107">Functions and methods</a></p>
<p class="calibre1"><a href="#p108">Documenting your code</a></p>
<p class="calibre1"><a href="#p109">Creating the application entry point</a></p>
<p class="calibre1"><a href="#p112">Downloading geocaching data</a></p>
<p class="calibre1"><a id="p6"/><a href="#p114">Geocaching data sources</a></p>
<p class="calibre1"><a href="#p115">Fetching information from a REST API</a></p>
<p class="calibre1"><a href="#p117">Downloading data from a URL</a></p>
<p class="calibre1"><a href="#p119">Downloading data manually</a></p>
<p class="calibre1"><a href="#p122">Opening the file and getting its contents</a></p>
<p class="calibre1"><a href="#p125">Preparing the content for analysis</a></p>
<p class="calibre1"><a href="#p126">Combining functions into an application</a></p>
<p class="calibre1"><a href="#p130">Setting your current location</a></p>
<p class="calibre1"><a href="#p134">Finding the closest point</a></p>
<p class="calibre1"><a href="#p140">Summary</a></p>
<p class="calibre1"><a href="#p142">3. Combining Multiple Data Sources</a></p>
<p class="calibre1"><a href="#p144">Representing geographic data</a></p>
<p class="calibre1"><a href="#p146">Representing geometries</a></p>
<p class="calibre1"><a href="#p148">Making data homogeneous</a></p>
<p class="calibre1"><a href="#p150">The concept of abstraction</a></p>
<p class="calibre1"><a href="#p151">Abstracting the geocache point</a></p>
<p class="calibre1"><a href="#p153">Abstracting geocaching data</a></p>
<p class="calibre1"><a href="#p154">Importing geocaching data</a></p>
<p class="calibre1"><a href="#p158">Reading GPX attributes</a></p>
<p class="calibre1"><a href="index_split_001.html#p163">Returning the homogeneous data</a></p>
<p class="calibre1"><a href="index_split_001.html#p165">Converting the data into Geocache objects</a></p>
<p class="calibre1"><a href="index_split_001.html#p167">Merging multiple sources of data</a></p>
<p class="calibre1"><a href="index_split_001.html#p169">Integrating new functionality into the application</a></p>
<p class="calibre1"><a href="index_split_001.html#p172">Summary</a></p>
<p class="calibre1"><a href="index_split_001.html#p174">4. Improving the App Search Capabilities</a></p>
<p class="calibre1"><a href="index_split_001.html#p176">Working with polygons</a></p>
<p class="calibre1"><a href="index_split_001.html#p177">Knowing well-known text</a></p>
<p class="calibre1"><a href="index_split_001.html#p180">Using Shapely to handle geometries</a></p>
<p class="calibre1"><a href="index_split_001.html#p183">Importing polygons</a></p>
<p class="calibre1"><a href="index_split_001.html#p191">Getting the attributes’ values</a></p>
<p class="calibre1"><a href="index_split_001.html#p194">Importing lines</a></p>
<p class="calibre1"><a id="p7"/><a href="index_split_001.html#p198">Converting the spatial reference system and units</a></p>
<p class="calibre1"><a href="index_split_001.html#p203">Geometry relationships</a></p>
<p class="calibre1"><a href="index_split_001.html#p205">Touches</a></p>
<p class="calibre1"><a href="index_split_001.html#p206">Crosses</a></p>
<p class="calibre1"><a href="index_split_001.html#p207">Contains</a></p>
<p class="calibre1"><a href="index_split_001.html#p208">Within</a></p>
<p class="calibre1"><a href="index_split_001.html#p209">Equals or almost equals</a></p>
<p class="calibre1"><a href="index_split_001.html#p210">Intersects</a></p>
<p class="calibre1"><a href="index_split_001.html#p211">Disjoint</a></p>
<p class="calibre1"><a href="index_split_001.html#p212">Filtering by attributes and relations</a></p>
<p class="calibre1"><a href="index_split_001.html#p217">Filtering by multiple attributes</a></p>
<p class="calibre1"><a href="index_split_001.html#p219">Chaining filters</a></p>
<p class="calibre1"><a href="index_split_001.html#p221">Integrating with the app</a></p>
<p class="calibre1"><a href="index_split_001.html#p225">Summary</a></p>
<p class="calibre1"><a href="index_split_001.html#p227">5. Making Maps</a></p>
<p class="calibre1"><a href="index_split_001.html#p229">Knowing Mapnik</a></p>
<p class="calibre1"><a href="index_split_001.html#p230">Making a map with pure Python</a></p>
<p class="calibre1"><a href="index_split_001.html#p232">Making a map with a style sheet</a></p>
<p class="calibre1"><a href="index_split_001.html#p234">Creating utility functions to generate maps</a></p>
<p class="calibre1"><a href="index_split_001.html#p236">Changing the data source at runtime</a></p>
<p class="calibre1"><a href="index_split_001.html#p239">Automatically previewing the map</a></p>
<p class="calibre1"><a href="index_split_001.html#p241">Styling maps</a></p>
<p class="calibre1"><a href="index_split_001.html#p243">Map style</a></p>
<p class="calibre1"><a href="index_split_001.html#p244">Polygon style</a></p>
<p class="calibre1"><a href="index_split_001.html#p246">Line styles</a></p>
<p class="calibre1"><a href="index_split_001.html#p248">Text styles</a></p>
<p class="calibre1"><a href="index_split_001.html#p249">Adding layers to the map</a></p>
<p class="calibre1"><a href="index_split_001.html#p252">Point styles</a></p>
<p class="calibre1"><a href="index_split_001.html#p254">Using Python objects as a source of data</a></p>
<p class="calibre1"><a href="index_split_001.html#p259">Exporting geo objects</a></p>
<p class="calibre1"><a href="index_split_001.html#p263">Creating the Map Maker app</a></p>
<p class="calibre1"><a id="p8"/><a href="index_split_002.html#p267">Using PythonDatasource</a></p>
<p class="calibre1"><a href="index_split_002.html#p273">Using the app with filtering</a></p>
<p class="calibre1"><a href="index_split_002.html#p275">Summary</a></p>
<p class="calibre1"><a href="index_split_002.html#p277">6. Working with Remote Sensing Images</a></p>
<p class="calibre1"><a href="index_split_002.html#p279">Understanding how images are represented</a></p>
<p class="calibre1"><a href="index_split_002.html#p282">Opening images with OpenCV</a></p>
<p class="calibre1"><a href="index_split_002.html#p284">Knowing numerical types</a></p>
<p class="calibre1"><a href="index_split_002.html#p286">Processing remote sensing images and data</a></p>
<p class="calibre1"><a href="index_split_002.html#p289">Mosaicking images</a></p>
<p class="calibre1"><a href="index_split_002.html#p294">Adjusting the values of the images</a></p>
<p class="calibre1"><a href="index_split_002.html#p296">Cropping an image</a></p>
<p class="calibre1"><a href="index_split_002.html#p298">Creating a shaded relief image</a></p>
<p class="calibre1"><a href="index_split_002.html#p300">Building an image processing pipeline</a></p>
<p class="calibre1"><a href="index_split_002.html#p303">Creating a RasterData class</a></p>
<p class="calibre1"><a href="index_split_002.html#p310">Summary</a></p>
<p class="calibre1"><a href="index_split_002.html#p312">7. Extract Information from Raster Data</a></p>
<p class="calibre1"><a href="index_split_002.html#p314">Getting the basic statistics</a></p>
<p class="calibre1"><a href="index_split_002.html#p316">Preparing the data</a></p>
<p class="calibre1"><a href="index_split_002.html#p317">Printing simple information</a></p>
<p class="calibre1"><a href="index_split_002.html#p319">Formatting the output information</a></p>
<p class="calibre1"><a href="index_split_002.html#p321">Calculating quartiles, histograms, and other statistics</a></p>
<p class="calibre1"><a href="index_split_002.html#p323">Making statistics a lazy property</a></p>
<p class="calibre1"><a href="index_split_002.html#p325">Creating color classified images</a></p>
<p class="calibre1"><a href="index_split_002.html#p329">Choosing the right colors for a map</a></p>
<p class="calibre1"><a href="index_split_002.html#p336">Blending images</a></p>
<p class="calibre1"><a href="index_split_002.html#p339">Showing statistics with colors</a></p>
<p class="calibre1"><a href="index_split_002.html#p342">Using the histogram to colorize the image</a></p>
<p class="calibre1"><a href="index_split_002.html#p345">Summary</a></p>
<p class="calibre1"><a href="index_split_002.html#p347">8. Data Miner App</a></p>
<p class="calibre1"><a href="index_split_002.html#p350">Measuring execution time</a></p>
<p class="calibre1"><a href="index_split_002.html#p354">Code profiling</a></p>
<p class="calibre1"><a id="p9"/><a href="index_split_002.html#p356">Storing information on a database</a></p>
<p class="calibre1"><a href="index_split_002.html#p358">Creating an Object Relational Mapping</a></p>
<p class="calibre1"><a href="index_split_002.html#p359">Preparing the environment</a></p>
<p class="calibre1"><a href="index_split_002.html#p360">Changing our models</a></p>
<p class="calibre1"><a href="index_split_002.html#p360">Customizing a manager</a></p>
<p class="calibre1"><a href="index_split_002.html#p365">Generating the tables and importing data</a></p>
<p class="calibre1"><a href="index_split_002.html#p367">Filtering the data</a></p>
<p class="calibre1"><a href="index_split_003.html#p368">Importing massive amount of data</a></p>
<p class="calibre1"><a href="index_split_003.html#p370">Optimizing database inserts</a></p>
<p class="calibre1"><a href="index_split_003.html#p373">Optimizing data parsing</a></p>
<p class="calibre1"><a href="index_split_003.html#p376">Importing OpenStreetMap points of interest</a></p>
<p class="calibre1"><a href="index_split_003.html#p380">Removing the test data</a></p>
<p class="calibre1"><a href="index_split_003.html#p381">Populating the database with real data</a></p>
<p class="calibre1"><a href="index_split_003.html#p385">Searching for data and crossing information</a></p>
<p class="calibre1"><a href="index_split_003.html#p388">Filtering using boundaries</a></p>
<p class="calibre1"><a href="index_split_003.html#p390">Summary</a></p>
<p class="calibre1"><a href="index_split_003.html#p392">9. Processing Big Images</a></p>
<p class="calibre1"><a href="index_split_003.html#p394">Working with satellite images</a></p>
<p class="calibre1"><a href="index_split_003.html#p396">Getting Landsat 8 images</a></p>
<p class="calibre1"><a href="index_split_003.html#p399">Memory and images</a></p>
<p class="calibre1"><a href="index_split_003.html#p403">Processing images in chunks</a></p>
<p class="calibre1"><a href="index_split_003.html#p405">Using GDAL to open images</a></p>
<p class="calibre1"><a href="index_split_003.html#p408">Iterating through the whole image</a></p>
<p class="calibre1"><a href="index_split_003.html#p412">Creating image compositions</a></p>
<p class="calibre1"><a href="index_split_003.html#p414">True color compositions</a></p>
<p class="calibre1"><a href="index_split_003.html#p417">Processing specific regions</a></p>
<p class="calibre1"><a href="index_split_003.html#p419">False color compositions</a></p>
<p class="calibre1"><a href="index_split_003.html#p422">Summary</a></p>
<p class="calibre1"><a href="index_split_003.html#p424">10. Parallel Processing</a></p>
<p class="calibre1"><a href="index_split_003.html#p426">Multiprocessing basics</a></p>
<p class="calibre1"><a href="index_split_003.html#p430">Block iteration</a></p>
<p class="calibre1"><a id="p10"/><a href="index_split_003.html#p436">Improving the image resolution</a></p>
<p class="calibre1"><a href="index_split_003.html#p438">Image resampling</a></p>
<p class="calibre1"><a href="index_split_003.html#p446">Pan sharpening</a></p>
<p class="calibre1"><a href="index_split_003.html#p450">Summary</a></p>
<p class="calibre1"><a href="index_split_003.html#p452">Index</a></p>
<p class="calibre1"><a id="p11"/>
<a id="p12"/><b class="calibre3">Geospatial Development By Example with</b></p>
<p class="calibre1"><b class="calibre3">Python</b></p>
<p class="calibre1"><a id="p13"/>
<a id="p14"/><b class="calibre3">Geospatial Development By Example with</b></p>
<p class="calibre1"><b class="calibre3">Python</b></p>
<p class="calibre1">Copyright © 2016 Packt Publishing</p>
<p class="calibre1">All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in critical articles or reviews. </p>
<p class="calibre1">Every effort has been made in the preparation of this book to ensure the accuracy of the information presented. However, the information contained in this book is sold without warranty, either express or implied. Neither the author, nor Packt Publishing, and its dealers and distributors will be held liable for any damages caused or alleged to be caused directly or indirectly by this book. </p>
<p class="calibre1">Packt Publishing has endeavored to provide trademark information about all of the companies and products mentioned in this book by the appropriate use of capitals. </p>
<p class="calibre1">However, Packt Publishing cannot guarantee the accuracy of this information. </p>
<p class="calibre1">First published: January 2016</p>
<p class="calibre1">Production reference: 1250116</p>
<p class="calibre1">Published by Packt Publishing Ltd. </p>
<p class="calibre1">Livery Place</p>
<p class="calibre1">35 Livery Street</p>
<p class="calibre1">Birmingham B3 2PB, UK. </p>
<p class="calibre1">ISBN 978-1-78528-235-5</p>
<p class="calibre1"><a href="http://www.packtpub.com">www.packtpub.com</a></p>
<p class="calibre1"><a id="p15"/>
<a id="p16"/><b class="calibre3">Credits</b></p>
<p class="calibre1"><b class="calibre3">Author</b></p>
<p class="calibre1">Pablo Carreira</p>
<p class="calibre1"><b class="calibre3">Reviewers</b></p>
<p class="calibre1">Brylie Christopher Oxley</p>
<p class="calibre1">Vivek Kumar Singh</p>
<p class="calibre1">Claudio Sparpaglione</p>
<p class="calibre1"><b class="calibre3">Commissioning Editor</b></p>
<p class="calibre1">Sarah Crofton</p>
<p class="calibre1"><b class="calibre3">Acquisition Editor</b></p>
<p class="calibre1">Meeta Rajani</p>
<p class="calibre1"><b class="calibre3">Content Development Editor</b></p>
<p class="calibre1">Rashmi Suvarna</p>
<p class="calibre1"><b class="calibre3">Technical Editor</b></p>
<p class="calibre1">Shivani Kiran Mistry</p>
<p class="calibre1"><b class="calibre3">Copy Editor</b></p>
<p class="calibre1">Akshata Lobo</p>
<p class="calibre1"><b class="calibre3">Project Coordinator</b></p>
<p class="calibre1">Judie Jose</p>
<p class="calibre1"><b class="calibre3">Proofreader</b></p>
<p class="calibre1">Safis Editing</p>
<p class="calibre1"><b class="calibre3">Indexer</b></p>
<p class="calibre1">Hemangini Bari</p>
<p class="calibre1"><b class="calibre3">Graphics</b></p>
<p class="calibre1">Disha Haria</p>
<p class="calibre1"><b class="calibre3">Production Coordinator</b></p>
<p class="calibre1">Nilesh Mohite</p>
<p class="calibre1"><b class="calibre3">Cover Work</b></p>
<p class="calibre1">Nilesh Mohite</p>
<p class="calibre1"><a id="p17"/>
<a id="p18"/><b class="calibre3">About the Author</b></p>
<p class="calibre1"><b class="calibre3">Pablo Carreira</b> is a Python programmer and a full stack developer living in São Paulo state, Brazil. He is now the lead developer of an advanced web platform for precision agriculture and actively uses Python as a backend solution for efficient geoprocessing. </p>
<p class="calibre1">Born in 1980, Brazil, Pablo graduated as an agronomical engineer. Being a programming enthusiast and self-taught since childhood, he learned programming as a hobby and later honored his techniques in order to solve work tasks. </p>
<p class="calibre1">Having 8 years of professional experience in geoprocessing, he uses Python along with geographic information systems in order to automate processes and solve problems related to precision agriculture, environmental analysis, and land division. </p>
<p class="calibre1">I would like to thank my mother and father for the support given through all my life. I also would like to thank my wife for her help and patience in face of my absence during all the writing sessions. </p>
<p class="calibre1">I thank my university teacher José Paulo Molin, who first introduced me to geoprocessing and precision agriculture and created in me a deep interest in the area and gave the means for my development. Finally, I thank my good friend Gerardo F. E. Perez for all the opportunities that he presented me with and for the uncountable hours of good technical discussions. </p>
<p class="calibre1"><a id="p19"/>
<a id="p20"/><b class="calibre3">About the Reviewers</b></p>
<p class="calibre1"><b class="calibre3">Brylie Christopher Oxley</b> enjoys working on technology projects that improve the human and environmental commons. He is dedicated to working for open source, open web, and open knowledge movements. </p>
<p class="calibre1">He regularly contributes to open source projects primarily built with web platform technologies, including a wellbeing visualization application for aging populations and a community portal for refugee support. </p>
<p class="calibre1">Thank you Elvin, Lauri, Antti, Marjo, and Lynne for being the shining stars of my life. </p>
<p class="calibre1"><b class="calibre3">Vivek Kumar Singh</b> is a research scholar at the center of atmospheric science, Indian Institute of Technology, Delhi (IIT Delhi). He has completed his master’s in technology in Remote Sensing and GIS from the Indian Institute of Remote Sensing, ISRO, in Dehradun, Uttarakhand, India. He focused on the different applications of Remote Sensing and GIS using geocomputational modeling with satellite observations during his time in graduate school. His main research expertise is in the application of satellite remote sensing for air quality monitoring and assessment, urban heat island and remote sensing, and geographical systems around the world. He is also interested in researching the air quality in growing megacities, spatial and temporal trends in aerosols over urban regions, the radiative effects of aerosols, the development of statistical models to estimate surface level particulate matter air quality, aerosols and clouds data validation, and the retrieval of cloud products from UV satellite measurements. He is also an associate with the BhuNak science team on the development and validation of new GIS products for climate studies. </p>
<p class="calibre1">He also currently participated in developing and conducting remote sensing technical workshops and capacity building activities for the BhuNak Program, where he teaches the application of satellite imagery to environmental decision-making activities with a focus on urban living quality. </p>
<p class="calibre1">I would like to thank Vaibhav Kumar, PhD Scholar at the Center of Urban Science and Engineering, Indian Institute of Technology, Bombay (IIT-Bombay), for his contribution (cofounder of BhuNak Research Group). A special thank you to ML Singh (father), Prashant Kumar Singh (brother), and Kimeera Tummala (friend) for their contribution in my life. </p>
<p class="calibre1"><b class="calibre3">Claudio Sparpaglione</b> is a CTO at WalletSaver, an Italian startup rocking in the mobile phone tariff comparison landscape. His work experience includes the design and building of geospatial applications and web-oriented systems in the online advertisement industry. </p>
<p class="calibre1">A passionate Pythonista and open-source advocate, he’s a maintainer of the PyOWM</p>
<p class="calibre1">project and actively involved in the community with contributions to projects such as Python-Requests and Reactive Manifesto. His main interests include high-scalable web architectures, APIs design, and cloud computing. </p>
<p class="calibre1"><a id="p21"/>
<a id="p22"/><b class="calibre3">www.PacktPub.com</b></p>
<p class="calibre1"><a id="p23"/><img src="img/index-23_1.jpg" alt="Image 2" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Support files, eBooks, discount offers, and</b></p>
<p class="calibre1"><b class="calibre3">more</b></p>
<p class="calibre1">For support files and downloads related to your book, please visit <a href="http://www.PacktPub.com">www.PacktPub.com. </a></p>
<p class="calibre1">Did you know that Packt offers eBook versions of every book published, with PDF and ePub files available? You can upgrade to the eBook version at<a href="http://www.PacktPub.com"> www.PacktPub.com</a> and as a print book customer, you are entitled to a discount on the eBook copy. Get in touch with us at &lt; <a href="mailto:service@packtpub.com">service@packtpub.com</a>&gt; for more details. </p>
<p class="calibre1">At <a href="http://www.PacktPub.com">www.PacktPub.com, </a> you can also read a collection of free technical articles, sign up for a range of free newsletters and receive exclusive discounts and offers on Packt books and eBooks. </p>
<p class="calibre1"><a href="https://www2.packtpub.com/books/subscription/packtlib">https://www2.packtpub.com/books/subscription/packtlib</a></p>
<p class="calibre1">Do you need instant solutions to your IT questions? PacktLib is Packt’s online digital book library. Here, you can search, access, and read Packt’s entire library of books. </p>
<p class="calibre1"><a id="p24"/><b class="calibre3">Why subscribe? </b></p>
<p class="calibre1">Fully searchable across every book published by Packt</p>
<p class="calibre1">Copy and paste, print, and bookmark content</p>
<p class="calibre1">On demand and accessible via a web browser</p>
<p class="calibre1"><a id="p25"/><b class="calibre3">Free access for Packt account holders</b></p>
<p class="calibre1">If you have an account with Packt at<a href="http://www.PacktPub.com"> www.PacktPub.com, </a> you can use this to access PacktLib today and view 9 entirely free books. Simply use your login credentials for immediate access. </p>
<p class="calibre1"><a id="p26"/>
<a id="p27"/><b class="calibre3">Preface</b></p>
<p class="calibre1">From Python programming good practices to the advanced use of analysis packages, this book teaches how to write applications that will perform complex geoprocessing tasks that can be replicated and reused. The book contains three sample applications. <a href="#p45"> Chapter 1</a></p>
<p class="calibre1">shows how to prepare a development environment. From<a href="#p103"> Chapter 2 </a>to<a href="index_split_001.html#p174"> Chapter 4, </a> the reader goes deep into Python functionality using classes, inheritance, and other resources in order to read, manipulate, combine, and search information in vector data. <a href="index_split_001.html#p227">Chapter 5</a> to</p>
<p class="calibre1"><a href="index_split_002.html#p312">Chapter 7 </a>presents techniques to render beautiful maps, and handle and analyze raster data. In the final three chapters, the book approaches code optimization and presents solutions to handle large datasets common in geoprocessing tasks. All the examples are modular and can be rearranged to achieve countless different results. During the book, the code is deduced step by step until it reaches the final form. The reader is led to edit, change, and improve the code, experimenting with different solutions and organizations, subtly learning the mental process of the development of a geoprocessing application. </p>
<p class="calibre1"><a id="p28"/><b class="calibre3">What this book covers</b></p>
<p class="calibre1"><a href="#p45">Chapter 1, </a>  <i class="calibre4">Preparing the Work Environment</i>, shows the processes of installing all the libraries that you will need to go through the examples in the book, as well how to set up an integrated development environment (IDE) that will help organize the code and avoid mistakes. Finally, it will present the first contact with one of the geospatial libraries. </p>
<p class="calibre1"><a href="#p103">Chapter 2, </a>  <i class="calibre4">The Geocaching App</i>, will go through the important steps in geoprocessing applications, such as opening files, reading data, and preparing it for analysis with the tools at hand. Going through these steps, the user will learn how to organize and use the resources provided by the language to write consistent applications. </p>
<p class="calibre1"><a href="#p142">Chapter 3, </a>  <i class="calibre4">Combining Multiple Data Sources</i>, will cover the process of combining sources, and how to use Python classes to create your own representation of geospatial data. Geographic data tends to be heterogeneous, so writing programs that are able to combine multiple sources of data is a fundamental topic in geoprocessing. </p>
<p class="calibre1"><a href="index_split_001.html#p174">Chapter 4, </a>  <i class="calibre4">Improving the App Search Capabilities</i>, will add new functionalities to the application. Users will write a code capable of filtering features by geographic boundaries and by any field in the data. In the process, they will see how to work with polygons and how the relations between geometries can be analyzed in a geoprocessing application. </p>
<p class="calibre1"><a href="index_split_001.html#p227">Chapter 5, </a>  <i class="calibre4">Making Maps</i>, starts a new application that will be able to produce nice maps from the vectors of the data. Mapnik, one of the most used mapping packages, will be used. The user will understand how it works and how to adapt it to consume the data presented in the previous chapters. </p>
<p class="calibre1"><a href="index_split_002.html#p277">Chapter 6, </a>  <i class="calibre4">Working with Remote Sensing Images</i>, will present a process of deduction that will result in a versatile and powerful software structure able to combine, crop, and adjust the values of images to prepare them for presentation. </p>
<p class="calibre1"><a href="index_split_002.html#p312">Chapter 7, </a>  <i class="calibre4">Extract Information from Raster Data</i>, will approach the process of extracting information from raster data, which can be analyzed in order to produce valuable information. Going beyond simple numerical values, it will show how to display this information on beautiful color maps. </p>
<p class="calibre1"><a href="index_split_002.html#p347">Chapter 8, </a>  <i class="calibre4">Data Miner App</i>, will show how to use databases and how to import data into it in order to minimize processing time and allow huge datasets to be processed. Geospatial data tends to be extensive and its processing demands a lot of computer power. To make the code more efficient, the reader will learn techniques of code profiling and optimization. </p>
<p class="calibre1"><a href="index_split_003.html#p392">Chapter 9, </a>  <i class="calibre4">Processing Big Images</i>, will show how to process big satellite images. It will focus on how to perform sustainable image processing and how to open and make calculations with many big images while keeping the memory consumption low with efficient code. </p>
<p class="calibre1"><a href="index_split_003.html#p424">Chapter 10</a>,  <i class="calibre4">Parallel Processing</i>, will teach the reader how to use the full available computer power. In order to speed up tasks, it will show how to distribute them among</p>
<p class="calibre1"><a id="p29"/>processor cores for parallel processing. </p>
<p class="calibre1"><a id="p30"/>
<a id="p31"/><b class="calibre3">What you need for this book</b></p>
<p class="calibre1">To run the examples of this book, you will only need a computer with at least 4 GB of RAM with the Ubuntu Linux or Microsoft Windows operating system. All the programs and libraries that we will use are either free of charge or open source. </p>
<p class="calibre1"><a id="p32"/>
<a id="p33"/><b class="calibre3">Who this book is for</b></p>
<p class="calibre1">This book is intended for beginners or advanced developers in Python, who want to work with geographic data. The book is suitable for professional developers who are new to geospatial development, for hobbyists, or for data scientists who want to move into simple development. </p>
<p class="calibre1"><a id="p34"/>
<a id="p35"/><b class="calibre3">Conventions</b></p>
<p class="calibre1">In this book, you will find a number of text styles that distinguish between different kinds of information. Here are some examples of these styles and an explanation of their meaning. </p>
<p class="calibre1">Code words in text, database table names, folder names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles are shown as follows: “A Python package is a directory containing one or more Python files (that is, modules) plus one __init__.py file.” </p>
<p class="calibre1">A block of code is set as follows:</p>
<p class="calibre1">import ogr</p>
<p class="calibre1"># Open the shapefile and get the first layer. </p>
<p class="calibre1">datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">print("Number of features: {}".format(layer.GetFeatureCount())) When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1"><b class="calibre3">    vector_data = PointCollection("../data/geocaching.gpx")</b> vector_data.print_information()</p>
<p class="calibre1">Any command-line input or output is written as follows:</p>
<p class="calibre1"><b class="calibre3">Collecting django</b></p>
<p class="calibre1"><b class="calibre3">  Downloading Django-1.9-py2.py3-none-any.whl (6.6MB)</b></p>
<p class="calibre1"><b class="calibre3">    100% |################################| 6.6MB 43kB/s</b> <b class="calibre3">Installing collected packages: django</b></p>
<p class="calibre1"><b class="calibre3">Successfully installed django-1.9</b></p>
<p class="calibre1"><b class="calibre3">New terms</b> and <b class="calibre3">important words</b> are shown in bold. Words that you see on the screen, for example, in menus or dialog boxes, appear in the text like this: “Proceed with the default options by clicking on the <b class="calibre3">Next</b> button.” </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Warnings or important notes appear in a box like this. </p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">Tips and tricks appear like this. </p>
<p class="calibre1"><a id="p36"/>
<a id="p37"/><b class="calibre3">Reader feedback</b></p>
<p class="calibre1">Feedback from our readers is always welcome. Let us know what you think about this book—what you liked or disliked. Reader feedback is important for us as it helps us develop titles that you will really get the most out of. </p>
<p class="calibre1">To send us general feedback, simply e-mail <a href="mailto:feedback@packtpub.com">&lt;feedback@packtpub.com&gt; </a>, and mention the book’s title in the subject of your message. </p>
<p class="calibre1">If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, see our author guide at<a href="http://www.packtpub.com/authors"> www.packtpub.com/authors</a>. </p>
<p class="calibre1"><a id="p38"/>
<a id="p39"/><b class="calibre3">Customer support</b></p>
<p class="calibre1">Now that you are the proud owner of a Packt book, we have a number of things to help you to get the most from your purchase. </p>
<p class="calibre1"><a id="p40"/><b class="calibre3">Downloading the example code</b></p>
<p class="calibre1">You can download the example code files from your account at<a href="http://www.packtpub.com"> http://www.packtpub.com</a></p>
<p class="calibre1">for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support </a>and register to have the files e-mailed directly to you. </p>
<p class="calibre1"><a id="p41"/><b class="calibre3">Downloading the color images of this book</b> We also provide you with a PDF file that has color images of the screenshots/diagrams used in this book. The color images will help you better understand the changes in the output. You can download this file from</p>
<p class="calibre1"><a href="https://www.packtpub.com/sites/default/files/downloads/GeospatialDevelopmentByExampleWithPython_ColorImages.pdf">https://www.packtpub.com/sites/default/files/downloads/GeospatialDevelopmentByExamp</a>leWithPython_ColorImages.pdf</p>
<p class="calibre1"><a id="p42"/><b class="calibre3">Errata</b></p>
<p class="calibre1">Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you find a mistake in one of our books—maybe a mistake in the text or the code—we would be grateful if you could report this to us. By doing so, you can save other readers from frustration and help us improve subsequent versions of this book. If you find any errata, please report them by visiting<a href="http://www.packtpub.com/submit-errata"> http://www.packtpub.com/submit-errata</a>, selecting your book, clicking on the <b class="calibre3">Errata Submission Form</b> link, and entering the details of your errata. Once your errata are verified, your submission will be accepted and the errata will be uploaded to our website or added to any list of existing errata under the Errata section of that title. </p>
<p class="calibre1">To view the previously submitted errata, go to</p>
<p class="calibre1"><a href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a> and enter the name of the book in the search field. The required information will appear under the <b class="calibre3">Errata</b> section. </p>
<p class="calibre1"><a id="p43"/><b class="calibre3">Piracy</b></p>
<p class="calibre1">Piracy of copyrighted material on the Internet is an ongoing problem across all media. At Packt, we take the protection of our copyright and licenses very seriously. If you come across any illegal copies of our works in any form on the Internet, please provide us with the location address or website name immediately so that we can pursue a remedy. </p>
<p class="calibre1">Please contact us at <a href="mailto:copyright@packtpub.com">&lt;copyright@packtpub.com</a>&gt; with a link to the suspected pirated material. </p>
<p class="calibre1">We appreciate your help in protecting our authors and our ability to bring you valuable content. </p>
<p class="calibre1"><a id="p44"/><b class="calibre3">Questions</b></p>
<p class="calibre1">If you have a problem with any aspect of this book, you can contact us at</p>
<p class="calibre1"><a href="mailto:questions@packtpub.com">&lt;questions@packtpub.com</a>&gt;, and we will do our best to address the problem. </p>
<p class="calibre1"><a id="p45"/>
<a id="p46"/><b class="calibre3">Chapter 1. Preparing the Work</b></p>
<p class="calibre1"><b class="calibre3">Environment</b></p>
<p class="calibre1">Working with a programming language as a tool for geoprocessing provides the opportunity to construct a personalized application that can more optimally perform the task required by the user. This means that repetitive tasks can be automated, file inputs and outputs can be customized, and processes can be tuned to perform exactly what you want to be done. </p>
<p class="calibre1">Python is a powerful programming language that is gaining special attention as a tool for geoprocessing and scientific analysis. A number of factors may have contributed to its popularization, and three among them are worth mentioning: it’s a scripting language, it’s flexible and easy to learn, and it has a wide range of libraries available as open source software. </p>
<p class="calibre1">The number of available libraries and packages allow users to spend less time in programming basic functionalities and more in building processes and workflows to reach their goals. </p>
<p class="calibre1">In this first chapter, we will go through the process of installing all the libraries that you will need to go through the examples; it’s likely that these same libraries will also satisfy most of your needs in real-world applications. Then, we will set up an <b class="calibre3">Integrated</b> <b class="calibre3">Development Environment</b> (<b class="calibre3">IDE</b>) that will help organize code and avoid mistakes. </p>
<p class="calibre1">Finally, we will write a sample program with one of the libraries. Therefore, here are the topics that will be covered:</p>
<p class="calibre1">Installing Python and the packages that you need for the examples in this book Learning the basics of the packages that you will use</p>
<p class="calibre1">Installing an IDE to write and organize your code</p>
<p class="calibre1">Creating a project for this book</p>
<p class="calibre1">Writing your first code</p>
<p class="calibre1"><a id="p47"/><b class="calibre3">Installing Python</b></p>
<p class="calibre1">For this book, we suggest using Python 2.7; this version of Python is fully compatible with the libraries and packages that we will use in the examples and also has precompiled binary files available on the Internet for Windows users. We will keep all the examples as compatible as possible with Python 3.4 so that it would be easy to port future upgrades. </p>
<p class="calibre1">Windows users may find compatibility problems with the 64-bit packages, so we recommend the 32-bit version of Python for them. </p>
<p class="calibre1">For Linux users, we will show the installation procedures for Ubuntu Linux distribution and use package managers, so you don’t need to worry about versions and requirements; the package managers will do this for you. </p>
<p class="calibre1">The libraries that you will install are written in Python and other languages, the most common being C and C++. These libraries can abstract classes, methods, and functions to Python objects or have an extra layer that makes the connection; when this happens, we say that the library has  <i class="calibre4">Python bindings</i>. </p>
<p class="calibre1"><a id="p48"/><b class="calibre3">Windows</b></p>
<p class="calibre1">Here are the steps to perform for the installation of Python on Windows: 1.  Go to<a href="https://www.python.org/downloads/windows/"> https://www.python.org/downloads/windows/</a> and click on Download the latest Python 2.7 release for Windows. </p>
<p class="calibre1">2.  On the next page, roll down, and you will find a list of files; make sure that you download <b class="calibre3">Windows x86 MSI installer</b>. </p>
<p class="calibre1">3.  After the file is downloaded, open the installer by clicking on the file and following the instructions. Proceed with the default options by clicking on the <b class="calibre3">Next</b> button. </p>
<p class="calibre1"><a id="p49"/><b class="calibre3">Ubuntu Linux</b></p>
<p class="calibre1">Ubuntu already comes with Python installed, so there is no need to install it. If for any reason, it’s not available, you can install it with the following command: sudo apt-get install python</p>
<p class="calibre1">Python 2.7.9 comes with Pip, but if you use an older version, you need to install Pip with the following command:</p>
<p class="calibre1">sudo apt-get install python-pip</p>
<p class="calibre1"><a id="p50"/>
<a id="p51"/><b class="calibre3">Python packages and package manager</b></p>
<p class="calibre1">A Python package is a directory containing one or more Python files (that is, modules) plus one __init__.py file (this can be just an empty file). This file tells Python Interpreter that the directory is a package. </p>
<p class="calibre1">When writing Python code, we can import packages and modules and use them in our code. The Python community does this a lot; many packages use other packages and so on, forming an intricate network of requirements and dependencies. </p>
<p class="calibre1">In order to facilitate the installation of packages and all the requirements for it to run, Python has a package manager called pip. </p>
<p class="calibre1">Pip looks for packages in a central repository (or on a user-defined place), downloads it, then downloads its dependencies, and installs them. Some packages also use libraries in other languages, such as C. In these cases, these libraries need to be compiled during the installation. Ubuntu users don’t have problem with this because many compilers are already installed on the system, but this won’t work on Windows by default. </p>
<p class="calibre1"><a id="p52"/><b class="calibre3">The repository of Python packages for Windows</b> Python makes it easy to install libraries and packages through pip. However, since Windows doesn’t include any compiler by default, the installation of packages that needs the compilation of libraries fails. Instead of going through the process of installing a compiler, which is out of this book’s scope, we can get the packages ready to use. </p>
<p class="calibre1">These packages come prebuilt for various types of system and don’t need a compilation of its libraries. This type of package is called a wheel. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Christoph Gohlke did a favor to all of us by building these packages and making them available for download at<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/"> http://www.lfd.uci.edu/~gohlke/pythonlibs/. </a></p>
<p class="calibre1"><a id="p53"/>
<a id="p54"/><b class="calibre3">Installing packages and required software</b></p>
<p class="calibre1">In this topic, we will go through the installation process of every package used in the book. </p>
<p class="calibre1"><a id="p55"/><b class="calibre3">OpenCV</b></p>
<p class="calibre1">OpenCV is an optimized C/C++ library intended for video and image processing with hundreds of functions ranging from simple image resizing to object recognition, face detection, and so on. OpenCV is a big library, and we will use its capabilities of reading, transforming, and writing images. It’s a good choice because its development is active, and it has a large user community and very good documentation. </p>
<p class="calibre1"><a id="p56"/><b class="calibre3">Windows</b></p>
<p class="calibre1">Here is the installation procedure for Windows:</p>
<p class="calibre1">1.  Go to<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/"> http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>. </p>
<p class="calibre1">2.  Press  <i class="calibre4">Ctrl</i> +  <i class="calibre4">F</i> to open the search dialog of your browser and then search for OpenCV. </p>
<p class="calibre1">3.  You will find a list of files; choose opencv_python-2.4.11-cp27-none-win32.whl or any OpenCV version that contains cp27 and win32. This means that this is the 32-bit version for Python 2.7. </p>
<p class="calibre1">4.  Save the downloaded file to a known location. </p>
<p class="calibre1">5.  Open Windows Command Prompt and run the following command: <b class="calibre3">c:\Python27\scripts\pip install path_to_the_file_you_downloaded.whl</b> 6.  You should see an output telling you that the installation was successful, as follows: <b class="calibre3">Processing c:\downloads\opencv_python-2.4.12-cp27-none-win32.whl</b> <b class="calibre3">Installing collected packages: opencv-python</b></p>
<p class="calibre1"><b class="calibre3">Successfully installed opencv-python-2.4.12</b></p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">You can drag and drop a file into the command prompt to enter its full path. </p>
<p class="calibre1"><a id="p57"/><b class="calibre3">Ubuntu Linux</b></p>
<p class="calibre1">Here is the installation process for Ubuntu Linux:</p>
<p class="calibre1">1.  Open a new terminal with  <i class="calibre4">Ctrl</i> +  <i class="calibre4">T</i>. </p>
<p class="calibre1">2.  Then, enter the following command:</p>
<p class="calibre1"><b class="calibre3">sudo apt-get install python-opencv</b></p>
<p class="calibre1"><a id="p58"/>
<a id="p59"/><b class="calibre3">Installing NumPy</b></p>
<p class="calibre1">NumPy is a package for scientific computing with Python. It handles multidimensional arrays of operations in a very efficient way. NumPy is required by OpenCV to run and will be used by many raster operations that we will perform in the examples. NumPy is also an efficient data container and will be our tool to calculate massive image data. </p>
<p class="calibre1"><a id="p60"/><b class="calibre3">Windows</b></p>
<p class="calibre1">Repeat the same procedure as you did to install OpenCV; however, this time, search for NumPy and choose a file named numpy-1.9.2+mkl-cp27-none-win32.whl. </p>
<p class="calibre1"><a id="p61"/><b class="calibre3">Ubuntu Linux</b></p>
<p class="calibre1">NumPy is automatically installed as a dependency of OpenCV on Ubuntu, but if you want to install it without OpenCV, follow these steps:</p>
<p class="calibre1">1.  Open a new terminal with  <i class="calibre4">Ctrl</i> +  <i class="calibre4">T</i>. </p>
<p class="calibre1">2.  Then, enter the following command:</p>
<p class="calibre1"><b class="calibre3">sudo pip install numpy</b></p>
<p class="calibre1"><a id="p62"/>
<a id="p63"/><b class="calibre3">Installing GDAL and OGR</b></p>
<p class="calibre1"><b class="calibre3">GDAL</b> (<b class="calibre3">Geospatial Data Abstraction Library</b>) is composed of two packages that come together: OGR handles geospatial vector file formats, including coordinate system transformations and vector operations. GDAL is the raster part of the library, and in version 1.11, it comes packed with 139 drivers that can read, and some even create rasters. </p>
<p class="calibre1">GDAL also comes packed with functions for raster transformations and calculations such as resizing, clipping, reprojecting, and so on. </p>
<p class="calibre1">In the following tables, there’s an excerpt of the list of GDAL and OGR drivers with the most common formats that you may find:</p>
<p class="calibre1"><b class="calibre3">Long format name</b></p>
<p class="calibre1"><b class="calibre3">Code</b></p>
<p class="calibre1"><b class="calibre3">Creation</b></p>
<p class="calibre1">Arc/Info ASCII Grid</p>
<p class="calibre1">AAIGrid</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Arc/Info Export E00 GRID</p>
<p class="calibre1">E00GRID</p>
<p class="calibre1">No</p>
<p class="calibre1">ENVI .hdr Labelled Raster</p>
<p class="calibre1">ENVI</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Generic Binary (.hdr Labelled)</p>
<p class="calibre1">GENBIN</p>
<p class="calibre1">No</p>
<p class="calibre1">Oracle Spatial GeoRaster</p>
<p class="calibre1">GEORASTER</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GSat File Format</p>
<p class="calibre1">GFF</p>
<p class="calibre1">No</p>
<p class="calibre1">Graphics Interchange Format (.gif)</p>
<p class="calibre1">GIF</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GMT Compatible netCDF</p>
<p class="calibre1">GMT</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GRASS ASCII Grid</p>
<p class="calibre1">GRASSASCIIGrid No</p>
<p class="calibre1">Golden Software ASCII Grid</p>
<p class="calibre1">GSAG</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Golden Software Binary Grid</p>
<p class="calibre1">GSBG</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Golden Software Surfer 7 Binary Grid</p>
<p class="calibre1">GS7BG</p>
<p class="calibre1">Yes</p>
<p class="calibre1">TIFF / BigTIFF / GeoTIFF (.tif)</p>
<p class="calibre1">GTiff</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GXF (Grid eXchange File)</p>
<p class="calibre1">GXF</p>
<p class="calibre1">No</p>
<p class="calibre1">Erdas Imagine (.img)</p>
<p class="calibre1">HFA</p>
<p class="calibre1">Yes</p>
<p class="calibre1">JPEG JFIF (.jpg)</p>
<p class="calibre1">JPEG</p>
<p class="calibre1">Yes</p>
<p class="calibre1">NOAA Polar Orbiter Level 1b Data Set (AVHRR) L1B</p>
<p class="calibre1">No</p>
<p class="calibre1">NOAA NGS Geoid Height Grids</p>
<p class="calibre1">NGSGEOID</p>
<p class="calibre1">No</p>
<p class="calibre1">NITF</p>
<p class="calibre1">NITF</p>
<p class="calibre1">Yes</p>
<p class="calibre1"><a id="p64"/>NTv2 Datum Grid Shift</p>
<p class="calibre1">NTv2</p>
<p class="calibre1">Yes</p>
<p class="calibre1">PCI .aux Labelled</p>
<p class="calibre1">PAux</p>
<p class="calibre1">Yes</p>
<p class="calibre1">PCI Geomatics Database File</p>
<p class="calibre1">PCIDSK</p>
<p class="calibre1">Yes</p>
<p class="calibre1">PCRaster</p>
<p class="calibre1">PCRaster</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Geospatial PDF</p>
<p class="calibre1">PDF</p>
<p class="calibre1">Yes</p>
<p class="calibre1">NASA Planetary Data System</p>
<p class="calibre1">PDS</p>
<p class="calibre1">No</p>
<p class="calibre1">Portable Network Graphics (.png)</p>
<p class="calibre1">PNG</p>
<p class="calibre1">Yes</p>
<p class="calibre1">R Object Data Store</p>
<p class="calibre1">R</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Raster Matrix Format (*.rsw, .mtw)</p>
<p class="calibre1">RMF</p>
<p class="calibre1">Yes</p>
<p class="calibre1">RadarSat2 XML (product.xml)</p>
<p class="calibre1">RS2</p>
<p class="calibre1">No</p>
<p class="calibre1">Idrisi Raster</p>
<p class="calibre1">RST</p>
<p class="calibre1">Yes</p>
<p class="calibre1">SAGA GIS Binary format</p>
<p class="calibre1">SAGA</p>
<p class="calibre1">Yes</p>
<p class="calibre1">USGS SDTS DEM (*CATD.DDF)</p>
<p class="calibre1">SDTS</p>
<p class="calibre1">No</p>
<p class="calibre1">SGI Image Format</p>
<p class="calibre1">SGI</p>
<p class="calibre1">Yes</p>
<p class="calibre1">SRTM HGT Format</p>
<p class="calibre1">SRTMHGT</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Terragen Heightfield (.ter)</p>
<p class="calibre1">TERRAGEN</p>
<p class="calibre1">Yes</p>
<p class="calibre1">USGS ASCII DEM / CDED (.dem)</p>
<p class="calibre1">USGSDEM</p>
<p class="calibre1">Yes</p>
<p class="calibre1">ASCII Gridded XYZ</p>
<p class="calibre1">XYZ</p>
<p class="calibre1">Yes</p>
<p class="calibre1">The following table describes the OGR drivers:</p>
<p class="calibre1"><b class="calibre3">Format name</b></p>
<p class="calibre1"><b class="calibre3">Code</b></p>
<p class="calibre1"><b class="calibre3">Creation</b></p>
<p class="calibre1">Arc/Info Binary Coverage</p>
<p class="calibre1">AVCBin</p>
<p class="calibre1">No</p>
<p class="calibre1">Arc/Info .E00 (ASCII) Coverage AVCE00</p>
<p class="calibre1">No</p>
<p class="calibre1">AutoCAD DXF</p>
<p class="calibre1">DXF</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Comma Separated Value (.csv) CSV</p>
<p class="calibre1">Yes</p>
<p class="calibre1">ESRI Shapefile</p>
<p class="calibre1">ESRI Shapefile Yes</p>
<p class="calibre1">GeoJSON</p>
<p class="calibre1">GeoJSON</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Géoconcept Export</p>
<p class="calibre1">Geoconcept</p>
<p class="calibre1">Yes</p>
<p class="calibre1"><a id="p65"/>GeoRSS</p>
<p class="calibre1">GeoRSS</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GML</p>
<p class="calibre1">GML</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GMT</p>
<p class="calibre1">GMT</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GPSBabel</p>
<p class="calibre1">GPSBabel</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GPX</p>
<p class="calibre1">GPX</p>
<p class="calibre1">Yes</p>
<p class="calibre1">GPSTrackMaker (.gtm, .gtz)</p>
<p class="calibre1">GPSTrackMaker</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Hydrographic Transfer Format</p>
<p class="calibre1">HTF</p>
<p class="calibre1">No</p>
<p class="calibre1">Idrisi Vector (.VCT)</p>
<p class="calibre1">Idrisi</p>
<p class="calibre1">No</p>
<p class="calibre1">KML</p>
<p class="calibre1">KML</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Mapinfo File</p>
<p class="calibre1">MapInfo File</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Microstation DGN</p>
<p class="calibre1">DGN</p>
<p class="calibre1">Yes</p>
<p class="calibre1">OpenAir</p>
<p class="calibre1">OpenAir</p>
<p class="calibre1">No</p>
<p class="calibre1">ESRI FileGDB</p>
<p class="calibre1">OpenFileGDB</p>
<p class="calibre1">No</p>
<p class="calibre1">PCI Geomatics Database File</p>
<p class="calibre1">PCIDSK</p>
<p class="calibre1">Yes</p>
<p class="calibre1">Geospatial PDF</p>
<p class="calibre1">PDF</p>
<p class="calibre1">Yes</p>
<p class="calibre1">PDS</p>
<p class="calibre1">PDS</p>
<p class="calibre1">No</p>
<p class="calibre1">PostgreSQL SQL dump</p>
<p class="calibre1">PGDump</p>
<p class="calibre1">Yes</p>
<p class="calibre1">U.S. Census TIGER/Line</p>
<p class="calibre1">TIGER</p>
<p class="calibre1">No</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">You can find the full GDAL and OGR API documentation and the complete list of drivers at <a href="http://gdal.org/python/">http://gdal.org/python/</a>. </p>
<p class="calibre1"><a id="p66"/><b class="calibre3">Windows</b></p>
<p class="calibre1">Again, we will use a wheel for the installation. Repeat the same procedure as before: 1.  Go to<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/"> http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>. </p>
<p class="calibre1">2.  Now, search for GDAL and download the file named</p>
<p class="calibre1">GDAL-1.11.3-cp27-none-win32.whl. </p>
<p class="calibre1">3.  Finally, install it with pip, as we did before. </p>
<p class="calibre1"><a id="p67"/><b class="calibre3">Ubuntu Linux</b></p>
<p class="calibre1">Perform the following steps:</p>
<p class="calibre1">1.  Go to the terminal or open a new one. </p>
<p class="calibre1">2.  Then, enter the following command:</p>
<p class="calibre1"><b class="calibre3">sudo apt-get install python-gdal</b></p>
<p class="calibre1"><a id="p68"/>
<a id="p69"/><b class="calibre3">Installing Mapnik</b></p>
<p class="calibre1">Mapnik is a map rendering package. It is a free toolkit to develop mapping applications. It produces high-quality maps and is used on many applications, including OpenStreetMaps. </p>
<p class="calibre1"><a id="p70"/><b class="calibre3">Windows</b></p>
<p class="calibre1">Mapnik isn’t available for installation as other libraries are. Instead, you need to go to</p>
<p class="calibre1"><a href="http://mapnik.org/">http://mapnik.org/</a> and follow the download link: 1.  Download the Windows 32-bit package of Mapnik 2.2. </p>
<p class="calibre1">2.  Extract the mapnik-v2.2.0 to C:\ folder. </p>
<p class="calibre1">3.  Then, rename the extracted folder c:\mapnik. </p>
<p class="calibre1">4.  Now, add Mapnik to your <b class="calibre3">PATH</b>. </p>
<p class="calibre1">5.  Open <b class="calibre3">Control Panel</b> and go to <b class="calibre3">System</b>. </p>
<p class="calibre1">6.  Click on the <b class="calibre3">Advanced System Settings</b> link in the left-hand side column. </p>
<p class="calibre1">7.  In the <b class="calibre3">System Properties</b> window, click on the <b class="calibre3">Advanced</b> tab. </p>
<p class="calibre1">8.  Next, click on the <b class="calibre3">Environment Variables</b> button. </p>
<p class="calibre1">9.  In the <b class="calibre3">System variables</b> section, highlight the <b class="calibre3">PATH</b> variable and click on <b class="calibre3">Edit</b>. Add the following paths to the end of the list, each separated with a semicolon, as follows: <b class="calibre3">c:\mapnik\bin;c:\mapnik\lib</b></p>
<p class="calibre1">10.  Now, click on the <b class="calibre3">New</b> button; then, set the variable name to PYTHONPATH and value to c:\mapnik\python\2.7\site-packages. </p>
<p class="calibre1"><a id="p71"/><b class="calibre3">Ubuntu Linux</b></p>
<p class="calibre1">For this, perform the following:</p>
<p class="calibre1">1.  Go to the terminal or open a new one. </p>
<p class="calibre1">2.  Then, enter the following command:</p>
<p class="calibre1"><b class="calibre3">sudo apt-get install mapnik</b></p>
<p class="calibre1"><a id="p72"/>
<a id="p73"/><b class="calibre3">Installing Shapely</b></p>
<p class="calibre1">Shapely is a package for the manipulation and analysis of two dimensional geometries. It can perform operations such as union and subtraction of geometries. It also can perform tests and comparisons, such as when a geometry intersects other geometries. </p>
<p class="calibre1"><a id="p74"/><b class="calibre3">Windows</b></p>
<p class="calibre1">Here’s what you need to do:</p>
<p class="calibre1">1.  As before, download the prebuilt wheel; this time, look for a file named Shapely-1.5.13-cp27-none-win32.whl. </p>
<p class="calibre1">2.  Then, install it with pip. </p>
<p class="calibre1"><a id="p75"/><b class="calibre3">Ubuntu Linux</b></p>
<p class="calibre1">Here are the steps you need to perform:</p>
<p class="calibre1">1.  Go to the terminal or open a new one with  <i class="calibre4">Ctrl</i> +  <i class="calibre4">T</i>. </p>
<p class="calibre1">2.  Enter the following command:</p>
<p class="calibre1"><b class="calibre3">sudo pip install shapely</b></p>
<p class="calibre1"><a id="p76"/>
<a id="p77"/><b class="calibre3">Installing other packages directly from</b></p>
<p class="calibre1"><b class="calibre3">pip</b></p>
<p class="calibre1">Some packages do not require compilation steps. For Windows users, these are easier to install because they can be obtained and installed directly with pip with a single command. </p>
<p class="calibre1"><a id="p78"/><b class="calibre3">Windows</b></p>
<p class="calibre1">You need to simply type the following command in your Command Prompt: <b class="calibre3">c:\Python27\scripts\pip install django tabulate requests xmltodict psycopg2</b></p>
<p class="calibre1"><a id="p79"/><b class="calibre3">Ubuntu Linux</b></p>
<p class="calibre1">In the terminal, type the following command:</p>
<p class="calibre1"><b class="calibre3">sudo pip install django tabulate requests xmltodict psycopg2</b></p>
<p class="calibre1">For each package, you should see the progress of the installation, similar to the following: <b class="calibre3">Collecting django</b></p>
<p class="calibre1"><b class="calibre3">  Downloading Django-1.9-py2.py3-none-any.whl (6.6MB)</b></p>
<p class="calibre1"><b class="calibre3">    100% |################################| 6.6MB 43kB/s</b> <b class="calibre3">Installing collected packages: django</b></p>
<p class="calibre1"><b class="calibre3">Successfully installed django-1.9</b></p>
<p class="calibre1"><a id="p80"/>
<a id="p81"/><b class="calibre3">Installing an IDE</b></p>
<p class="calibre1">IDEs are fancy text editors with tools and inspections regarding programming languages. </p>
<p class="calibre1">You can surely use any text editor or IDE of your preference; none of the tasks in this book depends on the IDE, but an IDE will facilitate our work a lot because the suggested configuration will help you avoid mistakes and save time on typing, running, and debugging your code. The IDE checks the code for you and detects underlying errors; it even guesses what you are typing and completes the statements for you, runs the code with a simple command, and if there are exceptions, it provides links to the place where the exception occurred. For Windows or Linux, go to <a href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a></p>
<p class="calibre1">and click on the big orange button <b class="calibre3">Get Pycharm Now</b>. On the next page, select the free community edition. </p>
<p class="calibre1"><a id="p82"/><b class="calibre3">Windows</b></p>
<p class="calibre1">Here are the steps you need to perform:</p>
<p class="calibre1">1.  After the download finishes, open the downloaded file; the <b class="calibre3">Setup Wizard</b> will pop up. </p>
<p class="calibre1">2.  Click on <b class="calibre3">Next</b>, and in the installation options, check both of the boxes: <b class="calibre3">Create</b> <b class="calibre3">Desktop shortcut</b> and <b class="calibre3">Create associations</b>. </p>
<p class="calibre1">3.  Click on <b class="calibre3">Next</b> and continue the installation. </p>
<p class="calibre1"><a id="p83"/><b class="calibre3">Linux</b></p>
<p class="calibre1">Perform the following steps:</p>
<p class="calibre1">1.  Unpack the downloaded file in a directory. </p>
<p class="calibre1">2.  To open PyCharm, run pycharm.sh from the bin subdirectory. You can create a shortcut to it if you wish. </p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1"><b class="calibre3">Downloading the example code</b></p>
<p class="calibre1">You can download the example code files for all Packt books you have purchased from your account at<a href="http://www.packtpub.com"> http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you. </p>
<p class="calibre1"><a id="p84"/>
<a id="p85"/><img src="img/index-85_1.jpg" alt="Image 3" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Creating the book project</b></p>
<p class="calibre1">Perform the following steps:</p>
<p class="calibre1">1.  After installation, open Pycharm, and you will be prompted to create your first project:</p>
<p class="calibre1">2.  Click on create new project and then choose c:\geopy as your project location. In Linux, you can put the project inside your home folder—for example, </p>
<p class="calibre1">/home/myname/geopy. Click on <b class="calibre3">Create</b> to create the project. </p>
<p class="calibre1"><a id="p86"/><img src="img/index-86_1.jpg" alt="Image 4" class="calibre2"/></p>
<p class="calibre1">3.  In Windows, you will receive a security alert; this is Pycharm trying to access the Internet. It’s recommended that you allow it so that you can later check for updates or download plugins:</p>
<p class="calibre1"><a id="p87"/><img src="img/index-87_1.jpg" alt="Image 5" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-87_2.jpg" alt="Image 6" class="calibre2"/></p>
<p class="calibre1">4.  Finally, you should see the following window on your project workspace. Take some time to explore the menus and buttons, try right-clicking on your project folder to see the options:</p>
<p class="calibre1"><a id="p88"/>
<a id="p89"/><b class="calibre3">Programming and running your first</b></p>
<p class="calibre1"><b class="calibre3">example</b></p>
<p class="calibre1">Now that we have all we need installed, we will go through our first example. In this example, we will test the installation and then see a glimpse of OGR’s capabilities. </p>
<p class="calibre1">To do this, we will open a vector file containing the boundaries of all the countries in the world and make a list of country names. The objective of this simple example is to present the logic behind OGR objects and functions and give an understanding of how geospatial files are represented. Here’s how:</p>
<p class="calibre1">1.  First, you need to copy the sample data provided with the book to your project folder. </p>
<p class="calibre1">You can do this by dragging and dropping the data folder into the geopy folder. Make sure that the data folder is named data and that it’s inside the geopy folder. </p>
<p class="calibre1">2.  Now, create a new directory for this chapter code, inside PyCharm. With your geopy project opened, right-click on the project folder and select <b class="calibre3">New</b> | <b class="calibre3">Directory</b>. Name it Chapter1. </p>
<p class="calibre1">3.  Create a new Python file. To do this, right-click on the Chapter1 folder and select <b class="calibre3">New</b> | <b class="calibre3">Python File</b>. Name it world_borders.py, and PyCharm will automatically open the file for editing. </p>
<p class="calibre1">4.  Type the following code in this file:</p>
<p class="calibre1">import ogr</p>
<p class="calibre1"># Open the shapefile and get the first layer. </p>
<p class="calibre1">datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">print("Number of features: {}".format(layer.GetFeatureCount())) 5.  Now, run the code; in the menu bar, navigate to <b class="calibre3">Run</b> | <b class="calibre3">Run</b>, and in the dialog, choose world_borders. An output console will open at the bottom of the screen, and if everything goes fine, you should see this output:</p>
<p class="calibre1"><b class="calibre3">C:\Python27\python.exe C:/geopy/world_borders.py</b></p>
<p class="calibre1"><b class="calibre3">Number of features: 246</b></p>
<p class="calibre1"><b class="calibre3">Process finished with exit code 0</b></p>
<p class="calibre1">Congratulations! You successfully opened a Shapefile and counted the number of features inside it. Now, let’s understand what this code does. </p>
<p class="calibre1">The first line imports the ogr package. From this point on, all the functions are available as ogr.FunctionName(). Note that ogr doesn’t follow the Python naming conventions for functions. </p>
<p class="calibre1">The line after the comment opens the OGR datasource (this opens the shapefile containing the data) and assigns the object to the datasource variable. Note that the path, even on Windows, uses a forward slash (/) and not a backslash. </p>
<p class="calibre1">The next line gets the first layer of the data source by its index (0). Some data sources can</p>
<p class="calibre1"><a id="p90"/>have many layers, but this is not the case of a Shapefile, which has only one layer. So, when working with Shapefiles, we always know that the layer of interest is layer 0. </p>
<p class="calibre1">In the final line, the print statement prints the number of features returned by layer.GetFeatureCount(). Here, we will use Python’s string formatting, where the curly braces are replaced by the argument passed to format(). </p>
<p class="calibre1">Now, perform the following steps:</p>
<p class="calibre1">1.  In the same file, let’s type the next part of our program:</p>
<p class="calibre1"># Inspect the fields available in the layer. </p>
<p class="calibre1">feature_definition = layer.GetLayerDefn()</p>
<p class="calibre1">for field_index in range(feature_definition.GetFieldCount()): field_definition = feature_definition.GetFieldDefn(field_index) print("\t{}\t{}\t{}".format(field_index, </p>
<p class="calibre1">field_definition.GetTypeName(), </p>
<p class="calibre1">field_definition.GetName()))</p>
<p class="calibre1">2.  Rerun the code; you can use the  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> shortcut for this. Now, you should see the number of features as before plus a pretty table showing information on all the fields in the shapefile, as follows:</p>
<p class="calibre1"><b class="calibre3">Number of features: 246</b></p>
<p class="calibre1"><b class="calibre3"> 0 String  FIPS</b></p>
<p class="calibre1"><b class="calibre3"> 1 String  ISO2</b></p>
<p class="calibre1"><b class="calibre3"> 2 String  ISO3</b></p>
<p class="calibre1"><b class="calibre3"> 3 Integer UN</b></p>
<p class="calibre1"><b class="calibre3"> 4 String  NAME</b></p>
<p class="calibre1"><b class="calibre3"> 5 Integer POP2005</b></p>
<p class="calibre1"><b class="calibre3"> 6 Integer REGION</b></p>
<p class="calibre1"><b class="calibre3"> 7 Integer SUBREGION</b></p>
<p class="calibre1"><b class="calibre3">Process finished with exit code 0</b></p>
<p class="calibre1">What happens in this piece of code is that feature_definition =</p>
<p class="calibre1">layer.GetLayerDefn() gets the object that contains the definition of the features. </p>
<p class="calibre1">This object contains the definition for each field and the type of geometry. </p>
<p class="calibre1">In the for loop, we will get each field definition and print its index, name, and type. </p>
<p class="calibre1">Note that the object returned by layer.GetLayerDefn() is not iterable, and we can’t use for directly with it. So first, we will get the number of fields and use it in the range() function so that we can iterate through the indexes of the fields: 3.  Now, type the last part, as follows:</p>
<p class="calibre1"># Print a list of country names. </p>
<p class="calibre1">layer.ResetReading()</p>
<p class="calibre1">for feature in layer:</p>
<p class="calibre1">print(feature.GetFieldAsString(4))</p>
<p class="calibre1">4.  Run the code again and check the results in the output: <b class="calibre3">Number of features: 246</b></p>
<p class="calibre1"><b class="calibre3"> 0 String FIPS</b></p>
<p class="calibre1"><a id="p91"/><b class="calibre3"> 1 String ISO2</b></p>
<p class="calibre1"><b class="calibre3"> 2 String ISO3</b></p>
<p class="calibre1"><b class="calibre3"> 3 Integer UN</b></p>
<p class="calibre1"><b class="calibre3"> 4 String NAME</b></p>
<p class="calibre1"><b class="calibre3"> 5 Integer POP2005</b></p>
<p class="calibre1"><b class="calibre3"> 6 Integer REGION</b></p>
<p class="calibre1"><b class="calibre3"> 7 Integer SUBREGION</b></p>
<p class="calibre1"><b class="calibre3">Antigua and Barbuda</b></p>
<p class="calibre1"><b class="calibre3">Algeria</b></p>
<p class="calibre1"><b class="calibre3">Azerbaijan</b></p>
<p class="calibre1"><b class="calibre3">Albania</b></p>
<p class="calibre1"><b class="calibre3">Armenia</b></p>
<p class="calibre1"><b class="calibre3">Angola</b></p>
<p class="calibre1"><b class="calibre3">... </b></p>
<p class="calibre1"><b class="calibre3">Saint Barthelemy</b></p>
<p class="calibre1"><b class="calibre3">Guernsey</b></p>
<p class="calibre1"><b class="calibre3">Jersey</b></p>
<p class="calibre1"><b class="calibre3">South Georgia South Sandwich Islands</b></p>
<p class="calibre1"><b class="calibre3">Taiwan</b></p>
<p class="calibre1"><b class="calibre3">Process finished with exit code 0</b></p>
<p class="calibre1">The layer is iterable, but first, we need to ensure that we are at the beginning of the layer list with layer.ResetReading() (this is one of OGR’s “gotcha” points). </p>
<p class="calibre1">The feature.GetFieldAsString(4) method returns the value of field 4 as a Python string. There are two ways of knowing whether the country names are in field 4: Looking at the data’s DBF file (by opening it with LibreOffice or Excel) Looking at the table that we printed in the first part of the code Your complete code should look similar to the following:</p>
<p class="calibre1">import ogr</p>
<p class="calibre1"># Open the shapefile and get the first layer. </p>
<p class="calibre1">datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">print("Number of features: {}".format(layer.GetFeatureCount()))</p>
<p class="calibre1"># Inspect the fields available in the layer. </p>
<p class="calibre1">feature_definition = layer.GetLayerDefn()</p>
<p class="calibre1">for field_index in range(feature_definition.GetFieldCount()): field_definition = feature_definition.GetFieldDefn(field_index) print("\t{}\t{}\t{}".format(field_index, </p>
<p class="calibre1">field_definition.GetTypeName(), </p>
<p class="calibre1">field_definition.GetName()))</p>
<p class="calibre1"># Print a list of country names. </p>
<p class="calibre1">layer.ResetReading()</p>
<p class="calibre1">for feature in layer:</p>
<p class="calibre1">print(feature.GetFieldAsString(4)) </p>
<p class="calibre1"><a id="p92"/>
<a id="p93"/><b class="calibre3">Transforming the coordinate system and</b></p>
<p class="calibre1"><b class="calibre3">calculating the area of all countries</b></p>
<p class="calibre1">Now, the objective is to know how much area is occupied by each country. However, the coordinates of country borders are expressed in latitude and longitude, and we can’t calculate areas in this coordinate system. We want the area to be in the metric system, so first we need to convert the spatial reference system of the geometries. </p>
<p class="calibre1">Let’s also take a step further in the programming techniques and start using functions to avoid the repetition of code. Perform the following steps:</p>
<p class="calibre1">1.  Create a new file in the Chapter1 directory, name this file world_areas.py, and program this first function:</p>
<p class="calibre1">import ogr</p>
<p class="calibre1">def open_shapefile(file_path):</p>
<p class="calibre1">"""Open the shapefile, get the first layer and returns the ogr datasource. </p>
<p class="calibre1">""" </p>
<p class="calibre1">datasource = ogr.Open(file_path)</p>
<p class="calibre1">layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">print("Opening {}".format(file_path))</p>
<p class="calibre1">print("Number of features: {}".format(  </p>
<p class="calibre1">layer.GetFeatureCount()))</p>
<p class="calibre1">return datasource</p>
<p class="calibre1">2.  Run the code, go to <b class="calibre3">Run</b> | <b class="calibre3">Run…</b> in the menu, and select world_areas. If everything is correct, nothing should happen. This is because we are not calling our function. </p>
<p class="calibre1">Add this line of code at the end and outside the function:</p>
<p class="calibre1">datasource = open_shapefile("../data/world_borders_simple.shp") 3.  Now, run the code again with  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and check the output, as follows: <b class="calibre3">Opening ../data/world_borders_simple.shp</b></p>
<p class="calibre1"><b class="calibre3">Number of features: 246</b></p>
<p class="calibre1"><b class="calibre3">Process finished with exit code 0</b></p>
<p class="calibre1">That’s wonderful! You just created a piece of very useful and reusable code. You now have a function that can open any shapefile, print the number of features, and return the ogr datasource. From now on, you can reuse this function in any of your projects. </p>
<p class="calibre1">You are already familiar with how this code works, but there are a few novelties here that deserve an explanation. The def statement defines a function with the def function_name(arguments): syntax. </p>
<p class="calibre1">Remember when I told you that OGR doesn’t follow Python’s naming convention? Well, the convention is that function names should all be in lowercase with an underscore</p>
<p class="calibre1"><a id="p94"/>between words. A good hint for names is to follow the verb_noun rule. </p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">These conventions are described in a document called <b class="calibre3">PEP-8</b>, where <b class="calibre3">PEP</b> stands for <b class="calibre3">Python Enhancement Program</b>. You can find this document at</p>
<p class="calibre1"><a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/. </a></p>
<p class="calibre1">Right after the function’s definition, you can see a description between triple quotes; this is a docstring, and it is used to document the code. It’s optional but very useful for you to know what the function does. </p>
<p class="calibre1">Now, let’s get back to our code. The second important thing to point out is the return statement. This makes the function return the values of the variables listed after the statement—in this case, the datasource. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">It’s very important that all pieces of the OGR objects flow together through the program. </p>
<p class="calibre1">In this case, if we return only the layer, for example, we will get a runtime error later in our program. This happens because in OGR internals, the layer has a reference to the data source, and when you exit a Python function, all objects that don’t exit the function are trashed, and this breaks the reference. </p>
<p class="calibre1">Now, the next step is to create a function that performs the transformation. In OGR, the transformation is made in the feature’s geometry, so we need to iterate over the features, get the geometry, and transform its coordinates. We will do this using the following steps: 1.  Add the following function to your world_areas.py file just after the open_shapefile function:</p>
<p class="calibre1">def transform_geometries(datasource, src_epsg, dst_epsg):</p>
<p class="calibre1">"""Transform the coordinates of all geometries in the first layer. </p>
<p class="calibre1">""" </p>
<p class="calibre1"># Part 1</p>
<p class="calibre1">src_srs = osr.SpatialReference()</p>
<p class="calibre1">src_srs.ImportFromEPSG(src_epsg)</p>
<p class="calibre1">dst_srs = osr.SpatialReference()</p>
<p class="calibre1">dst_srs.ImportFromEPSG(dst_epsg)</p>
<p class="calibre1">transformation = osr.CoordinateTransformation(src_srs, dst_srs) layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1"># Part 2</p>
<p class="calibre1">geoms = []</p>
<p class="calibre1">layer.ResetReading()</p>
<p class="calibre1">for feature in layer:</p>
<p class="calibre1">geom = feature.GetGeometryRef().Clone()</p>
<p class="calibre1">geom.Transform(transformation)</p>
<p class="calibre1">geoms.append(geom)</p>
<p class="calibre1">return geoms</p>
<p class="calibre1">The function takes three arguments: the ogr layer, the EPSG code of the coordinate system of the file, and the EPSG code for the transformation output. </p>
<p class="calibre1"><a id="p95"/>Here, it created an osr.CoordinateTransformation object; this object contains the instructions to perform the transformation. </p>
<p class="calibre1">Probably by now, Pycharm should be complaining that osr is an unresolved reference; osr is the part of GDAL that deals with coordinate systems. </p>
<p class="calibre1">2.  Now, import the module by adding this line at the top of your code: <b class="calibre3">import osr</b></p>
<p class="calibre1">Here, the code iterates over all features, gets a reference to the geometry, and performs the transformation. As we don’t want to change the original data, the geometry is cloned, and the transformation is made on the clone. </p>
<p class="calibre1">Python lists are ordered; this means that the elements are in the same order in which they are appended to the list, and this order is always kept. This allows us to create a list of geometries in the same order of the features that are in the data source. This means that the geometries in the list and the features have the same index and can be related in the future by the index. </p>
<p class="calibre1">3.  Now, let’s test the code; add the following lines at the end of the file (the first line is the one that you already added before):</p>
<p class="calibre1">datasource = open_shapefile("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">feature = layer.GetFeature(0)</p>
<p class="calibre1">print("Before transformation:")</p>
<p class="calibre1">print(feature.GetGeometryRef())</p>
<p class="calibre1">transformed_geoms = transform_geometries(datasource, 4326, 3395) print("After transformation:")</p>
<p class="calibre1">print(transformed_geoms[0])</p>
<p class="calibre1">4.  Finally, before you run the code, add one more import at the beginning of the program. It should be the first statement of your code, as follows: from __future__ import print_function</p>
<p class="calibre1">This import allows us to use the print() function from Python 3 with the desired behavior, thus maintaining the compatibility. </p>
<p class="calibre1">5.  The complete code should look similar to this:</p>
<p class="calibre1">from __future__ import print_function</p>
<p class="calibre1">import ogr</p>
<p class="calibre1">import osr</p>
<p class="calibre1">def open_shapefile(file_path):</p>
<p class="calibre1">... </p>
<p class="calibre1">def transform_geometries(datasource, src_epsg, dst_epsg):</p>
<p class="calibre1">... </p>
<p class="calibre1"/>
<p class="calibre1">datasource = open_shapefile("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1"><a id="p96"/>feature = layer.GetFeature(0)</p>
<p class="calibre1">print("Before transformation:")</p>
<p class="calibre1">print(feature.GetGeometryRef())</p>
<p class="calibre1">transformed_geoms = transform_geometries(datasource, 4326, 3395) print("After transformation:")</p>
<p class="calibre1">print(transformed_geoms[0])</p>
<p class="calibre1">6.  Run your program again by pressing  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>. In the output, note the difference in the coordinates before and after the transformation:</p>
<p class="calibre1"><b class="calibre3">Opening ../data/world_borders_simple.shp</b></p>
<p class="calibre1"><b class="calibre3">Number of features: 246</b></p>
<p class="calibre1"><b class="calibre3">Before transformation:</b></p>
<p class="calibre1"><b class="calibre3">MULTIPOLYGON (((-61.686668 17.024441000000138… )))</b></p>
<p class="calibre1"><b class="calibre3">After transformation:</b></p>
<p class="calibre1"><b class="calibre3">MULTIPOLYGON (((-6866928.4704937246… )))</b></p>
<p class="calibre1"><b class="calibre3">Process finished with exit code 0</b></p>
<p class="calibre1">7.  Now, add another function. This function will calculate the area in square meters (because we will use the geometries that have coordinates in meters), convert the value (or not) to square kilometers or square miles, and store the values in another list with the same order as before. Execute the following code:</p>
<p class="calibre1">def calculate_areas(geometries, unity='km2'):</p>
<p class="calibre1">"""Calculate the area for a list of ogr geometries.""" </p>
<p class="calibre1"># Part 1</p>
<p class="calibre1">conversion_factor = {</p>
<p class="calibre1">'sqmi': 2589988.11, </p>
<p class="calibre1">'km2': 1000000, </p>
<p class="calibre1">'m': 1}</p>
<p class="calibre1"># Part2</p>
<p class="calibre1">if unity not in conversion_factor:</p>
<p class="calibre1">raise ValueError(</p>
<p class="calibre1">"This unity is not defined: {}".format(unity))</p>
<p class="calibre1"># Part 3</p>
<p class="calibre1">areas = []</p>
<p class="calibre1">for geom in geometries:</p>
<p class="calibre1">area = geom.Area()</p>
<p class="calibre1">areas.append(area / conversion_factor[unity])</p>
<p class="calibre1">return areas</p>
<p class="calibre1">Firstly, note that in the function definition, we use unity='km2'; this is a keyword argument, and when you call the functions, this argument is optional. </p>
<p class="calibre1">In Part 1, a dictionary is used to define a few conversion factors for the area unit. </p>
<p class="calibre1">Feel free to add more units if you wish. By the way, Python doesn’t care if you use single or double quotes. </p>
<p class="calibre1">In Part 2, a verification is made to check whether the passed unity exists and whether it is defined in conversion_factor. Another way of doing this is catching the exception later; however, for now, let’s opt for readability. </p>
<p class="calibre1">In Part 3, the code iterates the ogr geometries, calculates the area, converts the values, and puts it on a list. </p>
<p class="calibre1"><a id="p97"/>8.  Now, to test the code, edit your first line, including division to the future imports. </p>
<p class="calibre1">This will ensure that all divisions return floating point numbers and not integers. </p>
<p class="calibre1">Here’s how it should look:</p>
<p class="calibre1">from __future__ import print_function, division</p>
<p class="calibre1">9.  Then, update the testing part of your code to the following: datasource = open_shapefile("../data/world_borders_simple.shp") transformed_geoms = transform_geometries(datasource, 4326, 3395) calculated_areas = calculate_areas(transformed_geoms, unity='sqmi') print(calculated_areas)</p>
<p class="calibre1">10.  Run it, change the unity, then run again, and note how the results change. </p>
<p class="calibre1">Very well, unity conversion is another very important procedure in geoprocessing, and you just implemented it in your calculate_areas function. </p>
<p class="calibre1">However, having a list of numbers as the output is not very useful to us. So, it’s time to combine everything that we did so far in order to extract valuable information. </p>
<p class="calibre1"><a id="p98"/>
<a id="p99"/><b class="calibre3">Sort the countries by area size</b></p>
<p class="calibre1">You programmed three functions so far; now, let’s add another one to our list by converting the code that generated a list of country names to a function and add this function to world_areas.py, as follows:</p>
<p class="calibre1">def get_country_names(datasource):</p>
<p class="calibre1">"""Returns a list of country names.""" </p>
<p class="calibre1">layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">country_names = []</p>
<p class="calibre1">layer.ResetReading()</p>
<p class="calibre1">for feature in layer:</p>
<p class="calibre1">country_names.append(feature.GetFieldAsString(4))</p>
<p class="calibre1">return country_names</p>
<p class="calibre1">Now, we have four functions, which are:</p>
<p class="calibre1">open_shapefile</p>
<p class="calibre1">transform_geometries</p>
<p class="calibre1">calculate_areas</p>
<p class="calibre1">get_country_names</p>
<p class="calibre1">All these functions return iterables, with each item sharing the same index on all of them, thus making it easy to combine the information. </p>
<p class="calibre1">So, let’s take advantage of this feature to sort the countries by area size and return a list of the five biggest countries and their areas. For this, add another function, as follows: def get_biggest_countries(countries, areas, elements=5):</p>
<p class="calibre1">"""Returns a list of n countries sorted by area size.""" </p>
<p class="calibre1">countries_list = [list(country) </p>
<p class="calibre1">for country in zip(areas, countries)]</p>
<p class="calibre1">sorted_countries = sorted(countries_list, </p>
<p class="calibre1">key=itemgetter(0), reverse=True) </p>
<p class="calibre1">return sorted_countries[:5]</p>
<p class="calibre1">In the first line, the two lists are zipped together, producing a list of country-area pairs. </p>
<p class="calibre1">Then, we used the Python list’s sorted method, but as we don’t want the lists to be sorted by both values, we will define the key for sorting. Finally, the list is sliced, returning only the desired number of values. </p>
<p class="calibre1">1.  In order to run this code, you need to import the itemgetter function and put it at the beginning of the code but after from __future__ imports, as follows: from operator import itemgetter</p>
<p class="calibre1">2.  Now, edit the testing part of your code to look similar to the following: datasource = open_shapefile("../data/world_borders_simple.shp") transformed_geoms = transform_geometries(datasource, 4326, 3395) country_names = get_country_names(datasource)</p>
<p class="calibre1">country_areas = calculate_areas(transformed_geoms)</p>
<p class="calibre1">biggest_countries = get_biggest_countries(country_names, </p>
<p class="calibre1"><a id="p100"/>                                          country_areas) for item in biggest_countries:</p>
<p class="calibre1">print("{}\t{}".format(item[0], item[1])) </p>
<p class="calibre1">3.  Now, run the code and take a look at the results, as follows: Opening ../data/world_borders_simple.shp</p>
<p class="calibre1">Number of features: 246</p>
<p class="calibre1">82820725.1423 Russia</p>
<p class="calibre1">51163710.3726 Canada</p>
<p class="calibre1">35224817.514 Greenland</p>
<p class="calibre1">21674429.8403 United States</p>
<p class="calibre1">14851905.8596 China</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p101"/>
<a id="p102"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we had a brief introduction to the libraries and packages that we will use in this book. By installing these libraries, you also learned the general procedure of how to search and install Python packages. You can use this procedure in other cases whenever you feel the need for other libraries in your applications. </p>
<p class="calibre1">Then, we wrote code that made use of the OGR library to open a shapefile and perform area calculation and sorting. These simple procedures showed a little bit of the internal organization of OGR, how it handles geographic data, and how it is possible to extract information from them. In the next chapter, we will use some of the techniques learned here to read data and process vector points. </p>
<p class="calibre1"><a id="p103"/>
<a id="p104"/><b class="calibre3">Chapter 2. The Geocaching App</b></p>
<p class="calibre1">In this chapter, we will build a geocaching app that will initially get geocache points from the Internet and return the coordinates and information on the point closest to a user’s location. </p>
<p class="calibre1">We will go through some of the most important steps in every geoprocessing application: we will discuss opening files, reading information, preparing data for analysis, and performing calculations with each object in your data. To achieve this, you will learn how to organize your code with Python and use the resources provided by the language to write consistent applications. </p>
<p class="calibre1">In this chapter, we will start to make use of classes, methods, functions, decorators, and exception handling, which will help us build an application with reusable components and clean code. Don’t worry if these terms are new to you; they will be explained in the examples. In short, here’s what we will cover:</p>
<p class="calibre1">Programming the basic application structures</p>
<p class="calibre1">Downloading geocaching data</p>
<p class="calibre1">Opening geocaching files and getting their contents</p>
<p class="calibre1">Combining functions into an application</p>
<p class="calibre1">Setting your current location</p>
<p class="calibre1">Handling exceptions</p>
<p class="calibre1">Finding the closest point</p>
<p class="calibre1"><a id="p105"/><b class="calibre3">Building the basic application structure</b> There are two main reasons to define a good basic structure for our application: It keeps our code organized</p>
<p class="calibre1">It allows us to reuse pieces of code in later applications</p>
<p class="calibre1">Python is a flexible language in terms of code organization, and although users are allowed to write the whole application in a single file, it’s preferable to separate the functionalities into modules and packages. </p>
<p class="calibre1">Modules are Python files that contain classes and functions that can be imported into another file with the import statement. Packages are special directories (folders) that contain modules. This leads to organized and well-structured code that is less prone to having bugs and is easier to maintain. </p>
<p class="calibre1">The proposed structure is to have a folder for each chapter. Inside it, we can create packages or files for each application; we will create a package for a common utility code that can be imported and reused and a directory to perform experiments. </p>
<p class="calibre1"><a id="p106"/><b class="calibre3">Creating the application tree structure</b> Here are the steps that you need to perform:</p>
<p class="calibre1">If you went through <a href="#p45">Chapter 1</a>,  <i class="calibre4">Preparing the Work Environment</i>, you should now have a PyCharm project named geopy with the Chapter1 and data directories located at C:\geopy in Windows or ~/geopy in Linux. Start PyCharm and open your project. </p>
<p class="calibre1">In the project root (the uppermost folder named geopy), right-click, select <b class="calibre3">New</b> |</p>
<p class="calibre1"><b class="calibre3">Directory</b>, and name it Chapter2. </p>
<p class="calibre1">Right-click on Chapter2, select <b class="calibre3">New</b> | <b class="calibre3">Directory</b>, and name it experiments. </p>
<p class="calibre1">Again, right-click inside the Chapter2 directory; this time, select <b class="calibre3">New</b> | <b class="calibre3">Python</b> <b class="calibre3">Package</b> and name it utils. </p>
<p class="calibre1">Now, you should have a tree structure similar to this:</p>
<p class="calibre1">\geopy</p>
<p class="calibre1">+---Chapter1</p>
<p class="calibre1">|       world_areas.py</p>
<p class="calibre1">|       world_borders.py</p>
<p class="calibre1">|</p>
<p class="calibre1">+---Chapter2</p>
<p class="calibre1">|   |</p>
<p class="calibre1">|   \---experiments</p>
<p class="calibre1">|   \---utils</p>
<p class="calibre1">|   </p>
<p class="calibre1">|</p>
<p class="calibre1">+---data</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1"><b class="calibre3">Python Packages</b></p>
<p class="calibre1">Packages are special folders that contain another packages and modules. They are directories with a special file called __init__.py. This file may be empty and is used to denote that the package can be imported with the import statement. </p>
<p class="calibre1">For example, if we have a directory called foo (with a __init__.py file) and we create a bar.py file inside it, we can later use import foo.bar or from foo import bar in our code. </p>
<p class="calibre1"><a id="p107"/><b class="calibre3">Functions and methods</b></p>
<p class="calibre1">Functions and methods (which are functions inside classes) should be concise so that when you call them, you can trust that you will get the desired results or appropriate exceptions. The programmer doesn’t want to check the function’s contents every time they use it; they want to call it and get the anticipated results, which is called taking  <i class="calibre4">the leap of</i> <i class="calibre4">faith</i>. For example, in this book, we use many external packages; when we use a given function of a package, we trust that this function will do what it’s supposed to do or raise an error telling us that something went wrong. Anything besides this is called  <i class="calibre4">unexpected</i> <i class="calibre4">behavior</i>, and this is the most dangerous type of bug that an application can have because it is passed silently but has consequences later in code. </p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">So far, we saw a module that may have this kind of unexpected behavior: GDAL/OGR. </p>
<p class="calibre1">The ogr.Open() function is passed silently even if the file doesn’t exist, unless we specifically tell OGR that we want it to raise exceptions for us. </p>
<p class="calibre1"><a id="p108"/><b class="calibre3">Documenting your code</b></p>
<p class="calibre1">As the application starts to gain scale, it’s very important to keep track of what each piece of code does. This prevents the programmer from repeating code and saves a lot of time later trying to find out what is going on. Also, it allows other people to use and improve your code. There are two crucial tools that can be used to document the code, and we had a glimpse of it in the first chapter:</p>
<p class="calibre1"><b class="calibre3">Code comments</b>: These are the comments inserted in code with the # symbol. </p>
<p class="calibre1">Everything from this symbol to the next line is a comment and will be ignored when the program runs. The Python syntax is intuitive, and a well-written code requires a few comments. Here are two tips to concisely comment your code: Place a comment before each logical block of code telling what it’s doing Comment pieces of code that are hard to read or understand</p>
<p class="calibre1"><b class="calibre3">Docstrings</b>: Docstrings are texts placed in special locations in document classes, functions, and methods. They have a special meaning because they can be interpreted by some programs and used to provide the user with help and automatically generate documentation. Docstrings can also be used to test your code, but this will not be covered in this book. In PyCharm, docstrings have a special purpose and provide hints for automatic code inspection. Within docstrings, you can specify parameters and return types (for example, strings, list, and dictionary). PyCharm uses this to make auto-complete suggestions and warn you about possible mistakes. </p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">In this book, we will use the reStructuredText type of markup for docstrings; you can find more information at<a href="http://docutils.sourceforge.net/rst.html"> http://docutils.sourceforge.net/rst.html</a>. </p>
<p class="calibre1">In the following example, you can note a class and method documented with docstrings (you don’t need to type this code):</p>
<p class="calibre1">class MyClass:</p>
<p class="calibre1">"""This is an example of a docstring of a class.""" </p>
<p class="calibre1">def __init__(self):</p>
<p class="calibre1">"""You can also put docstrings in the __init__ method.""" </p>
<p class="calibre1">pass</p>
<p class="calibre1">def sum_values(self, arg1, arg2):</p>
<p class="calibre1">"""This is the docstring for a method, you can describe the arguments and specify its types. </p>
<p class="calibre1">If you do so, PyCharm will use that information</p>
<p class="calibre1">for autocomplete and to check your code. </p>
<p class="calibre1">:param float arg1: The first argument. </p>
<p class="calibre1">:param float arg2: The second argument. </p>
<p class="calibre1">:returns float: The sum of the arguments. </p>
<p class="calibre1">""" </p>
<p class="calibre1">return arg1 + arg2</p>
<p class="calibre1"><a id="p109"/><b class="calibre3">Creating the application entry point</b></p>
<p class="calibre1">The entry point of an application is the first thing executed when you run the program. In Python, it’s the first line of code. We can write an application that runs top-down, mixing function and class declarations along with other statements, but this would make the code harder to develop and debug, especially when it starts to grow more complex. It would be a better idea if we explicitly show where the program starts, and from this point, different parts of the program will be called as needed. </p>
<p class="calibre1">Let’s do an experiment to understand some points on how the code is executed and modules are imported:</p>
<p class="calibre1">1.  Inside your Chapter2/experiments folder, create two new files named import_test.py and module_test.py. To do this, right-click inside the experiments folder and choose <b class="calibre3">New</b> | <b class="calibre3">Python file</b>. </p>
<p class="calibre1">2.  Double-click on module_test.py to open it for editing. </p>
<p class="calibre1">3.  Now, type the following code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">print "I'm module_test.py and my name is: " + __name__</p>
<p class="calibre1">def function1():</p>
<p class="calibre1">print "Hi, I'm inside function1." </p>
<p class="calibre1">print "Calling function1…" </p>
<p class="calibre1">function1()</p>
<p class="calibre1">Every module contains a __name__ attribute, and we will print its value in the first line of the code of this test. </p>
<p class="calibre1">Next, we will declare a function that, when called, prints "Hi, I'm inside function1." to the output. </p>
<p class="calibre1">Finally, we will print that the function will be called, and then we will call function1. </p>
<p class="calibre1">4.  Run the code, press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and choose module_test from the list. Take a look at the output:</p>
<p class="calibre1">I'm module_test.py and my name is: __main__</p>
<p class="calibre1">Calling function1…</p>
<p class="calibre1">Hi, I'm inside function1. </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Note here that the __name__ attribute is equal to __main__; this is a special condition in Python. The module (the file) that is run is always called __main__. </p>
<p class="calibre1"><a id="p110"/>5.  To understand more about this mechanism, create a new Python file inside the experiments folder, name it import_test.py, and open it for editing. Now, type the following code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">print "I'm import_test.py and my name is: " + __name__</p>
<p class="calibre1">print "Importing module_test" </p>
<p class="calibre1">import module_test</p>
<p class="calibre1">print "Calling function1 from within import_test" </p>
<p class="calibre1">module_test.function1()</p>
<p class="calibre1">6.  Now, run import_test.py (press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and select it from the list) and take a look the following output:</p>
<p class="calibre1">I'm import_test.py and my name is: __main__</p>
<p class="calibre1">Importing module_test</p>
<p class="calibre1">I'm module_test.py and my name is: module_test</p>
<p class="calibre1">Calling function1…</p>
<p class="calibre1">Hi, I'm inside function1. </p>
<p class="calibre1">Calling function1 from within import_test</p>
<p class="calibre1">Hi, I'm inside function1. </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">This time it is import_test that is called __main__ because it is the file that is executed. Next, when we import module_test, the code in it is executed. Note that module_test is not called __main__ anymore; it’s called module_test. </p>
<p class="calibre1">The behavior of this special __name__ attribute allows us to implement a technique in Python, which in turn allows us to execute some code when a file is run directly and avoid this code’s execution when this same file is imported. Let’s see how this works: 7.  Edit module_test.py and change its code, as follows:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">print "I'm module_test.py and my name is: " + __name__</p>
<p class="calibre1">def function1():</p>
<p class="calibre1">print "Hi, I'm inside function1." </p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">print "Calling function1 - only if i'm __main__…" </p>
<p class="calibre1">function1()</p>
<p class="calibre1">So, if __name__ is equal to '__main__', the code inside this block is executed, and</p>
<p class="calibre1"><a id="p111"/>we know that __name__ is __main__ only when the file is executed directly. </p>
<p class="calibre1">Therefore, the code inside this block is executed only when the file is run and not when it’s imported. </p>
<p class="calibre1">8.  Next, run import_test.py again (to rerun the last file, press  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>), and take a look at what happens:</p>
<p class="calibre1">I'm import_test.py and my name is: __main__</p>
<p class="calibre1">Importing module_test</p>
<p class="calibre1">I'm module_test.py and my name is: module_test</p>
<p class="calibre1">Calling function1 from within import_test</p>
<p class="calibre1">Hi, I'm inside function1. </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">9.  Now, run module_test.py (to choose the file to run, press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>) and look at the output:</p>
<p class="calibre1">I'm module_test.py and my name is: __main__</p>
<p class="calibre1">Calling function1 - only if i'm __main__…</p>
<p class="calibre1">Hi, I'm inside function1. </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">As expected, the code inside the if __name__ == '__main__': block ran only when module_test.py was run directly and not when it was imported. </p>
<p class="calibre1">Now that we know how to make an entry point explicit in Python, let’s create our first file for the application and make an entry point. </p>
<p class="calibre1">10.  Create a new file inside your Chapter2 folder and name it geocaching_app.py. </p>
<p class="calibre1">11.  Then, open the file to edit and insert the following piece of code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">def main():</p>
<p class="calibre1">print("Hello geocaching APP!")</p>
<p class="calibre1"/>
<p class="calibre1">if __name__ == "__main__":</p>
<p class="calibre1">main()</p>
<p class="calibre1">The purpose of the main() function is to receive the initial parameters and then take actions so that the program executes and produces the desired results. The content of the main function should be minimal and should try to express a clear sequence of actions. This makes the application’s logic very easy to debug. </p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">For Windows users, the if __name__ == '__main__' technique is also required in order for parallel processing to work; we will discuss this in<a href="index_split_003.html#p424"> Chapter 10, </a>  <i class="calibre4">Parallel Processing</i>. </p>
<p class="calibre1"><a id="p112"/>
<a id="p113"/><b class="calibre3">Downloading geocaching data</b></p>
<p class="calibre1">We now have the basic application structure with an entry point; next, we will start writing modules that execute the tasks that the application needs to produce the desired results. </p>
<p class="calibre1">The first thing that we need is to obtain some geocaching data from the Internet, and we want our application to do this for us. There are two common ways of doing this, and they are not restricted only to geocaching data. Many geographical data repositories can be accessed by these methods:</p>
<p class="calibre1"><b class="calibre3">Direct download</b>: This is a download similar to what you do in a browser. There is a link, a request is made to this link, and the download starts. </p>
<p class="calibre1"><b class="calibre3">REST API</b>: Many services offer this kind of data access. <b class="calibre3">REST</b> (<b class="calibre3">Representational</b> <b class="calibre3">State Transfer</b>) is a way of serving data where a client makes requests with a series of constraints, and the server responds with the result. It’s particularly useful because it allows the user to customize the data of interest. </p>
<p class="calibre1"><a id="p114"/><b class="calibre3">Geocaching data sources</b></p>
<p class="calibre1">There are many sources of geocaching data on the Internet; some are commercial, and some are community driven. In the following table, you can note the summary of some of the sources available:</p>
<p class="calibre1"><b class="calibre3">Site</b></p>
<p class="calibre1"><b class="calibre3">REST</b></p>
<p class="calibre1"><b class="calibre3">Region</b></p>
<p class="calibre1"><a href="http://www.opencaching.us/">http://www.opencaching.us/</a></p>
<p class="calibre1">Y (OKAPI) Open</p>
<p class="calibre1">USA</p>
<p class="calibre1"><a href="http://opencaching.pl/">http://opencaching.pl/</a></p>
<p class="calibre1">Y (OKAPI) Open</p>
<p class="calibre1">Poland</p>
<p class="calibre1"><a href="http://www.opencaching.de/">http://www.opencaching.de/</a></p>
<p class="calibre1">Y (OKAPI) Open</p>
<p class="calibre1">Denmark</p>
<p class="calibre1"><a href="http://www.opencaching.nl/">http://www.opencaching.nl/</a></p>
<p class="calibre1">Y (OKAPI) Open</p>
<p class="calibre1">Netherlands</p>
<p class="calibre1"><a href="http://www.opencaching.ro/">http://www.opencaching.ro/</a></p>
<p class="calibre1">Y (OKAPI) Open</p>
<p class="calibre1">Romania</p>
<p class="calibre1"><a href="http://www.opencaching.it/">http://www.opencaching.it/</a></p>
<p class="calibre1">N</p>
<p class="calibre1">Open</p>
<p class="calibre1">Italy</p>
<p class="calibre1"><a href="http://www.opencachingspain.es/">http://www.opencachingspain.es/ </a>N</p>
<p class="calibre1">Open</p>
<p class="calibre1">Spain</p>
<p class="calibre1"><a href="http://www.opencaching.org.uk/">http://www.opencaching.org.uk/</a></p>
<p class="calibre1">N</p>
<p class="calibre1">Open</p>
<p class="calibre1">United Kingdom</p>
<p class="calibre1"><a href="http://www.opencaching.cz/">http://www.opencaching.cz/</a></p>
<p class="calibre1">N</p>
<p class="calibre1">Open</p>
<p class="calibre1">Czech Republic</p>
<p class="calibre1"><a href="https://www.geocaching.com/play">https://www.geocaching.com/play </a>Y</p>
<p class="calibre1">Commercial Global</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">OKAPI is a public API project for National Opencaching sites (also known as <b class="calibre3">Opencaching Nodes</b>). </p>
<p class="calibre1">It provides OC sites with a set of useful, well-documented API methods, allows external developers to easily read public Opencaching data, allows us to read and write private (that is, user-related) data with OAuth 3-legged authentication. The project aims to become a standard API for all National Opencaching.xx sites. </p>
<p class="calibre1"><a href="http://opencaching.pl/okapi/introduction.html">(http://opencaching.pl/okapi/introduction.html</a>)</p>
<p class="calibre1"><a id="p115"/><b class="calibre3">Fetching information from a REST API</b></p>
<p class="calibre1">We will make a simple test to fetch data from a geocaching REST API. We won’t go deep into communicating with REST APIs this time because all geocaching sites require a user key so that users can access the data; this is in order to avoid abuses and misuse. For now, we will have a glimpse at how this works and request a method that doesn’t require a key. </p>
<p class="calibre1">If you are interested in accessing the download functions, you can contact the site and request a key. Here’s how you can do this:</p>
<p class="calibre1">1.  Create a new file inside your Chapter2/utils directory and name it data_transfer.py. </p>
<p class="calibre1">2.  Type this code in the file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from pprint import pprint</p>
<p class="calibre1">import requests</p>
<p class="calibre1">def request_api_methods():</p>
<p class="calibre1">result = requests.get(</p>
<p class="calibre1">"http://www.opencaching.us/okapi/services/apiref/method_index") pprint(result.json())</p>
<p class="calibre1">if __name__ == "__main__":</p>
<p class="calibre1">request_api_methods()</p>
<p class="calibre1">3.  Run this file, press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>, and select rest_api on the list. Now, take a look at the results:</p>
<p class="calibre1">[{u'brief_description': u'Retrieve information on given issue', u'name': u'services/apiref/issue'}, </p>
<p class="calibre1">{u'brief_description': u'Get information on a given OKAPI service method', </p>
<p class="calibre1">u'name': u'services/apiref/method'}, </p>
<p class="calibre1">{u'brief_description': u'Get a list of OKAPI methods with brief descriptions', </p>
<p class="calibre1">u'name': u'services/apiref/method_index'}, </p>
<p class="calibre1">{u'brief_description': u'Get information on this OKAPI installation', u'name': u'services/apisrv/installation'}, </p>
<p class="calibre1">... </p>
<p class="calibre1">{u'brief_description': u'Retrieve information on a single user', u'name': u'services/users/user'}, </p>
<p class="calibre1">{u'brief_description': u'Retrieve information on multiple users', u'name': u'services/users/users'}]</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">The URL that you see is meant to retrieve a list containing the description of all methods exposed by the API. The module requests makes everything much easier for us, and the</p>
<p class="calibre1"><a id="p116"/>result.json() method converts the result of our request to a Python object (a list of dictionaries) and pprint (that is, pretty print) prints the list one item per line. Note that we made use of if __name__ == 'main': here so that we can test our function; later, when this function is imported by other modules, all the code following if name ==</p>
<p class="calibre1">'main': won’t run, so we can safely put all our tests there. </p>
<p class="calibre1"><a id="p117"/><b class="calibre3">Downloading data from a URL</b></p>
<p class="calibre1">To avoid the API key restriction in the geocaching sites and give continuity to our examples, we prepared some sample data that can be downloaded directly from a link. The function that you write downloads a file from a given URL and saves it to the disk. This function will be generalized and may be used by other applications in the future. We want to pass the following as parameters (that is, arguments):</p>
<p class="calibre1">The URL or link to the file</p>
<p class="calibre1">A path to the destination folder</p>
<p class="calibre1">An override to the name of the file. </p>
<p class="calibre1">Perform the following steps:</p>
<p class="calibre1">1.  In the data_transfer.py file, add the download_data function and edit the if __name__ == '__main__' block. Your code should look similar to this:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from pprint import pprint</p>
<p class="calibre1">import requests</p>
<p class="calibre1">from os import path</p>
<p class="calibre1">def request_api_methods():</p>
<p class="calibre1">result = requests.get(</p>
<p class="calibre1">"http://www.opencaching.us/okapi/services/apiref/method_index") pprint(result.json())</p>
<p class="calibre1">def download_data(base_url, data_path, data_filename):</p>
<p class="calibre1">save_file_path = path.join(data_path, data_filename)</p>
<p class="calibre1">request = requests.get(base_url, stream=True)</p>
<p class="calibre1"># Save the download to the disk. </p>
<p class="calibre1">with open(save_file_path, 'wb') as save_file:</p>
<p class="calibre1">for chunk in request.iter_content(1024):</p>
<p class="calibre1">save_file.write(chunk)</p>
<p class="calibre1">if __name__ == "__main__":</p>
<p class="calibre1">download_data('https://s3.amazonaws.com/geopy/geocaching.gpx', </p>
<p class="calibre1">'../../data', </p>
<p class="calibre1">'geocaching_test.gpx')</p>
<p class="calibre1">2.  Now, run the code and check your data directory; there should be a new file there named geocaching_test.gpx. </p>
<p class="calibre1">What happens in the function is that first, we prepare the save_file_path variable using the os.path function; this function takes care of concatenating paths and ensuring that the result is correct for every operating system. Whenever we handle paths in our application, </p>
<p class="calibre1"><a id="p118"/>we prefer using os.path. </p>
<p class="calibre1">Using the requests library, we can make a request to the desired URL. The optional stream=True parameter tells it that we want the download to happen in chunks, as we request, as opposed to downloading the whole file to the memory once. This is important because some files may be large in size and occupy a lot of memory. </p>
<p class="calibre1">Finally, a file is opened and the chunks of data are read and written to the disk. The with statement is also called a <b class="calibre3">context manager</b> because it makes a given resource (a file, in this case) available only inside the block. Then, chunks of 1024 bytes each are read and written in the file. When the program exits the with block, the file is automatically closed and the save_file variable is deleted. </p>
<p class="calibre1">We don’t want the application to download the file every time we run it; this would be a waste of time. So, in the next part, we need to implement a verification to make the program skip the download if there is already a file with the chosen name. </p>
<p class="calibre1">Edit the download_data function, as follows:</p>
<p class="calibre1">def download_data(base_url, data_path, data_filename):</p>
<p class="calibre1">save_file_path = path.join(data_path, data_filename)</p>
<p class="calibre1">request = requests.get(base_url, stream=True)</p>
<p class="calibre1"/>
<p class="calibre1"># Check if the file exists. </p>
<p class="calibre1">if path.isfile(save_file_path):</p>
<p class="calibre1">print('File already available.')</p>
<p class="calibre1"># Save the download to the disk. </p>
<p class="calibre1">with open(save_file_path, 'wb') as save_file:</p>
<p class="calibre1">for chunk in request.iter_content(1024):</p>
<p class="calibre1">save_file.write(chunk)</p>
<p class="calibre1">Now, run your application again, and you should see the following output warning you that the file was already downloaded:</p>
<p class="calibre1">File already available. </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p119"/><img src="img/index-119_1.jpg" alt="Image 7" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Downloading data manually</b></p>
<p class="calibre1">Now, you may want to choose the data specifically for your region; to do this, you need to go to a geocaching site, filter the data, and download the file manually. </p>
<p class="calibre1">As an example, we will go through the process to download data from the site</p>
<p class="calibre1"><a href="http://www.opencaching.us/">http://www.opencaching.us/. </a> You don’t need an account; just follow these steps: 1.  Open the website. In the left-hand side menu, click on <b class="calibre3">Seek A Cache</b>: 2.  This will open a page containing various fields. First, select the limiting factors for your search using the fields shown in the following image:</p>
<p class="calibre1"><a id="p120"/><img src="img/index-120_1.jpg" alt="Image 8" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-120_2.jpg" alt="Image 9" class="calibre2"/></p>
<p class="calibre1">3.  Next, you need to specify a region or criteria to search for the geocaches. There are many alternatives to choose from, so scroll through the page and take a look. You can use a zip code, coordinates, a state, and others. Let’s search by state; select <b class="calibre3">New York</b> and click on <b class="calibre3">Search</b>. </p>
<p class="calibre1"><a id="p121"/><img src="img/index-121_1.jpg" alt="Image 10" class="calibre2"/></p>
<p class="calibre1">4.  A list with the results will appear. Scroll to the end of the page, and you will note the links to download data. Choose to download <b class="calibre3">Caches From All Pages</b> in the <b class="calibre3">GPX</b></p>
<p class="calibre1">format:</p>
<p class="calibre1"><a id="p122"/>
<a id="p123"/><b class="calibre3">Opening the file and getting its contents</b></p>
<p class="calibre1">Now, we will open the downloaded file and prepare it for processing. This is something that we already did in<a href="#p45"> Chapter 1, </a>  <i class="calibre4">Preparing the Work Environment</i>, so we will copy our function and improve it so that we can reuse it in this application and the ones to come. </p>
<p class="calibre1">Here are the steps that we will perform:</p>
<p class="calibre1">1.  Create a new file named geo_functions.py inside the utils directory. </p>
<p class="calibre1">2.  Open the world_areas.py file from<a href="#p45"> Chapter 1, </a>  <i class="calibre4">Preparing the Work Environment</i>, and copy the open_shapefile function. Then, paste it into the created file. </p>
<p class="calibre1">3.  Now, change the name of the function to open_vector_file so that it makes more sense as we will use this function to open many kinds of file. The geocaching file isn’t a shapefile—it’s a GPX, and to open it, we don’t need to change anything. OGR</p>
<p class="calibre1">will handle this for us. </p>
<p class="calibre1">4.  Now, to keep the code well documented, change the docstring to reflect the function’s capabilities. Change it to something similar to "Opens a vector file compatible with OGR, gets the first layer, and returns the OGR data source". </p>
<p class="calibre1">5.  Finally, don’t forget to import the required packages. Your code should look similar to this:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import ogr</p>
<p class="calibre1">import osr</p>
<p class="calibre1">def open_vector_file(file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR, get the first layer and returns the ogr datasource. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">:return: The ogr datasource. </p>
<p class="calibre1">""" </p>
<p class="calibre1">datasource = ogr.Open(file_path)</p>
<p class="calibre1">layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">print("Opening {}".format(file_path))</p>
<p class="calibre1">print("Number of features: {}".format(</p>
<p class="calibre1">layer.GetFeatureCount()))</p>
<p class="calibre1">return datasource</p>
<p class="calibre1">if __name__ == "__main__":</p>
<p class="calibre1">open_vector_file("../../data/geocaching.gpx")</p>
<p class="calibre1">6.  Run the code again, and you should see the following output (don’t worry about the warnings):</p>
<p class="calibre1">Opening ../data/geocaching.gpx</p>
<p class="calibre1">Warning 1: Could not parse {2010-10-01T00:00:00Z} as a valid dateTime Warning 1: Could not parse {2011-04-10T00:00:00Z} as a valid dateTime</p>
<p class="calibre1"><a id="p124"/>Warning 1: Could not parse {2010-11-21T00:00:00Z} as a valid dateTime Number of features: 130</p>
<p class="calibre1">Warning 1: Could not parse {2010-11-22T00:00:00Z} as a valid dateTime</p>
<p class="calibre1"><a id="p125"/><b class="calibre3">Preparing the content for analysis</b></p>
<p class="calibre1">This application makes use of distances such as meters or miles, so we do not want our measurements to be in degrees. Most geocaching coordinates and point data come in degrees, so we need to convert the coordinate system into the metric system. </p>
<p class="calibre1">To do this, we will start by using a function from <a href="#p45">Chapter 1</a>,  <i class="calibre4">Preparing the Work</i> <i class="calibre4">Environment</i>: transform_geometries. Perform the following: 1.  Copy this function and paste it into the geo_functions.py file. This function will iterate over the features in the data to get its geometry and then convert the coordinate system, returning a list with all of the converted geometries. The function should look similar to this:</p>
<p class="calibre1">def transform_geometries(datasource, src_epsg, dst_epsg):</p>
<p class="calibre1">"""Transform the coordinates of all geometries in the first layer. </p>
<p class="calibre1">""" </p>
<p class="calibre1"/>
<p class="calibre1"># Part 1</p>
<p class="calibre1">src_srs = osr.SpatialReference()</p>
<p class="calibre1">src_srs.ImportFromEPSG(src_epsg)</p>
<p class="calibre1">dst_srs = osr.SpatialReference()</p>
<p class="calibre1">dst_srs.ImportFromEPSG(dst_epsg)</p>
<p class="calibre1">transformation = osr.CoordinateTransformation(src_srs, dst_srs) layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1"># Part 2</p>
<p class="calibre1">geoms = []</p>
<p class="calibre1">layer.ResetReading()</p>
<p class="calibre1">for feature in layer:</p>
<p class="calibre1">geom = feature.GetGeometryRef().Clone()</p>
<p class="calibre1">geom.Transform(transformation)</p>
<p class="calibre1">geoms.append(geom)</p>
<p class="calibre1">return geoms</p>
<p class="calibre1"><a id="p126"/>
<a id="p127"/><b class="calibre3">Combining functions into an application</b></p>
<p class="calibre1">So far, we looked at very useful utility functions that perform specific tasks; however, to form an application, we need to combine these functions by calling them in an ordered manner to achieve our objectives. We need code that orchestrates the calls and results—</p>
<p class="calibre1">one that will make the application run. </p>
<p class="calibre1">For this, we will dive into one of the most beautiful and powerful parts of Python programming: classes and methods. </p>
<p class="calibre1">Python is an object-oriented programming language (but it is not strict). If you are not familiar with the concept of object-oriented programming, don’t worry; the best way to understand what this is about is by examples, so I won’t go into theories now but teach by example instead. Perform the following steps now:</p>
<p class="calibre1">1.  Remember the application’s entry point? It’s in the Chapter2 folder, in the geochaching_app.py file. Open it for editing, and you should have this:</p>
<p class="calibre1"># coding=utf-8    </p>
<p class="calibre1">def main():print "Hello geocaching APP!" </p>
<p class="calibre1"/>
<p class="calibre1">if __name__ == "__main__":    </p>
<p class="calibre1">main()</p>
<p class="calibre1">2.  Now, let’s import the modules that we have written so far so that we can use them in our application. Also, let’s import the other modules that we will need. Insert the import statements after the encoding declaration (# coding=utf-8). Your code should now be similar to this:</p>
<p class="calibre1"># coding=utf-8    </p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">from utils.geo_functions import transform_geometries</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1">import math</p>
<p class="calibre1">def main():</p>
<p class="calibre1">print "Hello geocaching APP!" </p>
<p class="calibre1"/>
<p class="calibre1">if __name__ == "__main__":    </p>
<p class="calibre1">main()</p>
<p class="calibre1">3.  Now, remove the main() function, and right after the imports, add the class that will represent our application:</p>
<p class="calibre1">class GeocachingApp(object):</p>
<p class="calibre1"><a id="p128"/>    def __init__(self, data_file=None):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param data_file: An OGR compatible file</p>
<p class="calibre1">with geocaching points. </p>
<p class="calibre1">""" </p>
<p class="calibre1"># Part 1. </p>
<p class="calibre1">self._datasource = None</p>
<p class="calibre1">self._transformed_geoms = None        </p>
<p class="calibre1"># Part 2. </p>
<p class="calibre1">if data_file:</p>
<p class="calibre1">self.open_file(data_file)</p>
<p class="calibre1">def open_file(self, file_path):</p>
<p class="calibre1">"""Open a file containing geocaching data and prepare it for use. </p>
<p class="calibre1">:param file_path: </p>
<p class="calibre1">""" </p>
<p class="calibre1">self._datasource = open_vector_file(file_path)</p>
<p class="calibre1">self._transformed_geoms = transform_geometries(</p>
<p class="calibre1">self._datasource, 4326, 3395)</p>
<p class="calibre1">Here, we created a class representing our application. Inside the class, there is a special method called __init__. This method is called when the class is instantiated, which means when a new instance of the class is created. Here, we can see a parameter named self; this parameter is passed by the class to all instance methods, and self is the class instance itself. Again, don’t worry if these terms are strange to you, we will discuss more on them soon. </p>
<p class="calibre1">In the first part, we defined two properties that any instance of this class may have; note that the underscore before the name denotes that a given property is for internal use only and should not be called from outside the class. This notation is only a convention, and it doesn’t really prevent the property from being used from outside the method. In second part, if the user passes the optional file, the application calls the open_file method, which in turn opens the file and prepares the data using the functions that we already developed. </p>
<p class="calibre1">The way it’s coded allows us to change the file that we work on at any time. </p>
<p class="calibre1">Note that as we reached this point, we have achieved a higher level of abstraction. First, you had the OGR library with basic functions, where many lines of code were needed to be written to perform a given task. Then, you have the utils package, which wraps ogr functions into utility functions that perform simple tasks with a single line of code. Now, you have the application class that combines utility functions into methods that automate the processes by calling each one of them in the right order and with the right parameters. </p>
<p class="calibre1">At this point, you need to perform the following steps:</p>
<p class="calibre1">1.  Edit your if __name__ == '__main__': block with the following code: if __name__ == "__main__":</p>
<p class="calibre1">my_app = GeocachingApp()</p>
<p class="calibre1"><a id="p129"/>    my_app.open_file('../data/geocaching.gpx') 2.  Run the application, and take a look at the results. </p>
<p class="calibre1"><a id="p130"/>
<a id="p131"/><b class="calibre3">Setting your current location</b></p>
<p class="calibre1">So far, the application can open a file. The next step is to define your location so that we can find the closest geocache. To do this, we will change the GeocachingApp class so that it can keep track of the current location through a property. We will also create methods to change the location (similar to the geometries), transform its coordinates, and prepare it for processing. </p>
<p class="calibre1">Here are the steps that need to be performed:</p>
<p class="calibre1">1.  Edit the GeocachingApp class init method using the following code:</p>
<p class="calibre1">#.. </p>
<p class="calibre1">def __init__(self, data_file=None, my_location=None):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param data_file: An OGR compatible file</p>
<p class="calibre1">with geocaching points. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self._datasource = None</p>
<p class="calibre1">self._transformed_geoms = None</p>
<p class="calibre1">self._my_location = None</p>
<p class="calibre1">self.distances = None</p>
<p class="calibre1">if data_file:</p>
<p class="calibre1">self.open_file(data_file)</p>
<p class="calibre1">if my_location:</p>
<p class="calibre1">self.my_location = my_location</p>
<p class="calibre1">2.  Now, add these two methods to the class:</p>
<p class="calibre1">@property</p>
<p class="calibre1">def my_location(self):</p>
<p class="calibre1">return self._my_location</p>
<p class="calibre1">@my_location.setter</p>
<p class="calibre1">def my_location(self, coordinates):</p>
<p class="calibre1">self._my_location = transform_points([coordinates])[0]</p>
<p class="calibre1">The logic here is that the class instance should have a my_location property, and we want the program to automatically convert its coordinate system, as it does with geocaching data. </p>
<p class="calibre1">There are many ways to achieve this kind of behavior. If you have experience with other programming languages, you may have come across the concept of getters and setters. </p>
<p class="calibre1">Getters and setters are methods designed to retrieve and set a given property of a class. </p>
<p class="calibre1">The use of methods instead of direct access to the properties allows the programmer, among other things, to modify values or perform complex procedures when retrieving or changing a property. </p>
<p class="calibre1">We can have a getter and setter method for this property—get_my_location() and</p>
<p class="calibre1"><a id="p132"/>set_my_location(), for example—but Python provides an elegant way of intervening in the processes of setting and getting a given property with the @property decorator. </p>
<p class="calibre1">As can be noted in the preceding code, the actual value of my_location is stored in the _my_location property and defined in the __init__ method (the underscore before the name denotes that the property shouldn’t be accessed outside the class). </p>
<p class="calibre1">Then, there are two methods with the same name, which is the name of the property that we want to expose. These functions are decorated so that the first one becomes a getter and the second one a setter. In the setter, we will call the functions that transform the coordinates of the point before storing it (we will get to this function in the next steps). </p>
<p class="calibre1">As we did with the data, the location can be passed as an initial parameter to the class and changed at any time. Here’s how we can do this:</p>
<p class="calibre1">1.  Now, your complete class should be similar to this:</p>
<p class="calibre1">class GeocachingApp(object):</p>
<p class="calibre1">def __init__(self, data_file=None, my_location=None):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param data_file: An OGR compatible file</p>
<p class="calibre1">with geocaching points. </p>
<p class="calibre1">:param my_location: Coordinates of your location. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self._datasource = None</p>
<p class="calibre1">self._transformed_geoms = None</p>
<p class="calibre1">self._my_location = None</p>
<p class="calibre1">self.distances = None</p>
<p class="calibre1">if data_file:</p>
<p class="calibre1">self.open_file(data_file)</p>
<p class="calibre1">if my_location:</p>
<p class="calibre1">self.my_location = my_location</p>
<p class="calibre1">def open_file(self, file_path):</p>
<p class="calibre1">"""Open a file containing geocaching data </p>
<p class="calibre1">and prepare it for use. </p>
<p class="calibre1">:param file_path:</p>
<p class="calibre1">""" </p>
<p class="calibre1">self._datasource = open_vector_file(file_path)</p>
<p class="calibre1">self._transformed_geoms = transform_geometries(</p>
<p class="calibre1">self._datasource, 4326, 3395)</p>
<p class="calibre1">@property</p>
<p class="calibre1">def my_location(self):</p>
<p class="calibre1">return self._my_location</p>
<p class="calibre1">@my_location.setter</p>
<p class="calibre1">def my_location(self, coordinates):</p>
<p class="calibre1">self._my_location = transform_points([coordinates])[0]</p>
<p class="calibre1">2.  As we don’t have a transform_points function, you should notice that PyCharm</p>
<p class="calibre1"><a id="p133"/>underlines transform_points in red. So, let’s create one in the geo_functions.py file. Also, we will avoid boilerplate code by creating another function that creates the OSR transformation:</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1"><b class="calibre3">Boilerplate code</b></p>
<p class="calibre1">Boilerplate code, or boilerplate, are pieces of code that repeated in many places with little or no alteration. </p>
<p class="calibre1">def create_transform(src_epsg, dst_epsg):</p>
<p class="calibre1">"""Creates an OSR tranformation. </p>
<p class="calibre1">:param src_epsg: EPSG code for the source geometry. </p>
<p class="calibre1">:param dst_epsg: EPSG code for the destination geometry. </p>
<p class="calibre1">:return: osr.CoordinateTransformation</p>
<p class="calibre1">""" </p>
<p class="calibre1">src_srs = osr.SpatialReference()</p>
<p class="calibre1">src_srs.ImportFromEPSG(src_epsg)</p>
<p class="calibre1">dst_srs = osr.SpatialReference()</p>
<p class="calibre1">dst_srs.ImportFromEPSG(dst_epsg)</p>
<p class="calibre1">return osr.CoordinateTransformation(src_srs, dst_srs)</p>
<p class="calibre1">def transform_points(points, src_epsg=4326, dst_epsg=3395):</p>
<p class="calibre1">"""Transform the coordinate reference system of a list of coordinates (a list of points)</p>
<p class="calibre1">:param src_epsg: EPSG code for the source geometry. </p>
<p class="calibre1">:param dst_epsg: EPSG code for the destination geometry. </p>
<p class="calibre1">""" </p>
<p class="calibre1">transform = create_transform(src_epsg, dst_srs)</p>
<p class="calibre1">points = transform.TransformPoints(points)</p>
<p class="calibre1">return points</p>
<p class="calibre1">The transform_points function uses an OSR function with the same name that performs the transformation over an array. This function is incredibly efficient and can transform pairs of coordinates in an order of a magnitude of millions per second in an ordinary home computer. The reason that we will wrap it in our function is that we want to avoid repeating code and add default parameters. </p>
<p class="calibre1">Note that in the my_location setter, we put the coordinates inside a list and then got the first element of the returning value (self.mylocation =</p>
<p class="calibre1">transform_points([coordinates])[0]). </p>
<p class="calibre1"><a id="p134"/>
<a id="p135"/><img src="img/index-135_1.jpg" alt="Image 11" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-135_2.jpg" alt="Image 12" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Finding the closest point</b></p>
<p class="calibre1">To find the closest point, we need to first calculate the distance between the current location (my location) and all points. Then, we need to find the point that has the smallest distance from my location. </p>
<p class="calibre1">So, for each of the points, we must apply an equation that returns the distance to my location and stores these results in the same order as the points in the following table: <b class="calibre3">Point index x</b></p>
<p class="calibre1"><b class="calibre3">y</b></p>
<p class="calibre1"><b class="calibre3">Distance to my location</b></p>
<p class="calibre1">0</p>
<p class="calibre1">35 44 ? </p>
<p class="calibre1">1</p>
<p class="calibre1">20 92 ? </p>
<p class="calibre1">2</p>
<p class="calibre1">11 77 ? </p>
<p class="calibre1">The distance between two points is given by the following equation: Translating this equation to Python, we have the following code: distance = math.sqrt((xb-xa)**2 + (yb-ya)**2)</p>
<p class="calibre1">The following table illustrates the basic Python math operators <b class="calibre3">Syntax</b></p>
<p class="calibre1"><b class="calibre3">Mathematical Expression Operation Name</b></p>
<p class="calibre1">a + b</p>
<p class="calibre1"> <i class="calibre4">a</i> +  <i class="calibre4">b</i></p>
<p class="calibre1">Addition</p>
<p class="calibre1"><a id="p136"/><img src="img/index-136_1.jpg" alt="Image 13" class="calibre2"/></p>
<p class="calibre1">a - b</p>
<p class="calibre1"> <i class="calibre4">a</i> -  <i class="calibre4">b</i></p>
<p class="calibre1">Subtraction</p>
<p class="calibre1">a * b</p>
<p class="calibre1"> <i class="calibre4">a</i> x  <i class="calibre4">b</i></p>
<p class="calibre1">Multiplication</p>
<p class="calibre1">a / b</p>
<p class="calibre1"> <i class="calibre4">a</i> ÷  <i class="calibre4">b</i></p>
<p class="calibre1">Division</p>
<p class="calibre1">a ** b</p>
<p class="calibre1"> <i class="calibre4">a</i> b</p>
<p class="calibre1">Exponent</p>
<p class="calibre1">math.sqrt(a)</p>
<p class="calibre1">Square root</p>
<p class="calibre1">Now, insert the preceding method inside the GeocachingApp class by executing the following code:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def calculate_distances(self):</p>
<p class="calibre1">"""Calculates the distance between a</p>
<p class="calibre1">set of points and a given location. </p>
<p class="calibre1">:return: A list of distances in the same order as</p>
<p class="calibre1">the points. </p>
<p class="calibre1">""" </p>
<p class="calibre1">xa = self.my_location[0]</p>
<p class="calibre1">ya = self.my_location[1]</p>
<p class="calibre1">points = self._transformed_geoms</p>
<p class="calibre1">distances = []</p>
<p class="calibre1">for geom in points:</p>
<p class="calibre1">point_distance = math.sqrt(</p>
<p class="calibre1">(geom.GetX() - xa)**2 + (geom.GetY() - ya))</p>
<p class="calibre1">distances.append(point_distance)</p>
<p class="calibre1">return distances</p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1"><b class="calibre3">Gradual optimization of code</b></p>
<p class="calibre1">Some equations or operations may be very complex, and they sometimes become hard to write, or you may need to see the results for the intermediary steps to debug. The tip for these situations is to not worry about writing optimized and fast code right away. </p>
<p class="calibre1">Start by writing readable and clear code, separating each intermediary step into variables. </p>
<p class="calibre1">For example, consider the following equation for distance:</p>
<p class="calibre1">distance = math.sqr((xb-xa)**2 + (yb-ya)**2)</p>
<p class="calibre1">This can be broken into intermediary steps:</p>
<p class="calibre1">vertical_distance = yb - ya</p>
<p class="calibre1">horizontal_distance = xb – xa</p>
<p class="calibre1">distance = math.sqrt(horizontal_distance**2 + vertical_distance**2) Now, debug and check the results; when you are sure that the logic is correct and the result is what you expect, you can gradually optimize the code by replacing parts and trying alternative paths to improve the performance by checking whether the results match. </p>
<p class="calibre1">The final part is to find the closest point in the list of distances, which means to find the</p>
<p class="calibre1"><a id="p137"/>index of the item that has the minimum value. Add this method to the class:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def find_closest_point(self):</p>
<p class="calibre1">"""Find the closest point to a given location and return the cache that's on that point. </p>
<p class="calibre1">:return: OGR feature containing the point. </p>
<p class="calibre1">""" </p>
<p class="calibre1"># Part 1. </p>
<p class="calibre1">distances = self.calculate_distances()</p>
<p class="calibre1">index = np.argmin(distances)</p>
<p class="calibre1"># Part 2. </p>
<p class="calibre1">layer = self._datasource.GetLayerByIndex(0)</p>
<p class="calibre1">feature = layer.GetFeature(index)</p>
<p class="calibre1">print "Closest point at: {}m".format(distances[index]) return feature</p>
<p class="calibre1">There is a possibility that the data contains repeated values, which will result in the same distance, or a remote possibility that two points have the same distance. </p>
<p class="calibre1">So, in the first part, the np.argmin function returns the index or indexes with a minimum value among all points. In the second part, the program gets the feature at this index. </p>
<p class="calibre1">Perform the following steps:</p>
<p class="calibre1">1.  Now, let’s test our application and edit the if __name__ == '__main__' block, as follows:</p>
<p class="calibre1">if __name__ == "__main__":</p>
<p class="calibre1">my_app = GeocachingApp('../data/geocaching.gpx', [-73.0, 43.0]) my_app.find_closest_point()</p>
<p class="calibre1">2.  Now, your geocaching_app.py should look similar to this:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">from utils.geo_functions import transform_geometries</p>
<p class="calibre1">from utils.geo_functions import transform_points</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1">import math</p>
<p class="calibre1">class GeocachingApp(object):</p>
<p class="calibre1">def __init__(self, data_file=None, my_location=None):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param data_file: An OGR compatible file</p>
<p class="calibre1">with geocaching points. </p>
<p class="calibre1">:param my_location: Coordinates of your location. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self._datasource = None</p>
<p class="calibre1">self._transformed_geoms = None</p>
<p class="calibre1">self._my_location = None</p>
<p class="calibre1">self.distances = None</p>
<p class="calibre1"><a id="p138"/>        if data_file:</p>
<p class="calibre1">self.open_file(data_file)</p>
<p class="calibre1">if my_location:</p>
<p class="calibre1">self.my_location = my_location</p>
<p class="calibre1">def open_file(self, file_path):</p>
<p class="calibre1">"""Open a file containing geocaching data and prepare it for use. </p>
<p class="calibre1">:param file_path:</p>
<p class="calibre1">""" </p>
<p class="calibre1">self._datasource = open_vector_file(file_path)</p>
<p class="calibre1">self._transformed_geoms = transform_geometries(</p>
<p class="calibre1">self._datasource, 4326, 3395)</p>
<p class="calibre1">@property</p>
<p class="calibre1">def my_location(self):</p>
<p class="calibre1">return self._my_location</p>
<p class="calibre1">@my_location.setter</p>
<p class="calibre1">def my_location(self, coordinates):</p>
<p class="calibre1">self._my_location = transform_points([coordinates])[0]</p>
<p class="calibre1">def calculate_distances(self):</p>
<p class="calibre1">"""Calculates the distance between a</p>
<p class="calibre1">set of points and a given location. </p>
<p class="calibre1">:return: A list of distances in the same order as</p>
<p class="calibre1">the points. </p>
<p class="calibre1">""" </p>
<p class="calibre1">xa = self.my_location[0]</p>
<p class="calibre1">ya = self.my_location[1]</p>
<p class="calibre1">points = self._transformed_geoms</p>
<p class="calibre1">distances = []</p>
<p class="calibre1">for geom in points:</p>
<p class="calibre1">point_distance = math.sqrt(</p>
<p class="calibre1">(geom.GetX() - xa)**2 + (geom.GetY() - ya))</p>
<p class="calibre1">distances.append(point_distance)</p>
<p class="calibre1">return distances</p>
<p class="calibre1">def find_closest_point(self):</p>
<p class="calibre1">"""Find the closest point to a given location and return the cache that's on that point. </p>
<p class="calibre1">:return: OGR feature containing the point. </p>
<p class="calibre1">""" </p>
<p class="calibre1"># Part 1. </p>
<p class="calibre1">distances = self.calculate_distances()</p>
<p class="calibre1">index = np.argmin(distances)</p>
<p class="calibre1"># Part 2. </p>
<p class="calibre1">layer = self._datasource.GetLayerByIndex(0)</p>
<p class="calibre1">feature = layer.GetFeature(index)</p>
<p class="calibre1">print "Closest point at: {}m".format(distances[index]) return feature</p>
<p class="calibre1"><a id="p139"/>if __name__ == "__main__":</p>
<p class="calibre1">my_app = GeocachingApp('../data/geocaching.gpx', [-73.0, 43.0]) my_app.find_closest_point()</p>
<p class="calibre1">3.  Run the code, press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>, and select geocaching_app. Take a look at the result in the output:</p>
<p class="calibre1">Closest point at: 49653.3244095m</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p140"/>
<a id="p141"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we discussed important concepts related to code organization and data manipulation. This was accomplished by writing code with an increasing level of abstraction until we had a class with high-level functionality. </p>
<p class="calibre1">First, we wrote utility functions in order to automate tasks and prepare the data to be processed. Some of these functions were simple abstractions over the OGR library, which were made to avoid unnecessary code repetition. </p>
<p class="calibre1">Then, we wrote methods in a class representing the application. These methods take care of performing sequences of operations to make an application work. </p>
<p class="calibre1">Finally, we presented the foundation of how to perform mathematical operations over the elements of data. We wrote a very efficient method that calculates the distance for a list of elements. </p>
<p class="calibre1">In the next chapter, we will improve our data abstraction and make it possible for the application to combine multiple sources of data. </p>
<p class="calibre1"><a id="p142"/>
<a id="p143"/><b class="calibre3">Chapter 3. Combining Multiple Data</b></p>
<p class="calibre1"><b class="calibre3">Sources</b></p>
<p class="calibre1">Geographic data tends to be heterogeneous. Just to cite a few factors that contribute to this heterogeneity, it may come from different sources, have been produced at different times, or even have different languages. Given this fact, writing programs that can combine multiple sources of data is a fundamental topic in geoprocessing. </p>
<p class="calibre1">Data sources may come in different formats, such as shapefiles, text files, Google KML</p>
<p class="calibre1">files, GPX files from GPS, and so on. They may also vary in their contents; for example, they may have different types of geometries, coordinate systems, and attributes. </p>
<p class="calibre1">In this chapter, we will enhance our application by adding the capability to combine multiple sources of data from both different sites and different file formats. In order to achieve this, we will write code capable of identifying the type of data, and depending on this, we will make transformations to obtain a homogeneous set of data. </p>
<p class="calibre1">By extending OGR capabilities and including our own functions, we can represent the data in Python classes and add some smart capabilities to them that would make the process of combining many sources very easy for this application and others. </p>
<p class="calibre1">In order to achieve these objectives, we will cover the following topics in this chapter: The structure of geographic data files</p>
<p class="calibre1">How geometries are represented</p>
<p class="calibre1">How to transform data into Python objects</p>
<p class="calibre1">How to combine multiple sources of data</p>
<p class="calibre1">Using class inheritance in Python to write better code</p>
<p class="calibre1"><a id="p144"/><b class="calibre3">Representing geographic data</b></p>
<p class="calibre1">Most file formats that contain geographic data are made of a common simple structure consisting of a number of features, each containing a geometry and innumerous named properties. </p>
<p class="calibre1">Here, you can take a look at a sample of the contents of a GeoJSON file. This type of geographic file has the advantage of being human readable, allowing us to see exactly the structure that is being described. You don’t need to type this example; just take a good look at it. </p>
<p class="calibre1">Its structure is very similar to a Python dictionary. At the uppermost level, there is FeatureCollection, which contains a list of features. Each feature has a geometry, whose type may vary, and a  <i class="calibre4">dictionary</i> of properties that may contain any arbitrary property defined by the user. In brief, it follows exactly the described schema of data representation as shown in the following code:</p>
<p class="calibre1">{"type": "FeatureCollection", </p>
<p class="calibre1">"features": [</p>
<p class="calibre1">{"type": "Feature", </p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": "Point", </p>
<p class="calibre1">"coordinates": [102.0, 0.5]}, </p>
<p class="calibre1">"properties": {"prop0": "value0"}</p>
<p class="calibre1">}, </p>
<p class="calibre1">{"type": "Feature", </p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": "LineString", </p>
<p class="calibre1">"coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0]]</p>
<p class="calibre1">}, </p>
<p class="calibre1">"properties": {</p>
<p class="calibre1">"prop0": "value0", </p>
<p class="calibre1">"prop1": 0.0</p>
<p class="calibre1">}</p>
<p class="calibre1">}, </p>
<p class="calibre1">{"type": "Feature", </p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": "Polygon", </p>
<p class="calibre1">"coordinates": [</p>
<p class="calibre1">[ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], </p>
<p class="calibre1">[100.0, 1.0], [100.0, 0.0] ]</p>
<p class="calibre1">]</p>
<p class="calibre1">}, </p>
<p class="calibre1">"properties": {</p>
<p class="calibre1">"prop0": "value0", </p>
<p class="calibre1">"prop1": {"this": "that"}</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">]</p>
<p class="calibre1">}</p>
<p class="calibre1"><b class="calibre3">JSON</b> stands for <b class="calibre3">JavaScript Object Notation</b> and is a format that can be easily read and written in a number of programming languages. Specifically in Python, a JSON object can</p>
<p class="calibre1"><a id="p145"/>be transformed into a dictionary and vice versa. </p>
<p class="calibre1">There a number of other formats that implement the same structure; some of them add extra functionality and some have characteristics that are very specific for a given purpose. </p>
<p class="calibre1">For example, the <b class="calibre3">ESRI</b> shapefile has indexing capabilities, the <b class="calibre3">GPX</b> format is made to work with GPS devices to store waypoints and tracks, and <b class="calibre3">SpatiLite</b> is a single file spatial database at the top of SQLite that allows objects to have relations with each other. </p>
<p class="calibre1">In the following table, there are some common file formats and a brief description of each: <b class="calibre3">Format</b></p>
<p class="calibre1"><b class="calibre3">Description</b></p>
<p class="calibre1">Cartesian</p>
<p class="calibre1">This is a simple point cloud. </p>
<p class="calibre1">coordinate system</p>
<p class="calibre1">Digital Line</p>
<p class="calibre1">This is a USGS format for vector data. </p>
<p class="calibre1">Graph (DLG)</p>
<p class="calibre1">Geography</p>
<p class="calibre1">Markup</p>
<p class="calibre1">This is an XML-based open standard (by OpenGIS) for GIS data exchange. </p>
<p class="calibre1">Language</p>
<p class="calibre1">GeoJSON</p>
<p class="calibre1">This is a lightweight format based on JSON and is used by many open source GIS packages. </p>
<p class="calibre1">This is a spatial extension to SQLite that provides vector geodatabase functionality. It is similar to Spatialite</p>
<p class="calibre1">PostGIS, Oracle Spatial, and SQL Server with spatial extensions. </p>
<p class="calibre1">Shapefile</p>
<p class="calibre1">This is a popular vector data GIS format developed by Esri. </p>
<p class="calibre1"><a id="p146"/><img src="img/index-146_1.jpg" alt="Image 14" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Representing geometries</b></p>
<p class="calibre1">As we saw before, in geographic data, each feature contains a geometry. A geometry is the spatial representation of a given object. For example, a point can represent a tree, a place of interest, or, as in our case, a geocache. A line can be a road, a river, and so on. </p>
<p class="calibre1">Countries, cities, states, or any other type of areas can be represented by polygons. </p>
<p class="calibre1">In this book, we will follow the geometry representation described by the simple features specifications standardized in ISO 19125. It consists of two-dimensional geographic data made of points, lines, polygons, and aggregations or collections of them, as shown in the following image:</p>
<p class="calibre1">Any geometry in this format is represented by points and a linear interpolation between them. An example of this would be two points that form a line. </p>
<p class="calibre1">This type of geometry is simple, very common, and easy to use. Nevertheless, there are noticeable flaws, and the most important one is the lack of topological representation. </p>
<p class="calibre1">For example, we may have two features representing two neighbor countries—for example, Canada and USA. For each feature (that is, each country) there is a polygon representing the whole limit of the country. By consequence, the borders shared by the two countries will overlap. </p>
<p class="calibre1"><a id="p147"/><img src="img/index-147_1.jpg" alt="Image 15" class="calibre2"/></p>
<p class="calibre1">Now, think about the states in the USA and the provinces of Canada; each will be a polygon, their borders will also overlap, and they will, in turn, overlap the countries’</p>
<p class="calibre1">borders. So, we will end up with the following:</p>
<p class="calibre1">States/provinces</p>
<p class="calibre1">Country border</p>
<p class="calibre1">Other country border</p>
<p class="calibre1">Other states/provinces</p>
<p class="calibre1">This makes four overlapping lines; if we want to represent cities, districts, and so on, the number of overlapping geometries would increase. With this, we would have a higher probability of errors and require more space for storage. </p>
<p class="calibre1">This is why this type of geometry representation is also called <b class="calibre3">spaghetti data</b>; it ends with a juxtaposition of a lot of lines (similar to spaghetti). </p>
<p class="calibre1">This flaw can be solved through the topological representation of the geometries. The big difference is that, in this example, it wouldn’t store polygons; it would store the relationships between objects. You have a set of boundaries that relate to each other and represent an area, and two areas can have the same boundary. <b class="calibre3">OpenStreetMap</b> is a good example of a topological representation of geographic features. </p>
<p class="calibre1">Although topological representation is more advanced, it is much harder to work with, and the vast majority of geographic analysis can be done with a simple representation. </p>
<p class="calibre1"><a id="p148"/>
<a id="p149"/><b class="calibre3">Making data homogeneous</b></p>
<p class="calibre1">What relates the representation of data to real-life objects is the simple combination of geometry with the properties of a feature. </p>
<p class="calibre1">A line for example, can be a road, river, fence, and so on. The only difference may be the type property that tells us what it is. Alternatively, we may have a file named roads that lets us know that it contains roads. </p>
<p class="calibre1">However, the computer doesn’t know about this as it doesn’t know what the other properties represent or what the file is. Because of this, we need to make transformations in the data in order to have a common format that can be analyzed. </p>
<p class="calibre1">This common format is the subject of this topic; it is how data can be represented in Python in an optimal way and in which the objects can be manipulated and analyzed to produce the expected results. </p>
<p class="calibre1">The objective is to transform the basic data representation of features, geometries, and properties into a representation of real-life objects and hide the details of the functionality under the hood in this process. In computer science, this is called <b class="calibre3">abstraction</b>. </p>
<p class="calibre1">Instead of just writing some prepared code and magically performing the transformation, we will go step by step through the process of deduction of how the transformation needs to be done. This is very important because it’s the foundation of developing code to perform any kind of transformation on any type of geographic data that you can put to use in the future. </p>
<p class="calibre1"><a id="p150"/><b class="calibre3">The concept of abstraction</b></p>
<p class="calibre1">Now that we have a clear understanding of how data is represented, let’s get back to our geocaching application. </p>
<p class="calibre1">Abstraction is a programming technique intended to reduce the complexity of code for the programmer. It’s done by encapsulating complex code under progressive layers of more human-friendly solutions. The lower the level of abstraction, the closer to the machine language and the harder to maintain it is. The higher the level of abstraction, the more the code tries to mimic the behavior of real things or the more it resembles a natural language, thus becoming more intuitive and easier to maintain and extend. </p>
<p class="calibre1">Going back to the examples that we saw so far, we may notice many levels of abstraction</p>
<p class="calibre1">—for example, when we use the OGR library in the function we use to open shapefiles. </p>
<p class="calibre1">Take a look at the following code:</p>
<p class="calibre1">def open_vector_file(file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR, get the first layer and returns the ogr datasource. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">:return: The ogr datasource. </p>
<p class="calibre1">""" </p>
<p class="calibre1">datasource = ogr.Open(file_path)</p>
<p class="calibre1">layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">print("Opening {}".format(file_path))</p>
<p class="calibre1">print("Number of features: {}".format(layer.GetFeatureCount())) return datasource</p>
<p class="calibre1">Just at the uppermost layers of abstraction, we have the function itself that hides the functionality of OGR. Then, we have the OGR Python bindings that abstract the OGR C</p>
<p class="calibre1">API, which in turn handles memory allocation, all the mathematics, and so on. </p>
<p class="calibre1"><a id="p151"/><img src="img/index-151_1.jpg" alt="Image 16" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Abstracting the geocache point</b></p>
<p class="calibre1">So, we need to handle multiple sources of data in a smart way so that: We don’t need to change the code for each type of data</p>
<p class="calibre1">It’s possible to combine data from multiple sources</p>
<p class="calibre1">If we add extra functionality to our program, we don’t need to worry about file formats and data types</p>
<p class="calibre1">How will we do this? The answer is simple: we will abstract our data and hide the process of format and type handling in the internal functionality. </p>
<p class="calibre1">The objective is that after this point in the app, we won’t need to deal with OGR, layers, features, and so on. We will have one and only one type of object that we will use to represent our data, and all the interaction will be done with this object. The geocache object will represent a single geocaching point with the properties and methods that can be used to manipulate this object. </p>
<p class="calibre1">Now, perform the following steps:</p>
<p class="calibre1">1.  First, let’s organize the project structure. Open your geopy project in PyCharm and create a directory named Chapter3. </p>
<p class="calibre1">2.  Copy all the files and directories from Chapter2 to Chapter3. You should end up with a structure similar to the following:</p>
<p class="calibre1">+---Chapter3</p>
<p class="calibre1">|   |   geocaching_app.py</p>
<p class="calibre1">|   |   __init__.py</p>
<p class="calibre1">|   |   </p>
<p class="calibre1">|   +---experiments</p>
<p class="calibre1">|   |       import_test.py</p>
<p class="calibre1">|   |       module_test.py</p>
<p class="calibre1">|   |       </p>
<p class="calibre1">|   \---utils</p>
<p class="calibre1">|           data_transfer.py</p>
<p class="calibre1">|           geo_functions.py</p>
<p class="calibre1">|           __init__.py</p>
<p class="calibre1">3.  Inside Chapter3, create a new file named models.py (from this point on, we will</p>
<p class="calibre1"><a id="p152"/>work inside the Chapter3 directory). </p>
<p class="calibre1">4.  Now, add this code to the file:</p>
<p class="calibre1">class Geocache(object):</p>
<p class="calibre1">"""This class represents a single geocaching point.""" </p>
<p class="calibre1"/>
<p class="calibre1">def __init__(self, x, y):</p>
<p class="calibre1">self.x = x</p>
<p class="calibre1">self.y = y</p>
<p class="calibre1"/>
<p class="calibre1">@property</p>
<p class="calibre1">def coordinates(self):</p>
<p class="calibre1">return self.x, self.y</p>
<p class="calibre1">5.  Now, we have a geocache class with its first properties: the coordinates for the geocache. To test our class, we can write the following code: if __name__ == '__main__':</p>
<p class="calibre1">one_geocaching_point = Geocache(20, 40)</p>
<p class="calibre1">print(one_geocaching_point.coordinates)</p>
<p class="calibre1">6.  Run your code, press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>, and select the models files. You should get this output in the console:</p>
<p class="calibre1">(20, 40)</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p153"/><b class="calibre3">Abstracting geocaching data</b></p>
<p class="calibre1">As we have a single point, we also need to have a collection of points. We will call this PointCollection. Continuing the process of abstraction, the objective is to hide the operations of importing and converting the data. We will do this by creating a new class and encapsulating some of our utility functions inside it. Go to your models.py file and add the following class:</p>
<p class="calibre1">class PointCollection(object):</p>
<p class="calibre1">def __init__(self):</p>
<p class="calibre1">"""This class represents a group of vector data.""" </p>
<p class="calibre1">Self.data = []</p>
<p class="calibre1">It’s a simple class definition, and in the __init__ method, we will define that each instance of this class will have a data property. Now that we have created our simple abstractions, let’s add functionality to it. </p>
<p class="calibre1"><a id="p154"/>
<a id="p155"/><b class="calibre3">Importing geocaching data</b></p>
<p class="calibre1">In the previous chapter, we generalized our import function by adding the capability to import more types of data supported by OGR. </p>
<p class="calibre1">Now, we will improve it again, make it handle some errors, make it compatible with our objects, and add two new capabilities. We will also convert the data in order to produce uniform objects. </p>
<p class="calibre1">To achieve our goals, we will analyze what kind of information is stored in the files that we want to open. We will use OGR to inspect the files and return some information that may help us with the data conversion. </p>
<p class="calibre1">First, let’s alter our open_vector_file function, allowing it to handle incorrect paths and filenames, which is a very a common error. Perform the following steps: 1.  Go to the utils folder and open the geo_functions.py file. </p>
<p class="calibre1">2.  Add the following import statements at the beginning of the file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import ogr</p>
<p class="calibre1">import osr</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">import os</p>
<p class="calibre1">from pprint import pprint</p>
<p class="calibre1">3.  Now, edit the open_vector_file function via the following code: def open_vector_file(file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR, get the first layer and returns the ogr datasource. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">:return: The ogr datasource. </p>
<p class="calibre1">""" </p>
<p class="calibre1">datasource = ogr.Open(file_path)</p>
<p class="calibre1"># Check if the file was opened. </p>
<p class="calibre1">if not datasource:</p>
<p class="calibre1">if not os.path.isfile(file_path):</p>
<p class="calibre1">message = "Wrong path." </p>
<p class="calibre1">else:</p>
<p class="calibre1">message = "File format is invalid." </p>
<p class="calibre1">raise IOError(</p>
<p class="calibre1">'Error opening the file {}\n{}'.format(</p>
<p class="calibre1">file_path, message))</p>
<p class="calibre1">layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">print("Opening {}".format(file_path))</p>
<p class="calibre1">print("Number of features: {}".format(</p>
<p class="calibre1">layer.GetFeatureCount()))</p>
<p class="calibre1">return datasource</p>
<p class="calibre1">In this step, we added a verification to check whether the file was correctly opened. If the file doesn’t exist or if there are any other problems, OGR will be silent and the</p>
<p class="calibre1"><a id="p156"/>datasource will be empty. So, if the datasource is empty (None), we will know that something went wrong and perform another verification to see whether there was a mistake with the file path or something else happened. In either case, the program will raise an exception, preventing it from continuing with bad data. </p>
<p class="calibre1">4.  Now, we will add another function to print some information about the datasource for us. After the open_vector_file function, add the get_datasource_information function with the following code:</p>
<p class="calibre1">def get_datasource_information(datasource, print_results=False):</p>
<p class="calibre1">"""Get informations about the first layer in the datasource. </p>
<p class="calibre1">:param datasource: An OGR datasource. </p>
<p class="calibre1">:param bool print_results: True to print the results on</p>
<p class="calibre1">the screen. </p>
<p class="calibre1">""" </p>
<p class="calibre1">info = {}</p>
<p class="calibre1">layer = datasource.GetLayerByIndex(0)</p>
<p class="calibre1">bbox = layer.GetExtent()</p>
<p class="calibre1">info['bbox'] = dict(xmin=bbox[0], xmax=bbox[1], </p>
<p class="calibre1">ymin=bbox[2], ymax=bbox[3])</p>
<p class="calibre1">srs = layer.GetSpatialRef()</p>
<p class="calibre1">if srs:</p>
<p class="calibre1">info['epsg'] = srs.GetAttrValue('authority', 1)</p>
<p class="calibre1">else:</p>
<p class="calibre1">info['epsg'] = 'not available' </p>
<p class="calibre1">info['type'] = ogr.GeometryTypeToName(layer.GetGeomType())</p>
<p class="calibre1"># Get the attributes names. </p>
<p class="calibre1">info['attributes'] = []</p>
<p class="calibre1">layer_definition = layer.GetLayerDefn()</p>
<p class="calibre1">for index in range(layer_definition.GetFieldCount()):</p>
<p class="calibre1">info['attributes'].append(</p>
<p class="calibre1">layer_definition.GetFieldDefn(index).GetName())</p>
<p class="calibre1"># Print the results. </p>
<p class="calibre1">if print_results:</p>
<p class="calibre1">pprint(info)</p>
<p class="calibre1">return info</p>
<p class="calibre1">Here, we will use a number of OGR’s methods and functions to get information from the datasource and layer on it. This information is put in a dictionary, which is returned by the function. If we have print_results = True, the dictionary is printed with the pprint function (pretty print). This function tries to print Python objects in a more human-friendly way. </p>
<p class="calibre1">5.  Now, to test our code, edit the if __name__ == '__main__': block at the end of the file, as follows:</p>
<p class="calibre1">if __name__ == "__main__":</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">datasource = open_vector_file("../../data/geocaching.gpx") info = get_datasource_information(</p>
<p class="calibre1">datasource, print_results=True)</p>
<p class="calibre1">There is a new element here: gdal.PushErrorHandler('CPLQuietErrorHandler'). </p>
<p class="calibre1"><a id="p157"/>Geocaching files normally contain features with empty date fields. When OGR finds this situation, it prints a warning message. This could get pretty annoying when we have a lot of features. This command tells OGR/GDAL to suppress these messages so that we can have a clean output with only what we want to see. </p>
<p class="calibre1">6.  Run the code, press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>, and select <b class="calibre3">geo_functions</b>. You should get the following output showing the information that is collected: Opening ../../data/geocaching.gpx</p>
<p class="calibre1">Number of features: 130</p>
<p class="calibre1">{'attributes': ['ele', </p>
<p class="calibre1">'time', </p>
<p class="calibre1">'magvar', </p>
<p class="calibre1">'geoidheight', </p>
<p class="calibre1">'name', </p>
<p class="calibre1">'cmt', </p>
<p class="calibre1">'desc', </p>
<p class="calibre1">'src', </p>
<p class="calibre1">'url', </p>
<p class="calibre1">'urlname', </p>
<p class="calibre1">'sym', </p>
<p class="calibre1">'type', </p>
<p class="calibre1">'fix', </p>
<p class="calibre1">'sat', </p>
<p class="calibre1">'hdop', </p>
<p class="calibre1">'vdop', </p>
<p class="calibre1">'pdop', </p>
<p class="calibre1">'ageofdgpsdata', </p>
<p class="calibre1">'dgpsid'], </p>
<p class="calibre1">'bbox': {'xmax': -73.44602, </p>
<p class="calibre1">'xmin': -79.3536, </p>
<p class="calibre1">'ymax': 44.7475, </p>
<p class="calibre1">'ymin': 40.70558}, </p>
<p class="calibre1">'epsg': '4326', </p>
<p class="calibre1">'type': 'Point'}</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">The attributes key of the dictionary contains the field names that could be read from the data. Every feature on our GPX file (that is, every point) contains this set of attributes. The bbox code is the bounding box of the data, which are the coordinates of the upper-left and lower-right corners of the rectangle that comprises the geographical extent of the data. The epsg code contains the code for the coordinate system of the data. Finally, type is the type of geometry identified by OGR. </p>
<p class="calibre1"><a id="p158"/><b class="calibre3">Reading GPX attributes</b></p>
<p class="calibre1">Take a look at the attributes (field names) found by OGR in the previous example; we have a name, a description, and the time. We have some technical data about the GPS</p>
<p class="calibre1">solution (pdop, hdop, sat, fix, and many more) and some other fields, but none of them contains in-depth information about the geocache. </p>
<p class="calibre1">In order to take a look at what information the GPX file contains that OGR is not displaying, let’s open it in PyCharm:</p>
<p class="calibre1">1.  In your geopy project, go to the data folder. </p>
<p class="calibre1">2.  Locate geocaching.gpx. To open it, either drag and drop it in the editor area or double-click on the filename. </p>
<p class="calibre1">PyCharm will open it for editing but won’t recognize the file format and will display it in a single color; so, let’s inform it that this is an XML file. </p>
<p class="calibre1">3.  Right-click on the geocaching.gpx file. In the menu, select <b class="calibre3">Associate with File</b> <b class="calibre3">Type</b>, and a window with a list will pop up. Select <b class="calibre3">XML Files</b> and then click on the <b class="calibre3">OK</b> button. </p>
<p class="calibre1">Now, the contents of the GPX file should appear with colors differentiating the various elements of the extended markup language. PyCharm is also capable of recognizing the file structure, as it does with Python. Let’s take a look via the following steps: 1.  Press  <i class="calibre4">Alt</i> +  <i class="calibre4">7</i> or navigate to the <b class="calibre3">View</b> | <b class="calibre3">Tool Windows</b> | <b class="calibre3">Structure</b> menu. </p>
<p class="calibre1"><a id="p159"/><img src="img/index-159_1.jpg" alt="Image 17" class="calibre2"/></p>
<p class="calibre1">2.  This is the GPX file structure. Note that after some initial tags, it contains all the waypoints. Click on the arrow to the left of any waypoint to expand it. Then, locate the waypoint’s geocache tag and expand it too. </p>
<p class="calibre1"><a id="p160"/><img src="img/index-160_1.jpg" alt="Image 18" class="calibre2"/></p>
<p class="calibre1">3.  As you can note, the geocaching point contains much more information than OGR is capable of reading, including the status attribute of the geocache tag. </p>
<p class="calibre1">4.  Before we proceed, explore the file to get familiar with its notation. Click on some of the tags and look at the code editor to see the contents. </p>
<p class="calibre1">Since we can’t access these attributes directly with OGR, we will program an alternative. </p>
<p class="calibre1">The objective is to read this information and flatten it in a single level of key/value pairs in a dictionary. GPX files are XML files, so we can use an XML parser to read them. The choice here is the xmltodict package; it will simply convert the XML file into a Python dictionary, making it easier to manipulate as we are very familiar with dictionaries. Now, perform the following steps:</p>
<p class="calibre1">1.  Add the import of xmltodict at the beginning of the geo_functions.py file by executing the following code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import xmltodict</p>
<p class="calibre1">import ogr</p>
<p class="calibre1">import osr</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">import os</p>
<p class="calibre1">from pprint import pprint</p>
<p class="calibre1"><a id="p161"/>2.  Create a new function before open_vector_file and add the following code: def read_gpx_file(file_path):</p>
<p class="calibre1">"""Reads a GPX file containing geocaching points. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">with open(file_path) as gpx_file:</p>
</body></html>