["```py\n# Will run the circuit on the state vector (sv) simulator\n# Returns state vector results, circuit diagram, BlochSphere and QSphere\ndef execute_circuit_sv(quantum_circuit):\n    #Get the state vector results\n    statevectorResults = run_sv_circuit(quantum_circuit)\n    #Draw the circuit diagram\n    circuit_diagram = quantum_circuit.draw(output=\"mpl\")\n    #Draw the QSphere\n    q_sphere = statevectorResults.draw('qsphere')\n    #Draw the Bloch sphere     bloch_sphere = statevectorResults.draw('bloch')\n    #Return the results, circuit diagram, and QSphere     return statevectorResults, circuit_diagram, q_sphere, bloch_sphere \n```", "```py\n    # Load helper file\n    %run helper_file_1.0.ipynb\n    #H-gate\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add an H gate to the qubit\n    qc.h(0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([0.70710678+0.j, 0.70710678+0.j], dims=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #X-gate\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add an X gate to the qubit\n    qc.x(0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([0.+0.j, 1.+0.j], dims=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #Y-gate operation on a qubit\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add a Y gate to the qubit\n    qc.y(0)\n    #Execute the circuit and capture all the results returned\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([0.-0.j, 0.+1.j], dims=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #Z-gate\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add an H gate to the qubit to set the qubit in #superposition\n    qc.h(0)\n    #Add a Z gate to the qubit to rotate out of phase by π/2\n    qc.z(0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([ 0.70710678+0.j, -0.70710678+0.j], dims=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #S-gate\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add an H gate to the qubit to drop the vector onto the #X-axis\n    qc.h(0)\n    #Add an S gate to the qubit\n    qc.s(0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([7.07106781e-01+0.j, 4.32978028e-17+0.70710678j], dims=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #Sdg-gate\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add an H gate to the qubit to drop the vector onto the #X-axis\n    qc.h(0)\n    #Add an S† gate to the qubit\n    qc.sdg(0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([0.70710678+0.j, 4.32978028e-17-0.70710678j], dims=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #T-gate\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add an H gate to the qubit to drop the vector onto the #X-axis\n    qc.h(0)\n    #Add a T gate to the qubit\n    qc.t(0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([0.70710678+0.j , 0.5+0.5j], dims=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #Tdg-gate\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add an H gate to the qubit to drop the vector onto the #X-axis\n    qc.h(0)\n    #Add a Tdg gate to the qubit\n    qc.tdg(0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([0.70710678+0.j , 0.5 -0.5j], dims=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #Rz-gate\n    #Create the single qubit circuit\n    qc = QuantumCircuit(1)\n    #Import pi from the math library\n    from math import pi\n    #Add an H gate to help visualize phase rotation\n    qc.h(0)\n    #Add an RZ gate with an arbitrary angle theta of pi/6\n    qc.rz(pi/6, 0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    result \n    ```", "```py\nStatevector([0.06830127-0.1830127j, 0.6830127+0.1830127j], dim=(2,)) \n```", "```py\n    img \n    ```", "```py\n    bloch_sphere \n    ```", "```py\n    qsphere \n    ```", "```py\n    #U-gate\n    from math import pi\n    #Create a single qubit circuit\n    qc = QuantumCircuit(1)\n    #Add a U gate and rotate all parameters by pi/2, and #apply it to the qubit\n    qc.u(pi/2, pi/2, pi/2, 0)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\nStatevector([7.07106781e-01+0.j, 4.32978028e-17+0.70710678j], dims=(2,)) \n```", "```py\n    bloch_sphere \n    ```", "```py\n# Will execute the circuit on the Sampler primitive\n# Returns results, circuit diagram, and histogram\ndef execute_circuit_returns(quantum_circuit):\n    from qiskit.primitives import Sampler\n    sampler = Sampler()\n\nresult = sampler.run(quantum_circuit, shots=1024).result()\n    quasi_dists = result.quasi_dists\n#Get the counts\ncounts = quasi_dists[0].binary_probabilities()\ncircuit_diagram = quantum_circuit.draw(output=\"mpl\")\n    #Create a histogram of the results\n    histogram = plot_distribution(counts)\n    #Return the results, circuit diagram, and histogram\n    return counts, circuit_diagram, histogram \n```", "```py\n    #CNOT-gate\n    #Create a two-qubit circuit\n    qc = QuantumCircuit(2)\n    #Add an H gate to the qubit\n    qc.h(0)\n    #Add an CNOT gate where, control = first, target = second #qubit\n    qc.cx(0,1)\n    #Measure all qubits and send results to classical bits\n    qc.measure_all()\n    #Execute the circuit and capture all the results\n    counts, img, histogram = execute_circuit_returns(qc) \n    ```", "```py\n    counts \n    ```", "```py\n{'11': 526, '00': 498} \n```", "```py\n    img \n    ```", "```py\n    histogram \n    ```", "```py\n    #Toffoli (CCX)-gate\n    #Create a three-qubit circuit\n    qc = QuantumCircuit(3)\n    #Enable the Control qubits, first two qubits, of the Toffoli gate\n    qc.x(range(2))\n    #Add the Toffoli gate (CCX)\n    qc.ccx(0,1,2)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n[0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j\n 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j\n 0.+0.00000000e+00j 1.-3.05311332e-16j] \n```", "```py\n    bloch_sphere \n    ```", "```py\n    qc_decomposed = qc.decompose()\n    qc_decomposed.draw(output=\"mpl\") \n    ```", "```py\n    #Swap-gate\n    from math import pi\n    #Create a two-qubit circuit\n    qc = QuantumCircuit(2)\n    #Qubit 0 is initialized to |0> state\n    #Prepare qubit 1 to the |1> state\n    qc.x(1)\n    #Now swap gates\n    qc.swap(0,1)\n    #Execute the circuit and capture all the results\n    result, img, qsphere, bloch_sphere = execute_circuit_sv(qc) \n    ```", "```py\n    #CNOT-gate\n    #Create a two-qubit circuit\n    qc = QuantumCircuit(2)\n    #Add an H gate to the qubit\n    qc.h(0)\n    #Add a CNOT gate where, control = first, target = second\n    #qubit\n    qc.cx(0,1)\n    #Measure qubits and map to classical bits\n    qc.measure_all()\n    #Execute the circuit and capture all the results\n    result, img, histogram = execute_circuit_returns(qc) \n    ```", "```py\n    Result \n    ```", "```py\n{'11': 448, '00': 512} \n```", "```py\n    histogram \n    ```", "```py\n    img \n    ```", "```py\n    #Measurement operator\n    #Create two separate two-qubit,\n    #and two classical bit circuits\n    qc1 = QuantumCircuit(2,2)\n    qc2 = QuantumCircuit(2,2)\n    #In the first circuit (qc1), measure qubits individually\n    qc1.measure(0,0)\n    qc1.measure(1,1)\n    #In the second circuit (qc2) measure using a list\n    qc2.measure([0,1],[0,1])\n    #Execute the circuit and capture all the results\n    result, img, histogram = execute_circuit_returns(qc1)\n    result2, img2, histogram2 = execute_circuit_returns(qc2) \n    ```"]