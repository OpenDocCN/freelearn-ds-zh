<html><head></head><body>
<div id="_idContainer215" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-129"><a id="_idTextAnchor133" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-130" class="calibre5"><a id="_idTextAnchor134" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Introduction to Snowpark Container Services</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Containers represent a contemporary method for packaging code in diverse languages, ensuring seamless portability and consistency across various environments. </span><span class="kobospan" id="kobo.3.2">This is particularly true for advanced AI/ML models and comprehensive data-centric applications. </span><span class="kobospan" id="kobo.3.3">These modern data products often handle vast volumes of proprietary data, presenting challenges in efficiently creating, developing, and </span><span><span class="kobospan" id="kobo.4.1">scaling workloads.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">Developers and data scientists often spend more time managing computing resources and clusters than addressing core business challenges. </span><span class="kobospan" id="kobo.5.2">With its unique features, Snowpark Container Services offers a seamless solution to this problem. </span><span class="kobospan" id="kobo.5.3">It allows applications and </span><strong class="bold"><span class="kobospan" id="kobo.6.1">large language models</span></strong><span class="kobospan" id="kobo.7.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.8.1">LLMs</span></strong><span class="kobospan" id="kobo.9.1">) to be executed on containers directly within the Snowflake Data Cloud, reducing the time and effort spent on resource management. </span><span class="kobospan" id="kobo.9.2">This chapter will help you learn about deploying apps and LLMs on containers </span><span><span class="kobospan" id="kobo.10.1">within Snowpark.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.11.1">In this chapter, we are going to cover the </span><span><span class="kobospan" id="kobo.12.1">following topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.13.1">Introduction to Snowpark </span><span><span class="kobospan" id="kobo.14.1">Container Services</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.15.1">Setting up Snowpark </span><span><span class="kobospan" id="kobo.16.1">Container Services</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.17.1">Setting up a Snowpark Container </span><span><span class="kobospan" id="kobo.18.1">Service job</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.19.1">Deploying LLMs </span><span><span class="kobospan" id="kobo.20.1">with Snowpark</span></span></li>
</ul>
<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor135" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.21.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.22.1">To set up the environment, please refer to the technical requirements in the previous chapter. </span><span class="kobospan" id="kobo.22.2">Docker Client and Desktop are also required; you can install Docker </span><span><span class="kobospan" id="kobo.23.1">from </span></span><a href="https://huggingface.co/docs/hub/en/security-tokens" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.24.1">https://docs.docker.com/get-docker/</span></span></a><span><span class="kobospan" id="kobo.25.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">We’ll also be using the Hugging Face API. </span><span class="kobospan" id="kobo.26.2">To obtain the Hugging Face API token, sign up </span><span><span class="kobospan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.28.1">https://huggingface.co/</span></span></a><span><span class="kobospan" id="kobo.29.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">The supporting materials are available </span><span><span class="kobospan" id="kobo.31.1">at </span></span><a href="https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.32.1">https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark</span></span></a><span><span class="kobospan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-132" class="calibre5"><a id="_idTextAnchor136" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.34.1">Introduction to Snowpark Container Services</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">Snowpark Container Services</span><a id="_idIndexMarker477" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.36.1"> represents a comprehensive managed container solution tailored to facilitate the deployment, management, and scaling of containerized applications within the Snowflake environment. </span><span class="kobospan" id="kobo.36.2">Users can experience the convenience of executing containerized workloads directly within Snowflake, eliminating the need to transfer data outside the </span><a id="_idIndexMarker478" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.37.1">Snowflake ecosystem for processing. </span><span class="kobospan" id="kobo.37.2">Snowpark Container Services introduces an </span><strong class="bold"><span class="kobospan" id="kobo.38.1">Open Container Initiative</span></strong><span class="kobospan" id="kobo.39.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.40.1">OCI</span></strong><span class="kobospan" id="kobo.41.1">) runtime execution environment meticulously optimized for Snowflake, which empowers users to flawlessly execute OCI images while leveraging the robust capabilities of Snowflake’s </span><span><span class="kobospan" id="kobo.42.1">data platform.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.43.1">Snowpark Container Services extends Snowpark’s capability, empowering developers with a trusted and familiar environment to process non-SQL code seamlessly within Snowflake’s governed data domain. </span><span class="kobospan" id="kobo.43.2">This enables applications to effortlessly perform tasks such as connecting to Snowflake, executing SQL queries within a Snowflake virtual warehouse, accessing data files in a Snowflake stage, and processing data with Snowpark models. </span><span class="kobospan" id="kobo.43.3">This streamlined integration fosters an environment conducive to efficient collaboration and focused development efforts </span><span><span class="kobospan" id="kobo.44.1">within teams.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">Developers can create containers tailored to their needs that offer configurable hardware options, including GPU support, enabling a wide range of AI/ML and application workloads within Snowflake through Snowpark. </span><span class="kobospan" id="kobo.45.2">For instance, data science teams can expedite ML tasks by leveraging Python libraries for training and inference while executing resource-intensive generative AI models such as LLMs. </span><span class="kobospan" id="kobo.45.3">App developers can craft and deploy user interfaces using popular frameworks, and data engineers can execute optimized logic within the same processing engine handling SQL or Python </span><span><span class="kobospan" id="kobo.46.1">DataFrame operations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.47.1">In the next section, we will understand how data security works in Snowpark </span><span><span class="kobospan" id="kobo.48.1">Container Services.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.49.1">Note on Snowpark Container Services</span></p>
<p class="callout"><span class="kobospan" id="kobo.50.1">At the time of writing this chapter, Snowpark Container Services are currently in a private preview phase. </span><span class="kobospan" id="kobo.50.2">Please note that once they become available to all users, there may be slight variations in the API methods compared to what is described in this book. </span><span class="kobospan" id="kobo.50.3">We encourage you to monitor the book's GitHub repository for any new changes and updates to the code </span><span><span class="kobospan" id="kobo.51.1">contents: </span></span><a href="https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.52.1">https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark</span></span></a></p>
<h2 id="_idParaDest-133" class="calibre7"><a id="_idTextAnchor137" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.53.1">Data security in Snowpark Container Services</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">Snowpark </span><a id="_idIndexMarker479" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.55.1">Container Services facilitates the secure deployment of full-stack applications, LLMs, and other advanced data products directly within the data environment. </span><span class="kobospan" id="kobo.55.2">This new runtime option under Snowpark streamlines the deployment, management, and scaling of containerized workloads, including jobs, services, and service functions, leveraging Snowflake-managed infrastructure with customizable hardware configurations, such as GPUs. </span><span class="kobospan" id="kobo.55.3">By adopting this innovative runtime, users can bypass the complexities of managing compute resources and container clusters, allowing seamless integration of sophisticated AI/ML models and applications without compromising data security. </span><span class="kobospan" id="kobo.55.4">With containers operating within the Snowflake environment, there’s no need to transfer governed data outside of Snowflake, minimizing exposure to potential security risks. </span><span class="kobospan" id="kobo.55.5">This ensures a secure and robust ecosystem for leveraging internally developed solutions or third-party offerings, such as Snowflake Native Apps, accessible through the </span><span><span class="kobospan" id="kobo.56.1">Snowflake Marketplace.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.57.1">In the next section, we will look at the components of </span><span><span class="kobospan" id="kobo.58.1">Snowpark Containers.</span></span></p>
<h2 id="_idParaDest-134" class="calibre7"><a id="_idTextAnchor138" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.59.1">Components of Snowpark Containers</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.60.1">Snowpark Container Services</span><a id="_idIndexMarker480" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.61.1"> offers a streamlined and fully managed approach to the life cycle management of containerized applications and AI/ML models. </span><span class="kobospan" id="kobo.61.2">Unlike other solutions, it provides a cohesive solution that necessitates piecing together disparate components such as container registries, management services, and computing platforms. </span><span class="kobospan" id="kobo.61.3">Consolidating these elements eliminates the burden of managing computing resources and clusters, thereby accelerating the development and deployment of </span><span><span class="kobospan" id="kobo.62.1">data applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">Moreover, Snowpark Container Services simplifies container hosting and deployment by offering a combination of simplicity and scalability. </span><span class="kobospan" id="kobo.63.2">Developers only need to provide their containers, and Snowflake handles the hosting and scaling without requiring extensive knowledge of Kubernetes. </span><span class="kobospan" id="kobo.63.3">Developers can interact with the service using SQL, CLI, or Python interfaces, catering to diverse preferences and workloads. </span><span class="kobospan" id="kobo.63.4">Snowpark Containers has two distinct execution options to accommodate various application requirements: services</span><a id="_idIndexMarker481" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.64.1"> jobs through using service function, and compute pools. </span><span class="kobospan" id="kobo.64.2">The following diagram shows the </span><span><span class="kobospan" id="kobo.65.1">different components:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer193">
<span class="kobospan" id="kobo.66.1"><img alt="Figure 8.1 – Snowpark Container components" src="image/B19923_08_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.67.1">Figure 8.1 – Snowpark Container components</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.68.1">Let’s look at each of </span><span><span class="kobospan" id="kobo.69.1">the options:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.70.1">Services</span></strong><span class="kobospan" id="kobo.71.1">: A service in</span><a id="_idIndexMarker482" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.72.1"> Snowflake operates continuously, much like a web service, until explicitly terminated. </span><span class="kobospan" id="kobo.72.2">These services are hosted on secure ingress endpoints and typically host application frontends or APIs. </span><span class="kobospan" id="kobo.72.3">They remain continuously available to handle </span><span><span class="kobospan" id="kobo.73.1">on-demand requests.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.74.1">Jobs</span></strong><span class="kobospan" id="kobo.75.1">: These </span><a id="_idIndexMarker483" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.76.1">are processes with specific time limits, often initiated manually or scheduled regularly. </span><span class="kobospan" id="kobo.76.2">They encompass various tasks, such as launching container images for machine learning </span><a id="_idIndexMarker484" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.77.1">training on GPUs or executing steps within a data pipeline using diverse languages, frameworks, or libraries encapsulated </span><span><span class="kobospan" id="kobo.78.1">in containers.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.79.1">Service functions</span></strong><span class="kobospan" id="kobo.80.1">: Functions </span><a id="_idIndexMarker485" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.81.1">are time-limited processes designed to receive input, execute specific actions, and be triggered repeatedly by events, leveraging your </span><span><span class="kobospan" id="kobo.82.1">containerized environments.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.83.1">Compute pools</span></strong><span class="kobospan" id="kobo.84.1">: A compute pool</span><a id="_idIndexMarker486" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.85.1"> comprising one or more </span><strong class="bold"><span class="kobospan" id="kobo.86.1">virtual machine</span></strong><span class="kobospan" id="kobo.87.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.88.1">VM</span></strong><span class="kobospan" id="kobo.89.1">) nodes serves as</span><a id="_idIndexMarker487" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.90.1"> the infrastructure upon which Snowflake executes your jobs </span><span><span class="kobospan" id="kobo.91.1">and services.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.92.1">Snowpark Container Services </span><a id="_idIndexMarker488" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.93.1">also enables developers to deploy applications directly within their end customers’ Snowflake accounts using the aforementioned components. </span><span class="kobospan" id="kobo.93.2">This allows them to securely install and operate state-of-the-art offerings, such as hosted notebooks and LLMs, within their Snowflake environment, safeguarding the provider’s </span><span><span class="kobospan" id="kobo.94.1">intellectual property.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">In the next section, we will cover how to set up Snowpark </span><span><span class="kobospan" id="kobo.96.1">Container Services.</span></span></p>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor139" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.97.1">Setting up Snowpark Container Services</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.98.1">In this section, we’ll lay down </span><a id="_idIndexMarker489" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.99.1">the groundwork necessary for exploring Snowpark Container Services. </span><span class="kobospan" id="kobo.99.2">We will use Docker to create an OCI-compliant image to deploy to Snowpark. </span><span class="kobospan" id="kobo.99.3">We’ll start by creating </span><span><span class="kobospan" id="kobo.100.1">Snowflake objects.</span></span></p>
<h2 id="_idParaDest-136" class="calibre7"><a id="_idTextAnchor140" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.101.1">Creating Snowflake objects</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.102.1">To create</span><a id="_idIndexMarker490" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.103.1"> Snowflake objects, follow these steps in Snowsight with the </span><span><strong class="bold"><span class="kobospan" id="kobo.104.1">ACCOUNTADMIN</span></strong></span><span><span class="kobospan" id="kobo.105.1"> role:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.106.1">Create a role named </span><strong class="source-inline1"><span class="kobospan" id="kobo.107.1">test_role</span></strong><span class="kobospan" id="kobo.108.1"> using the following command. </span><span class="kobospan" id="kobo.108.2">This role will be used for our </span><span><span class="kobospan" id="kobo.109.1">Snowpark application:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.110.1">USE ROLE ACCOUNTADMIN;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.111.1">CREATE ROLE test_role;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.112.1">This will print the </span><span><span class="kobospan" id="kobo.113.1">following output:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer194">
<span class="kobospan" id="kobo.114.1"><img alt="Figure 8.2 – A Snowflake role" src="image/B19923_08_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.115.1">Figure 8.2 – A Snowflake role</span></p>
<ol class="calibre13">
<li value="2" class="calibre14"><span class="kobospan" id="kobo.116.1">Create a</span><a id="_idIndexMarker491" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.117.1"> database and grant access to the database role by running the </span><span><span class="kobospan" id="kobo.118.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.119.1">CREATE DATABASE IF NOT EXISTS SNOWPARK_DEFINITIVE_GUIDE;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.120.1">GRANT OWNERSHIP ON DATABASE SNOWPARK_DEFINITIVE_GUIDE</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.121.1">  TO ROLE test_role COPY CURRENT GRANTS;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.122.1">This will display the </span><span><span class="kobospan" id="kobo.123.1">following output:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer195">
<span class="kobospan" id="kobo.124.1"><img alt="Figure 8.3 – Granting access" src="image/B19923_08_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.125.1">Figure 8.3 – Granting access</span></p>
<ol class="calibre13">
<li value="3" class="calibre14"><span class="kobospan" id="kobo.126.1">We will be granting access to a warehouse for this role by executing the </span><span><span class="kobospan" id="kobo.127.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.128.1">GRANT USAGE ON WAREHOUSE COMPUTE_WH TO ROLE test_role;</span></strong></pre></li> <li class="calibre14"><span class="kobospan" id="kobo.129.1">Next, we will create a security integration for Snowflake services to access the resources securely by running the </span><span><span class="kobospan" id="kobo.130.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.131.1">CREATE SECURITY INTEGRATION IF NOT EXISTS snowservices_ingress_oauth</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.132.1">  TYPE=oauth</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.133.1">  OAUTH_CLIENT=snowservices_ingress</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.134.1">  ENABLED=true;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.135.1">The output is </span><span><span class="kobospan" id="kobo.136.1">as follows:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer196">
<span class="kobospan" id="kobo.137.1"><img alt="Figure 8.4 – Security integration" src="image/B19923_08_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.138.1">Figure 8.4 – Security integration</span></p>
<ol class="calibre13">
<li value="5" class="calibre14"><span class="kobospan" id="kobo.139.1">Next, we</span><a id="_idIndexMarker492" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.140.1"> will bind the service endpoint on the account to this role by running the following command. </span><span class="kobospan" id="kobo.140.2">This allows access to the service endpoint from the </span><span><span class="kobospan" id="kobo.141.1">public ingress:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.142.1">GRANT BIND SERVICE ENDPOINT ON ACCOUNT TO ROLE test_role;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.143.1">This will display the </span><span><span class="kobospan" id="kobo.144.1">following output:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer197">
<span class="kobospan" id="kobo.145.1"><img alt="Figure 8.5 – Binding the service endpoint" src="image/B19923_08_5.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.146.1">Figure 8.5 – Binding the service endpoint</span></p>
<ol class="calibre13">
<li value="6" class="calibre14"><span class="kobospan" id="kobo.147.1">Finally, we will create a compute pool and assign it to the role by running the </span><span><span class="kobospan" id="kobo.148.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.149.1">CREATE COMPUTE POOL snowpark_cs_compute_pool</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.150.1">MIN_NODES = 1</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.151.1">MAX_NODES = 1</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.152.1">INSTANCE_FAMILY = CPU_X64_XS;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.153.1">GRANT USAGE, MONITOR ON</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.154.1">  COMPUTE POOL snowpark_cs_compute_pool TO ROLE test_role;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.155.1">This will display the </span><span><span class="kobospan" id="kobo.156.1">following output:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer198">
<span class="kobospan" id="kobo.157.1"><img alt="Figure 8.6 – A compute pool" src="image/B19923_08_6.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.158.1">Figure 8.6 – A compute pool</span></p>
<ol class="calibre13">
<li value="7" class="calibre14"><span class="kobospan" id="kobo.159.1">We have </span><a id="_idIndexMarker493" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.160.1">now created a role, </span><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">test_role</span></strong><span class="kobospan" id="kobo.162.1">, and the necessary Snowflake objects we will use for the container services. </span><span class="kobospan" id="kobo.162.2">Now, grant the role to the user you are logged into by running the </span><span><span class="kobospan" id="kobo.163.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.164.1">GRANT ROLE test_role TO USER &lt;user_name&gt;;</span></strong></pre></li> <li class="calibre14"><span class="kobospan" id="kobo.165.1">Now that we have the role configured and ready to use, let’s create the necessary </span><span><span class="kobospan" id="kobo.166.1">database-scoped objects:</span></span><ul class="calibre18"><li class="calibre14"><span class="kobospan" id="kobo.167.1">Select the database by running the </span><span><span class="kobospan" id="kobo.168.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.169.1">USE DATABASE SNOWPARK_DEFINITIVE_GUIDE;</span></strong></pre></li><li class="calibre14"><span class="kobospan" id="kobo.170.1">Create a schema named </span><strong class="source-inline1"><span class="kobospan" id="kobo.171.1">MY_SCHEMA</span></strong><span class="kobospan" id="kobo.172.1"> by running the </span><span><span class="kobospan" id="kobo.173.1">following code:</span></span><pre class="source-code"><strong class="bold1"><span class="kobospan1" id="kobo.174.1">CREATE SCHEMA IF NOT EXISTS MY_SCHEMA;</span></strong></pre></li></ul></li> <li class="calibre14"><span class="kobospan" id="kobo.175.1">Create an image repository that stores the container image by running the </span><span><span class="kobospan" id="kobo.176.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.177.1">CREATE IMAGE REPOSITORY IF NOT EXISTS snowpark_cs_repository;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.178.1">Once the image is created, you’ll see the </span><span><span class="kobospan" id="kobo.179.1">following output:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer199">
<span class="kobospan" id="kobo.180.1"><img alt="Figure 8.7 – An image repository" src="image/B19923_08_7.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.181.1">Figure 8.7 – An image repository</span></p>
<ol class="calibre13">
<li value="10" class="calibre14"><span class="kobospan" id="kobo.182.1">Finally, create </span><a id="_idIndexMarker494" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.183.1">a stage that is used to upload the files by running the </span><span><span class="kobospan" id="kobo.184.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.185.1">CREATE STAGE IF NOT EXISTS snowpark_cs_stage</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.186.1">  DIRECTORY = ( ENABLE = true );</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.187.1">You’ll see the </span><span><span class="kobospan" id="kobo.188.1">following output:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer200">
<span class="kobospan" id="kobo.189.1"><img alt="Figure 8.8 – Stage creation" src="image/B19923_08_8.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.190.1">Figure 8.8 – Stage creation</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.191.1">We will be using the HuffPost dataset, which is available on Kaggle. </span><span class="kobospan" id="kobo.191.2">The dataset is provided in our code repository. </span><span class="kobospan" id="kobo.191.3">The dataset delineates approximately 200,000 headlines from 2012 through May 2018, with an additional 10,000 from May 2018 to 2022, reflecting adjustments in the website’s </span><span><span class="kobospan" id="kobo.192.1">operational dynamics.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.193.1">In the next section, we will set up </span><span><span class="kobospan" id="kobo.194.1">the services.</span></span></p>
<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor141" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.195.1">Setting up the services</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.196.1">Flask</span></strong><span class="kobospan" id="kobo.197.1"> is a</span><a id="_idIndexMarker495" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.198.1"> lightweight </span><a id="_idIndexMarker496" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.199.1">web framework that allows developers to easily create web applications in Python. </span><span class="kobospan" id="kobo.199.2">It is designed to be flexible, modular, and easy to use, making it a popular choice for building web applications of all sizes. </span><span class="kobospan" id="kobo.199.3">Flask is particularly well-suited for building small to medium-sized web applications, as it provides just enough functionality to get the job done without adding </span><span><span class="kobospan" id="kobo.200.1">unnecessary complexity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.201.1">Flask is used for a wide range of applications, including building web APIs, developing microservices, and creating simple web applications. </span><span class="kobospan" id="kobo.201.2">Its flexibility and simplicity make it a popular choice for developers who want to quickly prototype and deploy web applications. </span><span class="kobospan" id="kobo.201.3">Additionally, Flask </span><a id="_idIndexMarker497" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.202.1">can be easily extended with a variety of third-party libraries and tools, making it a powerful and versatile tool for building web applications </span><span><span class="kobospan" id="kobo.203.1">in Python.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.204.1">We will be utilizing Flask to write our service code that runs a persisting service to take </span><span><span class="kobospan" id="kobo.205.1">HTTPS calls.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.206.1">Note on filter service</span></p>
<p class="callout"><span class="kobospan" id="kobo.207.1">Filter service, which we are discussing in the next section, is just one simple example since our focus is more on explaining how to set up Snowpark Container Services rather than building a complex application. </span><span class="kobospan" id="kobo.207.2">By following similar steps, any other use case can </span><span><span class="kobospan" id="kobo.208.1">be developed.</span></span></p>
<h2 id="_idParaDest-138" class="calibre7"><a id="_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.209.1">Setting up the filter service</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.210.1">In this</span><a id="_idIndexMarker498" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.211.1"> section, we</span><a id="_idIndexMarker499" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.212.1"> will set up a service called </span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">filter_service</span></strong><span class="kobospan" id="kobo.214.1">, which filters the table based on a unique ID. </span><span class="kobospan" id="kobo.214.2">We will perform the following steps to set up </span><span><span class="kobospan" id="kobo.215.1">the service.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.216.1">Service code</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.217.1">You’ll find a</span><a id="_idIndexMarker500" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.218.1"> Python application encompassing the code for crafting the filter service on the code repository. </span><span class="kobospan" id="kobo.218.2">To initiate, download the provided zip file to a designated directory. </span><span class="kobospan" id="kobo.218.3">Upon download completion, proceed to extract its contents. </span><span class="kobospan" id="kobo.218.4">You’ll encounter a </span><strong class="source-inline"><span class="kobospan" id="kobo.219.1">service</span></strong><span class="kobospan" id="kobo.220.1"> directory containing the service code within the extracted files. </span><span class="kobospan" id="kobo.220.2">The directory consists of the Docker file, </span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">filter_service.py</span></strong><span class="kobospan" id="kobo.222.1">, and the templates for </span><span><span class="kobospan" id="kobo.223.1">the UI.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.224.1">Filter Service in Python</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.225.1">The </span><a id="_idIndexMarker501" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.226.1">following Python script includes the core logic of our service, encapsulating a minimalistic HTTP server based on Flask, and designed to filter the table based on input. </span><span class="kobospan" id="kobo.226.2">It serves a dual purpose: handling filter requests from Snowflake service functions and furnishing a web UI for submitting </span><span><span class="kobospan" id="kobo.227.1">filter requests.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.228.1">
@app.post("/filter")
def udf_calling_function():
    message = request.json
    logger.debug(f'Received request: {message}')
    if message is None or not message['data']:
        logger.info('Received empty message')
        return {}
    unique_id = message['data']</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.229.1">The </span><a id="_idIndexMarker502" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.230.1">filter function facilitates communication between a Snowflake service function and the service. </span><span class="kobospan" id="kobo.230.2">This function is adorned with the </span><strong class="source-inline"><span class="kobospan" id="kobo.231.1">@app.post()</span></strong><span class="kobospan" id="kobo.232.1"> decoration, signifying its capability to handle HTTP </span><strong class="source-inline"><span class="kobospan" id="kobo.233.1">POST</span></strong><span class="kobospan" id="kobo.234.1"> requests directed to the </span><strong class="source-inline"><span class="kobospan" id="kobo.235.1">/filter</span></strong><span class="kobospan" id="kobo.236.1"> path. </span><span class="kobospan" id="kobo.236.2">Upon receiving such requests, the function processes and sends back the filter results encapsulated within the </span><span><span class="kobospan" id="kobo.237.1">request body:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.238.1">
def ui():
    '''
    Main handler for providing a web UI.
</span><span class="kobospan1" id="kobo.238.2">    '''
    if request.method == "POST":
        # Getting input in HTML form
        input_text = request.form.get("input")</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.239.1">The UI function segment orchestrates a web form presentation and manages filter requests submitted via the web form. </span><span class="kobospan" id="kobo.239.2">Decorated with the </span><strong class="source-inline"><span class="kobospan" id="kobo.240.1">@app.route()</span></strong><span class="kobospan" id="kobo.241.1"> decorator, this function is designated to handle requests targeting the </span><strong class="source-inline"><span class="kobospan" id="kobo.242.1">/ui</span></strong><span class="kobospan" id="kobo.243.1"> path. </span><span class="kobospan" id="kobo.243.2">Upon receiving an HTTP </span><strong class="source-inline"><span class="kobospan" id="kobo.244.1">GET</span></strong><span class="kobospan" id="kobo.245.1"> request for this path, the server delivers a simple HTML form prompting the user to input a string. </span><span class="kobospan" id="kobo.245.2">Subsequently, upon form submission, an HTTP </span><strong class="source-inline"><span class="kobospan" id="kobo.246.1">POST</span></strong><span class="kobospan" id="kobo.247.1"> request is dispatched, and the server processes it, returning the original string encapsulated within an </span><span><span class="kobospan" id="kobo.248.1">HTTP response:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.249.1">
@app.get("/healthcheck")
def readiness_probe():
    return "I'm ready!"</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.250.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.251.1">readiness_probe</span></strong><span class="kobospan" id="kobo.252.1"> function, adorned with the </span><strong class="source-inline"><span class="kobospan" id="kobo.253.1">@app.get()</span></strong><span class="kobospan" id="kobo.254.1"> decorator, is primed to</span><a id="_idIndexMarker503" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.255.1"> handle requests directed to </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">/healthcheck</span></strong><span class="kobospan" id="kobo.257.1">. </span><span class="kobospan" id="kobo.257.2">This function is pivotal for Snowflake to verify the service’s readiness. </span><span class="kobospan" id="kobo.257.3">When Snowflake initiates a container, it dispatches an HTTP </span><strong class="source-inline"><span class="kobospan" id="kobo.258.1">GET</span></strong><span class="kobospan" id="kobo.259.1"> request to this path as a health probe, ensuring that only healthy containers handle incoming traffic. </span><span class="kobospan" id="kobo.259.2">The function’s implementation is flexible, accommodating various actions to ascertain the </span><span><span class="kobospan" id="kobo.260.1">service’s readiness.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.261.1">Next, we will look at the Dockerfile in </span><span><span class="kobospan" id="kobo.262.1">the directory.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.263.1">The Dockerfile</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.264.1">The Dockerfile </span><a id="_idIndexMarker504" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.265.1">serves as a blueprint for constructing an image using Docker. </span><span class="kobospan" id="kobo.265.2">It includes directives on installing the Flask library within the Docker container. </span><span class="kobospan" id="kobo.265.3">The Dockerfile consists of </span><span><span class="kobospan" id="kobo.266.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.267.1">
ARG BASE_IMAGE=python:3.10-slim-buster
FROM $BASE_IMAGE
COPY filter_service.py ./
COPY templates/ ./templates/
RUN pip install --upgrade pip &amp;&amp; \
    pip install flask &amp;&amp; \
    pip install snowflake-snowpark-python[pandas]
CMD ["python3", "filter_service.py"]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.268.1">The code within </span><strong class="source-inline"><span class="kobospan" id="kobo.269.1">filter_service.py</span></strong><span class="kobospan" id="kobo.270.1"> relies on Flask to efficiently handle </span><span><span class="kobospan" id="kobo.271.1">HTTP requests.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.272.1">Next, we will examine the </span><span><span class="kobospan" id="kobo.273.1">UI templates.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.274.1">UI templates</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.275.1">The UI template</span><a id="_idIndexMarker505" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.276.1"> files are located at </span><strong class="source-inline"><span class="kobospan" id="kobo.277.1">/template/basic_ui.html</span></strong><span class="kobospan" id="kobo.278.1">. </span><span class="kobospan" id="kobo.278.2">They render a web form for the filter service’s publicly exposed endpoint. </span><span class="kobospan" id="kobo.278.3">This form is displayed when the public endpoint URL is loaded in a web browser with </span><strong class="source-inline"><span class="kobospan" id="kobo.279.1">/ui</span></strong><span class="kobospan" id="kobo.280.1"> appended. </span><span class="kobospan" id="kobo.280.2">Users can input a string via this form, and upon submission, the service filters the table with submitted row given as string within an </span><span><span class="kobospan" id="kobo.281.1">HTTP response.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.282.1">In the next section, we will cover the </span><span><span class="kobospan" id="kobo.283.1">service function.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.284.1">The service function</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.285.1">A service function serves</span><a id="_idIndexMarker506" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.286.1"> as a conduit for communicating with your service. </span><span class="kobospan" id="kobo.286.2">A </span><strong class="bold"><span class="kobospan" id="kobo.287.1">user-defined function</span></strong><span class="kobospan" id="kobo.288.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.289.1">UDF</span></strong><span class="kobospan" id="kobo.290.1">) is tethered to a service</span><a id="_idIndexMarker507" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.291.1"> endpoint. </span><span class="kobospan" id="kobo.291.2">Upon execution, the service function dispatches a request to the associated service endpoint and awaits a response. </span><span class="kobospan" id="kobo.291.3">Creating such service functions involves executing the </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">CREATE FUNCTION</span></strong><span class="kobospan" id="kobo.293.1"> command with specified parameters, such as the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.294.1">filter_doc_udf</span></strong></span><span><span class="kobospan" id="kobo.295.1"> function:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.296.1">
CREATE FUNCTION filter_doc_udf (InputText varchar)
  RETURNS varchar
  SERVICE=filter_service
  ENDPOINT=filterendpoint
  AS '/filter';</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.297.1">This function, for instance, accepts a string as input and returns a string, with the </span><strong class="source-inline"><span class="kobospan" id="kobo.298.1">SERVICE</span></strong><span class="kobospan" id="kobo.299.1"> property designating the service (</span><strong class="source-inline"><span class="kobospan" id="kobo.300.1">filter_service</span></strong><span class="kobospan" id="kobo.301.1">) and the </span><strong class="source-inline"><span class="kobospan" id="kobo.302.1">ENDPOINT</span></strong><span class="kobospan" id="kobo.303.1"> property specifying the user-friendly endpoint name (</span><strong class="source-inline"><span class="kobospan" id="kobo.304.1">filterendpoint</span></strong><span class="kobospan" id="kobo.305.1">). </span><span class="kobospan" id="kobo.305.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.306.1">AS '/filter'</span></strong><span class="kobospan" id="kobo.307.1"> designation denotes the path for the service, tying it to the corresponding function within </span><strong class="source-inline"><span class="kobospan" id="kobo.308.1">filter_service.py</span></strong><span class="kobospan" id="kobo.309.1">. </span><span class="kobospan" id="kobo.309.2">Thus, invoking this function triggers Snowflake to dispatch a request to the designated path within the </span><span><span class="kobospan" id="kobo.310.1">service container.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.311.1">In the next section, we will build the </span><span><span class="kobospan" id="kobo.312.1">Docker image.</span></span></p>
<h2 id="_idParaDest-139" class="calibre7"><a id="_idTextAnchor143" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.313.1">Building the Docker image</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.314.1">In this section, we</span><a id="_idIndexMarker508" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.315.1"> will construct the image using the Linux/AMD64 base, which is compatible with Snowpark, and dispatch it to your account’s image repository. </span><span class="kobospan" id="kobo.315.2">To build the Docker image, perform the </span><span><span class="kobospan" id="kobo.316.1">following steps:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.317.1">Obtain the repository URL by executing the following </span><span><span class="kobospan" id="kobo.318.1">SQL command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.319.1">SHOW IMAGE REPOSITORIES;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.320.1">This will display all the </span><span><span class="kobospan" id="kobo.321.1">image repositories:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer201">
<span class="kobospan" id="kobo.322.1"><img alt="Figure 8.9 – The image repositories" src="image/B19923_08_9.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.323.1">Figure 8.9 – The image repositories</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.324.1">The </span><strong class="bold"><span class="kobospan" id="kobo.325.1">repository_url</span></strong><span class="kobospan" id="kobo.326.1"> column in the output furnishes the essential URL, and the hostname delineated in the repository URL denotes the </span><span><span class="kobospan" id="kobo.327.1">registry hostname.</span></span></p>
<ol class="calibre13">
<li value="2" class="calibre14"><span class="kobospan" id="kobo.328.1">The following commands require Docker Desktop to be installed in the system. </span><span class="kobospan" id="kobo.328.2">You can install it from </span><a href="https://www.docker.com/products/docker-desktop/" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.329.1">https://www.docker.com/products/docker-desktop/</span></a><span class="kobospan" id="kobo.330.1"> before proceeding with the commands. </span><span class="kobospan" id="kobo.330.2">Next, in the local terminal window, switch to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.331.1">service</span></strong><span class="kobospan" id="kobo.332.1"> directory containing the unzipped files and execute the subsequent </span><strong class="source-inline1"><span class="kobospan" id="kobo.333.1">docker build</span></strong><span class="kobospan" id="kobo.334.1"> command using the </span><span><span class="kobospan" id="kobo.335.1">Docker CLI:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.336.1">docker build --rm --platform linux/amd64 -t &lt;orgname&gt;-&lt;acctname&gt;.registry.snowflakecomputing.com/snowpark_definitive_guide/my_schema/snowpark_cs_repository/my_filter_service_image:latest .</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.337.1">This command designates the current working directory (</span><strong class="source-inline"><span class="kobospan" id="kobo.338.1">.</span></strong><span class="kobospan" id="kobo.339.1">) as the path for building the latest image from the Docker file. </span><span class="kobospan" id="kobo.339.2">The output will be </span><span><span class="kobospan" id="kobo.340.1">as follows:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer202">
<span class="kobospan" id="kobo.341.1"><img alt="Figure 8.10 – The Docker build command" src="image/B19923_08_10.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.342.1">Figure 8.10 – The Docker build command</span></p>
<ol class="calibre13">
<li value="3" class="calibre14"><span class="kobospan" id="kobo.343.1">Next, we’ll authenticate Docker with Snowflake. </span><span class="kobospan" id="kobo.343.2">To authenticate Docker with the Snowflake registry, execute the </span><span><span class="kobospan" id="kobo.344.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.345.1">docker login &lt;registry_hostname&gt; -u &lt;username&gt;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.346.1">Specify your Snowflake username for the username parameter. </span><span class="kobospan" id="kobo.346.2">Docker will prompt you for your password. </span><span class="kobospan" id="kobo.346.3">Use the Snowflake password </span><span><span class="kobospan" id="kobo.347.1">to authenticate:</span></span></p><div class="img---figure" id="_idContainer203"><span class="kobospan" id="kobo.348.1"><img alt="Figure 8.11 – Repository login" src="image/B19923_08_11.0.jpg" class="calibre4"/></span></div></li> </ol>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.349.1">Figure 8.11 – Repository login</span></p>
<ol class="calibre13">
<li value="4" class="calibre14"><span class="kobospan" id="kobo.350.1">Finally, upload the image to the Docker registry by executing the </span><span><span class="kobospan" id="kobo.351.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.352.1">docker push &lt;orgname&gt;-&lt;acctname&gt;.registry.snowflakecomputing.com/snowpark_definitive_guide/my_schema/snowpark_cs_repository/my_filter_service_image:latest</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.353.1">You should see the </span><span><span class="kobospan" id="kobo.354.1">following output:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer204">
<span class="kobospan" id="kobo.355.1"><img alt="Figure 8.12 – Repository push" src="image/B19923_08_12.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.356.1">Figure 8.12 – Repository push</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.357.1">The </span><a id="_idIndexMarker509" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.358.1">image is now available in the registry for deployment into </span><span><span class="kobospan" id="kobo.359.1">Container Services.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.360.1">In the next section, we will examine how to deploy the service, but it is always best practice to test your build locally before pushing it to the Snowflake repository. </span><span class="kobospan" id="kobo.360.2">This part is not explained in this section as it is beyond the scope of </span><span><span class="kobospan" id="kobo.361.1">this book.</span></span></p>
<h2 id="_idParaDest-140" class="calibre7"><a id="_idTextAnchor144" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.362.1">Deploying the service</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">In this </span><a id="_idIndexMarker510" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.364.1">section, we’ll guide you through deploying the service and establishing a service function to facilitate communication with it. </span><span class="kobospan" id="kobo.364.2">We will start by deploying the service, which requires the existing compute pool. </span><span class="kobospan" id="kobo.364.3">Let’s start by checking the compute pool by running the </span><span><span class="kobospan" id="kobo.365.1">following command:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.366.1">
DESCRIBE COMPUTE POOL snowpark_cs_compute_pool;</span></pre> <div class="calibre2">
<div class="img---figure" id="_idContainer205">
<span class="kobospan" id="kobo.367.1"><img alt="Figure 8.13 – The compute pool" src="image/B19923_08_13.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.368.1">Figure 8.13 – The compute pool</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.369.1">If it’s in the </span><strong class="bold"><span class="kobospan" id="kobo.370.1">STARTING</span></strong><span class="kobospan" id="kobo.371.1"> state, you’ll need to wait until it transitions to </span><strong class="bold"><span class="kobospan" id="kobo.372.1">ACTIVE</span></strong> <span><span class="kobospan" id="kobo.373.1">or </span></span><span><strong class="bold"><span class="kobospan" id="kobo.374.1">IDLE</span></strong></span><span><span class="kobospan" id="kobo.375.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.376.1">Now that the </span><a id="_idIndexMarker511" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.377.1">pool is active, we can create the service in the </span><span><span class="kobospan" id="kobo.378.1">next section.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.379.1">Creating the service</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.380.1">We can </span><a id="_idIndexMarker512" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.381.1">create the service by running it using </span><strong class="source-inline"><span class="kobospan" id="kobo.382.1">test_role</span></strong><span class="kobospan" id="kobo.383.1">. </span><span class="kobospan" id="kobo.383.2">To do that, run the </span><span><span class="kobospan" id="kobo.384.1">following command:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.385.1">
USE ROLE test_role;
CREATE SERVICE filter_service
  IN COMPUTE POOL snowpark_cs_compute_pool
  FROM SPECIFICATION $$
    spec:
      containers:
      - name: filter
        image: /snowpark_definitive_guide/my_schema/snowpark_cs_repository/my_filter_service_image:latest
        env:
          SERVER_PORT: 8000
        readinessProbe:
          port: 8000
          path: /healthcheck
      endpoints:
      - name: filterendpoint
        port: 8000
        public: true
      $$
  MIN_INSTANCES=1
  MAX_INSTANCES=1;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.386.1">We are using</span><a id="_idIndexMarker513" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.387.1"> the image that we have built to deploy the service. </span><span class="kobospan" id="kobo.387.2">The service should be created </span><span><span class="kobospan" id="kobo.388.1">within Snowflake.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.389.1">Once the service is created, you can execute the following SQL command to check </span><span><span class="kobospan" id="kobo.390.1">its status:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.391.1">
SELECT SYSTEM$GET_SERVICE_STATUS('filter_service');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.392.1">The output should show that the service is running. </span><span class="kobospan" id="kobo.392.2">The information about the service can be obtained by running the </span><span><span class="kobospan" id="kobo.393.1">following command:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.394.1">
DESCRIBE SERVICE filter_service;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.395.1">This will display the details, as shown in the </span><span><span class="kobospan" id="kobo.396.1">following screenshot:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer206">
<span class="kobospan" id="kobo.397.1"><img alt="Figure 8.14 – Service information" src="image/B19923_08_14.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.398.1">Figure 8.14 – Service information</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.399.1">In the next section, we will create the </span><span><span class="kobospan" id="kobo.400.1">service function.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.401.1">Creating a service function</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.402.1">The service function</span><a id="_idIndexMarker514" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.403.1"> performs the filter function and associates it with an endpoint. </span><span class="kobospan" id="kobo.403.2">To create a service function, execute the </span><span><span class="kobospan" id="kobo.404.1">following command:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.405.1">
CREATE FUNCTION filter_doc_udf (InputText varchar)
RETURNS varchar
SERVICE=filter_service
ENDPOINT=filterendpoint
AS '/filter';</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.406.1">Here, the </span><strong class="source-inline"><span class="kobospan" id="kobo.407.1">SERVICE</span></strong><span class="kobospan" id="kobo.408.1"> property links the UDF with the </span><strong class="source-inline"><span class="kobospan" id="kobo.409.1">filter_service</span></strong><span class="kobospan" id="kobo.410.1"> service, while the </span><strong class="source-inline"><span class="kobospan" id="kobo.411.1">ENDPOINT</span></strong><span class="kobospan" id="kobo.412.1"> property associates it with the </span><strong class="source-inline"><span class="kobospan" id="kobo.413.1">filterendpoint</span></strong><span class="kobospan" id="kobo.414.1"> endpoint within the service. </span><span class="kobospan" id="kobo.414.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.415.1">AS '/filter'</span></strong><span class="kobospan" id="kobo.416.1"> specification denotes the HTTP path leading to the filter server, which can be located within the </span><span><span class="kobospan" id="kobo.417.1">service code.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.418.1">Once the previous SQL statement is executed correctly, you can see the service function you created in Snowsight </span><span><span class="kobospan" id="kobo.419.1">under </span></span><span><strong class="bold"><span class="kobospan" id="kobo.420.1">Functions</span></strong></span><span><span class="kobospan" id="kobo.421.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer207">
<span class="kobospan" id="kobo.422.1"><img alt="Figure 8.15 – The service function" src="image/B19923_08_15.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.423.1">Figure 8.15 – The service function</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.424.1">Now the function is ready to </span><span><span class="kobospan" id="kobo.425.1">be executed.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.426.1">Executing the function</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.427.1">We will </span><a id="_idIndexMarker515" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.428.1">switch to the context we created earlier in the chapter by running the </span><span><span class="kobospan" id="kobo.429.1">following command:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.430.1">
USE ROLE test_role;
USE DATABASE SNOWPARK_DEFINITIVE_GUIDE;
USE SCHEMA MY_SCHEMA;
USE WAREHOUSE compute_wh;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.431.1">You should get the </span><span><span class="kobospan" id="kobo.432.1">following confirmation:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer208">
<span class="kobospan" id="kobo.433.1"><img alt="Figure 8.16 – Function execution" src="image/B19923_08_16.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.434.1">Figure 8.16 – Function execution</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.435.1">With the</span><a id="_idIndexMarker516" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.436.1"> context set up, you can initiate communication with the filter service by invoking the service function within a query. </span><span class="kobospan" id="kobo.436.2">To call the </span><strong class="source-inline"><span class="kobospan" id="kobo.437.1">filter_doc_udf</span></strong><span class="kobospan" id="kobo.438.1"> service function, execute the following </span><strong class="source-inline"><span class="kobospan" id="kobo.439.1">SELECT</span></strong><span class="kobospan" id="kobo.440.1"> statement, providing a sample input </span><span><span class="kobospan" id="kobo.441.1">string (</span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.442.1">'122880'</span></strong></span><span><span class="kobospan" id="kobo.443.1">):</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.444.1">
SELECT filter_doc_udf('122880');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.445.1">Upon executing this query, Snowflake dispatches a </span><strong class="source-inline"><span class="kobospan" id="kobo.446.1">POST</span></strong><span class="kobospan" id="kobo.447.1"> request to the service endpoint (</span><strong class="source-inline"><span class="kobospan" id="kobo.448.1">filterendpoint</span></strong><span class="kobospan" id="kobo.449.1">). </span><span class="kobospan" id="kobo.449.2">Upon receiving the request, the service utilizes the input string to filter the table for </span><strong class="source-inline"><span class="kobospan" id="kobo.450.1">UNIQUE_ID</span></strong><span class="kobospan" id="kobo.451.1"> and sends back the appropriate row in the response, as </span><span><span class="kobospan" id="kobo.452.1">shown here:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer209">
<span class="kobospan" id="kobo.453.1"><img alt="Figure 8.17 – The filter function" src="image/B19923_08_17.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.454.1">Figure 8.17 – The filter function</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.455.1">The service exposes its endpoint publicly but still securely behind the Snowflake authentication mechanism, as specified in the inline specification provided within the </span><strong class="source-inline"><span class="kobospan" id="kobo.456.1">CREATE SERVICE</span></strong><span class="kobospan" id="kobo.457.1"> command. </span><span class="kobospan" id="kobo.457.2">Consequently, you can access a web UI that the service exposes to the internet and send requests to the service from a web browser. </span><span class="kobospan" id="kobo.457.3">To find the URL of the public endpoint the service exposes, execute the </span><span><span class="kobospan" id="kobo.458.1">following command:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.459.1">
SHOW ENDPOINTS IN SERVICE filter_service;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.460.1">To access the web UI, append </span><strong class="source-inline"><span class="kobospan" id="kobo.461.1">/ui</span></strong><span class="kobospan" id="kobo.462.1"> to the endpoint URL and paste it into the web browser. </span><span class="kobospan" id="kobo.462.2">This action triggers the execution of the </span><strong class="source-inline"><span class="kobospan" id="kobo.463.1">ui()</span></strong><span class="kobospan" id="kobo.464.1"> function specified in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.465.1">filter_service.py</span></strong></span><span><span class="kobospan" id="kobo.466.1"> script:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer210">
<span class="kobospan" id="kobo.467.1"><img alt="Figure 8.18 – The service UI" src="image/B19923_08_18.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.468.1">Figure 8.18 – The service UI</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.469.1">Please </span><a id="_idIndexMarker517" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.470.1">note that the first time you access the endpoint URL, you’ll be prompted to log in to Snowflake. </span><span class="kobospan" id="kobo.470.2">Ensure you log in as the same user who created the service to guarantee you possess the </span><span><span class="kobospan" id="kobo.471.1">necessary privileges.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.472.1">We have successfully deployed the service and the components. </span><span class="kobospan" id="kobo.472.2">In the next section, we will look at the </span><span><span class="kobospan" id="kobo.473.1">service job.</span></span></p>
<h1 id="_idParaDest-141" class="calibre5"><a id="_idTextAnchor145" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.474.1">Setting up a Snowpark Container Service job</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.475.1">In this section, we</span><a id="_idIndexMarker518" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.476.1"> will create a simple job to connect to a Snowflake table and conduct some feature engineering tasks by generating new columns. </span><span class="kobospan" id="kobo.476.2">Subsequently, we’ll save the resultant data to the same table within the Snowflake environment. </span><span class="kobospan" id="kobo.476.3">Unlike services, jobs are short-lived, providing a one-time execution </span><span><span class="kobospan" id="kobo.477.1">of tasks.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.478.1">In the next section, we will set up the </span><span><span class="kobospan" id="kobo.479.1">container job.</span></span></p>
<h2 id="_idParaDest-142" class="calibre7"><a id="_idTextAnchor146" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.480.1">Setting up the job</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.481.1">For the job, instead of the Flask server implementation for services, we’ll utilize a straightforward </span><strong class="source-inline"><span class="kobospan" id="kobo.482.1">main.py</span></strong><span class="kobospan" id="kobo.483.1"> file to execute the job action. </span><span class="kobospan" id="kobo.483.2">We will perform the following steps to set up </span><span><span class="kobospan" id="kobo.484.1">the job.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.485.1">Job code</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.486.1">The code for </span><a id="_idIndexMarker519" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.487.1">this section is in our GitHub repository under the </span><strong class="source-inline"><span class="kobospan" id="kobo.488.1">chapter_8</span></strong><span class="kobospan" id="kobo.489.1"> folder. </span><span class="kobospan" id="kobo.489.2">The folder contains the following files, which are required for </span><span><span class="kobospan" id="kobo.490.1">the job.</span></span></p>
<h4 class="calibre16"><span class="kobospan" id="kobo.491.1">The main.py file</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.492.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.493.1">main.py</span></strong><span class="kobospan" id="kobo.494.1"> file is </span><a id="_idIndexMarker520" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.495.1">the core Python script for orchestrating the job’s execution. </span><span class="kobospan" id="kobo.495.2">At its heart lies the following </span><strong class="source-inline"><span class="kobospan" id="kobo.496.1">run_job()</span></strong><span class="kobospan" id="kobo.497.1"> function, invoked when the script is executed. </span><span class="kobospan" id="kobo.497.2">This function plays a pivotal role in reading environment variables and utilizing them to set default values for various parameters that are essential for connecting </span><span><span class="kobospan" id="kobo.498.1">to Snowflake.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.499.1">
def run_job():
    """
    Main body of this job.
</span><span class="kobospan1" id="kobo.499.2">    """
    logger = get_logger()
    logger.info("Job started")
    # Parse input arguments
    args = get_arg_parser().parse_args()
    table = args.table
    column = args.date_column</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.500.1">While Snowflake automatically populates some parameters when the image runs within its environment, explicit provision is required when testing the image locally. </span><span class="kobospan" id="kobo.500.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.501.1">run_job()</span></strong><span class="kobospan" id="kobo.502.1"> function gets a table name and column to perform feature engineering from </span><span><span class="kobospan" id="kobo.503.1">the spec.</span></span></p>
<h4 class="calibre16"><span class="kobospan" id="kobo.504.1">The Dockerfile</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.505.1">The Dockerfile </span><a id="_idIndexMarker521" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.506.1">encapsulates all the necessary commands required to build an image using Docker. </span><span class="kobospan" id="kobo.506.2">This file resembles what we’ve previously implemented in our service section, ensuring consistency and coherence across different Snowpark Container Services </span><span><span class="kobospan" id="kobo.507.1">environment components.</span></span></p>
<h4 class="calibre16"><span class="kobospan" id="kobo.508.1">The job specification file</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.509.1">The</span><a id="_idIndexMarker522" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.510.1"> following job specification file provides Snowflake with essential container configuration information. </span><span class="kobospan" id="kobo.510.2">Snowflake leverages the information provided in the </span><strong class="source-inline"><span class="kobospan" id="kobo.511.1">my_job_spec.yaml</span></strong><span class="kobospan" id="kobo.512.1"> specification file to configure and execute your job seamlessly. </span><span class="kobospan" id="kobo.512.2">In addition to mandatory fields such as </span><strong class="source-inline"><span class="kobospan" id="kobo.513.1">container.name</span></strong><span class="kobospan" id="kobo.514.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">container.image</span></strong><span class="kobospan" id="kobo.516.1">, this specification file includes optional fields such as </span><strong class="source-inline"><span class="kobospan" id="kobo.517.1">container.args</span></strong><span class="kobospan" id="kobo.518.1">, which list the arguments required for </span><span><span class="kobospan" id="kobo.519.1">job execution.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.520.1">
spec:
  container:
  - name: main
    image: /snowpark_definitive_guide/my_schema/snowpark_cs_repository/my_job_image:latest
    env:
      SNOWFLAKE_WAREHOUSE: compute_wh
    args:
    - "--table=NEWS_CATEGORY"
    - "--date_column=DATE"</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.521.1">Notably, the </span><strong class="source-inline"><span class="kobospan" id="kobo.522.1">--query</span></strong><span class="kobospan" id="kobo.523.1"> argument specifies the query to be executed when the job runs, while the </span><strong class="source-inline"><span class="kobospan" id="kobo.524.1">--result_table</span></strong><span class="kobospan" id="kobo.525.1"> argument identifies the table where the query results will </span><span><span class="kobospan" id="kobo.526.1">be stored.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.527.1">In the next section, we will deploy </span><span><span class="kobospan" id="kobo.528.1">the job.</span></span></p>
<h2 id="_idParaDest-143" class="calibre7"><a id="_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.529.1">Deploying the job</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.530.1">To</span><a id="_idIndexMarker523" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.531.1"> upload your job specification file (</span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">my_job_spec.yaml</span></strong><span class="kobospan" id="kobo.533.1">) into the Snowflake environment, you have a couple of options for uploading it to the </span><span><span class="kobospan" id="kobo.534.1">designated stage:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.535.1">Snowsight web interface</span></strong><span class="kobospan" id="kobo.536.1">: Utilizing</span><a id="_idIndexMarker524" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.537.1"> the Snowsight web interface offers a user-friendly approach to uploading your job specification file. </span><span class="kobospan" id="kobo.537.2">Following the instructions we have covered in previous chapters, you can effortlessly navigate the process and ensure </span><span><span class="kobospan" id="kobo.538.1">successful integration.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.539.1">SnowSQL command-line interface (CLI)</span></strong><span class="kobospan" id="kobo.540.1">: Alternatively, you can use the SnowSQL CLI to </span><a id="_idIndexMarker525" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.541.1">execute the file upload process by executing the following </span><strong class="source-inline1"><span class="kobospan" id="kobo.542.1">PUT</span></strong> <span><span class="kobospan" id="kobo.543.1">command syntax:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.544.1">PUT file://path/to/my_job_spec.yaml @snowpark_cs_stage/my_job_spec.yaml OVERWRITE=TRUE;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.545.1">Upon successfully executing the </span><strong class="source-inline"><span class="kobospan" id="kobo.546.1">PUT</span></strong><span class="kobospan" id="kobo.547.1"> command, detailed information regarding the uploaded file will be displayed </span><span><span class="kobospan" id="kobo.548.1">in Snowsight:</span></span></p></li> </ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer211">
<span class="kobospan" id="kobo.549.1"><img alt="Figure 8.19 – Job upload" src="image/B19923_08_19.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.550.1">Figure 8.19 – Job upload</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.551.1">Now that the job file has been uploaded, we will execute the job in the </span><span><span class="kobospan" id="kobo.552.1">next section.</span></span></p>
<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor148" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.553.1">Executing the job</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.554.1">To kick off </span><a id="_idIndexMarker526" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.555.1">the execution of a job, you’ll utilize the </span><strong class="source-inline"><span class="kobospan" id="kobo.556.1">EXECUTE SERVICE</span></strong><span class="kobospan" id="kobo.557.1"> command, which acts as the catalyst for launching the specified task. </span><span class="kobospan" id="kobo.557.2">Run the following command to trigger the job (this command may change since we are in private preview at the time </span><span><span class="kobospan" id="kobo.558.1">of writing):</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.559.1">
EXECUTE SERVICE IN COMPUTE POOL snowpark_cs_compute_pool
  FROM @snowpark_cs_stage SPEC='my_job_spec.yaml';</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.560.1">Alternatively, you can use </span><span><span class="kobospan" id="kobo.561.1">the following:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.562.1">
EXECUTE JOB SERVICE
  IN COMPUTE POOL snowpark_cs_compute_pool
  NAME = test_job
  FROM @SNOWPARK_CS_STAGE
  SPECIFICATION_FILE='my_job_spec.yaml';</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.563.1">The specified compute pool, </span><strong class="source-inline"><span class="kobospan" id="kobo.564.1">snowpark_cs_compute_pool</span></strong><span class="kobospan" id="kobo.565.1">, determines the allocation of computational resources necessary for the job’s successful execution. </span><span class="kobospan" id="kobo.565.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.566.1">@snowpark_cs_stage</span></strong><span class="kobospan" id="kobo.567.1"> notation denotes the designated stage within Snowflake where the job specification file is stored, facilitating seamless access to the required configuration details. </span><span class="kobospan" id="kobo.567.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.568.1">my_job_spec.yaml</span></strong><span class="kobospan" id="kobo.569.1"> file refers to the specific configuration file containing the instructions and parameters for executing the job seamlessly. </span><span class="kobospan" id="kobo.569.2">Successful execution of the command should display the </span><span><span class="kobospan" id="kobo.570.1">following output:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer212">
<span class="kobospan" id="kobo.571.1"><img alt="Figure 8.20 – Job execution" src="image/B19923_08_20.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.572.1">Figure 8.20 – Job execution</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.573.1">Upon execution, the job performs the specified SQL statement and saves the resultant data to a designated table, as outlined within the job specification file (</span><strong class="source-inline"><span class="kobospan" id="kobo.574.1">my_job_spec.yaml</span></strong><span class="kobospan" id="kobo.575.1">). </span><span class="kobospan" id="kobo.575.2">It’s crucial to note that the execution of the SQL statement does not </span><a id="_idIndexMarker527" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.576.1">occur within the Docker container itself. </span><span class="kobospan" id="kobo.576.2">Instead, the container connects with Snowflake, leveraging a Snowflake warehouse to execute the SQL statement efficiently. </span><span class="kobospan" id="kobo.576.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">EXECUTE SERVICE</span></strong><span class="kobospan" id="kobo.578.1"> command returns the</span><a id="_idIndexMarker528" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.579.1"> output containing vital information, including the Snowflake-assigned </span><strong class="bold"><span class="kobospan" id="kobo.580.1">UUID</span></strong><span class="kobospan" id="kobo.581.1"> (short for </span><strong class="bold"><span class="kobospan" id="kobo.582.1">Universally Unique Identifier</span></strong><span class="kobospan" id="kobo.583.1">) of the job. </span><span class="kobospan" id="kobo.583.2">This UUID serves as a unique identifier for the executed job, aiding in tracking and monitoring its progress </span><span><span class="kobospan" id="kobo.584.1">and status.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.585.1">In the next section, we will deploy an LLM for Snowpark </span><span><span class="kobospan" id="kobo.586.1">Container Services.</span></span></p>
<h1 id="_idParaDest-145" class="calibre5"><a id="_idTextAnchor149" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.587.1">Deploying LLMs with Snowpark</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.588.1">Modern enterprises</span><a id="_idIndexMarker529" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.589.1"> increasingly demand that LLMs be harnessed with proprietary data. </span><span class="kobospan" id="kobo.589.2">Open source and proprietary models play pivotal roles in enabling this transition. </span><span class="kobospan" id="kobo.589.3">However, the main challenge is finding a robust platform capable of effectively leveraging LLMs’ power. </span><span class="kobospan" id="kobo.589.4">Snowflake empowers organizations to apply near-magical generative AI transformations to their data. </span><span class="kobospan" id="kobo.589.5">By leveraging advanced LLM models within Snowflake, organizations can efficiently operate with large volumes of data, enabling generative AI use cases. </span><span class="kobospan" id="kobo.589.6">In this section, we will discuss deploying LLM models within Snowpark </span><span><span class="kobospan" id="kobo.590.1">Container Services.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.591.1">In this walk-through, we’ll explore how to harness publicly accessible data to demonstrate the transformative capabilities of Snowflake’s ecosystem by deploying the Llama 2 LLM from the Hugging </span><span><span class="kobospan" id="kobo.592.1">Face repository.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.593.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.594.1">Llama 2 by Meta, housed within Hugging Face’s library, epitomizes advanced </span><strong class="bold"><span class="kobospan" id="kobo.595.1">natural language processing</span></strong><span class="kobospan" id="kobo.596.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.597.1">NLP</span></strong><span class="kobospan" id="kobo.598.1">) technology. </span><span class="kobospan" id="kobo.598.2">As </span><a id="_idIndexMarker530" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.599.1">stipulated by Meta’s specific terms of service, you’ll need a Hugging Face token to access Llama 2 with Hugging Face. </span><span class="kobospan" id="kobo.599.2">Please visit </span><a href="https://huggingface.co/docs/hub/en/security-tokens" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.600.1">https://huggingface.co/docs/hub/en/security-tokens</span></a><span class="kobospan" id="kobo.601.1"> to </span><span><span class="kobospan" id="kobo.602.1">learn more.</span></span></p>
<h2 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor150" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.603.1">Preparing the LLM</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.604.1">We </span><a id="_idIndexMarker531" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.605.1">will start by preparing the LLM by utilizing our convenient wrapper around the Hugging Face Transformers API, and harness the capabilities of Llama 2 7B from Hugging Face. </span><span class="kobospan" id="kobo.605.2">To achieve this, run the </span><span><span class="kobospan" id="kobo.606.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.607.1">
HF_AUTH_TOKEN = " ************************* "
registry = model_registry.ModelRegistry(session=session, database_name="SNOWPARK_DEFINITIVE_GUIDE", schema_name="MY_SCHEMA", create_if_not_exists=True)
llama_model = huggingface_pipeline.HuggingFacePipelineModel(task="text-generation", model="meta-llama/Llama-2-7b-chat-hf", token=HF_AUTH_TOKEN, return_full_text=False, max_new_tokens=100)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.608.1">Make sure to replace </span><strong class="source-inline"><span class="kobospan" id="kobo.609.1">HF_AUTH_TOKEN</span></strong><span class="kobospan" id="kobo.610.1"> with your token from Hugging Face. </span><span class="kobospan" id="kobo.610.2">The code creates the model registry and assigns the model from the Hugging Face registry. </span><span class="kobospan" id="kobo.610.3">The model is obtained from the Hugging Face registry and directly imported </span><span><span class="kobospan" id="kobo.611.1">into Snowpark.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.612.1">Next, we will register the model within </span><span><span class="kobospan" id="kobo.613.1">Snowpark ML.</span></span></p>
<h2 id="_idParaDest-147" class="calibre7"><a id="_idTextAnchor151" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.614.1">Registering the model</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.615.1">Next, we’ll utilize</span><a id="_idIndexMarker532" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.616.1"> the model registry’s </span><strong class="source-inline"><span class="kobospan" id="kobo.617.1">log_model</span></strong><span class="kobospan" id="kobo.618.1"> API within Snowpark ML to register the model. </span><span class="kobospan" id="kobo.618.2">This involves specifying a model name and a version string and providing the model obtained in the </span><span><span class="kobospan" id="kobo.619.1">previous step:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.620.1">
MODEL_NAME = "LLAMA2_MODEL_7b_CHAT"
MODEL_VERSION = "1"
llama_model=registry.log_model(
    model_name=MODEL_NAME,
    model_version=MODEL_VERSION,
    model=llama_model
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.621.1">You should see an output similar to </span><span><span class="kobospan" id="kobo.622.1">the following:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer213">
<span class="kobospan" id="kobo.623.1"><img alt="Figure 8.21 – Model registration" src="image/B19923_08_21.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.624.1">Figure 8.21 – Model registration</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.625.1">The model</span><a id="_idIndexMarker533" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.626.1"> is now registered in the registry. </span><span class="kobospan" id="kobo.626.2">Now that the model is ready, we will deploy it to </span><span><span class="kobospan" id="kobo.627.1">Container Services.</span></span></p>
<h2 id="_idParaDest-148" class="calibre7"><a id="_idTextAnchor152" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.628.1">Deploying the model to Snowpark Container Services</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.629.1">Now, let </span><a id="_idIndexMarker534" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.630.1">us deploy the model to our designated compute pool. </span><span class="kobospan" id="kobo.630.2">Once the deployment process is initiated, the model will become accessible as a Snowpark Container Services endpoint. </span><span class="kobospan" id="kobo.630.3">Run the following code to deploy the model to Container Services. </span><span class="kobospan" id="kobo.630.4">To run this step, you may need to alter your compute pool to include a GPU instance, or you can create a new compute pool with a </span><span><span class="kobospan" id="kobo.631.1">GPU instance.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.632.1">
llama_model.deploy(
  deployment_name="llama_predict",
  platform=deploy_platforms.TargetPlatform.SNOWPARK_CONTAINER_SERVICES,
  options={
            "compute_pool": "snowpark_cs_compute_pool",
            "num_gpus": 1
  },
)
"external_access_integrations": ["ALLOW_ALL_ACCESS_INTEGRATION"]</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.633.1">This streamlined deployment process highlights how Snowpark ML simplifies the deployment of LLMs, handling the creation of the corresponding Snowpark Container Services </span><strong class="source-inline"><span class="kobospan" id="kobo.634.1">SERVICE</span></strong><span class="kobospan" id="kobo.635.1"> definition, packaging the model within a Docker image along with its runtime dependencies, and launching the service within the specified </span><span><span class="kobospan" id="kobo.636.1">compute pool.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.637.1">After executing the code, you should see a </span><span><span class="kobospan" id="kobo.638.1">similar output:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer214">
<span class="kobospan" id="kobo.639.1"><img alt="Figure 8.22 – Deploying the LLM model to Snowpark Container Services" src="image/B19923_08_22.0.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.640.1">Figure 8.22 – Deploying the LLM model to Snowpark Container Services</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.641.1">In the next section, we</span><a id="_idIndexMarker535" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.642.1"> will execute this model in </span><span><span class="kobospan" id="kobo.643.1">the container.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.644.1">Note on model deployment</span></p>
<p class="callout"><span class="kobospan" id="kobo.645.1">Only the snippets required for explanation are shown in this section. </span><span class="kobospan" id="kobo.645.2">The complete code is available in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.646.1">chapter_8.ipynb</span></strong><span class="kobospan" id="kobo.647.1"> notebook in GitHub. </span><span class="kobospan" id="kobo.647.2">You should be mindful of the model deployment step as it takes considerable time </span><span><span class="kobospan" id="kobo.648.1">and resources.</span></span></p>
<h2 id="_idParaDest-149" class="calibre7"><a id="_idTextAnchor153" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.649.1">Running the model</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.650.1">Invoke the model by</span><a id="_idIndexMarker536" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.651.1"> supplying the subset of the </span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">NEWS_CATEGORY</span></strong><span class="kobospan" id="kobo.653.1"> table with the </span><strong class="source-inline"><span class="kobospan" id="kobo.654.1">inputs</span></strong><span class="kobospan" id="kobo.655.1"> column containing </span><span><span class="kobospan" id="kobo.656.1">the prompt:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.657.1">
res = llama_model_ref.predict( deployment_name=DEPLOYMENT_NAME, data=input_df )</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.658.1">This yields a Snowpark DataFrame with an output column containing the model’s response for each row. </span><span class="kobospan" id="kobo.658.2">The raw response intersperses text with the expected JSON output, exemplified </span><span><span class="kobospan" id="kobo.659.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.660.1">
{
  "category": "Art",
  "keywords": [
    "Gertrude",
    "contemporary art",
    "democratization",
    "demystification"
  ],
  "importance": 9
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.661.1">Deploying and </span><a id="_idIndexMarker537" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.662.1">executing an LLM model is very easy with Snowpark </span><span><span class="kobospan" id="kobo.663.1">Container Services.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.664.1">We will conclude the chapter with </span><span><span class="kobospan" id="kobo.665.1">a summary.</span></span></p>
<h1 id="_idParaDest-150" class="calibre5"><a id="_idTextAnchor154" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.666.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.667.1">In this chapter, we explored Snowpark Container Services, a powerful solution designed to simplify the deployment and management of containerized applications within the Snowflake ecosystem. </span><span class="kobospan" id="kobo.667.2">We discussed the distinction between jobs and services within Snowpark Container Services, highlighting their respective functionalities and use cases. </span><span class="kobospan" id="kobo.667.3">We demonstrated how to effectively configure, deploy, and manage jobs and services through practical </span><span><span class="kobospan" id="kobo.668.1">implementation examples.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.669.1">Additionally, we delved into containerization through Snowpark ML, showcasing how Snowflake users can seamlessly leverage advanced ML models within their environment. </span><span class="kobospan" id="kobo.669.2">By integrating a language model from Hugging Face, we illustrated how Snowpark ML facilitates the integration of containerized models, enabling sophisticated NLP tasks directly within Snowflake. </span><span class="kobospan" id="kobo.669.3">Overall, this chapter equips you with the knowledge and tools to harness the transformative potential of SCS and Snowpark ML in your </span><span><span class="kobospan" id="kobo.670.1">data-driven initiatives.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.671.1">In conclusion, Snowpark Container Services offers a compelling value proposition for businesses seeking efficient and scalable data processing solutions. </span><span class="kobospan" id="kobo.671.2">By enabling secure execution of containerized workloads directly within Snowflake, Snowpark eliminates the need for data movement, ensuring data integrity and reducing latency. </span><span class="kobospan" id="kobo.671.3">Additionally, Snowpark simplifies the development and deployment of data applications, allowing teams to focus on innovation rather than infrastructure management. </span><span class="kobospan" id="kobo.671.4">Automated container management further streamlines operational tasks, enhancing overall productivity </span><span><span class="kobospan" id="kobo.672.1">and agility.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.673.1">With this, we conclude the book. </span><span class="kobospan" id="kobo.673.2">Thank you </span><span><span class="kobospan" id="kobo.674.1">for reading.</span></span></p>
</div>
</body></html>