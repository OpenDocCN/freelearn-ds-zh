- en: Chapter 3. Managing Your Workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the behavior of R objects is compared to game rules, then the workspace
    can be compared to the playground. To play the game well, you need to familiarize
    yourself not only with the rules, but also with the playground. In this chapter,
    I will introduce to you some basic but important skills to manage your workspace.
    These skills include:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting the working environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying global options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the library of packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R's working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An R session always starts in a directory, no matter whether it is launched
    as an R terminal or in RStudio. The directory in which R is running is called
    the **working directory** of the R session. When you access other files on your
    hard drive, you can use either absolute paths (for example, `D:\Workspaces\test-project\data\2015.csv`)
    in most cases or relative paths (for example, `data\2015.csv`) with the right
    working directory (in this case, `D:\Workspaces\test-project`).
  prefs: []
  type: TYPE_NORMAL
- en: The use of relative paths to the working directory does not change the file
    paths, but the way you specify them is shorter. It also makes your scripts more
    portable. Imagine you are writing some R scripts to produce graphics according
    to a bunch of data files in a directory. If you write the directory as an absolute
    path, then anyone else who wants to run your script on their own computer would
    have to modify the paths in your code to the location of the data in their hard
    drives. However, if you write the directory as a relative path, then if the data
    is kept in the same relative location, the script will work without any modification.
  prefs: []
  type: TYPE_NORMAL
- en: In an R terminal, you can get the current working directory of the running R
    session using `getwd()`. By default, commandR starts a new R session from your
    user directory, and RStudio runs an R session in the background from your user
    documents directory.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the defaults, you can choose a directory and create an R project
    in RStudio. Then, every time you open that project, the working directory is the
    location of the project, which makes it super easy to access files in the project
    directory using relative paths, which improves the portability of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an R project in RStudio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new project, simply go to **File **| **New Project** or click the
    Project drop-down menu in the top-right corner of the main window and choose **New
    Project**. A window will appear, and you can create a new directory or choose
    an existing directory on your hard drive as the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an R project in RStudio](img/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you choose a local directory, the project will be created there. An R project
    is nothing but a `.Rproj` file that stores some settings. If you open such a project
    file in RStudio, the settings in it will be applied, and the working directory
    will be set to the directory in which the project file is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful point in using RStudio to work in a project is that auto-completion
    makes writing file paths much more efficient. When you are typing a string of
    either an absolute or relative file path, press *Tab* and RStudio will list the
    files in that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an R project in RStudio](img/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comparing absolute and relative paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since I''m writing this book with RMarkdown in RStudio, the working directory
    is the directory of my book project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that the working directory mentioned earlier uses `/` instead
    of `\`. In Windows operating systems, `\` is the default path separator, but this
    symbol is already used to make special characters. For example, when you create
    a character vector, you can use `\n` to represent a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Special characters are preserved when the character vector is directly printed
    as a representation of the string. However, if you add `cat()` to it, the string
    will be written in the console with the escape characters translated to the characters
    they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The second word starts by a new line (`\n`) as normal. However, if `\` is so
    special, how should we write `\` itself? Just use `\\`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That is why we should use `\\` or `/` in paths in Windows operating systems
    since both are supported. In Unix-like operating systems, such as macOS and Linux,
    things are easier: always use `/`. If you are using Windows and misuse `\` to
    refer to a file, an error will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you need to write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, we can use `/` in Windows in most cases, which makes the same
    code runnable in nearly all popular operating systems using relative paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Instead of getting the working directory using `getwd()`, we can also set the
    working directory of the current R session using `setwd()`. However, this is almost
    always not recommended because it can direct all relative paths in a script to
    another directory and make everything go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a good practice is to create an R project to start your work.
  prefs: []
  type: TYPE_NORMAL
- en: Managing project files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we create a project in RStudio, a `.Rproj` file is also created in the
    project directory in which there is no other file at the moment. Since R is related
    to statistical computing and data visualization, an R project mainly contains
    R scripts that do statistical computing (or other programming tasks), data files
    (such as `.csv` files), documents (such as Markdown files), and sometimes output
    graphics.
  prefs: []
  type: TYPE_NORMAL
- en: If different types of file are mixed up in the project directory, it will be
    increasingly more difficult to manage these project files, especially as input
    data accumulates or output data and graphics clutter the directory.
  prefs: []
  type: TYPE_NORMAL
- en: A recommended practice is to create subdirectories to contain different types
    of files resulting from different types of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following directory structure is plain, with all files together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, the following directory structure is much cleaner and nicer to
    work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding directory structures, directories are represented in the form
    of `directory/` and files in the form of `file-name.ext`. In most cases, the second
    structure is recommended because, as project needs and tasks become more complex,
    the first structure will end up in a mess while the second structure will remain
    tidy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the structure issue, it is common to write the project introduction
    in `README.md` and put additional notes in `NOTES.md`. These two documents are
    Markdown documents (`.md`), and it is worth becoming familiar with its extremely
    simple syntax. Read *Daring Fireball: Markdown Syntax Documentation* ([https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax))
    and *GitHub Help: Markdown Basics* ([https://help.github.com/articles/markdown-basics/](https://help.github.com/articles/markdown-basics/))
    for details. We will cover the topic of combining R and Markdown in [Chapter 15](ch15.html
    "Chapter 15. Boosting Productivity"), *Boosting Productivity*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now the working directory is ready. In the next section, you will learn various
    methods to inspect the working environment in an R session.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In R, every expression is evaluated within a specific environment. An environment
    is a collection of symbols and their bindings. When we bind a value to a symbol,
    call a function, or refer to a name, R will find the symbols in the current environment.
    If you type commands in the RStudio console, your commands are evaluated in the
    **Global Environment**.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we start a fresh R session in a terminal or RStudio, we start
    working within an empty global environment. In other words, there is no symbol
    defined in this environment. If we run `x <- c(1, 2, 3)`, the numeric vector `c(1,
    2, 3)` is bound to symbol `x` in the global environment. Then, the global environment
    has one binding that maps `x` to the vector `c(1, 2, 3)`. In other words, if you
    evaluate `x`, then you will get its value.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting existing symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to manipulating vectors and lists as we did in the previous chapter,
    we need to know some basic functions to inspect and manipulate our working environment.
    The most basic but useful function to inspect the collection of objects we are
    working with is `objects()`. The function returns a character vector of the names
    of existing objects in the current environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a fresh R session, there should not be any symbol in the current environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume we create the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will get a character vector of the existing object names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Many developers prefer `ls()` as an alias of `objects()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, especially when you are working in RStudio, you don''t have
    to use `objects()` or `ls()` to see what symbols have been created because the
    **Environment** pane shows all symbols available in the global environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting existing symbols](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Environment** pane shows symbols and their values in a compact representation.
    You can interact with objects in it by expanding a list or data frame and viewing
    the vectors inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the list view, the **Environment** pane also provides an alternative
    grid view. The grid view shows not only the names, types, and the value structures
    of existing objects, but also their object sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting existing symbols](img/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although the **Environment** pane in RStudio makes it straightforward to inspect
    all existing variables, `objects()` or `ls()` can be still useful when RStudio
    is not available, when you write a function to work with their names, or the objects
    are provided dynamically in different manners.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the structure of an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the **Environment** pane, the compact representation of an object comes from
    the `str()` function, which prints the structure of a given object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when `str()` is applied to a simple numeric vector, it shows its
    type, positions, and a preview of its values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the vector has more than 10 elements, `str()` will only show the first 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For a list, directly evaluating it in the console or using `print()` will show
    the elements in a verbose form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, `str()` shows its type, length, and the structure preview of
    the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume we created the following nested list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Directly printing will show all its elements and tell us how we can access
    them which can be long and unnecessary in most cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a compact representation that is easier to view and work with, call
    `str()` with a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'While `str()` shows the structure of an object, `ls.str()` shows the structure
    of the current environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Its functionality is similar to that of the **Environment** pane in RStudio
    and can be useful when you need to inspect a customized environment or only show
    the structures of some particular variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'One filter for `ls.str()` is the mode argument. You can show the structures
    of all values that are list objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The other filter is the pattern argument, which specifies the pattern of the
    names to match. The pattern is expressed in a **regular expression**. If you want
    to show the structures of all variables whose names contain only one character,
    you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to show the structures of all list objects whose names contain
    only one character, you can use both pattern and mode at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you're put off by commands such as `^\\w$`, don't worry. This pattern matches
    all strings in the form of `(string begin)(any one word character like a, b, c)(string
    end)`. We will cover this powerful tool in [Chapter 6](ch06.html "Chapter 6. Working
    with Strings"), *Working with Strings*.
  prefs: []
  type: TYPE_NORMAL
- en: Removing symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only created symbols. Sometimes, it can be useful to remove
    them. The `remove()` function, or equivalently `rm()`, removes existing symbols
    from the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before removing `x`, the symbols in the environment are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will use `rm()` to remove `x` from the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the function also works with variable names in strings. Therefore,
    `rm("x")` has exactly the same effect. We can also remove multiple symbols in
    one function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If the symbol to be removed does not exist in the environment, a warning will
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rm()` function can also remove all symbols specified by a character vector
    of symbol names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to clear all the bindings in an environment, we can combine `rm()`
    and `ls()` and call the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now there's no symbol in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, removing symbols is not necessary, but it can be useful to remove
    very large objects that occupy a big area of memory. If R feels memory pressure,
    it will clean up unused objects with no bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying global options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of creating, inspecting, and removing objects in the working environment,
    R options have effects in the global scale of the current R session. We can call
    `getOption()` to see the value of a given option and call `options()` to modify
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the number of digits to print
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In RStudio, when you type `getOption(<Tab>)`, you can see a list of available
    options and their descriptions. A commonly used option, for instance, is the number
    of digits to display. Sometimes, it is not sufficient when we deal with numbers
    requiring higher precision. In an R session, the number of digits printed on screen
    is entirely managed by digits. We can call `getOption()` to see the current value
    of digits and call `options()` to set `digits` to a larger number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying the number of digits to print](img/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When an R session starts, the default value of digits is 7\. To demonstrate
    its effect, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It is obvious that the 11-digit number is only shown with 7 digits. This means
    the last few decimal digits are gone; the printer only displays the number with
    7 digits. To verify no precision is lost because of `digits = 7`, see the output
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If the numbers are rounded to the seventh decimal place by default, then `0.10000002`
    should be rounded to `0.1` and the second expression should result in `0`. However,
    apparently, this does not happen because `digits = 7` only means the number of
    numeric digits to be displayed rather than rounded up.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in some cases, the number before the decimal point can be large, and
    we don''t want to ignore digits following the decimal point. Without modifying
    digits, the following number will only display the integer part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to see more digits printed, we need to increase digits from the
    default value 7 to a higher number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that once, `options()` is called, the modified options take effect immediately
    and may affect the behavior of all subsequent commands. To reset options, use
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the warning level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another options example managing the warning level by specifying the value
    of the `warn` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the warning level is `0`, which means a warning is a warning and
    an error is an error. In this state, a warning will be displayed but will not
    stop the code, while an error terminates the code immediately. If multiple warnings
    occur, they will be combined and displayed together. For example, the following
    conversion from a string to a numeric vector will produce a warning and result
    in a missing value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make it completely silent and still get a missing value from the unsuccessful
    conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Then, the warning is gone. Making the warning messages disappear is almost always
    a bad idea. It will make potential errors silent. You can (or cannot) realize
    something is wrong from the final result. The recommendation is to be strict in
    your code and save a lot of time debugging it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting warn to 1 or 2 will make buggy code fail fast. When `warn = 0`, the
    default behavior for evaluating a function call is to first return the value and
    then show all the warning messages together, if any. To demonstrate this behavior,
    the following function is called with two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'At the default warning level, all warning messages are shown after the function
    returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The function coerces two input arguments to numeric vectors. As the input arguments
    are both strings, two warnings will be produced, but will only appear after the
    function returns. If the preceding function does some heavy work and takes a considerable
    period of time, you won't see any warning before you get the final result but
    in fact the intermediate computing has been way off the correct results for quite
    a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'This prompts the use of `warn = 1`, which forces the warning message to be
    printed as soon as a warning is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same, but the warning messages appear ahead of the result.
    If the function is time-consuming, we should be able to see the warning messages
    first. So, we can choose to stop the code and check whether something is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: A warning level is even stricter. The `warn = 2` argument directly regards any
    warning as an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: These options have effects in the global scale. Therefore, it is convenient
    to manage common aspects of an R session, but it can also be dangerous to change
    options. Just like changing the working directory may invalidate all relative
    paths in the script from running, changing global options may break all subsequent
    code that is based on incompatible assumptions of the global options.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is not recommended to modify global options unless absolutely
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the library of packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In R, packages play an indispensable role in data analysis and visualization.
    In fact, R itself is only a tiny core and is built on several basic packages.
    A package is a container of predefined functions, which are often designed to
    be general enough to solve a certain range of problems. Using a well-designed
    package, we don't have to reinvent the wheel again and again, which allows us
    to focus more on the problem we are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: R is powerful not only because of its rich source of packages, but also because
    of the well-maintained package archive system called *The Comprehensive R Archive
    Network*, or CRAN ([http://cran.r-project.org/](http://cran.r-project.org/)).
    The source code of R and thousands of packages is archived in this system. At
    the time of writing, there are 7,750 active packages on CRAN maintained by more
    than 4,500 package maintainers around the world. Every week, more than 100 packages
    will be updated and more than 2 million package downloads happen. You can check
    out the table of packages at [https://cran.rstudio.com/web/packages/](https://cran.rstudio.com/web/packages/)
    in which all the packages currently available are listed.
  prefs: []
  type: TYPE_NORMAL
- en: Just don't panic when you hear the number of packages on CRAN! The number is
    large and the coverage is wide, but you only have to learn a small fraction of
    them. If you focus on the work of a specific field, it is very likely that there
    are no more than 10 packages that are heavily related to your work and field.
    Therefore, there's absolutely no need for you to know all the packages (nobody
    can or even need to), but only the most useful and field-related ones.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of finding packages in the table, which is not that informative, I recommend
    that you visit CRAN Task Views ([https://cran.rstudio.com/web/views/](https://cran.rstudio.com/web/views/))
    and METACRAN [http://www.r-pkg.org/](http://www.r-pkg.org/), and get started by
    learning about the packages that are most commonly used or closely related to
    your working field. Before learning how to use a specific package, we need to
    have a general idea about installing packages from different sources and understand
    how a package basically works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know a package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A package is a collection of functions to solve a certain range of problems.
    It can be an implementation of a family of statistical estimators, data-mining
    methods, database interfaces, or optimization tools. To know more about a package,
    for example, ggplot2, a super powerful graphics package, several information sources
    are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Package description page** ([https://cran.rstudio.com/web/packages/ggplot2/](https://cran.rstudio.com/web/packages/ggplot2/)):
    The page contains the basic information about the package, including the name,
    description, version, publishing date, authors, related websites, reference manuals,
    vignettes, relationship to other packages, and so on. The description page of
    a package is provided not only by CRAN, but by some other third-party package
    information websites. METACRAN also provides a description of ggplot2 at [http://www.r-pkg.org/pkg/ggplot2](http://www.r-pkg.org/pkg/ggplot2).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package website (**[http://ggplot2.org/](http://ggplot2.org/)): The webpage
    contains a description and related resources for the package, such as blogs, tutorials,
    and books. Not every package has a website, but if one does the website is the
    official starting point for learning about the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package source code** ([https://github.com/hadley/ggplot2](https://github.com/hadley/ggplot2)):
    The authors host the source code of the package on GitHub ([https://github.com](https://github.com)),
    and the page is the source code the package. If you are interested in the implementation
    of the package functions, you can check out the source code and take a look. If
    you find some unexpected behavior that looks like a bug, you can report it at [https://github.com/hadley/ggplot2/issues](https://github.com/hadley/ggplot2/issues).
    Also, you can file an issue at the same place to request a new feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading the package description, you can try it by installing the package
    to the R library.
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages from CRAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CRAN archives R packages and distributes them to more than 120 mirrors around
    the world. You can visit CRAN Mirrors ([https://cran.r-project.org/mirrors.html](https://cran.r-project.org/mirrors.html))
    and check out a nearby mirror. If you find one, you can go to **Tools** | **Global
    Options** and open the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing packages from CRAN](img/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can change the CRAN mirror to a nearby one or simply use the default mirror.
    In general, you will experience very fast downloading if you use a nearby mirror.
    In recent months, some mirrors have started using HTTPS to secure data transfers.
    If **Use secure download method for HTTP** is checked, then you can only view
    HTTPS mirrors.
  prefs: []
  type: TYPE_NORMAL
- en: Once a mirror is chosen, to download and install a package in R becomes extremely
    easy. Just call `install.packages("ggplot2")`, and R will automatically download
    the package, install it, and sometimes compile it.
  prefs: []
  type: TYPE_NORMAL
- en: 'RStudio also provides an easy way to install packages. Just go to the Packages
    pane and click on **Install**. The following dialog appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing packages from CRAN](img/image_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the package description shows, a package may depend on other packages. In
    other words, when you call a function in the package, the function also calls
    some functions in other packages, which requires that you also install those packages
    as well. Fortunately, `install.packages()` is smart enough to know the dependency
    structure of the package to install and will install those packages first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main page of METACRAN ([http://www.r-pkg.org/](http://www.r-pkg.org/)),
    featured packages are those with the most stars on GitHub. That is, these packages
    are marked by many GitHub users. You may want to install multiple featured packages
    in one call, which is naturally allowed if you write the package names as a character
    vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Then the `install.packages()` function automatically resolves the joint dependency
    structure of all these packages and installs them.
  prefs: []
  type: TYPE_NORMAL
- en: Updating packages from CRAN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the `install.packages()` function installs the latest version of
    the specified packages. Once they are installed, the package version stays fixed.
    However, the packages may be updated to fix bugs or add new features. Sometimes,
    an updated version of a package may deprecate functions in older versions with
    warnings. In these cases, we may keep the package out-of-date, or update it after
    reading the `NEWS` package, which can be found in the package description (for
    example, [https://cran.r-project.org/web/packages/ggplot2/news.html](https://cran.r-project.org/web/packages/ggplot2/news.html); see
    this for details about the new version in the case of breaking changes).
  prefs: []
  type: TYPE_NORMAL
- en: 'RStudio provides an **Update** button next to **Install** in the package pane.
    We can also use the following function and choose which packages are going to
    be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Both RStudio and the preceding function scan newer versions of packages and
    install these packages along with dependencies if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages from online repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nowadays, many package authors host their work on GitHub because version control
    and community development are very easy, thanks to the well-designed issue-tracking
    systems and merge request system. Some authors do not release their work to CRAN,
    and others only release the stable versions to CRAN and keep new versions under
    development on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try the latest development version, which often has new features
    or has fixed some bugs, you can directly install the package from the online repository
    using the devtools package.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the devtools package if it does not appear in your library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use `install_github()` in the devtools package to install the latest
    development version of ggplot2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The devtools package will download the source code from GitHub and makes it
    a package in your library. If your library has already got the package, the installation
    will replace it without asking. If you want to revert the development version
    to the latest CRAN version, you can run the CRAN installing code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Then, the local version (GitHub version) is replaced by the CRAN version.
  prefs: []
  type: TYPE_NORMAL
- en: Using package functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to use the functions in a package. First, we can call `library()`
    to attach the package so that the functions in it can be directly called. Second,
    we can call `package::function()` to only use the function without attaching the
    whole package to the environment.
  prefs: []
  type: TYPE_NORMAL
- en: For example, some statistical estimators are not implemented as built-in functions
    in base R but in other packages. One instance is skewness; the statistical function
    is provided by the moments package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the skewness of numeric vector `x`, we can attach the package
    first and directly call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can call package functions without attaching the package,
    using `::`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The two methods return the same result, but they work in different ways and
    have a different impact on the environment. More specifically, the first method
    (using `library()`) modifies the search path of symbols, whereas the second method
    (using `::`) does not. When you call `library(moments)`, the package is attached
    and added to the search path so that the package functions are directly available
    in subsequent code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is useful to see what packages we are using by calling `sessionInfo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The session info shows the R version and lists the attached packages and loaded
    packages. When we use `::` to access a function in a package, the package is not
    attached but loaded in memory. In this case, other functions in the package are
    still not directly available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the moments package is loaded but not attached. When we `calllibrary(moments)`,
    the package will be attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Then, `skewness()` as well as other package functions in moments are directly
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier way to see attached packages is `search()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The function returns the current search path of symbols. When you evaluate a
    function call that uses skewness, it finds a skewness symbol in the current environment
    first. Then, it goes to `package:moment` and the symbol is found. If the package
    is not attached, the symbol will not be found, so an error will occur. We will
    cover this symbol-finding mechanism in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach a package, `require()` is similar to `library()`, but it returns
    a logical value to indicate whether the package is successfully attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature allows the following code to attach a package if it is installed
    or install it if it is not yet installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, most uses of the `require()` function in user code are not like this.
    The following is typical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks equivalent to using `library()` but has a silent drawback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the package to attach is not installed or even does not exist at all (maybe
    a typo), `require()` only produces a warning instead of an error like that produced
    by `library()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine you are running a long and time-consuming R script that depends on
    several packages. If you use `require()` and unfortunately the computer running
    your script does not happen to have installed the required packages, the script
    will only fail later, when the package function is being called and the function
    is not found. However, if you use `library()` instead, the script will stop immediately
    if the packages do not exist on the running computer. Yihui Xie wrote a blog ([http://yihui.name/en/2014/07/library-vs-require/](http://yihui.name/en/2014/07/library-vs-require/))
    on this issue and proposes the *fail fast* principle: if the task has to fail,
    it is better to fail fast.'
  prefs: []
  type: TYPE_NORMAL
- en: Masking and name conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fresh R session starts with basic packages automatically attached. The basic
    packages refer to base, stats, graphics, and so on. With these packages attached,
    you can calculate the average of a numeric vector using `mean()` and the median
    of it using `median()`, without using `base::mean()` and `stats::median()` or
    having to manually attach `base` and `stats` packages.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, thousands of functions are immediately available from automatically
    attached packages, and each package defines a number of functions for a particular
    purpose. Therefore, it is likely that the functions in two packages conflict with
    each other. For example, suppose two packages A and B both have a function named
    X. If you attach A and then attach B, the function A::X will be masked by the
    function B::X. In other words, when you attach A and you call `X()`, then A's
    X is called. Then, you attach B and call `X()`; it is now B's X that is called.
    This mechanism is known as **masking**. The following example shows what happens
    when masking occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The powerful data manipulation package dplyr defines a family of functions
    that make it easier to manipulate tabular data. When we attach the package, some
    messages are printed to show you that some existing functions are masked by the
    package functions with the same names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, the implementation of these functions in `dplyr` does not change
    the meaning and usage, but generalizes them. These functions are compatible with
    the masked version. Therefore, you don't have to worry that the masked functions
    are broken and no longer work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package functions that mask basic functions almost always generalize rather
    than replace. However, if you have to use two packages in which some functions
    share the same names, you had better not attach either package; instead, extract
    the functions from both packages you need, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you happen to attach one package and want to detach it, you can call `unloadNamespace()`.
    For example, we have attached moments and we can detach it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as the package is detached, the package functions are no longer directly
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can still use `::` to call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether a package is installed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is useful to know that `install.packages()` performs the installation, while `installed.packages()`
    shows information about the installed packages, which is a matrix of 16 columns
    that covers a wide range of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be useful when you need to check whether a package is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you need to check the version of a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A simpler way to get the package version is using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compare two package versions so that we can check whether a package
    is newer than a given version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we can directly use a string version to perform the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Checking package versions can be useful if your scripts depend on some packages
    that must be equal to or newer than, a specific version. This can be true if your
    scripts rely on some of the new features introduced in that version. In addition,
    `packageVersion()` will produce an error if a package is not installed, which
    also makes it check the package installation status.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the working-directory concept and tools dealing
    with it. You also explored functions to inspect the working environment, modify
    global options, and manage the library of packages. Now, you have the basic knowledge
    to manage your workspace.
  prefs: []
  type: TYPE_NORMAL
- en: In this next chapter, you will learn several basic expressions, including assignment,
    condition, and loop. These expressions are the building blocks of program logic.
    I will show you how to write efficient and robust control-flow expressions in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
