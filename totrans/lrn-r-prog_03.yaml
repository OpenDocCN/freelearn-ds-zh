- en: Chapter 3. Managing Your Workspace
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 管理你的工作空间
- en: 'If the behavior of R objects is compared to game rules, then the workspace
    can be compared to the playground. To play the game well, you need to familiarize
    yourself not only with the rules, but also with the playground. In this chapter,
    I will introduce to you some basic but important skills to manage your workspace.
    These skills include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将R对象的行性行为比作游戏规则，那么工作空间可以比作游乐场。为了玩好这个游戏，你需要熟悉规则，也要熟悉游乐场。在本章中，我将向你介绍一些基本但重要的技能来管理你的工作空间。这些技能包括：
- en: Using the working directory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作目录
- en: Inspecting the working environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查工作环境
- en: Modifying global options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改全局选项
- en: Managing the library of packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理包的库
- en: R's working directory
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R的工作目录
- en: An R session always starts in a directory, no matter whether it is launched
    as an R terminal or in RStudio. The directory in which R is running is called
    the **working directory** of the R session. When you access other files on your
    hard drive, you can use either absolute paths (for example, `D:\Workspaces\test-project\data\2015.csv`)
    in most cases or relative paths (for example, `data\2015.csv`) with the right
    working directory (in this case, `D:\Workspaces\test-project`).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是作为R终端还是RStudio启动，R会话总是从一个目录开始。R正在运行的目录被称为R会话的**工作目录**。当你访问硬盘上的其他文件时，你可以使用绝对路径（例如，`D:\Workspaces\test-project\data\2015.csv`）在大多数情况下，或者使用正确的**工作目录**（在这种情况下，`D:\Workspaces\test-project`）的相对路径（例如，`data\2015.csv`）。
- en: The use of relative paths to the working directory does not change the file
    paths, but the way you specify them is shorter. It also makes your scripts more
    portable. Imagine you are writing some R scripts to produce graphics according
    to a bunch of data files in a directory. If you write the directory as an absolute
    path, then anyone else who wants to run your script on their own computer would
    have to modify the paths in your code to the location of the data in their hard
    drives. However, if you write the directory as a relative path, then if the data
    is kept in the same relative location, the script will work without any modification.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相对于工作目录的路径并不会改变文件路径，但指定它们的方式更短。这也会使你的脚本更易于移植。想象一下，你正在编写一些R脚本，根据目录中的一系列数据文件生成图形。如果你将目录作为绝对路径写入，那么任何想要在自己的电脑上运行你的脚本的人都需要修改代码中的路径，以匹配他们硬盘上数据的位置。然而，如果你将目录作为相对路径写入，那么如果数据保持在相同的相对位置，脚本将无需任何修改即可运行。
- en: In an R terminal, you can get the current working directory of the running R
    session using `getwd()`. By default, commandR starts a new R session from your
    user directory, and RStudio runs an R session in the background from your user
    documents directory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在R终端中，你可以使用`getwd()`函数获取当前R会话的工作目录。默认情况下，commandR从你的用户目录启动一个新的R会话，而RStudio则在你的用户文档目录的背景中运行一个R会话。
- en: Apart from the defaults, you can choose a directory and create an R project
    in RStudio. Then, every time you open that project, the working directory is the
    location of the project, which makes it super easy to access files in the project
    directory using relative paths, which improves the portability of the project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认设置外，你还可以选择一个目录，并在RStudio中创建一个R项目。然后，每次你打开该项目时，工作目录就是项目位置，这使得使用相对路径访问项目目录中的文件变得非常容易，这提高了项目的可移植性。
- en: Creating an R project in RStudio
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在RStudio中创建R项目
- en: 'To create a new project, simply go to **File **| **New Project** or click the
    Project drop-down menu in the top-right corner of the main window and choose **New
    Project**. A window will appear, and you can create a new directory or choose
    an existing directory on your hard drive as the project directory:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新项目，只需转到**文件**|**新建项目**或点击主窗口右上角的**项目**下拉菜单并选择**新建项目**。会出现一个窗口，你可以在其中创建一个新的目录或选择硬盘上的现有目录作为项目目录：
- en: '![Creating an R project in RStudio](img/image_03_001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![在RStudio中创建R项目](img/image_03_001.jpg)'
- en: Once you choose a local directory, the project will be created there. An R project
    is nothing but a `.Rproj` file that stores some settings. If you open such a project
    file in RStudio, the settings in it will be applied, and the working directory
    will be set to the directory in which the project file is located.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了一个本地目录，项目就会在那里创建。R项目实际上是一个`.Rproj`文件，它存储了一些设置。如果你在RStudio中打开这样的项目文件，其中的设置将被应用，并且工作目录将被设置为项目文件所在的目录。
- en: 'Another useful point in using RStudio to work in a project is that auto-completion
    makes writing file paths much more efficient. When you are typing a string of
    either an absolute or relative file path, press *Tab* and RStudio will list the
    files in that directory:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RStudio在项目中工作时，另一个有用的点是自动完成使编写文件路径变得更加高效。当你输入一个绝对或相对文件路径的字符串时，按 *Tab* 键，RStudio将列出该目录中的文件：
- en: '![Creating an R project in RStudio](img/image_03_002.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![在RStudio中创建R项目](img/image_03_002.jpg)'
- en: Comparing absolute and relative paths
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较绝对路径和相对路径
- en: 'Since I''m writing this book with RMarkdown in RStudio, the working directory
    is the directory of my book project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我使用RStudio中的RMarkdown编写这本书，工作目录是我的书项目目录：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You may notice that the working directory mentioned earlier uses `/` instead
    of `\`. In Windows operating systems, `\` is the default path separator, but this
    symbol is already used to make special characters. For example, when you create
    a character vector, you can use `\n` to represent a new line:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到前面提到的工作目录使用 `/` 而不是 `\`。在Windows操作系统中，`\` 是默认路径分隔符，但这个符号已经被用来表示特殊字符。例如，当你创建一个字符向量时，你可以使用
    `\n` 来表示一个新行：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Special characters are preserved when the character vector is directly printed
    as a representation of the string. However, if you add `cat()` to it, the string
    will be written in the console with the escape characters translated to the characters
    they represent:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符向量直接打印为字符串表示时，特殊字符会被保留。然而，如果你给它添加 `cat()`，字符串将在控制台中写入，转义字符将被转换为它们所代表的字符：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The second word starts by a new line (`\n`) as normal. However, if `\` is so
    special, how should we write `\` itself? Just use `\\`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个单词从新的一行（`\\n`）开始，就像平常一样。然而，如果 `\` 是如此特殊，我们应该如何写出 `\` 本身呢？只需使用 `\\`：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That is why we should use `\\` or `/` in paths in Windows operating systems
    since both are supported. In Unix-like operating systems, such as macOS and Linux,
    things are easier: always use `/`. If you are using Windows and misuse `\` to
    refer to a file, an error will occur:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在Windows操作系统中，我们应该使用 `\\` 或 `/` 作为路径分隔符，因为两者都受到支持。在类似Unix的操作系统中，例如macOS和Linux，事情要简单得多：始终使用
    `/`。如果你使用Windows并且错误地使用 `\` 来引用文件，将会发生错误：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead, you need to write it like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你需要这样写：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Fortunately, we can use `/` in Windows in most cases, which makes the same
    code runnable in nearly all popular operating systems using relative paths:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在大多数情况下，我们可以在Windows中使用 `/`，这使得相同的代码在几乎所有流行的操作系统上使用相对路径时都能运行：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of getting the working directory using `getwd()`, we can also set the
    working directory of the current R session using `setwd()`. However, this is almost
    always not recommended because it can direct all relative paths in a script to
    another directory and make everything go wrong.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以通过 `getwd()` 获取工作目录，还可以使用 `setwd()` 设置当前R会话的工作目录。然而，这几乎总是不被推荐，因为它可以将脚本中的所有相对路径直接指向另一个目录，导致一切出错。
- en: Therefore, a good practice is to create an R project to start your work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个好的做法是创建一个R项目来开始你的工作。
- en: Managing project files
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理项目文件
- en: Once we create a project in RStudio, a `.Rproj` file is also created in the
    project directory in which there is no other file at the moment. Since R is related
    to statistical computing and data visualization, an R project mainly contains
    R scripts that do statistical computing (or other programming tasks), data files
    (such as `.csv` files), documents (such as Markdown files), and sometimes output
    graphics.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在RStudio中创建了一个项目，项目目录中也会创建一个 `.Rproj` 文件，目前该目录中没有其他文件。由于R与统计计算和数据可视化相关，R项目主要包含进行统计计算（或其他编程任务）的R脚本，数据文件（如
    `.csv` 文件），文档（如Markdown文件），有时还包括输出图形。
- en: If different types of file are mixed up in the project directory, it will be
    increasingly more difficult to manage these project files, especially as input
    data accumulates or output data and graphics clutter the directory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在项目目录中混合了不同类型的文件，随着输入数据的积累或输出数据和图形使目录变得杂乱，管理这些项目文件将会越来越困难。
- en: A recommended practice is to create subdirectories to contain different types
    of files resulting from different types of tasks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个推荐的做法是创建子目录来包含不同类型任务产生的不同类型的文件。
- en: 'For example, the following directory structure is plain, with all files together:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下目录结构很简单，所有文件都在一起：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By contrast, the following directory structure is much cleaner and nicer to
    work with:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，以下目录结构要干净得多，也更易于使用：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding directory structures, directories are represented in the form
    of `directory/` and files in the form of `file-name.ext`. In most cases, the second
    structure is recommended because, as project needs and tasks become more complex,
    the first structure will end up in a mess while the second structure will remain
    tidy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的目录结构中，目录以 `directory/` 的形式表示，文件以 `file-name.ext` 的形式表示。在大多数情况下，建议使用第二种结构，因为随着项目需求和任务的复杂化，第一种结构最终会变得混乱，而第二种结构将保持整洁。
- en: 'Apart from the structure issue, it is common to write the project introduction
    in `README.md` and put additional notes in `NOTES.md`. These two documents are
    Markdown documents (`.md`), and it is worth becoming familiar with its extremely
    simple syntax. Read *Daring Fireball: Markdown Syntax Documentation* ([https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax))
    and *GitHub Help: Markdown Basics* ([https://help.github.com/articles/markdown-basics/](https://help.github.com/articles/markdown-basics/))
    for details. We will cover the topic of combining R and Markdown in [Chapter 15](ch15.html
    "Chapter 15. Boosting Productivity"), *Boosting Productivity*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '除了结构问题之外，通常会在 `README.md` 中编写项目介绍，并在 `NOTES.md` 中放置额外的注释。这两个文档都是 Markdown 文档（`.md`），熟悉其极其简单的语法是值得的。阅读
    *Daring Fireball: Markdown 语法文档* ([https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax))
    和 *GitHub 帮助：Markdown 基础* ([https://help.github.com/articles/markdown-basics/](https://help.github.com/articles/markdown-basics/))
    以获取详细信息。我们将在第 15 章 [提高生产力](ch15.html "第 15 章. 提高生产力") 中介绍 R 和 Markdown 的结合。'
- en: Now the working directory is ready. In the next section, you will learn various
    methods to inspect the working environment in an R session.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在工作目录已准备就绪。在下一节中，你将学习在 R 会话中检查工作环境的各种方法。
- en: Inspecting the environment
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查环境
- en: In R, every expression is evaluated within a specific environment. An environment
    is a collection of symbols and their bindings. When we bind a value to a symbol,
    call a function, or refer to a name, R will find the symbols in the current environment.
    If you type commands in the RStudio console, your commands are evaluated in the
    **Global Environment**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，每个表达式都是在特定的环境中评估的。环境是一组符号及其绑定的集合。当我们将值绑定到符号、调用函数或引用名称时，R 将在当前环境中查找符号。如果你在
    RStudio 控制台中输入命令，你的命令将在 **全局环境** 中评估。
- en: For example, when we start a fresh R session in a terminal or RStudio, we start
    working within an empty global environment. In other words, there is no symbol
    defined in this environment. If we run `x <- c(1, 2, 3)`, the numeric vector `c(1,
    2, 3)` is bound to symbol `x` in the global environment. Then, the global environment
    has one binding that maps `x` to the vector `c(1, 2, 3)`. In other words, if you
    evaluate `x`, then you will get its value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们在一个终端或 RStudio 中启动一个新的 R 会话时，我们开始在空的全局环境中工作。换句话说，在这个环境中没有定义任何符号。如果我们运行
    `x <- c(1, 2, 3)`，数值向量 `c(1, 2, 3)` 将绑定到全局环境中的符号 `x`。然后，全局环境有一个绑定，将 `x` 映射到向量
    `c(1, 2, 3)`。换句话说，如果你评估 `x`，那么你将得到它的值。
- en: Inspecting existing symbols
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查现有符号
- en: In addition to manipulating vectors and lists as we did in the previous chapter,
    we need to know some basic functions to inspect and manipulate our working environment.
    The most basic but useful function to inspect the collection of objects we are
    working with is `objects()`. The function returns a character vector of the names
    of existing objects in the current environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在上一章中我们处理向量列表之外，我们还需要了解一些基本函数来检查和操作我们的工作环境。检查我们正在处理的对象集合的最基本但有用的函数是 `objects()`。该函数返回当前环境中现有对象名称的字符向量。
- en: 'In a fresh R session, there should not be any symbol in the current environment:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的 R 会话中，当前环境中不应该有任何符号：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s assume we create the following objects:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们创建了以下对象：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, you will get a character vector of the existing object names:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将得到一个包含现有对象名称的字符向量：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Many developers prefer `ls()` as an alias of `objects()`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者更喜欢将 `ls()` 作为 `objects()` 的别名：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In most cases, especially when you are working in RStudio, you don''t have
    to use `objects()` or `ls()` to see what symbols have been created because the
    **Environment** pane shows all symbols available in the global environment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，尤其是在你使用 RStudio 的情况下，你不需要使用 `objects()` 或 `ls()` 来查看创建了哪些符号，因为 **环境**
    面板显示了全局环境中所有可用的符号：
- en: '![Inspecting existing symbols](img/image_03_003.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![检查现有符号](img/image_03_003.jpg)'
- en: The **Environment** pane shows symbols and their values in a compact representation.
    You can interact with objects in it by expanding a list or data frame and viewing
    the vectors inside.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境**面板以紧凑的形式显示符号及其值。你可以通过展开列表或数据帧并查看其中的向量与之交互。'
- en: 'In addition to the list view, the **Environment** pane also provides an alternative
    grid view. The grid view shows not only the names, types, and the value structures
    of existing objects, but also their object sizes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列表视图外，**环境**面板还提供了一个替代的网格视图。网格视图不仅显示现有对象的名字、类型和值结构，还显示它们的对象大小：
- en: '![Inspecting existing symbols](img/image_03_004.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![检查现有符号](img/image_03_004.jpg)'
- en: Although the **Environment** pane in RStudio makes it straightforward to inspect
    all existing variables, `objects()` or `ls()` can be still useful when RStudio
    is not available, when you write a function to work with their names, or the objects
    are provided dynamically in different manners.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RStudio中的**环境**面板使得检查所有现有变量变得简单，但在RStudio不可用、编写与它们的名称一起工作的函数或对象以不同方式动态提供时，`objects()`或`ls()`仍然很有用。
- en: Viewing the structure of an object
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看对象的结构
- en: In the **Environment** pane, the compact representation of an object comes from
    the `str()` function, which prints the structure of a given object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在**环境**面板中，对象的紧凑表示来自`str()`函数，该函数打印给定对象的结构。
- en: 'For example, when `str()` is applied to a simple numeric vector, it shows its
    type, positions, and a preview of its values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当`str()`应用于一个简单的数值向量时，它显示其类型、位置和值预览：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the vector has more than 10 elements, `str()` will only show the first 10:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向量有超过10个元素，`str()`将只显示前10个：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For a list, directly evaluating it in the console or using `print()` will show
    the elements in a verbose form:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表，直接在控制台或使用`print()`评估它将显示其元素并以冗长形式显示：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, `str()` shows its type, length, and the structure preview of
    the elements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`str()`显示其类型、长度和元素结构预览：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s assume we created the following nested list:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建了以下嵌套列表：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Directly printing will show all its elements and tell us how we can access
    them which can be long and unnecessary in most cases:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 直接打印将显示所有元素并告诉我们如何访问它们，这在大多数情况下可能既长又没有必要：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To get a compact representation that is easier to view and work with, call
    `str()` with a list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个更易于查看和工作的紧凑表示，请使用列表调用`str()`：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'While `str()` shows the structure of an object, `ls.str()` shows the structure
    of the current environment:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`str()`显示了对象的结构，但`ls.str()`显示了当前环境的结构：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Its functionality is similar to that of the **Environment** pane in RStudio
    and can be useful when you need to inspect a customized environment or only show
    the structures of some particular variables.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其功能类似于RStudio中的**环境**面板，当需要检查自定义环境或仅显示某些特定变量的结构时，可能很有用。
- en: 'One filter for `ls.str()` is the mode argument. You can show the structures
    of all values that are list objects:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls.str()`的一个过滤器是模式参数。你可以显示所有值为列表对象的结构：'
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The other filter is the pattern argument, which specifies the pattern of the
    names to match. The pattern is expressed in a **regular expression**. If you want
    to show the structures of all variables whose names contain only one character,
    you can run the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个过滤器是模式参数，它指定要匹配的名称模式。该模式用**正则表达式**表示。如果你想显示所有只包含一个字符的变量结构，你可以运行以下命令：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you want to show the structures of all list objects whose names contain
    only one character, you can use both pattern and mode at the same time:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想显示所有只包含一个字符的列表对象结构，你可以同时使用模式和模式：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you're put off by commands such as `^\\w$`, don't worry. This pattern matches
    all strings in the form of `(string begin)(any one word character like a, b, c)(string
    end)`. We will cover this powerful tool in [Chapter 6](ch06.html "Chapter 6. Working
    with Strings"), *Working with Strings*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被像`^\\w$`这样的命令吓到，不要担心。此模式匹配所有形式为`(string begin)(any one word character like
    a, b, c)(string end)`的字符串。我们将在第6章[“处理字符串”](ch06.html "第6章。处理字符串")中介绍这个强大的工具。
- en: Removing symbols
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除符号
- en: So far, we have only created symbols. Sometimes, it can be useful to remove
    them. The `remove()` function, or equivalently `rm()`, removes existing symbols
    from the environment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了符号。有时，移除它们可能很有用。`remove()`函数，或等价的`rm()`，从环境中移除现有符号。
- en: 'Before removing `x`, the symbols in the environment are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除 `x` 之前，环境中的符号如下：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we will use `rm()` to remove `x` from the environment:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `rm()` 从环境中移除 `x`：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that the function also works with variable names in strings. Therefore,
    `rm("x")` has exactly the same effect. We can also remove multiple symbols in
    one function call:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数也适用于字符串中的变量名。因此，`rm("x")` 有完全相同的效果。我们也可以在一个函数调用中移除多个符号：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the symbol to be removed does not exist in the environment, a warning will
    appear:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要移除的符号在环境中不存在，将会出现警告：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `rm()` function can also remove all symbols specified by a character vector
    of symbol names:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm()` 函数也可以通过符号名称的字符向量移除指定的所有符号：'
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we want to clear all the bindings in an environment, we can combine `rm()`
    and `ls()` and call the function like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想清除环境中的所有绑定，我们可以结合 `rm()` 和 `ls()` 并像这样调用函数：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now there's no symbol in the environment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在环境中没有符号。
- en: In many cases, removing symbols is not necessary, but it can be useful to remove
    very large objects that occupy a big area of memory. If R feels memory pressure,
    it will clean up unused objects with no bindings.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，移除符号不是必需的，但移除占用大量内存的大对象可能很有用。如果 R 感觉到内存压力，它将清理没有绑定的未使用对象。
- en: Modifying global options
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改全局选项
- en: Instead of creating, inspecting, and removing objects in the working environment,
    R options have effects in the global scale of the current R session. We can call
    `getOption()` to see the value of a given option and call `options()` to modify
    one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与在工作环境中创建、检查和删除对象相比，R 选项在当前 R 会话的全局范围内产生影响。我们可以调用 `getOption()` 来查看给定选项的值，并调用
    `options()` 来修改它。
- en: Modifying the number of digits to print
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改打印数字的位数
- en: 'In RStudio, when you type `getOption(<Tab>)`, you can see a list of available
    options and their descriptions. A commonly used option, for instance, is the number
    of digits to display. Sometimes, it is not sufficient when we deal with numbers
    requiring higher precision. In an R session, the number of digits printed on screen
    is entirely managed by digits. We can call `getOption()` to see the current value
    of digits and call `options()` to set `digits` to a larger number:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RStudio 中，当你输入 `getOption(<Tab>)` 时，你可以看到一个可用选项及其描述的列表。例如，常用的一个选项是显示的数字位数。有时，当我们处理需要更高精度的数字时，这并不足够。在一个
    R 会话中，屏幕上打印的数字位数完全由 `digits` 管理。我们可以调用 `getOption()` 来查看 `digits` 的当前值，并调用 `options()`
    将 `digits` 设置为更大的数字：
- en: '![Modifying the number of digits to print](img/image_03_005.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![修改打印数字的位数](img/image_03_005.jpg)'
- en: 'When an R session starts, the default value of digits is 7\. To demonstrate
    its effect, run the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当 R 会话开始时，`digits` 的默认值是 7。为了演示其效果，运行以下代码：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It is obvious that the 11-digit number is only shown with 7 digits. This means
    the last few decimal digits are gone; the printer only displays the number with
    7 digits. To verify no precision is lost because of `digits = 7`, see the output
    of the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，11 位的数字只显示了 7 位。这意味着最后几位小数位已经丢失；打印机只显示 7 位的数字。为了验证 `digits = 7` 不会因为精度丢失，请查看以下代码的输出：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the numbers are rounded to the seventh decimal place by default, then `0.10000002`
    should be rounded to `0.1` and the second expression should result in `0`. However,
    apparently, this does not happen because `digits = 7` only means the number of
    numeric digits to be displayed rather than rounded up.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字默认四舍五入到第七位小数，那么 `0.10000002` 应该四舍五入到 `0.1`，第二个表达式应该得到 `0`。然而，显然这不是因为 `digits
    = 7` 只意味着要显示的数字位数，而不是向上舍入。
- en: 'However, in some cases, the number before the decimal point can be large, and
    we don''t want to ignore digits following the decimal point. Without modifying
    digits, the following number will only display the integer part:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，小数点前的数字可能很大，我们不希望忽略小数点后的数字。在不修改数字的情况下，以下数字将只显示整数部分：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we want to see more digits printed, we need to increase digits from the
    default value 7 to a higher number:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想打印更多的数字，我们需要将数字从默认值 7 增加到一个更高的数字：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that once, `options()` is called, the modified options take effect immediately
    and may affect the behavior of all subsequent commands. To reset options, use
    this command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦调用 `options()`，修改后的选项将立即生效，可能会影响所有后续命令的行为。要重置选项，请使用此命令：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Modifying the warning level
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改警告级别
- en: 'Another options example managing the warning level by specifying the value
    of the `warn` option:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个通过指定`warn`选项值来管理警告级别的选项示例：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By default, the warning level is `0`, which means a warning is a warning and
    an error is an error. In this state, a warning will be displayed but will not
    stop the code, while an error terminates the code immediately. If multiple warnings
    occur, they will be combined and displayed together. For example, the following
    conversion from a string to a numeric vector will produce a warning and result
    in a missing value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，警告级别是`0`，这意味着警告就是警告，错误就是错误。在这种状态下，警告会被显示，但不会停止代码，而错误会立即终止代码。如果发生多个警告，它们将被合并并一起显示。例如，以下从字符串到数值向量的转换将产生警告并导致缺失值：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can make it completely silent and still get a missing value from the unsuccessful
    conversion:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使它完全静音，并且仍然从失败的转换中获取缺失值：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then, the warning is gone. Making the warning messages disappear is almost always
    a bad idea. It will make potential errors silent. You can (or cannot) realize
    something is wrong from the final result. The recommendation is to be strict in
    your code and save a lot of time debugging it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，警告信息消失了。使警告信息消失几乎总是个坏主意。它会使得潜在的错误变得无声。你可能（或不可能）从最终结果中意识到有什么地方出了问题。建议对代码严格要求，这样可以节省大量调试时间。
- en: 'Setting warn to 1 or 2 will make buggy code fail fast. When `warn = 0`, the
    default behavior for evaluating a function call is to first return the value and
    then show all the warning messages together, if any. To demonstrate this behavior,
    the following function is called with two strings:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将`warn`设置为1或2将使有缺陷的代码快速失败。当`warn = 0`时，评估函数调用的默认行为是首先返回值，然后如果有的话，一起显示所有警告信息。为了演示这种行为，以下函数使用两个字符串被调用：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At the default warning level, all warning messages are shown after the function
    returns:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的警告级别下，所有警告信息都在函数返回后显示：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The function coerces two input arguments to numeric vectors. As the input arguments
    are both strings, two warnings will be produced, but will only appear after the
    function returns. If the preceding function does some heavy work and takes a considerable
    period of time, you won't see any warning before you get the final result but
    in fact the intermediate computing has been way off the correct results for quite
    a while.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将两个输入参数强制转换为数值向量。由于输入参数都是字符串，将产生两个警告，但它们只会在函数返回后出现。如果前面的函数执行了一些繁重的工作并花费了相当长的时间，那么在得到最终结果之前你不会看到任何警告，但实际上中间计算已经偏离正确结果有一段时间了。
- en: 'This prompts the use of `warn = 1`, which forces the warning message to be
    printed as soon as a warning is produced:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这促使使用`warn = 1`，它强制警告信息在产生警告时立即打印出来：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The result is the same, but the warning messages appear ahead of the result.
    If the function is time-consuming, we should be able to see the warning messages
    first. So, we can choose to stop the code and check whether something is wrong.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相同，但警告信息出现在结果之前。如果函数耗时较长，我们应该能够先看到警告信息。因此，我们可以选择停止代码并检查是否有问题。
- en: A warning level is even stricter. The `warn = 2` argument directly regards any
    warning as an error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 警告级别甚至更严格。`warn = 2`参数直接将任何警告视为错误。
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These options have effects in the global scale. Therefore, it is convenient
    to manage common aspects of an R session, but it can also be dangerous to change
    options. Just like changing the working directory may invalidate all relative
    paths in the script from running, changing global options may break all subsequent
    code that is based on incompatible assumptions of the global options.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项在全局范围内有影响。因此，它们便于管理R会话的常见方面，但改变选项也可能很危险。就像改变工作目录可能会使脚本中所有相对路径无效一样，改变全局选项可能会破坏所有基于全局选项不兼容假设的后续代码。
- en: In general, it is not recommended to modify global options unless absolutely
    necessary.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，除非绝对必要，否则不建议修改全局选项。
- en: Managing the library of packages
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理包库
- en: In R, packages play an indispensable role in data analysis and visualization.
    In fact, R itself is only a tiny core and is built on several basic packages.
    A package is a container of predefined functions, which are often designed to
    be general enough to solve a certain range of problems. Using a well-designed
    package, we don't have to reinvent the wheel again and again, which allows us
    to focus more on the problem we are trying to solve.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 语言中，包在数据分析和可视化中扮演着不可或缺的角色。实际上，R 本身只是一个微小的核心，它建立在几个基本包的基础上。包是一个预定义函数的容器，这些函数通常设计得足够通用，可以解决一定范围内的问题。使用一个设计良好的包，我们不必一次次地重新发明轮子，这使我们能够更多地关注我们试图解决的问题。
- en: R is powerful not only because of its rich source of packages, but also because
    of the well-maintained package archive system called *The Comprehensive R Archive
    Network*, or CRAN ([http://cran.r-project.org/](http://cran.r-project.org/)).
    The source code of R and thousands of packages is archived in this system. At
    the time of writing, there are 7,750 active packages on CRAN maintained by more
    than 4,500 package maintainers around the world. Every week, more than 100 packages
    will be updated and more than 2 million package downloads happen. You can check
    out the table of packages at [https://cran.rstudio.com/web/packages/](https://cran.rstudio.com/web/packages/)
    in which all the packages currently available are listed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: R 语言之所以强大，不仅因为其丰富的包资源，还因为有一个维护良好的包存档系统，称为**综合 R 存档网络**，或简称 CRAN ([http://cran.r-project.org/](http://cran.r-project.org/))。R
    的源代码和数千个包都存档在这个系统中。在撰写本文时，CRAN 上有 7,750 个活跃的包，由全球超过 4,500 名包维护者维护。每周，将有超过 100
    个包被更新，超过 200 万次包下载。您可以在[https://cran.rstudio.com/web/packages/](https://cran.rstudio.com/web/packages/)查看包的表格，其中列出了目前所有可用的包。
- en: Just don't panic when you hear the number of packages on CRAN! The number is
    large and the coverage is wide, but you only have to learn a small fraction of
    them. If you focus on the work of a specific field, it is very likely that there
    are no more than 10 packages that are heavily related to your work and field.
    Therefore, there's absolutely no need for you to know all the packages (nobody
    can or even need to), but only the most useful and field-related ones.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到 CRAN 上包的数量时，请不要慌张！数量很大，覆盖面很广，但你只需要学习其中的一小部分。如果你专注于特定领域的工作，那么与你工作和领域高度相关的包可能不超过
    10 个。因此，你完全没有必要了解所有的包（没有人能够或甚至需要这样做），只需要了解最有用和与领域相关的那些。
- en: Instead of finding packages in the table, which is not that informative, I recommend
    that you visit CRAN Task Views ([https://cran.rstudio.com/web/views/](https://cran.rstudio.com/web/views/))
    and METACRAN [http://www.r-pkg.org/](http://www.r-pkg.org/), and get started by
    learning about the packages that are most commonly used or closely related to
    your working field. Before learning how to use a specific package, we need to
    have a general idea about installing packages from different sources and understand
    how a package basically works.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在表格中寻找包，这并不那么有信息量，我建议你访问 CRAN 任务视图([https://cran.rstudio.com/web/views/](https://cran.rstudio.com/web/views/))和
    METACRAN [http://www.r-pkg.org/](http://www.r-pkg.org/)，并从学习与你工作领域最常用或最相关的包开始。在学习如何使用特定包之前，我们需要对从不同来源安装包有一个大致的了解，并理解包的基本工作原理。
- en: Getting to know a package
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解一个包
- en: 'A package is a collection of functions to solve a certain range of problems.
    It can be an implementation of a family of statistical estimators, data-mining
    methods, database interfaces, or optimization tools. To know more about a package,
    for example, ggplot2, a super powerful graphics package, several information sources
    are useful:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 包是一组用于解决一定范围内问题的函数。它可以是一个统计估计器系列、数据挖掘方法、数据库接口或优化工具的实现。要了解更多关于某个包的信息，例如功能强大的图形包
    ggplot2，以下信息来源很有用：
- en: '**Package description page** ([https://cran.rstudio.com/web/packages/ggplot2/](https://cran.rstudio.com/web/packages/ggplot2/)):
    The page contains the basic information about the package, including the name,
    description, version, publishing date, authors, related websites, reference manuals,
    vignettes, relationship to other packages, and so on. The description page of
    a package is provided not only by CRAN, but by some other third-party package
    information websites. METACRAN also provides a description of ggplot2 at [http://www.r-pkg.org/pkg/ggplot2](http://www.r-pkg.org/pkg/ggplot2).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件包描述页面(**[https://cran.rstudio.com/web/packages/ggplot2/](https://cran.rstudio.com/web/packages/ggplot2/))：该页面包含软件包的基本信息，包括名称、描述、版本、发布日期、作者、相关网站、参考手册、示例、与其他软件包的关系等。软件包的描述页面不仅由
    CRAN 提供，还由一些其他第三方软件包信息网站提供。METACRAN 还在[http://www.r-pkg.org/pkg/ggplot2](http://www.r-pkg.org/pkg/ggplot2)上提供了
    ggplot2 的描述。'
- en: '**Package website (**[http://ggplot2.org/](http://ggplot2.org/)): The webpage
    contains a description and related resources for the package, such as blogs, tutorials,
    and books. Not every package has a website, but if one does the website is the
    official starting point for learning about the package.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件包网站(**[http://ggplot2.org/](http://ggplot2.org/))：该网页包含软件包的描述和相关资源，如博客、教程和书籍。并非每个软件包都有网站，但如果有，该网站是了解软件包的官方起点。'
- en: '**Package source code** ([https://github.com/hadley/ggplot2](https://github.com/hadley/ggplot2)):
    The authors host the source code of the package on GitHub ([https://github.com](https://github.com)),
    and the page is the source code the package. If you are interested in the implementation
    of the package functions, you can check out the source code and take a look. If
    you find some unexpected behavior that looks like a bug, you can report it at [https://github.com/hadley/ggplot2/issues](https://github.com/hadley/ggplot2/issues).
    Also, you can file an issue at the same place to request a new feature.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件包源代码(**[https://github.com/hadley/ggplot2](https://github.com/hadley/ggplot2))：作者在
    GitHub([https://github.com](https://github.com))上托管软件包的源代码，该页面是软件包的源代码。如果您对软件包函数的实现感兴趣，您可以查看源代码并查看。如果您发现一些看起来像错误的不寻常行为，您可以在[https://github.com/hadley/ggplot2/issues](https://github.com/hadley/ggplot2/issues)处报告它。您也可以在同一个地方提交问题以请求新功能。'
- en: After reading the package description, you can try it by installing the package
    to the R library.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读软件包描述后，您可以通过将软件包安装到 R 库中来尝试它。
- en: Installing packages from CRAN
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 CRAN 安装软件包
- en: 'CRAN archives R packages and distributes them to more than 120 mirrors around
    the world. You can visit CRAN Mirrors ([https://cran.r-project.org/mirrors.html](https://cran.r-project.org/mirrors.html))
    and check out a nearby mirror. If you find one, you can go to **Tools** | **Global
    Options** and open the following dialog:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: CRAN 存档 R 软件包并将它们分发到全球超过 120 个镜像站点。您可以访问 CRAN 镜像([https://cran.r-project.org/mirrors.html](https://cran.r-project.org/mirrors.html))并查看附近的镜像。如果您找到了一个，您可以去**工具**
    | **全局选项**并打开以下对话框：
- en: '![Installing packages from CRAN](img/image_03_006.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![从 CRAN 安装软件包](img/image_03_006.jpg)'
- en: You can change the CRAN mirror to a nearby one or simply use the default mirror.
    In general, you will experience very fast downloading if you use a nearby mirror.
    In recent months, some mirrors have started using HTTPS to secure data transfers.
    If **Use secure download method for HTTP** is checked, then you can only view
    HTTPS mirrors.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 CRAN 镜像更改为附近的镜像或简单地使用默认镜像。通常，如果您使用附近的镜像，您将体验到非常快的下载速度。在最近几个月，一些镜像开始使用 HTTPS
    来保护数据传输。如果勾选了**使用安全的 HTTP 下载方法**，那么您就只能查看 HTTPS 镜像。
- en: Once a mirror is chosen, to download and install a package in R becomes extremely
    easy. Just call `install.packages("ggplot2")`, and R will automatically download
    the package, install it, and sometimes compile it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了镜像，在 R 中下载和安装软件包就变得极其简单。只需调用 `install.packages("ggplot2")`，R 将自动下载软件包，安装它，有时还会编译它。
- en: 'RStudio also provides an easy way to install packages. Just go to the Packages
    pane and click on **Install**. The following dialog appears:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio 也提供了一个安装软件包的简单方法。只需转到“软件包”面板并点击**安装**。将出现以下对话框：
- en: '![Installing packages from CRAN](img/image_03_007.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![从 CRAN 安装软件包](img/image_03_007.jpg)'
- en: As the package description shows, a package may depend on other packages. In
    other words, when you call a function in the package, the function also calls
    some functions in other packages, which requires that you also install those packages
    as well. Fortunately, `install.packages()` is smart enough to know the dependency
    structure of the package to install and will install those packages first.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如包描述所示，一个包可能依赖于其他包。换句话说，当你调用包中的函数时，该函数也会调用其他包中的某些函数，这要求你也安装那些包。幸运的是，`install.packages()`足够智能，能够知道要安装的包的依赖结构，并将首先安装这些包。
- en: 'In the main page of METACRAN ([http://www.r-pkg.org/](http://www.r-pkg.org/)),
    featured packages are those with the most stars on GitHub. That is, these packages
    are marked by many GitHub users. You may want to install multiple featured packages
    in one call, which is naturally allowed if you write the package names as a character
    vector:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在METACRAN的主页（[http://www.r-pkg.org/](http://www.r-pkg.org/))上，特色包是那些在GitHub上拥有最多星标的包。也就是说，这些包被许多GitHub用户标记。你可能希望在一次调用中安装多个特色包，如果你将包名作为字符向量写入，这是自然允许的：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Then the `install.packages()` function automatically resolves the joint dependency
    structure of all these packages and installs them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`install.packages()`函数会自动解析所有这些包的联合依赖结构，并安装它们。
- en: Updating packages from CRAN
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从CRAN更新包
- en: By default, the `install.packages()` function installs the latest version of
    the specified packages. Once they are installed, the package version stays fixed.
    However, the packages may be updated to fix bugs or add new features. Sometimes,
    an updated version of a package may deprecate functions in older versions with
    warnings. In these cases, we may keep the package out-of-date, or update it after
    reading the `NEWS` package, which can be found in the package description (for
    example, [https://cran.r-project.org/web/packages/ggplot2/news.html](https://cran.r-project.org/web/packages/ggplot2/news.html); see
    this for details about the new version in the case of breaking changes).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`install.packages()`函数安装指定包的最新版本。一旦安装，包的版本就保持固定。然而，包可能会更新以修复错误或添加新功能。有时，包的更新版本可能会在警告中废弃旧版本中的函数。在这些情况下，我们可能保留包的过时状态，或者阅读包描述中的`NEWS`包后更新它，该包可以在包描述中找到（例如，[https://cran.r-project.org/web/packages/ggplot2/news.html](https://cran.r-project.org/web/packages/ggplot2/news.html)；有关重大更改的新版本详情，请参阅此链接）。
- en: 'RStudio provides an **Update** button next to **Install** in the package pane.
    We can also use the following function and choose which packages are going to
    be updated:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio在包面板中“安装”旁边的“更新”按钮提供。我们也可以使用以下函数并选择要更新的包：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Both RStudio and the preceding function scan newer versions of packages and
    install these packages along with dependencies if necessary.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio和前面的函数会扫描包的新版本，并在必要时安装这些包及其依赖项。
- en: Installing packages from online repositories
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从在线仓库安装包
- en: Nowadays, many package authors host their work on GitHub because version control
    and community development are very easy, thanks to the well-designed issue-tracking
    systems and merge request system. Some authors do not release their work to CRAN,
    and others only release the stable versions to CRAN and keep new versions under
    development on GitHub.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多包作者在GitHub上托管他们的工作，因为版本控制和社区开发非常容易，这得益于精心设计的issue-tracking系统和merge request系统。一些作者不将他们的工作发布到CRAN，而其他人只发布稳定的版本到CRAN，并将新版本的开发保持在GitHub上。
- en: If you want to try the latest development version, which often has new features
    or has fixed some bugs, you can directly install the package from the online repository
    using the devtools package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试最新的开发版本，它通常包含新功能或修复了一些错误，你可以直接使用devtools包从在线仓库安装包。
- en: 'First, install the devtools package if it does not appear in your library:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果devtools包不在你的库中，请安装它：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, use `install_github()` in the devtools package to install the latest
    development version of ggplot2:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用devtools包中的`install_github()`安装ggplot2的最新开发版本：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The devtools package will download the source code from GitHub and makes it
    a package in your library. If your library has already got the package, the installation
    will replace it without asking. If you want to revert the development version
    to the latest CRAN version, you can run the CRAN installing code again:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: devtools包将从GitHub下载源代码，并将其作为你的库中的一个包。如果你的库中已经有了这个包，安装将替换它而不会询问。如果你想将开发版本回滚到最新的CRAN版本，你可以再次运行CRAN安装代码：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then, the local version (GitHub version) is replaced by the CRAN version.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，本地版本（GitHub版本）被CRAN版本所取代。
- en: Using package functions
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包函数
- en: There are two ways to use the functions in a package. First, we can call `library()`
    to attach the package so that the functions in it can be directly called. Second,
    we can call `package::function()` to only use the function without attaching the
    whole package to the environment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包中的函数有两种方法。首先，我们可以调用 `library()` 来附加包，这样其中的函数就可以直接调用。其次，我们可以调用 `package::function()`
    来仅使用函数，而无需将整个包附加到环境中。
- en: For example, some statistical estimators are not implemented as built-in functions
    in base R but in other packages. One instance is skewness; the statistical function
    is provided by the moments package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一些统计估计器不是在基础R中作为内置函数实现的，而是在其他包中实现。一个例子是偏度；统计函数由 moments 包提供。
- en: 'To calculate the skewness of numeric vector `x`, we can attach the package
    first and directly call the function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算数值向量 `x` 的偏度，我们首先可以附加包，然后直接调用函数：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Alternatively, we can call package functions without attaching the package,
    using `::`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，我们可以不附加包就调用包函数，使用 `::`:'
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The two methods return the same result, but they work in different ways and
    have a different impact on the environment. More specifically, the first method
    (using `library()`) modifies the search path of symbols, whereas the second method
    (using `::`) does not. When you call `library(moments)`, the package is attached
    and added to the search path so that the package functions are directly available
    in subsequent code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法返回相同的结果，但它们以不同的方式工作，并对环境有不同的影响。更具体地说，第一种方法（使用 `library()`）修改了符号的搜索路径，而第二种方法（使用
    `::`）则不会。当你调用 `library(moments)` 时，包会被附加并添加到搜索路径中，这样包中的函数就可以在后续代码中直接使用。
- en: 'Sometimes, it is useful to see what packages we are using by calling `sessionInfo()`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过调用 `sessionInfo()` 来查看我们正在使用的包是有用的：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The session info shows the R version and lists the attached packages and loaded
    packages. When we use `::` to access a function in a package, the package is not
    attached but loaded in memory. In this case, other functions in the package are
    still not directly available:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 会话信息显示了R版本，并列出了附加包和已加载包。当我们使用 `::` 访问包中的函数时，包未附加但已加载到内存中。在这种情况下，包中的其他函数仍然不可直接使用：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This shows that the moments package is loaded but not attached. When we `calllibrary(moments)`,
    the package will be attached:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 moments 包已被加载但未附加。当我们 `calllibrary(moments)` 时，包将被附加：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Then, `skewness()` as well as other package functions in moments are directly
    available.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`skewness()` 以及 moments 中的其他包函数都可直接使用。
- en: 'An easier way to see attached packages is `search()`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '查看附加包的一个更简单的方法是使用 `search()`:'
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The function returns the current search path of symbols. When you evaluate a
    function call that uses skewness, it finds a skewness symbol in the current environment
    first. Then, it goes to `package:moment` and the symbol is found. If the package
    is not attached, the symbol will not be found, so an error will occur. We will
    cover this symbol-finding mechanism in later chapters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回符号的当前搜索路径。当你评估使用偏度的函数调用时，它首先在当前环境中查找偏度符号。然后，它转到 `package:moment` 并找到符号。如果包未附加，则符号将找不到，因此会发生错误。我们将在后面的章节中介绍这种符号查找机制。
- en: 'To attach a package, `require()` is similar to `library()`, but it returns
    a logical value to indicate whether the package is successfully attached:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加包，`require()` 与 `library()` 类似，但它返回一个逻辑值以指示包是否成功附加：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This feature allows the following code to attach a package if it is installed
    or install it if it is not yet installed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能允许以下代码在包已安装的情况下附加包，如果没有安装，则安装它：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, most uses of the `require()` function in user code are not like this.
    The following is typical:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户代码中 `require()` 函数的大多数使用并不像这样。以下是一个典型的例子：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This looks equivalent to using `library()` but has a silent drawback:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与使用 `library()` 相似，但有一个无声的缺点：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the package to attach is not installed or even does not exist at all (maybe
    a typo), `require()` only produces a warning instead of an error like that produced
    by `library()`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要附加的包未安装或甚至根本不存在（可能是拼写错误），`require()` 只会产生警告而不是像 `library()` 那样产生错误：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Imagine you are running a long and time-consuming R script that depends on
    several packages. If you use `require()` and unfortunately the computer running
    your script does not happen to have installed the required packages, the script
    will only fail later, when the package function is being called and the function
    is not found. However, if you use `library()` instead, the script will stop immediately
    if the packages do not exist on the running computer. Yihui Xie wrote a blog ([http://yihui.name/en/2014/07/library-vs-require/](http://yihui.name/en/2014/07/library-vs-require/))
    on this issue and proposes the *fail fast* principle: if the task has to fail,
    it is better to fail fast.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在运行一个漫长且耗时的R脚本，它依赖于几个包。如果你使用`require()`，不幸的是运行你的脚本的计算机没有安装所需的包，脚本将仅在稍后失败，当调用包函数而找不到函数时。然而，如果你使用`library()`代替，如果运行计算机上不存在这些包，脚本将立即停止。Yihui
    Xie就这个问题写了一篇博客([http://yihui.name/en/2014/07/library-vs-require/](http://yihui.name/en/2014/07/library-vs-require/))，并提出了*快速失败*原则：如果任务必须失败，最好是快速失败。
- en: Masking and name conflicts
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掩盖和名称冲突
- en: A fresh R session starts with basic packages automatically attached. The basic
    packages refer to base, stats, graphics, and so on. With these packages attached,
    you can calculate the average of a numeric vector using `mean()` and the median
    of it using `median()`, without using `base::mean()` and `stats::median()` or
    having to manually attach `base` and `stats` packages.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的R会话以自动附加的基本包开始。基本包指的是base、stats、graphics等。附加这些包后，你可以使用`mean()`计算数值向量的平均值，使用`median()`计算其中位数，而无需使用`base::mean()`和`stats::median()`或手动附加`base`和`stats`包。
- en: In fact, thousands of functions are immediately available from automatically
    attached packages, and each package defines a number of functions for a particular
    purpose. Therefore, it is likely that the functions in two packages conflict with
    each other. For example, suppose two packages A and B both have a function named
    X. If you attach A and then attach B, the function A::X will be masked by the
    function B::X. In other words, when you attach A and you call `X()`, then A's
    X is called. Then, you attach B and call `X()`; it is now B's X that is called.
    This mechanism is known as **masking**. The following example shows what happens
    when masking occurs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从自动附加的包中立即可用数千个函数，每个包都定义了为特定目的而设计的函数。因此，两个包中的函数可能存在冲突。例如，假设两个包A和B都有一个名为X的函数。如果你先附加A然后附加B，函数A::X将被函数B::X掩盖。换句话说，当你附加A并调用`X()`时，调用的是A的X。然后，你附加B并调用`X()`；现在调用的是B的X。这种机制被称为**掩盖**。以下示例显示了掩盖发生时的情况。
- en: 'The powerful data manipulation package dplyr defines a family of functions
    that make it easier to manipulate tabular data. When we attach the package, some
    messages are printed to show you that some existing functions are masked by the
    package functions with the same names:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的数据处理包dplyr定义了一系列函数，使操作表格数据更加容易。当我们附加该包时，会打印一些消息来显示一些现有函数被具有相同名称的包函数掩盖：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Fortunately, the implementation of these functions in `dplyr` does not change
    the meaning and usage, but generalizes them. These functions are compatible with
    the masked version. Therefore, you don't have to worry that the masked functions
    are broken and no longer work.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`dplyr`中这些函数的实现并没有改变其意义和用法，而是泛化了它们。这些函数与被掩盖的版本兼容。因此，你不必担心被掩盖的函数已损坏且不再工作。
- en: 'Package functions that mask basic functions almost always generalize rather
    than replace. However, if you have to use two packages in which some functions
    share the same names, you had better not attach either package; instead, extract
    the functions from both packages you need, as shown here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将几乎掩盖基本功能的包函数打包几乎总是泛化而不是替换。然而，如果你必须使用两个包含一些函数具有相同名称的包，你最好不要附加任何包；相反，从你需要的两个包中提取函数，如下所示：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you happen to attach one package and want to detach it, you can call `unloadNamespace()`.
    For example, we have attached moments and we can detach it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你偶然附加了一个包并想要卸载它，你可以调用`unloadNamespace()`。例如，我们已经附加了moments，我们可以卸载它：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As soon as the package is detached, the package functions are no longer directly
    available:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包被卸载，包函数就不再直接可用：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'However, you can still use `::` to call the function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你仍然可以使用`::`来调用函数：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Checking whether a package is installed
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查包是否已安装
- en: 'It is useful to know that `install.packages()` performs the installation, while `installed.packages()`
    shows information about the installed packages, which is a matrix of 16 columns
    that covers a wide range of information:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的一点是，`install.packages()` 执行安装，而 `installed.packages()` 显示已安装软件包的信息，这是一个包含16列的矩阵，涵盖了广泛的信息：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This can be useful when you need to check whether a package is installed:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要检查一个软件包是否已安装时，这可能很有用：
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Sometimes, you need to check the version of a package:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要检查软件包的版本：
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A simpler way to get the package version is using the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 获取软件包版本的一个更简单的方法是使用以下命令：
- en: '[PRE66]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can compare two package versions so that we can check whether a package
    is newer than a given version:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以比较两个软件包版本，以便检查软件包是否比给定版本新：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In fact, we can directly use a string version to perform the comparison:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以直接使用字符串版本来进行比较：
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Checking package versions can be useful if your scripts depend on some packages
    that must be equal to or newer than, a specific version. This can be true if your
    scripts rely on some of the new features introduced in that version. In addition,
    `packageVersion()` will produce an error if a package is not installed, which
    also makes it check the package installation status.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的脚本依赖于某些必须等于或更新于特定版本的软件包，检查软件包版本可能很有用。如果脚本依赖于该版本中引入的一些新功能，这也可能成立。此外，如果软件包未安装，`packageVersion()`
    将产生错误，这也使得检查软件包安装状态成为可能。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the working-directory concept and tools dealing
    with it. You also explored functions to inspect the working environment, modify
    global options, and manage the library of packages. Now, you have the basic knowledge
    to manage your workspace.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了工作目录的概念以及处理它的工具。你还探索了检查工作环境、修改全局选项和管理软件包库的函数。现在，你有了管理工作空间的基本知识。
- en: In this next chapter, you will learn several basic expressions, including assignment,
    condition, and loop. These expressions are the building blocks of program logic.
    I will show you how to write efficient and robust control-flow expressions in
    the next chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习到几个基本表达式，包括赋值、条件和循环。这些表达式是程序逻辑的构建块。我将在下一章中向你展示如何编写高效且健壮的控制流表达式。
