["```py\n>>> import numpy\n>>> import scipy.special\n>>> a=scipy.special.exp10(-16)\n>>> numpy.log(1+a)\n\n```", "```py\n0.0\n\n```", "```py\n>>> scipy.special.log1p(a)\n\n```", "```py\n9.9999999999999998e-17\n\n```", "```py\n>>> import numpy\n>>> P1=numpy.poly1d([1,0,1])           # using coefficients\n>>> print (P1)\n\n```", "```py\n 2\n1 x + 1\n\n```", "```py\n>>> print (P1.r); print (P1.o); print (P1.deriv())\n\n```", "```py\n[ 0.+1.j  0.-1.j]\n2\n2 x\n\n```", "```py\n>>> P2=numpy.poly1d([1,1,1], True)     # using roots\n>>> print (P2)\n\n```", "```py\n 3     2\n1 x - 3 x + 3 x â€“ 1\n\n```", "```py\n>>> P2=numpy.poly1d([1,1,1], True, variable='z')\n>>> print (P2)\n\n```", "```py\n 3     2 \n1 z - 3 z + 3 z - 1\n\n```", "```py\n>>> P1( numpy.arange(10) )           # evaluate at 0,1,...,9\n\n```", "```py\narray([ 1,  2,  5, 10, 17, 26, 37, 50, 65, 82])\n\n```", "```py\n>>> P1.__call__(numpy.arange(10))    # same evaluation\n\n```", "```py\narray([ 1,  2,  5, 10, 17, 26, 37, 50, 65, 82])\n\n```", "```py\n>>> import numpy\n>>> Px=numpy.poly1d([-(1./2.),1,0])\n>>> print(Px)\n\n```", "```py\n 2\n-0.5 x + 1 x\n\n```", "```py\n>>> a=1./10000000000000000.\n>>> print(a)\n\n```", "```py\n1e-16\n\n```", "```py\n>>> Px(a)\n\n```", "```py\n9.9999999999999998e-17\n\n```", "```py\n>>> P1=numpy.poly1d([1,0,1])\n>>> print(P1)\n\n```", "```py\n 2\n1 x + 1\n\n```", "```py\n>>> print(numpy.polyadd(P1, numpy.poly1d([2,1])))\n\n```", "```py\n 2\n1 x + 2 x + 2\n\n```", "```py\n>>> print(numpy.polyadd(P1, [2,1]))\n\n```", "```py\n 2\n1 x + 2 x + 2\n\n```", "```py\n>>> print(P1 + numpy.poly1d([2,1]))\n\n```", "```py\n 2\n1 x + 2 x + 2\n\n```", "```py\n>>> print(P1 + [2,1])\n\n```", "```py\n 2\n1 x + 2 x + 2\n\n```", "```py\n>>> P1/[2,1]\n\n```", "```py\n(poly1d([ 0.5 , -0.25]), poly1d([ 1.25]))\n\n```", "```py\n>>> eval_jacobi(n, alpha, beta, x)\n\n```", "```py\n>>> import numpy \n>>> import scipy.special\n>>> import matplotlib.pyplot as plt\n>>> x=numpy.linspace(-1,1,1000)\n>>> plt.plot(x,scipy.special.eval_jacobi(3,0,1,x))\n>>> plt.show()\n\n```", "```py\n>>> import scipy.special\n>>> 10**10*scipy.special.psi(10**15)\n\n```", "```py\n345387763949.10681\n\n```", "```py\n>>> import numpy\n>>> import scipy.special\n>>> import  matplotlib.pyplot as plt\n>>> import mpl_toolkits.mplot3d\n>>> x=numpy.mgrid[-4:4:100j,-4:4:100j]\n>>> z=x[0]+1j*x[1]\n>>> (Ai, Aip, Bi, Bip) = scipy.special.airy(z)\n>>> steps = range(int(Bi.real.min()), int(Bi.real.max()),6)\n>>> fig=plt.figure()\n>>> subplot1=fig.add_subplot(121,aspect='equal')\n>>> subplot1.contourf(x[0], x[1], Bi.real, steps)\n>>> subplot2=fig.add_subplot(122,projection='3d')\n>>> subplot2.plot_surface(x[0],x[1],Bi.real)\n>>> plt.show()\n\n```", "```py\n>>> import numpy\n>>> import scipy.special\n>>> scipy.special.jn(5,numpy.pi)\n\n```", "```py\n0.052141184367118461\n\n```", "```py\n>>> import numpy\n>>> import matplotlib.pyplot as plt\n>>> import scipy.interpolate\n>>> x=numpy.linspace(-1,1,10); xn=numpy.linspace(-1,1,1000)\n>>> y=numpy.sin(x)\n>>> polynomial=scipy.interpolate.lagrange(x, numpy.sin(x))\n>>> plt.plot(xn,polynomial(xn),x,y,'or')\n>>> plt.show()\n\n```", "```py\n>>> import numpy\n>>> import scipy.interpolate\n>>> x1=numpy.linspace(1,10,10); y1=numpy.sin(x1)\n>>> Polynomial=scipy.interpolate.BarycentricInterpolator(x1,y1)\n>>> exactValues=numpy.sin(x1+0.3)\n>>> exactValues\n\n```", "```py\narray([ 0.96355819,  0.74570521, -0.15774569, -0.91616594, \n-0.83226744,\n 0.0168139 ,  0.85043662,  0.90217183,  0.12445442, \n-0.76768581])\n\n```", "```py\n>>> interpolatedValues=Polynomial(x1+0.3)\n>>> interpolatedValues\n\n```", "```py\narray([ 0.97103132,  0.74460631, -0.15742869, -0.91631362, \n-0.83216445, \n 0.01670922,  0.85059283,  0.90181323,  0.12588718, \n-0.7825744 ])\n\n```", "```py\n>>> PercentRelativeError = numpy.abs((exactValues - interpolatedValues)/interpolatedValues)*100\n>>> PercentRelativeError\n\n```", "```py\narray([ 0.76960822,  0.14758101,  0.20136334,  0.01611703,  0.01237594, \n 0.62647084,  0.01836479,  0.0397652 ,  1.13812858,  1.90251374])\n\n```", "```py\n>>> x2=numpy.linspace(1.5,10.5,10); y2=numpy.sin(x2)\n>>> Polynomial.add_xi(x2,y2)\n>>> interpolatedValues2=Polynomial(x1+0.3)\n>>> interpolatedValues2\n\n```", "```py\narray([ 0.96355818,  0.74570521, -0.15774569, -0.91616594, -0.83226744,\n 0.0168139 ,  0.85043662,  0.90217183,  0.12445442, -0.76768581])\n\n```", "```py\n>>> PercentRelativeError = numpy.abs((exactValues - interpolatedValues2)/interpolatedValues2)*100\n>>> PercentRelativeError\n\n```", "```py\narray([  1.26241742e-07,   2.02502252e-09,   5.95225989e-10,\n 1.84438143e-11,   8.75086862e-12,   4.14359323e-10,\n 1.75194631e-11,   8.52321518e-11,   9.45285176e-09,\n 1.29570657e-07])\n\n```", "```py\n>>> import numpy\n>>> import matplotlib.pyplot as plt\n>>> import  scipy.interpolate\n>>> x=numpy.array([0,0,1,1,2,2]); y=numpy.array([0,0,1,0,2,0])\n>>> interp=scipy.interpolate.KroghInterpolator(x,y)\n>>> xn=numpy.linspace(0,2,20)   # evaluate polynomial in larger set\n>>> plt.plot(x,y,'o',xn,interp(xn),'r')\n>>> plt.show()\n\n```", "```py\nInterpolatedUnivariateSpline(x, y, w=None, bbox=[None, None], k=3)\n```", "```py\n>>> import numpy\n>>> import matplotlib.pyplot as plt\n>>>import scipy.interpolate\n>>> x=numpy.arange(5); y=numpy.sin(x)\n>>> xn=numpy.linspace(0,4,40)\n>>> interp=scipy.interpolate.InterpolatedUnivariateSpline(x,y)\n>>> plt.plot(x,y,'.',xn,interp(xn))\n>>> plt.show()\n\n```", "```py\n>>> import numpy\n>>> import scipy.interpolate\n>>> import matplotlib.pyplot as plt\n>>> from mpl_toolkits.mplot3d import Axes3D\n>>> x=y=numpy.arange(10)\n>>> f=(lambda i,j: numpy.sin(i)*numpy.cos(j))  # function to interpolate\n>>> A=numpy.fromfunction(f, (10,10))           # generate samples\n>>> spline=scipy.interpolate.RectBivariateSpline(x,y,A)\n>>> fig=plt.figure()\n>>> subplot=fig.add_subplot(111,projection='3d')\n>>> xx=numpy.mgrid[0:9:100j, 0:9:100j]     # larger grid for plotting\n>>> A=spline(numpy.linspace(0,9,100), numpy.linspace(0,9,100))\n>>> subplot.plot_surface(xx[0],xx[1],A)\n>>> plt.show()\n\n```", "```py\n>>> import numpy\n>>> import scipy\n>>> import matplotlib.pyplot as plt\n>>> x=numpy.linspace(0,1,10)\n>>> y=numpy.sin(x*numpy.pi/2)\n>>> line=numpy.polyfit(x,y,deg=1)\n>>> plt.plot(x,y,'.',x,numpy.polyval(line,x),'r')\n>>> plt.show()\n\n```", "```py\n>>> import numpy\n>>> import scipy.interpolate\n>>> import matplotlib.pyplot as plt\n>>> x=numpy.linspace(0,1,10)\n>>> y=numpy.sin(x*numpy.pi/2)\n>>> spline=scipy.interpolate.UnivariateSpline(x,y,k=2)\n>>> xn=numpy.linspace(0,1,100)\n>>> plt.plot(x,y,'.', xn, spline(xn))\n>>> plt.show()\n\n```", "```py\ncurve_fit(f, xdata, ydata, p0=None, sigma=None, **kw)\n```", "```py\n>>> import numpy\n>>> import scipy\n>>> A=18; w=3*numpy.pi; h=0.5\n>>> x=numpy.linspace(0,1,100); y=A*numpy.sin(w*x+h)\n>>> y += 4*((0.5-scipy.rand(100))*numpy.exp(2*scipy.rand(100)**2))\n\n```", "```py\n>>> import scipy.optimize\n>>> p0 = [20, 2*numpy.pi, 1]\n>>> target_function = lambda x,AA,ww,hh: AA*numpy.sin(ww*x+hh)\n\n```", "```py\n>>> pF,pVar = scipy.optimize.curve_fit(target_function, x, y, p0)\n\n```", "```py\n>>> print (pF)\n\n```", "```py\n[ 18.13799397   9.32232504   0.54808516]\n\n```", "```py\nleastsq(func, x0, args=(), Dfun=None, full_output=0,\n        col_deriv=0, ftol=1.49012e-8, xtol=1.49012e-8,\n        gtol=0.0, maxfev=0, epsfcn=0.0, factor=100, diag=None):\n```", "```py\nleastsq(error_function,p0,args=(x,y))\n```", "```py\n>>> import scipy.optimize\n>>> scipy.optimize.fmin(scipy.optimize.rosen,[0,0])\n\n```", "```py\nOptimization terminated successfully.\n Current function value: 0.000000\n Iterations: 79\n Function evaluations: 146\narray([ 1.00000439,  1.00001064])\n\n```", "```py\nminimize( fun, x0, args=(), method='BFGS', jac=None, hess=None, hessp=None, bounds=None, constraints=(),tol=None, callback=None, options=None)\n```", "```py\n>>> import scipy.special\n>>> print (scipy.special.jn_zeros(4,3))\n\n```", "```py\n[  7.58834243  11.06470949  14.37253667]\n\n```", "```py\nroot(fun, x0, args=(), method='hybr', jac=None, tol=None, callback=None, options=None)\n```", "```py\n>>> import numpy \n>>> import matplotlib.pyplot as plt \n>>> f=lambda x: [x[0]**2 - 2*x[0] - x[1] + 0.5, x[0]**2 + 4*x[1]**2 - 4]\n>>> x,y=numpy.mgrid[-0.5:2.5:24j,-0.5:2.5:24j]\n>>> U,V=f([x,y])\n>>> plt.quiver(x,y,U,V,color='r', \\\n linewidths=(0.2,), edgecolors=('k'), \\\n headaxislength=5)\n>>> plt.show()\n\n```", "```py\n>>> import scipy.optimize\n>>> f=lambda x: [x[0]**2 - 2*x[0] - x[1] + 0.5, x[0]**2 + 4*x[1]**2 - 4]\n>>> scipy.optimize.root(f,[0,1])\n\n```", "```py\n status: 1\n success: True\nqtf: array([ -4.81190247e-09,  -3.83395899e-09])\nnfev: 9\n r: array([ 2.38128242, -0.60840482, -8.35489601])\n fun: array([  3.59529073e-12,   3.85025345e-12])\n x: array([-0.22221456,  0.99380842])\n message: 'The solution converged.'\nfjac: array([[-0.98918813, -0.14665209],\n [ 0.14665209, -0.98918813]])\n\n```", "```py\n>>> scipy.optimize.root(f,[2,0])\n\n```", "```py\n status: 1\n success: True\nqtf: array([  2.08960516e-10,   8.61298294e-11])\nnfev: 12\n r: array([-4.56575336, -1.67067665, -1.81464307])\n fun: array([  2.44249065e-15,   1.42996726e-13])\n x: array([ 1.90067673,  0.31121857])\n message: 'The solution converged.'\nfjac: array([[-0.39612596, -0.91819618],\n [ 0.91819618, -0.39612596]])\n\n```", "```py\nquad(func, a, b, args=(), full_output=0, epsabs=1.49e-08, epsrel=1.49e-08, limit=50, points=None, weight=None, wvar=None, wopts=None, maxp1=50, limlst=50)\n```", "```py\n>>> simps(y, x=None, dx=1, axis=-1, even='avg')\n\n```", "```py\n>>> f=lambda t: numpy.exp(-t)*t**4\n>>> from scipy.special import gammainc\n>>> from scipy.integrate import quad\n>>> from scipy.misc import factorial\n>>> print (gammainc(5,1))\n\n```", "```py\n0.00365984682734\n\n```", "```py\nprint('%.19f' % gammainc(5,1))\n\n```", "```py\n0.0036598468273437131\n\n```", "```py\n>>> import numpy\n>>> result,error=quad(f,0,1)/factorial(4)\n>>> result\n\n```", "```py\n0.0036598468273437122\n\n```", "```py\n>>> import numpy \n>>> import scipy.integrate\n>>> x=numpy.linspace(0,1,10000)\n>>> scipy.integrate.simps(f(x)/factorial(4), x)\n\n```", "```py\n0.0036598468273469071\n\n```", "```py\node(f,jac=None)\n```", "```py\n>>> import numpy\n>>> from scipy.integrate import ode\n>>> f=lambda t,y: -20*y        # The ODE\n>>> actual_solution=lambda t:numpy.exp(-20*t)  # actual solution\n>>> dt=0.01            # time step\n>>> solver=ode(f).set_integrator('dop853')  # solver\n>>> solver.set_initial_value(1,0)      # initial value\n>>> while solver.successful() and solver.t<=1+dt:\n # solve the equation at succesive time steps,\n # until the time is greater than 1\n # but make sure that the solution is successful\n print (solver.t, solver.y, actual_solution(solver.t))\n # We compare each numerical solution with the actual\n # solution of the ODE\n solver.integrate(solver.t + dt)    # solve next step\n\n```", "```py\n<scipy.integrate._ode.ode at 0x10eac5e50>\n0 [ 1.] 1.0\n0.01 [ 0.81873075] 0.818730753078\n0.02 [ 0.67032005] 0.670320046036\n0.03 [ 0.54881164] 0.548811636094\n0.04 [ 0.44932896] 0.449328964117\n0.05 [ 0.36787944] 0.367879441171\n0.06 [ 0.30119421] 0.301194211912\n0.07 [ 0.24659696] 0.246596963942\n0.08 [ 0.20189652] 0.201896517995\n0.09 [ 0.16529889] 0.165298888222\n0.1 [ 0.13533528] 0.135335283237\n ...\n0.9 [  1.52299797e-08] 1.52299797447e-08\n0.91 [  1.24692528e-08] 1.24692527858e-08\n0.92 [  1.02089607e-08] 1.02089607236e-08\n0.93 [  8.35839010e-09] 8.35839010137e-09\n0.94 [  6.84327102e-09] 6.84327102222e-09\n0.95 [  5.60279644e-09] 5.60279643754e-09\n0.96 [  4.58718175e-09] 4.58718174665e-09\n0.97 [  3.75566677e-09] 3.75566676594e-09\n0.98 [  3.07487988e-09] 3.07487987959e-09\n0.99 [  2.51749872e-09] 2.51749871944e-09\n1.0   [  2.06115362e-09] 2.06115362244e-09\n\n```", "```py\nodeint(func, y0, t, args=(), Dfun=None, col_deriv=0, full_output=0, ml=None, mu=None, rtol=None, atol=None, tcrit=None, h0=0.0, hmax=0.0, hmin=0.0, ixpr=0, mxstep=0, mxhnil=0, mxordn=12, mxords=5, printmessg=0)\n```", "```py\n>>> import numpy\n>>> from numpy import linspace\n>>> import scipy\n>>> from scipy.integrate import odeint\n>>> import matplotlib.pyplot as plt\n>>> from mpl_toolkits.mplot3d import Axes3D\n>>> sigma=10.0\n>>> b=8/3.0\n>>> r=28.0\n>>> f = lambda x,t: [sigma*(x[1]-x[0]), r*x[0]-x[1]-x[0]*x[2], x[0]*x[1]-b*x[2]]\n\n```", "```py\n>>> t=linspace(0,20,2000); y0=[5.0,5.0,5.0]\n>>> solution=odeint(f,y0,t)\n>>> X=solution[:,0]; Y=solution[:,1]; Z=solution[:,2]\n\n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> plt.gca(projection='3d'); plt.plot(X,Y,Z)\n>>> plt.show()\n\n```", "```py\n>>> plt.rcParams['figure.figsize'] = (10.0, 5.0)\n>>> plt.subplot(121); plt.plot(t,Z)\n>>> plt.subplot(122); plt.plot(Y,Z)\n>>> plt.show()\n\n```"]