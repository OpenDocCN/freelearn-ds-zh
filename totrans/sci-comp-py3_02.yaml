- en: Chapter 2. Variables and Basic Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will present the most important and basic types in Python.
    What is a type? It is a set consisting of data content, its representation, and
    all possible operations. Later in this book, we will make this definition much
    more precise, when we introduce the concepts of a class in [Chapter 8](ch08.html
    "Chapter 8. Classes"), *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables are references to Python objects. They are created by assignments,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Variables take names that consist of any combination of capital and small letters,
    the underscore `_` , and digits. A variable name must not start with a digit.
    Note that variable names are case sensitive. A good naming of variables is an
    essential part of documenting your work, so we recommend that you use descriptive
    variable names.
  prefs: []
  type: TYPE_NORMAL
- en: Python has some *reserved keywords*, which cannot be used as variable names
    (refer to following table, *Table 2.1*). An attempt to use such a keyword as variable
    name would raise a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: '![Variables](img/Table-2.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 2.1: Reserved Python keywords.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As opposed to other programming languages, variables require no type declaration.
    You can create several variables with a multiple assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables can also be altered after their definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two statements can be written by combining the two operations with
    an assignment directly by using increment operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, you will have to work with numbers, so we start by considering
    different forms of numeric types in Python. In mathematics, we distinguish between
    natural numbers (ℕ), integers (ℤ), rational numbers (ℚ), real numbers (ℝ) and
    complex numbers (ℂ). These are infinite sets of numbers. Operations differ between
    these sets and may even not be defined. For example, the usual division of two
    numbers in ℤ might not result in an integer — it is not defined on ℤ.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, like many other computer languages, we have numeric types:'
  prefs: []
  type: TYPE_NORMAL
- en: The numeric type `int`, which is at least theoretically the entire ℤ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numeric type `float`, which is a finite subset of ℝ and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numeric type `complex`, which is a finite subset of ℂ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finite sets have a smallest and a largest number and there is a minimum spacing
    between two numbers; refer to the section on *Floating Point Representation* for
    further details.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest numerical type is the integer type.
  prefs: []
  type: TYPE_NORMAL
- en: Plain integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The statement `k = 3` assigns the variable `k` to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Applying an operation of the type `+`, `-`, or `*` to integers returns an integer.
    The division operator, `//`, returns an integer, while `/` may return a `float:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The set of integers in Python is unbounded; there is no largest integer. The
    limitation here is the computer’s memory rather than any fixed value given by
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the division operator (`/`) in the example returns 3, you might not have
    installed the correct Python version.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you execute the statement `a = 3.0` in Python, you create a floating-point
    number (Python type: `float`). These numbers form a subset of rational numbers,
    ℚ.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively the constant could have been given in exponent notation as `a
    = 30.0e-1` or simply `a = 30.e-1`. The symbol `e` separates the exponent from
    the mantissa, and the expression reads in mathematical notation *a = 30.0 × 10^(−1)*.
    The name *floating-point number* refers to the internal representation of these
    numbers and reflects the floating position of the decimal point when considering
    numbers over a wide range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the elementary mathematical operations `+`, `-`, `*`, and `/` to two
    floating-point numbers or to an integer and a floating-point number returns a
    floating-point number. Operations between floating-point numbers rarely return
    the exact result expected from rational number operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This facts matters, when comparing floating point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Floating point representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Internally, floating-point numbers are represented by four quantities: the
    sign, the mantissa, the exponent sign, and the exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Floating point representation](img/float1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with *β* ϵ *ℕ* and *x[0]*≠ 0, 0 ≤ *x[i]≤ β*
  prefs: []
  type: TYPE_NORMAL
- en: '*x*[0]...x[t-1] is called the mantissa, *β* the basis and *e* the exponent
    *|e| ≤ U* . *t* is called the mantissa length. The condition *x*[0] ≠ 0 makes
    the representation unique and saves, in the binary case (*β* = 2), one bit.'
  prefs: []
  type: TYPE_NORMAL
- en: There exist two-floating point zeros +0 and -0, both represented by the mantissa
    0.
  prefs: []
  type: TYPE_NORMAL
- en: On a typical Intel processor, *β* = 2 . To represent a number in the `float`
    type 64 bits are used, namely 2 bits for the signs, *t* = 52 bits for the mantissa
    and 10 bits for the exponent `|e|`. The upper bound *U* for the exponent is consequently
    2^(10)-1 *=* 102*3*.
  prefs: []
  type: TYPE_NORMAL
- en: With this data the smallest positive representable number is
  prefs: []
  type: TYPE_NORMAL
- en: fl[min] = 1.0 *×* 2^(-1023) ≈ 10^(-308) and the largest is  fl[max] = 1.111...1
    *×* 2^(1023) ≈ 10^(308)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Note that floating-point numbers are not equally spaced in [0, fl[max]]. There
    is in particular a  gap at zero (refer to [[29]](apa.html "Appendix . References")).
    The distance between 0 and the first positive number is 2^(-1023), while the distance
    between the first and the second is smaller by a factor *2*^(-52)*≈ 2.2* *×* 10^(-16).
    This effect, caused by the normalization *x*[0] *≠ 0*, is visualized in *Figure
    2.1*.
  prefs: []
  type: TYPE_NORMAL
- en: This gap is filled equidistantly with subnormal floating-point numbers to which
    such a result is rounded. Subnormal floating-point numbers have the smallest possible
    exponent and do not follow the convention that the leading digit *x[0]* has to
    differ from zero; refer to [[13]](apa.html "Appendix . References").
  prefs: []
  type: TYPE_NORMAL
- en: Infinite and not a number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are in total![Infinite and not a number](img/float2.jpg) floating-point
    numbers. Sometimes a numerical algorithm computes floating-point numbers outside
    this range.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generates number over- or underflow. In SciPy the special floating-point
    number `inf` is assigned to overflow results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Working with `inf` may lead to mathematically undefined results. This is indicated
    in Python by assigning the result another special floating-point number, `nan`.
    This stands for not-a-number, that is, an undefined result of a mathematical operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are special rules for operations with `nan` and `inf`. For instance,
    `nan` compared to anything (even to itself) always returns `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See *Exercise 4* for some surprising consequences of the fact that `nan` is
    never equal to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The float `inf` behaves much more as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: One way to check for `nan` and `inf` is to use the  `isnan` and `isinf` functions.
    Often, one wants to react directly when a variable gets the value `nan` or `inf`.
    This can be achieved by using the NumPy command `seterr`. The following command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: would raise an error if a calculation were to return one of those values.
  prefs: []
  type: TYPE_NORMAL
- en: Underflow - Machine Epsilon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underflow occurs when an operation results in a rational number that falls into
    the gap at zero; refer to *Figure 2.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Underflow - Machine Epsilon](img/floatz.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The floating point gap at zero, here t = 3, U = 1'
  prefs: []
  type: TYPE_NORMAL
- en: The *machine epsilon* or rounding unit is the largest number *ε* such that float*(*1.0
    *+ ε) =* 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that *ε* ≈ *β*^(1-t)/2 = 1.1102 × 10^(-16) on most of today’s computers.
    The value that is valid on the actual machine you are running your code on is
    accessible using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The variable `sys.float_info`  contains more information about the internal
    representation of the float type on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `float`  converts other types to a floating-point number—if possible.
    This function is especially useful when converting an appropriate string to a
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Other float types in NumPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NumPy also provides other float types, known from other programming languages
    as double-precision and single-precision numbers, namely `float64` and `float32`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The second last line demonstrates that `a` and `a1` do not differ in accuracy.
    In the first two lines, they only differ in the way they are displayed. The real
    difference in accuracy is between `a` and its single-precision counterpart, `a2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The NumPy function `finfo`  can be used to display information on these floating-point
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complex numbers are an extension of the real numbers frequently used in many
    scientific and engineering fields.
  prefs: []
  type: TYPE_NORMAL
- en: Complex Numbers in Mathematics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complex numbers consist of two floating-point numbers, the real part *a* of
    the number and its imaginary part *b*. In mathematics, a complex number is written
    as *z=a+b*i, where i defined by i*² =* -1 is the imaginary unit. The conjugate
    complex counterpart of *z* is ![Complex Numbers in Mathematics](img/conjcomplex.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: If the real part *a* is zero, the number is called an imaginary number.
  prefs: []
  type: TYPE_NORMAL
- en: The j notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, imaginary numbers are characterized by suffixing a floating-point
    number with the letter `j`, for example, `z = 5.2j`. A complex number is formed
    by the sum of a floating-point number and an imaginary number, for example, `z
    = 3.5 + 5.2j`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While in mathematics the imaginary part is expressed as a product of a real
    number *b* with the imaginary unit i, the Python way of expressing an imaginary
    number is not a product: `j` is just a suffix to indicate that the number is imaginary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is demonstrated by the following small experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `conjugate` returns the conjugate of `z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Real and imaginary parts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One may access the real and imaginary parts of a complex number *z* using the
    `real` and `imag` attributes. Those attributes are read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not possible to convert a complex number to a real number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, the `real` and `imag` attributes as well as the conjugate method
    work just as well for complex arrays *([Chapter 4](ch04.html "Chapter 4. Linear
    Algebra – Arrays")*, *Linear Algebra – Arrays)*. We demonstrate this by computing
    the *N*^(th) roots of unity which are ![Real and imaginary parts](img/rootsofunity.jpg),
    that is, the *N* solutions of the equation ![Real and imaginary parts](img/rootsofunity1.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The resulting figure (*Figure 2.2*) shows the roots of unity together with the
    unit circle. (For more details on how to make plots, refer [Chapter 6](ch06.html
    "Chapter 6. Plotting"), *Plotting.*)
  prefs: []
  type: TYPE_NORMAL
- en: '![Real and imaginary parts](img/nrootsofunity.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Roots of unity together with a unit circle'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is of course possible to mix the previous methods, as illustrated by the
    following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boolean is a datatype named after *George Boole* (1815-1864). A Boolean variable
    can take only two values, `True` or `False`. The main use of this type is in logical
    expressions. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean expressions are often used in conjunction with the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Boolean operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boolean operations are performed using the `and`, `or`, and `not` keywords
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The operators follow some precedence rules (refer to section *Executing scripts*
    in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting started*) which
    would make the parentheses in the third line and in the last obsolete (it is a
    good practice to use them anyway to increase the readability of your code). Note
    that the `and` operator is implicitly chained in the following Boolean expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Rules of Conversion to Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Boolean operators](img/Capture.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 2.2 : Rule of conversion to Boolean'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most objects Python may be converted to Booleans; this is called *Boolean casting*.
    The built-in function `bool` performs that conversion. Note that most objects
    are cast to `True`, except `0`, the empty tuple, the empty list, the empty string,
    or the empty array. These are all cast to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is *not* possible to cast arrays into Booleans unless they contain no or
    only one element; this is explained further in [Chapter 5](ch05.html "Chapter 5. Advanced
    Array Concepts"), *Advanced Array Concepts*. The previous table contains summarized
    rules for Boolean casting. Some usage examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Automatic Boolean casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using an `if` statement with a non-Boolean type will cast it to a Boolean.
    In other words, the following two statements are always equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical example is testing whether a list is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An empty array, list, or tuple will return `False`. You can also use a variable
    in the `if` statement, for example, an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used `%` for the modulo operation, which returns the remainder
    of an integer division. In this case, it returns `0` or `1` as the remainder after
    modulo `2`.
  prefs: []
  type: TYPE_NORMAL
- en: In this last example, the values `0` or `1` are cast to `bool`. Boolean operators
    `or`,`and` , and `not` will also implicitly convert some of their arguments to
    a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Return values of and and or
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that the operators `and` and `or` do not necessarily produce Boolean values.
    The expression `*x* and *y*` is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And the expression `x or y` is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, this means that when executing the statement `True or x`, the
    variable `x` need not even be defined! The same holds for `False and x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, unlike their counterparts in mathematical logic, these operators
    are no longer commutative in Python. Indeed, the following expressions are not
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Boolean and integer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In fact, Booleans and integers are the same. The only difference is in the
    string representation of 0 and 1 which is in the case of Booleans `False` and
    `True` respectively. This allows constructions like this (for the format method
    refer section on *string formatting*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We note for readers already familiar with the concept of subclasses, that the
    type `bool` is a subclass of the type `int` (refer to [Chapter 8](ch08.html "Chapter 8. Classes"),
    *Classes*). Indeed, all four inquiries `isinstance(True, bool)`, `isinstance(False,
    bool)`, `isinstance(True, int)`, and `isinstance(False, int)` return the value
    `True` (refer to section *Type Checking* in [Chapter 3](ch03.html "Chapter 3. Container
    Types"), *Container Types*).
  prefs: []
  type: TYPE_NORMAL
- en: Even rarely used statements such as `True+13` are syntactically correct.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The type `string` is a type used for text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A string is enclosed either by single or double quotes. If a string contains
    several lines, it has to be enclosed by three double quotes `"""` or three single
    quotes `'''`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings can be indexed with simple indexes or slices (refer to [Chapter 3](ch03.html
    "Chapter 3. Container Types"), *Container Types*, for a comprehensive explanation
    on slices):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are immutable; that is, items cannot be altered. They share this property
    with tuples. The command **`book[1] = ''a''`** returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The string `''\n''` is used to insert a line break  and `''t''` inserts a horizontal
    tabulator (TAB) into the string to align several lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'These strings are examples of *escape sequences*. Escape sequences always start
    with a backslash, `\` . A multi line string automatically includes escape sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A special escape sequence is `""`, which represents the backslash symbol in
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be achieved by using a raw string instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in raw strings, the backslash remains in the string and is used to
    escape some special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Operations on strings and string methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Addition of strings means concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplication is just repeated addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When strings are compared, lexicographical order applies and the uppercase
    form precedes the lowercase form of the same letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Among the variety of string methods, we will mention here only the most important
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Splitting a string**: This method generates a list from a string by using
    a single or multiple blanks as separators. Alternatively, an argument can be given
    by specifying a particular string as a separator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Joining a list to a string**: This is the reverse operation of splitting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Searching in a string**: This method returns the first index in the string,
    where a given search substring starts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the search string is not found, the return value of the method is -1 .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'String formatting is done using the `format` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The function `format` is a string method; it scans the string for the occurrence
    of placeholders, which are enclosed by curly brackets. These placeholders are
    replaced in a way specified by the argument of the format method. How they are
    replaced depends on the format specification defined in each `{}` pair. Format
    specifications are indicated by a colon, `":"`, as their prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format method offers a range of possibilities to customize the formatting
    of objects depending on their types. Of particular use in scientific computing
    are the formatting specifiers for the `float` type. One may choose either the
    standard with `{:f}` or the exponential notation with `{:e}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The format specifiers allow to specify the rounding precision (digits following
    the decimal point in the representation). Also the total number of symbols including
    leading blanks to represent the number can be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the name of the object that gets its value inserted is given
    as an argument to the format method. The first `{}` pair is replaced by the first
    argument and the following pairs by the subsequent arguments. Alternatively, it
    may also be convenient to use the key-value syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, two values are processed, a string `name` without a format specifier and
    a float `value` that is printed in fixed point notation with one digit after the
    decimal point. (We refer to the complete reference documentation for more details
    on *string formatting*, [[34]](apa.html "Appendix . References")).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Braces in the string**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a string might contain a pair of curly braces, which should not
    be considered as placeholders for a `format` method. In that case, double braces
    are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r"we {} in LaTeX \begin{{equation}}".format(''like'')`'
  prefs: []
  type: TYPE_NORMAL
- en: This returns the following string: `'we like in LaTeX \\begin{equation}'`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you met the basic data types in Python and saw the corresponding
    syntax elements. We will work mostly with numeric types such as integers, floats
    and complex.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans are needed for setting conditions, and by using strings, we often communicate
    results and messages.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1 **→ Check whether *x =* 2.3 is a zero of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/polynomialCh2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 2 →** According to de Moivre''s formula, the following holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/deMoivre-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Choose numbers *n* and *x* and verify that formula in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3 →** Complex numbers. Verify Euler''s formula in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/EulersFormula.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 4 →** Suppose we are trying to check the convergence of a diverging sequence
    (here the sequence is defined by the recursive relation *u[n]*[+1]= 2*u[n]* and
    u[0] = 1.0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since the sequence does not converge, the code should print the `No convergence`
    message. Execute it to see what happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What happens if you replace the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It should give exactly the same result, shouldn't it? Run the code again to
    see what happens.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What happens if you replace *u=1.0* by *u=1* (without decimal point). Run the
    code to check your predictions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the unexpected behavior of this code. The key to understand what happens
    is that `inf`evaluates to `nan`, and the comparison of `nan` with anything else
    is returns always the value  `False` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ex. 5 →** An implication *C = (A ⇒ B)* is a Boolean expression that is defined
    as'
  prefs: []
  type: TYPE_NORMAL
- en: '*C* is `True` if *A* is `False` or *A* and *B* are both `True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C* is `False` otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Python function `implication(A, B)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Ex. 6 →** This exercise is to train Boolean operations. Two binary digits
    (bits) are added by using a logical device called a **half adder**. It produces
    a carry bit (the digit of the next higher value) and the sum as defined by the
    following table, and half adder circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **p** | **q** | **sum** | **carry** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Definition of the half adder operation
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/half_adder.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A half adder circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'A full adder consists of two half adders and sums up two bits and an additional
    carry bit on the input (refer to the following figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/full_adder.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: A full adder circuit'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function that implements a half adder and another that implements a
    full adder. Test these functions.
  prefs: []
  type: TYPE_NORMAL
