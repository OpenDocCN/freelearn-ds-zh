<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. The End of the Beginning</h1></div></div></div><p>This book is almost done, but there is so much more to know about writing code in Python and ArcPy. Unfortunately, I can't fit it all into one book, but that also means that you get to have fun exploring all of the methods and properties of ArcPy. As a conclusion to the book, we will cover some other important topics that can crop up when writing ArcPy scripts. Combined with the lessons from earlier chapters, I hope you'll soon be using ArcPy at work, at school, or just for fun (why not?).</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with field information – types, aliases, domains, spatial types, and more</li><li class="listitem" style="list-style-type: disc">Accessing information describing a Feature Class</li><li class="listitem" style="list-style-type: disc">Automatically generating a Feature Class and populating it with fields</li><li class="listitem" style="list-style-type: disc">Automatically creating File Geodatabases and Feature Datasets</li><li class="listitem" style="list-style-type: disc">Creating a Script tool that will run the bus stop analysis and generate results in an automatically generated File Geodatabase, Feature Dataset, and Feature Class</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec58"/>Getting field information from feature classes</h1></div></div></div><p>When <a id="id423" class="indexterm"/>creating script tools, or just running <a id="id424" class="indexterm"/>a script, there can be times that extracting field information from a feature class (or shapefile) is necessary. This information can include field names and aliases, field type and length, scale, domains, or subtypes. These are all properties available through the <code class="literal">arcpy.ListFields</code> method. We'll explore the many properties, how to extract them, and how to use them in a script.</p><p>By organizing the ArcPy methods into a function, the data is organized in a form that we prefer, instead of relying on the default organization used by the designers of ArcPy. It's important to remember that scripts you create should reflect your needs, and creating these function <strong>wrappers</strong> is one step forward towards polishing the raw ArcPy tools to work in <a id="id425" class="indexterm"/>your <a id="id426" class="indexterm"/>workflows.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec84"/>Accessing the ListFields' properties</h2></div></div></div><p>The List Fields tool is<a id="id427" class="indexterm"/> available as an ArcPy method. <code class="literal">Arcpy.ListFields</code> accepts only one parameter, a feature class, or shapefile. Once the parameter<a id="id428" class="indexterm"/> has been passed, a series of important properties are available using dot notation. To take further advantage of these properties, we will create functions that make it easy to get the information we want, in the format we require.</p><div><div><div><div><h3 class="title"><a id="ch12lvl3sec37"/>List comprehensions</h3></div></div></div><p>Within these <a id="id429" class="indexterm"/>field information functions, we will take advantage <a id="id430" class="indexterm"/>of a Python data structure known as list comprehensions. They simplify the <code class="literal">for</code> loop structure to make it easier to populate a list with the values required (the field information in this case).</p><p>To create a list comprehension, a <code class="literal">for</code> loop is generated inside a set of brackets, and the list is populated with the generated values. Here is an example of a list comprehension that creates a list with the square values of the numbers from 1 to 10, as run in the Python interpreter:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt;originalList = range(1,11)</strong>
<strong>&gt;&gt;&gt;print originalList</strong>
<strong>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</strong>
<strong>&gt;&gt;&gt;newList =  [x**2 for x in originalList]</strong>
<strong>&gt;&gt;&gt;print newList</strong>
<strong>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</strong>
</pre></div><p>List comprehensions are used because they are faster and easier to write, though it may take some time to get used to the syntax. Experiment with them to better understand their use and limitations, and also consult some of the many resources available online.</p></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec85"/>Creating the field information functions</h2></div></div></div><p>Each <a id="id431" class="indexterm"/>of the functions will be a separate<a id="id432" class="indexterm"/> entity, but they will all have a similar structure. One parameter will be accepted by each function, the feature class of interest. ArcPy will be imported, and later deleted from memory, to make sure that the <code class="literal">ListFields()</code> method can be called without an error. Once the feature class is passed to the <code class="literal">ListFields()</code> method, the values desired will populate a list inside a list comprehension. Once it has been populated, it is returned from the function using the return keyword.</p><p>Here is the set of functions for the field names:</p><div><pre class="programlisting">
<strong>def returnfieldnames(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fieldnames = [f.name for f in arcpy.ListFields(fc)]</strong>
<strong>    del arcpy</strong>
<strong>    return fieldnames</strong>

<strong>def returnfieldalias(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fieldalias = [f.aliasName for f in arcpy.ListFields(fc)]</strong>
<strong>    del arcpy</strong>
<strong>    return fieldalias</strong>

<strong>def returnfieldbasename(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fieldtypes = [f.baseName for f in arcpy.ListFields(fc)]</strong>
<strong>    del arcpy</strong>
<strong>    return fieldtypes</strong>
</pre></div><p>These <a id="id433" class="indexterm"/>name functions are useful when<a id="id434" class="indexterm"/> creating a new feature class based on another feature class. Sometimes there is a need to preserve the exact names and aliases from the original feature class, and using these functions will make this possible. When doing this, there is a need to provide other field information as well. Here are the functions related to field types, lengths, precision, and scale:</p><div><pre class="programlisting">
<strong>def returnfieldtypes(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fieldtypes = [f.type for f in arcpy.ListFields(fc)]</strong>
<strong>    del arcpy</strong>
<strong>    return fieldtypes</strong>

<strong>def returnfieldlength(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fieldlengths = [f.length for f in arcpy.ListFields(fc)]</strong>
<strong>    del arcpy</strong>
<strong>    return fieldlengths</strong>

<strong>def returnfieldprecision(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fieldprecise = [f.precision for f in arcpy.ListFields(fc)]</strong>
<strong>    del arcpy</strong>
<strong>    return fieldprecise</strong>

<strong>def returnfieldscale(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fieldscales = [f.scale for f in arcpy.ListFields(fc)]</strong>
<strong>    del arcpy</strong>
<strong>    return fieldscales</strong>
</pre></div><p>There is even a property used to request domain information:</p><div><pre class="programlisting">
<strong>def returnfielddomain(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fielddomains = [f.domain for f in arcpy.ListFields(fc)]</strong>
<strong>    del arcpy</strong>
<strong>    return fielddomains</strong>
</pre></div><p>These<a id="id435" class="indexterm"/> functions all share the structure discussed <a id="id436" class="indexterm"/>earlier, and have the advantage of being simple to use and easy to search throughout. Because fields in a feature class have a specific order, each list returned by the functions will have an order to the information returned, accessible by a specific index number.</p><p>The <code class="literal">fieldsubtypes</code> are also available through the data access module. Because they are related to the fields, they are returned as a dictionary:</p><div><pre class="programlisting">
<strong>def returnfieldsubtypes(fc):</strong>
<strong>    import arcpy</strong>
<strong>    fieldsubdic = {}</strong>
<strong>    subtypes = arcpy.da.ListSubtypes(fc)</strong>
<strong>    for stcode, stdict in subtypes.iteritems():</strong>
<strong>        for stkey in stdict.iterkeys():</strong>
<strong>            if stkey == 'FieldValues':</strong>
<strong>                fields = stdict[stkey]</strong>
<strong>                for field, fieldvals in fields.iteritems():</strong>
<strong>                    sub = fieldvals[0]</strong>
<strong>                    desc = fieldvals[1]</strong>
<strong>                    fieldsubdic[field] = sub, desc</strong>

<strong>    del arcpy</strong>
<strong>    return fieldsubdic</strong>
</pre></div><div><div><h3 class="title"><a id="note24"/>Note</h3><p>Adding these functions to the <code class="literal">useful.py</code> script in the common module will make them available to any script or script tool. Use the <code class="literal">import</code> keyword to add them to any new script. They are self-contained functions that only require the file path to the feature class of interest.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec86"/>Querying feature class information</h2></div></div></div><p>Some<a id="id437" class="indexterm"/> important pieces of information about<a id="id438" class="indexterm"/> an incoming feature class cannot be accessed using the <code class="literal">ListFields()</code> method. Instead, a number of different methods will be used to find the Geometry type, or Spatial Reference, or the field subtype of each feature class. Some of these are discovered using ArcPy's <code class="literal">Describe</code> method, built to provide</p><p>For the Geometry type, we will use the <code class="literal">shapeType</code> property of the <code class="literal">Describe()</code> method:</p><div><pre class="programlisting">
<strong>def returngeometrytype(fc):</strong>
<strong>    import arcpy</strong>
<strong>    arcInfo = arcpy.Describe(fc)</strong>
<strong>    geomtype = arcInfo.shapeType</strong>
<strong>    del arcpy</strong>
<strong>    return str(geomtype)</strong>
</pre></div><p>The name of the Shape field (which usually defaults to Shape) can also be requested using the <code class="literal">Describe</code> method and returns a string data type:</p><div><pre class="programlisting">
<strong>def returngeometryname(fc):</strong>
<strong>    import arcpy</strong>
<strong>    arcInfo = arcpy.Describe(fc)</strong>
<strong>    geomname = arcInfo.shapeFieldName</strong>
<strong>    del arcpy</strong>
<strong>    return str(geomname)</strong>
</pre></div><p>The feature class <code class="literal">spatial_reference</code> is also available through the <code class="literal">Describe</code> method. The data is returned as a <code class="literal">spatial_reference</code> object:</p><div><pre class="programlisting">
<strong>def returnspatialreference(fc):</strong>
<strong>    import arcpy</strong>
<strong>    spatial_reference = arcpy.Describe(fc).spatialReference</strong>
<strong>    del arcpy</strong>
<strong>    return spatial_reference</strong>
</pre></div><p>A <code class="literal">spatial_reference</code> object has a number of important properties. The <code class="literal">projectionname</code> and <code class="literal">projectioncode</code> are among the important</p><div><pre class="programlisting">
<strong>def returnprojectioncode(fc):</strong>
<strong>    import arcpy</strong>
<strong>    spatial_reference = arcpy.Describe(fc).spatialReference</strong>
<strong>    proj_code = spatial_reference.projectionCode</strong>
<strong>    del arcpy</strong>
<strong>    return  proj_code</strong>

<strong>def returnprojectionname(fc):</strong>
<strong>    import arcpy</strong>
<strong>    spatial_reference = arcpy.Describe(fc).spatialReference</strong>
<strong>    proj_name = spatial_reference.name</strong>
<strong>    del arcpy</strong>
<strong>    return  proj_name</strong>
</pre></div><p>Many<a id="id439" class="indexterm"/> other properties and methods can<a id="id440" class="indexterm"/> be similarly utilized to make them available within scripts or script tools. Explore the ArcGIS help documents for further insights into the properties available through the <code class="literal">Describe</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec87"/>Generating File Geodatabases and feature classes</h2></div></div></div><p>File Geodatabases do not have to exist before a script is run; instead, they can be generated <a id="id441" class="indexterm"/>when a script is executed using<a id="id442" class="indexterm"/> the <code class="literal">CreateFileGDB</code> tool, which is also an ArcPy method. Once the <code class="literal">File</code> Geodatabase has been created, <code class="literal">Feature Datasets</code> can be added.</p><p>Generating the File Geodatabase is very easy. The only parameters are the folders to place it inside, and the name of the Geodatabase:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>folderPath = r"C:\Projects"</strong>
<strong>gdbName = "ArcPy.gdb"</strong>
<strong>arcpy.CreateFileGDB_management(folderPath, gdbName)</strong>
</pre></div><p>The Feature Datasets are more difficult to create, as there is an optional spatial reference parameter that requires a Spatial Reference object to be generated. While the Spatial Reference object is optional, it is highly recommended.</p><p>There are a few options to generate the <code class="literal">SpatialReference</code> object. One of them uses the <code class="literal">return specialReference()</code> function defined earlier; by passing a feature class to the function, a Spatial Reference object is created. Another method would be to pass a file path to a projection file <code class="literal">.prj</code> as the optional third parameter. A third method is to generate a Spatial Reference object by using the <code class="literal">arcpy.SpatialReference</code> method and passing it a projection code or a projection string:</p><div><pre class="programlisting">
<strong>spatialReference = arcpy.SpatialReference(2227)</strong>
</pre></div><p>However it is generated, it is then passed to the <code class="literal">arcpy.CreateFeatureDataset</code> method along with the file path of the File Geodatabase and the name of the Feature Dataset:</p><div><pre class="programlisting">
<strong>spatialReference = arcpy.SpatialReference(2227)</strong>
<strong>fileGDB = r"{0}\{1}".format(folderPath,gdbName)</strong>
<strong>featureDataset = "Chapter12Results"</strong>
<strong>arcpy.CreateFeatureDataset_management(fileGDB, featureDataset,   spatialReference)
</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec88"/>Generating a feature class</h2></div></div></div><p>Now that a File Geodatabase and a Feature Dataset have been created, let's generate a Feature Class inside the Feature Dataset. This is done using the <code class="literal">arcpy.CreateFeatureClass</code> method. This method has a number of optional parameters, including a <a id="id443" class="indexterm"/>Feature Class to use as a template and a Spatial Reference. For this example, there is no need to use the Spatial Reference parameter as it is being written to a Feature Dataset, which dictates the Spatial Reference used. The template parameter will copy the fields of the template Feature Class, but for now, we will only create the Shape field:</p><div><pre class="programlisting">
<strong>featureClass = "BufferArea"</strong>
<strong>geometryType = "POLYGON"</strong>
<strong>featurePath = r"{0}\{1}".format(fileGDB,featureDataset)</strong>
<strong>arcpy.CreateFeatureclass_management(featurePath, featureClass,  geometryType)
</strong>
</pre></div><p>The created Feature Class will need some fields with the attribute information that will be populated later. The fields have a number of parameters that depend on the field type, including length, precision, and alias, among others:</p><div><pre class="programlisting">
<strong>fieldName = "STOPID"</strong>
<strong>fieldAlias = "Bus Stop Identifier"</strong>
<strong>fieldType = "LONG"</strong>
<strong>fieldPrecision = 9</strong>
<strong>featureClassPath = r"{0}\{1}".format(featurePath,featureClass)</strong>
<strong>arcpy.AddField_management(featureClassPath, fieldName,fieldType, fieldPrecision,</strong>
<strong>"", "", fieldAlias)</strong>
</pre></div><p>Let's add a second field to hold the averaged population values produced by the Bus Stop analysis:</p><div><pre class="programlisting">
<strong>fieldName2 = "AVEPOP"</strong>
<strong>fieldAlias2 = "Average Census Population"</strong>
<strong>fieldType2 = "FLOAT"</strong>
<strong>featureClassPath = r"{0}\{1}".format(featurePath,featureClass)</strong>
<strong>arcpy.AddField_management(featureClassPath, fieldName2, fieldType2, "", "", "", fieldAlias2)</strong>
</pre></div><p>The File Geodatabase, Feature Dataset, and Feature Class fields have now been generated. Let's extend the script into a script tool by adding the Bus Stop analysis functions, while writing the results to the generated <strong>Feature Class</strong>. Creating, a script tool that populates a feature class.</p><p>This script tool will borrow from the ideas outlined in <a class="link" href="ch10.html" title="Chapter 10. Advanced Geometry Object Methods">Chapter 10</a>, <em>Advanced Geometry Object Methods</em> and will create a union of the Polygon Geometry objects that intersect with the buffered bus stops to populate the <strong>Shape field</strong>, along with the <strong>bus stop ID</strong> and the averaged population for the blocks intersected with each buffer.</p><p>Open the script <code class="literal">Chapter12_3.py</code> and explore its contents. Coupled with the code snippets<a id="id444" class="indexterm"/> mentioned earlier and the use of <code class="literal">arcpy.GetParameterAsText</code> to get data from the script tool, the data generated will be written in a feature class by the following code:</p><div><pre class="programlisting">
<strong>arcpy.AddMessage("Beginning Analysis")</strong>
<strong>insertCursor = arcpy.da.InsertCursor(featureClassPath,['SHAPE@',fieldName, fieldName2])</strong>
<strong>arcpy.MakeFeatureLayer_management(censusBlocks2010,"census_lyr")</strong>

<strong>with arcpy.da.SearchCursor(busStops, ['SHAPE@', busStopField],sql) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        stop = row[0]</strong>
<strong>        stopID = row[1]</strong>
<strong>        busBuffer = stop.buffer(400)</strong>
<strong>        arcpy.SelectLayerByLocation_management("census_lyr","intersect",busBuffer,'','NEW_SELECTION')</strong>
<strong>        censusShapes = []</strong>
<strong>        censusPopList = []</strong>
<strong>        with arcpy.da.SearchCursor("census_lyr", ['SHAPE@',censusBlockPopField]) as ncursor:</strong>
<strong>            for nrow in ncursor:</strong>
<strong>                censusShapes.append(nrow[0])</strong>
<strong>                censusPopList.append(nrow[1])</strong>

<strong>        censusUnion = censusShapes[0]</strong>
<strong>        for block in censusShapes[1:]:</strong>
<strong>            censusUnion = censusUnion.union(block)</strong>

<strong>        censusPop = sum(censusPopList)/len(censusPopList)</strong>
<strong>        finalData = (censusUnion,stopID, censusPopulation)</strong>
<strong>        insertCursor.insertRow(finalData)</strong>
<strong>arcpy.AddMessage("Analysis Complete")</strong>
</pre></div><p>The script combines many of the ideas that have been introduced throughout the book to allow the user to run a complete workflow that generates a feature class containing the results of the analysis. By adding only the fields of interest and populating them with the unioned <code class="literal">Polygon</code> objects, the script eliminates most of the cruft, normally created when running a spatial analysis, and produces a results dataset that can be viewed in ArcMap.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec89"/>Setting up the script tool parameters</h2></div></div></div><p>Here <a id="id445" class="indexterm"/>is how the parameters of the script tool <a id="id446" class="indexterm"/>look when set up:</p><div><img src="img/8662OS_12_01.jpg" alt="Setting up the script tool parameters"/></div><p>The list of parameters is long, so I am using two images to portray them. It is important to choose the correct data type for each parameter as it will control the dialog generated to retrieve the data.</p><p>The <strong>bus stop ID field</strong> and the <strong>Population</strong> field are both obtained from their respective feature classes. The <strong>File Geodatabase</strong> name is a string and the code will append <code class="literal">.gdb</code> to the end of the input string if it is not entered initially, to make sure that it can be correctly generated. It should not already exist; it will not be generated if it does (if desired, this can be changed by setting the <code class="literal">arcpy.env.overwriteOutput</code> property to <code class="literal">True</code> after the <code class="literal">import</code> statement).</p><p>Once the parameters have been set, and the tool has a name and description, save it and then open the tool. It should look like this once it has been filled out:</p><div><img src="img/8662OS_12_02.jpg" alt="Setting up the script tool parameters"/></div><p>Click<a id="id447" class="indexterm"/> on <strong>OK</strong> to run the tool. Open <strong>ArcMap</strong> and<a id="id448" class="indexterm"/> add the results, along with the San Francisco polygon and the <code class="literal">Inbound71</code> feature class from <em>Chapter 4</em>, <em>Complex ArcPy Scripts and Generalizing Functions</em>. The results will look similar to this, after a bit of cartographic symbolizing:</p><div><img src="img/8662OS_12_03.jpg" alt="Setting up the script tool parameters"/></div><p>The final<a id="id449" class="indexterm"/> result will have one row per bus <a id="id450" class="indexterm"/>stop selected, along with the averaged population and the bus stop ID value. Instead of using a spreadsheet as an output, the feature class will allow to make maps or produce further spatial analysis. Producing custom data using custom script tools puts you in the driver's seat when performing geospatial analyses and makes your tools, and you, a valuable asset to any team.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec90"/>Environmental settings</h2></div></div></div><p>The ArcPy <a id="id451" class="indexterm"/>module allows for the control of global settings <a id="id452" class="indexterm"/>that controls input and output processes using ArcPy's <code class="literal">env</code> class. These settings will have an effect on the accuracy of data produced using geospatial analysis tools. Resolution and tolerance settings for <em>X</em>, <em>Y</em>, <em>Z</em>, and <em>M</em> coordinates can be controlled, along with output extent, raster cell size, analysis workspace, and many other settings.</p><p>To access the environmental settings using ArcPy, the class <code class="literal">env</code> is imported from <code class="literal">arcpy</code>:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from arcpy import env</strong>
</pre></div><p>It can also be<a id="id453" class="indexterm"/> called using dot notation shown as follows. Setting<a id="id454" class="indexterm"/> the workspace removes the need to pass a file path to any subsequent methods called on the <code class="literal">workspace</code>. Here is an example of setting the workspace and calling the <code class="literal">ListDatasets()</code> method without passing a file path as a parameter:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import arcpy</strong>
<strong>&gt;&gt;&gt; arcpy.env.workspace = r"C:\Projects\SanFrancisco.gdb"</strong>
<strong>&gt;&gt;&gt; arcpy.ListDatasets()</strong>
<strong>[u'SanFrancisco', u'Chapter3Results', u'Chapter4Results', u'Chapter5Results', u'Chapter7Results', u'Chapter11Results']</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch12lvl3sec38"/>Resolution and tolerance settings</h3></div></div></div><p>The <a id="id455" class="indexterm"/>resolution and tolerance settings control the accuracy<a id="id456" class="indexterm"/> of the output of any data produced by a tool in ArcToolbox or when running a script using ArcPy. These can (and should) be set for Feature Datasets in File Geodatabases or Enterprise Geodatabases, but it is important to set them for analysis run in the memory or when using shapefiles, or if the geospatial analysis requires greater accuracy than used by those Geodatabases.</p><p>Setting the resolutions and tolerances require an understanding of the accuracy required for your projects. These settings will limit the ability to snap to a line or find points that intersect with a line. The linear unit will need to reflect the coordinate system of choice:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>arcpy.env.MResolution = 0.0005</strong>
<strong>arcpy.env.MTolerance = 0.005</strong>
<strong>arcpy.env.ZResolution = "0.0025 Feet"</strong>
<strong>arcpy.env.ZTolerance = "0.001 Feet"</strong>
<strong>arcpy.env.XYResolution = "0.00025 Feet"</strong>
<strong>arcpy.env.XYTolerance = "0.0005 Feet"</strong>
</pre></div><p>Other important environmental settings include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>Extent</strong> setting, which limits the extent of any data produced from an analysis<a id="id457" class="indexterm"/> by setting a rectangle of interest using an <code class="literal">Extent</code> object, or a string with space delimited coordinates (<code class="literal">Xmin</code>, <code class="literal">Ymin</code>, <code class="literal">Xmax</code>, <code class="literal">Ymax</code>) in the current coordinate system.</li><li class="listitem" style="list-style-type: disc">The <strong>Mask</strong> setting, which limits raster analysis to areas that intersect with a feature class <a id="id458" class="indexterm"/>or a raster passed as a string file path parameter to the setting.</li><li class="listitem" style="list-style-type: disc">The <strong>Cell Size </strong>setting, which controls the cell size of the data produced using raster<a id="id459" class="indexterm"/> analysis.</li></ul></div><p>Take time<a id="id460" class="indexterm"/> and explore the powerful ArcPy<a id="id461" class="indexterm"/> Environmental Settings to reduce the time needed to write code and ensure high-quality data production.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec59"/>Summary</h1></div></div></div><p>This chapter and this book have demonstrated some of the many ways that ArcPy can be used to automate geospatial analysis. By applying the lessons, and by being creative with the many methods and properties of ArcPy, repetitive and slow geospatial processes can be scripted and made into custom tools that will save a lot of time.</p><p>I hope that you enjoyed learning the basics of scripting with ArcPy and Python. I really hope that you've even come to like the idea of programming, as it is powerful and empowering. There is much more to master, but I think you will find that the more scripting you do, the easier it is to understand.</p><p>The best resource for further understanding of ArcPy is the ArcGIS Help Documents, available through the Help menu in ArcCatalog or ArcMap. The documentation is also available at <a class="ulink" href="http://resources.arcgis.com/en/help/main/10.2/index.html">http://resources.arcgis.com/en/help/main/10.2/index.html</a>. Working on entering the correct question into Google can be very helpful as well. Programming forums such as Stack Exchange (<a class="ulink" href="http://gis.stackexchange.com/">http://gis.stackexchange.com/</a>) or ESRI's GeoNet (<a class="ulink" href="https://geonet.esri.com/welcome">https://geonet.esri.com/welcome</a>) are valuable resources to ask all kinds of programming questions. There is an answer for almost every question you may have (but never be afraid to ask questions yourself!).</p><p>Have fun creating solutions and tools, and good luck in all your future geospatial programming challenges!</p></div></body></html>