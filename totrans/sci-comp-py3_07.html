<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Functions</h1></div></div></div><p>This chapter introduces functions, a fundamental building block in programming. We show how to define them, how to handle input and output, how to properly use them, and how to treat them as objects.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Basics</h1></div></div></div><p>In mathematics, a function is written as a map that uniquely assigns an element <em>y</em> from the range <em>R</em> to every element <em>x</em> from the domain <em>D</em>.</p><p>This is expressed by <em>f : D → R</em>
</p><p>Alternatively, when considering particular elements <em>x</em> and <em>y</em>, one writes <em>f : x → y</em>
</p><p>Here,<em> f</em> is called the name of the function and <em>f(x)</em> is its value when applied to <em>x</em>. Here, <em>x</em> is sometimes called the argument of <em>f. </em>Let's first look at an example before considering functions in Python.</p><p>For example,<em> D = </em>ℝ x ℝ  and <em>y = f(x<sub>1</sub>, x<sub>2</sub>) = x<sub>1</sub> - x<sub>2</sub></em>. This function maps two real numbers to their difference.</p><p>In mathematics, functions can have numbers, vectors, matrices, and even other functions as arguments. Here is an example of a function with mixed arguments: </p><p>
<img src="img/B05511_07_01-1.jpg" alt="Basics"/>.</p><p>In this case, a number is returned. When working with functions, we have to distinguish between two different steps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The definition of the function</li><li class="listitem" style="list-style-type: disc">The evaluation of the function, that is, the computation of <em>f(x) </em>for a given value of <em>x</em></li></ul></div><p>The first step is done once, while the second can be performed many times for various arguments. Functions in programming languages follow the same concept and apply it to a wide range of types of input arguments, for example, strings, lists, or any object. We demonstrate a definition of the function by considering the given example again:</p><pre class="programlisting">def subtract(x1, x2):&#13;
    return x1 - x2</pre><p>The keyword <code class="literal">def</code>  indicates that we are going to define a function. <code class="literal">subtract</code> is the function’s name and <code class="literal">x1</code> and <code class="literal">
<em>x2</em>
</code> are its parameters. The colon indicates that we are using a block command and the value that is returned by the function follows the <code class="literal">return</code> keyword. Now, we can evaluate this function. This function is called with its parameters replaced by input arguments:</p><pre class="programlisting">r = subtract(5.0, 4.3)</pre><p>The result 0.7 is computed and assigned to the <code class="literal">r</code> variable.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Parameters and arguments</h1></div></div></div><p>When defining a function, its input variables are called the parameters of the function. The input used when executing the function is called its argument.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec81"/>Passing arguments - by position and by keyword</h2></div></div></div><p>We will consider the previous example again, where the function takes two parameters, namely <code class="literal">x1</code> and <code class="literal">x2</code>.</p><p>Their names serve to distinguish the two numbers, which in this case cannot be interchanged without altering the result. The first parameter defines the number from which the second parameter is subtracted. When <code class="literal">subtract</code> is called, every parameter is replaced by an argument. Only the order of the arguments matters; the arguments can be any objects. For instance, we may call the following:</p><pre class="programlisting">z = 3 &#13;
e = subtract(5,z)</pre><p>Besides this standard way of calling a function, which is by passing the arguments by position, it might sometimes be convenient to pass arguments using keywords. The names of the parameters are the keywords; consider the following instance:</p><pre class="programlisting">z = 3 &#13;
e = subtract(x2 = z, x1 = 5)</pre><p>Here, the arguments are assigned to the parameters by name and not by position in the call. Both ways of calling a function can be combined so that the arguments given by position come first and the arguments given by keyword follow last. We show this by using the function <code class="literal">plot</code>, which was described in <a class="link" href="ch06.html" title="Chapter 6. Plotting">Chapter 6</a>, <em>Plotting</em>:</p><pre class="programlisting">plot(xp, yp, linewidth = 2,label = 'y-values')</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec82"/>Changing arguments</h2></div></div></div><p>The purpose of parameters is to provide the function with the necessary input data. Changing the value of the parameter inside the function normally has no effect on its value outside the function:</p><pre class="programlisting">def subtract(x1, x2):&#13;
    z = x1 - x2&#13;
    x2 = 50.&#13;
    return z&#13;
a = 20.&#13;
b = subtract(10, a)    # returns -10&#13;
a    # still has the value 20</pre><p>This applies to all immutable arguments, such as strings, numbers, and tuples. The situation is different if mutable arguments, such as lists or dictionaries, are changed.</p><p>For example, passing mutable input arguments to a function and changing them inside the function can change them outside the function too:</p><pre class="programlisting">def subtract(x):&#13;
    z = x[0] - x[1]&#13;
    x[1] = 50.&#13;
    return z&#13;
a = [10,20]&#13;
b = subtract(a)    # returns -10&#13;
a    # is now [10, 50.0]</pre><p>Such a function misuses its arguments to return results. We strongly dissuade you from such constructions and recommend that you do not change input arguments inside the function (for more information refer to <em>Default Arguments</em> section).</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec83"/>Access to variables defined outside the local namespace</h2></div></div></div><p>Python allows functions to access variables defined in any of its enclosing program units. These are called global variables, in contrast to local variables. The latter are only accessible within the function. For example, consider the following code:</p><pre class="programlisting">import numpy as np # here the variable np is defined&#13;
def sqrt(x):&#13;
    return np.sqrt(x) # we use np inside the function</pre><p>This feature should not be abused. The following code is an example of what not to do:</p><pre class="programlisting">a = 3&#13;
def multiply(x):&#13;
    return a * x # bad style: access to the variable a defined outside</pre><p>When changing the variable <code class="literal">a</code> the function, <code class="literal">multiply</code> tacitly changes its behavior:</p><pre class="programlisting">a=3&#13;
multiply(4)  # returns 12&#13;
a=4&#13;
multiply(4)  # returns 16</pre><p>It is much better in that case to provide the variable as a parameter through the argument list:</p><pre class="programlisting">def multiply(x, a):&#13;
    return a * x</pre><p>Global variables can be useful when working with closures. Namespaces and scopes are discussed more extensively in <a class="link" href="ch11.html" title="Chapter 11. Namespaces, Scopes, and Modules">Chapter 11</a>, <em>Namespaces, Scopes, and Modules</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec84"/>Default arguments</h2></div></div></div><p>Some functions can have many parameters, and among them some might only be of interest in nonstandard situations. It would be practical if arguments could automatically be set to standard (default) values. We demonstrate the use of default arguments by looking at the command <code class="literal">norm</code> in the <code class="literal">scipy.linalg</code> module. It computes various norms of matrices and vectors.</p><p>The following snippet calls for computing the <strong>Frobenius norm </strong> of the <em>3 × 3</em> identity matrix are equivalent (more on matrix norms can be found in <a class="link" href="apa.html" title="Appendix . References">
[10]
</a>
):</p><pre class="programlisting">import scipy.linalg as sl&#13;
sl.norm(identity(3))&#13;
sl.norm(identity(3), ord = 'fro')&#13;
sl.norm(identity(3), 'fro')</pre><p>Note that in the first call, no information about the <code class="literal">ord</code> keyword is given. How does Python know that it should compute the Frobenius norm and not another norm, for example, the Euclidean 2-norm?</p><p>The answer to the previous question is the use of default values. A default value is a value already given by the function definition. If the function is called without providing this argument, Python uses the value that the programmer provided when the function was defined.</p><p>Suppose we call the function <code class="literal">subtract</code> only one argument; we get an error message:</p><pre class="programlisting">TypeError: subtract() takes exactly 2 arguments (1 given)</pre><p>To allow the omission of the argument <code class="literal">x2</code>, the definition of the function has to provide a default value, for example:</p><pre class="programlisting">def subtract(x1, x2 = 0): &#13;
    return x1 - x2</pre><p>To summarize, arguments can be given as positional arguments and keyword arguments. All positional arguments have to be given first. You do not need to provide all keyword arguments as long as those omitted arguments have default values in the function definition.</p><div><div><div><div><h3 class="title"><a id="ch07lvl4sec6"/>Beware of mutable default arguments</h3></div></div></div><p>The default arguments are set upon function definition. Changing mutable arguments inside a function has a side effect when working with default values, for example:</p><pre class="programlisting">def my_list(x1, x2 = []):&#13;
    x2.append(x1)&#13;
    return x2&#13;
my_list(1)  # returns [1]&#13;
my_list(2)  # returns [1,2]</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl2sec85"/>Variable number of arguments</h1></div></div></div><p>Lists and dictionaries may be used to define or call functions with a variable number of arguments. Let's define a list and a dictionary as follows:</p><pre class="programlisting">data = [[1,2],[3,4]]    &#13;
style = dict({'linewidth':3,'marker':'o','color':'green'})</pre><p>Then we can call the <code class="literal">plot</code> function using starred (<code class="literal">*</code>) arguments:</p><pre class="programlisting">plot(*data,**style)</pre><p>A variable name prefixed by <code class="literal">*</code> , such as <code class="literal">*data</code> in the preceding example, means that a list that gets unpacked in the function call is provided. In this way, a list generates positional arguments. Similarly, a variable name prefixed by <code class="literal">**</code>, such as <code class="literal">**style</code> in the example, unpacks a dictionary to keyword arguments. Refer to the following figure (<em>Figure 7.1</em>):</p><p>
</p><div><img src="img/starred_arguments_on_call.jpg" alt="Variable number of arguments"/></div><p>
</p><p>Figure 7.1: Starred arguments in function calls</p><p>You might also want to use the reverse process, where all given positional arguments are packed into a list and all keyword arguments are packed into a dictionary when passed to a function.</p><p>In the function definition, this is indicated by parameters prefixed by <code class="literal">*</code>  and <code class="literal">**</code>, respectively. You will often find the <code class="literal">*args</code> and <code class="literal">**kwargs</code> parameters in code documentation, refer <em>Figure 7.2</em>.</p><p>
</p><div><img src="img/starred_arguments_at_definition.jpg" alt="Variable number of arguments"/></div><p>
</p><p>Figure 7.2: Starred arguments in function definitions</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Return values</h1></div></div></div><p>A function in Python always returns a single object. If a function has to return more than one object, these are packed and returned as a single tuple object.</p><p>For instance, the following function takes a complex number <em>z</em> and returns its polar coordinate representation as magnitude <em>r</em> and angle <img src="img/varphi.jpg" alt="Return values"/> according to Euler’s formula:</p><p>
</p><div><img src="img/euler.jpg" alt="Return values"/></div><p>
</p><p>And the Python counterpart would be this:</p><pre class="programlisting">def complex_to_polar(z):&#13;
    r = sqrt(z.real ** 2 + z.imag ** 2)&#13;
    phi = arctan2(z.imag, z.real)&#13;
    return (r,phi)  # here the return object is formed</pre><p>Here, we used the <code class="literal">sqrt(x)</code> NumPy function for the square root of a number <code class="literal">x</code> and <code class="literal">arctan2(x,y)</code> for the expression tan<sup>-1</sup>(<em>x/y</em>).</p><p>Let us try our function:</p><pre class="programlisting">z = 3 + 5j  # here we define a complex number&#13;
a = complex_to_polar(z)&#13;
r = a[0]&#13;
phi = a[1]</pre><p>The last three statements can be written more elegantly in a single line:</p><pre class="programlisting">r,phi = complex_to_polar(z)</pre><p>We can test our function by calling <code class="literal">polar_to_comp</code>; refer to <em>Exercise 1</em>.</p><p>If a function has no <code class="literal">return</code> statement, it returns the value <code class="literal">None</code>. There are many cases where a function does not need to return any value. This could be because the variables passed to a function may be subject to modification. Consider, for instance, the following function:</p><pre class="programlisting">def append_to_list(L, x):&#13;
    L.append(x)</pre><p>The preceding function does not return anything because it modifies one of the objects that is given as an argument. We mentioned in <em>Parameters and Arguments</em> section why this is useful. There are many methods that behave in the same way. To mention the list methods only, the <code class="literal">append</code>, <code class="literal">extend</code>, <code class="literal">reverse</code>, and <code class="literal">sort</code> methods do not return anything (that is, they return <code class="literal">None</code> ). When an object is modified by a method in this way, the modification is called in-place. It is difficult to know whether a method changes an object, except by looking at the code or the documentation.</p><p>Another reason for a function, or a method, not to return anything is when it prints out a message or writes to a file.</p><p>The execution stops at the first occurring <code class="literal">return</code> statement. Lines after that statement are dead code, which will never be executed:</p><pre class="programlisting">def function_with_dead_code(x):&#13;
    return 2 * x&#13;
    y = x ** 2 # these two lines ...&#13;
    return y   # ... are never executed!</pre></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Recursive functions</h1></div></div></div><p>In mathematics, many functions are defined recursively. In this section, we will show how this concept can be used even when programming a function. This makes the relation of the program to its mathematical counterpart very clear, which may ease the readability of the program.</p><p>Nevertheless, we recommend that you use this programming technique with care, especially within scientific computing. In most applications, the more straightforward iterative approach is more efficient. This will become immediately clear from the following example.</p><p>Chebyshev polynomials are defined by a three-term recursion:</p><p>
</p><div><img src="img/chebychev.jpg" alt="Recursive functions"/></div><p>
</p><p>Such a recursion needs to be initialized, that is, <em>T</em><sub>0</sub>(<em>x</em>) =1,<em> T</em><sub>1</sub>(<em>x</em>) =<em> x. </em>
</p><p>In Python, this three term recursion can be realized by the following function definition:</p><pre class="programlisting">def chebyshev(n, x):&#13;
    if n == 0:&#13;
        return 1.&#13;
    elif n == 1:&#13;
        return x&#13;
    else:&#13;
        return 2. * x * chebyshev(n - 1, x) &#13;
                      - chebyshev(n - 2 ,x)&#13;
&#13;
</pre><p>The function is then called like this:</p><pre class="programlisting">chebyshev(5, 0.52) # returns 0.39616645119999994</pre><p>This example also illustrates the risk of dramatically wasting computation time. The number of function evaluations increases exponentially with the recursion level and most of these evaluations are just duplicates of previous computations. While it might be tempting to use recursive programs for demonstrating the strong relation between code and mathematical definition, a production code will avoid this programming technique (refer to <em>Exercise</em> 6). We also refer to a technique called memoization (refer to <a class="link" href="apa.html" title="Appendix . References">[22]</a> for more details<em>)</em> that combines recursive programming with a caching technique to save replicated function evaluations.</p><p>A recursive function usually has a level parameter. In the previous example, it is <em>n. </em>It is used to control the function's  two main parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The base case, here, the first two <code class="literal">if</code> branches</li><li class="listitem" style="list-style-type: disc">The recursive body, in which the function itself is called once or several times with smaller level parameters.</li></ul></div><p>The number of levels passed by an execution of a recursive function is called the recursion depth. This quantity should not be too large; otherwise the computation might no longer be effective and in the ultimate case, the following error will be raised:</p><pre class="programlisting">RuntimeError: maximum recursion depth exceeded</pre><p>The maximal recursion depth depends on the memory of the computer you use. This error also occurs when the initialization step is missing in the function definition. We encourage the use of recursive programs for very small recursion depths (for more information, refer to the section <em>Infinite Iteration</em> of <a class="link" href="ch09.html" title="Chapter 9. Iterating">Chapter 9</a>, <em>Iterating</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Function documentation</h1></div></div></div><p>You should document your functions using a string at the beginning. This is called docstring:</p><pre class="programlisting">def newton(f, x0):&#13;
    """&#13;
    Newton's method for computing a zero of a function&#13;
    on input:&#13;
    f  (function) given function f(x)&#13;
    x0 (float) initial guess &#13;
    on return:&#13;
    y  (float) the approximated zero of f&#13;
    """&#13;
     ...</pre><p>When calling <code class="literal">help(newton)</code>, you get this docstring displayed together with the call of this function:</p><pre class="programlisting">Help on function newton in module __main__:&#13;
&#13;
newton(f, x0)&#13;
     Newton's method for computing a zero of a function&#13;
     on input:&#13;
     f  (function) given function f(x)&#13;
     x0 (float) initial guess&#13;
     on return:&#13;
     y  (float) the approximated zero of f</pre><p>The docstring is internally saved as an attribute, <code class="literal">__doc__</code>, of the given function. In the example, it's <code class="literal">newton.__doc__</code>. The minimal information you should provide in a docstring is the purpose of the function and the description of the input and output objects. There are tools to automatically generate full code documentation by collecting all docstrings in your program (for more information refer to <a class="link" href="apa.html" title="Appendix . References">[32]</a>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Functions are objects</h1></div></div></div><p>Functions are objects, like everything else in Python. One may pass functions as arguments, change their names, or delete them. For example:</p><pre class="programlisting">def square(x):&#13;
    """&#13;
    Return the square of x&#13;
    """&#13;
    return x ** 2&#13;
square(4) # 16&#13;
sq = square # now sq is the same as square&#13;
sq(4) # 16&#13;
del square # square doesn't exist anymore&#13;
print(newton(sq, .2)) # passing as argument</pre><p>Passing functions as arguments is very common when applying algorithms in scientific computing. The functions <code class="literal">fsolve</code>  in <code class="literal">scipy.optimize</code> for computing a zero of a given function or <code class="literal">quad</code> in <code class="literal">scipy.integrate</code> for computing integrals are typical examples.</p><p>A function itself can have a different number of arguments with differing types. So, when passing your function <code class="literal">f</code> to another function <code class="literal">g</code> as argument, make sure that <code class="literal">f</code> has exactly the form described in the docstring of <code class="literal">g</code>.</p><p>The docstring of <code class="literal">fsolve</code>  gives information about its <code class="literal">func</code> parameter:</p><pre class="programlisting">func -- A Python function or method which takes at least one&#13;
               (possibly vector) argument.</pre><div><div><div><div><h2 class="title"><a id="ch07lvl2sec86"/>Partial application</h2></div></div></div><p>Let's start with an example of a function with two variables.</p><p>The function <img src="img/fullsine.jpg" alt="Partial application"/>can be viewed as a function in two variables. Often one considers ω not as a free variable but as a fixed parameter of a family of functions <em>f</em><sub>ω</sub>:</p><p>
</p><div><img src="img/partialsine.jpg" alt="Partial application"/></div><p>
</p><p>This interpretation reduces a function in two variables to a function in one variable, <code class="literal">t</code>, given a fixed parameter value <em>ω</em>. The process of defining a new function by fixing (freezing) one or several parameters of a function is called partial application.</p><p>Partial applications are easily created using the Python module <code class="literal">functools</code>, which provides a function called <code class="literal">partial</code> for precisely this purpose. We illustrate this by constructing a function that returns a sine for a given frequency:</p><pre class="programlisting">import functools&#13;
def sin_omega(t, freq):&#13;
    return sin(2 * pi * freq * t)&#13;
&#13;
def make_sine(frequency):&#13;
    return functools.partial(sin_omega, freq = frequency)</pre><div><div><div><div><h3 class="title"><a id="ch07lvl4sec7"/>Using Closures</h3></div></div></div><p>Using the view that functions are objects, partial applications can be realized by writing a function, which itself returns a new function, with a reduced number of input arguments. For instance, the function could be defined as follows:</p><pre class="programlisting">def make_sine(freq):&#13;
    "Make a sine function with frequency freq"&#13;
    def mysine(t):&#13;
        return sin_omega(t, freq)&#13;
    return mysine</pre><p>In this example the inner function <code class="literal">mysine</code> has access to the variable <code class="literal">freq</code>; it is neither a local variable of this function nor is it passed to it via the argument list. Python allows such a construction (refer to <em>Namespaces</em> section in <a class="link" href="ch11.html" title="Chapter 11. Namespaces, Scopes, and Modules">Chapter 11</a>, <em>Namespaces, Scopes, and Modules</em>).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Anonymous functions - the  lambda keyword</h1></div></div></div><p>The keyword lambda is used in Python to define anonymous functions, that is; functions without a name and described by a single expression. You might just want to perform an operation on a function that can be expressed by a simple expression without naming this function and without defining this function by a lengthy <code class="literal">def</code> block.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>The name <em>lambda</em> originates from a special branch of calculus and mathematical logic, the <img src="img/lambda.jpg" alt="Anonymous functions - the  lambda keyword"/>-calculus.</p></div></div><p>For instance, to compute the following expression, we may use SciPy’s function <code class="literal">quad</code>, which requires the function to be integrated as its first argument and the integration bounds as the next two arguments:</p><p>
</p><div><img src="img/B05511_07_02.jpg" alt="Anonymous functions - the  lambda keyword"/></div><p>
</p><p>Here, the function to integrate is just a simple one-liner and we use the <code class="literal">lambda</code> keyword to define it:</p><pre class="programlisting">import scipy.integrate as si&#13;
si.quad(lambda x: x ** 2 + 5, 0, 1)</pre><p>The syntax is as follows:</p><pre class="programlisting">lambda parameter_list: expression</pre><p>The definition of the <code class="literal">lambda</code> function can only consist of a single expression and in particular, cannot contain loops. <code class="literal">lambda</code> functions are, just like other functions, objects and can be assigned to variables:</p><pre class="programlisting">parabola = lambda x: x ** 2 + 5&#13;
parabola(3) # gives 14</pre><div><div><div><div><h2 class="title"><a id="ch07lvl2sec87"/>The lambda construction is always replaceable
</h2></div></div></div><p>It is important to note that lambda construction is only syntactic sugar in Python. Any lambda construction may be replaced by an explicit function definition:</p><pre class="programlisting">parabola = lambda x: x**2+5 &#13;
# the following code is equivalent&#13;
def parabola(x):&#13;
    return x ** 2 + 5</pre><p>The main reason to use a construction is for very simple functions, when a full function definition would be too cumbersome.</p><p>
<code class="literal">lambda</code> functions provide a third way to make closures as we demonstrate by continuing with the previous example:</p><p>We use the <code class="literal">sin_omega</code> function to compute the integral of the sine function for various frequencies:</p><pre class="programlisting">import scipy.integrate as si&#13;
for iteration in range(3):&#13;
    print(si.quad(lambda x: sin_omega(x, iteration*pi), 0, pi/2.) )</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Functions as decorators</h1></div></div></div><p>In the partial application section, we saw how a function can be used to modify another function. A decorator is a syntax element in Python that conveniently allows us to alter the behavior of a function without changing the definition of the function itself. Let us start with the following situation:</p><p>Assume that we have a function that determines the degree of sparsity of a matrix:</p><pre class="programlisting">def how_sparse(A):&#13;
    return len(A.reshape(-1).nonzero()[0])</pre><p>This function returns an error if it is not called with an array object as input. More precisely, it will not work with an object that does not implement the <code class="literal">reshape</code> method. For instance, the <code class="literal">how_sparse</code> function will not work with a list, because lists have no <code class="literal">reshape</code> method. The following helper function modifies any function with one input parameter so that it tries to make a type conversion to an array:</p><pre class="programlisting">def cast2array(f):&#13;
    def new_function(obj):&#13;
        fA = f(array(obj))&#13;
        return fA&#13;
    return new_function</pre><p>Thus, the modified function <code class="literal">how_sparse = cast2array(how_sparse)</code> can be applied to any object that can be cast to an array. The same functionality is achieved if the definition of <code class="literal">how_sparse</code> is decorated with the type conversion function. It is recommend also to consider the <code class="literal">functools.wraps</code> (refer to <a class="link" href="apa.html" title="Appendix . References">[8]</a> for more details):
</p><pre class="programlisting">@cast2array&#13;
def how_sparse(A):&#13;
    return len(A.reshape(-1).nonzero()[0])</pre><p>To define a decorator, you need a callable object such as a function that modifies the definition of the function to be decorated. The main purposes are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To increase code readability by separating parts from a function that do not directly serve its functionality (for example, memoizing)</li><li class="listitem" style="list-style-type: disc">To put common preamble and epilogue parts of a family of similar functions in a common place (for example, type checking)</li><li class="listitem" style="list-style-type: disc">To be able to easily switch off and on additional functionalities of a function (for example, test prints, tracing)</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Summary</h1></div></div></div><p>Functions are not only the ideal tools for making your program modular, but they also reflect mathematical thinking. You learned the syntax of function definitions and to distinguish between defining and calling a function.</p><p>We considered functions as objects that can be modified by other functions. When working with functions, it is important to be familiar with the notion of the scope of a variable and how information is passed into a function by parameters.</p><p>Sometimes, it is convenient to define functions on the fly with so-called anonymous functions. For this, we introduced the keyword lambda.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Exercises</h1></div></div></div><p>
<strong>Ex 1</strong> → Write a function <code class="literal">polar_to_comp</code>, which takes two arguments <em>r</em> and <img src="img/varphi.jpg" alt="Exercises"/> and returns the complex number <img src="img/euler.jpg" alt="Exercises"/> Use the NumPy function <code class="literal">exp</code> for the exponential function.</p><p>
<strong>Ex 2</strong> → In the description of the Python module <code class="literal">functools</code>, (refer to <a class="link" href="apa.html" title="Appendix . References">[8]</a> for more detail on functools) you find the following Python function:</p><pre class="programlisting">def partial(func, *args, **keywords):&#13;
    def newfunc(*fargs, **fkeywords):&#13;
        newkeywords = keywords.copy()&#13;
        newkeywords.update(fkeywords)&#13;
        return func(*(args + fargs), **newkeywords)&#13;
    newfunc.func = func&#13;
    newfunc.args = args&#13;
    newfunc.keywords = keywords&#13;
    return newfunc</pre><p>Explain and test this function.</p><p>
<strong>Ex 3</strong> → Write a decorator for the function <code class="literal">how_sparse</code>,  which cleans the input matrix <em>A</em> by setting the elements that are less than 1.e-16 to zero (consider example in section<em> Function as decorators</em>).</p><p>
<strong>Ex 4</strong> → A continuous function <em>f</em> with <em>f</em>(<em>a</em>)<em>f</em>(<em>b</em>) &lt; 0 changes its sign in the interval [<em>a, b</em>] and  has at least one root (zero) in this interval. Such a root can be found with the bisection method. This method starts from the given interval. Then it investigates the sign changes in the subintervals,</p><p>
</p><div><img src="img/subintervals.jpg" alt="Exercises"/></div><p>
</p><p>If the sign changes in the first subinterval <em>b</em> is redefined to be:</p><p>
</p><div><img src="img/B05511_07_05.jpg" alt="Exercises"/></div><p>
</p><p>Otherwise, it is redefined in the same manner to:</p><p>
</p><div><img src="img/B05511_07_06.jpg" alt="Exercises"/></div><p>
</p><p>And the process is repeated until the <em>b-a</em> is less than a given tolerance.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implement this method as a function that takes as arguments:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">– the function <em>f</em></li><li class="listitem" style="list-style-type: disc">– the initial interval [<em>a, b</em>]</li><li class="listitem" style="list-style-type: disc">– the tolerance</li></ul></div></li><li class="listitem" style="list-style-type: disc">This function <code class="literal">bisec</code> should return the final interval and its midpoint.</li><li class="listitem" style="list-style-type: disc">Test the method with the function <code class="literal">arctan</code> and also with the polynomial <em>f(x) = 3 x<sup>2</sup> -5</em> in the interval [1.1, 1.4]<em>,</em> and alternatively in [1.3, 1.4].</li></ul></div><p>
<strong>Ex. 5</strong> → The greatest common divisor of two integers can be computed with Euclid’s algorithm described by the following recursion:</p><p>
</p><div><img src="img/B05511_07_07.jpg" alt="Exercises"/></div><p>
</p><p>Write a function that computes the greatest common divisor of two integers. Write another function that computes the least common multiple of these numbers using the relation:</p><p>
</p><div><img src="img/B05511_07_08.jpg" alt="Exercises"/></div><p>
</p><p>
<strong>Ex. 6</strong> → Study the recursive implementation of Chebyshev polynomials, consider the example in section <em>Recursive Function</em>. Rewrite the program in a non-recursive way and study computation time versus polynomial degree (see also the <code class="literal">timeit</code> module).</p></div></body></html>