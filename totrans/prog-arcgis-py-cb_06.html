<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Creating Custom Geoprocessing Tools</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a custom geoprocessing tool</li><li class="listitem" style="list-style-type: disc">Creating a Python toolbox</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Introduction</h1></div></div></div><p>In addition to accessing the system tools provided by ArcGIS, you can also create your own custom tools. These tools work in the same way as system tools and can be used in ModelBuilder, a Python window, or standalone Python scripts. Many organizations build their own library of tools that perform geoprocessing operations specific to their data.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Creating a custom geoprocessing tool</h1></div></div></div><p>Along with<a id="id337" class="indexterm"/> being able to execute any of the available tools in your scripts, you can also create your own custom tools, which can also be called from a script. Custom tools are frequently created to handle geoprocessing tasks that are specific to an organization. These tools can be easily shared as well.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec126"/>Getting ready</h2></div></div></div><p>In this recipe, you will learn how to create custom geoprocessing script tools by attaching a Python script to a custom toolbox in ArcToolbox. There are a number of advantages of creating a custom script tool. When you take this approach, the script becomes a part of the geoprocessing framework, which means that it can be run from a model, command line, or another script. Also, the script has access to the environment settings and help documentation of ArcMap. Other advantages include a nice, easy-to-use user interface and error prevention capabilities. Error prevention capabilities that are provided include a dialog box that informs the user of certain errors.</p><p>These custom developed script tools must be added to a custom toolbox that you create, because the system toolboxes provided with ArcToolbox are read-only toolboxes, and thus can't accept new tools.</p><p>In this recipe, you are going to be provided with a prewritten Python script that reads wildfire <a id="id338" class="indexterm"/>data from a comma-delimited text file, and writes this information to a point feature class called <code class="literal">FireIncidents</code>. References to these datasets have been hardcoded, so you are going to have to alter the script to accept dynamic variable inputs. You'll then attach the script to a custom tool in ArcToolbox to give your end users a visual interface to use the script.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec127"/>How to do it…</h2></div></div></div><p>The custom Python geoprocessing scripts that you write can be added to ArcToolbox inside custom toolboxes. You are not allowed to add your scripts to any of the system toolboxes, such as <strong>Analysis</strong> or <strong>Data Management</strong>. However, by creating a new custom toolbox, you can add scripts in this way:</p><div><ol class="orderedlist arabic"><li class="listitem">Open ArcMap with an empty map document file and open the ArcToolbox window.</li><li class="listitem">Right-click anywhere in the white space area of ArcToolbox and select <strong>Add Toolbox</strong>.</li><li class="listitem">Navigate to the <code class="literal">C:\ArcpyBook\Ch6</code> folder.</li><li class="listitem">In the <strong>Add Toolbox</strong> dialog box, click on the new toolbox button. This will create a new toolbox with a default name of <code class="literal">Toolbox.tbx</code>; you will rename the toolbox in the next step:<div><img src="img/B04314_06_1.jpg" alt="How to do it…"/></div></li><li class="listitem">Name<a id="id339" class="indexterm"/> the toolbox <code class="literal">WildfireTools.tbx</code>:<div><img src="img/B04314_06_2.jpg" alt="How to do it…"/></div></li><li class="listitem">Open the <a id="id340" class="indexterm"/>toolbox by selecting <code class="literal">WildfireTools.tbx</code> and clicking on the <strong>Open</strong> button. The toolbox should now be displayed in <strong>ArcToolbox</strong>, as shown in the following screenshot:<div><img src="img/B04314_06_14.jpg" alt="How to do it…"/></div></li><li class="listitem">Each <a id="id341" class="indexterm"/>toolbox should be given a name and an alias. The alias will be used to uniquely define your custom tool. Alias names should be kept short and should not include any special characters. Right-click on the new toolbox and select <strong>Properties</strong>. Add an alias of <code class="literal">wildfire</code>, as shown in the following screenshot:<div><img src="img/B04314_06_15.jpg" alt="How to do it…"/></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>You can optionally create a new toolset inside this toolbox by right-clicking on the toolbox and navigating to <strong>New</strong> | <strong>Toolset</strong>. Toolsets allow you to functionally group your scripts. In this example, it won't be necessary to do this, but if you need to group your scripts in the future, then this is how you can accomplish it.</p></div></div></li><li class="listitem">In this <a id="id342" class="indexterm"/>next step, we will alter an existing Python script called <code class="literal">InsertWildfires.py</code> to accept dynamic inputs that will be provided by the user of the tool through the ArcToolbox interface. Open <code class="literal">c:\ArcpyBook\Ch6\InsertWildfires.py</code> in IDLE.<p>Notice that we have hardcoded the path to our workspace as well as the comma-delimited text file containing the wildland fire incidents:</p><div><pre class="programlisting">arcpy.env.workspace = "C:/ArcpyBook/data/Wildfires/WildlandFires.mdb"
f = open("C:/ArcpyBook/data/Wildfires/NorthAmericaWildfires_2007275.txt","r")</pre></div></li><li class="listitem">Delete the preceding two lines of code.<p>In addition to this, we have also hardcoded the name of the output feature class:</p><div><pre class="programlisting">cur = arcpy.InsertCursor("FireIncidents")</pre></div><p>This hardcoding limits the usefulness of our script. If the datasets move or are deleted, the script will no longer run. Additionally, the script lacks the flexibility to specify different input and output datasets. In the next step, we will remove this hardcoding and replace it with the ability to accept dynamic input.</p></li><li class="listitem">We <a id="id343" class="indexterm"/>will use the <code class="literal">GetParameterAsText()</code> function found in <code class="literal">arcpy</code> to accept dynamic input from the user. Add the following lines of code to the try block, so that your code appears as follows:<div><pre class="programlisting">try:
  #the output feature class name
  outputFC = arcpy.GetParameterAsText(0)

  # template featureclass that defines the attribute schema
  fClassTemplate = arcpy.GetParameterAsText(1)

  # open the file to read
  f = open(arcpy.GetParameterAsText(2),'r')

      arcpy.CreateFeatureclass_management (os.path.split(outputFC)[0], os.path.split(outputFC)[1], "point", fClassTemplate)</pre></div><p>Notice that we call the <code class="literal">CreateFeatureClass</code> tool, found in the <strong>Data Management Tools</strong> toolbox, passing the <code class="literal">outputFC</code> variable along with the template feature class (<code class="literal">fClassTemplate</code>). This tool will create the empty feature class containing the output feature class defined by the user.</p></li><li class="listitem">You will<a id="id344" class="indexterm"/> also need to alter the line of code that creates an <code class="literal">InsertCursor</code> object. Change the line as follows:<div><pre class="programlisting">with arcpy.da.InsertCursor(outputFC) as cur:</pre></div></li><li class="listitem">The entire script should appear as follows:<div><pre class="programlisting">#Script to Import data to a feature class within a geodatabase
import arcpy, os
try:
    outputFC = arcpy.GetParameterAsText(0)
    fClassTemplate = arcpy.GetParameterAsText(1)
    f = open(arcpy.GetParameterAsText(2),'r')
    arcpy.CreateFeatureclass_management(os.path.split(outputFC)[0], os.path.split(outputFC)[1],"point",fClassTemplate)
    lstFires = f.readlines()
    with arcpy.da.InsertCursor(outputFC) as cur:
        cntr = 1
        for fire in lstFires:
            if 'Latitude' in fire:
                continue
            vals = fire.split(",")
            latitude = float(vals[0])
            longitude = float(vals[1])
            confid = int(vals[2])
            pnt = arcpy.Point(longitude, latitude)
            feat = cur.newRow()
            feat.shape = pnt
            feat.setValue("CONFIDENCEVALUE", confid)
            cur.insertRow(feat)
            arcpy.AddMessage("Record number" + str(cntr) + "written to feature class")
            cntr = cntr + 1
except:
    print arcpy.GetMessages()
finally:
    f.close()</pre></div></li><li class="listitem">You can check your work by examining the <code class="literal">c:\ArcpyBook\code\Ch6\InsertWildfires.py</code> solution file.</li><li class="listitem">In the next step, we will add the script that we just created to the <strong>Wildfire Tools</strong> toolbox as a script tool.</li><li class="listitem">In ArcToolbox, right-click on the <strong>Wildfire Tools</strong> custom toolbox that you created <a id="id345" class="indexterm"/>earlier and navigate to <strong>Add</strong> | <strong>Script</strong>. This will display the <strong>Add Script</strong> dialog, as shown in the following screenshot. Give your script a name, label, and description. The <strong>Name:</strong> field can not contain any spaces or special characters. The <strong>Label:</strong> field is the name that shows up next to the script. For this example, give it a label of <code class="literal">Load Wildfires From Text</code>. Finally, add some descriptive information that details the operations that the script will perform.</li><li class="listitem">The details relating to <strong>Name:</strong>, <strong>Label:</strong>, and <strong>Description:</strong> are shown in the following screenshot:<div><img src="img/B04314_06_29.jpg" alt="How to do it…"/></div></li><li class="listitem">Click on <strong>Next</strong> to display the next input dialog box for <strong>Add Script</strong>.</li><li class="listitem">In this <a id="id346" class="indexterm"/>dialog box, you will specify the script that will be attached to the tool. Navigate to <code class="literal">c:\ArcpyBook\Ch6\InsertWildfires.py</code> and add <code class="literal">InsertWildfires.py</code> as the script.</li><li class="listitem">You will also want to make sure that the <strong>Run Python script in process</strong> checkbox is selected, as shown in the following screenshot. Running a Python script <em>in process</em>. increases the performance of your script.<div><img src="img/B04314_06_10.jpg" alt="How to do it…"/></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>Running a script out of process requires ArcGIS to create a separate process to execute the script. The time it takes to start this process and execute the script leads to performance problems. Always run your scripts in process. Running a script in process means that ArcGIS does not have to spawn a second process to run the script. It runs in the same process space as ArcGIS.</p></div></div></li><li class="listitem">Click<a id="id347" class="indexterm"/> on <strong>Next</strong> to display the parameter window, as shown in the following screenshot:<div><img src="img/B04314_06_3.jpg" alt="How to do it…"/></div><p>Each parameter that you enter in this dialog box corresponds to a single call to <code class="literal">GetParameterAsText()</code>. Earlier, you altered your script to accept dynamic parameters through the <code class="literal">GetParameterAsText()</code> method. The parameters should be entered in this dialog box in the same order that your script expects to receive them. For instance, you inserted the following line of code in your code:</p><div><pre class="programlisting">outputFC = arcpy.GetParameterAsText(0)</pre></div><p>The<a id="id348" class="indexterm"/> first parameter that you add to the dialog box will need to correspond to this line. In our code, this parameter represents the feature class that will be created as a result of this script. You add parameters by clicking on the first available row under <strong>Display Name</strong>. You can enter any text in this row. This text will be displayed to the user. You will also need to select a corresponding data type for the parameter. In this case, Data Type should be set to <strong>Feature Class</strong>, since this is the expected data that will be gathered from the user. Each parameter also has a number of properties that can be set. Some of the more important properties include <strong>Type</strong>, <strong>Direction</strong>, and <strong>Default</strong>.</p></li><li class="listitem">Enter the information, as shown in the following screenshot, into your dialog box, for the output feature class. Make sure that you set <strong>Direction</strong> to <code class="literal">Output</code>:<div><img src="img/B04314_06_4.jpg" alt="How to do it…"/></div></li><li class="listitem">Next, we <a id="id349" class="indexterm"/>need to add a parameter that defines the feature class that will be used as the attribute template for our new feature class. Enter the following information in your dialog box:<div><img src="img/B04314_06_11.jpg" alt="How to do it…"/></div></li><li class="listitem">Finally, we<a id="id350" class="indexterm"/> need to add a parameter that will be used to specify the comma-delimited text file that will be used as an input in the creation of our new feature class. Enter the following information into your dialog box:<div><img src="img/B04314_06_12.jpg" alt="How to do it…"/></div></li><li class="listitem">Click<a id="id351" class="indexterm"/> on <strong>Finish</strong>. The new script tool will be added to your <strong>Wildfire Tools</strong> toolbox, as shown in the following screenshot:<div><img src="img/B04314_06_5.jpg" alt="How to do it…"/></div></li><li class="listitem">Now, we'll test the tool to make sure it works. Double-click on the script tool to display the dialog box, as shown in the following screenshot:<div><img src="img/B04314_06_6.jpg" alt="How to do it…"/></div></li><li class="listitem">Define <a id="id352" class="indexterm"/>a new output feature class, which should be loaded inside the existing <code class="literal">WildlandFires.mdb</code> personal geodatabase, as shown in the next screenshot. Click on the open folder icon and navigate to the <code class="literal">WildlandFires.mdb</code> personal geodatabase, which should be located in <code class="literal">c:\ArcpyBook\data\Wildfires</code>.</li><li class="listitem">You will also need to give your new feature class a name. In this case, we'll name the feature class <code class="literal">TodaysWildfires</code>, but the name can be whatever you'd like. In the following screenshot, you can see an example of how this should be done. Click on the <strong>Save</strong> button:<div><img src="img/B04314_06_16.jpg" alt="How to do it…"/></div></li><li class="listitem">For the <a id="id353" class="indexterm"/>attribute template, you will want to point to the <code class="literal">FireIncidents</code> feature class that has already been created for you. This feature class contains a field called <code class="literal">CONFIDENCEVAL</code>. This field will be created in our new feature class. Click on the <strong>Browse</strong> button, navigate to <code class="literal">c:\ArcpyBook\data\Wildfires\WildlandFires.mdb</code>, and you should see the <code class="literal">FireIncidents</code> feature class. Select it and click on <strong>Add</strong>.</li><li class="listitem">Finally, the last parameter needs to point to our comma-delimited text file containing wildland fires. This file can be found at <code class="literal">c:\ArcpyBook\data\Wildfires\NorthAmericaWildfires_2007275.txt</code>. Click on the <strong>Browse</strong> button and navigate to <code class="literal">c:\ArcpyBook\data\Wildfires</code>. Click on <code class="literal">NorthAmericaWildfires_2007275.txt</code> and click on the <strong>Add</strong> button. Your tool should appear as follows:<div><img src="img/B04314_06_7.jpg" alt="How to do it…"/></div></li><li class="listitem">Click<a id="id354" class="indexterm"/> on <strong>OK</strong> to execute the tool. Any messages will be written to the dialog box shown in the following screenshot. This is a standard dialog box for any geoprocessing tool.<div><img src="img/B04314_06_8.jpg" alt="How to do it…"/></div></li><li class="listitem">If everything is set up correctly, you should see the following screenshot, which <a id="id355" class="indexterm"/>shows that a new feature class will be added to the ArcMap display:<div><img src="img/B04314_06_9.jpg" alt="How to do it…"/></div></li><li class="listitem">In ArcMap, select <strong>add basemap</strong> and then choose the Topographic <code class="literal">basemap</code>. Click on the <strong>Add</strong> button to add the <code class="literal">basemap</code> layer.<div><img src="img/B04314_06_25.jpg" alt="How to do it…"/></div></li></ol></div><p>This will <a id="id356" class="indexterm"/>provide a reference for the data that you have just imported, as seen in the preceding screenshot.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec128"/>How it works…</h2></div></div></div><p>Almost all script tools have parameters, and the values are set for the tool dialog box. When the tool is executed, the parameter values are sent to your script. Your script reads these values and then proceeds with its work. Python scripts can accept parameters as input. Parameters, also known as arguments, allow your scripts to become dynamic. Up to this point, all of our scripts have used hardcoded values. By specifying input parameters for a script, you are able to supply the name of the feature class at runtime. This capability makes your scripts more versatile.</p><p>The <code class="literal">GetParameterAsText()</code> method, which is used to capture parameter input, is zero-based with the first parameter entered occupying a <code class="literal">0</code> index and each successive parameter is incremented by <code class="literal">1</code>. The output feature class that will be created by reading the comma-delimited text file is specified in the <code class="literal">outputFC</code> variable, which is retrieved by <code class="literal">GetParameterAsText(0)</code>. With <code class="literal">GetParameterAsText(1)</code>, we capture a feature class that will act as a template for the output feature class attribute schema. The attribute fields in the template feature class are used to define the fields that will populate our output feature class. Finally, <code class="literal">GetParameterAsText(2)</code> is used to create a variable called <code class="literal">f</code>, which will hold the comma-delimited text file that will be read.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec129"/>There's more...</h2></div></div></div><p>The <code class="literal">arcpy.GetParameterAsText()</code> method is not the only way to capture information passed into <a id="id357" class="indexterm"/>your script. When you call a Python script from the command line, you can pass in a set of arguments. When passing arguments to a script, each word must be separated by a space. These words are stored in a zero-based list object called <code class="literal">sys.argv</code>. With <code class="literal">sys.argv</code>, the first item in the list, referenced by the <code class="literal">0</code> index, stores the name of the script. Each successive word is referenced by the next integer. Therefore, the first parameter will be stored in <code class="literal">sys.argv[1]</code>, the second in <code class="literal">sys.argv[2]</code>, and so on. These arguments can then be accessed from within your script.</p><p>It is recommended that you use the <code class="literal">GetParameterAsText()</code> function rather than <code class="literal">sys.argv</code>, because <code class="literal">GetParameterAsText()</code> does not have a character limit, whereas <code class="literal">sys.argv</code> has a limit of 1,024 characters per parameter. In either case, once the parameters have been read into the script, your script can continue execution using the input values.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Creating a Python toolbox</h1></div></div></div><p>There are two ways to create toolboxes in ArcGIS: script tools in custom toolboxes that we covered<a id="id358" class="indexterm"/> in the last recipe, and script tools in Python toolboxes. Python toolboxes were introduced in version 10.1 of ArcGIS and they encapsulate everything in one place: parameters, validation code, and source code. This is not the case with custom toolboxes, which are created using a wizard and a separate script that processes business logic.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec130"/>Getting ready</h2></div></div></div><p>A <strong>Python Toolbox</strong> is similar to any other toolbox in <strong>ArcToolbox</strong>, but it is created entirely in Python and has a file extension of <code class="literal">.pyt</code>. It is created programmatically as a class named <code class="literal">Toolbox</code>. In this recipe, you will learn how to create a <strong>Python Toolbox</strong> and add a custom tool. After creating the basic structure of <code class="literal">Toolbox</code> and <code class="literal">Tool</code>, you'll complete the functionality of the tool by adding code that connects to an <strong>ArcGIS Server</strong> map service, downloads real-time data, and inserts it into a feature class.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec131"/>How to do it…</h2></div></div></div><p>Complete these steps to create a <strong>Python Toolbox</strong> and create a custom tool that connects to an <strong>ArcGIS Server</strong> map service, downloads real-time data, and inserts it into a feature class:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <strong>ArcCatalog</strong>. You can create a python toolbox in a folder by right-clicking <a id="id359" class="indexterm"/>on the folder and selecting <strong>New</strong> | <strong>Python Toolbox</strong>. In ArcCatalog, there is a folder called <strong>Toolboxes</strong> and inside it is a <strong>My Toolboxes</strong> folder, as seen in this screenshot:<div><img src="img/B04314_06_17.jpg" alt="How to do it…"/></div></li><li class="listitem">Right-click on this folder and select <strong>New</strong> | <strong>Python Toolbox</strong>.</li><li class="listitem">The name of the toolbox is controlled by the file name. Name the toolbox <code class="literal">InsertWildfires.pyt</code>:<div><img src="img/B04314_06_18.jpg" alt="How to do it…"/></div></li><li class="listitem">The <strong>Python Toolbox</strong> file (<code class="literal">.pyt</code>) can be edited in any text or code editor. By default, the code will open in <strong>Notepad</strong>. You can change this by setting the default editor <a id="id360" class="indexterm"/>for your script by going to <strong>Geoprocessing</strong> | <strong>Geoprocessing Options</strong> and going to the <strong>Editor</strong> section. You'll notice in the following screenshot that I have set my editor to <strong>PyScripter</strong>, which is my preferred environment. You may want to change this to <strong>IDLE</strong> or whatever development environment you are currently using. Please note that this step is not required though. As mentioned, by default, it will open your code in Notepad.<div><img src="img/B04314_06_19.jpg" alt="How to do it…"/></div></li><li class="listitem">Right-click on <code class="literal">InsertWildfires.pyt</code> and select <strong>Edit</strong>. This will open your development environment. Your development environment will vary depending on the editor that you have defined.</li><li class="listitem">Remember<a id="id361" class="indexterm"/> that you will not be changing the name of the class, which is <code class="literal">Toolbox</code>. However, you will rename the <code class="literal">Tool</code> class to reflect the name of the tool you want to create. Each tool will have various methods, including <code class="literal">__init__()</code>, which is the constructor for the tool along with <code class="literal">getParameterInfo()</code>, <code class="literal">isLicensed()</code>, <code class="literal">updateParameters()</code>, <code class="literal">updateMessages()</code>, and <code class="literal">execute()</code>. You can use the <code class="literal">__init__()</code> method to set initialization properties, such as the tool's label and description. Look for the <code class="literal">Tool</code> class and change the name to <code class="literal">USGSDownload</code>. Also, set the label, and description, as seen in this code:<div><pre class="programlisting">class USGSDownload(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "USGS Download"
        self.description = "Download from USGS ArcGIS Server instance"</pre></div></li><li class="listitem">You can use the <code class="literal">Tool</code> class as a template for other tools you'd like to add to the toolbox by copying and pasting the class and its methods. We're not going to do this in this particular exercise, but I wanted you to be aware of this fact. You will need to add each tool to the <code class="literal">tools</code> property of <code class="literal">Toolbox</code>. Add the <code class="literal">USGS Download</code> tool, as seen in this code:<div><pre class="programlisting">class Toolbox(object):
    def __init__(self):
        """Define the toolbox (the name of the toolbox is the name of the
        .pyt file)."""
        self.label = "Toolbox"
        self.alias = ""
        # List of tool classes associated with this toolbox
        self.tools = [USGSDownload]</pre></div></li><li class="listitem">When you close the code editor, your <strong>Toolboxes</strong> should automatically be refreshed. You can also manually refresh a toolbox by right-clicking on the toolbox and selecting <strong>Refresh</strong>. If a syntax error occurs in your code, the toolbox icon will change, as seen in the following screenshot. Note the red <strong>X</strong> next to the toolbox.<div><img src="img/B04314_06_20.jpg" alt="How to do it…"/></div></li><li class="listitem">You<a id="id362" class="indexterm"/> shouldn't have any errors at this time, but if you do, right-click on the toolbox and select Check Syntax to display the errors, as seen in the following screenshot. Note that if you have an error, it may be different from the following example:<div><img src="img/B04314_06_21.jpg" alt="How to do it…"/></div></li><li class="listitem">Assuming that you don't have any syntax errors, you should see the following Toolbox/Tool structure:<div><img src="img/B04314_06_22.jpg" alt="How to do it…"/></div></li><li class="listitem">Almost all tools have parameters, and you set their values in the tool dialog box or within a script. When the tool is executed, the parameter values are sent to <a id="id363" class="indexterm"/>your tool's source code. Your tool reads these values and proceeds with its work. You use the <code class="literal">getParameterInfo()</code> method to define the parameters for your tool. Individual <code class="literal">Parameter</code> objects are created as part of this process. Add the following parameters in the <code class="literal">getParameterInfo()</code> method and then we'll discuss them:<div><img src="img/B04314_06_26.jpg" alt="How to do it…"/></div><p>Each <code class="literal">Parameter</code> object is created using <code class="literal">arcpy.Parameter</code> and is passed a number of arguments that define the object.</p><p>For the first <code class="literal">Parameter</code> object (<code class="literal">param0</code>), we are going to capture a URL for an ArcGIS Server map service containing current wildfire data. We give it a display name (ArcGIS Server Wildfire URL), which will be displayed in the dialog box for the tool, a name for the parameter, data type, parameter type (this is mandatory), and direction.</p><p>In the case of the first parameter (<code class="literal">param0</code>), we also assign an initial value, which is the URL for an existing map service containing wildfire data.</p><p>For the second parameter, we define an output feature class where the wildfire data that is read from the map service will be written. An empty feature class to store the data has already been created for you. Finally, we added both parameters to a Python list called <code class="literal">params</code> and return the list to the calling function</p></li><li class="listitem">The main <a id="id364" class="indexterm"/>work of a tool is done inside the <code class="literal">execute()</code> method. This is where the geoprocessing of your tool takes place. The <code class="literal">execute()</code> method, seen in the following code, can accept a number of arguments, including the tool (self), parameters, and messages:<div><pre class="programlisting">  def execute(self, parameters, messages):
        """The source code of the tool. """
        return</pre></div></li><li class="listitem">To access the parameter values that are passed into the tool, you can use the <code class="literal">valueAsText()</code> method. Add the following code to access the parameter values that will be passed into your tool. Remember, as seen in a previously mentioned step, that the first parameter will contain a URL for a map service containing wildfire data, and the second parameter is the output feature class where the data will be written:<div><pre class="programlisting">def execute(self, parameters, messages):
        inFeatures = parameters[0].valueAsText
        outFeatureClass = parameters[1].valueAsText</pre></div></li><li class="listitem">At this point, you have created a Python toolbox, added a tool, defined the parameters for the tool, and created variables that will hold the parameter values that the end user has defined. Ultimately, this tool will use the URL that is passed into the tool to connect to an ArcGIS Server map service, download the current wildfire data, and write the wildfire data to a feature class. We'll do this next.</li><li class="listitem">Note that to <a id="id365" class="indexterm"/>complete the remainder of this exercise, you will need to install the Python <code class="literal">requests</code> (refer to <a class="ulink" href="http://docs.python-requests.org/en/latest/">http://docs.python-requests.org/en/latest/</a>) module using <code class="literal">pip</code> (refer to <a class="ulink" href="https://pip.pypa.io/en/latest/installing.html">https://pip.pypa.io/en/latest/installing.html</a>). Do this now before<a id="id366" class="indexterm"/> proceeding to the next step. Installation instructions for both <code class="literal">pip</code> and <code class="literal">requests</code> can be found at the links provided.</li><li class="listitem">Next, add the code that connects to the wildfire map service to perform a query. In this step, you will also define the <code class="literal">QueryString</code> parameters that will be passed into the query of the map service. First, we'll import the <code class="literal">requests</code> and <code class="literal">json</code> modules by adding this code:<div><pre class="programlisting">import requests
import json</pre></div></li><li class="listitem">Then, create the payload variable that will hold the <code class="literal">QueryString</code> parameters. Notice that in this case we have defined a <code class="literal">where</code> clause so that only the fires greater than <code class="literal">5</code> acres in size will be returned. The <code class="literal">inFeatures</code> variable holds the URL:<div><pre class="programlisting">def execute(self, parameters, messages):
        inFeatures = parameters[0].valueAsText
        outFeatureClass = parameters[1].valueAsText

        agisurl = inFeatures

        payload = { 'where': 'acres &gt; 5','f': 'pjson', 'outFields': 'latitude,longitude,fire_name,acres'}</pre></div></li><li class="listitem">Submit the<a id="id367" class="indexterm"/> request to the ArcGIS Server instance and the response should be stored in a variable called <code class="literal">r</code>. Print a message to the dialog indicating the response:<div><pre class="programlisting">def execute(self, parameters, messages):
        inFeatures = parameters[0].valueAsText
        outFeatureClass = parameters[1].valueAsText

        agisurl = inFeatures

        payload = { 'where': 'acres &gt; 5','f': 'pjson', 'outFields': 'latitude,longitude,fire_name,acres'}

        r = requests.get(inFeatures, params=payload)</pre></div></li><li class="listitem">Let's test the code to make sure we're on the right track. Save the file and refresh your toolbox in ArcCatalog. Execute the tool and leave the default URL. If everything works as expected, you should see a JSON object output of the progress dialog. Your output will probably vary somewhat.<div><img src="img/B04314_06_23.jpg" alt="How to do it…"/></div></li><li class="listitem">Return to<a id="id368" class="indexterm"/> the <code class="literal">execute()</code> method and convert the JSON object to a Python dictionary:<div><pre class="programlisting">    def execute(self, parameters, messages):
        inFeatures = parameters[0].valueAsText
        outFeatureClass = parameters[1].valueAsText

        agisurl = inFeatures

        payload = { 'where': 'acres &gt; 5','f': 'pjson', 'outFields': 'latitude,longitude,fire_name,acres'}

        r = requests.get(inFeatures, params=payload)
      

        decoded = json.loads(r.text)</pre></div></li><li class="listitem">Create an <code class="literal">InsertCursor</code> by passing the output feature class defined in the tool dialog along with the fields that will be populated. We then start a <code class="literal">for</code> loop that loops through each of the features (wildfires) that have been returned from the request to the ArcGIS Server map service. The <code class="literal">decoded</code> variable is a Python dictionary. Inside the <code class="literal">for</code> loop, we retrieve the fire name, latitude, longitude, and acres from the <code class="literal">attributes</code> dictionary. Finally, we call the <code class="literal">insertRow()</code> method to insert a new row into the feature class along with the fire <a id="id369" class="indexterm"/>name and acres as attributes. The progress information is written to <strong>Progress Dialog</strong> and the counter is updated. The <code class="literal">execute()</code> method should now appear as follows:<div><img src="img/B04314_06_27.jpg" alt="How to do it…"/></div></li><li class="listitem">Save the file and refresh your <strong>Python Toolbox</strong> if needed.</li><li class="listitem">You can check your work by examining the <code class="literal">c:\ArcpyBook\code\Ch6\InsertWildfires_PythonToolbox.py</code> solution file.</li><li class="listitem">Double-click on the <strong>USGS Download</strong> tool.</li><li class="listitem">Leave the default URL and select the <strong>RealTimeFires</strong> feature class in the <strong>WildlandFires</strong> geodatabase found in <code class="literal">c:\ArcpyBook\data</code>. The <strong>RealTimeFires</strong> feature class is empty and has fields for <code class="literal">NAME</code> and <code class="literal">ACRES</code>.</li><li class="listitem">Click on <strong>OK</strong> to execute the tool. The number of features written to the feature class will vary depending on the current wildfire activity. Most of the time, there is at least a little bit of activity, but it is possible (though not likely) that there wouldn't be any wildfires in the U.S:<div><img src="img/B04314_06_24.jpg" alt="How to do it…"/></div></li><li class="listitem">View the<a id="id370" class="indexterm"/> feature class in <strong>ArcMap</strong> to see its features. You may want to add a <code class="literal">basemap</code> layer to provide a reference, as seen in this screenshot:<div><img src="img/B04314_06_28.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec132"/>How it works…</h2></div></div></div><p>The newer <a id="id371" class="indexterm"/>style ArcGIS Python Toolbox provides a Python-centric way of creating your custom script tools. The older style of creating custom script tools in ArcGIS for Desktop uses a combination of Python along with a wizard-based approach to define various aspects of the tool. The newer approach provides a more straightforward method for creating your tools. All the tools that you create are contained within a <code class="literal">Toolbox</code> class that should not be renamed. By default, a single <code class="literal">Tool</code> class will be created inside <code class="literal">Toolbox</code>. This <code class="literal">Tool</code> class should be renamed. In this recipe, we renamed it <code class="literal">USGSDownload</code>. Inside the <code class="literal">USGSDownload</code> class, the <code class="literal">getParameterInfo()</code> and <code class="literal">execute()</code> methods are present, among others. Using the <code class="literal">getParameterInfo()</code> method, <code class="literal">Parameter</code> objects can be defined to hold input data. In this tool, we defined a <code class="literal">Parameter</code> to capture a URL for an ArcGIS Server map service containing live wildfire data and a second <code class="literal">Parameter</code> object to reference a local feature class to hold the data. Finally, the <code class="literal">execute()</code> method is triggered when the user clicks on the <strong>OK</strong> button in the tool. Parameter information is sent as an argument to the <code class="literal">execute()</code> method in the form of the <code class="literal">parameters</code> variable. Inside this method, a request to obtain the wildfire data from the remove ArcGIS Server instance is submitted using the Python <code class="literal">requests</code> module. The response is returned as a <code class="literal">json</code> object that is converted into a Python dictionary stored in a variable called <strong>decoded</strong>. The fire name, latitude, longitude, and acres are pulled out of the decoded variable and written to the local feature<a id="id372" class="indexterm"/> class using an <code class="literal">InsertCursor</code> object from the <code class="literal">arcpy.da</code> module. We'll cover the <code class="literal">arcpy.da</code> module in great detail in a later chapter of the book.</p></div></div></div>
</body></html>