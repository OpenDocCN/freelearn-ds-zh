["```py\n(defproject nullh \"0.1.0-snapshot\"\n  :dependencies [[org.clojure/clojure \"1.5.1\"]\n                 [enlive \"1.1.4\"]\n                 [http.async.client \"0.5.2\"]\n                 [org.clojure/data.csv \"0.1.2\"]\n                 [org.clojure/data.json \"0.2.3\"]\n                 [me.raynes/fs \"1.4.5\"]\n                 [incanter \"1.5.4\"]\n                 [geocoder-clj \"0.2.2\"]\n                 [geo-clj \"0.3.5\"]\n                 [congomongo \"0.4.1\"]\n                 [org.apache.poi/poi-ooxml \"3.9\"]]\n  :profiles {:dev {:dependencies\n                   [[org.clojure/tools.namespace \"0.2.4\"]]\n                   :source-paths [\"dev\"]}})\n```", "```py\nuser=> (require '[incanter.core :as i] '[incanter.stats :as s])\nnil\nuser=> (def table (i/matrix [157 151 175 187 143 187]))\n#'user/table\nuser=> (def r (s/chisq-test :table table))\n#'user/r\nuser=> (pprint (select-keys r [:p-value :df :X-sq]))\n{:X-sq 10.771999999999998, :df 5, :p-value 0.05609271590058857}\n\n```", "```py\n(ns nullh.unodc\n  (:require [clojure.java.io :as io]\n            [clojure.string :as str]\n            [me.raynes.fs :as fs]\n            [clojure.data.json :as json]\n            [nullh.utils :as u])\n  (:import\n    [java.io FileInputStream]\n    [org.apache.poi.ss.usermodel\n     Cell CellStyle DataFormat Font RichTextString Row Sheet]\n    [org.apache.poi.hssf.usermodel HSSFWorkbook]))\n```", "```py\n(defrecord sheet-data [sheet-name sheet-rows])\n(defrecord xl-row\n  [sheet region sub-region country\n   count-2003 count-2004 count-2005 count-2006 count-2007\n   count-2008 count-2009 count-2010 count-2011\n   rate-2003 rate-2004 rate-2005 rate-2006 rate-2007\n   rate-2008 rate-2009 rate-2010 rate-2011])\n```", "```py\n(defn sheets [workbook]\n  (->> workbook\n    (.getNumberOfSheets)\n    (range)\n    (map #(.getSheetAt workbook %))))\n(defn rows [sheet]\n  (->> sheet\n    (.getPhysicalNumberOfRows)\n    (range)\n    (map #(.getRow sheet %))\n    (remove nil?)))\n(defn cells [row]\n  (->> row\n    (.getPhysicalNumberOfRows)\n    (range)\n    (map #(.getCell row %))))\n```", "```py\n(defn cell-type [cell]\n  (if (nil? cell)\n    nil\n    (let [cell-types {Cell/CELL_TYPE_BLANK   :blank\n                      Cell/CELL_TYPE_BOOLEAN :boolean\n                      Cell/CELL_TYPE_ERROR   :error\n                      Cell/CELL_TYPE_FORMULA :formula\n                      Cell/CELL_TYPE_NUMERIC :numeric\n                      Cell/CELL_TYPE_STRING  :string}]\n      (cell-types (.getCellType cell)))))\n(defmulti cell-value cell-type)\n(defmethod cell-value :blank   [_] nil)\n(defmethod cell-value :boolean [c] (.getBooleanCellValue c))\n(defmethod cell-value :error   [c] (.getErrorCellValue   c))\n(defmethod cell-value :formula [c] (.getErrorCellValue   c))\n(defmethod cell-value :numeric [c] (.getNumericCellValue c))\n(defmethod cell-value :string  [c] (.getStringCellValue  c))\n(defmethod cell-value :default [c] nil)\n```", "```py\n(defn open-file [filename]\n  (with-open [s (io/input-stream filename)]\n    (HSSFWorkbook. s)))\n```", "```py\n(defn get-sheet-data [sheet]\n  (->sheet-data (.getSheetName sheet) (rows sheet)))\n```", "```py\n(defn on-rows [sheet f]\n  (assoc sheet :sheet-rows (f (:sheet-rows sheet))))\n```", "```py\n(defn first-cell-empty? [cells]\n  (empty? (cell-value (first cells))))\n(defn skip-headers [sheet]\n  (on-rows sheet (fn [r]\n                   (->> r\n                     (drop-while #(first-cell-empty? (cells %)))\n                     (drop 1)\n                     (take-while #(not (first-cell-empty? %)))))))\n```", "```py\n(defn row-values [sheet-name row]\n  (conj (mapv cell-value (cells row)) sheet-name))\n(defn sheet-data->seq [sheet]\n  (map #(row-values (:sheet-name sheet) %) (:sheet-rows sheet)))\n```", "```py\n(defn clean-row [row]\n  (u/pad-vec 22\n             (concat (list (last row) (first row))\n                     (take 11 (drop 3 row))\n                     (drop 15 row))))\n```", "```py\n(defn seq->xl-row [coll] (apply ->xl-row coll))\n```", "```py\n(defrecord region [region-name sub-regions])\n(defrecord sub-region [sub-region-name countries])\n(defrecord country [country-name counts rates sheet])\n(defrecord yearly-data\n   [year-2003 year-2004 year-2005 year-2006 year-2007 year-2008\n    year-2009 year-2010 year-2011])\n```", "```py\n(defn xl-rows->regions [coll]\n  (->> coll\n    (group-by :region)\n    (map #(->region\n            (first %) (xl-rows->sub-regions (second %))))))\n```", "```py\n(defn conj-into [m k v]\n\n  (if (contains? m k)\n    (assoc m k (conj (get m k) v))\n    (assoc m k [v])))\n(defn fold-sub-region [state row]\n  (let [[current accum] state]\n    (if (str/blank? (:sub-region row))\n      [current\n       (conj-into accum current (assoc row :sub-region current))]\n      (let [new-sub-region (:sub-region row)]\n        [new-sub-region\n         (conj-into accum new-sub-region row)]))))\n(defn xl-rows->sub-regions [coll]\n  (->> coll\n    (reduce fold-sub-region [nil {}])\n    second\n    (map #(->sub-region\n            (first %) (xl-rows->countries (second %))))))\n```", "```py\n(defn xl-rows->countries [coll]\n  (->> coll\n    (group-by :country)\n    (map #(let [[country-name [row & _]] %]\n            (->country country-name\n                       (xl-row->counts row)\n                       (xl-row->rates row)\n                       (:sheet row))))))\n```", "```py\n(defn xl-row->yearly [coll fields]\n  (apply ->yearly-data (map #(get coll %) fields)))\n(defn xl-row->counts [coll]\n  (xl-row->yearly\n    coll\n    [:count-2003 :count-2004 :count-2005 :count-2006 :count-2007\n     :count-2008 :count-2009 :count-2010 :count-2011]))\n(defn xl-row->rates [coll]\n  (xl-row->yearly\n    coll\n    [:rate-2003 :rate-2004 :rate-2005 :rate-2006 :rate-2007\n     :rate-2008 :rate-2009 :rate-2010 :rate-2011]))\n```", "```py\n(defn region->xl-rows [tree nil-row]\n  (let [region-row (assoc nil-row :region (:region-name tree))]\n    (mapcat #(sub-regions->xl-rows % region-row)\n            (:sub-regions tree))))\n(defn regions->xl-rows [region-coll]\n  (let [nil-row (seq->xl-row (repeat 22 nil))]\n    (mapcat #(region->xl-rows % nil-row) region-coll)))\n```", "```py\n(defn country->xl-rows [tree sub-region-row]\n  (let [counts (:counts tree), rates (:rates tree)]\n    (assoc sub-region-row\n           :sheet (:sheet tree)\n           :country (:country-name tree)\n           :count-2003 (:year-2003 counts)\n           :count-2004 (:year-2004 counts)\n           ;; ...\n           :rate-2003 (:year-2003 rates)\n           :rate-2004 (:year-2004 rates)\n           ;; ...\n           )))\n(defn sub-regions->xl-rows [tree region-row]\n  (let [sub-region-row (assoc region-row :sub-region\n                              (:sub-region-name tree))]\n    (map #(country->xl-rows % sub-region-row) (:countries tree))))\n```", "```py\n(defn read-sheets [filename]\n  (->> filename\n    (open-file)\n    (sheets)\n    (map get-sheet-data)\n    (map skip-headers)\n    (map (fn [s] (on-rows s #(remove empty? %))))\n    (mapcat sheet-data->seq)\n    (map clean-row)\n    (map seq->xl-row)\n    (xl-rows->regions)\n    (regions->xl-rows)))\n```", "```py\n{:sheet \"CTS 2012 Domestic Burglary\",\n :region \"Africa\",\n :sub-region \"Middle Africa\",\n :country \"Sao Tome and Principe\",\n :count-2003 nil,\n :count-2004 nil,\n :count-2005 nil,\n :count-2006 2.0,\n :count-2007 0.0,\n :count-2008 2.0,\n :count-2009 5.0,\n :count-2010 16.0,\n :count-2011 20.0,\n :rate-2003 nil,\n :rate-2004 nil,\n :rate-2005 nil,\n :rate-2006 1.290572368845583,\n :rate-2007 0.0,\n :rate-2008 1.2511573205214825,\n :rate-2009 3.0766390794695875,\n :rate-2010 9.673694202434143,\n :rate-2011 11.867604998635224}\n```", "```py\n(ns nullh.data\n  (:require [incanter.core :as i]\n            [incanter.io :as iio]\n            [clojure.set :as set]\n            [clojure.string :as str]\n            [clojure.data.csv :as csv]\n            [clojure.data.json :as json]\n            [clojure.java.io :as io]\n            [me.raynes.fs :as fs]\n            [nullh.unodc :as unodc]\n            [nullh.utils :as u]))\n```", "```py\n(defn read-cts-data [dirname]\n  (let [input (mapcat unodc/read-sheets (u/ls dirname))\n        cols (keys (first input))]\n    (i/dataset cols (doall (map #(map second %) input)))))\n```", "```py\n(def headers [:country-name :country-code :indicator-name\n              :indicator-code :1961 :1962 :1963 :1964 :1965 :1966\n              :1967 :1968 :1969 :1970 :1971 :1972 :1973 :1974\n              :1975 :1976 :1977 :1978 :1979 :1980 :1981 :1982\n              :1983 :1984 :1985 :1986 :1987 :1988 :1989 :1990\n              :1991 :1992 :1993 :1994 :1995 :1996 :1997 :1998\n              :1999 :2000 :2001 :2002 :2003 :2004 :2005 :2006\n              :2007 :2008 :2009 :2010 :2011 :2012 :2013])\n(defn ->double [x] (if (str/blank? x) nil (Double/parseDouble x)))\n(defn coerce-row [row]\n  (let [[x y] (split-at 4 row)]\n    (concat x (map ->double y))))\n(defn read-indicator-data [filename]\n  (with-open [f (io/reader filename)]\n    (->> f\n      csv/read-csv\n      (drop 3)\n      (map coerce-row)\n      doall\n      (i/dataset headers))))\n```", "```py\n(defn join-all [indicator cts]\n  (i/$join [:country-name :country] indicator cts))\n```", "```py\n(defn pivot-map [m]\n  (let [years [2003 2004 2005 2006 2007 2008 2009 2010 2011]]\n    (map #(pivot-year m %) years)))\n(defn pivot-data [map-seq] (mapcat pivot-map map-seq))\n```", "```py\n(defn pivot-year [m year]\n  (let [count-key (keyword (str \"count-\" year))\n        rate-key (keyword (str \"rate-\" year))\n        year-key (keyword (str year))]\n    (-> m\n      (select-keys [:region :sub-region :country :country-code\n                    :indicator :indicator-code\n                    :sheet count-key rate-key year-key])\n      (set/rename-keys {:sheet :crime,\n                        count-key :count,\n                        rate-key :rate,\n                        year-key :indicator-value})\n      (assoc :year year))))\n```", "```py\n(defn remove-missing [coll]\n  (let [fields [:count :rate :indicator-value]\n        has-missing (fn [r] (some nil? (map r fields)))]\n    (remove has-missing coll)))\n```", "```py\n(defn ->maps [dset]\n  (let [col-names (i/col-names dset)]\n    (map #(zipmap col-names %) (i/to-list dset))))\n(defn load-join-pivot [cts-dir data-file]\n  (let [cts (read-cts-data cts-dir)\n        indicator-data (read-indicator-data data-file)]\n    (->> (join-all indicator-data cts)\n      ->maps\n      pivot-data\n      remove-missing\n      i/to-dataset)))\n```", "```py\n(def d (d/load-join-pivot\n         \"unodc-data\"\n         \"ag.lnd/ag.lnd.totl.k2_Indicator_en_csv_v2.csv\"))\n```", "```py\n(s/summary\n  (i/$where {:crime {:$eq \"CTS 2012 Burglary\"}} by-ag-lnd))\n```", "```py\n(def by-ag-lnd\n  (d/load-join-pivot\n    \"unodc-data\"\n    \"ag.lnd/ag.lnd.totl.k2_Indicator_en_csv_v2.csv\"))\n```", "```py\n(def burglary\n  (i/$where {:crime {:$eq \"CTS 2012 Burglary\"}} by-ag-lnd))\n```", "```py\n(def h\n  (c/histogram (i/sel burglary :cols :count)\n                :nbins 30\n                :title \"Burglary Counts\"\n                :x-label \"Burglaries\"))\n(i/view h)\n```", "```py\n(defn by-crime [dset crime-label]\n  (i/$where {:crime {:$eq crime-label}} dset))\n```", "```py\n(defn plot-crime [dset indicator-label crime-label]\n  (let [x (i/sel dset :cols :indicator-value)\n        y (i/sel dset :cols :rate)\n        title (str indicator-label \" and \" crime-label)]\n    (c/scatter-plot x y\n                    :title title\n                    :x-label indicator-label\n                    :y-label crime-label)))\n```", "```py\n(def by-ag-lnd\n  (d/load-join-pivot\n    \"unodc-data\"\n    \"ag.lnd/ag.lnd.totl.k2_Indicator_en_csv_v2.csv\"))\n(def ag-plot\n  (n-ch/plot-crime (d/by-crime by-ag-lnd \"CTS 2012 Burglary\")\n                   \"Land Area\" \"Burglary\"))\n(i/view ag-plot)\n```", "```py\n(defn aggregate-years-by-country\n  ([dset] (aggregate-years-by-country dset :mean))\n  ([dset by]\n   (let [data-cols [:count :rate :indicator-value]]\n     (->> [:count :rate :indicator-value]\n       (map #(i/$rollup by % :country dset))\n       (reduce #(i/$join [:country :country] %1 %2))))))\n```", "```py\n(defn spearmans\n  ([col-a col-b] (spearmans col-a col-b i/$data))\n  ([col-a col-b dataset]\n   (let [rho (s/spearmans-rho\n               (i/sel dataset :cols col-a)\n               (i/sel dataset :cols col-b))\n         n (i/nrow dataset)\n         mu 0.0\n         sigma (Math/sqrt (/ 1.0 (- n 1.0)))\n         z (/ (- rho mu) sigma)]\n     {:rho rho, :n n, :mu mu, :sigma sigma, :z z})))\n```", "```py\nuser=> (def by-ny-gnp\n (d/load-join-pivot\n \"unodc-data\"\n \"ny.gnp/ny.gnp.pcap.cd_Indicator_en_csv_v2.csv\"))\n#'user/by-ny-gnp\nuser=> (def burglary (d/by-crime by-ny-gnp \"CTS 2012 Burglary\"))\n#'user/burglary\nuser=> (pprint (n-stat/spearmans :indicator-value :rate burglary))\n{:rho 0.6938241467993876,\n :n 537,\n :mu 0.0,\n :sigma 0.04319342127906801,\n :z 16.063190325134588}\n\n```"]