- en: Chapter 5. Advanced Array Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。高级数组概念
- en: In this chapter, we will explain some more advanced aspects of arrays. First,
    we will cover the notion of an array view, followed by Boolean arrays and how
    to compare arrays. We briefly describe indexing and vectorization, explain sparse
    arrays, and some special topics such as broadcasting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释数组的一些更高级的方面。首先，我们将介绍数组视图的概念，然后是布尔数组以及如何比较数组。我们将简要描述索引和向量化，解释稀疏数组，以及广播等一些特殊主题。
- en: Array views and copies
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组视图和副本
- en: In order to control precisely how memory is used, NumPy offers the concept of
    view of an array. Views are smaller arrays that share the same data as a larger
    array. This works just like a reference to one single object (refer to section
    *Basic Types* in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting
    Started*).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确控制内存的使用，NumPy提供了数组的视图概念。视图是较小的数组，与较大的数组共享相同的数据。这就像对一个单一对象的引用（参见[第1章](ch01.html
    "第1章。入门")中的*基本类型*部分，*入门*）。
- en: Array views
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组视图
- en: 'The simplest example of a view is given by a slice of an array:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的简单示例是数组的切片：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding slice is a view of `M`. It shares the same data as `M`. Modifying
    `v` will modify `M` as well:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的切片是`M`的视图。它与`M`共享相同的数据。修改`v`也会修改`M`：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is possible to access the object that owns the data using the array attribute
    `base`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用数组的`base`属性访问拥有数据的对象：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If an array owns its data, the attribute base is none :'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组拥有自己的数据，则基础属性为none：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Slices as views
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为视图的切片
- en: 'There are precise rules on which slices will return views and which ones will
    return copies. Only basic slices (mainly index expressions with `:`) return views,
    whereas any advanced selections (such as slicing with a Boolean) will return a
    copy of the data. For instance, it is possible to create new matrices by indexing
    with lists (or arrays):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '有关于哪些切片会返回视图以及哪些会返回副本的精确规则。只有基本切片（主要是带有`:`的索引表达式）会返回视图，而任何高级选择（例如使用布尔值的切片）都会返回数据的副本。例如，可以通过列表（或数组）索引创建新的矩阵： '
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the array `b` is not a view, whereas the array `c`,
    obtained with a simpler slice, is a view.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，数组`b`不是一个视图，而通过更简单的切片获得的数组`c`是一个视图。
- en: 'There is an especially simple slice of an array that returns a view of the
    whole array:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特别简单的数组切片可以返回整个数组的视图：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Transpose and reshape as views
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转置和重塑作为视图
- en: 'Some other important operations return views. For instance, transpose returns
    a view:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他重要操作会返回视图。例如，转置会返回一个视图：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same applies for all reshaping operations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有重塑操作也适用：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Array copy
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组复制
- en: 'Sometimes it is necessary to explicitly request that the data be copied. This
    is simply achieved with the NumPy function called `array`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要显式请求复制数据。这可以通过NumPy函数`array`简单地实现：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We may verify that the data has indeed been copied:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证数据确实已被复制：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Comparing arrays
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较数组
- en: 'Comparing two arrays is not as simple as it may seem. Consider the following
    code, which is intended to check whether two matrices are close to each other:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个数组并不像看起来那么简单。考虑以下代码，其目的是检查两个矩阵是否接近：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code raises the exception when the `if` statement is executed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`if`语句时，此代码会引发异常：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we explain why this is so and how to remedy this state of affairs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释为什么会这样，以及如何纠正这种情况。
- en: Boolean arrays
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔数组
- en: 'Boolean arrays are useful for advanced array indexing (refer to section *Indexing
    with Boolean arrays*). A Boolean array is simply an array for which the entries
    have the type `bool`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数组对于高级数组索引很有用（参见*使用布尔数组索引*部分）。布尔数组是一个条目类型为`bool`的数组：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Any comparison operator acting on arrays will create a Boolean array instead
    of a simple Boolean:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任何作用于数组的比较运算符都会创建一个布尔数组而不是简单的布尔值：
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that because array comparison creates Boolean arrays, one cannot use array
    comparison directly in conditional statements, for example, `if` statements. the
    solution is to use the methods `all` and `any`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于数组比较会创建布尔数组，因此不能直接在条件语句（例如`if`语句）中使用数组比较。解决方案是使用`all`和`any`方法：
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Checking for equality
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查相等性
- en: 'Checking for equality of two float arrays is not straight forward, because
    two floats may be very close without being equal. In NumPy, it is possible to
    check for equality with `allclose`. This function checks for equality of two arrays
    up to a given precision:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The tolerance is given in terms of a relative tolerance bound, `rtol`, and
    an absolute error bound, `atol`. The command `allclose` is a short form of: `(abs(A-B)
    < atol+rtol*abs(B)).all()`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `allclose` can be also applied to scalars:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Boolean operations on arrays
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You cannot use `and`, `or`, and `not` on Boolean arrays. Indeed, those operators
    force the casting from array to Boolean, which is not permitted. Instead, we can
    use the operators given in the following table (*Table 5.1*) for componentwise
    logical operations on Boolean arrays:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logic operator** | **Replacement for Boolean arrays** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `A and B` | `A & B` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `A or B` | `A &#124; B` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `not A` | `~ A` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: Table 5.1 Logical operators and, or and not do not work with arrays.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is an example usage of logical operators with Boolean arrays:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we have a sequence of data that is marred with some measurement
    error. Suppose further that we run a regression and it gives us a deviation for
    each value. We wish to obtain all the exceptional values and all the values with
    little deviation that are lower than a given threshold:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Array indexing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that one may index arrays by combinations of slices and
    integers, this is the basic slicing technique. There are, however, many more possibilities,
    which allow for a variety of ways to access and modify array elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with Boolean arrays
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is often useful to access and modify only parts of an array, depending on
    its value. For instance, one might want to access all the positive elements of
    an array. This turns out to be possible using Boolean arrays, which act like masks
    to select only some elements of an array. The result of such an indexing is *always*
    a vector. For instance, consider the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In fact, the `M[B]` call is equivalent to `M.flatten()[B]`. One may then replace
    the resulting vector by another vector. For instance, one may replace all the
    elements by zero (refer to section *Broadcasting* for more information):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or one may replace all the selected values by others:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By combining the creation of Boolean arrays (`M > 2`), smart indexing (indexing
    with Boolean array), and broadcasting, one may use the following elegant syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The expression broadcasting here refers to the tacit conversion of the scalar
    0 to a vector of an appropriate shape.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Using where
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command `where` gives a useful construct that can take a Boolean array as
    a condition and either return the indexes of the array elements satisfying the
    condition or return different values depending on the values in the Boolean array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure is:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will return values from `a` when the condition is `True` and values from
    `b` when it is `False`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'For instances consider, a *Heaviside* function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个*海维赛德*函数：
- en: '![Using where](img/B05511_05_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用where](img/B05511_05_01.jpg)'
- en: 'The following code implements a Heaviside function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了一个海维赛德函数：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second and third arguments can be either arrays of the same size as the
    condition (the Boolean array) or scalars. We give two more example to demonstrated
    how to manipulate elements from an array or a scalar depending on a condition:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个参数可以是与条件（布尔数组）大小相同的数组或标量。我们给出两个更多示例，以展示如何根据条件从数组或标量中操作元素：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the second and third arguments are omitted, then a tuple containing the indexes
    of the elements satisfying the condition is returned.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第二个和第三个参数，则返回满足条件的元素的索引组成的元组。
- en: 'For example consider the use of `where` with only one argument in the following
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码中`where`只使用一个参数的使用：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Performance and Vectorization
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和向量化
- en: When it comes to performance of your Python code, it often boils down to the
    difference between interpreted code and compiled code. Python is an interpreted
    programming language and basic Python code is executed directly without any intermediate
    compilation to machine code. With a compiled language, the code needs to be translated
    to machine instructions before execution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到Python代码的性能时，这通常归结为解释代码和编译代码之间的差异。Python是一种解释型编程语言，基本的Python代码是直接执行，而不需要任何中间编译成机器代码。对于编译型语言，代码在执行之前需要被翻译成机器指令。
- en: The benefits of an interpreted language are many but interpreted code cannot
    compete with compiled code for speed. To make your code faster, you can write
    some parts in a compiled language like FORTRAN, C, or C++. This is what NumPy
    and SciPy do.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言的优点很多，但解释型代码在速度上无法与编译型代码竞争。为了使你的代码更快，你可以用像FORTRAN、C或C++这样的编译型语言编写一些部分。这正是NumPy和SciPy所做的事情。
- en: 'For this reason, it is best to use functions in NumPy and SciPy over interpreted
    versions whenever possible. NumPy array operations such as matrix multiplication,
    matrix-vector multiplication, matrix factorization, scalar products, and so on
    are much faster than any pure Python equivalent. Consider the simple case of scalar
    products. The scalar product is much slower than the compiled NumPy function, `dot(a,b)`
    (more than 100 times slower for arrays with about 100 elements):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在可能的情况下，最好使用NumPy和SciPy中的函数，而不是解释型版本。NumPy数组操作，如矩阵乘法、矩阵-向量乘法、矩阵分解、标量积等，比任何纯Python等价物都要快得多。考虑标量积的简单情况。标量积比编译型NumPy函数`dot(a,b)`慢得多（对于大约有100个元素的数组，慢100多倍）：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Measuring the speed of your functions is an important aspect of scientific computing.
    Refer to section *Measuring execution time* in [Chapter 13](ch13.html "Chapter 13. Testing"),
    *Testing, * for details on measuring execution times.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 测量函数的速度是科学计算的一个重要方面。有关测量执行时间的详细信息，请参阅[第13章](ch13.html "第13章。测试")中的*测量执行时间*部分，*测试*。
- en: Vectorization
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量化
- en: 'To improve performance, one has to vectorize the code often. Replacing `for`
    loops and other slower parts of the code with NumPy slicing, operations, and functions
    can give significant improvements. For example, the simple addition of a scalar
    to a vector by iterating over the elements is very slow:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，必须经常向量化代码。用NumPy切片、操作和函数替换`for`循环和其他较慢的代码部分可以带来显著的改进。例如，通过遍历元素将标量加到向量上的简单操作非常慢：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'where using NumPy''s addition is much faster:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中使用NumPy的加法要快得多：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using NumPy slicing can also give significant speed improvements over iterating
    with `for` loops. To demonstrate this let us consider forming the average of neighbors
    in a two-dimensional array:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy切片也可以在迭代`for`循环时提供显著的性能提升。为了演示这一点，让我们考虑在一个二维数组中形成邻居的平均值：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These functions both assign each element the average of its four neighbors.
    The second version, using slicing, is much faster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都给每个元素分配了其四个邻居的平均值。第二种版本，使用切片，要快得多。
- en: Besides replacing `for` loops and other slower constructions with NumPy functions,
    there is a useful function called `vectorize`, refer to section *Functions acting
    on arrays* in [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"), *Linear
    Algebra - Arrays*. This will take a function and create a vectorized version that
    applies the function on all elements of an array using functions wherever possible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example for vectorizing a function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Applying this by iterating over an array is very slow:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead, use `vectorize` to create a new function, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function can then be applied to the array directly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The vectorized option is much faster (around 10 times faster with arrays of
    length 100).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Broadcasting in NumPy denotes the ability to guess a common, compatible shape
    between two arrays. For instance, when adding a vector (one-dimensional array)
    and a scalar (zero-dimensional array), the scalar is extended to a vector, in
    order to allow for the addition. The general mechanism is called broadcasting.
    We will first review that mechanism from a mathematical point of view, and then
    proceed to give the precise rules for broadcasting in NumPy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical view
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Broadcasting is often performed in mathematics, mainly implicitly. Examples
    are expressions such as *f(x) + C* or *f(x) + g(y)*. We'll give an explicit description
    of that technique in this section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We have in mind the very close relationship between functions and NumPy arrays,
    as described in section *Mathematical preliminaries* of [Chapter 4](ch04.html
    "Chapter 4. Linear Algebra – Arrays"), *Linear Algebra - Arrays.*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Constant functions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most common examples of broadcasting is the addition of a function
    and a constant; if *C* is a scalar, one often writes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Constant functions](img/sinplusC.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'This is an abuse of notation since one should not be able to add functions
    and constants. Constants are however implicitly broadcast to functions. The broadcast
    version of the constant *C* is the function ![Constant functions](img/B05511_05_06_Cbar.jpg)
    defined by:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Constant functions](img/cbar.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Now it makes sense to add two functions together:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Constant functions](img/sinplusCbar.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'We are not being pedantic for the sake of it, but because a similar situation
    may arise for arrays, as in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, everything happens as if the scalar `1.` had been converted
    to an array of the same length as `vector`, that is, `array([1.,1.,1.,1.])`, and
    then added to `vector`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: This example is exceedingly simple, so we proceed to show less obvious situations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Functions of several variables
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A more intricate example of broadcasting arises when building functions of
    several variables. Suppose, for instance, that we were given two functions of
    one variable, *f* and *g*, and that we want to construct a new function *F* according
    to the formula:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions of several variables](img/fplusg.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: This is clearly a valid mathematical definition. We would like to express this
    definition as the sum of two functions in two variables defined as
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions of several variables](img/fgoverline.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'and now we may simply write:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions of several variables](img/fplugoverline.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'The situation is similar to that arising when adding a column matrix and a
    row matrix:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is especially useful when sampling functions of two variables, as shown
    in section *Typical examples*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: General mechanism
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen how to add a function and a scalar and how to build a function
    of two variables from two functions of one variable. Let us now focus on the general
    mechanism that makes this possible. The general mechanism consists of two steps:
    reshaping and extending.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the function *g* is reshaped to a function ![General mechanism](img/gwidetilde.jpg) that
    takes two arguments. One of these arguments is a dummy argument, which we take
    to be zero, as a convention:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/gtilde-1.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'Mathematically, the domain of definition of ![General mechanism](img/gwidetilde.jpg)
    is now ![General mechanism](img/domain.jpg)Then the function *f* is reshaped in
    a way similar to:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/ftilde.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Now both ![General mechanism](img/fwidetilde.jpg) and ![General mechanism](img/gwidetilde.jpg)
    take two arguments, although one of them is always zero. We proceed to the next
    step, extending. It is the same step that converted a constant into a constant
    function (refer to the constant function example).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The function ![General mechanism](img/fwidetilde.jpg) is extended to:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/foverlinewide.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'The function ![General mechanism](img/gwidetilde.jpg) is extended to:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/goverlinewide.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Now the function of two variables *F*, which was sloppily defined by *F(x,y)
    = f(x) + g(y)*, may be defined without reference to its arguments:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/Fasfoverlinepluggoverline.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'For example, let us describe the preceding mechanism for constants. A constant
    is a scalar, that is, a function of zero arguments. The reshaping step is thus
    to define the function of one (empty) variable:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/Cwidetilde.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'Now the extension step proceeds simply by:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/Cwideoverline.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Conventions
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last ingredient is the convention on how to add the extra arguments to a
    function, that is, how the reshaping is automatically performed. By convention,
    a function is automatically reshaped by adding zeros on the left.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a function *g* of two arguments has to be reshaped to three
    arguments, the new function would be defined by:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Conventions](img/gthreearguments.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Broadcasting arrays
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now repeat the observation that arrays are merely functions of several variables
    (refer to section *Mathematical preliminaries* in [Chapter 4](ch04.html "Chapter 4. Linear
    Algebra – Arrays"), *Linear Algebra - Arrays*). Array broadcasting thus follows
    exactly the same procedure as explained above for mathematical functions. Broadcasting
    is done automatically in NumPy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure (*Figure 5.1*), we show what happens when adding a
    matrix of shape (4, 3) to a matrix of size (1, 3). The second matrix is of the
    shape (4, 3):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Broadcasting arrays](img/broadcastingMV.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Broadcasting between a matrix and a vector.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The broadcasting problem
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When NumPy is given two arrays with different shapes, and is asked to perform
    an operation that would require the two shapes to be the same, both arrays are
    broadcast to a common shape.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the two arrays have shapes *s[1]* and *s[2]*. This broadcasting is
    performed in two steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: If the shape *s[1]* is shorter than the shape *s[2]* then ones are added on
    the left of the shape *s[1]*. This is a reshaping.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the shapes have the same length, the array is extended to match the shape
    *s[2]* (if possible).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose we want to add a vector of shape (3, ) to a matrix of shape (4, 3).
    The vector needs be broadcast. The first operation is a reshaping; the shape of
    the vector is converted from (3, ) to (1, 3). The second operation is an extension;
    the shape is converted from (1, 3) to (4, 3).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose a vector of size *n* is to be broadcast to the shape
    (*m, n*):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '*v* is automatically reshaped to (1, *n*).'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*v* is extended to (*m*, *n*).'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To demonstrate this we consider a matrix defined by:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'and vector given by:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we may add `M` and `v` directly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result is this matrix:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![The broadcasting problem](img/B05511_05_02.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Shape mismatch
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is not possible to automatically broadcast a vector `v` of length `n` to
    the shape `(n,m)`. This is illustrated in the following figure:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape mismatch](img/broadcastingwrong.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'The broadcasting will fail, because the shape `(n,)` may not be automatically
    broadcast to the shape `(m, n)`. The solution is to manually reshape `v` to the
    shape `(n,1)`. The broadcasting will now work as usual (by extension only):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is another example, define a matrix  by:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and a vector by:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now automatic broadcasting will fail, because automatic reshaping does not
    work:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The solution is thus to take care of the reshaping manually. What we want in
    that case is to add 1 on the right, that is, transform the vector into a column
    matrix. The broadcasting then works directly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the shape parameter -1, refer to section *Accessing and changing the shape*
    of [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"), *Linear Algebra
     - Arrays.* The result is this matrix:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape mismatch](img/B05511_05_03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Typical examples
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us examine some typical examples where broadcasting may come in handy.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Rescale rows
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose `M` is an *n* × *m* matrix, and we want to multiply each row by a coefficient.
    The coefficients are stored in a vector `coeff` with *n* components. In that case,
    automatic reshaping will not work, and we have to execute:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Rescale columns
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The setup is the same here, but we would like to rescale each column with a
    coefficient stored in a vector `coeff` of length *m*. In this case, automatic
    reshaping will work:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Obviously, we may also do the reshaping manually and achieve the same result
    with:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Functions of two variables
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose *u* and *v* are vectors and we want to form the matrix *W* with elements
    *w[ij] = u[i] + v[j]*. This would correspond to the function *F(x, y) = x + y*.
    The matrix *W* is merely defined by:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the vectors *u* and *v* are [0, 1] and [0, 1, 2] respectively, the result
    is:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions of two variables](img/B05511_05_04.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'More generally, suppose that we want to sample the function *w*(*x, y*) *:=*
    cos(*x*) *+* sin(2*y*). Supposing that the vectors *x* and *y* are defined, the
    matrix *w* of sampled values is obtained by:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that this is very frequently used in combination with `ogrid`. The vectors
    obtained from `ogrid` are already conveniently shaped for broadcasting. This allows
    for the following elegant sampling of the function cos(*x*) *+* sin(2*y*):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The syntax of `ogrid` needs some explanation. First, `ogrid` is no function.
    It is an instance of a class with a `__getitem__` method (refer to section *Attributes*
    in [Chapter 8](ch08.html "Chapter 8. Classes"), *Classes*). That is why it is
    used with brackets instead of parentheses.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The two commands are equivalent:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The stride parameter in the preceding example is a complex number. This is
    to indicate that it is the number of steps instead of the step size. The rules
    for the stride parameter might be confusing at first glance:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If the stride is a real number, then it defines the size of the steps between
    start and stop and stop is not included in the list.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the stride is a complex number `s`, then the integer part of `s.imag` defines
    the number of steps between start and stop and stop is included in the list.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another example for the output of `ogrid` is a tuple with two arrays, which
    can be used for broadcasting:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'gives:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'which is equivalent to:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Sparse matrices
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matrices with a small number of nonzero entries are called **sparse matrices**.
    Sparse matrices occur, for example, in scientific computing when describing discrete
    differential operators in the context of numerically solving partial differential
    equations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Sparse matrices often have large dimensions, sometimes so large that the entire
    matrix (with zero entries) would not even fit in the available memory. This is
    one motivation for a special type for sparse matrices. Another motivation is better performance
    of operations where zero matrix entries can be avoided.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: There are only a very limited number of algorithms for general, unstructured
    sparse matrices in linear algebra. Most of them are iterative in nature and based
    on efficient implementations of matrix-vector multiplication for sparse matrices.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Examples for sparse matrices are diagonal or banded matrices. The simple pattern
    of these matrices allows straightforward storing strategies; the principal diagonal
    and the sub- and super-diagonals are stored in 1D arrays. Conversion from a sparse
    representation to the classical array type and vice-versa can be done by the command
    `diag`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In general, there is not such a simple structure and the description of sparse
    matrices requires special techniques and standards. Here we present a row and
    a column oriented type for sparse matrices, both available through the module
    `scipy.sparse` .
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![Sparse matrices](img/sparse.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: A stiffness matrix from a finite element model of an elastic plate.
    The pixels denote nonzero entries in the 1250 × 1250 matrix'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Sparse matrix formats
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `scipy.sparse` module provides many different storing formats from sparse
    matrices. We describe here only the most important ones: CSR, CSC, and LIL. The
    LIL format should be used for generating and altering sparse matrices; CSR and
    CSC are efficient formats for matrix-matrix and matrix-vector operations.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Compressed sparse row
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The compressed sparse row format (CSR) uses three arrays: `data`, `indptr`,
    and `indices`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The 1D array `data` stores all the nonzero values in order. It has as many elements
    as there are nonzero elements, often denoted by the variable `nnz`.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1D array `indptr` contains integers such that `indptr[i]` is the index of
    the element in `data`, which is the first nonzero element of row *i*. If the entire
    row *i* is zero, then `indptr[i]==indptr[i+1]`. If the original matrix has *m*
    rows, then `len(indptr)==m+1`.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1D array `indices` contains the column index information in such a way that
    `indices[indptr[i]:indptr[i+1]]` is an integer array with the column indexes of
    the nonzero elements in row *i*. Obviously, `len(indices)==len(data)==nnz`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see an example: The CSR format of the matrix:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Compressed sparse row](img/B05511_05_05.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'is given by the three arrays:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The module `scipy.sparse` provides a type, `csr_matrix`, with a constructor,
    which can be used in the following ways:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: With a 2D array as argument
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a matrix in one of the other sparse formats in `scipy.sparse`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a shape argument, `(m,n)`, to generate a zero matrix in CSR format
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By a 1D array for the `data` and an integer array `ij` with the shape `(2,len(data))`
    such that `ij[0,k]` is the row index and `ij[1,k]` is the column index of `data[k]`
    of the matrix
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three arguments, `data`, `indptr`, and `indices`, can be given to the constructor
    directly
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two options are there for conversion purposes while the last two directly
    define the sparse matrix.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the above example in python look like:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Among others, the following attributes are provided:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Compressed Sparse Column
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CSR format has a column oriented twin - the compressed sparse column (CSC)
    format. The only difference in it compared to the CSR format is the definition
    of the `indptr` and `indices` arrays, which are now column-related. The type for
    the CSC format is `csc_matrix` and its use corresponds to `csr_matrix`, explained
    previously in this section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the same example in CSC format:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Row-based linked list format
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The linked list sparse format stores the nonzero matrix entries rowwise in a
    list `data` such that `data[k]` is a list of the nonzero entries in row *k*. If
    all entries in that row are 0, it contains an empty list.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'A second list, `rows`, contains at position *k* a list of column indexes of
    the nonzero elements in row *k*.  Here is an example in **Row-Based linked List
    Format (LIL)** format:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Altering and slicing matrices in LIL format
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The LIL format is the one best suited for slicing, that is, extracting submatrices
    in LIL format, and for changing the sparsity pattern by inserting nonzero elements.
    Slicing is demonstrated by the next example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Insertion of a new nonzero element automatically updates the attributes:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: These operations are discouraged in the other sparse matrix formats as they
    are extremely inefficient.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Generating sparse matrices
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NumPy commands `eye`, `identity`, `diag`, and `rand` have their sparse counterparts.
    They take an additional argument; it specifies the sparse matrix format of the
    resulting matrix.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands generate the identity matrix but in different sparse
    matrix formats:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `sp.rand` command takes an additional argument describing the density of
    the generated random matrix. A dense matrix has density 1 while a zero matrix
    has density 0:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There is no direct correspondence to the NumPy command `zeroes`. Matrices completely
    filled with zeros are generated by instantiating the corresponding type with the
    shape parameters as constructor parameters:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Sparse matrix methods
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are methods to convert one sparse type into another or into an array:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The type of a sparse matrix can be inspected by the methods `issparse` ,  `isspmatrix_lil`,
    `isspmatrix_csr`, and `isspmatrix_csc`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Elementwise operations `+`, `*`, `/`, and `**` on sparse matrices are defined
    as for NumPy arrays. Regardless of the sparse matrix format of the operands, the
    result is always a `csr_matrix`. Applying elementwise operating functions to sparse
    matrices requires first transforming them to either CSR or CSC format and applying
    the functions to their `data` attribute, as demonstrated by the next example.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The elementwise sine of a sparse matrix can be defined by an operation on its
    `data` attribute:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For matrix-matrix or matrix-vector multiplications, there is a sparse matrix
    method, `dot`. It returns either a `csr_matrix` or a 1D NumPy `array`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Tip
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid using NumPy's command `dot` on sparse matrices, as this might lead to
    unexpected results. Use the command `dot` from `scipy.sparse` instead.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在稀疏矩阵上使用 NumPy 的 `dot` 命令，因为这可能会导致意外结果。请使用 `scipy.sparse` 中的 `dot` 命令。
- en: Other linear algebra operations such as system solving, least squares, eigenvalues,
    and singular values are provided by the `scipy.sparse.linalg` module.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 其他线性代数操作，如系统求解、最小二乘法、特征值和奇异值，由 `scipy.sparse.linalg` 模块提供。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The concept of views is one of the important topics you should have learned
    from this chapter. Missing this topic will give you a hard time when debugging
    your code. Boolean arrays occur at various places throughout this book. They are
    handy and compact tools for avoiding lengthy `if` constructions and loops when
    working with arrays. In nearly all large computational projects, sparse matrices
    become an issue. You saw how these are handled and which related methods are available.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的概念是您应该从本章中学到的重点之一。错过这个主题，在调试代码时可能会给您带来困难。布尔数组在本书的各个地方都有出现。它们是处理数组时避免冗长的 `if`
    语句和循环的便捷且紧凑的工具。在几乎所有的大型计算项目中，稀疏矩阵都会成为一个问题。您已经看到了如何处理这些问题以及哪些相关方法可用。
