- en: Chapter 5. Advanced Array Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explain some more advanced aspects of arrays. First,
    we will cover the notion of an array view, followed by Boolean arrays and how
    to compare arrays. We briefly describe indexing and vectorization, explain sparse
    arrays, and some special topics such as broadcasting.
  prefs: []
  type: TYPE_NORMAL
- en: Array views and copies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to control precisely how memory is used, NumPy offers the concept of
    view of an array. Views are smaller arrays that share the same data as a larger
    array. This works just like a reference to one single object (refer to section
    *Basic Types* in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting
    Started*).
  prefs: []
  type: TYPE_NORMAL
- en: Array views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest example of a view is given by a slice of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding slice is a view of `M`. It shares the same data as `M`. Modifying
    `v` will modify `M` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to access the object that owns the data using the array attribute
    `base`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If an array owns its data, the attribute base is none :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Slices as views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are precise rules on which slices will return views and which ones will
    return copies. Only basic slices (mainly index expressions with `:`) return views,
    whereas any advanced selections (such as slicing with a Boolean) will return a
    copy of the data. For instance, it is possible to create new matrices by indexing
    with lists (or arrays):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the array `b` is not a view, whereas the array `c`,
    obtained with a simpler slice, is a view.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an especially simple slice of an array that returns a view of the
    whole array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Transpose and reshape as views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some other important operations return views. For instance, transpose returns
    a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies for all reshaping operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Array copy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it is necessary to explicitly request that the data be copied. This
    is simply achieved with the NumPy function called `array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We may verify that the data has indeed been copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Comparing arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing two arrays is not as simple as it may seem. Consider the following
    code, which is intended to check whether two matrices are close to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code raises the exception when the `if` statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we explain why this is so and how to remedy this state of affairs.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boolean arrays are useful for advanced array indexing (refer to section *Indexing
    with Boolean arrays*). A Boolean array is simply an array for which the entries
    have the type `bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Any comparison operator acting on arrays will create a Boolean array instead
    of a simple Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that because array comparison creates Boolean arrays, one cannot use array
    comparison directly in conditional statements, for example, `if` statements. the
    solution is to use the methods `all` and `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Checking for equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Checking for equality of two float arrays is not straight forward, because
    two floats may be very close without being equal. In NumPy, it is possible to
    check for equality with `allclose`. This function checks for equality of two arrays
    up to a given precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The tolerance is given in terms of a relative tolerance bound, `rtol`, and
    an absolute error bound, `atol`. The command `allclose` is a short form of: `(abs(A-B)
    < atol+rtol*abs(B)).all()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `allclose` can be also applied to scalars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Boolean operations on arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You cannot use `and`, `or`, and `not` on Boolean arrays. Indeed, those operators
    force the casting from array to Boolean, which is not permitted. Instead, we can
    use the operators given in the following table (*Table 5.1*) for componentwise
    logical operations on Boolean arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logic operator** | **Replacement for Boolean arrays** |'
  prefs: []
  type: TYPE_TB
- en: '| `A and B` | `A & B` |'
  prefs: []
  type: TYPE_TB
- en: '| `A or B` | `A &#124; B` |'
  prefs: []
  type: TYPE_TB
- en: '| `not A` | `~ A` |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 Logical operators and, or and not do not work with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example usage of logical operators with Boolean arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we have a sequence of data that is marred with some measurement
    error. Suppose further that we run a regression and it gives us a deviation for
    each value. We wish to obtain all the exceptional values and all the values with
    little deviation that are lower than a given threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Array indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that one may index arrays by combinations of slices and
    integers, this is the basic slicing technique. There are, however, many more possibilities,
    which allow for a variety of ways to access and modify array elements.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with Boolean arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is often useful to access and modify only parts of an array, depending on
    its value. For instance, one might want to access all the positive elements of
    an array. This turns out to be possible using Boolean arrays, which act like masks
    to select only some elements of an array. The result of such an indexing is *always*
    a vector. For instance, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the `M[B]` call is equivalent to `M.flatten()[B]`. One may then replace
    the resulting vector by another vector. For instance, one may replace all the
    elements by zero (refer to section *Broadcasting* for more information):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or one may replace all the selected values by others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By combining the creation of Boolean arrays (`M > 2`), smart indexing (indexing
    with Boolean array), and broadcasting, one may use the following elegant syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The expression broadcasting here refers to the tacit conversion of the scalar
    0 to a vector of an appropriate shape.
  prefs: []
  type: TYPE_NORMAL
- en: Using where
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command `where` gives a useful construct that can take a Boolean array as
    a condition and either return the indexes of the array elements satisfying the
    condition or return different values depending on the values in the Boolean array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will return values from `a` when the condition is `True` and values from
    `b` when it is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instances consider, a *Heaviside* function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using where](img/B05511_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code implements a Heaviside function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second and third arguments can be either arrays of the same size as the
    condition (the Boolean array) or scalars. We give two more example to demonstrated
    how to manipulate elements from an array or a scalar depending on a condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the second and third arguments are omitted, then a tuple containing the indexes
    of the elements satisfying the condition is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example consider the use of `where` with only one argument in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Performance and Vectorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to performance of your Python code, it often boils down to the
    difference between interpreted code and compiled code. Python is an interpreted
    programming language and basic Python code is executed directly without any intermediate
    compilation to machine code. With a compiled language, the code needs to be translated
    to machine instructions before execution.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of an interpreted language are many but interpreted code cannot
    compete with compiled code for speed. To make your code faster, you can write
    some parts in a compiled language like FORTRAN, C, or C++. This is what NumPy
    and SciPy do.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, it is best to use functions in NumPy and SciPy over interpreted
    versions whenever possible. NumPy array operations such as matrix multiplication,
    matrix-vector multiplication, matrix factorization, scalar products, and so on
    are much faster than any pure Python equivalent. Consider the simple case of scalar
    products. The scalar product is much slower than the compiled NumPy function, `dot(a,b)`
    (more than 100 times slower for arrays with about 100 elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Measuring the speed of your functions is an important aspect of scientific computing.
    Refer to section *Measuring execution time* in [Chapter 13](ch13.html "Chapter 13. Testing"),
    *Testing, * for details on measuring execution times.
  prefs: []
  type: TYPE_NORMAL
- en: Vectorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To improve performance, one has to vectorize the code often. Replacing `for`
    loops and other slower parts of the code with NumPy slicing, operations, and functions
    can give significant improvements. For example, the simple addition of a scalar
    to a vector by iterating over the elements is very slow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'where using NumPy''s addition is much faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using NumPy slicing can also give significant speed improvements over iterating
    with `for` loops. To demonstrate this let us consider forming the average of neighbors
    in a two-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These functions both assign each element the average of its four neighbors.
    The second version, using slicing, is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Besides replacing `for` loops and other slower constructions with NumPy functions,
    there is a useful function called `vectorize`, refer to section *Functions acting
    on arrays* in [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"), *Linear
    Algebra - Arrays*. This will take a function and create a vectorized version that
    applies the function on all elements of an array using functions wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example for vectorizing a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this by iterating over an array is very slow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use `vectorize` to create a new function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can then be applied to the array directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The vectorized option is much faster (around 10 times faster with arrays of
    length 100).
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Broadcasting in NumPy denotes the ability to guess a common, compatible shape
    between two arrays. For instance, when adding a vector (one-dimensional array)
    and a scalar (zero-dimensional array), the scalar is extended to a vector, in
    order to allow for the addition. The general mechanism is called broadcasting.
    We will first review that mechanism from a mathematical point of view, and then
    proceed to give the precise rules for broadcasting in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Broadcasting is often performed in mathematics, mainly implicitly. Examples
    are expressions such as *f(x) + C* or *f(x) + g(y)*. We'll give an explicit description
    of that technique in this section.
  prefs: []
  type: TYPE_NORMAL
- en: We have in mind the very close relationship between functions and NumPy arrays,
    as described in section *Mathematical preliminaries* of [Chapter 4](ch04.html
    "Chapter 4. Linear Algebra – Arrays"), *Linear Algebra - Arrays.*
  prefs: []
  type: TYPE_NORMAL
- en: Constant functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most common examples of broadcasting is the addition of a function
    and a constant; if *C* is a scalar, one often writes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constant functions](img/sinplusC.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an abuse of notation since one should not be able to add functions
    and constants. Constants are however implicitly broadcast to functions. The broadcast
    version of the constant *C* is the function ![Constant functions](img/B05511_05_06_Cbar.jpg)
    defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constant functions](img/cbar.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it makes sense to add two functions together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constant functions](img/sinplusCbar.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not being pedantic for the sake of it, but because a similar situation
    may arise for arrays, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, everything happens as if the scalar `1.` had been converted
    to an array of the same length as `vector`, that is, `array([1.,1.,1.,1.])`, and
    then added to `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: This example is exceedingly simple, so we proceed to show less obvious situations.
  prefs: []
  type: TYPE_NORMAL
- en: Functions of several variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A more intricate example of broadcasting arises when building functions of
    several variables. Suppose, for instance, that we were given two functions of
    one variable, *f* and *g*, and that we want to construct a new function *F* according
    to the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions of several variables](img/fplusg.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is clearly a valid mathematical definition. We would like to express this
    definition as the sum of two functions in two variables defined as
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions of several variables](img/fgoverline.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and now we may simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions of several variables](img/fplugoverline.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The situation is similar to that arising when adding a column matrix and a
    row matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is especially useful when sampling functions of two variables, as shown
    in section *Typical examples*.
  prefs: []
  type: TYPE_NORMAL
- en: General mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen how to add a function and a scalar and how to build a function
    of two variables from two functions of one variable. Let us now focus on the general
    mechanism that makes this possible. The general mechanism consists of two steps:
    reshaping and extending.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the function *g* is reshaped to a function ![General mechanism](img/gwidetilde.jpg) that
    takes two arguments. One of these arguments is a dummy argument, which we take
    to be zero, as a convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/gtilde-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Mathematically, the domain of definition of ![General mechanism](img/gwidetilde.jpg)
    is now ![General mechanism](img/domain.jpg)Then the function *f* is reshaped in
    a way similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/ftilde.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now both ![General mechanism](img/fwidetilde.jpg) and ![General mechanism](img/gwidetilde.jpg)
    take two arguments, although one of them is always zero. We proceed to the next
    step, extending. It is the same step that converted a constant into a constant
    function (refer to the constant function example).
  prefs: []
  type: TYPE_NORMAL
- en: 'The function ![General mechanism](img/fwidetilde.jpg) is extended to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/foverlinewide.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The function ![General mechanism](img/gwidetilde.jpg) is extended to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/goverlinewide.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the function of two variables *F*, which was sloppily defined by *F(x,y)
    = f(x) + g(y)*, may be defined without reference to its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/Fasfoverlinepluggoverline.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, let us describe the preceding mechanism for constants. A constant
    is a scalar, that is, a function of zero arguments. The reshaping step is thus
    to define the function of one (empty) variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/Cwidetilde.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the extension step proceeds simply by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![General mechanism](img/Cwideoverline.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last ingredient is the convention on how to add the extra arguments to a
    function, that is, how the reshaping is automatically performed. By convention,
    a function is automatically reshaped by adding zeros on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a function *g* of two arguments has to be reshaped to three
    arguments, the new function would be defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conventions](img/gthreearguments.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Broadcasting arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now repeat the observation that arrays are merely functions of several variables
    (refer to section *Mathematical preliminaries* in [Chapter 4](ch04.html "Chapter 4. Linear
    Algebra – Arrays"), *Linear Algebra - Arrays*). Array broadcasting thus follows
    exactly the same procedure as explained above for mathematical functions. Broadcasting
    is done automatically in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure (*Figure 5.1*), we show what happens when adding a
    matrix of shape (4, 3) to a matrix of size (1, 3). The second matrix is of the
    shape (4, 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broadcasting arrays](img/broadcastingMV.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Broadcasting between a matrix and a vector.'
  prefs: []
  type: TYPE_NORMAL
- en: The broadcasting problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When NumPy is given two arrays with different shapes, and is asked to perform
    an operation that would require the two shapes to be the same, both arrays are
    broadcast to a common shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the two arrays have shapes *s[1]* and *s[2]*. This broadcasting is
    performed in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the shape *s[1]* is shorter than the shape *s[2]* then ones are added on
    the left of the shape *s[1]*. This is a reshaping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the shapes have the same length, the array is extended to match the shape
    *s[2]* (if possible).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose we want to add a vector of shape (3, ) to a matrix of shape (4, 3).
    The vector needs be broadcast. The first operation is a reshaping; the shape of
    the vector is converted from (3, ) to (1, 3). The second operation is an extension;
    the shape is converted from (1, 3) to (4, 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose a vector of size *n* is to be broadcast to the shape
    (*m, n*):'
  prefs: []
  type: TYPE_NORMAL
- en: '*v* is automatically reshaped to (1, *n*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*v* is extended to (*m*, *n*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To demonstrate this we consider a matrix defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'and vector given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we may add `M` and `v` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The broadcasting problem](img/B05511_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shape mismatch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is not possible to automatically broadcast a vector `v` of length `n` to
    the shape `(n,m)`. This is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape mismatch](img/broadcastingwrong.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The broadcasting will fail, because the shape `(n,)` may not be automatically
    broadcast to the shape `(m, n)`. The solution is to manually reshape `v` to the
    shape `(n,1)`. The broadcasting will now work as usual (by extension only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example, define a matrix  by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and a vector by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now automatic broadcasting will fail, because automatic reshaping does not
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is thus to take care of the reshaping manually. What we want in
    that case is to add 1 on the right, that is, transform the vector into a column
    matrix. The broadcasting then works directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For the shape parameter -1, refer to section *Accessing and changing the shape*
    of [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"), *Linear Algebra
     - Arrays.* The result is this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape mismatch](img/B05511_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Typical examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us examine some typical examples where broadcasting may come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Rescale rows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose `M` is an *n* × *m* matrix, and we want to multiply each row by a coefficient.
    The coefficients are stored in a vector `coeff` with *n* components. In that case,
    automatic reshaping will not work, and we have to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Rescale columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The setup is the same here, but we would like to rescale each column with a
    coefficient stored in a vector `coeff` of length *m*. In this case, automatic
    reshaping will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we may also do the reshaping manually and achieve the same result
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Functions of two variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose *u* and *v* are vectors and we want to form the matrix *W* with elements
    *w[ij] = u[i] + v[j]*. This would correspond to the function *F(x, y) = x + y*.
    The matrix *W* is merely defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If the vectors *u* and *v* are [0, 1] and [0, 1, 2] respectively, the result
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functions of two variables](img/B05511_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'More generally, suppose that we want to sample the function *w*(*x, y*) *:=*
    cos(*x*) *+* sin(2*y*). Supposing that the vectors *x* and *y* are defined, the
    matrix *w* of sampled values is obtained by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is very frequently used in combination with `ogrid`. The vectors
    obtained from `ogrid` are already conveniently shaped for broadcasting. This allows
    for the following elegant sampling of the function cos(*x*) *+* sin(2*y*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The syntax of `ogrid` needs some explanation. First, `ogrid` is no function.
    It is an instance of a class with a `__getitem__` method (refer to section *Attributes*
    in [Chapter 8](ch08.html "Chapter 8. Classes"), *Classes*). That is why it is
    used with brackets instead of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two commands are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The stride parameter in the preceding example is a complex number. This is
    to indicate that it is the number of steps instead of the step size. The rules
    for the stride parameter might be confusing at first glance:'
  prefs: []
  type: TYPE_NORMAL
- en: If the stride is a real number, then it defines the size of the steps between
    start and stop and stop is not included in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the stride is a complex number `s`, then the integer part of `s.imag` defines
    the number of steps between start and stop and stop is included in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another example for the output of `ogrid` is a tuple with two arrays, which
    can be used for broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'which is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Sparse matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matrices with a small number of nonzero entries are called **sparse matrices**.
    Sparse matrices occur, for example, in scientific computing when describing discrete
    differential operators in the context of numerically solving partial differential
    equations.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse matrices often have large dimensions, sometimes so large that the entire
    matrix (with zero entries) would not even fit in the available memory. This is
    one motivation for a special type for sparse matrices. Another motivation is better performance
    of operations where zero matrix entries can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: There are only a very limited number of algorithms for general, unstructured
    sparse matrices in linear algebra. Most of them are iterative in nature and based
    on efficient implementations of matrix-vector multiplication for sparse matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Examples for sparse matrices are diagonal or banded matrices. The simple pattern
    of these matrices allows straightforward storing strategies; the principal diagonal
    and the sub- and super-diagonals are stored in 1D arrays. Conversion from a sparse
    representation to the classical array type and vice-versa can be done by the command
    `diag`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, there is not such a simple structure and the description of sparse
    matrices requires special techniques and standards. Here we present a row and
    a column oriented type for sparse matrices, both available through the module
    `scipy.sparse` .
  prefs: []
  type: TYPE_NORMAL
- en: '![Sparse matrices](img/sparse.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: A stiffness matrix from a finite element model of an elastic plate.
    The pixels denote nonzero entries in the 1250 × 1250 matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Sparse matrix formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `scipy.sparse` module provides many different storing formats from sparse
    matrices. We describe here only the most important ones: CSR, CSC, and LIL. The
    LIL format should be used for generating and altering sparse matrices; CSR and
    CSC are efficient formats for matrix-matrix and matrix-vector operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Compressed sparse row
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The compressed sparse row format (CSR) uses three arrays: `data`, `indptr`,
    and `indices`:'
  prefs: []
  type: TYPE_NORMAL
- en: The 1D array `data` stores all the nonzero values in order. It has as many elements
    as there are nonzero elements, often denoted by the variable `nnz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1D array `indptr` contains integers such that `indptr[i]` is the index of
    the element in `data`, which is the first nonzero element of row *i*. If the entire
    row *i* is zero, then `indptr[i]==indptr[i+1]`. If the original matrix has *m*
    rows, then `len(indptr)==m+1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1D array `indices` contains the column index information in such a way that
    `indices[indptr[i]:indptr[i+1]]` is an integer array with the column indexes of
    the nonzero elements in row *i*. Obviously, `len(indices)==len(data)==nnz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see an example: The CSR format of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compressed sparse row](img/B05511_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'is given by the three arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The module `scipy.sparse` provides a type, `csr_matrix`, with a constructor,
    which can be used in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: With a 2D array as argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a matrix in one of the other sparse formats in `scipy.sparse`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a shape argument, `(m,n)`, to generate a zero matrix in CSR format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By a 1D array for the `data` and an integer array `ij` with the shape `(2,len(data))`
    such that `ij[0,k]` is the row index and `ij[1,k]` is the column index of `data[k]`
    of the matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three arguments, `data`, `indptr`, and `indices`, can be given to the constructor
    directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two options are there for conversion purposes while the last two directly
    define the sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the above example in python look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Among others, the following attributes are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Compressed Sparse Column
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CSR format has a column oriented twin - the compressed sparse column (CSC)
    format. The only difference in it compared to the CSR format is the definition
    of the `indptr` and `indices` arrays, which are now column-related. The type for
    the CSC format is `csc_matrix` and its use corresponds to `csr_matrix`, explained
    previously in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the same example in CSC format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Row-based linked list format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The linked list sparse format stores the nonzero matrix entries rowwise in a
    list `data` such that `data[k]` is a list of the nonzero entries in row *k*. If
    all entries in that row are 0, it contains an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second list, `rows`, contains at position *k* a list of column indexes of
    the nonzero elements in row *k*.  Here is an example in **Row-Based linked List
    Format (LIL)** format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Altering and slicing matrices in LIL format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The LIL format is the one best suited for slicing, that is, extracting submatrices
    in LIL format, and for changing the sparsity pattern by inserting nonzero elements.
    Slicing is demonstrated by the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Insertion of a new nonzero element automatically updates the attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: These operations are discouraged in the other sparse matrix formats as they
    are extremely inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Generating sparse matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NumPy commands `eye`, `identity`, `diag`, and `rand` have their sparse counterparts.
    They take an additional argument; it specifies the sparse matrix format of the
    resulting matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands generate the identity matrix but in different sparse
    matrix formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sp.rand` command takes an additional argument describing the density of
    the generated random matrix. A dense matrix has density 1 while a zero matrix
    has density 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no direct correspondence to the NumPy command `zeroes`. Matrices completely
    filled with zeros are generated by instantiating the corresponding type with the
    shape parameters as constructor parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Sparse matrix methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are methods to convert one sparse type into another or into an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The type of a sparse matrix can be inspected by the methods `issparse` ,  `isspmatrix_lil`,
    `isspmatrix_csr`, and `isspmatrix_csc`.
  prefs: []
  type: TYPE_NORMAL
- en: Elementwise operations `+`, `*`, `/`, and `**` on sparse matrices are defined
    as for NumPy arrays. Regardless of the sparse matrix format of the operands, the
    result is always a `csr_matrix`. Applying elementwise operating functions to sparse
    matrices requires first transforming them to either CSR or CSC format and applying
    the functions to their `data` attribute, as demonstrated by the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The elementwise sine of a sparse matrix can be defined by an operation on its
    `data` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'For matrix-matrix or matrix-vector multiplications, there is a sparse matrix
    method, `dot`. It returns either a `csr_matrix` or a 1D NumPy `array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid using NumPy's command `dot` on sparse matrices, as this might lead to
    unexpected results. Use the command `dot` from `scipy.sparse` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Other linear algebra operations such as system solving, least squares, eigenvalues,
    and singular values are provided by the `scipy.sparse.linalg` module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of views is one of the important topics you should have learned
    from this chapter. Missing this topic will give you a hard time when debugging
    your code. Boolean arrays occur at various places throughout this book. They are
    handy and compact tools for avoiding lengthy `if` constructions and loops when
    working with arrays. In nearly all large computational projects, sparse matrices
    become an issue. You saw how these are handled and which related methods are available.
  prefs: []
  type: TYPE_NORMAL
