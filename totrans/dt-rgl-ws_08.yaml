- en: 8\. RDBMS and SQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. RDBMS和SQL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will introduce you to the basics of using an RDBMS to query a database
    using Python and convert data from SQL and then store it in a `pandas` DataFrame.
    It will explain the concepts of databases, including their creation, manipulation,
    and control, and how to transform tables into `pandas` DataFrames. By the end
    of this chapter, you will learn some basic SQL commands. This knowledge will make
    you adept at adding, updating, retrieving, and deleting data from databases; another
    valuable skill in a budding data wrangling expert's repertoire.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍使用Python查询数据库、将数据从SQL转换为然后存储在`pandas` DataFrame中的RDBMS基础知识。它将解释数据库的概念，包括它们的创建、操作和控制，以及如何将表转换为`pandas`
    DataFrame。到本章结束时，您将学习一些基本的SQL命令。这些知识将使您能够熟练地添加、更新、检索和从数据库中删除数据；这对于成长中的数据整理专家来说是另一种宝贵的技能。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter of our data journey is focused on **Relational Database Management
    System** (**RDBMS**) and **Structured Query Language** (**SQL**). In the previous
    chapter, we stored and read data from a file. In this chapter, we will read structured
    data, design access to the data, and create query interfaces for databases.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据之旅的这一章专注于**关系型数据库管理系统（RDBMS**）和**结构化查询语言（SQL**）。在前一章中，我们存储并从文件中读取数据。在本章中，我们将读取结构化数据，设计对数据的访问，并为数据库创建查询接口。
- en: For years, the RDBMS format has been the conventional way to store data. An
    RDBMS is one of the safest ways to store, manage, and retrieve data. It is backed
    by a solid mathematical foundation (relational algebra and calculus) and exposes
    an efficient and intuitive declarative language – SQL – for easy interaction.
    Almost every language has a rich set of libraries to interact with different RDBMS,
    and the tricks and methods of using them are well tested and well understood.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，RDBMS格式一直是存储数据的传统方式。RDBMS是存储、管理和检索数据最安全的方式之一。它有一个坚实的数学基础（关系代数和关系演算），并暴露了一个高效直观的声明性语言——SQL，以便轻松交互。几乎每种语言都有丰富的库来与不同的RDBMS交互，使用它们的技巧和方法已经过充分测试和了解。
- en: Scaling an RDBMS is a pretty well-understood task, and there is a group of well
    trained, experienced professionals to do this job (DBAs, or database administrators).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展关系型数据库管理系统（RDBMS）是一个相当熟悉的任务，有一群受过良好训练、经验丰富的专业人士（数据库管理员，简称DBA）来执行这项工作。
- en: So, it is understandable that we, as data wrangling professionals or data engineers,
    will encounter RDBMS at some point. We will need the tools and knowledge acquired
    from this chapter to deal with RDBMS.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们作为数据整理专业人员或数据工程师，在某个时候遇到RDBMS是完全可以理解的。我们将需要从本章获得工具和知识来处理RDBMS。
- en: 'As we can see in the following chart, the database management system market
    is big. This chart was produced based on market research that was done by Scalegrid
    in 2019:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在以下图表中可以看到的，数据库管理系统市场很大。这个图表是基于Scalegrid在2019年进行的市场研究制作的：
- en: '![Figure 8.1: Commercial database market share released by ScaleGrid in 2019'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：ScaleGrid在2019年发布的商业数据库市场份额]'
- en: '](img/B15780_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_08_01.jpg]'
- en: 'Figure 8.1: Commercial database market share released by ScaleGrid in 2019'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：ScaleGrid在2019年发布的商业数据库市场份额
- en: We will learn and play around with some of the basic and fundamental concepts
    of database and relational database management systems in this chapter. We will
    start with a refresher of the theoretical concept of a database, and then we will
    create and operate a database from our Python environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习和探索数据库和关系型数据库管理系统的一些基本和基本概念。我们将从数据库的理论概念复习开始，然后将在我们的Python环境中创建和操作数据库。
- en: Refresher of RDBMS and SQL
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RDBMS和SQL的复习
- en: An RDBMS is a piece of software that manages data (represented for the end user
    in tabular form) on physical hard disks and is built using Codd's relational model.
    Most of the databases that we encounter today are RDBMS. In recent years, there
    has been a huge industry shift toward a newer kind of database management system,
    called NoSQL (MongoDB, CouchDB, Riak, and so on). These systems, while they do
    follow some of the rules of RDBMS in certain aspects, in most cases they reject
    or modify them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS是一种管理数据（以表格形式表示给最终用户）的软件，它使用Codd的关系模型构建，并存储在物理硬盘上。我们今天遇到的大多数数据库都是RDBMS。近年来，整个行业向一种新型的数据库管理系统转变，称为NoSQL（MongoDB、CouchDB、Riak等）。这些系统虽然在某些方面遵循RDBMS的一些规则，但在大多数情况下，它们拒绝或修改了这些规则。
- en: How Is an RDBMS Structured?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RDBMS是如何结构的？
- en: 'The RDBMS structure consists of three main elements, namely the storage engine,
    the query engine, and log management. Here is a diagram that demonstrates the
    structure of an RDBMS:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS 结构由三个主要元素组成，即存储引擎、查询引擎和日志管理。以下是一个演示 RDBMS 结构的图表：
- en: '![Figure 8.2: RDBMS structure'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2：RDBMS 结构'
- en: '](img/B15780_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2：RDBMS 结构](img/B15780_08_02.jpg)'
- en: 'Figure 8.2: RDBMS structure'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：RDBMS 结构
- en: 'The following are the main concepts of any RDBMS structure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 RDBMS 结构的主要概念：
- en: '**Storage engine:** This is the part of the RDBMS that is responsible for storing
    data in an efficient way and also retrieving it, when asked for, in an efficient
    way. As an end user of the RDBMS system (an application developer is considered
    an end user of an RDBMS), we will never need to interact with this layer directly.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储引擎**：这是 RDBMS 的部分，负责以高效的方式存储数据，并在需要时以高效的方式检索数据。作为 RDBMS 系统的最终用户（应用程序开发人员被视为
    RDBMS 的最终用户），我们永远不会需要直接与这一层交互。'
- en: '**Query engine:** This is the part of the RDBMS that allows us to create data
    objects (tables, views, and so on), manipulate them (create and delete columns,
    create/delete/update rows, and so on), and query them (read rows) using a simple,
    yet powerful, language.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询引擎**：这是关系型数据库管理系统（RDBMS）的一部分，它允许我们创建数据对象（表、视图等），操作它们（创建和删除列，创建/删除/更新行等），并使用简单而强大的语言查询它们（读取行）。'
- en: '**Log management:** This part of the RDBMS is responsible for creating and
    maintaining the logs. If you are wondering why the log is such an important thing,
    then you should look into how replication and partitions are handled in a modern
    RDBMS (such as PostgreSQL) using something called the **Write Ahead Log** (or
    **WAL** for short).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志管理**：这是 RDBMS 的部分，负责创建和维护日志。如果你想知道为什么日志如此重要，那么你应该了解一下现代 RDBMS（如 PostgreSQL）如何使用所谓的**写入前日志**（或简称
    **WAL**）来处理复制和分区。'
- en: We will focus on the query engine in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中关注查询引擎。
- en: SQL
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL
- en: '**SQL** (pronounced *sequel*), as it is commonly known, is a domain-specific
    language that was originally designed based on E.F. Codd''s relational model and
    is widely used in today''s databases to define, insert, manipulate, and retrieve
    data from them. It can be further sub-divided into four smaller sub-languages,
    namely **Data Definition Language** (**DDL**), **Data Manipulation Language**
    (**DML**), **Data Query Language** (**DQL**), and **Data Control Language** (**DCL**).
    There are several advantages of using SQL, some of which are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQL**（发音为 *sequel*），正如其通常所知，是一种基于 E.F. Codd 的关系模型最初设计的特定领域语言，在今天的数据库中广泛用于定义、插入、操作和从数据库中检索数据。它可以进一步细分为四个较小的子语言，即**数据定义语言**（**DDL**）、**数据操作语言**（**DML**）、**数据查询语言**（**DQL**）和**数据控制语言**（**DCL**）。使用
    SQL 有几个优点，以下是一些：'
- en: It is based on a solid mathematical framework and thus it is easy to understand.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它基于一个坚实的数学框架，因此易于理解。
- en: It is a declarative language, which means that we actually never tell it how
    to do its job. We almost always tell it what to do. This frees us from the big
    burden of writing custom code for data management. We can be more focused on the
    actual query problem we are trying to solve, instead of bothering about how to
    create and maintain a data store.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一种声明性语言，这意味着我们实际上从未告诉它如何完成其工作。我们几乎总是告诉它要做什么。这使我们免去了编写数据管理自定义代码的大负担。我们可以更专注于我们试图解决的查询问题，而不是烦恼于如何创建和维护数据存储。
- en: It gives you a fast and readable way to deal with data.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了快速且易于阅读的方式来处理数据。
- en: SQL gives you out-of-the-box ways to get multiple pieces of data with a single
    query.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL 提供了通过单个查询获取多个数据片段的现成方法。
- en: 'The main areas of focus for the following topic will be DDL, DML, and DQL.
    The DCL part is more for database administrators. Let''s discuss them briefly:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题的主要关注领域将是 DDL、DML 和 DQL。DCL 部分更多是针对数据库管理员的。让我们简要讨论一下：
- en: '`CREATE TABLE`, `DROP TABLE`, and `ALTER TABLE`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`、`DROP TABLE` 和 `ALTER TABLE`。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the use of uppercase letters. This is not a requirement, and you may
    use lowercase letters, but it is a widely followed convention, and we will use
    it in this book.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意大写字母的使用。这并不是一个要求，你可以使用小写字母，但这是一个广泛遵循的约定，我们将在本书中使用它。
- en: '`INSERT INTO`, `DELETE FROM`, or `UPDATE`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT INTO`、`DELETE FROM` 或 `UPDATE`。'
- en: '`SELECT` command. We will also see and use the concepts of the primary key,
    foreign key, index, joins, and so on.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT` 命令。我们还将看到并使用主键、外键、索引、连接等概念。'
- en: 'Once you define and insert data in a database, it can be represented as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在数据库中定义并插入数据，它可以表示如下：
- en: '![Figure 8.3: Table displaying sample data'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：显示样本数据的表]'
- en: '](img/B15780_08_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_08_03.jpg]'
- en: 'Figure 8.3: Table displaying sample data'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：显示样本数据的表]'
- en: Another thing to remember about an RDBMS is relations. Generally, in a table,
    we have one or more columns that will have unique values for each row in the table.
    We call them **primary keys** for the table. We should be aware that we will encounter
    unique values across the rows, which are not primary keys. The main difference
    between them and primary keys is the fact that a primary key cannot be null.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于RDBMS的另一件事要记住的是关系。通常，在一个表中，我们有一列或多列，这些列将为表中的每一行提供唯一的值。我们称它们为表的**主键**。我们应该意识到，我们将在行之间遇到唯一的值，这些值不是主键。它们与主键之间的主要区别是主键不能为空。
- en: By using the primary key of one table and mentioning it as a foreign key in
    another table, we can establish relations between two tables. A certain table
    can be related to any finite number of tables.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个表的主键并将其作为另一个表的外键提及，我们可以在两个表之间建立关系。某个表可以与任何有限数量的表相关联。
- en: 'The relations can be `1:1`, which means that each row of the second table is
    uniquely related to one row of the first table, or `1:N`, `N:1`, or `N: M`. An
    example of relations is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关系可以是`1:1`，这意味着第二个表中的每一行都与第一个表中的一行唯一相关联，或者是`1:N`、`N:1`或`N:M`。以下是一个关系的示例：
- en: '![Figure 8.4: Diagram showing relations'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：显示关系的图]'
- en: '](img/B15780_08_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_08_04.jpg]'
- en: 'Figure 8.4: Diagram showing relations'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：显示关系的图]'
- en: With this brief refresher, we are now ready to jump into hands-on exercises
    and write some SQL to store and retrieve data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简短的复习，我们现在可以开始动手练习，并编写一些SQL来存储和检索数据。
- en: Using an RDBMS (MySQL/PostgreSQL/SQLite)
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RDBMS（MySQL/PostgreSQL/SQLite）
- en: In this topic, we will focus on how to write some basic SQL commands, as well
    as how to connect to a database from Python and use it effectively within Python.
    The database we will choose here is SQLite. There are other databases, such as
    Oracle, MySQL, PostgreSQL, and DB2\. The main tricks that you are going to learn
    here will not change depending on the database you are using. However, for different
    databases, you will need to install different third-party Python libraries (such
    as Psycopg2 for PostgreSQL). The reason they all behave the same way (apart for
    some small details) is the fact that they all adhere to PEP249 (commonly known
    as Python DB API 2).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将关注如何编写一些基本的SQL命令，以及如何从Python连接到数据库并在Python中有效地使用它。我们将选择SQLite作为数据库。还有其他数据库，如Oracle、MySQL、PostgreSQL和DB2。你将要学习的主要技巧不会因你使用的数据库而改变。然而，对于不同的数据库，你需要安装不同的第三方Python库（例如，对于PostgreSQL，需要安装Psycopg2）。它们之所以都以相同的方式（除了某些小细节外）运行，是因为它们都遵循PEP249（通常称为Python
    DB API 2）。
- en: This is a good standardization and saves us a lot of headaches while porting
    from one RDBMS to another. If you already have some experience with databases,
    then you will notice that we will not be using any server address, username, password,
    or other credentials to connect to a database. This is because these fields are
    not mandatory in sqlite3, unlike in PostgreSQL or MySQL. The main database engine
    of SQLite is embedded.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个良好的标准化，在从一种关系型数据库管理系统（RDBMS）迁移到另一种时，可以节省我们很多麻烦。如果你已经对数据库有一些经验，那么你会注意到我们不会使用任何服务器地址、用户名、密码或其他凭证来连接到数据库。这是因为这些字段在sqlite3中不是必需的，与PostgreSQL或MySQL不同。SQLite的主要数据库引擎是嵌入式的。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the industry-standard projects that are written in Python and use some
    kind of RDBMS as the data store most often rely on an **Object Relational Mapper**
    (**ORM**). An ORM is a high-level library in Python that makes many tasks easier
    when dealing with an RDBMS. It also exposes a more Pythonic API than writing raw
    SQL inside Python code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用Python编写并使用某种RDBMS作为数据存储的行业标准项目通常依赖于一个**对象关系映射器**（**ORM**）。ORM是Python中的一个高级库，在处理RDBMS时使许多任务变得简单。它还提供了一个比在Python代码中编写原始SQL更Pythonic的API。
- en: 'Exercise 8.01: Connecting to a Database in SQLite'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：在SQLite中连接到数据库
- en: 'In this exercise, we will look into the first step toward using an RDBMS in
    Python code. We are going to connect to a database, `lesson.db`. We will then
    close the connection safely. Let''s perform the following steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探讨在Python代码中使用RDBMS的第一步。我们将连接到数据库`lesson.db`。然后我们将安全地关闭连接。让我们执行以下步骤：
- en: 'Import the `sqlite3` library from Python by using the following command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从 Python 导入 `sqlite3` 库：
- en: '[PRE0]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the `connect` function to connect to a database:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `connect` 函数连接到数据库：
- en: '[PRE1]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Close the connection, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式关闭连接：
- en: '[PRE2]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `conn` object is the main connection object, and we will need it to get
    a second type of object in the future once we want to interact with the database.
    We need to be careful about closing any open connection to our database.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此 `conn` 对象是主要连接对象，一旦我们想要与数据库交互，我们将需要它来获取第二种类型的对象。我们需要小心关闭对数据库的任何打开连接。
- en: 'Use the same `with` statement from Python, just like we did for files, and
    connect to the database, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与文件相同的 `with` 语句，连接到数据库，如下所示：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this exercise, we have connected to a database using Python.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用 Python 连接到一个数据库。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YMWrBD](https://packt.live/2YMWrBD).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2YMWrBD](https://packt.live/2YMWrBD)。
- en: You can also run this example online at [https://packt.live/3df6q87](https://packt.live/3df6q87).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/3df6q87](https://packt.live/3df6q87) 上运行此示例。
- en: In the next exercise, we will see the best way to create a table and put data
    into it using Python.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将看到使用 Python 创建表并将数据放入表中的最佳方式。
- en: DDL and DML Commands in SQLite
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite 中的 DDL 和 DML 命令
- en: To create a table in SQL, use the `CREATE TABLE` SQL clause. This will require
    the table name and the table definition. The table name is a unique identifier
    for the database engine to find and use the table for all future transactions.
    It can be anything (any alphanumeric string), as long as it is unique. We add
    the table definition in the form of (`column_name_1 data_type`, `column_name_2
    data type`, `…` ). For our purpose, we will use the text and integer data types,
    but usually, a standard database engine supports many more data types, such as
    float, double, date time, and Boolean. We will also need to specify a primary
    key. A primary key is a unique, non-null identifier that's used to uniquely identify
    a row in a table. In our case, we use email as a primary key. A primary key can
    be an integer or text.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中创建一个表，使用 `CREATE TABLE` SQL 子句。这需要表名和表定义。表名是数据库引擎用来查找和使用表以进行所有未来事务的唯一标识符。它可以是一切（任何字母数字字符串），只要它是唯一的。我们以
    (`column_name_1 data_type`, `column_name_2 data type`, `…` ) 的形式添加表定义。为了我们的目的，我们将使用文本和整数数据类型，但通常，标准数据库引擎支持更多的数据类型，例如浮点数、双精度浮点数、日期时间型和布尔型。我们还需要指定一个主键。主键是一个唯一、非空的标识符，用于在表中唯一标识一行。在我们的例子中，我们使用电子邮件作为主键。主键可以是整数或文本。
- en: The last thing you need to know is that unless you call a commit on the series
    of operations you just performed (together, we formally call them a transaction),
    nothing will actually be performed and reflected in the database. This property
    is called atomicity. In fact, for a database to be industry-standard (to be useable
    in real life), it needs to follow the **Atomicity, Consistency, Isolation, Durability**
    (**ACID**) properties.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道的是，除非你对你刚刚执行的一系列操作（我们正式称之为事务）调用提交，否则实际上什么都不会执行并在数据库中反映出来。这个特性被称为原子性。实际上，为了使数据库成为行业标准（在现实生活中可用），它需要遵循
    **原子性、一致性、隔离性、持久性**（**ACID**）特性。
- en: As the name suggests, **Data Definition Language** (**DDL**) is the way to communicate
    with the database engine in advance to define what the data will look like. The
    database engine creates a table object based on the definition provided and prepares
    it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**数据定义语言**（**DDL**）是提前与数据库引擎通信以定义数据将如何呈现的方式。数据库引擎根据提供的定义创建一个表对象，并对其进行准备。
- en: 'Exercise 8.02: Using DDL and DML Commands in SQLite'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.02：在 SQLite 中使用 DDL 和 DML 命令
- en: 'In this exercise, we will connect with the `lesson.db` database and then create
    a `user` table. Then, we will insert data into the table using the DDL and DML
    commands. Let''s perform the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将连接到 `lesson.db` 数据库，然后创建一个 `user` 表。然后，我们将使用 DDL 和 DML 命令将数据插入到表中。让我们执行以下步骤：
- en: 'Use SQLite''s `connect` function to connect to the `lesson.db` database. Create
    a `cursor` object by calling `conn.cursor()`. The `cursor` object acts as a medium
    by which to communicate with the database:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SQLite 的 `connect` 函数连接到 `lesson.db` 数据库。通过调用 `conn.cursor()` 创建一个 `cursor`
    对象。`cursor` 对象充当与数据库通信的中介：
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a table in Python, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式在 Python 中创建一个表：
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Insert rows into the database that you created, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行插入你创建的数据库中，如下所示：
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Commit to the database:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交到数据库：
- en: '[PRE7]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will create the table and write two rows to it with data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建表并将两行数据写入其中。
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YeniaH](https://packt.live/2YeniaH).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅[https://packt.live/2YeniaH](https://packt.live/2YeniaH)。
- en: You can also run this example online at [https://packt.live/2BogE8J](https://packt.live/2BogE8J).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2BogE8J](https://packt.live/2BogE8J)上运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook才能得到期望的结果。
- en: In the next section, we will read back the data that we just stored.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将读取我们刚刚存储的数据。
- en: Reading Data from a Database in SQLite
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在SQLite中从数据库读取数据
- en: In the preceding exercise, we created a table and stored data in it. Now, we
    will learn how to read the data that's stored in this database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，我们创建了一个表格并将数据存储在其中。现在，我们将学习如何读取存储在这个数据库中的数据。
- en: The `SELECT` clause is immensely powerful, and it is really important for a
    data practitioner to master `SELECT` and everything related to it (such as conditions,
    joins, and group-by).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`子句非常强大，对于数据从业者来说，掌握`SELECT`及其相关内容（如条件、连接和分组）非常重要。'
- en: The `*` after `SELECT` tells the engine to select all of the columns from the
    table. This is a useful shorthand. We have not mentioned any condition for the
    selection (such as above a certain age, first name starting with a certain sequence
    of letters, and so on). We are practically telling the database engine to select
    all the rows and all the columns from the table. It is time-consuming and less
    effective if we have a huge table. Hence, we would want to use the `LIMIT` clause
    to limit the number of rows we want.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`后面的`*`告诉引擎从表中选取所有列。这是一个有用的缩写。我们没有提到任何选择条件（例如年龄超过某个值，名字以某个字母序列开头等）。如果我们有一个非常大的表，这样做既耗时又效率低下。因此，我们希望使用`LIMIT`子句来限制我们想要的行数。'
- en: 'You can use the `SELECT` clause in SQL to retrieve data, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用SQL中的`SELECT`子句检索数据，如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The syntax to use the `SELECT` clause with `LIMIT` is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LIMIT`与`SELECT`子句的语法如下：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This syntax is sample code and will not work on Jupyter Notebooks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法是示例代码，在Jupyter Notebooks上不会工作。
- en: This will select all the columns, but only the first `50` rows from the table.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择所有列，但只从表中选取前`50`行。
- en: Now that we have seen how to connect, write, and read basic data to a database,
    we will be venturing into more advanced operations in the coming exercises, with
    the sorting of data being the next one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何连接、写入和读取基本数据到数据库，在接下来的练习中，我们将探索更高级的操作，其中数据的排序将是下一个要学习的。
- en: 'Exercise 8.03: Sorting Values That Are Present in the Database'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.03：排序数据库中存在的值
- en: 'In this exercise, we will use the `ORDER BY` clause to sort the rows of the
    `user` table with respect to the `age` column in both descending and ascending
    order. Let''s perform the following steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`ORDER BY`子句按`age`列的降序和升序对`user`表的行进行排序。让我们执行以下步骤：
- en: 'Connect to the `lesson.db` database and sort `lesson.db` by age in descending
    order, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到`lesson.db`数据库，并按年龄降序排序，如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Sort the `lesson.db` database by age in ascending order, as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按年龄升序排序`lesson.db`数据库，如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we don't need to specify the order as `ASC` in order to sort it
    in ascending order.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要指定`ASC`来按升序排序。
- en: In this exercise, we have seen how to sort data. Sorting is one of the most
    important operations you will often need to do.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何排序数据。排序是你经常需要执行的最重要操作之一。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/37I7Iap](https://packt.live/37I7Iap).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅[https://packt.live/37I7Iap](https://packt.live/37I7Iap)。
- en: You can also run this example online at [https://packt.live/2YOu4D5](https://packt.live/2YOu4D5).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2YOu4D5](https://packt.live/2YOu4D5)上运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行整个Notebook才能得到期望的结果。
- en: In the coming exercise, we will see how to update the structure of an already
    defined table.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将看到如何更新已定义表的架构。
- en: The ALTER Command
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ALTER命令
- en: '`ALTER` is a command that is used by a RDBMS to add a new column to an already
    existing table, or to change the data type of a column, whereas the `UPDATE` command
    is used to update the value of one or more columns in one or several rows of a
    database. We will examine them in the following section to check out their use.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER`是RDBMS用来向已存在的表中添加新列或更改列的数据类型的命令，而`UPDATE`命令用来更新数据库中一行或多行的一个或多个列的值。我们将在下一节中检查它们的使用。'
- en: 'Exercise 8.04: Altering the Structure of a Table and Updating the New Fields'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.04：修改表结构并更新新字段
- en: 'In this exercise, we are going to add a column, `gender`, using the `ALTER`
    command in the `user` table. Then, by using the `UPDATE` command, we will set
    the value of the `gender` column. Let''s perform the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`ALTER`命令在`user`表中添加一个列`gender`。然后，通过使用`UPDATE`命令，我们将设置`gender`列的值。让我们按照以下步骤进行操作：
- en: 'Establish a connection with the database by using the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令与数据库建立连接：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add another column in the `user` table and fill it with null values by using
    the following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在`user`表中添加另一列并填充null值：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update all of the values of gender so that they are `M` by using the following
    command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令更新所有性别值，使它们为`M`：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To check the altered table, execute the following command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查修改后的表，请执行以下命令：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have to be cautious when using `UPDATE`, because using `UPDATE` without selective
    clauses (such as `WHERE`) affects the entire table.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`UPDATE`时必须谨慎，因为没有选择性子句（如`WHERE`）的`UPDATE`会影响整个表。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/312BtBL](https://packt.live/312BtBL).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/312BtBL](https://packt.live/312BtBL)。
- en: You can also run this example online at [https://packt.live/3ddIYbh](https://packt.live/3ddIYbh).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3ddIYbh](https://packt.live/3ddIYbh)在线运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须执行整个笔记本才能获得期望的结果。
- en: The GROUP BY clause
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`GROUP BY`子句'
- en: 'We will learn about a concept that we have already learned about in pandas.
    This is called the `GROUP BY` clause. The `GROUP BY` clause is a technique that''s
    used to retrieve distinct values from the database and place them in individual
    buckets. The following diagram explains how the `GROUP BY` clause works:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习一个我们已经学习过的概念。这被称为`GROUP BY`子句。`GROUP BY`子句是一种用于从数据库中检索不同值并将它们放入单独桶中的技术。以下图表解释了`GROUP
    BY`子句是如何工作的：
- en: '![Figure 8.5: Illustration of the GROUP BY clause on a table'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5：GROUP BY子句在表上的说明'
- en: '](img/B15780_08_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_08_05.jpg](img/B15780_08_05.jpg)'
- en: 'Figure 8.5: Illustration of the GROUP BY clause on a table'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：GROUP BY子句在表上的说明
- en: 'In the preceding diagram, we can see that the `col3` column has only two unique
    values across all rows, `A` and `B`. The command that''s used to check the total
    number of rows belonging to each group is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到`col3`列在所有行中只有两个唯一的值，`A`和`B`。用于检查每个组所属行总数的命令如下：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's go through the following exercise to practice the `GroupBy` clause.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下练习来练习`GroupBy`子句。
- en: 'Exercise 8.05: Grouping Values in Tables'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.05：在表中分组值
- en: 'In this exercise, we will use the `GROUP BY` clause to select the columns grouped
    by `gender`. We''ll add users whose genders are male and female to the table and
    group them based on gender. Let''s perform the following steps to do so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`GROUP BY`子句来选择按`gender`分组的列。我们将向表中添加男性和女性的用户，并根据性别对他们进行分组。让我们按照以下步骤进行操作：
- en: 'Establish the connection with the database by using the following command:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令与数据库建立连接：
- en: '[PRE21]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a female user to the table:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将女性用户添加到表中：
- en: '[PRE22]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the following code to see the count by each `gender`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码以查看每个`gender`的计数：
- en: '[PRE23]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3fEzV4N](https://packt.live/3fEzV4N).
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3fEzV4N](https://packt.live/3fEzV4N)。
- en: You can also run this example online at [https://packt.live/2N8kS7l](https://packt.live/2N8kS7l).
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2N8kS7l](https://packt.live/2N8kS7l)在线运行此示例。
- en: We have seen by now how to connect to a database, create a table, and insert
    values in it. We have also looked into topics such as reading values from a table,
    sorting them, and grouping them by common values. These are all very essential
    skills to have when dealing with databases. However, we have not looked into the
    "*Relational*" part of an RDBMS. This is what is coming up next.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了如何连接数据库、创建表以及在其中插入值。我们还探讨了诸如从表中读取值、排序和按共同值分组等主题。这些都是在处理数据库时非常必要的技能。然而，我们还没有探讨
    RDBMS 的 "*关系*" 部分。这正是接下来要讨论的内容。
- en: Relation Mapping in Databases
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库中的关系映射
- en: 'We have been working with a single table and altering it, as well as reading
    back the data. However, the real power of an RDBMS comes from the handling of
    relationships among different objects (tables). In this section, we are going
    to create a new table called comments and link it with the user table in a `1:
    N` relationship. This means that one user can have multiple comments. The way
    we are going to do this is by adding the user table''s primary key as a foreign
    key in the comments table. This will create a `1: N` relationship.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '我们一直在使用单个表，对其进行修改，以及读取数据。然而，关系型数据库管理系统（RDBMS）的真正力量来自于处理不同对象（表）之间的关系。在本节中，我们将创建一个名为
    comments 的新表，并以 `1: N` 的关系将其与用户表链接起来。这意味着一个用户可以有多个评论。我们将通过在 comments 表中添加用户表的主键作为外键来实现这一点。这将创建一个
    `1: N` 的关系。'
- en: 'When we link two tables, we need to specify to the database engine what should
    be done if the parent row is deleted, which has many children in the other table.
    As we can see in the following diagram, we are asking what happens at the place
    of the question marks when we delete `row1` of the user table:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们链接两个表时，我们需要指定如果父行被删除，并且在其另一个表中有很多子行时，数据库引擎应该做什么。正如我们可以在以下图中看到的那样，当我们删除用户表的
    `row1` 时，我们正在询问问号所在位置会发生什么：
- en: '![Figure 8.6: Illustration of relations'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6：关系说明图'
- en: '](img/B15780_08_06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_08_06.jpg)'
- en: 'Figure 8.6: Illustration of relations'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：关系说明图
- en: 'In a non-RDBMS situation, this situation can quickly become difficult and messy
    to manage and maintain. However, with an RDBMS, all we have to tell the database
    engine, in very precise ways, is what to do when a situation like this occurs.
    The database engine will do the rest for us. We use `ON DELETE` to tell the engine
    what we do with all the rows of a table when the parent row gets deleted. The
    following code illustrates these concepts:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在非 RDBMS 情况下，这种情况可能会迅速变得难以管理和维护。然而，使用 RDBMS，我们只需要非常精确地告诉数据库引擎在这种情况下应该做什么。数据库引擎会为我们完成剩下的工作。我们使用
    `ON DELETE` 来告诉引擎当父行被删除时，我们应该如何处理表中的所有行。以下代码说明了这些概念：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `ON DELETE` `CASCADE` line informs the database engine that we want to delete
    all the children rows when the parent gets deleted. We will cover deleting values
    in detail in a later exercise. We can also define actions for `UPDATE`. In this
    case, there is nothing to do on `UPDATE`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON DELETE CASCADE` 行通知数据库引擎，当父行被删除时，我们希望删除所有子行。我们将在后续练习中详细讨论删除值。我们也可以为 `UPDATE`
    定义操作。在这种情况下，对于 `UPDATE` 没有要执行的操作。'
- en: The `FOREIGN KEY` modifier modifies a column definition (`user_id`, in this
    case) and marks it as a foreign key, which is related to the primary key (email,
    in this case) of another table. A foreign key is a link between two tables. We
    define a primary key in one table and then define the same values as foreign keys
    to another table, thereby creating a link between them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`FOREIGN KEY` 修饰符修改一个列定义（在这个例子中是 `user_id`）并将其标记为外键，这与其他表的主键（在这个例子中是 `email`）相关联。外键是两个表之间的链接。我们在一个表中定义主键，然后将其相同的值定义为另一个表的外键，从而在它们之间创建链接。'
- en: You may notice the strange looking `cursor.execute("PRAGMA foreign_keys = 1")`
    line in the code. It is there just because SQLite does not use the normal foreign
    key features by default. It is this line that enables that feature. It is typical
    to SQLite and we won't need it for any other databases.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到代码中看起来奇怪的 `cursor.execute("PRAGMA foreign_keys = 1")` 行。它之所以存在，仅仅是因为
    SQLite 默认不使用正常的 foreign key 功能。正是这一行启用了该功能。这是 SQLite 的典型做法，我们不需要为任何其他数据库使用它。
- en: Hence, we have covered the idea of relations between two tables. One table can
    be related to any number of tables. And there are different types of relationships
    such as `1:1`, `1:n`, and `n:n`. Readers are encouraged to look into these in
    detail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经涵盖了两个表之间关系的基本概念。一个表可以与任意数量的表相关联。存在不同类型的关系，例如`1:1`、`1:n`和`n:n`。鼓励读者详细了解这些内容。
- en: In the next section, we will insert rows in the newly created table.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向新创建的表中插入行。
- en: Adding Rows in the comments Table
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在评论表中添加行
- en: 'We have created a table called `comments`. In this section, we will dynamically
    generate an `INSERT` query, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`comments`的表。在本节中，我们将动态生成一个`INSERT`查询，如下所示：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pay attention to how we dynamically generate the insert query so that we can
    insert 10 comments for each user.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何动态生成插入查询，以便为每个用户插入10条评论。
- en: We have inserted some rows in the new table and we have established a relationship
    between this one and the one before. Up next is one of the most important concepts
    of databases – joins. They help us to write concise queries to retrieve data from
    several linked tables.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在新表中插入了一些行，并建立了这个表与之前表之间的关系。接下来，我们将讨论数据库中最重要概念之一——连接。它们帮助我们编写简洁的查询以从多个相关联的表中检索数据。
- en: Joins
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: Now, we will learn how to exploit the relationship we just built. This means
    that if we have the primary key from one table, we can recover all the data needed
    from that table and also all the linked rows from the child table. To achieve
    this, we will use something called a join.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何利用我们刚刚建立的关系。这意味着如果我们有一个表的主键，我们可以从该表恢复所需的所有数据，以及从子表中的所有相关联行。为了实现这一点，我们将使用称为连接的东西。
- en: 'A join is basically a way to retrieve linked rows from two tables using any
    kind of primary key – foreign key relation that they have. There are many types
    of join, including `INNER`, `LEFT` `OUTER`, `RIGHT` `OUTER`, `FULL` `OUTER`, and
    `CROSS`. They are used in different situations. However, most of the time, in
    simple `1: N` relations, we end up using an `INNER` join. In *Chapter 1*, *Introduction
    to Data Wrangling with Python*, we learned about sets. We can view an `INNER`
    join as an intersection of two sets. The following diagram illustrate the concepts:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 连接基本上是一种通过使用任何类型的键（主键-外键关系）从两个表中检索相关联行的方法。存在许多类型的连接，包括`INNER`、`LEFT OUTER`、`RIGHT
    OUTER`、`FULL OUTER`和`CROSS`。它们用于不同的场景。然而，在大多数简单`1:N`关系中，我们最终会使用`INNER`连接。在*第一章*，*使用Python进行数据整理入门*中，我们学习了集合。我们可以将`INNER`连接视为两个集合的交集。以下图表说明了这些概念：
- en: '![Figure 8.7: A diagram representing the intersection join'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：表示交集连接的图表'
- en: '](img/B15780_08_07.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_08_07.jpg)'
- en: 'Figure 8.7: A diagram representing the intersection join'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：表示交集连接的图表
- en: Here, `A` represents one table, and `B` represents another. The meaning of having
    common members is to have a relationship between them. It takes all of the rows
    of `A` and compares them with all of the rows of B to find the matching rows that
    satisfy the join predicate. This can quickly become a complex and time-consuming
    operation. Joins can be very expensive operations. Usually, we use some kind of
    where clause, after we specify the join, to shorten the scope of rows that are
    fetched from table `A` or `B` to perform the matching.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`A`代表一个表，`B`代表另一个表。拥有共同成员的意义是它们之间存在关系。它将`A`表的所有行与`B`表的所有行进行比较，以找到满足连接谓词的匹配行。这可能会迅速变成一个复杂且耗时的操作。连接操作可能非常昂贵。通常，在指定连接后，我们使用某种类型的`WHERE`子句来缩短从表`A`或`B`中检索的行以执行匹配的范围。
- en: 'In our case, our first table, user, has three entries, with the primary key
    being email. We can make use of this in our query to get comments just from Bob:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们的第一个表，即用户表，有三个条目，主键是电子邮件。我们可以在查询中使用这一点来获取来自Bob的评论：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding output of the `JOIN` query, showing that we have jointly read
    data from two tables at the same time, is restricting our query scope to a particular
    email.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之前`JOIN`查询的输出，显示我们同时从两个表中读取数据，将查询范围限制在特定的电子邮件上。
- en: We have just looked into one of the most important operations of all, joins.
    We will cover some other aspects of the same in the coming section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚探讨了所有操作中最重要的一项——连接操作。在接下来的章节中，我们将讨论其其他一些方面。
- en: Retrieving Specific Columns from a JOIN Query
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JOIN查询中检索特定列
- en: In the previous exercise, we saw that we can use a `JOIN` to fetch the related
    rows from two tables. However, if we look at the results, we will see that it
    returned all the columns, thus combining both tables. This is not very concise.
    What about if we only want to see the emails and the related comments, and not
    all the data?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看到了我们可以使用`JOIN`来从两个表中检索相关行。然而，如果我们查看结果，我们会看到它返回了所有列，从而结合了两个表。这并不非常简洁。如果我们只想看到电子邮件和相关的评论，而不是所有数据呢？
- en: 'There is some nice shorthand code that lets us do this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些简洁的代码可以让我们做到这一点：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Just by changing the `SELECT` statement, we made our final result appear as
    follows, where only columns from the `comments` table are present:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 只需更改`SELECT`语句，我们就可以使最终结果如下，其中只包含`comments`表的列：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have now looked at joins. They are very useful, and you will end up using
    them often while dealing with databases in real life. Up next is a detailed look
    into deleting rows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了连接。它们非常有用，您在处理现实生活中的数据库时经常会使用它们。接下来是删除行的详细探讨。
- en: Deleting Rows from Tables
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从表中删除行
- en: This will be done by using the `DELETE` command. As the name suggests, this
    command helps to delete rows from a table. It is an irreversible process, meaning
    once deleted, we cannot restore those rows. So be very careful when running this
    command as it can have a destructive effect on the data. Please keep in mind that
    it has to almost always be run accompanied by a `WHERE` clause so that we delete
    just a part of the data and not everything.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过使用`DELETE`命令来完成。正如其名所示，这个命令有助于从表中删除行。这是一个不可逆的过程，意味着一旦删除，我们就无法恢复这些行。所以在运行此命令时要非常小心，因为它可能会对数据产生破坏性影响。请记住，它几乎总是需要与`WHERE`子句一起运行，以便我们只删除部分数据，而不是全部数据。
- en: 'Exercise 8.06: Deleting Rows from Tables'
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.06：从表中删除行
- en: In this exercise, we will be working with two tables, `user` and `comments`,
    which are a part of the `lesson.db` database.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将与两个表`user`和`comments`一起工作，这两个表是`lesson.db`数据库的一部分。
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The GitHub version of this exercise begins with the previous 4 examples that
    we just saw, starting off with creation of the `comments` table. You may ignore
    those steps if you have executed them already.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的GitHub版本从我们刚才看到的前4个示例开始，首先是创建`comments`表。如果您已经执行了这些步骤，可以忽略这些步骤。
- en: 'We will delete a row from the `user` table and observe the effects it will
    have on the comments table. Include all the steps mentioned previously. Let''s
    perform the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`user`表中删除一行，并观察它将对评论表产生的影响。包括所有之前提到的步骤。让我们执行以下步骤：
- en: 'To delete a row from a table, we use the `DELETE` clause in SQL. To run delete
    on the user table, we are going to use the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从表中删除一行，我们使用SQL中的`DELETE`子句。要运行对用户表的删除操作，我们将使用以下代码：
- en: '[PRE31]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Perform the `SELECT` operation on the user table:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对用户表执行`SELECT`操作：
- en: '[PRE32]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Observe that the user `Bob` has been deleted.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，用户`Bob`已经被删除。
- en: Now, moving on to the `comments` table, we have to remember that we had mentioned
    `ON DELETE` `CASCADE` while creating the table. The database engine knows that
    if a row is deleted from the parent table (`user`), all the related rows from
    the child tables (`comments`) will have to be deleted.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，转向`comments`表，我们必须记住，在创建表时我们已经提到了`ON DELETE CASCADE`。数据库引擎知道，如果从父表（`user`）中删除一行，所有相关的子表（`comments`）中的行也必须被删除。
- en: 'Perform a `SELECT` operation on the `comments` table by using the following
    command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令对`comments`表执行`SELECT`操作：
- en: '[PRE34]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output (partially shown) is as follows:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下：
- en: '[PRE35]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that all of the rows related to `Bob` are deleted from the `comments`
    table.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，与`Bob`相关的所有行都已从`comments`表中删除。
- en: We have observed the `DELETE` command and also learned how to use it safely.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经观察了`DELETE`命令，并且学习了如何安全地使用它。
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YeutzP](https://packt.live/2YeutzP).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YeutzP](https://packt.live/2YeutzP)。
- en: You can also run this example online at [https://packt.live/3fArsQb](https://packt.live/3fArsQb).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3fArsQb](https://packt.live/3fArsQb)上在线运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须执行整个笔记本才能得到期望的结果。
- en: In the following section, we will see how to update a specific value in a table.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将看到如何更新表中的特定值。
- en: Updating Specific Values in a Table
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表中更新特定值
- en: In this example, we will see how we can update rows in a table. Without `WHERE`,
    updating is often a bad idea. The reason is that we may end up updating rows that
    we did not intend to.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将看到如何更新表中的行。没有`WHERE`子句，更新通常不是一个好主意。原因是我们可能最终会更新我们本不想更新的行。
- en: 'We can combine `UPDATE` with `WHERE` to selectively update the first name of
    the user with the email address tom@web.com, as shown in the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`UPDATE`与`WHERE`结合使用，以选择性地更新具有电子邮件地址tom@web.com的用户的首个名字，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 8.8: Output of the update query, showing the newly updated first name'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8：更新查询的输出，显示新更新的第一个名字'
- en: '](img/B15780_08_08.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_08_08.jpg)'
- en: 'Figure 8.8: Output of the update query, showing the newly updated first name'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：更新查询的输出，显示新更新的第一个名字
- en: So far, we have covered a lot of concepts related to databases. We have learned
    a set of skills that are important for dealing with database-level operations.
    In the next section, we will combine two worlds; the world of databases and the
    world of pandas.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了与数据库相关的大量概念。我们学习了一套处理数据库级操作的重要技能。在下一节中，我们将结合两个世界；数据库的世界和pandas的世界。
- en: We have looked into many fundamental aspects of storing and querying data from
    a database, but as a data wrangling expert, we need our data to be packed and
    presented as a DataFrame so that we can perform quick and convenient operations
    on them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了从数据库存储和查询数据的基本方面，但作为一个数据整理专家，我们需要我们的数据打包并呈现为DataFrame，这样我们就可以对它们进行快速方便的操作。
- en: 'Exercise 8.07: RDBMS and DataFrames'
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.07：关系数据库管理系统和DataFrame
- en: 'In this exercise, we will connect to the `lesson.db` database and join the
    two tables, `user` and `comments`. We will create an empty `data` list and then
    add the rows of this joined table in `data`. Next, we will store the content of
    `data` in a `pandas` DataFrame. To complete this exercise, let''s perform the
    following steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将连接到`lesson.db`数据库并连接两个表，`user`和`comments`。我们将创建一个空的`data`列表，然后添加这个连接表的行到`data`中。接下来，我们将`data`的内容存储在一个`pandas`
    DataFrame中。为了完成这个练习，让我们执行以下步骤：
- en: 'Import pandas using the following code:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导入pandas：
- en: '[PRE37]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a columns list with email, first name, last name, age, gender, and comments
    as column names. Also, create an empty `data` list:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用电子邮件、名字、姓氏、年龄、性别和评论作为列名创建一个列列表。同时，创建一个空的`data`列表：
- en: '[PRE38]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Connect to `lesson.db` using SQLite and obtain a cursor, as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SQLite连接到`lesson.db`并获取一个游标，如下所示：
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the `execute` method from the cursor to set `PRAGMA foreign_keys = 1`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用游标的`execute`方法设置`PRAGMA foreign_keys = 1`：
- en: '[PRE40]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a `sql` variable that will contain the `SELECT` command and use the
    join command to join the databases:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`SELECT`命令的`sql`变量，并使用连接命令连接数据库：
- en: '[PRE41]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use the execute method of `cursor` to execute the `sql` command:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cursor`的`execute`方法执行`sql`命令：
- en: '[PRE42]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Append the rows to the data list:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行追加到数据列表中：
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a DataFrame using the data list and print out the result:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数据列表创建一个DataFrame并打印结果：
- en: '[PRE44]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output will be:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.9: Output of the dataframe'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.9：DataFrame的输出'
- en: '](img/B15780_08_09.jpg)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_08_09.jpg)'
- en: 'Figure 8.9: Output of the dataframe'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：DataFrame的输出
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YPSdZX](https://packt.live/2YPSdZX).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YPSdZX](https://packt.live/2YPSdZX)。
- en: You can also run this example online at [https://packt.live/37HZaAi](https://packt.live/37HZaAi).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/37HZaAi](https://packt.live/37HZaAi)上在线运行此示例。
- en: You must execute the entire Notebook in order to get the desired result.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须执行整个笔记本才能获得期望的结果。
- en: This ends our journey into the world of databases. It was a basic introduction.
    Nonetheless, we managed to cover a wide range of essential topics. DBMS and related
    fields are a mature stream in computer science and are still under active development
    and research. We strongly encourage the reader to read more about it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们探索数据库世界的旅程结束。这是一个基本的介绍。尽管如此，我们还是成功地覆盖了众多基本主题。数据库管理系统及相关领域是计算机科学中的一个成熟分支，并且仍在积极发展和研究中。我们强烈建议读者了解更多相关信息。
- en: 'Activity 8.01: Retrieving Data Accurately from Databases'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动八.01：从数据库中准确检索数据
- en: The goal of this activity is to fetch data and retrieve information from two
    tables, `persons` and `pets`, which are a part of the `petsdb` database.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目标是获取来自`persons`和`pets`两个表的数据，这两个表是`petsdb`数据库的一部分。
- en: Note
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the `petsdb` database at [https://packt.live/3dcH0rx](https://packt.live/3dcH0rx).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.live/3dcH0rx](https://packt.live/3dcH0rx)找到`petsdb`数据库。
- en: 'The `persons` table is defined as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`persons`表的定义如下：'
- en: '![Figure 8.10: The persons table'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10：人员表'
- en: '](img/B15780_08_10.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_08_10.jpg)'
- en: 'Figure 8.10: The persons table'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：人员表
- en: 'The `persons` table has the following columns:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`persons`表有以下列：'
- en: '`first_name`: The first name of the person'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_name`：人的名字'
- en: '`last_name`: The last name of the person (can be `null`)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_name`：人的姓氏（可以是`null`）'
- en: '`age`: The age of the person'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age`：人的年龄'
- en: '`city`: The city where they are from'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`city`：他们来自的城市'
- en: '`zip_code`: The zip code of the city'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip_code`：城市的邮政编码'
- en: As we can see, the `id` column in the `persons` table (which is an integer)
    serves as the primary key for that table and as a foreign key for the `pets` table,
    which is linked via the `owner_id` column.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`persons`表中的`id`列（它是一个整数）是该表的主键，也是`pets`表的外键，通过`owner_id`列进行链接。
- en: 'The `pets` table is defined as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`pets`表的定义如下：'
- en: '![Figure 8.11: The pets table'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11：宠物表'
- en: '](img/B15780_08_11.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_08_11.jpg)'
- en: 'Figure 8.11: The pets table'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：宠物表
- en: 'The pets table has the following columns:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物表有以下列：
- en: '`pet_name`: The name of the pet.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet_name`：宠物的名字。'
- en: '`pet_type`: What type of pet it is, for example, `cat` or `dog`. Due to a lack
    of further information, we do not know which number represents what, but it is
    an integer and can be `null`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet_type`：宠物的类型，例如`cat`或`dog`。由于缺乏更多信息，我们不知道哪个数字代表什么，但它是一个整数，可以是`null`。'
- en: '`treatment_done`: This is also an integer column, and `0` here represents `No`,
    whereas `1` represents `Yes`.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`treatment_done`：这也是一个整数列，其中`0`表示`否`，而`1`表示`是`。'
- en: 'In this activity, you will first connect to the `petsdb` database and check
    whether the connection has been successful. You will then create and execute a
    few SQL commands to answer the following questions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你首先将连接到`petsdb`数据库并检查连接是否成功。然后，你将创建并执行一些SQL命令来回答以下问题：
- en: What is the count of people belonging to different age groups in the `persons`
    table?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人员表中不同年龄组的人数是多少？
- en: Which age group has the maximum number of people?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个年龄组的人数最多？
- en: How many people do not have a last name?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少人没有姓氏？
- en: How many people have more than one pet?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少人拥有不止一只宠物？
- en: How many pets have received treatment?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受了治疗的有多少宠物？
- en: How many pets have received treatment, and the type of pet is known?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少宠物接受了治疗，并且已知宠物的类型？
- en: How many pets are from the city called east port?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自名为east port的城市有多少宠物？
- en: How many pets are from the city called east port, and who received treatment?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自名为east port的城市有多少宠物，并且谁接受了治疗？
- en: 'The output should be as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: 'Answer to question 1 (the following is partial output):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 问题1的答案（以下为部分输出）：
- en: '![Figure 8.12: Partial output of the count of people belonging to different
    age groups'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12：人员表中不同年龄组人数的部分输出'
- en: from the persons table
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 来自人员表
- en: '](img/B15780_08_12.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_08_12.jpg)'
- en: 'Figure 8.12: Partial output of the count of people belonging to different age
    groups from the persons table'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：人员表中不同年龄组人数的部分输出
- en: 'Answer to question 2:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 问题2的答案：
- en: '[PRE45]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Answer to question 3:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 问题3的答案：
- en: '[PRE46]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Answer to question 4:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 问题4的答案：
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Answer to question 5:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 问题5的答案：
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Answer to question 6:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 问题6的答案：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Answer to question 7:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 问题7的答案：
- en: '[PRE50]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Answer to question 8:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 问题8的答案：
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor327).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过[这个链接](B15780_Solution_Final_RK.xhtml#_idTextAnchor327)找到这个活动的解决方案。
- en: In this activity, we have applied all the skills we learned in this chapter
    concerning databases.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们应用了本章关于数据库的所有技能。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have come to the end of the database chapter. We have learned how to connect
    to SQLite using Python. We have brushed up on the basics of relational databases
    and how to open and close a database. We then learned how to export this relational
    database into Python DataFrames.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了数据库章节的结尾。我们学习了如何使用Python连接到SQLite数据库。我们复习了关系数据库的基础知识以及如何打开和关闭数据库。然后我们学习了如何将这个关系数据库导出到Python
    DataFrames。
- en: In the next chapter, we will be performing data wrangling on datasets that are
    used in business use cases. We will use different types of datasets and then clean
    and process the data in a meaningful way. We will be able to apply all the skills
    and tricks we have learned so far in this book to process data and get valuable
    insights from them.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将对用于商业用例的数据集进行数据处理。我们将使用不同类型的数据集，然后以有意义的方式进行数据清洗和处理。我们将能够将本书中迄今为止学到的所有技能和技巧应用于数据处理，并从中获得有价值的见解。
