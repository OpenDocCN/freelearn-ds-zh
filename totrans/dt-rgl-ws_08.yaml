- en: 8\. RDBMS and SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to the basics of using an RDBMS to query a database
    using Python and convert data from SQL and then store it in a `pandas` DataFrame.
    It will explain the concepts of databases, including their creation, manipulation,
    and control, and how to transform tables into `pandas` DataFrames. By the end
    of this chapter, you will learn some basic SQL commands. This knowledge will make
    you adept at adding, updating, retrieving, and deleting data from databases; another
    valuable skill in a budding data wrangling expert's repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter of our data journey is focused on **Relational Database Management
    System** (**RDBMS**) and **Structured Query Language** (**SQL**). In the previous
    chapter, we stored and read data from a file. In this chapter, we will read structured
    data, design access to the data, and create query interfaces for databases.
  prefs: []
  type: TYPE_NORMAL
- en: For years, the RDBMS format has been the conventional way to store data. An
    RDBMS is one of the safest ways to store, manage, and retrieve data. It is backed
    by a solid mathematical foundation (relational algebra and calculus) and exposes
    an efficient and intuitive declarative language – SQL – for easy interaction.
    Almost every language has a rich set of libraries to interact with different RDBMS,
    and the tricks and methods of using them are well tested and well understood.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling an RDBMS is a pretty well-understood task, and there is a group of well
    trained, experienced professionals to do this job (DBAs, or database administrators).
  prefs: []
  type: TYPE_NORMAL
- en: So, it is understandable that we, as data wrangling professionals or data engineers,
    will encounter RDBMS at some point. We will need the tools and knowledge acquired
    from this chapter to deal with RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following chart, the database management system market
    is big. This chart was produced based on market research that was done by Scalegrid
    in 2019:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Commercial database market share released by ScaleGrid in 2019'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.1: Commercial database market share released by ScaleGrid in 2019'
  prefs: []
  type: TYPE_NORMAL
- en: We will learn and play around with some of the basic and fundamental concepts
    of database and relational database management systems in this chapter. We will
    start with a refresher of the theoretical concept of a database, and then we will
    create and operate a database from our Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: Refresher of RDBMS and SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An RDBMS is a piece of software that manages data (represented for the end user
    in tabular form) on physical hard disks and is built using Codd's relational model.
    Most of the databases that we encounter today are RDBMS. In recent years, there
    has been a huge industry shift toward a newer kind of database management system,
    called NoSQL (MongoDB, CouchDB, Riak, and so on). These systems, while they do
    follow some of the rules of RDBMS in certain aspects, in most cases they reject
    or modify them.
  prefs: []
  type: TYPE_NORMAL
- en: How Is an RDBMS Structured?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The RDBMS structure consists of three main elements, namely the storage engine,
    the query engine, and log management. Here is a diagram that demonstrates the
    structure of an RDBMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: RDBMS structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.2: RDBMS structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the main concepts of any RDBMS structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage engine:** This is the part of the RDBMS that is responsible for storing
    data in an efficient way and also retrieving it, when asked for, in an efficient
    way. As an end user of the RDBMS system (an application developer is considered
    an end user of an RDBMS), we will never need to interact with this layer directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query engine:** This is the part of the RDBMS that allows us to create data
    objects (tables, views, and so on), manipulate them (create and delete columns,
    create/delete/update rows, and so on), and query them (read rows) using a simple,
    yet powerful, language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log management:** This part of the RDBMS is responsible for creating and
    maintaining the logs. If you are wondering why the log is such an important thing,
    then you should look into how replication and partitions are handled in a modern
    RDBMS (such as PostgreSQL) using something called the **Write Ahead Log** (or
    **WAL** for short).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on the query engine in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SQL** (pronounced *sequel*), as it is commonly known, is a domain-specific
    language that was originally designed based on E.F. Codd''s relational model and
    is widely used in today''s databases to define, insert, manipulate, and retrieve
    data from them. It can be further sub-divided into four smaller sub-languages,
    namely **Data Definition Language** (**DDL**), **Data Manipulation Language**
    (**DML**), **Data Query Language** (**DQL**), and **Data Control Language** (**DCL**).
    There are several advantages of using SQL, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is based on a solid mathematical framework and thus it is easy to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a declarative language, which means that we actually never tell it how
    to do its job. We almost always tell it what to do. This frees us from the big
    burden of writing custom code for data management. We can be more focused on the
    actual query problem we are trying to solve, instead of bothering about how to
    create and maintain a data store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gives you a fast and readable way to deal with data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL gives you out-of-the-box ways to get multiple pieces of data with a single
    query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main areas of focus for the following topic will be DDL, DML, and DQL.
    The DCL part is more for database administrators. Let''s discuss them briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE TABLE`, `DROP TABLE`, and `ALTER TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice the use of uppercase letters. This is not a requirement, and you may
    use lowercase letters, but it is a widely followed convention, and we will use
    it in this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`INSERT INTO`, `DELETE FROM`, or `UPDATE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT` command. We will also see and use the concepts of the primary key,
    foreign key, index, joins, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you define and insert data in a database, it can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Table displaying sample data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.3: Table displaying sample data'
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to remember about an RDBMS is relations. Generally, in a table,
    we have one or more columns that will have unique values for each row in the table.
    We call them **primary keys** for the table. We should be aware that we will encounter
    unique values across the rows, which are not primary keys. The main difference
    between them and primary keys is the fact that a primary key cannot be null.
  prefs: []
  type: TYPE_NORMAL
- en: By using the primary key of one table and mentioning it as a foreign key in
    another table, we can establish relations between two tables. A certain table
    can be related to any finite number of tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relations can be `1:1`, which means that each row of the second table is
    uniquely related to one row of the first table, or `1:N`, `N:1`, or `N: M`. An
    example of relations is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Diagram showing relations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.4: Diagram showing relations'
  prefs: []
  type: TYPE_NORMAL
- en: With this brief refresher, we are now ready to jump into hands-on exercises
    and write some SQL to store and retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: Using an RDBMS (MySQL/PostgreSQL/SQLite)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this topic, we will focus on how to write some basic SQL commands, as well
    as how to connect to a database from Python and use it effectively within Python.
    The database we will choose here is SQLite. There are other databases, such as
    Oracle, MySQL, PostgreSQL, and DB2\. The main tricks that you are going to learn
    here will not change depending on the database you are using. However, for different
    databases, you will need to install different third-party Python libraries (such
    as Psycopg2 for PostgreSQL). The reason they all behave the same way (apart for
    some small details) is the fact that they all adhere to PEP249 (commonly known
    as Python DB API 2).
  prefs: []
  type: TYPE_NORMAL
- en: This is a good standardization and saves us a lot of headaches while porting
    from one RDBMS to another. If you already have some experience with databases,
    then you will notice that we will not be using any server address, username, password,
    or other credentials to connect to a database. This is because these fields are
    not mandatory in sqlite3, unlike in PostgreSQL or MySQL. The main database engine
    of SQLite is embedded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Most of the industry-standard projects that are written in Python and use some
    kind of RDBMS as the data store most often rely on an **Object Relational Mapper**
    (**ORM**). An ORM is a high-level library in Python that makes many tasks easier
    when dealing with an RDBMS. It also exposes a more Pythonic API than writing raw
    SQL inside Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.01: Connecting to a Database in SQLite'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will look into the first step toward using an RDBMS in
    Python code. We are going to connect to a database, `lesson.db`. We will then
    close the connection safely. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `sqlite3` library from Python by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `connect` function to connect to a database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the connection, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `conn` object is the main connection object, and we will need it to get
    a second type of object in the future once we want to interact with the database.
    We need to be careful about closing any open connection to our database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the same `with` statement from Python, just like we did for files, and
    connect to the database, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we have connected to a database using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YMWrBD](https://packt.live/2YMWrBD).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3df6q87](https://packt.live/3df6q87).
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will see the best way to create a table and put data
    into it using Python.
  prefs: []
  type: TYPE_NORMAL
- en: DDL and DML Commands in SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a table in SQL, use the `CREATE TABLE` SQL clause. This will require
    the table name and the table definition. The table name is a unique identifier
    for the database engine to find and use the table for all future transactions.
    It can be anything (any alphanumeric string), as long as it is unique. We add
    the table definition in the form of (`column_name_1 data_type`, `column_name_2
    data type`, `…` ). For our purpose, we will use the text and integer data types,
    but usually, a standard database engine supports many more data types, such as
    float, double, date time, and Boolean. We will also need to specify a primary
    key. A primary key is a unique, non-null identifier that's used to uniquely identify
    a row in a table. In our case, we use email as a primary key. A primary key can
    be an integer or text.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing you need to know is that unless you call a commit on the series
    of operations you just performed (together, we formally call them a transaction),
    nothing will actually be performed and reflected in the database. This property
    is called atomicity. In fact, for a database to be industry-standard (to be useable
    in real life), it needs to follow the **Atomicity, Consistency, Isolation, Durability**
    (**ACID**) properties.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, **Data Definition Language** (**DDL**) is the way to communicate
    with the database engine in advance to define what the data will look like. The
    database engine creates a table object based on the definition provided and prepares
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.02: Using DDL and DML Commands in SQLite'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will connect with the `lesson.db` database and then create
    a `user` table. Then, we will insert data into the table using the DDL and DML
    commands. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use SQLite''s `connect` function to connect to the `lesson.db` database. Create
    a `cursor` object by calling `conn.cursor()`. The `cursor` object acts as a medium
    by which to communicate with the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a table in Python, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert rows into the database that you created, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create the table and write two rows to it with data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YeniaH](https://packt.live/2YeniaH).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2BogE8J](https://packt.live/2BogE8J).
  prefs: []
  type: TYPE_NORMAL
- en: You must execute the entire Notebook in order to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will read back the data that we just stored.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Data from a Database in SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding exercise, we created a table and stored data in it. Now, we
    will learn how to read the data that's stored in this database.
  prefs: []
  type: TYPE_NORMAL
- en: The `SELECT` clause is immensely powerful, and it is really important for a
    data practitioner to master `SELECT` and everything related to it (such as conditions,
    joins, and group-by).
  prefs: []
  type: TYPE_NORMAL
- en: The `*` after `SELECT` tells the engine to select all of the columns from the
    table. This is a useful shorthand. We have not mentioned any condition for the
    selection (such as above a certain age, first name starting with a certain sequence
    of letters, and so on). We are practically telling the database engine to select
    all the rows and all the columns from the table. It is time-consuming and less
    effective if we have a huge table. Hence, we would want to use the `LIMIT` clause
    to limit the number of rows we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `SELECT` clause in SQL to retrieve data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax to use the `SELECT` clause with `LIMIT` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This syntax is sample code and will not work on Jupyter Notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: This will select all the columns, but only the first `50` rows from the table.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to connect, write, and read basic data to a database,
    we will be venturing into more advanced operations in the coming exercises, with
    the sorting of data being the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.03: Sorting Values That Are Present in the Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the `ORDER BY` clause to sort the rows of the
    `user` table with respect to the `age` column in both descending and ascending
    order. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to the `lesson.db` database and sort `lesson.db` by age in descending
    order, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sort the `lesson.db` database by age in ascending order, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we don't need to specify the order as `ASC` in order to sort it
    in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have seen how to sort data. Sorting is one of the most
    important operations you will often need to do.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/37I7Iap](https://packt.live/37I7Iap).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YOu4D5](https://packt.live/2YOu4D5).
  prefs: []
  type: TYPE_NORMAL
- en: You must execute the entire Notebook in order to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming exercise, we will see how to update the structure of an already
    defined table.
  prefs: []
  type: TYPE_NORMAL
- en: The ALTER Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ALTER` is a command that is used by a RDBMS to add a new column to an already
    existing table, or to change the data type of a column, whereas the `UPDATE` command
    is used to update the value of one or more columns in one or several rows of a
    database. We will examine them in the following section to check out their use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.04: Altering the Structure of a Table and Updating the New Fields'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to add a column, `gender`, using the `ALTER`
    command in the `user` table. Then, by using the `UPDATE` command, we will set
    the value of the `gender` column. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Establish a connection with the database by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another column in the `user` table and fill it with null values by using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update all of the values of gender so that they are `M` by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check the altered table, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have to be cautious when using `UPDATE`, because using `UPDATE` without selective
    clauses (such as `WHERE`) affects the entire table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/312BtBL](https://packt.live/312BtBL).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3ddIYbh](https://packt.live/3ddIYbh).
  prefs: []
  type: TYPE_NORMAL
- en: You must execute the entire Notebook in order to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: The GROUP BY clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn about a concept that we have already learned about in pandas.
    This is called the `GROUP BY` clause. The `GROUP BY` clause is a technique that''s
    used to retrieve distinct values from the database and place them in individual
    buckets. The following diagram explains how the `GROUP BY` clause works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Illustration of the GROUP BY clause on a table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.5: Illustration of the GROUP BY clause on a table'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see that the `col3` column has only two unique
    values across all rows, `A` and `B`. The command that''s used to check the total
    number of rows belonging to each group is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the following exercise to practice the `GroupBy` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.05: Grouping Values in Tables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the `GROUP BY` clause to select the columns grouped
    by `gender`. We''ll add users whose genders are male and female to the table and
    group them based on gender. Let''s perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Establish the connection with the database by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a female user to the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following code to see the count by each `gender`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3fEzV4N](https://packt.live/3fEzV4N).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2N8kS7l](https://packt.live/2N8kS7l).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have seen by now how to connect to a database, create a table, and insert
    values in it. We have also looked into topics such as reading values from a table,
    sorting them, and grouping them by common values. These are all very essential
    skills to have when dealing with databases. However, we have not looked into the
    "*Relational*" part of an RDBMS. This is what is coming up next.
  prefs: []
  type: TYPE_NORMAL
- en: Relation Mapping in Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been working with a single table and altering it, as well as reading
    back the data. However, the real power of an RDBMS comes from the handling of
    relationships among different objects (tables). In this section, we are going
    to create a new table called comments and link it with the user table in a `1:
    N` relationship. This means that one user can have multiple comments. The way
    we are going to do this is by adding the user table''s primary key as a foreign
    key in the comments table. This will create a `1: N` relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we link two tables, we need to specify to the database engine what should
    be done if the parent row is deleted, which has many children in the other table.
    As we can see in the following diagram, we are asking what happens at the place
    of the question marks when we delete `row1` of the user table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Illustration of relations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.6: Illustration of relations'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a non-RDBMS situation, this situation can quickly become difficult and messy
    to manage and maintain. However, with an RDBMS, all we have to tell the database
    engine, in very precise ways, is what to do when a situation like this occurs.
    The database engine will do the rest for us. We use `ON DELETE` to tell the engine
    what we do with all the rows of a table when the parent row gets deleted. The
    following code illustrates these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `ON DELETE` `CASCADE` line informs the database engine that we want to delete
    all the children rows when the parent gets deleted. We will cover deleting values
    in detail in a later exercise. We can also define actions for `UPDATE`. In this
    case, there is nothing to do on `UPDATE`.
  prefs: []
  type: TYPE_NORMAL
- en: The `FOREIGN KEY` modifier modifies a column definition (`user_id`, in this
    case) and marks it as a foreign key, which is related to the primary key (email,
    in this case) of another table. A foreign key is a link between two tables. We
    define a primary key in one table and then define the same values as foreign keys
    to another table, thereby creating a link between them.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice the strange looking `cursor.execute("PRAGMA foreign_keys = 1")`
    line in the code. It is there just because SQLite does not use the normal foreign
    key features by default. It is this line that enables that feature. It is typical
    to SQLite and we won't need it for any other databases.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we have covered the idea of relations between two tables. One table can
    be related to any number of tables. And there are different types of relationships
    such as `1:1`, `1:n`, and `n:n`. Readers are encouraged to look into these in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will insert rows in the newly created table.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Rows in the comments Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have created a table called `comments`. In this section, we will dynamically
    generate an `INSERT` query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to how we dynamically generate the insert query so that we can
    insert 10 comments for each user.
  prefs: []
  type: TYPE_NORMAL
- en: We have inserted some rows in the new table and we have established a relationship
    between this one and the one before. Up next is one of the most important concepts
    of databases – joins. They help us to write concise queries to retrieve data from
    several linked tables.
  prefs: []
  type: TYPE_NORMAL
- en: Joins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will learn how to exploit the relationship we just built. This means
    that if we have the primary key from one table, we can recover all the data needed
    from that table and also all the linked rows from the child table. To achieve
    this, we will use something called a join.
  prefs: []
  type: TYPE_NORMAL
- en: 'A join is basically a way to retrieve linked rows from two tables using any
    kind of primary key – foreign key relation that they have. There are many types
    of join, including `INNER`, `LEFT` `OUTER`, `RIGHT` `OUTER`, `FULL` `OUTER`, and
    `CROSS`. They are used in different situations. However, most of the time, in
    simple `1: N` relations, we end up using an `INNER` join. In *Chapter 1*, *Introduction
    to Data Wrangling with Python*, we learned about sets. We can view an `INNER`
    join as an intersection of two sets. The following diagram illustrate the concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: A diagram representing the intersection join'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.7: A diagram representing the intersection join'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `A` represents one table, and `B` represents another. The meaning of having
    common members is to have a relationship between them. It takes all of the rows
    of `A` and compares them with all of the rows of B to find the matching rows that
    satisfy the join predicate. This can quickly become a complex and time-consuming
    operation. Joins can be very expensive operations. Usually, we use some kind of
    where clause, after we specify the join, to shorten the scope of rows that are
    fetched from table `A` or `B` to perform the matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, our first table, user, has three entries, with the primary key
    being email. We can make use of this in our query to get comments just from Bob:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output of the `JOIN` query, showing that we have jointly read
    data from two tables at the same time, is restricting our query scope to a particular
    email.
  prefs: []
  type: TYPE_NORMAL
- en: We have just looked into one of the most important operations of all, joins.
    We will cover some other aspects of the same in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Specific Columns from a JOIN Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous exercise, we saw that we can use a `JOIN` to fetch the related
    rows from two tables. However, if we look at the results, we will see that it
    returned all the columns, thus combining both tables. This is not very concise.
    What about if we only want to see the emails and the related comments, and not
    all the data?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some nice shorthand code that lets us do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Just by changing the `SELECT` statement, we made our final result appear as
    follows, where only columns from the `comments` table are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have now looked at joins. They are very useful, and you will end up using
    them often while dealing with databases in real life. Up next is a detailed look
    into deleting rows.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Rows from Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This will be done by using the `DELETE` command. As the name suggests, this
    command helps to delete rows from a table. It is an irreversible process, meaning
    once deleted, we cannot restore those rows. So be very careful when running this
    command as it can have a destructive effect on the data. Please keep in mind that
    it has to almost always be run accompanied by a `WHERE` clause so that we delete
    just a part of the data and not everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.06: Deleting Rows from Tables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be working with two tables, `user` and `comments`,
    which are a part of the `lesson.db` database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub version of this exercise begins with the previous 4 examples that
    we just saw, starting off with creation of the `comments` table. You may ignore
    those steps if you have executed them already.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will delete a row from the `user` table and observe the effects it will
    have on the comments table. Include all the steps mentioned previously. Let''s
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete a row from a table, we use the `DELETE` clause in SQL. To run delete
    on the user table, we are going to use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform the `SELECT` operation on the user table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the user `Bob` has been deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, moving on to the `comments` table, we have to remember that we had mentioned
    `ON DELETE` `CASCADE` while creating the table. The database engine knows that
    if a row is deleted from the parent table (`user`), all the related rows from
    the child tables (`comments`) will have to be deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Perform a `SELECT` operation on the `comments` table by using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output (partially shown) is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that all of the rows related to `Bob` are deleted from the `comments`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: We have observed the `DELETE` command and also learned how to use it safely.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YeutzP](https://packt.live/2YeutzP).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3fArsQb](https://packt.live/3fArsQb).
  prefs: []
  type: TYPE_NORMAL
- en: You must execute the entire Notebook in order to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will see how to update a specific value in a table.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Specific Values in a Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will see how we can update rows in a table. Without `WHERE`,
    updating is often a bad idea. The reason is that we may end up updating rows that
    we did not intend to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine `UPDATE` with `WHERE` to selectively update the first name of
    the user with the email address tom@web.com, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Output of the update query, showing the newly updated first name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.8: Output of the update query, showing the newly updated first name'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered a lot of concepts related to databases. We have learned
    a set of skills that are important for dealing with database-level operations.
    In the next section, we will combine two worlds; the world of databases and the
    world of pandas.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked into many fundamental aspects of storing and querying data from
    a database, but as a data wrangling expert, we need our data to be packed and
    presented as a DataFrame so that we can perform quick and convenient operations
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.07: RDBMS and DataFrames'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will connect to the `lesson.db` database and join the
    two tables, `user` and `comments`. We will create an empty `data` list and then
    add the rows of this joined table in `data`. Next, we will store the content of
    `data` in a `pandas` DataFrame. To complete this exercise, let''s perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import pandas using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a columns list with email, first name, last name, age, gender, and comments
    as column names. Also, create an empty `data` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect to `lesson.db` using SQLite and obtain a cursor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `execute` method from the cursor to set `PRAGMA foreign_keys = 1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `sql` variable that will contain the `SELECT` command and use the
    join command to join the databases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the execute method of `cursor` to execute the `sql` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the rows to the data list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a DataFrame using the data list and print out the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.9: Output of the dataframe'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_08_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.9: Output of the dataframe'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YPSdZX](https://packt.live/2YPSdZX).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/37HZaAi](https://packt.live/37HZaAi).
  prefs: []
  type: TYPE_NORMAL
- en: You must execute the entire Notebook in order to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: This ends our journey into the world of databases. It was a basic introduction.
    Nonetheless, we managed to cover a wide range of essential topics. DBMS and related
    fields are a mature stream in computer science and are still under active development
    and research. We strongly encourage the reader to read more about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.01: Retrieving Data Accurately from Databases'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this activity is to fetch data and retrieve information from two
    tables, `persons` and `pets`, which are a part of the `petsdb` database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the `petsdb` database at [https://packt.live/3dcH0rx](https://packt.live/3dcH0rx).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `persons` table is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: The persons table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.10: The persons table'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `persons` table has the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first_name`: The first name of the person'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name`: The last name of the person (can be `null`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age`: The age of the person'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`city`: The city where they are from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip_code`: The zip code of the city'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the `id` column in the `persons` table (which is an integer)
    serves as the primary key for that table and as a foreign key for the `pets` table,
    which is linked via the `owner_id` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pets` table is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: The pets table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.11: The pets table'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pets table has the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pet_name`: The name of the pet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet_type`: What type of pet it is, for example, `cat` or `dog`. Due to a lack
    of further information, we do not know which number represents what, but it is
    an integer and can be `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`treatment_done`: This is also an integer column, and `0` here represents `No`,
    whereas `1` represents `Yes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this activity, you will first connect to the `petsdb` database and check
    whether the connection has been successful. You will then create and execute a
    few SQL commands to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the count of people belonging to different age groups in the `persons`
    table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which age group has the maximum number of people?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many people do not have a last name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many people have more than one pet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many pets have received treatment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many pets have received treatment, and the type of pet is known?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many pets are from the city called east port?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many pets are from the city called east port, and who received treatment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer to question 1 (the following is partial output):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: Partial output of the count of people belonging to different
    age groups'
  prefs: []
  type: TYPE_NORMAL
- en: from the persons table
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_08_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.12: Partial output of the count of people belonging to different age
    groups from the persons table'
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer to question 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer to question 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer to question 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer to question 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer to question 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer to question 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Answer to question 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor327).
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we have applied all the skills we learned in this chapter
    concerning databases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come to the end of the database chapter. We have learned how to connect
    to SQLite using Python. We have brushed up on the basics of relational databases
    and how to open and close a database. We then learned how to export this relational
    database into Python DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be performing data wrangling on datasets that are
    used in business use cases. We will use different types of datasets and then clean
    and process the data in a meaningful way. We will be able to apply all the skills
    and tricks we have learned so far in this book to process data and get valuable
    insights from them.
  prefs: []
  type: TYPE_NORMAL
