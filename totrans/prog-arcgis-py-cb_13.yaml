- en: Chapter 13. Using Python with ArcGIS Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the new Python window in ArcGIS Pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding differences between ArcGIS for Desktop and ArcGIS Pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Python for standalone ArcGIS Pro scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting ArcGIS for Desktop Python code to ArcGIS Pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will briefly cover several concepts related to using Python
    in ArcGIS Pro. There are many similarities between using Python in ArcGIS for
    Desktop and ArcGIS Pro, so what you've learned up to this point will almost certainly
    translate to the new ArcGIS Pro environment. However, there are some differences
    in ArcGIS for Desktop and ArcGIS Pro, also there is a new Python Window that you
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some differences between using Python in ArcGIS for Desktop and ArcGIS
    Pro. In general, you can break down the differences as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Functionality differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python version 3 instead of version 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsupported data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to functionality in ArcPy for ArcGIS Pro includes the removal of some
    geoprocessing tools, including the Coverage, Data Interoperability, Parcel Fabric,
    Schematics, and Tracking Analyst toolboxes. There are some additional tools in
    other toolboxes that are not available as well. The full list of geoprocessing
    tools that are not included can be found at [http://pro.arcgis.com/en/pro-app/tool-reference/appendices/unavailable-tools.htm](http://pro.arcgis.com/en/pro-app/tool-reference/appendices/unavailable-tools.htm).
  prefs: []
  type: TYPE_NORMAL
- en: ArcGIS Pro uses version 3.4 of Python, while ArcGIS for Desktop 10.3 uses version
    2.7\. There are some significant differences between the two releases and they
    are incompatible. A lot of the language is the same, but there are some significant
    differences related to strings, dictionaries, and other objects.
  prefs: []
  type: TYPE_NORMAL
- en: A number of data formats will not be supported in the new ArcGIS Pro environment,
    including personal geodatabases, raster catalogs, geometric networks, topologies,
    layer and map packages, and others. If you have been using one of these data formats
    in ArcGIS for Desktop, please keep in mind that they are not supported, so any
    scripts that you have written that use these formats will not be able to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new Python window in ArcGIS Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been using the Python window in ArcGIS for Desktop, you'll already
    be pretty familiar with the Python window in ArcGIS Pro. However, there are some
    differences between the two and some improvements as well. In this recipe, you'll
    learn how to use the ArcGIS Pro Python window.
  prefs: []
  type: TYPE_NORMAL
- en: The Python window in ArcGIS Pro functions in much the same way as the window
    in ArcGIS for Desktop. It serves as an integrated tool used to execute Python
    code for geoprocessing operations. Using the Python Window, you can execute Python
    functionalities, including ArcPy, core Python functionalities, and third-party
    libraries. Python code that you write in the window can be saved or loaded from
    an existing script source. The inclusion of autocompletion functionality makes
    it easier to complete coding operations, including calling tools and passing parameters.
    In this recipe, you'll learn how to use the ArcGIS Pro Python window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to use the ArcGIS Pro Python window:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **ArcGIS Pro** and select a project or create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **ANALYSIS** menu item in ArcGIS Pro and then the **Python** tool,
    as shown in the following screenshot:![Using the new Python window in ArcGIS Pro](img/B04314_13_1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will display the **Python** window at the bottom of the ArcGIS Pro window,
    as seen in the following screenshot:![Using the new Python window in ArcGIS Pro](img/B04314_13_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Python window can be pinned, unpinned, and resized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two basic sections of the Python window in ArcGIS Pro: **Transcript**
    and **Python prompt**. Both are shown in the following screenshot. You will write
    code in the Python prompt section one line at a time. The transcript section provides
    a record of Python code that has already been executed.![Using the new Python
    window in ArcGIS Pro](img/B04314_13_3.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After typing in a line of code, you press the *Enter* key on your keyboard
    and the code is executed and moved to the transcript section. Print messages are
    written to the transcript window as errors. Type the following line of code to
    import the ArcPy mapping module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The ArcGIS Pro Python window has a code completion functionality so that as
    you begin typing, various matching options will be presented that provide a current
    match to what you have typed. You can select one of the items from the presented
    list to complete the typing. You can see an illustration of this by typing `arc`
    in the Python prompt. The code completion functionality will present two options:
    `arcgis` and `arcpy`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can access the built-in help system by using the `help()` method. Type `help(arcpy.ListFeatureClasses())`
    in order to see an illustration of the help documentation that is provided:![Using
    the new Python window in ArcGIS Pro](img/B04314_13_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can save any Python code that you have written by right-clicking inside
    the transcript section and selecting **Save Transcript**. In addition to this,
    you can load an existing Python script into the window by right-clicking in the
    prompt section and selecting **Load Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ArcGIS Pro Python window can be used to write basic Python geoprocessing
    scripts, execute tools, access ArcPy and its associated modules, Python core modules
    and third-party modules, load and execute existing Python scripts, save Python
    scripts for later use, and obtain help for ArcPy classes and functions. However,
    there are coding differences between ArcGIS for Desktop and ArcGIS Pro.
  prefs: []
  type: TYPE_NORMAL
- en: Coding differences between ArcGIS for Desktop and ArcGIS Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss some of the differences between Python code written
    in ArcGIS for Desktop and ArcGIS Pro. Fortunately, there aren't many differences.
  prefs: []
  type: TYPE_NORMAL
- en: ArcPy supports a variety of modules, including the data access, mapping, spatial
    analyst, network analyst, and time modules. As you have already learned, to use
    these modules, you must first import them into your script. For most of these
    modules, the way that you import them will be the same regardless of whether you're
    using ArcGIS for Desktop or ArcGIS Pro. However, there are some differences when
    importing the ArcPy mapping module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the ArcGIS Pro Python environment, you''ll need to use the following syntax
    to import the mapping module. The use of a two-character reference to the mapping
    module is in line with how all the other modules are imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This differs from how you reference the ArcPy mapping module in ArcGIS for
    Desktop, as seen in this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installing Python for ArcGIS Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of you will probably have become quite familiar with executing your Python
    ArcGIS for Desktop geoprocessing scripts in standalone environments. Examples
    of this would include executing a script from an integrated development environment,
    such as IDLE as a scheduled task, or from an operating system prompt. By default,
    ArcGIS Pro does not include this capability. ArcGIS Pro does include an embedded
    Python editor that will allow you to execute your code in the Python window as
    a script tool or a geoprocessing tool. However, if you need to be able to access
    ArcGIS Pro functionalities from a standalone environment, you will need to download
    and install a Python setup file from **My Esri** ([https://my.esri.com/#/downloads](https://my.esri.com/#/downloads)).
    This installer file will install Python 3.4.1 and other requirements needed by
    ArcGIS Pro.
  prefs: []
  type: TYPE_NORMAL
- en: Converting ArcGIS for Desktop Python code to ArcGIS Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier in this chapter, there aren't many differences between
    the Python code you would write for ArcGIS for Desktop and ArcGIS Pro. We've already
    discussed the primary differences between the two. The versions of Python used
    are quite different with ArcGIS for Desktop 10.3, which runs Python 2.7 and ArcGIS
    Pro 1.0, which runs Python 3.4\. These two versions of Python are incompatible
    and there are some tools that you can use when migrating your existing code to
    ArcGIS Pro.
  prefs: []
  type: TYPE_NORMAL
- en: The first tool that we'll examine is the `AnalyzeToolsForPro`. This geoprocessing
    tool can be found in the `Management` toolbox. This tool analyzes Python scripts
    and custom geoprocessing tools, and toolboxes for functionalities that are not
    supported by ArcGIS Pro. This tool will identify any geoprocessing tools and environment
    settings that are not supported by ArcGIS Pro, the replacement of `arcpy.mapping`
    with `arcpy.mp`, and any unsupported data formats, such as personal geodatabases
    that are not supported by ArcGIS Pro. For issues related to Python 2 and Python
    3, the tool also uses the `2to3` utility to identify any Python-specific issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax for this tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The input for this tool can be a geoprocessing toolbox, Python file, or tool
    name, and the optional report parameter is a output text file that includes any
    issues that were identified.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the standalone `2to3` Python tool that will identify any Python-specific
    coding issues related to the differences between the two versions of the language.
    This is a command-line utility provided with Python 2 and 3 installations. The
    utility can be found in a path similar to `C:\Python34\Tools\Scripts\2to3.py`
    or `C:\Python27\Tools\Scripts\2to3.py`. This is not a perfect tool, but has been
    estimated to identify approximately 95 percent of the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Automating Python Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Python scripts from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sys.argv[ ] to capture command-line input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Python scripts to batch files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling batch files to run at prescribed times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python geoprocessing scripts can be executed either outside ArcGIS as standalone
    scripts or inside ArcGIS as script tools. Both methods have their advantages and
    disadvantages. Up to this point in the book, all our scripts have been run either
    inside ArcGIS as a script tool, from a Python development environment such as
    IDLE, or the Python window in ArcGIS. However, Python scripts can also be executed
    from the Windows operating system command line. The command line is a window that
    you can use to type in commands, rather than the usual point-and-click approach
    provided by Windows. This method of running Python scripts is useful for scheduling
    the execution of a script. There are a number of reasons why you might want to
    schedule your scripts. Many geoprocessing scripts take a long time to fully execute
    and need to be scheduled to run during nonworking hours on a regular basis. Additionally,
    some scripts need to be executed on a routine basis (every day, week, month, and
    so on), and should be scheduled for efficiency. In this chapter, you will learn
    how to execute scripts from the command line, place scripts inside a batch file,
    and schedule the execution of scripts at prescribed times. Keep in mind that any
    scripts run from the command line will still need access to an ArcGIS for Desktop
    license in order to use the `arcpy` module.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python scripts from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point in the book, all your Python scripts have been run as either
    script tools in ArcGIS or from a Python development environment. The Windows command
    prompt provides yet another way of executing your Python scripts. The command
    prompt is used primarily to execute scripts that will be run as a part of a batch
    file and/or as scheduled tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple advantages of running Python geoprocessing scripts from the
    command prompt. These scripts can be scheduled to batch process your data during
    off hours for more efficient processing, and they are easier to debug due to the
    built-in Python error handling and debugging capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the Windows command prompt to execute
    a Python script. You will need administrative rights to complete this recipe,
    so you may need to contact your information technology support group to make this
    change.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to run a script from the Windows command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, navigate to **Start** | **All Programs** | **Accessories** | **Command
    Prompt** which will display a window similar to the following screenshot:![How
    to do it…](img/B04314_A1_1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The window will display the current directory. Your directory will differ to
    some degree. Let's change to the directory for this appendix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type `cd c:\ArcpyBook\Appendix1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `dir` to see a listing of the files and subdirectories. You should see
    only a single Python file called `ListFields.py`:![How to do it…](img/B04314_A1_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to make sure that the Python interpreter can be run from anywhere
    in your directory structure. Navigate to **Start** | **All Programs** | **Accessories**
    | **System Tools** | **Control Panel** as shown in the following screenshot:![How
    to do it…](img/B04314_A1_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **System and Security**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **System**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Advanced system settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **System Properties** dialog box, select the **Advanced** tab and then
    the **Environment Variables** button, as shown in the following screenshot:![How
    to do it…](img/B04314_A1_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Path** system variable, as can be seen in the following screenshot,
    and click on **Edit…**:![How to do it…](img/B04314_A1_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the entire text string for the `C:\Python27\ArcGIS10.3` directory. If
    the text string isn't found, add it to the end. Make sure that you add a semicolon
    before adding the path as shown in the following screenshot. Now, when you type
    `python` in the command prompt, it will look through each of the directories in
    the **Path** system variable, checking for an executable called `python.exe`.![How
    to do it…](img/B04314_A1_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to dismiss the **Edit System Variable** dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to dismiss the **Environment Variables** dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to dismiss the **System Properties** dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `python ListFields.py`. This will run the `ListFields.py` script. After
    a brief delay, you should see the following output:![How to do it…](img/B04314_A1_7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The delay is caused by the first line of code that imports the `arcpy` module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider adding a `print` statement before `import` to inform users of the delay.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ListFields.py` script provided for you in this recipe is a simple script
    that lists the attribute fields for `Burglary feature class`. The workspace and
    feature class name are hardcoded in the script. Typing `python` followed by the
    name of the script, which is `ListFields.py` in this case, triggered the execution
    of a script using the Python interpreter. As I mentioned earlier, the workspace
    and feature class names were hardcoded in this script. In the next recipe, you
    will learn how to pass in arguments to the script so that you can remove the hardcoding
    and make your script more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Using sys.argv[ ] to capture command-line input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of hardcoding your scripts with paths to specific datasets, you can
    make your scripts more flexible by allowing them to accept input in the form of
    parameters from the command prompt. These input parameters can be captured using
    Python's `sys.argv[]` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python''s `sys.argv[]` object allows you to capture input parameters from the
    command line when a script is executed. We will use an example to illustrate how
    this works. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B04314_A1_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each word must be separated by a space. These words are stored in a zero-based
    list object called `sys.argv[]`. In the `sys.argv[]` object, the first item in
    the list referenced by the `0` index, stores the name of the script. In this case,
    it would be `ListFields.py`. Each successive word is referenced by the next integer.
    Therefore, the first parameter (`c:\ArcpyBook\data`) will be stored in `sys.argv[1]`,
    and the second parameter (`Burglaries.shp`) will be stored in `sys.argv[2]`. Each
    of the arguments in the `sys.argv[]` object can be accessed and used inside your
    geoprocessing script. In this recipe, you're going to update the `ListFields.py`
    script so that it accepts input parameters from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Python script that can accept input parameters
    from the command prompt, using `sys.argv[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `C:\ArcpyBook\Appendix1\ListFields.py` in IDLE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `sys` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable to hold the workspace that will be passed into the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable to hold the feature class that will be passed into the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the lines of code that set the workspace and call the `ListFields()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your completed script should appear as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix1\ListFields_Step2.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, open the command prompt and navigate to `C:\ArcpyBook\Appendix1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the command line, type the following and press the *Enter* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again, you should see the output detailing the attribute fields for the
    `Burglaries_2009.shp` file. The difference is that your script no longer has a
    hardcoded workspace and feature class name. You now have a more flexible script,
    which is capable of listing the attribute fields for any feature class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sys` module contains a list object called `argv[]`, which is used to store
    the input parameters for the command-line execution of a Python script. The first
    item stored in the list is always the name of the script. So, in this case, `sys.argv[0]`
    contains `ListFields.py`. Two parameters are passed into the script, including
    the workspace and a feature class. These are stored in `sys.argv[1]` and `sys.argv[2]`,
    respectively. These values are then assigned to variables and used in the script.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Python scripts to batch files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scheduling your Python scripts to run at prescribed times will require that
    you create a batch file containing one or more scripts and or operating system
    commands. These batch files can then be added to the Windows scheduler to run
    at a specific time interval.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Batch files are text files containing command-line sequences to run Python scripts
    or perform operating system commands. They have a file extension of `.bat`, which
    Windows recognizes as an executable file. Since batch files simply contain command-line
    sequences, they can be written with any text editor, though it is recommended
    that you use a basic text editor, such as Notepad. This is done so that you can
    avoid the inclusion of invisible special characters, which are sometimes inserted
    by programs, such as Microsoft Word. In this recipe, you will create a simple
    batch file that navigates to the directory containing your `ListFields.py` script
    and executes it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a batch file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Notepad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of text to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file to your desktop as `ListFields.bat`. Make sure you change the
    **Save as Type** drop-down list to **All Files**, otherwise you'll wind up with
    a file called `ListFields.bat.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Windows, navigate to your desktop and double-click on `ListFields.bat` to
    execute the sequence of commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A command prompt will be displayed during execution. After the commands have
    been executed, the command prompt will automatically close.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows treats a batch file as an executable, so double-clicking on the file
    will automatically execute the sequence of commands contained within the file
    in a new command prompt window. All the `print` statements will be written to
    the window. After the commands have been executed, the command prompt will automatically
    close. In the event that you need to keep a track of the output, you can write
    the statements to an output log file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Batch files can contain variables, loops, comments, and conditional logic. These
    functionalities are beyond the scope of this recipe. However, if you're writing
    and running a number of scripts for your organization, it's worthwhile spending
    some time learning more about batch files. Batch files have been around for a
    long time, so there is no shortage of information about these files on the Web.
    For more information about batch files, please consult the Wikipedia page for
    this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling batch files to run at prescribed times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once created, your batch files can then be scheduled to run at prescribed times
    using the Windows scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many geoprocessing scripts are time-intensive and best run after hours when
    they can take full advantage of system resources and free up your time to concentrate
    on other tasks. In this recipe, you will learn how to use the Windows scheduler
    to schedule the execution of your batch file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to schedule a batch file with the Windows scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Windows scheduler by navigating to **Start** | **All Programs** | **Accessories**
    | **System Tools** | **Control Panel** | **Administrative Tools**. Select **Task
    Scheduler**. The scheduler should appear, as shown in the following screenshot:![How
    to do it...](img/B04314_A1_9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Action** menu item and then **Create Basic Task** to display the
    **Create Basic Task Wizard** dialog box, as shown in the next screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give your task a name. In this case, we will call it `List Fields from a Feature
    Class`. Click on **Next**:![How to do it...](img/B04314_A1_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a trigger for when the task should be executed. This can, and often will
    be a time-based trigger, but there can also be other types of triggers, such as
    a user login or computer start. In this case, let's just select **Daily**. Click
    on **Next**:![How to do it...](img/B04314_A1_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a start date/time as well as a recurrence interval. In the following
    screenshot, I have selected the date as `12/3/2012`, with the time as `1:00:00
    AM`, and a recurrence interval of `1` day. So, every day at 1:00 AM, this task
    will be executed. Click on **Next**:![How to do it...](img/B04314_A1_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Start a program** as the action:![How to do it...](img/B04314_A1_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to your script and add the parameters. Click on **Next**:![How to do
    it...](img/B04314_A1_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish** to add a task to the scheduler:![How to do it...](img/B04314_A1_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tasks should now be displayed in the list of active tasks:![How to do it...](img/B04314_A1_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Windows task scheduler keeps track of all the active tasks and handles the
    execution of these tasks when the prescribed trigger is fired. In this recipe,
    we have scheduled our task to execute each day at 1:00 AM. At this time, the batch
    file we created will be triggered and the arguments we specified when creating
    the task will be passed into the script. Using the scheduler to automatically
    execute geoprocessing tasks after hours, without the need for GIS staff to interact
    with the scripts gives you more flexibility and increases your efficiency. You
    might also want to consider logging the errors in your Python scripts to a log
    file for more information about specific problems.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B. Five Python Recipes Every GIS Programmer Should Know
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from a delimited text file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending e-mails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving files from an FTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ZIP files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading XML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to write scripts that perform general purpose
    tasks with Python. Tasks, such as reading and writing delimited text files, sending
    e-mails, interacting with FTP servers, creating `.zip` files, and reading and
    writing JSON and XML files, are common. Every GIS programmer should know how to
    write Python scripts that incorporate these functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from a delimited text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File handling with Python is a very important topic for GIS programmers. Text
    files have been used as an interchange format to exchange data between systems.
    They are simple, cross-platform, and easy to process. Comma and tab-delimited
    text files are among the most commonly used formats for text files, so we'll take
    an extensive look at the Python tools available to process these files. A common
    task for GIS programmers is to read comma-delimited text files containing *x*
    and *y* coordinates, along with other attribute information. This information
    is then converted into GIS data formats, such as shapefiles or geodatabases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use Python's built-in file processing functionality, you must first open
    the file. Once open, data within the file is processed using functions provided
    by Python, and finally, the file is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always remember to close the file when you're done. Python does not necessarily
    close the files for you, so it is possible that you could run out of resources
    or overwrite something. Also, some operating system platforms won't let the same
    file be simultaneously open for read-only and writing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to open, read, and process a comma-delimited
    text file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Python script that reads a comma-delimited text
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `C:\ArcpyBook\data` folder, you will find a file called `N_America.A2007275.txt`.
    Open this file in a text editor. It should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This file contains data related to wildfire incidents that was derived from
    a satellite sensor from a single day in 2007\. Each row contains latitude and
    longitude information for the fire along with additional information, including
    the date and time, satellite type, confidence value, and other details. In this
    recipe, you are going to pull out only the latitude, longitude, and confidence
    value. The first item contains the latitude, the second contains longitude, and
    the final value contains the confidence value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open **IDLE** and create a file called `C:\ArcpyBook\Appendix2\ReadDelimitedTextFile.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the Python `open()` function to open the file in order to read it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `for` loop to iterate all the rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `split()` function to split the values into a list, using a comma as
    the delimiter. The list will be assigned to a variable called `lstValues`. Make
    sure that you indent this line of code inside the for loop you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the index values that reference latitude, longitude, and confidence values,
    create new variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the values of each with the `print` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`ReadDelimitedTextFile.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's `open()` function creates a file object, which serves as a link to
    a file residing on your computer. You must call the `open()` function on a file
    before reading or writing data in a file. The first parameter for the `open()`
    function is a path to the file you'd like to open. The second parameter of the
    `open()` function corresponds to a mode, which is typically read (`r`), write
    (`w`), or append (`a`). A value of `r` indicates that you'd like to open the file
    for read-only operations, while a value of `w` indicates that you'd like to open
    the file for write operations. If the file you open in write mode already exists,
    it will overwrite any existing data in the file, so be careful when using this
    mode. Append (`a`) mode will open a file for write operations, but instead of
    overwriting any existing data, it will append data to the end of the file. So,
    in this recipe, we have opened the `N_America.A2007275.txt` file in read-only
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `for` loop, which is used to loop through each of the values in
    the text file one line at a time, the `split()` function is used to create a list
    object from a line of text that is delimited in some way. Our file is comma-delimited,
    so we can use `split(",")`. You can also split based on other delimiters, such
    as tabs, spaces, or any other delimiter. This new list object created by `split()`
    is stored in a variable called `lstValues`. This variable contains each of the
    wildfire values. This is illustrated in the following screenshot. You''ll notice
    that latitude is located in the first position, longitude is located in the second
    position, and so on. Lists are zero-based:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04314_A2_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the index values (which references latitude, longitude, and confidence
    values), we create new variables called `latitude`, `longitude`, and `confid`.
    Finally, we print each of the values. A more robust geoprocessing script might
    write this information into a feature class using an `InsertCursor` object. We
    actually did this in a previous recipe in [Chapter 8](ch08.html "Chapter 8. Using
    the ArcPy Data Access Module with Feature Classes and Tables"), *Using the ArcPy
    Data Access Module with Feature Classes and Tables*.
  prefs: []
  type: TYPE_NORMAL
- en: It would be possible to use the `readlines()` function to read the entire contents
    of the file into a Python list, which could then be iterated. Each row in the
    text file will be a unique value in the list. Since this function reads the entire
    file into a list, you need to use this method with caution, as large files can
    cause significant performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to instances of reading files, there are a number of methods that you
    can use to write data to a file. The `write()` function is probably the easiest
    to use. It takes a single string argument and writes it to a file. The `writelines()`
    function can be used to write the contents of a list structure to a file. Before
    writing data to a text file, you will need to open the file in either a write
    or append mode.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be occasions when you may need to send an e-mail from a Python script.
    An example of this might be an alert for the successful completion or errors incurred
    in a long-running geoprocessing operation. On these and other occasions, sending
    an e-mail can be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending an e-mail through a Python script will require you to have access to
    a mail server. This can be a public e-mail service, such as Yahoo, Gmail, or others.
    It can also use outgoing mail servers that is configured with applications, such
    as Microsoft Outlook. In either case, you'll need to know the host name and port
    of the e-mail server. The Python `smtplib` module is used to create connections
    to the mail server and to send e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `email` module contains a `Message` class that represents e-mail
    messages. Each message contains both headers and a body. This class can't be used
    to send e-mails, it just handles its object representation. In this recipe, you'll
    learn how to use the `smtp` class to send e-mails containing an attachment through
    your script. The `Message` class can parse a stream of characters or a file containing
    an e-mail by using either the `message_from_file()` or `message_from_string()`
    functions. Both will create a new `Message` object. The body of the mail can be
    obtained by calling `Message.getpayload()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using the Google Mail service for this exercise. If you already have
    a Gmail account, then simply provide your username and password as the values
    for these variables. If you don't have a Gmail account, you'll need to create
    one or use a different mail service to complete this exercise. Gmail accounts
    are free. Google may block attempts to send an e-mail through scripts, so be aware
    that this may not work as expected if you're using Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a script that can send e-mails:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and create a file called `C:\ArcpyBook\Appendix2\SendEmail.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to send e-mails with attachments, you''re going to need to import
    the `smtplib` module along with the `os` module, and several classes from the
    e-mail module. Add the following import statements to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following variables and assign your Gmail username and password
    as the values. Keep in mind that this method of e-mailing from your Python script
    can invite problems, as it requires that you include your username and password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that including an e-mail `username` and `password` in a script is not secure
    so you wouldn't want to include these in a production script. There are ways of
    encrypting these values but that is beyond the scope of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new Python function called `mail()`. This function will accept four
    parameters: `to`, `subject`, `text`, and `attach`. Each of these parameters should
    be self-explanatory. Create a new `MIMEMultipart` object and assign the `from`,
    `to`, and `subject` keys. You can also attach the text of the e-mail to this new
    `msg` object using `MIMEMultipart.attach()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach the file to the e-mail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new SMTP object that references the Google Mail service, passes in
    the username and password to connect to the mail services, sends the e-mail, and
    closes the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `mail()` function, passing in the recipient of the e-mail, a subject
    for the e-mail, the text of the e-mail, and the attachment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`SendEmail`.py
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the script. For testing, I used my personal Yahoo account as the
    recipient. You'll notice that my inbox has a new message from my Gmail account;
    also, notice the attachment:![How to do it…](img/B04314_A2_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first parameter passed into the `mail()` function is the e-mail address
    that will receive the e-mail. This can be any valid e-mail address, but you'll
    want to supply a mail account that you can actually check, so that you can make
    sure your script runs correctly. The second parameter is just the subject line
    of the e-mail. The third parameter is the text. The final parameter is the name
    of a file that will be attached to the e-mail. Here, I've simply defined that
    the `bc_pop1996.csv` file should be attached. You can use any file you have access
    to, but you may want to just use this file for testing.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new `MIMEMultipart` object inside the `mail()` function, and
    assign the `from`, `to`, and `subject` keys. You can also attach the text of the
    e-mail to this new `msg` object using `MIMEMultipart.attach()`. The `bc_pop1996.csv`
    file is then attached to the e-mail using a `MIMEBase` object and attached to
    the e-mail using `msg.attach(part)`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've examined how a basic text e-mail can be sent. However,
    we want to send a more complex e-mail message that contains text and an attachment.
    This requires the use of MIME messages, which provide the functionality to handle
    multipart e-mails. MIME messages need boundaries between multiple parts of an
    e-mail along with extra headers to specify the content being sent. The `MIMEBase`
    class is an abstract subclass of `Message` and enables this type of an e-mail
    to be sent. Since it is an abstract class, you can't create actual instances of
    this class. Instead, you use one of the subclasses, such as `MIMEText`. The last
    step of the `mail()` function is to create a new SMTP object that references the
    Google Mail service, passes in the username and password in order to connect to
    the mail services, sends the e-mail, and then closes the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving files from an FTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieving files from an FTP server for processing is a very common operation
    for GIS programmers and can be automated with a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connecting to an FTP server and downloading a file is accomplished through the
    `ftplib` module. A connection to an FTP server is created through the FTP object,
    which accepts a host, username, and password to create the connection. Once a
    connection has been opened, you can then search for and download files.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will connect to the **National Interagency Fire Center Incident**
    FTP site and download a PDF file for a wildfire in Colorado. Before you run the
    following script, you will need to create a username/password through [http://gis.nwcg.gov/data_nifcftp.html](http://gis.nwcg.gov/data_nifcftp.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a script that connects to an FTP server and downloads
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and create a file called `C:\ArcpyBook\Appendix2\ftp.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll be connecting to an FTP server at the NIFC. Visit their website at [http://gis.nwcg.gov/data_nifcftp.html](http://gis.nwcg.gov/data_nifcftp.html)
    for more information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `ftplib`, `os`, and `socket` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following variables that define the URL, directory, and filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code block to create a connection. If there is a connection
    error, a message will be generated. If the connection was successful, a success
    message will be printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code block to anonymously log in to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code block to change to the directory specified in our `DIRN`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `FTP.retrbinary()` function to retrieve the PDF file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you disconnect from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`ftp`.py
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. If everything is successful, you should see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check your `C:\ArcpyBook\Appendix2` directory for the file. By default, FTP
    will download files to the current working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To connect to an FTP server, you need to know the URL. You also need to know
    the directory and filename for the file that will be downloaded. In this script,
    we have hardcoded this information, so that you can focus on implementing the
    FTP-specific functionality. Using this information, we then created a connection
    to the NIFC FTP server. This is done through the `ftplib.FTP()` function, which
    accepts a URL to the host.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you'll need to obtain a username/password to log in and download
    the data. Once logged in, the script then changes directories from the root of
    the FTP server to the path defined in the `DIRN` variable. This was accomplished
    with the `cwd(<path>)` function. The PDF file was retrieved by using the `retrbinary()`
    function. Finally, you will want to close your connection to the FTP server when
    you're done. This is done with the `quit()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of additional FTP-related methods that you can use to perform
    various actions. Generally, these can be divided into directory-level operations
    and file-level operations. Directory level methods include the `dir()` method
    to obtain a list of files in a directory, `mkd()` to create a new directory, `pwd()`
    to get the current working directory, and `cwd()` to change the current directory.
    Keep in mind that the actions you attempt to perform through your script will
    be governed by the privileges assigned to your account, so you may not be able
    to successfully execute every method that I mention.
  prefs: []
  type: TYPE_NORMAL
- en: The `ftplib` module also includes various methods to work with files. You can
    upload and download files in a binary or plain text format. The `retrbinary()`
    and `storbinary()` methods are used to retrieve and store binary files, respectively.
    Plain text files can be retrieved and stored using `retrlines()` and `storlines()`.
  prefs: []
  type: TYPE_NORMAL
- en: There are several others methods on the FTP class that you should be aware of.
    Deleting a file can be done with the `delete()` method, while renaming a file
    can be accomplished with `rename()`. You can also send commands to the FTP server
    through the `sendcmd()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ZIP files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GIS often requires the use of large files that will be compressed into a `.zip`
    format for ease of sharing. Python includes a module that you can use to decompress
    and compress files in this format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ZIP is a common compression and archive format and is implemented in Python
    through the `zipfile` module. The `ZipFile` class can be used to create, read,
    and write `.zip` files. To create a new `.zip` file, simply provide the filename
    along with a mode as `w`, which indicates that you want to write data to the file.
    In the following code example, we are creating a `.zip` file called `datafile.zip`.
    The second parameter, `w`, indicates that a new file will be created. A new file
    will be created or an existing file with the same name will be truncated in the
    write mode. An optional compression parameter can also be used when creating the
    file. This value can be set to either `ZIP_STORED` or `ZIP_DEFLATED`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you will use Python to create file, add files, and apply compression
    to a `.zip` file. You'll be archiving all the shapefiles located in the `C:\ArcpyBook\data`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create a script that builds a `.zip` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and create a script called `C:\ArcpyBook\Appendix2\CreateZipfile.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `zipfile` and `os` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `.zip` file called `shapefiles.zip` in write mode and add a compression
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll use the `os.listdir()` function to create a list of files in the
    data directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through a list of all the files and write to the `.zip` file if the file
    ends with `shp`, `dbf`, or `shx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Print out a list of all the files that were added to the ZIP archive. You can
    use the `ZipFile.namelist()` function to create a list of files in the archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `.zip` archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`CreateZipfile_Step1`.py
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Windows Explorer, you should be able to see the output `.zip` file, as shown
    in the following screenshot. Note the size of archive. This file was created without
    compression:![How to do it…](img/B04314_A2_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''re going to create a compressed version of the `.zip` file to see
    the difference. Make the following changes to the line of code that creates the
    `.zip` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`CreateZipfile_Step2`.py
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and rerun the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the size of the new `shapefiles2.zip` file that you just created.
    Note the decreased size of the file due to compression:![How to do it…](img/B04314_A2_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you created a new `.zip` file called `shapefiles.zip` in write
    mode. In the first iteration of this script, you didn't compress the contents
    of the file. However, in the second iteration, you did it by using the `DEFLATED`
    parameter that was passed into the constructor for the `ZipFile` object. The script
    then obtained a list of files in the data directory and looped through each of
    the files. Each file that has an extension of `.shp`, `.dbf`, or `.shx` is then
    written to the archive file, using the `write()` function. Finally, the names
    of each of the files written to the archive are printed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The contents of an existing file stored in a ZIP archive can be read by using
    the `read()` method. The file should first be opened in a read mode, and then
    you can call the `read()` method passing a parameter that represents the filename
    that should be read. The contents of the file can then be printed to the screen,
    written to another file, or stored as a list or dictionary variable.
  prefs: []
  type: TYPE_NORMAL
- en: Reading XML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML files were designed as a way to transport and store data. They are platform-independent
    since the data is stored in a plain text file. Although similar to HTML, XML differs
    from HTML since the former is designed for display purposes, whereas XML data
    is designed for data. XML files are sometimes used as an interchange format for
    GIS data that is going between various software systems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XML documents have a tree-like structure that is composed of a `root` element,
    `child` elements, and element attributes. Elements are also called **nodes**.
    All XML files contain a `root` element. This `root` element is the parent to all
    other elements or child nodes. The following code example illustrates the structure
    of an XML document. Unlike HTML files, XML files are case sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python provides several programming modules that you can use to process XML
    files. The module that you use should be determined by the module that is right
    for the job. Don't try to force a single module to do everything. Each module
    has specific functions that they are good at performing.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to read data from an XML file using the `nodes`
    and `element` attributes that are a part of the document.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways that you can access nodes within an XML document.
    Perhaps, the easiest way to do so is to find nodes by tag name and then through
    walk the tree containing a list of the child nodes. Before doing so, you'll want
    to parse the XML document with the `minidom.parse()` method. Once parsed, you
    can then use the `childNodes` attribute to obtain a list of all the `child` nodes
    starting at root of the tree. Finally, you can search the nodes by tag names with
    the `getElementsByTagName(tag)` function, which accepts a tag name as an argument.
    This will return a list of all `child` nodes that are associated with the tag.
  prefs: []
  type: TYPE_NORMAL
- en: You can also determine if a node contains an attribute by calling `hasAttribute(name)`,
    which will return a `true`/`false` value. Once you've determined that an attribute
    exists, a call to `getAttribute(name)` will obtain the value for the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will parse an XML file and pull out values associated
    with a particular element (node) and attribute. We'll load an XML file containing
    wildfire data. In this file, we'll look for the `<fire>` node and the `address`
    attribute for each of these nodes. The addresses will be printed out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open **IDLE** and create a script called `C:\ArcpyBook\Appendix2\XMLAccessElementAttribute.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `WitchFireResidenceDestroyed.xml` file will be used. The file is located
    in your `C:\ArcpyBook\Appendix2` folder. You can see a sample of its contents,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `minidom` from `xml.dom`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parse the XML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a list of nodes from the XML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a list of all the `<fire>` nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through the list of elements, test for the existence of the `address`
    attribute and print the value of the attribute, if it exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`XMLAccessElementAttribute`.py
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loading an XML document into your script is probably the most basic thing you
    can do with XML files. You can use the `xml.dom` module to do this through the
    use of the `minidom` object. The `minidom` object has a method called `parse()`,
    which accepts a path to an XML document and creates a **document object model**
    (**DOM**) tree object from the `WitchFireResidenceDestroyed.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `childNodes` property of the DOM tree generates a list of all the nodes
    in the XML file. You can then access each of the nodes using the `getElementsByTagName()`
    method. The final step is to loop through each of the `<fire>` nodes contained
    within the `eList` variable. For each node, we then check for the `address` attribute
    with the `hasAttribute()` method, and if it exists, we call the `getAttribute()`
    function and print the address to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will be times when you will need to search an XML document for a specific
    text string. This requires the use of the `xml.parsers.expat` module. You'll need
    to define a search class derived from the basic `expat` class and then create
    an object from this class. Once created, you can call the `parse()` method on
    the `search` object to search for data. Finally, you can then search the nodes
    by tag names with the `getElementsByTagName(tag)` function, which accepts a tag
    name as an argument. This will return a list of all child nodes that are associated
    with the tag.
  prefs: []
  type: TYPE_NORMAL
