<html><head></head><body><div><h1 class="header-title">Python and Geographic Information Systems</h1>
                
            
            
                
<p>This chapter will focus on applying Python to functions that are typically performed by a <strong>geographic information system</strong> (<strong>GIS</strong>) such as QGIS or ArcGIS. These functions are the heart and soul of geospatial analysis. We will continue to use as few external dependencies as possible outside of Python itself so that you have tools that are as reusable as possible in different environments. In this book, we separate GIS analysis and remote sensing from a programming perspective, which means that, in this chapter, we'll mostly focus on vector data.</p>
<p>As with the other chapters in this book, the items presented here are core functions that serve as building blocks that you can recombine to solve challenges that you will encounter beyond this book. The topics in this chapter include the following:</p>
<ul>
<li>Measuring distance</li>
<li>Converting coordinates</li>
<li>Reprojecting vector data</li>
<li>Measuring area</li>
<li>Editing shapefiles</li>
<li>Selecting data from within larger datasets</li>
<li>Creating thematic maps</li>
<li>Using spreadsheets</li>
<li>Conversion of non-GIS data types</li>
<li>Geocoding</li>
<li>Multiprocessing</li>
</ul>
<p class="mce-root"/>
<p>This chapter contains many code samples. In addition to the text, code comments are included as guides within the samples. This chapter covers more ground than any other chapter in this book. It covers everything from measuring the earth to editing data and creating maps, to using scaled up multiprocessing for faster analysis. By the end of this chapter, you'll be a geospatial analyst ready to learn about the more advanced techniques in the rest of this book.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>For this chapter, you will require the following:</p>
<ul>
<li>Python 3.7</li>
<li>The Python UTM library</li>
<li>The Python OGR library</li>
<li>The Python Shapefile library</li>
<li>The Python Fiona library</li>
<li>The Python PNGCanvas library</li>
<li>The Python Pillow library (Python Imaging Library)</li>
<li>The Python Folium library</li>
<li>The Python Pymea library</li>
<li>The Python Geocoder library</li>
<li>The Python GeoPy library</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Measuring distance</h1>
                
            
            
                
<p>The essence of geospatial analysis is discovering the relationships of objects on Earth. Items that are closer together tend to have a stronger relationship than those that are farther apart. This concept is known as <strong>Tobler's First Law of Geography</strong>. Therefore, measuring distance is a critical function of geospatial analysis.</p>
<p class="mce-root"/>
<p>As we have learned, every map is a model of the Earth and they are all wrong to some degree. For this reason, measuring the accurate distance between two points on the Earth while sitting in front of a computer is impossible. Even professional land surveyors (who go out in the field with both traditional sighting equipment and very precise GPS equipment) fail to account for every anomaly in the Earth's surface between point A and point B. So, to measure distance, we must look at the following questions:</p>
<ul>
<li>What are we measuring?</li>
<li>How much are we measuring?</li>
<li>How much accuracy do we need?</li>
</ul>
<p>Now, to calculate distance, there are three models of the Earth that we can use:</p>
<ul>
<li>Flat plane</li>
<li>Spherical</li>
<li>Ellipsoid</li>
</ul>
<p>In the flat plane model, standard Euclidean geometry is used. The Earth is considered a flat plane with no curvature, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/abac7e8a-364b-4d65-afb6-545b8e4afbb6.png" style="width:27.08em;height:15.50em;" width="1425" height="813"/></p>
<p>This model makes math quite simple because you work with straight lines. The most common format for geospatial coordinates is decimal degrees. However, decimal degree coordinates are reference measurements on a sphere taken as angles – between the longitude and the prime meridian—and the latitude and equator. Furthermore, the lines of longitude converge toward zero at the poles. The circumference of each line of latitude becomes smaller toward the poles as well. These facts mean decimal degrees are not a valid coordinate system for Euclidean geometry, which uses infinite planes.</p>
<p>Map projections attempt to simplify the issues of dealing with a 3D ellipsoid in a 2D plane, either on paper or on a computer screen. As we discussed in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, map projections flatten a round model of the Earth to a plane and introduce distortion in exchange for the convenience of a map. Once this projection is in place and decimal degrees are traded for a Cartesian coordinate system with <em>x</em> and <em>y</em> coordinates, we can use the simplest forms of Euclidean geometry—namely, the Pythagorean theorem.</p>
<p>At a large enough scale, a sphere or ellipsoid like the Earth appears more like a plane than a sphere. In fact, for centuries, everyone thought the Earth was flat! If the difference in degrees of longitude is small enough, you can often get away with using Euclidean geometry and then converting the measurements into meters, kilometers, or miles. This method is generally not recommended but the decision is ultimately up to you and your requirements for accuracy as an analyst.</p>
<p>The spherical model approach tries to better approximate reality by avoiding the problems resulting from smashing the Earth onto a flat surface. As the name suggests, this model uses a perfect sphere for representing the Earth (similar to a physical globe), which allows us to work with degrees directly. This model ignores the fact that the Earth is really more of an egg-shaped ellipsoid with varying degrees of thickness in its crust. But by working with distance on the surface of a sphere, we can begin to measure longer distances with more accuracy. The following screenshot illustrates this concept:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0f4a15ce-8515-4c9a-a240-1086fc87eb42.png" style="width:18.50em;height:18.50em;" width="1020" height="1020"/></p>
<p>Using the ellipsoid model of the Earth, analysts strive for the best model of the Earth's surface. There are several ellipsoid models, which are called datums. A <strong>datum</strong> is a set of values that define an estimated shape for the Earth, also known as a <strong>geodetic system</strong>. Like any other georeferencing system, a datum can be optimized for a localized area. The most commonly used datum is called <strong>WGS84</strong>, which is designed for global use. You should be aware that WGS84 is occasionally updated as assessment techniques and technology improves. The most recent revision occurred in 2004.</p>
<p>In North America, the NAD83 datum is used to optimize referencing over the continent. In the Eastern Hemisphere, the <strong>European Terrestrial Reference System 1989</strong> (<strong>ETRS89</strong>) is used more frequently. ETRS89 is fixed to the stable part of the <strong>Eurasian Plate</strong>. Maps of Europe based on ETRS89 are immune to continental drift, which changes up to 2.5 cm per year as the Earth's crust shifts.</p>
<p>An ellipsoid does not have a constant radius from the center. This fact means the formulas used in the spherical model of the Earth begin to have issues in the ellipsoid model. Though not a perfect approximation, it is much closer to reality than the spherical model.</p>
<p>The following screenshot shows a generic ellipsoid model denoted by a black line contrasted against a representation of the Earth's uneven crust, which is using a red line to represent the geoid. Although we will not use it for these examples, another model is the geoid model. The geoid is the most precise and accurate model of the Earth, which is based on the Earth's surface with no influencing factors except gravity and rotation. The following diagram is a representation of a geoid, ellipsoid, and spherical model to illustrate their differences:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2c85e437-d07d-40f5-9a93-e62c78ed294b.png" style="width:24.00em;height:20.25em;" width="1298" height="1101"/></p>
<p>Understanding these models of the Earth is critical to everything else in this book because we're modeling the Earth, after all.</p>
<p>Now that we've discussed these different models of the Earth and the issues with measuring them, let's look at some solutions using Python.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the Pythagorean theorem</h1>
                
            
            
                
<p>We'll start by measuring with the simplest method, that is, the Pythagorean theorem, also known as Euclidean distance. If you remember your geometry lessons from school, the Pythagorean theorem asserts the following:</p>
<pre>a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></pre>
<p>In this assertion, the variables <em>a</em>, <em>b</em>, and <em>c</em> are all sides of a triangle. You can solve any one side if you know the other two.</p>
<p>In this example, we'll start with two projected points in the <strong>Mississippi Transverse Mercator</strong> (<strong>MSTM</strong>) projection. The units of this projection are in meters. The <em>x</em>-axis locations are measured from the central meridian defined by the westernmost location in the state. The <em>y</em>-axis is defined from the NAD83 horizontal datum. The first point, defined as (<em>x</em>1,<em>y</em>1), represents Jackson, the state capital of Mississippi. The second point, defined as (<em>x</em>2,<em>y</em>2) represents the city of Biloxi, which is a coastal town, as shown in the following illustration:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c6a11c12-f5cb-4e57-9386-3005535b2ed6.png" style="width:18.00em;height:22.83em;" width="453" height="577"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the following example, the double-asterisk (**) in Python is the syntax for exponents, which we'll use to square the distances.</p>
<p>We'll import the Python math module for its square root function called <kbd>sqrt()</kbd>. Then, we'll calculate the <em>x</em>-axis and <em>y</em>-axis distances. Finally, we'll use these variables to execute the Euclidean distance formula to get the distance across the bounding box in meters from an <em>x</em>, <em>y</em> origin, which will be used in the MSTM projection:</p>
<pre>import math<br/># First point<br/>x1 = 456456.23<br/>y1 = 1279721.064<br/># Second point<br/>x2 = 576628.34<br/>y2 = 1071740.33<br/># X distance<br/>x_dist = x1 - x2<br/># Y distance<br/>y_dist = y1 - y2<br/># Pythagorean theorem<br/>dist_sq = x_dist**2 + y_dist**2<br/>distance = math.sqrt(dist_sq)<br/>print(distance)<br/># 240202.66</pre>
<p>So, the distance is approximately 240,202 meters, which is around 240.2 kilometers or 150 miles. This calculation is reasonably accurate because this projection is optimized for measuring distance and area in Mississippi using Cartesian coordinates.</p>
<p>We can also measure distance using decimal degrees, but we must perform a few additional steps. To measure using degrees, we must convert the angles into radians, which account for the curved surface distance between the coordinates. We'll also multiply our output in radians times the radius of the Earth in meters to convert back from radians.</p>
<p>You can read more about radians at <a href="http://en.wikipedia.org/wiki/Radian">http://en.wikipedia.org/wiki/Radian</a>.</p>
<p>We'll perform this conversion using the Python <kbd>math.radians()</kbd> method in the following code when we calculate the <em>x</em> and <em>y</em> distances:</p>
<pre>import math<br/>x1 = -90.21<br/>y1 = 32.31<br/>x2 = -88.95<br/>y2 = 30.43<br/>x_dist = math.radians(x1 - x2)<br/>y_dist = math.radians(y1 - y2)<br/>dist_sq = x_dist**2 + y_dist**2<br/>dist_rad = math.sqrt(dist_sq)<br/>dist_rad * 6371251.46<br/># 251664.46</pre>
<p>Okay, so this time, we came up with around 251 kilometers, which is 11 kilometers more than our first measurement. So, as you can see, your choice of measurement algorithm and Earth model can have significant consequences. Using the same equation, we come up with radically different answers, depending on our choice of coordinate system and Earth model.</p>
<p>You can read more about Euclidean distance at <a href="http://mathworld.wolfram.com/Distance.html">http://mathworld.wolfram.com/Distance.html</a>.</p>
<p>Let's check out the haversine formula next.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the haversine formula</h1>
                
            
            
                
<p>Part of the problem with using the Pythagorean theorem to measure distance on the Earth, which is a sphere, is the concept of great circle distance. A great circle is the shortest distance between two points on a sphere. Another important feature that defines a great circle is that the circle, if followed all of the way around the sphere, will bisect the sphere into two equal halves, as shown in the following Wikipedia illustration:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2e646971-a86b-466e-8cc3-1f4241fcdff7.png" style="width:21.75em;height:22.08em;" width="573" height="582"/></p>
<p>So, what is the right way to measure a line on a curved sphere? The most popular method is to use the <strong>haversine formula</strong>, which uses trigonometry to calculate the Great Circle distance using coordinates defined in decimal degrees as input. The haversine formula is <em>haversine(θ) = sin²(θ/2)</em>, where θ is the central angle between two points on a sphere. Once again, we'll convert the axis distances from degrees into radians before we apply the formula, just like in the previous example. But this time, we'll also convert the latitude (<em>y</em>-axis) coordinates into radians separately:</p>
<pre>import math<br/>x1 = -90.212452861859035<br/>y1 = 32.316272202663704<br/>x2 = -88.952170968942525<br/>y2 = 30.438559624660321<br/>x_dist = math.radians(x1 - x2)<br/>y_dist = math.radians(y1 - y2)<br/>y1_rad = math.radians(y1)<br/>y2_rad = math.radians(y2)<br/>a = math.sin(y_dist/2)**2 + math.sin(x_dist/2)**2 \<br/> * math.cos(y1_rad) * math.cos(y2_rad)<br/>c = 2 * math.asin(math.sqrt(a))<br/>distance = c * 6371  # kilometers<br/>print(distance)<br/># 240.63</pre>
<p>Wow! We get 240.6 kilometers using the haversine formula, compared to 240.2 kilometers using the optimized and more accurate projection. This difference is less than half a kilometer, which is not bad for a distance calculation of two cities 150 miles apart. The haversine formula is the most commonly used distance measuring formula because it is relatively lightweight from a coding perspective and reasonably accurate in most cases. It is considered to be accurate to within about a meter.</p>
<p>To summarize what we've learned so far, most of the point coordinates you encounter as an analyst are in unprojected decimal degrees. So, your options for measurement are as follows:</p>
<ul>
<li>Reproject to a distance-accurate Cartesian projection and measure.</li>
<li>Just use the haversine formula and see how far it takes you for your analysis.</li>
<li>Use the even more precise Vincenty formula.</li>
</ul>
<p>That's right! There's another formula that seeks to provide an even better measurement than haversine.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the Vincenty formula</h1>
                
            
            
                
<p>So, we've examined distance measurement using the Pythagorean theorem (flat Earth model) and the haversine formula (spherical Earth model). The Vincenty formula accounts for the ellipsoid model of the Earth. And if you are using a localized ellipsoid, it can be accurate to much less than a meter.</p>
<p>In the following implementation of this formula, you can change the semi-major axis value and flattening ratio to fit the definition of any ellipsoid. Let's see what the distance is when we measure using the Vincenty formula on the NAD83 ellipsoid in the following example:</p>
<ol>
<li>First, we will import the <kbd>math</kbd> module, which allows us to work in radians, and the other <kbd>math</kbd> functions we'll need:</li>
</ol>
<pre style="padding-left: 60px">import math</pre>
<ol start="2">
<li>Now, we need to set up our variables, including the variable that holds our distance value, the two points we're measuring, the constants describing the Earth, and the derivative formulas we need:</li>
</ol>
<pre style="padding-left: 60px">distance = None<br/>x1 = -90.212452861859035<br/>y1 = 32.316272202663704<br/>x2 = -88.952170968942525<br/>y2 = 30.438559624660321<br/># Ellipsoid Parameters<br/># Example is NAD83<br/>a = 6378137  # semi-major axis<br/>f = 1/298.257222101  # inverse flattening<br/>b = abs((f*a)-a)  # semi-minor axis<br/>L = math.radians(x2-x1)<br/>U1 = math.atan((1-f) * math.tan(math.radians(y1)))<br/>U2 = math.atan((1-f) * math.tan(math.radians(y2)))<br/>sinU1 = math.sin(U1)<br/>cosU1 = math.cos(U1)<br/>sinU2 = math.sin(U2)<br/>cosU2 = math.cos(U2)<br/>lam = L</pre>
<ol start="3">
<li>Now begins the Vincenty formula. There's just no easy way to do this and the math is a little complicated, but it works:</li>
</ol>
<pre style="padding-left: 60px">for i in range(100):<br/>    sinLam = math.sin(lam)<br/>    cosLam = math.cos(lam)<br/>    sinSigma = math.sqrt((cosU2*sinLam)**2 +<br/>                         (cosU1*sinU2-sinU1*cosU2*cosLam)**2)<br/>    if (sinSigma == 0):<br/>        distance = 0  # coincident points<br/>        break<br/>    cosSigma = sinU1*sinU2 + cosU1*cosU2*cosLam<br/>    sigma = math.atan2(sinSigma, cosSigma)<br/>    sinAlpha = cosU1 * cosU2 * sinLam / sinSigma<br/>    cosSqAlpha = 1 - sinAlpha**2<br/>    cos2SigmaM = cosSigma - 2*sinU1*sinU2/cosSqAlpha<br/>    if math.isnan(cos2SigmaM):<br/>        cos2SigmaM = 0  # equatorial line<br/>    C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha))<br/>    LP = lam<br/>    lam = L + (1-C) * f * sinAlpha *<br/>        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma *<br/>                             (-1+2*cos2SigmaM*cos2SigmaM)))<br/>    if not abs(lam-LP)  1e-12:<br/>        break<br/>uSq = cosSqAlpha * (a**2 - b**2) / b**2<br/>A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)))<br/>B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)))<br/>deltaSigma = B*sinSigma*(cos2SigmaM+B/4 *<br/>(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM) - B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma) * (-3+4*cos2SigmaM*cos2SigmaM)))<br/>s = b*A*(sigma-deltaSigma)</pre>
<p>Finally, after all that, we have our distance:</p>
<pre>distance = s<br/>print(distance)<br/># 240237.66693880095</pre>
<p>Using the Vincenty formula, our measurement came to 240.1 kilometers, which is only 100 meters off from our projected measurement using Euclidean distance. Impressive! While many times more mathematically complex than the haversine formula, you can see that it is also much more accurate.</p>
<p>The pure Python geopy module includes an implementation of the Vincenty formula and has the ability to geocode locations by turning place names into latitude and longitude coordinates: <a href="http://geopy.readthedocs.org/en/latest/">http://geopy.readthedocs.org/en/latest/</a>.</p>
<p>The points that were used in these examples are reasonably close to the equator. As you move toward the poles or work with larger distances or extremely small distances, the choices you make become increasingly more important. If you're just trying to make a radius around a city to select locations for a marketing campaign promoting a concert, then an error of a few kilometers is probably okay. However, if you're trying to estimate fuel required for an airplane to make a flight between two airports, then you want to be spot on!</p>
<p>If you'd like to learn more about issues with measuring distance and direction, and how to work around them with programming, visit the following site: <a href="http://www.movable-type.co.uk/scripts/latlong.html">http://www.movable-type.co.uk/scripts/latlong.html</a>.</p>
<p>On this site, Chris Veness goes into great detail on this topic and provides online calculators, as well as examples written in JavaScript, which can easily be ported to Python. The Vincenty formula implementation that we just saw is ported from the JavaScript on this site.</p>
<p>You can see the full pure mathematical notation for the Vincenty formula here: <a href="https://en.wikipedia.org/wiki/Vincenty%27s_formulae">https://en.wikipedia.org/wiki/Vincenty%27s_formulae</a>.</p>
<p>Now that we know how to calculate distance, we need to understand how to calculate the direction of a line to relate objects on Earth by distance and location for geospatial analysis.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Calculating line direction</h1>
                
            
            
                
<p>In addition to distance, you will often want to know the bearing of a line between its endpoints. We can calculate this line direction from one of the points using only the Python <kbd>math</kbd> module:</p>
<ol>
<li>First, we import the <kbd>math</kbd> functions we'll need:</li>
</ol>
<pre style="padding-left: 60px">from math import atan2, cos, sin, degrees</pre>
<ol start="2">
<li>Next, we set up some variables for our two points:</li>
</ol>
<pre style="padding-left: 60px">lon1 = -90.21<br/>lat1 = 32.31<br/>lon2 = -88.95<br/>lat2 = 30.43</pre>
<ol start="3">
<li>Next, we'll calculate the angle between the two points:</li>
</ol>
<pre style="padding-left: 60px">angle = atan2(cos(lat1)*sin(lat2)-sin(lat1) * \<br/>  cos(lat2)*cos(lon2-lon1), sin(lon2-lon1)*cos(lat2))</pre>
<ol start="4">
<li>Finally, we'll calculate the bearing of the line in degrees:</li>
</ol>
<pre style="padding-left: 60px">bearing = (degrees(angle) + 360) % 360<br/>print(bearing)<br/>309.3672990606595</pre>
<p>Sometimes, you end up with a negative bearing value. To avoid this issue, we add <kbd>360</kbd> to the result to avoid a negative number and use the Python modulo operator to keep the value from climbing to over <kbd>360</kbd>.</p>
<p>The <kbd>math</kbd> in the angle calculation is reverse engineering a right triangle and then figuring out the acute angle of the triangle. The following URL provides an explanation of the elements of this formula, along with an interactive example at the end: <a href="http://www.movable-type.co.uk/scripts/latlong.html">https://www.mathsisfun.com/sine-cosine-tangent.html</a>.</p>
<p>We now know how to calculate the location of features on the Earth. Next, we'll learn how to integrate data from different sources, starting with coordinate conversion.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding coordinate conversion</h1>
                
            
            
                
<p>Coordinate conversion allows you to convert point coordinates between different coordinate systems. When you start working with multiple datasets, you'll inevitably end up with data in different coordinate systems and projections. You can convert back and forth between two of the most common coordinate systems, UTM and geographic coordinates (latitude and longitude), using a pure Python module called <kbd>utm</kbd>. You can install it using <kbd>easy_install</kbd> or <kbd>pip</kbd> from PyPI: <a href="https://pypi.python.org/pypi/utm">https://pypi.python.org/pypi/utm</a>.</p>
<p>The <kbd>utm</kbd> module is straightforward to use. To convert from UTM into latitude and longitude, you can use the following code:</p>
<pre>import utm<br/>y = 479747.0453210057<br/>x = 5377685.825323031<br/>zone = 32<br/>band = 'U'<br/>print(utm.to_latlon(y, x, zone, band))<br/># (48.55199390882121, 8.725555729071763)</pre>
<p>The UTM zones are numbered horizontally. However, vertically, the bands of latitude are ordered by the English alphabet with a few exceptions. For example, the letters <em>A</em>, <em>B</em>, <em>Y</em>, and <em>Z</em> are used to label the Earth's poles. The letters <em>I</em> and <em>O</em> are omitted because they look too much like <em>1</em> and <em>0</em>. Letters <em>N</em> through <em>X</em> are in the Northern Hemisphere while <em>C</em> through <em>M</em> are in the Southern Hemisphere. The following screenshot, from the website <em>Atlas Florae Europaeae</em>, illustrates the UTM zones over Europe:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9c13b8e9-cba9-442b-9c94-b80f2812f216.png" style="width:24.75em;height:30.67em;" width="585" height="724"/></p>
<p>Converting from latitude and longitude is even easier. We just pass the latitude and longitude to the <kbd>from_latlon()</kbd> method, which returns a tuple with the same parameters that are accepted by the <kbd>to_latlon()</kbd> method:</p>
<pre>import utm<br/>utm.from_latlon(48.55199390882121, 8.725555729071763)<br/># (479747.04524576373, 5377691.373080335, 32, 'U')</pre>
<p>The algorithms that were used in this Python implementation are described in detail at <a href="http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM">http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM</a>.</p>
<p>Converting between UTM and latitude/longitude just scratches the surface of transforming datasets from different sources so that they can be overlaid nicely on a map. To go beyond the basics, we'll need to perform map projections. </p>
<p>Now that we know how to calculate line direction, let's see how reprojection is done.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding reprojection</h1>
                
            
            
                
<p>In GIS, reprojection is all about changing the coordinates in a dataset from one coordinate system to another. While reprojection is less common these days due to more advanced methods of data distribution, sometimes you need to reproject a shapefile. The pure Python <kbd>utm</kbd> module works for reference system conversion, but for a full reprojection, we need some help from the OGR Python API. The OGR API contained in the <kbd>osgeo</kbd> module also provides the Open Spatial Reference module, also known as <kbd>osr</kbd>, which we'll use for reprojection.</p>
<p>As an example, we'll use a point shapefile containing New York City museum and gallery locations in the Lambert conformal projection. We'll reproject it to WGS84 geographic (or un-project, it rather). You can download this zipped shapefile at <a href="https://git.io/vLbT4">https://git.io/vLbT4</a>.</p>
<p>The following minimalist script reprojects the shapefile. The geometry is transformed and then written to the new file, but the <kbd>.dbf</kbd> file is simply copied to the new name as we aren't changing it. The standard Python <kbd>shutil</kbd> module, short for shell utilities, is used to copy <kbd>.dbf</kbd>. The source and target shapefile names are variables at the beginning of the script. The target projection is also near the top, which is set using an EPSG code. The script assumes there is a <kbd>.prj</kbd> projection file, which defines the source projection. If not, you could manually define it using the same syntax as the target projection. We'll walk through projecting a dataset step by step. Each section is marked with comments:</p>
<ol>
<li>First, we import our libraries:</li>
</ol>
<pre style="padding-left: 60px">from osgeo import ogr<br/>from osgeo import osr<br/>import os<br/>import shutil</pre>
<ol start="2">
<li>Next, we define our shapefile names as variables:</li>
</ol>
<pre style="padding-left: 60px">srcName = 'NYC_MUSEUMS_LAMBERT.shp'<br/>tgtName = 'NYC_MUSEUMS_GEO.shp'</pre>
<ol start="3">
<li>Now, we create our target spatial reference using the <kbd>osr</kbd> module as EPSG code <kbd>4326</kbd>, which is WGS84 Geographic:</li>
</ol>
<pre style="padding-left: 60px">tgt_spatRef = osr.SpatialReference()<br/>tgt_spatRef.ImportFromEPSG(4326)</pre>
<ol start="4">
<li>Then, we set up our shapefile <kbd>Reader</kbd> object using <kbd>ogr</kbd> and get the spatial reference:</li>
</ol>
<pre style="padding-left: 60px">driver = ogr.GetDriverByName('ESRI Shapefile')<br/>src = driver.Open(srcName, 0)<br/>srcLyr = src.GetLayer()<br/>src_spatRef = srcLyr.GetSpatialRef()</pre>
<ol start="5">
<li>Next, we check whether our target shapefile already exists from a previous test run and delete it if it does:</li>
</ol>
<pre style="padding-left: 60px">if os.path.exists(tgtName):<br/>    driver.DeleteDataSource(tgtName)</pre>
<ol start="6">
<li>Now, we can begin building our target layer for the shapefile:</li>
</ol>
<pre style="padding-left: 60px">tgt = driver.CreateDataSource(tgtName)<br/>lyrName = os.path.splitext(tgtName)[0]<br/># Use well-known binary format (WKB) to specify geometry<br/>tgtLyr = tgt.CreateLayer(lyrName, geom_type=ogr.wkbPoint)<br/>featDef = srcLyr.GetLayerDefn()<br/>trans = osr.CoordinateTransformation(src_spatRef, tgt_spatRef)</pre>
<ol start="7">
<li>Next, we can loop through the features in our source shapefile, reproject them using the <kbd>Transform()</kbd> method, and add them to the new shapefile:</li>
</ol>
<pre style="padding-left: 60px">srcFeat = srcLyr.GetNextFeature()<br/>while srcFeat:<br/>    geom = srcFeat.GetGeometryRef()<br/>    geom.Transform(trans)<br/>    feature = ogr.Feature(featDef)<br/>    feature.SetGeometry(geom)<br/>    tgtLyr.CreateFeature(feature)<br/>    feature.Destroy()<br/>    srcFeat.Destroy()<br/>    srcFeat = srcLyr.GetNextFeature()<br/>src.Destroy()<br/>tgt.Destroy()</pre>
<ol start="8">
<li>Then, we need to create a shapefile <kbd>.prj</kbd> file containing projection information as a shapefile has no inherent way to store it:</li>
</ol>
<pre style="padding-left: 60px"># Convert geometry to Esri flavor of Well-Known Text (WKT) format<br/># for export to the projection (prj) file.<br/>tgt_spatRef.MorphToESRI()<br/>prj = open(lyrName + '.prj', 'w')<br/>prj.write(tgt_spatRef.ExportToWkt())<br/>prj.close()</pre>
<ol start="9">
<li>Finally, we can just make a copy of the <kbd>.dbf</kbd> source with the new filename as the attributes are part of the reprojection process:</li>
</ol>
<pre style="padding-left: 60px">srcDbf = os.path.splitext(srcName)[0] + '.dbf'<br/>tgtDbf = lyrName + '.dbf'<br/>shutil.copyfile(srcDbf, tgtDbf)</pre>
<p>The following screenshot shows the reprojected points in QGIS with satellite imagery in the background:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e38dd1d3-50b4-4bfd-b5e5-d7bea52744a8.png" style="width:25.25em;height:24.92em;" width="773" height="764"/></p>
<p>If you are working with a set of points, you can reproject them programmatically instead of reprojecting a shapefile using PyProj: <a href="https://jswhit.github.io/pyproj/">https://jswhit.github.io/pyproj/</a>.</p>
<p>In addition to converting coordinates into different projections, you often need to convert them among different formats, which we'll look at next.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding coordinate format conversion</h1>
                
            
            
                
<p>Map coordinates were traditionally represented as degrees, minutes, and seconds (DMS) for maritime navigation. However, in GIS (which is computer-based), latitude and longitude are represented as decimal numbers known as <strong>decimal degrees</strong>. The degrees, minutes, and seconds format is still used. Sometimes, you have to convert between that format and decimal degrees to perform calculations and output reports.</p>
<p>In this example, we'll create two functions that can convert either format into the other:</p>
<ol>
<li>First, we import the <kbd>math</kbd> module to do conversions and the <kbd>re</kbd> regular expression module to parse the coordinate string:</li>
</ol>
<pre style="padding-left: 60px">import math<br/>import re</pre>
<ol start="2">
<li>We have our function to convert decimal degrees into a <kbd>degrees</kbd>, <kbd>minutes</kbd>, and <kbd>seconds</kbd> string:</li>
</ol>
<pre style="padding-left: 60px">def dd2dms(lat, lon):<br/>    """Convert decimal degrees to degrees, minutes, seconds"""<br/>    latf, latn = math.modf(lat)<br/>    lonf, lonn = math.modf(lon)<br/>    latd = int(latn)<br/>    latm = int(latf * 60)<br/>    lats = (lat - latd - latm / 60) * 3600.00<br/>    lond = int(lonn)<br/>    lonm = int(lonf * 60)<br/>    lons = (lon - lond - lonm / 60) * 3600.00<br/>    compass = {<br/>        'lat': ('N','S'),<br/>        'lon': ('E','W')<br/>    }<br/>    lat_compass = compass['lat'][0 if latd &gt;= 0 else 1]<br/>    lon_compass = compass['lon'][0 if lond &gt;= 0 else 1]<br/>    return '{}º {}\' {:.2f}" {}, {}º {}\' {:.2f}" <br/>    {}'.format(abs(latd),<br/>    abs(latm), abs(lats), lat_compass, abs(lond),<br/>    abs(lonm), abs(lons), lon_compass)</pre>
<ol start="3">
<li>Next, we have our function to go the other way and convert degrees:</li>
</ol>
<pre style="padding-left: 60px">def dms2dd(lat, lon):<br/>    lat_deg, lat_min, \<br/>    lat_sec, lat_dir = re.split('[^\d\.A-Z]+', lat)<br/>    lon_deg, lon_min, \<br/>    lon_sec, lon_dir = re.split('[^\d\.A-Z]+', lon)<br/>    lat_dd = float(lat_deg) +\<br/>    float(lat_min)/60 + float(lat_sec)/(60*60);<br/>    lon_dd = float(lon_deg) +\<br/>    float(lon_min)/60 + float(lon_sec)/(60*60);<br/>    if lat_dir == 'S':<br/>        lat_dd *= -1<br/>    if lon_dir == 'W':<br/>        lon_dd *= -1<br/>    return (lat_dd, lon_dd);</pre>
<ol start="4">
<li>Now, if we want to convert decimal degrees into DMS, it's as simple as using the following code:</li>
</ol>
<pre style="padding-left: 60px">print(dd2dms(35.14953, -90.04898))<br/> # 35º 8' 58.31" N, 90º 2' 56.33" W</pre>
<ol start="5">
<li>To go the other direction, you just type the following function:</li>
</ol>
<pre style="padding-left: 60px">dms2dd("""29º 56' 0.00" N""", """90º 4' 12.36" W""")<br/> (29.933333333333334, -90.0701)</pre>
<p>Note that, because the DMS coordinates contain both single and double quotes to represent minutes and seconds, we have to use the Python string convention of using triple quotes on each latitude and longitude coordinate to contain both types of quotes so that they are parsed correctly.</p>
<p>Coordinates are the fundamental units of a GIS dataset. They are used to build points, lines, and polygons.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Calculating the area of a polygon</h1>
                
            
            
                
<p>We have one more calculation before we move on to editing GIS data. The most basic unit of GIS is a point. Two points can form a line. Multiple lines that share endpoints can form a polyline, and polylines can form polygons. Polygons are used to represent everything from a house to an entire country in geospatial operations.</p>
<p class="mce-root"/>
<p class="mce-root">Calculating the area of a polygon is one of the most useful operations in GIS  if we wish to understand the relative size of features. But in GIS, area calculations go beyond basic geometry. The polygon lies on the Earth, which is a curved surface. The polygon must be projected to account for that curvature.</p>
<p class="mce-root">Fortunately, there is a pure Python module simply called <kbd>area</kbd> that handles these complications for us. And because it's pure Python, you can look at the source code to see how it works. The <kbd>area</kbd> module's <kbd>area()</kbd> function accepts a GeoJSON string with a list of points that form a polygon and then returns the area. The following steps will show you how to calculate the area of a polygon:</p>
<ol>
<li class="mce-root">You can install the <kbd>area</kbd> module using <kbd>pip</kbd>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>pip install area</strong></pre>
<ol start="2">
<li class="mce-root">First, we'll import the <kbd>area</kbd> function from the <kbd>area</kbd> module:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">from area import area</pre>
<ol start="3">
<li class="mce-root">Next, we'll create a variable called <kbd>polygon</kbd> that's contained in a GeoJSON geometry for our polygon:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Our points making up a polygon<br/>polygon = {"type":"Polygon","coordinates":[[[-89.324,30.312],[-89.326,30.31],[-89.322,30.31],[-89.321,30.311],[-89.321,30.312],[-89.324,30.312]]]}</pre>
<ol start="4">
<li class="mce-root">Now, we're able to pass the polygon points string to the area function to calculate the area:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">a = area(polygon)</pre>
<ol start="5">
<li class="mce-root">The area that's returned is <kbd>80235.13927976067</kbd> square meters. We can then use Python's built-in <kbd>round()</kbd> function to round the long floating-point value to two decimal places to get <strong>80235.14</strong>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">round(a, 2)</pre>
<p>You now have the tools to do the math regarding the distance and size for geospatial data.</p>
<p>In the next section, we'll look at editing datasets in one of the most popular GIS data formats—shapefiles.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Editing shapefiles</h1>
                
            
            
                
<p>Shapefiles are one of the most common data formats in GIS, both for exchanging data as well as performing GIS analysis. In this section, we'll learn how to work with these files extensively. In <a href="a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml">Chapter 2</a>, <em>Learning Geospatial Data</em>, we discussed shapefiles as a format that can have many different file types associated with it. For editing shapefiles, and most other operations, we are only concerned with two file types:</p>
<ul>
<li>The <kbd>.shp</kbd> file</li>
<li>The <kbd>.dbf</kbd> file</li>
</ul>
<p>The <kbd>.shp</kbd> file contains the geometry while the <kbd>.dbf</kbd> file contains the attributes of the corresponding geometry. For each geometry record in a shapefile, there is one <kbd>.dbf</kbd> record. The records aren't numbered or identified in any way. This means that, when adding and deleting information from a shapefile, you must be careful to remove or add a record to each file type to match.</p>
<p>As we discussed in <a href="ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml"/><a href="ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml">Chapter 4</a>, <em>Geospatial Python Toolbox</em>, there are two libraries we can use to edit shapefiles in Python:</p>
<ul>
<li>One is the Python bindings to the OGR library.</li>
<li>The other is the PyShp library, which is written in pure Python.</li>
</ul>
<p>We'll use PyShp in order to stick with the <em>pure Python when possible</em> theme of this book. To install PyShp, use <kbd>easy_install</kbd> or <kbd>pip</kbd>.</p>
<p>To begin editing shapefiles, we'll start with a point shapefile containing cities for the state of Mississippi, which you can download as a ZIP file. Download the following file to your working directory and unzip it: <a href="http://git.io/vLbU4">http://git.io/vLbU4</a>.</p>
<p>The points we are working with can be seen in the following illustration:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/06c2c998-8899-449c-974f-3b25085cc87c.png" style="width:16.58em;height:23.92em;" width="431" height="622"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Accessing the shapefile</h1>
                
            
            
                
<p>To do anything with a shapefile, we'll need to access it as a data source. To access the shapefile, we'll use PyShp to open it. In PyShp, we'll add the following code:</p>
<pre>import shapefile<br/> r = shapefile.Reader('MSCities_Geo_Pts')<br/> r<br/>&lt;shapefile.Reader instance at 0x00BCB760&gt;</pre>
<p>We created a shapefile <kbd>Reader</kbd> object instance and set it to the <kbd>r</kbd> variable. Notice that, when we passed the filename to the <kbd>Reader</kbd> class, we didn't use any file extensions. Remember that we are dealing with at least two different files ending in <kbd>.shp</kbd> and <kbd>.dbf</kbd>. So, the base filename without the extension that is common to these two files is all we really need.</p>
<p>You can, however, use a file extension. PyShp will just ignore it and use the base filename. So, why would you add an extension? Most operating systems allow an arbitrary number of periods in a filename. For example, you might have a shapefile with the following base name: <kbd>myShapefile.version.1.2</kbd>.</p>
<p>In this case, PyShp will try to interpret the characters after the last period as a file extension, which would be <kbd>.2</kbd>. This issue will prevent you from opening the shapefile. So, if your shapefile has periods in the base name, you would need to add a file extension such as <kbd>.shp</kbd> or <kbd>.dbf</kbd> to the filename.</p>
<p>Once you have opened a shapefile and created a <kbd>Reader</kbd> object, you can get some information about the geographic data. In the following sample, we'll get the bounding box, shape type, and the number of records in the shapefile from our <kbd>Reader</kbd> object:</p>
<pre>r.bbox<br/> [-91.38804855553174, 30.29314882296931, -88.18631833931401, <br/> 34.96091138678437]<br/> r.shapeType<br/> # 1<br/> r.numRecords<br/> # 298</pre>
<p>The bounding box, which is stored in the <kbd>r.bbox</kbd> property, is returned as a list containing the minimum <em>x</em> value, minimum <em>y</em> value, maximum <em>x</em> value, and maximum <em>y</em> value. The shape type, which is available as the <kbd>shapeType</kbd> property, is a numeric code defined by the official shapefile specification. In this case, <kbd>1</kbd> represents a point shapefile, <kbd>3</kbd> represents lines, and <kbd>5</kbd> represents polygons. And finally, the <kbd>numRecords</kbd> property tells us there are <kbd>298</kbd> records in this shapefile. Because it is a simple point shapefile, we know there are <kbd>298</kbd> points, each with their own <kbd>.dbf</kbd> record.</p>
<p>The following table shows the different geometry types for shapefiles, along with their corresponding numeric code:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><strong>Geometry</strong></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign"><strong>Numeric Code</strong></td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>NULL</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">0</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POINT</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">1</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POLYLINE</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">3</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POLYGON</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">5</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>MULTIPOINT</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">8</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POINTZ</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">11</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POLYLINEZ</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">13</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POLYGONZ</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">15</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>MULTIPOINTZ</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">18</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POINTM</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">21</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POLYLINEM</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">23</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>POLYGONM</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">25</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>MULTIPOINTM</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">28</td>
</tr>
<tr>
<td style="width: 24%" class="CDPAlignCenter CDPAlign"><kbd>MULTIPATCH</kbd></td>
<td style="width: 26.8877%" class="CDPAlignCenter CDPAlign">31</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now that we know how to access it, let's see how we can read these files.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reading shapefile attributes</h1>
                
            
            
                
<p>The <kbd>.dbf</kbd> file is a simple database format that is structured in a similar way to a spreadsheet with rows and columns, with each column as a label defining what information it contains. We can view that information by checking the fields property of the <kbd>Reader</kbd> object:</p>
<pre>r.fields<br/> # [('DeletionFlag', 'C', 1, 0), ['STATEFP10', 'C', 2, 0], <br/> ['PLACEFP10', 'C', 5, 0],<br/> # ['PLACENS10', 'C', 8, 0], ['GEOID10', 'C', 7, 0], ['NAME10', 'C', <br/> 100, 0],<br/> # ['NAMELSAD10', 'C', 100, 0], ['LSAD10', 'C', 2, 0], ['CLASSFP10', <br/> 'C', 2, 0],<br/> # ['PCICBSA10', 'C', 1, 0], ['PCINECTA10', 'C', 1, 0], ['MTFCC10', <br/> 'C', 5, 0],<br/> # ['FUNCSTAT10', 'C', 1, 0], ['ALAND10', 'N', 14, 0], ['AWATER10', <br/> 'N', 14,0],<br/> # ['INTPTLAT10', 'C', 11, 0], ['INTPTLON10', 'C', 12, 0]]</pre>
<p>The <kbd>fields</kbd> property returns quite a bit of information. The fields contain a list of information about each field, called <strong>field descriptors</strong>. For each field, the following information is presented:</p>
<ul>
<li><strong>Field name:</strong> This is the name of the field as text, which can be no longer than 10 characters for shapefiles.</li>
<li><strong>Field type:</strong> This is the type of the field, which can be text, number, date, floating-point number, or Boolean represented as C, N, D, F, and L, respectively. The shapefile specification says it uses the <kbd>.dbf</kbd> format specified as dBASE III, but most GIS software seems to support dBASE IV. In version IV (4), the number and floating-point types are equivalent.</li>
<li><strong>Field length:</strong> This is the length of the data in characters or digits.</li>
<li><strong>Decimal length:</strong> This is the number of decimal places in a number or floating-point field.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The first field descriptor outlines a hidden field that is part of the <kbd>.dbf</kbd> file format specification. <kbd>DeletionFlag</kbd> allows the software to mark records for deletion without actually deleting them. That way, the information is still in the file but can be removed from the displayed record list or search queries.</p>
<p>If we just want the field name and not the other metadata, we can use Python list comprehensions to return just the first item in the descriptor and ignore the <kbd>DeletionFlag</kbd> field. This example creates a list comprehension that returns the first item in each descriptor (field name), starting with the second descriptor to ignore the deletion flag:</p>
<pre>[item[0] for item in r.fields[1:]]<br/># ['STATEFP10', 'PLACEFP10', 'PLACENS10', 'GEOID10', 'NAME10', 'NAMELSAD10', 'LSAD10',<br/># 'CLASSFP10', 'PCICBSA10', 'PCINECTA10', 'MTFCC10', 'FUNCSTAT10', 'ALAND10',<br/># 'AWATER10', 'INTPTLAT10', 'INTPTLON10']</pre>
<p>Now, we have just the field names, which are much easier to read. For clarity, the field names all contain the number <kbd>10</kbd> because this is version 2010 of this shapefile, which is created as a part of each census. These kinds of abbreviations are common in shapefile <kbd>.dbf</kbd> files due to the <kbd>10</kbd> character limit on the field names.</p>
<p>Next, let's examine some of the records that these fields describe. We can view an individual record using the <kbd>r.record()</kbd> method. We know from the first example that there are <kbd>298</kbd> records. So, let's examine the third record as an example. The records are accessed using list indexes. In Python, indexes start at <kbd>0</kbd>, so we have to subtract one from the desired record number to get the index. For record 3, the index would be <kbd>2</kbd>. You just pass the index to the <kbd>record()</kbd> method, as shown in the following code:</p>
<pre>r.record(2)<br/>#['28', '16620', '02406337', '2816620', 'Crosby', 'Crosby town', '43', 'C1', 'N','N', # 'G4110', 'A', 5489412, 21336, '+31.2742552', '-091.0614840']</pre>
<p>As you can see, the field names are stored separately from the actual records. If you want to select a record value, you need its index. The index of the city name in each record is <kbd>4</kbd>:</p>
<pre>r.record(2)[4]<br/># 'Crosby'</pre>
<p>But counting indexes is tedious. It's much easier to reference a value by the field name. There are several ways we can associate a field name with the value of a particular record. The first is to use the <kbd>index()</kbd> method in Python lists to programmatically get the index using the field name:</p>
<pre>fieldNames = [item[0] for item in r.fields[1:]]<br/>name10 = fieldNames.index('NAME10')<br/>name10<br/># 4<br/>r.record(2)[name10]<br/># 'Crosby'</pre>
<p>Another way we can associate field names to values is by using Python's built-in <kbd>zip()</kbd> method, which matches corresponding items in two or more lists and merges them into a list of tuples. Then, we can loop through that list, check the name, and then grab the associated value, as shown in the following code:</p>
<pre>fieldNames = [item[0] for item in r.fields[1:]]<br/>fieldNames<br/># ['STATEFP10', 'PLACEFP10', 'PLACENS10', 'GEOID10', 'NAME10', 'NAMELSAD10',<br/># 'LSAD10', 'CLASSFP10', 'PCICBSA10', 'PCINECTA10', 'MTFCC10','FUNCSTAT10',<br/># 'ALAND10','AWATER10', 'INTPTLAT10', 'INTPTLON10']<br/> rec = r.record(2)<br/> rec<br/># ['28', '16620', '02406337', '2816620', 'Crosby', 'Crosby town',<br/># '43', 'C1', 'N','N', 'G4110', 'A', 5489412, 21336, '+31.2742552', '-091.0614840']<br/> zipRec = zip(fieldNames, rec)<br/> list(zipRec)<br/># [('STATEFP10', '28'), ('PLACEFP10', '16620'), ('PLACENS10', '02406337'),<br/># ('GEOID10', '2816620'), ('NAME10', 'Crosby'), ('NAMELSAD10', 'Crosby town'),<br/># ('LSAD10', '43'), ('CLASSFP10', 'C1'), ('PCICBSA10','N'),('PCINECTA10','N'),<br/># ('MTFCC10', 'G4110'), ('FUNCSTAT10', 'A'), ('ALAND10', 5489412),('AWATER10', 21336),<br/># ('INTPTLAT10', '+31.2742552'), ('INTPTLON10', '-091.0614840')]<br/>for z in zipRec:<br/>    if z[0] == 'NAME10': print(z[1])<br/># Crosby</pre>
<p>We can also loop through <kbd>.dbf</kbd> records using the <kbd>r.records()</kbd> method. In this example, we'll loop through the list returned by the <kbd>records()</kbd> method but limit the results using Python array slicing to the first three records. As we mentioned previously, shapefiles don't contain record numbers, so we'll also enumerate the records list and create a record number on the fly, so the output is a little easier to read. In this example, we'll use the <kbd>enumerate()</kbd> method, which will return tuples containing an index and the record, as shown in the following code:</p>
<pre>for rec in enumerate(r.records()[:3]):<br/>    print(rec[0]+1, ': ', rec[1])<br/># 1 :  ['28', '59560', '02404554', '2859560', 'Port Gibson', 'Port Gibson city', '<br/># 25', 'C1', 'N', 'N', 'G4110', 'A', 4550230, 0, '+31.9558031', '-090.9834329']<br/># 2 :  ['28', '50440', '02404351', '2850440', 'Natchez', 'Natchez city', '25', 'C1',<br/>#      'Y', 'N', 'G4110', 'A', 34175943, 1691489, '+31.5495016', '-091.3887298']<br/># 3 :  ['28', '16620', '02406337', '2816620', 'Crosby', 'Crosby town', '43', 'C1','N',<br/>#       'N', 'G4110', 'A', 5489412, 21336, '+31.2742552', '-091.0614840']</pre>
<p>This kind of enumeration trick is what most GIS software packages use when displaying records in a table. Many GIS analysts assume shapefiles store the record number because every GIS program displays one. But if you delete a record, for example, record number 5 in ArcGIS or QGIS, and save the file, when you open it again, you'll find what was formerly record number 6 is now record 5. Some spatial databases may assign a unique identifier to records. Often, a unique identifier is helpful. You can always create another field and column in <kbd>.dbf</kbd> and assign your own number, which remains constant even when records are deleted.</p>
<p class="mce-root"/>
<p>If you are working with very large shapefiles, PyShp has iterator methods that access data more efficiently. The default <kbd>records()</kbd> method reads all the records into the RAM at once, which is fine for the small <kbd>.dbf</kbd> files but becomes difficult to manage even with a few thousand records. Any time you'd use the <kbd>records()</kbd> method, you can also use the <kbd>r.iterRecords()</kbd> method the same way. This method holds the minimum amount of information needed to provide the record at hand rather than the whole dataset. In this quick example, we're using the <kbd>iterRecords()</kbd> method to count the number of records to verify the count in the file header:</p>
<pre>counter = 0<br/>for rec in r.iterRecords():<br/>    counter += 1<br/>counter<br/># 298</pre>
<p>Now that we can read one half of the shapefile, that is, the attributes, we're ready to look at the other half, that is, the geometry.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Reading shapefile geometry</h1>
                
            
            
                
<p>Now, let's take a look at the geometry. Previously, we looked at the header information and determined this shapefile was a point shapefile. So, we know that each record contains a single point. Let's examine the first geometry record:</p>
<pre>geom = r.shape(0)<br/>geom.points<br/># [[-90.98343326763826, 31.9558035947602]]</pre>
<p>In each geometry record, also known as <kbd>shape</kbd>, the points are stored in a list called <kbd>points</kbd>, even if there is only one point, as in this case. Points are stored as <em>x</em>, <em>y</em> pairs, so longitude comes before latitude if that coordinate system is used.</p>
<p>The shapefile specification also allows for 3D shapes. Elevation values are along the <em>z</em>-axis and often called <em>z</em> values. So, a 3D point is typically described as <em>x</em>, <em>y</em>, <em>z</em>. In the shapefile format, <em>z</em> values are stored in a separate <em>z</em> attribute if they're allowed by the shape type. If the shape type doesn't allow for <em>z</em> values, then that attribute is never set when the records are read by PyShp. Shapefiles with <em>z</em> values also contain measure values or <em>m</em> values, which are rarely used and are not used in this example.</p>
<p>A measure is a user-assigned value that may be associated with a shape. An example would be a temperature recorded at a given location. There is another class of shape types that allow for adding <em>m</em> values to each shape but not <em>z</em> values. This class of shape types is called an <strong>M shape type</strong>. Just like the <em>z</em> values, if the data is there, the <em>m</em> attribute is created; otherwise, it's not. You don't typically run into shapefiles with <em>z</em> values and you rarely come across shapefiles with <em>m</em> values set. But sometimes you do, so it's good to be aware of them. And just like our fields and records <kbd>.dbf</kbd> example, if you don't like having the <em>z</em> and <em>m</em> values stored in separate lists, from the points list, you can use the <kbd>zip()</kbd> method to combine them. The <kbd>zip</kbd> method can take multiple lists as parameters separated by commas, as demonstrated when we looped through the records previously and joined the field names and attributes.</p>
<p>When you create a <kbd>Reader</kbd> object with PyShp, it is read-only. You can change any values in the <kbd>Reader</kbd> object, but they are not written to the original shapefile. In the next subsection, we'll see how we can make changes in the original shapefile.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Changing a shapefile</h1>
                
            
            
                
<p>To create a shapefile, you need to also create a <kbd>Writer</kbd> object. You can change values in either a <kbd>Reader</kbd> or <kbd>Writer</kbd> object; they are just dynamic Python data types. But at some point, you must copy the values from <kbd>Reader</kbd> to <kbd>Writer</kbd>. PyShp automatically handles all of the header information, such as the bounding box and record count. You only need to worry about the geometry and attributes. You'll find that this method is much simpler than the OGR example we used previously. However, it is also limited to UTM projections.</p>
<p>To demonstrate this concept, we'll read in a shapefile containing points with units in degrees and convert it into the UTM reference system in a <kbd>Writer</kbd> object before saving it. We'll use PyShp and the UTM module we discussed previously in this chapter. The shapefile we'll use is the New York City museums shapefile, which we reprojected to a WGS84 geographic. You can also just download it as a ZIP file, which is available at <a href="https://git.io/vLd8Y">https://git.io/vLd8Y</a>.</p>
<p>In the following example, we'll read in the shapefile, create a writer for the converted shapefile, copy the fields over and then the records, and finally convert each point and write it as a geometry record before saving the converted shapefile:</p>
<pre>import shapefile<br/>import utm<br/>r = shapefile.Reader('NYC_MUSEUMS_GEO')<br/>w = shapefile.Writer(r.shapeType)<br/>w.fields = list(r.fields)<br/>w.records.extend(r.records())<br/>for s in r.iterShapes():<br/>    lon,lat = s.points[0]<br/>    y,x,zone,band = utm.from_latlon(lat,lon)<br/>    w.point(x,y)<br/>w.save('NYC_MUSEUMS_UTM')</pre>
<p>If you were to print out the first point of the first shape, you would see the following:</p>
<pre>print(w.shapes()[0].points[0])<br/># [4506346.393408813, 583315.4566450359, 0, 0]</pre>
<p>The point is returned as a list containing four numbers. The first two are the <em>x</em> and <em>y</em> values, while the last two are placeholders, in this case for elevation and measure values, respectively, which are used when you write those types of shapefiles. Also, we did not write a PRJ projection file, as we did in the preceding reprojection example. Here's a simple way to create a PRJ file using the EPSG code from <a href="https://spatialreference.org/">https://spatialreference.org/</a>. The <kbd>zone</kbd> variable in the preceding example tells us that we are working in UTM Zone 18, which is EPSG code 26918. The following code will create a <kbd>prj</kbd> file:</p>
<pre>from urllib.request import urlopen<br/>prj = urlopen('http://spatialreference.org/ref/epsg/26918/esriwkt/')<br/>with open('NYC\_MUSEUMS\_UTM', 'w') as f:<br/>    f.write(str(prj.read()))</pre>
<p>As another example, we can add a new feature to a shapefile. In this example, we'll add a second polygon to a shapefile representing a tropical storm. You can download the zipped shapefile for this example here: <a href="https://git.io/vLdlA">https://git.io/vLdlA</a>.</p>
<p>We'll read the shapefile, copy it to a <kbd>Writer</kbd> object, add the new polygon, and write it back out with the same filename using the following code:</p>
<pre>import shapefile<br/>file_name = "ep202009.026_5day_pgn.shp"<br/>r = shapefile.Reader(file_name)<br/>with shapefile.Writer("test", r.shapeType) as w: <br/>    w.fields = list(r.fields) <br/>    for rec in r.records():<br/>        w.record(*list(rec)) <br/>    for s in r.shapes():<br/>        w._shapeparts(parts=[s.points], shapeType=s.shapeType) <br/>    w.poly([[[-104, 24], [-104, 25], [-103, 25], [-103, 24], [-104, <br/>    24]]]) <br/>    w.record("STANLEY", "TD", "091022/1500", "27", "21", "48", "ep")</pre>
<p>This is how we do the changes in the original shapefile. Now, let's see how we can add new fields in the shapefile.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding fields</h1>
                
            
            
                
<p>A very common operation on shapefiles is to add additional fields to them. This operation is easy but there's one important element to remember. When you add a field, you must also loop through the records and either create an empty cell or add a value for that column. As an example, let's add a reference latitude and longitude column to the UTM version of the New York City museums shapefile:</p>
<ol>
<li>First, we'll open the shapefile and create a new <kbd>Writer</kbd> object:</li>
</ol>
<pre style="padding-left: 60px">import shapefile<br/>r = shapefile.Reader('NYC_MUSEUMS_UTM')<br/>with shapefile.Writer("test", r.shapeType) as w:</pre>
<ol start="2">
<li>Next, we'll add the fields as float types with a length of <kbd>8</kbd> for the entire field and a maximum precision of <kbd>5</kbd> decimal places:</li>
</ol>
<pre style="padding-left: 60px">   w.fields = list(r.fields)<br/>   w.field('LAT','F',8,5)<br/>   w.field('LON','F',8,5)</pre>
<ol start="3">
<li>Next, we'll open the geographic version of the shapefile and grab the coordinates from each record. We'll add these to the corresponding attribute record in the UTM version's <kbd>.dbf</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    for i in range(len(r.shapes())):<br/>        lon, lat = r.shape(i).points[0]<br/>        w.point(lon, lat)<br/>        w.record(*list(r.record(i)), lat, lon)</pre>
<p>In the next subsection, we'll see how we can merge multiple shapefiles.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Merging shapefiles</h1>
                
            
            
                
<p>Aggregating multiple related shapefiles of the same type into one larger shapefile is another very useful technique. You might be working as part of a team that divides up an area of interest and then assembles the data at the end of the day. Or, you might aggregate data from a series of sensors out in the field, such as weather stations.</p>
<p>For this example, we'll use a set of building footprints for a county that is maintained separately in four different quadrants (northwest, northeast, southwest, and southeast). You can download these shapefiles as a single ZIP file at <a href="http://git.io/vLbUE">http://git.io/vLbUE</a>.</p>
<p>When you unzip these files, you'll see they are named by quadrant. The following script uses PyShp to merge them into a single shapefile:</p>
<pre>import glob<br/>import shapefile<br/>files = glob.glob('footprints_*shp')<br/>with shapefile.Writer("Merged") as w:<br/>    r = None<br/>    for f in files:<br/>        r = shapefile.Reader(f)<br/>        if not w.fields:<br/>            w.fields = list(r.fields)<br/>        for rec in r.records():<br/>            w.record(*list(rec))<br/>        for s in r.shapes():<br/>            w._shapeparts(parts=[s.points], shapeType=s.shapeType)</pre>
<p>As you can see, merging a set of shapefiles is very straightforward. However, we didn't do any sanity checks to make sure the shapefiles were all of the same type, which you might want to do if this script was used for a repeated automated process, instead of just a quick one-off process.</p>
<p>Another note about this example is how we invoked the <kbd>Writer</kbd> object. In the other examples, we used a numeric code to define a shape type. You can define that number directly (for example, 1 for point shapefiles) or call one of the PyShp constants. The constants are the type of shapefile in all caps. For example, a polygon is as follows:</p>
<pre>shapefile.POLYGON</pre>
<p>In this case, the value of that constant is 5. When copying data from a <kbd>Reader</kbd> to a <kbd>Writer</kbd> object, you'll notice the shape type definition is simply referenced, as shown in this example:</p>
<pre>r = shapefile.Reader('myShape')<br/>w = shapefile.Writer("myShape", r.shapeType)</pre>
<p>This method makes your script more robust as the script has one less variable that needs to be changed if you later change the script or the dataset. In the merging example, we don't have the benefit of having a <kbd>Reader</kbd> object available when we invoke <kbd>Writer</kbd>.</p>
<p>We could open the first shapefile in the list and check its type, but that would add several more lines of code. An easier way is just to omit the shape type. If the <kbd>Writer</kbd> shape type isn't saved, PyShp will ignore it until you save the shapefile. At that time, it will check the individual header of a geometry record and determine it from that.</p>
<p>While you can use this method in special cases, it's better to define the shape type explicitly when you can, for clarity, and just to be safe to prevent any outlier case errors. The following illustration is a sample of this dataset so that you get a better idea of what the data looks like, as we will be using it more next:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d6dbb7db-b1ed-478d-8481-d53f7976afc3.png" style="width:25.67em;height:16.50em;" width="679" height="438"/></p>
<p>Now, let's see how to do this with the <kbd>.dbfpy</kbd> files.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Merging shapefiles with dbfpy</h1>
                
            
            
                
<p>The <kbd>.dbf</kbd> portion of PyShp can occasionally run into issues with <kbd>.dbf</kbd> files that are  produced by certain software. Fortunately, PyShp allows you to manipulate the different shapefile types separately. There's a more robust <kbd>.dbf</kbd> library, named <kbd>dbfpy3</kbd>, which we discussed in <a href="ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml">Chapter 4</a>, <em>Geospatial Python Toolbox</em>. You can use PyShp to handle the <kbd>.shp</kbd> and <kbd>.shx</kbd> files, while <kbd>.dbfpy</kbd> handles more complex <kbd>.dbf</kbd> files. You can download the module here: <a href="https://github.com/GeospatialPython/dbfpy3/archive/master.zip">https://github.com/GeospatialPython/dbfpy3/archive/master.zip</a>.</p>
<p class="mce-root"/>
<p>This approach takes more code but it will often succeed where PyShp alone fails with <kbd>.dbf</kbd> issues. This example uses the same shapefiles from the previous example. In the following example, we'll merge a shapefile using only its attributes:</p>
<ol>
<li>First, we import the libraries we need, get a list of shapefiles using the glob module, and create a shapefile <kbd>Writer</kbd> object using PyShp:</li>
</ol>
<pre style="padding-left: 60px">import glob<br/>import shapefile<br/>from dbfpy3 import dbf<br/>shp_files = glob.glob('footprints_*.shp')<br/>w = shapefile.Writer(shp="merged.shp", shx="merged.shx")</pre>
<ol start="2">
<li>Now, we're going to open only the <kbd>.</kbd><kbd>shp</kbd> files and copy the geometries to the writer. We'll circle back and get the attributes using the <kbd>dbypy3</kbd> module later to demonstrate working with shapefile components separately:</li>
</ol>
<pre style="padding-left: 60px"># Loop through ONLY the shp files and copy their shapes<br/># to a Writer object. We avoid opening the dbf files<br/># to prevent any field-parsing errors.<br/>for f in shp_files:<br/>    print("Shp: {}".format(f))<br/>    r = shapefile.Reader(f)<br/>    r = shapefile.Reader(shp=shpf)<br/>    for s in r.shapes():<br/>        w.poly([s.points])<br/>    print("Num. shapes: {}".format(len(w.shapes())))</pre>
<ol start="3">
<li>Once all of the geometry has been copied over to the writer, we can save the <kbd>.shp</kbd> file and have PyShp create an index file for the geometry:</li>
</ol>
<pre style="padding-left: 60px"># Save only the shp and shx index file to the new<br/># merged shapefile.<br/>w.close()</pre>
<ol start="4">
<li>Next, we can get a list of <kbd>.dbf</kbd> files using the <kbd>glob</kbd> module:</li>
</ol>
<pre style="padding-left: 60px"># Now we come back with dbfpy and merge the dbf files<br/>dbf\_files = glob.glob('\*.dbf')</pre>
<ol start="5">
<li>Next, we'll use the first <kbd>.dbf</kbd> file in the list as a template to get the field data and use it to set the properties of the shapefile writer: </li>
</ol>
<pre style="padding-left: 60px"># Use the first dbf file as a template<br/>template = dbf\_files.pop(0)<br/>merged\_dbf\_name = 'merged.dbf'<br/># Copy the entire template dbf file to the merged file<br/>merged\_dbf = open(merged\_dbf\_name, 'wb')<br/>temp = open(template, 'rb')<br/>merged\_dbf.write(temp.read())<br/>merged\_dbf.close()<br/>temp.close()</pre>
<ol start="6">
<li>Then, we simply loop through the <kbd>.dbf</kbd> files and copy the records to <kbd>Writer:</kbd></li>
</ol>
<pre style="padding-left: 60px"># Now read each record from the remaining dbf files<br/># and use the contents to create a new record in<br/># the merged dbf file.<br/>db = dbf.Dbf(merged\_dbf\_name)<br/>for f in dbf\_files:<br/>    print('Dbf: {}'.format(f))<br/>    dba = dbf.Dbf(f)<br/>    for rec in dba:<br/>        db\_rec = db.newRecord()<br/>        for k, v in list(rec.asDict().items()):<br/>            db\_rec[k] = v<br/>        db\_rec.store()<br/>db.close()</pre>
<p>Now that we know how to merge shapefiles, let's check out how to split them.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Splitting shapefiles</h1>
                
            
            
                
<p>Sometimes, you may also need to split larger shapefiles to make it easier for you to focus on a subset of interest. This splitting, or subsetting, can be done spatially or by attributes, depending on which aspect of the data is of interest.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Subsetting spatially</h1>
                
            
            
                
<p>One way to extract part of a dataset is to use spatial attributes such as size. In the following example, we'll subset the southeast quadrant file we merged. We'll filter the building footprint polygons by area and export any buildings with a 100 square meters or less (about 1,000 square feet) profile to a new shapefile. We'll use the <kbd>footpints_se</kbd> shapefile for this.</p>
<p>PyShp has a signed area method that accepts a list of coordinates and returns either a positive or negative area. We'll use the <kbd>utm</kbd> module to convert the coordinates into meters. Normally, the positive or negative area denotes whether the point order of the polygon is clockwise or counterclockwise, respectively. But point order doesn't matter here, so we'll use the absolute value using the <kbd>abs()</kbd> function, as shown here, when we get the area value:</p>
<pre>import shapefile<br/>import utm<br/>r = shapefile.Reader('footprints\_se')<br/>w = shapefile.Writer(r.shapeType)<br/>w.fields = list(r.fields)<br/>for sr in r.shapeRecords():<br/>    utmPoints = []<br/>    for p in sr.shape.points:<br/>        x,y,band,zone = utm.from_latlon(p[1],p[0])<br/>        utmPoints.append([x,y])<br/>    area = abs(shapefile.signed_area(utmPoints))<br/>    if area &lt;= 100:<br/>        w._shapes.append(sr.shape)<br/>        w.records.append(sr.record)<br/>w.save('footprints\_185')</pre>
<p>Let's see the difference in the number of records between the original and the subset shapefile:</p>
<pre>r = shapefile.Reader('footprints\_se')<br/>subset = shapefile.Reader('footprints\_185')<br/>print(r.numRecords)<br/># 26447<br/>print(subset.numRecords)<br/># 13331</pre>
<p>We now have some substantial building blocks for geospatial analysis with vector data, as well as attributes.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Performing selections</h1>
                
            
            
                
<p>The previous subsetting example is one way to select data. There are many other ways to subset data for further analysis. In this section, we'll examine selecting subsets of data that are critical for efficient data processing to reduce the size of a large dataset down to just our area of interest for a given dataset.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The point-in-polygon formula</h1>
                
            
            
                
<p>We briefly discussed the point-in-polygon formula in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, as a common type of geospatial operation. You'll find it is one of the most useful formulas out there. The formula is relatively straightforward.</p>
<p>The following function performs this check using the <strong>Ray Casting</strong> method. This method draws a line from the test point all of the way through the polygon and counts the number of times it crosses the polygon boundary. If the count is even, the point is outside the polygon. If it is odd, then it's inside. This particular implementation also checks to see whether the point is on the edge of the polygon:</p>
<pre>def point_in_poly(x,y,poly):<br/>    # check if point is a vertex<br/>    if (x,y) in poly: return True<br/>    # check if point is on a boundary<br/>    for i in range(len(poly)):<br/>       p1 = None<br/>       p2 = None<br/>       if i==0:<br/>          p1 = poly[0]<br/>          p2 = poly[1]<br/>       else:<br/>          p1 = poly[i-1]<br/>          p2 = poly[i]<br/>       if p1[1] == p2[1] and p1[1] == y and x min(p1[0], \<br/>          p2[0]) and x &lt; max(p1[0], p2[0]):<br/>          return True<br/>    n = len(poly)<br/>    inside = False<br/>    p1x,p1y = poly[0]<br/>    for i in range(n+1):<br/>       p2x,p2y = poly[i % n]<br/>       if y min(p1y,p2y):<br/>          if y &lt;= max(p1y,p2y):<br/>             if x &lt;= max(p1x,p2x):<br/>                if p1y != p2y:<br/>                   xints = (y-p1y)*(p2x-p1x)/(p2y-p1y)+p1x<br/>                if p1x == p2x or x &lt;= xints:<br/>                   inside = not inside<br/>       p1x,p1y = p2x,p2y<br/>    if inside: return True<br/>    return False</pre>
<p class="mce-root"/>
<p>Now, let's use the <kbd>point_in_poly()</kbd> function to test a point in Chile:</p>
<pre># Test a point for inclusion<br/>myPolygon = [(-70.593016,-33.416032), (-70.589604,-33.415370),<br/>(-70.589046,-33.417340), (-70.592351,-33.417949),<br/>(-70.593016,-33.416032)]<br/># Point to test<br/>lon = -70.592000<br/>lat = -33.416000<br/>print(point_in_poly(lon, lat, myPolygon))<br/># True</pre>
<p>This shows that the point is inside. Let's also verify that edge points will be detected:</p>
<pre># test an edge point<br/>lon = -70.593016<br/>lat = -33.416032<br/>print(point_in_poly(lon, lat, myPolygon))<br/># True</pre>
<p>You'll find new uses for this function all the time. It's definitely one to keep in your toolbox.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Bounding box selections</h1>
                
            
            
                
<p>A bounding box is the smallest rectangle that can completely contain a feature. We can use it as an efficient way to subset one or more individual features from a larger dataset. We'll look at one more example of using a simple bounding box to isolate a complex set of features and save it in a new shapefile. In this example, we'll subset the roads on the island of Puerto Rico from the mainland US Major Roads shapefile. You can download the shapefile here: <a href="https://github.com/GeospatialPython/Learn/raw/master/roads.zip">https://github.com/GeospatialPython/Learn/raw/master/roads.zip</a>.</p>
<p>Floating-point coordinate comparisons can be expensive, but because we are using a box and not an irregular polygon, this code is efficient enough for most operations:</p>
<pre>import shapefile<br/>r = shapefile.Reader('roadtrl020')<br/>w = shapefile.Writer(r.shapeType)<br/>w.fields = list(r.fields)<br/>xmin = -67.5<br/>xmax = -65.0<br/>ymin = 17.8<br/>ymax = 18.6<br/>for road in r.iterShapeRecords():<br/>    geom = road.shape<br/>    rec = road.record<br/>    sxmin, symin, sxmax, symax = geom.bbox<br/>    if sxmin &lt; xmin: continue<br/>    elif sxmax xmax: continue<br/>    elif symin &lt; ymin: continue<br/>    elif symax ymax: continue<br/>    w._shapes.append(geom)<br/>    w.records.append(rec)<br/>w.save('Puerto_Rico_Roads')</pre>
<p>Now that we've used geometry to select features, let's do it another way by using attributes.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Attribute selections</h1>
                
            
            
                
<p>We've now seen two different ways of subsetting a larger dataset, resulting in a smaller one based on spatial relationships. But we can also select data using the attribute fields. So, let's examine a quick way to subset vector data using the attribute table. In this example, we'll use a polygon shapefile that has densely populated urban areas within Mississippi. You can download this zipped shapefile from <a href="http://git.io/vLbU9">http://git.io/vLbU9</a>.</p>
<p>This script is really quite simple. It creates the <kbd>Reader</kbd> and <kbd>Writer</kbd> objects, copies the <kbd>.dbf</kbd> fields, loops through the records for matching attributes, and then adds them to <kbd>Writer</kbd>. We'll select urban areas with a population of less than <kbd>5000</kbd>:</p>
<pre>import shapefile<br/># Create a reader instance<br/>r = shapefile.Reader('MS_UrbanAnC10')<br/># Create a writer instance<br/>w = shapefile.Writer(r.shapeType)<br/># Copy the fields to the writer<br/>w.fields = list(r.fields)<br/># Grab the geometry and records from all features<br/># with the correct population<br/>selection = []<br/>for rec in enumerate(r.records()):<br/>    if rec[1][14] &lt; 5000:<br/>        selection.append(rec)<br/># Add the geometry and records to the writer<br/>for rec in selection:<br/>    w._shapes.append(r.shape(rec[0]))<br/>    w.records.append(rec[1])<br/># Save the new shapefile<br/>w.save('MS_Urban_Subset')</pre>
<p>Attribute selections are typically fast. Spatial selections are computationally expensive because of floating-point calculations. Whenever possible, make sure you are unable to use attribute selection to subset first. The following illustration shows the starting shapefile containing all urban areas on the left with a state boundary, and the urban areas with less than 5,000 people on the right, after the previous attribute selection:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c80699c3-d955-4f23-b462-5a852a566dd6.png" style="width:19.00em;height:17.25em;" width="1387" height="1260"/></p>
<p>Let's see what that same example looks like using <kbd>fiona</kbd>, which takes advantage of the OGR library. We'll use nested <kbd>with</kbd> statements to reduce the amount of code needed to properly open and close the files:</p>
<pre>import fiona<br/>with fiona.open('MS_UrbanAnC10.shp') as sf:<br/>    filtered = filter(lambda f: f['properties']['POP'] &lt; 5000, sf)<br/>    # Shapefile file format driver<br/>    drv = sf.driver<br/>    # Coordinate Reference System<br/>    crs = sf.crs<br/>    # Dbf schema<br/>    schm = sf.schema<br/>    subset = 'MS_Urban_Fiona_Subset.shp'<br/>    with fiona.open(subset, 'w',<br/>        driver=drv,<br/>        crs=crs,<br/>        schema=schm) as w:<br/>            for rec in filtered:<br/>                w.write(rec)</pre>
<p>Now, we know how to combine discrete datasets as well as split larger datasets apart. What else can we do? We can aggregate features within a dataset.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Aggregating geometry</h1>
                
            
            
                
<p>GIS vector datasets are typically composed of point, line, or polygon features. One of the principles of GIS is that things that are closer together geographically are more related than things that are further apart. When you have a set of related features, often, it's too much detail for the analysis you're trying to accomplish. It can be useful to generalize them to speed up processing or simplify a map. This type of operation is called <strong>aggregation</strong>. A common example of aggregation is to combine a set of local political boundaries into a larger political boundary such as counties into a state or states into a country or countries into continents.</p>
<p>In this example, we'll do just that. We'll convert a dataset comprising all of the counties in the US state of Mississippi into a single polygon representing the entire state. The Python Shapely library is perfect for this kind of operation; however, it can only manipulate geometry and doesn't read or write data files. To read and write data files, we'll use the Fiona library. If you don't have Shapely or Fiona installed, use <kbd>pip</kbd> to install them. You can download the counties dataset here: <a href="https://git.io/fjt3b">https://git.io/fjt3b</a>.</p>
<p>The following illustration shows what the counties dataset looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5a61c8ea-f3ce-495b-9d9d-623950104a65.png" style="width:14.42em;height:22.08em;" width="517" height="790"/></p>
<p class="mce-root"/>
<p>The following steps will show you how to merge the individual county polygons into a single polygon:</p>
<ol>
<li>In the following code, we import the libraries we need, including the different portions of the <kbd>shapely</kbd> library.</li>
<li>Then, we'll open the counties GeoJSON file.</li>
<li>Next, we'll copy the schema of the source file, which defines all of the metadata for the dataset.</li>
<li>Then, we need to alter that metadata copy to change the attributes  in order to define a single attribute for the state name. We also need to alter the geometry type from <em>MultiPolygon</em> to <em>Polygon</em>.</li>
<li>Then, we'll open our output dataset GeoJSON file named <kbd>combined.geojson</kbd>.</li>
<li>Next, we'll extract all of the polygons and attributes and combine all of the polygons into one.</li>
<li>Finally, we'll write the combined polygon out with the new attribute.</li>
<li>We'll import our libraries, including <kbd>OrderDict</kbd>, so that we can maintain control of the shapefile attributes:</li>
</ol>
<pre style="padding-left: 60px"># Used OrderedDict to control the order<br/># of data attributes<br/>from collections import OrderedDict<br/># Import the shapely geometry classes and methods.<br/># The "mapping" method returns a GeoJSON representation<br/># of a geometry.<br/>from shapely.geometry import shape, mapping, Polygon<br/># Import the shapely union function which combines<br/># geometries<br/>from shapely.ops import unary_union<br/># Import Fiona to read and write datasets<br/>import fiona</pre>
<ol start="9">
<li>We open our GeoJSON file and copy the metadata:</li>
</ol>
<pre style="padding-left: 60px"># Open the counties dataset<br/>with fiona.open('ms_counties.geojson') as src:<br/>    # copy the metadata<br/>    schema = src.meta.copy()<br/>    # Create a new field type for our<br/>    # state dataset<br/>    fields = {"State": "str:80"}</pre>
<ol start="10">
<li>Then, we create our new field:</li>
</ol>
<pre style="padding-left: 60px">    # Create a new property for our dataset<br/>    # using the new field<br/>    prop = OrderedDict([("State", "Mississippi")])<br/>    # Change the metadata geometry type to Polygon<br/>    schema['geometry'] = 'Polygon'<br/>    schema['schema']['geometry'] = 'Polygon'</pre>
<ol start="11">
<li>Now, we can add the new field to the metadata:</li>
</ol>
<pre style="padding-left: 60px">    # Add the new field<br/>    schema['properties'] = fields<br/>    schema['schema']['properties'] = fields</pre>
<ol start="12">
<li>Next, we can open the combined GeoJSON file and write out our results:</li>
</ol>
<pre style="padding-left: 60px"># Open the output GeoJSON dataset<br/>with fiona.open('combined.geojson', 'w', **schema) as dst:<br/>    # Extract the properties and geometry <br/>    # from the counties dataset<br/>    props, geom = zip(*[(f['properties'],shape(f['geometry'])) for<br/>    f in src])<br/>    # Write the new state dataset out while <br/>    # combining the polygons into a<br/>    # single polygon and add the new property<br/>    dst.write({'geometry': mapping(\<br/>    Polygon(unary_union(geom).exterior)),<br/>    'properties': prop})</pre>
<p>The output dataset will look similar to the following illustration:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bedbcd4d-abae-4cd7-910e-4504a3a4e5e2.png" style="width:11.42em;height:17.33em;" width="515" height="789"/></p>
<p>Now that we know all about reading, editing, and writing GIS data, we can begin visualizing it in the upcoming sections.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating images for visualization</h1>
                
            
            
                
<p>Now, we're moving from calculations and data editing to something we can see! We'll begin by creating different types of maps. In <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, we visualized our SimpleGIS program using the Tkinter module that's included with Python. In <a href="ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml">Chapter 4</a>, <em>Geospatial Python Toolbox</em>, we examined a few other methods for creating images. Now, we'll examine these tools in more depth by creating two specific types of thematic maps. The first is a dot density map and the second is a choropleth map.</p>
<p>First, let's start with the dot density map.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Dot density calculations</h1>
                
            
            
                
<p>A dot density map shows concentrations of subjects within a given area. If an area is divided up into polygons containing statistical information, you can model that information using randomly distributed dots within that area using a fixed ratio across the dataset. This type of map is commonly used for population density maps.</p>
<p>The cat map in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, is a dot density map. Let's create a dot density map from scratch using pure Python. Pure Python allows you to work with much more lightweight libraries that are generally easier to install and are more portable. For this example, we'll use a US Census Bureau Tract shapefile along the US Gulf Coast, which contains population data. We'll also use the point-in-polygon algorithm to ensure the randomly distributed points are within the proper census tract. Finally, we'll use the <kbd>PNGCanvas</kbd> module to write out our image.</p>
<p>The <kbd>PNGCanvas</kbd> module is excellent and fast. However, it doesn't have the ability to fill in polygons beyond simple rectangles. You can implement a fill algorithm but it is very slow in pure Python. However, for a quick outline and point plot, it does a great job.</p>
<p>You'll also see the <kbd>world2screen()</kbd> method, which is similar to the coordinates-to-mapping algorithm we used in SimpleGIS in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python. </em>In this example, we'll read in a shapefile and write it back out as an image:</p>
<ol>
<li>First, we import the libraries we need, including <kbd>pngcanvas</kbd>, to draw a map image:</li>
</ol>
<pre style="padding-left: 60px">import shapefile<br/>import random<br/>import pngcanvas</pre>
<ol start="2">
<li>Next, we define our point-in-polygon function, which we've used before. In this example, we'll use it to randomly distribute population values within a location:</li>
</ol>
<pre style="padding-left: 60px">def point_in_poly(x,y,poly):<br/>    '''Boolean: is a point inside a polygon?'''<br/>    # check if point is a vertex<br/>    if (x,y) in poly: return True<br/>    # check if point is on a boundary<br/>    for i in range(len(poly)):<br/>        p1 = None<br/>        p2 = None<br/>        if i==0:<br/>            p1 = poly[0]<br/>            p2 = poly[1]<br/>        else:<br/>            p1 = poly[i-1]<br/>            p2 = poly[i]<br/>        if p1[1] == p2[1] and p1[1] == y and \<br/>        x min(p1[0], p2[0]) and x &lt; max(p1[0], p2[0]):<br/>            return True<br/>    n = len(poly)<br/>    inside = False<br/>    p1x,p1y = poly[0]<br/>    for i in range(n+1):<br/>        p2x,p2y = poly[i % n]<br/>        if y min(p1y,p2y):<br/>            if y &lt;= max(p1y,p2y):<br/>                if x &lt;= max(p1x,p2x):<br/>                    if p1y != p2y:<br/>                        xints = (y-p1y)*(p2x-p1x)/(p2y-p1y)+p1x<br/>                    if p1x == p2x or x &lt;= xints:<br/>                    inside = not inside<br/>        p1x,p1y = p2x,p2y<br/>    if inside: return True<br/>    else: return False</pre>
<ol start="3">
<li>Now, we need a function to scale our geospatial coordinates to the map image:</li>
</ol>
<pre style="padding-left: 60px">def world2screen(bbox, w, h, x, y):<br/>    '''convert geospatial coordinates to pixels'''<br/>    minx,miny,maxx,maxy = bbox<br/>    xdist = maxx - minx<br/>    ydist = maxy - miny<br/>    xratio = w/xdist<br/>    yratio = h/ydist<br/>    px = int(w - ((maxx - x) * xratio))<br/>    py = int((maxy - y) * yratio)<br/>    return (px,py)</pre>
<ol start="4">
<li>Next, we read in the shapefile and set the size of our output map image:</li>
</ol>
<pre style="padding-left: 60px"># Open the census shapefile<br/>inShp = shapefile.Reader('GIS_CensusTract_poly')<br/># Set the output image size<br/>iwidth = 600<br/>iheight = 400</pre>
<ol start="5">
<li>Next, we need to determine the index of the population field so that we can get the population count for each area:</li>
</ol>
<pre style="padding-left: 60px"># Get the index of the population field<br/>pop_index = None<br/>dots = []<br/>for i,f in enumerate(inShp.fields):<br/>    if f[0] == 'POPULAT11':<br/>        # Account for deletion flag<br/>        pop_index = i-1</pre>
<ol start="6">
<li>Then, we calculate the population density value. We want to create a dot on the map for every 100 people:</li>
</ol>
<pre style="padding-left: 60px"># Calculate the density and plot points<br/>for sr in inShp.shapeRecords():<br/>    population = sr.record[pop_index]<br/>    # Density ratio - 1 dot per 100 people<br/>    density = population / 100<br/>    found = 0</pre>
<ol start="7">
<li>We will loop through each polygon and randomly distribute the points to create a density map:</li>
</ol>
<pre style="padding-left: 60px"># Randomly distribute points until we<br/># have the correct density<br/>while found &lt; density:<br/>    minx, miny, maxx, maxy = sr.shape.bbox<br/>    x = random.uniform(minx,maxx)<br/>    y = random.uniform(miny,maxy)<br/>    if point_in_poly(x,y,sr.shape.points):<br/>        dots.append((x,y))<br/>        found += 1</pre>
<ol start="8">
<li>We're now ready to create our output image:</li>
</ol>
<pre style="padding-left: 60px"># Set up the PNG output image<br/>c = pngcanvas.PNGCanvas(iwidth,iheight)<br/># Draw the red dots<br/>c.color = (255,0,0,0xff)<br/>for d in dots:<br/>    # We use the *d notation to exand the (x,y) tuple<br/>    x,y = world2screen(inShp.bbox, iwidth, iheight, *d)<br/>    c.filled_rectangle(x-1,y-1,x+1,y+1)</pre>
<ol start="9">
<li>Our dots have been created. Now, we need to create the outlines of the census tract:</li>
</ol>
<pre style="padding-left: 60px"># Draw the census tracts<br/>c.color = (0,0,0,0xff)<br/>for s in inShp.iterShapes():<br/>    pixels = []<br/>    for p in s.points:<br/>        pixel = world2screen(inShp.bbox, iwidth, iheight, *p)<br/>        pixels.append(pixel)<br/>    c.polyline(pixels)</pre>
<ol start="10">
<li>Finally, we'll save the output image:</li>
</ol>
<pre style="padding-left: 60px"># Save the image<br/>with open('DotDensity.png','wb') as img:<br/>    img.write(c.dump())</pre>
<p>This script outputs an outline of the census tract, along with the density dots, to show population concentration very effectively:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/59b0b86e-4854-46c0-ab62-a32cd4ffbd3e.png" style="width:25.42em;height:16.92em;" width="600" height="400"/></p>
<p>Now, let's check out the second type of map: choropleth maps.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Choropleth maps</h1>
                
            
            
                
<p>A choropleth uses shading, coloring, or symbols to show an average value or quantity within an area. They make it easy for us to visualize large amounts of data as a summary. This method is useful if related data spans multiple polygons. For example, in a worldwide population density map by country, many countries have disconnected polygons (for example, Hawaii is an island state of the US).</p>
<p>In this example, we'll use the <strong>Python Imaging Library</strong> (<strong>PIL</strong>) we discussed in <a href="a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml">Chapter 3</a>, <em>The Geospatial Technology Landscape</em>. PIL is not purely Python but is designed specifically for Python. We'll recreate our previous dot density example as a choropleth map. We'll calculate a density ratio for each census tract based on the number of people (population) per square kilometer and use that value to adjust the color. Dark is more densely populated while lighter is less. Follow these steps:</p>
<ol>
<li>First, we will import our libraries:</li>
</ol>
<pre style="padding-left: 60px">import math<br/>import shapefile<br/>try:<br/>   import Image<br/>   import ImageDraw<br/>except:<br/>   from PIL import Image, ImageDraw</pre>
<ol start="2">
<li>Then, we'll need our geospatial coordinates to image coordinates conversion function:</li>
</ol>
<pre style="padding-left: 60px">def world2screen(bbox, w, h, x, y):<br/>    '''convert geospatial coordinates to pixels'''<br/>    minx,miny,maxx,maxy = bbox<br/>    xdist = maxx - minx<br/>    ydist = maxy - miny<br/>    xratio = w/xdist<br/>    yratio = h/ydist<br/>    px = int(w - ((maxx - x) * xratio))<br/>    py = int((maxy - y) * yratio)<br/>    return (px,py)</pre>
<ol start="3">
<li>Now, we open our shapefile and set our output image size:</li>
</ol>
<pre style="padding-left: 60px"># Open our shapefile<br/>inShp = shapefile.Reader('GIS_CensusTract_poly')<br/>iwidth = 600<br/>iheight = 400</pre>
<ol start="4">
<li>We then set up PIL to draw our map image:</li>
</ol>
<pre style="padding-left: 60px"># PIL Image<br/>img = Image.new('RGB', (iwidth,iheight), (255,255,255))<br/># PIL Draw module for polygon fills<br/>draw = ImageDraw.Draw(img)</pre>
<ol start="5">
<li>Just like our previous example, we need to get the index of the population field:</li>
</ol>
<pre style="padding-left: 60px"># Get the population AND area index<br/>pop_index = None<br/>area_index = None<br/># Shade the census tracts<br/>for i,f in enumerate(inShp.fields):<br/>    if f[0] == 'POPULAT11':<br/>        # Account for deletion flag<br/>        pop_index = i-1<br/>    elif f[0] == 'AREASQKM':<br/>        area_index = i-1</pre>
<ol start="6">
<li>Now, we can draw the polygons, shade them according to population density, and save the image:</li>
</ol>
<pre># Draw the polygons<br/>for sr in inShp.shapeRecords():<br/>    density = sr.record[pop_index]/sr.record[area_index]<br/>    # The 'weight' is a scaled value to adjust the color<br/>    # intensity based on population<br/>    weight = min(math.sqrt(density/80.0), 1.0) * 50<br/>    R = int(205 - weight)<br/>    G = int(215 - weight)<br/>    B = int(245 - weight)<br/>    pixels = []<br/>    for x,y in sr.shape.points:<br/>        (px,py) = world2screen(inShp.bbox, iwidth, iheight, x, y)<br/>        pixels.append((px,py))<br/>        draw.polygon(pixels, outline=(255,255,255), fill=(R,G,B))<br/>    img.save('choropleth.png')</pre>
<p>This script produces the following diagram with the relative density of tracks. You can adjust the color using the R, G, and B variables:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/53ca2791-0a19-4602-ae26-99d663441ae3.png" style="width:24.42em;height:16.25em;" width="600" height="400"/></p>
<p>Now that we can show statistical data from shapefiles, we can look at a statistical data source that is even more common than shapefiles: spreadsheets.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using spreadsheets</h1>
                
            
            
                
<p>Spreadsheets such as Microsoft Office Excel and Open Office Calc are inexpensive (even free), ubiquitous, easy to use, and great for recording structured data. For these reasons, spreadsheets are widely used to collect data for entry into a GIS format. As an analyst, you will find yourself working with spreadsheets frequently.</p>
<p>In the previous chapters, we discussed the CSV format, which is a text file with the same basic rows and columns data structure as a spreadsheet. For CSV files, you use Python's built-in <kbd>csv</kbd> module. But most of the time, people don't bother exporting a true spreadsheet to a generic CSV file. That's where the pure Python <kbd>xlrd</kbd> module comes into play. The name <kbd>xlrd</kbd> is short for <strong>Excel Reader</strong> and is available from PyPI. There is also an accompanying module, the <kbd>xlwt</kbd> (Excel Writer) module, for writing spreadsheets. These two modules make reading and writing Excel spreadsheets a snap. Combine it with PyShp and you can move back and forth between spreadsheets and shapefiles with ease. This example demonstrates converting a spreadsheet into a shapefile. We'll use a spreadsheet version of the New York City museum point data available at <a href="https://git.io/Jemi9">https://git.io/Jemi9</a>.</p>
<p>The spreadsheet contains the attribute data, followed by an <em>x</em> column with the longitude and a <em>y</em> column with the latitude. To export it to a shapefile, we'll execute the following steps:</p>
<ol>
<li>Open the spreadsheet.</li>
<li>Create a shapefile <kbd>Writer</kbd> object.</li>
<li>Capture the first row of the spreadsheet as the <kbd>dbf</kbd> columns.</li>
<li>Loop through each row of the spreadsheet and copy the attributes to <kbd>dbf</kbd>.</li>
<li>Create a point from the <em>x</em> and <em>y</em> spreadsheet columns.</li>
</ol>
<p>The script is as follows:</p>
<pre>import xlrd<br/>import shapefile<br/># Open the spreadsheet reader<br/>xls = xlrd.open_workbook('NYC_MUSEUMS_GEO.xls')<br/>sheet = xls.sheet_by_index(0)<br/># Open the shapefile writer<br/>w = shapefile.Writer(shapefile.POINT)<br/># Move data from spreadsheet to shapefile<br/>for i in range(sheet.ncols):<br/>    # Read the first header row<br/>    w.field(str(sheet.cell(0,i).value), 'C', 40)<br/>for i in range(1, sheet.nrows):<br/>    values = []<br/>    for j in range(sheet.ncols):<br/>        values.append(sheet.cell(i,j).value)<br/>    w.record(*values)<br/>    # Pull latitude/longitude from the last two columns<br/>    w.point(float(values[-2]),float(values[-1]))<br/>w.save('NYC_MUSEUMS_XLS2SHP')</pre>
<p>Converting a shapefile into a spreadsheet is a much less common operation, though not difficult. To convert a shapefile into a spreadsheet, you need to make sure you have an <em>x</em> and <em>y</em> column by using the <em>Adding fields</em> example from the <em>Editing shapefiles</em> section in this chapter. You would loop through the shapes and add the <em>x</em>, <em>y</em> values to those columns. Then, you would read the field names and column values from <kbd>dbf</kbd> into an <kbd>xlwt</kbd> spreadsheet object or a CSV file using the <kbd>csv</kbd> module. The coordinate columns are labeled in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e854dbdf-2cce-4df8-9e10-3178bdca4126.png" style="width:39.83em;height:28.67em;" width="1600" height="1153"/></p>
<p>In the next section, we'll use a spreadsheet as an input data source.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating heat maps</h1>
                
            
            
                
<p>A heat map is used to show the geographic clustering of data using a raster image that shows density. The clustering can also be weighed by using a field in the data to not only show geographic density but also an intensity factor. In this example, we'll use bear sighting data contained in the CSV dataset, which stores the data as points to create a heat map of the frequency of bear sightings in different areas of Mississippi. This dataset is so simple that's we're going to treat the CSV file as a text file, which is one of the nice features of a CSV file.</p>
<p>You can download the dataset here: <a href="https://git.io/fjtGL">https://git.io/fjtGL</a>.</p>
<p>The output is going to be a simple HTML web map that you can open in any web browser. The web map will be based on the excellent Leaflet JavaScript library. On top of that, we'll use the Python Folium library, which makes it easy  for us to create Leaflet web maps, in order to generate the HTML page:</p>
<pre>import os<br/>import folium<br/>from folium.plugins import HeatMap<br/>f = open('bear_sightings.csv', 'r')<br/>lines = f.readlines()<br/>lines.pop(0)<br/>data = []<br/>bears = [list(map(float, l.strip().split(','))) for l in lines]<br/>m = folium.Map([32.75, -89.52], tiles='stamentonerbackground', zoom_start=7, max_zoom=7, min_zoom=7)<br/>HeatMap(bears, max_zoom=16, radius=22, min_opacity=1, blur=30).add_to(m)<br/>m.save('heatmap.html')</pre>
<p>This script will create a file called <kbd>heatmap.html</kbd>. Open it in any web browser to see a similar image:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c2a59cc9-3722-430d-80af-409a4160d16f.png" width="1950" height="1219"/></p>
<p>Next, we'll learn how to use data generated by a GPS to collect field data such as the information in the preceding heatmap.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using GPS data</h1>
                
            
            
                
<p>The most common type of GPS data these days is the Garmin GPX format. We covered this XML format in <a href="ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml">Chapter 4</a>, <em>Geospatial Python Toolbox</em>, which has become an unofficial industry standard. Because it is an XML format, all of the well-documented rules of XML apply to it. However, there is another type of GPS data that pre-dates XML and GPX, called the <strong>National Marine Electronics Association</strong> (<strong>NMEA</strong>). This data is ASCII text sentences that are designed to be streamed.</p>
<p class="mce-root"/>
<p>You occasionally bump into this format from time to time because even though it is older and esoteric, it is still very much alive and well, especially for communicating ship locations via the <strong>Automated Identification System</strong> (<strong>AIS</strong>), which tracks ships globally. But as usual, you have a good option in pure Python. The <kbd>pynmea</kbd> module is available on PyPI. The following code is a small sample of NMEA sentences:</p>
<pre><strong>$GPRMC,012417.859,V,1856.599,N,15145.602,W,12.0,7.27,020713,,E\*4F</strong><br/><strong>$GPGGA,012418.859,1856.599,N,15145.602,W,0,00,,,M,,M,,\*54</strong><br/><strong>$GPGLL,1856.599,N,15145.602,W,012419.859,V\*35</strong><br/><strong>$GPVTG,7.27,T,,M,12.0,N,22.3,K\*52</strong><br/><strong>$GPRMC,012421.859,V,6337.596,N,12330.817,W,66.2,23.41,020713,,E\*74</strong></pre>
<p>To install the <kbd>pynmea</kbd> module from PyPI and download the complete sample file, you can view the following URL: <a href="http://git.io/vLbTv">http://git.io/vLbTv</a>. Then, you can run the following sample, which will parse the <kbd>NMEA</kbd> sentences into objects. The NMEA sentences contain a wealth of information:</p>
<pre>from pynmea.streamer import NMEAStream<br/>nmeaFile = open('nmea.txt')<br/>nmea_stream = NMEAStream(stream_obj=nmeaFile)<br/>next_data = nmea_stream.get_objects()<br/>nmea_objects = []<br/>while next_data:<br/>    nmea_objects += next_data<br/>    next_data = nmea_stream.get_objects()<br/># The NMEA stream is parsed!<br/># Let's loop through the<br/># Python object types:<br/>for nmea_ob in nmea_objects:<br/>    if hasattr(nmea_ob, 'lat'):<br/>        print('Lat/Lon: (%s, %s)' % (nmea_ob.lat, nmea_ob.lon))</pre>
<p>The latitudes and longitudes are stored in a format called <strong>degrees decimal minutes</strong>. For example, this random coordinate, 4533.35, is 45 degrees and 33.35 minutes. 0.35 of a minute is exactly 21 seconds. In another example, 16708.033 is 167 degrees and 8.033 minutes. 0.033 of a minute is approximately 2 seconds. You can find more information about the NMEA format at <a href="http://aprs.gids.nl/nmea/">http://aprs.gids.nl/nmea/</a>.</p>
<p>GPS data is an important location data source, but there's another way we can describe a point on the Earth using a street address. The method for locating a street address on the Earth is called geocoding.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Geocoding</h1>
                
            
            
                
<p>Geocoding is the process of converting a street address into latitude and longitude. This operation is critical to in-vehicle navigation systems and online driving direction websites. Python has two excellent geocoder libraries available named <kbd>geocoder</kbd> and <kbd>geopy</kbd>. Both take advantage of online geocoding services to allow you to geocode addresses programmatically. The geopy library even lets you reverse geocode to match a latitude and longitude to the nearest address:</p>
<ol>
<li>First, let's do a quick example with the <kbd>geocoder</kbd> library, which defaults to using Google Maps as its engine:</li>
</ol>
<pre style="padding-left: 60px">import geocoder<br/>g = geocoder.google('1403 Washington Ave, New Orleans, LA 70130')<br/>print(g.geojson)<br/># {'type': 'Feature', 'geometry': {'type': 'Point', 'coordinates': [-90.08421849999999, 29.9287839]},<br/>'bbox': {'northeast': [29.9301328802915, -90.0828695197085], 'southwest': [29.9274349197085, -90.0855674802915]},<br/>'properties': {'quality': 'street_address', 'lat': 29.9287839, 'city': 'New Orleans',<br/>'provider': 'google', 'geometry': {'type': 'Point', 'coordinates': [-90.08421849999999, 29.9287839]},<br/>'lng': -90.08421849999999, 'method': 'geocode', 'encoding': 'utf-8', 'confidence': 9, 'address': '1403 Washington Ave,<br/>New Orleans, LA 70130, USA', 'ok': True, 'neighborhood': 'Garden District', 'county': 'Orleans Parish',<br/>'accuracy': 'ROOFTOP', 'street': 'Washington Ave', 'location': '1403 Washington Ave, New Orleans, LA 70130',<br/>'bbox': {'northeast': [29.9301328802915, -90.0828695197085], 'southwest': [29.9274349197085, -90.0855674802915]},<br/>'status': 'OK', 'country': 'US', 'state': 'LA', 'housenumber': '1403', 'postal': '70130'}}<br/>print(g.wkt)<br/># 'POINT(-90.08421849999999 29.9287839)'</pre>
<p style="padding-left: 60px">Here, we print the GeoJSON record for that address, which contains all known information in Google's database. Then, we print out the returned latitude and longitude as a WKT string, which could be used as input to other operations such as checking whether the address is inside of a flood plain polygon. The documentation for this library also shows you how to switch to other online geocoding services such as Bing or Yahoo. Some of these services require an API key and may have request limits.</p>
<ol start="2">
<li>Now, let's look at the <kbd>geopy</kbd> library. In this example, we'll geocode against the <kbd>OpenStreetMap</kbd> database. Once we match the address to a location, we'll turn around and reverse geocode it:</li>
</ol>
<pre>from geopy.geocoders import Nominatim<br/>g = Nominatim()<br/>location = g.geocode('88360 Diamondhead Dr E, Diamondhead, MS 39525')<br/>rev = g.reverse('{},{}'.format(location.latitude, location.longitude))<br/>print(rev)<br/># NVision Solutions Inc., 88360, Diamondhead Drive East, Diamondhead, Hancock County, Mississippi, 39520,<br/># United States of America<br/>print(location.raw)<br/># {'class': 'office', 'type': 'yes', 'lat': '30.3961962', 'licence': 'Data © OpenStreetMap contributors,<br/># ODbL 1.0. http://www.openstreetmap.org/copyright', 'display\_name': 'NVision Solutions Inc.,<br/># 88360, Diamondhead Drive East, Diamondhead, Hancock County, Mississippi, 39520, United States of America',<br/># 'lon': '-89.3462139', 'boundingbox': ['30.3961462', '30.3962462', '-89.3462639', '-89.3461639'],<br/># 'osm\_id': '2470309304', 'osm\_type': 'node', 'place\_id': '25470846', 'importance': 0.421}</pre>
<p>Now that we know of several different ways to geocode, let's look at speeding up the process. If you have thousands of addresses to geocode, it can take a while. Using multiprocessing, you can reduce a geocoding process that might take days into a few hours.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Multiprocessing</h1>
                
            
            
                
<p>Geospatial datasets are very large. Processing them can take time, which can be hours or sometimes even days. But there's a way you can speed processing up for certain operations. Python's built-in multiprocessing module can spawn multiple processes on your computer to take advantage of all of the available processors.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>One operation that works really well with the multiprocessing module is geocoding. In this example, we'll geocode a list of cities and split that processing across all of the processors on your machine. We'll use the same geocoding technique as before, but this time, we'll add the multiprocessing module to increase the potential for greater speed and scalability. The following code will geocode a list of cities simultaneously across multiple processors:</p>
<ol>
<li>First, we import the modules we need:</li>
</ol>
<pre style="padding-left: 60px"># Import our geocoding module<br/>from geopy.geocoders import Nominatim<br/># Import the multiprocessing module<br/>import multiprocessing as mp</pre>
<ol start="2">
<li>Next, we create our geocoder object:</li>
</ol>
<pre style="padding-left: 60px"># Create our geocoder<br/>g = Nominatim()</pre>
<ol start="3">
<li>Now, we need a function to geocode and individual address:</li>
</ol>
<pre style="padding-left: 60px"># Create a function to geocode an individual address<br/>def gcode(address):<br/>    location = g.geocode(address)<br/>    print("Geocoding: {}".format(address))<br/>    return location</pre>
<ol start="4">
<li>Next, we create our list of cities to process:</li>
</ol>
<pre style="padding-left: 60px"># Our list of cities to process<br/>cities = ["New Orleans, LA", "Biloxi, MS", "Memphis, TN",<br/>"Atlanta, GA", "Little Rock, AR", "Destin, FL"]</pre>
<ol start="5">
<li>Then, we set up our processor pool based on the number of processors available:</li>
</ol>
<pre style="padding-left: 60px"># Create our processor pool counting all of the processors<br/># on the machine.<br/>pool = mp.Pool(processes=mp.cpu_count())</pre>
<ol start="6">
<li>Next, we map our list of cities to the geocode function though the processor pool:</li>
</ol>
<pre style="padding-left: 60px"># Map our cities list to the geocoding function<br/># and allow the processor pool to split it<br/># across processors<br/>results = pool.map(gcode, cities)</pre>
<ol start="7">
<li>Then, we can print the results:</li>
</ol>
<pre style="padding-left: 60px"># Now print the results<br/>print(results)<br/> <br/># [Location(New Orleans, Orleans Parish, Louisiana, USA, (29.9499323, -90.0701156, 0.0)),<br/># Location(Biloxi, Harrison County, Mississippi, USA, (30.374673, -88.8459433348286, 0.0)),<br/># Location(Memphis, Shelby County, Tennessee, USA, (35.1490215, -90.0516285, 0.0)),<br/># Location(Atlanta, Fulton County, Georgia, USA, (33.7490987, -84.3901849, 0.0)),<br/># Location(Little Rock, Arkansas, USA, (34.7464809, -92.2895948, 0.0)),<br/># Location(Destin, Okaloosa County, Florida, USA, (30.3935337, -86.4957834, 0.0))]</pre>
<p>This technique can be very powerful, but not every type of processing can be performed this way. The type of processing  you use has to support operations that can be broken apart into discrete calculations. But when you can break problems apart, like we did in this example, the results are orders of magnitude faster.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter covered the critical components of GIS analysis. We examined the challenges of measuring on the curved surface of the Earth using different approaches. We looked at the basics of coordinate conversion and full reprojection using OGR, the <kbd>utm</kbd> module with PyShp, and Fiona, which simplifies OGR. We edited shapefiles and performed spatial and attribute selections. We created thematic maps from scratch using only Python. We also imported data from spreadsheets. Then, we parsed GPS data from NMEA streams. Finally, we used geocoding to convert street addresses into locations and back.</p>
<p>As a geospatial analyst, you may be familiar with both GIS and remote sensing, but most analysts specialize in one field or the other. That is why this book approaches the fields in separate chapters – so that we can focus on their differences. As we mentioned in the introduction, the techniques in this chapter are the building blocks for all geospatial analysis and will give you the tools you need so that you can learn about any aspect of this field.</p>
<p>In <a href="13990656-5786-445c-878b-8b262ad6f3c0.xhtml">Chapter 6</a>, <em>Python and Remote Sensing</em>, we'll tackle remote sensing. In GIS, we have been able to explore this field using pure Python modules. In remote sensing, we'll become more dependent on bindings to compiled modules written in C due to the sheer size and complexity of the data.</p>


            

            
        
    </div>



  </body></html>