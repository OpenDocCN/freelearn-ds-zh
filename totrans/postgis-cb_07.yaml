- en: Into the Nth Dimension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing LiDAR data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing 3D queries on a LiDAR point cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing and serving buildings 2.5D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ST_Extrude to extrude building footprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating arbitrary 3D objects for PostGIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting models as X3D for the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconstructing Unmanned Aerial Vehicle (UAV) image footprints with PostGIS 3D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UAV photogrammetry in PostGIS – point cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UAV photogrammetry in PostGIS – DSM creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the 3D capabilities of PostGIS. We will focus
    on three main categories: how to insert 3D data into PostGIS, how to analyze and
    perform queries using 3D data, and how to dump 3D data out of PostGIS. This chapter
    will use 3D point clouds as 3D data, including LiDAR data and those derived from
    **Structure from Motion** (**SfM**) techniques. Additionally, we will build a
    function that extrudes building footprints to 3D.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that for this chapter, we will address the postgreSQL-pointcloud
    extension; point clouds are usually large data sets of a three dimensional representation
    of point coordinates in a coordinate system. Point clouds are used to represent
    surfaces of sensed objects with great accuracy, such as by using geographic LiDAR
    data. The pointcloud extension will help us store LiDAR data into point cloud
    objects in our database. Also, this extension adds functions that allow you to
    transform point cloud objects into geometries and do spatial filtering using point
    cloud data. For more information about this extension, you can visit the official
    GitHub repository at [https://github.com/pgpointcloud/pointcloud](https://github.com/pgpointcloud/pointcloud).
    In addition, you can check out Paul Ramsey's tutorial at [http://workshops.boundlessgeo.com/tutorial-lidar/](http://workshops.boundlessgeo.com/tutorial-lidar/).
  prefs: []
  type: TYPE_NORMAL
- en: Download the example datasets we have for your use, available at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: Importing LiDAR data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Light Detection And Ranging** (**LiDAR**) is one of the most common devices
    for generating point cloud data. The system captures 3D location and other properties
    of objects or surfaces in a given space. This approach is very similar to radar
    in that it uses electromagnetic waves to measure distance and brightness, among
    other things. However, one main difference between LIDAR and radar is that the
    first one uses laser beam technology, instead of microwaves or radio waves. Another
    distinction is that LiDAR generally sends out a single focused pulse and measures
    the time of the returned pulse, calculating distance and depth. Radar, by contrast,
    will send out multiple pulses before receiving return pulses and thus, requires
    additional processing to determine the source of each pulse.'
  prefs: []
  type: TYPE_NORMAL
- en: LiDAR data has become quite common in conjunction with both ground and airborne
    applications, aiding in ground surveys, enhancing and substantially automating
    aspects of photogrammetric engineering. There are many data sources with plenty
    of LiDAR data.
  prefs: []
  type: TYPE_NORMAL
- en: LiDAR data is typically distributed in the **LAS** or **LASer** **format.**
    The **American Society for Photogrammetry and Remote Sensing** (**ASPRS**) established
    the LAS standard. LAS is a binary format, so reading it to push into a PostGIS
    database is non-trivial. Fortunately, we can make use of the open source tool
    PDAL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our source data will be in the LAS format, which we will insert into our database
    using the PDAL library, available at [https://www.pdal.io/](https://www.pdal.io/).
    This tool is available for Linux/UNIX and Mac users; for Windows, it is available
    with the OSGeo4W package ([https://www.pdal.io/workshop/osgeo4w.html](https://www.pdal.io/workshop/osgeo4w.html)).
  prefs: []
  type: TYPE_NORMAL
- en: LAS data can contain a lot of interesting data, not just *X*, *Y*, and *Z* values.
    It can include the intensity of the return from the object sensed and the classification
    of the object (ground versus vegetation versus buildings). When we place our LAS
    file in our PostGIS database, we can optionally collect any of this information.
    Furthermore, PDAL internally constructs a pipeline to translate data for reading,
    processing, and writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In preparation for this, we need to create a JSON file that represents the
    PDAL processing pipeline. For each LAS file, we create a JSON file to configure
    the reader and the writer to use the postgres-pointcloud option. We also need
    to write the database connection parameters. For the test file `test_1.las`, the
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20526f23-bacc-41d8-beb5-e26f1c3fa9eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can download our data. It is recommended to either download it from
    [http://gis5.oit.ohio.gov/geodatadownload/](http://gis5.oit.ohio.gov/geodatadownload/)
    or to download the sample dataset we have for your use, available at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to convert our LAS file to a format that can be used by PDAL.
    We created a Python script, which reads from a directory of LAS files and generates
    its corresponding JSON. With this script, we can automate the generation if we
    have a large directory of files. Also, we chose Python for its simplicity and
    because you can execute the script regardless of the operating system you are
    using. To execute the script, run the following in the console (for Windows users,
    make sure you have the Python interpreter included in the `PATH` variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This script will read each LAS file, and will store within a folder called `pipelines`
    all the metadata related to the LAS file that will be inserted into the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using PDAL, we execute a `for` loop to insert LAS files into Postgres:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This point cloud data is split into three different tables. If we want to merge
    them, we need to execute the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The postgres-pointcloud extension uses two main point cloud objects as variables:
    the *PcPoint* object, which is a point that can have many dimensions, but a minimum
    of X and Y values that are placed in a space; and the *PcPatch* object,which is
    a collection of multiple PcPoints that are close together. According to the documentation
    of the plugin, it becomes inefficient to store large amounts of points as individual
    records in a table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all of our data into our database within a single table, if
    we want to visualize our point cloud data, we need to create a spatial table to
    be understood by our layer viewer; for instance, QGIS. The point cloud plugin
    for Postgres has PostGIS integration, so we can transform our *PcPatch* and *PcPoint*
    objects into geometries and use PostGIS functions for analyzing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This SQL script performs an inner query, which initially returns a set of *PcPoints*
    from the *PcPatch* using the `PC_Explode` function. Then, for each point returned,
    we cast from  *PcPoint* object to a PostGIS geometry object. Finally, we create
    the `gid` column and add it to the table as a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can view our data using our favorite desktop GIS, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dc6fd63-5802-48ec-9972-c554932f59a3.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Performing 3D queries on a LiDAR point cloud* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing 3D queries on a LiDAR point cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Importing LiDAR data*, we brought a LiDAR 3D point
    cloud into PostGIS, creating an explicit 3D dataset from the input. With the data
    in 3D form, we have the ability to perform spatial queries against it. In this
    recipe, we will leverage 3D indexes so that our nearest-neighbor search works
    in all the dimensions our data are in.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the LiDAR data imported in the previous recipe as our dataset of
    choice. We named that table `chp07.lidar`. To perform a nearest-neighbor search,
    we will require an index created on the dataset. Spatial indexes, much like ordinary
    database table indexes, are similar to book indexes insofar as they help us find
    what we are looking for faster. Ordinarily, such an index-creation step would
    look like the following (which we won''t run this time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A 3D index does not perform as quickly as a 2D index for 2D queries, so a `CREATE
    INDEX` query defaults to creating a 2D index. In our case, we want to force the
    gist to apply to all three dimensions, so we will explicitly tell PostgreSQL to
    use the n-dimensional version of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the approach depicted in the previous code would also work if we
    had a time dimension or a 3D plus time. Let''s load a second 3D dataset and the
    stream centerlines that we will use in our query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This data, as shown in the following image, overlays nicely with our LiDAR
    point cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd9b14d3-2d3c-427e-a1fa-bb13be93becf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can build a simple query to retrieve all the LiDAR points within one
    foot of our stream centerline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But, this is a little bit of a sloppy approach; we could end up with duplicate
    LiDAR points, so we will refine our query with `LEFT JOIN` and `SELECT DISTINCT`
    instead, but continue using `ST_DWithin` as our limiting condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can visualize our returned points, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f5387c4-7252-4aac-bbc8-90a34b835908.png)'
  prefs: []
  type: TYPE_IMG
- en: Try this query using `ST_DWithin` instead of `ST_3DDWithin`. You'll find an
    interesting difference in the number of points returned, since `ST_DWithin` will
    collect LiDAR points that may be close to our streamline in the XY plane, but
    not as close when looking at a 3D distance.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine `ST_3DWithin` querying within a tunnel around our line. `ST_DWithin`,
    by contrast, is going to query a vertical wall of LiDAR points, as it is only
    searching for adjacent points based on XY distance, ignoring height altogether,
    and thus gathering up all the points within a narrow wall above and below our
    points.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing and serving buildings 2.5D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Detailed building footprints from LiDAR* recipe in [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml),
    *Working with Vector Data - Advanced Recipes*, we explored the automatic generation
    of building footprints using LiDAR data. What we were attempting to do was create
    2D data from 3D data. In this recipe, we attempt the opposite, in a sense. We
    start with 2D polygons of building footprints and feed them into a function that
    extrudes them as 3D polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will extrude a building footprint of our own making. Let
    us quickly create a table with a single building footprint, for testing purposes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be beneficial to keep the creation of 3D buildings encapsulated as
    simply as possible in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function takes two inputs: the building footprint and a height to extrude
    to. We can also imagine a function that takes in a third parameter: the height
    of the base of the building.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct the building walls, we will need to first convert our polygons
    into linestrings and then further separate the linestrings into their individual,
    two-point segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code returns each of the two-point segments of our original shape.
    For example, for `simple_building,` the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8b5d4be-7870-44db-8cf2-520f5b8b93dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a series of individual lines, we can use those to construct
    the walls of the building. First, we need to recast our 2D lines as 3D using `ST_Force3DZ`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a2d705f-5b92-486a-bb6b-f8215a0d2326.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to break each of those lines from `MULTILINESTRING` into many
    `LINESTRINGS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0306df57-a196-4da2-a91b-a74fd66da846.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to construct a line representing the boundary of the extruded
    wall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to convert each linestring to `polygon.threeDwall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, put in the roof and floor on our building, using the original geometry
    for the floor (forced to 3D) and a copy of the original geometry translated to
    our input height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We put the walls, roof, and floor together and, during the process, convert
    this to a 3D `MULTIPOLYGON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'While we could leave our geometry as a `MULTIPOLYGON`, we''ll do things properly
    and munge an informal cast to `POLYHEDRALSURFACE`. In our case, we are already
    effectively formatted as a `POLYHEDRALSURFACE`, so we''ll just convert our geometry
    to text with `ST_AsText`, replace the word with `POLYHEDRALSURFACE`, and then
    convert our text back to geometry with `ST_GeomFromText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the entire function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a 3D-building extrusion function, we can easily extrude our
    building footprint with our nicely encapsulated function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply this function to a real building footprint dataset (available
    in our data directory), in which case, if we have a height field, we can extrude
    according to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output gives us a nice, extruded set of building footprints,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b9104f4-1cac-40b2-92a2-18103221083a.png)'
  prefs: []
  type: TYPE_IMG
- en: The *Detailed building footprints from LiDAR* recipe in [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml),
    *Working with Vector Data - Advanced Recipes*, explores the extraction of building
    footprints from LiDAR. A complete workflow could be envisioned, which extracts
    building footprints from LiDAR and then reconstructs polygon geometries using
    the current recipe, thus converting point clouds to surfaces, combining the current
    recipe with the one referenced previously.
  prefs: []
  type: TYPE_NORMAL
- en: Using ST_Extrude to extrude building footprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostGIS 2.1 brought a lot of really cool additional functionality to PostGIS.
    Operations on PostGIS raster types are among the more important improvements that
    come with PostGIS 2.1\. A quieter and equally potent game changer was the addition
    of the SFCGAL library as an optional extension to PostGIS. According to the website
    [http://sfcgal.org/](http://sfcgal.org/), SFCGAL is a C++ wrapper library around
    CGAL with the aim of supporting ISO 19107:2013 and OGC Simple Features Access
    1.2 for 3D operations.
  prefs: []
  type: TYPE_NORMAL
- en: From a practical standpoint, what does this mean? It means that PostGIS is moving
    toward a fully functional 3D environment, from representation of the geometries
    themselves and the operations on those 3D geometries. More information is available
    at [http://postgis.net/docs/reference.html#reference_sfcgal](http://postgis.net/docs/reference.html#reference_sfcgal).
  prefs: []
  type: TYPE_NORMAL
- en: 'This and several other recipes will assume that you have a version of PostGIS
    installed with SFCGAL compiled and enabled. Doing so enables the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ST_Extrude`: This extrudes a surface to a related volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_StraightSkeleton`: This computes a straight skeleton from a geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_IsPlanar`: This checks whether a surface is a planar or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_Orientation`: This determines the surface orientation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_ForceLHR`: This forces LHR orientation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_MinkowskiSum`: This computes the Minkowski sum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_Tesselate`: This performs surface Tessellation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll use `ST_Extrude` in much the same way we used our own
    custom-built function in the previous recipe, *Constructing and serving buildings
    2.5D*. The advantage over the previous recipe is that we are not required to have
    the SFCGAL library compiled in PostGIS. The advantage to this recipe is that we
    have more control over the extrusion process; that is, we can extrude in all three
    dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '`ST_Extrude` returns a geometry, specifically a polyhedral surface. It requires
    four parameters: an input geometry and the extrusion amount along the *X*, *Y*,
    and *Z* axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4a0d0f7c-cec0-455e-81fc-92fd42b7f23e.png)'
  prefs: []
  type: TYPE_IMG
- en: And so, with the help of the *Constructing and serving buildings 2.5D* recipe,
    we get our extruded buildings, but with some additional flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arbitrary 3D objects for PostGIS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sources of 3D information are not only generated from LiDAR, nor are they purely
    synthesized from 2D geometries and associated attributes as in the *Constructing
    and serving buildings 2.5D* and *Using ST_Extrude to extrude building footprints*
    recipes, but they can also be created from the principles of computer vision as
    well. The process of calculating 3D information from the association of related
    keypoints between images is known as SfM.
  prefs: []
  type: TYPE_NORMAL
- en: As a computer vision concept, we can leverage SfM to generate 3D information
    in ways similar to how the human mind perceives the world in 3D, and further store
    and process that information in a PostGIS database.
  prefs: []
  type: TYPE_NORMAL
- en: Computer vision is a discipline within computer science focused on automated
    analysis and inference from images and video. It is considered a research area
    that develops algorithms that interpret the world in a way that is similar to
    human vision. An excellent summary can be found at [http://en.wikipedia.org/wiki/Computer_vision](http://en.wikipedia.org/wiki/Computer_vision).
  prefs: []
  type: TYPE_NORMAL
- en: A number of open source projects have matured to deal with solving SfM problems.
    Popular among these are Bundler, which can be found at [http://phototour.cs.washington.edu/bundler/](http://phototour.cs.washington.edu/bundler/),
    and **VisualSFM** at [http://ccwu.me/vsfm/](http://ccwu.me/vsfm/). Binaries exist
    for multiple platforms for these tools, including versions. The nice thing about
    such projects is that a simple set of photos can be used to reconstruct 3D scenes.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we will use VisualSFM and skip the installation and configuration
    of this software. The reason for this is that SfM is beyond the scope of a PostGIS
    book to cover in detail, and we will focus on how we can use the data in PostGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to understand that SfM techniques, while highly effective, have
    certain limitations in the kinds of imagery that can be effectively processed
    into point clouds. The techniques are dependent upon finding matches between subsequent
    images and thus can have trouble processing images that are smooth, are missing
    the camera's embedded **Exchangeable Image File Format** (**EXIF**) information,
    or are from cell phone cameras.
  prefs: []
  type: TYPE_NORMAL
- en: EXIF tags are a metadata format for images. Stored in these tags are often the
    camera settings, camera type, lens type, and other information relevant to SfM
    extraction.
  prefs: []
  type: TYPE_NORMAL
- en: We will start processing an image series into a point cloud with a photo series
    that we know largely works, but as you experiment with SfM, you can feed in your
    own photo series. Good tips on how to create a photo series that will result in
    a 3D model can be found at [https://www.youtube.com/watch?v=IStU-WP2XKs&t=348s](https://www.youtube.com/watch?v=IStU-WP2XKs&t=348s)
    and [http://www.cubify.com/products/capture/photography_tips.aspx](http://www.cubify.com/products/capture/photography_tips.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download VisualSFM from [http://ccwu.me/vsfm/](http://ccwu.me/vsfm/). In a
    console terminal, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: VisualSFM will start rendering the 3D, model using as input a folder with images.
    It will take a couple of hours to process. Then, when it finishes, it will return
    a point cloud file.
  prefs: []
  type: TYPE_NORMAL
- en: We can view this data in a program such as **MeshLab** at [http://meshlab.sourceforge.net/](http://meshlab.sourceforge.net/).
    A good tutorial on using MeshLab to view point clouds can be found at [http://www.cse.iitd.ac.in/~mcs112609/Meshlab%20Tutorial.pdf](http://www.cse.iitd.ac.in/~mcs112609/Meshlab%20Tutorial.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows what our point cloud looks like when viewed in MeshLab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8eff27ef-10d9-4ce5-a42c-039fea1e9ec7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the VisualSFM output, there is a file with the extension `.ply`, for example,
    `giraffe.ply` (included in the source code for this chapter). If you open this
    file in a text editor, it will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df01490c-c68e-4000-bd9a-b0605bc8fda5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the header portion of our file. It specifies the .`ply` format, the
    encoding `format ascii 1.0`, the number of vertices, and then the column names
    for all the data returned: `x`, `y`, `z`, `nx`, `ny`, `nz`, `red`, `green`, and
    `blue`.'
  prefs: []
  type: TYPE_NORMAL
- en: For importing into PostGIS, we will import all the fields, but will focus on
    `x`, `y`, and `z` for our point cloud, as well as look at color. For our purposes,
    this file specifies relative `x`, `y`, and `z` coordinates, and the color of each
    of those points in channels `red`, `green`, and `blue`. These colors are 24-bit
    colors—and thus they can have integer values between 0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the remainder of the recipe, we will create a PDAL pipeline, modifying
    the JSON structure reader to be a `.ply` file. Check the recipe for *Importing
    LiDAR data* in this chapter to see how to create a PDAL pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we execute in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This output will serve us for input in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting models as X3D for the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Entering 3D data in a PostGIS database is not nearly as interesting if we have
    no capacity for extracting the data back out in some useable form. One way to
    approach this problem is to leverage the PostGIS ability to write 3D tables to
    the X3D format.
  prefs: []
  type: TYPE_NORMAL
- en: X3D is an XML standard for displaying 3D data and works well via the web. For
    those familiar with **Virtual Reality Modeling Language** (**VRML**), X3D is the
    next generation of that.
  prefs: []
  type: TYPE_NORMAL
- en: To view X3D in the browser, a user has the choice of a variety of plugins, or
    they can leverage JavaScript APIs to enable viewing. We will perform the latter,
    as it requires no user configuration to work. We will use X3DOM's JavaScript framework
    to accomplish this. X3DOM is a demonstration of the integration of HTML5 and 3D
    and uses **Web Graphics Library** (**WebGL**); ([https://en.wikipedia.org/wiki/WebGL](https://en.wikipedia.org/wiki/WebGL))
    to allow rendering and interaction with 3D content in the browser. This means
    that our data will not get displayed in browsers that are not WebGL compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the point cloud from the previous example to serve in X3D
    format. PostGIS documentation on X3D includes an example of using the `ST_AsX3D`
    function to output the formatted X3D code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We included the copy to `STDOUT WITH CSV` to make a dump in raw code. The user
    is able to save this query as an SQL script file and execute it from the console
    in order to dump the result into a file. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example, while complete in serving the pure X3D, needs additional code
    to allow in-browser viewing. We do so by including style sheets, and the appropriate
    X3DOM includes the headers of an XHTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The full query to generate the XHTML of X3D data is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open the `.html` file in our favorite browser, we will get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8f1d2a2-11c2-44b2-af55-190f175ad655.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One might want to use this X3D conversion as a function, feeding geometry into
    a function and getting a page in return. In this way, we can reuse the code easily
    for other tables. Embodied in a function, X3D conversion is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for the function to work, we need to first use `ST_UNION` on the geometry
    parameter to pass to the `AsX3D_XHTML` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can now very simply generate the appropriate XHTML directly from the command
    line or a web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Reconstructing Unmanned Aerial Vehicle (UAV) image footprints with PostGIS 3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rapid development of **Unmanned Aerial Systems** (**UAS**), also known as
    **Unmanned Aerial Vehicles** (**UAVs**), as data collectors is revolutionizing
    remote data collection in all sectors. Barriers to wider adoption outside military
    sectors include regulatory frameworks preventing their flight in some nations,
    such as, the United States, and the lack of open source implementations of post-processing
    software. In the next four recipes, we'll attempt preliminary solutions to the
    latter of these two barriers.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will be using the metadata from a UAV flight in Seneca County,
    Ohio, by the Ohio Department of Transportation to map the coverage of the flight.
    This is included in the code folder for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea for this recipe is to estimate the field of view of the UAV camera,
    generate a 3D pyramid that represents that field of view, and use the flight ephemeris
    (bearing, pitch, and roll) to estimate ground coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The metadata or ephemeris we have for the flight includes the bearing, pitch,
    and roll of the UAS, in addition to its elevation and location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b1d3e5-d649-4461-9f24-fa7b848ce352.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To translate these ephemeris into PostGIS terms, we''ll assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 90 degrees minus the pitch is equivalent to `ST_RotateX`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The negative roll is equivalent to `ST_RotateY`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 90 degrees minus the bearing is equivalent to `ST_RotateZ`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to perform our analysis, we require external functions. These functions
    can be downloaded from [https://github.com/smathermather/postgis-etc/tree/master/3D](https://github.com/smathermather/postgis-etc/tree/master/3D).
  prefs: []
  type: TYPE_NORMAL
- en: We will use patched versions of `ST_RotateX`, `ST_RotateY` (`ST_RotateX.sql`,
    and `ST_RotateY.sql`), which allow us to rotate geometries around an input point,
    as well as a function for calculating our field of view, `pyramidMaker.sql`. Future
    versions of PostGIS will include these versions of `ST_RotateX` and `ST_RotateY`
    built in. We have another function, `ST_RotateXYZ`, which is built upon these
    and will also simplify our code by allowing us to specify three axes at the same
    time for rotation.
  prefs: []
  type: TYPE_NORMAL
- en: For the final step, we'll need the capacity to perform volumetric intersection
    (the 3D equivalent of intersection). For this, we'll use `volumetricIntersection.sql`,
    which allows us to just return the volumetric portion of the intersection as a
    **triangular irregular network** (**TIN**).
  prefs: []
  type: TYPE_NORMAL
- en: A TIN is a 3D surface model for representing surfaces and volumes as a mesh
    of triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install the functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to calculate the viewing footprint, we will calculate a rectangular
    pyramid descending from the viewpoint to the ground. This pyramid will need to
    point to the left and right of the nadir according to the UAS's roll, forward
    or backward from the craft according to its pitch, and be oriented relative to
    the direction of movement of the craft according to its bearing.
  prefs: []
  type: TYPE_NORMAL
- en: The `pyramidMaker` function will construct our pyramid for us and `ST_RotateXYZ`
    will rotate the pyramid in the direction we need to compensate for roll, pitch,
    and bearing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image is an example map of such a calculated footprint for a
    single image. Note the slight roll to the left for this example, resulting in
    an asymmetric-looking pyramid when viewed from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/104bebdd-9aa8-4eb6-836e-a2117231b533.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The total track for the UAS flight overlayed on a contour map is shown in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44b94751-c2db-4190-ac23-f8c526f32104.png)'
  prefs: []
  type: TYPE_IMG
- en: Total track for the flight viewed with QGIS
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a function to calculate our footprint pyramid. To input to the
    function, we''ll need the position of the UAS as geometry (origin), the pitch,
    bearing, and roll, as well as the field of view angle in `x` and `y` for the camera.
    Finally, we''ll need the relative height of the craft above ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our pyramid function assumes that we know what the base size of our pyramid
    is. We don''t know this initially, so we''ll calculate its size based on the field
    of view angle of the camera and the height of the craft:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have enough information to construct our pyramid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We will require the following code to rotate our view relative to pitch, roll,
    and bearing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to use our function, let us import the UAS positions from the `uas_locations`
    shapefile included in the source for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is possible to calculate an estimated footprint for each UAS position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you import this with your favorite desktop GIS, such as QGIS, you will be
    able to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5400b7a7-cfd6-492a-abf6-e056ca39ea44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With a terrain model, we can go a step deeper in this analysis. Since our UAS
    footprints are volumetric, we will first load the terrain model. We will load
    this from a `.backup` file included in the source code for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a smaller version of our `viewshed` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you import this with your favorite desktop GIS, such as QGIS, you will be
    able to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/384e3e01-1517-4988-a6c3-41176fe21b0a.png)'
  prefs: []
  type: TYPE_IMG
- en: UAV photogrammetry in PostGIS – point cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the techniques we've used in the previous recipe named *Creating
    arbitrary 3D objects for PostGIS* learn how to create and import a UAV-derived
    point cloud in PostGIS.
  prefs: []
  type: TYPE_NORMAL
- en: One caveat before we begin is that while we will be working with geospatial
    data, we will be doing so in relative space, rather than a known coordinate system.
    In other words, this approach will calculate our dataset in an arbitrary coordinate
    system. `ST_Affine` could be used in combination with the field measurements of
    locations to transform our data into a known coordinate system, but this is beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like with the *Creating arbitrary 3D objects for PostGIS* recipe,  we will
    be taking an image series and converting it into a point cloud. In this case,
    however, our image series will be from UAV imagery. Download the image series
    included in the code folder for this chapter, `uas_flight`, and feed it into VisualSFM
    (check [http://ccwu.me/vsfm/](http://ccwu.me/vsfm/)for more information on how
    to use this tool); in order to retrieve a point cloud, name it `uas_points.ply`
    (this file is also included in this folder in case you would rather use it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The input for PostGIS is the same as before. Create a JSON file and use PDAL
    store it into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we copy data from the point cloud into our table. Refer to the *Importing
    LiDAR data recipe* in this chapter to verify the pointcloud extension object representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This data, as viewed in MeshLab ([http://www.meshlab.net/](http://www.meshlab.net/))
    from the .`ply` file, is pretty interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc8744f6-98ec-48ba-bc78-27cb1f19ed45.png)'
  prefs: []
  type: TYPE_IMG
- en: The original data is color infrared imagery, so vegetation shows up red, and
    farm fields and roads as gray. Note the bright colors in the sky; those are camera
    position points that we'll need to filter out.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to generate orthographic imagery from this data.
  prefs: []
  type: TYPE_NORMAL
- en: UAV photogrammetry in PostGIS – DSM creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The photogrammetry example would be incomplete if we did not produce a digital
    terrain model from our inputs. A fully rigorous solution where the input point
    cloud would be classified into ground points, building points, and vegetation
    points is not feasible here, but this recipe will provide the basic framework
    for accomplishing such a solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a 3D TIN, which will represent the surface of
    the point cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, `ST_DelaunayTriangles` is available only in PostGIS 2.1 using
    GEOS 3.4\. This is one of the few recipes in this book to require such advanced
    versions of PostGIS and GEOS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ST_DelaunayTriangles` will calculate a 3D TIN with the correct flag: geometry
    `ST_DelaunayTriangles` (geometry `g1`, float `tolerance`, int4 `flags`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a full TIN of a digital surface model at our disposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e8abb92-9074-4cf2-a2ca-dc36daabb460.jpg)'
  prefs: []
  type: TYPE_IMG
