- en: Into the Nth Dimension
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入第N维
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Importing LiDAR data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入激光雷达数据
- en: Performing 3D queries on a LiDAR point cloud
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在激光雷达点云上执行3D查询
- en: Constructing and serving buildings 2.5D
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和提供2.5D建筑
- en: Using ST_Extrude to extrude building footprints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ST_Extrude扩展建筑底图
- en: Creating arbitrary 3D objects for PostGIS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为PostGIS创建任意3D对象
- en: Exporting models as X3D for the web
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型导出为X3D格式以供网页使用
- en: Reconstructing Unmanned Aerial Vehicle (UAV) image footprints with PostGIS 3D
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostGIS 3D重建无人机（UAV）图像底图
- en: UAV photogrammetry in PostGIS – point cloud
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostGIS中的无人机摄影测量 – 点云
- en: UAV photogrammetry in PostGIS – DSM creation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostGIS中的无人机摄影测量 – 创建数字表面模型（DSM）
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In this chapter, we will explore the 3D capabilities of PostGIS. We will focus
    on three main categories: how to insert 3D data into PostGIS, how to analyze and
    perform queries using 3D data, and how to dump 3D data out of PostGIS. This chapter
    will use 3D point clouds as 3D data, including LiDAR data and those derived from
    **Structure from Motion** (**SfM**) techniques. Additionally, we will build a
    function that extrudes building footprints to 3D.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨PostGIS的3D功能。我们将重点关注三个主要类别：如何将3D数据插入到PostGIS中，如何使用3D数据进行分析和执行查询，以及如何将3D数据从PostGIS中导出。本章将使用3D点云作为3D数据，包括激光雷达数据和由**运动结构**（**SfM**）技术派生出的数据。此外，我们将构建一个将建筑底图扩展到3D的功能。
- en: It is important to note that for this chapter, we will address the postgreSQL-pointcloud
    extension; point clouds are usually large data sets of a three dimensional representation
    of point coordinates in a coordinate system. Point clouds are used to represent
    surfaces of sensed objects with great accuracy, such as by using geographic LiDAR
    data. The pointcloud extension will help us store LiDAR data into point cloud
    objects in our database. Also, this extension adds functions that allow you to
    transform point cloud objects into geometries and do spatial filtering using point
    cloud data. For more information about this extension, you can visit the official
    GitHub repository at [https://github.com/pgpointcloud/pointcloud](https://github.com/pgpointcloud/pointcloud).
    In addition, you can check out Paul Ramsey's tutorial at [http://workshops.boundlessgeo.com/tutorial-lidar/](http://workshops.boundlessgeo.com/tutorial-lidar/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在本章中，我们将讨论postgreSQL-pointcloud扩展；点云通常是指在一个坐标系中三维点坐标的三维表示的大型数据集。点云用于以高精度表示感知对象的表面，例如使用地理激光雷达数据。pointcloud扩展将帮助我们将激光雷达数据存储到数据库中的点云对象中。此外，此扩展还添加了允许您将点云对象转换为几何形状并使用点云数据进行空间过滤的功能。有关此扩展的更多信息，您可以访问官方GitHub仓库[https://github.com/pgpointcloud/pointcloud](https://github.com/pgpointcloud/pointcloud)。此外，您还可以查看Paul
    Ramsey的教程[http://workshops.boundlessgeo.com/tutorial-lidar/](http://workshops.boundlessgeo.com/tutorial-lidar/)。
- en: Download the example datasets we have for your use, available at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下载我们提供的示例数据集以供您使用，可在[http://www.packtpub.com/support](http://www.packtpub.com/support)找到。
- en: Importing LiDAR data
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入激光雷达数据
- en: '**Light Detection And Ranging** (**LiDAR**) is one of the most common devices
    for generating point cloud data. The system captures 3D location and other properties
    of objects or surfaces in a given space. This approach is very similar to radar
    in that it uses electromagnetic waves to measure distance and brightness, among
    other things. However, one main difference between LIDAR and radar is that the
    first one uses laser beam technology, instead of microwaves or radio waves. Another
    distinction is that LiDAR generally sends out a single focused pulse and measures
    the time of the returned pulse, calculating distance and depth. Radar, by contrast,
    will send out multiple pulses before receiving return pulses and thus, requires
    additional processing to determine the source of each pulse.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**光探测与测距**（**LiDAR**）是生成点云数据最常用的设备之一。该系统捕捉给定空间中对象或表面的3D位置和其他属性。这种方法与雷达非常相似，因为它使用电磁波来测量距离和亮度等。然而，LiDAR与雷达的主要区别在于，前者使用激光束技术，而不是微波或无线电波。另一个区别是，LiDAR通常发送一个单一的聚焦脉冲并测量返回脉冲的时间，计算距离和深度。相比之下，雷达在接收到返回脉冲之前会发送多个脉冲，因此需要额外的处理来确定每个脉冲的来源。'
- en: LiDAR data has become quite common in conjunction with both ground and airborne
    applications, aiding in ground surveys, enhancing and substantially automating
    aspects of photogrammetric engineering. There are many data sources with plenty
    of LiDAR data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LiDAR 数据与地面和空中应用相结合已成为相当常见，有助于地面测量，增强并极大地自动化了摄影测量工程的一些方面。有许多数据源拥有大量的 LiDAR 数据。
- en: LiDAR data is typically distributed in the **LAS** or **LASer** **format.**
    The **American Society for Photogrammetry and Remote Sensing** (**ASPRS**) established
    the LAS standard. LAS is a binary format, so reading it to push into a PostGIS
    database is non-trivial. Fortunately, we can make use of the open source tool
    PDAL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: LiDAR 数据通常以 **LAS** 或 **LASer** **格式**分发。**美国摄影测量与遥感学会**（**ASPRS**）建立了 LAS 标准。LAS
    是一种二进制格式，因此将其读入 PostGIS 数据库是非平凡的。幸运的是，我们可以利用开源工具 PDAL。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Our source data will be in the LAS format, which we will insert into our database
    using the PDAL library, available at [https://www.pdal.io/](https://www.pdal.io/).
    This tool is available for Linux/UNIX and Mac users; for Windows, it is available
    with the OSGeo4W package ([https://www.pdal.io/workshop/osgeo4w.html](https://www.pdal.io/workshop/osgeo4w.html)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据源将以 LAS 格式存在，我们将使用可从 [https://www.pdal.io/](https://www.pdal.io/) 获取的 PDAL
    库将其插入到我们的数据库中。此工具适用于 Linux/UNIX 和 Mac 用户；对于 Windows，它可通过 OSGeo4W 软件包获得（[https://www.pdal.io/workshop/osgeo4w.html](https://www.pdal.io/workshop/osgeo4w.html)）。
- en: LAS data can contain a lot of interesting data, not just *X*, *Y*, and *Z* values.
    It can include the intensity of the return from the object sensed and the classification
    of the object (ground versus vegetation versus buildings). When we place our LAS
    file in our PostGIS database, we can optionally collect any of this information.
    Furthermore, PDAL internally constructs a pipeline to translate data for reading,
    processing, and writing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: LAS 数据可以包含很多有趣的数据，不仅仅是 *X*、*Y* 和 *Z* 值。它还可以包括从被感知对象返回的强度以及对象的分类（地面、植被、建筑物）。当我们将
    LAS 文件放入我们的 PostGIS 数据库中时，我们可以选择收集这些信息中的任何一项。此外，PDAL 内部构建一个管道来转换用于读取、处理和写入的数据。
- en: 'In preparation for this, we need to create a JSON file that represents the
    PDAL processing pipeline. For each LAS file, we create a JSON file to configure
    the reader and the writer to use the postgres-pointcloud option. We also need
    to write the database connection parameters. For the test file `test_1.las`, the
    code is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在为此做准备之前，我们需要创建一个表示 PDAL 处理管道的 JSON 文件。对于每个 LAS 文件，我们创建一个 JSON 文件来配置读取器和写入器使用
    postgres-pointcloud 选项。我们还需要编写数据库连接参数。对于测试文件 `test_1.las`，代码如下：
- en: '![](img/20526f23-bacc-41d8-beb5-e26f1c3fa9eb.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20526f23-bacc-41d8-beb5-e26f1c3fa9eb.png)'
- en: Now, we can download our data. It is recommended to either download it from
    [http://gis5.oit.ohio.gov/geodatadownload/](http://gis5.oit.ohio.gov/geodatadownload/)
    or to download the sample dataset we have for your use, available at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以下载我们的数据。建议您从 [http://gis5.oit.ohio.gov/geodatadownload/](http://gis5.oit.ohio.gov/geodatadownload/)
    下载，或者下载我们为您提供的样本数据集，可在 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    获取。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we need to convert our LAS file to a format that can be used by PDAL.
    We created a Python script, which reads from a directory of LAS files and generates
    its corresponding JSON. With this script, we can automate the generation if we
    have a large directory of files. Also, we chose Python for its simplicity and
    because you can execute the script regardless of the operating system you are
    using. To execute the script, run the following in the console (for Windows users,
    make sure you have the Python interpreter included in the `PATH` variable):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将我们的 LAS 文件转换为 PDAL 可以使用的格式。我们创建了一个 Python 脚本，该脚本从 LAS 文件目录中读取并生成相应的
    JSON。使用此脚本，如果我们有一个大文件目录，我们可以自动化生成。此外，我们选择 Python 是因为它简单，并且无论使用什么操作系统都可以执行脚本。要执行脚本，请在控制台中运行以下命令（对于
    Windows 用户，请确保 Python 解释器已包含在 `PATH` 变量中）：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This script will read each LAS file, and will store within a folder called `pipelines`
    all the metadata related to the LAS file that will be inserted into the database.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将读取每个 LAS 文件，并将与要插入数据库的 LAS 文件相关的所有元数据存储在名为 `pipelines` 的文件夹中。
- en: 'Now, using PDAL, we execute a `for` loop to insert LAS files into Postgres:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 PDAL，我们执行一个 `for` 循环将 LAS 文件插入到 Postgres：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This point cloud data is split into three different tables. If we want to merge
    them, we need to execute the following SQL command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这点云数据被分成三个不同的表。如果我们想合并它们，我们需要执行以下 SQL 命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The postgres-pointcloud extension uses two main point cloud objects as variables:
    the *PcPoint* object, which is a point that can have many dimensions, but a minimum
    of X and Y values that are placed in a space; and the *PcPatch* object,which is
    a collection of multiple PcPoints that are close together. According to the documentation
    of the plugin, it becomes inefficient to store large amounts of points as individual
    records in a table.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: postgres-pointcloud 扩展使用两个主要的点云对象作为变量：*PcPoint* 对象，它是一个可以有多个维度但至少包含 X 和 Y 值的点，这些值放置在空间中；以及
    *PcPatch* 对象，它是一组紧密相邻的多个 PcPoint。根据插件的文档，将大量点作为单个记录存储在表中会变得效率低下。
- en: 'Now that we have all of our data into our database within a single table, if
    we want to visualize our point cloud data, we need to create a spatial table to
    be understood by our layer viewer; for instance, QGIS. The point cloud plugin
    for Postgres has PostGIS integration, so we can transform our *PcPatch* and *PcPoint*
    objects into geometries and use PostGIS functions for analyzing the data:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有数据放入单个表中，如果我们想可视化点云数据，我们需要创建一个空间表，以便我们的图层查看器可以理解；例如，QGIS。Postgres 的点云插件具有
    PostGIS 集成，因此我们可以将 *PcPatch* 和 *PcPoint* 对象转换为几何对象，并使用 PostGIS 函数分析数据：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This SQL script performs an inner query, which initially returns a set of *PcPoints*
    from the *PcPatch* using the `PC_Explode` function. Then, for each point returned,
    we cast from  *PcPoint* object to a PostGIS geometry object. Finally, we create
    the `gid` column and add it to the table as a primary key.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 SQL 脚本执行一个内部查询，最初使用 `PC_Explode` 函数从 *PcPatch* 返回一组 *PcPoints*。然后，对于返回的每个点，我们将从
    *PcPoint* 对象转换为 PostGIS 几何对象。最后，我们创建 `gid` 列并将其添加到表中作为主键。
- en: 'Now, we can view our data using our favorite desktop GIS, as shown in the following
    image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们最喜欢的桌面 GIS 查看我们的数据，如下面的图像所示：
- en: '![](img/0dc6fd63-5802-48ec-9972-c554932f59a3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0dc6fd63-5802-48ec-9972-c554932f59a3.png)'
- en: See also
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Performing 3D queries on a LiDAR point cloud* recipe
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 LiDAR 点云上执行 3D 查询* 配方'
- en: Performing 3D queries on a LiDAR point cloud
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 LiDAR 点云上执行 3D 查询
- en: In the previous recipe, *Importing LiDAR data*, we brought a LiDAR 3D point
    cloud into PostGIS, creating an explicit 3D dataset from the input. With the data
    in 3D form, we have the ability to perform spatial queries against it. In this
    recipe, we will leverage 3D indexes so that our nearest-neighbor search works
    in all the dimensions our data are in.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，*导入 LiDAR 数据*，我们将一个 LiDAR 3D 点云导入到 PostGIS 中，从输入中创建了一个显式的 3D 数据集。有了
    3D 形式的数据，我们就有能力对其执行空间查询。在这个配方中，我们将利用 3D 索引，以便我们的最近邻搜索可以在数据的所有维度上工作。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will use the LiDAR data imported in the previous recipe as our dataset of
    choice. We named that table `chp07.lidar`. To perform a nearest-neighbor search,
    we will require an index created on the dataset. Spatial indexes, much like ordinary
    database table indexes, are similar to book indexes insofar as they help us find
    what we are looking for faster. Ordinarily, such an index-creation step would
    look like the following (which we won''t run this time):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前配方中导入的 LiDAR 数据作为我们的数据集。我们给那个表命名为 `chp07.lidar`。为了执行最近邻搜索，我们需要在数据集上创建一个索引。空间索引与普通数据库表索引类似，就像书籍索引一样，它们帮助我们更快地找到我们想要的东西。通常，这样一个索引创建步骤看起来如下（这次我们不会运行它）：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A 3D index does not perform as quickly as a 2D index for 2D queries, so a `CREATE
    INDEX` query defaults to creating a 2D index. In our case, we want to force the
    gist to apply to all three dimensions, so we will explicitly tell PostgreSQL to
    use the n-dimensional version of the index:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 索引在 2D 查询中不如 2D 索引执行得快，因此 `CREATE INDEX` 查询默认创建一个 2D 索引。在我们的情况下，我们希望强制 gist
    应用到所有三个维度，因此我们将明确告诉 PostgreSQL 使用索引的多维版本：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the approach depicted in the previous code would also work if we
    had a time dimension or a 3D plus time. Let''s load a second 3D dataset and the
    stream centerlines that we will use in our query:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前代码中描述的方法如果存在时间维度或 3D 加时间维度也会有效。让我们加载第二个 3D 数据集以及我们将用于查询的流中心线：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This data, as shown in the following image, overlays nicely with our LiDAR
    point cloud:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，这些数据与我们的 LiDAR 点云叠加得很好：
- en: '![](img/dd9b14d3-2d3c-427e-a1fa-bb13be93becf.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd9b14d3-2d3c-427e-a1fa-bb13be93becf.png)'
- en: 'Now, we can build a simple query to retrieve all the LiDAR points within one
    foot of our stream centerline:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个简单的查询来检索所有位于我们溪流中心线一英尺范围内的激光雷达点：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But, this is a little bit of a sloppy approach; we could end up with duplicate
    LiDAR points, so we will refine our query with `LEFT JOIN` and `SELECT DISTINCT`
    instead, but continue using `ST_DWithin` as our limiting condition:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这有点草率；我们可能会得到重复的激光雷达点，因此我们将使用`LEFT JOIN`和`SELECT DISTINCT`来细化我们的查询，但继续使用`ST_DWithin`作为限制条件：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can visualize our returned points, as shown in the following image:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以可视化我们返回的点，如下面的图像所示：
- en: '![](img/4f5387c4-7252-4aac-bbc8-90a34b835908.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f5387c4-7252-4aac-bbc8-90a34b835908.png)'
- en: Try this query using `ST_DWithin` instead of `ST_3DDWithin`. You'll find an
    interesting difference in the number of points returned, since `ST_DWithin` will
    collect LiDAR points that may be close to our streamline in the XY plane, but
    not as close when looking at a 3D distance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`ST_DWithin`而不是`ST_3DDWithin`进行此查询。你会发现返回点的数量有有趣的不同，因为`ST_DWithin`将收集XY平面上可能接近我们的流线的激光雷达点，但在3D距离上并不那么接近。
- en: You can imagine `ST_3DWithin` querying within a tunnel around our line. `ST_DWithin`,
    by contrast, is going to query a vertical wall of LiDAR points, as it is only
    searching for adjacent points based on XY distance, ignoring height altogether,
    and thus gathering up all the points within a narrow wall above and below our
    points.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象`ST_3DWithin`在围绕我们的线进行查询。相比之下，`ST_DWithin`将查询一个垂直的激光雷达点墙，因为它只基于XY距离搜索相邻点，完全忽略高度，因此收集所有在点上方和下方的狭窄墙体内的点。
- en: Constructing and serving buildings 2.5D
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建2.5D建筑和提供服务
- en: In the *Detailed building footprints from LiDAR* recipe in [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml),
    *Working with Vector Data - Advanced Recipes*, we explored the automatic generation
    of building footprints using LiDAR data. What we were attempting to do was create
    2D data from 3D data. In this recipe, we attempt the opposite, in a sense. We
    start with 2D polygons of building footprints and feed them into a function that
    extrudes them as 3D polygons.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](68182eea-7041-4488-9f05-188b0a493ba5.xhtml)“*详细建筑足迹从激光雷达数据中生成*”的配方中，我们在“*处理矢量数据
    - 高级配方*”部分探讨了使用激光雷达数据自动生成建筑足迹。我们试图从3D数据中创建2D数据。在这个配方中，我们尝试做相反的事情。我们以2D建筑足迹多边形开始，并将它们输入到一个函数中，使其扩展为3D多边形。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will extrude a building footprint of our own making. Let
    us quickly create a table with a single building footprint, for testing purposes,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将挤压我们自行制作的建筑足迹。让我们快速创建一个包含单个建筑足迹的表，用于测试，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It would be beneficial to keep the creation of 3D buildings encapsulated as
    simply as possible in a function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将3D建筑的创建尽可能简单地封装在一个函数中是有益的：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our function takes two inputs: the building footprint and a height to extrude
    to. We can also imagine a function that takes in a third parameter: the height
    of the base of the building.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能接受两个输入：建筑足迹和要挤压的高度。我们还可以想象一个接受第三个参数的功能：建筑底座的高度。
- en: 'To construct the building walls, we will need to first convert our polygons
    into linestrings and then further separate the linestrings into their individual,
    two-point segments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建建筑墙体，我们首先需要将我们的多边形转换为线字符串，然后进一步将线字符串分离成它们各自的两点段：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code returns each of the two-point segments of our original shape.
    For example, for `simple_building,` the output is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回我们原始形状的两个点段。例如，对于`simple_building`，输出如下：
- en: '![](img/e8b5d4be-7870-44db-8cf2-520f5b8b93dc.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8b5d4be-7870-44db-8cf2-520f5b8b93dc.png)'
- en: 'Now that we have a series of individual lines, we can use those to construct
    the walls of the building. First, we need to recast our 2D lines as 3D using `ST_Force3DZ`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一系列单独的线，我们可以使用这些线来构建建筑的墙体。首先，我们需要使用`ST_Force3DZ`将我们的2D线重新表示为3D：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/2a2d705f-5b92-486a-bb6b-f8215a0d2326.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a2d705f-5b92-486a-bb6b-f8215a0d2326.png)'
- en: 'The next step is to break each of those lines from `MULTILINESTRING` into many
    `LINESTRINGS`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`MULTILINESTRING`中的每条线分解成许多`LINESTRINGS`：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for this is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下：
- en: '![](img/0306df57-a196-4da2-a91b-a74fd66da846.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0306df57-a196-4da2-a91b-a74fd66da846.png)'
- en: 'The next step is to construct a line representing the boundary of the extruded
    wall:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建一个代表挤压墙体边界的线：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need to convert each linestring to `polygon.threeDwall`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们需要将每条线字符串转换为`polygon.threeDwall`:'
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, put in the roof and floor on our building, using the original geometry
    for the floor (forced to 3D) and a copy of the original geometry translated to
    our input height:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的建筑上加上屋顶和地板，使用原始几何形状作为地板（强制转换为3D）和原始几何形状的副本，该副本已平移到我们的输入高度：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We put the walls, roof, and floor together and, during the process, convert
    this to a 3D `MULTIPOLYGON`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将墙壁、屋顶和地板组合在一起，在过程中将其转换为3D `MULTIPOLYGON`:'
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'While we could leave our geometry as a `MULTIPOLYGON`, we''ll do things properly
    and munge an informal cast to `POLYHEDRALSURFACE`. In our case, we are already
    effectively formatted as a `POLYHEDRALSURFACE`, so we''ll just convert our geometry
    to text with `ST_AsText`, replace the word with `POLYHEDRALSURFACE`, and then
    convert our text back to geometry with `ST_GeomFromText`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将我们的几何形状保留为`MULTIPOLYGON`，但我们会做得更规范，并使用非正式的铸造到`POLYHEDRALSURFACE`。在我们的情况下，我们已经是`POLYHEDRALSURFACE`的有效格式，所以我们将使用`ST_AsText`将我们的几何形状转换为文本，用`POLYHEDRALSURFACE`替换单词，然后使用`ST_GeomFromText`将我们的文本转换回几何形状：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, the entire function is:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，整个函数是：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now that we have a 3D-building extrusion function, we can easily extrude our
    building footprint with our nicely encapsulated function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了3D建筑拉伸函数，我们可以轻松地使用我们封装良好的函数拉伸我们的建筑底图：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can apply this function to a real building footprint dataset (available
    in our data directory), in which case, if we have a height field, we can extrude
    according to it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此函数应用于实际的建筑底图数据集（位于我们的数据目录中），在这种情况下，如果我们有一个高度场，我们可以根据它进行拉伸：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting output gives us a nice, extruded set of building footprints,
    as shown in the following image:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出给我们一组漂亮的拉伸建筑底图，如下面的图像所示：
- en: '![](img/9b9104f4-1cac-40b2-92a2-18103221083a.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b9104f4-1cac-40b2-92a2-18103221083a.png)'
- en: The *Detailed building footprints from LiDAR* recipe in [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml),
    *Working with Vector Data - Advanced Recipes*, explores the extraction of building
    footprints from LiDAR. A complete workflow could be envisioned, which extracts
    building footprints from LiDAR and then reconstructs polygon geometries using
    the current recipe, thus converting point clouds to surfaces, combining the current
    recipe with the one referenced previously.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](68182eea-7041-4488-9f05-188b0a493ba5.xhtml)中的“*从LiDAR获取详细建筑底图*”配方，*处理矢量数据
    - 高级配方*，探讨了从LiDAR中提取建筑底图。可以设想一个完整的工作流程，该流程从LiDAR中提取建筑底图，然后使用当前配方重建多边形几何形状，从而将点云转换为表面，将当前配方与之前引用的配方相结合。'
- en: Using ST_Extrude to extrude building footprints
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ST_Extrude`来拉伸建筑底图
- en: PostGIS 2.1 brought a lot of really cool additional functionality to PostGIS.
    Operations on PostGIS raster types are among the more important improvements that
    come with PostGIS 2.1\. A quieter and equally potent game changer was the addition
    of the SFCGAL library as an optional extension to PostGIS. According to the website
    [http://sfcgal.org/](http://sfcgal.org/), SFCGAL is a C++ wrapper library around
    CGAL with the aim of supporting ISO 19107:2013 and OGC Simple Features Access
    1.2 for 3D operations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS 2.1为PostGIS带来了许多真正酷的附加功能。PostGIS 2.1带来的更重要改进之一是对PostGIS栅格类型的操作。SFCGAL库作为PostGIS的可选扩展被添加，是一个更安静但同样强大的变革者。根据网站[http://sfcgal.org/](http://sfcgal.org/)，SFCGAL是一个围绕CGAL的C++包装库，旨在支持ISO
    19107:2013和OGC简单特征访问1.2的3D操作。
- en: From a practical standpoint, what does this mean? It means that PostGIS is moving
    toward a fully functional 3D environment, from representation of the geometries
    themselves and the operations on those 3D geometries. More information is available
    at [http://postgis.net/docs/reference.html#reference_sfcgal](http://postgis.net/docs/reference.html#reference_sfcgal).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，这意味着什么？这意味着PostGIS正朝着完全功能的3D环境发展，从几何形状本身及其3D几何形状的操作。更多信息请参阅[http://postgis.net/docs/reference.html#reference_sfcgal](http://postgis.net/docs/reference.html#reference_sfcgal)。
- en: 'This and several other recipes will assume that you have a version of PostGIS
    installed with SFCGAL compiled and enabled. Doing so enables the following functions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档和几个其他配方将假设您已安装带有SFCGAL编译和启用的PostGIS版本。这样做将启用以下功能：
- en: '`ST_Extrude`: This extrudes a surface to a related volume'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_Extrude`：将表面拉伸到相关体积'
- en: '`ST_StraightSkeleton`: This computes a straight skeleton from a geometry'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_StraightSkeleton`：从这个几何形状计算直骨骼'
- en: '`ST_IsPlanar`: This checks whether a surface is a planar or not'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_IsPlanar`：检查表面是否为平面'
- en: '`ST_Orientation`: This determines the surface orientation'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_Orientation`：这决定了表面方向'
- en: '`ST_ForceLHR`: This forces LHR orientation'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_ForceLHR`：这强制LHR方向'
- en: '`ST_MinkowskiSum`: This computes the Minkowski sum'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_MinkowskiSum`：这计算Minkowski和'
- en: '`ST_Tesselate`: This performs surface Tessellation'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_Tesselate`：这执行表面细分'
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this recipe, we'll use `ST_Extrude` in much the same way we used our own
    custom-built function in the previous recipe, *Constructing and serving buildings
    2.5D*. The advantage over the previous recipe is that we are not required to have
    the SFCGAL library compiled in PostGIS. The advantage to this recipe is that we
    have more control over the extrusion process; that is, we can extrude in all three
    dimensions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将像在之前的配方*构建和提供2.5D建筑*中使用我们自己的自定义函数一样使用`ST_Extrude`。与之前的配方相比的优势是，我们不需要在PostGIS中编译SFCGAL库。这个配方的优势在于我们能够更多地控制挤压过程；也就是说，我们可以在三个维度上进行挤压。
- en: '`ST_Extrude` returns a geometry, specifically a polyhedral surface. It requires
    four parameters: an input geometry and the extrusion amount along the *X*, *Y*,
    and *Z* axes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_Extrude`返回一个几何体，具体是一个多面体表面。它需要四个参数：输入几何体以及沿*X*、*Y*和*Z*轴的挤压量：'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/4a0d0f7c-cec0-455e-81fc-92fd42b7f23e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a0d0f7c-cec0-455e-81fc-92fd42b7f23e.png)'
- en: And so, with the help of the *Constructing and serving buildings 2.5D* recipe,
    we get our extruded buildings, but with some additional flexibility.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，借助*构建和提供2.5D建筑*配方，我们得到了挤压的建筑，但有一些额外的灵活性。
- en: Creating arbitrary 3D objects for PostGIS
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为PostGIS创建任意3D对象
- en: Sources of 3D information are not only generated from LiDAR, nor are they purely
    synthesized from 2D geometries and associated attributes as in the *Constructing
    and serving buildings 2.5D* and *Using ST_Extrude to extrude building footprints*
    recipes, but they can also be created from the principles of computer vision as
    well. The process of calculating 3D information from the association of related
    keypoints between images is known as SfM.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 3D信息来源不仅来自LiDAR，也不是纯粹从2D几何形状及其相关属性中合成，如*构建和提供2.5D建筑*和*使用ST_Extrude挤压建筑足迹*配方中所述，它们还可以根据计算机视觉原理创建。从图像之间相关关键点的关联计算3D信息的过程称为SfM。
- en: As a computer vision concept, we can leverage SfM to generate 3D information
    in ways similar to how the human mind perceives the world in 3D, and further store
    and process that information in a PostGIS database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为计算机视觉的概念，我们可以利用SfM以类似于人类大脑在3D中感知世界的方式生成3D信息，并将其进一步存储和处理在PostGIS数据库中。
- en: Computer vision is a discipline within computer science focused on automated
    analysis and inference from images and video. It is considered a research area
    that develops algorithms that interpret the world in a way that is similar to
    human vision. An excellent summary can be found at [http://en.wikipedia.org/wiki/Computer_vision](http://en.wikipedia.org/wiki/Computer_vision).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉是计算机科学中的一个学科，专注于从图像和视频中自动分析和推理。它被认为是一个开发算法的研究领域，这些算法以类似于人类视觉的方式解释世界。有关该领域的优秀总结可以在[http://en.wikipedia.org/wiki/Computer_vision](http://en.wikipedia.org/wiki/Computer_vision)找到。
- en: A number of open source projects have matured to deal with solving SfM problems.
    Popular among these are Bundler, which can be found at [http://phototour.cs.washington.edu/bundler/](http://phototour.cs.washington.edu/bundler/),
    and **VisualSFM** at [http://ccwu.me/vsfm/](http://ccwu.me/vsfm/). Binaries exist
    for multiple platforms for these tools, including versions. The nice thing about
    such projects is that a simple set of photos can be used to reconstruct 3D scenes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开源项目已经成熟，用于解决SfM问题。其中最受欢迎的是Bundler，可以在[http://phototour.cs.washington.edu/bundler/](http://phototour.cs.washington.edu/bundler/)找到，还有[http://ccwu.me/vsfm/](http://ccwu.me/vsfm/)的**VisualSFM**。这些工具的多个平台都有二进制文件，包括版本。这样的项目的优点是，可以使用一组简单的照片来重建3D场景。
- en: For our purposes, we will use VisualSFM and skip the installation and configuration
    of this software. The reason for this is that SfM is beyond the scope of a PostGIS
    book to cover in detail, and we will focus on how we can use the data in PostGIS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将使用VisualSFM并跳过该软件的安装和配置。原因是SfM超出了PostGIS书籍详细介绍的范畴，我们将专注于如何在PostGIS中使用这些数据。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: It is important to understand that SfM techniques, while highly effective, have
    certain limitations in the kinds of imagery that can be effectively processed
    into point clouds. The techniques are dependent upon finding matches between subsequent
    images and thus can have trouble processing images that are smooth, are missing
    the camera's embedded **Exchangeable Image File Format** (**EXIF**) information,
    or are from cell phone cameras.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，虽然 SfM 技术非常有效，但在将图像有效处理成点云的图像类型方面存在某些局限性。这些技术依赖于在后续图像之间找到匹配，因此可能会在处理平滑、缺少相机嵌入的
    **Exchangeable Image File Format** (**EXIF**) 信息或来自手机相机的图像时遇到困难。
- en: EXIF tags are a metadata format for images. Stored in these tags are often the
    camera settings, camera type, lens type, and other information relevant to SfM
    extraction.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: EXIF 标签是图像的元数据格式。这些标签中存储的通常是相机设置、相机类型、镜头类型以及其他与 SfM 提取相关的信息。
- en: We will start processing an image series into a point cloud with a photo series
    that we know largely works, but as you experiment with SfM, you can feed in your
    own photo series. Good tips on how to create a photo series that will result in
    a 3D model can be found at [https://www.youtube.com/watch?v=IStU-WP2XKs&t=348s](https://www.youtube.com/watch?v=IStU-WP2XKs&t=348s)
    and [http://www.cubify.com/products/capture/photography_tips.aspx](http://www.cubify.com/products/capture/photography_tips.aspx).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个已知大部分可以工作的照片系列开始处理图像系列到点云，但随着你对 SfM 进行实验，你也可以输入你自己的照片系列。有关如何创建将产生 3D 模型的照片系列的优秀提示，可以在
    [https://www.youtube.com/watch?v=IStU-WP2XKs&t=348s](https://www.youtube.com/watch?v=IStU-WP2XKs&t=348s)
    和 [http://www.cubify.com/products/capture/photography_tips.aspx](http://www.cubify.com/products/capture/photography_tips.aspx)
    找到。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Download VisualSFM from [http://ccwu.me/vsfm/](http://ccwu.me/vsfm/). In a
    console terminal, execute the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://ccwu.me/vsfm/](http://ccwu.me/vsfm/) 下载 VisualSFM。在控制台终端中，执行以下命令：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: VisualSFM will start rendering the 3D, model using as input a folder with images.
    It will take a couple of hours to process. Then, when it finishes, it will return
    a point cloud file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: VisualSFM 将开始使用图像文件夹作为输入渲染 3D 模型。处理可能需要几个小时。完成后，它将返回一个点云文件。
- en: We can view this data in a program such as **MeshLab** at [http://meshlab.sourceforge.net/](http://meshlab.sourceforge.net/).
    A good tutorial on using MeshLab to view point clouds can be found at [http://www.cse.iitd.ac.in/~mcs112609/Meshlab%20Tutorial.pdf](http://www.cse.iitd.ac.in/~mcs112609/Meshlab%20Tutorial.pdf).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 **MeshLab** [http://meshlab.sourceforge.net/](http://meshlab.sourceforge.net/)
    这样的程序中查看这些数据。有关如何使用 MeshLab 查看点云的优秀教程可以在 [http://www.cse.iitd.ac.in/~mcs112609/Meshlab%20Tutorial.pdf](http://www.cse.iitd.ac.in/~mcs112609/Meshlab%20Tutorial.pdf)
    找到。
- en: 'The following image shows what our point cloud looks like when viewed in MeshLab:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了在 MeshLab 中查看点云时的样子：
- en: '![](img/8eff27ef-10d9-4ce5-a42c-039fea1e9ec7.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8eff27ef-10d9-4ce5-a42c-039fea1e9ec7.png)'
- en: 'In the VisualSFM output, there is a file with the extension `.ply`, for example,
    `giraffe.ply` (included in the source code for this chapter). If you open this
    file in a text editor, it will look something like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VisualSFM 的输出中，有一个扩展名为 `.ply` 的文件，例如，`giraffe.ply`（包含在本章源代码中）。如果你在文本编辑器中打开此文件，它看起来可能如下所示：
- en: '![](img/df01490c-c68e-4000-bd9a-b0605bc8fda5.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df01490c-c68e-4000-bd9a-b0605bc8fda5.png)'
- en: 'This is the header portion of our file. It specifies the .`ply` format, the
    encoding `format ascii 1.0`, the number of vertices, and then the column names
    for all the data returned: `x`, `y`, `z`, `nx`, `ny`, `nz`, `red`, `green`, and
    `blue`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文件的头部部分。它指定了 `.ply` 格式、编码 `format ascii 1.0`、顶点数，以及所有返回数据的列名：`x`、`y`、`z`、`nx`、`ny`、`nz`、`red`、`green`
    和 `blue`。
- en: For importing into PostGIS, we will import all the fields, but will focus on
    `x`, `y`, and `z` for our point cloud, as well as look at color. For our purposes,
    this file specifies relative `x`, `y`, and `z` coordinates, and the color of each
    of those points in channels `red`, `green`, and `blue`. These colors are 24-bit
    colors—and thus they can have integer values between 0 and 255.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于导入到 PostGIS，我们将导入所有字段，但将重点放在我们的点云的 `x`、`y` 和 `z` 上，以及查看颜色。对于我们的目的，此文件指定了相对的
    `x`、`y` 和 `z` 坐标，以及每个点的颜色在通道 `red`、`green` 和 `blue` 中。这些颜色是 24 位颜色，因此它们可以具有介于
    0 和 255 之间的整数值。
- en: 'For the remainder of the recipe, we will create a PDAL pipeline, modifying
    the JSON structure reader to be a `.ply` file. Check the recipe for *Importing
    LiDAR data* in this chapter to see how to create a PDAL pipeline:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的食谱中，我们将创建一个PDAL管道，修改JSON结构读取器以读取`.ply`文件。查看本章中关于*导入LiDAR数据*的食谱，了解如何创建PDAL管道：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we execute in the Terminal:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在终端中执行以下操作：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This output will serve us for input in the next recipe.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出将作为下一个食谱的输入。
- en: Exporting models as X3D for the web
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型导出为X3D以供网络使用
- en: Entering 3D data in a PostGIS database is not nearly as interesting if we have
    no capacity for extracting the data back out in some useable form. One way to
    approach this problem is to leverage the PostGIS ability to write 3D tables to
    the X3D format.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostGIS数据库中输入3D数据，如果没有能力以某种可用的形式提取数据，那么这几乎就没有什么趣味。解决这个问题的方法之一是利用PostGIS将3D表格写入X3D格式的能力。
- en: X3D is an XML standard for displaying 3D data and works well via the web. For
    those familiar with **Virtual Reality Modeling Language** (**VRML**), X3D is the
    next generation of that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: X3D是用于显示3D数据的XML标准，通过网络工作得很好。对于那些熟悉**虚拟现实建模语言**（**VRML**）的人来说，X3D是那个语言的下一代。
- en: To view X3D in the browser, a user has the choice of a variety of plugins, or
    they can leverage JavaScript APIs to enable viewing. We will perform the latter,
    as it requires no user configuration to work. We will use X3DOM's JavaScript framework
    to accomplish this. X3DOM is a demonstration of the integration of HTML5 and 3D
    and uses **Web Graphics Library** (**WebGL**); ([https://en.wikipedia.org/wiki/WebGL](https://en.wikipedia.org/wiki/WebGL))
    to allow rendering and interaction with 3D content in the browser. This means
    that our data will not get displayed in browsers that are not WebGL compatible.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中查看X3D，用户可以选择各种插件，或者他们可以利用JavaScript API来实现查看功能。我们将执行后者，因为它不需要用户配置即可工作。我们将使用X3DOM的JavaScript框架来完成这项工作。X3DOM是HTML5和3D集成的演示，它使用**Web图形库**（**WebGL**）；([https://en.wikipedia.org/wiki/WebGL](https://en.wikipedia.org/wiki/WebGL))来允许在浏览器中渲染和交互3D内容。这意味着我们的数据将不会在不支持WebGL的浏览器中显示。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be using the point cloud from the previous example to serve in X3D
    format. PostGIS documentation on X3D includes an example of using the `ST_AsX3D`
    function to output the formatted X3D code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前一个示例中的点云数据，以X3D格式提供服务。PostGIS关于X3D的文档中包含了一个使用`ST_AsX3D`函数输出格式化X3D代码的示例：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We included the copy to `STDOUT WITH CSV` to make a dump in raw code. The user
    is able to save this query as an SQL script file and execute it from the console
    in order to dump the result into a file. For instance:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了复制到`STDOUT WITH CSV`以进行原始代码的转储。用户可以将此查询保存为SQL脚本文件，并在控制台中执行它，以便将结果转储到文件中。例如：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This example, while complete in serving the pure X3D, needs additional code
    to allow in-browser viewing. We do so by including style sheets, and the appropriate
    X3DOM includes the headers of an XHTML document:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例虽然完整地提供了纯X3D，但需要额外的代码来允许在浏览器中查看。我们通过包含样式表和适当的X3DOM包含XHTML文档的标题来实现这一点：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The full query to generate the XHTML of X3D data is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 生成X3D数据的XHTML的完整查询如下所示：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we open the `.html` file in our favorite browser, we will get the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在最喜欢的浏览器中打开`.html`文件，我们将得到以下内容：
- en: '![](img/a8f1d2a2-11c2-44b2-af55-190f175ad655.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8f1d2a2-11c2-44b2-af55-190f175ad655.png)'
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One might want to use this X3D conversion as a function, feeding geometry into
    a function and getting a page in return. In this way, we can reuse the code easily
    for other tables. Embodied in a function, X3D conversion is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能希望将这个X3D转换作为一个函数使用，将几何形状输入到函数中，然后返回一个页面。这样，我们可以轻松地重用代码来处理其他表格。将X3D转换封装在函数中如下所示：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In order for the function to work, we need to first use `ST_UNION` on the geometry
    parameter to pass to the `AsX3D_XHTML` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使函数能够工作，我们需要首先在几何参数上使用`ST_UNION`，然后将结果传递给`AsX3D_XHTML`函数：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can now very simply generate the appropriate XHTML directly from the command
    line or a web framework.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以非常简单地直接从命令行或Web框架中生成适当的XHTML。
- en: Reconstructing Unmanned Aerial Vehicle (UAV) image footprints with PostGIS 3D
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostGIS 3D重建无人机（UAV）图像足迹
- en: The rapid development of **Unmanned Aerial Systems** (**UAS**), also known as
    **Unmanned Aerial Vehicles** (**UAVs**), as data collectors is revolutionizing
    remote data collection in all sectors. Barriers to wider adoption outside military
    sectors include regulatory frameworks preventing their flight in some nations,
    such as, the United States, and the lack of open source implementations of post-processing
    software. In the next four recipes, we'll attempt preliminary solutions to the
    latter of these two barriers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据收集器的**无人机系统**（**UAS**），也称为**无人机**（**UAVs**），其快速发展正在彻底改变各个领域的远程数据收集。在军事领域之外更广泛的应用障碍包括防止某些国家（如美国）飞行的监管框架，以及缺乏开源的后处理软件实现。在接下来的四个菜谱中，我们将尝试解决这两个障碍中的后者。
- en: For this recipe, we will be using the metadata from a UAV flight in Seneca County,
    Ohio, by the Ohio Department of Transportation to map the coverage of the flight.
    This is included in the code folder for this chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用俄亥俄州交通运输部在辛尼卡县进行的无人机飞行元数据来绘制飞行覆盖范围。这些数据包含在本章的代码文件夹中。
- en: The basic idea for this recipe is to estimate the field of view of the UAV camera,
    generate a 3D pyramid that represents that field of view, and use the flight ephemeris
    (bearing, pitch, and roll) to estimate ground coverage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的基本思路是估计无人机摄像头的视场，生成一个代表该视场的3D金字塔，并使用飞行星历（航向、俯仰角和滚转角）来估计地面覆盖。
- en: Getting started
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'The metadata or ephemeris we have for the flight includes the bearing, pitch,
    and roll of the UAS, in addition to its elevation and location:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为飞行提供的元数据或星历包括无人机的航向、俯仰角和滚转角，以及其高度和位置：
- en: '![](img/d9b1d3e5-d649-4461-9f24-fa7b848ce352.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9b1d3e5-d649-4461-9f24-fa7b848ce352.png)'
- en: 'To translate these ephemeris into PostGIS terms, we''ll assume the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些星历转换为PostGIS术语，我们假设以下内容：
- en: 90 degrees minus the pitch is equivalent to `ST_RotateX`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 90度减去俯仰角等于 `ST_RotateX`
- en: The negative roll is equivalent to `ST_RotateY`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负滚转等于 `ST_RotateY`
- en: 90 degrees minus the bearing is equivalent to `ST_RotateZ`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 90度减去航向等于 `ST_RotateZ`
- en: In order to perform our analysis, we require external functions. These functions
    can be downloaded from [https://github.com/smathermather/postgis-etc/tree/master/3D](https://github.com/smathermather/postgis-etc/tree/master/3D).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行我们的分析，我们需要外部函数。这些函数可以从[https://github.com/smathermather/postgis-etc/tree/master/3D](https://github.com/smathermather/postgis-etc/tree/master/3D)下载。
- en: We will use patched versions of `ST_RotateX`, `ST_RotateY` (`ST_RotateX.sql`,
    and `ST_RotateY.sql`), which allow us to rotate geometries around an input point,
    as well as a function for calculating our field of view, `pyramidMaker.sql`. Future
    versions of PostGIS will include these versions of `ST_RotateX` and `ST_RotateY`
    built in. We have another function, `ST_RotateXYZ`, which is built upon these
    and will also simplify our code by allowing us to specify three axes at the same
    time for rotation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `ST_RotateX`、`ST_RotateY`（`ST_RotateX.sql` 和 `ST_RotateY.sql`）的修补版本，这些版本允许我们在输入点周围旋转几何形状，以及一个用于计算我们视场的函数
    `pyramidMaker.sql`。PostGIS的未来版本将内置这些版本的 `ST_RotateX` 和 `ST_RotateY`。我们还有一个名为 `ST_RotateXYZ`
    的函数，它基于这些函数，并将通过允许我们同时指定三个旋转轴来简化我们的代码。
- en: For the final step, we'll need the capacity to perform volumetric intersection
    (the 3D equivalent of intersection). For this, we'll use `volumetricIntersection.sql`,
    which allows us to just return the volumetric portion of the intersection as a
    **triangular irregular network** (**TIN**).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一步，我们需要执行体积交集（3D交集的等效）的能力。为此，我们将使用 `volumetricIntersection.sql`，它允许我们仅返回交集的体积部分作为一个**三角不规则网络**（**TIN**）。
- en: A TIN is a 3D surface model for representing surfaces and volumes as a mesh
    of triangles.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: TIN是表示表面和体积的3D表面模型，它是一个三角形的网格。
- en: 'We will install the functions as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式安装功能：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In order to calculate the viewing footprint, we will calculate a rectangular
    pyramid descending from the viewpoint to the ground. This pyramid will need to
    point to the left and right of the nadir according to the UAS's roll, forward
    or backward from the craft according to its pitch, and be oriented relative to
    the direction of movement of the craft according to its bearing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算视场足迹，我们将计算从视点到地面的矩形金字塔。这个金字塔需要根据无人机的滚转指向天顶的左右两侧，根据俯仰角从飞行器的前后移动，并根据航向相对于飞行器的移动方向进行定位。
- en: The `pyramidMaker` function will construct our pyramid for us and `ST_RotateXYZ`
    will rotate the pyramid in the direction we need to compensate for roll, pitch,
    and bearing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyramidMaker`函数将为我们构建金字塔，而`ST_RotateXYZ`将旋转金字塔，以补偿翻滚、俯仰和方位。'
- en: 'The following image is an example map of such a calculated footprint for a
    single image. Note the slight roll to the left for this example, resulting in
    an asymmetric-looking pyramid when viewed from above:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像是单个图像计算出的足迹示例地图。注意这个示例中轻微的向左倾斜，从上方看时导致金字塔看起来不对称：
- en: '![](img/104bebdd-9aa8-4eb6-836e-a2117231b533.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/104bebdd-9aa8-4eb6-836e-a2117231b533.png)'
- en: 'The total track for the UAS flight overlayed on a contour map is shown in the
    following image:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了无人机飞行轨迹叠加在等高线图上的总轨迹：
- en: '![](img/44b94751-c2db-4190-ac23-f8c526f32104.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44b94751-c2db-4190-ac23-f8c526f32104.png)'
- en: Total track for the flight viewed with QGIS
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QGIS查看的飞行总轨迹
- en: 'We will write a function to calculate our footprint pyramid. To input to the
    function, we''ll need the position of the UAS as geometry (origin), the pitch,
    bearing, and roll, as well as the field of view angle in `x` and `y` for the camera.
    Finally, we''ll need the relative height of the craft above ground:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个函数来计算我们的足迹金字塔。为了输入函数，我们需要无人机位置作为几何形状（原点），俯仰、方位和翻滚，以及相机在`x`和`y`方向上的视场角。最后，我们需要无人机相对于地面的相对高度：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our pyramid function assumes that we know what the base size of our pyramid
    is. We don''t know this initially, so we''ll calculate its size based on the field
    of view angle of the camera and the height of the craft:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的金字塔函数假设我们知道金字塔的底面积。我们最初不知道这个，所以我们将根据相机的视场角和无人机的高度来计算其大小：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we have enough information to construct our pyramid:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了足够的信息来构建我们的金字塔：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will require the following code to rotate our view relative to pitch, roll,
    and bearing:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下代码来相对于俯仰、翻滚和方位旋转我们的视图：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The whole function is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 整个函数如下所示：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, to use our function, let us import the UAS positions from the `uas_locations`
    shapefile included in the source for this chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用我们的函数，让我们从本章源代码中包含的`uas_locations`形状文件中导入无人机位置：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, it is possible to calculate an estimated footprint for each UAS position:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为每个无人机位置计算一个估计的足迹：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you import this with your favorite desktop GIS, such as QGIS, you will be
    able to see the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用你喜欢的桌面GIS导入此代码，例如QGIS，你将能够看到以下内容：
- en: '![](img/5400b7a7-cfd6-492a-abf6-e056ca39ea44.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5400b7a7-cfd6-492a-abf6-e056ca39ea44.png)'
- en: 'With a terrain model, we can go a step deeper in this analysis. Since our UAS
    footprints are volumetric, we will first load the terrain model. We will load
    this from a `.backup` file included in the source code for this chapter:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地形模型，我们可以在这个分析中更进一步。由于我们的无人机足迹是体积的，我们首先加载地形模型。我们将从这个章节源代码中包含的`.backup`文件中加载它：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we will create a smaller version of our `viewshed` table:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个较小的`viewshed`表版本：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you import this with your favorite desktop GIS, such as QGIS, you will be
    able to see the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用你喜欢的桌面GIS导入此代码，例如QGIS，你将能够看到以下内容：
- en: '![](img/384e3e01-1517-4988-a6c3-41176fe21b0a.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/384e3e01-1517-4988-a6c3-41176fe21b0a.png)'
- en: UAV photogrammetry in PostGIS – point cloud
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostGIS中的无人机航摄影像测量 – 点云
- en: We will use the techniques we've used in the previous recipe named *Creating
    arbitrary 3D objects for PostGIS* learn how to create and import a UAV-derived
    point cloud in PostGIS.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在之前名为“为PostGIS创建任意3D对象”的配方中使用的技巧，学习如何在PostGIS中创建和导入无人机衍生的点云。
- en: One caveat before we begin is that while we will be working with geospatial
    data, we will be doing so in relative space, rather than a known coordinate system.
    In other words, this approach will calculate our dataset in an arbitrary coordinate
    system. `ST_Affine` could be used in combination with the field measurements of
    locations to transform our data into a known coordinate system, but this is beyond
    the scope of this book.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前有一个注意事项是，虽然我们将处理地理空间数据，但我们将在相对空间中这样做，而不是在已知坐标系中。换句话说，这种方法将在任意坐标系中计算我们的数据集。`ST_Affine`可以与位置的字段测量相结合，将我们的数据转换到已知坐标系中，但这超出了本书的范围。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Much like with the *Creating arbitrary 3D objects for PostGIS* recipe,  we will
    be taking an image series and converting it into a point cloud. In this case,
    however, our image series will be from UAV imagery. Download the image series
    included in the code folder for this chapter, `uas_flight`, and feed it into VisualSFM
    (check [http://ccwu.me/vsfm/](http://ccwu.me/vsfm/)for more information on how
    to use this tool); in order to retrieve a point cloud, name it `uas_points.ply`
    (this file is also included in this folder in case you would rather use it).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与*为PostGIS创建任意3D对象*配方类似，我们将从一个图像系列转换成点云。然而，在本例中，我们的图像系列将来自无人机影像。下载本章代码文件夹中包含的图像系列`uas_flight`，并将其输入到VisualSFM中（有关如何使用此工具的更多信息，请参阅[http://ccwu.me/vsfm/](http://ccwu.me/vsfm/)）；为了检索点云，将其命名为`uas_points.ply`（此文件也包含在此文件夹中，以防您想使用它）。
- en: 'The input for PostGIS is the same as before. Create a JSON file and use PDAL
    store it into the database:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS的输入与之前相同。创建一个JSON文件，并使用PDAL将其存储到数据库中：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, we copy data from the point cloud into our table. Refer to the *Importing
    LiDAR data recipe* in this chapter to verify the pointcloud extension object representation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将点云数据复制到我们的表格中。请参考本章中的*导入LiDAR数据配方*以验证点云扩展对象表示：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This data, as viewed in MeshLab ([http://www.meshlab.net/](http://www.meshlab.net/))
    from the .`ply` file, is pretty interesting:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从MeshLab ([http://www.meshlab.net/](http://www.meshlab.net/))中查看的`.ply`文件，这些数据非常有趣：
- en: '![](img/fc8744f6-98ec-48ba-bc78-27cb1f19ed45.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc8744f6-98ec-48ba-bc78-27cb1f19ed45.png)'
- en: The original data is color infrared imagery, so vegetation shows up red, and
    farm fields and roads as gray. Note the bright colors in the sky; those are camera
    position points that we'll need to filter out.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据是彩色红外影像，因此植被显示为红色，农田和道路为灰色。注意天空中的亮色；这些是我们需要过滤掉的相机位置点。
- en: The next step is to generate orthographic imagery from this data.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从这些数据生成正射影像。
- en: UAV photogrammetry in PostGIS – DSM creation
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostGIS中的无人机摄影测量 – 创建DSM
- en: The photogrammetry example would be incomplete if we did not produce a digital
    terrain model from our inputs. A fully rigorous solution where the input point
    cloud would be classified into ground points, building points, and vegetation
    points is not feasible here, but this recipe will provide the basic framework
    for accomplishing such a solution.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不从输入中生成数字地形模型，则摄影测量示例将是不完整的。在这里，将输入点云分类为地面点、建筑点和植被点的完全严格解决方案是不可行的，但此配方将提供实现此类解决方案的基本框架。
- en: In this recipe, we will create a 3D TIN, which will represent the surface of
    the point cloud.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将创建一个3D TIN，它将代表点云的表面。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we start, `ST_DelaunayTriangles` is available only in PostGIS 2.1 using
    GEOS 3.4\. This is one of the few recipes in this book to require such advanced
    versions of PostGIS and GEOS.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，`ST_DelaunayTriangles`仅在PostGIS 2.1使用GEOS 3.4时可用。这是本书中要求此类高级版本PostGIS和GEOS的少数配方之一。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '`ST_DelaunayTriangles` will calculate a 3D TIN with the correct flag: geometry
    `ST_DelaunayTriangles` (geometry `g1`, float `tolerance`, int4 `flags`):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_DelaunayTriangles`将计算带有正确标志的3D TIN：几何 `ST_DelaunayTriangles`（几何 `g1`，浮点
    `tolerance`，整数4 `flags`）：'
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we have a full TIN of a digital surface model at our disposal:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了数字表面模型的完整TIN：
- en: '![](img/4e8abb92-9074-4cf2-a2ca-dc36daabb460.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e8abb92-9074-4cf2-a2ca-dc36daabb460.jpg)'
