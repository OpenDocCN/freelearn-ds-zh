- en: '*Chapter 3*: IBM Quantum Experience® – Quantum Drag and Drop'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something pretty amazing happened in the cloud in early 2016; a new type of
    computer opened its arms to the world—a programmable quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk briefly about the early history of IBM Quantum
    Experience®, how to get there, and how to open a user account. We will take a
    look at the drag-and-drop user interface for programming the IBM quantum computers
    (Circuit Composer).
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will take a quick peek at how you can move back and forth between IBM
    Quantum Experience® and Qiskit® by using the underlying OpenQASM coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IBM Quantum Experience®
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building quantum scores with Circuit Composer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tossing a quantum coin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving between worlds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not stay long here; just long enough to scratch the surface, present
    a quantum circuit we will play with later in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*, and get a feel for the plethora of
    gates that are available to use.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The quantum programs that we will discuss in this chapter can be found here:
    [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter03](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already, get yourself an IBM Quantum Experience® account. For
    information, see *Creating your IBM Quantum Experience® account* in [*Chapter
    1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021), *Preparing Your Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IBM Quantum Experience®
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IBM Quantum Experience®** is an open platform available for someone to start
    their quantum computing journey. In it, you have free access to a number of IBM
    quantum computers, ranging in size from a single qubit to 15 qubits (at the time
    of writing), as well as a 32-qubit simulator that runs on IBM POWER9™ hardware.
    That''s a lot of power at your fingertips.'
  prefs: []
  type: TYPE_NORMAL
- en: IBM Quantum Experience® opened its doors in May 2016, in a world-first announcement
    that the public would now have access to actual quantum computing hardware in
    the cloud. Since then, several other companies have announced similar initiatives
    and opened up for cloud quantum computing, initially on *simulators*. Notable
    among this crowd are Google, Microsoft, Rigetti, Qutech, and more. As of this
    book's writing, IBM gives free access to both hardware and software quantum computing
    through its IBM Quantum Experience®, we will focus on that platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'From your web browser, go to the following URL, and log in with your IBM Quantum
    Experience® account: [https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: You are now on the main IBM Quantum Experience® landing page from which you
    can access all the quantum experience tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the right pane, we have backends that are available to you. Clicking on each
    brings up a data page with the access status, provider access, chip structure
    and error rate data, the number of qubits, a list of basis gates, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the center area, you find your workbench. There's a list of recent circuits,
    currently running experiments, and your previous experiment results; when you
    first drop in here, it will be quite empty. From this area, you can also manage
    your user profile, configure notifications, get your API key, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the left, we have the main tools and help resources. These are described
    in more detail in the next section's *How to do it…*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The IBM Quantum Experience® home page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – The IBM Quantum Experience® home page
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have successfully logged in and looked around, let''s take a look
    at the quantum computing programming tools at our disposal. From the main menu
    on the right, you can access the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Results**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit Composer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantum Lab**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The IBM Quantum Experience® programming tools](img/Figure_3.2_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The IBM Quantum Experience® programming tools
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each of those pages now.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Results** section of IBM Quantum Experience® is just a long list of your
    pending jobs and your previously run quantum computing programs. You can search,
    sort, and filter by variables such as execution time, services (backends), and
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The Results page](img/Figure_3.3_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The Results page
  prefs: []
  type: TYPE_NORMAL
- en: The **Results** pane in IBM Quantum Experience® includes not only the jobs that
    are run from the **Circuit Composer** but also all jobs that you run on IBM Quantum®
    backends from your local Qiskit® with the same ID.
  prefs: []
  type: TYPE_NORMAL
- en: Each job includes not only the results of your job but also other data such
    as how long the job stayed in each stage of processing, how long it took to run,
    the status of the job, the **transpiled** circuit diagram, and the OpenQASM code
    for the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit Composer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Circuit Composer is the main tool for working with your quantum scores
    (which is what IBM Quantum Experience® calls quantum programs built using the
    Circuit Composer tool). We will go through it in detail in the recipes in this
    chapter, but I will provide you with a quick overview of its components here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The Circuit Composer files page](img/Figure_3.4_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The Circuit Composer files page
  prefs: []
  type: TYPE_NORMAL
- en: Just like the **Results** pane has a list of jobs, the **Circuit Composer files**
    pane has a list of your *circuits*. From here, you can open and run all circuits
    that you have created using the Circuit Composer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also click **New Circuit** to start from scratch, which opens Circuit
    Composer on an untitled circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A blank circuit in Circuit Composer](img/Figure_3.5_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – A blank circuit in Circuit Composer
  prefs: []
  type: TYPE_NORMAL
- en: No Qiskit® overlap
  prefs: []
  type: TYPE_NORMAL
- en: The Circuit Composer window does not (in contrast to the **Results** pane) contain
    any of the circuits that you have run from a local Qiskit® environment. Only the
    quantum scores that you have created in IBM Quantum Experience® are available
    here. If you want to see your Qiskit® circuits here, you must import them as OpenQASM
    code. See the *Moving between worlds* recipe at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have opened or created a circuit, a set of new tools open up to help
    you build your quantum score. These are covered in the next recipe, *Building
    quantum scores with Circuit Composer*.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum Lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third toolkit is a collection of Jupyter Notebook tutorials put together
    by the Qiskit® team. You can access them all from the **Qiskit tutorials** tile.
    You can also create your Jupyter Notebooks from this pane, and these will show
    up in this window much like the circuits in the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Quantum Lab](img/Figure_3.6_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Quantum Lab
  prefs: []
  type: TYPE_NORMAL
- en: Running Python programs in notebooks
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the Jupyter Notebook environment to run the quantum computing
    Python sample scripts that we include in this book. Take a look at the *Downloading
    the code samples* recipe in [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*, for a quick reminder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the tools that you will use to code your quantum programs, IBM
    Quantum Experience® also includes some extended help in the form of two additional
    pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docs**: This page includes a collection of getting started tutorials, a more
    extensive set of instructions for Circuit Composer, algorithms, and more. This
    is a good starting point to explore IBM Quantum Experience® when you are done
    working your way through this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ibm-q-experience`) and Qiskit® (`qiskit`). These social environments are vibrant
    and responsive, and you can bounce around questions, ideas, and more in a give-and-take
    manner. Questions are not long left unanswered by knowledgeable members and moderators!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building quantum scores with Circuit Composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will walk you through the basic steps of creating a quantum score
    in IBM Quantum Experience®, to get a feel for how the composer works, how to build
    and modify a score, and finally how to analyze the score step by step using the
    **Inspect** feature.
  prefs: []
  type: TYPE_NORMAL
- en: Drag-and-drop programming
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter will be run in the IBM Quantum Experience® web environment,
    using the drag-and-drop interface, which nicely visualizes what you are doing
    in an intuitive way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build ourselves a little quantum score:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your web browser (Chrome seems to work best), go to the following URL,
    and then log in with your IBM Quantum Experience® account: [https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left pane, select **Circuit Composer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This opens the composer to a blank **Untitled circuit**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Optional: Set the number of qubits to play with.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the default setting, you will see three lines, much like a music score (hence
    the term quantum score). Each line represents one of your qubits, and the basic
    score is designed for a 5-qubit machine. As you will see in the *Comparing backends*
    recipe in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring
    the IBM Quantum® Hardware with Qiskit®,* this is currently the most common setup
    for the free IBM quantum machines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this example, we want to use only 1 qubit for clarity. If we use all five,
    the results that will be displayed will also include the results of the four we
    won't be using, which can be confusing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, in the **Untitled circuit** tab that you just opened, hover over a qubit
    label (**q****0**). The label shifts to a trash can icon. Use this icon to remove
    qubits until you have one left. Your quantum score now has only one line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Prepending that line is the label, **q****0**, which is the name of your qubit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.7 – A blank 1-qubit quantum score](img/Figure_3.7_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.7 – A blank 1-qubit quantum score
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a ![](img/Formula_03_001.png) gate to the score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select and drag the ![](img/Formula_03_001.png) gate to the **q****0** line
    of your score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you will see further in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*, in Qiskit®, the NOT gate is represented
    by an **X**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You have now added an X, or NOT gate, which will flip the qubit from its initial
    set value 0 to 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.8 – NOT gate added](img/Figure_3.8_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.8 – NOT gate added
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A glossary of operations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To get more information about the available instructions, click the (**i**)
    icon in the upper-right corner of Circuit Composer and select **Operations glossary**
    to open up an exhaustive guide to all instructions (gates, measurements, and more)
    that are available to you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, add a measurement instruction to finish off your circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The measurement instruction is required if you want to run your score and get
    a result. It measures the state of the **q****0** qubit and writes the result
    (0 or 1) to the classical register (**c1**) so that you can see the outcome of
    your experiment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In multi-qubit circuits, there is no need to display all the classical registers
    as lines. Instead, they are represented by one line labeled with the number of
    classical registers that it represents; for example, **c5** for five classical
    registers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Measurement instruction added](img/Figure_3.9_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.9 – Measurement instruction added
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now run your circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, save the circuit by first selecting **Untitled circuit** and giving
    the experiment a good name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Run on ibmq_qasm_simulator** button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take a look at the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To see the results of your job, click the **Jobs** icon right beneath the **Run**
    button. The results of your job are displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The job results box](img/Figure_3.10_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.10 – The job results box
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Clicking the job results box opens the **Result** page, and displays the final
    result of the job you just ran. In this case, we got a result of **1**, with **100%**
    certainty:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Job result: 1 with 100% certainty](img/Figure_3.11_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.11 – Job result: 1 with 100% certainty'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, go ahead and play a little.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag some more quantum instructions into your score willy-nilly, and adjust
    the number of qubits up and down. You are now building complex quantum circuits,
    but not necessarily working quantum programs or algorithms. This would be like
    soldering on random gates to your classical computer or cooking by randomly adding
    ingredients to your pot. You would get some kind of result, but probably nothing
    useful or edible. But it is fun!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here''s an example – see if you can recreate it and then inspect it to see
    what it does (if anything):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Randomly dragged and dropped circuit](img/Figure_3.12_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Randomly dragged and dropped circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Just look at the complex results of that circuit. I wonder what it does? And
    also, note the two graphical boxes at the bottom of the page: **Measurement Probabilities**
    and **Q-sphere**. I have ignored them until now, but let''s take a look and see
    what they are.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The score is read, much like a music score, from left to right, in time. This
    means that the gates on the left side of the score execute before the ones more
    to the right. You can inspect how your circuit should behave by using the **Inspect**
    feature of the composer:'
  prefs: []
  type: TYPE_NORMAL
- en: In IBM Quantum Experience®, open the circuit that you just created, with a single
    qubit, a single NOT gate, and a measurement instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the top menu, select **Inspect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window that opens, you can now step your way through your
    score to see how the statevector that represents your qubit changes as you apply
    the gates by clicking **>**. You will also see the so-called Q-sphere, which is
    a graphical representation of the possible outcomes of your circuit. We first
    encountered the state vector in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*. More about the Q-sphere can be found
    in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding
    the Qiskit® Gate Library*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our case, with just a single X gate, as we set up our qubit to start as
    0, we expect the statevector to start at ![](img/Formula_03_003.png) and then
    become ![](img/Formula_03_004.png) as we apply the first X gate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Visualizing the X gate action on our qubit as a statevector
    and as a Q-sphere'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Visualizing the X gate action on our qubit as a statevector and
    as a Q-sphere
  prefs: []
  type: TYPE_NORMAL
- en: 'The Q-sphere indicates that we will get only one outcome and that this outcome
    will be ![](img/Formula_03_005.png). If you switch the **Statevector** display
    to the **Measurement Probabilities** option instead, you can verify my statement
    that the circuit should, indeed, produce the result 100% of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – The result 1 with 100% certainty](img/Figure_3.14_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – The result 1 with 100% certainty
  prefs: []
  type: TYPE_NORMAL
- en: The **Inspect** tool lets you test your circuit at any gate. This is not possible
    when running on an actual quantum computer, as testing a qubit would be the same
    as measuring it, and then the qubit loses its quantumness and behaves like a classical
    bit. What is done here is a quick run of the circuit up to that point using a
    statevector simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to include the initial ![](img/Formula_03_006.png) state in the
    inspection, then add a barrier instruction before the first gate of your circuit.
    The barrier doesn''t manipulate the qubit but will let the **Inspect** tool register
    the initial state of the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Adding a barrier gate before the first gate](img/Figure_3.15_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Adding a barrier gate before the first gate
  prefs: []
  type: TYPE_NORMAL
- en: In the chapters that follow, we will create a variation of this **Inspect**
    feature to look through our circuits before we run them. For more information,
    see the *Visualizing circuits and results* recipe in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*.
  prefs: []
  type: TYPE_NORMAL
- en: Tossing a quantum coin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the examples I use is what is arguably the simplest useful quantum program
    that you can build: a simulated coin toss.'
  prefs: []
  type: TYPE_NORMAL
- en: We will go into more detail about the quantum coin toss in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*, but I will use that program as an example
    here. It is very small, and not too complicated to understand.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed briefly in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, a quantum computer, in contrast to
    a classical computer, provides you with probabilistic, or randomized, computation.
    In this case, we set up our qubit as a superposition that results in probabilities
    to get an outcome of 0 or 1, or heads or tails in coin toss nomenclature, when
    we measure the qubit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Build the quantum circuit and then run it. This is the circuit we will come
    back to later in the book, on the Qiskit® side of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to IBM Quantum Experience® at [https://quantum-computing.ibm.com/composer](https://quantum-computing.ibm.com/composer).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From IBM Quantum Experience®, select **Circuit Composer** from the left pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the gates that you need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe, we will just use two quantum instructions, one of which we briefly
    discussed in *Chapter 2*, *Quantum Computing and Qubits with Python*, in the *Hadamard
    gate* recipe. Remember that the H gate takes the input qubit and creates a superposition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will also use a measurement instruction to measure the qubit and write the
    result to the classical bit line at the bottom of the score.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the circuit by dragging the H gate from the **Gates** section of the composer
    to the first qubit line. And then drag the **Measurement** instruction to the
    same line, placing it to the right of the H gate. Your quantum score is now done.
    Your circuit should look something like this:![Figure 3.16 – Simple coin toss
    circuit](img/Figure_3.16_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 3.16 – Simple coin toss circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But why do I have so many qubits that I do not use?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The default number of qubits set by the composer is **3**. You can place your
    H gate on any qubit you want as long as you place the **Measure** instruction
    on the same qubit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is also nothing stopping you from placing an H gate on each of the qubits
    followed by a **Measure** gate. What you are then building is a set of five simultaneous
    coin tosses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also change the number of qubits, by clicking on the **+** icon directly
    below the lowest qubit, or by hovering over a qubit and clicking the trashcan
    icon that appears.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the circuit by first clicking **Untitled circuit** and giving the experiment
    a good name, then save it. Your circuit is now ready to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Run on ibmq_qasm_simulator** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To see the results of your job, click the **Jobs** icon right beneath the **Run**
    button. Wait for the job to display the **Completed** result, then click the job
    results box to open the **Result** page. Your 1,024 runs of the same circuit have
    resulted in a statistical 50/50 spread of the two possible outcomes 0 and 1, as
    we expected in the *Quick introduction to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*. The results will look something like
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.17 – The 50/50 result of our quantum coin toss, half heads and half
    tails](img/Figure_3.17_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.17 – The 50/50 result of our quantum coin toss, half heads and half
    tails
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, the output is a roughly equal probability of getting a 0 or a 1, just
    like a physical coin, where the probability of heads or tails is roughly equal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run your score on a real quantum computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But really, running your scores on a simulator is a little disappointing perhaps.
    That is not why you started down the quantum computing path. But fear not, we
    can do better.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will run the score one more time but select a non-simulator backend. For
    this simple quantum score, the result will be the same for a 1-qubit coin toss
    unless the backend is really out of tune. For more complex quantum programs, however,
    the results will differ between the simulator and the real quantum computer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Run settings** button, and then select a *backend* other than **ibmq_qasm_simulator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get a feel for how long your wait time might be for each backend, you can
    go to the main **IBM Quantum Experience** dashboard and look at the individual
    queues for the backends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wait for the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see the results of your job, click the **Jobs** icon right beneath the **Run**
    button. Wait for the job to display the **Completed** result, then click the job
    results box to open the **Results** page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Get in line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By default, your quantum score will run on the online IBM Quantum® simulator
    that simulates a universal 32-qubit quantum computer. The simulator is a great
    way to test and tweak your quantum scores to make sure they run the way that you
    expect them to. Running on the simulator is usually very quick. Running on an
    actual quantum computer can take longer though, as you will be sharing those with
    other users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The results might look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.18 – The quantum coin toss results on a real quantum computer](img/Figure_3.18_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – The quantum coin toss results on a real quantum computer
  prefs: []
  type: TYPE_NORMAL
- en: Note how the result looks fairly similar to what you got on the simulator. This
    will generally be the case unless the physical quantum computer qubit on which
    you run your score is out of balance, and favors one outcome over the other. Remember,
    the actual qubits are physical things and not perfect mathematical abstracts.
    In [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the
    IBM Quantum® Hardware with Qiskit®,* we will, among other things, take a look
    at how individual qubits behave, and what to expect when running your circuits
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A non-simulator backend can only inherently run a set of basis gates, from which
    all other gates are constructed. When you run your quantum program, it gets interpreted
    by the software, and the fairly complex high-level gate architecture gets `u1`,
    `u2`, `u3`, `id`, and `cx`. It turns out that all quantum programs that you write
    on Qiskit® can be expressed by using only these gates.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the basis gates used by the quantum backend from the **Your backends**
    part of the IBM Quantum Experience® web console, by clicking the backend that
    you are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – The ibmq_santiago backend basis gates are u1, u2, u3, cx, and
    id'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – The ibmq_santiago backend basis gates are u1, u2, u3, cx, and
    id
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important? Well, the translation of the gates (in your score) to
    the basis gates that can be run on a backend is called **transpiling** and is
    done before you run the program. The transpiler takes your input score and converts
    it to the basis gates, which are then run on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it turns out that the regular gates that you are using are not always directly
    translatable to a single basis gate. Sometimes the transpiler has to do a bit
    of work, reworking your circuit by replacing your gates with clusters of other
    gates.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are the original and transpiled versions of the simple quantum
    coin toss as run on one of IBM''s 5-qubit machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Original and transpiled quantum coin toss'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.20_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Original and transpiled quantum coin toss
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, not many changes have occurred. The **H** gate is now a **U2**
    gate with 0 and ![](img/Formula_03_007.png) as input, and our simplified 3-qubit
    score is replaced by the actual five qubits of the backend. But the depth of the
    circuit stays the same – two gates long.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more complicated circuits, things get more complex mainly because there
    are other gates in it. In the example that follows, which is from [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover''s Search Algorithm*, in addition to X and H gates, there are more elaborate
    gates, such as the **controlled-controlled NOT** (**CCX**) gate with two inputs
    and one output. The original score has a depth of 22 gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Original Grover search algorithm for three qubits](img/Figure_3.21_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Original Grover search algorithm for three qubits
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the quantum computer backend cannot directly use the X, H, and CCX
    gates, these have to be transpiled into U and CX gates. The transpiled score is
    49 gates deep:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Transpiled Grover search algorithm for three qubits'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.22(a)_B14436-01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – Transpiled Grover search algorithm for three qubits
  prefs: []
  type: TYPE_NORMAL
- en: The importance of the barrier
  prefs: []
  type: TYPE_NORMAL
- en: If you take a closer look at the original Grover circuit, you will notice that
    in some locations, you see two of the same kind of gate immediately following
    each other. Remember from [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, that quantum gates are reversible,
    and that two identical gates following each other might simply cancel out. If
    we let the transpiler go to work, it would just remove the duplicated gates in
    order to simplify the circuit. This is usually not the best solution as the gates
    might be part of a bigger structure that needs to be kept intact.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the barrier component and the vertical gray bar in the score comes
    in. A **barrier** tells the transpiler to not simplify across it; if two identical
    gates are separated by a barrier, the transpiler will not remove them but transpile
    each of them into the correct gate type. Take a look at the transpiler version
    of the Grover score and you will see what I mean.
  prefs: []
  type: TYPE_NORMAL
- en: Moving between worlds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you have seen how to create your quantum scores in Circuit Composer, and
    how to run them on a simulator, and on a real IBM quantum computer. But the rest
    of the book will be about working in Qiskit® with your programs. Do we just say
    farewell to IBM Quantum Experience® then?
  prefs: []
  type: TYPE_NORMAL
- en: Not so fast. IBM Quantum Experience® is a great environment for learning how
    to build quantum scores, and you do not have to troubleshoot Python code or worry
    about your environment being up to date (IBM takes care of that for you), and
    it is actually pretty easy to take what you create in IBM Quantum Experience®
    and just move it over to Qiskit®.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Qiskit®**: With Qiskit® code export, your quantum score is translated into
    Python code that you can paste directly into your Python interpreter and run.
    This is a one-way trip from IBM Quantum Experience® to Qiskit®.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuantumCircuit.from_qasm_str()` method in Qiskit® to import that code. To
    go the other way, use `<circuit>.qasm()` to export your circuit from Qiskit® and
    then paste into **Code Editor** to go the other way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python files for this recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter03](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by importing the QASM code from your coin toss experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your web browser, go to the following URL, and then log in with your IBM
    Quantum Experience® account: [https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Circuit Composer**, and in the breadcrumb click **Circuits**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Circuit Composer** file page, click your **Coin toss** circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Circuit Composer** window, in the left pane, select the **<\> Code**
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To export your quantum score as Qiskit® code, in the dropdown select `print(circuit)`
    line and running the code. This will result in an output something like this:![Figure
    3.23 – The exported coin toss Python code and its output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.23_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.23 – The exported coin toss Python code and its output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To export your quantum score as QASM code, in the dropdown, select `.qasm` file,
    and later import that file into Qiskit®.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move over to your Qiskit® environment and run the `ch3_r1_import_qasm.py`
    file. If you have forgotten how to get there, take a look at the *Open a recipe
    file* recipe in *Chapter 1*, *Preparing Your Environment*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this simple recipe, we will only need the `QuantumCircuit` method, so we''ll
    add that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we import the QASM string from IBM Quantum Experience®, either as a
    pasted string or as a saved file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you paste in the QASM code at the prompt, you will end up with something
    similar to the following example. If you enter a filename, the file will get imported,
    with much the same end result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Paste in a QASM string from IBM Qx (or enter the full path and filename of
    a `.qasm` file to import):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hit *Enter* and the circuit is imported to Qiskit®, and can now be used for
    quantum computations. The added print(circuit) at the end should display something
    like the following:![Figure 3.24 – The imported coin toss quantum circuit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.24_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.24 – The imported coin toss quantum circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have now imported your QASM code into Qiskit® and created a quantum circuit
    object named `circ`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s try creating and exporting OpenQASM code from Qiskit®:'
  prefs: []
  type: TYPE_NORMAL
- en: But I don't know how to code in Qiskit® yet
  prefs: []
  type: TYPE_NORMAL
- en: Up until this point, you have not yet created any quantum circuits in Qiskit®.
    Not to worry, we will use the `random_circuit()` method to create random circuits
    that you can export and then import into IBM Quantum Experience® to take a look
    at.
  prefs: []
  type: TYPE_NORMAL
- en: In your Qiskit® environment, open the `ch3_r2_export_qasm.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The random circuit method to import is this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we create and print a random quantum circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The depth of the random circuit is set to `2` in this example, which means we
    will create a circuit with two gates maximum. The number of qubits is also set
    to `2`, with obvious results. You can tweak these numbers to see what shows up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The circuit might look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.25 – A randomly created circuit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_3.25_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.25 – A randomly created circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we export the circuit as QASM code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QASM code is displayed and is also saved to a file in your local environment
    with the filename specified:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in IBM Quantum Experience®, you can now go to the circuit editor in the
    `Circuit.qasm` file that you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Watch your circuit instantly appear in Circuit Composer:![Figure 3.26 – Imported,
    randomly generated circuit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_3.26_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.26 – Imported, randomly generated circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now run the circuit, drag and drop new gates into the circuit, or just
    move or tweak the existing gates to see how your changes cause the circuit to
    behave differently. Don't forget to use the **Inspect** feature, **Measurement
    probabilities**, and **Q-sphere** displays to step through your circuit and see
    what it does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use the `circ=QuantumCircuit.from_qasm_file()` method to import your
    quantum score, the `circ` object that you assign it to is now a `QuantumCircuit()`
    object, much in the same way that you will be creating quantum circuits in the
    chapters that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Using Qiskit®, you can display the circuit, append gates to the circuit, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be doing anything elaborate with the circuit in this chapter, but
    put a bookmark here to return when you start creating your own circuits in [*Chapter
    4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting at the Ground Level
    with Terra*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you work your way through this book, you will be running your experiments
    mainly in your Python Qiskit® environment. If you want to, you can pull the circuits
    that you build over from the IBM Quantum Experience® environment and run them
    here as well. Perhaps you like the graphical drag-and-drop environment better,
    and the option to edit your scores on the fly?
  prefs: []
  type: TYPE_NORMAL
- en: In the Qiskit® Python examples that follow, we will be creating `QuantumCircuit`
    objects that we give names such as `qc`, `circ`, `circuit`, and so on. You can
    export these to QASM and then import them to IBM Quantum Experience® using the
    `circ.qasm(formatted=True, filename="Circuit.qasm")` command.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can use the `print(circ)` or `circ.draw()` functions to print
    out the circuit, and then manually recreate it in the composer.
  prefs: []
  type: TYPE_NORMAL
- en: Our sample code from building quantum scores with IBM Quantum Experience®
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you remember, we displayed a fairly complex but random circuit in the second
    recipe of this chapter. Here is the QASM code for that circuit. Go ahead and import
    it and see if you get the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For much more information about OpenQASM, see the following publications:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Open Quantum Assembly Language*, Andrew W. Cross, Lev S. Bishop, John A. Smolin,
    Jay M. Gambetta, [https://arxiv.org/abs/1707.03429](https://arxiv.org/abs/1707.03429).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OpenQASM* GitHub project: [https://github.com/Qiskit/openqasm](https://github.com/Qiskit/openqasm).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
