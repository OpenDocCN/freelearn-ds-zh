<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Introduction to Location Privacy Protection Mechanisms</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Adding noise to protect location data</li>
<li>Creating redundancy in geographical query results</li>
</ul>
<div class="packt_tip">This chapter includes a set of references to documents (news, laws, academic work, and so on) that will be cited along the text, using a <em>[#]</em> format.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>This chapter is dedicated to an emerging issue in the design and implementation of location-based information systems: LBISs. The increasing use of smartphones in all kinds of applications, and their ability to acquire and report users' locations, has been adopted as a core functionality of many service providers. Enabling access to users' accurate locations throughout the day, which gives context to their requests and allows companies to better know their client and provide any relevant personalized services; however, this information can contain much more about the user than just the context of the service they want to access, such as their weekly routine, frequently visited places, groups of people gathered, and so on. These patterns can be obtained from the phone, and then analyzed and used to categorize or profile customers; this information in the wrong hands, however, could be used against individuals.</p>
<p>Even though there is very little <em>[1]</em> to no regulation on how to handle location information in a way that guarantees privacy for users, it is very important that the proper policies and implementation are included at the design stage.</p>
<p>Fortunately, among geoprivacy researchers, there exists a wide variety of mechanisms that can be used to help mitigate the issue of privacy in LBISs.</p>
<p><span>This chapter is somewhat different from the others because, in order to understand the background of each location privacy technique, we considered important to include the theoretical bases that support these recipes that to the best of our knowledge are only available through academic publications and not yet presented as a hands-on experience.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Definition of Location Privacy Protection Mechanisms – LPPMs</h1>
                </header>
            
            <article>
                
<p>Location privacy can be defined by <em>Duckham</em> and <em>Kulik</em> in <em>[2]</em> as follows: <em>A special type of information privacy which concerns the claim of individuals to determine for themselves when, how, and to what extent location information about them is communicated to others</em>. Based on this definition, users should have power over their location information; however, it is well known that this is not the reality in many cases. Often, a service provider requires full access to a user's location in order for the service to become available.</p>
<p>In addition, because there is no restriction on the quality of location information that service providers can record, it's common for the exact GPS coordinates to be acquired, even when it is not relevant to the service itself.</p>
<p>The main goal of LPPMs should be to allow users to hide or reduce the quality of this location information in such a way that users will still have an adequate service functionalities, and that the service provider can still benefit from insights product of spatial analysis .</p>
<p>In order to provide geoprivacy, it is important to understand the components location information, these are: identity, location, and time. If an adversary is able to link those three aspects, location privacy is compromised. These components form an instance of location information; a sequence of such instances that gives historical location information, allowing others to establish behavior patterns and then making it possible for them to identify the user's home, work, and routine. Most LPPMs attack at least one of these components in order to protect privacy.</p>
<p>Suppose an attacker gains access to a user's identity and the time, but has no clear knowledge of what places the user has visited. As the location component has been obfuscated, the attacker would be able to infer very little, as the context is highly-altered and the data has lost its potential usability. (This specific scenario corresponds to location privacy.)</p>
<p>Another popular solution has been the implementation of identity privacy or anonymity, where users' traveled pathways can be accessed, but they provide no information on the identity of the subjects, or even if they are different users; however, this information alone could be enough to infer the identity of a person by matching records on a phonebook, as in the experiments conducted by <em>[3]</em>.</p>
<p>Finally, when a user's location and identity are specified, but the time component is missing, the resulting information lacks context, and so pathways may not be reconstructed accurately; however, implementing a model in which this occurs is unlikely, as requests and LBS responses happen at a specific time and delaying queries can cause them to lose their relevance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classifying LPPMs</h1>
                </header>
            
            <article>
                
<p>Privacy in location-based services is often viewed as reaching a desirable trade-off between performance and a user's privacy; the more privacy provided, the less likely it is that the service can function as it would under a no-privacy scheme, or without suffering alterations in their architecture or application layer. As LBS offers a great variety of ever-changing features that keep up with users' needs while making use of the latest available technologies and adjusting to social behavior, they provide a similar scenario to LPPMs that aims to cover these services.</p>
<p>In the case of <strong>proactive location-based services</strong> (<strong>PLBS</strong>), where users are constantly reporting their location <em>[4]</em>, the purpose of LPPMs is to alter the route as much as possible, while still providing a minimum level of accuracy that will allow the LBS to provide relevant information. This can be challenging because many PLBS, like traffic guidance apps, require the exact location of the user. So, unless the original data can be recovered or used in the altered format, it would be very complicated for these applications to implement an LPPM. Other services, like geomarketing or FriendFinder, may tolerate a larger alteration of the data, even if the change cannot be undone.</p>
<p>On the other hand, mechanisms intended for <strong>reactive location-based services</strong> (<strong>RLBS</strong>) often do not require critical accuracy, and therefore it is tolerable to alter the subject's position in order to provide location privacy.</p>
<p>Some LPPMs require special features alongside the usual client-server architecture, such as special database structures, extra data processing layers, third-party services, proxies, special electronics, a peer-to-peer approach between the LBS users' community, and so on. </p>
<p>Based on this, a proposed way to classify LPPMs is based on the application to PLBS and RLBS. Some of the techniques are general enough that they can be used in both worlds, but each has different implications:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-404 image-border" src="assets/24c7c337-24c2-4fea-b3c9-ab4be51bfcd1.jpg" style="width:27.17em;height:28.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 1. Taxonomy of LPPMs</div>
<p>In this chapter, two examples of LPPM implementations will be shown: noise-based location obfuscation, and private-information retrieval. Each of these imply changes to the design of the LBIS and the geographical database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding noise to protect location data</h1>
                </header>
            
            <article>
                
<p>Some of the mechanisms designed for location privacy protection are based on location obfuscation, which is explained in <em>[5]</em> as <em>the means of deliberately degrading the quality of information about an individual's location in order to protect that individual's location privacy</em>.</p>
<p>This is perhaps the simplest way to implement location privacy protection in LBISs because it has barely any impact on the server-side of the application, and is usually easy to implement on the client-side. Another way to implement it would be on the server-side, running periodically over the new data, or as a function applied to every new entry.</p>
<p>The main goal of these techniques is to add random noise to the original location obtained by the cellphone or any other location-aware device, so as to reduce the accuracy of the data. In this case, the user can usually define the maximum and/or minimum amount of noise that they want to add. The higher the noise added, the lower the quality of the service; so it is very important to reasonably set this parameter. For example, if a real-time tracking application receives data altered by 1 km, the information provided to the user may not be relevant to the real location.</p>
<p>Each noise-based location obfuscation technique presents a different way to generate noise:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c61c6588-9bd1-4932-826a-71a2c6b79574.png" style="width:46.50em;height:24.58em;"/></div>
<p>When the noise is generated with polar coordinates, it is more uniformly distributed over a projection of the circular area because both angle and distance follow that distribution. In the case of Cartesian-based noise, points appear to be generated uniformly among the area as a whole, resulting in a lower density of points near the center. The following figure shows the differences in both circular and rectangular projections of 500 random points. In this book, we will work with polar-based random generation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0849076d-054a-4574-9c6a-9ce37c494a08.png" style="width:59.58em;height:29.42em;"/></div>
<p>The following figure illustrates the way the <strong>N-RAND </strong><em>[6]</em>, <strong>θ-RAND </strong><em>[7]</em>, and <strong>Pinwheel </strong><em>[8]</em> techniques work:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c930fd02-e5c6-403d-ac57-bac0d1d7b360.png" style="width:37.67em;height:28.25em;"/></div>
<p><strong>N-RAND</strong> generates <em>N</em> points in a given area, and selects the point furthest away from the center. <strong>Θ-RAND</strong> does the same, but in a specific sector of the circular area. There can be more than just one area to select from. Finally, the <strong>Pinwheel</strong> mechanism differs from <strong>N-RAND</strong> and <strong>θ-RAND</strong> because it does not generate random distances for the points, and instead defines a specific one for each angle in the circumference, making the selection of the radius a more deterministic process when generating random points. In this case, the only random variable in the generation process is the angle <em>α</em>. The formula to calculate the radius for a given angle, <em>α</em>, is presented in <strong>(1)</strong>, as follows:</p>
<p><img class="fm-editor-equation" src="assets/4fadf42d-3da5-407e-9026-f2fb77a9f503.png" style="width:17.08em;height:1.83em;"/></p>
<p>Where <em>φ</em> is a preset parameter defined by the user, it determines the amplitude of the wings of geometry, which resembles a pinwheel.</p>
<p>The lower the value of <em>φ</em>, the more wings the pinwheel will have, but those wings will also be thinner; on the other hand, the higher the value, the fewer the number of <em>wider</em> wings:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b84090a8-9263-4ce2-8261-53d2705baa98.png" style="width:24.33em;height:24.33em;"/></div>
<p>Once the locations have been altered, it is very unlikely that you will be able to recover the original information; however, filtering noise techniques are available in the literature that reduce the impact of alterations and allow a better estimation of the location data. One of these mechanisms for noise-filtering is based on an <strong>exponential moving average</strong> (<strong>EMA</strong>) called Tis-Bad <em>[9]</em>.</p>
<p>There is still an open discussion on how much degradation of the location information is sufficient to provide location privacy to users, and moreover, if the resulting obfuscated information remains useful when accessing a LBS. After all, obtaining relevant responses while performing geospatial analysis is one of the main issues regarding LBS and the study of geo-referenced data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will create PLPGSQL functions that implement three noise-based obfuscation mechanisms: Rand, N-Rand, and Pinwheel. Then we will create a trigger function for a table in order to alter all newly inserted points. For this chapter, we will reuse the <kbd>rk_track_points</kbd> dataset used in <a href="68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml">Chapter 3</a>, <em>Working with Vector Data – The Basics</em>.</p>
<p>In this recipe, we will use the <kbd>ST_Project</kbd> function to add noise to a single point. Then, we will compare the original data with obfuscated data in QGIS. Finally, we will show the impact of noise filtering on the obfuscated data.</p>
<div class="packt_infobox">You will also need to extract the <kbd>data/chp03/runkeeper-gpx.zip</kbd> file to <kbd>working/chp12/runkeeper_gpx</kbd>.</div>
<p>In the recipe, we will use some of the same steps as in <a href="68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml">Chapter 3</a>, <em>Working with Vector Data – The Basics</em>, but for a new schema.</p>
<p>First, be sure of the format of the <kbd>.gpx</kbd> files that you need to import to PostGIS. Open one of them and check the file structure—each file must be in the XML format, composed of one <kbd>&lt;trk&gt;</kbd> element, which contains just one <kbd>&lt;trkseg&gt;</kbd> element, which contains multiple <kbd>&lt;trkpt&gt;</kbd> elements (the points stored from the runner's GPS device).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps to create the functions:</p>
<ol>
<li>Create a new schema named <kbd>chp12</kbd> to store the data for all the recipes in this chapter using the following command:</li>
</ol>
<pre>      <strong>postgis_cookbook=# create schema chp12;</strong></pre>
<ol start="2">
<li>The implementation of <kbd>Rand</kbd> requires the creation of a PLPGSQL function that receives the <kbd>radius</kbd> parameter, which defines the maximum distance, and the geometry <kbd>the_geom</kbd> to be altered.</li>
</ol>
<p style="padding-left: 60px">The <kbd>ST_Project</kbd> function will move the point to a given distance and angle from its original location. In order to simplify the expression, we will use polar noise generation. Execute the following SQL command:</p>
<pre>      <strong>postgis_cookbook=# CREATE OR REPLACE <br/>      FUNCTION chp12.rand(radius numeric, the_geom geometry) <br/>      returns geometry as $$</strong>
      <strong>BEGIN</strong>
    <strong>    return st_Project(the_geom, random()*radius, <br/>                          radians(random()*360));</strong>
      <strong>END;</strong>
      <strong>$$</strong>
      <strong>LANGUAGE plpgsql;</strong></pre>
<ol start="3">
<li>The implementation of N-Rand requires the <kbd>n</kbd> parameter, the number of trials to look for the longest distance from the original point, and the <kbd>radius</kbd> parameter, which defines the maximum distance, and the geometry <kbd>the_geom</kbd> to be altered. Execute the following SQL command:</li>
</ol>
<pre>      <strong>postgis_cookbook=# CREATE OR REPLACE FUNCTION chp12.nrand(n integer, <br/>        radius numeric, the_geom geometry) <br/>      returns geometry as $$</strong>
      <strong>DECLARE</strong>
        <strong>tempdist numeric;</strong>
        <strong>maxdist numeric;</strong>
      <strong>BEGIN</strong>
    <strong>    tempdist := 0;</strong>
    <strong>    maxdist := 0;</strong>
    <strong>    FOR i IN 1..n</strong>
    <strong>    LOOP</strong>
    <strong>      tempdist := random()*radius;</strong>
    <strong>      IF maxdist &lt; tempdist THEN</strong>
    <strong>        maxdist := tempdist;</strong>
    <strong>      END IF;</strong>
    <strong>    END LOOP;</strong>
    
    <strong>    return st_Project(the_geom,maxdist, radians(random()*360));</strong>
      <strong>END;</strong>
      <strong>$$</strong>
      <strong>LANGUAGE plpgsql;</strong></pre>
<ol start="4">
<li>The implementation of Pinwheel requires the <kbd>n</kbd> parameter, the number of trials to look for the longest distance from the original point, and the <kbd>radius</kbd> parameter, which defines the maximum distance, and the geometry <kbd>the_geom</kbd> to be altered. Execute the following SQL command:</li>
</ol>
<pre>      <strong>postgis_cookbook=# CREATE OR REPLACE FUNCTION chp12.pinwheel<br/>        (theta numeric, radius numeric, the_geom geometry) <br/>      returns geometry as $$</strong>
      <strong>DECLARE</strong>
      <strong>angle numeric;</strong>
      <strong>BEGIN</strong>
    <strong>    angle = random()*360;</strong>
    <strong>    return st_Project(the_geom,mod(<br/>          CAST(angle as integer), theta)/theta*radius, radians(angle));</strong>
      <strong>END;</strong>
      <strong>$$</strong>
      <strong>LANGUAGE plpgsql;</strong></pre>
<ol start="5">
<li>Now we will replicate part of the steps in <a href="68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml">Chapter 3</a>, <em>Working with Vector Data – The Basics</em>, but for the schema <kbd>chp12</kbd>. Create the <kbd>chp12.rk_track_points</kbd> table in PostgreSQL by executing the following command lines:</li>
</ol>
<pre>      <strong>postgis_cookbook=# CREATE TABLE chp12.rk_track_points</strong>
      <strong>(</strong>
      <strong>  fid serial NOT NULL,</strong>
    <strong>    the_geom geometry(Point,4326),</strong>
    <strong>    ele double precision,</strong>
    <strong>    "time" timestamp with time zone,</strong>
    <strong>    CONSTRAINT activities_pk PRIMARY KEY (fid)</strong>
      <strong>);</strong></pre>
<ol start="6">
<li>As an example, let's use the <kbd>nrand</kbd> function to create a trigger for all the new points inserted in the <kbd>rk_track_points</kbd> table. In order to simulate this, we will create a new table that we will use.</li>
</ol>
<p style="padding-left: 60px">This function will return a new geometry:</p>
<pre>      <strong>CREATE OR REPLACE FUNCTION __trigger_rk_track_points_before_insert(</strong>
      <strong>) RETURNS trigger AS $__$</strong>
      <strong>DECLARE</strong>
      <strong>maxdist integer;</strong>
      <strong>n integer; </strong>
      <strong>BEGIN</strong>
    <strong>    maxdist = 500;</strong>
    <strong>    n = 4;</strong>
    <strong>    NEW.the_geom  = chp12.nrand(n, maxdist, NEW.the_geom);</strong>
    <strong>    RETURN NEW;</strong>
      <strong>END;</strong>
    
      <strong>$__$ LANGUAGE plpgsql;</strong>
      <strong>CREATE TRIGGER rk_track_points_before_insert <br/>      BEFORE INSERT ON chp12.rk_track_points FOR EACH ROW <br/>      EXECUTE PROCEDURE __trigger_rk_track_points_before_insert();</strong></pre>
<ol start="7">
<li>Create the following script to import all of the <kbd>.gpx</kbd> files in the <kbd>chp12.rk_track_points</kbd> table using the GDAL <kbd>ogr2ogr</kbd> command.</li>
</ol>
<p style="padding-left: 60px"><span class="NumberedBulletWithinBulletPACKTChar">The following is the Linux version (name it</span> <kbd>working/chp03/import_gpx.sh</kbd><span class="NumberedBulletWithinBulletPACKTChar">)</span>:</p>
<pre>        #!/bin/bash 
        for f in `find runkeeper_gpx -name \*.gpx -printf "%f\n"` 
        do 
          echo "Importing gpx file $f to chp12.rk_track_points <br/>            PostGIS table..." #, ${f%.*}" 
          ogr2ogr -append -update  -f PostgreSQL <br/>          PG:"dbname='postgis_cookbook' user='me' password='mypassword'"<br/>          runkeeper_gpx/$f -nln chp12.rk_track_points <br/>          -sql "SELECT ele, time FROM track_points" 
        done </pre>
<p style="padding-left: 60px">The following is the Windows version (name it <kbd>working/chp03/import_gpx.bat</kbd>):</p>
<pre>        @echo off 
        for %%I in (runkeeper_gpx\*.gpx*) do ( 
          echo Importing gpx file %%~nxI to chp12.rk_track_points <br/>            PostGIS table... 
          ogr2ogr -append -update -f PostgreSQL <br/>          PG:"dbname='postgis_cookbook' user='me' password='mypassword'"<br/>          runkeeper_gpx/%%~nxI -nln chp12.rk_track_points <br/>          -sql "SELECT ele, time FROM track_points" 
        )</pre>
<ol start="8">
<li>In Linux, don't forget to assign an execution permission to it before running. Run the following script:</li>
</ol>
<pre>      <strong>$ chmod 775 import_gpx.sh</strong>
      <strong>$ ./import_gpx.sh</strong>
      <strong>Importing gpx file 2012-02-26-0930.gpx to chp12.rk_track_points <br/>        PostGIS table...</strong>
      <strong>Importing gpx file 2012-02-29-1235.gpx to chp12.rk_track_points <br/>        PostGIS table...</strong>
      <strong>...</strong>
      <strong>Importing gpx file 2011-04-15-1906.gpx to chp12.rk_track_points <br/>        PostGIS table...</strong></pre>
<p style="padding-left: 60px">In Windows, double-click on the <kbd>.bat</kbd> file, or run it from the command prompt using the following command:</p>
<pre>      <strong>&gt; import_gpx.bat</strong></pre>
<ol start="9">
<li>Once the insertion command is invoked, the trigger call the <kbd>nrand</kbd> function, alter the incoming geometry in the row and store the new version of the data. If we compare the first 10 values of the original table <kbd>chp03.rk_track_points</kbd> with the <kbd>chp12.rk_track_points</kbd>, it can be seen that they are slightly different, due to the added noise. Execute the following query in order to see the results:</li>
</ol>
<pre>      <strong>select ST_ASTEXT(rk.the_geom), ST_ASTEXT(rk2.the_geom)</strong>
      <strong>from chp03.rk_track_points as rk, chp12.rk_track_points as rk2 </strong>
      <strong>where rk.fid = rk2.fid</strong>
      <strong>limit 10;</strong></pre>
<p style="padding-left: 60px">The results of the query are as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/82bb510f-fa36-4128-b867-2105e7206f39.png" style="width:36.08em;height:16.58em;"/></div>
<ol start="10">
<li>In order to evaluate the impact of the noise in the data, we will create two tables to store the obfuscated data with different noise levels: 500 m and 1 km. We will use the previously defined function <kbd>rand</kbd>. Execute the following SQL commands to create the tables:</li>
</ol>
<pre>      <strong>CREATE TABLE chp12.rk_points_rand_500 AS (</strong>
        <strong>SELECT chp12.rand(500, the_geom)</strong>
        <strong>FROM chp12.rk_track_points</strong>
      <strong>);</strong>
    
      <strong>CREATE TABLE chp12.rk_points_rand_1000 AS (</strong>
        <strong>SELECT chp12.rand(1000, the_geom)</strong>
        <strong>FROM chp12.rk_track_points</strong>
      <strong>);</strong></pre>
<ol start="11">
<li>Load the tables in QGIS or your favorite Desktop GIS. The following figure shows the comparison of the original data and the obfuscated points by 500 m and 1 km:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a771f031-cd82-444f-9dbe-da916fbc2118.png" style="width:42.50em;height:30.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we applied three different mechanisms for noise-based location obfuscation: Rand, N-Rand, and Pinwheel, defining PostgreSQL functions in PLPGSQL for each method. We used one of the functions in a trigger in order to automatically alter the incoming data, so that no changes would need to be made on the application on the user's side. In addition, we showed the impact of noise comparing two versions of the altered data, so we can better appreciate the impact of the configuration noise settings</p>
<p>In the following recipes, we will look at an implementation of a private information retrieval-based LPPM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating redundancy in geographical query results</h1>
                </header>
            
            <article>
                
<p><strong>Private information retrieval</strong> (<strong>PIR</strong>) LPPMs provide location privacy by mapping the spatial context to provide a private way to query a service without releasing any location information that could be obtained by third parties.</p>
<p>PIR-based methods can be classified as cryptography-based or hardware-based, according to [9]. Hardware-based methods use a special kind of <strong>secure coprocessor</strong> (<strong>SC</strong>) that acts as securely protected spaces in which the PIR query is processed in a non-decipherable way, as in <em>[10]</em>. Cryptography-based techniques only use logic resources, and do not require a special physical disposition on either the server or client-side.</p>
<p>In <em>[10]</em>, the authors present a hybrid technique that uses a cloaking method through various-size grid Hilbert curves to limit the search domain of a generic cryptography-based PIR algorithm; however, the PIR processing on the database is still expensive, as shown in their experiments, and it is not practical for a user-defined level of privacy. This is because the method does not allow the cloaking grid cell size to be specified by the user, nor can it be changed once the whole grid has been calculated; in other words, no new PoIs can be added to the system. Other techniques can be found in <em>[12]</em>.</p>
<p>PIR can also be combined with other techniques to increase the level of privacy. One type of compatible LPPM is the dummy query-based technique, where a set of random fake or dummy queries are generated for arbitrary locations within the greater search area (city, county, state, for example)  <em>[13]</em>, <em>[14]</em>. The purpose of this is to hide the one that the user actually wants to send.</p>
<p>The main disadvantage of the dummy query technique is the overall cost of sending and processing a large number of requests for both the user and the server sides. In addition, one of the queries will contain the original exact location and point of interest of the user, so the original trajectory could still be traced based on the query records from a user - especially if no intelligence is applied when generating the dummies. There are improvements to this method discussed in <em>[15]</em>, where rather than sending each point on a separate query, all the dummy and real locations are sent along with the location interest specified by the user. In <em>[16]</em>, the authors propose a method to avoid the random generation of points for each iteration, which should reduce the possibility of detecting the trend in real points; but this technique requires a lot of resources from the device when generating trajectories for each dummy path, generates separate queries per path, and still reveals the user's location.</p>
<p>The LPPM presented as an example in this book is MaPIR – a Map-based PIR <em>[17]</em>. This is a method that applies a mapping technique to provide a common language for the user and server, and that is also capable of providing redundant answers to single queries without overhead on the server-side, which, in turn, can improve response time due to a reduction in its use of geographical queries.</p>
<p>This technique creates a redundant geographical mapping of a certain area that uses the actual coordinate of the PoI to generate IDs on a different search scale. In the MaPIR paper, the decimal digit of the coordinate that will be used for the query. Near the Equator, each digit can be approximated to represent a certain distance, as shown in the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/85f74902-b81b-49a9-b1a8-f23e13834793.png" style="width:16.42em;height:17.67em;"/></div>
<p>This can be generalized by saying that nearby locations will appear close at larger scales (closer to the integer portion of the location), but not necessarily in smaller ones. It could also show relatively far away points as though they were closer, if they share the same set of digits (nth digit of latitude and nth digit of longitude).</p>
<p>Once the digits have been obtained, depending on the selected scale, a mapping technique is needed to reduce the number to a single ID. On paper, a simple pseudo-random function is applied to reduce the two-dimensional domain to a one-dimensional one:</p>
<pre>ID(Lat_Nth, Lon_Nth) = (((Lat_Nth + 1) * (Lon_Nth + 1)) mod p) - 1</pre>
<p>In the preceding equation, we can see that <kbd>p</kbd> is the next prime number to the maximum desired ID. Given that for the paper the maximum ID was <strong>9</strong>, the value of <kbd>p</kbd> is <strong>11</strong>. After applying this function, the final map looks as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f6a4051d-011a-4a32-b113-c4be8ba8039a.png" style="width:38.08em;height:27.42em;"/></div>
<p>The following figure shows a sample <strong>PoI ID</strong> that represents a restaurant located at <strong>10.964824,-74.804778</strong>. The final mapping grid cells will be <strong>2</strong>, <strong>6</strong>, and <strong>1</strong>, using the scales k = 3, 2, and 1 respectively.</p>
<p>This information can be stored on a specific table in the database, or as the DBA determined best for the application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/11b1eb59-2888-4f6d-82af-7c9a67c85bde.png" style="width:40.42em;height:20.67em;"/></div>
<p>Based on this structure, a query generated by a user will need to define the scale of search (within 100 m, 1 km, and so on), the type of business they are looking for, and the grid cell they are located. The server will receive the parameters and look for all restaurants in the same cell ID as the user. The results will return all restaurants located in the cells with the same ID, even if they are not close to the user. Given that cells are indistinguishable, an attacker that gains access to the server's log will only see that a user was in 1 of 10 cell IDs. Of course, some of the IDs may fall in inhabitable areas (such as in a forest or lake), but some level of redundancy will always be present.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will focus on the implementation of the MaPIR technique as an example of a PIR and dummy query-based LPPM. For this, a small dataset of supermarkets is loaded on the database as PoIs. These points will be processed and stored as explained in MaPIR, and then queried by a user.</p>
<p>The dataset was obtained from the Colombian open data platform <em>Datos Abiertos</em> at the following link:</p>
<p><a href="https://www.datos.gov.co/Comercio-Industria-y-Turismo/Mapa-supermercados-Guadalajara-de-Buga/26ma-3v68">https://www.datos.gov.co/Comercio-Industria-y-Turismo/Mapa-supermercados-Guadalajara-de-Buga/26ma-3v68</a></p>
<p><span class="MsoHyperlink">The points in the dataset are presented in the following figure:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/36415eb4-cb45-4023-be00-22cab43bd9e4.png" style="width:44.42em;height:33.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In the preceding recipe, we created temporary tables to store original data, as well as tables containing MaPIR information to be queried later by users. The following steps allow other users to access those tables:</p>
<ol>
<li>First, create the table <kbd>supermarkets</kbd> to store the information extracted from the dataset, and the table <kbd>supermarkets_mapir</kbd> to store the MaPIR-related information for each supermarket register. Execute the following command:</li>
</ol>
<pre><strong>      CREATE TABLE chp12.supermarkets (</strong><br/><strong>        sup_id serial,</strong><br/><strong>        the_geom geometry(Point,4326),</strong><br/><strong>        latitude numeric,</strong><br/><strong>        longitude numeric,</strong><br/><strong>        PRIMARY KEY (sup_id)</strong><br/><strong>      );</strong><br/><strong>      CREATE TABLE chp12.supermarkets_mapir (</strong><br/><strong>        sup_id int REFERENCES chp12.supermarkets (sup_id),</strong><br/><strong>        cellid int,</strong><br/><strong>        levelid int</strong><br/><strong>      );</strong></pre>
<ol start="2">
<li>Now, create a trigger function that will be applied to all the new registers inserted in the table <kbd>supermarkets</kbd>, so that the new registers will be inserted in the <kbd>supermarkets_mapir</kbd> table, calculating the <kbd>cellid</kbd> and <kbd>levelid</kbd> values. The following code will create the function:</li>
</ol>
<pre><strong>      CREATE OR REPLACE FUNCTION __trigger_supermarkets_after_insert(</strong><br/><strong>      ) RETURNS trigger AS $__$</strong><br/><strong>      DECLARE</strong><br/><strong>      tempcelliD integer;</strong><br/><strong>      BEGIN</strong><br/><strong>        FOR i IN -2..6</strong><br/><strong>        LOOP</strong><br/><strong>          tempcellid = mod((mod(CAST(TRUNC(ABS(NEW.latitude)*POWER(10,i))</strong><br/><strong>          as int),10)+1) * (mod(CAST(TRUNC(ABS(NEW.longitude)*POWER(10,i))</strong><br/><strong>          as int),10)+1), 11)-1;</strong><br/><strong>          INSERT INTO chp12.supermarkets_mapir (sup_id, cellid, levelid) </strong><br/><strong>          VALUES (NEW.sup_id, tempcellid, i);</strong><br/><strong>        END LOOP;</strong><br/><strong>      Return NEW;</strong><br/><strong>      END;</strong><br/><strong>      $__$ LANGUAGE plpgsql;</strong><br/><strong>      CREATE TRIGGER supermarkets_after_insert <br/>      AFTER INSERT ON chp12.supermarkets </strong><strong>FOR EACH ROW <br/>      EXECUTE PROCEDURE __trigger_supermarkets_after_insert ();</strong></pre>
<ol start="3">
<li>Given that the dataset is not properly organized, we extracted the location information of the supermarkets and built the following query. After the execution, both tables <kbd>supermarkets</kbd> and <kbd>supermarkets_mapir</kbd> should be populated. Execute the following command:</li>
</ol>
<pre><strong>      INSERT INTO chp12.supermarkets (the_geom, longitude, latitude) </strong><strong>VALUES<br/></strong><strong>        (ST_GEOMFROMTEXT('POINT(-76.304202 3.8992</strong><strong>)',4326),<br/>          -76.304202, 3.8992),<br/>        (ST_GEOMFROMTEXT('POINT(-76.308476 3.894591</strong><strong>)',4326),<br/>          -76.308476, 3.894591),<br/>        (ST_GEOMFROMTEXT('POINT(-76.297893 3.890615</strong><strong>)',4326),<br/>          -76.297893, 3.890615),<br/>        (ST_GEOMFROMTEXT('POINT(-76.299017 3.901726</strong><strong>)',4326),<br/>          -76.299017, 3.901726),<br/>        (ST_GEOMFROMTEXT('POINT(-76.292027 3.909094</strong><strong>)',4326),<br/>          -76.292027, 3.909094),<br/>        (ST_GEOMFROMTEXT('POINT(-76.299687 3.888735</strong><strong>)',4326),<br/>          -76.299687, 3.888735),<br/>        (ST_GEOMFROMTEXT('POINT(-76.307102 3.899181</strong><strong>)',4326), <br/>          -76.307102, 3.899181),<br/>        (ST_GEOMFROMTEXT('POINT(-76.310342 3.90145</strong><strong>)',4326),<br/>          -76.310342, 3.90145),<br/>        (ST_GEOMFROMTEXT('POINT(-76.297366 3.889721</strong><strong>)',4326), <br/>          -76.297366, 3.889721),<br/>        (ST_GEOMFROMTEXT('POINT(-76.293296 3.906171</strong><strong>)',4326),<br/>          -76.293296, 3.906171),<br/>        (ST_GEOMFROMTEXT('POINT(-76.300154 3.901235</strong><strong>)',4326),<br/>          -76.300154, 3.901235),<br/>        (ST_GEOMFROMTEXT('POINT(-76.299755 3.899361</strong><strong>)',4326),<br/>          -76.299755, 3.899361),<br/>        (ST_GEOMFROMTEXT('POINT(-76.303509 3.911253</strong><strong>)',4326),<br/>          -76.303509, 3.911253),<br/>        (ST_GEOMFROMTEXT('POINT(-76.300152 3.901175</strong><strong>)',4326),<br/>          -76.300152, 3.901175),<br/>        (ST_GEOMFROMTEXT('POINT(-76.299286 3.900895</strong><strong>)',4326), <br/>          -76.299286, 3.900895),<br/>        (ST_GEOMFROMTEXT('POINT(-76.309937 3.912021</strong><strong>)',4326),<br/>          -76.309937, 3.912021);</strong></pre>
<ol start="4">
<li>Now, all the supermarkets inserted in the <kbd>supermarket</kbd> table will have their MaPIR-related information in the <kbd>supermarkets_mapir</kbd> table. The following query will illustrate the information stored in the <kbd>supermarkets_mapir</kbd> table for a given register:</li>
</ol>
<pre><strong>      SELECT * FROM supermarkets_mapir WHERE sup_id = 8;</strong></pre>
<p style="padding-left: 60px">The result of the query is shown in the following table:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/15a3f8b6-c2bc-4288-b790-db5f53e8f11b.png"/></div>
<ol start="5">
<li>Now that the <kbd>supermarket</kbd> data is ready, assume that a user is at the coordinates <kbd>(-76.299017, 3.901726)</kbd>, which matches the location of one of the supermarkets, and that they want to use the scale 2 (the second decimal digit corresponding to a grid cell size of approximately 1 km² by the Equator).</li>
<li>The mobile app should generate a query asking for <kbd>levelid = 2</kbd> and a <kbd>cellid = 9</kbd>, calculated from the second decimal digit from <kbd>latitude = 0</kbd>, and <kbd>longitude = 9</kbd> on the second decimal digit. This calculation can be verified on the mapping table previously shown, with <kbd>Lat Nth +1 = 1</kbd> and <kbd>Long Nth + 1 = 10</kbd>:</li>
</ol>
<pre><strong>      SELECT sm.the_geom AS the_geom</strong><br/><strong>      FROM chp12.supermarkets_mapir AS smm, chp12.supermarkets AS sm</strong><br/><strong>      WHERE smm.levelid = 2 AND smm.cellid = 9 AND smm.sup_id = sm.sup_id;</strong></pre>
<p style="padding-left: 60px">Note that there is no need for any geographical information in the query anymore, because the mapping was done during the pre-processing stage. This reduces the query time, because it does not require the use of complex internal functions to determine distance; however, mapping cannot guarantee that all nearby results will be returned, as results in adjacent cells with different IDs may not appear. In the following figure, you can see that the supermarkets from the previous query (in black) do not include some of the supermarkets that are near the user's location (in white near the arrow). Some possible counter-measures can be applied to tackle this, such as double-mapping some of the elements close to the edges of the grid cells:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a8be935a-adae-4e3d-911b-aeff4a68874a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we implemented an LPPM that uses PIR and a dummy query called MaPIR. It created a mapping function for points of interest that allowed us to query using different scales. It also included redundancy in the answer, providing privacy protection, as it did not reveal the actual location of the user.</p>
<p>The process required for calculating the mapping of a dataset should be stored in a table that will be used for a user’s queries. In the MaPIR paper, it was shown that despite the multiple results, the execution time of the MaPIR queries took less than half the time, compared to the geopraphical queries based on distance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">References</h1>
                </header>
            
            <article>
                
<ol>
<li>
<p>European Union Directive on Privacy and Electronic Communications, 2002.</p>
</li>
<li><em>M. Duckham</em> and <em>L. Kulik</em>, <em>Location Privacy and Location-aware Computing</em>, Dyn. Mob. GIS Investig. Chang. Sp. time, vol. 3, pp. 35–51, 2006.</li>
<li>
<p><em>J. Krumm</em>, <em>Inference Attacks on Location Tracks</em>, in Pervasive Computing. Springer, 2007, pp. 127-143.</p>
</li>
<li>
<p><em>M. A. Labrador</em>, <em>A. J. Perez</em>, and <em>P. Wightman</em>. <em>Location-based Information Systems: Developing Real-time Tracking Applications</em>. Boca Raton: CRC Press, 2011.</p>
</li>
<li>
<p><em>M. Duckham</em> and <em>L. Kulik</em>, <em>A Formal Model of Obfuscation and Negotiation for Location Privacy</em>, in <em>Pervasive Computing. Springer</em>, 2005, pp. 152-170.</p>
</li>
<li>
<p><em>P. Wightman</em>, <em>W. Coronell</em>, <em>D. Jabba</em>, <em>M. Jimeno</em>, and <em>M. Labrador</em>, <em>Evaluation of Location Obfuscation Techniques for Privacy in Location-based Information Systems</em>, in Communications (LATINCOM), 2011 IEEE Latin-American Conference on, pp. 1-6.</p>
</li>
<li>
<p><em>P. Wightman</em>, <em>M. Zurbarán</em>, <em>E. Zurek</em>, <em>A. Salazar</em>, <em>D. Jabba</em>, and <em>M. Jimeno</em>, <em>θ-Rand: Random Noise-based Location Obfuscation Based on Circle Sectors</em>, in IEEE International Symposium on Industrial Electronics and Applications (ISIEA) on, 2013.</p>
</li>
<li>
<p><em>P. Wightman</em>, <em>M. Zurbarán</em>, and <em>A. Santander</em>, <em>High Variability Geographical Obfuscation for Location Privacy</em>, 2013 47th International Carnahan Conference on Security Technology (ICCST), Medellin, 2013, pp. 1-6.</p>
</li>
<li>
<p><em>A. Labrador</em>, <em>P. Wightman</em>, <em>A. Santander</em>, <em>D. Jabba</em>, <em>M. Jimeno</em>, <em>Tis-Bad: A Time Series-Based Deobfuscation Algorithm</em>, in Investigación e Innovación en Ingenierías. Universidad Simón Bolívar. Vol. 3 (1), pp. 1 - 8. 2015.</p>
</li>
<li>
<p><em>A. Khoshgozaran</em>, <em>H. Shirani-Mehr</em>, and <em>C. Shahabi</em>, <em>SPIRAL: A Scalable Private Information Retrieval Approach to Location Privacy</em>, in Mobile Data Management Workshops, 2008. MDMW 2008. Ninth International Conference on, pp. 55-62.</p>
</li>
<li><em>F. Olumofin</em>, <em>P. K. Tysowski</em>, <em>I. Goldberg</em>, and <em>U. Hengartner</em>, <em>Achieving Efficient Query Privacy for Location-based Services</em>, in Privacy Enhancing Technologies, 2010, pp. 93-110.</li>
<li>
<p><em>G. Ghinita</em>, <em>P. Kalnis</em>, <em>A. Khoshgozaran</em>, <em>C. Shahabi</em>, and <em>K. Tan</em>, <em>Private queries in location-based services: Anonymizers are not necessary</em>, in Proceedings of the 2008 ACM SIGMOD International Conference on Management of Data, pp. 121-132.</p>
</li>
<li>
<p><em>D. Quercia</em>, <em>I. Leontiadis</em>, <em>L. McNamara</em>, <em>C. Mascolo</em>, and <em>J. Crowcroft</em>, <em>SpotME if you can: Randomized Responses for Location Obfuscation on Mobile Phones</em>, in <em>Distributed Computing Systems (ICDCS), 2011 31st International Conference on,</em> 2011, pp. 363-372.</p>
</li>
<li>
<p><em>H. Kido</em>, <em>Y. Yanagisawa</em>, and <em>T. Satoh</em>, <em>An Anonymous Communication Technique using Dummies for Location-based Services</em>, in <em>Pervasive Services, 2005. ICPS '05. Proceedings. International Conference on,</em> pp. 88-97.</p>
</li>
<li>
<p><em>H. Lu</em>, <em>C. S. Jensen</em>, and <em>M. L. Yiu</em>, <em>Pad: Privacy-area aware, dummy-based location privacy in mobile services</em>, in <em>Proceedings of the Seventh ACM International Workshop on Data Engineering for Wireless and Mobile Access</em>, pp. 16-23.</p>
</li>
<li>
<p><em>P. Shankar</em>, <em>V. Ganapathy</em>, and <em>L. Iftode</em> (2009, September), <em>Privately Querying Location-based Services with sybilquery</em>. In Proceedings of the 11th international conference on Ubiquitous computing, 2009, pp. 31-40.</p>
</li>
<li><em>P. M. Wightman</em>, <em>M. Zurbarán</em>, <em>M. Rodríguez</em>, and <em>M. A. Labrador</em>, <em>MaPIR: Mapping-based Private Information Retrieval for Location Privacy in LBISs</em>, 38th Annual IEEE Conference on Local Computer Networks - Workshops, Sydney, NSW, 2013, pp. 964-971.</li>
</ol>


            </article>

            
        </section>
    </body></html>