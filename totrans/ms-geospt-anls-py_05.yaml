- en: Vector Data Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover geospatial analysis and processing of vector data. The
    following three Python libraries will be covered—Shapely, OGR, and GeoPandas.
    The reader will learn how to use these Python libraries to perform geospatial
    analysis, including the writing of basic and advanced analysis scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Each library is covered separately, with an overview of its data structures,
    methods, and classes where appropriate. We'll discuss the best use cases for each
    library and how to use them together for geospatial workflows. Short example scripts
    illustrate how to perform the basic geographical analysis. The GeoPandas library
    enables more complex functionality for doing data science tasks and incorporating
    geospatial analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing vector data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and manipulating vector data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing (plotting) vector data on a map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with map projections and reproject data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing spatial operations such as spatial joins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with vector geometries and attribute data in tabular form
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the results to answer questions, such as how many wildfires are there
    in area x?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter, you'll have a solid foundation to start working with geospatial
    vector data. You'll know the characteristics and use cases of all three geospatial
    libraries, and know how to do basic vector data processing and analysis.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: OGR Simple Features Library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OGR Simple Features Library** (part of the **Geospatial Data Abstraction
    Library** (**GDAL**)) offers a set of tools for dealing with vector data. Although
    both GDAL and OGR are now more integrated than they used to be, we can still divide
    GDAL between a vector part (OGR) and a raster part (GDAL). While OGR was written
    in C++ and the documentation is also in C++, with Python bindings we can access
    all of GDAL''s functionality using Python.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'We can distinguish the following components of OGR:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: OGR batch commands for describing and processing vector data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ogrmerge`, an instant Python script for merging multiple vector data files'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OGR library itself
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll briefly cover these components first, before moving on to some examples
    of how to use all three.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: OGR batch commands
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OGR offers a series of batch commands that can be used to describe and convert
    existing geospatial vector data. We''ve already mentioned two of them, `ogrinfo`
    and `ogr2ogr`, in [Chapter 4](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml), *Data
    Types, Storage, and Conversion*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`ogrinfo` can be used for doing all sorts of reporting on vector data, such
    as listing supported vector formats, available layers, and summary details, and
    can be combined with SQL-query syntax to select features from a dataset.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ogr2ogr` is for doing vector data translations, such as converting vector
    files between different formats, converting multiple layers into a new data source,
    and reproject vector data and filter features based on location. It can also be
    used with SQL-query syntax just like `ogrinfo`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are very powerful commands that let you do a lot of work. It is recommended
    you familiarize yourself with these commands when working with vector data. We'll
    get to some examples shortly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, two other batch commands exist for creating vector tiles, `ogrtindex`
    and `ogr2vrt`. The difference between the two is that the second one is more broadly
    usable than the first. The second command needs to be imported from an online
    script as it is not distributed with recent GDAL versions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: ogrmerge
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along with the installation of GDAL comes a set of Python scripts that can
    be used for specialized geospatial tasks. These scripts can be run directly from
    a Jupyter Notebook or terminal, along with a specified dataset. You can find all
    of the scripts inside of the `scripts` directory of your local `gdal` file folder,
    which on a Windows machine might be similar to the following path:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Users\Username\Anaconda3\pkgs\gdal-2.2.2-py36_1\scripts`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the list of Python scripts in this folder, almost all of
    them are for GDAL rather than OGR. All of these Python scripts can be run from
    a Jupyter Notebook or a terminal. Using a Jupyter Notebook, you can use the magic
    command `%run` to execute your Python script, whereas using a terminal you'd use
    `python` followed by the name of the script and the input/output data files.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Magic commands are commands that extend the core Python language and can only
    be used in the Jupyter Notebook application. They offer useful shortcuts, for
    example, inserting code from an external script, and executing Python code from
    `.py` files on disc or `shell` commands. A full list of magic commands can be
    printed with the following command in an empty cell, `%lsmagic`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses `ogrmerge.py`, a Python script available with GDAL
    version 2.2.2 and higher. Running this script from a Jupyter Notebook, it takes
    all shapefiles in a single folder from the Earth dataset and merges them into
    a single GeoPackage file called `merged.gpkg`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note that in order to run one of the Python scripts in the GDAL directory
    correctly, you need to reference their file location if it's located in a different
    folder than the one where you're running the script, which is likely to be the
    case if you're working with the Jupyter Notebook application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The OGR library and Python bindings
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OGR` library, combined with its Python bindings, forms the most important
    part for working with vector data in Python. With it, you can create points, lines,
    and polygons, and perform spatial operations on these elements. For example, you
    can calculate the area of a geometry, overlay different data on top of each other,
    and use proximity tools such as buffers. Additionally, just as with `ogrinfo`
    and `ogr2ogr`, the OGR library offers tools to read vector data files, iterate
    over individual elements, and select and reproject data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: OGR's main modules and classes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OGR library consists of two main modules—`ogr` and `osr`. Both are sub-modules
    inside of the `osgeo` module. The `ogr` sub-module deals with vector geometry,
    while `osr` is all about projections. In the *Reading and writing vector data
    with OGR* section in [Chapter 4](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml), *Data
    Types, Storage, and Conversion*, we already saw some examples of how to make use
    of both.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'OGR offers the following seven classes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '`Geometry`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spatial Reference`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Feature`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Feature Class Definition`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Layer`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dataset`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drivers`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class names are mostly self-explanatory, but it's good to have an overview
    of how OGR is structured. In the following examples, we'll see how to access and
    make use of these classes. OGR's modules, classes, and functions are documented
    on the GDAL website ([www.gdal.org/python](http://www.gdal.org/python)) but offer
    no code examples, which makes it hard to get started. What's good to know at this
    point is that other Python libraries fill in the gap and offer a more user-friendly
    way to deal with GDAL's capabilities (such as Fiona and GeoPandas). Also, both
    `ogrinfo` and `ogr2ogr` might be preferable over using Python in some use cases,
    for example, when reprojecting vector data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few OGR examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Creating polygon geometry with OGR
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OGR lets you write vector geometries such as points, lines, mulitipoints, multilinestrings,
    multipolygons and geometry collections. You can give these geometry values in
    coordinates or meters if you plan to project them later. All geometries you create
    follow the same procedure, separate points are defined and then strung together
    as lines or polygons. You define separate entities in numbers, encode them in
    **well-known binary** (**WKB**), and the final polygon is translated to **well-known
    text** (**WKT**). A Jupyter Notebook will return the coordinates of the polygon
    but won''t plot it automatically, for this, we''ll use Shapely later in this chapter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating polygon geometry from GeoJSON
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also create a geometry by passing in GeoJSON to OGR, which saves space
    compared to the first example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Basic geometric operations
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some basic geometric operations we can perform on our polygon. We
    create the area, centroid, boundary, convex hull, buffer, and check if a polygon
    contains a certain point:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing polygon data to a newly created shapefile
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our current polygon only exists in memory. We can create a new shapefile and
    write the polygon geometry we created earlier to this shapefile. The script consists
    of the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Import the modules and set the spatial reference (in this case, **World Geodetic
    System 1984** (**WGS1984**)).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the shapefile, then the layer using polygon geometry. Next, the geometry
    is put inside a feature and the feature in a layer. Notice that the script directly
    references the polygon from the earlier example.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The catch is to use the right geometry type in the first line of code, which
    in this case should be `wkbPolygon`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The polygon geometry from our earlier example is referenced in this step and
    put into the shapefile.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shapefile is added as a layer in this step.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use `ogrInfo` to see if the file has been created correctly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using a spatial filter to select features
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example uses the Natural Earth Dataset introduced in [Chapter 4](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml), *Data
    Types, Storage*, *and Conversion*, under the *Reading and writing vector data
    with GeoPandas* section. We'll use latitude-longitude coordinates to create a
    spatial filter in the form of a bounding box. This box selects only the data inside
    of this box. This is a way to work with a subset of our data. We'll use OGR's
    `SpatialFilterRec` method, which takes four values—`minx`, `miny`, `maxx` and
    `maxy`, to create a bounding box. Our (random) example is to select the cities
    in our bounding box (which shows the state of Texas, as well as parts of Oklahoma
    and Mexico). To filter our results even further, we only want the cities in the
    US. This means we have to filter our search results with an extra `if`/`else`
    statement in our `for` loop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The website [www.mapsofworld.com](http://www.mapsofworld.com) gives the following
    four values for our example code: `-102` (`minx`), `26` (`miny`), `-94` (`maxx`),
    and `36` (`maxy`) for the state of Texas. Here is the script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Shapely and Fiona
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Shapely and Fiona libraries have been introduced in [Chapter 2](757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml), *Introduction
    to Geospatial Code Libraries*, in the sections *Shapely* and *Fiona*. It makes
    sense to cover both of them together, as Shapely depends on other libraries for
    reading and writing files and Fiona fits the bill. As we'll see in the examples,
    we can use Fiona to open and read files and then pass geometry data to Shapely
    objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Shapely objects and classes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Shapely library is used for creating and manipulating 2D vector data without
    the need for a spatial database. Not only does it do away with a database, it
    also does away with projections and data formats, focusing on geometry only. The
    strength of Shapely is that it uses easily-readable syntax to create a variety
    of geometries that can be used for geometric operations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: With the aid of other Python packages, these geometries and the results of geometric
    operations can be written to a vector file format and projected if necessary—we'll
    cover examples combing `pyproj` and Fiona with Shapely's capabilities. An example
    of a workflow incorporating Shapely might be where you'd read vector geometries
    out of a shapefile using Fiona, and then use Shapely to simplify or clean up existing
    geometries, in case things might line up correctly internally or in combination
    with other geometries. The cleaned-up geometries can be used as input for other
    workflows, for example, for creating a thematic map or performing data science.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The Shapely library uses a set of classes that are implementations of three
    fundamental types of geometric objects—points, curves, and surfaces. If you are
    familiar with geospatial data and their geometries, they will sound familiar.
    If you''re not, use the examples to get familiar with them:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '| **Geometric object name** | **Class name** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| Point | Point |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| Curve | LineString, LinearRing |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| Surface | Polygon |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| Collection of points | MultiPoint |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| Collection of curves | MultiLineString |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| Collection of surfaces | MultiPolygon |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: Shapely methods for geospatial analysis
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Topological relationships are implemented as methods on geometric objects (for
    example, contains, touches, and more). Shapely also provides analysis methods
    that return new geometric objects (intersections, unions, and more). Creative
    use of the buffering method provides ways to clean shapes. Interoperation with
    other software is provided through well-known formats (WKT and WKB), NumPy + Python
    arrays, and the Python Geo Interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Fiona's data model
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Fiona is OGR's Python wrapper, Fiona uses a data model that differs
    from OGR. While OGR uses data sources, layers and features, Fiona uses the term
    records for accessing geographic features stored in vector data. These are based
    on GeoJSON features—reading a shapefile with Fiona, you reference a record through
    one of its keys, using a Python dictionary object. A record has an ID, geometry,
    and property key.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few Shapely and Fiona code examples.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Creating geometries with Shapely
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like OGR, you can use Shapely to create geometries. Jupyter Notebook will
    plot the geometries after you''ve created them, as opposed to OGR. You don''t
    have to use extra plot statements to do this, just repeat the variable name used
    to store the geometries:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Applying geometrical methods with Shapely
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a similar way to OGR, you can apply geometrical methods, using the polygon
    from the earlier example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Reading JSON geometries with Shapely
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although Shapely does not read or write data files, you can access geometries
    from outside of the library, for instance, by feeding it vector data written in
    `json`. The following script creates a polygon in `json` that is read into Shapely
    in line. Next, the mapping command returns a new, independent geometry with coordinates
    copied from the context:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Reading data with Fiona
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code reads a file from our Natural Earth dataset and prints its
    dictionary keys:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the data pretty-print (`pprint`) library that is part of Python''s standard
    library, we can print the corresponding values to the keys of the first feature
    from our dataset:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use the following methods on the data file object for printing the following
    information:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Accessing vector geometry in shapefiles using Shapely and Fiona
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using Fiona, you can open a shapefile and access attribute data, such as geometries.
    For example, our Natural Earth dataset contains a shapefile with all of the states
    in the US with their vector geometries. Use the following code to open the shapefile
    and get all of the vector geometry of the first feature (starting from index number
    `0`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can use the `shape` method and pass in all of the coordinates from Minnesota:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we plot the geometry with Shapely:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39032e40-fc47-412b-8d32-15240025c709.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'A note on plotting separate shapefile geometries in Python:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed from the prefacing text, referencing separate geometry
    elements such as a state from shapefiles and plotting them with Python isn''t
    that straightforward. Luckily, there are many code examples available for professionals
    to solve this problem. Have a look at the following options that are freely available
    for Python users, to see how you could approach plotting shapefile vector geometries
    in Python, if you decide to work directly with shapefiles instead of converting
    to the GeoJSON format:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Use NumPy arrays and `matplotlib`**: **You can use NumPy arrays to squeeze all
    of the coordinates in a one-dimensional array and plot these next.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Shapely and create a new dictionary from an existing shapefile**: **If you
    know how to reorganize an existing collection of dictionaries, it is possible
    to create a new dictionary out of an existing shapefile that uses the name of
    a geographical area as a key, with the geometry data of that area as values. Next,
    you can use Shapely to pass in elements of these dictionaries and plot them in
    Python.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `pyshp` and `matplotlib`**: **The `pyshp` library can be used to read in
    geometry information that can then be plotted with `matplotlib`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GeoPandas and `matplotlib`**: **The GeoPandas library can be used together
    to read in shapefiles. Not only can you plot vector data using matplotlib's capabilities,
    but you can also read in attribute tables as `pandas` dataframes.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoPandas
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GeoPandas has been introduced in the *GeoPandas* section of  [Chapter 2](757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml), *Introduction
    to Geospatial Code Libraries*, where its data structures and methods have also
    been covered.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial analysis with GeoPandas
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GeoPandas was created to offer data to scientists who want to work with spatial
    data similar to `pandas`, and this means giving access to geospatial attribute
    data through data structures not available through `pandas`. Combine this with
    a set of geometric operations, data overlay capabilities, geocoding and plotting
    capabilities and you have an idea of this library's capabilities. In the examples
    mentioned as we proceed, we'll cover GeoPandas' plotting methods, explain how
    to access and subset spatial data, and provide a typical workflow for doing geospatial
    analysis with GeoPandas, where data processing is an important condition for being
    able to analyze and interpret the data correctly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at a few code examples of GeoPandas.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and plotting geometry data with GeoPandas and Matplotlib
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following script combines `pandas` dataframe methods on GeoPandas GeoDataFrame
    objects. Together, you can easily subset data and plot separate feature geometries.
    We start with importing the module, the magic command for plotting data inside
    a Juypter Notebook and input data, which is a shapefile with all US state boundaries:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Some simple data inspection methods—`type(df)` returns the object type, which
    is a GeoPandas `GeoDataFrame`, which takes in the same methods as `pandas` dataframes.
    The `shape` method returns a tuple with rows and column amounts, while `df.columns`
    returns the column names as a list item:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can subset separate rows of our `GeoDataFrame` using `pandas`, `.loc` and
    `.iloc` methods. We access the first feature''s attributes, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we''ll plot some state data. First, we''ll get a list of all of the state
    names as we need the state names and their row numbers next:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Separate rows can be referenced by `name` instead of row number using `.loc`
    and a value. Repeating the `name` value returns all columns and attribute data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can plot the geometry of this variable as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is what the graph looks like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35aa3f80-07fc-48e7-ad32-6bc065dc5b38.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: 'You can plot multiple items by using the `.iloc` function and pass it a list
    of row numbers; in this case, the row numbers correspond to Washington, California,
    Nevada, and Oregon, respectively:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output graph will look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53ca246a-1f7e-4212-9d3f-63c0d05bad08.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'The same results can be obtained using the `.cx` method on the `GeoDataFrame`,
    passing in values for a bounding box. This method uses the following syntax: `df.cx[xmin:xmax,
    ymin:ymax]`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Mapping wildfire data with GeoPandas
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following script can be used to create a choropleth map that shows the total
    wildfires in the US from 1984-2015, based on total count per state. We can use
    the MTBS with fire data that was introduced in [Chapter 4](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml), *Data
    Types, Storage, and Conversion*, which gives us point data of all of the wildfire
    occurrences from 1984-2015\. We can use the state field of the wildfire data to
    map the wildfire occurrences by state. But, we choose here to overlay the data
    on a separate shapefile with state geometries, to illustrate the use of a spatial
    join. Next, we'll count the total wildfires per state and map the results. GeoPandas
    can be used to accomplish all of these tasks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with importing the module:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we import the shapefile with all of the state boundaries:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The attribute table of the file can be displayed as a `pandas` dataframe by
    repeating the variable name:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can see all of the state names listed in the name column. We will need this
    column later. The vector data can be plotted inside our Jupyter Notebook, using
    the magic command and the `plot` method from `matplotlib`. As the default maps
    look quite small, we''ll pass in some values using the `figsize` option to make
    it look bigger:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You''ll see the following map:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f4166b8-d750-402b-a4c0-84b903e89bed.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: 'The same procedure is repeated for our wildfire data. Using large values for
    the `figsize` option gives a large map showing the location of the wildfires:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The map looks something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef12ff6-c9ae-46ad-adb1-ffba9bff5878.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Have a look at the column called MTBS Zone in the `fires` `GeoDataFrame`, and
    verify that this dataset does not include all of the state names to reference
    the data. However, we have a geometry column that we can use to join both of the
    datasets. Before we can do this, we have to make sure that the data uses the same
    map projection. We can verify this as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are two map projections, but both need to have the same CRS in order
    to line up correctly. We can reproject the `fires` shapefile to WGS84 as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we''re ready to perform a spatial join, using the `sjoin` method, indicating
    we want to know if the `fires` geometries are within the state geometries:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The new `state_fires` `GeoDataFrame` has a column added to the outer right
    called name, showing the state where each fire is located:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44eddb95-7f43-4511-bb9a-4060333fe9e3.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'We can now count the total amount of wildfires per state. The result is a `pandas`
    series object showing the state name and total count. To start with the highest
    counts, we''ll use the `sort_values` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`Florida`, `California`, and `Idaho` are the three states with the most wildfires
    during 1984-2015, according to our data:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85151228-aa11-41f2-b580-a5acf8b4f2b0.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'These values can be fed into the original shapefile as a new field, showing
    total wildfire count per state:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `head` method prints the first five entries in the `states` shapefile,
    with a new field added to the right end of the table. Finally, a choropleth map
    for wildfire count per state can be created and plotted as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output will look something like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89b121e1-d8ce-40b8-a6f6-d099b4af28b3.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Compare this to another color scheme applied to the same results, doing away
    with the light colors for the lower values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is what the map looks like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfe4449d-6928-4c49-b997-a88001460399.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: 'Use the following code to fine-tune the map a little further, by adding a title
    and dropping the *x*-axis and *y*-axis:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaff1d5b-9846-4f61-b356-e29fbbf393bd.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Why data inspection matters
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you''re preparing your data, it''s good to know the data you''re dealing
    with. For example, listing statistics about your dataset that show you how many
    elements there are, and if there are any missing values. It''s common that data
    has to be cleaned up before doing the analysis. Because the GeoPandas data objects
    are subclasses of `pandas` data objects, you can use their methods to do data
    inspection and cleaning. Take, for instance, the wildfire data shapefile we used
    earlier. By listing our dataframe object, it not only prints all of the attribute
    data, but also lists the total rows and columns, which is 20340 rows and 30 columns.
    The total amount of rows can also be printed this way:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This means there are `20340` individual wildfire cases in our input dataset.
    Now, compare this row value to the sum of the counts per state, after we''ve performed
    the spatial join:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We notice that there are 74 less wildfires in our dataset after our spatial
    join. While at this point it''s not clear what went wrong with our spatial join
    and why there are missing values, it''s possible and recommended to check datasets
    before and after performing geometric operations, for example, checking for empty
    fields, non-values, or simply null-values:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The same operation can also be done by specifying a column name:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Be aware of the fact that GeoPandas geometry columns use a combination of text
    and values, so checking for NaN or zero values doesn't make any sense.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered three Python libraries for working with vector data—OGR,
    Shapely, and GeoPandas. In particular, we showed how to use all three for doing
    geospatial analysis and processing. Each library was covered separately, with
    their classes, methods, data structures and popular use cases. Short example scripts
    showed how to get started doing data processing and analysis. Taken as a whole,
    the reader now knows how to use each library separately, as well as how to combine
    all three for doing the following tasks:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing vector data
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and manipulating vector data
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting vector data
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with map projections
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing spatial operations
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with vector geometries and attribute data in tabular form
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting and analyzing the data to answer questions with a spatial component
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示和分析数据以回答具有空间成分的问题
- en: The next chapter discusses raster data processing and how to use the GDAL and
    Rasterio libraries. Using these libraries, the reader will learn how to perform
    raster-based geospatial search and analysis, and how to use geolocated text and
    images.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章讨论栅格数据处理以及如何使用GDAL和Rasterio库。使用这些库，读者将学习如何执行基于栅格的地理空间搜索和分析，以及如何使用地理定位的文本和图像。
