- en: Chapter 4. Using Raster Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a raster layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the cell size of a raster layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining the width and height of a raster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting raster bands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping raster bands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying the value of a raster at a specified point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reprojecting a raster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an elevation hillshade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating vector contours from elevation data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sampling a raster dataset using a regular grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding elevation data to line using a digital elevation model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a common extent for rasters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resampling raster resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting the unique values in a raster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mosaicing rasters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a TIFF image to a JPEG image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating pyramids for a raster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a pixel location to a map coordinate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a map coordinate to a pixel location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a KML image overlay for a raster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classifying a raster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a raster to a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Georeferencing a raster from ground control points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clipping a raster using a shapefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shows you how to bring raster data into a GIS and create derivative
    raster products using QGIS and Python. QGIS is equally adept at working with raster
    data as with vector data, by incorporating leading-edge open source libraries
    and algorithms, including GDAL, SAGA, and the Orfeo Toolbox. QGIS provides a consistent
    interface to for large array of remote sensing tools. We will switch back and
    forth between visually working with raster data and using QGIS as a processing
    engine via the Processing Toolbox, to completely automating remote sensing workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Raster data consists of rows and columns of cells or pixels, with each cell
    representing a single value. The easiest way to think of raster data is as images,
    which is how they are typically represented by software. However, raster datasets
    are not necessarily stored as images. They can also be ASCII text files or **binary
    large objects** (**BLOBs**) in databases.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between geospatial raster data and regular digital images
    is their resolution. Digital images express resolution as dots-per-inch, if they
    are printed in full size. Resolution can also be expressed as the total number
    of pixels in the image, defined as megapixels. However, geospatial raster data
    uses the ground distance that each cell represents. For example, a raster dataset
    with a two-feet resolution means that a single cell represents two feet on the
    ground. This also means that only objects larger than two feet can be identified
    visually in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Raster datasets may contain multiple bands, meaning that different wavelengths
    of light can be collected at the same time over the same area. Often, this range
    is from 3 to 7 bands wide, but it can be several hundred bands wide in hyperspectral
    systems. These bands are viewed individually or swapped in and out as the RGB
    bands of an image. They can also be recombined using mathematics into a derived
    single band image and then recolored using a set number of classes, representing
    similar values within the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a raster layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `QGSRasterLayer` API provides a convenient, high-level interface to raster
    data. To use this interface, we must load a layer into QGIS. The API allows you
    to work with a layer without adding it to the map. In this way, we'll load layer
    and then add it to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the other recipes in this book, you need to create a directory called
    `qgis_data` in our root or user directory, which provides a short pathname without
    spaces. This setup will help prevent any frustrating errors that result from path-related
    issues on a given system. In this recipe, and the others, we'll use a Landsat
    satellite image of the Mississippi Gulf Coast, which you can download from [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the `SatImage.tif` and `SatImage.tfw` files and place them in a directory
    named `rasters` within your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we'll go through how to load a raster layer and then step by step add it
    to the map
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in the **Python Console**, create the layer by specifying the source
    file and a layer name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, ensure that the layer is created as expected. The following command should
    return `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the layer to the layer registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that your QGIS map looks similar to the following image:![How to do it...](img/00029.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QGIS zooms to the extent of the raster layer when it is loaded as shown in this
    example of a Landsat satellite image of the Mississippi Gulf Coast
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `QgsRasterLayer` object requires the location of the file and a name for
    the layer in QGIS. The underlying GDAL library determines the appropriate method
    of loading the layer. This approach contrasts with the `QgsVectorLayer()` method,
    which requires you to specify a data provider. Raster layers also have a data
    provider, but unlike vector layers, all raster layers are managed through GDAL.
    One of the best features of QGIS is that it combines the best of breed open source
    geospatial tools into one package. GDAL can be used as a library as we are using
    it here from Python or as a command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created the `QgsRasterLayer` object, we do a quick check using
    the `rasterLayer.isValid()` method to see whether the file was loaded properly.
    This method will return `True` if the layer is valid. We won't use this method
    in every recipe; however, it is a best practice, especially when building dynamic
    applications that accept user input. Because most of the PyQGIS API is built around
    C libraries, many methods do not throw exceptions if an operation fails. You must
    use specialized methods to verify the output.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the layer to the map layer registry, which makes it available
    on the map and in the legend. The registry keeps track of all the loaded layers
    by separating, loading, and visualizing the layers. QGIS allows you to work behind
    the scenes in order to perform unlimited intermediate processes on a layer before
    adding the final product to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the cell size of a raster layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first key element of a geospatial raster is the width and height, in pixels.
    The second key element is the ground distance of each pixel, also called the pixel
    size. Once you know the cell size and a coordinate somewhere on the image (usually
    the upper-left corner), you can begin using remote sensing tools on the image.
    In this recipe, we'll query the cell size of a raster.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we will use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the raster as a layer and then use the `QgsRasterLayer` API to
    get the cell size for the *x* and *y* axis. To do this, we need to perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the layer and validate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, call the x distance method, which should return 0.00029932313140079714:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, call the *y* distance, which should be `0.00029932313140079714`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GDAL provides this information, which is passed through to the layer API. Note
    that while the *x* and *y* values are essentially the same in this case, it is
    entirely possible for the *x* and *y* distances to be different—especially if
    an image is projected or warped in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the width and height of a raster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All raster layers have a width and height in pixels. Because remote sensing
    data can be considered an image as well as an array or matrix, you will often
    see different terms used, including columns and rows or pixels and lines. These
    different terms surface many times within the QGIS API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the SatImage raster again, which is available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Python Console, load the layer and ensure that it is valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check the name of SatImage after unzipping.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Obtain the layer''s width, which should be `2592`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, get the raster''s height, which will return `2693`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The width and height of a raster are critical pieces of information for many
    algorithms, including calculating the map units that the raster occupies.
  prefs: []
  type: TYPE_NORMAL
- en: Counting raster bands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A raster might have one or more bands. Bands represent layers of information
    within a raster. Each band has the same number of columns and rows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will again use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the layer and then print the band count to the console. To do
    this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Python Console, load the layer and ensure that it is valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, get the band count, which should be `3` in this case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that raster bands are not zero-based indexes. When you
    want to access the first band, you reference it as `1` instead of `0`. Most sequences
    within a programming context start with `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Swapping raster bands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer displays render images in the visible spectrum of red, green, and blue
    light (RGB). However, raster images may contain bands outside the visible spectrum.
    These types of rasters make poor visualizations, so you will often want to recombine
    the bands to change the RGB values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use a false-color image, which you can download from
    [https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip this `tif` file and place it in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load this raster and swap the order of the first and second bands.
    Then, we will add it to the map. To do this, we need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Python Console**, load the layer and ensure that it is valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must access the layer renderer in order to manipulate the order of
    the bands displayed. Note that this change does not affect the underlying data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will set the `red band` to band `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will set the `green band` to band `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the altered raster layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Load the source image into QGIS as well to compare the results. In the false-color
    image, vegetation appears red, while in the band-swapped image, trees appear a
    more natural green and the water is blue. QGIS uses the RGB order to allow you
    to continue to reference the bands by number. Even though band `2` is displayed
    first, it is still referenced as band `2`. Also, notice that the band order is
    controlled by a `QgsMultiBandColorRenderer` object instantiated by the layer rather
    than the layer itself. The type of renderer that is needed is determined at load
    time by the data type and number of bands.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `QgsMultiBandColorRenderer()` method has other methods to control contrast
    enhancement for each band, such as `setRedContrastEnhancement()`. You can learn
    more about raster renderers for different types of data in the QGIS API documentation
    at [http://qgis.org/api/classQgsRasterRenderer.html](http://qgis.org/api/classQgsRasterRenderer.html).
  prefs: []
  type: TYPE_NORMAL
- en: Querying the value of a raster at a specified point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common remote sensing operation is to get the raster data value at a specified
    coordinate. In this recipe, we'll query the data value in the center of the image.
    It so happens that the raster layer will calculate the center coordinate of its
    extent for you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with many recipes in this chapter, we will again use the SatImage raster,
    which is available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the layer, get the center coordinate, and then query the value.
    To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, load and validate the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, get the layer''s center point from its `QgsRectangle extent` object,
    which will return a tuple with the *x* and *y* values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, using the layer''s data provider, we can query the data value at that
    point using the `identify()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because a query error won''t throw an exception, we must validate the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can view the query results, which will return a Python dictionary
    with each band number as the key pointing to the data values in that band:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that you get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is short compared to others, however, we have touched upon several
    portions of the PyQGIS raster API. First start with a raster layer and get the
    extents; we then calculate the center and create a point at the center coordinates,
    and lastly we query the raster at that point. If we were to perform this same,
    seemingly simple operation using the Python API of the underlying GDAL library,
    which does the work, this example would have be approximately seven times longer.
  prefs: []
  type: TYPE_NORMAL
- en: Reprojecting a raster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A core requirement for all geospatial analysis is the ability to change the
    map projection of data in order to allow different layers to be open on the same
    map. Reprojection can be challenging, but QGIS makes it a snap of the fingers.
    Starting with this recipe, we will begin using the powerful QGIS Processing Toolbox.
    The Processing Toolbox wraps over 600 algorithms into a highly consistent API,
    available to Python and also as interactive tools. This toolbox was originally
    a third-party plugin named SEXTANTE, but is now a standard plugin distributed
    with QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with many recipes in this chapter, we will use the SatImage raster available
    at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the `gdal warp` algorithm of the `processing` module
    to reproject our image from `EPSG 4326` to `3722`. To do this, we need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first line of code is used to import the `processing` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we load our raster layer and validate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we run the `gdal warp` algorithm by inserting the correct parameters,
    including the layer reference, current projection, desired projection, `None`
    for changes to the resolution, `0` to represent nearest neighbor resampling, `None`
    for additional parameters, `0 –Byte` output raster data type (`1 for int16`),
    and an output name for the reprojected image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that the output image, `warped.tif`, was properly created in the filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Processing Toolbox is essentially a wrapper for command-line tools. However,
    unlike the tools it accesses, the toolbox provides a consistent and mostly predictable
    API. Users familiar with Esri's ArcGIS ArcToolbox will find this approach familiar.
    Besides consistency, the toolbox adds additional validation of parameters and
    logging, making these tools more user friendly. It is important to remember that
    you must explicitly import the `processing` module. PyQGIS automatically loads
    the QGIS API, but this module is not yet included. Remember that it was a third-party
    plugin until fairly recently.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `runalg()` method, short for the run algorithm, is the most common way to
    run processing commands. There are other processing methods that you can use though.
    If you want to load the output of your command straight into QGIS, you can swap
    `runalg()` for the `runandload()` method. All arguments to the method remain the
    same. You can also get a list of processing algorithms with descriptions by running
    `processing.alglist()`. For any given algorithm, you can run the `alghelp()` command
    to see the types of input it requires, such as `processing.alghelp("gdalogr:warpproject")`.
    You can also write your own processing scripts based on combinations of algorithms
    and add them to the processing toolbox. There is also a visual modeler for chaining
    processing commands together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an elevation hillshade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A hillshade, or shaded relief, is a technique to visualize elevation data in
    order to make it photorealistic for presentation as a map. This capability is
    part of GDAL and is available in QGIS in two different ways. It is a tool in the
    **Terrain Analysis** menu under the **Raster** menu and it is also an algorithm
    in the Processing Toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download a DEM from [https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the file named `dem.asc` and place it in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will load the DEM layer and run the `Hillshade` processing
    algorithm against it. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `processing` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load and validate the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `Hillshade` algorithm, providing the algorithm name, layer reference,
    band number, compute edges option, zevenbergen option for smoother terrain, `z`-factor
    elevation exaggeration number, scaling ratio of vertical to horizontal units,
    azimuth (angle of the light source), altitude (height of the light source), and
    output image''s name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that the output image, `hillshade.tif`, looks similar to the following
    image in QGIS. It should be automatically loaded into QGIS via the `processing.runandload()`
    method:![How to do it...](img/00030.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Hillshade` algorithm simulates a light source over an elevation dataset
    to make it more visually appealing. Most of the time, the only variables in the
    algorithm you need to alter are the z-factor, azimuth, and altitude to get different
    effects. However, if the resulting image doesn't look right, you may need to alter
    the scale. According to the GDAL documentation, if your DEM is in degrees, you
    should set a scale of `111120`, and if it is in meters, you should set a scale
    of `370400`. This dataset covers a small area such that a scale of 1 is sufficient.
    For more information on these values, see the gdaldem documentation at [http://www.gdal.org/gdaldem.html](http://www.gdal.org/gdaldem.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating vector contours from elevation data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contours provides an effective visualization of terrain data by tracing a line
    along the same elevation to form a loop at set intervals in the dataset. Similar
    to the hillshade capability in QGIS, the **Contour** tool is provided by GDAL
    both as a menu option under the **Raster** menu in the **Extraction category**
    as well as a Processing Toolbox algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the DEM from [https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip),
    which is used in the other recipes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the file named `dem.asc` and place it in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will load and validate the DEM layer, add it to the map,
    and then produce and load the contour vector as a layer. To do this, we need to
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `processing` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load and validate the DEM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the DEM to the map using the `mapLayerRegistry` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the contour algorithm and draw the results on top of the DEM layer, specifying
    the algorithm name, layer reference, interval between contour lines in map units,
    name of the vector data attribute field that will contain the elevation value,
    any extra parameters, and output filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that the output in QGIS looks similar to the following screenshot:![How
    to do it...](img/00031.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe overlays the resulting elevation contours over the DEM as a way
    to convert elevation data into a vector data set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The contour algorithm creates a vector dataset, that is a shapefile. The layer
    attribute table contains the elevation values for each line. Depending on the
    resolution of the elevation dataset, you may need to change the contour interval
    to stop the contours from becoming too crowded or too sparse at your desired map
    resolution. Usually, autogenerated contours like this are a starting point, and
    you must manually edit the result to make it visually appealing. You may want
    to smoothen lines or remove unnecessary small loops.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling a raster dataset using a regular grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to sample a raster dataset at regular intervals in order
    to provide summary statistics or for quality assurance purposes on the raster
    data. A common way to accomplish this regular sampling is to create a point grid
    over the dataset, query the grid at each point, and assign the results as attributes
    to those points. In this recipe, we will perform this type of sampling over a
    satellite image. QGIS has a tool to perform this operation called regular points,
    which is in the **Vector** menu under **Research Tools**. However, there is no
    tool in the QGIS API to perform this operation programmatically. However, we can
    implement this algorithm directly using Python's `numpy` module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the previously used SatImage raster, available at
    [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The order of operation for this recipe is to load the raster layer, create
    a vector layer in memory, add points at regular intervals, sample the raster layer
    at these points, and then add the sampling data as attributes for each point.
    To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need to import the `numpy` module, which is included with QGIS, as
    well as the Qt core module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a `spacing` variable to control how far apart the points
    are in map units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create an `inset` variable to determine how close to the edge
    of the image the points start, in map units:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we load and validate the raster layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we collect the coordinate reference system and extent from the raster
    layer in order to transfer it to the point layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create an in-memory vector point layer, which won''t be written to
    disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to add points to the vector layer, we must access its data provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create the attributes'' fields to store the raster data samples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the `inset` variable to set up the layer''s extents inside the raster
    layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we use the `numpy` module to efficiently create the coordinates of the
    points in our regular grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a list to store the point features we will create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In one loop, we create the point features, query the raster, and then update
    the attribute table. We store the points in a list for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we pass the list of points to the data provider of the points layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we update the layer''s extents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add both the raster and vector layers to the map in the list. The
    last item in the list is on top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we refresh the map to see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows the end result, with one of the points in the
    grid identified using the **Identify Features** map tool. The results dialog shows
    the raster values of the selected point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you use the QGIS Identification Tool to click on one of the points, the
    results dialog shows the extracted Red, Green, and Blue values from the image.
  prefs: []
  type: TYPE_NORMAL
- en: Using memory layers in QGIS is an easy way to perform quick, one-off operations
    without the overhead of creating files on disk. Memory layers also tend to be
    fast if your machine has the resources to spare.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we used a regular grid, but we could have just as easily modified
    the numpy-based algorithm to create a random points grid, which in some cases
    is more useful. However, the Processing Toolbox also has a simple algorithm for
    random points called `grass:v.random`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elevation data to line vertices using a digital elevation model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a transportation route through some terrain, it is useful to know
    the elevation profile of that route. This operation can be accomplished using
    the points that make up the line along the route to query a DEM and to assign
    elevation values to that point. In this recipe, we'll do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need an elevation grid and a route. You can download this dataset from
    [https://geospatialpython.googlecode.com/svn/path.zip](https://geospatialpython.googlecode.com/svn/path.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the `path` directory containing a shapefile and the elevation grid. Place
    the whole path directory in your `qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need two processing algorithms to complete this recipe. We will load
    the raster and vector layers, convert the line feature to points, and then use
    these points to query the raster. The resulting point dataset will serve as the
    elevation profile for the route. To do this, we need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `processing` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the filenames as variables, so they can be used throughout the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load and validate the source layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the layers to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an intermediate point dataset from the line using a SAGA algorithm in
    the Processing Toolbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, use another processing algorithm from SAGA to create the final dataset
    with the grid values assigned to the points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following image saved from QGIS shows the DEM, route line, and elevation
    points with elevation labels, all displayed on the map, with some styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is necessary to convert the lines to points because a line feature can only
    have one set of attributes. You can perform the same operation with a polygon
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of running two algorithms, we can build a processing script that combines
    these two algorithms into one interface and then added it to the toolbox. In the
    Processing Toolbox, there is a category called **Scripts**, which has a tool called
    **Create new script**. Double-clicking on this tool will bring up an editor that
    lets you build your own processing scripts. Depending on your platform, you may
    need to install or configure SAGA to use this algorithm. You can find binary packages
    for Linux at [http://sourceforge.net/p/saga-gis/wiki/Binary%20Packages/](http://sourceforge.net/p/saga-gis/wiki/Binary%20Packages/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, on Linux, you may need to change the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Processing** menu, select **Options…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Options** dialog, open the **Providers** tree menu and then open the
    **Saga** tree menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck **the Use 2.0.8 syntax** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a common extent for rasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are trying to compare two raster images, it is important that they have
    the same extent and resolution. Most software packages won''t even allow you to
    attempt to compare images if they don''t have the same extent. Sometimes, you
    have images that overlap but do not share a common extent and/or are of different
    resolutions. The following illustration is an example of this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a common extent for rasters](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we'll take two overlapping images and give them the same extents.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download two overlapping images from [https://geospatialpython.googlecode.com/svn/overlap.zip](https://geospatialpython.googlecode.com/svn/overlap.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the images and place them in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to download the following processing script from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/unify_extents.zip](https://geospatialpython.googlecode.com/svn/unify_extents.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the contents and place the scripts in your `\.qgis2\processing\scripts`
    directory, found within your user directory. For example, on a Windows 64-bit
    machine, the directory will be `C:\Users\<username>\.qgis2\processing\scripts`,
    replacing `<username>` with your username.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you restart QGIS. This script is a modified version of the one created
    by Yury Ryabov on his blog at [http://ssrebelious.blogspot.com/2014/01/unifying-extent-and-resolution-of.html](http://ssrebelious.blogspot.com/2014/01/unifying-extent-and-resolution-of.html).
  prefs: []
  type: TYPE_NORMAL
- en: The original script used a confirmation dialog that required user interaction.
    The modified script adheres to the Processing Toolbox programming conventions
    and allows you to use it programmatically as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only step in QGIS is to run the newly created processing command. To do
    this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `processing` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the newly added processing algorithm, specifying the algorithm name, path
    to the two images, an optional no data value, an output directory for the unified
    images, and a Boolean flag to load the images into QGIS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the QGIS table of contents, verify that you have two images named:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows the common extent for the rasters, by setting
    the transparency of `Image1_unified.tif` to the pixel `0,0,0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you don't use the transparency setting, you will see that both images fill
    the non-overlapping areas with no data within the minimum bounding box of both
    extents. The no data values, specified as `-9999`, will be ignored by other processing
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Resampling raster resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resampling an image allows you to change the current resolution of an image
    to a different resolution. Resampling to a lower resolution, also known as downsampling,
    requires you to remove pixels from the image while maintaining the geospatial
    referencing integrity of the dataset. In the QGIS Processing Toolbox, the `gdalogr:warpproject`
    algorithm is used, which is the same as the algorithm used for reprojection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will again use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s an extra step in this process, where we will get the current pixel
    resolution of the raster as a reference to calculate the new resolution and pass
    it to the algorithm. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `processing` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load and validate the raster layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The algorithm requires projection information. We are not changing it, so just
    assign the current projection to a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the current pixel''s ground distance and multiply it by 2 to calculate
    half the ground resolution. We only use the X distance because in this case, it
    is identical to the Y distance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the resampling algorithm, specifying the algorithm name, layer reference,
    input and then output spatial reference system, desired resolution, resampling
    algorithm (`0` is the nearest neighbor), any additional parameters, `0` for output
    raster data type, and the output filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that the `resampled.tif` image was created in your `/qgis_data/rasters`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is counterintuitive at first to reduce the resolution by multiplying it.
    However, by increasing the spatial coverage of each pixel, it takes less pixels
    to cover the extent of the raster. You can easily compare the difference between
    the two in QGIS visually by loading both the images and zooming to an area with
    buildings or other detailed structures and then turning one layer off or on.
  prefs: []
  type: TYPE_NORMAL
- en: Counting the unique values in a raster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remotely-sensed images are not just pictures; they are data. The value of the
    pixels has meaning that can be automatically analyzed by a computer. The ability
    to run statistical algorithms on a dataset is key to remote sensing. This recipe
    counts the number of unique combinations of pixels across multiple bands. A use
    case for this recipe will be to assess the results of image classification, which
    is a recipe that we'll cover later in this chapter. This recipe is in contrast
    to the typical histogram function, which totals the unique values and the frequency
    of each value per band.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This algorithm relies completely on the `numpy` module, which is included with
    PyQGIS. Numpy can be accessed through the GDAL package''s `gdalnumeric` module.
    To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we must import the bridge module called `gdalnumeric`, which connects
    GDAL to Numpy in order to perform an array math on geospatial images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will load our raster image directly into a multidimensional array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code counts the number of pixel combinations in the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can take a look at the size of the resulting one-dimensional array
    to get the unique values count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, verify that the result is `16085631`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `numpy` module is an open source equivalent of the commercial package `Matlab`.
    You can learn more about Numpy at: [http://Numpy.org](http://Numpy.org).'
  prefs: []
  type: TYPE_NORMAL
- en: When you load an image using Numpy, it is loaded as a multidimensional array
    of numbers. Numpy allows you to do an array math on the entire array using operators
    and specialized functions, in the same way you would on variables containing a
    single numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: Mosaicing rasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mosaicing rasters is the process of fusing multiple geospatial images with the
    same resolution and map projection into one raster. In this recipe, we'll combine
    two overlapping satellite images into a single dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to download the overlapping dataset from [https://geospatialpython.googlecode.com/svn/overlap.zip](https://geospatialpython.googlecode.com/svn/overlap.zip)
    if you haven't downloaded it from a previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Place the two images in your `/qgis_data/rasters/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This process is relatively straightforward and has a dedicated algorithm within
    the Processing Toolbox. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the gdalogr:merge algorithm, specifying the process name, two images, a
    boolean to use the pseudocolor palette from the first image, a boolean to stack
    each image into a separate band, and the output filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that the `merged.tif` image has been created and displays the two images
    as a single raster within QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **merge** processing algorithm is a simplified version of the actual `gdal_merge`
    command-line utility. This algorithm is limited to the GDAL output and aggregates
    the extent of input rasters. It can only merge two rasters at a time. The gdal_merge
    tool has far more options, including additional output formats, the ability to
    merge more than two rasters at once, the ability to control the extent, and more.
    You can also use the GDAL API directly to take advantage of these features, but
    it will take far more code than what is used in this simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a TIFF image to a JPEG image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image format conversion is a part of nearly every geospatial project. Rasters
    come in dozens of different specialized formats, making conversion to a more common
    format a necessity. The GDAL utilities include a tool called `gdal_translate`
    specifically for format conversion. Unfortunately, the algorithm in the Processing
    Toolbox is limited in functionality. For format conversion, it is easier to use
    the core GDAL API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the SatImage raster available at [https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll open a TIFFimage using GDAL and copy it to a new dataset
    as a JPEG2000 image, which allows you to use the common JPEG format while maintaining
    geospatial information. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the gdal module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a GDAL driver for our desired format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the source image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the source dataset to the new format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the straight format conversion of an image format, the core GDAL library
    is extremely fast and simple. GDAL supports the creation of over 60 raster formats
    and the reading of over 130 raster formats.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pyramids for a raster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyramids, or overview images, sacrifice the disk space for map rendering speed
    by storing resampled, lower-resolution versions of images in the file alongside
    the full resolution image. Once you have finalized a raster, building pyramid
    overviews is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use a false-color image, that you can download from
    [https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip this `TIF` file and place it in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Processing Toolbox has a dedicated algorithm for building pyramid images.
    Perform the following steps to create pyramids for a raster
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu, select **Python Console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `processing` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `gdalogr:overviews` algorithm, specifying the process name, input image,
    overview levels, the option to remove existing overviews, resampling method (`0`
    is the nearest neighbor), and overview format (`1` is internal):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, load the raster into QGIS by dragging and dropping it from the filesystem
    onto the map canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the layer name in the map's legend to open the **Layer Properties**
    dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Layer Properties** dialog, click on the **Pyramids** tab and verify
    that the layer has multiple resolutions listed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of overview images is quite simple. You resample the images several
    times, and then a viewer chooses the most appropriate, smallest file to load on
    the map, depending on scale. The overviews can be stored in the header of the
    file for certain formats or as an external file format. The level of overviews
    needed depends largely on the file size and resolution of your current image,
    but is really arbitrary. In this example, we double the scale by a factor of 2,
    which a is common practice. Most of the zoom tools in the applications will double
    the scale when you click to zoom in. The factor of 2 gives you enough zoom levels,
    so that you usually won't zoom to a level where there is no pyramid image. There
    is a point of diminishing returns if you create too many levels because pyramids
    take up additional disk space. Usually 4 to 5 levels is effective.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a pixel location to a map coordinate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to view rasters in a geospatial context relies on the conversion
    of pixel locations to coordinates on the ground. Sooner or later when you use
    Python to write geospatial programs, you'll have to perform this conversion yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the SatImage raster available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use GDAL to extract the information needed to convert pixels to coordinates
    and then use pure Python to perform the calculation. We'll use the center pixel
    of the image as the location to convert.
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu select **Python Console**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to import the `gdal` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to define the reusable function that does the conversion accepting
    a GDAL `GeoTransform` object containing the raster georeferencing information
    and the pixel''s *x*,*y* values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we'll open the image in GDAL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, get the `GeoTransform` object from the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, calculate the center pixel of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, perform the conversion by calling our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify the coordinates returned are close to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pixel conversion is just a scaling ratio between two planes, the image coordinate
    system and the Earth coordinate system. When dealing with large areas, this conversion
    can become a more complex projection because the curvature of the Earth comes
    into play. The GDAL website has a nice tutorial about the geotransform object
    at the following URL: [http://www.gdal.org/gdal_tutorial.html](http://www.gdal.org/gdal_tutorial.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a map coordinate to a pixel location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you receive a map coordinate as user input or from some other source, you
    must be able to convert it back to the appropriate pixel location on a raster.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the SatImage raster available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous recipe, we will define a function, extract the GDAL
    `GeoTransform` object from our raster, and use it for the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu select **Python Console**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to import the gdal module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to define the reusable function that does the coordinate to pixel
    conversion. We get the GDAL `GeoTransform` object containing the raster georeferencing
    information and the map *x*,*y* coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we open the source image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, get the GeoTransform object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, perform the conversion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify your output is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This conversion is very reliable over small areas, but as the area of interest
    expands you must account for elevation as well, which requires a far more complex
    transformation depending on how an image was generated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following presentation from the University of Massachusetts does an excellent
    job of explain the challenges of georeferencing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://courses.umass.edu/nrc592g-cschweik/pdfs/Class_3_Georeferencing_concepts.pdf](http://courses.umass.edu/nrc592g-cschweik/pdfs/Class_3_Georeferencing_concepts.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a KML image overlay for a raster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GoogleEarth** is one of the most widely available geospatial viewers in existence.
    The XML data format used by GoogleEarth for geospatial data is called **KML**.
    The Open Geospatial Consortium adopted KML as a data standard. Converting rasters
    into a **KML** overlay compressed in a **KMZ** archive file is a very popular
    way to make data available to end users who know how to use GoogleEarth.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the SatImage raster again available at the following URL if you
    haven''t downloaded it from previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll create a **KML** document describing our image. Then we'll
    convert the image to a **JPEG** in memory using GDAL's specialized virtual file
    system and write all of the contents directly to a **KMZ** file using Python's
    `zipfile` module.
  prefs: []
  type: TYPE_NORMAL
- en: Start QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Plugins** menu select **Python Console**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to import the `gdal` module as well as the Python `zipfile` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll open our satellite image in `gdal`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll create a variable with our virtualized file name, using the GDAL
    virtual file naming convention beginning with `vismem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create the JPEG gdal driver object for the output format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can open the source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can copy that source file to our virtual JPEG:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are going to create a raster layer in QGIS for our raster, just for
    the benefit of it calculating the image''s extent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we get the layer''s extent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we format our KML document template and insert the image extents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we open our virtual JPEG in GDAL and prepare it for reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we write our KML document and virtual JPEG into a zipped KMZ file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, open the KMZ file in GoogleEarth and verify it looks like the following
    screenshot:![How to do it...](img/00036.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: KML is a straightforward XML format. There are entire libraries in Python dedicated
    to reading and writing it, but for a simple export to share an image or two, the
    PyQGIS console is more than adequate. While we run this script in the QGIS Python
    interpreter, it could be run outside of QGIS using just GDAL.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Orfeo Toolbox** has a processing algorithm called `otb:imagetokmzexport`
    which has a much more sophisticated KMZ export tool for images.
  prefs: []
  type: TYPE_NORMAL
- en: Classifying a raster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image classification is one of the most complex aspects of remote sensing. While
    QGIS is able to color pixels based on values for visualization, it stops short
    of doing much classification. It does provide a Raster Calculator tool where you
    can perform arbitrary math formulas on an image, however it does not attempt to
    implement any common algorithms. The Orfeo Toolbox is dedicated purely to remote
    sensing and includes an automated classification algorithm called K-means clustering,
    which groups pixels into an arbitrary number of similar classes to create a new
    image. We can do a nice demonstration of image classification using this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use a false color image which you can download here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/FalseColor.zip](https://geospatialpython.googlecode.com/files/FalseColor.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: Unzip this TIFF file and place it in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All we need to do is run the algorithm on our input image. The important parameters
    are the second, third, sixth, and tenth parameters. They define the input image
    name, the amount of RAM to dedicate to the task, the number of classes, and the
    output name respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `processing` module in the QGIS **Python Console**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, run the `otb` algorithm using the `processing.runandload()` method to
    display the output in QGIS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the image loads in QGIS, double click the layer name in the **Table of
    Contents**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Layer Properties** dialog, choose **Style**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **Render type** menu to **Singleband pseudocolor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the **color map** menu on the right to **Spectral**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Classify** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Ok** button at the bottom of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify your image looks similar to the following image, except without the class
    labels:![How to do it...](img/00037.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Keeping the class number low allows the automated classification algorithm
    to focus on the major features in the image and helps when us to achieve a very
    high level of accuracy determining overall land use. Additional automated classification
    would require supervised analysis with training data sets and more in-depth preparation.
    But the overall concept would remain the same. QGIS has a nice plugin for semi-automatic
    classification. You can learn more about it at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://plugins.qgis.org/plugins/SemiAutomaticClassificationPlugin/](https://plugins.qgis.org/plugins/SemiAutomaticClassificationPlugin/)'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a raster to a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raster datasets represent real-world features efficiently but can have limited
    usage for geospatial analysis. Once you have classified an image into a manageable
    data set, you can convert those raster classes into a vector data set for more
    sophisticated GIS analysis. GDAL has a function for this operation called **polygonize.**
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to download the following classified raster and place it in your
    `/qgis_data/rasters` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/landuse_bay.zip](https://geospatialpython.googlecode.com/svn/landuse_bay.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, you would save the output of this recipe as a shapefile. We won't
    specify an output file name. The Processing Toolbox will assign it a temporary
    filename and return that filename. We'll simply load the temporary file into QGIS.
    The algorithm allows you to write to a shapefile by specifying it as the last
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, import the `processing` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, run the algorithm specifying the process name, input image, the field
    name for the class number, and optionally the output shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get a vector layer with three classes, defined as polygons, denoting
    developed areas. In the sample image below, we have assigned unique colors to
    each class: developed area (darkest), water (midtones), and land (lightest color):![How
    to do it...](img/00038.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GDAL looks for clusters of pixels and creates polygons around them. It is important
    to have as few classes as possible. If there is too much variation in the pixels,
    then GDAL will create a polygon around each pixel in the image. You turn this
    recipe into a true analysis product by using the recipe in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Automating QGIS"), *Calculating the Area of a Polygon* to quantify
    each class of land use.
  prefs: []
  type: TYPE_NORMAL
- en: Georeferencing a raster from control points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes a raster that represents features on the earth is just an image with
    no georeferencing information. That is certainly the case with historical scanned
    maps. However, you can use a referenced data set of the same area to create tie
    points, or ground control points, and then use an algorithm to warp the image
    to fit the model of the earth. It is common for data collection systems to just
    store the **ground control points (GCP)** along with the raster to keep the image
    in as raw a format as possible. Each change to an image holds the possibility
    of losing data. So georeferencing an image on demand is often the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll georeference a historical survey map of the Louisiana
    and Mississippi Gulf Coast from 1853\. The control points were manually created
    with the QGIS Georeferencer plugin and saved to a standardized control point file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Download the following zip file, unzip the contents, and put the `georef` directory
    in `/qgis_data/rasters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/svn/georef.zip](https://geospatialpython.googlecode.com/svn/georef.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use a low-level module of the processing API to access some specialized
    GDAL utility functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the QGIS **Python Console**, import the `GdalUtils` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will set up some path names for source and target data, which will
    be used multiple times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will open up our GCP file and read past the header line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can begin building our first gdal utility command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through the GCP file and append the points to the command arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the input and output file to the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can execute the first command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we change the command to warp the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the output of the last command as the input and use the final image path
    as the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the warp command to complete the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GdalUtils API exposes the underlying tools used by the Processing Toolbox
    algorithm, yet provides a robust cross-platform approach that is better than other
    traditional methods of accessing external programs from Python. If you pull the
    output image into QGIS and compare it to the USGS coastline shapefile, you can
    see the results are fairly accurate and could be improved with additional control
    points and referenced data. The number of GCPs required for a given image is a
    matter of trial and error. Adding more GCPs won''t necessarily lead to better
    results. You can find out more about creating GCPs in the QGIS documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.qgis.org/2.6/en/docs/user_manual/plugins/plugins_georeferencer.html](http://docs.qgis.org/2.6/en/docs/user_manual/plugins/plugins_georeferencer.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Clipping a raster using a shapefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need to use a subset of an image which covers an area of interest
    for a project. In fact, areas of an image outside your area of interest can distract
    your audience from the idea you are trying to convey. Clipping a raster to a vector
    boundary allows you to only use the portions of the raster you need. It can also
    save processing time by eliminating areas outside your area of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the SatImage raster again available at the following URL if you
    haven''t downloaded it from previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/SatImage.zip](https://geospatialpython.googlecode.com/files/SatImage.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: Place this raster in your `/qgis_data/rasters` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clipping is a common operation and GDAL is well suited for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the QGIS **Python Console**, run import the processing module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, run the processing command specifying the input image name as the second
    argument and the output image as the seventh argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify your `output` raster looks like the following screenshot:![How to do
    it...](img/00039.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GDAL creates a no data mask outside the shapefile boundary. To the extent of
    the original image remains the same, however you no longer visualize it and processing
    algorithms will ignore the no data values.
  prefs: []
  type: TYPE_NORMAL
