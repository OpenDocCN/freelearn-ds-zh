<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Web Scraping"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Web Scraping</h1></div></div></div><p>R provides a platform with easy access to statistical computing and data analysis. Given a data set, it is handy to perform data transformation and apply analytic models and numeric methods with either flexible data structures or high performance, as discussed in previous chapters.</p><p>However, the input data set is not always as immediately available as tables provided by well-organized commercial databases. Sometimes, we have to collect data by ourselves. Web content is an important source of data for a wide range of research fields. To collect (scrape or harvest) data from the Internet, we need appropriate techniques and tools. In this chapter, we'll introduce the basic knowledge and tools of web scraping, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Looking inside web pages</li><li class="listitem" style="list-style-type: disc">Learning CSS and XPath selector</li><li class="listitem" style="list-style-type: disc">Analyzing HTML code and extracting data</li></ul></div><div class="section" title="Looking inside web pages"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec71"/>Looking inside web pages</h1></div></div></div><p>Web pages are made to present information. The following screenshot shows a simple web page located at <code class="literal">data/simple-page.html</code> that has a heading and a paragraph:</p><div class="mediaobject"><img src="graphics/image_14_001.jpg" alt="Looking inside web pages"/></div><p>All modern web browsers support such web pages. If you open <code class="literal">data/simple-page.html</code> with any text editor, it will show the code behind the web page as follows:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
  &lt;title&gt;Simple page&lt;/title&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
  &lt;h1&gt;Heading 1&lt;/h1&gt; &#13;
  &lt;p&gt;This is a paragraph.&lt;/p&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>The preceding code is an example of HTML (Hyper Text Markup Language). It is the most widely used language on the Internet. Different from any programming language to be finally translated into computer instructions, HTML describes the layout and content of a web page, and web browsers are designed to render the code into a web page according to web standards.</p><p>Modern web browsers use the first line of HTML to determine which standard is used to render the web page. In this case, the latest standard, HTML 5, is used.</p><p>If you read through the code, you'll probably notice that HTML is nothing but a nested structure of tags such as <code class="literal">&lt;html&gt;</code>, <code class="literal">&lt;title&gt;</code>, <code class="literal">&lt;body&gt;</code>, <code class="literal">&lt;h1&gt;</code>, and <code class="literal">&lt;p&gt;</code>. Each tag begins with <code class="literal">&lt;tag&gt;</code> and is closed with <code class="literal">&lt;/tag&gt;</code>.</p><p>In fact, these tags are not arbitrarily named, nor are they allowed to contain other arbitrary tags. Each has a specific meaning to the web browser and is only allowed to contain a subset of tags, or even none.</p><p>The <code class="literal">&lt;html&gt;</code> tag is the root element of all HTML. It most commonly contains <code class="literal">&lt;head&gt;</code> and <code class="literal">&lt;body&gt;</code>. The <code class="literal">&lt;head&gt;</code> tag usually contains <code class="literal">&lt;title&gt;</code> to show on the title bar and browser tabs and other metadata of the web page, while <code class="literal">&lt;body&gt;</code> plays the main role in determining the layout and contents of the web page.</p><p>In the <code class="literal">&lt;body&gt;</code> tag, tags can be nested more freely. The simple page only contains a level-1 heading (<code class="literal">&lt;h1&gt;</code>) and a paragraph (<code class="literal">&lt;p&gt;</code>) while the following web page contains a table with two rows and two columns:</p><div class="mediaobject"><img src="graphics/image_14_002.jpg" alt="Looking inside web pages"/></div><p>The HTML code behind the web page is stored in <code class="literal">data/single-table.html</code>:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
  &lt;title&gt;Single table&lt;/title&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
  &lt;p&gt;The following is a table&lt;/p&gt; &#13;
  &lt;table id="table1" border="1"&gt; &#13;
    &lt;thead&gt; &#13;
      &lt;tr&gt; &#13;
        &lt;th&gt;Name&lt;/th&gt; &#13;
        &lt;th&gt;Age&lt;/th&gt; &#13;
      &lt;/tr&gt; &#13;
    &lt;/thead&gt; &#13;
    &lt;tbody&gt; &#13;
      &lt;tr&gt; &#13;
        &lt;td&gt;Jenny&lt;/td&gt; &#13;
        &lt;td&gt;18&lt;/td&gt; &#13;
      &lt;/tr&gt; &#13;
      &lt;tr&gt; &#13;
        &lt;td&gt;James&lt;/td&gt; &#13;
        &lt;td&gt;19&lt;/td&gt; &#13;
      &lt;/tr&gt; &#13;
    &lt;/tbody&gt; &#13;
  &lt;/table&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Note that a <code class="literal">&lt;table&gt;</code> tag is structured row by row: <code class="literal">&lt;tr&gt;</code> represents a table row, <code class="literal">&lt;th&gt;</code> a table header cell, and <code class="literal">&lt;td&gt;</code> a table cell.</p><p>Also notice that an HTML element such as <code class="literal">&lt;table&gt;</code> may have additional attributes in the form of <code class="literal">&lt;table attr1="value1" attr2="value2"&gt;</code>. The attributes are not arbitrarily defined. Instead, each has a specific meaning according to the standard. In the preceding code, <code class="literal">id</code> is the identifier of the table and <code class="literal">border</code> controls its border width.</p><p>The following page looks different from the previous ones in that it shows some styling of contents:</p><div class="mediaobject"><img src="graphics/image_14_003.jpg" alt="Looking inside web pages"/></div><p>If you take a look at its source code at <code class="literal">data/simple-products.html</code>, you'll find some new tags such as <code class="literal">&lt;div&gt;</code> (a section), <code class="literal">&lt;ul&gt;</code> (unrecorded list), <code class="literal">&lt;li&gt;</code> (list item), and <code class="literal">&lt;span&gt;</code> (also a section used for applying styles); additionally, many HTML elements have an attribute called <code class="literal">style</code> to define their appearance:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
  &lt;title&gt;Products&lt;/title&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
  &lt;h1 style="color: blue;"&gt;Products&lt;/h1&gt; &#13;
  &lt;p&gt;The following lists some products&lt;/p&gt; &#13;
  &lt;div id="table1" style="width: 50px;"&gt; &#13;
    &lt;ul&gt; &#13;
      &lt;li&gt; &#13;
        &lt;span style="font-weight: bold;"&gt;Product-A&lt;/span&gt; &#13;
        &lt;span style="color: green;"&gt;$199.95&lt;/span&gt; &#13;
      &lt;/li&gt; &#13;
      &lt;li&gt; &#13;
        &lt;span style="font-weight: bold;"&gt;Product-B&lt;/span&gt; &#13;
        &lt;span style="color: green;"&gt;$129.95&lt;/span&gt; &#13;
      &lt;/li&gt; &#13;
      &lt;li&gt; &#13;
        &lt;span style="font-weight: bold;"&gt;Product-C&lt;/span&gt; &#13;
        &lt;span style="color: green;"&gt;$99.95&lt;/span&gt; &#13;
      &lt;/li&gt; &#13;
    &lt;/ul&gt; &#13;
  &lt;/div&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Values in style is written in the form of <code class="literal">property1: value1; property2: value2;</code>. However, the styles of the list items are a bit redundant because all product names share the same style and this is also true for all product prices. The following HTML at <code class="literal">data/products.html</code> uses CSS (<span class="strong"><strong>Cascading Style Sheets</strong></span>) instead to avoid redundant styling definitions:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
  &lt;title&gt;Products&lt;/title&gt; &#13;
  &lt;style&gt; &#13;
    h1 { &#13;
      color: darkblue; &#13;
    } &#13;
    .product-list { &#13;
      width: 50px; &#13;
    } &#13;
    .product-list li.selected .name { &#13;
      color: 1px blue solid; &#13;
    } &#13;
    .product-list .name { &#13;
      font-weight: bold; &#13;
    } &#13;
    .product-list .price { &#13;
      color: green; &#13;
    } &#13;
  &lt;/style&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
  &lt;h1&gt;Products&lt;/h1&gt; &#13;
  &lt;p&gt;The following lists some products&lt;/p&gt; &#13;
  &lt;div id="table1" class="product-list"&gt; &#13;
    &lt;ul&gt; &#13;
      &lt;li&gt; &#13;
        &lt;span class="name"&gt;Product-A&lt;/span&gt; &#13;
        &lt;span class="price"&gt;$199.95&lt;/span&gt; &#13;
      &lt;/li&gt; &#13;
      &lt;li class="selected"&gt; &#13;
        &lt;span class="name"&gt;Product-B&lt;/span&gt; &#13;
        &lt;span class="price"&gt;$129.95&lt;/span&gt; &#13;
      &lt;/li&gt; &#13;
      &lt;li&gt; &#13;
        &lt;span class="name"&gt;Product-C&lt;/span&gt; &#13;
        &lt;span class="price"&gt;$99.95&lt;/span&gt; &#13;
      &lt;/li&gt; &#13;
    &lt;/ul&gt; &#13;
  &lt;/div&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Note that we add <code class="literal">&lt;style&gt;</code> in <code class="literal">&lt;head&gt;</code> to declare a global stylesheet in the web page. We also switch <code class="literal">style</code> to <code class="literal">class</code> for content elements (<code class="literal">div</code>, <code class="literal">li</code>, and <code class="literal">span</code>) to use those pre-defined styles. The syntax of CSS is briefly introduced in the following code.</p><p>Match all <code class="literal">&lt;h1&gt;</code> elements:</p><pre class="programlisting">h1 { &#13;
  color: darkblue; &#13;
} &#13;
</pre><p>Match all elements with the <code class="literal">product-list</code> class:</p><pre class="programlisting">.product-list { &#13;
  width: 50px; &#13;
} &#13;
</pre><p>Match all elements with the <code class="literal">product-list</code> class, and then match all nested elements with the <code class="literal">name</code> class:</p><pre class="programlisting">.product-list .name { &#13;
  font-weight: bold; &#13;
} &#13;
</pre><p>Match all elements with the <code class="literal">product-list</code> class, then match all nested <code class="literal">&lt;li&gt;</code> elements with the <code class="literal">selected</code> class, and finally match all nested elements with the <code class="literal">name</code> class:</p><pre class="programlisting">.product-list li.selected .name { &#13;
  color: 1px blue solid; &#13;
} &#13;
</pre><p>Note that simply using <code class="literal">style</code> cannot achieve this. The following screenshot shows the rendered web page:</p><div class="mediaobject"><img src="graphics/image_14_004.jpg" alt="Looking inside web pages"/></div><p>Each CSS entry consists of a CSS selector (for example, <code class="literal">.product-list</code>) to match HTML elements and the styles (for example, <code class="literal">color: red;</code>) to apply. CSS selectors are not only used to apply styling, but are also commonly used to extract contents from web pages so the HTML elements of interest are properly matched. This is an underlying technique behind web scraping.</p><p>CSS is much richer than demonstrated in the preceding code. For web scraping, we use the following examples to show the most commonly used CSS selectors:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Syntax</strong></span></p>
</td><td>
<p><span class="strong"><strong>Match</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">*</code></p>
</td><td>
<p>All elements</p>
</td></tr><tr><td>
<p><code class="literal">h1, h2, h3</code></p>
</td><td>
<p><code class="literal">&lt;h1&gt;</code>,<code class="literal">&lt;h2&gt;</code>,<code class="literal">&lt;h3&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">#table1</code></p>
</td><td>
<p><code class="literal">&lt;* id="table1"&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">.product-list</code></p>
</td><td>
<p><code class="literal">&lt;* class="product-list"&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">div#container</code></p>
</td><td>
<p><code class="literal">&lt;div id="container"&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">div a</code></p>
</td><td>
<p><code class="literal">&lt;div&gt;&lt;a&gt;</code> and<code class="literal"> &lt;div&gt;&lt;p&gt;&lt;a&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">div &gt; a</code></p>
</td><td>
<p><code class="literal">&lt;div&gt;&lt;a&gt;</code> but not<code class="literal">&lt;div&gt;&lt;p&gt;&lt;a&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">div &gt; a.new</code></p>
</td><td>
<p><code class="literal">&lt;div&gt;&lt;a class="new"&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">ul &gt; li:first-child</code></p>
</td><td>
<p>First <code class="literal">&lt;li&gt;</code> in<code class="literal">&lt;ul&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">ul &gt; li:last-child</code></p>
</td><td>
<p>Last <code class="literal">&lt;li&gt;</code> in<code class="literal">&lt;ul&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">ul &gt; li:nth-child(3)</code></p>
</td><td>
<p>3rd <code class="literal">&lt;li&gt;</code> in<code class="literal">&lt;ul&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">p + *</code></p>
</td><td>
<p>Next element of <code class="literal">&lt;p&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">img[title]</code></p>
</td><td>
<p><code class="literal">&lt;img&gt;</code> with title attribute</p>
</td></tr><tr><td>
<p><code class="literal">table[border=1]</code></p>
</td><td>
<p>&lt;table border="1"&gt;</p>
</td></tr></tbody></table></div><p>In each level, <code class="literal">tag#id.class[]</code> can be used with <code class="literal">tag</code>, <code class="literal">#id.class</code>, and <code class="literal">[]</code> optionally. For more information on CSS selectors, visit <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors">https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors</a>. To learn more about HTML tags, visit <a class="ulink" href="http://www.w3schools.com/tags/">http://www.w3schools.com/tags/</a>.</p></div></div>
<div class="section" title="Extracting data from web pages using CSS selectors"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec72"/>Extracting data from web pages using CSS selectors</h1></div></div></div><p>In R, the easiest-to-use package for web scraping is <code class="literal">rvest</code>. Run the following code to install the package from CRAN:</p><pre class="programlisting">install.packages("rvest") &#13;
</pre><p>First, we load the package and use <code class="literal">read_html()</code> to read <code class="literal">data/single-table.html</code> and try to extract the table from the web page:</p><pre class="programlisting">library(rvest) &#13;
## Loading required package: xml2 &#13;
single_table_page &lt;- read_html("data/single-table.html") &#13;
single_table_page &#13;
## {xml_document} &#13;
## &lt;html&gt; &#13;
## [1] &lt;head&gt;\n  &lt;title&gt;Single table&lt;/title&gt;\n&lt;/head&gt; &#13;
## [2] &lt;body&gt;\n  &lt;p&gt;The following is a table&lt;/p&gt;\n  &lt;table i ... &#13;
</pre><p>Note that <code class="literal">single_table_page</code> is a parsed HTML document, which is a nested data structure of HTML nodes.</p><p>A typical process for scraping information from such a web page using <code class="literal">rvest</code> functions is: First, locate the HTML nodes from which we need to extract data. Then, use either the CSS selector or XPath expression to filter the HTML nodes so that the nodes we need are selected and those we don't need are omitted. Finally, use proper selectors with <code class="literal">html_nodes()</code> to take a subset of nodes, <code class="literal">html_attrs()</code> to extract attributes, and <code class="literal">html_text()</code> to extract text from the parsed web page.</p><p>The package also provides simple functions that directly extract data from a web page and return a data frame. For example, to extract all <code class="literal">&lt;table&gt;</code> elements from it, we directly call <code class="literal">html_table()</code>:</p><pre class="programlisting">html_table(single_table_page) &#13;
## [[1]] &#13;
##    Name Age &#13;
## 1 Jenny  18 &#13;
## 2 James  19 &#13;
</pre><p>To extract the first <code class="literal">&lt;table&gt;</code> element, we use <code class="literal">html_node()</code> to select the first node with the CSS selector <code class="literal">table</code> and then use <code class="literal">html_table()</code> with the node to get a data frame:</p><pre class="programlisting">html_table(html_node(single_table_page, "table")) &#13;
##    Name Age &#13;
## 1 Jenny  18 &#13;
## 2 James  19 &#13;
</pre><p>A more natural way to do this is to use pipelines, just like using <code class="literal">%&gt;%</code> with <code class="literal">dplyr</code> functions introduced in <a class="link" href="ch12.html" title="Chapter 12. Data Manipulation">Chapter 12</a>, <span class="emphasis"><em>Data Manipulation</em></span>. Recall that <code class="literal">%&gt;%</code> basically evaluates <code class="literal">x %&gt;% f(...)</code> as <code class="literal">f(x, ...)</code> so that a nested call can be unnested and become much more readable. The preceding code can be rewritten as the following using <code class="literal">%&gt;%</code>:</p><pre class="programlisting">single_table_page %&gt;% &#13;
  html_node("table") %&gt;% &#13;
  html_table() &#13;
##    Name Age &#13;
## 1 Jenny  18 &#13;
## 2 James  19 &#13;
</pre><p>Now we read <code class="literal">data/products.html</code> and use <code class="literal">html_nodes()</code> to match the <code class="literal">&lt;span class="name"&gt;</code> nodes:</p><pre class="programlisting">products_page &lt;- read_html("data/products.html") &#13;
products_page %&gt;% &#13;
  html_nodes(".product-list li .name") &#13;
## {xml_nodeset (3)} &#13;
## [1] &lt;span class="name"&gt;Product-A&lt;/span&gt; &#13;
## [2] &lt;span class="name"&gt;Product-B&lt;/span&gt; &#13;
## [3] &lt;span class="name"&gt;Product-C&lt;/span&gt; &#13;
</pre><p>Note that the nodes we want to select are of the <code class="literal">name</code> class in <code class="literal">&lt;li&gt;</code> nodes of a node of the <code class="literal">product-list</code> class, therefore we can use <code class="literal">.product-list li.name</code> to select all such nodes. Go through the CSS table if you feel you are not familiar with the notation.</p><p>To extract the contents from the selected nodes, we use <code class="literal">html_text()</code>, which returns a character vector:</p><pre class="programlisting">products_page %&gt;% &#13;
  html_nodes(".product-list li .name") %&gt;% &#13;
  html_text() &#13;
## [1] "Product-A" "Product-B" "Product-C" &#13;
</pre><p>Similarly, the following code extracts the product prices:</p><pre class="programlisting">products_page %&gt;% &#13;
  html_nodes(".product-list li .price") %&gt;% &#13;
  html_text() &#13;
## [1] "$199.95" "$129.95" "$99.95" &#13;
</pre><p>In the preceding code, <code class="literal">html_nodes()</code> returns a collection of HTML nodes while <code class="literal">html_text()</code> is smart enough to extract the inner text from each HTML node and returns a character vector.</p><p>Note that these prices are still in their raw format represented by a string rather than number. The following code extracts the same data and transforms it into a more useful form:</p><pre class="programlisting">product_items &lt;- products_page %&gt;% &#13;
  html_nodes(".product-list li") &#13;
products &lt;- data.frame( &#13;
  name = product_items %&gt;% &#13;
    html_nodes(".name") %&gt;% &#13;
    html_text(), &#13;
  price = product_items %&gt;% &#13;
    html_nodes(".price") %&gt;% &#13;
    html_text() %&gt;% &#13;
    gsub("$", "", ., fixed = TRUE) %&gt;% &#13;
    as.numeric(), &#13;
  stringsAsFactors = FALSE &#13;
) &#13;
products &#13;
##        name  price &#13;
## 1 Product-A 199.95 &#13;
## 2 Product-B 129.95 &#13;
## 3 Product-C  99.95 &#13;
</pre><p>Note that the intermediate results of selected nodes can be stored as a variable and used repeatedly. Then the subsequent <code class="literal">html_nodes()</code> and <code class="literal">html_node()</code> calls only match the inner nodes.</p><p>Since product prices should be numeric values, we use <code class="literal">gsub()</code> to remove <code class="literal">$</code> from the raw prices and convert the results to a numeric vector. The call of <code class="literal">gsub()</code> in the pipeline is somehow special because the previous result (represented by <code class="literal">.</code>) should be put to the third argument instead of the first one.</p><p>In this case, <code class="literal">.product-list li .name</code> can be reduced to <code class="literal">.name</code> and the same also applies to <code class="literal">.product-list li .price</code>. In practice, however, a CSS class may be used extensively and such a general selector may match too many elements that are not desired. Therefore, it is better to use a more descriptive and sufficiently strict selector to match the interested nodes.</p></div>
<div class="section" title="Learning XPath selectors"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec73"/>Learning XPath selectors</h1></div></div></div><p>In the previous section, we learned about CSS selectors and how to use them as well as functions provided by the <code class="literal">rvest</code> package to extract contents from web pages.</p><p>CSS selectors are powerful enough to serve most needs of HTML node matching. However, sometimes an even more powerful technique is required to select nodes that meet more special conditions.</p><p>Take a look at the following web page a bit more complex than <code class="literal">data/products.html</code>:</p><div class="mediaobject"><img src="graphics/image_14_005.jpg" alt="Learning XPath selectors"/></div><p>This web page is stored as a standalone HTML file at <code class="literal">data/new-products.html</code>. The full source code is long we will only show the <code class="literal">&lt;body&gt;</code>. here. Please go through the source code to get an impression of its structure:</p><pre class="programlisting">&lt;body&gt; &#13;
  &lt;h1&gt;New Products&lt;/h1&gt; &#13;
  &lt;p&gt;The following is a list of products&lt;/p&gt; &#13;
  &lt;div id="list" class="product-list"&gt; &#13;
    &lt;ul&gt; &#13;
      &lt;li&gt; &#13;
        &lt;span class="name"&gt;Product-A&lt;/span&gt; &#13;
        &lt;span class="price"&gt;$199.95&lt;/span&gt; &#13;
        &lt;div class="info bordered"&gt; &#13;
          &lt;p&gt;Description for Product-A&lt;/p&gt; &#13;
          &lt;ul&gt; &#13;
            &lt;li&gt;&lt;span class="info-key"&gt;Quality&lt;/span&gt; &lt;span class="info-value"&gt;Good&lt;/span&gt;&lt;/li&gt; &#13;
            &lt;li&gt;&lt;span class="info-key"&gt;Duration&lt;/span&gt; &lt;span class="info-value"&gt;5&lt;/span&gt;&lt;span class="unit"&gt;years&lt;/span&gt;&lt;/li&gt; &#13;
          &lt;/ul&gt; &#13;
        &lt;/div&gt; &#13;
      &lt;/li&gt; &#13;
      &lt;li class="selected"&gt; &#13;
        &lt;span class="name"&gt;Product-B&lt;/span&gt; &#13;
        &lt;span class="price"&gt;$129.95&lt;/span&gt; &#13;
        &lt;div class="info"&gt; &#13;
          &lt;p&gt;Description for Product-B&lt;/p&gt; &#13;
          &lt;ul&gt; &#13;
            &lt;li&gt;&lt;span class="info-key"&gt;Quality&lt;/span&gt; &lt;span class="info-value"&gt;Medium&lt;/span&gt;&lt;/li&gt; &#13;
            &lt;li&gt;&lt;span class="info-key"&gt;Duration&lt;/span&gt; &lt;span class="info-value"&gt;2&lt;/span&gt;&lt;span class="unit"&gt;years&lt;/span&gt;&lt;/li&gt; &#13;
          &lt;/ul&gt; &#13;
        &lt;/div&gt; &#13;
      &lt;/li&gt; &#13;
      &lt;li&gt; &#13;
        &lt;span class="name"&gt;Product-C&lt;/span&gt; &#13;
        &lt;span class="price"&gt;$99.95&lt;/span&gt; &#13;
        &lt;div class="info"&gt; &#13;
          &lt;p&gt;Description for Product-C&lt;/p&gt; &#13;
          &lt;ul&gt; &#13;
            &lt;li&gt;&lt;span class="info-key"&gt;Quality&lt;/span&gt; &lt;span class="info-value"&gt;Good&lt;/span&gt;&lt;/li&gt; &#13;
            &lt;li&gt;&lt;span class="info-key"&gt;Duration&lt;/span&gt; &lt;span class="info-value"&gt;4&lt;/span&gt;&lt;span class="unit"&gt;years&lt;/span&gt;&lt;/li&gt; &#13;
          &lt;/ul&gt; &#13;
        &lt;/div&gt; &#13;
      &lt;/li&gt; &#13;
    &lt;/ul&gt; &#13;
  &lt;/div&gt; &#13;
  &lt;p&gt;All products are available for sale!&lt;/p&gt; &#13;
&lt;/body&gt; &#13;
</pre><p>The source code of the web page contains a stylesheet and a product list of detailed information. Each product has a description and more properties to show. In the following code, we load the web page as we did in the previous examples:</p><pre class="programlisting">page &lt;- read_html("data/new-products.html") &#13;
</pre><p>The structure of the HTML code is simple and clear. Before digging into XPath, we need to know a little about XML. Well-written and well-organized HTML documents can be basically regarded as a specialization of <span class="strong"><strong>XML</strong></span> (<span class="strong"><strong>eXtensive Markup Language</strong></span>) documents. Different from HTML, XML allows arbitrary tags and attributes. The following is a simple XML document:</p><pre class="programlisting">&lt;?xml version="1.0"?&gt; &#13;
&lt;root&gt; &#13;
  &lt;product id="1"&gt; &#13;
    &lt;name&gt;Product-A&lt;name&gt; &#13;
    &lt;price&gt;$199.95&lt;/price&gt; &#13;
  &lt;/product&gt; &#13;
  &lt;product id="2"&gt; &#13;
    &lt;name&gt;Product-B&lt;/name&gt; &#13;
    &lt;price&gt;$129.95&lt;/price&gt; &#13;
  &lt;/product&gt; &#13;
&lt;/root&gt; &#13;
</pre><p>XPath is a technique designed for extracting data from XML documents. In this section, we compare XPath expressions with CSS selectors and see how they can be useful to extract data from web pages.</p><p>The <code class="literal">html_node()</code> and <code class="literal">html_nodes()</code> support XPath expressions via the <code class="literal">xpath=</code> argument. The following table shows some important comparisons between CSS selectors and equivalent XPath expressions:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>CSS</strong></span></p>
</td><td>
<p><span class="strong"><strong>XPath</strong></span></p>
</td><td>
<p><span class="strong"><strong>Match</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">li &gt; *</code></p>
</td><td>
<p><code class="literal">//li/*</code></p>
</td><td>
<p>All children of <code class="literal">&lt;li&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">li[attr]</code></p>
</td><td>
<p><code class="literal">//li[@attr]</code></p>
</td><td>
<p>All <code class="literal">&lt;li&gt;</code> with <code class="literal">attr</code> attribute</p>
</td></tr><tr><td>
<p><code class="literal">li[attr=value]</code></p>
</td><td>
<p><code class="literal">//li[@attr='value']</code></p>
</td><td>
<p><code class="literal">&lt;li attr="value"&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">li#item</code></p>
</td><td>
<p><code class="literal">//li[@id='item']</code></p>
</td><td>
<p><code class="literal">&lt;li id="item"&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">li.info</code></p>
</td><td>
<p><code class="literal">//li[contains(@class,'info')]</code></p>
</td><td>
<p><code class="literal">&lt;li class="info"&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">li:first-child</code></p>
</td><td>
<p><code class="literal">//li[1]</code></p>
</td><td>
<p>First <code class="literal">&lt;li&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">li:last-child</code></p>
</td><td>
<p><code class="literal">//li[last()]</code></p>
</td><td>
<p>Last <code class="literal">&lt;li&gt;</code></p>
</td></tr><tr><td>
<p><code class="literal">li:nth-child(n)</code></p>
</td><td>
<p><code class="literal">//li[n]</code></p>
</td><td>
<p><code class="literal">n</code>
<sup>th</sup><code class="literal">&lt;li&gt;</code></p>
</td></tr><tr><td>
<p>(N/A)</p>
</td><td>
<p><code class="literal">//p[a]</code></p>
</td><td>
<p>All <code class="literal">&lt;p&gt;</code> with a child <code class="literal">&lt;a&gt;</code></p>
</td></tr><tr><td>
<p>(N/A)</p>
</td><td>
<p><code class="literal">//p[position() &lt;= 5]</code></p>
</td><td>
<p>The first five <code class="literal">&lt;p&gt;</code> nodes</p>
</td></tr><tr><td>
<p>(N/A)</p>
</td><td>
<p><code class="literal">//p[last()-2]</code></p>
</td><td>
<p>The last third last <code class="literal">&lt;p&gt;</code></p>
</td></tr><tr><td>
<p>(N/A)</p>
</td><td>
<p><code class="literal">//li[value&gt;0.5]</code></p>
</td><td>
<p>All <code class="literal">&lt;li&gt;</code> with child <code class="literal">&lt;value&gt;</code> whose value <code class="literal">&gt; 0.5</code></p>
</td></tr></tbody></table></div><p>Note that CSS selectors usually match nodes at all sub-levels. In XPath, <code class="literal">//</code> tag and <code class="literal">/</code> tag are defined to match nodes differently. More specifically, <code class="literal">//</code> tag refers to <code class="literal">&lt;tag&gt;</code> nodes at all sub-levels while <code class="literal">/</code> tag only refers to <code class="literal">&lt;tag&gt;</code> nodes at the first sub-level.</p><p>To demonstrate the usage, the following are some examples:</p><p>Select all <code class="literal">&lt;p&gt;</code> nodes:</p><pre class="programlisting">page %&gt;% html_nodes(xpath = "//p") &#13;
## {xml_nodeset (5)} &#13;
## [1] &lt;p&gt;The following is a list of products&lt;/p&gt; &#13;
## [2] &lt;p&gt;Description for Product-A&lt;/p&gt; &#13;
## [3] &lt;p&gt;Description for Product-B&lt;/p&gt; &#13;
## [4] &lt;p&gt;Description for Product-C&lt;/p&gt; &#13;
## [5] &lt;p&gt;All products are available for sale!&lt;/p&gt; &#13;
</pre><p>Select all <code class="literal">&lt;li&gt;</code> with the <code class="literal">class</code> attribute:</p><pre class="programlisting">page %&gt;% html_nodes(xpath = "//li[@class]") &#13;
## {xml_nodeset (1)} &#13;
## [1] &lt;li class="selected"&gt;\n        &lt;span class="name"&gt;Pro ... &#13;
</pre><p>Select all <code class="literal">&lt;li&gt;</code> as children of <code class="literal">&lt;div id="list"&gt;&lt;ul&gt;</code>:</p><pre class="programlisting">page %&gt;% html_nodes(xpath = "//div[@id='list']/ul/li") &#13;
## {xml_nodeset (3)} &#13;
## [1] &lt;li&gt;\n        &lt;span class="name"&gt;Product-A&lt;/span&gt;\n   ... &#13;
## [2] &lt;li class="selected"&gt;\n        &lt;span class="name"&gt;Pro ... &#13;
## [3] &lt;li&gt;\n        &lt;span class="name"&gt;Product-C&lt;/span&gt;\n   ... &#13;
</pre><p>Select all <code class="literal">&lt;span class="name"&gt;</code> as children of <code class="literal">&lt;li&gt;</code> inside <code class="literal">&lt;div id="list"&gt;</code>:</p><pre class="programlisting">page %&gt;% html_nodes(xpath = "//div[@id='list']//li/span[@class='name']") &#13;
## {xml_nodeset (3)} &#13;
## [1] &lt;span class="name"&gt;Product-A&lt;/span&gt; &#13;
## [2] &lt;span class="name"&gt;Product-B&lt;/span&gt; &#13;
## [3] &lt;span class="name"&gt;Product-C&lt;/span&gt; &#13;
</pre><p>Select all <code class="literal">&lt;span class="name"&gt;</code> as children in <code class="literal">&lt;li class="selected"&gt;</code>:</p><pre class="programlisting">page %&gt;% &#13;
  html_nodes(xpath = "//li[@class='selected']/span[@class='name']") &#13;
## {xml_nodeset (1)} &#13;
## [1] &lt;span class="name"&gt;Product-B&lt;/span&gt; &#13;
</pre><p>All the preceding examples can be achieved with equivalent CSS selectors. The following examples, however, are not possible with CSS selectors.</p><p>Select all <code class="literal">&lt;div&gt;</code> with a child <code class="literal">&lt;p&gt;</code>:</p><pre class="programlisting">page %&gt;% html_nodes(xpath = "//div[p]") &#13;
## {xml_nodeset (3)} &#13;
## [1] &lt;div class="info bordered"&gt;\n          &lt;p&gt;Description ... &#13;
## [2] &lt;div class="info"&gt;\n          &lt;p&gt;Description for Prod ... &#13;
## [3] &lt;div class="info"&gt;\n          &lt;p&gt;Description for Prod ... &#13;
</pre><p>Select all <code class="literal">&lt;span class="info-value"&gt;Good&lt;/span&gt;</code>:</p><pre class="programlisting">page %&gt;%  &#13;
  html_nodes(xpath = "//span[@class='info-value' and text()='Good']") &#13;
## {xml_nodeset (2)} &#13;
## [1] &lt;span class="info-value"&gt;Good&lt;/span&gt; &#13;
## [2] &lt;span class="info-value"&gt;Good&lt;/span&gt; &#13;
</pre><p>Select all product names with good quality:</p><pre class="programlisting">page %&gt;% &#13;
  html_nodes(xpath = "//li[div/ul/li[1]/span[@class='info-value' and text()='Good']]/span[@class='name']") &#13;
## {xml_nodeset (2)} &#13;
## [1] &lt;span class="name"&gt;Product-A&lt;/span&gt; &#13;
## [2] &lt;span class="name"&gt;Product-C&lt;/span&gt; &#13;
</pre><p>Select all product names with a duration greater than three years:</p><pre class="programlisting">page %&gt;% &#13;
  html_nodes(xpath = "//li[div/ul/li[2]/span[@class='info-value' and text()&gt;3]]/span[@class='name']") &#13;
## {xml_nodeset (2)} &#13;
## [1] &lt;span class="name"&gt;Product-A&lt;/span&gt; &#13;
## [2] &lt;span class="name"&gt;Product-C&lt;/span&gt; &#13;
</pre><p>XPath is very flexible and can be a powerful tool to match nodes in web pages. To learn more, visit <a class="ulink" href="http://www.w3schools.com/xsl/xpath_syntax.aspac">http://www.w3schools.com/xsl/xpath_syntax.aspac</a>.</p></div>
<div class="section" title="Analysing HTML code and extracting data"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec74"/>Analysing HTML code and extracting data</h1></div></div></div><p>In the previous sections, we learned the basics of HTML, CSS, and XPath. To scrape real-world web pages, the problem now becomesa question of writing the proper CSS or XPath selectors. In this section, we introduce some simple ways to figure out working selectors.</p><p>Suppose we want to scrape all available R packages at <a class="ulink" href="https://cran.rstudio.com/web/packages/available_packages_by_name.html">https://cran.rstudio.com/web/packages/available_packages_by_name.html</a>. The web page looks simple. To figure out the selector expression, right-click on the table and select <span class="strong"><strong>Inspect Element</strong></span> in the context menu, which should be available in most modern web browsers:</p><div class="mediaobject"><img src="graphics/image_14_006.jpg" alt="Analysing HTML code and extracting data"/></div><p>Then the inspector panel shows up and we can see the underlying HTML of the web page. In Firefox and Chrome, the selected node is highlighted so it can be located more easily:</p><div class="mediaobject"><img src="graphics/image_14_007.jpg" alt="Analysing HTML code and extracting data"/></div><p>The HTML contains a unique <code class="literal">&lt;table&gt;</code> so we can directly use <code class="literal">table</code> to select it and use <code class="literal">html_table()</code> to extract it out as a data frame:</p><pre class="programlisting">page &lt;- read_html("https://cran.rstudio.com/web/packages/available_packages_by_name.html") &#13;
pkg_table &lt;- page %&gt;% &#13;
  html_node("table") %&gt;%  &#13;
  html_table(fill = TRUE) &#13;
head(pkg_table, 5) &#13;
##            X1 &#13;
## 1             &#13;
## 2          A3 &#13;
## 3      abbyyR &#13;
## 4         abc &#13;
## 5 ABCanalysis &#13;
##                                                                         X2 &#13;
## 1                                                                     &lt;NA&gt; &#13;
## 2 Accurate, Adaptable, and Accessible Error Metrics for Predictive\nModels &#13;
## 3                  Access to Abbyy Optical Character Recognition (OCR) API &#13;
## 4                         Tools for Approximate Bayesian Computation (ABC) &#13;
## 5                                                    Computed ABC Analysis &#13;
</pre><p>Note that the original table has no headers. The resulted data frame uses default headers instead and the first row is empty. The following code is written to fix these problems:</p><pre class="programlisting">pkg_table &lt;- pkg_table[complete.cases(pkg_table), ] &#13;
colnames(pkg_table) &lt;- c("name", "title") &#13;
head(pkg_table, 3) &#13;
##     name &#13;
## 2     A3 &#13;
## 3 abbyyR &#13;
## 4    abc &#13;
##                                                                      title &#13;
## 2 Accurate, Adaptable, and Accessible Error Metrics for Predictive\nModels &#13;
## 3                  Access to Abbyy Optical Character Recognition (OCR) API &#13;
## 4                         Tools for Approximate Bayesian Computation (ABC) &#13;
</pre><p>The next example is to extract the latest stock price of MSFT at <a class="ulink" href="http://finance.yahoo.com/quote/MSFT">http://finance.yahoo.com/quote/MSFT</a>. Using the element inspector, we find that the price is contained by a <code class="literal">&lt;span&gt;</code> with very long classes that are generated by the program:</p><div class="mediaobject"><img src="graphics/image_14_008.jpg" alt="Analysing HTML code and extracting data"/></div><p>Looking several levels up, we can find a path, <code class="literal">div#quote-header-info &gt; section &gt; span</code>, to navigate to this very node. Therefore, we can use this CSS selector to find and extract the stock price:</p><pre class="programlisting">page &lt;- read_html("https://finance.yahoo.com/quote/MSFT") &#13;
page %&gt;% &#13;
  html_node("div#quote-header-info &gt; section &gt; span") %&gt;% &#13;
  html_text() %&gt;% &#13;
  as.numeric() &#13;
## [1] 56.68 &#13;
</pre><p>On the right side of the web page, there is a table of corporate key statistics:</p><div class="mediaobject"><img src="graphics/image_14_009.jpg" alt="Analysing HTML code and extracting data"/></div><p>Before extracting it out, we again inspect the table and its enclosing nodes, and try to find a selector that navigates to this table:</p><div class="mediaobject"><img src="graphics/image_14_010.jpg" alt="Analysing HTML code and extracting data"/></div><p>It is obvious that the <code class="literal">&lt;table&gt;</code> of interest is enclosed by a <code class="literal">&lt;div id="key-statistics"</code>. Thus we can directly use <code class="literal">#key-statistics table</code> to match the table node and turn it into a data frame:</p><pre class="programlisting">page %&gt;% &#13;
  html_node("#key-statistics table") %&gt;% &#13;
  html_table() &#13;
##                 X1           X2 &#13;
## 1       Market Cap      442.56B &#13;
## 2  P/E Ratio (ttm)        26.99 &#13;
## 3      Diluted EPS          N/A &#13;
## 4             Beta         1.05 &#13;
## 5    Earnings Date          N/A &#13;
## 6 Dividend &amp; Yield 1.44 (2.56%) &#13;
## 7 Ex-Dividend Date          N/A &#13;
## 8    1y Target Est          N/A &#13;
</pre><p>With similar techniques, we can create a function that returns the company name and price given a stock ticker symbol (for example, <code class="literal">MSFT</code>):</p><pre class="programlisting">get_price &lt;- function(symbol) { &#13;
  page &lt;- read_html(sprintf("https://finance.yahoo.com/quote/%s", symbol)) &#13;
  list(symbol = symbol, &#13;
    company = page %&gt;%  &#13;
      html_node("div#quote-header-info &gt; div:nth-child(1) &gt; h6") %&gt;% &#13;
      html_text(), &#13;
    price = page %&gt;%  &#13;
      html_node("div#quote-header-info &gt; section &gt; span:nth-child(1)") %&gt;% &#13;
      html_text() %&gt;% &#13;
      as.numeric()) &#13;
} &#13;
</pre><p>The CSS selectors are restrictive enough to navigate to the right HTML nodes. To test this function, we run the following code:</p><pre class="programlisting">get_price("AAPL") &#13;
## $symbol &#13;
## [1] "AAPL" &#13;
##  &#13;
## $company &#13;
## [1] "Apple Inc." &#13;
##  &#13;
## $price &#13;
## [1] 104.19 &#13;
</pre><p>Another example is scraping top R questions at <a class="ulink" href="http://stackoverflow.com/questions/tagged/r?sort=votes">http://stackoverflow.com/questions/tagged/r?sort=votes</a>, shown as follows:</p><div class="mediaobject"><img src="graphics/image_14_011.jpg" alt="Analysing HTML code and extracting data"/></div><p>With a similar method, it is easy to find out that the question list is contained by a container whose <code class="literal">id</code> is <code class="literal">questions</code>. Therefore, we can load the page and select and store the question container with <code class="literal">#questions</code>:</p><pre class="programlisting">page &lt;- read_html("https://stackoverflow.com/questions/tagged/r?sort=votes&amp;pageSize=5") &#13;
questions &lt;- page %&gt;%  &#13;
  html_node("#questions") &#13;
</pre><p>To extract the question titles, we take a closer look at the HTML structure behind the first question:</p><div class="mediaobject"><img src="graphics/image_14_012.jpg" alt="Analysing HTML code and extracting data"/></div><p>It is easy to find out that each question title is contained in <code class="literal">&lt;div class="summary"&gt;&lt;h3&gt;</code>:</p><pre class="programlisting">questions %&gt;% &#13;
  html_nodes(".summary h3") %&gt;% &#13;
  html_text() &#13;
## [1] "How to make a great R reproducible example?"                                        &#13;
## [2] "How to sort a dataframe by column(s)?"                                              &#13;
## [3] "R Grouping functions: sapply vs. lapply vs. apply. vs. tapply vs. by vs. aggregate" &#13;
## [4] "How to join (merge) data frames (inner, outer, left, right)?"                       &#13;
## [5] "How can we make xkcd style graphs?" &#13;
</pre><p>Note that <code class="literal">&lt;a class="question-hyperlink"&gt;</code> also provides an even easier CSS selector that returns the same results:</p><pre class="programlisting">questions %&gt;% &#13;
  html_nodes(".question-hyperlink") %&gt;% &#13;
  html_text() &#13;
</pre><p>If we are also interested in the votes of each question, we can again inspect the votes and see how they can be described with a CSS selector:</p><div class="mediaobject"><img src="graphics/image_14_013.jpg" alt="Analysing HTML code and extracting data"/></div><p>Fortunately, all vote panels share the same structure and it is quite straightforward to find out their pattern. Each question is contained in a <code class="literal">&lt;div&gt;</code> with the <code class="literal">question-summary</code> class in which the vote is in a <code class="literal">&lt;span&gt;</code> with the <code class="literal">.vote-count-post</code> class:</p><pre class="programlisting">questions %&gt;% &#13;
  html_nodes(".question-summary .vote-count-post") %&gt;% &#13;
  html_text() %&gt;% &#13;
  as.integer() &#13;
## [1] 1429  746  622  533  471 &#13;
</pre><p>Similarly, the following code extracts the number of answers:</p><pre class="programlisting">questions %&gt;% &#13;
  html_nodes(".question-summary .status strong") %&gt;% &#13;
  html_text() %&gt;% &#13;
  as.integer() &#13;
## [1] 21 15  8 11  7 &#13;
</pre><p>If we go ahead with extracting the tags of each question, it becomes a bit tricky because different questions may have different numbers of tags. In the following code, we first select the tag containers of all questions and extract the tags in each container by iteration.</p><pre class="programlisting">questions %&gt;% &#13;
  html_nodes(".question-summary .tags") %&gt;% &#13;
  lapply(function(node) { &#13;
    node %&gt;% &#13;
      html_nodes(".post-tag") %&gt;% &#13;
      html_text() &#13;
  }) %&gt;% &#13;
  str &#13;
## List of 5 &#13;
##  $ : chr [1:2] "r" "r-faq" &#13;
##  $ : chr [1:4] "r" "sorting" "dataframe" "r-faq" &#13;
##  $ : chr [1:4] "r" "sapply" "tapply" "r-faq" &#13;
##  $ : chr [1:5] "r" "join" "merge" "dataframe" ... &#13;
##  $ : chr [1:2] "r" "ggplot2" &#13;
</pre><p>All the preceding scraping happens in one web page. What if we need to collect data across multiple web pages? Suppose we visit the page of each question (for example, <a class="ulink" href="http://stackoverflow.com/q/5963269/2906900">http://stackoverflow.com/q/5963269/2906900</a>). Notice that there is an info box on the up-right. We need to extract such info boxes of each question in list:</p><div class="mediaobject"><img src="graphics/image_14_014.jpg" alt="Analysing HTML code and extracting data"/></div><p>Inspecting tells us <code class="literal">#qinfo </code>is the key of the info box on each question page. Then we can select all question hyperlinks, extract the URLs of all questions, iterate over them, read each question page, and extract the info box using that key:</p><pre class="programlisting">questions %&gt;% &#13;
  html_nodes(".question-hyperlink") %&gt;% &#13;
  html_attr("href") %&gt;% &#13;
  lapply(function(link) { &#13;
    paste0("https://stackoverflow.com", link) %&gt;% &#13;
      read_html() %&gt;% &#13;
      html_node("#qinfo") %&gt;% &#13;
      html_table() %&gt;% &#13;
      setNames(c("item", "value")) &#13;
  }) &#13;
## [[1]] &#13;
##     item        value &#13;
## 1  asked  5 years ago &#13;
## 2 viewed 113698 times &#13;
## 3 active   7 days ago &#13;
##  &#13;
## [[2]] &#13;
##     item        value &#13;
## 1  asked  6 years ago &#13;
## 2 viewed 640899 times &#13;
## 3 active 2 months ago &#13;
##  &#13;
## [[3]] &#13;
##     item        value &#13;
## 1  asked  5 years ago &#13;
## 2 viewed 221964 times &#13;
## 3 active  1 month ago &#13;
##  &#13;
## [[4]] &#13;
##     item        value &#13;
## 1  asked  6 years ago &#13;
## 2 viewed 311376 times &#13;
## 3 active  15 days ago &#13;
##  &#13;
## [[5]] &#13;
##     item        value &#13;
## 1  asked  3 years ago &#13;
## 2 viewed  53232 times &#13;
## 3 active 4 months ago &#13;
</pre><p>Besides all these, <code class="literal">rvest</code> also supports creating an HTTP session to simulate page navigation. To learn more, read the <code class="literal">rvest</code> documentation. For many scraping tasks, you can also simplify the finding of selectors by using the tools provided by <a class="ulink" href="http://selectorgadget.com/">http://selectorgadget.com/</a>.</p><p>There are more advanced techniques of web scraping such as dealing with AJAX and dynamic web pages using JavaScript, but they are beyond the scope of this chapter. For more usage, read the documentation for the <code class="literal">rvest</code> package.</p><p>Note that <code class="literal">rvest</code> is largely inspired by Python packages Robobrowser and BeautifulSoup. These packages are more powerful and thus popular in web scraping in some aspects than <code class="literal">rvest</code>. If the source is complex and large in scale, you might do well to learn to use these Python packages. Go to <a class="ulink" href="https://www.crummy.com/software/BeautifulSoup/">https://www.crummy.com/software/BeautifulSoup/</a> for more information.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec75"/>Summary</h1></div></div></div><p>In this chapter, we learned how web pages are written in HTML and stylized by CSS. CSS selectors can be used to match HTML nodes so that their contents can be extracted. Well-written HTML documents can also be queried by XPath Expression, which has more features and is more flexible. Then we learned how to use the element inspector in modern web browsers to figure out a restrictive selector to match the HTML nodes of interest so that the needed data can be extracted from web pages.</p><p>In this next chapter, we will learn a series of techniques that boost your productivity, from R Markdown documents, diagrams, to interactive shiny apps. These tools make it much easier to create quality, reproducible, and interactive documents, which are very nice ways to present data, ideas, and prototypes.</p></div></body></html>