["```py\n(defproject clj-gis \"0.1.0-SNAPSHOT\"\n  :dependencies [[org.clojure/clojure \"1.5.1\"]\n                 [me.raynes/fs \"1.4.4\"]\n                 [com.velisco/clj-ftp \"0.3.0\"]\n                 [org.clojure/data.csv \"0.1.2\"]\n                 [clj-time \"0.5.1\"]\n                 [incanter/incanter-charts \"1.5.1\"]]\n  :jvm-opts [\"-Xmx4096m\"])\n```", "```py\n(ns clj-gis.download\n  (:require [clojure.java.io :as io]\n            [me.raynes.fs.compression :as compression]\n            [me.raynes.fs :as fs]\n            [miner.ftp :as ftp]\n            [clj-gis.locations :as loc]\n            [clj-gis.util :as u])\n  (:import [org.apache.commons.net.ftp FTP]\n           [java.util.zip GZIPInputStream]\n           [java.io BufferedInputStream]))\n```", "```py\n(defn download-file\n  \"Download a single file from FTP into a download directory.\"\n  [client download-dir dirname]\n  (let [src (download-src dirname)\n        dest (download-dest download-dir dirname)]\n    (ftp/client-get client src dest)))\n\n(defn download-data\n  \"Connect to an FTP server and download the GSOD data files.\"\n  [uri download-dir data-dir]\n  (let [download-dir (io/file download-dir)\n        data-dir (io/file data-dir)]\n    (ensure-dir download-dir)\n    (ensure-dir data-dir)\n    (ftp/with-ftp [client uri]\n      (.setFileType client FTP/BINARY_FILE_TYPE)\n      (doseq [dirname\n              (filter get-year\n                      (ftp/client-directory-names client))]\n        (download-file client download-dir dirname)))))\n```", "```py\n(defn untar\n  \"Untar the file into the destination directory.\"\n  [input-file dest-dir]\n  (compression/untar input-file dest-dir))\n\n(defn gunzip\n  \"Gunzip the input file and delete the original.\"\n  [input-file]\n  (let [input-file (fs/file input-file)\n        parts (fs/split input-file)\n        dest (fs/file (reduce fs/file (butlast parts))\n                      (first (fs/split-ext (last parts))))]\n    (with-open [f-in (BufferedInputStream.\n                       (GZIPInputStream.\n                         (io/input-stream input-file)))]\n      (with-open [f-out (io/output-stream dest)]\n        (io/copy f-in f-out)))))\n```", "```py\n(defn download-all []\n  (let [tar-dir (fs/file loc/*download-dir*)\n        data-dir (fs/file loc/*data-dir*)]\n    (download-data tar-dir data-dir)\n    (doseq [tar-file (fs/list-dir tar-dir)]\n      (untar (fs/file tar-dir tar-file) data-dir))\n    (doseq [gz-file (fs/list-dir data-dir)]\n      (gunzip (fs/file data-dir gz-file)))))\n```", "```py\nSTN--- WBAN   YEARMODA    TEMP       DEWP      SLP        STP       VISIB      WDSP     MXSPD   GUST    MAX     MIN   PRCP   SNDP   FRSHTT\n```", "```py\n007032 99999  20130126    80.1 12    65.5 12  9999.9  0  9999.9  0  999.9  0    2.5 12    6.0  999.9    91.4*   71.6*  0.00I 999.9  000000\n```", "```py\n(ns clj-gis.filter-data\n  (:require\n    [clojure.string :as str]\n    [clojure.data.csv :as csv]\n    [clojure.java.io :as io]\n    [me.raynes.fs :as fs]\n    [clj-gis.locations :as loc]\n    [clj-gis.util :refer (ensure-dir)]))\n```", "```py\n(defrecord IshHistory\n  [usaf wban station_name country fips state call\n   lat lon elevation begin end])\n(defn read-history\n  \"Read the station history file.\"\n  [filename]\n  (with-open [f (io/reader filename)]\n    (doall\n      (->> (csv/read-csv f)\n        (drop 1)\n        (map #(apply ->IshHistory %))))))\n```", "```py\n(defn get-station-set\n  \"Create a set of all stations in a country.\"\n  [country histories]\n  (set (map #(vector (:usaf %) (:wban %))\n            (filter #(= (:country %) country)\n                    histories))))\n```", "```py\n(defn filter-data-files\n  \"Read the history file and copy data files matching the\n  country code into a new directory.\"\n  [ish-history-file data-dir country-code]\n  (let [history (read-history ish-history-file)\n        stations (get-station-set country-code history)]\n    (ensure-dir (fs/file country-code))\n    (doseq [filename (fs/glob (str data-dir \"*.op\"))]\n      (let [base (fs/base-name filename)\n            station (vec (take 2 (str/split base #\"-\")))]\n        (when (contains? stations station)\n          (fs/copy filename (fs/file country-code base)))))))\n```", "```py\n(ns clj-gis.rolling-avg\n  (:require\n    [clojure.java.io :as io]\n    [clojure.string :as str]\n    [clojure.core.reducers :as r]\n    [clj-time.core :as clj-time]\n    [clj-time.format :refer (formatter parse)]\n    [clojure.data.csv :as csv]\n    [me.raynes.fs :as fs]\n    [clj-gis.filter-data :as fd]\n    [clj-gis.locations :as loc]\n    [clj-gis.types :refer :all]\n    [clj-gis.util :as u]))\n```", "```py\n(defrecord WeatherRow\n  [station wban date temp temp-count dewp dewp-count slp\n   slp-count stp stp-count visibility vis-count wdsp\n   wdsp-count max-wind-spd max-gust max-temp min-temp\n   precipitation snow-depth rfshtt])\n(defn read-weather\n  [filename]\n  (with-open [f (io/reader filename)]\n    (doall\n      (->> (line-seq f)\n        (r/drop 1)\n        (r/map #(str/split % #\"\\s+\"))\n        (r/map #(apply ->WeatherRow %))\n        (r/map normalize)\n        (r/remove nil?)\n        (into [])))))\n```", "```py\n    (defn only-month\n      \"1\\. Process only the observations for the month of July.\"\n      [month coll]\n      (r/filter #(= (clj-time/month (:date %)) month) coll))\n    ```", "```py\n    (defn mean [coll]\n      (/ (sum coll) (double (count coll))))\n    (defn get-monthly-avgs\n      \"2\\. Average the observations for each year's July, so\n      we'll have an average for July 2013, one for July 2012,\n      one for July 2011, and so on.\"\n      [weather-rows]\n      (->> weather-rows\n        (group-by #(clj-time/year (:date %)))\n        (r/map (fn [[year group]]\n                 [year (mean (map :max-temp group))]))))\n    ```", "```py\n    (defn get-windows\n      \"3\\. Group these monthly averages into a rolling ten-year\n      window. For example, one window will have the\n      observations for 1950–1960\\. Another window will have \n      observations for 1951–1961\\. And so on.\"\n      [period month-avgs]\n      (->>\n        month-avgs\n         (into [])\n         (sort-by first)\n         (partition period 1)\n         (r/filter #(> (count %) 1))\n         (r/map #(vector (ffirst %) (map second %))))))\n    ```", "```py\n    (defn average-window\n      \"4\\. Average each of these windows for a climatic average\n      temperature for July for that period.\"\n      [windows]\n      (r/map (fn [[start-year ws]] [start-year (mean ws)])\n             windows))\n    ```", "```py\n    (defn avg-diff\n      \"5\\. Calculate the change in maximum temperature by \n      subtracting the climatic average for the last window for \n      a station from the average of its first window.\"\n      [avgs]\n      (- (last avgs) (first avgs)))\n    ```", "```py\n(ns clj-gis.idw\n  (:require [clojure.core.reducers :as r]\n            [clj-gis.types :refer :all]))\n```", "```py\n(defn w\n  \"Finds the weighted inverse distance between the points x and\n  x_i. \"\n  ([p dist-fn x] (partial w p dist-fn x))\n  ([p dist-fn x x_i]\n   (/ 1.0 (Math/pow (dist-fn x x_i) p))))\n```", "```py\n(defn sum-over [f coll] (reduce + (map f coll)))\n(defn idw\n  ([sample-points data-key p dist-fn]\n   (partial idw sample-points data-key p dist-fn))\n  ([sample-points data-key p dist-fn point]\n (float\n (/ (sum-over #(* (w p dist-fn point %) (data-key %))\n sample-points)\n (sum-over (w p dist-fn point) sample-points))))\n  ([sample-points data-key p dist-fn lat lon]\n   (idw sample-points data-key p dist-fn\n        (->DataPoint lat lon nil))))\n```", "```py\n(defn generate-hm\n  [sample p border]\n  (let [{:keys [min-lat max-lat min-lon max-lon]}\n        (min-max-lat-lon sample)]\n    (->\n      (c/heat-map (idw sample :value p euclidean-dist)\n                  (- min-lon border) (+ max-lon border)\n                  (- min-lat border) (+ max-lat border))\n      (c/set-alpha 0.5)\n      (c/add-points (map :lon sample) (map :lat sample)))))\n```", "```py\n(i/view (hm/generate-hm sample 1.0 5.0))\n```"]