- en: Chapter 1. Hello, Data!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 嗨，数据！
- en: Most projects in R start with loading at least some data into the running R
    session. As R supports a variety of file formats and database backend, there are
    several ways to do so. In this chapter, we will not deal with basic data structures,
    which are already familiar to you, but will concentrate on the performance issue
    of loading larger datasets and dealing with special file formats.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，大多数项目都是从将至少一些数据加载到运行中的R会话开始的。由于R支持多种文件格式和数据库后端，因此有多种方法可以实现这一点。在本章中，我们不会处理您已经熟悉的基本数据结构，而是将重点放在加载大型数据集的性能问题和处理特殊文件格式上。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a quick overview on the standard tools and to refresh your knowledge on
    importing general data, please see *Chapter 7* of the official *An Introduction
    to R* manual of CRAN at [http://cran.r-project.org/doc/manuals/R-intro.html#Reading-data-from-files](http://cran.r-project.org/doc/manuals/R-intro.html#Reading-data-from-files)
    or Rob Kabacoff's Quick-R site, which offers keywords and cheat-sheets for most
    general tasks in R at [http://www.statmethods.net/input/importingdata.html](http://www.statmethods.net/input/importingdata.html).
    For further materials, please see the *References* section in the *Appendix*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速了解标准工具并刷新您对导入通用数据的知识，请参阅CRAN官方手册《R简介》的*第7章* [http://cran.r-project.org/doc/manuals/R-intro.html#Reading-data-from-files](http://cran.r-project.org/doc/manuals/R-intro.html#Reading-data-from-files)
    或Rob Kabacoff的Quick-R网站，该网站提供了R中大多数通用任务的关键字和速查表 [http://www.statmethods.net/input/importingdata.html](http://www.statmethods.net/input/importingdata.html)。有关进一步的材料，请参阅附录中的*参考文献*部分。
- en: Although R has its own (serialized) binary `RData` and `rds` file formats, which
    are extremely convenient to use for all R users as these also store R object meta-information
    in an efficient way, most of the time we have to deal with other input formats—provided
    by our employer or client.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然R有自己的（序列化的）二进制`RData`和`rds`文件格式，这对所有R用户来说都非常方便，因为这些格式也以高效的方式存储R对象元信息，但大多数时候我们不得不处理其他输入格式——这些格式由我们的雇主或客户提供。
- en: One of the most popular data file formats is flat files, which are simple text
    files in which the values are separated by white-space, the pipe character, commas,
    or more often by semi-colon in Europe. This chapter will discuss several options
    R has to offer to load these kinds of documents, and we will benchmark which of
    these is the most efficient approach to import larger files.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的数据文件格式之一是平面文件，这些文件是简单的文本文件，其中的值由空格、管道字符、逗号或更常见的是在欧洲的分号分隔。本章将讨论R提供的一些选项来加载这类文档，并将基准测试这些选项中哪个是导入大型文件最有效的方法。
- en: Sometimes we are only interested in a subset of a dataset; thus, there is no
    need to load all the data from the sources. In such cases, database backend can
    provide the best performance, where the data is stored in a structured way preloaded
    on our system, so we can query any subset of that with simple and efficient commands.
    The second section of this chapter will focus on the three most popular databases
    (MySQL, PostgreSQL, and Oracle Database), and how to interact with those in R.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们只对数据集的一个子集感兴趣；因此，没有必要从源中加载所有数据。在这种情况下，数据库后端可以提供最佳性能，其中数据以结构化的方式预先加载到我们的系统中，这样我们就可以使用简单高效的操作查询该数据的任何子集。本章的第二部分将重点介绍三种最流行的数据库（MySQL、PostgreSQL和Oracle数据库），以及如何在R中与这些数据库交互。
- en: Besides some other helper tools and a quick overview on other database backend,
    we will also discuss how to load Excel spreadsheets into R—without the need to
    previously convert those to text files in Excel or Open/LibreOffice.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他一些辅助工具和对其他数据库后端的快速概述外，我们还将讨论如何将Excel电子表格加载到R中——无需在Excel或Open/LibreOffice中将这些文件预先转换为文本文件。
- en: Of course this chapter is not just about data file formats, database connections,
    and such boring internals. But please bear in mind that data analytics always
    starts with loading data. This is unavoidable, so that our computer and statistical
    environment know the structure of the data before doing some real analytics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，本章不仅仅关于数据文件格式、数据库连接等枯燥的内部结构。但请记住，数据分析总是从加载数据开始的。这是不可避免的，这样我们的计算机和统计环境在执行一些真正的分析之前就能知道数据的结构。
- en: Loading text files of a reasonable size
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载合理大小的文本文件
- en: The title of this chapter might also be *Hello, Big Data!*, as now we concentrate
    on loading relatively large amount of data in an R session. But what is Big Data,
    and what amount of data is problematic to handle in R? What is reasonable size?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的标题也可能是**你好，大数据**！因为现在我们专注于在R会话中加载相对大量的数据。但什么是大数据，在R中处理多少数据是问题性的？什么是合理的大小？
- en: R was designed to process data that fits in the physical memory of a single
    computer. So handling datasets that are smaller than the actual accessible RAM
    should be fine. But please note that the memory required to process data might
    become larger while doing some computations, such as principal component analysis,
    which should be also taken into account. I will refer to this amount of data as
    reasonable sized datasets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: R被设计用来处理适合单个计算机物理内存的数据。因此，处理小于实际可用RAM的数据集应该没问题。但请注意，在执行某些计算时，如主成分分析，处理数据所需的内存可能会变得更大，这也应予以考虑。我将把这部分数据称为合理大小的数据集。
- en: 'Loading data from text files is pretty simple with R, and loading any reasonable
    sized dataset can be achieved by calling the good old `read.table` function. The
    only issue here might be the performance: how long does it take to read, for example,
    a quarter of a million rows of data? Let''s see:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用R从文本文件加载数据相当简单，通过调用古老的`read.table`函数，可以加载任何合理大小的数据集。这里可能唯一的问题是性能：读取例如25万行数据需要多长时间？让我们看看：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a reminder, please note that all R commands and the returned output are formatted
    as earlier in this book. The commands starts with `>` on the first line, and the
    remainder of multi-line expressions starts with `+`, just as in the R console.
    To copy and paste these commands on your machine, please download the code examples
    from the Packt homepage. For more details, please see the *What you need for this
    book* section in the *Preface*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，请注意，本书中所有R命令和返回的输出都格式化得与本书前面的格式相同。命令从第一行的`>`开始，多行表达式的其余部分从`+`开始，就像在R控制台中一样。要在您的机器上复制和粘贴这些命令，请从Packt主页下载代码示例。有关更多详细信息，请参阅**前言**中的**您需要为此书准备的内容**部分。
- en: 'Yes, we have just written an 18.5 MB text file to your disk from the `hflights`
    package, which includes some data on all flights departing from Houston in 2011:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们刚刚从`hflights`包中将一个18.5 MB的文本文件写入您的磁盘，其中包含有关2011年从休斯顿出发的所有航班的某些数据：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `hflights` package provides an easy way to load a subset of the huge Airline
    Dataset of the Research and Innovation Technology Administration at the Bureau
    of Transportation Statistics. The original database includes the scheduled and
    actual departure/arrival times of all US flights along with some other interesting
    information since 1987, and is often used to demonstrate machine learning and
    Big Data technologies. For more details on the dataset, please see the column
    description and other meta-data at [http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`hflights`包提供了一个简单的方法来加载美国交通统计局研究与创新技术管理局的庞大航空公司数据集的一个子集。原始数据库包括自1987年以来所有美国航班的预定和实际起飞/到达时间，以及一些其他有趣的信息，常用于演示机器学习和大数据技术。有关数据集的更多详细信息，请参阅列描述和其他元数据，见[http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0)。'
- en: 'We will use this 21-column data to benchmark data import times. For example,
    let''s see how long it takes to import the CSV file with `read.csv`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这21列数据来基准数据导入时间。例如，让我们看看使用`read.csv`导入CSV文件需要多长时间：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It took a bit more than one and a half seconds to load the data from an SSD
    here. It''s quite okay, but we can achieve far better results by identifying then
    specifying the classes of the columns instead of calling the default `type.convert`
    (see the docs in `read.table` for more details or search on StackOverflow, where
    the performance of `read.csv` seems to be a rather frequent and popular question):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里从SSD加载数据花费了超过一秒半的时间。这相当不错，但我们可以通过识别并指定列的类别来达到更好的效果，而不是调用默认的`type.convert`（有关更多详细信息，请参阅`read.table`中的文档或搜索StackOverflow，其中`read.csv`的性能似乎是一个相当常见且受欢迎的问题）：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It''s much better! But should we trust this one observation? On our way to
    mastering data analysis in R, we should implement some more reliable tests—by
    simply replicating the task *n* times and providing a summary on the results of
    the simulation. This approach provides us with performance data with multiple
    observations, which can be used to identify statistically significant differences
    in the results. The `microbenchmark` package provides a nice framework for such
    tasks:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多！但我们是否应该相信这个观察结果？在我们掌握R中的数据分析的过程中，我们应该实施一些更可靠的测试——通过简单地重复任务*n*次，并提供模拟结果的总览。这种方法为我们提供了具有多个观察结果的可视化数据，可以用来识别结果中的统计显著性差异。`microbenchmark`包提供了一个很好的框架来完成此类任务：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So we defined two functions: `f` stands for the default settings of `read.csv`
    while, in the `g` function, we passed the aforementioned column classes along
    with two other parameters for increased performance. The `comment.char` argument
    tells R not to look for comments in the imported data file, while the `nrows`
    parameter defined the exact number of rows to read from the file, which saves
    some time and space on memory allocation. Setting `stringsAsFactors` to `FALSE`
    might also speed up importing a bit.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了两个函数：`f`代表`read.csv`的默认设置，而在`g`函数中，我们传递了上述列类以及两个其他参数以提高性能。`comment.char`参数告诉R不要在导入的数据文件中查找注释，而`nrows`参数定义了从文件中读取的确切行数，这可以在内存分配上节省一些时间和空间。将`stringsAsFactors`设置为`FALSE`也可能略微加快导入速度。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Identifying the number of lines in the text file could be done with some third-party
    tools, such as `wc` on Unix, or a slightly slower alternative would be the `countLines`
    function from the `R.utils` package.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一些第三方工具识别文本文件中的行数，例如Unix中的`wc`，或者一个稍微慢一点的替代方法是`R.utils`包中的`countLines`函数。
- en: 'But back to the results. Let''s also visualize the median and related descriptive
    statistics of the test cases, which was run 100 times by default:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但回到结果。让我们也可视化测试用例的中位数和相关描述性统计，这些测试用例默认运行了100次：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Loading text files of a reasonable size](img/2028OS_01_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![合理大小的文本文件加载](img/2028OS_01_01.jpg)'
- en: The difference seems to be significant (please feel free to do some statistical
    tests to verify that), so we made a 50+ percent performance boost simply by fine-tuning
    the parameters of `read.table`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 差异似乎非常显著（请随意进行一些统计测试以验证这一点），所以我们仅仅通过微调`read.table`的参数就实现了50%以上的性能提升。
- en: Data files larger than the physical memory
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大于物理内存的数据文件
- en: 'Loading a larger amount of data into R from CSV files that would not fit in
    the memory could be done with custom packages created for such cases. For example,
    both the `sqldf` package and the `ff` package have their own solutions to load
    data from chunk to chunk in a custom data format. The first uses SQLite or another
    SQL-like database backend, while the latter creates a custom data frame with the
    `ffdf` class that can be stored on disk. The `bigmemory` package provides a similar
    approach. Usage examples (to be benchmarked) later:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将大量数据从CSV文件加载到R中，这些文件无法适应内存，可以通过为这种情况创建的定制包来完成。例如，`sqldf`包和`ff`包都有它们自己的解决方案，可以从块到块地以自定义数据格式加载数据。前者使用SQLite或其他类似SQL的数据库后端，而后者创建了一个带有`ffdf`类的自定义数据框，可以存储在磁盘上。`bigmemory`包提供了类似的方法。以下是一些使用示例（待基准测试）：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please note that the header defaults to `FALSE` with `read.big.matrix` from
    the `bigmemory` package, so be sure to read the manual of the referenced functions
    before doing your own benchmarks. Some of these functions also support performance
    tuning like `read.table`. For further examples and use cases, please see the *Large
    memory and out-of-memory data* section of the *High-Performance and Parallel Computing
    with R* CRAN Task View at [http://cran.r-project.org/web/views/HighPerformanceComputing.html](http://cran.r-project.org/web/views/HighPerformanceComputing.html).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`bigmemory`包的`read.big.matrix`时，默认情况下标题为`FALSE`，所以在进行自己的基准测试之前，务必阅读相关函数的说明书。其中一些函数也支持性能调整，就像`read.table`一样。有关更多示例和用例，请参阅CRAN任务视图中的*High-Performance
    and Parallel Computing with R*的*Large memory and out-of-memory data*部分，网址为[http://cran.r-project.org/web/views/HighPerformanceComputing.html](http://cran.r-project.org/web/views/HighPerformanceComputing.html)。
- en: Benchmarking text file parsers
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本文件解析器的基准测试
- en: Another notable alternative for handling and loading reasonable sized data from
    flat files to R is the `data.table` package. Although it has a unique syntax differing
    from the traditional S-based R markup, the package comes with great documentation,
    vignettes, and case studies on the indeed impressive speedup it can offer for
    various database actions. Such uses cases and examples will be discussed in the
    [Chapter 3](ch03.html "Chapter 3. Filtering and Summarizing Data"), *Filtering
    and Summarizing Data* and [Chapter 4](ch04.html "Chapter 4. Restructuring Data"),
    *Restructuring Data*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个处理和从平面文件加载合理大小数据的显著替代方案是`data.table`包。尽管它具有与传统基于S的R标记不同的独特语法，但该包提供了出色的文档、示例和案例研究，展示了它可以为各种数据库操作提供的真正令人印象深刻的加速。这些用例和示例将在[第3章](ch03.html
    "第3章。过滤和汇总数据")*过滤和汇总数据*和[第4章](ch04.html "第4章。重构数据")*重构数据*中讨论。
- en: 'The package ships a custom R function to read text files with improved performance:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该包提供了一种自定义R函数来读取具有改进性能的文本文件：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Loading the data was extremely quick compared to the preceding examples, although
    it resulted in an R object with a custom `data.table` class, which can be easily
    transformed to the traditional `data.frame` if needed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的示例相比，加载数据非常快，尽管它产生了一个具有自定义`data.table`类的R对象，如果需要，可以轻松转换为传统的`data.frame`：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or by using the `setDF` function, which provides a very fast and in-place method
    of object conversion without actually copying the data in the memory. Similarly,
    please note:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过使用`setDF`函数，它提供了一种非常快速且就地转换对象的方法，而不实际在内存中复制数据。同样，请注意：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This means that a `data.table` object can fall back to act as a `data.frame`
    for traditional usage. Leaving the imported data as is or transforming it to `data.frame`
    depends on the latter usage. Aggregating, merging, and restructuring data with
    the first is faster compared to the standard data frame format in R. On the other
    hand, the user has to learn the custom syntax of `data.table`—for example, `DT[i,
    j, by]` stands for "from DT subset by `i`, then do `j` grouped by by". We will
    discuss it later in the [Chapter 3](ch03.html "Chapter 3. Filtering and Summarizing
    Data"), *Filtering and Summarizing Data*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`data.table`对象可以回退以作为传统用途的`data.frame`。是否保留导入的数据不变或将其转换为`data.frame`取决于后续的使用。使用前者聚合、合并和重构数据比R的标准数据框格式更快。另一方面，用户必须学习`data.table`的定制语法——例如，`DT[i,
    j, by]`代表“从DT中按`i`子集，然后按`by`分组执行`j`”。我们将在[第3章](ch03.html "第3章。过滤和汇总数据")*过滤和汇总数据*中稍后讨论它。
- en: 'Now, let''s compare all the aforementioned data import methods: how fast are
    they? The final winner seems to be `fread` from `data.table` anyway. First, we
    define some methods to be benchmarked by declaring the test functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们比较所有上述数据导入方法：它们的速度如何？最终赢家似乎仍然是来自`data.table`的`fread`。首先，我们通过声明测试函数来定义要基准测试的方法：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s run all these functions 10 times each instead of several hundreds
    of iterations like previously—simply to save some time:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些函数各运行10次，而不是像之前那样运行数百次迭代——只是为了节省一些时间：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And print the results of the benchmark with a predefined number of digits:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 并以预定义的位数打印基准测试的结果：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that now we were dealing with datasets fitting in actual physical
    memory, and some of the benchmarked packages are designed and optimized for far
    larger databases. So it seems that optimizing the `read.table` function gives
    a great performance boost over the default settings, although if we are after
    really fast importing of reasonable sized data, using the `data.table` package
    is the optimal solution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在我们正在处理适合实际物理内存的数据集，而一些基准测试的包是为远大于数据库的数据库设计的和优化的。因此，优化`read.table`函数似乎在默认设置之上提供了很大的性能提升，尽管如果我们追求真正快速导入合理大小的数据，使用`data.table`包是最佳解决方案。
- en: Loading a subset of text files
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载文本文件的子集
- en: Sometimes we only need some parts of the dataset for an analysis, stored in
    a database backend or in flat files. In such situations, loading only the relevant
    subset of the data frame will result in much more speed improvement compared to
    any performance tweaks and custom packages discussed earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们只需要数据集的一部分来进行分析，存储在数据库后端或平面文件中。在这种情况下，仅加载数据框的相关子集将比任何性能调整和自定义包讨论的更快。
- en: Let's imagine we are only interested in flights to Nashville, where the annual
    *useR!* conference took place in 2012\. This means we need only those rows of
    the CSV file where the `Dest` equals `BNA` (this International Air Transport Association
    airport code stands for Nashville International Airport).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们只对2012年*useR!*会议（在纳什维尔举行）的航班感兴趣。这意味着我们只需要CSV文件中`Dest`等于`BNA`（这个国际航空运输协会机场代码代表纳什维尔国际机场）的行。
- en: Instead of loading the whole dataset in 160 to 2,000 milliseconds (see the previous
    section) and then dropping the unrelated rows (see in [Chapter 3](ch03.html "Chapter 3. Filtering
    and Summarizing Data"), *Filtering and Summarizing Data*), let's see the possible
    ways of filtering the data while loading it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在160到2,000毫秒内（见上一节）加载整个数据集，然后删除无关的行（见[第3章](ch03.html "第3章。过滤和汇总数据")，*过滤和汇总数据*），让我们看看在加载数据的同时过滤数据的方法。
- en: 'The already mentioned `sqldf` package can help with this task by specifying
    a SQL statement to be run on the temporary SQLite database created for the importing
    task:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提到的`sqldf`包可以通过指定一个要在为导入任务创建的临时SQLite数据库上运行的SQL语句来帮助完成这个任务：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `sql` argument defaults to `"select * from file"`, which means loading
    all fields of each row without any filters. Now we extended that with a `filter`
    statement. Please note that in our updated SQL statements, we also added the double
    quotes to the search term, as `sqldf` does not automatically recognize the quotes
    as special; it regards them as part of the fields. One may overcome this issue
    also by providing a custom filter argument, such as the following example on Unix-like
    systems:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`sql`参数默认为`"select * from file"`，这意味着加载每行的所有字段而不进行任何过滤。现在我们通过添加一个`filter`语句扩展了这一点。请注意，在我们的更新SQL语句中，我们还添加了双引号到搜索词中，因为`sqldf`不会自动识别引号为特殊字符；它将它们视为字段的一部分。也可以通过提供自定义的过滤参数来解决这个问题，例如以下Unix-like系统中的示例：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The resulting data frame holds only 3,481 observations out of the 227,496 cases
    in the original dataset, and filtering inside the temporary SQLite database of
    course speeds up data importing a bit:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据框只包含原始数据集中的227,496个案例中的3,481个观测值，当然，在临时SQLite数据库中进行过滤当然会稍微加快数据导入的速度：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The slight improvement is due to the fact that both R commands first loaded
    the CSV file to a temporary SQLite database; this process of course takes some
    time and cannot be eliminated from this process. To speed up this part of the
    evaluation, you can specify `dbname` as `NULL` for a performance boost. This way,
    the SQLite database would be created in memory instead of a `tempfile`, which
    might not be an optimal solution for larger datasets.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微的改进是由于两个R命令首先将CSV文件加载到一个临时的SQLite数据库中；这个过程当然需要一些时间，并且无法从这个过程中消除。为了加快这部分评估的速度，你可以将`dbname`指定为`NULL`以获得性能提升。这样，SQLite数据库就会在内存中创建，而不是在`tempfile`中，这可能不是处理大型数据集的最佳解决方案。
- en: Filtering flat files before loading to R
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在将文件加载到R之前过滤平面文件
- en: Is there a faster or smarter way to load only a portion of such a text file?
    One might apply some regular expression-based filtering on the flat files before
    passing them to R. For example, `grep` or `ack` might be a great tool to do so
    in a Unix environment, but it's not available by default on Windows machines,
    and parsing CSV files by regular expressions might result in some unexpected side-effects
    as well. Believe me, you never want to write a CSV, JSON, or XML parser from scratch!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有更快或更智能的方法来只加载这样的文本文件的一部分？一个人可以在将它们传递给R之前对平面文件应用一些基于正则表达式的过滤。例如，`grep`或`ack`可能在Unix环境中是一个很好的工具，但在Windows机器上默认不可用，并且通过正则表达式解析CSV文件可能会导致一些意外的副作用。相信我，你永远不想从头开始编写CSV、JSON或XML解析器！
- en: 'Anyway, a data scientist nowadays should be a real jack-of-all-trades when
    it comes to processing data, so here comes a quick and dirty example to show how
    one could read the filtered data in less than 100 milliseconds:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，现在的数据科学家在处理数据方面应该是一个真正的多面手，所以这里有一个快速且简单的例子来展示如何在100毫秒内读取过滤后的数据：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Well, that's a really great running time compared to any of our previous results!
    But what if we want to filter for flights with an arrival delay of more than 13.5
    minutes?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，与我们的任何先前结果相比，这是一个非常好的运行时间！但如果我们想过滤出到达延误超过13.5分钟的航班怎么办？
- en: Another way, and probably a more maintainable approach, would be to first load
    the data into a database backend, and query that when any subset of the data is
    needed. This way we could for example, simply populate a SQLite database in a
    file only once, and then later we could fetch any subsets in a fragment of `read.csv.sql`'s
    default run time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，可能是一个更易于维护的方法，就是首先将数据加载到数据库后端，并在需要任何数据子集时查询它。这样，例如，我们只需在文件中一次性填充 SQLite
    数据库，然后以后可以以 `read.csv.sql` 默认运行时间的片段来检索任何子集。
- en: 'So let''s create a persistent SQLite database:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个持久的 SQLite 数据库：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command has just created a file named to `hflights_db` in the current
    working directory. Next, let''s create a table named `hflights` and populate the
    content of the CSV file to the database created earlier:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令已经在当前工作目录中创建了一个名为 `hflights_db` 的文件。接下来，让我们创建一个名为 `hflights` 的表，并将 CSV 文件的內容填充到之前创建的数据库中：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'No benchmarking was made so far, as these steps will be run only once, while
    the queries for sub-parts of the dataset will probably run multiple times later:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有进行基准测试，因为这些步骤只会运行一次，而数据集子部分的查询可能稍后会多次运行：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And we have just loaded the required subset of the database in less than 100
    milliseconds! But we can do a lot better if we plan to often query the persistent
    database: why not dedicate a real database instance for our dataset instead of
    a simple file-based and server-less SQLite backend?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将所需的数据库子集在不到 100 毫秒内加载完成！但如果计划经常查询持久数据库，我们可以做得更好：为什么不专门为我们的数据集分配一个真实的数据库实例，而不是一个简单的基于文件和无需服务器的
    SQLite 后端呢？
- en: Loading data from databases
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库加载数据
- en: 'The great advantage of using a dedicated database backend instead of loading
    data from the disk on demand is that databases provide:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用数据库后端而不是按需从磁盘加载数据的巨大优势在于，数据库提供：
- en: Faster access to the whole or selected parts of large tables
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快地访问整个或所选部分的大表
- en: Powerful and quick ways to aggregate and filter data before loading it to R
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将数据加载到 R 之前，强大的快速聚合和过滤数据的方法
- en: Infrastructure to store data in a relational, more structured scheme compared
    to the traditional matrix model of spreadsheets and R objects
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比于传统的电子表格和 R 对象的矩阵模型，提供了一种在关系型、更结构化的方案中存储数据的基础设施
- en: Procedures to join and merge related data
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接和合并相关数据的程序
- en: Concurrent and network access from multiple clients at the same time
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时从多个客户端进行并发和网络访问
- en: Security policies and limits to access the data
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数据的安全策略和限制
- en: A scalable and configurable backend to store data
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展和可配置的后端以存储数据
- en: The `DBI` package provides a database interface, a communication channel between
    R and various **relational database management systems** (**RDBMS**), such as
    MySQL, PostgreSQL, MonetDB, Oracle, and for example Open Document Databases, and
    so on. There is no real need to install the package on its own because, acting
    as an interface, it will be installed anyway as a dependency, if needed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBI` 包提供了一个数据库接口，它是 R 与各种**关系数据库管理系统**（**RDBMS**）之间的通信渠道，例如 MySQL、PostgreSQL、MonetDB、Oracle，以及例如
    Open Document Databases 等，等等。实际上，没有必要单独安装此包，因为它作为接口，如果需要，将作为依赖项自动安装。'
- en: Connecting to a database and fetching data is pretty similar with all these
    backends, as all are based on the relational model and using SQL to manage and
    query data. Please be advised that there are some important differences between
    the aforementioned database engines and that several more open-source and commercial
    alternatives also exist. But we will not dig into the details on how to choose
    a database backend or how to build a data warehouse and **extract, transform,
    and load** (**ETL**) workflows, but we will only concentrate on making connections
    and managing data from R.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库并检索数据与所有这些后端都相当相似，因为它们都基于关系模型并使用 SQL 来管理和查询数据。请务必注意，上述数据库引擎之间存在一些重要差异，并且还存在更多开源和商业替代方案。但我们不会深入探讨如何选择数据库后端或如何构建数据仓库以及**提取、转换和加载**（**ETL**）工作流程的细节，我们只会专注于从
    R 中建立连接和管理数据。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SQL, originally developed at IBM, with its more than 40 years of history, is
    one of the most important programming languages nowadays—with various dialects
    and implementations. Being one of the most popular declarative languages all over
    the world, there are many online tutorials and free courses to learn how to query
    and manage data with SQL, which is definitely one of the most important tools
    in every data scientist's Swiss army knife.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: SQL，最初由 IBM 开发，拥有超过 40 年的历史，是目前最重要的编程语言之一——有各种方言和实现。作为全球最受欢迎的声明性语言之一，有许多在线教程和免费课程教授如何使用
    SQL 查询和管理数据，这无疑是每位数据科学家瑞士军刀中最重要的工具之一。
- en: So, besides R, it's really worth knowing your way around RDBMS, which are extremely
    common in any industry you may be working at as a data analyst or in a similar
    position.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了 R 之外，了解 RDBMS（关系数据库管理系统）也非常值得，这在您作为数据分析师或类似职位在任何行业中工作的地方都非常常见。
- en: Setting up the test environment
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: Database backends usually run on servers remote from the users doing data analysis,
    but for testing purposes, it might be a good idea to install local instances on
    the machine running R. As the installation process can be extremely different
    on various operating systems, we will not enter into any details of the installation
    steps, but we will rather refer to where the software can be downloaded from and
    some further links to great resources and documentation for installation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库后端通常运行在远离进行数据分析的用户的服务器上，但出于测试目的，在运行 R 的机器上安装本地实例可能是个好主意。由于安装过程在不同的操作系统上可能极其不同，我们不会进入安装步骤的任何细节，而是会参考软件的下载位置以及一些有关安装的优质资源和文档的链接。
- en: Please note that installing and actually trying to load data from these databases
    is totally optional and you do not have to follow each step—the rest of the book
    will not depend on any database knowledge or prior experience with databases.
    On the other hand, if you do not want to mess your workspace with temporary installation
    of multiple database applications for testing purposes, using virtual machines
    might be an optimal workaround. Oracle's `VirtualBox` provides a free and easy
    way of running multiple virtual machines with their dedicated operating system
    and userspace.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，安装并尝试从这些数据库加载数据完全是可选的，您不必遵循每个步骤——本书的其余部分将不依赖于任何数据库知识或与数据库相关的先前经验。另一方面，如果您不想在测试目的的多个数据库应用程序的临时安装中弄乱您的工作空间，使用虚拟机可能是一个最佳解决方案。Oracle
    的 `VirtualBox` 提供了一种免费且简单的方法来运行多个虚拟机，每个虚拟机都有其专用的操作系统和用户空间。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For detailed instructions on how to download then import a `VirtualBox` image,
    see the *Oracle* section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何下载并导入 `VirtualBox` 镜像的详细说明，请参阅 *Oracle* 部分。
- en: 'This way you can quickly deploy a fully functional, but disposable, database
    environment to test-drive the following examples of this chapter. In the following
    image, you can see `VirtualBox` with four installed virtual machines, of which
    three are running in the background to provide some database backends for testing
    purposes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以快速部署一个完全功能但可丢弃的数据库环境来测试本章的以下示例。在下面的图像中，您可以看到 `VirtualBox` 中安装了四个虚拟机，其中三个在后台运行，为测试目的提供一些数据库后端：
- en: '![Setting up the test environment](img/2028OS_01_02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![设置测试环境](img/2028OS_01_02.jpg)'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`VirtualBox` can be installed by your operating system''s package manager on
    Linux or by downloading the installation binary/sources from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
    For detailed and operating-system specific installation information, please refer
    to the *Chapter 2*, *Installation details* of the manual: [http://www.virtualbox.org/manual/](http://www.virtualbox.org/manual/).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualBox` 可以通过您的操作系统包管理器在 Linux 上安装，或者从 [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)
    下载安装二进制文件/源代码。有关详细和特定操作系统的安装信息，请参阅手册的 *第2章*，*安装细节*：[http://www.virtualbox.org/manual/](http://www.virtualbox.org/manual/).'
- en: Nowadays, setting up and running a virtual machine is really intuitive and easy;
    basically you only need a virtual machine image to be loaded and launched. Some
    virtual machines, so called appliances, include the operating system, with a number
    of further software usually already configured to work, for simple, easy and quick
    distribution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置和运行虚拟机非常直观和简单；基本上，您只需要加载并启动虚拟机镜像。一些虚拟机，所谓的虚拟机，已经包含了操作系统，通常已经配置了一些软件以便工作，以便简单、容易和快速分发。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Once again, if you do not enjoy installing and testing new software or spending
    time on learning about the infrastructure empowering your data needs, the following
    steps are not necessary and you can freely skip these optional tasks primarily
    described for full-stack developers/data scientists.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果您不喜欢安装和测试新软件或花时间学习支持您数据需求的基础设施，以下步骤不是必需的，您可以自由跳过这些主要针对全栈开发人员/数据科学家描述的可选任务。
- en: Such pre-configured virtual machines to be run on any computer can be downloaded
    from various providers on the Internet in multiple file formats, such as OVF or
    OVA. General purpose `VirtualBox` virtual appliances can be downloaded for example
    from [http://virtualboximages.com/vdi/index](http://virtualboximages.com/vdi/index)
    or [http://virtualboxes.org/images/](http://virtualboxes.org/images/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在任何计算机上运行的预配置虚拟机可以从互联网上的多个提供商处下载，格式多种多样，例如 OVF 或 OVA。例如，可以从 [http://virtualboximages.com/vdi/index](http://virtualboximages.com/vdi/index)
    或 [http://virtualboxes.org/images/](http://virtualboxes.org/images/) 下载通用的 `VirtualBox`
    虚拟设备。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Virtual appliances should be imported in VirtualBox, while non-OVF/OVA disk
    images should be attached to newly created virtual machines; thus, some extra
    manual configuration might also be needed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟设备应在 VirtualBox 中导入，而非 OVF/OVA 的磁盘镜像应附加到新创建的虚拟机上；因此，可能还需要一些额外的手动配置。
- en: 'Oracle also has a repository with a bunch of useful virtual images for data
    scientist apprentices and other developers at [http://www.oracle.com/technetwork/community/developer-vm/index.html](http://www.oracle.com/technetwork/community/developer-vm/index.html),
    with for example the Oracle Big Data Lite VM developer virtual appliance featuring
    the following most important components:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 还有一个包含大量对数据科学家学徒和其他开发人员有用的虚拟镜像的存储库，位于 [http://www.oracle.com/technetwork/community/developer-vm/index.html](http://www.oracle.com/technetwork/community/developer-vm/index.html)，例如，Oracle
    Big Data Lite VM 开发者虚拟设备包含以下最重要的组件：
- en: Oracle Database
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle 数据库
- en: Apache Hadoop and various tools in Cloudera distribution
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloudera 分发中的 Apache Hadoop 和各种工具
- en: The Oracle R Distribution
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle R 分发
- en: Build on Oracle Enterprise Linux
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Oracle Enterprise Linux 构建
- en: 'Disclaimer: Oracle wouldn''t be my first choice personally, but they did a
    great job with their platform-independent virtualization environment, just like
    with providing free developer VMs based on their commercial products. In short,
    it''s definitely worth using the provided Oracle tools.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 免责声明：Oracle 不会是我个人的首选，但他们在其平台无关的虚拟化环境中做得很好，就像他们基于其商业产品提供免费开发人员 VM 一样。简而言之，提供的
    Oracle 工具绝对值得使用。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you cannot reach your installed virtual machines on the network, please update
    your network settings to use *Host-only adapter* if no Internet connection is
    needed, or *Bridged networking* for a more robust setup. The latter setting will
    reserve an extra IP on your local network for the virtual machine; this way, it
    becomes accessible easily. Please find more details and examples with screenshots
    in the *Oracle database* section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法在网络上访问已安装的虚拟机，请更新您的网络设置，如果不需要互联网连接，请使用 *仅主机适配器*，或者对于更稳定的设置使用 *桥接网络*。后者设置将在您的本地网络上为虚拟机保留一个额外的
    IP 地址；这样，它就很容易访问了。请参阅 *Oracle 数据库* 部分以获取更多详细信息及示例截图。
- en: Another good source of virtual appliances created for open-source database engines
    is the Turnkey GNU/Linux repository at [http://www.turnkeylinux.org/database](http://www.turnkeylinux.org/database).
    These images are based on Debian Linux, are totally free to use, and currently
    support the MySQL, PostgreSQL, MongoDB, and CouchDB databases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个为开源数据库引擎创建的虚拟设备的好来源是 Turnkey GNU/Linux 存储库，位于 [http://www.turnkeylinux.org/database](http://www.turnkeylinux.org/database)。这些镜像基于
    Debian Linux，完全免费使用，目前支持 MySQL、PostgreSQL、MongoDB 和 CouchDB 数据库。
- en: A great advantage of the Turnkey Linux media is that it includes only open-source,
    free software and non-proprietary stuff. Besides, the disk images are a lot smaller
    and include only the required components for one dedicated database engine. This
    also results in far faster installation with less overhead in terms of the required
    disk and memory space.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Turnkey Linux 媒体的一个巨大优势是它只包含开源、免费软件和非专有内容。此外，磁盘镜像要小得多，只包含一个专用数据库引擎所需的组件。这也导致安装速度更快，在所需的磁盘和内存空间方面开销更小。
- en: Further similar virtual appliances are available at [http://www.webuzo.com/sysapps/databases](http://www.webuzo.com/sysapps/databases)
    with a wider range of database backends, such as Cassandra, HBase, Neo4j, Hypertable,
    or Redis, although some of the Webuzo appliances might require a paid subscription
    for deployment.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更多类似的虚拟应用可以在[http://www.webuzo.com/sysapps/databases](http://www.webuzo.com/sysapps/databases)找到，这里提供了更广泛的数据库后端选择，例如Cassandra、HBase、Neo4j、Hypertable或Redis，尽管一些Webuzo虚拟应用可能需要付费订阅才能部署。
- en: And as the new cool being Docker, I even more suggest you to get familiar with
    its concept on deploying software containers incredibly fast. Such container can
    be described as a standalone filesystem including the operating system, libraries,
    tools, data and so is based on abstraction layers of Docker images. In practice
    this means that you can fire up a database including some demo data with a one-liner
    command on your localhost, and developing such custom images is similarly easy.
    Please see some simple examples and further references at my R and Pandoc-related
    Docker images described at [https://github.com/cardcorp/card-rocker](https://github.com/cardcorp/card-rocker).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 而作为新兴的酷炫技术Docker，我更建议你熟悉其快速部署软件容器的概念。这样的容器可以被描述为一个包含操作系统、库、工具、数据和独立文件系统的独立文件系统，它基于Docker镜像的抽象层。在实践中，这意味着你可以在本地主机上使用一行命令启动一个包含一些示例数据的数据库，开发这样的自定义镜像同样简单。请参阅一些简单示例和进一步参考，我在[https://github.com/cardcorp/card-rocker](https://github.com/cardcorp/card-rocker)描述的R和Pandoc相关的Docker镜像。
- en: MySQL and MariaDB
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL和MariaDB
- en: 'MySQL is the most popular open-source database engine all over the world based
    on the number of mentions, job offers, Google searches, and so on, summarized
    by the DB-Engines Ranking: [http://db-engines.com/en/ranking](http://db-engines.com/en/ranking).
    Mostly used in Web development, the high popularity is probably due to the fact
    that MySQL is free, platform-independent, and relatively easy to set up and configure—just
    like its drop-in replacement fork called **MariaDB**.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL是全球最受欢迎的开源数据库引擎，这是基于DB-Engines排名总结的提及次数、工作机会、Google搜索等，[http://db-engines.com/en/ranking](http://db-engines.com/en/ranking)。主要用于Web开发，其高人气可能是因为MySQL是免费的、平台无关的，并且相对容易设置和配置——就像其替代品分支**MariaDB**一样。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MariaDB is a community-developed, fully open-source fork of MySQL, started and
    led by the founder of MySQL, Michael Widenius. It was later merged with SkySQL;
    thus further ex-MySQL executives and investors joined the fork. MariaDB was created
    after Sun Microsystems bought MySQL, currently owned by Oracle, and the development
    of the database engine changed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB是由MySQL的创始人Michael Widenius发起和领导的社区开发的开源分支，后来与SkySQL合并；因此，前MySQL的高管和投资者也加入了这个分支。在Sun
    Microsystems收购MySQL（目前由Oracle拥有）之后，数据库引擎的开发发生了变化。
- en: We will refer to both engines as MySQL in the book to keep it simple, as MariaDB
    can be considered as a drop-in replacement for MySQL, so please feel free to reproduce
    the following examples with either MySQL or MariaDB.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中，我们将这两个引擎都称为MySQL以保持简单，因为MariaDB可以被视为MySQL的替代品，所以请随意使用MySQL或MariaDB重放以下示例。
- en: 'Although the installation of a MySQL server is pretty straightforward on most
    operating systems ([https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/)),
    one might rather prefer to have the database installed in a virtual machine. Turnkey
    Linux provides small but fully configured, virtual appliances for free: [http://www.turnkeylinux.org/mysql](http://www.turnkeylinux.org/mysql).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数操作系统上安装MySQL服务器相当简单([https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/))，但有人可能更愿意在虚拟机上安装数据库。Turnkey
    Linux提供了免费的小型但完全配置好的虚拟应用：[http://www.turnkeylinux.org/mysql](http://www.turnkeylinux.org/mysql)。
- en: 'R provides multiple ways to query data from a MySQL database. One option is
    to use the `RMySQL` package, which might be a bit tricky for some users to install.
    If you are on Linux, please be sure to install the development packages of MySQL
    along with the MySQL client, so that the package can compile on your system. And,
    as there are no binary packages available on CRAN for Windows installation due
    to the high variability of MySQL versions, Windows users should also compile the
    package from source:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: R语言提供了多种从MySQL数据库查询数据的方法。一种选择是使用`RMySQL`包，对于一些用户来说，安装这个包可能有点棘手。如果你使用Linux，请确保安装MySQL的开发包和MySQL客户端，以便该包可以在你的系统上编译。另外，由于MySQL版本的高变异性，CRAN上没有可用的二进制包用于Windows安装，因此Windows用户也应该从源代码编译该包：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Windows users might find the following blog post useful about the detailed
    installation steps: [http://www.ahschulz.de/2013/07/23/installing-rmysql-under-windows/](http://www.ahschulz.de/2013/07/23/installing-rmysql-under-windows/).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户可能会发现以下关于在 Windows 下安装 `rmysql` 的详细步骤的博客文章很有用：[http://www.ahschulz.de/2013/07/23/installing-rmysql-under-windows/](http://www.ahschulz.de/2013/07/23/installing-rmysql-under-windows/)。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity, we will refer to the MySQL server as `localhost`
    listening on the default 3306 port; user will stand as `user` and password as
    `password` in all database connections. We will work with the `hflights` table
    in the `hflights_db` database, just like in the SQLite examples a few pages earlier.
    If you are working in a remote or virtual server, please modify the `host`, `username`,
    and so on arguments of the following code examples accordingly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将把 MySQL 服务器称为监听默认 3306 端口的 `localhost`；在所有数据库连接中，用户将是 `user`，密码将是
    `password`。我们将使用 `hflights_db` 数据库中的 `hflights` 表，就像在前面几页的 SQLite 示例中一样。如果你在一个远程或虚拟服务器上工作，请相应地修改以下代码示例中的
    `host`、`username` 等参数。
- en: After successfully installing and starting the MySQL server, we have to set
    up a test database, which we could later populate in R. To this end, let us start
    the MySQL command-line tool to create the database and a test user.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装并启动 MySQL 服务器后，我们必须设置一个测试数据库，稍后我们可以在 R 中填充它。为此，让我们启动 MySQL 命令行工具来创建数据库和测试用户。
- en: 'Please note that the following example was run on Linux, and a Windows user
    might have to also provide the path and probably the `exe` file extension to start
    the MySQL command-line tool:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下示例是在 Linux 上运行的，Windows 用户可能还需要提供路径以及可能还需要 `exe` 文件扩展名来启动 MySQL 命令行工具：
- en: '![MySQL and MariaDB](img/2028OS_01_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![MySQL 和 MariaDB](img/2028OS_01_03.jpg)'
- en: This quick session can be seen in the previous screenshot, where we first connected
    to the MySQL server in the command-line as the `root` (admin) user. Then we created
    a database named `hflights_db`, and granted all privileges and permissions of
    that database to a new user called `user` with the password set to `password`.
    Then we simply verified whether we could connect to the database with the newly
    created user, and we exited the command-line MySQL client.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，我们可以看到这次快速会话，我们首先以 `root`（管理员）用户身份在命令行中连接到 MySQL 服务器。然后我们创建了一个名为 `hflights_db`
    的数据库，并将该数据库的所有权限和权限授予了一个名为 `user` 的新用户，密码设置为 `password`。然后我们简单地验证是否可以与新创建的用户连接到数据库，并退出了命令行
    MySQL 客户端。
- en: 'To load data from a MySQL database into R, first we have to connect and also
    often authenticate with the server. This can be done with the automatically loaded
    `DBI` package when attaching `RMySQL`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据从 MySQL 数据库加载到 R 中，首先我们必须连接到服务器，并且通常还需要进行身份验证。这可以通过在附加 `RMySQL` 时自动加载的 `DBI`
    包来完成：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can refer to our MySQL connection as `con`, where we want to deploy
    the `hflights` dataset for later access:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的 MySQL 连接称为 `con`，其中我们想要部署 `hflights` 数据集以供后续访问：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `dbWriteTable` function wrote the `hflights` data frame with the same name
    to the previously defined connection. The latter command shows all the tables
    in the currently used databases, equivalent to the `SHOW TABLES` SQL command.
    Now that we have our original CVS file imported to MySQL, let''s see how long
    it takes to read the whole dataset:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbWriteTable` 函数将具有相同名称的 `hflights` 数据框写入先前定义的连接。后一个命令显示了当前使用的数据库中的所有表，相当于
    SQL 命令 `SHOW TABLES`。现在我们已经将原始的 CVS 文件导入到 MySQL 中，让我们看看读取整个数据集需要多长时间：'
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or we can do so with a direct SQL command passed to `dbGetQuery` from the same
    `DBI` package:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过将直接 SQL 命令传递给 `dbGetQuery` 的同一 `DBI` 包来完成：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And, just to keep further examples simpler, let's get back to the `sqldf` package,
    which stands for "SQL select on data frames". As a matter of fact, `sqldf` is
    a convenient wrapper around DBI's `dbSendQuery` function with some useful defaults,
    and returns `data.frame`. This wrapper can query various database engines, such
    as SQLite, MySQL, H2, or PostgreSQL, and defaults to the one specified in the
    global `sqldf.driver` option; or, if that's `NULL`, it will then check if any
    R packages have been loaded for the aforementioned backends.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使后续的示例更加简单，让我们回到 `sqldf` 包，它代表“数据框上的 SQL 选择”。实际上，`sqldf` 是围绕 DBI 的 `dbSendQuery`
    函数的一个方便的包装器，带有一些有用的默认设置，并返回 `data.frame`。这个包装器可以查询各种数据库引擎，如 SQLite、MySQL、H2 或
    PostgreSQL，默认使用全局 `sqldf.driver` 选项中指定的引擎；如果没有指定，它将检查是否有为上述后端加载了任何 R 包。
- en: 'As we have already loaded `RMySQL`, now `sqldf` will default to using MySQL
    instead of SQLite. But we still have to specify which connection to use; otherwise
    the function will try to open a new one—without any idea about our complex username
    and password combination, not to mention the mysterious database name. The connection
    can be passed in each `sqldf` expression or defined once in a global option:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已加载 `RMySQL`，现在 `sqldf` 将默认使用 MySQL 而不是 SQLite。但我们仍然需要指定要使用哪个连接；否则，函数将尝试打开一个新的连接——没有任何关于我们复杂的用户名和密码组合的想法，更不用说神秘的数据库名称了。连接可以在每个
    `sqldf` 表达式中传递，或者在一个全局选项中定义一次：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The difference in the preceding three versions of the same task does not seem
    to be significant. That 1-second timing seems to be a pretty okay result compared
    to our previously tested methods—although loading the whole dataset with `data.table`
    still beats this result. What about if we only need a subset of the dataset? Let''s
    fetch only those flights ending in Nashville, just like in our previous SQLite
    example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个相同任务的版本之间的差异似乎并不显著。与之前测试的方法相比，1 秒的计时似乎是一个相当不错的结果——尽管使用 `data.table` 加载数据集仍然优于这个结果。如果我们只需要数据集的子集怎么办？让我们只获取以纳什维尔结束的航班，就像我们之前的
    SQLite 示例一样：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This does not seem to be very convincing compared to our previous SQLite test,
    as the latter could reproduce the same result in less than 100 milliseconds. But
    please also note that that both the user and system elapsed times are zero, which
    was not the case with SQLite.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的 SQLite 测试相比，这似乎并不令人信服，因为后者可以在不到 100 毫秒内重现相同的结果。但请注意，用户和系统经过的时间都是零，这与
    SQLite 不同。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The returned elapsed time by `system.time` means the number of milliseconds
    passed since the start of the evaluation. The user and system times are a bit
    trickier to understand; they are reported by the operating system. More or less,
    `user` means the CPU time spent by the called process (like R or the MySQL server),
    while `system` reports the CPU time required by the kernel and other operating
    system processes (such as opening a file for reading). See `?proc.time` for further
    details.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`system.time` 返回的返回时间表示自评估开始以来经过的毫秒数。用户和系统时间稍微复杂一些；它们由操作系统报告。大致来说，`user` 表示被调用进程（如
    R 或 MySQL 服务器）所花费的 CPU 时间，而 `system` 报告内核和其他操作系统进程（如打开文件进行读取）所需的 CPU 时间。有关更多详细信息，请参阅
    `?proc.time`。'
- en: This means that no CPU time was used at all to return the required subset of
    data, which took almost 100 milliseconds with SQLite. How is it possible? What
    if we index the database on `Dest`?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着返回所需数据子集根本未使用任何 CPU 时间，使用 SQLite 需要 100 毫秒左右。这是怎么回事？如果我们对 `Dest` 上的数据库进行索引会怎样？
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This SQL query stands for creating an index named `Dest_idx` in our table based
    on the `Dest` column's first three letters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 SQL 查询代表在我们表的 `Dest` 列的前三个字母上创建一个名为 `Dest_idx` 的索引。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SQL index can seriously boost the performance of a `SELECT` statement with `WHERE`
    clauses, as MySQL this way does not have to read through the entire database to
    match each row, but it can determine the position of the relevant search results.
    This performance boost becomes more and more spectacular with larger databases,
    although it's also worth mentioning that indexing only makes sense if subsets
    of data are queried most of the time. If most or all data is needed, sequential
    reads would be faster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 索引可以显著提高带有 `WHERE` 子句的 `SELECT` 语句的性能，因为以这种方式，MySQL 不必读取整个数据库来匹配每一行，但它可以确定相关搜索结果的位置。随着数据库的增大，这种性能提升变得越来越显著，尽管也值得提一下，如果大多数情况下查询的是数据子集，则索引才有意义。如果需要大多数或所有数据，顺序读取会更快。
- en: 'Live example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实例演示：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It seems to be a lot better! Well, of course, we could have also indexed the
    SQLite database, not just the MySQL instance. To test it again, we have to revert
    the default `sqldf` driver to SQLite, which was overridden by loading the `RMySQL`
    package:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎要好得多！当然，我们也可以对 SQLite 数据库进行索引，而不仅仅是 MySQL 实例。为了再次测试，我们必须将默认的 `sqldf` 驱动程序还原为
    SQLite，这被加载 `RMySQL` 包所覆盖：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So it seems that both database engines are capable of returning the required
    subset of data in a fraction of a second, which is a lot better even compared
    to what we achieved with the impressive `data.table` before.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，似乎这两种数据库引擎都能够以秒分之一的时间返回所需的数据子集，这甚至比我们之前使用令人印象深刻的 `data.table` 所达到的结果要好得多。
- en: Although SQLite proved to be faster than MySQL in some earlier examples, there
    are many reasons to choose the latter in most situations. First, SQLite is a file-based
    database, which simply means that the database should be on a filesystem attached
    to the computer running R. This usually means having the SQLite database and the
    running R session on the same computer. Similarly, MySQL can handle larger amount
    of data; it has user management and rule-based control on what they can do, and
    concurrent access to the same dataset. The smart data scientist knows how to choose
    his weapon—depending on the task, another database backend might be the optimal
    solution. Let's see what other options we have in R!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些早期的例子中 SQLite 被证明比 MySQL 更快，但在大多数情况下，有许多原因选择后者。首先，SQLite 是一个基于文件的数据库，这意味着数据库应该位于连接到运行
    R 的计算机的文件系统上。这通常意味着 SQLite 数据库和运行中的 R 会话在同一台计算机上。同样，MySQL 可以处理更大的数据量；它具有用户管理和基于规则的权限控制，以及并发访问相同的数据集。聪明的数据科学家知道如何选择他的武器——根据任务，另一个数据库后端可能是最佳解决方案。让我们看看
    R 中我们还有哪些其他选项！
- en: PostgreSQL
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: While MySQL is said to be the most popular open-source relational database management
    system, PostgreSQL is famous for being "the world's most advanced open source
    database". This means that PostgreSQL is often considered to have more features
    compared to the simpler but faster MySQL, including analytic functions, which
    has led to PostgreSQL often being described as the open-source version of Oracle.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MySQL 被称为最受欢迎的开源关系型数据库管理系统，但 PostgreSQL 以“世界上最先进的开源数据库”而闻名。这意味着 PostgreSQL
    通常被认为比简单但更快的 MySQL 具有更多功能，包括分析函数，这也导致了 PostgreSQL 常常被描述为 Oracle 的开源版本。
- en: This sounds rather funny now, as Oracle owns MySQL today. So a bunch of things
    have changed in the past 20-30 years of RDBMS history, and PostgreSQL is not so
    slow any more. On the other hand, MySQL has also gained some nice new features—for
    example MySQL also became ACID-compliant with the `InnoDB` engine, allowing rollback
    to previous states of the database. There are some other differences between the
    two popular database servers that might support choosing either of them. Now let's
    see what happens if our data provider has a liking for PostgreSQL instead of MySQL!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在听起来相当有趣，因为 Oracle 现在拥有 MySQL。所以，在过去的 20-30 年的关系型数据库管理系统历史中，许多事情都发生了变化，PostgreSQL
    也不再那么慢了。另一方面，MySQL 也获得了一些很好的新功能——例如，MySQL 也通过 `InnoDB` 引擎成为 ACID 兼容，允许回滚到数据库的先前状态。这两个流行的数据库服务器之间还有一些其他差异，这些差异可能支持选择其中的任何一个。现在让我们看看如果我们的数据提供商更喜欢
    PostgreSQL 而不是 MySQL 会发生什么！
- en: Installing PostgreSQL is similar to MySQL. One may install the software with
    the operating system's package manager, download a graphical installer from [http://www.enterprisedb.com/products-services-training/pgdownload](http://www.enterprisedb.com/products-services-training/pgdownload),
    or run a virtual appliance with, for example, the free Turnkey Linux, which provides
    a small but fully configured disk image for free at [http://www.turnkeylinux.org/postgresql](http://www.turnkeylinux.org/postgresql).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 PostgreSQL 与 MySQL 类似。您可以使用操作系统的包管理器安装软件，从 [http://www.enterprisedb.com/products-services-training/pgdownload](http://www.enterprisedb.com/products-services-training/pgdownload)
    下载图形安装程序，或者使用例如免费的 Turnkey Linux 运行虚拟设备，Turnkey Linux 在 [http://www.turnkeylinux.org/postgresql](http://www.turnkeylinux.org/postgresql)
    提供了一个免费的小型但完全配置的磁盘镜像。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://www.packtpub.com](http://www.packtpub.com) 下载您购买的所有 Packt 出版物的示例代码文件。如果您在其他地方购买了这本书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册，以便将文件直接通过电子邮件发送给您。
- en: 'After successfully installing and starting the server, let''s set up the test
    database—just like we did after the MySQL installation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装并启动服务器后，让我们设置测试数据库——就像我们在 MySQL 安装后所做的那样：
- en: '![PostgreSQL](img/2028OS_01_04.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![PostgreSQL](img/2028OS_01_04.jpg)'
- en: The syntax is a bit different in some cases, and we have used some command-line
    tools for the user and database creation. These helper programs are shipped with
    PostgreSQL by default, and MySQL also have some similar functionality with `mysqladmin`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，语法略有不同，我们已使用了一些命令行工具用于用户和数据库的创建。这些辅助程序默认随 PostgreSQL 一起提供，MySQL 也提供了一些类似的功能，例如
    `mysqladmin`。
- en: 'After setting up the initial test environment, or if we already have a working
    database instance to connect, we can repeat the previously described data management
    tasks with the help of the `RPostgreSQL` package:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置初始测试环境之后，或者如果我们已经有一个可连接的工作数据库实例，我们可以借助 `RPostgreSQL` 包重复之前描述的数据管理任务：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your R session starts to throw strange error messages in the following examples,
    it's highly possible that the loaded R packages are conflicting. You could simply
    start a clean R session, or detach the previously attached packages—for example,
    `detach('package:RMySQL', unload = TRUE)`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 R 会话在以下示例中开始抛出奇怪的错误消息，那么加载的 R 包冲突的可能性非常高。你可以简单地启动一个干净的 R 会话，或者断开之前附加的包——例如，`detach('package:RMySQL',
    unload = TRUE)`。
- en: 'Connecting to the database (listening on the default port number 5432) is again
    familiar:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库（监听默认端口号 5432）再次变得熟悉：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s verify that we are connected to the right database instance, which should
    be currently empty without the `hflights` table:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证我们是否连接到了正确的数据库实例，它目前应该没有 `hflights` 表且为空：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then let''s write our demo table in PostgreSQL and see if the old rumor about
    it being slower than MySQL is still true:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们在 PostgreSQL 中编写我们的演示表，看看关于它比 MySQL 慢的旧传闻是否仍然成立：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Seems to be impressive! What about loading partial data?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很令人印象深刻！那么加载部分数据呢？
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Just under 100 milliseconds without indexing! Please note the extra escaped
    quotes around `Dest`, as the default PostgreSQL behavior folds unquoted column
    names to lower case, which would result in a column `dest` does not exist error.
    Creating an index and running the preceding query with much improved speed can
    be easily reproduced based on the MySQL example.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 没有索引的情况下大约 100 毫秒！请注意 `Dest` 周围额外的转义引号，因为默认的 PostgreSQL 行为会将未引用的列名折叠为小写，这会导致出现列
    `dest` 不存在的错误。根据 MySQL 示例，创建索引并运行前面的查询以大幅提高速度可以轻松重现。
- en: Oracle database
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle 数据库
- en: Oracle Database Express Edition can be downloaded and installed from [http://www.oracle.com/technetwork/database/database-technologies/express-edition/downloads/index.html](http://www.oracle.com/technetwork/database/database-technologies/express-edition/downloads/index.html).
    Although this is not a full-featured Oracle database, and it suffers from serious
    limitations, the Express Edition is a free and not too resource-hungry way to
    build a test environment at home.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 数据库 Express Edition 可以从 [http://www.oracle.com/technetwork/database/database-technologies/express-edition/downloads/index.html](http://www.oracle.com/technetwork/database/database-technologies/express-edition/downloads/index.html)
    下载和安装。虽然这不是一个功能齐全的 Oracle 数据库，并且存在严重的限制，但 Express Edition 是一种免费且不太占用资源的在家构建测试环境的方法。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Oracle database is said to be the most popular database management system in
    the world, although it is available only with a proprietary license, unlike the
    previous two discussed RDBMSs, which means that Oracle offers the product with
    term licensing. On the other hand, the paid license also comes with priority support
    from the developer company, which is often a strict requirement in enterprise
    environments. Oracle Database has supported a variety of nice features since its
    first release in 1980, such as sharding, master-master replication, and full ACID
    properties.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 据说 Oracle 数据库是世界上最受欢迎的数据库管理系统，尽管它只能通过专有许可证获得，与之前讨论的两个 RDBMS 不同，这意味着 Oracle 以条款许可的形式提供产品。另一方面，付费许可证还附带来自开发商公司的优先支持，这在企业环境中通常是一个严格的要求。Oracle
    数据库自 1980 年首次发布以来就支持了许多优秀的功能，例如分片、主-主复制和完全 ACID 属性。
- en: 'Another way of getting a working Oracle database for testing purposes is to
    download an Oracle Pre-Built Developer VM from [http://www.oracle.com/technetwork/community/developer-vm/index.html](http://www.oracle.com/technetwork/community/developer-vm/index.html),
    or a much smaller image custom created for *Hands-on Database Application Development*
    at *Oracle Technology Network Developer Day*: [http://www.oracle.com/technetwork/database/enterprise-edition/databaseappdev-vm-161299.html](http://www.oracle.com/technetwork/database/enterprise-edition/databaseappdev-vm-161299.html).
    We will follow the instructions from the latter source.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取用于测试目的的Oracle数据库的方法是从[http://www.oracle.com/technetwork/community/developer-vm/index.html](http://www.oracle.com/technetwork/community/developer-vm/index.html)下载Oracle预构建开发者虚拟机，或者从*Oracle技术网络开发者日*为*动手数据库应用开发*定制的更小的镜像：[http://www.oracle.com/technetwork/database/enterprise-edition/databaseappdev-vm-161299.html](http://www.oracle.com/technetwork/database/enterprise-edition/databaseappdev-vm-161299.html)。我们将遵循后者的说明。
- en: 'After accepting the License Agreement and registering for free at Oracle, we
    can download the `OTN_Developer_Day_VM.ova` virtual appliance. Let''s import it
    to VirtualBox via **Import appliance** in the **File** menu, then choose the `ova`
    file, and click **Next**:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接受许可协议并在Oracle免费注册后，我们可以下载`OTN_Developer_Day_VM.ova`虚拟设备。让我们通过**文件**菜单中的**导入设备**来将其导入VirtualBox，然后选择`ova`文件，并点击**下一步**：
- en: '![Oracle database](img/2028OS_01_05.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Oracle数据库](img/2028OS_01_05.jpg)'
- en: 'After clicking **Import**, you will have to agree again to the Software License
    Agreement. Importing the virtual disk image (15 GB) might take a few minutes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**导入**后，您需要再次同意软件许可协议。导入虚拟磁盘镜像（15 GB）可能需要几分钟时间：
- en: '![Oracle database](img/2028OS_01_06.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Oracle数据库](img/2028OS_01_06.jpg)'
- en: 'After importing has finished, we should first update the networking configuration
    so that we can access the internal database of the virtual machine from outside.
    So let''s switch from **NAT** to **Bridged Adapter** in the settings:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 导入完成后，我们应该首先更新网络配置，以便我们可以从外部访问虚拟机的内部数据库。所以让我们在设置中将**NAT**切换到**桥接适配器**：
- en: '![Oracle database](img/2028OS_01_07.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Oracle数据库](img/2028OS_01_07.jpg)'
- en: Then we can simply start the newly created virtual machine in VirtualBox. After
    Oracle Linux has booted, we can log in with the default `oracle` password.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在VirtualBox中简单地启动新创建的虚拟机。Oracle Linux启动后，我们可以使用默认的`oracle`密码登录。
- en: 'Although we have set a bridged networking interface for our virtual machine,
    which means that the VM is directly connected to our real sub-network with a real
    IP address, the machine is not yet accessible over the network. To connect with
    the default DHCP settings, simply navigate to the top red bar and look for the
    networking icon, then select **System eth0**. After a few seconds the VM is accessible
    from your host machine, as the guest system should be connected to your network.
    You can verify that by running the `ifconfig` or `ip addr show eth0` command in
    the already running console:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经为我们的虚拟机设置了一个桥接网络接口，这意味着虚拟机直接连接到我们的真实子网络并具有真实IP地址，但该机器在网络中尚不可访问。要使用默认的DHCP设置进行连接，只需导航到顶部红色栏并查找网络图标，然后选择**系统eth0**。几秒钟后，虚拟机可以从您的宿主机访问，因为虚拟系统应该连接到您的网络。您可以通过在已运行的控制台中运行`ifconfig`或`ip
    addr show eth0`命令来验证这一点：
- en: '![Oracle database](img/2028OS_01_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Oracle数据库](img/2028OS_01_08.jpg)'
- en: 'Unfortunately, this already running Oracle database is not yet accessible outside
    the guest machine. The developer VM comes with a rather strict firewall by default,
    which should be disabled first. To see the rules in effect, run the standard `iptables
    -L -n` command and, to flush all rules, execute `iptables -F`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个已经运行的Oracle数据库在虚拟机外部尚不可访问。开发者虚拟机默认有一个相当严格的防火墙，首先需要将其禁用。要查看生效的规则，运行标准命令`iptables
    -L -n`，要清除所有规则，执行`iptables -F`：
- en: '![Oracle database](img/2028OS_01_09.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Oracle数据库](img/2028OS_01_09.jpg)'
- en: 'Now that we have a running and remotely accessible Oracle database, let''s
    prepare the R client side. Installing the `ROracle` package might get tricky on
    some operating systems, as there are no prebuilt binary packages and you have
    to manually install the Oracle Instant Client Lite and SDK libraries before compiling
    the package from source. If the compiler complained about the path of your previously
    installed Oracle libraries, please pass the `--with-oci-lib` and `--with-oci-inc`
    arguments with your custom paths with the `--configure-args` parameter. More details
    can be found in the package installation document: [http://cran.r-project.org/web/packages/ROracle/INSTALL](http://cran.r-project.org/web/packages/ROracle/INSTALL).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个运行且可远程访问的Oracle数据库，让我们准备R客户端。在某些操作系统上安装 `ROracle` 包可能会变得复杂，因为没有预构建的二进制包，你必须手动安装Oracle
    Instant Client Lite和SDK库，然后再从源代码编译包。如果编译器抱怨你之前安装的Oracle库的路径，请使用 `--with-oci-lib`
    和 `--with-oci-inc` 参数，并通过 `--configure-args` 参数传递你的自定义路径。更多详细信息可以在包安装文档中找到：[http://cran.r-project.org/web/packages/ROracle/INSTALL](http://cran.r-project.org/web/packages/ROracle/INSTALL)。
- en: 'For example, on Arch Linux you can install the Oracle libs from AUR, then run
    the following command in `bash` after downloading the R package from CRAN:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Arch Linux上，你可以从AUR安装Oracle库，然后从CRAN下载R包后，在 `bash` 中运行以下命令：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After installing and loading the package, opening a connection is extremely
    similar to the pervious examples with `DBI::dbConnect`. We only pass an extra
    parameter here. First, let us specify the hostname or direct IP address of the
    Oracle database included in the `dbname` argument. Then we can connect to the
    already existing PDB1 database of the developer machine instead of the previously
    used `hflights_db`—just to save some time and space in the book on slightly off-topic
    database management tasks:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并加载包后，打开连接与之前的 `DBI::dbConnect` 示例极其相似。这里我们只传递一个额外的参数。首先，让我们指定包含在 `dbname`
    参数中的Oracle数据库的主机名或直接IP地址。然后我们可以连接到开发机器上已经存在的PDB1数据库，而不是之前使用的 `hflights_db`——只是为了在书中节省一些关于稍微偏离主题的数据库管理任务的时间和空间：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And we have a working connection to Oracle RDBMS:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个到Oracle RDBMS的工作连接：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s see what we have in the bundled database on the development VM:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看开发虚拟机上的捆绑数据库里有什么：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So it seems that we have a table called `TICKER` with three views on tick data
    of three symbols. Saving the `hflights` table in the same database will not do
    any harm, and we can also instantly test the speed of the Oracle database when
    reading the whole table:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，似乎我们有一个名为 `TICKER` 的表，它包含了三个符号的tick数据的三个视图。在同一个数据库中保存 `hflights` 表不会造成任何伤害，我们还可以立即测试Oracle数据库读取整个表的速度：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And the extremely familiar subset with 3,481 cases:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个包含3,481个案例的极其熟悉的子集：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Please note the quotes around the table name. In the previous examples with
    MySQL and PostgreSQL, the SQL statements run fine without those. However, the
    quotes are needed in the Oracle database, as we have saved the table with an all-lowercase
    name, and the default rule in Oracle DB is to store object names in upper case.
    The only other option is to use double quotes to create them, which is what we
    did; thus we have to refer to the table with quotes around the lowercase name.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意表名周围的引号。在之前的MySQL和PostgreSQL示例中，SQL语句运行良好，无需那些引号。然而，在Oracle数据库中需要引号，因为我们以全小写名称保存了表，Oracle
    DB的默认规则是将对象名称存储为大写。唯一的另一种选择是使用双引号来创建它们，这就是我们所做的；因此，我们必须用引号引用小写名称。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We started with unquoted table and column names in MySQL, then had to add escaped
    quotes around the variable name in the PostgreSQL query run from R, and now in
    Oracle database we have to put both names between quotes—which demonstrates the
    slight differences in the various SQL flavors (such as MySQL, PostgreSQL, PL/SQL
    of Oracle or Microsoft's Transact-SQL) on top of ANSI SQL.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从MySQL中的未引用的表和列名开始，然后在从R运行PostgreSQL查询时必须将变量名周围的引号转义，现在在Oracle数据库中我们必须将两个名称都放在引号之间——这展示了各种SQL方言（如MySQL、PostgreSQL、Oracle的PL/SQL或微软的Transact-SQL）在ANSI
    SQL之上的细微差别。
- en: 'And more importantly: do not stick to one database engine with all your projects,
    but rather choose the optimal DB for the task if company policy doesn''t stop
    you doing so.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是：不要让你的所有项目都坚持使用一个数据库引擎，而是如果公司政策不允许你这样做，就选择最适合任务的DB。
- en: 'These results were not so impressive compared to what we have seen by PostgreSQL,
    so let''s also see the results of an indexed query:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们看到的PostgreSQL相比，这些结果并不那么令人印象深刻，所以让我们也看看索引查询的结果：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I leave the full-scale comparative testing and benchmarking to you, so that
    you can run custom queries in the tests fitting your exact needs. It is highly
    possible that the different database engines perform differently in special use
    cases.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我将全面的比较测试和基准测试留给你，这样你就可以在适合你确切需求的测试中运行自定义查询。不同的数据库引擎在特殊用例中表现不同的可能性非常高。
- en: To make this process a bit more seamless and easier to implement, let's check
    out another R way of connecting to databases, although probably with a slight
    performance trade-off. For a quick scalability and performance comparison on connecting
    to Oracle databases with different approaches in R, please see [https://blogs.oracle.com/R/entry/r_to_oracle_database_connectivity](https://blogs.oracle.com/R/entry/r_to_oracle_database_connectivity).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个过程更加无缝和易于实现，让我们看看另一种R连接数据库的方法，尽管可能略有性能折衷。为了快速可扩展性和性能比较，请参阅使用不同方法在R中连接Oracle数据库的[https://blogs.oracle.com/R/entry/r_to_oracle_database_connectivity](https://blogs.oracle.com/R/entry/r_to_oracle_database_connectivity)。
- en: ODBC database access
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ODBC数据库访问
- en: As mentioned earlier, installing the native client software, libraries, and
    header files for the different databases so that the custom R packages can be
    built from source can be tedious and rather tricky in some cases. Fortunately,
    we can also try to do the opposite of this process. An alternative solution can
    be installing a middleware **Application Programming Interface** (**API**) in
    the databases, so that R, or as a matter of fact any other tool, could communicate
    with them in a standardized and more convenient way. However, please be advised
    that this more convenient way impairs performance due to the translation layer
    between the application and the DBMS.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为不同的数据库安装本机客户端软件、库和头文件，以便可以从源构建自定义R包，这可能会很繁琐，而且在某些情况下相当棘手。幸运的是，我们也可以尝试做这个过程的相反。一个替代方案是在数据库中安装一个中间件**应用程序编程接口**（**API**），这样R，或者更确切地说，任何其他工具，都可以以标准化和更方便的方式与它们通信。然而，请注意，这种更方便的方式由于应用程序和数据库管理系统之间的转换层而损害了性能。
- en: The `RODBC` package implements access to such a layer. The **Open Database Connectivity**
    (**ODBC**) driver is available for most database management systems, even for
    CSV and Excel files, so `RODBC` provides a standardized way to access data in
    almost any databases if the ODBC driver is installed. This platform-independent
    interface is available for SQLite, MySQL, MariaDB, PostgreSQL, Oracle database,
    Microsoft SQL Server, Microsoft Access, and IBM DB2 on Windows and on Linux.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`RODBC`包实现了对这一层的访问。**开放数据库连接**（**ODBC**）驱动程序适用于大多数数据库管理系统，甚至适用于CSV和Excel文件，因此如果安装了ODBC驱动程序，`RODBC`提供了访问几乎所有数据库的标准方式。这个平台无关的接口在Windows和Linux上可用于SQLite、MySQL、MariaDB、PostgreSQL、Oracle数据库、Microsoft
    SQL Server、Microsoft Access和IBM DB2。'
- en: 'For a quick example, let''s connect to MySQL running on `localhost` (or on
    a virtual machine). First, we have to set up a **Database Source Name** (**DSN**)
    with the connection details, such as:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速示例，让我们连接到运行在`localhost`（或虚拟机）上的MySQL。首先，我们必须设置一个**数据库源名称**（**DSN**），包括连接细节，例如：
- en: Database driver
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库驱动程序
- en: Host name or address and port number, optionally a Unix socket
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机名或地址和端口号，可选的Unix套接字
- en: Database name
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库名称
- en: Optionally the username and password to be used for the connection
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的用于连接的用户名和密码
- en: 'This can be done in the command line by editing the `odbc.ini` and `odbcinst.ini`
    files on Linux after installing the `unixODBC` program. The latter should include
    the following configuration for the MySQL driver in your `/etc` folder:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在安装`unixODBC`程序后，在Linux上编辑`odbc.ini`和`odbcinst.ini`文件来完成。后者应该在您的`/etc`文件夹中包含以下针对MySQL驱动程序的配置：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `odbc.ini` file includes the aforementioned DSN configuration for the exact
    database and server:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`odbc.ini`文件包含了上述针对特定数据库和服务器DSN配置：'
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or use a graphical user interface on Mac OS or Windows, as shown in the following
    screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在Mac OS或Windows上使用图形用户界面，如下面的截图所示：
- en: '![ODBC database access](img/2028OS_01_10.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![ODBC数据库访问](img/2028OS_01_10.jpg)'
- en: 'After configuring a DSN, we can connect with a one-line command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 配置DSN后，我们可以通过一条命令进行连接：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s fetch the data we saved in the database before:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取之前保存在数据库中的数据：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Well, it took a few seconds to finish. That''s the trade-off for using a more
    convenient and high-level interface to interact with the database. Removing and
    uploading data to the database can be done with similar high-level functions (such
    as `sqlFetch`) besides the `odbc*` functions, providing low-level access to the
    database. Quick examples:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，完成这个过程只花了几秒钟。这就是使用更方便、更高级的界面与数据库交互的权衡。除了`odbc*`函数提供低级数据库访问之外，还可以使用类似的高级函数（如`sqlFetch`）来删除和上传数据库中的数据。以下是一些快速示例：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can use the exact same commands to query any of the other supported database
    engines; just be sure to set up the DSN for each backend, and to close your connections
    if not needed any more:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用完全相同的命令查询任何其他支持的数据库引擎；只需确保为每个后端设置DSN，并在不再需要时关闭您的连接：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `RJDBC` package can provide a similar interface to database management systems
    with a **Java Database Connectivity** (**JDBC**) driver.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`RJDBC`包可以使用**Java数据库连接**（**JDBC**）驱动程序提供类似数据库管理系统的接口。'
- en: Using a graphical user interface to connect to databases
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用图形用户界面连接到数据库
- en: 'Speaking of high-level interfaces, R also has a graphical user interface to
    connect to MySQL in the `dbConnect` package:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 说到高级接口，R在`dbConnect`包中也有一个用于连接MySQL的图形用户界面：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'No parameters, no custom configuration in the console, just a simple dialog
    window:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数，控制台中没有自定义配置，只有一个简单的对话框窗口：
- en: '![Using a graphical user interface to connect to databases](img/2028OS_01_11.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![使用图形用户界面连接到数据库](img/2028OS_01_11.jpg)'
- en: 'After providing the required connection information, we can easily view the
    raw data and the column/variable types, and run custom SQL queries. A basic query
    builder can also help novice users to fetch subsamples from the database:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供所需的连接信息后，我们可以轻松查看原始数据和列/变量类型，并运行自定义SQL查询。基本查询构建器还可以帮助新手用户从数据库中获取子样本：
- en: '![Using a graphical user interface to connect to databases](img/2028OS_01_12.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![使用图形用户界面连接到数据库](img/2028OS_01_12.jpg)'
- en: The package ships with a handy function called `sqlToR`, which can turn the
    SQL results into R objects with a click in the GUI. Unfortunately, `dbConnect`
    relies heavily on `RMySQL`, which means it's a MySQL-only package, and there is
    no plan to extend the functionality of this interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该包附带一个名为`sqlToR`的便捷函数，它可以将SQL结果通过GUI点击转换为R对象。不幸的是，`dbConnect`严重依赖于`RMySQL`，这意味着它是一个仅适用于MySQL的包，并且没有计划扩展此接口的功能。
- en: Other database backends
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他数据库后端
- en: Besides the previously mentioned popular databases, there are several other
    implementations that we cannot discuss here in detail.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前提到的流行数据库之外，还有一些其他实现，我们在这里无法详细讨论。
- en: For example, column-oriented database management systems, such as MonetDB, are
    often used to store large datasets with millions of rows and thousands of columns
    to provide the backend for high-performance data mining. It also has great R support
    with the `MonetDB.R` package, which was among the most exciting talks at the useR!
    2013 conference.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，列式数据库管理系统，如MonetDB，通常用于存储包含数百万行和数千列的大型数据集，为高性能数据挖掘提供后端支持。它还提供了强大的R支持，`MonetDB.R`包在2013年useR!会议上的讨论中是最激动人心的之一。
- en: 'The ever-growing popularity of the NoSQL ecosystem also provides similar approaches,
    although usually without supporting SQL and providing a schema-free data storage.
    Apache Cassandra is a good example of such a similar, column-oriented, and primarily
    distributed database management system with high availably and performance, run
    on commodity hardware. The `RCassandra` package provides access to the basic Cassandra
    features and the Cassandra Query Language in a convenient way with the `RC.*`
    function family. Another Google Bigtable-inspired and similar database engine
    is HBase, which is supported by the `rhbase` package, part of the `RHadoop` project:
    [https://github.com/RevolutionAnalytics/RHadoop/wiki](https://github.com/RevolutionAnalytics/RHadoop/wiki).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL生态系统的持续增长也提供了类似的方法，尽管通常不支持SQL并提供无模式的数据存储。Apache Cassandra是一个很好的例子，它是一个类似的、以列为主的、主要分布式的数据库管理系统，具有高可用性和性能，运行在通用硬件上。`RCassandra`包以方便的方式提供了对Cassandra基本功能和Cassandra查询语言的基本访问，使用`RC.*`函数族。另一个受Google
    Bigtable启发的类似数据库引擎是HBase，它由`rhbase`包支持，是`RHadoop`项目的一部分：[https://github.com/RevolutionAnalytics/RHadoop/wiki](https://github.com/RevolutionAnalytics/RHadoop/wiki)。
- en: Speaking of Massively Parallel Processing, HP's Vertica and Cloudera's open-source
    Impala are also accessible from R, so you can easily access and query large amount
    of data with relatively good performance.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 说到大规模并行处理，HP 的 Vertica 和 Cloudera 的开源 Impala 也都可以从 R 访问，因此您可以轻松地以相对良好的性能访问和查询大量数据。
- en: One of the most popular NoSQL databases is MongoDB, which provides document-oriented
    data storage in a JSON-like format, providing an infrastructure to dynamic schemas.
    MongoDB is actively developed and has some SQL-like features, such as a query
    language and indexing, also with multiple R packages providing access to this
    backend. The `RMongo` package uses the *mongo-java-driver* and thus depends on
    Java, but provides a rather high-level interface to the database. Another implementation,
    the `rmongodb` package, is developed and maintained by the MongoDB Team. The latter
    has more frequent updates and more detailed documentation, but the R integration
    seems to be a lot more seamless with the first package as `rmongodb` provides
    access to the raw MongoDB functions and BSON objects, instead of concentrating
    on a translation layer for general R users. A more recent and really promising
    package supporting MongoDB is `mongolite` developed by Jeroen Ooms.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的 NoSQL 数据库之一是 MongoDB，它以类似 JSON 的格式提供面向文档的数据存储，提供动态模式的基础设施。MongoDB 正在积极开发，并具有一些类似
    SQL 的功能，如查询语言和索引，还有多个 R 包提供对此后端访问。`RMongo` 包使用 *mongo-java-driver*，因此依赖于 Java，但提供了相当高级的数据库接口。另一个实现是
    `rmongodb` 包，由 MongoDB 团队开发和维护。后者更新更频繁，文档更详细，但与第一个包相比，R 集成似乎更加无缝，因为 `rmongodb`
    提供了对原始 MongoDB 函数和BSON 对象的访问，而不是专注于为一般 R 用户提供翻译层。一个更近期的、非常有前景的 MongoDB 支持包是由 Jeroen
    Ooms 开发的 `mongolite`。
- en: CouchDB, my personal favorite for most schema-less projects, provides very convenient
    document storage with JSON objects and HTTP API, which means that integrating
    in applications, such as any R script, is really easy with, for example, the `RCurl`
    package, although you may find the `R4CouchDB` more quick to act in interacting
    with the database.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB，我最喜欢的无模式项目之一，提供了非常方便的文档存储，使用 JSON 对象和 HTTP API，这意味着在应用程序中集成，例如任何 R 脚本，都非常容易，例如使用
    `RCurl` 包，尽管您可能会发现 `R4CouchDB` 在与数据库交互时更快速。虽然您可能会发现 `R4CouchDB` 在与数据库交互时更快速。
- en: 'Google BigQuery also provides a similar, REST-based HTTP API to query even
    terabytes of data hosted in the Google infrastructure with an SQL-like language.
    Although the `bigrquery` package is not available on CRAN yet, you may easily
    install it from GitHub with the `devtools` package from the same author, Hadley
    Wickham:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Google BigQuery 还提供了一个类似的基于 REST 的 HTTP API，使用类似 SQL 的语言查询托管在 Google 基础设施中的甚至达到千兆字节的数据。尽管
    `bigrquery` 包尚未在 CRAN 上提供，但您可以使用同一作者 Hadley Wickham 的 `devtools` 包轻松地从 GitHub
    安装它：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To test-drive the features of this package and Google BigQuery, you can sign
    up for a free account to fetch and process the demo dataset provided by Google,
    respecting the 10,000 requests per day limitation for free usage. Please note
    that the current implementation is a read-only interface to the database.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试本包和 Google BigQuery 的功能，您可以注册一个免费账户以获取并处理 Google 提供的演示数据集，但请注意，免费使用的每日请求限制为
    10,000 次。请注意，当前实现是数据库的只读接口。
- en: For rather similar database engines and comparisons, see for example [http://db-engines.com/en/systems](http://db-engines.com/en/systems).
    Most of the popular databases already have R support but, if not, I am pretty
    sure that someone is already working on it. It's worth checking the CRAN packages
    at [http://cran.r-project.org/web/packages/available_packages_by_name.html](http://cran.r-project.org/web/packages/available_packages_by_name.html)
    or searching on GitHub or on [http://R-bloggers.com](http://R-bloggers.com) to
    see how other R users manage to interact with your database of choice.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相当类似的数据库引擎和比较，例如查看 [http://db-engines.com/en/systems](http://db-engines.com/en/systems)。大多数流行的数据库已经支持
    R，但如果还没有，我相当确信已经有某人在开发它。值得检查 CRAN 软件包 [http://cran.r-project.org/web/packages/available_packages_by_name.html](http://cran.r-project.org/web/packages/available_packages_by_name.html)
    或在 GitHub 或 [http://R-bloggers.com](http://R-bloggers.com) 上搜索，看看其他 R 用户是如何与您选择的数据库交互的。
- en: Importing data from other statistical systems
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从其他统计系统导入数据
- en: In a recent academic project, where my task was to implement some financial
    models in R, I got the demo dataset to be analyzed as Stata `dta` files. Working
    as a contractor at the university, without access to any Stata installations,
    it might have been problematic to read the binary file format of another statistical
    software, but as the `dta` file format is documented and the specification is
    publicly available at [http://www.stata.com/help.cgi?dta](http://www.stata.com/help.cgi?dta),
    some members of the Core R Team have already implemented an R parser in the form
    of the `read.dta` function in the `foreign` package.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个最近的项目中，我的任务是使用 R 实现一些金融模型，我得到了要分析的演示数据集，以 Stata `dta` 文件的形式。作为大学的一名承包商，没有访问任何
    Stata 安装权限，读取其他统计软件的二进制文件格式可能是个问题，但鉴于 `dta` 文件格式有文档记录，规范在 [http://www.stata.com/help.cgi?dta](http://www.stata.com/help.cgi?dta)
    公开可用，Core R 团队的一些成员已经在 `foreign` 软件包中以 `read.dta` 函数的形式实现了 R 解析器。
- en: 'To this end, loading (and often writing) Stata—or for example SPSS, SAS, Weka,
    Minitab, Octave, or dBase files—just cannot be easier in R. Please see the complete
    list of supported file formats and examples in the package documentation or in
    the *R Data Import/Export* manual: [http://cran.r-project.org/doc/manuals/r-release/R-data.html#Importing-from-other-statistical-systems](http://cran.r-project.org/doc/manuals/r-release/R-data.html#Importing-from-other-statistical-systems).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 R 中加载（和经常写入）Stata——或者例如 SPSS、SAS、Weka、Minitab、Octave 或 dBase 文件——简直不能更容易。请参阅软件包文档或
    *R 数据导入/导出* 手册中的完整支持文件格式和示例：[http://cran.r-project.org/doc/manuals/r-release/R-data.html#Importing-from-other-statistical-systems](http://cran.r-project.org/doc/manuals/r-release/R-data.html#Importing-from-other-statistical-systems)。
- en: Loading Excel spreadsheets
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载 Excel 工作表
- en: One of the most popular file formats to store and transfer relatively small
    amounts of data in academic institutions and businesses (besides CSV files) is
    still Excel `xls` (or `xlsx`, more recently). The first is a proprietary binary
    file format from Microsoft, which is exhaustively documented (the `xls` specification
    is available in a document of more than 1,100 pages and 50 megabytes!), but importing
    multiple sheets, macros, and formulas is not straightforward even nowadays. This
    section will only cover the most used platform-independent packages to interact
    with Excel.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在学术机构和商业领域，除了 CSV 文件外，存储和传输相对少量数据最流行的文件格式仍然是 Excel `xls`（或 `xlsx`，较新版本）。第一个是由微软拥有的二进制文件格式，它有详尽的文档（`xls`
    规范包含在一篇超过 1,100 页和 50 兆字节的文档中！），但即使现在导入多个工作表、宏和公式也不是一件简单的事情。本节将仅涵盖与 Excel 交互的最常用的平台无关的软件包。
- en: One option is to use the previously discussed `RODBC` package with the Excel
    driver to query an Excel spreadsheet. Other ways of accessing Excel data depend
    on third-party tools, such as using Perl to automatically convert the Excel file
    to CSV then importing it into R as the `read.xls` function from the `gdata` package.
    But installing Perl on Windows sometimes seems to be tedious; thus, `RODBC` might
    be a more convenient method on that platform.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用之前讨论过的 `RODBC` 软件包和 Excel 驱动程序来查询 Excel 工作表。访问 Excel 数据的其他方法依赖于第三方工具，例如使用
    Perl 自动将 Excel 文件转换为 CSV，然后使用 `gdata` 软件包中的 `read.xls` 函数将其导入 R。但在 Windows 上安装
    Perl 有时似乎很繁琐；因此，`RODBC` 在该平台上可能是一个更方便的方法。
- en: 'Some platform-independent, Java-based solutions also provide a way to not just
    read, but also write Excel files, especially to the `xlsx`, the Office Open XML
    file, format. Two separate implementations exist on CRAN to read and write Excel
    2007 and the 97/2000/XP/2003 file formats: the `xlConnect` and the `xlsx` packages.
    Both are actively maintained, and use the Apache POI Java API project. This latter
    means that it runs on any platform that supports Java, and there is no need to
    have Microsoft Excel or Office on the computer; both packages can read and write
    Excel files on their own.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基于 Java 的平台无关解决方案不仅提供读取 Excel 文件的方法，还提供写入 Excel 文件的方法，尤其是写入 `xlsx`，即 Office
    Open XML 格式。CRAN 上存在两个独立的实现来读取和写入 Excel 2007 以及 97/2000/XP/2003 文件格式：`xlConnect`
    和 `xlsx` 软件包。这两个软件包都在积极维护中，并使用 Apache POI Java API 项目。这意味着它可以在支持 Java 的任何平台上运行，无需在计算机上安装
    Microsoft Excel 或 Office；这两个软件包都可以独立读取和写入 Excel 文件。
- en: 'On the other hand, if you would rather not depend on Perl or Java, the recently
    published `openxlsx` package provides a platform-independent (C++-powered) way
    of reading and writing `xlsx` files. Hadley Wickham released a similar package,
    but with a slightly modified scope: the `readxl` package can read (but not write)
    both the `xls` and `xlsx` file formats.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你不想依赖 Perl 或 Java，最近发布的 `openxlsx` 包提供了一种平台无关的（由 C++ 驱动的）读取和写入 `xlsx`
    文件的方法。Hadley Wickham 发布了一个类似的包，但范围略有不同：`readxl` 包可以读取（但不能写入）`xls` 和 `xlsx` 文件格式。
- en: 'Remember: pick the most appropriate tool for your needs! For example to read
    Excel files without many external dependencies, I''d choose `readxl`; but, for
    writing Excel 2003 spreadsheets with cell formatting and more advanced features,
    probably we cannot save the Java dependency and should use the `xlConnect` or
    `xlsx` packages over the `xlsx`-only `openxlsx` package.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：根据你的需求选择最合适的工具！例如，为了读取没有许多外部依赖的 Excel 文件，我会选择 `readxl`；但是，对于需要单元格格式化和更多高级功能的
    Excel 2003 工作表，可能我们不能保存 Java 依赖，而应该使用 `xlConnect` 或 `xlsx` 包，而不是仅支持 `xlsx` 的 `openxlsx`
    包。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on some rather boring, but important tasks that we usually
    do every day. Importing data is among the first steps of every data science projects,
    thus mastering data analysis should start with how to load data into the R session
    in an efficient way.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了一些相当无聊但重要的任务，这是我们通常每天都会做的。导入数据是每个数据科学项目的第一步，因此掌握数据分析应该从如何在 R 会话中高效地加载数据开始。
- en: 'But efficiency is an ambiguous term in this sense: loading data should be quick
    in a technical point of view so as not to waste our time, although coding for
    long hours to speed up the importing process does not make much sense either.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个意义上，效率是一个模糊的概念：从技术角度来看，加载数据应该快速，这样我们才不会浪费时间，尽管长时间编码来加快导入过程也没有太多意义。
- en: The chapter gave a general overview on the most popular available options to
    read text files, to interact with databases, and to query subsets of data in R.
    Now you should be able to deal with all the most often used different data sources,
    and probably you can also choose which data source would be the ideal candidate
    in your projects and then do the benchmarks on your own, as we did previously.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了读取文本文件、与数据库交互以及查询 R 中的数据子集的最流行选项。现在你应该能够处理所有最常用的不同数据源，也许你还可以选择在你的项目中哪个数据源将是理想的候选者，然后像我们之前做的那样进行基准测试。
- en: The next chapter will extend this knowledge further by providing use cases for
    fetching data from the Web and different APIs. This simply means that you will
    be able to use public data in your projects, even if you do not yet have those
    in binary dataset files or on database backends.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过提供从网络和不同 API 获取数据的用例来进一步扩展这些知识。这意味着你将能够在你的项目中使用公共数据，即使你还没有那些二进制数据集文件或数据库后端。
