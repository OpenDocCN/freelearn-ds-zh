- en: Chapter 11. Web Analysis with GeoDjango
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a GeoDjango web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an indoor web routing service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing an indoor routing service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an indoor route-type service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an indoor route from room to room
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our final chapter is all about extending our analysis into a web application
    using the **Django** web framework. One of the standard Django contributed packages
    is known as **GeoDjango** and is found in the `django/contrib/gis` package. This
    is a feature-packed GIS toolset for geospatial web application development. The
    spatial libraries used here depend on the spatial database backend that you choose.
    For PostgreSQL the library requirements include GEOS, PROJ.4, and PostGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Django is known for its good documentation and the `gis contrib` package installation
    is no exception, having its own set of instructions for you to follow at [https://docs.djangoproject.com/en/dev/ref/contrib/gis/](https://docs.djangoproject.com/en/dev/ref/contrib/gis/).
  prefs: []
  type: TYPE_NORMAL
- en: Since GeoDjango is part of the standard Django installation, you will see that
    your first step is to install the Django framework. For any reference on installing
    GeoDjango, PostgreSQL, and PostGIS, take a look at [Chapter 1](ch01.html "Chapter 1. Setting
    Up Your Geospatial Python Environment"), *Setting Up Your Geospatial Python Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a GeoDjango web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to get some basic Django groundwork done and this will be a very high-level
    fly over at setting up the required basics to start a Django web application.
    Check out the official Django tutorials for further information at [https://docs.djangoproject.com/en/dev/intro/tutorial01/](https://docs.djangoproject.com/en/dev/intro/tutorial01/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not familiar with Django or GeoDjango, I would highly recommend that
    you read through and complete the online tutorials, starting with Django at [https://docs.djangoproject.com/en/dev/](https://docs.djangoproject.com/en/dev/)
    followed by the GeoDjango tutorial at [https://docs.djangoproject.com/en/dev/ref/contrib/gis/tutorial/](https://docs.djangoproject.com/en/dev/ref/contrib/gis/tutorial/).
    For this chapter, it is assumed that you are familiar with Django, have completed
    the entire online Django tutorial, and are, therefore, familiar with Django concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to build a routing web service using the *Django REST framework*
    ([http://www.django-rest-framework.org/](http://www.django-rest-framework.org/)).
    All that we need to implement is a basic web service that you can install with
    the help of `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install version 3.1.3, the latest version. If you want to install
    the newest version, simply enter the following command but, beware, it might not
    work with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now create a Django project using the `django-admin` tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, enter the `/ch11/code` directory and execute this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you will have a `/ch11/code/web_analysis/web_analysis` directory and inside
    it, you'll find all the standard basic Django components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create our web service, we are going to place all the services into a Django
    App called `api`. This app will store all our services. Creating this `api` application
    is as easy as typing this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change into the newly created `web_analysis` directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now create your new application called "api".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This creates a new `/ch11/code/web_analysis/api` folder and inside it you will
    find the default installed Django app files. Next, we need to tell Django about
    the Django REST Framework, GeoDjango gis app, and our new `api` application; we
    do this in our `/ch11/code/web_analysis/web_analysis/settings.py` file. Let''s
    add the lines `''django.contrib.gis''`, `''rest_framework''`, and `''api''` to
    our `INSTALLED_APPS` variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable the GeoDjango spatial models and spatial capabilities, `''django.contrib.gis''`
    will allow us to access the rich geospatial framework. We have it commented out
    at this point since we are not going to use it until later, but feel free to uncomment
    it as this will do no harm. This spatial framework requires a spatial database
    and we will use PostgreSQL with PostGIS as our backend. Let''s go ahead and change
    the database connection now in our `settings.py` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The database here is referencing the same *PostgreSQL + PostGIS* database that
    we created earlier on in [Chapter 3](ch03.html "Chapter 3. Moving Spatial Data
    from One Format to Another"), *Moving Spatial Data from One Format to Another*.
    Visit the *Converting a Shapefile to a PostGIS table using ogr2ogr,* recipe in
    [Chapter 3](ch03.html "Chapter 3. Moving Spatial Data from One Format to Another"),
    *Moving Spatial Data from One Format to Another* where we created the `py_geoan_cb`
    database, if you are going to skip ahead to this section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our final `settings.py` configuration is set up to log errors and exceptions
    to a log file, catching errors if any occur. First up, we''ll create a new folder
    called `/web_analysis/logs` and add two new files called `debug.log` and `verbose.log`.
    We will write any errors that occur into these two files and log a request or
    simply print out an error to these files. So, go ahead and copy this code into
    the bottom of your `/web_analysis/web_analysis/settings.py` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, let''s create a new database user and a separate PostgreSQL schema
    to store all our Django-related tables; otherwise, all the new Django tables will
    automatically be created in the PostgreSQL default schema public. Our new user
    is called `saturn` and can log in with the `secret` password. To create a new
    user, you can use the command-line tool that''s run as the `postgres` user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also use the PGAdmin free tool. On Ubuntu, don't forget to change to
    the `postgres` user that will allow you to create a new user on your database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s create a new schema called `django` that will store all our Django
    application tables. Use PGAdmin or the SQL command to do this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this new schema in place, we only need to assign the PostgreSQL `search_path`
    variable order to set the `django` schema as the first priority. To accomplish
    this, we need to use the SQL `ALTER ROLE` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets the `search_path` order defining `django` as the first schema, `geodata`
    as the second, and so forth. This order is for all database connections for the
    `saturn` user. When we create our new Django tables, all of them will now automatically
    be created inside the `django` schema.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go ahead now and initialize our Django project and create all the tables
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The built-in Django `manage.py` command calls the `migrate` function and performs
    the sync in one go. Next, let''s create a superuser for our application who can
    login and have full control of the entire web application. Then, follow the command-line
    instructions to enter the username, e-mail, and password as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With all these steps now completed, we are ready to actually get something
    done and build our online routing application. To test whether everything is working,
    run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open up your local web browser and see the welcome Django default page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an indoor web routing service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take all the effort we put into [Chapter 8](ch08.html "Chapter 8. Network
    Routing Analysis"), *Network Routing Analysis*, out onto the World Wide Web. Our
    routing service will simply accept a starting point location, an *x*, *y* coordinate
    pair, a floor level, and a destination location. The indoor routing service will
    then calculate the shortest path and return a complete route in the form of a
    GeoJSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To layout the tasks ahead, let''s list out what we need to accomplish at a
    high level so that we''re clear about where we are going:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a URL pattern to call a route service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build a view to handle an incoming URL request and deliver the appropriate
    GeoJSON route web response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept incoming request parameters.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Start *x* coordinate.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Start *y* coordinate.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Start floor number.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: End *x* coordinate.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: End *y* coordinate.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: End floor number.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Return GeoJSON LineString.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Route geometry.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Route length.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Route walk time.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to let our new database user named `saturn` in order to have access
    to the tables located in the PostgreSQL geodata schema created in [Chapter 8](ch08.html
    "Chapter 8. Network Routing Analysis"), *Network Routing Analysis*. Currently,
    only the user named `postgres` is the owner and almighty one. This needs to change
    so that we can keep on trucking without needing to recreate our tables as created
    in [Chapter 8](ch08.html "Chapter 8. Network Routing Analysis"), *Network Routing
    Analysis*. So, let''s go ahead and simply make the `saturn` user the owner of
    each of these tables as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are looking for a way to allow both the `saturn` user and any other
    user to gain access to these tables, you could create a PostgreSQL group role
    and assign the user to this role as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our code is now in one folder in a structure that''s common to all Django web
    projects, so following these steps should be straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by wiring up our new URL. Go ahead and open up the `urls.py` file
    inside your `ch11/code/web_analysis/` folder. Inside the file, you will need to
    enter the main URL configuration for our new web page. This file was automatically
    created when we created the project. Django fills in some helper text, as you
    can see, that shows you some basic configuration options. We need to add the `admin`
    app, which we will use later, and the URL for our new API. The API application
    will have its very own URL configuration file as you can see in the `api.urls`
    references, which we will create next. The `/web_analysis/urls.py` file should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, let''s create the `/web_analysis/api/urls.py` api URLs. This file
    is not automatically generated so we''ll create this file now. The content of
    this `/api/urls.py` file will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The regular expression looks wild as most regular expressions do. If you need
    some help understanding it, try referring to [https://regex101.com/#python](https://regex101.com/#python).
    Go ahead and paste this regular expression in the regular expression field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test your URL string, simply paste this text in the **TEST STRING** field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If it's lit up in some funky colors, you are good to go:![How to do it...](img/50790OS_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Django''s use of regular expressions for URL configuration is quite handy but
    not always obvious and explicit to read. Our URL is explained in a textual manner
    and would read like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a real example from your development machine. When calling the URL,
    it will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The start and end location information is separated with an `&` symbol, while
    the contents of each start parameter and end parameter are separated by a comma.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Going forward, in terms of complexity, we now need to enter the logic part of
    our API. Django handles this in the views. Our `/web_analysis/api/views.py` code
    contains the code to handle the request and response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The main `def create_route` function should look familiar as it is taken directly
    from [Chapter 8](ch08.html "Chapter 8. Network Routing Analysis"), *Network Routing
    Analysis,* with some modifications. A new `helper` function is created called
    `find_closest_network_node`. This new function is more robust and faster than
    our previous SQL that we used to find the node closest to any given *x*, *y* coordinate
    entered by a user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting API call has a nice web interface that's automatically generated
    by the **Django REST Framework** as shown in the following screenshot. The URL
    you need to call is also shown and should return a GeoJSON result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/50790OS_11_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The following URL will return GeoJSON to your browser; in Chrome, it will normally
    just show up as simple text. IE users may download it as a file by simply opening
    it in Notepad++ or a local text editor to see the contents of GeoJSON:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our view handles the request and response using the Django REST Framework.
    There are two functions that do all the hard work without ever using the Django
    **Object Relational Mapper** (**ORM**). The reason for this is two-fold: first,
    to show you the basics of direct Database usage without too much abstraction and
    the inner workings of what is going on; second, because we are using functions
    of PostGIS that are not available directly through the ORM of GeoDjango, such
    as `ST_3DDistance` or `ST_PointFromText`. We could use some of the fancy Django
    helpers, such as `.extra()`, but this would confuse everyone but an experienced
    Django user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the first `find_closest_network_node` function that takes three
    parameters: `x_coord`, `y_coord`, and `floor`. The *x* and *y* coordinates should
    be double precision float values, while the floor is an integer. Our regular expression
    URL limits any request to digits so there is no need to do any extra format checking
    in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL query that finds the nearest node and returns its ID limits the search
    radius to 200 m, which would equal one huge room or auditorium. Then, we order
    by the 3D distance between the points and `LIMIT` the result to one since we are
    not routing to multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: This feeds our second function called `create_route` where we pass it the start
    coordinate, start floor integer, end coordinate, and end floor number. Our URL
    at `/web_analysis/api/urls.py` uses a regular expression named `groups` that corresponds
    to the same names used in the request parameters of our function. This keeps things
    more explicit so that you know what values belong where in a query.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with parsing the incoming parameters to get the exact values as floats
    and integers to feed our routing query. The routing query itself is unchanged
    from [Chapter 8](ch08.html "Chapter 8. Network Routing Analysis"), *Network Routing
    Analysis,* so refer to this chapter for more details. The Django REST framework
    response sends the GeoJSON back to the client and has the ability to return it
    as raw text as well.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing an indoor routing service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our wonderful API created, it's time now to visualize this indoor route
    returned as GeoJSON on a map. We will now dive into the Django template components
    to create the HTML, JS, and CSS for our front-facing web page that displays a
    simple slippy web map using Openlayers 3.4.0\. and Bootstrap CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Our new web map will display the GeoJSON on the map with a nice style alongside
    a menu bar where we will include later functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing an indoor routing service](img/50790OS_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to build a few new folders and files to store new static and template
    content for our Django web application. Let's begin doing this by creating the
    `/web_analysis/templates` folder followed by the `/web_analysis/static` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our `/static/` folder, we will place the nondynamic content of the JavaScript
    and CSS files. The `/templates/` folder will store the HTML template files used
    to create our web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let''s tell Django `/web_analysis/settings.py` about the location
    of our new templates folder; add the `os.path.join(BASE_DIR, ''templates'')` value
    to the `''DIRS''` key shown here so that the `TEMPLATES` variable looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To manage our maps, lets create a new Django application called `maps` where
    we can store all our map information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, register your new app in the `/web_analysis/web_analysis/settings.py INSTALLED
    APPS` variable by adding this under the `api` entry `'maps'`, under the entry
    `'api'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/maps/urls.py` file is not automatically created so let''s do this now
    and fill in some content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We need to assign `maps/urls.py` within our main `/web_analysis/web_analysis/urls.py`
    so that we can freely create any URL for all our mapping needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this line to the `/web_analysis/web_analysis/urls.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This means that all the URL's inside our `/maps/urls.py` will start with `http://localhost:8000/maps/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to set up the static files and static contents inside `settings.py`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have the following folders and files now in the `/static/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This should be enough to set up your Django project in order for it to serve
    up a static map.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually serving up the map requires us to create an HTML page. We use the built-in
    Django template engine to build two HTML pages. The first page template is `base.html`
    that will hold the basics of our web map page, making it a very important part
    of our frontend design. What's included in this page is a set of block tags, each
    for separate content place holders. This allows us to quickly create new map pages
    based on our base template, which sets up our basic template architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `/templates/base.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s move on to the actual map. A new template called `/templates/route-map.html`
    contains all the actual Django template blocks that are filled with HTML content
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our application to actually show these templates, we need to create a view.
    The view handles the request and serves `route-map.html` in return. Now, our simple
    view is complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with the `base.html` template, we set out the basic building blocks
    for map making. The static files and resources were set up to handle serving our
    JavaScript and CSS code. The `base.html` file is designed to allow us to add elements
    that are shared between multiple HTML pages such as a master page in Microsoft
    PowerPoint. The more blocks, that is, place holders, the better your base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `route-map.html` contains the actual code referencing our `api` by calling
    it with a predefined, hardcoded from, `to URL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `/maps/views.py` code is where any map logic, variables, or parameters are
    passed around to the template. In our code, we simply take in a request and return
    an HTML page. Now you have a rudimentary indoor routing service and visualization
    client to show off to your friends.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an indoor route-type service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a route based on a specified type value, such as a **Barrier Free
    Route** or **Standard Pedestrian Route** value, is great for your users. How to
    build different route types is based on the available data connected to our indoor
    graph of ways. This example will allow a user to select the barrier-free route
    and our service will generate a path, avoiding obstacles such as stairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an indoor route-type service](img/50790OS_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to access some more data on our network to allow routing types. The
    type of route is based on a network line type, which is stored as an attribute
    on each LineString. To classify our route types, we have the following lookup
    table schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Route type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | Indoor route |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | Outdoor route |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | Elevator |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | Stairs |'
  prefs: []
  type: TYPE_TB
- en: Therefore, we want to avoid any stairs segments, which technically means avoiding
    `type_id = 3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optionally, you could create a lookup table to store all the possible types
    and their equivalent weights. These values could then be included in the calculation
    of the total cost value to influence the route outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can control how the route is generated based on certain preferences
    as well. A standard route search can now be set for preferences, such as taking
    the stairs over the elevator or vice versa, depending on your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you update `geodata.networklines_3857`, make sure the user `saturn` is the
    owner or has access; otherwise, your API call will break.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The least-cost path from any point is controlled by a basic property called
    `cost`. For a standard route, the cost is equal to the distance of a segment.
    We search for the least-cost path, which means finding the shortest path to our
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: To control the path, we set the cost values. Creating a barrier-free route involves
    setting all segment types equal to `stairs` at an extraordinarily high value so
    that the path, that is, the distance, is huge and is, therefore, excluded in the
    shortest path route finding process. Our other option is to add a `WHERE` clause
    to the query and only accept values where `type_id` is not equal to `3`, which
    means that it is not of the type `stairs`. We are going to use this option in
    our upcoming code.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore our data needs to be clean in order to allow us to assign specific
    costs to specific segment types in our network lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add a new parameter to capture the route type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll update the `/api/views.py` function, `create route()`, and add a new
    parameter called `route_type`. Next up is the actual query that needs to accept
    this new parameter. We set up a new variable called `barrierfree_q` to hold the
    `WHERE` clause that we will add to our original query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll update our `/api/urls.py` to input our new URL parameter, `route_type`.
    The newly added named group regular expression is naturally called `route_type`
    and only accepts numbers from 0 to 9\. This then, of course, also limits you to
    10 route types. So, if you want to add more types, you will need to update your
    `regex` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `/maps/views.py` function needs a facelift too so that we can pass in the
    parameters. Now, it will accept `route_type` as defined in our `/api/urls.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s time to update `route-map.html` to include radio buttons that allow a
    user to select either a **Standard Route** or **Barrier Free Route**. The map
    will then update the route as soon as you click on the route type radio button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our results for `type = 0` or a route using stairs should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/50790OS_11_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The barrier-free route will use `type = 1`, which means forced elevator use
    and avoiding all stairs. Your result should then look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/50790OS_11_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main part to understand here is that we need to add an option route type
    to our API call. This API call must accept a specific route type that we have
    defined as a number from 0 to 9\. This route type number is then passed to our
    URL as a parameter and `api/views.py` runs the call. The API then generates a
    new route based on the route type.
  prefs: []
  type: TYPE_NORMAL
- en: All our changes are made inside the `/api/view.py` code that now includes a
    SQL `WHERE` clause and excludes `networklines` with a `type_id = 3`—that is, `stairs`.
    This query change keeps our app fast without actually increasing any Django middleware
    code in our views.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend needs the user to select a route type with the default route type
    set to a standard value, such as `0`, as in the case of `stairs`. This default
    type is used because in most indoor environments the stairs are usually shorter.
    You can, of course, change this default to whatever value or criteria you'd like
    at any time. A radio select box is used to restrain the choice to either a standard
    route or a barrier-free route. Upon selecting a route type, the map automatically
    removes the old route and creates a new route.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an indoor route from room to room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing from room A to room B in an indoor routing web application over multiple
    floors with routing types brings together all our work up to this point. We will
    import some room data and utilize our network to then allow a user to select a
    room, route from one room to the next, and select a type of route.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an indoor route from room to room](img/50790OS_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to import a set of room polygons for both the first and second floor
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import a Shapefile of the first floor room polygons as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import a Shapefile of the second floor room polygons as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new PostgreSQL view to merge all the new room data into one table
    so that we can query all the rooms at once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow a user to route from A to B, we need to enable a route from a field
    and a route to a field, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new URL to accept the new parameter of the start and end room number.
    The first URL for example will look like `http://localhost:8000/api/directions/10010&20043&0`,
    which means that the route from room number `10010` to room number `20042` using
    the standard route type equals to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second URL is an extra function that you can call to only return the center
    coordinate of a room when you pass in the room number like this: `http://localhost:8000/directions/10010`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This function in the view *does not exist* and is left for you to do as homework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build a new `/api/views.py` function to find a room center coordinate and return
    the nearest node on `networklines` to this coordinate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the function inside `/api/views.py` to accept a start node ID, end node
    ID, and a route type that will then return a GeoJSON of the final route as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At last, we can create a function that our API will call to generate a response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a URL to `/api/urls.py` to access a list of all available rooms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an API service to return a JSON array of all room numbers. This array
    is used in autocomplete fields, `route-from`, and `route-to`. We use the Twitter
    `Typeahead.js` JavaScript library to handle our autocomplete dropdown type hinting.
    As a user, all you need to do is type 1, for example, and all the rooms beginning
    with 1 will show up as `10010` (check this out at [http://twitter.github.io/typeahead.js/examples/](http://twitter.github.io/typeahead.js/examples/)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our final `base.html` template is complete, containing all the spice needed
    for our final route from room to room as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''ll create our final `route-map.html` template and the JavaScript that
    goes with it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `maps/templates/routing.js` contains the functions needed to call the routing
    API as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, go ahead and enter `1` and see the autocomplete in action; then, select
    **Route To:** and enter `2` to see the second floor options. Finally, click on
    **GO!** and see the magic happen:![How to do it...](img/50790OS_11_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The internal workings of each step are shown, so let's go through all of them
    one at a time. We start off with the data import of our new room dataset as the
    basic starting and ending points of our new indoor routing tool. We lay out the
    top-level structure of our API with some new URLs, defining how we will call the
    new routing service, and then define these variables. Our regular expressions
    handle the correct data types that are passed in the URL without any exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: These URL patterns are then used by `api/views.py` to actually accept the incoming
    room numbers and route types to generate our new route. This generation is split
    up into a few functions to increase usability. The `get_room_centroid_node()`
    function is necessary so that we can find the middle point of the room and then
    find the next nearest node on a network. We could also simply use the polygon
    geometry to find the nearest node but this can lead to ambiguity if the rooms
    are large and the entrances are close to each other. The `centroid` method is
    much more reliable and does not add too much overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The `run_route()` function actually then runs `find_closest_network_node()`,
    which we created earlier, making things work well together. The `run_route` function
    then generates our GeoJSON result as it is passed in the start node ID, end node
    ID, and the route type.
  prefs: []
  type: TYPE_NORMAL
- en: The `route_room_to_room()` function is small as the heavy lifting has already
    been completed by our other functions. It simply inputs the URL parameters called
    by our API call, as seen in `http://localhost:8000/api/directions/10010&20043&0`.
    The final steps after step 6 are for the user interface. We need to provide the
    user with a list of rooms that are available to route from and to. The /`api/rooms`
    URL provides exactly this, delivering a JSON array of room numbers. The input
    fields are bootstrap inputs with Twitter `Typeahead.js` and `Bloodhound.js` to
    prefetch remote data. As a user, you simply enter a number and, bingo, a list
    appears. More detailed instructions on the JavaScript side of things are a little
    beyond the scope of this book, but these are, thankfully, kept to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, you now have a fully functional indoor mapping web application with
    a basic set of indoor 3D routing functions that you can expand on at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Other Geospatial Python Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered many libraries and examples but we haven't covered them all.
    This appendix is meant to quickly go over the other libraries out there that play
    a special role in the Python geospatial working environment. This list is definitely
    not complete and I have not had the pleasure of working with all these libraries
    at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing is a resource for further reading and experiments that will, hopefully,
    provide you with a step in the right direction to solve your specific problems.
    Each description of a library starts with the official library name followed by
    a short description and a link to the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Library name | Description | Website |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Rtree | This is a Python wrapper of `libspatialindex` that provides advanced
    spatial indexing features | [http://toblerity.org/rtree](http://toblerity.org/rtree)
    |'
  prefs: []
  type: TYPE_TB
- en: '| rasterio | This is a Mapbox creation that aims at working with rasters in
    an easier manner | [https://github.com/mapbox/rasterio](https://github.com/mapbox/rasterio)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Fiona | This focuses on reading and writing data in the standard Python I/O
    style | [http://toblerity.org/fiona](http://toblerity.org/fiona) |'
  prefs: []
  type: TYPE_TB
- en: '| geopy | This helps geocoding in Python | [http://www.geopy.org](http://www.geopy.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PyQGIS | This is the Python interface to QGIS (formerly known as Quantum
    GIS) that helps extend QGIS and more | [http://pythongisbook.com](http://pythongisbook.com)
    |'
  prefs: []
  type: TYPE_TB
- en: '| GeoPandas | This is an extension of the pandas library and handles geospatial
    database | [http://geopandas.org/](http://geopandas.org/) |'
  prefs: []
  type: TYPE_TB
- en: '| MapFish | This is Python''s geospatial web framework | [http://mapfish.org](http://mapfish.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PyWPS | This client interacts with various open geospatial standard services
    | [http://pywps.wald.intevation.org](http://pywps.wald.intevation.org) |'
  prefs: []
  type: TYPE_TB
- en: '| pycsw | This provides a metadata catalog interface | [http://pycsw.org](http://pycsw.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| GeoNode | This provides Python geospatial content management for the Web
    and is built on the Django web framework and GeoServer | [http://geonode.org](http://geonode.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| mapnik | This is a map visualization library to create maps for web tile
    cache | [http://mapnik.org](http://mapnik.org) |'
  prefs: []
  type: TYPE_TB
- en: '| cartopy | This is mapping made easy in Python-shapely | [http://scitools.org.uk/cartopy](http://scitools.org.uk/cartopy)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Kartograph | This creates SVG maps or web maps | [http://kartograph.org](http://kartograph.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| basemap | This is an extension of matplotlib in combination with descartes
    | [http://matplotlib.org/basemap](http://matplotlib.org/basemap) |'
  prefs: []
  type: TYPE_TB
- en: '| SciPy | This is a collection of Python libraries for scientific data analysis
    that are bundled or available as individual installations | [http://www.scipy.org](http://www.scipy.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| GeoAlchemy | This is a spatial extension to SQLAlchemy that works with the
    spatial database PostGIS | [http://geoalchemy.org](http://geoalchemy.org) |'
  prefs: []
  type: TYPE_TB
- en: '| pyspatialite | This helps you work with spatialite databases of geospatial
    data | [https://pypi.python.org/pypi/pyspatialite](https://pypi.python.org/pypi/pyspatialite)
    |'
  prefs: []
  type: TYPE_TB
- en: '| gpxpy | This helps when working with GPS data in the standard GPX format
    in a Python - friendly format | [http://www.trackprofiler.com/gpxpy/index.html](http://www.trackprofiler.com/gpxpy/index.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ShaPy | This is a pure Python version of Shapely with no dependencies | [https://github.com/karimbahgat/Shapy](https://github.com/karimbahgat/Shapy)
    |'
  prefs: []
  type: TYPE_TB
- en: '| pyshp | This reads and writes Shapefiles in pure Python | [https://github.com/GeospatialPython/pyshp](https://github.com/GeospatialPython/pyshp)
    |'
  prefs: []
  type: TYPE_TB
- en: '| TileCache | This is an implementation of a WMS-C (catalog) **Tile Mapping
    Server** (**TMS**) server | [http://tilecache.org](http://tilecache.org) |'
  prefs: []
  type: TYPE_TB
- en: '| TileStache | This is a Python-based server application that can serve up
    map tiles based on rendered geographic data | [http://www.tilestache.org](http://www.tilestache.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| FeatureServer | This is a restful feature service to easily get, edit, delete,
    and update features over the Web with the help of HTTP | [http://featureserver.org](http://featureserver.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| GeoScript | This is an implementation of Python, giving spatial analysis
    functionality to other scripting languages and Python is one of them; it is similar
    to Shapely | [http://www.geoscript.org](http://www.geoscript.org) |'
  prefs: []
  type: TYPE_TB
- en: '| karta | This is a Leatherman for geographic analyses | [http://ironicmtn.com/karta](http://ironicmtn.com/karta)
    |'
  prefs: []
  type: TYPE_TB
- en: Appendix B. Mapping Icon Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finding the perfect mapping icon set is hard. The following list provides some
    of the better map symbols around, for your web map application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Library name | Description | Website |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| map-icons | This is an icon font that''s used with the Google Maps API and
    Google Places API using SVG markers and icon labels | [http://map-icons.com/](http://map-icons.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Maki | This creates Mapbox Pixel-perfect icons for web cartography | [https://www.mapbox.com/maki](https://www.mapbox.com/maki)
    |'
  prefs: []
  type: TYPE_TB
- en: '| map icons | This focuses on reading and writing data in the standard Python
    IO style | [https://mapicons.mapsmarker.com/](https://mapicons.mapsmarker.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Integration and Application Network | This creates 2782 custom vector symbols
    | [http://ian.umces.edu/symbols/](http://ian.umces.edu/symbols/) |'
  prefs: []
  type: TYPE_TB
- en: '| OSM icons | This is a set of free SVG icons that are used for OSM maps |
    [http://osm-icons.org/wiki/Icons](http://osm-icons.org/wiki/Icons) |'
  prefs: []
  type: TYPE_TB
- en: '| OSGeo map symbol set | This is a collection of links to map icons | [http://wiki.osgeo.org/wiki/OSGeo_map_symbol_set](http://wiki.osgeo.org/wiki/OSGeo_map_symbol_set)
    |'
  prefs: []
  type: TYPE_TB
- en: '| SJJB collection | This is a set of PD/CC0 SVG map icons and tools to generate
    PNG icons | [https://github.com/twain47/Open-SVG-Map-Icons](https://github.com/twain47/Open-SVG-Map-Icons)
    and [http://www.sjjb.co.uk/mapicons/contactsheet](http://www.sjjb.co.uk/mapicons/contactsheet)
    |'
  prefs: []
  type: TYPE_TB
- en: '| OSM map-icons | This creates an OpenStreetMap set of icons | [https://github.com/openstreetmap/map-icons/tree/master/svg](https://github.com/openstreetmap/map-icons/tree/master/svg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| opensreetmap-carto | Andy Allan created these set of mapping icons in PNG
    | [https://github.com/gravitystorm/openstreetmap-carto/tree/master/symbols](https://github.com/gravitystorm/openstreetmap-carto/tree/master/symbols)
    |'
  prefs: []
  type: TYPE_TB
