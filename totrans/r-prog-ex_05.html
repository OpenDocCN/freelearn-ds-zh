<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Communicating Sales with Visualizations</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we will explore a very important and useful aspect of data analysis, data visualization. We will show how to create graph functions, which are the functions that encapsulate the process of creating a graph and output a graph object that can be seen or saved to disk. Working with graphs this way increases efficiency, adds flexibility, and provides repeatable processes.</p>
<p class="calibre2">The types of graphs we will create during this chapter include bar graphs, boxplots, scatter plots with marginal distributions, radar graphs, 3D interactive scatter plots, time-series graphs, static and interactive maps, and a cool globe visualization. The chapter will show the fundamentals you need to create a great variety of high-quality graphs.</p>
<p class="calibre2">Some of the important topics covered in this chapter are as follows:</p>
<ul class="calibre11">
<li class="calibre12">Working efficiently with graph functions and graph objects</li>
<li class="calibre12">Working with important graphing packages such as <kbd class="calibre9">ggplot2</kbd> and <kbd class="calibre9">leaflet</kbd></li>
<li class="calibre12">Data transformations to accommodate different visualizations</li>
<li class="calibre12">Graph generalization through variable parameterization</li>
<li class="calibre12">Increasing dimensions shown with colors and shapes</li>
<li class="calibre12">Extending <kbd class="calibre9">ggplot2</kbd> with custom graph types</li>
<li class="calibre12">Numerical data exploration with interactive graphs</li>
<li class="calibre12">Geographical data exploration with interactive maps</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Required packages</h1>
                
            
            <article>
                
<p class="calibre2">During this chapter we will make use of the following R packages. If you don't already have them installed, you can look into <a href="part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730" class="calibre4">Appendix</a><em class="calibre19">, Required Packages </em>for instructions on how do so. These packages will fall in one of two categories: packages for creating graphs and packages for working with data. Some of the packages used for interactive graphs (graphs that are not static, meaning you can <em class="calibre19">move them around</em> in your screen to see different angles of the data) will require system dependencies to work (for example, <kbd class="calibre9">rgl</kbd> and <kbd class="calibre9">rgdal</kbd>), and others will work through your web browser (for example, <kbd class="calibre9">threejs</kbd>, <kbd class="calibre9">leaflet</kbd>, and <kbd class="calibre9">plotly</kbd>). They have been tested using Google Chrome as a web browser. If you encounter any problems with your particular web browser, try using Google Chrome. The <em class="calibre19">static</em> graphics will be created using <kbd class="calibre9">ggplot2</kbd> and some packages that extend it (for example, <kbd class="calibre9">viridis</kbd> and <kbd class="calibre9">ggExtra</kbd>).</p>
<table class="calibre5">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Package</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Reason</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">ggplot2</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2"><span> High-quality graphs</span></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">viridis</kbd> </p>
</td>
<td class="calibre8">
<p class="calibre2"><span>Color palette for graphs</span></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">ggExtra</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2"><span>Graphs with marginal distributions</span></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">threejs</kbd> </p>
</td>
<td class="calibre8">
<p class="calibre2"><span>Interactive globe</span></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">leaflet</kbd> </p>
</td>
<td class="calibre8">
<p class="calibre2"><span>Interactive high-quality maps</span></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">plotly</kbd> </p>
</td>
<td class="calibre8">
<p class="calibre2"><span>Interactive high-quality graphs</span></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">rgl</kbd> </p>
</td>
<td class="calibre8">
<p class="calibre2"><span>Interactive 3D graphs</span></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">rgdal</kbd> </p>
</td>
<td class="calibre8">
<p class="calibre2"><span>Manipulating geographic data</span></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">tidyr</kbd> </p>
</td>
<td class="calibre8">
<p class="calibre2"><span>Manipulating data</span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Extending our data with profit metrics</h1>
                
            
            <article>
                
<p class="calibre2">As mentioned earlier, our objective for this chapter is to diagnose the current state of business and find new opportunities. To start with, we will look at three business metrics from different angles. The metrics are number of sales, profits, and profit ratios. They tell us how much The Food Factory is selling in quantity, how much it's earning in money (profit), and where it's growth opportunities are (profit ratio). Keep in mind that this is not a professional financial assessment and, as always, the focus is on the programming techniques not the actual results from the analysis.</p>
<p class="calibre2">The first thing we need to do is add to each sale its corresponding profits and profit ratio. We assume that the only way we can count a profit is if the sale order has been delivered and has been paid. Otherwise, we'll state the profit and profit ratio as zero. If the sale qualifies for a profit, then the profit calculation is <em class="calibre19">PROFIT = PRICE - COST - DISCOUNT</em>. Note that this allows for sales that are not profitable (The Food Factory loses money) if the <em class="calibre19">COST + DISCOUNT &gt; PRICE</em>. If there's a profit, then the profit ratio is <em class="calibre19">PROFIT / COST</em>. What we just described is programmed inside the <kbd class="calibre9">add_profits()</kbd> function:</p>
<pre class="mce-root">add_profits &lt;- function(data) {<br class="title-page-name"/>    unprofitable &lt;- c("RETURNED", "CANCELLED", "PENDING")<br class="title-page-name"/>    data$PROFIT &lt;- data$PRICE - data$COST - data$DISCOUNT<br class="title-page-name"/>    data$PROFIT[data$STATUS %in% unprofitable] &lt;- 0<br class="title-page-name"/>    data$PROFIT[data$PAID == "NO"] &lt;- 0<br class="title-page-name"/>    data$PROFIT_RATIO &lt;- data$PROFIT / data$COST<br class="title-page-name"/>    return(data)<br class="title-page-name"/>}</pre>
<p class="calibre2">After defining the <kbd class="calibre9">add_profit()</kbd> function, we simply apply it to our sales data as follows:</p>
<pre class="mce-root">sales &lt;- add_profits(sales)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building blocks for reusable high-quality graphs</h1>
                
            
            <article>
                
<p class="calibre2">To diagnose the business state and find new opportunities, in this chapter, we will use various types of graphs. When it comes to developing static high-quality graphs, you can't go wrong with the <kbd class="calibre9">ggplot2</kbd> package. Standard (built-in) graphs in R are fine for exploratory purposes, but are not as flexible or nice-looking as <kbd class="calibre9">ggplot2</kbd> graphs. Since we want to show how to create high-quality graphs, we will focus on using this package (and others extending it) for static graphs. However, since the vanilla <kbd class="calibre9">ggplot2</kbd> package only works for static graphs, we will use other packages for high-quality interactive graphs.</p>
<p class="calibre2">A downside of having so much flexibility when using <kbd class="calibre9">ggplot2</kbd> is that it's very verbose, thus requiring a lot of code to create graphs (specially when compared to standard R built-in graphing functions). We want to avoid having to copy-paste code if we are going to create similar graphs, so we will develop reusable functions that we can use to easily create similar graphs. For example, we could do something like the following instead of repeating more than 10 lines of <kbd class="calibre9">ggplot2</kbd> code to only make a few small changes:</p>
<pre class="mce-root">graph_1 &lt;- a_function_that_returns_a_graph_object(<br class="title-page-name"/>    data_1, other_parameters_1)
print(graph_1)

graph_2 &lt;- a_function_that_returns_a_graph_object(<br class="title-page-name"/>    data_2, other_parameters_2)
print(graph_2)</pre>
<p class="calibre2">Sometimes, people are not comfortable working this way, but these graphing functions are just the same as any other kind of function. The only difference is that, whenever we can, we will return a graph object instead of other data types. These graph objects are a nice feature when working with <kbd class="calibre9">ggplot2</kbd> because they can't be passed to other functions (not all graphing packages are designed this way). For example, while writing this book, we used the following <kbd class="calibre9">save_png()</kbd> function, which takes a graph object and saves it to disk. All we needed it to do was to optionally change a graph's dimensions when we saved it to make sure that it's the right size:</p>
<pre class="mce-root">save_png &lt;- function(graph, save_to, width = 480, height = 480) {<br class="title-page-name"/>    png(save_to, width = width, height = height)<br class="title-page-name"/>    print(graph)<br class="title-page-name"/>    dev.off()<br class="title-page-name"/>}</pre>
<div class="packt_tip">If you're working with lots of graphs, if you get an error while creating one of them and you print it, you may be confused to see a previous graph you were working on. To avoid this confusion, you may execute <kbd class="calibre21">graph &lt;- NULL</kbd> after every print or save function call to make sure that it's evident where the error occurred.</div>
<p class="calibre2">Now if you want to create a graph and save it into a 1024x768 pixels image, you can use the <kbd class="calibre9">save_png()</kbd> function as follows:</p>
<pre class="mce-root">graph &lt; a_function_that_returns_a_graph_object(data, parameters)
save_png(graph, 1024, 768)</pre>
<p class="calibre2">The standard way of developing analyzing data is an iterative process closely related to the scientific method. However, we will only focus on the code that generates the graphs during this chapter. We will interpret the results in <a href="part0147.html#4C62M0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 7</a>, <em class="calibre19">Developing Automatic Presentations</em>. We think this helps focus on each topic adequately in it's corresponding chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Starting with simple applications for bar graphs</h1>
                
            
            <article>
                
<p class="calibre2">We will start with simple graphs and build our way up towards advanced graphs. The first graph we will create is a bar graph. We will plot a frequency table that shows how many sale orders we have for each <kbd class="calibre9">QUANTITY</kbd> number in our sales. To do so, we use the <kbd class="calibre9">ggplot()</kbd> function using <kbd class="calibre9">sales</kbd> as the data and setting up the aesthetics with the <kbd class="calibre9">aes()</kbd> function with <kbd class="calibre9">QUANTITY</kbd> in the <em class="calibre19">x</em> axis (the first argument).</p>
<p class="calibre2">After we create a graph base with the <kbd class="calibre9">ggplot()</kbd> function, we add layers for different objects we want to see in the graph (for example, bars, lines, and points). In this case, we add bars with the <kbd class="calibre9">geom_bar()</kbd> function. Note how this layer is added using the <kbd class="calibre9">+</kbd> (plus) sign to the graph base. After that, we add another layer for the title with <kbd class="calibre9">ggtitle()</kbd>. Finally, we add an <em class="calibre19">x</em> axis specification with the <kbd class="calibre9">scale_x_continuous()</kbd> function that will allow us to see a number for each bar in the graph. If you don't add this layer, your graph may not show a number for each bar, which may be a little confusing. The way we specify it is by sending a sequence of numbers that should be used as the breaks (where tick data is shown). Since the numbers in the data may vary with different simulations, we make sure that we use the correct numbers by creating a sequence with the <kbd class="calibre9">seq()</kbd> function from the minimum number in the <kbd class="calibre9">QUANTITY</kbd> variable to the maximum. This will automatically show the correct numbers even if the <kbd class="calibre9">QUANTITY</kbd> variable has vastly different ranges.</p>
<p class="calibre2">These may seem like a lot of code to build a simple graph. However, it's precisely the amount of code that allows us to be very specific about what we want to see in the graph as you'll see in the following examples. Also, note that only the <kbd class="calibre9">ggplot()</kbd> (with its corresponding <kbd class="calibre9">aes()</kbd> function) and <kbd class="calibre9">geom_bar()</kbd> functions are required to actually produce the graph. The <kbd class="calibre9">ggtitle()</kbd> and <kbd class="calibre9">scale_x_continuous()</kbd> functions are only there to improve the graph:</p>
<pre class="mce-root">graph &lt;- ggplot(sales, aes(QUANTITY)) +<br class="title-page-name"/>    geom_bar() +<br class="title-page-name"/>    ggtitle("QUANTITY Frequency") +<br class="title-page-name"/>    scale_x_continuous(<br class="title-page-name"/>        breaks = seq(min(sales[, "QUANTITY"]), <br class="title-page-name"/>        max(sales[, "QUANTITY"]))<br class="title-page-name"/>    )</pre>
<p class="calibre2">The following graph shows the <strong class="calibre1">QUANTITY frequency</strong> for the preceding code:</p>
<div class="cdpaligncenter"><img class="alignnone" src="../images/00031.jpeg"/></div>
<div class="mce-root2">QUANTITY Frequency</div>
<p class="calibre2">Since we will be creating lots of bar graphs, we want to avoid having to copy-paste the code we just wrote, and not only that, but also make it more flexible. To accomplish this, we will generalize our code by parameterizing it and considering different scenarios we should cover.</p>
<p class="calibre2">So, what may we want our custom <kbd class="calibre9">graph_bars()</kbd> function to allow us to do? To start with, we may want to specify different variables for our <em class="calibre19">x</em> axis and <em class="calibre19">y</em> axis. To do this, we need to understand how the <kbd class="calibre9">geom_bar()</kbd> function works internally. If you look back at the code, we never specified the variable for the <em class="calibre19">y</em> axis, and <kbd class="calibre9">ggplot()</kbd> automatically used the number of times a <kbd class="calibre9">QUANTITY</kbd> number appeared in the data (the frequency).</p>
<p class="calibre2">What if we want to use the <kbd class="calibre9">PROFIT</kbd> value for each sale as the variable for the <em class="calibre19">y</em> axis? In that case, we need to realize that we have more than 2,000 potentially different values as <kbd class="calibre9">PROFIT</kbd> when <kbd class="calibre9">QUANTITY</kbd> is two or three, and less so in the other cases. We need to aggregate those <kbd class="calibre9">PROFIT</kbd> values somehow before we can use <kbd class="calibre9">PROFIT</kbd> in the <em class="calibre19">y</em> axis.</p>
<p class="calibre2">Any function that can reduce the <kbd class="calibre9">PROFIT</kbd> values into a single value for all the transactions, for each value of <kbd class="calibre9">QUANTITY</kbd>, could be used to aggregate the data. However, the most common choices are using the mean or the sum. The mean would show a graph where we see the average <kbd class="calibre9">PROFIT</kbd> for each <kbd class="calibre9">QUANTITY</kbd> value. The sum would show us the total <kbd class="calibre9">PROFIT</kbd> for each <kbd class="calibre9">QUANTITY</kbd> value. The same would apply if we want to use <kbd class="calibre9">PROFIT_RATIO</kbd> (or any other numerical variable) in the <em class="calibre19">y</em> axis. The most intuitive choices are using sum for <kbd class="calibre9">PROFIT</kbd> (total profit) and mean for <kbd class="calibre9">PROFIT_RATIO</kbd> (average profit ratio), so we will use those.</p>
<p class="calibre2">For the <em class="calibre19">x</em> axis, we may have categorical, numerical, or date variables. For this particular case, the default <em class="calibre19">x</em> axis options are fine for categorical and date variables, but we still want to see all the numbers in the ticks when working with numerical variables. This means that we need to provide a check for the type of variable in the <em class="calibre19">x</em> axis, and if it's numerical, then we need to do the proper adjustment (the same adjustment we saw in the previous code).</p>
<p class="calibre2">What we have explained before is what is programmed in our <kbd class="calibre9">graph_bars()</kbd> function. It receives as parameters the data and the <em class="calibre19">x</em> axis and <em class="calibre19">y</em> axis variables. First, it checks whether or not we specified a particular <em class="calibre19">y</em> axis variable. We use the "NULL check" technique mentioned in <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R</em>. If we don't receive a <em class="calibre19">y</em> axis variable, then we create a bar graph as we did earlier (using the frequency of the <em class="calibre19">x</em> axis variable by default), and we create the corresponding title using the <kbd class="calibre9">paste()</kbd> function. If we do get a variable for the <em class="calibre19">y</em> axis (meaning that we are in the <kbd class="calibre9">else</kbd> block), then we need to find out what type of aggregation we need to do, and we do so using our <kbd class="calibre9">get_aggregation()</kbd> function, which returns the sum as the aggregation method if we are asked to graph the <kbd class="calibre9">PROFIT</kbd> variable in the <em class="calibre19">y</em> axis, and returns the mean in any other case. We then use this function name as the value for the <kbd class="calibre9">fun.y</kbd> parameter (which is read as <em class="calibre19">function</em> <em class="calibre19">for</em> <kbd class="calibre9">y</kbd>), and specify that we are working with a summary function (when you don't need aggregation for a variable you should send the <kbd class="calibre9">stat = 'identity'</kbd> parameter to the <kbd class="calibre9">geom_bar()</kbd> function and avoid sending it to the <kbd class="calibre9">fun.y</kbd> parameter). Then we specify the title of the graph as needed. After the <kbd class="calibre9">if else</kbd> block, we check if the variable type for the <em class="calibre19">x</em> axis is numeric, and if it is we apply the interval names transformation:</p>
<pre class="mce-root">graph_bars &lt;- function(data, x, y = NULL) {<br class="title-page-name"/>    if (is.null(y)) {<br class="title-page-name"/>        graph &lt;- ggplot(data, aes_string(x)) +<br class="title-page-name"/>            geom_bar() +<br class="title-page-name"/>            ggtitle(paste(x, "Frequency")) +<br class="title-page-name"/>            ylab("Frequency")<br class="title-page-name"/>    } else {<br class="title-page-name"/>        aggregation &lt;- get_aggregation(y)<br class="title-page-name"/>            graph &lt;- ggplot(data, aes_string(x, y)) +<br class="title-page-name"/>            geom_bar(fun.y = aggregation, stat = "summary") + <br class="title-page-name"/>            ggtitle(paste(y, "by", x))<br class="title-page-name"/>   }<br class="title-page-name"/>   if (class(data[, x]) == "numeric") {<br class="title-page-name"/>        graph &lt;- graph +<br class="title-page-name"/>            scale_x_continuous(<br class="title-page-name"/>                breaks = seq(min(data[, x]), max(data[, x])))<br class="title-page-name"/>   }<br class="title-page-name"/>   return(graph)<br class="title-page-name"/>}</pre>
<p class="calibre2">When working with this special-case function, we recommend that you put the special case in the <kbd class="calibre9">if</kbd> part of the check to make sure that you only catch the special cases we're looking for, and return the generic case otherwise. If you do this the other way around (checking for generic cases first) you'll undoubtedly encounter some tricky bugs:</p>
<pre class="mce-root">get_aggregation &lt;- function(y) {<br class="title-page-name"/>    if (y == "PROFIT") {<br class="title-page-name"/>        return("sum")<br class="title-page-name"/>    }<br class="title-page-name"/>    return("mean")<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we can create many more bar graphs with our custom <kbd class="calibre9">graph_bars()</kbd> function:</p>
<pre class="mce-root">graph_bars(sales, "CONTINENT")<br class="title-page-name"/>graph_bars(sales, "CONTINENT", "PROFIT")<br class="title-page-name"/>graph_bars(sales, "CONTINENT", "PROFIT_RATIO")<br class="title-page-name"/><br class="title-page-name"/>graph_bars(sales, "PROTEIN_SOURCE")<br class="title-page-name"/>graph_bars(sales, "PROTEIN_SOURCE", "PROFIT")<br class="title-page-name"/>graph_bars(sales, "PROTEIN_SOURCE", "PROFIT_RATIO")</pre>
<p class="calibre2">All of the following graphs are shown together for easier visualization and space preservation, but you would get them one-by-one when executing the code yourself.</p>
<div class="cdpaligncenter"><img src="../images/00032.jpeg" class="calibre22"/></div>
<div class="mce-root2">Bar graphs</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding a third dimension with colors</h1>
                
            
            <article>
                
<p class="calibre2">As often happens, we want to work on some code we had already created to add more features. In this case, we want to add a third dimension to the graphs using colors. We want to be able to specify a <kbd class="calibre9">color</kbd> variable that will be used to further divide the data in the graph.</p>
<p class="calibre2">To accomplish this, we add a <kbd class="calibre9">color</kbd> parameter to the function's signature using the "NULL check" pattern and we add the corresponding parameter in each case. Adding the parameter directly in the <kbd class="calibre9">aes_string()</kbd> function is not problematic in case of <kbd class="calibre9">NULL</kbd> because <kbd class="calibre9">NULL</kbd> values indicate to <kbd class="calibre9">ggplot()</kbd> we don't want to use a fill color for the graph.</p>
<p class="calibre2">However, note that we are not able to use the same technique with <kbd class="calibre9">y</kbd> . Instead, we check whether we should send <kbd class="calibre9">y</kbd> or not, and only send it to the <kbd class="calibre9">ggplot()</kbd> function if we have a non-<kbd class="calibre9">NULL</kbd> value. Also, we add the <kbd class="calibre9">position = "dodge"</kbd> parameter to the <kbd class="calibre9">geom_bar()</kbd> function so that we get unstacked bar graphs. If we don't send this parameter we would get stacked bar graphs, and for these particular graphs, we thought the unstacked version looked better. Feel free to try the stacked version yourself. Let's look at the following code:</p>
<pre class="mce-root">graph_bars &lt;- function(data, x, y = NULL, color = NULL) {<br class="title-page-name"/>    if (is.null(y)) {<br class="title-page-name"/>        graph &lt;- ggplot(data, aes_string(x, fill = color)) +<br class="title-page-name"/>            geom_bar(position = "dodge") +<br class="title-page-name"/>            ggtitle(paste(x, "Frequency")) +<br class="title-page-name"/>            ylab("Frequency")<br class="title-page-name"/>    } else {<br class="title-page-name"/>        aggregation &lt;- get_aggregation(y)<br class="title-page-name"/>        graph &lt;- ggplot(data, aes_string(x, y, fill = color)) +<br class="title-page-name"/>                 geom_bar(<br class="title-page-name"/>                     fun.y = aggregation, <br class="title-page-name"/>                     stat = "summary", position = "dodge") +<br class="title-page-name"/>                     ggtitle(paste(y, "by", x)<br class="title-page-name"/>                 )<br class="title-page-name"/>    }<br class="title-page-name"/>    if (class(data[, x]) == "numeric") {<br class="title-page-name"/>        graph &lt;- graph +<br class="title-page-name"/>            scale_x_continuous(<br class="title-page-name"/>                breaks = seq(min(data[, x]), <br class="title-page-name"/>                max(data[, x]))<br class="title-page-name"/>            )<br class="title-page-name"/>    }<br class="title-page-name"/>    return(graph)<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that now we have four different cases we may want to graph, first, when specify only the <kbd class="calibre9">x</kbd> value, second, when we specify the <kbd class="calibre9">x</kbd> and <kbd class="calibre9">y</kbd> values, third, when we specify the <kbd class="calibre9">x</kbd> and <kbd class="calibre9">color</kbd> values, fourth, when we specify all three of them. Since the <kbd class="calibre9">ggplot()</kbd> specification for each of those cases is unique, we can't collapse them into a lower number of cases. You should also note that we only keep inside the conditional blocks the code that is specific for a particular check, and bring out of the conditional block the code that is not specific to the check and should be applied to two cases every time. That's what we do with the <kbd class="calibre9">ylab()</kbd> and <kbd class="calibre9">geom_bar()</kbd> functions in the outer <kbd class="calibre9">if</kbd> block and with the <kbd class="calibre9">get_aggregation()</kbd> and <kbd class="calibre9">geom_bar()</kbd> functions in the outer <kbd class="calibre9">else</kbd> block. Otherwise, we would be repeating code unnecessarily, which is a very bad practice.</p>
<div class="cdpaligncenter"><img src="../images/00033.jpeg" class="calibre22"/></div>
<div class="mce-root2">Bar graphs with colors</div>
<p class="calibre2">Now we can produce bar graphs that optionally receive a third parameter <kbd class="calibre9">color</kbd> (shown above), and if sent, it will be used to divide the data using colors. Note that in the first line of the following code, we need to explicitly send the <kbd class="calibre9">color</kbd> parameter. This is because we're omitting the <kbd class="calibre9">y</kbd> parameter from the function call, and if we are not explicit about the <kbd class="calibre9">color</kbd> parameter, it will be interpreted as being the <kbd class="calibre9">x</kbd> parameter. You can take a refresher on function calls in <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R</em>:</p>
<pre class="mce-root">graph_bars(sales, "QUANTITY", color = "PROTEIN_SOURCE")
graph_bars(sales, "CONTINENT", "PROFIT", "PROTEIN_SOURCE")
graph_bars(sales, "CONTINENT", "PROFIT_RATIO", "PROTEIN_SOURCE")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Graphing top performers with bar graphs</h1>
                
            
            <article>
                
<p class="calibre2">Bar graphs are one of the most used graphing tools in the world and this chapter is no exception. In our last bar graph example, we will show how to graph the top performers for a given variable in the decreasing order. Our objective is to graph either <kbd class="calibre9">PROFIT</kbd> or <kbd class="calibre9">Frequency</kbd> in the <em class="calibre19">y</em> axis and a parameterized variable for the <em class="calibre19">x</em> axis. We want to show the top <kbd class="calibre9">n</kbd> performers for the <kbd class="calibre9">x</kbd> variable in a decreasing order from left to right, as is shown in the graph below.</p>
<div class="cdpaligncenter"><img src="../images/00034.jpeg" class="calibre22"/></div>
<div class="mce-root2">Top n bar graphs</div>
<p class="calibre2">To accomplish this, we receive as parameters the data (<kbd class="calibre9">sales</kbd> in this case), the variable that will be used for the <em class="calibre19">x</em> axis <kbd class="calibre9">x</kbd>, the number of top performers we want to show <kbd class="calibre9">n</kbd>, and whether we want to use <kbd class="calibre9">PROFIT</kbd> in the <em class="calibre19">y</em> axis or not (in which case we will use the <kbd class="calibre9">Frequency</kbd>) by using the Boolean <kbd class="calibre9">by_profit</kbd>.</p>
<p class="calibre2">The first thing we do is check for the <kbd class="calibre9">by_profit</kbd> parameter; if it's <kbd class="calibre9">TRUE</kbd>, then we aggregate the <kbd class="calibre9">PROFIT</kbd> data for each <kbd class="calibre9">CLIENT_ID</kbd> with the <kbd class="calibre9">aggregate()</kbd> function using the <kbd class="calibre9">sum</kbd> operator (we want the total profit by client, not the average profit by client). Then we order the results with the <kbd class="calibre9">order()</kbd> function. The minus sign (<kbd class="calibre9">-</kbd>) just before the <kbd class="calibre9">profit_by_client$x</kbd> value means that we want a decreasing order, and the <kbd class="calibre9">x</kbd> that follows <kbd class="calibre9">profit_by_client</kbd> is because the result of the <kbd class="calibre9">aggregate()</kbd> function is a data frame with <kbd class="calibre9">Group.1</kbd> and <kbd class="calibre9">x</kbd> columns, which store the <kbd class="calibre9">CLIENT_ID</kbd> and the <kbd class="calibre9">PROFIT</kbd> sum, respectively.</p>
<p class="calibre2">Since we want to avoid unnecessary duplication of the code when we return the graph we want, we need to make sure that both cases in the <kbd class="calibre9">if else</kbd> block use the same names for the variables we will use in the <kbd class="calibre9">ggplot()</kbd> function. That's why we explicitly assign the <kbd class="calibre9">x</kbd> and <kbd class="calibre9">y_bar</kbd> names to the <kbd class="calibre9">top_df</kbd> data frame. If you looked inside the <kbd class="calibre9">top_df</kbd> object during execution, you would find that it has duplicated data with different column names. We could take care of this by removing the columns with the names we don't want, but it's unnecessary at this point since it's a throwaway object anyway. However, in certain situations this may be a performance issue we need to deal with, but not in this case.</p>
<p class="calibre2">In the case of the <kbd class="calibre9">else</kbd> block, conceptually we do the same thing. However, technically we implement differently. In this case, we create a table where each entry in the table is a unique <kbd class="calibre9">CLIENT_ID</kbd> value and the value for each entry is the number of times the <kbd class="calibre9">CLIENT_ID</kbd> appears in the data (<kbd class="calibre9">Frequency</kbd>), and we do so with the <kbd class="calibre9">table()</kbd> function. Then we sort these results in the decreasing order with the <kbd class="calibre9">sort()</kbd> function and take the top <kbd class="calibre9">n</kbd> results. Then we use these results to create the <kbd class="calibre9">top_df</kbd> data frame with the corresponding columns. Note that we need an auxiliary name <kbd class="calibre9">aux_name</kbd> for the <kbd class="calibre9">x</kbd> variable since we can't create a data frame by specifying a column name with a variable. What we do is then copy the data from the <kbd class="calibre9">aux_name</kbd> column to the actual name we need (contained in the <kbd class="calibre9">x</kbd> variable).</p>
<p class="calibre2">Finally, we create a graph and immediately return it without intermediate storage. The specifics on what each line is doing in that part of the code should be clear to you by this point, so we will avoid explaining that again.</p>
<p class="calibre2">Now you create <em class="calibre19">top n</em> graphs easily with the following code. We suggest that you try to create similar graphs for other categorical variables (for example, <kbd class="calibre9">CONTINENT</kbd> or <kbd class="calibre9">PROTEIN_SOURCE</kbd>). Note that the <kbd class="calibre9">CLIENT_ID</kbd> values in each case are different, meaning that the clients that buy the most from The Food Factory are not necessarily the clients that generate the most profit for it:</p>
<pre class="mce-root">graph_top_n_bars(sales, "CLIENT_ID", 10)
graph_top_n_bars(sales, "CLIENT_ID", 10, TRUE)</pre>
<p class="calibre2">We wanted to start simple and show the basic concepts of working with graph functions before we complicate things in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Graphing disaggregated data with boxplots</h1>
                
            
            <article>
                
<p class="calibre2">Creating bar graphs is useful when presenting results to people who are not familiar with statistics, but the fact that bar graphs aggregate information (just as we did in the bar graphs for top performers) means that, in reality, we lose information due to the reduction. If you're working with people who understand what quartiles are, then boxplots may be a useful visualization. They are an easy way to see individual distributions for different levels of a variable.</p>
<p class="calibre2">Each box represents the first quartile at the bottom, the third quartile at the top, and the median on the line in the middle. The lines that extend vertically reach up to any observation within <em class="calibre19">1.5 * IQR</em>, where the <strong class="calibre1">interquartile range</strong> (<strong class="calibre1">IQR</strong>) is the distance between the first and third quartiles. Any observation beyond <em class="calibre19">1.5 * IQR</em> is treated as an outlier and is shown individually.</p>
<p class="calibre2">Our objective is to show the bar graph we created for top performers according to <kbd class="calibre9">PROFIT</kbd>, but in a disaggregated way. When using bar graphs, the difficulty comes from aggregating the data correctly, but since we don't need to aggregate data for boxplots, their creation is very simple.</p>
<p class="calibre2">Our <kbd class="calibre9">graph_top_n_boxplots()</kbd> function takes as parameters the <kbd class="calibre9">data</kbd> value, the variables for the <em class="calibre19">x</em> and <em class="calibre19">y</em> axis, the number of top performers to show as <kbd class="calibre9">n</kbd>, and optionally the line and fill colors, as <kbd class="calibre9">c</kbd> and <kbd class="calibre9">f</kbd>, respectively. If no colors are specified, a selection of blues is used. The color specification must be done either in a HEX notation (<a href="https://en.wikipedia.org/wiki/Web_colors#Hex_triplet" class="calibre4">https://en.wikipedia.org/wiki/Web_colors#Hex_triplet</a>) or with R color names (<a href="http://sape.inf.usi.ch/quick-reference/ggplot2/colour" class="calibre4">http://sape.inf.usi.ch/quick-reference/ggplot2/colour</a>). We simply filter the data with our <kbd class="calibre9">filter_n_top()</kbd> function and use the <kbd class="calibre9">boxplot()</kbd> layer to produce the boxplots with the adequate colors. We also specify the title as the combination of the parameters received by the function:</p>
<pre class="mce-root">graph_top_n_boxplots &lt;- <br class="title-page-name"/>    function(data, x, y, n, f = "#2196F3", c = "#0D47A1") {<br class="title-page-name"/>    data &lt;- filter_n_top(sales, n, x)<br class="title-page-name"/>    return(<br class="title-page-name"/>        ggplot(data, aes_string(x, y)) +<br class="title-page-name"/>        geom_boxplot(fill = f, color = c) +<br class="title-page-name"/>        ggtitle(paste(y, "by", x, "( Top", n, ")"))<br class="title-page-name"/>    )<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">filter_n_top()</kbd> function receives as parameters the <kbd class="calibre9">data</kbd> value, the number of top performers we want to keep as <kbd class="calibre9">n</kbd>, and the identifier for the performers as <kbd class="calibre9">by</kbd>. First, we use the <kbd class="calibre9">aggregate()</kbd> function to aggregate the <kbd class="calibre9">PROFIT</kbd> variable by the chosen identifier (which is sent as a list, as is required by the function), and do the aggregation with the <kbd class="calibre9">sum</kbd> operator to get the total <kbd class="calibre9">PROFIT</kbd> per client. If we had used the <kbd class="calibre9">mean</kbd> operator, we would see a graph for the average <kbd class="calibre9">PROFIT</kbd> per client. Then we order the results, which are contained in the second column of the <kbd class="calibre9">aggr</kbd> object in decreasing order, and take the top <kbd class="calibre9">n</kbd> values from the first column, which contain the identifiers (the <kbd class="calibre9">CLIENT_ID</kbd> values in the example below). Finally, we keep only those observations in the data that correspond to the top identifiers we have in the <kbd class="calibre9">top</kbd> object.</p>
<pre class="mce-root">filter_n_top &lt;- function(data, n, by) {<br class="title-page-name"/>    aggr &lt;- aggregate(data$PROFIT, list(data[, by]), sum)<br class="title-page-name"/>    top &lt;- aggr[order(-aggr[, 2])[1:n], 1]<br class="title-page-name"/>    data &lt;- data[data[, by] %in% top, ]<br class="title-page-name"/>    return(data)<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we can easily replicate the bar graph we created in the previous section using boxplots.</p>
<div class="cdpaligncenter"><img src="../images/00035.jpeg" class="calibre22"/></div>
<div class="mce-root2">Top m boxplots</div>
<p class="calibre2">As you can see, we have more information shown in the graph, but we loose the ability to easily spot the total <kbd class="calibre9">PROFIT</kbd> value for each <kbd class="calibre9">CLIENT_ID</kbd>. Choosing the graph type depends on what information you're trying to communicate:</p>
<pre class="mce-root">graph_top_n_boxplots(sales, "CLIENT_ID", "PROFIT", 10)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scatter plots with joint and marginal distributions</h1>
                
            
            <article>
                
<p class="calibre2">We have seen how to create scatter plots with <kbd class="calibre9">ggplot()</kbd> in previous chapters. Therefore, in this section, we will only focus on the parts that we have not seen before. Our objective is to create scatter plots that not only show the scatter plot, but extend it by showing the marginal distributions on both axes. These are called <strong class="calibre1">marginal plots</strong> and are useful for understanding how data is jointly (two variables) as well as marginally (one variable) distributed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pricing and profitability by protein source and continent</h1>
                
            
            <article>
                
<p class="calibre2">As usual, we start developing our graph function. We receive as parameters the <kbd class="calibre9">data</kbd>, and the variables for the <em class="calibre19">x</em> axis (<kbd class="calibre9">x</kbd>) and <em class="calibre19">y</em> axis (<kbd class="calibre9">y</kbd>), and, in this case, we anticipate four cases that correspond to the combinations of including or not the <kbd class="calibre9">color</kbd> and <kbd class="calibre9">shape</kbd> variables for the graph. We do the standard checking and create the corresponding graph base. Here comes the different part, we call the <kbd class="calibre9">ggMarginal()</kbd> function of the <kbd class="calibre9">ggExtra</kbd> package with the graph object we want (in this case, the base graph plus the points layer), and specify the type of graph to be used for the marginal distributions. You can chose from <kbd class="calibre9">density</kbd>, <kbd class="calibre9">histogram</kbd>, and <kbd class="calibre9">boxplot</kbd>. We choose <kbd class="calibre9">histogram</kbd>:</p>
<pre class="mce-root">graph_marginal_distributions &lt;- <br class="title-page-name"/>function(data, x, y, color = NULL, shape = NULL) {<br class="title-page-name"/>    if (is.null(color)) {<br class="title-page-name"/>        if (is.null(shape)) {<br class="title-page-name"/>            graph &lt;- ggplot(data, aes_string(x, y))<br class="title-page-name"/>        } else {<br class="title-page-name"/>            graph &lt;- ggplot(data, aes_string(x, y, shape = shape))<br class="title-page-name"/>        }<br class="title-page-name"/>    } else {<br class="title-page-name"/>        if (is.null(shape)) {<br class="title-page-name"/>            graph &lt;- ggplot(data, aes_string(x, y, color = color))<br class="title-page-name"/>        } else {<br class="title-page-name"/>            graph &lt;- ggplot(data, aes_string(x, y, <br class="title-page-name"/>                            color = color, <br class="title-page-name"/>                            shape = shape))<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>    return(ggMarginal(graph + geom_point(), type = "histogram"))<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we are able to easily create scatter plots with marginal distributions on the sides. In the first graph (left), we show the relation among <kbd class="calibre9">PRICE</kbd>, <kbd class="calibre9">COST</kbd>, <kbd class="calibre9">PROTEIN_SOURCE</kbd>, and <kbd class="calibre9">CONTINENT</kbd>.</p>
<div class="cdpaligncenter"><img src="../images/00036.jpeg" class="calibre22"/></div>
<div class="mce-root2">Marginal distributions</div>
<p class="calibre2">Note that there are very distinguishable groups. In the second graph (right), we show the relation among <kbd class="calibre9">PRICE</kbd>, <kbd class="calibre9">PROFIT_RATIO</kbd>, <kbd class="calibre9">PROTEIN_SOURCE</kbd>, and <kbd class="calibre9">CONTINENT</kbd>. Note that we find the same relation we did in our 3D interactive scatter plots, the higher the <kbd class="calibre9">PRICE</kbd> value, the higher the <kbd class="calibre9">PROFIT_RATIO</kbd> value. However, there are two interesting findings here that we will mention in <a href="part0147.html#4C62M0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 7</a>, <em class="calibre19">Developing Automatic Presentations</em>. Can you tell what they are?</p>
<pre class="mce-root">graph_marginal_distributions(sales, <br class="title-page-name"/>       "COST", "PRICE", "PROTEIN_SOURCE", "CONTINENT")</pre>
<p class="calibre2">If you use the <kbd class="calibre9">graph_marginal_distributions()</kbd> function to graph the combination of <kbd class="calibre9">COST</kbd>, <kbd class="calibre9">PRICE</kbd>, <kbd class="calibre9">STATUS</kbd>, and <kbd class="calibre9">PAID</kbd>, you should see no pattern emerge as those distributions were randomly simulated to be normally distributed in <a href="part0091.html#2MP360-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 4</a>, <em class="calibre19">Simulating Sales Data and Working with Databases</em>, and no skewing process was applied to them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Client birth dates, gender, and ratings</h1>
                
            
            <article>
                
<p class="calibre2">A problem you will encounter when programming is that sometimes a function you thought would be general enough needs to be changed in some way. Sometimes the right decision is to change the existing function, but other times, the right decision is to create a new function (maybe based on the original one) that can be modified as needed without breaking old code that used it. This happens when the assumptions for the function are not met, and can't be easily accommodated.</p>
<p class="calibre2">In our case, what happens if we want to use the <kbd class="calibre9">clients</kbd> data to graph our clients' birth dates using the year in the <em class="calibre19">x</em> axis, month in the <em class="calibre19">y</em> axis, color by gender, and show the rating adjusting the size of the dots? Well, the <em class="calibre19">x</em> axis and the <em class="calibre19">y</em> axis data assumptions may be fulfilled with minor data transformations, the color assumption is already met, but the size assumption doesn't seem to fit our previous model.</p>
<p class="calibre2">In our <kbd class="calibre9">graph_marginal_distributions()</kbd> function, we assumed that we would use the <kbd class="calibre9">shape</kbd> as the fourth variable to represent categorical variables, but it seems that, even though the <kbd class="calibre9">STARS</kbd> variable is technically a factor, it would be better represented using size rather than different shapes. The fact that we need to deal with the <em class="calibre19">x</em> axis, <em class="calibre19">y</em> axis, and size assumptions within special cases for the <kbd class="calibre9">clients</kbd> data, is reason enough to decide to create its own function based on the original one. If at some point we want to merge these two functions into a single one, we can do so, but there's no need to over complicate things for ourselves at this point.</p>
<p class="calibre2">In our <kbd class="calibre9">graph_marginal_distributions_client_birth_dates()</kbd> function, we only need to receive the data we will be working on (<kbd class="calibre9">clients</kbd> in this case). There's no need for other parameters because all the assumptions will be hardcoded inside the function in this case, because we're not looking to generalize the code. To make the code a little more readable, we will use short variable names to contain the string we will use to create the specification for the plot. That's what those <kbd class="calibre9">x</kbd>, <kbd class="calibre9">y</kbd>, <kbd class="calibre9">x_noise</kbd>, and <kbd class="calibre9">y_noise</kbd> variables are.</p>
<p class="calibre2">As mentioned, we need to slightly transform the data before we are able to produce the plot. First, we need to disaggregate the <kbd class="calibre9">BIRTH_DATE</kbd> into <kbd class="calibre9">BD_YEAR</kbd> and <kbd class="calibre9">BD_MONTH</kbd> (<kbd class="calibre9">BD</kbd> is short for birth date). Then we add noise to the dates because if just kept dates as they are, we would get a grid of values, not a distribution, and that's because both the year and the month are integer values, so there would be a lot of dots stacked up on each other and a lot of space empty between them, we can see a mixed version of the data, and that's why we need to add noise to it. See below how both of these functions work internally.</p>
<p class="calibre2">After we have our short names and have transformed our data, we are ready to create a scatter plot just as we have done before. Here's where the distinction between dates with and without noise comes into play. If we used the dates with noise to display the tick values for the axis, we would see year labels like 1953.51, 1973.85, 1993.23, and so on. Clearly, it's not intuitive to display the year axis with such values. Similarly, for the <em class="calibre19">y</em> axis, we would see month values like 1.24, 4.09, 8.53, and so on. The same problem. That's why we need two versions of the data, the one with the noise (real values) that is used to place the dots in the graph, and the one without the noise (integer values) that is used to show values in the axis. Finally, we add the axis labels and send the graph through the <kbd class="calibre9">ggMarginal()</kbd> function as we had done earlier:</p>
<pre class="mce-root">graph_marginal_distributions_client_birth_dates &lt;- function(data) {
    x &lt;- "BD_YEAR"
    y &lt;- "BD_MONTH"
    x_noise &lt;- "BD_YEAR_NOISE"
    y_noise &lt;- "BD_MONTH_NOISE"
    data &lt;- disaggregate_dates(data)
    data &lt;- add_dates_noise(data)
    graph &lt;- ggplot(data, aes_string(x_noise, <br class="title-page-name"/>                                     y_noise,
                                     size = "STARS",<br class="title-page-name"/>                                     color = "GENDER")) +
        scale_x_continuous(breaks = seq(min(data[, x]),<br class="title-page-name"/>                                    max(data[, x]), by = 5)) +
        scale_y_continuous(breaks = seq(min(data[, y]),  <br class="title-page-name"/>                                    max(data[, y]))) +
                                    geom_point() +
                                    ylab("MONTH") +
                                    xlab("YEAR")
    return(ggMarginal(graph, type = "histogram"))
}
disaggregate_dates &lt;- function(data) {
    data$BD_YEAR &lt;- as.numeric(format(data$BIRTH_DATE, "%Y"))
    data$BD_MONTH &lt;- as.numeric(format(data$BIRTH_DATE, "%m"))
    return(data)
}</pre>
<p class="calibre2">Adding noise to the data is straightforward, we simply create new variables (<kbd class="calibre9">BD_YEAR_NOISE</kbd> and <kbd class="calibre9">BD_MONTH_NOISE</kbd>) that have the original (integer) values and we add a random number from the normal distribution with a mean of 0 and a standard deviation of 0.5. We need a small standard deviation to make sure that our data is not changed too much:</p>
<pre class="mce-root">add_dates_noise &lt;- function(data) {<br class="title-page-name"/>    year_noise &lt;- rnorm(nrow(data), sd = 0.5)<br class="title-page-name"/>    month_noise &lt;- rnorm(nrow(data), sd = 0.5)<br class="title-page-name"/>    data$BD_YEAR_NOISE &lt;- data$BD_YEAR + year_noise<br class="title-page-name"/>    data$BD_MONTH_NOISE &lt;- data$BD_MONTH + month_noise<br class="title-page-name"/>    return(data)<br class="title-page-name"/>}</pre>
<p class="calibre2">To disaggregate the dates, we simply create new variables (<kbd class="calibre9">BD_YEAR</kbd> and <kbd class="calibre9">BD_MONTH</kbd>) that contain the corresponding date value extracted using the date format specification that comes with R (<kbd class="calibre9">%Y</kbd> for year and <kbd class="calibre9">%m</kbd> for numeric month) converted to numbers (so that we can add noise to them and plot them). For more information on the date format specification, take a look at the <em class="calibre19">Dates and Times in R</em> page from Berkeley University (<a href="https://www.stat.berkeley.edu/~s133/dates.html" class="calibre4">https://www.stat.berkeley.edu/~s133/dates.html</a>).</p>
<p class="calibre2">Let's take a look at the client birth dates with the help of a graph:</p>
<div class="cdpaligncenter">
<div class="cdpaligncenter"><img src="../images/00037.jpeg" class="calibre22"/></div>
<div class="mce-root2">Client birth dates with marginal distribution</div>
</div>
<p class="calibre2">Now we can easily create this graph anytime we want without having to worry about the details of how to create it with the following code:</p>
<pre class="mce-root">graph_marginal_distributions_client_birth_dates(clients)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Developing our own graph type – radar graphs</h1>
                
            
            <article>
                
<p class="calibre2">This section will take our graph functions to the next level as we develop our own custom graph type. The <kbd class="calibre9">ggplot2</kbd> package does not have a way to produce radar graphs by default, so we will develop it ourselves during this section. There are packages that extend <kbd class="calibre9">ggplot2</kbd> with radar graph capabilities (for example, <kbd class="calibre9">ggradar</kbd>), but we will show how to create it yourself from scratch. After reading this section, you'll be equipped to develop complex graphs on your own.</p>
<p class="calibre2">Radar graphs are plotted on a circular canvas and can show many variables values at the same time. They form a <em class="calibre19">radar-looking</em> shape and are useful if you want to compare different variable values among various <em class="calibre19">entities</em>. Sometimes they are used to visually get a sense of how similar or different <em class="calibre19">entities</em> are. If you're not familiar with this type of graphs, there's one shown in the following image. In our example, instead of measuring speed, durability, comfort, power, and space, as this example does, we will measure the three different macronutrients for The Food Factory's top five clients.</p>
<div class="cdpaligncenter"><img src="../images/00038.jpeg" class="calibre46"/></div>
<p class="calibre2">The <kbd class="calibre9">graph_radar()</kbd> function receives as parameters the <kbd class="calibre9">data</kbd> data frame and the variable by which we want to show radars (<kbd class="calibre9">CLIENT_ID</kbd> in our case). First, it transforms the data we need from wide to long format using the <kbd class="calibre9">gather()</kbd> function. Then it creates the labels that will be used in top of each radar graph, which show the profit produced by each <kbd class="calibre9">CLIENT_ID</kbd>. Finally it returns the graph object, which is created by specifying the macronutrients and percentages, adding a polygon layer groups, colors, and fills by the <kbd class="calibre9">CLIENT_ID</kbd>, and adjusting the <kbd class="calibre9">alpha</kbd>(transparency) and line size to look good.</p>
<p class="calibre2">The <kbd class="calibre9">facet_wrap()</kbd> function is used to repeat the same plot for each instance of the <kbd class="calibre9">by</kbd> variable in the data (<kbd class="calibre9">CLIENT_ID</kbd> in our case). Since it requires a formula, and we want to generalize its usage, we use a combination of the <kbd class="calibre9">as.formula()</kbd> and <kbd class="calibre9">paste()</kbd> functions. To recall how these work, look at <a href="part0076.html#28FAO0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 3</a>, <em class="calibre19">Predicting Votes with Linear Models</em>. We also pass the <kbd class="calibre9">nrow = 1</kbd> parameter to make sure that we get a single row of graphs. We remove any legend information with the <kbd class="calibre9">guides()</kbd> function by sending the <kbd class="calibre9">"none"</kbd> string to the corresponding legends, apply our <kbd class="calibre9">coord_radar()</kbd> function (more on this below), and remove the axis labels:</p>
<pre class="mce-root">graph_radar &lt;- function(data, by) {<br class="title-page-name"/>    data &lt;- tidyr::gather(<br class="title-page-name"/>                   data, MACRO, PERCENTAGE, <br class="title-page-name"/>                   PROTEIN:FAT, factor_key = TRUE)<br class="title-page-name"/>    data$CLIENT_ID &lt;- paste(<br class="title-page-name"/>        data$CLIENT_ID, " ($", data$PROFIT, ")", sep = ""<br class="title-page-name"/>    )<br class="title-page-name"/>    return(<br class="title-page-name"/>        ggplot(data, aes(MACRO, PERCENTAGE)) +<br class="title-page-name"/>        geom_polygon(<br class="title-page-name"/>            aes_string(group = by, color = by, fill = by),<br class="title-page-name"/>            alpha = 0.4,<br class="title-page-name"/>            size = 2<br class="title-page-name"/>        ) +<br class="title-page-name"/>       facet_wrap(as.formula(paste("~", by)), nrow = 1) +<br class="title-page-name"/>       guides(color = "none", fill = "none") +<br class="title-page-name"/>       coord_radar() +<br class="title-page-name"/>       xlab("") +<br class="title-page-name"/>       ylab("")<br class="title-page-name"/>   )<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">coord_radar()</kbd> function is not a built-in function in the <kbd class="calibre9">ggplot2</kbd> package, and we need to program it ourselves. The version we will work with here is a slightly modified version of the <kbd class="calibre9">coord_radar()</kbd> found around the internet first attributed to Hadley Wickham. It leverages the <kbd class="calibre9">ggproto()</kbd> function to inherit and modify the polar coordinates layer in <kbd class="calibre9">ggplot2</kbd>, which receives parameters <kbd class="calibre9">theta</kbd> (angle), <kbd class="calibre9">r</kbd> (radius), <kbd class="calibre9">start</kbd> (starting point), <kbd class="calibre9">direction</kbd> (whether to use positive or negative units), and a hack that returns the function required by the <kbd class="calibre9">is_linear</kbd> parameter such that its value is always <kbd class="calibre9">TRUE</kbd>. If we did not send this last hack, we would get circular shapes just as we do with polar coordinates when trying to graph a straight line. The preceding code simply selects the appropriate axis for the angle so that we get the radar shape:</p>
<pre class="mce-root">coord_radar &lt;- function(theta = "x", start = 0, direction = 1) {<br class="title-page-name"/>    if (theta == "x") {<br class="title-page-name"/>        r &lt;- "y"<br class="title-page-name"/>    } else {<br class="title-page-name"/>        r &lt;- "x"<br class="title-page-name"/>    }<br class="title-page-name"/>    return(ggproto(<br class="title-page-name"/>        "CordRadar", <br class="title-page-name"/>        CoordPolar, <br class="title-page-name"/>        theta = theta, <br class="title-page-name"/>        r = r, <br class="title-page-name"/>        start = start, <br class="title-page-name"/>        direction = sign(direction),<br class="title-page-name"/>        is_linear = function(coord) { return(TRUE) }<br class="title-page-name"/>    ))<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">ggproto()</kbd> function is used as an <em class="calibre19">internal object system</em> within the <kbd class="calibre9">ggplot2</kbd> package, and was developed to avoid having to change too much of the code base when implementing layered objects. It's not recommended for you to use it unless absolutely necessary. For more information on object systems, look at <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies.</em></p>
<p class="calibre2">Now that we have our graph function ready, we need to make sure that our data is formatted correctly. To do so, we create the <kbd class="calibre9">filter_data()</kbd> function to filter the data and produce the expected structure. The function receives as parameters the <kbd class="calibre9">data</kbd> we will use, the number of days to keep backwards from the current date as <kbd class="calibre9">n_days</kbd>, the number of top performers we will show as <kbd class="calibre9">n_top</kbd>, and the variable we will aggregate by as <kbd class="calibre9">aggregate_by</kbd>.</p>
<p class="calibre2">First, we filter the data <kbd class="calibre9">n</kbd> days back and then keep the observations only for the <kbd class="calibre9">n_top</kbd> performers according to the <kbd class="calibre9">aggregate_by</kbd> variable. As we do, we update the <kbd class="calibre9">data</kbd> accordingly. Then, we aggregate the data twice, once by <kbd class="calibre9">PROFIT</kbd> and the other time by macronutrients (<kbd class="calibre9">PROTEIN</kbd>, <kbd class="calibre9">CARBS</kbd>, and <kbd class="calibre9">FAT</kbd>), and we get back the <kbd class="calibre9">CLIENT_ID</kbd> name into the data frame. Doing so produces two data frames, <kbd class="calibre9">aggr_profit</kbd> and <kbd class="calibre9">aggr_macros</kbd>, where each one aggregates its respective variables for each unique <kbd class="calibre9">CLIENT_ID</kbd>. Note that we separate this process into two independent parts because we want to aggregate <kbd class="calibre9">PROTEIN</kbd>, <kbd class="calibre9">CARBS</kbd>, and <kbd class="calibre9">FAT</kbd> with <kbd class="calibre9">mean</kbd> to get the average preference for each <kbd class="calibre9">CLIENT_ID</kbd>, but at the same time, we want to aggregate <kbd class="calibre9">PROFIT</kbd> with <kbd class="calibre9">sum</kbd> to get the total profit (not the average profit) for each <kbd class="calibre9">CLIENT_ID</kbd>.</p>
<p class="calibre2">Finally, we merge the data with the <kbd class="calibre9">merge()</kbd> function using our <kbd class="calibre9">aggregate_by</kbd> variable to be the index by which we join the data, drop residue columns from the data frame, and order it by <kbd class="calibre9">PROFIT</kbd>:</p>
<pre class="mce-root">filter_data &lt;- function(data, n_days, n_top, aggregate_by, static = TRUE) {<br class="title-page-name"/>    data &lt;- filter_n_days_back(data, n_days)<br class="title-page-name"/>    data &lt;- filter_n_top(data, n_top, aggregate_by)<br class="title-page-name"/>    if (static) {<br class="title-page-name"/>        aggr_profit &lt;- aggregate(<br class="title-page-name"/>            data[, c("PROFIT", "PROFIT_RATIO")],<br class="title-page-name"/>            list(data[, aggregate_by]),<br class="title-page-name"/>            sum<br class="title-page-name"/>        )<br class="title-page-name"/>        aggr_profit$CLIENT_ID &lt;- aggr_profit$Group.1<br class="title-page-name"/>        aggr_macros &lt;- aggregate(<br class="title-page-name"/>            data[, c("PROTEIN", "CARBS", "FAT")],<br class="title-page-name"/>            list(data[, aggregate_by]),<br class="title-page-name"/>            mean<br class="title-page-name"/>        )<br class="title-page-name"/>        aggr_macros$CLIENT_ID &lt;- aggr_macros$Group.1<br class="title-page-name"/>        data &lt;- merge(aggr_profit, aggr_macros, by = aggregate_by)<br class="title-page-name"/>        drop_columns &lt;- c("Group.1.x", "Group.1.y", "PROFIT_RATIO")<br class="title-page-name"/>        data &lt;- data[, !(names(data) %in% drop_columns)]<br class="title-page-name"/>        data &lt;- data[order(-data$PROFIT), ]<br class="title-page-name"/>    }<br class="title-page-name"/>    return(data)<br class="title-page-name"/>}</pre>
<p class="calibre2">If you read the code carefully, you may have noticed a detail we did not mention, the usage of the <kbd class="calibre9">PROFIT_RATIO</kbd> variable in the aggregation even if we don't use it later in the function. The reason for including <kbd class="calibre9">PROFIT_RATIO</kbd> in the <kbd class="calibre9">aggregate()</kbd> computation is because of the side-effect it produces. When specifying two or more variables inside the data for the <kbd class="calibre9">aggregate()</kbd> function, the result comes back with the actual data frame column names in the resulting data frame <kbd class="calibre9">aggr_profit</kbd>. If we only specify <kbd class="calibre9">PROFIT</kbd> by itself, the result will have a column named <kbd class="calibre9">x</kbd> instead of <kbd class="calibre9">PROFIT</kbd>, as we have seen and used in the previous code during this chapter. It's an easy way to avoid dealing with variable name changes. In my opinion, the <kbd class="calibre9">aggregate()</kbd> function should always return the original data frame names, but it does not so we have to work around it. Remember to keep this usability in mind when programming for others.</p>
<p class="calibre2">To see how we actually filter dates, we look inside the <kbd class="calibre9">filter_n_days_back()</kbd> function. As you can see, we receive as parameter the <kbd class="calibre9">data</kbd> we want to filter and the number of days we want to keep backwards as <kbd class="calibre9">n</kbd>. If <kbd class="calibre9">n</kbd> is <kbd class="calibre9">NULL</kbd>, meaning that the user did not want to filter the data backward, then we simply return the same <kbd class="calibre9">data</kbd> we got. If you do receive a number in <kbd class="calibre9">n</kbd>, then we get the current date and subtract <kbd class="calibre9">n</kbd> days from it with <kbd class="calibre9">Sys.Date() - n</kbd>. This simple subtraction is automatically done with days as units, thanks to a technique called <strong class="calibre1">operator overloading</strong>. We will look at the details of how it works in <a href="part0178.html#59O440-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 8</a>, <em class="calibre19">Object-Oriented System to Track Cryptocurrencies</em>. Finally, we simply keep those dates that is at least the <kbd class="calibre9">n_days_back</kbd> date (another usage of the <em class="calibre19">operator overloading</em> technique which allows us to compare dates). The <kbd class="calibre9">filter_n_top()</kbd> function is the one we created earlier for the boxplots code:</p>
<pre class="mce-root">filter_n_days_back &lt;- function(data, n) {<br class="title-page-name"/>    if (is.null(n)) {<br class="title-page-name"/>        return(data)<br class="title-page-name"/>    }<br class="title-page-name"/>    n_days_back &lt;- Sys.Date() - n<br class="title-page-name"/>    return(data[data[, "DATE"] &gt;= n_days_back, ])<br class="title-page-name"/>}</pre>
<p class="calibre2">Our <kbd class="calibre9">filter_data()</kbd> function is very useful in itself. For example, we can easily show the average macronutrients for the top 5 clients during the last 30 days by executing:</p>
<pre class="mce-root">filter_data(sales, 30, 5, "CLIENT_ID")
<strong class="calibre1">#&gt;    CLIENT_ID PROFIT   PROTEIN     CARBS       FAT
#&gt; 2 BAWHQ69720 74.298 0.3855850 0.3050690 0.3093460
#&gt; 3 CFWSY56410 73.378 0.4732115 0.3460788 0.1807097
#&gt; 4 CQNQB52245 61.468 0.1544217 0.3274938 0.5180846
#&gt; 1 AHTSR81362 58.252 0.3301151 0.3326516 0.3372332
#&gt; 5 VJAQG30905 53.104 0.2056474 0.5909554 0.2033972</strong></pre>
<p class="calibre2">Having made the investment in creating the corresponding graph function, we are now able to easily produce our own radar graphs. For example, we can easily produce the corresponding radar graph for the data we just showed earlier with:</p>
<pre class="mce-root">graph_radar(filter_data(sales, 30, 5, "CLIENT_ID"), "CLIENT_ID")</pre>
<p class="calibre2">The following image gives a representation of the preceding command:</p>
<div class="cdpaligncenter"><img src="../images/00039.jpeg" class="calibre22"/></div>
<div class="mce-root2">Top clients' macronutrients average radar</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exploring with interactive 3D scatter plots</h1>
                
            
            <article>
                
<p class="calibre2">When exploring data, sometimes it's useful to look at a 3D scatter plot. However, if the scatter plot is fixed (meaning that you cannot move it around), it may not be easy to interpret. Having an interactive plot (one you can move around) to see different angles of the data is very useful in these cases. These graphs don't normally go into static reports because they are hard to interpret correctly when fixed, but are very useful to do data exploration. Luckily, they are also very easy to create with the <kbd class="calibre9">plot3d()</kbd> function from the <kbd class="calibre9">rgl</kbd> package:</p>
<pre class="mce-root">library(rgl)
plot3d(sales$PROTEIN, sales$CARBS, sales$FAT)
plot3d(sales$PROFIT_RATIO, sales$PRICE, sales$QUANTITY)</pre>
<p class="calibre2">Once you create these plots in your computer, remember to move them around with your mouse! The first time you do this, it's pretty amazing. In this case, you can see two phenomenons that occur in the <kbd class="calibre9">sales</kbd> data. First, macronutrient percentages must add to one, and since there are three of them, what you will see in the graph on the left is a triangle shape in such a way that the sum of the coordinates for each point inside it is equal to one. Second, the graph on the right shows the relation among <kbd class="calibre9">PRICE</kbd>, <kbd class="calibre9">QUANTITY</kbd>, and <kbd class="calibre9">PROFIT_RATIO</kbd>. It shows that there are no fractional quantities in our sales data (just as we designed it), that there are lots of orders with zero <kbd class="calibre9">PROFIT_RATIO</kbd> because they are not fulfilled or payed for, and that the higher the <kbd class="calibre9">PRICE</kbd> is, the higher the <kbd class="calibre9">PROFIT_RATIO</kbd> is.</p>
<div class="cdpaligncenter"><img src="../images/00040.jpeg" class="calibre22"/></div>
<p class="calibre2">There's not much more to explain about these graphs. They are simple to create, have a simple purpose which sometimes can be very useful, but you will not normally see them in written reports.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Looking at dynamic data with time-series</h1>
                
            
            <article>
                
<p class="calibre2">Now we are going to focus on another very common type of graph: time-series. Our objective is to understand how our data is behaving for the last <kbd class="calibre9">n</kbd> days, and, as we have done before, we want to further disaggregate using colors, like the graph below shows:</p>
<div class="cdpaligncenter"><img src="../images/00041.jpeg" class="calibre22"/></div>
<p class="calibre2">If you have read all the chapter up until this point, you should be able to understand most of what the function is doing. The only new function is <kbd class="calibre9">scale_x_date()</kbd>. It allows us to specify date formats for the axis ticks other than the default. In this case, we want to use breaks by day (as we had done in some examples before), but we want the format of the labels to be similar to <strong class="calibre1">July 30, 2017</strong>, for example. To do so we make use of the date formats mentioned in a previous section in this chapter and send the desired string structure to the <kbd class="calibre9">date_labels</kbd> parameter:</p>
<pre class="mce-root">graph_last_n_days &lt;- function(data, n, y = NULL, color = NULL) {<br class="title-page-name"/>    subset &lt;- filter_n_days_back(data, n)<br class="title-page-name"/>    days_range &lt;- paste("(last ", n, " days)", sep = "")<br class="title-page-name"/>    date_sequence &lt;- seq(min(subset[, "DATE"]), <br class="title-page-name"/>                         max(subset[, "DATE"]), by = "day")<br class="title-page-name"/>    if (is.null(y)) {<br class="title-page-name"/>        graph &lt;- <br class="title-page-name"/>            ggplot(subset, aes_string(x = "DATE", color = color)) +<br class="title-page-name"/>            ggtitle(paste("Frequency", days_range))+<br class="title-page-name"/>            geom_point(stat = "count", size = 3) +<br class="title-page-name"/>            geom_line(stat = "count", size = 1)<br class="title-page-name"/>    } else {<br class="title-page-name"/>        aggregation &lt;- get_aggregation(y)<br class="title-page-name"/>        graph &lt;- ggplot(subset, aes_string(<br class="title-page-name"/>                            x = "DATE", <br class="title-page-name"/>                            y = y, <br class="title-page-name"/>                            color = color)) +<br class="title-page-name"/>            ggtitle(paste(y, days_range)) +<br class="title-page-name"/>            geom_point(<br class="title-page-name"/>                fun.y = aggregation, <br class="title-page-name"/>                stat = "summary", size = 3) +<br class="title-page-name"/>            geom_line(<br class="title-page-name"/>                fun.y = aggregation, <br class="title-page-name"/>                 stat = "summary", size = 1)<br class="title-page-name"/>    }<br class="title-page-name"/>    graph &lt;- graph +<br class="title-page-name"/>        ylab(y) +<br class="title-page-name"/>        scale_x_date(<br class="title-page-name"/>        breaks = date_sequence,<br class="title-page-name"/>        date_labels = "%B %d, %Y"<br class="title-page-name"/>    )<br class="title-page-name"/>    return(graph)<br class="title-page-name"/>}</pre>
<p class="calibre2">If you want to look at simple line graphs that show either the frequency, <kbd class="calibre9">PROFIT</kbd>, or <kbd class="calibre9">PROFIT_RATIO</kbd> for the last 30 days, you can use the following code. We don't show these images to preserve space:</p>
<pre class="mce-root">graph_last_n_days(sales, 30)
graph_last_n_days(sales, 30, "PROFIT")
graph_last_n_days(sales, 30, "PROFIT_RATIO")</pre>
<p class="calibre2">To look at line graphs for frequency, <kbd class="calibre9">PROFIT</kbd>, and <kbd class="calibre9">PROFIT_RATIO</kbd>, that distinguish <kbd class="calibre9">PROTEIN_SOURCE</kbd> with colors, you can use the following code:</p>
<pre class="mce-root">graph_last_n_days(sales, 30, color = "PROTEIN_SOURCE")
graph_last_n_days(sales, 30, "PROFIT", "PROTEIN_SOURCE")
graph_last_n_days(sales, 30, "PROFIT_RATIO", "PROTEIN_SOURCE")</pre>
<p class="calibre2">You can use the <kbd class="calibre9">graph_last_n_days()</kbd> function with other data frames. For example, graph the <kbd class="calibre9">STARS</kbd> ratings during the last 30 days coming from <kbd class="calibre9">client_messages</kbd>, you simply need to transform the categorical variable <kbd class="calibre9">STARS</kbd> into a numeric variable with the <kbd class="calibre9">as.numeric()</kbd> function so that you don't get errors for type mismatches, and call the function.</p>
<div class="cdpaligncenter"><img src="../images/00042.gif" class="calibre22"/></div>
<p class="calibre2">If you don't specify a variable to disaggregate using colors, it will graph with black by default:</p>
<pre class="mce-root">aux &lt;- client_messages
aux$STARS &lt;- as.numeric(aux$STARS)
graph_last_n_days(aux, 30, "STARS")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Looking at geographical data with static maps</h1>
                
            
            <article>
                
<p class="calibre2">Maps can be very useful tools to get an intuition behind geographical data. In this section, we will produce a map with the <kbd class="calibre9">ggplot2</kbd> package. The objective is to show the location of our client's messages, the <kbd class="calibre9">PRICE</kbd> associated to their purchases, and the corresponding <kbd class="calibre9">PROFIT_RATIO</kbd>. This example will show us how to join data from the <kbd class="calibre9">sales</kbd> and <kbd class="calibre9">client_messages</kbd> data frames.</p>
<p class="calibre2">Our <kbd class="calibre9">graph_client_messages_static()</kbd> function receives as parameters the <kbd class="calibre9">client_messages</kbd> and <kbd class="calibre9">sales</kbd> data frames, and that's all it needs as we are showing unfiltered (full) datasets. First, we need to merge our two data frames using the identifier they share, which is <kbd class="calibre9">SALE_ID</kbd>. To do so we use the <kbd class="calibre9">merge()</kbd> function, and we specify that we want to keep all observation on the <kbd class="calibre9">x</kbd> data frame, which is the first one (<kbd class="calibre9">client_messages</kbd>), and we don't want to keep observations from the <kbd class="calibre9">y</kbd> data frame, which is the second one (<kbd class="calibre9">sales</kbd>), if they don't have a corresponding identifier in the first data frame. This allows us to keep only data that has client messages associated with it. Then we produce the map geographical data with the <kbd class="calibre9">map_data()</kbd> (it comes in the <kbd class="calibre9">ggplot2</kbd> package), and we filter it to remove any region marked as <kbd class="calibre9">"Antarctica"</kbd>.</p>
<p class="calibre2">To actually create the graph we are going to use two main layers. The first one is the geographical data, which is added with the <kbd class="calibre9">geom_polygon()</kbd> function, using the <kbd class="calibre9">world_map</kbd> data, specifying the coordinates and groups (groups define countries), and use some dark colors to contrast with our dots. The second layer is the messages data, which is added with the <kbd class="calibre9">geom_point()</kbd> function, using the merged <kbd class="calibre9">data</kbd> data frame, with the corresponding coordinates, and adding colors and sizes with <kbd class="calibre9">PRICE</kbd> and <kbd class="calibre9">PROFIT_RATIO</kbd>, respectively. Since we are using a numeric variable to specify the color in this example, we will get a gradient of colors instead of discrete colors as in previous examples. Finally, we specify the actual color palette using the <kbd class="calibre9">scale_color_viridis()</kbd> function, set up the appropriate axis labels, and make the coordinates have equal units with the <kbd class="calibre9">coord_fixed()</kbd> function. If we don't use this last function, we can get maps which are deformed:</p>
<pre class="mce-root">graph_client_messages_static &lt;- function(client_messages, sales) {<br class="title-page-name"/>    data &lt;- merge(<br class="title-page-name"/>                  client_messages, sales, <br class="title-page-name"/>                  "SALE_ID", all.x = TRUE, <br class="title-page-name"/>                  all.y = FALSE<br class="title-page-name"/>                 )<br class="title-page-name"/>    world_map &lt;- filter(map_data("world"), region != "Antarctica")<br class="title-page-name"/>    return(<br class="title-page-name"/>        ggplot() +<br class="title-page-name"/>        geom_polygon(<br class="title-page-name"/>            data = world_map,<br class="title-page-name"/>            aes(long, lat, group = group),<br class="title-page-name"/>            color = "grey60",<br class="title-page-name"/>            fill = "grey50"<br class="title-page-name"/>        ) +<br class="title-page-name"/>        geom_point(<br class="title-page-name"/>            data = data,<br class="title-page-name"/>            aes(LNG, LAT, color = PRICE, size = PROFIT_RATIO)<br class="title-page-name"/>        ) +<br class="title-page-name"/>        scale_color_viridis(option = "inferno") +<br class="title-page-name"/>        ylab("Latitude") +<br class="title-page-name"/>        xlab("Longitude") +<br class="title-page-name"/>        coord_fixed()<br class="title-page-name"/>    )<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we can create our maps with the following function call:</p>
<pre class="mce-root">graph_client_messages_static(client_messages, sales)</pre>
<p class="calibre2">Doing so, results in the following graph:</p>
<div class="cdpaligncenter"><img src="../images/00043.jpeg" class="calibre47"/></div>
<p class="calibre2">Of course, if you want to generalize this function, you can parameterize some of the variables used for the graph's specification as we have done in previous examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Navigating geographical data with interactive maps</h1>
                
            
            <article>
                
<p class="calibre2">We can navigate the geographical data with the help of interactive maps, which are explained in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Maps you can navigate and zoom-in to</h1>
                
            
            <article>
                
<p class="calibre2">In this final section, we will create interactive maps that we can navigate. This is a very powerful tool that can be embedded in your R projects, greatly increasing their value and impact on your audience. We will use the <kbd class="calibre9">leaflet</kbd> package to develop this map. Our objective is to show a map with the locations of the messages we receive from our clients with icons that represent the type of rating we got using the <kbd class="calibre9">STARS</kbd> variable of the message and tooltips that show the <kbd class="calibre9">PROFIT</kbd> associated to the corresponding purchase of each message.</p>
<p class="calibre2">Our <kbd class="calibre9">graph_client_messages_interactive()</kbd> function receives the <kbd class="calibre9">client_messages</kbd> and <kbd class="calibre9">sales</kbd> data frames. As in the previous map, we will show all data without any filters, so that's all we need as parameters. The first thing we do, as we did earlier, is merge the data so that we keep only observations that have an associated message. Then we add a new variable to the <kbd class="calibre9">data</kbd> data frame that contains the icon specification that will be used by <kbd class="calibre9">leaflet</kbd>. To do so, we use the <kbd class="calibre9">awesomeIcons()</kbd> function (it's part of the <kbd class="calibre9">leaflet</kbd> package) and specify the functions used to specify the icon, the marker color, and say we want our icons to be white and that they should come from the <kbd class="calibre9">ion</kbd> icon library (<a href="http://ionicons.com/" class="calibre4">http://ionicons.com/</a>). Other icon libraries available are <kbd class="calibre9">glyphicon</kbd> (<a href="http://glyphicons.com/" class="calibre4">http://glyphicons.com/</a>) and <kbd class="calibre9">fa</kbd> (<kbd class="calibre9">fontawesome</kbd>, <a href="http://fontawesome.io/icons/" class="calibre4">http://fontawesome.io/icons/</a>). You may find the icon you're looking for in the referenced websites. Finally, we return the <em class="calibre19">leaflet graph</em> by creating markers with the <kbd class="calibre9">addAwesomeMarkers()</kbd> function, which receives a <em class="calibre19">leaflet object</em> created with the <kbd class="calibre9">leaflet()</kbd> function wrapped around our <kbd class="calibre9">data</kbd>, the formulas for longitudes and latitudes, the formula for icons, and the formula for the labels. Optionally, we wrap the <em class="calibre19">leaflet graph</em> with the <kbd class="calibre9">addProviderTiles()</kbd> to make sure that we get <em class="calibre19">tiles</em> (geographical background images) in our web browser. We need this because at the time of this writing there's a bug that will not show geographic data (only the markers) under specific circumstances and we want to avoid that problem, which we can easily do with the mentioned technique:</p>
<pre class="mce-root">graph_client_messages_interactive &lt;- function(client_messages, sales) {<br class="title-page-name"/>    data &lt;- merge(<br class="title-page-name"/>                  client_messages, <br class="title-page-name"/>                  sales, <br class="title-page-name"/>                  "SALE_ID", <br class="title-page-name"/>                  all.x = TRUE, <br class="title-page-name"/>                  all.y = FALSE)<br class="title-page-name"/>    data$ICON &lt;- awesomeIcons(<br class="title-page-name"/>        markerColor = get_icon_color(data),<br class="title-page-name"/>        icon = get_icon(data),<br class="title-page-name"/>        iconColor = 'white',<br class="title-page-name"/>        library = 'ion'<br class="title-page-name"/>    )<br class="title-page-name"/>    return(<br class="title-page-name"/>        addProviderTiles(addAwesomeMarkers(<br class="title-page-name"/>            leaflet(data),<br class="title-page-name"/>           ~LNG, ~LAT,<br class="title-page-name"/>           icon = ~ICON,<br class="title-page-name"/>           label = ~paste("Profit:", PROFIT)<br class="title-page-name"/>        ), providers$OpenStreetMap)<br class="title-page-name"/>    )<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we will explain the functions that specify the icons and marker colors. The <kbd class="calibre9">get_icon_color()</kbd> function will receive our <kbd class="calibre9">data</kbd> data frame and return a vector with string, which is either <kbd class="calibre9">"green"</kbd> or <kbd class="calibre9">"red"</kbd>, depending on whether or not the associated <kbd class="calibre9">STARS</kbd> where higher or equal to 4, or not. We do so using the <kbd class="calibre9">sapply()</kbd> function. If you need a refresher on these vectorized functions, take a look at <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R</em>:</p>
<pre class="mce-root">get_icon_color &lt;- function(data) {<br class="title-page-name"/>    return(sapply(<br class="title-page-name"/>        as.numeric(data$STARS),<br class="title-page-name"/>        function(stars) {<br class="title-page-name"/>            if (stars &gt;= 4) {<br class="title-page-name"/>                return("green")<br class="title-page-name"/>            } else {<br class="title-page-name"/>                return("red")<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    ))<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">get_icon()</kbd> function is very similar but it will return the name of the icon we want. We got these names from the <kbd class="calibre9">ion</kbd> icon library website (referenced earlier):</p>
<pre class="mce-root">get_icon &lt;- function(data) {<br class="title-page-name"/>    return(sapply(<br class="title-page-name"/>        as.numeric(data$STARS),<br class="title-page-name"/>        function(stars) {<br class="title-page-name"/>            if (stars &gt;= 4) {<br class="title-page-name"/>                return("ion-android-happy")<br class="title-page-name"/>            } else {<br class="title-page-name"/>                return("ion-android-sad")<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    ))<br class="title-page-name"/>}</pre>
<p class="calibre2">Now we can easily produce the interactive maps for our clients' messages using the following code. It will open a web browser and show you a map that you can move around.</p>
<pre class="mce-root">graph &lt;- graph_client_messages_interactive(client_messages, sales)<br class="title-page-name"/>print(graph)</pre>
<p class="calibre2">The initial position for the map will show the full geographical data as is shown in the following image. As you can see, the markers contain either a happy or a sad face, depending on the rating each message had. Also, the color of the marker is either green or red, again depending on the rating.</p>
<div class="cdpaligncenter"><img src="../images/00044.jpeg" class="calibre48"/></div>
<p class="calibre2">A zoomed-in version of the interactive map can be seen in the following image. Depending on the provider you choose in the <kbd class="calibre9">addProviderTiles()</kbd> function, you will get different types of geographical images (you can see some of them in action at <a href="http://leaflet-extras.github.io/leaflet-providers/preview/" class="calibre4">htt://leaflet-extras.github.io/leaflet-providers/preview/</a>).</p>
<div class="cdpaligncenter"><img src="../images/00045.jpeg" class="calibre49"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">High-tech-looking interactive globe</h1>
                
            
            <article>
                
<p class="calibre2">To finish this chapter, we will build an interactive high-tech-looking globe you can move around and show off to your friends. These types of visualizations are normally not very useful for analysis, but they are cool!</p>
<p class="mce-root3">Our objective is to show a globe that will show geographical data coming from clients' messages as well as bars whose height represents the <kbd class="calibre9">PROFIT</kbd> associated to each sale and colors for <kbd class="calibre9">PROTEIN_SOURCE</kbd>. To accomplish this, we will use the <kbd class="calibre9">threejs</kbd> package.</p>
<p class="calibre2">As we did earlier, our <kbd class="calibre9">graph_client_message_in_globe()</kbd> function receives the <kbd class="calibre9">client_messages</kbd> and <kbd class="calibre9">sales</kbd> data and sets it up using the <kbd class="calibre9">setup_globe_data()</kbd> function. Then it will get world <kbd class="calibre9">data</kbd> using the <kbd class="calibre9">get_world_map_data()</kbd> function and append it to the <kbd class="calibre9">data</kbd> data frame using the <kbd class="calibre9">rbind.fill()</kbd> function from the <kbd class="calibre9">plyr</kbd> package. This function resembles R's own <kbd class="calibre9">rbind()</kbd> function, but won't complain if columns do not match. Instead, it will fill the empty values with missing data indicators. Finally, we return a globe object with the <kbd class="calibre9">globejs()</kbd> function, which receives the coordinates in <kbd class="calibre9">lat</kbd> and <kbd class="calibre9">long</kbd>, the bar height under the <kbd class="calibre9">val</kbd> parameter, which comes from the <kbd class="calibre9">PROFIT</kbd> variable, the <kbd class="calibre9">color</kbd> which comes from a <kbd class="calibre9">COLOR</kbd> variable created during the data setup (see in the following example), and the <kbd class="calibre9">atmosphere = TRUE</kbd> parameter to show a glowing effect around the globe:</p>
<pre class="mce-root">graph_client_messages_in_globe &lt;- function(client_messages, sales) {<br class="title-page-name"/>    data &lt;- setup_globe_data(client_messages, sales)<br class="title-page-name"/>    world_map &lt;- get_world_map_data()<br class="title-page-name"/>    data &lt;- rbind.fill(data, world_map)<br class="title-page-name"/>    return(globejs(<br class="title-page-name"/>        lat = data$LAT,<br class="title-page-name"/>        long = data$LNG,<br class="title-page-name"/>        val = data$PROFIT^1.2,<br class="title-page-name"/>        color = data$COLOR,<br class="title-page-name"/>        pointsize = 1,<br class="title-page-name"/>        atmosphere = TRUE<br class="title-page-name"/>    ))<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">setup_globe_data()</kbd> function does the standard merging we've done with all maps and adds a new variable named <kbd class="calibre9">COLOR</kbd> that contains the colors that should be used for each observation. In the case of the <kbd class="calibre9">ggplot2</kbd> package, this color assignment was done automatically for us, but in the <kbd class="calibre9">threejs</kbd> package, we need do it ourselves. It will simply be a different color for each value in the <kbd class="calibre9">PROTEIN_SOURCE</kbd> variable:</p>
<pre class="mce-root">setup_globe_data &lt;- function(client_messages, sales) {<br class="title-page-name"/>    data &lt;- merge(<br class="title-page-name"/>        client_messages,<br class="title-page-name"/>        sales,<br class="title-page-name"/>        "SALE_ID",<br class="title-page-name"/>        all.x = TRUE,<br class="title-page-name"/>        all.y = FALSE<br class="title-page-name"/>    )<br class="title-page-name"/>    data$COLOR &lt;- NA<br class="title-page-name"/>    data[data$PROTEIN_SOURCE == "BEEF", "COLOR"] &lt;- "#aaff00"<br class="title-page-name"/>    data[data$PROTEIN_SOURCE == "FISH", "COLOR"] &lt;- "#00ffaa"<br class="title-page-name"/>    data[data$PROTEIN_SOURCE == "CHICKEN", "COLOR"] &lt;- "#00aaff"<br class="title-page-name"/>    data[data$PROTEIN_SOURCE == "VEGETARIAN", "COLOR"] &lt;- "#0055ff"<br class="title-page-name"/>    return(data)<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">get_world_map_data()</kbd> function is somewhat complicated. If you don't understand how it works, don't worry too much, as you probably won't need to do this yourself. We can't just use the data we had used before to create maps that we crated with the <kbd class="calibre9">map_data()</kbd> function, because the required data structure is different. In this case, we will create a temporary file named <kbd class="calibre9">cache</kbd> with the <kbd class="calibre9">tempfile()</kbd> function. Then we will read a binary file coming from a URL with the <kbd class="calibre9">url()</kbd> and <kbd class="calibre9">readBin()</kbd> functions. The file is a TIFF file, which we open in a <kbd class="calibre9">"raw"</kbd> format to keep all the data as is and avoid any data interpretation within R. The <kbd class="calibre9">n</kbd> parameter is the maximum number of records to be read from the data, which is 1 million in this case. Then we send this data through the <kbd class="calibre9">writeBin()</kbd> function so that it gets written to the <kbd class="calibre9">cache</kbd> file we created before. This mechanism is a way of downloading some temporary data so that we can read it into a function that does not support reading from online resources.</p>
<p class="calibre2">Once we have the temporary file ready, we read it with the <kbd class="calibre9">readGDAL()</kbd> function from the <kbd class="calibre9">rgdal</kbd> package, which will read it as geographical data. The specific format for this data includes longitude, latitude, and an altitude metric. The altitude metric is used to identify areas without land (oceans), which contain a value higher than or equal to 255 in this data. We proceed to remove any <kbd class="calibre9">NA</kbd> values in the data and assign default <kbd class="calibre9">PROFIT</kbd> and <kbd class="calibre9">COLOR</kbd> values. Note that we create these <kbd class="calibre9">PROFIT</kbd> and <kbd class="calibre9">COLOR</kbd> values to facilitate merging the data later on. We use the <kbd class="calibre9">PROFIT</kbd> column name for the altitude metric just for convenience since we will want to show the geographic areas with low bars, and we know that we will use <kbd class="calibre9">PROFIT</kbd> to generate the height for each bar:</p>
<pre class="mce-root">get_world_map_data &lt;- function() {<br class="title-page-name"/>    cache &lt;- tempfile()<br class="title-page-name"/>    writeBin(readBin(url(<br class="title-page-name"/>"http://illposed.net/nycr2015/MOD13A2_E_NDVI_2014-05-25_rgb_360x180.TIFF",<br class="title-page-name"/>        open = "rb"), <br class="title-page-name"/>        what = "raw", n = 1e6), con = cache)<br class="title-page-name"/><br class="title-page-name"/>    world_map &lt;- readGDAL(cache)<br class="title-page-name"/>    world_map &lt;- as.data.frame(cbind(<br class="title-page-name"/>                     coordinates(world_map), <br class="title-page-name"/>                     world_map@data[,1]))<br class="title-page-name"/>    names(world_map) &lt;- c("LNG", "LAT", "PROFIT")<br class="title-page-name"/><br class="title-page-name"/>    world_map &lt;- world_map[world_map$PROFIT &lt; 255,]<br class="title-page-name"/>    world_map &lt;- na.exclude(world_map)<br class="title-page-name"/><br class="title-page-name"/>    world_map$PROFIT &lt;- 1<br class="title-page-name"/>    world_map$COLOR &lt;- "#0055ff"<br class="title-page-name"/>    <br class="title-page-name"/>    return(world_map)<br class="title-page-name"/>}</pre>
<p class="calibre2">Once we invested in creating our graph function, we can create high-tech looking maps that display the location of messages we get from our clients, with bars and colors that indicate related <kbd class="calibre9">PROFIT</kbd> and <kbd class="calibre9">PROTEIN_SOURCE</kbd> for each message, respectively. Feel free to move the globe around in your web browser:</p>
<pre class="mce-root">graph_client_messages_in_globe(client_messages, sales)</pre>
<p class="calibre2"><span>It's a pretty cool effect isn't it?</span></p>
<div class="cdpaligncenter"><img src="../images/00046.jpeg" class="calibre50"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you learned how to create various types of data visualizations and how to work with graph functions and graph objects efficiently. Apart from the basic graph types, you learned how to create interactive graphs and maps and how to create our own custom types of graphs. The fundamentals shown in this chapter allow you to create high-quality visualizations using important and popular packages such as <kbd class="calibre9">ggplot2</kbd> and <kbd class="calibre9">leaflet</kbd>.</p>
<p class="calibre2">In the next chapter, <a href="part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 6</a>, <em class="calibre19">Understanding Reviews with Text Analysis</em>, we will analyze the text data we have from client messages as well as data we retrieve from Twitter in real-time. We will show how to generate sentiment analysis given textual data, and we will prepare ourselves to put the graphs in this chapter together with the text analysis in the following chapter into automatic reports in <a href="part0147.html#4C62M0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 7</a>, <em class="calibre19">Developing Automatic Presentations.</em></p>


            </article>

            
        </section>
    </body></html>