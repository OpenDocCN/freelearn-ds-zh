<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Projections</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discovering projection(s) of a Shapefile or GeoJSON dataset</li><li class="listitem" style="list-style-type: disc">Listing projection(s) from a WMS server</li><li class="listitem" style="list-style-type: disc">Creating a projection definition for a Shapefile if it does not exist</li><li class="listitem" style="list-style-type: disc">Batch setting the projection definition of a folder full of Shapefiles</li><li class="listitem" style="list-style-type: disc">Reprojecting a Shapefile from one projection to another</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Introduction</h1></div></div></div><p>Working with projections, in my opinion, is not too exciting but they're very important, and your ability to deal with them in any application is crucial.</p><p>The goal of this chapter is to provide some common predata screening or transformation steps to get your data in shape or, better yet, in position for geospatial analysis. We cannot always perform analysis on multiple datasets that are in different coordinate systems without the risk of achieving inconsistent results, such as data positional inaccuracies. Therefore, it is a best practice to work on data in the same coordinate system, such as EPSG:4326, when working on a global scale, or use a local coordinate system for your region that will provide you the most accurate results.</p><p>
<strong>European Petroleum Survey Group</strong> or <strong>EPSG</strong> codes <a id="id74" class="indexterm"/>have decided to give all coordinate systems a number code to simplify finding and sharing projection information. Coordinate systems are described by their definitions, which are stored in text files of various formats. These text files are designed to be computer-readable formats, specifically for individual GIS desktop software packages, such as QGIS or ESRI ArcMap or for your web/scripting applications.</p><p>The EPSG code 4326<a id="id75" class="indexterm"/> represents <strong>World Geographic System 1984 (WGS 84)</strong> and is a <a id="id76" class="indexterm"/>
<strong>geographic coordinate system</strong> with longitude and latitude (<em>x</em>, <em>y</em>) units (refer to the following image). The geographic coordinate system represents the Earth as a sphere, as in this image, and the unit of measurement is degrees.</p><div><img src="img/B03543_02_01.jpg" alt="Introduction"/><div><p>Illustration 1: Geographic Coordinate System (<a class="ulink" href="http://kartoweb.itc.nl/geometrics/coordinate%20systems/coordsys.html">http://kartoweb.itc.nl/geometrics/coordinate%20systems/coordsys.html</a>)</p></div></div><p>The second type of coordinate system is a <a id="id77" class="indexterm"/>
<strong>projected coordinate system</strong>, which is a two-dimensional flat plane with constant areas, lengths, or angles that are measured on an <em>x</em> and <em>y</em> grid. <strong>EPSG:3857 Pseudo-Mercator</strong> is such a projected coordinate system where the units are in meters with correct lengths but the angles and areas are distorted. In any given projected coordinate system, only two of the three properties, <em>area</em>, <em>distance</em>, or <em>angles</em>, can be correctly represented on a single map. The <a id="id78" class="indexterm"/>
<strong>Universal Transverse Mercator</strong> (<strong>UTM</strong>) coordinate reference system divides the world into 60 zones (refer to the following image):</p><div><img src="img/B03543_02_02.jpg" alt="Introduction"/><div><p>Illustration 2: Projected Coordinate System UTM (<a class="ulink" href="http://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#mediaviewer/File:Utm-zones.jpg">http://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#mediaviewer/File:Utm-zones.jpg</a>)</p></div></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Note that you have to enter your Python virtual environment using the <code class="literal">workon pygeoan_cb</code> command.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Discovering projection(s) of a Shapefile or GeoJSON dataset</h1></div></div></div><p>Remember <a id="id79" class="indexterm"/>that all data is stored in a coordinate system, no matter what the data source is. It is your job to figure this out using a simple approach outlined in this section. We will take a look at two different data storage types: a <strong>Shapefile</strong> and a <strong>GeoJSON</strong> file. These two formats contain geometries, such as points, lines, or <a id="id80" class="indexterm"/>polygons, and their associated attributes. For example, a tree would be stored as a point geometry with attributes, such as height, age, and species, Each of these data types store their projection data differently and, therefore, require different methods to discover their projection information.</p><p>Now a quick introduction to what a Shapefile is: a Shapefile is not a single file but a minimum of three files, such as <code class="literal">.shp</code>, <code class="literal">.shx</code>, and, <code class="literal">.dbf</code>, all of which have the same name. For example, <code class="literal">world_borders.shp</code>, <code class="literal">world_borders.shx</code> and <code class="literal">world_borders.dbf</code> make up one file. The <code class="literal">.shp</code> file stores geometry, <code class="literal">.dbf</code> stores a table of attribute values, and <code class="literal">.shx</code> is the index table that connects geometry to an attribute value as a lookup table.</p><p>A Shapefile <a id="id81" class="indexterm"/>should come with a very important fourth text file called <code class="literal">world_borders.prj</code>. The <strong>.prj</strong> stands for <strong>projection information</strong> and contains the projection definition of the Shapefile <a id="id82" class="indexterm"/>in a plain text format. As crazy as it sounds, you can still find and download tons of data being delivered today without this <code class="literal">.prj</code> file. You can do this simply by opening this <code class="literal">.prj</code> file in a text editor, such as <em>Sublime Text</em> or <em>Notepad++</em>, where you can read about the projection definition in order to determine the files coordinate system.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>The <code class="literal">.prj</code> file is a plain text file that can easily be generated for the wrong coordinate system if you are not careful. The wrong projection definition can cause problems with your analysis and transformations. We will see how to correctly assess a Shapefile's projection information.</p></div></div><p>GeoJSON is a <a id="id83" class="indexterm"/>single file stored in plain text. The GeoJSON standard (<a class="ulink" href="http://www.geojson.org">http://www.geojson.org</a>) is based on the JSON standard. The coordinate reference information is, in my experience, often <em>not</em> included and the default is WGS 84 and EPSG:4326, where the coordinates are stored in the <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">z</code> format and in this <em>exact order</em>.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>Mixing <em>x</em> and <em>y</em> for <em>y</em>, <em>x</em> can happen and when it does, your data will most likely end up in the ocean, so always remember that order matters:</p><p>
<em>x = longitude</em>
</p><p>
<em>y = latitude</em>
</p><p>
<em>z = height</em>
</p></div></div><p>The following is how the GeoJSON CRS information looks if it is presented in <code class="literal">FeatureCollection</code>:</p><div><pre class="programlisting">{
"type": "FeatureCollection",
"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
…</pre></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Getting ready</h2></div></div></div><p>The first thing is to head over to <a class="ulink" href="https://github.com/mdiener21/python-geospatial-analysis-cookbook">https://github.com/mdiener21/python-geospatial-analysis-cookbook</a> and download the entire source code and geodata in one go. The download icon is located on the bottom right-hand side and is labeled as <strong>Download ZIP</strong>. If you are a GitHub user, you can, of course, clone the repository. Beware that it is a <a id="id84" class="indexterm"/>download that's a little over 150 MB. Inside the repository, you will find each chapter with the following three folders: <code class="literal">/geodata/</code> to store data, <code class="literal">/code/</code> to store code scripts that have been completed, and an empty folder called <code class="literal">/working/</code> for you to create your self-written code scripts. The structure looks like this:</p><div><pre class="programlisting">/ch01/
–------/code
–------/geodata
–------/working
/ch02/
–------/code
–------/geodata
–------/working
...</pre></div><p>The source <a id="id85" class="indexterm"/>of the data used in this recipe comes from the City of Vancouver, BC, Canada, which is located at <a class="ulink" href="http://data.vancouver.ca/datacatalogue/index.htm">http://data.vancouver.ca/datacatalogue/index.htm</a> (Vancouver schools).</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>When downloading data from an Internet source, always look around for metadata descriptions about the projection information so that you know a little about your data's history and its source before you begin working with it. Most data today is publicly available in EPSG:4326 WGS 84 or EPSG:3857 Web Pseudo-Mercator. Data stemming from a government resource is most likely stored in local coordinate systems.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec38"/>How to do it...</h2></div></div></div><p>We are going to start with our Shapefile and identify the coordinate system it is stored in using the GDAL library that imports the OGR module:</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>Note that we have assumed that your Shapefile has a <code class="literal">.prj</code> file. If not, this process will not work.</p></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new Python file named as <code class="literal">ch02_01_show_shp_srs.py</code> in your <code class="literal">/ch02/working/</code> directory, and add the following code:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

from osgeo import ogr
shp_driver = ogr.GetDriverByName('ESRI Shapefile')
shp_dataset = shp_driver.Open(r'../geodata/schools.shp')
shp_layer = shp_dataset.GetLayer()
shp_srs = shp_layer.GetSpatialRef()
print shp_srs</pre></div></li><li class="listitem">Now <a id="id86" class="indexterm"/>save the file and run the <code class="literal">ch02_01_show_shp_srs.py</code> script from the command line:<div><pre class="programlisting">
<strong>$ python ch02-01-show_shp_srs.py</strong>
<strong>PROJCS["NAD_1983_UTM_Zone_10N",</strong>
<strong>    GEOGCS["GCS_North_American_1983",</strong>
<strong>        DATUM["North_American_Datum_1983",</strong>
<strong>            SPHEROID["GRS_1980",6378137,298.257222101]],</strong>
<strong>        PRIMEM["Greenwich",0],</strong>
<strong>        UNIT["Degree",0.017453292519943295]],</strong>
<strong>    PROJECTION["Transverse_Mercator"],</strong>
<strong>    PARAMETER["latitude_of_origin",0],</strong>
<strong>    PARAMETER["central_meridian",-123],</strong>
<strong>    PARAMETER["scale_factor",0.9996],</strong>
<strong>    PARAMETER["false_easting",500000],</strong>
<strong>    PARAMETER["false_northing",0],</strong>
<strong>    UNIT["Meter",1]]</strong>
</pre></div><p>You should see the preceding text print out on your screen, showing information on the <code class="literal">.prj</code> projection.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Note that we could also simply open the <code class="literal">.prj</code> file with a text editor and view this information as well.</p></div></div><p>Now, we will take a look at a GeoJSON file to see the projection information if it's available.</p></li><li class="listitem">Determining <a id="id87" class="indexterm"/>the coordinate system of a <strong>GeoJSON</strong> file is a little harder since we must make one of two assumptions where the first case is the standard case and most common:<div><ol class="orderedlist arabic"><li class="listitem">No CRS is explicitly defined inside the GeoJSON, so we assume EPSG:4326 WGS 84 is the coordinate system.</li><li class="listitem">CRS is defined explicitly and is correct.</li></ol></div></li><li class="listitem">Create a new Python file named <code class="literal">ch02_02_show_geojson_srs.py</code> in your <code class="literal">/ch02/working/</code> directory, and add the following code:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import json

geojson_yes_crs = '../geodata/schools.geojson'
geojson_no_crs = '../geodata/golfcourses_bc.geojson'

with open(geojson_no_crs) as my_geojson:    
    data = json.load(my_geojson)

# check if crs is in the data python dictionary data
# if yes print the crs to screen
# else print NO to screen and print geojson data type
if 'crs' in data:
    print "the crs is : " + data['crs']['properties']['name']
else:
    print "++++++ no crs tag in file+++++"
    print "++++++ assume EPSG:4326 ++++++"
    if "type" in data:
        print "current GeoJSON data type is :" + data['type']</pre></div></li><li class="listitem">The <a id="id88" class="indexterm"/>script is set up to run on the <code class="literal">geojson_no_crs</code> variable set in the GeoJSON <code class="literal">golfcourses_bc.geojson</code> file. The source of this data is <a id="id89" class="indexterm"/><strong>OpenStreetMap</strong>, which is exported using the <a id="id90" class="indexterm"/><strong>Overpass API</strong><a id="id91" class="indexterm"/> that's located at <a class="ulink" href="http://overpass-turbo.eu/">http://overpass-turbo.eu/</a>. Now, run the <code class="literal">ch02_02_show_geojson_srs.py</code> script and you should see this output for our first file:<div><pre class="programlisting">
<strong>$ python ch02_02_show_geojson_crs.py</strong>
<strong>++++++ no crs tag in file+++++</strong>
<strong>      ++++++ assume EPSG:4326 ++++++</strong>
<strong>current GeoJSON data type is :FeatureCollection</strong>
</pre></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>If no CRS is inside our GeoJSON file, we'll assume it has a projection of EPSG:4326. To check this, you will need to look at the coordinates listed inside the file and see if they fall within bounds, such as <code class="literal">-180.0000</code>, <code class="literal">-90.0000</code>, <code class="literal">180.0000</code>, and <code class="literal">90.0000</code>. If so, we'll assume that the dataset is truly EPSG:4326 and open the data in QGIS to check this.</p></div></div></li><li class="listitem">Now, go into the code and edit line 10, change the variable from <code class="literal">geojson_no_crs</code> to <code class="literal">geojson_yes_crs</code>, and rerun the <code class="literal">ch02_02_show_geojson_srs.py</code> code file:<div><pre class="programlisting">
<strong>$ python ch02_02_show_geojson_crs.py</strong>
<strong>the crs is : urn:ogc:def:crs:EPSG::26910</strong>
</pre></div><p>You should now see the preceding output printed on screen.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec39"/>How it works...</h2></div></div></div><p>Beginning <a id="id92" class="indexterm"/>with the Shapefile, we've used the OGR library to help <a id="id93" class="indexterm"/>us quickly discover the EPSG code information of our Shapefile as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Begin with importing the OGR module as follows:<div><pre class="programlisting">
<strong>from osgeo import ogr</strong>
</pre></div></li><li class="listitem">Activate the OGR Shapefile driver:<div><pre class="programlisting">
<strong>shp_driver = ogr.GetDriverByName('ESRI Shapefile')</strong>
</pre></div></li><li class="listitem">Open the Shapefile with OGR:<div><pre class="programlisting">
<strong>shp_dataset = shp_driver.Open(r'../geodata/schools.shp')</strong>
</pre></div></li><li class="listitem">Access the layer information with <code class="literal">GetLayer()</code>:<div><pre class="programlisting">
<strong>shp_layer = shp_dataset.GetLayer()</strong>
</pre></div></li><li class="listitem">Now we can get the coordinate information using the <code class="literal">GetSpatialRef()</code> function:<div><pre class="programlisting">
<strong>shp_srs = shp_layer.GetSpatialRef()</strong>
</pre></div></li><li class="listitem">Finally, print the spatial reference system on screen:<div><pre class="programlisting">
<strong>print shp_srs</strong>
</pre></div></li></ol></div><p>The GeoJSON file was a little harder to tackle when we used the Python JSON module to look for the <code class="literal">crs</code> key and print out its value on the screen, if it existed.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>We could have simply replaced the first example code with the GeoJSON driver and we would get the same result. However, not all GeoJSON files include projection information. The OGR driver will always output WGS 84 as the coordinate system by default which, in our <code class="literal">no_geojson_crs.geojson</code> example file, is wrong. This can lead to confusion for new users. The important thing to note is to check your data, have a look at the coordinate values, and see if they fit in a defined coordinate range of values. To explore codes, or if you enter a code that you have and want to see the area it covers on a live web map, refer to <a class="ulink" href="http://epsg.io">http://epsg.io</a>.</p></div></div><p>First, we'll import the standard Python JSON module, and then set two variables to store both our GeoJSON files. Next, we'll open one file, the <code class="literal">golfcourses_bc.geojson</code> file, and load the GeoJSON file into a Python object. Then, all we need to do is check to see whether the <code class="literal">crs</code> key is in the GeoJSON; if it is, we'll print out its value. If not, we'll simply print to screen that <code class="literal">crs</code> is not available and the GeoJSON data type.</p><p>The GeoJSON <a id="id94" class="indexterm"/>default CRS is WGS 84 EPSG:4326, which means that we are dealing with latitude and longitude values. The values must fall within the bounds of <code class="literal">-180.0000</code>, <code class="literal">-90.0000</code>, <code class="literal">180.0000</code>, and <code class="literal">90.0000</code> to qualify.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec40"/>There's more...</h2></div></div></div><p>Here are some <a id="id95" class="indexterm"/>projection definition examples for your reference:</p><div><ol class="orderedlist arabic"><li class="listitem">The code for the ESRI Well-Known Text (stored with Shapefile as <code class="literal">ShapefileName.prj</code>) is as follows:<div><pre class="programlisting">GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]</pre></div></li><li class="listitem">The code for the OGC Well-Known Text of the same coordinate system as EPSG:4326 is as follows:<div><pre class="programlisting">GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.01745329251994328,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]]</pre></div></li><li class="listitem">The code for the Proj4 format, which also shows <code class="literal">EPSG:4326</code>, is as follows:<div><pre class="programlisting">
<strong>+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec41"/>See also</h2></div></div></div><p>The web page at <a class="ulink" href="http://www.spatialreference.org">http://www.spatialreference.org</a> is a great place to get coordinates for any projection you desire by simply selecting the destination coordinate system that you like, zooming in on the map, and then copying and pasting the coordinates. Later on, we will use the <a class="ulink" href="http://spatialreference.org/">http://spatialreference.org/</a> API to get the EPSG definition to create our own <code class="literal">.prj</code> file for a Shapefile.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Listing projection(s) from a WMS server</h1></div></div></div><p>The <strong>Web Mapping Service </strong>(<strong>WMS)</strong>, which<a id="id96" class="indexterm"/> can be found at <a class="ulink" href="https://en.wikipedia.org/wiki/Web_Map_Service">https://en.wikipedia.org/wiki/Web_Map_Service</a>, is fun since most service providers <a id="id97" class="indexterm"/>provide data in several coordinate systems and you can then specify which one you would like. However, you can't reproject or transform the WMS into some other system that the service provider <a id="id98" class="indexterm"/>does not provide, which means that you can only use the coordinate system that is provided. The following is an example of a WMS <code class="literal">getCapabilities</code> request (<a class="ulink" href="http://gis.ktn.gv.at/arcgis/services/INSPIRE/INSPIRE/MapServer/WmsServer?service=wms&amp;version=1.3.0&amp;request=getcapabilities">http://gis.ktn.gv.at/arcgis/services/INSPIRE/INSPIRE/MapServer/WmsServer?service=wms&amp;version=1.3.0&amp;request=getcapabilities</a>), showing a list of the five available coordinate systems from a WMS service:</p><div><img src="img/B03543_02_04.jpg" alt="Listing projection(s) from a WMS server"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec42"/>Getting ready</h2></div></div></div><p>The WMS service URL that we will use is <a class="ulink" href="http://ogc.bgs.ac.uk/cgi-bin/BGS_1GE_Geology/wms?service=WMS&amp;version=1.3.0&amp;request=GetCapabilities">http://ogc.bgs.ac.uk/cgi-bin/BGS_1GE_Geology/wms?service=WMS&amp;version=1.3.0&amp;request=GetCapabilities</a>. This is from the British Geological Survey, titled <em>OneGeology Europe geology</em>.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>For a list of WMS servers that are available worldwide, refer to Skylab Mobile Systems at <a class="ulink" href="http://www.skylab-mobilesystems.com/en/wms_serverlist.html">http://www.skylab-mobilesystems.com/en/wms_serverlist.html</a>. Also, take a look at <a class="ulink" href="http://geopole.org/">http://geopole.org/</a>.</p></div></div><p>We will use a<a id="id99" class="indexterm"/> library called OWSLib. This library is a great package for working with OGC web services such as WMS, as follows:</p><div><pre class="programlisting">
<strong>Pip install owslib</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How to do it...</h2></div></div></div><p>Let's go through these steps to retrieve the projections that a WMS server provides and print the available EPSG codes to screen:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new Python file named <code class="literal">ch02_03_show_wms_srs.py</code> in your <code class="literal">/ch02/code/working/</code> directory, and add the following code:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

from owslib.wms import WebMapService

url = "http://ogc.bgs.ac.uk/cgi-bin/BGS_1GE_Geology/wms"

get_wms_url = WebMapService(url)

crs_list = get_wms_url.contents['GBR_Kilmarnock_BGS_50K_CompressibleGround'].crsOptions

print crs_list</pre></div></li><li class="listitem">Now, run the <code class="literal">ch02_03_show_wms_srs.py</code> script and you should see the following screen output:<div><pre class="programlisting">
<strong>$ python ch02_03_show_wms_srs.py</strong>
<strong>['EPSG:3857', 'EPSG:3034', 'EPSG:4326', 'EPSG:3031', 'EPSG:27700', 'EPSG:900913', 'EPSG:3413', 'CRS:84', 'EPSG:4258']</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec44"/>How it works...</h2></div></div></div><p>Determining<a id="id100" class="indexterm"/> information on the WMS projection involves using the OWSLib library. This is quite a powerful way to get all kinds of OGC web service information from your client. The code simply takes in the WMS URL to retrieve the WMS information. The content of the response is called, and we are able to access the <code class="literal">crsOptions</code> attribute to list out all the available EPSG codes.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Creating a projection definition for a Shapefile if it does not exist</h1></div></div></div><p>You <a id="id101" class="indexterm"/>recently downloaded a Shapefile from an Internet resource and saw that the <code class="literal">.prj</code> file was not included. You do know, however, that the data is stored in the EPSG:4326 coordinate system as stated on the website from where you downloaded the data. Now the following code will create a new <code class="literal">.prj</code> file.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Getting ready</h2></div></div></div><p>Start up your Python virtual environment with the <code class="literal">workon pygeo_analysis_cookbook</code> command:</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How to do it...</h2></div></div></div><p>In the following steps, we will take you through creating a new <code class="literal">.prj</code> file to accompany our Shapefile. The <code class="literal">.prj</code> extension is necessary for many spatial operations performed by a desktop GIS, web service, or script:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new Python file named <code class="literal">ch02_04_write_prj_file.py</code> in your <code class="literal">/ch02/code/working/</code> directory and add the following code:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import urllib
import os

def get_epsg_code(epsg):
   """
   Get the ESRI formatted .prj definition
   usage get_epsg_code(4326)

   We use the http://spatialreference.org/ref/epsg/4326/esriwkt/
   """
  
   f=urllib.urlopen("http://spatialreference.org/ref/epsg/{0}/esriwkt/".format(epsg))
   return (f.read())

# Shapefile filename must equal the new .prj filename
shp_filename = "../geodata/UTM_Zone_Boundaries"


# Here we write out a new .prj file with the same name
# as our Shapefile named "schools" in this example

with open("../geodata/{0}.prj".format(shp_filename), "w") as prj:
    epsg_code = get_epsg_code(4326)
    prj.write(epsg_code)
    print "done writing projection definition to EPSG: " + epsg_code </pre></div></li><li class="listitem">Now, run the <code class="literal">ch02_04_write_prj_file.py</code> script:<div><pre class="programlisting">
<strong>$ python ch02_04_write_prj_file.py</strong>
</pre></div></li><li class="listitem">You <a id="id102" class="indexterm"/>should see the following screen output:<div><pre class="programlisting">
<strong>done writing projection definition UTM_Zone_Boundaries.prj to EPSG:4326</strong>
</pre></div></li><li class="listitem">Inside your folder, you should see a new <code class="literal">.prj</code> file created with the same name as the Shapefile.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How it works...</h2></div></div></div><p>We first wrote a function to fetch our projection definition text using the <a class="ulink" href="http://spatialreference.org/">http://spatialreference.org/</a> API by passing the EPSG code value. The function returns a textual description of the EPSG code information using the <code class="literal">esriwkt</code> formatting style, indicating ESRI Well-Known Text, which is the format that the ESRI software uses to store the <code class="literal">.prj</code> file information.</p><p>Then we need to input the Shapefile name because the filename of <code class="literal">.prj</code> must be equal to the Shapefile name.</p><p>In the last step, we'll create the <code class="literal">.prj</code> file using <code class="literal">shp_filename</code> that is specified, and call the function that we wrote to get the text definition of the coordinate reference system.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Batch setting the projection definition of a folder full of Shapefiles</h1></div></div></div><p>Working <a id="id103" class="indexterm"/>with one Shapefile is fine but working with tens or hundreds of files is something else. In such a scenario, we'll need automation to get a job done fast.</p><p>We have a folder that contains several Shapefiles that are all in the same coordinate system but do not have a <code class="literal">.prj</code> file. We want to create a <code class="literal">.prj</code> file for each Shapefile in the current directory.</p><p>This script is a modified version of the previous code example that could write a <code class="literal">.prj</code> file for a single Shapefile into a batch process that can run over several Shapefiles.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>How to do it...</h2></div></div></div><p>We have a folder with many Shapefiles and we would like to create a new <code class="literal">.prj</code> file for each Shapefile in this folder, so let's get started:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new Python file named <code class="literal">ch02_05_batch_shp_prj.py</code> in your <code class="literal">/ch02/code/working/</code> directory and add the following code:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import urllib
import os
from osgeo import osr


def create_epsg_wkt_esri(epsg):
    """
    Get the ESRI formatted .prj definition
    usage create_epsg_wkt(4326)

    We use the http://spatialreference.org/ref/epsg/4326/esriwkt/

    """
    spatial_ref = osr.SpatialReference()
    spatial_ref.ImportFromEPSG(epsg)

    # transform projection format to ESRI .prj style
    spatial_ref.MorphToESRI()

    # export to WKT
    wkt_epsg = spatial_ref.ExportToWkt()

    return wkt_epsg


# Optional method to get EPGS as wkt from a web service
def get_epsg_code(epsg):
    """
    Get the ESRI formatted .prj definition
    usage get_epsg_code(4326)

    We use the http://spatialreference.org/ref/epsg/4326/esriwkt/

    """
    web_url = "http://spatialreference.org/ref/epsg/{0}/esriwkt/".format(epsg)
    f = urllib.urlopen(web_url)
    return f.read()


# Here we write out a new .prj file with the same name
# as our Shapefile named "schools" in this example
def write_prj_file(folder_name, shp_filename, epsg):
    """
    input the name of a Shapefile without the .shp
    input the EPSG code number as an integer

    usage  write_prj_file(&lt;ShapefileName&gt;,&lt;EPSG CODE&gt;)

    """

    in_shp_name = "/{0}.prj".format(shp_filename)
    full_path_name = folder_name + in_shp_name

    with open(full_path_name, "w") as prj:
        epsg_code = create_epsg_wkt_esri(epsg)
        prj.write(epsg_code)
        print ("done writing projection definition : " + epsg_code)


def run_batch_define_prj(folder_location, epsg):
    """
    input path to the folder location containing
    all of your Shapefiles

    usage  run_batch_define_prj("../geodata/no_prj")

    """

    # variable to hold our list of shapefiles
    shapefile_list = []

    # loop through the directory and find shapefiles
    # for each found shapefile write it to a list
    # remove the .shp ending so we do not end up with 
    # file names such as .shp.prj
    for shp_file in os.listdir(folder_location):
        if shp_file.endswith('.shp'):
            filename_no_ext = os.path.splitext(shp_file)[0]
            shapefile_list.append(filename_no_ext)

    # loop through the list of shapefiles and write
    # the new .prj for each shapefile
    for shp in shapefile_list:
        write_prj_file(folder_location, shp, epsg)


# Windows users please use the full path
# Linux users can also use full path        
run_batch_define_prj("c:/02_DEV/01_projects/04_packt/ch02/geodata/no_prj/", 4326)</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>How it works...</h2></div></div></div><p>Using the<a id="id104" class="indexterm"/> standard <code class="literal">urllib</code> Python module, we can access an EPSG code via the Web and write this definition to a <code class="literal">.prj</code> file. We need to create a list of Shapefiles that we want to define <code class="literal">.prj</code> for and then create a <code class="literal">.prj</code> file for each Shapefile in this list.</p><p>The <code class="literal">get_epsg_code(epsg)</code> function returns the ESPG code text definition that we need. The <code class="literal">write_prj_file(shp_filename, epsg)</code> function takes two parameters, the Shapefile name and the EPSG code, writing out the <code class="literal">.prj</code> file to disk.</p><p>Next, we'll create an empty list to store the list of Shapefiles, switch to the directory where the Shapefiles are stored, and then list all the Shapefiles that currently in this directory.</p><p>Our <code class="literal">for</code> loop then populates the Shapefile list with the filenames without the <code class="literal">.shp</code> extension. Finally, the<a id="id105" class="indexterm"/> last <code class="literal">for</code> loop takes us through each Shapefile and calls our function to write each <code class="literal">.prj</code> file for each Shapefile in the list.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Reprojecting a Shapefile from one projection to another</h1></div></div></div><p>Working <a id="id106" class="indexterm"/>with spatial data from multiple sources leads to data that's most likely from multiple regions on Earth with multiple coordinate systems. To perform consistent spatial analysis, we should transform all our input data into the same coordinate system. This means reprojecting your Shapefile into your chosen working coordinate system.</p><p>In this recipe, we will reproject a single Shapefile from ESPG:4326 into a web mercator system EPSG:3857 for use in a web application.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How to do it...</h2></div></div></div><p>Our goal is to reproject a given Shapefile from one coordinate system to another; the steps to do this are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new Python file named <code class="literal">ch02_06_re_project_shp.py</code> in your <code class="literal">/ch02/code/working/</code> directory and add the following code:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import ogr
import osr
import os

shp_driver = ogr.GetDriverByName('ESRI Shapefile')

# input SpatialReference
input_srs = osr.SpatialReference()
input_srs.ImportFromEPSG(4326)

# output SpatialReference
output_srs = osr.SpatialReference()
output_srs.ImportFromEPSG(3857)

# create the CoordinateTransformation
coord_trans = osr.CoordinateTransformation(input_srs, output_srs)

# get the input layer
input_shp = shp_driver.Open(r'../geodata/UTM_Zone_Boundaries.shp')
in_shp_layer = input_shp.GetLayer()

# create the output layer
output_shp_file = r'../geodata/UTM_Zone_Boundaries_3857.shp'
# check if output file exists if yes delete it
if os.path.exists(output_shp_file):
    shp_driver.DeleteDataSource(output_shp_file)

# create a new Shapefile object
output_shp_dataset = shp_driver.CreateDataSource(output_shp_file)

# create a new layer in output Shapefile and define its geometry type
output_shp_layer = output_shp_dataset.CreateLayer("basemap_3857", geom_type=ogr.wkbMultiPolygon)

# add fields to the new output Shapefile
# get list of attribute fields
# create new fields for output
in_layer_def = in_shp_layer.GetLayerDefn()
for i in range(0, in_layer_def.GetFieldCount()):
    field_def = in_layer_def.GetFieldDefn(i)
    output_shp_layer.CreateField(field_def)

# get the output layer's feature definition
output_layer_def = output_shp_layer.GetLayerDefn()

# loop through the input features
in_feature = in_shp_layer.GetNextFeature()
while in_feature:
    # get the input geometry
    geom = in_feature.GetGeometryRef()
    # reproject the geometry
    geom.Transform(coord_trans)
    # create a new feature
    output_feature = ogr.Feature(output_layer_def)
    # set the geometry and attribute
    output_feature.SetGeometry(geom)
    for i in range(0, output_layer_def.GetFieldCount()):
        output_feature.SetField(output_layer_def.GetFieldDefn(i).GetNameRef(), in_feature.GetField(i))
    # add the feature to the shapefile
    output_shp_layer.CreateFeature(output_feature)
    # destroy the features and get the next input feature
    output_feature.Destroy()
    in_feature.Destroy()
    in_feature = in_shp_layer.GetNextFeature()

# close the shapefiles
input_shp.Destroy()
output_shp_dataset.Destroy()

spatialRef = osr.SpatialReference()
spatialRef.ImportFromEPSG(3857)

spatialRef.MorphToESRI()
prj_file = open('UTM_Zone_Boundaries.prj', 'w')
prj_file.write(spatialRef.ExportToWkt())
prj_file.close()</pre></div></li><li class="listitem">Now we can run our code from the command line as follows:<div><pre class="programlisting">
<strong>$ python ch02_06_re_project_shp.py</strong>
</pre></div></li><li class="listitem">We now<a id="id107" class="indexterm"/> have a new Shapefile called <code class="literal">UTM_Zone_Boundaries_3857.shp</code> that is in the <code class="literal">EPSG:3857</code> coordinate system and is ready for further use.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>How it works...</h2></div></div></div><p>The <code class="literal">osgeo</code>, <code class="literal">ogr</code>, and <code class="literal">osr</code> modules do the heavy lifting and the code required to reproject a Shapefile is quite verbose. It works by going through each geometry and transforming it individually into the new coordinate system.</p><p>Starting with the driver for the ESRI Shapefile, we'll work at setting our input and output <strong>Spatial Reference System</strong> (<strong>SRS</strong>) so<a id="id108" class="indexterm"/> that we can transform the two.</p><p>We need to copy each feature's geometry and its attributes from the old Shapefile into the new one as we transform each geometry. Finally, we'll close the input and output Shapefile with the <code class="literal">Destroy()</code> function.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec52"/>See also</h2></div></div></div><p>Using code is not always the best or fastest way to reproject a Shapefile. Another method that you could use is the <code class="literal">ogr2ogr</code> command-line tool that will simply reproject a Shapefile in one line. You could pipe this one-liner into a Python script and batch reproject many Shapefiles:</p><div><pre class="programlisting">
<strong>ogr2ogr -t_srs EPSG:4326 outputwith4236.shp input.shp</strong>
</pre></div><p>The GDAL library <a id="id109" class="indexterm"/>comes with several other very useful and helpful command-line functions that are worth checking out.</p></div></div></div>
</body></html>