["```py\n# Loading your IBM Quantum account(s)\nservice = QiskitRuntimeService(channel=\"ibm_quantum\", token=\"API_TOKEN\") \n```", "```py\n# Create a simple circuit:\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister,   \n                   transpile\nfrom qiskit.visualization import plot_distribution\nq_reg = QuantumRegister(4, name='qr')\nc_reg = ClassicalRegister(4, name='cr')\nqc = QuantumCircuit(q_reg, c_reg)\nqc.h(0)\nqc.cx(0, 1)\nqc.cx(1, 2)\nqc.cx(2, 3)\nqc.draw(output=\"mpl\") \n```", "```py\nfrom qiskit.quantum_info import Statevector\n# Pass the circuit instructions into the Statevector\nresults = Statevector.from_instruction(qc).probabilities_dict()\nplot_distribution(results) \n```", "```py\n# Add measurements to our circuit\nqc.measure_all(add_bits=False)\n# Select the least busy backend system to run circuit\nbackend = service.least_busy(simulator=False, operational=True)\nprint(\"Least busy backend: \", backend) \n```", "```py\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\ntarget = backend.target\npm = generate_preset_pass_manager(target=target, optimization_level=3)\ntranspiled_qc = pm.run(qc)\ntranspiled_qc.draw(output=\"mpl\", idle_wires=False, style=\"iqp\") \n```", "```py\nfrom qiskit.circuit.library import GroverOperator\noracle = Statevector.from_label(\"110\")\ngrover_qc = QuantumCircuit(3)\ngrover_qc.h(range(3))\ngrover_qc = grover_qc.compose(GroverOperator(oracle))\ngrover_qc.draw(output=\"mpl\") \n```", "```py\nresults = Statevector.from_instruction(grover_qc).probabilities_dict() \n```", "```py\ngrover_qc.measure_all()\ntranspiled_grover_qc = pm.run(grover_qc)\ntranspiled_grover_qc.draw(output=\"mpl\", idle_wires=False, style=\"iqp\") \n```", "```py\ncircuits=[]\nfor optimization_level in [0,3]:\n    transpiled_grover_qc = transpile(grover_qc, backend, optimization_level=optimization_level, seed_transpiler=1000)\n    print(f\"ECR (Optimization level={optimization_level}): \", transpiled_grover_qc.count_ops()[\"ecr\"])\n    circuits.append(transpiled_grover_qc) \n```", "```py\nECRs (optimization_level=0):  24\nECRs (optimization_level=3):  14 \n```", "```py\nwith Batch(service=service, backend=backend):\n    sampler = Sampler()\n    job = sampler.run(\n        circuits=circuits,\n        skip_transpilation=True,\n        shots=8000\n    )\n    result = job.result() \n```", "```py\nSamplerResult(quasi_dists=[{0: 0.136596417234717, 1: 0.057482039100449, 2: 0.03807773583055, 3: 0.051080549862785, 4: 0.028575374054239, 5: 0.068434342226471, 6: 0.540689745421478, 7: 0.079063796269311}, {0: \n0.013241830253957, 1: 0.044991185036454, 2: 0.066493715476242, 3: 0.033981414166734, 4: 0.077452855226391, 5: 0.045273457404358, 6: 0.654480551636603, 7: 0.064084990799261}], metadata=[{'shots': 8000, 'circuit_metadata': {}, 'readout_mitigation_overhead': 1.2784314899265776, 'readout_mitigation_time': 0.03348202304914594}, {'shots': 8000, 'circuit_metadata': {}, 'readout_mitigation_overhead': 1.0800027370262115, 'readout_mitigation_time': 0.0965154911391437}]) \n```", "```py\nqc_results = [quasi_dist.binary_probabilities() for quasi_dist in result.quasi_dists]\nplot_histogram(\n    qc_results + [results],\n    legend=[\n        \"optimization_level=0\",\n        \"optimization_level=3\",\n        \"Simulated results\"\n    ],\n    bar_labels=False\n) \n```", "```py\n%run helper_file_1.0.ipynb\nimport numpy as np\nfrom qiskit.circuit.library import XGate\nfrom qiskit.transpiler import PassManager, InstructionDurations\nfrom qiskit.transpiler.passes import ALAPScheduleAnalysis, PadDynamicalDecoupling\nfrom qiskit.visualization import timeline_drawer \n```", "```py\n# Select a random backend you have access to, or pick the least busy:\nbackend = service.get_backend('ibm_kyoto')\n# Pull and print the duration times of the backend system for each get per qubit:\ndur = InstructionDurations.from_backend(backend)\nprint(dur) \n```", "```py\nx(0,): 3.5555555555555554e-08 s\nx(1,): 3.5555555555555554e-08 s\nx(2,): 3.5555555555555554e-08 s\nx(3,): 3.5555555555555554e-08 s\nx(4,): 3.5555555555555554e-08 s \n```", "```py\n # Set the duration times for each gate.\ncustom_duration_times = InstructionDurations([('x', None, 100),\n                                              ('h', 0, 100),\n                                              (\"cx\", [0, 1], 200),\n                                              (\"cx\", [1, 2], 200), \n                                              (\"cx\", [2, 3], 200),\n                                              (\"measure\", None, 500\n                                                  )])\n# Print the timescales for each gate we set:\nprint(custom_duration_times) \n```", "```py\n#Let's transpile the circuit and view the default timeline\ntranspiled_qc = transpile(qc, backend, scheduling_method='alap',\nlayout_method='trivial')\ntimeline_drawer(transpiled_qc, time_range=[0,5500], show_idle=False) \n```", "```py\n# Create the Dynamical Decoupling sequence of reversible gates, let's use XGates:\nrev_gates = [XGate(), XGate()]\n# Set the PassManager with the Dynamical Decoupling sequence and custom duration times\npm = PassManager([ALAPScheduleAnalysis(custom_duration_times),\n                  PadDynamicalDecoupling(custom_duration_times, rev_gates)]) \n```", "```py\n# Run the circuit through the PassManager to add the DD to the circuit\nqc_dynamical_decoupling = pm.run(transpiled_qc) \n```", "```py\ntimeline_drawer(qc_dynamical_decoupling, show_idle=False) \n```", "```py\n# Update durations\nupdated_values = [('x', None, 1500)]\nupdated_durations = custom_duration_times.update(updated_values)\nprint(updated_durations) \n```", "```py\n# Set the PassManager with the Dynamical Decoupling sequence and custom duration times\npm = PassManager([ALAPScheduleAnalysis(updated_durations),\n                  PadDynamicalDecoupling(updated_durations, rev_gates)])\nqc_dynamical_decoupling = pm.run(transpiled_qc)\ntimeline_drawer(qc_dynamical_decoupling, show_idle=False) \n```", "```py\nleast_busy_backend = service.least_busy(simulator=False, operational=True,    \n                         min_num_qubits=transpiled_qc.num_qubits)\n# Let's transpile the circuit to this new backend:\ntranspiled_qc=transpile(qc, backend=least_busy_backend)\noptions = Options()\noptions.execution.shots = 1000\noptions.optimization_level = 0  # No error suppression\noptions.resilience_level = 0  # No error mitigation\nwith Session(service=service, backend=least_busy_backend) as session:\n    sampler = Sampler(session=session, options=options)\n    job_sim_0 = sampler.run(transpiled_qc)\n    print(job_sim_0.result())\n    session.close()\nplot_distribution(job_sim_0.result().quasi_dists) \n```", "```py\nSamplerResult(quasi_dists=[{0: 0.463, 1: 0.011, 2: 0.006, 3: 0.008, 4: 0.008, 6: 0.001, 7: 0.009, 8: 0.01, 9: 0.001, 10: 0.008, 11: 0.01, 12: 0.006, 13: 0.014, 14: 0.099, 15: 0.346}], metadata=[{'shots': 1000}]) \n```", "```py\noptions.execution.shots = 1000\noptions.optimization_level = 3  # Levels 1-3 use Dynamical Decoupling\noptions.resilience_level = 1  # Level 1 uses TREX for error mitigation\nwith Session(service=service, backend=least_busy_backend) as session:\n    sampler = Sampler(session=session, options=options)\n    job_sim_1 = sampler.run(transpiled_qc)\n    print(job_sim_1.result())\n    session.close()\nplot_distribution(job_sim_1.result().quasi_dists) \n```", "```py\nSamplerResult(quasi_dists=[{0: 0.4741007821539706, 1: -0.00328801216329741, 2: -0.006989853410409116, 3: 0.0018169643386157586, 4: -0.005096477885881826, 5: 0.00010104383589854057, 6: 0.0016676295409465852, 7: 0.0017229622606998135, 8: 0.0038884349758400295, 11: -0.0025386992448873155, 12: 0.0014124334608473367, 13: 0.0009761688074426505, 14: 3.0231076968467426e-05, 15: 0.5321963922532457}], metadata=[{'shots': 1000, 'readout_mitigation_overhead': 1.6922534955446735, 'readout_mitigation_time': 0.059042368084192276}]) \n```"]