<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Restructuring Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Restructuring Data</h1></div></div></div><p>We already covered the most basic methods for restructuring data in the <a class="link" href="ch03.html" title="Chapter 3. Filtering and Summarizing Data">Chapter 3</a>, <span class="emphasis"><em>Filtering and Summarizing Data</em></span>, but of course, there are several other, more complex tasks that we will master in the forthcoming pages.</p><p>Just to give a quick example on how diversified tools are needed for getting the data in a form that can be used for real data analysis: Hadley Wickham, one of the best known R developers and users, spent one third of his PhD thesis on reshaping data. As he says, "it is unavoidable before doing any exploratory data analysis or visualization."</p><p>So now, besides the previous examples of restructuring data, such as the counting of elements in each group, we will focus on some more advanced features, as listed next:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Transposing matrices</li><li class="listitem" style="list-style-type: disc">Splitting, applying, and joining data</li><li class="listitem" style="list-style-type: disc">Computing margins of tables</li><li class="listitem" style="list-style-type: disc">Merging data frames</li><li class="listitem" style="list-style-type: disc">Casting and melting data</li></ul></div><div class="section" title="Transposing matrices"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Transposing matrices</h1></div></div></div><p>One of the most used, but<a class="indexterm" id="id300"/> often not mentioned, methods for restructuring data is transposing matrices. This simply means switching the columns with rows and vice versa, via the <code class="literal">t</code> function:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; (m &lt;- matrix(1:9, 3))</strong></span>
<span class="strong"><strong>     [,1] [,2] [,3]</strong></span>
<span class="strong"><strong>[1,]    1    4    7</strong></span>
<span class="strong"><strong>[2,]    2    5    8</strong></span>
<span class="strong"><strong>[3,]    3    6    9</strong></span>
<span class="strong"><strong>&gt; t(m)</strong></span>
<span class="strong"><strong>     [,1] [,2] [,3]</strong></span>
<span class="strong"><strong>[1,]    1    2    3</strong></span>
<span class="strong"><strong>[2,]    4    5    6</strong></span>
<span class="strong"><strong>[3,]    7    8    9</strong></span>
</pre></div><p>Of course, this <code class="literal">S3</code> method also works with <code class="literal">data.frame</code>, and actually, with any tabular object. For more advanced features, such as transposing a multi-dimensional table, take a look at the<a class="indexterm" id="id301"/> <code class="literal">aperm</code> function<a class="indexterm" id="id302"/> from the <code class="literal">base</code> package.</p></div></div>
<div class="section" title="Filtering data by string matching"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Filtering data by string matching</h1></div></div></div><p>Although some filtering algorithms were already discussed in the previous chapters, the <code class="literal">dplyr</code> package contains<a class="indexterm" id="id303"/> some magic features that have not<a class="indexterm" id="id304"/> yet been covered and are worth mentioning here. As we all know by this time, the <a class="indexterm" id="id305"/>
<code class="literal">subset</code> function in <code class="literal">base</code>, or the<a class="indexterm" id="id306"/> <code class="literal">filter</code> function from <code class="literal">dplyr</code> is used for filtering rows, and the <a class="indexterm" id="id307"/>
<code class="literal">select</code> function can be used to choose a subset of columns.</p><p>The function filtering rows usually takes an R expression, which returns the IDs of the rows to drop, similar to the <code class="literal">which</code> function. On the other hand, providing such R expressions to describe column names is often more problematic for the <code class="literal">select</code> function; it's harder if not impossible to evaluate R expressions on column names.</p><p>The <code class="literal">dplyr</code> package provides some useful functions to select some columns of the data, based on column name patterns. For example, we can keep only the variables ending with the string, <code class="literal">delay</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(dplyr)</strong></span>
<span class="strong"><strong>&gt; library(hflights)</strong></span>
<span class="strong"><strong>&gt; str(select(hflights, ends_with("delay")))</strong></span>
<span class="strong"><strong>'data.frame':  227496 obs. of  2 variables:</strong></span>
<span class="strong"><strong> $ ArrDelay: int  -10 -9 -8 3 -3 -7 -1 -16 44 43 ...</strong></span>
<span class="strong"><strong> $ DepDelay: int  0 1 -8 3 5 -1 -1 -5 43 43 ...</strong></span>
</pre></div><p>Of course, there is a similar helper function to check the first characters of the column names with <code class="literal">starts_with</code>, and both functions can ignore (by default) or take into account the upper or lower case of the characters with the <code class="literal">ignore.case</code> parameter. And we have the more general, <code class="literal">contains</code> function, looking for substrings in the column names:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; str(select(hflights, contains("T", ignore.case = FALSE)))</strong></span>
<span class="strong"><strong>'data.frame':  227496 obs. of  7 variables:</strong></span>
<span class="strong"><strong> $ DepTime          : int  1400 1401 1352 1403 1405 ...</strong></span>
<span class="strong"><strong> $ ArrTime          : int  1500 1501 1502 1513 1507 ...</strong></span>
<span class="strong"><strong> $ TailNum          : chr  "N576AA" "N557AA" "N541AA" "N403AA" ...</strong></span>
<span class="strong"><strong> $ ActualElapsedTime: int  60 60 70 70 62 64 70 59 71 70 ...</strong></span>
<span class="strong"><strong> $ AirTime          : int  40 45 48 39 44 45 43 40 41 45 ...</strong></span>
<span class="strong"><strong> $ TaxiIn           : int  7 6 5 9 9 6 12 7 8 6 ...</strong></span>
<span class="strong"><strong> $ TaxiOut          : int  13 9 17 22 9 13 15 12 22 19 ...</strong></span>
</pre></div><p>The other option is that we might need a more complex approach with regular expressions, which is another extremely important skill for data scientists. Now, we will provide a regular expression to the <code class="literal">matches</code> function, which is to be fitted against all the columns names. Let's select all the columns with a name comprising of 5 or 6 characters:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; str(select(hflights, matches("^[[:alpha:]]{5,6}$")))</strong></span>
<span class="strong"><strong>'data.frame':  227496 obs. of  3 variables:</strong></span>
<span class="strong"><strong> $ Month : int  1 1 1 1 1 1 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ Origin: chr  "IAH" "IAH" "IAH" "IAH" ...</strong></span>
<span class="strong"><strong> $ TaxiIn: int  7 6 5 9 9 6 12 7 8 6 ...</strong></span>
</pre></div><p>We can keep all <a class="indexterm" id="id308"/>column names that do not match a regular expression by using a negative sign before the expression. For example, let's identify<a class="indexterm" id="id309"/> the most frequent number of characters in the columns' names:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; table(nchar(names(hflights)))</strong></span>
<span class="strong"><strong> 4  5  6  7  8  9 10 13 16 17 </strong></span>
<span class="strong"><strong> 2  1  2  5  4  3  1  1  1  1</strong></span>
</pre></div><p>And then, let's remove all the columns with 7 or 8 characters from the dataset. Now, we will show the column names from the filtered dataset:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; names(select(hflights, -matches("^[[:alpha:]]{7,8}$")))</strong></span>
<span class="strong"><strong> [1] "Year"              "Month"             "DayofMonth"       </strong></span>
<span class="strong"><strong> [4] "DayOfWeek"         "UniqueCarrier"     "FlightNum"        </strong></span>
<span class="strong"><strong> [7] "ActualElapsedTime" "Origin"            "Dest"             </strong></span>
<span class="strong"><strong>[10] "TaxiIn"            "Cancelled"         "CancellationCode"</strong></span>
</pre></div></div>
<div class="section" title="Rearranging data"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Rearranging data</h1></div></div></div><p>Sometimes, we do<a class="indexterm" id="id310"/> not want to filter any part of the data (neither the rows, nor the columns), but the data is simply not in the most useful order due to convenience or performance issues, as we have seen, for instance, in <a class="link" href="ch03.html" title="Chapter 3. Filtering and Summarizing Data">Chapter 3</a>, <span class="emphasis"><em>Filtering and Summarizing Data</em></span>.</p><p>Besides the base <code class="literal">sort</code> and <code class="literal">order</code> functions, or providing the order of variables passed to the <code class="literal">[</code> operator, we can also use some SQL-like solutions with the <code class="literal">sqldf</code> package, or query the data in the right format directly from the database. And the previously mentioned <code class="literal">dplyr</code> package also provides an effective method for ordering data. Let's sort the <code class="literal">hflights</code> data, based on the actual elapsed time for each of the quarter million flights:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; str(arrange(hflights, ActualElapsedTime))</strong></span>
<span class="strong"><strong>'data.frame':  227496 obs. of  21 variables:</strong></span>
<span class="strong"><strong> $ Year             : int  2011 2011 2011 2011 2011 2011 ...</strong></span>
<span class="strong"><strong> $ Month            : int  7 7 8 9 1 4 5 6 7 8 ...</strong></span>
<span class="strong"><strong> $ DayofMonth       : int  24 25 13 21 3 29 9 21 8 2 ...</strong></span>
<span class="strong"><strong> $ DayOfWeek        : int  7 1 6 3 1 5 1 2 5 2 ...</strong></span>
<span class="strong"><strong> $ DepTime          : int  2005 2302 1607 1546 1951 2035 ...</strong></span>
<span class="strong"><strong> $ ArrTime          : int  2039 2336 1641 1620 2026 2110 ...</strong></span>
<span class="strong"><strong> $ UniqueCarrier    : chr  "WN" "XE" "WN" "WN" ...</strong></span>
<span class="strong"><strong> $ FlightNum        : int  1493 2408 912 2363 2814 2418 ...</strong></span>
<span class="strong"><strong> $ TailNum          : chr  "N385SW" "N12540" "N370SW" "N524SW" ...</strong></span>
<span class="strong"><strong> $ ActualElapsedTime: int  34 34 34 34 35 35 35 35 35 35 ...</strong></span>
<span class="strong"><strong> $ AirTime          : int  26 26 26 26 23 23 27 26 25 25 ...</strong></span>
<span class="strong"><strong> $ ArrDelay         : int  9 -8 -4 15 -19 20 35 -15 86 -9 ...</strong></span>
<span class="strong"><strong> $ DepDelay         : int  20 2 7 26 -4 35 45 -8 96 1 ...</strong></span>
<span class="strong"><strong> $ Origin           : chr  "HOU" "IAH" "HOU" "HOU" ...</strong></span>
<span class="strong"><strong> $ Dest             : chr  "AUS" "AUS" "AUS" "AUS" ...</strong></span>
<span class="strong"><strong> $ Distance         : int  148 140 148 148 127 127 148 ...</strong></span>
<span class="strong"><strong> $ TaxiIn           : int  3 3 4 3 4 4 5 3 5 4 ...</strong></span>
<span class="strong"><strong> $ TaxiOut          : int  5 5 4 5 8 8 3 6 5 6 ...</strong></span>
<span class="strong"><strong> $ Cancelled        : int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ CancellationCode : chr  "" "" "" "" ...</strong></span>
<span class="strong"><strong> $ Diverted         : int  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
</pre></div><p>Well, it's pretty straightforward that flights departing to Austin are among the first few records shown. For improved readability, the above three R expressions can be called in a much nicer way with the<a class="indexterm" id="id311"/> pipe operator from the automatically imported <a class="indexterm" id="id312"/>
<code class="literal">magrittr</code> package, which provides a simple way to pass an R object as the first argument of the subsequent R expression:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights %&gt;% arrange(ActualElapsedTime) %&gt;% str</strong></span>
</pre></div><p>So, instead of nesting R functions, we can now start our R command with the core object and pass the results of each evaluated R expression to the next one in the chain. In most cases, this makes the code more convenient to read. Although most hardcore R programmers have already gotten used to reading the nested function calls from inside-out, believe me, it's pretty easy to get used to this nifty feature! Do not let me confuse you with the inspiring painting of René Magritte, which became the slogan, "This is not a pipe," and a symbol of the <code class="literal">magrittr</code> package:</p><div class="mediaobject"><img alt="Rearranging data" src="graphics/2028OS_06_01.jpg"/></div><p>There is no limit to the number of chainable R expressions and objects one can have. For example, let's also<a class="indexterm" id="id313"/> filter a few cases and variables to see how easy it is to follow the data restructuring steps with <code class="literal">dplyr</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights %&gt;%</strong></span>
<span class="strong"><strong>+     arrange(ActualElapsedTime) %&gt;%</strong></span>
<span class="strong"><strong>+     select(ActualElapsedTime, Dest) %&gt;%</strong></span>
<span class="strong"><strong>+     subset(Dest != 'AUS') %&gt;%</strong></span>
<span class="strong"><strong>+     head %&gt;%</strong></span>
<span class="strong"><strong>+     str</strong></span>
<span class="strong"><strong>'data.frame':  6 obs. of  2 variables:</strong></span>
<span class="strong"><strong> $ ActualElapsedTime: int  35 35 36 36 37 37</strong></span>
<span class="strong"><strong> $ Dest             : chr  "LCH" "LCH" "LCH" "LCH" ...</strong></span>
</pre></div><p>So, now we have filtered the original dataset a few times to see the closest airport after Austin, and the code is indeed easy to read and understand. This is a nice and efficient way to filter data, although some prefer to use nifty one-liners with the <code class="literal">data.table</code> package:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; str(head(data.table(hflights, key = 'ActualElapsedTime')[Dest !=</strong></span>
<span class="strong"><strong>+   'AUS', c('ActualElapsedTime', 'Dest'), with = FALSE]))</strong></span>
<span class="strong"><strong>Classes 'data.table' and 'data.frame':  6 obs. of  2 variables:</strong></span>
<span class="strong"><strong> $ ActualElapsedTime: int  NA NA NA NA NA NA</strong></span>
<span class="strong"><strong> $ Dest             : chr  "MIA" "DFW" "MIA" "SEA" ...</strong></span>
<span class="strong"><strong> - attr(*, "sorted")= chr "ActualElapsedTime"</strong></span>
<span class="strong"><strong> - attr(*, ".internal.selfref")=&lt;externalptr&gt;</strong></span>
</pre></div><p>Almost perfect! The only problem is that we got different results due to the missing values, which were ordered at the beginning of the dataset while we defined the <code class="literal">data.table</code> object to<a class="indexterm" id="id314"/> be indexed by <code class="literal">ActualElapsedTime</code>. To overcome this issue, let's drop the <code class="literal">NA</code> values, and instead of specifying the column names as strings along with forcing the <code class="literal">with</code> parameter to be <code class="literal">FALSE</code>, let's pass a list of column names:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; str(head(na.omit(</strong></span>
<span class="strong"><strong>+   data.table(hflights, key = 'ActualElapsedTime'))[Dest != 'AUS',</strong></span>
<span class="strong"><strong>+     list(ActualElapsedTime, Dest)]))</strong></span>
<span class="strong"><strong>Classes 'data.table' and 'data.frame':  6 obs. of  2 variables:</strong></span>
<span class="strong"><strong> $ ActualElapsedTime: int  35 35 36 36 37 37</strong></span>
<span class="strong"><strong> $ Dest             : chr  "LCH" "LCH" "LCH" "LCH" ...</strong></span>
<span class="strong"><strong> - attr(*, "sorted")= chr "ActualElapsedTime"</strong></span>
<span class="strong"><strong> - attr(*, ".internal.selfref")=&lt;externalptr&gt;</strong></span>
</pre></div><p>This is exactly the same results as we have seen before. Please note that in this example, we have omitted the <code class="literal">NA</code> values after transforming <code class="literal">data.frame</code> to <code class="literal">data.table</code>, indexed by the <code class="literal">ActualElapsedTime</code> variable, which is a lot faster compared to calling <code class="literal">na.omit</code> on <code class="literal">hflights</code> first and then evaluating all the other R expressions:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; system.time(str(head(data.table(na.omit(hflights),</strong></span>
<span class="strong"><strong>+   key = 'ActualElapsedTime')[Dest != 'AUS',</strong></span>
<span class="strong"><strong>+     c('ActualElapsedTime', 'Dest'), with = FALSE])))</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.374   0.017   0.390 </strong></span>
<span class="strong"><strong>&gt; system.time(str(head(na.omit(data.table(hflights,</strong></span>
<span class="strong"><strong>+   key = 'ActualElapsedTime'))[Dest != 'AUS',</strong></span>
<span class="strong"><strong>+     c('ActualElapsedTime', 'Dest'), with = FALSE])))</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>   0.22    0.00    0.22</strong></span>
</pre></div></div>
<div class="section" title="dplyr versus data.table"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>dplyr versus data.table</h1></div></div></div><p>You might now be wondering, "which package should we use?"</p><p>The <code class="literal">dplyr</code> and <code class="literal">data.table</code> packages provide a spectacularly different syntax and a slightly less determinative difference in performance. Although <code class="literal">data.table</code> seems to be slightly more effective on larger datasets, there is no clear winner in this spectrum—except for doing aggregations on a high number of groups. And to be honest, the syntax of <code class="literal">dplyr</code>, provided by the <code class="literal">magrittr</code> package, can be also used by the <code class="literal">data.table</code> objects if needed.</p><p>Also, there is another R package that provides pipes in R, called the<a class="indexterm" id="id315"/> <code class="literal">pipeR</code> package, which claims to be a lot more effective on larger datasets than <code class="literal">magrittr</code>. This performance gain is due to the fact that the <code class="literal">pipeR</code> operators do not try to be smart like the F# language's <code class="literal">|&gt;</code>-compatible operator in <code class="literal">magrittr</code>. Sometimes, this performance overhead is estimated to be 5-15 times more than the ones where no pipes are used at all.</p><p>One should take<a class="indexterm" id="id316"/> into account the community and support behind an R package before spending a reasonable amount of time learning about its usage. In a nutshell, the <code class="literal">data.table</code> package is now mature enough, without doubt, for production usage, as the development was started around 6 years ago by Matt Dowle, who was working for a large hedge fund at that time. The development has been continuous since then. Matt and Arun (co-developer of the package) release new features and performance tweaks from time to time, and they both seem to be keen on providing support on the public R forums and channels, such as mailing lists and StackOverflow.</p><p>On the other hand, <code class="literal">dplyr</code> is shipped by Hadley Wickham and RStudio, one of the most well-known persons and trending companies in the R community, which translates to an even larger user-base, community, and kind-of-instant support on StackOverflow and GitHub.</p><p>In short, I suggest using the packages that fit your needs best, after dedicating some time to discover the power and features they make available. If you are coming from an SQL background, you'll probably find <code class="literal">data.table</code> a lot more convenient, while others rather opt for the Hadleyverse (take a look at the R package with this name; it installs a bunch of useful R packages developed by Hadley). You should not mix the two approaches in a single project, as both for readability and performance issues, it's better to stick to only one syntax at a time.</p><p>To get a deeper understanding of the pros and cons of the different approaches, I will continue to provide multiple implementations of the same problem in the following few pages as well.</p></div>
<div class="section" title="Computing new variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Computing new variables</h1></div></div></div><p>One of the most trivial <a class="indexterm" id="id317"/>actions we usually perform while restructuring a dataset is to create a new variable. For a traditional <code class="literal">data.frame</code>, it's as simple as assigning a <code class="literal">vector</code> to a new variable of the R object.</p><p>Well, this method also works with <code class="literal">data.table</code>, but the usage is deprecated due to the fact that there is a much more efficient way of creating one, or even multiple columns in the dataset:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_dt &lt;- data.table(hflights)</strong></span>
<span class="strong"><strong>&gt; hflights_dt[, DistanceKMs := Distance / 0.62137]</strong></span>
</pre></div><p>We have just computed the distances, in kilometers, between the origin and destination airports with a simple division; although all the hardcore users can head for the <code class="literal">udunits2</code> package, which<a class="indexterm" id="id318"/> includes a bunch of conversion tools based on Unidata's <code class="literal">udunits</code> library.</p><p>And as can be seen previously, data.table uses that special  := assignment operator inside of the square brackets, which might seem strange at first glance, but you will love it!</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>The <code class="literal">:=</code> operator can be more than 500 times faster than the traditional <code class="literal">&lt;-</code> assignment, which is based on the official <code class="literal">data.table</code> documentation. This speedup is due to not copying the whole dataset into the memory like R used to do before the 3.1 version. Since then, R has used shallow copies, which greatly improved the performance of column updates, but is still beaten by <code class="literal">data.table</code> powerful in-place updates.</p></div></div><p>Compare the speed <a class="indexterm" id="id319"/>of how the preceding computation was run with the traditional <code class="literal">&lt;-</code> operator and <code class="literal">data.table</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; system.time(hflights_dt$DistanceKMs &lt;-</strong></span>
<span class="strong"><strong>+   hflights_dt$Distance / 0.62137)</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.017   0.000   0.016 </strong></span>
<span class="strong"><strong>&gt; system.time(hflights_dt[, DistanceKMs := Distance / 0.62137])</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.003   0.000   0.002</strong></span>
</pre></div><p>This is impressive, right? But it's worth double checking what we've just done. The first traditional call, of course, create/updates the <code class="literal">DistanceKMs</code> variable, but what happens in the second call? The <code class="literal">data.table</code> syntax did not return anything (visibly), but in the background, the <code class="literal">hflights_dt</code> R object was updated in-place due to the <code class="literal">:=</code> operator.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>Please note that the <code class="literal">:=</code> operator can produce unexpected results when used inside of <code class="literal">knitr</code>, such as returning the <code class="literal">data.table</code> visible after the creation of a new variable, or strange rendering of the command when the return is <code class="literal">echo = TRUE</code>. As a workaround, Matt Dowle suggests increasing the <code class="literal">depthtrigger</code> option of <code class="literal">data.table</code>, or one can simply reassign the <code class="literal">data.table</code> object with the same name. Another solution might be to use my <code class="literal">pander</code> package over <code class="literal">knitr</code>. :)</p></div></div><p>But once again, how was it so fast?</p><div class="section" title="Memory profiling"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Memory profiling</h2></div></div></div><p>The magic of the <code class="literal">data.table</code> package—besides having more than 50 percent of C code in the sources—is copying objects in memory only if it's truly necessary. This means that R often copies objects in memory while updating those, and <code class="literal">data.table</code> tries to keep these resource-hungry<a class="indexterm" id="id320"/> actions at a minimal level. Let's verify this by analyzing the previous example with the help of the <a class="indexterm" id="id321"/>
<code class="literal">pryr</code> package, which provides convenient access to some helper functions for memory profiling and understanding R-internals.</p><p>First, let's recreate the <code class="literal">data.table</code> object and let's take a note of the pointer value (location address of the object in the memory), so that we will be able to verify later if the new variable simply updated the same R object, or if it was copied in the memory while the operation took place:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(pryr)</strong></span>
<span class="strong"><strong>&gt; hflights_dt &lt;- data.table(hflights)</strong></span>
<span class="strong"><strong>&gt; address(hflights_dt)</strong></span>
<span class="strong"><strong>[1] "0x62c88c0"</strong></span>
</pre></div><p>Okay, so <code class="literal">0x62c88c0</code> refers to the location where <code class="literal">hflights_dt</code> is stored at the moment. Now, let's check if it changes due to the traditional assignment operator:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_dt$DistanceKMs &lt;- hflights_dt$Distance / 0.62137</strong></span>
<span class="strong"><strong>&gt; address(hflights_dt)</strong></span>
<span class="strong"><strong>[1] "0x2c7b3a0"</strong></span>
</pre></div><p>This is definitely a different location, which means that adding a new column to the R object also requires R to copy the whole object in the memory. Just imagine, we now moved 21 columns in memory due to adding another one.</p><p>Now, to bring about the usage of <code class="literal">:=</code> in <code class="literal">data.table</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_dt &lt;- data.table(hflights)</strong></span>
<span class="strong"><strong>&gt; address(hflights_dt)</strong></span>
<span class="strong"><strong>[1] "0x8ca2340"</strong></span>
<span class="strong"><strong>&gt; hflights_dt[, DistanceKMs := Distance / 0.62137]</strong></span>
<span class="strong"><strong>&gt; address(hflights_dt)</strong></span>
<span class="strong"><strong>[1] "0x8ca2340"</strong></span>
</pre></div><p>The location of the R object in the memory did not change! And copying objects in the memory can cost you a lot of resources, thus a lot of time. Take a look at the following example, which is a slightly updated version of the above traditional variable assignment call, but with an added convenience layer of <code class="literal">within</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; system.time(within(hflights_dt, DistanceKMs &lt;- Distance / 0.62137))</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.027   0.000   0.027</strong></span>
</pre></div><p>Here, using the <code class="literal">within</code> function probably copies the R object once more in the memory, and hence brings about the relatively serious performance overhead. Although the absolute time difference between the preceding examples might not seem very significant (not in the <a class="indexterm" id="id322"/>statistical context), but just imagine how the needless memory updates can affect the processing time of your data analysis with some larger datasets!</p></div><div class="section" title="Creating multiple variables at a time"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Creating multiple variables at a time</h2></div></div></div><p>One nice feature of <code class="literal">data.table</code> is the creation of multiple columns with a single command, which can be extremely useful in some cases. For example, we might be interested in the distance <a class="indexterm" id="id323"/>of airports in feet as well:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_dt[, c('DistanceKMs', 'DiastanceFeets') :=</strong></span>
<span class="strong"><strong>+   list(Distance / 0.62137, Distance * 5280)]</strong></span>
</pre></div><p>So, it's as simple as providing a character vector of the desired variable names on the left-hand side and the <code class="literal">list</code> of appropriate values on the right-hand side of the <code class="literal">:=</code> operator. This feature can easily be used for some more complex tasks. For example, let's create the dummy variables of the airline carriers:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; carriers &lt;- unique(hflights_dt$UniqueCarrier)</strong></span>
<span class="strong"><strong>&gt; hflights_dt[, paste('carrier', carriers, sep = '_') :=</strong></span>
<span class="strong"><strong>+   lapply(carriers, function(x) as.numeric(UniqueCarrier == x))]</strong></span>
<span class="strong"><strong>&gt; str(hflights_dt[, grep('^carrier', names(hflights_dt)),</strong></span>
<span class="strong"><strong>+   with = FALSE])</strong></span>
<span class="strong"><strong>Classes 'data.table' and 'data.frame': 227496 obs. of  15 variables:</strong></span>
<span class="strong"><strong> $ carrier_AA: num  1 1 1 1 1 1 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ carrier_AS: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_B6: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_CO: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_DL: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_OO: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_UA: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_US: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_WN: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_EV: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_F9: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_FL: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_MQ: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_XE: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> $ carrier_YV: num  0 0 0 0 0 0 0 0 0 0 ...</strong></span>
<span class="strong"><strong> - attr(*, ".internal.selfref")=&lt;externalptr&gt;</strong></span>
</pre></div><p>Although it's not a one-liner, and it also introduces a helper variable, it's not that complex to see what we did:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we saved the <code class="literal">unique</code> carrier names in a character vector.</li><li class="listitem">Then, we defined the new variables' name with the help of that.</li><li class="listitem">We iterated our anonymous function over this character vector as well, to return <code class="literal">TRUE</code> or <code class="literal">FALSE</code> if the carrier name matched the given column.</li><li class="listitem">The given column was converted to <code class="literal">0</code> or <code class="literal">1</code> through <code class="literal">as.numeric</code>.</li><li class="listitem">And then, we<a class="indexterm" id="id324"/> simply checked the structure of all columns whose names start with <code class="literal">carrier</code>.</li></ol></div><p>This is not perfect, as we usually leave out one label from the dummy variables to reduce redundancy. In the current situation, the last new column is simply the linear combination of the other newly created columns, thus information is duplicated. For this end, it's usually a good practice to leave out, for example, the last category by passing <code class="literal">-1</code> to the <code class="literal">n</code> argument in the <code class="literal">head</code> function.</p></div><div class="section" title="Computing new variables with dplyr"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Computing new variables with dplyr</h2></div></div></div><p>The usage of <code class="literal">mutate</code> from the <code class="literal">dplyr</code> package is identical to that of the base <code class="literal">within</code> function, although<a class="indexterm" id="id325"/> <code class="literal">mutate</code> is a lot quicker than <code class="literal">within</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights &lt;- hflights %&gt;%</strong></span>
<span class="strong"><strong>+     mutate(DistanceKMs = Distance / 0.62137)</strong></span>
</pre></div><p>If the analogy of <code class="literal">mutate</code> and <code class="literal">within</code> has not been made straightforward by the previous example, it's probably also useful to show the same example without using pipes:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights &lt;- mutate(hflights, DistanceKMs = Distance / 0.62137)</strong></span>
</pre></div></div></div>
<div class="section" title="Merging datasets"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Merging datasets</h1></div></div></div><p>Besides the <a class="indexterm" id="id326"/>previously described elementary actions on a single dataset, joining multiple data sources is one of the most used methods in everyday action. The most often used solution for such a task is to simply call the <code class="literal">merge</code> S3 method, which can act as a traditional SQL inner and left/right/full outer joiner of operations—represented in a brief summary by C.L. Moffatt (2008) as follows:</p><div class="mediaobject"><img alt="Merging datasets" src="graphics/2028OS_06_02.jpg"/></div><p>The <code class="literal">dplyr</code> package<a class="indexterm" id="id327"/> provides some easy ways for doing the previously presented join operations right from R, in an easy way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">inner_join</code>: This joins the<a class="indexterm" id="id328"/> variables of all the rows, which are found in both datasets</li><li class="listitem" style="list-style-type: disc"><code class="literal">left_join</code>: This includes <a class="indexterm" id="id329"/>all the rows from the first dataset and join variables from the other table</li><li class="listitem" style="list-style-type: disc"><code class="literal">semi_join</code>: This includes<a class="indexterm" id="id330"/> only those rows from the first dataset that are found in the other one as well</li><li class="listitem" style="list-style-type: disc"><code class="literal">anti_join</code>: This is similar to <a class="indexterm" id="id331"/><code class="literal">semi_join</code>, but includes only those rows from the first dataset that are not found in the other one<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>For more examples, take a look at the <span class="emphasis"><em>Two-table verbs</em></span> <code class="literal">dplyr</code> vignette, and the Data Wrangling cheat sheet listed in the <span class="emphasis"><em>References</em></span> chapter at the end of the book.</p></div></div></li></ul></div><p>These features are also supported by the <code class="literal">mult</code> argument of <code class="literal">[</code> operator of <code class="literal">data.table</code> call, but for the time being, let's stick to the simpler use cases.</p><p>In the following<a class="indexterm" id="id332"/> example, we will merge a tiny dataset with the <code class="literal">hflights</code> data. Let's create the <code class="literal">data.frame</code> demo by assigning names to the possible values of the <code class="literal">DayOfWeek</code> variable:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; (wdays &lt;- data.frame(</strong></span>
<span class="strong"><strong>+     DayOfWeek       = 1:7,</strong></span>
<span class="strong"><strong>+     DayOfWeekString = c("Sunday", "Monday", "Tuesday",</strong></span>
<span class="strong"><strong>+         "Wednesday", "Thursday", "Friday", "Saturday")</strong></span>
<span class="strong"><strong>+     ))</strong></span>
<span class="strong"><strong>  DayOfWeek DayOfWeekString</strong></span>
<span class="strong"><strong>1         1          Sunday</strong></span>
<span class="strong"><strong>2         2          Monday</strong></span>
<span class="strong"><strong>3         3         Tuesday</strong></span>
<span class="strong"><strong>4         4       Wednesday</strong></span>
<span class="strong"><strong>5         5        Thursday</strong></span>
<span class="strong"><strong>6         6          Friday</strong></span>
<span class="strong"><strong>7         7        Saturday</strong></span>
</pre></div><p>Let's see how we can left-join the previously defined <code class="literal">data.frame</code> with another <code class="literal">data.frame</code> and other tabular objects, as <code class="literal">merge</code> also supports fast operations on, for example, <code class="literal">data.table</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; system.time(merge(hflights, wdays))</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.700   0.000   0.699 </strong></span>
<span class="strong"><strong>&gt; system.time(merge(hflights_dt, wdays, by = 'DayOfWeek'))</strong></span>
<span class="strong"><strong>   user  system elapsed </strong></span>
<span class="strong"><strong>  0.006   0.000   0.009</strong></span>
</pre></div><p>The prior example automatically merged the two tables via the <code class="literal">DayOfWeek</code> variable, which was part of both datasets and resulted in an extra variable in the original <code class="literal">hflights</code> dataset. However, we had to pass the variable name in the second example, as the <code class="literal">by</code> argument of <code class="literal">merge.data.table</code> defaults to the key variable of the object, which was missing then. One thing to note is that merging with <code class="literal">data.table</code> was a lot faster than the traditional tabular object type.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>Any ideas on how to improve the previous didactical example? Instead of merging, the new variable could be computed as well. See for example, the weekdays function from base R: <code class="literal">weekdays(as.Date(with(hflights, paste(Year, Month, DayofMonth, sep = '-'))))</code>.</p></div></div><p>A much simpler way of merging datasets is when you simply want to add new rows or columns to the dataset with the same structure. For this end, <code class="literal">rbind</code> and <code class="literal">cbind</code>, or <code class="literal">rBind</code> and <code class="literal">cBind</code> for sparse matrices, do a wonderful job.</p><p>One of the most<a class="indexterm" id="id333"/> often used functions along with these base commands is <code class="literal">do.call</code>, which can execute the <code class="literal">rbind</code> or <code class="literal">cbind</code> call on all elements of a <code class="literal">list</code>, thus enabling us, for example, to join a list of data frames. Such lists are usually created by <code class="literal">lapply</code> or the related functions from the <code class="literal">plyr</code> package. Similarly, <code class="literal">rbindlist</code> can be called to merge a <code class="literal">list</code> of <code class="literal">data.table</code> objects in a much faster way.</p></div>
<div class="section" title="Reshaping data in a flexible way"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Reshaping data in a flexible way</h1></div></div></div><p>Hadley Wickham has <a class="indexterm" id="id334"/>written several R packages to tweak data structures, for example, a major part of his thesis concentrated on how to reshape data frames with his<a class="indexterm" id="id335"/> <code class="literal">reshape</code> package. Since then, this general aggregation and restructuring package has been renewed to <a class="indexterm" id="id336"/>be more efficient with the most commonly used tasks, and it was released with a new version number attached to the<a class="indexterm" id="id337"/> name: <code class="literal">reshape2</code> package.</p><p>This was a total rewrite of the <code class="literal">reshape</code> package, which improves speed at the cost of functionality. Currently, the most important feature of <code class="literal">reshape2</code> is the possibility to convert between the so-called long (narrow) and wide tabular data format. This basically pertains to the columns being stacked below each other, or arranged beside each other.</p><p>These features were presented in Hadley's works with the following image on data restructuring, with the related <code class="literal">reshape</code> functions and simple use cases:</p><div class="mediaobject"><img alt="Reshaping data in a flexible way" src="graphics/2028OS_06_03.jpg"/></div><p>As the <a class="indexterm" id="id338"/>
<code class="literal">reshape</code> package is not under active development anymore, and its parts were outsourced to <code class="literal">reshape2</code>, <code class="literal">plyr</code>, and most recently to <code class="literal">dplyr</code>, we will only focus on the commonly used<a class="indexterm" id="id339"/> features of <code class="literal">reshape2</code> in the following pages. This will basically consist of the <code class="literal">melt</code> and <a class="indexterm" id="id340"/>
<code class="literal">cast</code> functions, which provides a smart way of melting the data into a standardized form of measured and identifier variables (long table format), which can later be casted to a new shape for further analysis.</p><div class="section" title="Converting wide tables to the long table format"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Converting wide tables to the long table format</h2></div></div></div><p>Melting a data frame <a class="indexterm" id="id341"/>means that we transform the tabular data to key-value pairs, based on the given identifier variables. The original column names become the categories of the newly created <code class="literal">variable</code> column, while all numeric values of those (measured variables) are included in the new <code class="literal">value</code> column. Here's a quick example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(reshape2)</strong></span>
<span class="strong"><strong>&gt; head(melt(hflights))</strong></span>
<span class="strong"><strong>Using UniqueCarrier, TailNum, Origin, Dest, CancellationCode as id variables</strong></span>
<span class="strong"><strong>  UniqueCarrier TailNum Origin Dest CancellationCode variable value</strong></span>
<span class="strong"><strong>1            AA  N576AA    IAH  DFW                      Year  2011</strong></span>
<span class="strong"><strong>2            AA  N557AA    IAH  DFW                      Year  2011</strong></span>
<span class="strong"><strong>3            AA  N541AA    IAH  DFW                      Year  2011</strong></span>
<span class="strong"><strong>4            AA  N403AA    IAH  DFW                      Year  2011</strong></span>
<span class="strong"><strong>5            AA  N492AA    IAH  DFW                      Year  2011</strong></span>
<span class="strong"><strong>6            AA  N262AA    IAH  DFW                      Year  2011</strong></span>
</pre></div><p>So, we have just restructured the original <code class="literal">data.frame</code>, which had 21 variables and a quarter of a million records, into only 7 columns and more than 3.5 million records. Six out of the seven columns are factor type identifier variables, and the last column stores all the values. But why is it useful? Why should we transform the traditional wide tabular format to the much longer type of data?</p><p>For example, we<a class="indexterm" id="id342"/> might be interested in comparing the distribution of flight time with the actual elapsed time of the flight, which might not be straightforward to plot with the original data format. Although plotting a scatter plot of the above variables with<a class="indexterm" id="id343"/> the <code class="literal">ggplot2</code> package is extremely easy, how would you create two separate boxplots comparing the distributions?</p><p>The problem here is that we have two separate variables for the time measurements, while <code class="literal">ggplot</code> requires one <code class="literal">numeric</code> and one <code class="literal">factor</code> variable, from which the latter will be used to provide the labels on the <span class="emphasis"><em>x</em></span>-axis. For this end, let's restructure our dataset with <code class="literal">melt</code> by specifying the two numeric variables to treat as measurement variables and dropping all other columns— or in other words, not having any identifier variables:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_melted &lt;- melt(hflights, id.vars = 0,</strong></span>
<span class="strong"><strong>+   measure.vars = c('ActualElapsedTime', 'AirTime'))</strong></span>
<span class="strong"><strong>&gt; str(hflights_melted)</strong></span>
<span class="strong"><strong>'data.frame':  454992 obs. of  2 variables:</strong></span>
<span class="strong"><strong> $ variable: Factor w/ 2 levels "ActualElapsedTime",..: 1 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ value   : int  60 60 70 70 62 64 70 59 71 70 ...</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>In general, it's not a good idea to melt a dataset without identifier variables, as casting it later becomes cumbersome, if not impossible.</p></div></div><p>Please note that now we have exactly twice as many rows than we had before, and the <code class="literal">variable</code> column is a factor with only two levels, which represent the two measurement variables. And this resulting <code class="literal">data.frame</code> is now easy to plot with the two newly created columns:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(ggplot2)</strong></span>
<span class="strong"><strong>&gt; ggplot(hflights_melted, aes(x = variable, y = value)) +</strong></span>
<span class="strong"><strong>+   geom_boxplot()</strong></span>
</pre></div><div class="mediaobject"><img alt="Converting wide tables to the long table format" src="graphics/2028OS_06_04.jpg"/></div><p>Well, the previous<a class="indexterm" id="id344"/> example might not seem mission critical, and to be honest, I first used the<a class="indexterm" id="id345"/> <code class="literal">reshape</code> package when I needed some similar transformation to be able to produce some nifty <code class="literal">ggplot2</code> charts—as the previous problem simply does not exist if someone is using <code class="literal">base</code> graphics. For example, you can simply pass the two separate variables of the original dataset to the <code class="literal">boxplot</code> function.</p><p>So, this is kind of entering the world of Hadley Wickham's R packages, and the journey indeed offers some great data analysis practices. Thus, I warmly suggest reading further, for example, on how using <code class="literal">ggplot2</code> is not easy, if not impossible, without knowing how to reshape datasets efficiently.</p></div><div class="section" title="Converting long tables to the wide table format"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Converting long tables to the wide table format</h2></div></div></div><p>Casting a dataset is the<a class="indexterm" id="id346"/> opposite of melting, like turning key-value pairs into a tabular data format. But bear in mind that the key-value pairs can always be combined together in a variety of ways, so this process can result in extremely diversified outputs. Thus, you need a table and a formula to cast, for example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_melted &lt;- melt(hflights, id.vars = 'Month',</strong></span>
<span class="strong"><strong>+   measure.vars = c('ActualElapsedTime', 'AirTime'))</strong></span>
<span class="strong"><strong>&gt; (df &lt;- dcast(hflights_melted, Month ~ variable,</strong></span>
<span class="strong"><strong>+   fun.aggregate = mean, na.rm = TRUE))</strong></span>
<span class="strong"><strong>   Month ActualElapsedTime  AirTime</strong></span>
<span class="strong"><strong>1      1          125.1054 104.1106</strong></span>
<span class="strong"><strong>2      2          126.5748 105.0597</strong></span>
<span class="strong"><strong>3      3          129.3440 108.2009</strong></span>
<span class="strong"><strong>4      4          130.7759 109.2508</strong></span>
<span class="strong"><strong>5      5          131.6785 110.3382</strong></span>
<span class="strong"><strong>6      6          130.9182 110.2511</strong></span>
<span class="strong"><strong>7      7          130.4126 109.2059</strong></span>
<span class="strong"><strong>8      8          128.6197 108.3067</strong></span>
<span class="strong"><strong>9      9          128.6702 107.8786</strong></span>
<span class="strong"><strong>10    10          128.8137 107.9135</strong></span>
<span class="strong"><strong>11    11          129.7714 107.5924</strong></span>
<span class="strong"><strong>12    12          130.6788 108.9317</strong></span>
</pre></div><p>This example shows how to aggregate the measured flight times for each month in 2011 with the help<a class="indexterm" id="id347"/> of melting and casting the <code class="literal">hflights</code> dataset:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we melted the <code class="literal">data.frame</code> with the IDs being the <code class="literal">Month</code>, where we only kept two numeric variables for the flight times.</li><li class="listitem">Then, we casted the resulting <code class="literal">data.frame</code> with a simple formula to show the mean of each month for all measurement variables.</li></ol></div><p>I am pretty sure that now you can quickly restructure this data to be able to plot two separate lines for this basic time-series:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; ggplot(melt(df, id.vars = 'Month')) +</strong></span>
<span class="strong"><strong>+   geom_line(aes(x = Month, y = value, color = variable)) +</strong></span>
<span class="strong"><strong>+   scale_x_continuous(breaks = 1:12) +</strong></span>
<span class="strong"><strong>+   theme_bw() + </strong></span>
<span class="strong"><strong>+   theme(legend.position = 'top')</strong></span>
</pre></div><div class="mediaobject"><img alt="Converting long tables to the wide table format" src="graphics/2028OS_06_05.jpg"/></div><p>But of course, melting and casting can be used for a variety of things besides aggregating. For example, we can restructure our original database to have a special <code class="literal">Month</code>, which includes all the<a class="indexterm" id="id348"/> records of the data. This, of course, doubles the number of rows in the dataset, but also lets us easily generate a table on the data with margins. Here's a quick example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; hflights_melted &lt;- melt(add_margins(hflights, 'Month'),</strong></span>
<span class="strong"><strong>+    id.vars = 'Month',</strong></span>
<span class="strong"><strong>+    measure.vars = c('ActualElapsedTime', 'AirTime'))</strong></span>
<span class="strong"><strong>&gt; (df &lt;- dcast(hflights_melted, Month ~ variable,</strong></span>
<span class="strong"><strong>+    fun.aggregate = mean, na.rm = TRUE))</strong></span>
<span class="strong"><strong>   Month ActualElapsedTime  AirTime</strong></span>
<span class="strong"><strong>1      1          125.1054 104.1106</strong></span>
<span class="strong"><strong>2      2          126.5748 105.0597</strong></span>
<span class="strong"><strong>3      3          129.3440 108.2009</strong></span>
<span class="strong"><strong>4      4          130.7759 109.2508</strong></span>
<span class="strong"><strong>5      5          131.6785 110.3382</strong></span>
<span class="strong"><strong>6      6          130.9182 110.2511</strong></span>
<span class="strong"><strong>7      7          130.4126 109.2059</strong></span>
<span class="strong"><strong>8      8          128.6197 108.3067</strong></span>
<span class="strong"><strong>9      9          128.6702 107.8786</strong></span>
<span class="strong"><strong>10    10          128.8137 107.9135</strong></span>
<span class="strong"><strong>11    11          129.7714 107.5924</strong></span>
<span class="strong"><strong>12    12          130.6788 108.9317</strong></span>
<span class="strong"><strong>13 (all)          129.3237 108.1423</strong></span>
</pre></div><p>This is very similar to what we have seen previously, but as an intermediate step, we have converted the <code class="literal">Month</code> variable to be factor with a special level, which resulted in the last line of this table. This row represents the overall arithmetic average of the related measure variables.</p></div><div class="section" title="Tweaking performance"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Tweaking performance</h2></div></div></div><p>Some further good<a class="indexterm" id="id349"/> news on <code class="literal">reshape2</code> is that <code class="literal">data.table</code> has decent support for melting and casting, with highly improved performance. Matt Dowle has published some benchmarks with a 5-10 percent improvement in the processing times of using <code class="literal">cast</code> and <code class="literal">melt</code> on <code class="literal">data.table</code> objects instead of the traditional data frames, which is highly impressive.</p><p>To verify these results on your own dataset, simply transform the <code class="literal">data.frame</code> objects to <code class="literal">data.table</code> before calling the <code class="literal">reshape2</code> functions, as the <code class="literal">data.table</code> package already ships the appropriate <code class="literal">S3</code> methods to extend <code class="literal">reshape2</code>.</p></div></div>
<div class="section" title="The evolution of the reshape packages"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>The evolution of the reshape packages</h1></div></div></div><p>As mentioned<a class="indexterm" id="id350"/> before, <code class="literal">reshape2</code> was a complete rewrite of the <code class="literal">reshape</code> package, based on around 5 years of experience in using and developing the latter. This update also included some trade-offs, as the original reshape tasks were split among multiple packages. Thus, <code class="literal">reshape2</code> now offers a lot less compared to the kind of magic features that were supported by <code class="literal">reshape</code>. Just check, for example <code class="literal">reshape::cast</code>; especially the <code class="literal">margins</code> and <code class="literal">add.missing</code> argument!</p><p>But as it turns out, even <code class="literal">reshape2</code> offers a lot more than simply melting and casting data frames. The birth of the<a class="indexterm" id="id351"/> <code class="literal">tidyr</code> package was inspired by this fact: to have a package in the Hadleyverse that supports easy data cleaning and transformation between the long and wide table formats. In <code class="literal">tidyr</code> parlance, these operations are called <code class="literal">gather</code> and <code class="literal">spread</code>.</p><p>Just to give a quick example of this new syntax, let's re-implement the previous examples:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt; library(tidyr)</strong></span>
<span class="strong"><strong>&gt; str(gather(hflights[, c('Month', 'ActualElapsedTime', 'AirTime')],</strong></span>
<span class="strong"><strong>+   variable, value, -Month))</strong></span>
<span class="strong"><strong>'data.frame':  454992 obs. of  3 variables:</strong></span>
<span class="strong"><strong> $ Month   : int  1 1 1 1 1 1 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ variable: Factor w/ 2 levels "ActualElapsedTime",..: 1 1 1 1 ...</strong></span>
<span class="strong"><strong> $ value   : int  60 60 70 70 62 64 70 59 71 70 ...</strong></span>
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we focused on how to transform raw data into an appropriately structured format, before we could run statistical tests. This process is a really important part of our everyday actions, and it takes most of a data scientist's time. But after reading this chapter, you should be confident in how to restructure your data in most cases— so, this is the right time to focus on building some models, which we will do in the next chapter.</p></div></body></html>