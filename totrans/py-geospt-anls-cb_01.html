<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Setting Up Your Geospatial Python Environment</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing virtualenv and virtualenvwrapper</li><li class="listitem" style="list-style-type: disc">Installing pyproj and NumPy</li><li class="listitem" style="list-style-type: disc">Installing shapely, matplotlib, and descartes</li><li class="listitem" style="list-style-type: disc">Installing pyshp, geojson, and pandas</li><li class="listitem" style="list-style-type: disc">Installing SciPy, PySal, and IPython</li><li class="listitem" style="list-style-type: disc">Installing GDAL and OGR</li><li class="listitem" style="list-style-type: disc">Installing GeoDjango and PostgreSQL with PostGIS</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>This chapter will get the grunt work done for you so that you can freely and actively complete all the recipes in this book. We will start off by installing, each of the libraries you will be using, one by one. Once each step is completed, we will test each library installation to make sure it works. Since this book is directed toward those of you already working with spatial data, you can skip this chapter if you have it installed already. If not, you will find the installation instructions here useful as a reference.</p><p>The choice of Python libraries is based on industry-proven reliability and functionality. The plethora of functions in Python libraries has led to a flourishing GIS support on many top desktop GIS systems, such as QGIS and ESRI ArcGIS.</p><p>Also included in this book is an <code class="literal">installer.sh</code> bash file. The <code class="literal">installer.sh</code> file can be used to install the Python libraries that are available for your virtual environment from <code class="literal">pip</code> and other dependencies via the <code class="literal">apt-get</code> command. The <code class="literal">installer.sh</code> bash file is executed from the command line and installs almost everything in one go, so please take a look at it. For those of you who are starting with Python for the first time, follow the instructions in this chapter and your machine will be set up to complete different recipes.</p><p>Installations can sometimes be tricky even for advanced users, so you will find some of the most common pitfalls and hook-ups described in this chapter.</p><p>The development of these recipes was completed on a fresh <a id="id0" class="indexterm"/>
<strong>Linux/Ubuntu 14.04</strong> machine. Therefore, the code examples, if not otherwise specified, are Linux/Ubuntu-specific with Windows notes wherever necessary, unless otherwise specified.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Installing virtualenv and virtualenvwrapper</h1></div></div></div><p>This recipe <a id="id1" class="indexterm"/>will enable you to manage different versions of different libraries for multiple projects. We use <code class="literal">virtualenv</code> to create virtual Python environments to host collections of project-specific libraries in an isolated directory. For example, you may have an old legacy project using Django 1.4, whereas a new project requires you use Django version 1.8. With <code class="literal">virtualenv</code>, you can have both versions of Django installed on the same machine, and each project can access the appropriate version of Django without any conflicts or problems.</p><p>Without <code class="literal">virtualenv</code>, you are forced to either upgrade the old project or find a workaround to implement the new features of the other version, therefore limiting or complicating the new project.</p><p>The <code class="literal">virtualenv</code>
<a id="id2" class="indexterm"/> allows you to simply switch between different Python virtual environments for your individual projects. This has the added benefit that you can easily and quickly set up a new machine for testing or help a new developer get their machine up and running as fast as possible.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Getting ready</h2></div></div></div><p>Before anything, we are going to assume that you already have a Linux/Ubuntu machine or a <a id="id3" class="indexterm"/>
<strong>virtualbox</strong> instance running Linux/Ubuntu so you can follow these instructions.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>I also suggest trying out <a id="id4" class="indexterm"/>Vagrant (<a class="ulink" href="http://www.vagrantup.com">http://www.vagrantup.com</a>), which uses virtualbox to box and standardize your development environment.</p></div></div><p>Ubuntu 14.04 comes with Python 2.7.6 and Python 3.4 preinstalled; the other libraries are your responsibility as explained in the following sections.</p><p>Windows users need to download and install Python 2.7.x from the Python home page at <a class="ulink" href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a>; please download the newest version of the 2.7.x series since this book is written with 2.7.X in mind. The installer includes a bundled version of pip, so make sure you install it!</p><p>Take a close look at <a id="id5" class="indexterm"/>the correct version to download, making sure that you get either the <em>32-bit</em> or <em>64-bit</em> download. You cannot mix and match the versions, so be careful and remember to install the correct version.</p><p>A great site for other kinds of Windows binaries can be found at <a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>. Wheel files are the new norms of installations and can be executed from the command line as follows:</p><div><pre class="programlisting">
<strong>python pip install libraryName.whl</strong>
</pre></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>On Windows, make sure that your Python interpreter is set up on your system path. This way, you can simply call Python directly from the command prompt using the <code class="literal">C:\Users\Michael&gt; python filename.py</code> command. If you need more help, information can be found by following one of the online instructions at <a class="ulink" href="https://pypi.python.org/pypi/pip">https://pypi.python.org/pypi/pip</a>.</p><p>As of Python 2.7.9 and later versions, <code class="literal">pip</code> is available on installation.</p></div></div><p>Python 3 would be awesome to use, and for many Python GIS libraries, it is ready for show time. Unfortunately, not all GIS libraries jive with Python 3 (pyproj) as one would love to see at the time of writing this. If you want, feel free to go for Python 3.x and give it a go. A great webpage to check the compatibility of a library can be found at <a class="ulink" href="https://caniusepython3.com/">https://caniusepython3.com/</a>.</p><p>To install <a id="id6" class="indexterm"/>
<code class="literal">virtualenv</code>, you need to have a running installation of Python and pip. The pip package manager manages and installs Python packages, making our lives easier. Throughout this book, if we need to install a package, <code class="literal">pip</code> will be our tool of choice for this job. The official installation instructions for pip can be found at <a class="ulink" href="https://pip.pypa.io/en/latest/installing.html">https://pip.pypa.io/en/latest/installing.html</a>. To install pip from the command line, we first need to install <code class="literal">easy_install</code>. Let's try it out from the Terminal:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install python-setuptools python-pip</strong>
</pre></div><p>With this one line, you have both <code class="literal">pip</code> and <code class="literal">easy_install</code> installed.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>
<strong>What is sudo?</strong>
</p><p>sudo is a program for Unix-like computer operating systems that allows users to run programs with the security privileges of another user (normally, the super user or root). Its name is a concatenation of <strong>su</strong> (<strong>substitute user</strong>) and <strong>do</strong> (<strong>take action</strong>). Take a look at <a class="ulink" href="http://en.wikipedia.org/wiki/Sudo">http://en.wikipedia.org/wiki/Sudo</a> for more information on this.</p></div></div><p>The command <strong>sudo</strong> means to run an execution as a super user. If this fails, you will need to get the<code class="literal">ez_setup.py</code> file, which is available at <a class="ulink" href="https://bootstrap.pypa.io/ez_setup.py">https://bootstrap.pypa.io/ez_setup.py</a>. After downloading the file, you can run it from the command line:</p><div><pre class="programlisting">
<strong>$ python ez_setup.py</strong>
</pre></div><p>Now <code class="literal">pip</code> should be up and <a id="id7" class="indexterm"/>running and you can execute commands to complete the installations of <strong>virtualenv</strong> and <strong>virtualenvwrapper</strong>. The <a id="id8" class="indexterm"/>
<code class="literal">virtualenvwrapper</code> creates shortcuts that are faster ways to create or delete your virtual environments. You can test it as follows:</p><div><pre class="programlisting">
<strong>$ pip install virtualenv</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How to do it...</h2></div></div></div><p>The steps to install your<a id="id9" class="indexterm"/> Python <code class="literal">virtualenv</code> and <code class="literal">virtualenvwrapper</code> packages are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Install <code class="literal">virtualenv</code> using the pip installer:<div><pre class="programlisting">
<strong>$ sudo pip install virtualenv</strong>
</pre></div></li><li class="listitem">Install <code class="literal">virtualenvwrapper</code> using <code class="literal">easy_install</code>:<div><pre class="programlisting">
<strong>$ sudo easy_install virtualenvwrapper</strong>
</pre></div><div><div><h3 class="title"><a id="note04"/>Note</h3><p>We use <code class="literal">easy_install</code> instead of <code class="literal">pip</code> because with Ubuntu 14.04, the <code class="literal">virtualenvwrapper.sh</code> file is unfortunately not located at <code class="literal">/usr/local/bin/virtualenvwrapper.sh</code> where it should be according to the online documentation.</p></div></div></li><li class="listitem">Assign the <code class="literal">WORKON_HOME</code> variable to your home directory with the folder name <code class="literal">venvs</code>. Create a single folder where you want to store all your different Python virtual environments; in my case, the folder is located at <code class="literal">/home/mdiener/venvs</code>:<div><pre class="programlisting">
<strong>$ export WORKON_HOME=~/venvs</strong>
<strong>$ mkdir $WORKON_HOME</strong>
</pre></div></li><li class="listitem">Run the source command to execute the <code class="literal">virtualenvrapper.sh</code> bash file:<div><pre class="programlisting">
<strong>$ source /usr/local/bin/virtualenvwrapper.sh</strong>
</pre></div></li><li class="listitem">Next, we create a new virtual environment called <code class="literal">pygeoan_cb</code>, and this is also the name of the new folder where the virtual environment is installed:<div><pre class="programlisting">
<strong>$ mkvirtualenv pygeoan_cb</strong>
</pre></div><p>To use <code class="literal">virtualenvwrapper</code> the next time you start up your machine, we need to set it up so that your bash terminal runs the <code class="literal">virtualenvwrapper.sh</code> script when your computer starts.</p></li><li class="listitem">First, put it in your <code class="literal">~/.bashrc</code> file:<div><pre class="programlisting">
<strong>$ echo "export WORKON_HOME=$WORKON_HOME" &gt;&gt; ~/.bashrc</strong>
</pre></div></li><li class="listitem">Next, we'll <a id="id10" class="indexterm"/>import the <code class="literal">virtualenvwrapper</code> function in our bash:<div><pre class="programlisting">
<strong>$ echo "source /usr/local/bin/virtualenvwrapper.sh" &gt;&gt; ~/.bashrc</strong>
</pre></div></li><li class="listitem">Now we can execute our bash:<div><pre class="programlisting">
<strong>$ source ~/.bashrc</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How it works...</h2></div></div></div><p>Step one shows how<a id="id11" class="indexterm"/> pip installs the <code class="literal">virtualenv</code> package into your system-wide Python installation. Step two shows how the <code class="literal">virtualenvwrapper</code> helper package is installed with <code class="literal">easy_install</code> because the <code class="literal">virtualenvwrapper.sh</code> file is not created using the pip installer. This will help us create, enter, and generally, work or switch between Python virtual environments with ease. Step three assigns the <code class="literal">WORKON_HOME</code> variable to a directory where we want to have all of our virtual environments. Then, we'll create a new directory to hold all the virtual environments. In step four, the command source is used to execute the shell script to set up the <code class="literal">virtualenvwrapper</code> package. In step five, we see how to actually create a new <code class="literal">virtualenv</code> called <code class="literal">pygeoan_cb</code> in our <code class="literal">/home/mdiener/venvs</code> directory. This final step automatically starts our <code class="literal">virtualenv</code> session.</p><p>Once the <code class="literal">virtualenv</code> session starts, we can now see the name of <code class="literal">virtualenv</code> in brackets like this:</p><div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$</strong>
</pre></div><p>To exit <code class="literal">virtualenv</code>, simply type the following code:</p><div><pre class="programlisting">
<strong>$ deactivate</strong>
</pre></div><p>Now, your command line should be back to normal as shown here:</p><div><pre class="programlisting">
<strong>mdiener@mdiener-VirtualBox:~$</strong>
</pre></div><p>To reactivate <code class="literal">virtualenv</code>, simply type:</p><div><pre class="programlisting">
<strong>$ workon pygeoan_cb</strong>
</pre></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>The <code class="literal">workon</code> command has <em>Tab</em> completion. So, simply type <code class="literal">workon</code>, and then the first letter of the name of the virtual environment you want to enter, such as <code class="literal">py</code>. Hit <em>Tab</em> and it will autocomplete the name.</p></div></div><p>Inside the <code class="literal">/venvs</code> folder, you<a id="id12" class="indexterm"/> will find specific individual virtual environments for each project in the form of a subfolder. The <code class="literal">virtualenvwrapper</code> package will always create a new folder for each new project you create. You can, therefore, easily delete a folder and it will remove your virtual environment.</p><p>To quickly print a list all of the installed libraries to a file, we'll use the <code class="literal">pip</code> command:</p><div><pre class="programlisting">
<strong>$ pip freeze &gt; requirements.txt</strong>
</pre></div><p>This will create a text file called <code class="literal">requirements.txt</code> in the current folder. The text file contains a list of all the installed Python packages inside the Python virtual environment currently running.</p><p>To create a new <a id="id13" class="indexterm"/>
<code class="literal">virtualenv</code> from a requirements file, use the following command:</p><div><pre class="programlisting">
<strong>$ pip install -r /path/to/requirements.txt</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>There's more…</h2></div></div></div><p>For those of you who are just starting out with geospatial Python development, it should be noted that you should keep your project-specific code at another location outside your Python virtual environment folder. For example, I always have each project-related code contained in a separate folder called <code class="literal">01_projects</code>, which is my main folder. The path to my projects folder is <code class="literal">/home/mdiener/01_projects</code>, and the structure of two of my projects is as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">01_projects/Name_project1</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">01_projects/Name_project2</code></li></ul></div><p>All virtual environments are located under <code class="literal">/home/mdiener/venvs/</code>. Usually, I give them the same name as a project to keep things organized, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/home/mdiener/venvs/Name_project1</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">/home/mdiener/venvs/Name_project2</code></li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Installing pyproj and NumPy</h1></div></div></div><p>The<strong> pyproj</strong> is <a id="id14" class="indexterm"/>a wrapper around the PROJ.4 library that works with projections and performs transformations (<a class="ulink" href="https://pypi.python.org/pypi/pyproj/">https://pypi.python.org/pypi/pyproj/</a>) in <a id="id15" class="indexterm"/>Python. All your geographic information should be projected into one of the many coordinate systems supported by the <strong>European Petroleum Survey Group</strong> (<strong>EPSG</strong>). This information is necessary for the systems to correctly place data at the appropriate location on Earth. The geographic data can then be placed on top of each other as layers upon layers of data in order to create maps or perform analysis. The data must be correctly positioned or we won't be able to add, combine, or compare it to other data sources spatially.</p><p>Data comes from many sources and, often, a projection is not the same as a dataset. Even worse, the data could be delivered with a description from a data provider stating it's in projection UTM31 when, in reality, the data is in projection UTM34! This can lead to big problems later on when trying to get your data to work together as programs will throw you some ugly error messages.</p><p>
<strong>NumPy</strong>
<a id="id16" class="indexterm"/> is the scientific backbone of number crunching arrays and complex numbers that are used to power several popular geospatial libraries including <a id="id17" class="indexterm"/>
<strong>GDAL</strong> (<strong>geospatial abstraction library</strong>). The power of NumPy lies is in its support for large matrices, arrays, and math functions. The installation of NumPy is, therefore, necessary for the other libraries to function smoothly, but is seldom used directly in our quest for spatial analysis.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Getting ready</h2></div></div></div><p>Fire up your <a id="id18" class="indexterm"/>virtual environment, if it is not already running, using the following standard start command:</p><div><pre class="programlisting">
<strong>$ workon pygeoan_cb</strong>
</pre></div><p>Your prompt should now look like this:</p><div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$</strong>
</pre></div><div><div><h3 class="title"><a id="note05"/>Note</h3><p>If <code class="literal">workon</code> for some reason does not start your virtual environment, you can start it simply by executing <code class="literal">source /home/mdiener/venvs/pygeoan_cb/bin/activate</code> from the command line; try the steps listed in the <em>Installing virtualenv and virtualenvwrapper</em> recipe again to get it going.</p></div></div><p>Now, we <a id="id19" class="indexterm"/>need to install some Python tools for development that allow us to install NumPy, so run this command:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install -y python-dev</strong>
</pre></div><p>You are now ready to move on and install pyproj and NumPy inside your running virtual environment.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How to do it...</h2></div></div></div><p>Simply fire up<a id="id20" class="indexterm"/> <code class="literal">virtualenv</code> and we will use the pip installer to do all the heavy lifting as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Use pip to go ahead and install NumPy; this can take a couple of minutes as many lines of installation verbosity are written on screen:<div><pre class="programlisting">
<strong>$ pip install numpy</strong>
</pre></div><p>Windows users can grab the <code class="literal">.whl</code> file for NumPy and execute it using following command:</p><div><pre class="programlisting">
<strong>pip install numpy -1.9.2+mkl-cp27-none-win32.whl</strong>
</pre></div></li><li class="listitem">Use <code class="literal">pip</code> one more time to install pyproj:<div><pre class="programlisting">
<strong>$ pip install pyproj</strong>
</pre></div><p>Windows users can use the following command to install pyproj:</p><div><pre class="programlisting">
<strong>pip install pyproj-1.9.4-cp27-none-win_amd64.whl</strong>
</pre></div></li><li class="listitem">Wait a <a id="id21" class="indexterm"/>few minutes; NumPy should be now running along with pyproj. To test if it's worked out, enter the following command in the Python console. The output should look like this:<div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~/venv$ python</strong>
<strong>Python 2.7.3 (default,  Feb 27 2014, 19:58:35)</strong>
<strong>[GCC 4.6.3] on linux2</strong>
<strong>Type “help”,  “copyright”, “credits”, or  “license” for more information.</strong>
<strong>&gt;&gt; import numpy</strong>
<strong>&gt;&gt; import pyproj</strong>
</pre></div></li></ol></div><p>No errors, I hope. You have now successfully installed NumPy and pyproj.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>All sorts of errors could show up, so please take a look at the respective installation links to help you solve them:</p><p>For <a id="id22" class="indexterm"/>pyproj: <a class="ulink" href="https://pypi.python.org/pypi/pyproj/">https://pypi.python.org/pypi/pyproj/</a>
</p><p>For <a id="id23" class="indexterm"/>NumPy: <a class="ulink" href="http://www.numpy.org">http://www.numpy.org</a>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How it works...</h2></div></div></div><p>This easy installation <a id="id24" class="indexterm"/>works using the standard pip installation method. No tricks or special commands are needed. You need to simply execute the <code class="literal">pip install &lt;library_name&gt;</code> command and you are off to the races.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Library names can be found by visiting the <a class="ulink" href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a> web page if you are unsure of the exact name you want to install.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Installing shapely, matplotlib, and descartes</h1></div></div></div><p>A large part of geospatial analysis and visualization is made possible using Shapely, matplotlib, GDAL, OGR, and descartes, which are installed later. Most of the recipes here will use these libraries extensively so setting them up is necessary to complete our exercises.</p><p>
<strong>Shapely</strong> (<a class="ulink" href="http://toblerity.org/shapely">http://toblerity.org/shapely</a>) provides<a id="id25" class="indexterm"/> pure spatial <a id="id26" class="indexterm"/>analysis of geometries using the Cartesian coordinate system as is used by AutoCAD, for those of you familiar with CAD-like programs. The benefit of using a flat coordinate system is that all the rules of Euclidean geometry and analytic geometry are applied. For a quick refresher in the coordinate systems that we all learned in school, here is a little image to quickly jolt your memory.</p><div><img src="img/B03543_01_02.jpg" alt="Installing shapely, matplotlib, and descartes"/></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>
<strong>Description</strong>: A Cartesian coordinate system demonstrating a flat plane to plot and measure geometry.</p><p>
<strong>Illustration 1</strong>: Source: <a class="ulink" href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">http://en.wikipedia.org/wiki/Cartesian_coordinate_system</a>.</p></div></div><p>The classic overlay analysis and other geometric computations is where Shapely shines using the GEOS library as its workhorse in the background.</p><p>As for <a id="id27" class="indexterm"/>
<strong>matplotlib</strong> (<a class="ulink" href="http://matplotlib.org/">http://matplotlib.org/</a>), it is the plotting engine that renders <a id="id28" class="indexterm"/>nice graphs and data to your screen as an image or <a id="id29" class="indexterm"/>
<strong>scalable vector graphic</strong> (<strong>svg</strong>). The uses of matplotlib are only limited to your imagination. So, like the name partially implies, matplotlib enables you to plot your data on a graph or even on a map. For those of you familiar with MATLAB, you will find matplotlib quite similar in functionality.</p><p>The<strong> descartes</strong> library<a id="id30" class="indexterm"/> provides a nicer integration of Shapely geometry objects with Matplotlib. Here, you will see that descartes opens the <code class="literal">fill</code> and <code class="literal">patch</code> of matplotlib plots to work with the geometries from Shapely and saves you from typing them individually.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Getting ready</h2></div></div></div><p>To prepare <a id="id31" class="indexterm"/>for installation, it is necessary to install some global packages, such as <code class="literal">libgeos_c</code>, as these are required by Shapely. NumPy is also a requirement that we have already met and is also used by Shapely.</p><p>Install the requirements<a id="id32" class="indexterm"/> of matplotlib from the command line like this:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install freetype* libpng-dev libjpeg8-dev</strong>
</pre></div><p>These are the dependencies of matplotlib, which can be seen on a Ubuntu 14.04 machine.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How to do it...</h2></div></div></div><p>Follow these<a id="id33" class="indexterm"/> instructions:</p><div><ol class="orderedlist arabic"><li class="listitem">Run pip to install shapely:<div><pre class="programlisting">
<strong>$ pip install shapely</strong>
</pre></div></li><li class="listitem">Run pip to install matplotlib:<div><pre class="programlisting">
<strong>$ pip install matplotlib</strong>
</pre></div></li><li class="listitem">Finally, run pip to install descartes:<div><pre class="programlisting">
<strong>$ pip install descartes</strong>
</pre></div></li></ol></div><p>Another test to see if all has gone well is to simply enter the Python console and try to import the packages, and if no errors occur, your console should show an empty Python cursor. The output<a id="id34" class="indexterm"/> should look like what is shown in the following code:</p><div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~/venv$ python</strong>
<strong>Python 2.7.3 (default,  Feb 27 2014, 19:58:35)</strong>
<strong>[GCC 4.6.3] on linux2</strong>
<strong>Type “help”,  “copyright”, “credits”, or  “license” for more information.</strong>
<strong>&gt;&gt;&gt; import shapely</strong>
<strong>&gt;&gt;&gt; import matplotlib</strong>
<strong>&gt;&gt;&gt; import descartes</strong>
<strong>&gt;&gt;&gt;</strong>

<strong># type exit() to return</strong>
<strong>&gt;&gt;&gt; exit()</strong>
</pre></div><p>If any errors occur, Python <a id="id35" class="indexterm"/>usually provides some good clues as to where the problem is located and there is always <a id="id36" class="indexterm"/>
<strong>Stack Overflow</strong>. For example, have a look at <a class="ulink" href="http://stackoverflow.com/questions/19742406/could-not-find-library-geos-c-or-load-any-of-its-variants/23057508#2305750823057508">http://stackoverflow.com/questions/19742406/could-not-find-library-geos-c-or-load-any-of-its-variants/23057508#2305750823057508</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How it works...</h2></div></div></div><p>Here, the order in which you install <a id="id37" class="indexterm"/>the packages is very important. The descartes package depends on matplotlib, and matplotlib depends on NumPy plus freetype and libpng. This narrows you down to installing NumPy first, then matplotlib and its dependencies, and finally, descartes.</p><p>The installation itself is simple with pip and should be quick and painless. The tricky parts occur if <code class="literal">libgeos_c</code> is not installed properly, and you might need to install the <code class="literal">libgeos-dev</code> library.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Installing pyshp, geojson, and pandas</h1></div></div></div><p>These specific libraries are for specific formats that make our life easier and simpler than using GDAL for some projects. pyshp will work with shapefiles, geojson with GeoJSON, and pandas with all other textual data types in a structured manner.</p><p>
<strong>pyshp</strong> is<a id="id38" class="indexterm"/> pure Python and is used to import and export shapefiles; you can find the source code for pyshp<a id="id39" class="indexterm"/> here at <a class="ulink" href="https://github.com/GeospatialPython/pyshp">https://github.com/GeospatialPython/pyshp</a>. The pyshp library's sole purpose is to work with shapefiles. GDAL will be used to do most of our data's in/out needs, but sometimes, a pure Python library is simpler when working with shapefiles.</p><p>
<strong>geojson</strong> is<a id="id40" class="indexterm"/> the name of a<a id="id41" class="indexterm"/> Python library and also a format, making it a little confusing to understand. The GeoJSON format (<a class="ulink" href="http://geojson.org">http://geojson.org</a>) is becoming ever more popular and to this extent, we use the Python geojson library to handle its creation. You will find it on <strong>Python Package Index</strong> (<strong>PyPI</strong>) if you search for geojson. As you would expect, this will help us create all the different geometry types supported in the GeoJSON specifications.</p><p>
<strong>pandas</strong> (<a class="ulink" href="http://pandas.pydata.org">http://pandas.pydata.org</a>) is <a id="id42" class="indexterm"/>a<a id="id43" class="indexterm"/> data analysis library that structures your data in a spreadsheet-like manner for further computations. Since our geospatial data comes from a broad set of sources and formats, such as CSV, pandas helps work with the data with minimal effort.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Getting ready</h2></div></div></div><p>Enter your virtual environment using the following command:</p><div><pre class="programlisting">
<strong>$ workon pygeoan_cb</strong>
</pre></div><p>Your prompt should now look like this:</p><div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How to do it...</h2></div></div></div><p>The three <a id="id44" class="indexterm"/>installations are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Pyshp <a id="id45" class="indexterm"/>will first be installed by simply using pip as follows:<div><pre class="programlisting">
<strong>$ pip install pyshp</strong>
</pre></div></li><li class="listitem">Next, the <a id="id46" class="indexterm"/>geojson library will be installed using pip:<div><pre class="programlisting">
<strong>$ pip install geojson</strong>
</pre></div></li><li class="listitem">Finally, pip will install pandas:<div><pre class="programlisting">
<strong>$ pip install pandas</strong>
</pre></div></li></ol></div><p>To test your installation of pyshp, use the <code class="literal">import shapefile</code> type. The output should look like what is <a id="id47" class="indexterm"/>shown in the following output:</p><div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~/venv$ python</strong>
<strong>Python 2.7.3 (default,  Feb 27 2014, 19:58:35)</strong>
<strong>[GCC 4.6.3] on linux2</strong>
<strong>Type “help”,  “copyright”, “credits”, or  “license” for more information.</strong>
<strong>&gt;&gt; import shapefile</strong>
<strong>&gt;&gt; import geojson</strong>
<strong>&gt;&gt; import pandas</strong>
</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>The <code class="literal">import shapefile</code> statement imports the <code class="literal">pyshp</code> library; unlike the other libraries, the import name is not the same as the installation name.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How it works...</h2></div></div></div><p>As seen in the other modules, we've used the standard installation pip package to execute installations. There are no other dependencies to worry about, making for fast progress.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Installing SciPy, PySAL, and IPython</h1></div></div></div><p>
<strong>SciPy</strong> is a<a id="id48" class="indexterm"/> collection of Python libraries, including SciPy library, matplotlib, pandas, SymPy, and IPython. The SciPy library itself is used for many operations, but we are particularly interested in the <a id="id49" class="indexterm"/>
<strong>spatial</strong> module. This module can do many things including running a nearest neighbor query.</p><p>
<strong>PySAL</strong> is a <a id="id50" class="indexterm"/>geospatial computing library that's used for spatial analysis. Creating models and running simulations directly from Python code are some of the many library functions that PySAL offers. PySAL is a library that, when put together with our visualization tools such as matplotlib, gives us a great tool.</p><p>
<strong>IPython</strong> is a <a id="id51" class="indexterm"/>Python interpreter for a console that replaces the normal Python console you may be used to when running and testing Python code from your terminal. This is really just an advanced interpreter with some cool features, such as <em>Tab</em> completion, which means that beginners can get commands quickly by typing a letter and hitting <em>Tab</em>. The IPython notebooks help share code in the form of a web page, including code, images, and more without any installation.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>Getting ready</h2></div></div></div><p>The dependency jungle we looked at earlier is back and we need three more universal installations to our Ubuntu system using <code class="literal">apt-get install</code> as follows:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install libblas-dev liblapack-dev gfortran</strong>
</pre></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Windows and Mac users can use a full installer (<a class="ulink" href="http://www.scipy.org/install.html">http://www.scipy.org/install.html</a>), such as Anaconda or Enthought Canopy, which will perform all the installation dependencies for you in one go.</p></div></div><p>Three dependencies are used for the SciPy installation. PySAL depends on SciPy so make sure to install SciPy first. Only IPython does not need any extra installations.</p><p>Start up your Python virtual environment with the following code:</p><div><pre class="programlisting">
<strong>mdiener@mdiener-VirtualBox:~$ workon pygeoan_cb</strong>
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How to do it...</h2></div></div></div><p>Let's look at<a id="id52" class="indexterm"/> these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we'll install SciPy since PySAL depends on it. This will take a while to install; it took my machine 5 minutes to go through so take a break:<div><pre class="programlisting">
<strong>$ pip install scipy</strong>
</pre></div></li><li class="listitem">PySAL<a id="id53" class="indexterm"/> can be installed super quickly using pip:<div><pre class="programlisting">
<strong>$ pip install pysal</strong>
</pre></div></li><li class="listitem">As usual, we'd like to see whether everything's working, so let's fire up the Python shell as follows:<div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$python</strong>
<strong>&gt;&gt;&gt; import scipy</strong>
<strong>&gt;&gt;&gt; import pysal</strong>
<strong>&gt;&gt;&gt;</strong>
</pre></div></li><li class="listitem">IPython <a id="id54" class="indexterm"/>is to be installed globally or inside the virtual environment using pip as follows:<div><pre class="programlisting">
<strong>$ pip install ipython</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How it works...</h2></div></div></div><p>SciPy and PySAL libraries are both geared to help accomplish various spatial analysis duties. The choice of tool is based on the task at hand, so make sure that you check which library offers what function at the command prompt as follows:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from scipy import spatial</strong>
<strong>&gt;&gt;&gt; help(spatial)</strong>
</pre></div><p>The output <a id="id55" class="indexterm"/>should <a id="id56" class="indexterm"/>look <a id="id57" class="indexterm"/>like what is shown in the following screenshot:</p><div><img src="img/B03543_01_06.jpg" alt="How it works..."/></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Installing GDAL and OGR</h1></div></div></div><p>Converting formats is boring, repetitive, and is one of the many, many responsibilities that the GDAL<a id="id58" class="indexterm"/> library provides, not to mention format transformations. However, GDAL also shines with regard to other geospatial functions, such as getting the current projections of a Shapefile or generating contours from elevation data. So, to only say that GDAL is a transformation library would be wrong; it really is so much more. The father of GDAL, Frank Warmerdam, deserves credit for starting it all off, and the GDAL project is now part of the <a id="id59" class="indexterm"/>
<strong>OSGEO</strong> (<strong>Open Source Geospatial Foundation</strong>, refer to <a class="ulink" href="http://www.osgeo.org">www.osgeo.org</a>).</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>The GDAL installation includes OGR; there is no extra installation required.</p></div></div><p>Currently, GDAL covers working with raster data, and <a id="id60" class="indexterm"/>OGR covers working with vector data. With GDAL 2.x now here, the two sides, raster and vector, are merged under one hat. GDAL and OGR are the so-called Swiss Army knives of geospatial data transformations, covering over 200 different spatial data formats.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Getting ready</h2></div></div></div><p>GDAL isn't known<a id="id61" class="indexterm"/> to be the friendliest beast to install on Windows, Linux, or OSX. There are many dependencies and even more ways to install them. The descriptions are not all very straightforward. Keep in mind that this description is just one way of doing things and will not always work on all machines, so please refer to the online instructions for the latest and best ways to get your system up and running.</p><p>To start with, we will install some dependencies globally on our machine. After the dependencies have been installed, we will go into the global installation of GDAL for Python in our global site packages.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How to do it...</h2></div></div></div><p>To globally <a id="id62" class="indexterm"/>install GDAL into our Python site packages, we will proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">The following command is used when installing build and XML tools:<div><pre class="programlisting">
<strong>$ sudo apt-get install -y build-essentiallibxml2-dev libxslt1-dev</strong>
</pre></div></li><li class="listitem">Install the GDAL development files using the following command:<div><pre class="programlisting">
<strong>$ sudo apt-get install libgdal-dev # install is 125MB</strong>
</pre></div></li><li class="listitem">This following command will install GDAL package in the main Python package. This means that GDAL will be installed globally. The global installation of GDAL is usually not a bad thing since, as far as I am aware, there are no backward incompatible versions, which is very rare these days. The installation of GDAL directly and only in <code class="literal">virtualenv</code> is painful, to say the least, and if you are interested in attempting it, I've mentioned some links for you to try out.<div><pre class="programlisting">
<strong>$ sudo apt-get install python-gdal</strong>
</pre></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>If you would like to attempt the installation inside your virtual environment, please take a look at this Stack Overflow question at <a class="ulink" href="http://gis.stackexchange.com/questions/28966/python-gdal-package-missing-header-file-when-installing-via-pip">http://gis.stackexchange.com/questions/28966/python-gdal-package-missing-header-file-when-installing-via-pip</a>.</p></div></div></li><li class="listitem">To get <a id="id63" class="indexterm"/>GDAL in the Python virtual environment, we only need to run a simple virtualevnwrapper command:<div><pre class="programlisting">
<strong>toggleglobalsitepackages</strong>
</pre></div><p>Make sure you have your virtual environment activated as follows:</p><div><pre class="programlisting">
<strong>mdiener@mdiener-VirtualBox:~$ workon pygeoan_cb</strong>
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$</strong>
</pre></div></li><li class="listitem">Now, activate the global Python site packages in your current virtual environment:<div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$ toggleglobalsitepackages</strong>
<strong>enable global site-packages</strong>
</pre></div></li><li class="listitem">The final check is to see if GDAL is available as follows:<div><pre class="programlisting">
<strong>$ python</strong>
<strong>&gt;&gt;&gt; import gdal</strong>
<strong>&gt;&gt;&gt;</strong>
</pre></div></li><li class="listitem">No errors have been found and GDAL is ready for action.</li></ol></div><p>Windows 7 plus users should use the <a id="id64" class="indexterm"/>OSGeo4W windows installer (<a class="ulink" href="https://trac.osgeo.org/osgeo4w/">https://trac.osgeo.org/osgeo4w/</a>).Find the following section on the web page and download your Windows version in 32-bit or 64-bit. Follow the graphical installer instructions and the GDAL installation will then be complete.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Windows users can also directly get binaries if all fails at <a class="ulink" href="http://www.gisinternals.com/sdk/">http://www.gisinternals.com/sdk/</a>. This installer should help avoid any other Windows specific problems that can arise and this site can help get you going in the right direction.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How it works...</h2></div></div></div><p>The GDAL installation encompasses both the raster (GDAL) and vector (OGR) tools in one. Within the GDAL install are five modules that can be separately imported into your project depending on your needs:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from osgeo import gdal</strong>
<strong>&gt;&gt;&gt; from osgeo import ogr</strong>
<strong>&gt;&gt;&gt; from osgeo import osr</strong>
<strong>&gt;&gt;&gt; from osgeo import gdal_array</strong>
<strong>&gt;&gt;&gt; from osgeo import gdalconst</strong>
<strong>&gt;&gt;&gt; python</strong>
<strong>&gt;&gt;&gt; import osgeo</strong>
<strong>&gt;&gt;&gt; help(osgeo)</strong>
</pre></div><p>To see what <a id="id65" class="indexterm"/>packages are included with your Python GDAL installation, we use the Python built-in help function to list what the OSGeo module has to offer. This is what you should see:</p><div><pre class="programlisting">
<strong>NAME</strong>
<strong>    osgeo - # __init__ for osgeo package.</strong>
<strong>FILE</strong>
<strong>    /usr/lib/python2.7/dist-packages/osgeo/__init__.py</strong>
<strong>MODULE DOCS</strong>
<strong>    http://docs.python.org/library/osgeo</strong>
<strong>PACKAGE CONTENTS</strong>
<strong>    _gdal</strong>
<strong>    _gdal_array</strong>
<strong>    _gdalconst</strong>
<strong>    _ogr</strong>
<strong>    _osr</strong>
<strong>    gdal</strong>
<strong>    gdal_array</strong>
<strong>    gdalconst</strong>
<strong>    gdalnumeric</strong>
<strong>    ogr</strong>
<strong>    osr</strong>
<strong>DATA</strong>
<strong>    __version__ = '1.10.0'</strong>
<strong>    version_info = sys.version_info(major=2, minor=7, micro=3, releaseleve...</strong>
<strong>VERSION</strong>
<strong>    1.10.0</strong>
<strong>(END)</strong>
</pre></div><p>At the time of <a id="id66" class="indexterm"/>writing this, the GDAL version is now bumped up to 2.0, and in developer land, this is old even before it gets printed. Beware that the GDAL 2.0 has compatibility issues and for this book, version 1.x.x is recommended.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>See also</h2></div></div></div><p>The <a class="ulink" href="http://www.gdal.org">http://www.gdal.org</a> homepage is always the best place for reference regarding any information about it. The OSGEO includes GDAL as a supported project, and you can find more information on it at <a class="ulink" href="http://www.osgeo.org">http://www.osgeo.org</a>.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Installing GeoDjango and PostgreSQL with PostGIS</h1></div></div></div><p>This is our final installation recipe and if you have followed along so far, you are ready for a simple, straightforward start to Django. Django is a web framework for professionals with deadlines, according to the Django homepage. The spatial part of it can be found in <a id="id67" class="indexterm"/>
<strong>GeoDjango</strong>. GeoDjango is a contrib module installed with every Django installation therefore, you only need to install Django to get GeoDjango running. Of course, "geo" has its dependencies that were met in the previous sections. For reference purposes, take a look at this great documentation on the Django homepage at</p><p>
<a class="ulink" href="https://docs.djangoproject.com/en/dev/ref/contrib/gis/install/#ref-gis-install">https://docs.djangoproject.com/en/dev/ref/contrib/gis/install/#ref-gis-install</a>.</p><p>We will use<a id="id68" class="indexterm"/> PostgreSQL<a id="id69" class="indexterm"/> and PostGIS <a id="id70" class="indexterm"/>since they are the open source industry go-to spatial databases. The installations are not 100% necessary, but without them there is no real point because you then limit your operations, and they're definitely needed if you plan to store your spatial data in a spatial database. The combination of PostgreSQL and PostGIS is the most common spatial database setup for GeoDjango. This installation is definitely more involved and can lead to some hook-ups depending on your system.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>Getting ready</h2></div></div></div><p>To use GeoDjango, we<a id="id71" class="indexterm"/> will need to have a spatial database installed, and in our case, we will be using PostgreSQL with the PostGIS extension. GeoDjango also supports Oracle, Spatialite, and MySQL. The dependencies of PostGIS include GDAL, GEOS, PROJ.4, LibXML2, and JSON-C.</p><p>Start up your Python virtual environment as follows:</p><div><pre class="programlisting">
<strong>mdiener@mdiener-VirtualBox:~$ workon pygeoan_cb</strong>
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$</strong>
</pre></div><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How to do it...</h2></div></div></div><p>Follow these steps. These are taken from the PostgreSQL homepage for Ubuntu Linux:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new file called <code class="literal">pgdg.list</code> using the standard gedit text editor. This stores the command to fire up your Ubuntu installer package:<div><pre class="programlisting">
<strong>$ sudo gedit /etc/apt/sources.list.d/pgdg.list</strong>
</pre></div></li><li class="listitem">Add this line to the file, save, and then close it:<div><pre class="programlisting">
<strong>$ deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main</strong>
</pre></div></li><li class="listitem">Now, run the <code class="literal">wget</code> command for add the key:<div><pre class="programlisting">
<strong>$ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | \ sudo apt-key add -</strong>
</pre></div></li><li class="listitem">Run the <code class="literal">update</code> command to actualize your installer packages:<div><pre class="programlisting">
<strong>$ sudo apt-get update</strong>
</pre></div></li><li class="listitem">Run the <code class="literal">install</code> command to actually install PostgreSQL 9.3:<div><pre class="programlisting">
<strong>$ sudo apt-get install postgresql-9.3</strong>
</pre></div></li><li class="listitem">To install PostGIS 2.1, we will have one unmet dependency, <code class="literal">libgdal1</code>, so go ahead and install it:<div><pre class="programlisting">
<strong>$ sudo apt-get install libgdal1</strong>
</pre></div></li><li class="listitem">Now we <a id="id72" class="indexterm"/>can install PostGIS 2.1 for PostgreSQL 9.3 on our machine:<div><pre class="programlisting">
<strong>$ sudo apt-get install postgresql-9.3-postgis-2.1</strong>
</pre></div></li><li class="listitem">Install the PostgreSQL header files:<div><pre class="programlisting">
<strong>$ sudo apt-get install libpq-dev</strong>
</pre></div></li><li class="listitem">Finally, install the <code class="literal">contrib</code> module with contributions:<div><pre class="programlisting">
<strong>$ sudo apt-get install postgresql-contrib</strong>
</pre></div></li><li class="listitem">Install the Python database adapter, <code class="literal">psycopg2</code>, to connect to your PostgreSQL database from Python:<div><pre class="programlisting">
<strong>$ sudo apt-get install python-psycopg2</strong>
</pre></div></li><li class="listitem">Now we can create a standard PostgreSQL database as follows:<div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$ createdb [NewDatabaseName]</strong>
</pre></div></li><li class="listitem">Using the <code class="literal">psql</code> command-line tool, we can create a PostGIS extension to our newly created database to give it all the PostGIS functions as follows:<div><pre class="programlisting">
<strong>(pygeoan_cb)mdiener@mdiener-VirtualBox:~$ psql -d [NewDatabaseName] -c "CREATE EXTENSION postgis;"</strong>
</pre></div></li><li class="listitem">Moving on, we can finally install Django in one line directly in our activated virtual environment:<div><pre class="programlisting">
<strong>$ pip install django</strong>
</pre></div></li><li class="listitem">Test out your install of Django and GDAL and, as always, try to import them as follows:<div><pre class="programlisting">
<strong>&gt;&gt;&gt; from django.contrib.gis import gdal</strong>
<strong>&gt;&gt;&gt; gdal.HAS_GDAL</strong>
<strong>True</strong>
</pre></div></li></ol></div><p>Windows users should be directed to the PostgreSQL Windows (<a class="ulink" href="http://www.postgresql.org/download/windows/">http://www.postgresql.org/download/windows/</a>) binaries provided by EnterpriseDB (<a class="ulink" href="http://www.enterprisedb.com/products-services-training/pgdownload#windows">http://www.enterprisedb.com/products-services-training/pgdownload#windows</a>). Download the correct version and follow the installer instructions. PostGIS is also included in the list of extensions that you can directly install using the installer.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>How it works...</h2></div></div></div><p>Installations using <a id="id73" class="indexterm"/>the apt-get Ubuntu installer and the Windows installers are simple enough in order to have PostgreSQL, PostGIS, and Django up and running. However, the inner workings of the installers are beyond the scope of this book.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>There's more...</h2></div></div></div><p>To summarize all the installed libraries, take a look at this table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Library name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Reason to install</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>NumPy</p>
</td><td style="text-align: left" valign="top">
<p>This adds support for large multidimensional arrays and matrices</p>
</td><td style="text-align: left" valign="top">
<p>It is a requirement for many other libraries</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>pyproj</p>
</td><td style="text-align: left" valign="top">
<p>This handles projections</p>
</td><td style="text-align: left" valign="top">
<p>It transforms projections</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>shapely</p>
</td><td style="text-align: left" valign="top">
<p>This handles geospatial operations</p>
</td><td style="text-align: left" valign="top">
<p>It performs fast geometry manipulations and operations</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>matplotlib</p>
</td><td style="text-align: left" valign="top">
<p>This plots libraries</p>
</td><td style="text-align: left" valign="top">
<p>It provides a quick visualization of results</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>descartes</p>
</td><td style="text-align: left" valign="top">
<p>This uses Shapely or GeoJSON objects as matplotlib paths and patches</p>
</td><td style="text-align: left" valign="top">
<p>It speedily plots geo-data</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>pandas</p>
</td><td style="text-align: left" valign="top">
<p>This provides high-performance data structures and data analysis</p>
</td><td style="text-align: left" valign="top">
<p>It performs data manipulation, CSV creation, and data manipulation</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SciPy</p>
</td><td style="text-align: left" valign="top">
<p>This provides a collection of Python libraries for scientific computing</p>
</td><td style="text-align: left" valign="top">
<p>It has the best collection of necessary tools</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PySAL</p>
</td><td style="text-align: left" valign="top">
<p>This contains a geospatial analysis library</p>
</td><td style="text-align: left" valign="top">
<p>It performs a plethora of spatial operations (optional)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>IPython</p>
</td><td style="text-align: left" valign="top">
<p>This provides interactive Python computing</p>
</td><td style="text-align: left" valign="top">
<p>It is a helpful notebook to store and save your scripts (optional)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Django</p>
</td><td style="text-align: left" valign="top">
<p>This contains a web application framework</p>
</td><td style="text-align: left" valign="top">
<p>It is used for our demo web application in <a class="link" href="ch11.html" title="Chapter 11. Web Analysis with GeoDjango">Chapter 11</a>, <em>Web Analysis with GeoDjango</em>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>pyshp</p>
</td><td style="text-align: left" valign="top">
<p>This provides pure Python shapefile manipulation and generation</p>
</td><td style="text-align: left" valign="top">
<p>It helps input and output shapefiles</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GeoJSON</p>
</td><td style="text-align: left" valign="top">
<p>This contains the JSON format for spatial data</p>
</td><td style="text-align: left" valign="top">
<p>It facilitates the exchange and publication of this format</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PostgreSQL</p>
</td><td style="text-align: left" valign="top">
<p>This is a relational database</p>
</td><td style="text-align: left" valign="top">
<p>It helps store spatial data</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PostGIS</p>
</td><td style="text-align: left" valign="top">
<p>This is the spatial extension to PostgreSQL</p>
</td><td style="text-align: left" valign="top">
<p>It stores and performs spatial operations on geographic data in PostgreSQL</p>
</td></tr></tbody></table></div></div></div></div>
</body></html>