["```py\nimport itertools, operator\nfrom .data import *\n\nimport shapely\nfrom shapely.prepared import prep as supershapely\n```", "```py\nimport itertools, operator\nfrom .data import *\nfrom .manager import *\n\nimport PIL.Image, PIL.ImageMath, PIL.ImageStat\n```", "```py\nfrom . import analyzer\n```", "```py\ndef overlap_summary(groupbydata, valuedata, fieldmapping=[]):\n    # prep\n    data1,data2 = groupbydata,valuedata\n    if fieldmapping: aggfields,aggtypes = zip(*fieldmapping)\n    aggfunctions = dict([(\"count\",len),\n                         (\"sum\",sum),\n                         (\"max\",max),\n                         (\"min\",min),\n                         (\"average\",lambda seq: sum(seq)/float(len(seq)) ) ])\n\n    # create spatial index\n    if not hasattr(data1, \"spindex\"): data1.create_spatial_index()\n    if not hasattr(data2, \"spindex\"): data2.create_spatial_index()\n\n    # create new\n    new = VectorData()\n    new.fields = list(data1.fields)\n    if fieldmapping: \n        for aggfield,aggtype in fieldmapping:\n            new.fields.append(aggfield)\n\n    # for each groupby feature\n    for i,feat in enumerate(data1.quick_overlap(data2.bbox)):\n        geom = feat.get_shapely()\n        geom = supershapely(geom)\n        matches = []\n\n        # get all value features that intersect\n        for otherfeat in data2.quick_overlap(feat.bbox):        \n            othergeom = otherfeat.get_shapely()\n            if geom.intersects(othergeom):\n                matches.append(otherfeat)\n\n        # make newrow from original row\n        newrow = list(feat.row)\n\n        # if any matches\n        if matches:\n            def make_number(value):\n                try: return float(value)\n                except: return None\n\n            # add summary values to newrow based on fieldmapping\n            for aggfield,aggtype in fieldmapping:\n                values = [otherfeat[aggfield] for otherfeat in matches]\n                if aggtype in (\"sum\",\"max\",\"min\",\"average\"):\n                    # only consider number values if numeric stats\n                    values = [make_number(value) for value in values if make_number(value) != None]\n                aggregatefunc = aggfunctions[aggtype]\n                summaryvalue = aggregatefunc(values)\n                newrow.append(summaryvalue)\n\n        # otherwise, add empty values\n        else:\n            newrow.extend((\"\" for _ in fieldmapping))\n\n        # write feature to output\n        new.add_feature(newrow, feat.geometry)\n\n    return new\n```", "```py\ndef buffer(data, dist_expression):\n    # buffer and change each geojson dict in-place\n    new = VectorData()\n    new.fields = list(data.fields)\n    for feat in data:\n        geom = feat.get_shapely()\n        dist = eval(dist_expression)\n        buffered = geom.buffer(dist)\n        if not buffered.is_empty:\n            geojson = buffered.__geo_interface__\n            geojson[\"type\"] = buffered.type\n            new.add_feature(feat.row, geojson)\n    # change data type to polygon\n    new.type = \"Polygon\"\n    return new\n```", "```py\ndef zonal_statistics(zonaldata, valuedata, zonalband=0, valueband=0, outstat=\"mean\"):\n    \"\"\"\n    For each unique zone in \"zonaldata\", summarizes \"valuedata\" cells that overlap \"zonaldata\".\n    Which band to use must be specified for each.\n\n    The \"outstat\" statistics option can be one of: mean, median, max, min, stdev, var, count, or sum\n    \"\"\"\n    # get nullvalues\n    nullzone = zonaldata.info.get(\"nodata_value\")\n\n    # position value grid into zonal grid\n    (valuedata,valuemask) = valuedata.positioned(zonaldata.width, zonaldata.height,\n                                                 zonaldata.bbox)\n\n    # pick one image band for each\n    zonalimg = zonaldata.bands[zonalband].img\n    valueimg = valuedata.bands[valueband].img\n\n    # create output image, using nullzone as nullvalue\n    outimg = PIL.Image.new(\"F\", zonalimg.size, nullzone)\n\n    # get stats for each unique value in zonal data\n    zonevalues = [val for count,val in zonalimg.getcolors()]\n    zonesdict = {}\n    for zoneval in zonevalues:\n        # exclude nullzone\n        if zoneval == nullzone: continue\n\n        # mask only the current zone\n        zonemask = zonalimg.point(lambda px: 1 if px == zoneval else 0, \"1\")\n        fullmask = PIL.Image.new(\"1\", zonemask.size, 0)\n        # also exclude null values from calculations\n        fullmask.paste(zonemask, valuemask)\n\n        # retrieve stats\n        stats = PIL.ImageStat.Stat(valueimg, fullmask)\n        statsdict = {}\n        statsdict[\"min\"],statsdict[\"max\"] = stats.extrema[0]\n        for stattype in (\"count\",\"sum\",\"mean\",\"median\",\"var\",\"stddev\"):\n            try: statsdict[stattype] = stats.__getattr__(stattype)[0]\n            except ZeroDivisionError: statsdict[stattype] = None\n        zonesdict[zoneval] = statsdict\n\n        # write chosen stat to outimg\n        outimg.paste(statsdict[outstat], (0,0), zonemask)\n\n    # make outimg to raster\n    outraster = Raster(image=outimg, **zonaldata.info)\n\n    return zonesdict, outraster\n```", "```py\n        # Buffering\n        def open_options_window():\n            window = VectorBufferOptionWindow(self.layeritem, self.layerspane, self.layeritem, statusbar)\n        self.imgs[\"buffer\"] = icons.get(\"buffer.png\", width=32, height=32)\n        self.add_command(label=\"Buffer\", command=open_options_window, image=self.imgs[\"buffer\"], compound=\"left\")\n```", "```py\nclass VectorBufferOptionWindow(Window):\n    def __init__(self, master, layerspane, layeritem, statusbar, **kwargs):\n        # Make this class a subclass and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Create runtoolframe\n        self.runtool = RunToolFrame(self)\n        self.runtool.pack(fill=\"both\", expand=True)\n        self.runtool.assign_statusbar(statusbar)\n\n        # Add a hidden option from its associated layeritem data\n        self.runtool.add_hidden_option(argname=\"data\", value=layeritem.renderlayer.data)\n\n        # Set the remaining options\n        self.runtool.set_target_method(\"Buffering data...\", vector.analyzer.buffer)\n        self.runtool.add_option_input(argname=\"dist_expression\",\n                              label=\"Distance calculation\",\n                              valuetype=str)\n\n        # Define how to process\n        def process(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Failed to buffer the data:\" + \"\\n\\n\" + str(result) )\n            else:\n                layerspane.add_layer(result)\n                self.destroy()\n        self.runtool.set_finished_method(process)\n```", "```py\n        ## Analysis tab\n        analysistab = self.ribbon.add_tab(\"Analyze\")\n        ### (Vector toolbar)\n        vectorfiles = analysistab.add_toolbar(\"Vector\")\n        def open_overlapsummary_window():\n            window = VectorOverlapSummaryWindow(self, self.layerspane, self.statusbar)\n        vectorfiles.add_button(text=\"Overlap Summary\", icon=\"overlap.png\",\n                               command=open_overlapsummary_window)\n        ### (Raster toolbar)\n        rasterfiles = analysistab.add_toolbar(\"Raster\")\n        def open_zonalstats_window():\n            window = RasterZonalStatsOptionWindow(self, self.layerspane, self.statusbar)\n        rasterfiles.add_button(text=\"Zonal statistics\", icon=\"zonalstats.png\",\n                               command=open_zonalstats_window)\n```", "```py\nclass VectorOverlapSummaryWindow(Window):\n    def __init__(self, master, layerspane, statusbar, **kwargs):\n        # Make this class a subclass and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Create runtoolframe\n        self.runtool = RunToolFrame(self)\n        self.runtool.pack(fill=\"both\", expand=True)\n        self.runtool.assign_statusbar(statusbar)\n\n        # Set the remaining options\n        self.runtool.set_target_method(\"Calculating overlap summary on data...\", vector.analyzer.overlap_summary)\n        def get_data_from_layername(name):\n            data = None\n            for layeritem in layerspane:\n                if layeritem.namelabel[\"text\"] == name:\n                    data = layeritem.renderlayer.data\n                    break\n            return data\n        self.runtool.add_option_input(argname=\"groupbydata\",\n                              label=\"Group by data\",\n                              default=\"(Choose layer)\",\n                              choices=[layeritem.namelabel[\"text\"] for layeritem in layerspane],\n                              valuetype=get_data_from_layername)\n        self.runtool.add_option_input(argname=\"valuedata\",\n                              label=\"Value data\",\n                              default=\"(Choose layer)\",\n                              choices=[layeritem.namelabel[\"text\"] for layeritem in layerspane],\n                              valuetype=get_data_from_layername)\n        self.runtool.add_option_input(argname=\"fieldmapping\",\n                              label=\"Field mapping\",\n                              multi=True,\n                              valuetype=eval)\n\n        # Define how to process\n        def process(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Failed to calculate overlap summary on data:\" + \"\\n\\n\" + str(result) )\n            else:\n                layerspane.add_layer(result, name=\"overlap summary\")\n        self.runtool.set_finished_method(process)\n```", "```py\nclass RasterZonalStatsOptionWindow(Window):\n    def __init__(self, master, layerspane, statusbar, **kwargs):\n        # Make this class a subclass and add to it\n        Window.__init__(self, master, **kwargs)\n\n        # Create runtoolframe\n        self.runtool = RunToolFrame(self)\n        self.runtool.pack(fill=\"both\", expand=True)\n        self.runtool.assign_statusbar(statusbar)\n\n        # Set the remaining options\n        self.runtool.set_target_method(\"Calculating zonal statistics on data...\", raster.analyzer.zonal_statistics)\n        def get_data_from_layername(name):\n            data = None\n            for layeritem in layerspane:\n                if layeritem.namelabel[\"text\"] == name:\n                    data = layeritem.renderlayer.data\n                    break\n            return data\n        self.runtool.add_option_input(argname=\"zonaldata\",\n                              label=\"Zonal data\",\n                              default=\"(Choose layer)\",\n                              choices=[layeritem.namelabel[\"text\"] for layeritem in layerspane],\n                              valuetype=get_data_from_layername)\n        self.runtool.add_option_input(argname=\"valuedata\",\n                              label=\"Value data\",\n                              default=\"(Choose layer)\",\n                              choices=[layeritem.namelabel[\"text\"] for layeritem in layerspane],\n                              valuetype=get_data_from_layername)\n        self.runtool.add_option_input(argname=\"zonalband\",\n                              label=\"Zonal band\",\n                              valuetype=int,\n                              default=0)\n        self.runtool.add_option_input(argname=\"valueband\",\n                              label=\"Value band\",\n                              valuetype=int,\n                              default=0)\n        self.runtool.add_option_input(argname=\"outstat\",\n                              label=\"Output Raster Statistic\",\n                              valuetype=str,\n                              default=\"mean\",\n                              choices=[\"min\",\"max\",\"count\",\"sum\",\"mean\",\"median\",\"var\",\"stddev\"] )\n```", "```py\n        # Define how to process\n        def process(result):\n            if isinstance(result, Exception):\n                popup_message(self, \"Failed to calculate zonal statistics on the data:\" + \"\\n\\n\" + str(result) )\n            else:\n                zonesdict, outraster = result\n                # add the resulting zonestatistics layer\n                layerspane.add_layer(outraster, name=\"zonal statistic\")\n                # also view stats in window\n                win = Window()\n                textbox = tkst.ScrolledText(win)\n                textbox.pack(fill=\"both\", expand=True)\n                textbox.insert(tk.END, \"Zonal statistics detailed result:\")\n                textbox.insert(tk.END, \"\\n------------------------ ---------\\n\")\n                for zone,stats in zonesdict.items():\n                    statstext = \"\\n\"+\"Zone %i:\"%zone\n                    statstext += \"\\n\\t\" + \"\\n\\t\".join([\"%s: %f\"%(key,val) for key,val in stats.items()])\n                    textbox.insert(tk.END, statstext)\n        self.runtool.set_finished_method(process)\n```"]