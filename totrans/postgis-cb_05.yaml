- en: Working with Raster Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting and loading rasters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with basic raster information and analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing simple map-algebra operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining geometries with rasters for analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between rasters and geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing and loading rasters with GDAL VRT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warping and resampling rasters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing advanced map-algebra operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing DEM operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing and visualizing rasters through SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the recipes are presented in a step-by-step workflow that you
    may apply while working with a raster. This entails loading the raster, getting
    a basic understanding of the raster, processing and analyzing it, and delivering
    it to consumers. We intentionally add some detours to the workflow to reflect
    the reality that the raster, in its original form, may be confusing and not suitable
    for analysis. At the end of this chapter, you should be able to take the lessons
    learned from the recipes and confidently apply them to solve your raster problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going further, we should describe what a raster is, and what a raster
    is used for. At the simplest level, a raster is a photo or image with information
    describing where to place the raster on the Earth''s surface. A photograph typically
    has three sets of values: one set for each primary color (red, green, and blue).
    A raster also has sets of values, often more than those found in a photograph.
    Each set of values is known as a **band**. So, a photograph typically has three
    bands, while a raster has at least one band. Like digital photographs, rasters
    come in a variety of file formats. Common raster formats you may come across include
    PNG, JPEG, GeoTIFF, HDF5, and NetCDF. Since rasters can have many bands and even
    more values, they can be used to store large quantities of data in an efficient
    manner. Due to their efficiency, rasters are used for satellite and aerial sensors
    and modeled surfaces, such as weather forecasts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few keywords used in this chapter and in the PostGIS ecosystem
    that need to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raster**: This is the PostGIS data type for storing raster files in PostgreSQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tile**: This is a small chunk of the original raster file to be stored in
    one column of a table''s row. Each tile has its own set of spatial information,
    and thus is independent of all the other tiles in the same column of the same
    table, even if the other tiles are from the same original raster file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coverage**: This consists of all the tiles of a single raster column from
    one table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We make heavy use of GDAL in this chapter. GDAL is generally considered the
    de facto Swiss Army knife for working with rasters. GDAL is not a single application,
    but is a raster-abstraction library with many useful utilities. Through GDAL,
    you can get the metadata of a raster, convert that raster to a different format,
    and warp that raster among many other capabilities. For our needs in this chapter,
    we will use three GDAL utilities: `gdalinfo`, `gdalbuildvrt`, and `gdal_translate`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting and loading rasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we load most of the rasters used in this chapter. These rasters
    are examples of satellite imagery and model-generated surfaces, two of the most
    common raster sources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have not done so already, create a directory and copy the chapter''s
    datasets; for Windows, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For Linux or macOS, go into the folder you wish to use and run the following
    commands, where `/path/to/book_dataset/chap05` is the path where you originally
    stored the book source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also create a new schema for this chapter in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with the PRISM average monthly minimum-temperature raster dataset
    for 2016 with coverage for the continental United States. The raster is provided
    by the PRISM Climate Group at Oregon State University, with additional rasters
    available at [http://www.prism.oregonstate.edu/mtd/](http://www.prism.oregonstate.edu/mtd/).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the command line, navigate to the `PRISM` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us spot check one of the PRISM rasters with the GDAL utility `gdalinfo`.
    It is always a good practice to inspect at least one raster to get an idea of
    the metadata and ensure that the raster does not have any issues. This can be
    done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gdalinfo` output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3097d298-ff89-49c1-be46-01d1b67344c6.png)'
  prefs: []
  type: TYPE_IMG
- en: The `gdalinfo` output reveals that the raster has no issues, as evidenced by
    the `Corner Coordinates`, `Pixel Size`, `Band`, and `Coordinate System` being
    unempty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking through the metadata, we find that the metadata about the spatial reference
    system indicates that raster uses the NAD83 coordinate system. We can double-check
    this by searching for the details of NAD83 in the `spatial_ref_sys` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Comparing the text of `srtext` to the PRISM raster's metadata spatial attributes,
    we find that the raster is in EPSG (SRID 4269).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can load the PRISM rasters into the `chp05.prism` table with `raster2pgsql`,
    which will import the raster files to the database in a similar manner as the
    `shp2pgsql` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `raster2pgsql` command is called with the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-s`: This flag assigns SRID`4269` to the imported rasters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t`: This flag denotes the tile size. It chunks the imported rasters into
    smaller and more manageable pieces; each record added to the table will be, at
    most, 100 x 100 pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-F`: This flag adds a column to the table and fills it with the raster''s
    filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-I`: This flag creates a GIST spatial index on the table''s raster column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-C`: This flag applies the standard set of constraints on the table. The standard
    set of constraints includes checks for dimension, scale, skew, upper-left coordinate,
    and SRID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Y`: This flag instructs `raster2pgsql` to use `COPY` statements instead of
    `INSERT` statements. `COPY` is typically faster than `INSERT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a reason why we passed `-F` to `raster2pgsql`. If you look at the
    filenames of the PRISM rasters, you''ll note the year and month. So, let''s convert
    the value in the `filename` column to a date in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is all that needs to be done with the `PRISM` rasters for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's import a **Shuttle Radar Topography Mission** (**SRTM**) raster.
    The SRTM raster is from the SRTM that was conducted by the NASA Jet Propulsion
    Laboratory in February, 2000\. This raster and others like it are available at: [http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/](http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the current directory to the `SRTM` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you spot check the SRTM raster with `gdalinfo` to ensure that it
    is valid and has a value for `Coordinate System`. Once checked, import the SRTM
    raster into the `chp05.srtm` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We use the same `raster2pgsql` flags for the SRTM raster as those for the PRISM
    rasters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to import a `shapefile` of San Francisco provided by the City
    and County of San Francisco, available with the book''s dataset files, or the
    one found on the following link, after exporting the data to a shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://data.sfgov.org/Geographic-Locations-and-Boundaries/SF-Shoreline-and-Islands/rgcx-5tix](https://data.sfgov.org/Geographic-Locations-and-Boundaries/SF-Shoreline-and-Islands/rgcx-5tix)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fc8441e-bfdc-43c7-a64f-bc6aed696736.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The San Francisco''s boundaries from the book''s files will be used in many
    of the follow-up recipes, and it must be loaded to the database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we imported the required PRISM and SRTM rasters needed for the
    rest of the recipes. We also imported a `shapefile` containing San Francisco's
    boundaries to be used in the various raster analyses. Now, on to the fun!
  prefs: []
  type: TYPE_NORMAL
- en: Working with basic raster information and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've checked and imported the PRISM and SRTM rasters into the `chp05`
    schema of the `postgis_cookbook` database. We will now proceed to work with the
    rasters within the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore functions that provide insight into the raster attributes
    and characteristics found in the `postgis_cookbook` database. In doing so, we
    can see if what is found in the database matches the information provided by accessing `gdalinfo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostGIS includes the `raster_columns` view to provide a high-level summary of
    all the raster columns found in the database. This view is similar to the `geometry_columns`
    and `geography_columns` views in function and form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the following SQL query in the `raster_columns` view to see what
    information is available in the `prism` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL query returns a record similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b19975a-d332-498c-84f9-8fa9db10c094.png)![](img/48ea6133-ae9f-4066-b507-326d7e9ce775.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you look back at the `gdalinfo` output for one of the PRISM rasters, you'll
    see that the values for the scales (the pixel size) match. The flags passed to
    `raster2pgsql`, specifying tile size and `SRID`, worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the metadata of a single raster tile looks like. We will use
    the `ST_Metadata()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1f006b3-060e-47b9-9897-9d0da65d15be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use `ST_BandMetadata()` to examine the first and only band of raster tiles
    at the record ID `54`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The results indicate that the band is of pixel type `32BF`, and has a `NODATA`
    value of `-9999`. The `NODATA` value is the value assigned to an empty pixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ae15d6a-9090-4723-884b-208b358b927d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, to do something a bit more useful, run some basic statistic functions on
    this raster tile.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s compute the summary statistics (count, mean, standard deviation,
    min, and max) with `ST_SummaryStats() for an specific raster, in this case, number
    54`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90003a6a-40f3-463f-ace0-879fa17846be.png)'
  prefs: []
  type: TYPE_IMG
- en: In the summary statistics, if the `count` indicates less than *10,000 (100²)*,
    it means that the raster is 10,000-count/100\. In this case, the raster tile is
    about 0% `NODATA`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the values of the raster tile are distributed with `ST_Histogram()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad639382-a20d-4612-93ff-afb2712f14e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks like about 78% of all of the values are at or below `1370.50`. Another
    way to see how the pixel values are distributed is to use `ST_Quantile()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3afabcee-98d7-4579-b881-74f51c6baa61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see what the top 10 occurring values are in the raster tile with `ST_ValueCount()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4015129-1c61-447e-bdb1-ea3ef7ea20f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ST_ValueCount` allows other combinations of parameters that will allow
    rounding up of the values in order to aggregate some of the results, but a previous
    subset of values to look for must be defined; for example, the following code
    will count the appearance of values `2`, `3`, `2.5`, `5.612999` and `4.176` rounded
    to the fifth decimal point `0.00001`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The results show the number of elements that appear similar to the rounded-up
    values in the array. The two values borrowed from the results on the previous
    figure, confirm the counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fbe1084-94b5-4ac2-bf6d-35715532211c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part of this recipe, we looked at the metadata of the `prism` raster
    table and a single raster tile. We focused on that single raster tile to run a
    variety of statistics. The statistics provided some idea of what the data looks
    like.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that the pixel values looked wrong when we looked at the output
    from `ST_SummaryStats()`. This same issue continued in the output from subsequent
    statistics functions. We also found that the values were in Celsius degrees. In
    the next recipe, we will recompute all the pixel values to their true values with
    a map-algebra operation.
  prefs: []
  type: TYPE_NORMAL
- en: Performing simple map-algebra operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw that the values in the PRISM rasters did not
    look correct for temperature values. After looking at the PRISM metadata, we learned
    that the values were scaled by `100`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will process the scaled values to get the true values. Doing
    this will prevent future end-user confusion, which is always a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostGIS provides two types of map-algebra functions, both of which return a
    new raster with one band. The type you use depends on the problem being solved
    and the number of raster bands involved.
  prefs: []
  type: TYPE_NORMAL
- en: The first map-algebra function (`ST_MapAlgebra()` or `ST_MapAlgebraExpr()`)
    depends on a valid, user-provided PostgreSQL algebraic expression that is called
    for every pixel. The expression can be as simple as an equation, or as complex
    as a logic-heavy SQL expression. If the map-algebra operation only requires at
    most two raster bands, and the expression is not complicated, you should have
    no problems using the expression-based map-algebra function.
  prefs: []
  type: TYPE_NORMAL
- en: The second map-algebra function (`ST_MapAlgebra()`, `ST_MapAlgebraFct()`, or
    `ST_MapAlgebraFctNgb()`) requires the user to provide an appropriate PostgreSQL
    function to be called for each pixel. The function being called can be written
    in any of the PostgreSQL PL languages (for example, PL/pgSQL, PL/R, PL/Perl),
    and be as complex as needed. This type is more challenging to use than the expression
    map-algebra function type, but it has the flexibility to work on any number of
    raster bands.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we use only the expression-based map-algebra function, `ST_MapAlgebra()`,
    to create a new band with the temperature values in Fahrenheit, and then append
    this band to the processed raster. If you are not using PostGIS 2.1 or a later
    version, use the equivalent `ST_MapAlgebraExpr()` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any operation that is going to take a while and/or modify a stored raster,
    it is best to test that operation to ensure there are no mistakes and the output
    looks correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `ST_MapAlgebra()` on one raster tile, and compare the summary statistics
    before and after the map-algebra operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/148cc3c8-884d-4252-b969-e4d13c2727cf.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `ST_MapAlgebra()` function, we indicate that the output raster's band
    will have a pixel type of `32BF` and a `NODATA` value of `-9999`. We use the expression
    `'([rast]*9/5)+32'` to convert each pixel value to its new value in Fahrenheit.
    Before `ST_MapAlgebra()` evaluates the expression, the pixel value replaces the
    placeholder `'[rast]'`. There are several other placeholders available, and they
    can be found in the `ST_MapAlgebra()` documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the summary statistics and comparing the before and after processing,
    we see that the map-algebra operation works correctly. So, let''s correct the
    entire table. We will append the band created from `ST_MapAlgebra()` to the existing
    raster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The SQL query will not work. Why? If you remember, when we loaded the PRISM
    rasters, we instructed `raster2pgsql` to add the standard constraints with the
    `-C` flag. It looks like we violated at least one of those constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'When installed, the standard constraints enforce a set of rules on each value
    of a raster column in the table. These rules guarantee that each raster column
    value has the same (or appropriate) attributes. The standard constraints comprise
    the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Width and height**: This rule states that all the rasters must have the same
    width and height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale X and Y**: This rule states that all the rasters must have the same
    scale X and Y'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SRID**: This rule states that all rasters must have the same SRID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Same alignment**: This rule states that all rasters must be aligned to one
    another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum extent**: This rule states that all rasters must be within the table''s
    maximum extent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of bands**: This rule states that all rasters must have the same number
    of bands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NODATA values**: This rule states that all raster bands at a specific index
    must have the same NODATA value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Out-db**: This rule states that all raster bands at a specific index must
    be `in-db` or `out-db`, not both'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pixel type**: This rule states that all raster bands at a specific index
    must be of the same pixel type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error message indicates that we violated the `out-db` constraint. But we
    can't accept the error message as it is, because we are not doing anything related
    to `out-db`. All we are doing is adding a second band to the raster. Adding the
    second band violates the `out-db` constraint, because the constraint is prepared
    only for one band in the raster, not a raster with two bands.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have to drop the constraints, make our changes, and reapply the constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After this command, we will have the following output showing the constraints
    were dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fedf15ae-fcc8-444f-80b2-f166a5e9eb2c.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UPDATE` will take some time, and the output will look as follows, showing
    that the constraints were added again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55eddef7-c396-4e29-8e3d-2282490b2462.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is not much information provided in the output, so we will inspect the
    rasters. We will look at one raster tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b88f202-5686-4413-87d7-d3d675ced876.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The raster has two bands. The following are the details of these two bands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aabe0af-6362-4e68-9bd2-823a6094f42c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first band is the same as the new second band with the correct attributes
    (the `32BF` pixel type, and the `NODATA value` of `-9999`) that we specified in
    the call to `ST_MapAlgebra()`.The real test, though, is to look at the summary
    statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6f09e95-8821-4ca2-8387-24e06ec0c549.png)'
  prefs: []
  type: TYPE_IMG
- en: The summary statistics show that band `2` is correct after the values from band
    `1` were transformed into Fahrenheit; that is, the mean temperature is `6.05`
    of band 1 in degrees Celsius, and `42.90` in degrees Fahrenheit in band 2).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we applied a simple map-algebra operation with `ST_MapAlgebra()`
    to correct the pixel values. In a later recipe, we will present an advanced map-algebra
    operation to demonstrate the power of `ST_MapAlgebra()`.
  prefs: []
  type: TYPE_NORMAL
- en: Combining geometries with rasters for analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two recipes, we ran basic statistics only on one raster tile.
    Though running operations on a specific raster is great, it is not very helpful
    for answering real questions. In this recipe, we will use geometries to filter,
    clip, and unite raster tiles so that we can answer questions for a specific area.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the San Francisco boundaries geometry previously imported into the
    `sfpoly` table. If you have not imported the boundaries, refer to the first recipe
    of this chapter for instructions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are to look at rasters in the context of San Francisco, an easy question
    to ask is: what was the average temperature for March, 2017 in San Francisco? Have
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding SQL query, there are four items to pay attention to, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ST_Transform()`: This method converts the geometry''s coordinates from one
    spatial reference system to another. Transforming a geometry is typically faster
    than transforming a raster. Transforming a raster requires the pixel values to
    be resampled, a compute-intensive process, and one that could introduce undesirable
    results. If possible, always transform a geometry before transforming a raster,
    because spatial joins need to use the same SRID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_Intersects()`: The `ST_Intersects()` method found in the `JOIN ON` clause
    tests if the raster tile and the geometry spatially intersect. It will use any
    available spatial indexes. Depending on the installed version of PostGIS, `ST_Intersects()`
    will implicitly convert the input geometry to a raster (PostGIS 2.0), or the input
    raster to a geometry (PostGIS 2.1), before comparing the two inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_Clip()`: This method trims each intersecting raster tile only to the area
    that intersects the geometry. It eliminates the pixels that are not spatially
    part of the geometry. Like `ST_Intersects()`, the geometry is implicitly converted
    to a raster before clipping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ST_Union()`: This method aggregates and merges the clipped raster tiles into
    one raster for further processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following output shows the average minimum temperature for San Francisco:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5a35ea8-33f3-4803-a851-e2faf9c15a82.png)'
  prefs: []
  type: TYPE_IMG
- en: San Francisco was really cold in March, 2017\. So, how does the rest of 2017
    look? Is San Francisco always cold?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The only change from the prior SQL query is the removal of the `WHERE` clause
    and the addition of a `GROUP BY` clause. Since `ST_Union()` is an aggregate function,
    we need to group the clipped rasters by `month_year`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9831fb6-74b2-44e8-bea1-95158f76b513.png)'
  prefs: []
  type: TYPE_IMG
- en: Based on the results, the late summer months of 2017 were the warmest, though
    not by a huge margin.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using a geometry to filter the rasters in the prism table, only a small set
    of rasters needed clipping with the geometry and unionizing to compute the mean.
    This maximized the query performance, and more importantly, provided the answer
    to our question.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between rasters and geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we used the geometries to filter and clip rasters only to
    the areas of interest. The `ST_Clip()` and `ST_Intersects()` functions implicitly
    converted the geometry before relating it to the raster.
  prefs: []
  type: TYPE_NORMAL
- en: PostGIS provides several functions for converting rasters to geometries. Depending
    on the function, a pixel can be returned as an area or a point.
  prefs: []
  type: TYPE_NORMAL
- en: PostGIS provides one function for converting geometries to rasters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will convert rasters to geometries, and geometries to rasters.
    We will use the `ST_DumpAsPolygons()` and `ST_PixelsAsPolygons()` functions to
    convert rasters to geometries. We will then convert geometries to rasters using
    `ST_AsRaster()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s adapt part of the query used in the last recipe to find out the average
    minimum temperature in San Francisco. We replace `ST_SummaryStats()` with `ST_DumpAsPolygons()`,
    and then return the geometries as `WKT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b3a693b-b340-4c5e-99d7-9ea38b7e0ae3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, replace the `ST_DumpAsPolygons()` function with `ST_PixelsAsPolyons()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee245520-e737-4ab3-be13-c0a35bfc7a7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, the query results have been trimmed. What is important is the number
    of rows returned. `ST_PixelsAsPolygons()` returns significantly more geometries
    than `ST_DumpAsPolygons()`. This is due to the different mechanism used in each
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following images show the difference between `ST_DumpAsPolygons()` and
    `ST_PixelsAsPolygons()`. The `ST_DumpAsPolygons()` function only dumps pixels
    with a value and unites these pixels with the same value. The `ST_PixelsAsPolygons()`
    function does not merge pixels and dumps all of them, as shown in the following
    diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01d80a68-2208-47ea-9e9d-60b7751d96f6.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ST_PixelsAsPolygons()` function returns one geometry for each pixel. If
    there are 100 pixels, there will be 100 geometries. Each geometry of `ST_DumpAsPolygons()`
    is the union of all of the pixels in an area with the same value. If there are
    100 pixels, there may be up to 100 geometries.
  prefs: []
  type: TYPE_NORMAL
- en: There is one other significant difference between `ST_PixelAsPolygons()` and
    `ST_DumpAsPolygons()`. Unlike `ST_DumpAsPolygons()`, `ST_PixelAsPolygons()` returns
    a geometry for pixels with the `NODATA` value, and has an empty value for the
    `val` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert a geometry to a raster with `ST_AsRaster()`. We insert `ST_AsRaster()`
    to return a raster with a pixel size of 100 by `-100` meters containing four bands
    of the pixel type `8BUI`. Each of these bands will have a pixel `NODATA` value
    of `0`, and a specific pixel value (`29`, `194`, `178`, and `255` for each band
    respectively). The units for the pixel size are determined by the geometry''s
    projection, which is also the projection of the created raster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we visualize the generated raster of San Francisco''s boundaries and overlay
    the source geometry, we get the following result, which is a zoomed-in view of
    the San Francisco boundary''s geometry converted to a raster with `ST_AsRaster()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c03dfb9-4e3b-4402-83e2-76bdf153ec9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Though it is great that the geometry is now a raster, relating the generated
    raster to other rasters requires additional processing. This is because the generated
    raster and the other raster will most likely not be aligned. If the two rasters
    are not aligned, most PostGIS raster functions do not work. The following figure
    shows two non-aligned rasters (simplified to pixel grids):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f351f242-0287-46de-a31f-2c7265bb24c6.png)'
  prefs: []
  type: TYPE_IMG
- en: The pixel grids of Raster 1 and Raster 2 are not aligned. If the rasters are
    aligned, the edges of one grid's cell will be on top of one of the other grid's
    cell's edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a geometry needs to be converted to a raster so as to relate to an existing
    raster, use that existing raster as a reference when calling `ST_AsRaster()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding query, we use the raster tile at `rid = 1` as our reference
    raster. The `ST_AsRaster()` function uses the reference raster's metadata to create
    the geometry's raster. If the geometry and reference raster have different SRIDs,
    the geometry is transformed to the same SRID before creating the raster.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we converted rasters to geometries. We also created new rasters
    from geometries. The ability to convert between rasters and geometries allows
    the use of functions that would otherwise not be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Processing and loading rasters with GDAL VRT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though PostGIS has plenty of functions for working with rasters, it is sometimes
    more convenient and more efficient to work on the source rasters before importing
    them into the database. One of the times when working with rasters outside the
    database is more efficient is when the raster contains subdatasets, typically
    found in HDF4, HDF5, and NetCDF files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will preprocess a MODIS raster with the **GDAL VRT** format
    to filter and rearrange the subdatasets. Internally, a VRT file is comprised of
    XML tags. This means we can create a VRT file with any text editor. But since
    creating a VRT file manually can be tedious, we will use the `gdalbuildvrt` utility.
  prefs: []
  type: TYPE_NORMAL
- en: The MODIS raster we use is provided by NASA, and is available in the source
    package.
  prefs: []
  type: TYPE_NORMAL
- en: You will need GDAL built with HDF4 support to continue with this recipe, as
    MODIS rasters are usually in the HDF4-EOS format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the MODIS raster used in this recipe and the
    next two recipes. In the following image, we see parts of California, Nevada,
    Arizona, and Baja California:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7362496-dfd3-48f7-ba11-cd620533c4a3.png)'
  prefs: []
  type: TYPE_IMG
- en: To allow PostGIS to properly support MODIS rasters, we will also need to add
    the MODIS Sinusoidal projection to the `spatial_ref_sys` table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the command line, navigate to the `MODIS` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MODIS` directory, there should be several files. One of these files
    has the name `srs.sql` and contains the `INSERT` statement needed for the MODIS
    Sinusoidal projection. Run the `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The main file has the extension HDF. Let''s check the metadata of that HDF
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, `gdalinfo` outputs a lot of information. We are looking for the list
    of subdatasets found in the `Subdatasets` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/87853995-72fa-4d08-be9d-cda58f44b7fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each subdataset is one variable of the `MODIS` raster included in the source
    code for this chapter. For our purposes, we only need the first four subdatasets,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subdataset 1: 620 - 670 nm (red)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subdataset 2: 841 - 876 nm (near infrared or NIR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subdataset 3: 459 - 479 nm (blue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subdataset 4: 545 - 565 nm (green)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VRT format allows us to select the subdatasets to be included in the VRT
    raster as well as change the order of the subdatasets. We want to rearrange the
    subdatasets so that they are in the RGB order.
  prefs: []
  type: TYPE_NORMAL
- en: Let's call `gdalbuildvrt` to create a VRT file for our MODIS raster. Do not
    run the following!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We really hope you did not run the preceding code. The command does work but
    is too long and cumbersome. It would be better if we can pass a file indicating
    the subdatasets to include and their order in the VRT. Thankfully, `gdalbuildvrt`
    provides such an option with the `-input_file_list` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the MODIS directory, the `modis.txt` file can be passed to `gdalbuildvrt`
    with the `-input_file_list` flag. Each line of the `modis.txt` file is the name
    of a subdataset. The order of the subdatasets in the text file dictates the placement
    of each subdataset in the VRT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, call `gdalbuildvrt` with `modis.txt` in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to inspect the generated `modis.vrt` VRT file in your favorite text
    editor. Since the contents of the VRT file are just XML tags, it is easy to make
    additions, changes, and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do one last thing before importing our processed MODIS raster into
    PostGIS. We will convert the VRT file to a GeoTIFF file with the `gdal_translate`
    utility, because not all applications have built-in support for HDF4, HDF5, NetCDF,
    or VRT, and the superior portability of GeoTIFF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, import `modis.tif` with `raster2pgsql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `raster2pgsql` supports a long list of input formats. You can call the command
    with the option -G to see the complete list.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe was all about processing a MODIS raster into a form suitable for
    use in PostGIS. We used the `gdalbuildvrt` utility to create our VRT. As a bonus,
    we used `gdal_translate` to convert between raster formats; in this case, from
    VRT to GeoTIFF.
  prefs: []
  type: TYPE_NORMAL
- en: If you're feeling particularly adventurous, try using `gdalbuildvrt` to create
    a VRT of the 12 PRISM rasters with each raster as a separate band.
  prefs: []
  type: TYPE_NORMAL
- en: Warping and resampling rasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we processed a MODIS raster to extract only those subdatasets
    that are of interest, in a more suitable order. Once done with the extraction,
    we imported the MODIS raster into its own table.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we make use of the warping capabilities provided in PostGIS. This ranges
    from simply transforming the MODIS raster to a more suitable projection, to creating
    an overview by resampling the pixel size.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use several PostGIS warping functions, specifically `ST_Transform()`
    and `ST_Rescale()`. The `ST_Transform()` function reprojects a raster to a new
    spatial reference system (for example, from WGS84 to NAD83). The `ST_Rescale()`
    function shrinks or grows the pixel size of a raster.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we will do is transform our raster, since the MODIS rasters
    have their own unique spatial-reference system. We will convert the raster from
    **MODIS Sinusoidal projection** to **US National Atlas Equal Area** (**SRID 2163**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we transform the raster, we will clip the MODIS raster with our San
    Francisco boundaries geometry. By clipping our raster before transformation, the
    operation takes less time than it does to transform and then clip the raster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the clipped MODIS raster with the San Francisco boundaries
    on top for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5eeb5b42-d394-4eb1-9148-c14b19dd11c2.png)'
  prefs: []
  type: TYPE_IMG
- en: When we call `ST_Transform()` on the MODIS raster, we only pass the destination
    `SRID 2163`. We could specify other parameters, such as the **resampling algorithm**
    and **error tolerance**. The default resampling algorithm and error tolerance
    are set to `NearestNeighbor` and `0.125`. Using a different algorithm and/or lowering
    the error tolerance may improve the quality of the resampled raster at the cost
    of more processing time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s transform the MODIS raster again, this time specifying the resampling
    algorithm and error tolerance as `Cubic` and `0.05`, respectively. We also indicate
    that the transformed raster must be aligned to a reference raster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the prior queries where we transform the MODIS raster, let''s create
    an **overview**. An overview is a lower-resolution version of the source raster.
    If you are familiar with pyramids, an overview is level one of a pyramid, while
    the source raster is the base level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The overview is 25% of the resolution of the original MODIS raster. This means
    four times the scale, and one quarter the width and height. To prevent hardcoding
    the desired scale X and scale Y, we use the MODIS raster''s scale X and scale
    Y returned by `ST_Metadata()`. As you can see in the following image, the overview
    has a coarser resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2081166c-bb2d-4bab-afba-760afffe7893.png)'
  prefs: []
  type: TYPE_IMG
- en: The rescaled raster is more pixelated due to the reduction of resolution.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using some of PostGIS's resampling capabilities, we projected the MODIS raster
    to a different spatial reference with `ST_Transform()` as well as controlled the
    quality of the projected raster. We also created an overview with `ST_Rescale()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using these functions and other PostGIS resampling functions, you should be
    able to manipulate all the rasters.
  prefs: []
  type: TYPE_NORMAL
- en: Performing advanced map-algebra operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a prior recipe, we used the expression-based map-algebra function `ST_MapAlgebra()`
    to convert the PRISM pixel values to their true values. The expression-based `ST_MapAlgebra()`
    method is easy to use, but limited to operating on at most two raster bands. This
    restricts the `ST_MapAlgebra()` function's usefulness for processes that require
    more than two input raster bands, such as the **Normalized Difference Vegetation
    Index** (**NDVI**) and the **Enhanced Vegetation Index** (**EVI**).
  prefs: []
  type: TYPE_NORMAL
- en: There is a variant of `ST_MapAlgebra()` designed to support an unlimited number
    of input raster bands. Instead of taking an expression, this `ST_MapAlgebra()`
    variant requires a callback function. This callback function is run for each set
    of input pixel values, and returns either a new pixel value, or `NULL` for the
    output pixel. Additionally, this variant of `ST_MapAlgebra()` permits operations
    on neighborhoods (sets of pixels around a center pixel).
  prefs: []
  type: TYPE_NORMAL
- en: PostGIS comes with a set of ready-to-use `ST_MapAlgebra()` callback functions.
    All of these functions are intended for neighborhood calculations, such as computing
    the average value of a neighborhood, or interpolating empty pixel values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the MODIS raster to compute the EVI. EVI is a three-band operation
    consisting of the red, blue, and near-infrared bands. To do an `ST_MapAlgebra()`
    operation on three bands, PostGIS 2.1 or a higher version is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use `ST_MapAlgebra()` on more than two bands, we must use the callback function
    variant. This means we need to create a callback function. Callback functions
    can be written in any PostgreSQL PL language, such as PL/pgSQL or PL/R. Our callback
    functions are all written in PL/pgSQL, as this language is always included with
    a base PostgreSQL installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our callback function uses the following equation to compute the three-band
    EVI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/192bfa71-ccfe-4947-be4b-38379be780d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code implements the MODIS EVI function in SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you can't create the function, you probably do not have the necessary privileges
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several characteristics required for all of the callback functions.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All `ST_MapAlgebra()` callback functions must have three input parameters,
    namely, `double precision[]`, `integer[]`, and `variadic text[]`. The `value`
    parameter is a 3D array where the first dimension denotes the raster index, the
    second dimension the Y axis, and the third dimension the X axis. The position
    parameter is an array of two dimensions, with the first dimension indicating the
    raster index, and the second dimension consisting of the X, Y coordinates of the
    center pixel. The last parameter, `userargs`, is a 1D array of zero or more elements
    containing values that a user wants to pass to the `callback` function. If visualized,
    the parameters look like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: All `ST_MapAlgebra()` callback functions must return a double-precision value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the callback functions are not correctly structured, the `ST_MapAlgebra()`
    function will fail or behave incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we convert the user arguments to their correct datatypes,
    rescale the pixel values, check that no pixel values are `NULL` (arithmetic operations
    with `NULL` values always result in `NULL`), compute the numerator and denominator
    components of `EVI`, check that the denominator is not zero (prevent division
    by zero), and then finish the computation of `EVI`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we call our callback function, `modis_evi(),` with `ST_MapAlgebra()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In our call to `ST_MapAlgebra()`, there are three criteria to take note of,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The signature for the `modis_evi()` callback function. When passing the callback
    function to `ST_MapAlgebra()`, it must be written as a string containing the function
    name and the input-parameter types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last four function parameters (`'1.'`, `'6.'`, `'7.5'`, `'2.5'`) are user-defined
    arguments that are passed for processing by the `callback` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the band numbers affects the order of the pixel values passed to
    the callback function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following images show the MODIS raster before and after running the EVI
    operation. The EVI raster has a pale white to dark green colormap applied for
    highlighting areas of high vegetation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4eb54f5a-f324-4005-a135-6db27f6c12b1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are unable to run the standard EVI operation, or want more practice,
    we will now compute a two-band EVI. We will use the `ST_MapAlgebraFct()` function.
    Please note that `ST_MapAlgebraFct()` is deprecated in PostGIS 2.1, and may be
    removed in the future versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the two-band EVI, we will use the following `callback` function. The two-band
    EVI equation is computed with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `ST_MapAlgebra()` callback functions, `ST_MapAlgebraFct()` requires callback
    functions to be structured in a specific manner. There is a difference between
    the callback function for `ST_MapAlgebraFct()` and the prior one for `ST_MapAlgebra()`.
    This function has two simple pixel-value parameters instead of an array for all
    pixel values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Besides the difference in function names, `ST_MapAlgebraFct()` is called differently
    than `ST_MapAlgebra()`. The same raster is passed to `ST_MapAlgebraFct()` twice.
    The other difference is that there is one less user-defined argument being passed
    to the `callback` function, as the two-band EVI has one less coefficient.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We demonstrated some of the advanced uses of PostGIS's map-algebra functions
    by computing the three-band and two-band EVIs from our MODIS raster. This was
    achieved using `ST_MapAlgebra()` and `ST_MapAlgebraFct()`, respectively. With
    some planning, PostGIS's map-algebra functions can be applied to other uses, such
    as edge detection and contrast stretching.
  prefs: []
  type: TYPE_NORMAL
- en: 'For additional practice, write your own callback function to generate an *NDVI*
    raster from the MODIS raster. The equation for NDVI is: *NDVI = ((IR - R)/(IR
    + R)) *where *IR* is the pixel value on the infrared band, and *R* is the pixel
    value on the red band. This index generates values between -1.0 and 1.0, in which
    negative values usually represent non-green elements (water, snow, clouds), and
    values close to zero represent rocks and deserted land.'
  prefs: []
  type: TYPE_NORMAL
- en: Executing DEM operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostGIS comes with several functions for use on digital elevation model (DEM)
    rasters to solve terrain-related problems. Though these problems have historically
    been in the hydrology domain, they can now be found elsewhere; for example, finding
    the most fuel-efficient route from point A to point B or determining the best
    location on a roof for a solar panel. PostGIS 2.0 introduced `ST_Slope()`, `ST_Aspect()`,
    and `ST_HillShade()` while PostGIS 2.1 added the new functions `ST_TRI()`, `ST_TPI()`,
    and `ST_Roughness()`, and new variants of existing elevation functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the SRTM raster, loaded as 100 x 100 tiles, in this chapter's first
    recipe. With it, we will generate slope and hillshade rasters using San Francisco
    as our area of interest.
  prefs: []
  type: TYPE_NORMAL
- en: The next two queries in the How to do it section use variants of `ST_Slope()`
    and `ST_HillShade()` that are only available in PostGIS 2.1 or higher versions.
    The new variants permit the specification of a custom extent to constrain the
    processing area of the input raster.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s generate a slope raster from a subset of our SRTM raster tiles using
    `ST_Slope()`. A slope raster computes the rate of elevation change from one pixel
    to a neighboring pixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: All spatial objects in this query are projected to **California Albers** (**SRID
    3310**), a projection with units in meters. This projection eases the use of `ST_DWithin()`
    to broaden our area of interest to include the tiles within 1,000 meters of San
    Francisco's boundaries, which improves the computed slope values for the pixels
    at the edges of the San Francisco boundaries. We also use a rasterized version
    of our San Francisco boundaries as the custom extent for restricting the computed
    area. After running `ST_Slope()`, we clip the slope raster just to San Francisco.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse the `ST_Slope()` query and substitute `ST_HillShade()` for `ST_Slope()`
    to create a hillshade raster, showing how the sun would illuminate the terrain
    of the SRTM raster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `ST_HillShade()` is a drop-in replacement for `ST_Slope()` because
    we do not specify any special input parameters for either function. If we need
    to specify additional arguments for `ST_Slope()` or `ST_HillShade()`, all changes
    are confined to just one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following images show the SRTM raster before and after processing it with
    `ST_Slope()` and `ST_HillShade()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/593ad00d-446f-4464-b5a6-2d1efe0d96ea.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the screenshot, the slope and hillshade rasters help us better
    understand the terrain of San Francisco.
  prefs: []
  type: TYPE_NORMAL
- en: 'If PostGIS 2.0 is available, we can still use 2.0''s `ST_Slope()` and `ST_HillShade()`
    to create slope and hillshade rasters. But there are several differences you need
    to be aware of, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ST_Slope()` and `ST_Aspect()` return a raster with values in radians instead
    of degrees'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some input parameters of `ST_HillShade()` are expressed in radians instead of
    degrees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The computed raster from `ST_Slope()`, `ST_Aspect()`, or `ST_HillShade()` has
    an empty 1-pixel border on all four sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can adapt our `ST_Slope()` query from the beginning of this recipe by removing
    the creation and application of the custom extent. Since the custom extent constrained
    the computation to just a specific area, the inability to specify such a constraint
    means PostGIS 2.0''s `ST_Slope()` will perform slower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DEM functions in PostGIS allowed us to quickly analyze our SRTM raster.
    In the basic use cases, we were able to swap one function for another without
    any issues.
  prefs: []
  type: TYPE_NORMAL
- en: What is impressive about these DEM functions is that they are all wrappers around
    `ST_MapAlgebra()`. The power of `ST_MapAlgebra()` is in its adaptability to different
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing and visualizing rasters through SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml), *Working with Vector
    Data – Advanced Recipes*, we used `gdal_translate` to export PostGIS rasters to
    a file. This provides a method for transferring files from one user to another,
    or from one location to another. The only problem with this method is that you
    may not have access to the `gdal_translate` utility.
  prefs: []
  type: TYPE_NORMAL
- en: A different but equally functional approach is to use the `ST_AsGDALRaster()`
    family of functions available in PostGIS. In addition to `ST_AsGDALRaster()`,
    PostGIS provides `ST_AsTIFF()`, `ST_AsPNG()`, and `ST_AsJPEG()` to support the
    most common raster file formats.
  prefs: []
  type: TYPE_NORMAL
- en: To easily visualize raster files without the need for a GIS application, PostGIS
    2.1 and later versions provide `ST_ColorMap()`. This function applies a built-in
    or user-specified color palette to a raster, that upon exporting with `ST_AsGDALRaster()`,
    can be viewed with any image viewer, such as a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use `ST_AsTIFF()` and `ST_AsPNG()`to export rasters
    to GeoTIFF and PNG file formats, respectively. We will also apply the `ST_ColorMap()`
    so that we can see them in any image viewer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable GDAL drivers in PostGIS, you should run the following command in
    `pgAdmin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The following queries can be run in a standard SQL client, such as **psql**
    or **pgAdminIII**; however, we can't use the returned output because the output
    has escaped, and these clients do not undo the escaping. Applications with lower-level
    API functions can unescape the query output. Examples of this would be a PHP script,
    a pass-a-record element to `pg_unescape_bytea()`, or a Python script using Psycopg2's
    implicit decoding while fetching a record. A sample PHP script (`save_raster_to_file.php`)
    can be found in this chapter's `data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us say that a colleague asks for the monthly minimum temperature data for
    San Francisco during the summer months as a single raster file. This entails restricting
    our PRISM rasters to June, July, and August, clipping each monthly raster to San
    Francisco''s boundaries, creating one raster with each monthly raster as a band,
    and then outputting the combined raster to a portable raster format. We will convert
    the combined raster to the GeoTIFF format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: To filter our PRISM rasters, we use `ST_Intersects()` to keep only those raster
    tiles that spatially intersect San Francisco's boundaries. We also remove all
    rasters whose relevant month is not June, July, or August. We then use `ST_AddBand()`
    to create a new raster with each summer month's new raster band. Finally, we pass
    the combined raster to `ST_AsTIFF()` to generate a GeoTIFF.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you output the returned value from `ST_AsTIFF()` to a file, run `gdalinfo`
    on that file. The `gdalinfo` output shows that the GeoTIFF file has three bands,
    and the coordinate system of SRID 4322:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the GeoTIFF raster is that we generally can't view it in a
    standard image viewer. If we use `ST_AsPNG()` or `ST_AsJPEG()`, the image generated
    is much more readily viewable. But PNG and JPEG images are limited by the supported
    pixel types 8BUI and 16BUI (PNG only). Both formats are also limited to, at the
    most, three bands (four, if there is an alpha band).
  prefs: []
  type: TYPE_NORMAL
- en: To help get around various file format limitations, we can use `ST_MapAlgebra()`,
    `ST_Reclass()` , or `ST_ColorMap()`, for this recipe. The `ST_ColorMap()` function
    converts a raster band of any pixel type to a set of up to four 8BUI bands. This
    facilitates creating a grayscale, RGB, or RGBA image that is then passed to `ST_AsPNG()`,
    or `ST_AsJPEG()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking our query for computing a slope raster of San Francisco from our SRTM
    raster in a prior recipe, we can apply one of `ST_ColorMap()` function''s built-in
    colormaps, and then pass the resulting raster to `ST_AsPNG()` to create a PNG
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The bluered colormap sets the minimum, median, and maximum pixel values to dark
    blue, pale white, and bright red, respectively. Pixel values between the minimum,
    median, and maximum values are assigned colors that are linearly interpolated
    from the minimum to median or median to maximum range. The resulting image readily
    shows where the steepest slopes in San Francisco are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a PNG image generated by applying the bluered colormap with
    `ST_ColorMap()` and `ST_AsPNG()`. The pixels in red represent the steepest slopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1026d40c-71fb-443c-aa7e-30b278a7f344.png)'
  prefs: []
  type: TYPE_IMG
- en: In our use of `ST_AsTIFF()` and `ST_AsPNG()`, we passed the raster to be converted
    as the sole argument. Both of these functions have additional parameters to customize
    the output TIFF or PNG file. These additional parameters include various compression
    and data organization settings.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `ST_AsTIFF()` and `ST_AsPNG()`, we exported rasters from PostGIS to GeoTIFF
    and PNG. The `ST_ColorMap()` function helped generate images that can be opened
    in any image viewer. If we needed to export these images to a different format
    supported by GDAL, we would use `ST_AsGDALRaster()`.
  prefs: []
  type: TYPE_NORMAL
