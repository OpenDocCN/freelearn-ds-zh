- en: Working with Raster Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理和加载栅格数据
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Getting and loading rasters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和加载栅格数据
- en: Working with basic raster information and analysis
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和基本分析栅格信息
- en: Performing simple map-algebra operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行简单的地图代数运算
- en: Combining geometries with rasters for analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将几何形状与栅格数据结合进行分析
- en: Converting between rasters and geometries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栅格和几何形状之间进行转换
- en: Processing and loading rasters with GDAL VRT
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GDAL VRT处理和加载栅格
- en: Warping and resampling rasters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换和重采样栅格
- en: Performing advanced map-algebra operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行高级地图代数运算
- en: Executing DEM operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行DEM操作
- en: Sharing and visualizing rasters through SQL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SQL共享和可视化栅格
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, the recipes are presented in a step-by-step workflow that you
    may apply while working with a raster. This entails loading the raster, getting
    a basic understanding of the raster, processing and analyzing it, and delivering
    it to consumers. We intentionally add some detours to the workflow to reflect
    the reality that the raster, in its original form, may be confusing and not suitable
    for analysis. At the end of this chapter, you should be able to take the lessons
    learned from the recipes and confidently apply them to solve your raster problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以逐步工作流程的形式介绍配方，您可以在处理栅格时应用这些配方。这包括加载栅格，获取栅格的基本理解，处理和分析它，并将其交付给消费者。我们故意在工作流程中添加一些绕道，以反映现实情况，即原始的栅格可能令人困惑且不适合分析。在本章结束时，您应该能够将所学到的知识应用到解决您的栅格问题中。
- en: 'Before going further, we should describe what a raster is, and what a raster
    is used for. At the simplest level, a raster is a photo or image with information
    describing where to place the raster on the Earth''s surface. A photograph typically
    has three sets of values: one set for each primary color (red, green, and blue).
    A raster also has sets of values, often more than those found in a photograph.
    Each set of values is known as a **band**. So, a photograph typically has three
    bands, while a raster has at least one band. Like digital photographs, rasters
    come in a variety of file formats. Common raster formats you may come across include
    PNG, JPEG, GeoTIFF, HDF5, and NetCDF. Since rasters can have many bands and even
    more values, they can be used to store large quantities of data in an efficient
    manner. Due to their efficiency, rasters are used for satellite and aerial sensors
    and modeled surfaces, such as weather forecasts.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该描述什么是栅格，以及栅格的用途。在最简单的层面上，栅格是带有描述如何在地球表面上放置栅格的信息的照片或图像。照片通常有三组值：每组对应于一种主要颜色（红色、绿色和蓝色）。栅格也有值集，通常比照片中的值集更多。每组值被称为**波段**。因此，照片通常有三个波段，而栅格至少有一个波段。像数字照片一样，栅格有多种文件格式。您可能会遇到的常见栅格格式包括PNG、JPEG、GeoTIFF、HDF5和NetCDF。由于栅格可以有许多波段和更多的值，它们可以以高效的方式存储大量数据。由于它们的效率，栅格被用于卫星和航空传感器以及建模表面，如天气预报。
- en: 'There are a few keywords used in this chapter and in the PostGIS ecosystem
    that need to be defined:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和PostGIS生态系统中使用的一些关键字需要定义：
- en: '**Raster**: This is the PostGIS data type for storing raster files in PostgreSQL.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栅格**：这是PostGIS用于在PostgreSQL中存储栅格文件的数据类型。'
- en: '**Tile**: This is a small chunk of the original raster file to be stored in
    one column of a table''s row. Each tile has its own set of spatial information,
    and thus is independent of all the other tiles in the same column of the same
    table, even if the other tiles are from the same original raster file.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瓦片**：这是原始栅格文件中的一小块，将被存储在表格行的某一列中。每个瓦片都有自己的空间信息集，因此它独立于同一表格同一列中的所有其他瓦片，即使其他瓦片来自相同的原始栅格文件。'
- en: '**Coverage**: This consists of all the tiles of a single raster column from
    one table.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖**：这由单个栅格列中的一个表格的所有瓦片组成。'
- en: 'We make heavy use of GDAL in this chapter. GDAL is generally considered the
    de facto Swiss Army knife for working with rasters. GDAL is not a single application,
    but is a raster-abstraction library with many useful utilities. Through GDAL,
    you can get the metadata of a raster, convert that raster to a different format,
    and warp that raster among many other capabilities. For our needs in this chapter,
    we will use three GDAL utilities: `gdalinfo`, `gdalbuildvrt`, and `gdal_translate`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们大量使用 GDAL。GDAL 通常被认为是处理栅格的瑞士军刀。GDAL 不是一个单一的应用程序，而是一个具有许多有用工具的栅格抽象库。通过
    GDAL，您可以获取栅格的元数据，将该栅格转换为不同的格式，并在许多其他功能中扭曲该栅格。对于本章的需求，我们将使用三个 GDAL 工具：`gdalinfo`、`gdalbuildvrt`
    和 `gdal_translate`。
- en: Getting and loading rasters
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和加载栅格
- en: In this recipe, we load most of the rasters used in this chapter. These rasters
    are examples of satellite imagery and model-generated surfaces, two of the most
    common raster sources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将加载本章中使用的绝大多数栅格。这些栅格是卫星图像和模型生成的表面的示例，这两种是最常见的栅格来源。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If you have not done so already, create a directory and copy the chapter''s
    datasets; for Windows, use the following commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请创建一个目录并复制章节的数据集；对于 Windows，请使用以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For Linux or macOS, go into the folder you wish to use and run the following
    commands, where `/path/to/book_dataset/chap05` is the path where you originally
    stored the book source code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 或 macOS，进入您希望使用的文件夹，并运行以下命令，其中 `/path/to/book_dataset/chap05` 是您最初存储书籍源代码的路径：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should also create a new schema for this chapter in the database:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该在数据库中为这一章创建一个新的模式：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will start with the PRISM average monthly minimum-temperature raster dataset
    for 2016 with coverage for the continental United States. The raster is provided
    by the PRISM Climate Group at Oregon State University, with additional rasters
    available at [http://www.prism.oregonstate.edu/mtd/](http://www.prism.oregonstate.edu/mtd/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 2016 年美国大陆的 PRISM 平均月最低温度栅格数据集开始。该栅格由俄勒冈州立大学的 PRISM 气候组提供，更多栅格可在 [http://www.prism.oregonstate.edu/mtd/](http://www.prism.oregonstate.edu/mtd/)
    获取。
- en: 'On the command line, navigate to the `PRISM` directory as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，按照以下方式导航到 `PRISM` 目录：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let us spot check one of the PRISM rasters with the GDAL utility `gdalinfo`.
    It is always a good practice to inspect at least one raster to get an idea of
    the metadata and ensure that the raster does not have any issues. This can be
    done using the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GDAL 工具 `gdalinfo` 检查其中一个 PRISM 栅格。检查至少一个栅格以了解元数据并确保栅格没有问题总是一个好习惯。可以使用以下命令完成：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `gdalinfo` output is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdalinfo` 的输出如下：'
- en: '![](img/3097d298-ff89-49c1-be46-01d1b67344c6.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3097d298-ff89-49c1-be46-01d1b67344c6.png)'
- en: The `gdalinfo` output reveals that the raster has no issues, as evidenced by
    the `Corner Coordinates`, `Pixel Size`, `Band`, and `Coordinate System` being
    unempty.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdalinfo` 的输出表明栅格没有问题，正如 `Corner Coordinates`、`Pixel Size`、`Band` 和 `Coordinate
    System` 不为空所证明的。'
- en: 'Looking through the metadata, we find that the metadata about the spatial reference
    system indicates that raster uses the NAD83 coordinate system. We can double-check
    this by searching for the details of NAD83 in the `spatial_ref_sys` table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看元数据，我们发现关于空间参考系统的元数据表明栅格使用 NAD83 坐标系统。我们可以通过在 `spatial_ref_sys` 表中搜索 NAD83
    的详细信息来双重检查这一点：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Comparing the text of `srtext` to the PRISM raster's metadata spatial attributes,
    we find that the raster is in EPSG (SRID 4269).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `srtext` 的文本与 PRISM 栅格的元数据空间属性进行比较，我们发现栅格位于 EPSG (SRID 4269)。
- en: 'You can load the PRISM rasters into the `chp05.prism` table with `raster2pgsql`,
    which will import the raster files to the database in a similar manner as the
    `shp2pgsql` command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `raster2pgsql` 将 PRISM 栅格数据加载到 `chp05.prism` 表中，该命令将以与 `shp2pgsql` 命令类似的方式将栅格文件导入数据库：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `raster2pgsql` command is called with the following flags:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`raster2pgsql` 命令使用以下标志：'
- en: '`-s`: This flag assigns SRID`4269` to the imported rasters.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`：此标志将 SRID`4269` 分配给导入的栅格。'
- en: '`-t`: This flag denotes the tile size. It chunks the imported rasters into
    smaller and more manageable pieces; each record added to the table will be, at
    most, 100 x 100 pixels.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`：此标志表示瓦片大小。它将导入的栅格分成更小、更易于管理的块；添加到表中的每个记录最多为 100 x 100 像素。'
- en: '`-F`: This flag adds a column to the table and fills it with the raster''s
    filename.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-F`：此标志向表中添加一个列，并用栅格的文件名填充它。'
- en: '`-I`: This flag creates a GIST spatial index on the table''s raster column.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-I`：此标志在表的栅格列上创建一个GIST空间索引。'
- en: '`-C`: This flag applies the standard set of constraints on the table. The standard
    set of constraints includes checks for dimension, scale, skew, upper-left coordinate,
    and SRID.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-C`：此标志在表上应用标准约束集。标准约束集包括对维度、比例、倾斜、左上角坐标和SRID的检查。'
- en: '`-Y`: This flag instructs `raster2pgsql` to use `COPY` statements instead of
    `INSERT` statements. `COPY` is typically faster than `INSERT`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Y`：此标志指示`raster2pgsql`使用`COPY`语句而不是`INSERT`语句。`COPY`通常比`INSERT`快。'
- en: 'There is a reason why we passed `-F` to `raster2pgsql`. If you look at the
    filenames of the PRISM rasters, you''ll note the year and month. So, let''s convert
    the value in the `filename` column to a date in the table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以传递`-F`给`raster2pgsql`，是有原因的。如果您查看PRISM栅格的文件名，您会注意到年份和月份。因此，让我们将`filename`列中的值转换为表中的日期：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is all that needs to be done with the `PRISM` rasters for now.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对于`PRISM`栅格需要做的就这些。
- en: Now, let's import a **Shuttle Radar Topography Mission** (**SRTM**) raster.
    The SRTM raster is from the SRTM that was conducted by the NASA Jet Propulsion
    Laboratory in February, 2000\. This raster and others like it are available at: [http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/](http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们导入一个**航天飞机雷达地形测绘任务**（**SRTM**）栅格。这个SRTM栅格是由美国国家航空航天局喷气推进实验室在2000年2月进行的。这个栅格和其他类似的栅格可以在以下网址找到：[http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/](http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/).
- en: 'Change the current directory to the `SRTM` directory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前目录更改为`SRTM`目录：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Make sure you spot check the SRTM raster with `gdalinfo` to ensure that it
    is valid and has a value for `Coordinate System`. Once checked, import the SRTM
    raster into the `chp05.srtm` table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您使用`gdalinfo`检查SRTM栅格，以确保它是有效的并且有`坐标系统`的值。一旦检查完毕，将SRTM栅格导入到`chp05.srtm`表中：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the same `raster2pgsql` flags for the SRTM raster as those for the PRISM
    rasters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为SRTM栅格和PRISM栅格使用相同的`raster2pgsql`标志。
- en: 'We also need to import a `shapefile` of San Francisco provided by the City
    and County of San Francisco, available with the book''s dataset files, or the
    one found on the following link, after exporting the data to a shapefile:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导入由旧金山和旧金山市提供的`shapefile`，这些文件与书中的数据集文件一起提供，或者可以从以下链接找到，在将数据导出为shapefile之后：
- en: '[https://data.sfgov.org/Geographic-Locations-and-Boundaries/SF-Shoreline-and-Islands/rgcx-5tix](https://data.sfgov.org/Geographic-Locations-and-Boundaries/SF-Shoreline-and-Islands/rgcx-5tix)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://data.sfgov.org/Geographic-Locations-and-Boundaries/SF-Shoreline-and-Islands/rgcx-5tix](https://data.sfgov.org/Geographic-Locations-and-Boundaries/SF-Shoreline-and-Islands/rgcx-5tix)'
- en: '![](img/8fc8441e-bfdc-43c7-a64f-bc6aed696736.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fc8441e-bfdc-43c7-a64f-bc6aed696736.png)'
- en: 'The San Francisco''s boundaries from the book''s files will be used in many
    of the follow-up recipes, and it must be loaded to the database as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的文件将用于后续的许多食谱，并且必须按照以下方式加载到数据库中：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we imported the required PRISM and SRTM rasters needed for the
    rest of the recipes. We also imported a `shapefile` containing San Francisco's
    boundaries to be used in the various raster analyses. Now, on to the fun!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们导入了后续食谱所需的PRISM和SRTM栅格，还导入了包含旧金山边界的`shapefile`，用于各种栅格分析。现在，让我们进入有趣的部分！
- en: Working with basic raster information and analysis
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理基本栅格信息和分析
- en: So far, we've checked and imported the PRISM and SRTM rasters into the `chp05`
    schema of the `postgis_cookbook` database. We will now proceed to work with the
    rasters within the database.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经检查并导入了PRISM和SRTM栅格到`postgis_cookbook`数据库的`chp05`模式中。现在，我们将继续在数据库中处理这些栅格。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we explore functions that provide insight into the raster attributes
    and characteristics found in the `postgis_cookbook` database. In doing so, we
    can see if what is found in the database matches the information provided by accessing `gdalinfo`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们探索了提供对`postgis_cookbook`数据库中栅格属性和特征洞察的函数。通过这样做，我们可以查看数据库中找到的内容是否与通过访问`gdalinfo`提供的信息相匹配。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: PostGIS includes the `raster_columns` view to provide a high-level summary of
    all the raster columns found in the database. This view is similar to the `geometry_columns`
    and `geography_columns` views in function and form.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS包括`raster_columns`视图，以提供数据库中所有栅格列的高级总结。这个视图在功能和形式上与`geometry_columns`和`geography_columns`视图类似。
- en: 'Let''s run the following SQL query in the `raster_columns` view to see what
    information is available in the `prism` table:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`raster_columns`视图中运行以下SQL查询，以查看`prism`表中可用的信息：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The SQL query returns a record similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SQL查询返回的记录类似于以下内容：
- en: '![](img/3b19975a-d332-498c-84f9-8fa9db10c094.png)![](img/48ea6133-ae9f-4066-b507-326d7e9ce775.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b19975a-d332-498c-84f9-8fa9db10c094.png)![](img/48ea6133-ae9f-4066-b507-326d7e9ce775.png)'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you look back at the `gdalinfo` output for one of the PRISM rasters, you'll
    see that the values for the scales (the pixel size) match. The flags passed to
    `raster2pgsql`, specifying tile size and `SRID`, worked.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下PRISM栅格之一的`gdalinfo`输出，你会看到尺度（像素大小）的值是一致的。传递给`raster2pgsql`的标志，指定瓦片大小和`SRID`，是有效的。
- en: 'Let''s see what the metadata of a single raster tile looks like. We will use
    the `ST_Metadata()` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看单个栅格瓦片的元数据是什么样的。我们将使用`ST_Metadata()`函数：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will look similar to the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '![](img/e1f006b3-060e-47b9-9897-9d0da65d15be.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1f006b3-060e-47b9-9897-9d0da65d15be.png)'
- en: 'Use `ST_BandMetadata()` to examine the first and only band of raster tiles
    at the record ID `54`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ST_BandMetadata()`来检查记录ID `54`的栅格瓦片的第一和唯一波段：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The results indicate that the band is of pixel type `32BF`, and has a `NODATA`
    value of `-9999`. The `NODATA` value is the value assigned to an empty pixel:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，该波段是像素类型`32BF`，并且具有`NODATA`值为`-9999`。`NODATA`值是分配给空像素的值：
- en: '![](img/4ae15d6a-9090-4723-884b-208b358b927d.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ae15d6a-9090-4723-884b-208b358b927d.png)'
- en: Now, to do something a bit more useful, run some basic statistic functions on
    this raster tile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了做一些更有用的操作，对这个栅格瓦片运行一些基本的统计函数。
- en: 'First, let''s compute the summary statistics (count, mean, standard deviation,
    min, and max) with `ST_SummaryStats() for an specific raster, in this case, number
    54`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`ST_SummaryStats()`计算特定栅格（在这种情况下，编号为54）的汇总统计（计数、平均值、标准差、最小值和最大值）：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/90003a6a-40f3-463f-ace0-879fa17846be.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90003a6a-40f3-463f-ace0-879fa17846be.png)'
- en: In the summary statistics, if the `count` indicates less than *10,000 (100²)*,
    it means that the raster is 10,000-count/100\. In this case, the raster tile is
    about 0% `NODATA`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇总统计中，如果`count`指示小于*10,000 (100²)*，则表示该栅格是10,000-count/100。在这种情况下，栅格瓦片大约是0%
    `NODATA`。
- en: 'Let''s see how the values of the raster tile are distributed with `ST_Histogram()`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`ST_Histogram()`来分布栅格瓦片的值：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output will look as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/ad639382-a20d-4612-93ff-afb2712f14e6.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad639382-a20d-4612-93ff-afb2712f14e6.png)'
- en: 'It looks like about 78% of all of the values are at or below `1370.50`. Another
    way to see how the pixel values are distributed is to use `ST_Quantile()`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来大约78%的所有值都在`1370.50`或以下。另一种查看像素值分布的方法是使用`ST_Quantile()`：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/3afabcee-98d7-4579-b881-74f51c6baa61.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3afabcee-98d7-4579-b881-74f51c6baa61.png)'
- en: 'Let''s see what the top 10 occurring values are in the raster tile with `ST_ValueCount()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`ST_ValueCount()`在栅格瓦片中出现的最频繁的10个值：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the code is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![](img/f4015129-1c61-447e-bdb1-ea3ef7ea20f1.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4015129-1c61-447e-bdb1-ea3ef7ea20f1.png)'
- en: 'The `ST_ValueCount` allows other combinations of parameters that will allow
    rounding up of the values in order to aggregate some of the results, but a previous
    subset of values to look for must be defined; for example, the following code
    will count the appearance of values `2`, `3`, `2.5`, `5.612999` and `4.176` rounded
    to the fifth decimal point `0.00001`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_ValueCount`允许其他参数组合，这将允许将值四舍五入以聚合一些结果，但必须定义要查找的前一个值子集；例如，以下代码将计算值`2`、`3`、`2.5`、`5.612999`和`4.176`四舍五入到第五位小数`0.00001`的出现次数：'
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The results show the number of elements that appear similar to the rounded-up
    values in the array. The two values borrowed from the results on the previous
    figure, confirm the counting:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了与数组中四舍五入值相似出现的元素数量。从上一个图例中借用的两个值，证实了计数：
- en: '![](img/2fbe1084-94b5-4ac2-bf6d-35715532211c.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fbe1084-94b5-4ac2-bf6d-35715532211c.png)'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first part of this recipe, we looked at the metadata of the `prism` raster
    table and a single raster tile. We focused on that single raster tile to run a
    variety of statistics. The statistics provided some idea of what the data looks
    like.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的第一部分，我们查看了`prism`栅格表和单个栅格瓦片的元数据。我们专注于单个栅格瓦片来运行各种统计。这些统计提供了一些关于数据外观的线索。
- en: We mentioned that the pixel values looked wrong when we looked at the output
    from `ST_SummaryStats()`. This same issue continued in the output from subsequent
    statistics functions. We also found that the values were in Celsius degrees. In
    the next recipe, we will recompute all the pixel values to their true values with
    a map-algebra operation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，当我们查看`ST_SummaryStats()`的输出时，像素值看起来是错误的。这个问题在后续的统计函数输出中也持续存在。我们还发现这些值是以摄氏度表示的。在下一个菜谱中，我们将使用地图代数操作重新计算所有像素值，使其成为它们的真实值。
- en: Performing simple map-algebra operations
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行简单的地图代数操作
- en: In the previous recipe, we saw that the values in the PRISM rasters did not
    look correct for temperature values. After looking at the PRISM metadata, we learned
    that the values were scaled by `100`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们看到了PRISM栅格中的值对于温度值看起来并不正确。在查看PRISM元数据后，我们了解到这些值被`100`倍缩放了。
- en: In this recipe, we will process the scaled values to get the true values. Doing
    this will prevent future end-user confusion, which is always a good thing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将处理缩放值以获取真实值。这样做将防止未来的最终用户混淆，这始终是一件好事。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: PostGIS provides two types of map-algebra functions, both of which return a
    new raster with one band. The type you use depends on the problem being solved
    and the number of raster bands involved.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS提供了两种类型的地图代数函数，这两种函数都返回一个单波段的新栅格。你使用的类型取决于要解决的问题和涉及的栅格带数量。
- en: The first map-algebra function (`ST_MapAlgebra()` or `ST_MapAlgebraExpr()`)
    depends on a valid, user-provided PostgreSQL algebraic expression that is called
    for every pixel. The expression can be as simple as an equation, or as complex
    as a logic-heavy SQL expression. If the map-algebra operation only requires at
    most two raster bands, and the expression is not complicated, you should have
    no problems using the expression-based map-algebra function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个地图代数函数（`ST_MapAlgebra()`或`ST_MapAlgebraExpr()`）依赖于一个有效的、用户提供的PostgreSQL代数表达式，该表达式为每个像素调用。表达式可以简单到只是一个方程，也可以复杂到是一个逻辑密集型的SQL表达式。如果地图代数操作只需要最多两个栅格带，并且表达式不复杂，你应该没有问题使用基于表达式的地图代数函数。
- en: The second map-algebra function (`ST_MapAlgebra()`, `ST_MapAlgebraFct()`, or
    `ST_MapAlgebraFctNgb()`) requires the user to provide an appropriate PostgreSQL
    function to be called for each pixel. The function being called can be written
    in any of the PostgreSQL PL languages (for example, PL/pgSQL, PL/R, PL/Perl),
    and be as complex as needed. This type is more challenging to use than the expression
    map-algebra function type, but it has the flexibility to work on any number of
    raster bands.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个地图代数函数（`ST_MapAlgebra()`、`ST_MapAlgebraFct()`或`ST_MapAlgebraFctNgb()`）要求用户为每个像素提供一个适当的PostgreSQL函数来调用。被调用的函数可以用PostgreSQL
    PL语言中的任何一种编写（例如，PL/pgSQL、PL/R、PL/Perl），并且可以按照需要复杂。这种类型比表达式地图代数函数类型更具有挑战性，但它具有处理任意数量栅格带的灵活性。
- en: For this recipe, we use only the expression-based map-algebra function, `ST_MapAlgebra()`,
    to create a new band with the temperature values in Fahrenheit, and then append
    this band to the processed raster. If you are not using PostGIS 2.1 or a later
    version, use the equivalent `ST_MapAlgebraExpr()` function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们只使用基于表达式的地图代数函数`ST_MapAlgebra()`来创建一个带有华氏温度值的新的波段，然后将这个波段附加到处理过的栅格上。如果你不是使用PostGIS
    2.1或更高版本，请使用等效的`ST_MapAlgebraExpr()`函数。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: With any operation that is going to take a while and/or modify a stored raster,
    it is best to test that operation to ensure there are no mistakes and the output
    looks correct.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何可能需要花费较长时间或修改存储栅格的操作，最好测试该操作以确保没有错误，并且输出看起来是正确的。
- en: 'Let''s run `ST_MapAlgebra()` on one raster tile, and compare the summary statistics
    before and after the map-algebra operation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个栅格瓦片上运行`ST_MapAlgebra()`，并比较地图代数操作前后的摘要统计信息：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output looks as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来如下：
- en: '![](img/148cc3c8-884d-4252-b969-e4d13c2727cf.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/148cc3c8-884d-4252-b969-e4d13c2727cf.png)'
- en: In the `ST_MapAlgebra()` function, we indicate that the output raster's band
    will have a pixel type of `32BF` and a `NODATA` value of `-9999`. We use the expression
    `'([rast]*9/5)+32'` to convert each pixel value to its new value in Fahrenheit.
    Before `ST_MapAlgebra()` evaluates the expression, the pixel value replaces the
    placeholder `'[rast]'`. There are several other placeholders available, and they
    can be found in the `ST_MapAlgebra()` documentation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ST_MapAlgebra()`函数中，我们指定输出栅格的波段将具有`32BF`像素类型和`NODATA`值`-9999`。我们使用表达式`'([rast]*9/5)+32'`将每个像素值转换为华氏度的新值。在`ST_MapAlgebra()`评估表达式之前，像素值替换占位符`'[rast]'`。还有几个其他占位符可用，它们可以在`ST_MapAlgebra()`文档中找到。
- en: 'Looking at the summary statistics and comparing the before and after processing,
    we see that the map-algebra operation works correctly. So, let''s correct the
    entire table. We will append the band created from `ST_MapAlgebra()` to the existing
    raster:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看摘要统计信息并比较处理前后的情况，我们发现地图代数操作是正确的。因此，让我们纠正整个表格。我们将把由`ST_MapAlgebra()`创建的波段附加到现有栅格上：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The SQL query will not work. Why? If you remember, when we loaded the PRISM
    rasters, we instructed `raster2pgsql` to add the standard constraints with the
    `-C` flag. It looks like we violated at least one of those constraints.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: SQL查询将不会工作。为什么？如果你记得，当我们加载PRISM栅格时，我们指示`raster2pgsql`使用`-C`标志添加标准约束。看起来我们违反了至少其中一条约束。
- en: 'When installed, the standard constraints enforce a set of rules on each value
    of a raster column in the table. These rules guarantee that each raster column
    value has the same (or appropriate) attributes. The standard constraints comprise
    the following rules:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装时，标准约束对表中每个栅格列的每个值强制执行一组规则。这些规则保证每个栅格列值具有相同的（或适当的）属性。标准约束包括以下规则：
- en: '**Width and height**: This rule states that all the rasters must have the same
    width and height'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽度和高度**：此规则说明所有栅格必须具有相同的宽度和高度'
- en: '**Scale X and Y**: This rule states that all the rasters must have the same
    scale X and Y'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X和Y比例**：此规则说明所有栅格必须具有相同的X和Y比例'
- en: '**SRID**: This rule states that all rasters must have the same SRID'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SRID**：此规则说明所有栅格必须具有相同的SRID'
- en: '**Same alignment**: This rule states that all rasters must be aligned to one
    another'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相同对齐**：此规则说明所有栅格必须相互对齐'
- en: '**Maximum extent**: This rule states that all rasters must be within the table''s
    maximum extent'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大范围**：此规则说明所有栅格必须在表的最大范围内'
- en: '**Number of bands**: This rule states that all rasters must have the same number
    of bands'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**波段数量**：此规则说明所有栅格必须具有相同的波段数量'
- en: '**NODATA values**: This rule states that all raster bands at a specific index
    must have the same NODATA value'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NODATA值**：此规则说明特定索引处的所有栅格波段必须具有相同的NODATA值'
- en: '**Out-db**: This rule states that all raster bands at a specific index must
    be `in-db` or `out-db`, not both'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Out-db**：此规则说明特定索引处的所有栅格波段必须是`in-db`或`out-db`，不能同时是两者'
- en: '**Pixel type**: This rule states that all raster bands at a specific index
    must be of the same pixel type'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素类型**：此规则说明特定索引处的所有栅格波段必须是相同的像素类型'
- en: The error message indicates that we violated the `out-db` constraint. But we
    can't accept the error message as it is, because we are not doing anything related
    to `out-db`. All we are doing is adding a second band to the raster. Adding the
    second band violates the `out-db` constraint, because the constraint is prepared
    only for one band in the raster, not a raster with two bands.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息表明我们违反了`out-db`约束。但我们不能接受这个错误信息，因为我们没有做任何与`out-db`相关的事情。我们只是向栅格添加了第二个波段。添加第二个波段违反了`out-db`约束，因为该约束是为栅格中的一个波段准备的，而不是具有两个波段的栅格。
- en: 'We will have to drop the constraints, make our changes, and reapply the constraints:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须删除约束，进行更改，并重新应用约束：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After this command, we will have the following output showing the constraints
    were dropped:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们将得到以下输出，显示约束已被删除：
- en: '![](img/fedf15ae-fcc8-444f-80b2-f166a5e9eb2c.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fedf15ae-fcc8-444f-80b2-f166a5e9eb2c.png)'
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `UPDATE` will take some time, and the output will look as follows, showing
    that the constraints were added again:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPDATE`操作将花费一些时间，输出将如下所示，显示约束已再次添加：'
- en: '![](img/55eddef7-c396-4e29-8e3d-2282490b2462.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55eddef7-c396-4e29-8e3d-2282490b2462.png)'
- en: 'There is not much information provided in the output, so we will inspect the
    rasters. We will look at one raster tile:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中提供的信息不多，因此我们将检查栅格。我们将查看一个栅格瓦片：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/9b88f202-5686-4413-87d7-d3d675ced876.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b88f202-5686-4413-87d7-d3d675ced876.png)'
- en: 'The raster has two bands. The following are the details of these two bands:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格有两个波段。以下为这两个波段的详细信息：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output looks as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来如下：
- en: '![](img/3aabe0af-6362-4e68-9bd2-823a6094f42c.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3aabe0af-6362-4e68-9bd2-823a6094f42c.png)'
- en: 'The first band is the same as the new second band with the correct attributes
    (the `32BF` pixel type, and the `NODATA value` of `-9999`) that we specified in
    the call to `ST_MapAlgebra()`.The real test, though, is to look at the summary
    statistics:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个波段与具有正确属性（`32BF` 像素类型和 `-9999` 的 `NODATA value`）的新第二个波段相同，这是我们调用 `ST_MapAlgebra()`
    时指定的。然而，真正的测试是查看汇总统计：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d6f09e95-8821-4ca2-8387-24e06ec0c549.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6f09e95-8821-4ca2-8387-24e06ec0c549.png)'
- en: The summary statistics show that band `2` is correct after the values from band
    `1` were transformed into Fahrenheit; that is, the mean temperature is `6.05`
    of band 1 in degrees Celsius, and `42.90` in degrees Fahrenheit in band 2).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 汇总统计显示，在将波段 `1` 的值转换为华氏度后，波段 `2` 是正确的；也就是说，波段 1 的平均温度为 `6.05` 摄氏度，波段 2 中的华氏度为
    `42.90`）。
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we applied a simple map-algebra operation with `ST_MapAlgebra()`
    to correct the pixel values. In a later recipe, we will present an advanced map-algebra
    operation to demonstrate the power of `ST_MapAlgebra()`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用 `ST_MapAlgebra()` 应用了一个简单的地图代数操作来纠正像素值。在后面的食谱中，我们将展示一个高级地图代数操作，以展示
    `ST_MapAlgebra()` 的强大功能。
- en: Combining geometries with rasters for analysis
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将几何形状与栅格结合进行分析
- en: In the previous two recipes, we ran basic statistics only on one raster tile.
    Though running operations on a specific raster is great, it is not very helpful
    for answering real questions. In this recipe, we will use geometries to filter,
    clip, and unite raster tiles so that we can answer questions for a specific area.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个食谱中，我们只对一个栅格瓦片运行了基本统计。虽然对特定栅格运行操作很好，但对于回答实际问题并不很有帮助。在这个食谱中，我们将使用几何形状来过滤、裁剪和合并栅格瓦片，以便我们可以回答特定区域的问题。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: We will use the San Francisco boundaries geometry previously imported into the
    `sfpoly` table. If you have not imported the boundaries, refer to the first recipe
    of this chapter for instructions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前导入到 `sfpoly` 表中的旧金山边界几何形状。如果您尚未导入边界，请参阅本章的第一个食谱以获取说明。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Since we are to look at rasters in the context of San Francisco, an easy question
    to ask is: what was the average temperature for March, 2017 in San Francisco? Have
    a look at the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要查看旧金山的栅格，一个简单的问题就是：2017 年 3 月旧金山的平均温度是多少？看看以下代码：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding SQL query, there are four items to pay attention to, which
    are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 SQL 查询中，有四个需要注意的项目，如下所述：
- en: '`ST_Transform()`: This method converts the geometry''s coordinates from one
    spatial reference system to another. Transforming a geometry is typically faster
    than transforming a raster. Transforming a raster requires the pixel values to
    be resampled, a compute-intensive process, and one that could introduce undesirable
    results. If possible, always transform a geometry before transforming a raster,
    because spatial joins need to use the same SRID.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_Transform()`：此方法将几何形状的坐标从一个空间参考系统转换为另一个。转换几何形状通常比转换栅格更快。转换栅格需要重采样像素值，这是一个计算密集型过程，可能会引入不希望的结果。如果可能，始终在转换栅格之前转换几何形状，因为空间连接需要使用相同的
    SRID。'
- en: '`ST_Intersects()`: The `ST_Intersects()` method found in the `JOIN ON` clause
    tests if the raster tile and the geometry spatially intersect. It will use any
    available spatial indexes. Depending on the installed version of PostGIS, `ST_Intersects()`
    will implicitly convert the input geometry to a raster (PostGIS 2.0), or the input
    raster to a geometry (PostGIS 2.1), before comparing the two inputs.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_Intersects()`：在 `JOIN ON` 子句中找到的 `ST_Intersects()` 方法测试栅格瓦片和几何形状是否在空间上相交。它将使用任何可用的空间索引。根据安装的
    PostGIS 版本，`ST_Intersects()` 将在比较两个输入之前隐式地将输入几何形状转换为栅格（PostGIS 2.0），或将输入栅格转换为几何形状（PostGIS
    2.1）。'
- en: '`ST_Clip()`: This method trims each intersecting raster tile only to the area
    that intersects the geometry. It eliminates the pixels that are not spatially
    part of the geometry. Like `ST_Intersects()`, the geometry is implicitly converted
    to a raster before clipping.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_Clip()`: 此方法仅将每个相交的栅格瓦片裁剪到与几何形状相交的区域。它消除了不属于几何形状空间部分的像素。与`ST_Intersects()`类似，在裁剪之前，几何形状隐式转换为栅格。'
- en: '`ST_Union()`: This method aggregates and merges the clipped raster tiles into
    one raster for further processing.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_Union()`: 此方法聚合并合并裁剪的栅格瓦片，以便进行进一步处理。'
- en: 'The following output shows the average minimum temperature for San Francisco:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出显示了旧金山的平均最低温度：
- en: '![](img/c5a35ea8-33f3-4803-a851-e2faf9c15a82.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5a35ea8-33f3-4803-a851-e2faf9c15a82.png)'
- en: San Francisco was really cold in March, 2017\. So, how does the rest of 2017
    look? Is San Francisco always cold?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年3月的旧金山真的很冷。那么，2017年的其余时间又是怎样的呢？旧金山是不是一直都很冷？
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The only change from the prior SQL query is the removal of the `WHERE` clause
    and the addition of a `GROUP BY` clause. Since `ST_Union()` is an aggregate function,
    we need to group the clipped rasters by `month_year`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的SQL查询相比，唯一的改变是删除了`WHERE`子句并添加了`GROUP BY`子句。由于`ST_Union()`是一个聚合函数，我们需要按`month_year`对裁剪的栅格进行分组。
- en: 'The output is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/e9831fb6-74b2-44e8-bea1-95158f76b513.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9831fb6-74b2-44e8-bea1-95158f76b513.png)'
- en: Based on the results, the late summer months of 2017 were the warmest, though
    not by a huge margin.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根据结果，2017年晚夏月份是最热的，尽管温差并不大。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By using a geometry to filter the rasters in the prism table, only a small set
    of rasters needed clipping with the geometry and unionizing to compute the mean.
    This maximized the query performance, and more importantly, provided the answer
    to our question.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用几何形状来过滤棱柱表中的栅格，只需对与几何形状相交并联合计算平均值的少量栅格进行裁剪。这最大化了查询性能，更重要的是，提供了我们问题的答案。
- en: Converting between rasters and geometries
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栅格和几何形状之间的转换
- en: In the last recipe, we used the geometries to filter and clip rasters only to
    the areas of interest. The `ST_Clip()` and `ST_Intersects()` functions implicitly
    converted the geometry before relating it to the raster.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们使用几何形状来过滤和裁剪仅到感兴趣区域的栅格。`ST_Clip()`和`ST_Intersects()`函数在将其与栅格关联之前隐式转换了几何形状。
- en: PostGIS provides several functions for converting rasters to geometries. Depending
    on the function, a pixel can be returned as an area or a point.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS提供了几个将栅格转换为几何形状的函数。根据函数的不同，像素可以返回为一个区域或一个点。
- en: PostGIS provides one function for converting geometries to rasters.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS提供了一个将几何形状转换为栅格的函数。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: In this recipe, we will convert rasters to geometries, and geometries to rasters.
    We will use the `ST_DumpAsPolygons()` and `ST_PixelsAsPolygons()` functions to
    convert rasters to geometries. We will then convert geometries to rasters using
    `ST_AsRaster()`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将转换栅格到几何形状，并将几何形状转换为栅格。我们将使用`ST_DumpAsPolygons()`和`ST_PixelsAsPolygons()`函数将栅格转换为几何形状。然后，我们将使用`ST_AsRaster()`将几何形状转换为栅格。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s adapt part of the query used in the last recipe to find out the average
    minimum temperature in San Francisco. We replace `ST_SummaryStats()` with `ST_DumpAsPolygons()`,
    and then return the geometries as `WKT`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整上一个菜谱中使用的查询的一部分，以找出旧金山的平均最低温度。我们将`ST_SummaryStats()`替换为`ST_DumpAsPolygons()`，然后以`WKT`返回几何形状：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/1b3a693b-b340-4c5e-99d7-9ea38b7e0ae3.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b3a693b-b340-4c5e-99d7-9ea38b7e0ae3.png)'
- en: 'Now, replace the `ST_DumpAsPolygons()` function with `ST_PixelsAsPolyons()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`ST_DumpAsPolygons()`函数替换为`ST_PixelsAsPolyons()`：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/ee245520-e737-4ab3-be13-c0a35bfc7a7a.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee245520-e737-4ab3-be13-c0a35bfc7a7a.png)'
- en: Again, the query results have been trimmed. What is important is the number
    of rows returned. `ST_PixelsAsPolygons()` returns significantly more geometries
    than `ST_DumpAsPolygons()`. This is due to the different mechanism used in each
    function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，查询结果已被裁剪。重要的是返回的行数。`ST_PixelsAsPolygons()`返回的几何形状比`ST_DumpAsPolygons()`多得多。这是由于每个函数中使用的不同机制造成的。
- en: 'The following images show the difference between `ST_DumpAsPolygons()` and
    `ST_PixelsAsPolygons()`. The `ST_DumpAsPolygons()` function only dumps pixels
    with a value and unites these pixels with the same value. The `ST_PixelsAsPolygons()`
    function does not merge pixels and dumps all of them, as shown in the following
    diagrams:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了 `ST_DumpAsPolygons()` 和 `ST_PixelsAsPolygons()` 之间的区别。`ST_DumpAsPolygons()`
    函数仅输出具有值的像素，并将这些像素合并在一起。`ST_PixelsAsPolygons()` 函数不合并像素，并输出所有像素，如下面的图示所示：
- en: '![](img/01d80a68-2208-47ea-9e9d-60b7751d96f6.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01d80a68-2208-47ea-9e9d-60b7751d96f6.png)'
- en: The `ST_PixelsAsPolygons()` function returns one geometry for each pixel. If
    there are 100 pixels, there will be 100 geometries. Each geometry of `ST_DumpAsPolygons()`
    is the union of all of the pixels in an area with the same value. If there are
    100 pixels, there may be up to 100 geometries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_PixelsAsPolygons()` 函数为每个像素返回一个几何图形。如果有100个像素，将有100个几何图形。`ST_DumpAsPolygons()`
    的每个几何图形是具有相同值的区域中所有像素的并集。如果有100个像素，可能有最多100个几何图形。'
- en: There is one other significant difference between `ST_PixelAsPolygons()` and
    `ST_DumpAsPolygons()`. Unlike `ST_DumpAsPolygons()`, `ST_PixelAsPolygons()` returns
    a geometry for pixels with the `NODATA` value, and has an empty value for the
    `val` column.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_PixelAsPolygons()` 和 `ST_DumpAsPolygons()` 之间有一个显著的区别。与 `ST_DumpAsPolygons()`
    不同，`ST_PixelAsPolygons()` 对于具有 `NODATA` 值的像素返回一个几何图形，并且 `val` 列具有空值。'
- en: 'Let''s convert a geometry to a raster with `ST_AsRaster()`. We insert `ST_AsRaster()`
    to return a raster with a pixel size of 100 by `-100` meters containing four bands
    of the pixel type `8BUI`. Each of these bands will have a pixel `NODATA` value
    of `0`, and a specific pixel value (`29`, `194`, `178`, and `255` for each band
    respectively). The units for the pixel size are determined by the geometry''s
    projection, which is also the projection of the created raster:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `ST_AsRaster()` 将一个几何图形转换为栅格。我们插入 `ST_AsRaster()` 以返回一个像素大小为100米乘以-100米的栅格，包含像素类型
    `8BUI` 的四个波段。这些波段中的每一个都将具有像素 `NODATA` 值 `0`，以及特定的像素值（每个波段分别为 `29`、`194`、`178`
    和 `255`）。像素大小的单位由几何图形的投影确定，这也是创建的栅格的投影：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we visualize the generated raster of San Francisco''s boundaries and overlay
    the source geometry, we get the following result, which is a zoomed-in view of
    the San Francisco boundary''s geometry converted to a raster with `ST_AsRaster()`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将生成的旧金山边界栅格和源几何图形可视化，并将它们叠加，我们得到以下结果，这是使用 `ST_AsRaster()` 将旧金山边界几何图形转换为栅格的放大视图：
- en: '![](img/6c03dfb9-4e3b-4402-83e2-76bdf153ec9d.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c03dfb9-4e3b-4402-83e2-76bdf153ec9d.png)'
- en: 'Though it is great that the geometry is now a raster, relating the generated
    raster to other rasters requires additional processing. This is because the generated
    raster and the other raster will most likely not be aligned. If the two rasters
    are not aligned, most PostGIS raster functions do not work. The following figure
    shows two non-aligned rasters (simplified to pixel grids):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然几何图形现在是栅格很棒，但将生成的栅格与其他栅格相关联需要额外的处理。这是因为生成的栅格和其他栅格很可能不会对齐。如果两个栅格没有对齐，大多数PostGIS栅格函数将无法工作。以下图示显示了两个未对齐的栅格（简化为像素网格）：
- en: '![](img/f351f242-0287-46de-a31f-2c7265bb24c6.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f351f242-0287-46de-a31f-2c7265bb24c6.png)'
- en: The pixel grids of Raster 1 and Raster 2 are not aligned. If the rasters are
    aligned, the edges of one grid's cell will be on top of one of the other grid's
    cell's edges.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格1和栅格2的像素网格未对齐。如果栅格对齐，一个网格的单元格边缘将位于另一个网格单元格边缘的上方。
- en: 'When a geometry needs to be converted to a raster so as to relate to an existing
    raster, use that existing raster as a reference when calling `ST_AsRaster()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将几何图形转换为栅格以与现有栅格相关联时，在调用 `ST_AsRaster()` 时使用该现有栅格作为参考：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding query, we use the raster tile at `rid = 1` as our reference
    raster. The `ST_AsRaster()` function uses the reference raster's metadata to create
    the geometry's raster. If the geometry and reference raster have different SRIDs,
    the geometry is transformed to the same SRID before creating the raster.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的查询中，我们使用 `rid = 1` 的栅格瓦片作为我们的参考栅格。`ST_AsRaster()` 函数使用参考栅格的元数据来创建几何图形的栅格。如果几何图形和参考栅格具有不同的SRID，几何图形在创建栅格之前将转换为相同的SRID。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we converted rasters to geometries. We also created new rasters
    from geometries. The ability to convert between rasters and geometries allows
    the use of functions that would otherwise not be possible.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将栅格转换为几何图形。我们还从几何图形创建了新的栅格。在栅格和几何图形之间进行转换的能力允许使用其他情况下不可能使用的函数。
- en: Processing and loading rasters with GDAL VRT
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GDAL VRT 处理和加载栅格
- en: Though PostGIS has plenty of functions for working with rasters, it is sometimes
    more convenient and more efficient to work on the source rasters before importing
    them into the database. One of the times when working with rasters outside the
    database is more efficient is when the raster contains subdatasets, typically
    found in HDF4, HDF5, and NetCDF files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PostGIS 有许多用于处理栅格数据的函数，但在某些情况下，在将它们导入数据库之前在源栅格上工作可能更方便、更高效。在数据库外处理栅格数据更有效的情况之一是栅格包含子数据集，通常在
    HDF4、HDF5 和 NetCDF 文件中找到。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will preprocess a MODIS raster with the **GDAL VRT** format
    to filter and rearrange the subdatasets. Internally, a VRT file is comprised of
    XML tags. This means we can create a VRT file with any text editor. But since
    creating a VRT file manually can be tedious, we will use the `gdalbuildvrt` utility.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将使用 **GDAL VRT** 格式预处理 MODIS 栅格数据，以过滤和重新排列子数据集。内部，VRT 文件由 XML 标签组成。这意味着我们可以使用任何文本编辑器创建
    VRT 文件。但由于手动创建 VRT 文件可能很繁琐，我们将使用 `gdalbuildvrt` 工具。
- en: The MODIS raster we use is provided by NASA, and is available in the source
    package.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的 MODIS 栅格数据由 NASA 提供，可在源代码包中找到。
- en: You will need GDAL built with HDF4 support to continue with this recipe, as
    MODIS rasters are usually in the HDF4-EOS format.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用具有 HDF4 支持构建的 GDAL 继续此配方，因为 MODIS 栅格数据通常以 HDF4-EOS 格式存储。
- en: 'The following screenshot shows the MODIS raster used in this recipe and the
    next two recipes. In the following image, we see parts of California, Nevada,
    Arizona, and Baja California:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本配方和下一个两个配方中使用的 MODIS 栅格。在以下图像中，我们可以看到加利福尼亚州、内华达州、亚利桑那州和下加利福尼亚州的部分地区：
- en: '![](img/f7362496-dfd3-48f7-ba11-cd620533c4a3.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7362496-dfd3-48f7-ba11-cd620533c4a3.png)'
- en: To allow PostGIS to properly support MODIS rasters, we will also need to add
    the MODIS Sinusoidal projection to the `spatial_ref_sys` table.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 PostGIS 正确支持 MODIS 栅格数据，我们还需要将 MODIS Sinusoidal 投影添加到 `spatial_ref_sys`
    表中。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the command line, navigate to the `MODIS` directory:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，导航到 `MODIS` 目录：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `MODIS` directory, there should be several files. One of these files
    has the name `srs.sql` and contains the `INSERT` statement needed for the MODIS
    Sinusoidal projection. Run the `INSERT` statement:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MODIS` 目录中，应该有几个文件。其中之一文件名为 `srs.sql`，包含用于 MODIS Sinusoidal 投影所需的 `INSERT`
    语句。运行 `INSERT` 语句：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The main file has the extension HDF. Let''s check the metadata of that HDF
    file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 主文件扩展名为 HDF。让我们检查该 HDF 文件的元数据：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When run, `gdalinfo` outputs a lot of information. We are looking for the list
    of subdatasets found in the `Subdatasets` section:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，`gdalinfo` 会输出大量信息。我们在 `Subdatasets` 部分寻找找到的子数据集列表：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](img/87853995-72fa-4d08-be9d-cda58f44b7fe.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87853995-72fa-4d08-be9d-cda58f44b7fe.png)'
- en: 'Each subdataset is one variable of the `MODIS` raster included in the source
    code for this chapter. For our purposes, we only need the first four subdatasets,
    which are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子数据集是 `MODIS` 栅格在本书源代码中的一个变量。就我们的目的而言，我们只需要前四个子数据集，如下所示：
- en: 'Subdataset 1: 620 - 670 nm (red)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子数据集 1：620 - 670 nm（红色）
- en: 'Subdataset 2: 841 - 876 nm (near infrared or NIR)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子数据集 2：841 - 876 nm（近红外或 NIR）
- en: 'Subdataset 3: 459 - 479 nm (blue)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子数据集 3：459 - 479 nm（蓝色）
- en: 'Subdataset 4: 545 - 565 nm (green)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子数据集 4：545 - 565 nm（绿色）
- en: The VRT format allows us to select the subdatasets to be included in the VRT
    raster as well as change the order of the subdatasets. We want to rearrange the
    subdatasets so that they are in the RGB order.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: VRT 格式允许我们选择要包含在 VRT 栅格中的子数据集以及更改子数据集的顺序。我们希望重新排列子数据集，使它们按照 RGB 顺序排列。
- en: Let's call `gdalbuildvrt` to create a VRT file for our MODIS raster. Do not
    run the following!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用 `gdalbuildvrt` 来为我们的 MODIS 栅格创建一个 VRT 文件。不要运行以下命令！
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We really hope you did not run the preceding code. The command does work but
    is too long and cumbersome. It would be better if we can pass a file indicating
    the subdatasets to include and their order in the VRT. Thankfully, `gdalbuildvrt`
    provides such an option with the `-input_file_list` flag.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真心希望您没有运行前面的代码。该命令确实有效，但太长且繁琐。如果能通过一个文件来指定要包含的子数据集及其在 VRT 中的顺序会更好。幸运的是，`gdalbuildvrt`
    提供了这样的选项，即 `-input_file_list` 标志。
- en: 'In the MODIS directory, the `modis.txt` file can be passed to `gdalbuildvrt`
    with the `-input_file_list` flag. Each line of the `modis.txt` file is the name
    of a subdataset. The order of the subdatasets in the text file dictates the placement
    of each subdataset in the VRT:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MODIS 目录中，可以使用 `-input_file_list` 标志将 `modis.txt` 文件传递给 `gdalbuildvrt`。`modis.txt`
    文件的每一行都是一个子数据集的名称。文本文件中子数据集的顺序决定了每个子数据集在 VRT 中的位置：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, call `gdalbuildvrt` with `modis.txt` in the following manner:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式调用 `gdalbuildvrt` 命令，使用 `modis.txt`：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Feel free to inspect the generated `modis.vrt` VRT file in your favorite text
    editor. Since the contents of the VRT file are just XML tags, it is easy to make
    additions, changes, and deletions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用您喜欢的文本编辑器检查生成的 `modis.vrt` VRT 文件。由于 VRT 文件的内容仅仅是 XML 标签，因此添加、更改和删除内容都很简单。
- en: 'We will do one last thing before importing our processed MODIS raster into
    PostGIS. We will convert the VRT file to a GeoTIFF file with the `gdal_translate`
    utility, because not all applications have built-in support for HDF4, HDF5, NetCDF,
    or VRT, and the superior portability of GeoTIFF:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在将处理过的 MODIS 栅格导入 PostGIS 之前，我们最后要做的最后一件事是将 VRT 文件转换为 GeoTIFF 文件，使用 `gdal_translate`
    工具，因为并非所有应用程序都内置了对 HDF4、HDF5、NetCDF 或 VRT 的支持，而 GeoTIFF 具有更好的可移植性：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, import `modis.tif` with `raster2pgsql`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `raster2pgsql` 导入 `modis.tif`：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `raster2pgsql` supports a long list of input formats. You can call the command
    with the option -G to see the complete list.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`raster2pgsql` 支持一系列输入格式。您可以使用带有 -G 选项的命令查看完整的列表。'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe was all about processing a MODIS raster into a form suitable for
    use in PostGIS. We used the `gdalbuildvrt` utility to create our VRT. As a bonus,
    we used `gdal_translate` to convert between raster formats; in this case, from
    VRT to GeoTIFF.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方完全是关于将 MODIS 栅格处理成适合在 PostGIS 中使用的格式。我们使用了 `gdalbuildvrt` 工具来创建我们的 VRT。作为额外的好处，我们使用了
    `gdal_translate` 在栅格格式之间进行转换；在这种情况下，从 VRT 转换到 GeoTIFF。
- en: If you're feeling particularly adventurous, try using `gdalbuildvrt` to create
    a VRT of the 12 PRISM rasters with each raster as a separate band.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您特别有冒险精神，尝试使用 `gdalbuildvrt` 创建一个包含 12 个 PRISM 栅格的 VRT 文件，每个栅格作为一个单独的波段。
- en: Warping and resampling rasters
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变形和重采样栅格
- en: In the previous recipe, we processed a MODIS raster to extract only those subdatasets
    that are of interest, in a more suitable order. Once done with the extraction,
    we imported the MODIS raster into its own table.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们处理了一个 MODIS 栅格，仅提取那些有意义的子数据集，并按更合适的顺序排列。一旦提取完成，我们就将 MODIS 栅格导入到它自己的表中。
- en: Here, we make use of the warping capabilities provided in PostGIS. This ranges
    from simply transforming the MODIS raster to a more suitable projection, to creating
    an overview by resampling the pixel size.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用 PostGIS 提供的变形能力。这包括从简单地将 MODIS 栅格转换到更合适的投影，到通过重采样像素大小创建概述。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use several PostGIS warping functions, specifically `ST_Transform()`
    and `ST_Rescale()`. The `ST_Transform()` function reprojects a raster to a new
    spatial reference system (for example, from WGS84 to NAD83). The `ST_Rescale()`
    function shrinks or grows the pixel size of a raster.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用几个 PostGIS 变形函数，特别是 `ST_Transform()` 和 `ST_Rescale()`。`ST_Transform()`
    函数将栅格重新投影到新的空间参考系统（例如，从 WGS84 到 NAD83）。`ST_Rescale()` 函数缩小或放大栅格的像素大小。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The first thing we will do is transform our raster, since the MODIS rasters
    have their own unique spatial-reference system. We will convert the raster from
    **MODIS Sinusoidal projection** to **US National Atlas Equal Area** (**SRID 2163**).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是转换我们的栅格，因为 MODIS 栅格有自己的独特空间参考系统。我们将栅格从 **MODIS Sinusoidal 投影**转换为**美国国家地图等面积投影**（**SRID
    2163**）。
- en: 'Before we transform the raster, we will clip the MODIS raster with our San
    Francisco boundaries geometry. By clipping our raster before transformation, the
    operation takes less time than it does to transform and then clip the raster:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换栅格之前，我们将使用旧金山的边界几何形状裁剪 MODIS 栅格。通过在转换之前裁剪栅格，操作所需的时间比先转换然后裁剪栅格所需的时间要少：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following image shows the clipped MODIS raster with the San Francisco boundaries
    on top for comparison:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了裁剪后的 MODIS 栅格，上面有旧金山的边界以供比较：
- en: '![](img/5eeb5b42-d394-4eb1-9148-c14b19dd11c2.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5eeb5b42-d394-4eb1-9148-c14b19dd11c2.png)'
- en: When we call `ST_Transform()` on the MODIS raster, we only pass the destination
    `SRID 2163`. We could specify other parameters, such as the **resampling algorithm**
    and **error tolerance**. The default resampling algorithm and error tolerance
    are set to `NearestNeighbor` and `0.125`. Using a different algorithm and/or lowering
    the error tolerance may improve the quality of the resampled raster at the cost
    of more processing time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在MODIS栅格上调用`ST_Transform()`时，我们只传递了目标`SRID 2163`。我们可以指定其他参数，例如**重采样算法**和**误差容限**。默认的重采样算法和误差容限设置为`NearestNeighbor`和`0.125`。使用不同的算法和/或降低误差容限可能会提高重采样栅格的质量，但会增加处理时间。
- en: 'Let''s transform the MODIS raster again, this time specifying the resampling
    algorithm and error tolerance as `Cubic` and `0.05`, respectively. We also indicate
    that the transformed raster must be aligned to a reference raster:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次转换MODIS栅格，这次指定重采样算法和误差容限分别为`Cubic`和`0.05`。我们还指出，转换后的栅格必须与参考栅格对齐：
- en: '[PRE43]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Unlike the prior queries where we transform the MODIS raster, let''s create
    an **overview**. An overview is a lower-resolution version of the source raster.
    If you are familiar with pyramids, an overview is level one of a pyramid, while
    the source raster is the base level:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前转换MODIS栅格的查询不同，让我们创建一个**概览**。概览是源栅格的低分辨率版本。如果你熟悉金字塔，概览是金字塔的第一层，而源栅格是基础层：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The overview is 25% of the resolution of the original MODIS raster. This means
    four times the scale, and one quarter the width and height. To prevent hardcoding
    the desired scale X and scale Y, we use the MODIS raster''s scale X and scale
    Y returned by `ST_Metadata()`. As you can see in the following image, the overview
    has a coarser resolution:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 概览是原始MODIS栅格分辨率的25%。这意味着放大了四倍，宽度和高度缩小了四分之一。为了避免硬编码所需的X轴和Y轴比例，我们使用`ST_Metadata()`返回的MODIS栅格的X轴和Y轴比例。如图所示，概览的分辨率更粗糙：
- en: '![](img/2081166c-bb2d-4bab-afba-760afffe7893.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2081166c-bb2d-4bab-afba-760afffe7893.png)'
- en: The rescaled raster is more pixelated due to the reduction of resolution.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分辨率降低，重采样后的栅格像素化更明显。
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using some of PostGIS's resampling capabilities, we projected the MODIS raster
    to a different spatial reference with `ST_Transform()` as well as controlled the
    quality of the projected raster. We also created an overview with `ST_Rescale()`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PostGIS的一些重采样功能，我们使用`ST_Transform()`将MODIS栅格投影到不同的空间参考系，并控制了投影栅格的质量。我们还使用`ST_Rescale()`创建了一个概览。
- en: Using these functions and other PostGIS resampling functions, you should be
    able to manipulate all the rasters.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数和其他PostGIS重采样函数，你应该能够操作所有栅格。
- en: Performing advanced map-algebra operations
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行高级地图代数操作
- en: In a prior recipe, we used the expression-based map-algebra function `ST_MapAlgebra()`
    to convert the PRISM pixel values to their true values. The expression-based `ST_MapAlgebra()`
    method is easy to use, but limited to operating on at most two raster bands. This
    restricts the `ST_MapAlgebra()` function's usefulness for processes that require
    more than two input raster bands, such as the **Normalized Difference Vegetation
    Index** (**NDVI**) and the **Enhanced Vegetation Index** (**EVI**).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们使用了基于表达式的地图代数函数`ST_MapAlgebra()`将PRISM像素值转换为它们的真实值。基于表达式的`ST_MapAlgebra()`方法易于使用，但仅限于最多操作两个栅格波段。这限制了`ST_MapAlgebra()`函数在需要超过两个输入栅格波段的过程（如**归一化植被指数**（**NDVI**）和**增强植被指数**（**EVI**））中的有用性。
- en: There is a variant of `ST_MapAlgebra()` designed to support an unlimited number
    of input raster bands. Instead of taking an expression, this `ST_MapAlgebra()`
    variant requires a callback function. This callback function is run for each set
    of input pixel values, and returns either a new pixel value, or `NULL` for the
    output pixel. Additionally, this variant of `ST_MapAlgebra()` permits operations
    on neighborhoods (sets of pixels around a center pixel).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种`ST_MapAlgebra()`的变体旨在支持无限数量的输入栅格波段。这种`ST_MapAlgebra()`变体不采用表达式，而是需要一个回调函数。这个回调函数为每一组输入像素值运行，并返回新的像素值，或者对于输出像素返回`NULL`。此外，这种`ST_MapAlgebra()`变体还允许对邻域（围绕中心像素的像素集）进行操作。
- en: PostGIS comes with a set of ready-to-use `ST_MapAlgebra()` callback functions.
    All of these functions are intended for neighborhood calculations, such as computing
    the average value of a neighborhood, or interpolating empty pixel values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS附带了一组现成的`ST_MapAlgebra()`回调函数。所有这些函数都是用于邻域计算，例如计算邻域的平均值或插值空像素值。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the MODIS raster to compute the EVI. EVI is a three-band operation
    consisting of the red, blue, and near-infrared bands. To do an `ST_MapAlgebra()`
    operation on three bands, PostGIS 2.1 or a higher version is required.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MODIS栅格数据计算EVI。EVI是一个由红、蓝和近红外波段组成的三波段操作。要对三个波段执行`ST_MapAlgebra()`操作，需要PostGIS
    2.1或更高版本。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To use `ST_MapAlgebra()` on more than two bands, we must use the callback function
    variant. This means we need to create a callback function. Callback functions
    can be written in any PostgreSQL PL language, such as PL/pgSQL or PL/R. Our callback
    functions are all written in PL/pgSQL, as this language is always included with
    a base PostgreSQL installation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要在超过两个波段上使用`ST_MapAlgebra()`，我们必须使用回调函数变体。这意味着我们需要创建一个回调函数。回调函数可以用任何PostgreSQL
    PL语言编写，例如PL/pgSQL或PL/R。我们的回调函数都是用PL/pgSQL编写的，因为这种语言总是包含在基本的PostgreSQL安装中。
- en: 'Our callback function uses the following equation to compute the three-band
    EVI:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的回调函数使用以下方程来计算三波段EVI：
- en: '![](img/192bfa71-ccfe-4947-be4b-38379be780d6.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/192bfa71-ccfe-4947-be4b-38379be780d6.png)'
- en: 'The following code implements the MODIS EVI function in SQL:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了SQL中的MODIS EVI函数：
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you can't create the function, you probably do not have the necessary privileges
    in the database.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法创建函数，那么您可能没有数据库中必要的权限。
- en: 'There are several characteristics required for all of the callback functions.
    These are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 所有回调函数都需要满足一些特性。具体如下：
- en: 'All `ST_MapAlgebra()` callback functions must have three input parameters,
    namely, `double precision[]`, `integer[]`, and `variadic text[]`. The `value`
    parameter is a 3D array where the first dimension denotes the raster index, the
    second dimension the Y axis, and the third dimension the X axis. The position
    parameter is an array of two dimensions, with the first dimension indicating the
    raster index, and the second dimension consisting of the X, Y coordinates of the
    center pixel. The last parameter, `userargs`, is a 1D array of zero or more elements
    containing values that a user wants to pass to the `callback` function. If visualized,
    the parameters look like the following:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有`ST_MapAlgebra()`回调函数都必须有三个输入参数，即`double precision[]`、`integer[]`和`variadic
    text[]`。`value`参数是一个三维数组，其中第一个维度表示栅格索引，第二个维度表示Y轴，第三个维度表示X轴。位置参数是一个二维数组，第一个维度表示栅格索引，第二个维度包含中心像素的X、Y坐标。最后一个参数`userargs`是一个包含用户想要传递给`callback`函数的值的0个或多个元素的1D数组。如果可视化，参数看起来如下：
- en: '[PRE46]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: All `ST_MapAlgebra()` callback functions must return a double-precision value.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有`ST_MapAlgebra()`回调函数都必须返回一个双精度值。
- en: If the callback functions are not correctly structured, the `ST_MapAlgebra()`
    function will fail or behave incorrectly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回调函数的结构不正确，`ST_MapAlgebra()`函数将失败或表现不正确。
- en: In the function body, we convert the user arguments to their correct datatypes,
    rescale the pixel values, check that no pixel values are `NULL` (arithmetic operations
    with `NULL` values always result in `NULL`), compute the numerator and denominator
    components of `EVI`, check that the denominator is not zero (prevent division
    by zero), and then finish the computation of `EVI`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们将用户参数转换为正确的数据类型，调整像素值，检查没有像素值是`NULL`（与`NULL`值的算术运算总是导致`NULL`），计算EVI的分子和分母组件，检查分母不是零（防止除以零），然后完成EVI的计算。
- en: 'Now we call our callback function, `modis_evi(),` with `ST_MapAlgebra()`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`ST_MapAlgebra()`调用我们的回调函数`modis_evi()`：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In our call to `ST_MapAlgebra()`, there are three criteria to take note of,
    which are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对`ST_MapAlgebra()`的调用中，有三个需要注意的标准，具体如下：
- en: The signature for the `modis_evi()` callback function. When passing the callback
    function to `ST_MapAlgebra()`, it must be written as a string containing the function
    name and the input-parameter types.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modis_evi()`回调函数的签名。当将回调函数传递给`ST_MapAlgebra()`时，它必须写成包含函数名和输入参数类型的字符串。'
- en: The last four function parameters (`'1.'`, `'6.'`, `'7.5'`, `'2.5'`) are user-defined
    arguments that are passed for processing by the `callback` function.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后四个函数参数（`'1.'`, `'6.'`, `'7.5'`, `'2.5'`）是用户定义的参数，传递给回调函数进行处理。
- en: The order of the band numbers affects the order of the pixel values passed to
    the callback function.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波段编号的顺序会影响传递给回调函数的像素值顺序。
- en: 'The following images show the MODIS raster before and after running the EVI
    operation. The EVI raster has a pale white to dark green colormap applied for
    highlighting areas of high vegetation:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了运行 EVI 操作前后的 MODIS 栅格图像。EVI 栅格应用了从浅白色到深绿色的颜色映射，以突出植被茂盛的区域：
- en: '![](img/4eb54f5a-f324-4005-a135-6db27f6c12b1.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4eb54f5a-f324-4005-a135-6db27f6c12b1.png)'
- en: If you are unable to run the standard EVI operation, or want more practice,
    we will now compute a two-band EVI. We will use the `ST_MapAlgebraFct()` function.
    Please note that `ST_MapAlgebraFct()` is deprecated in PostGIS 2.1, and may be
    removed in the future versions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法运行标准的 EVI 操作，或者想要更多的练习，我们现在将计算一个两波段 EVI。我们将使用 `ST_MapAlgebraFct()` 函数。请注意，`ST_MapAlgebraFct()`
    在 PostGIS 2.1 中已被弃用，并且可能在未来的版本中删除。
- en: 'For the two-band EVI, we will use the following `callback` function. The two-band
    EVI equation is computed with the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两波段 EVI，我们将使用以下 `callback` 函数。两波段 EVI 方程式通过以下代码计算：
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Like `ST_MapAlgebra()` callback functions, `ST_MapAlgebraFct()` requires callback
    functions to be structured in a specific manner. There is a difference between
    the callback function for `ST_MapAlgebraFct()` and the prior one for `ST_MapAlgebra()`.
    This function has two simple pixel-value parameters instead of an array for all
    pixel values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ST_MapAlgebra()` 回调函数类似，`ST_MapAlgebraFct()` 要求回调函数以特定的方式组织。`ST_MapAlgebraFct()`
    的回调函数与 `ST_MapAlgebra()` 的先前回调函数之间有一个区别。此函数有两个简单的像素值参数，而不是所有像素值的数组：
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Besides the difference in function names, `ST_MapAlgebraFct()` is called differently
    than `ST_MapAlgebra()`. The same raster is passed to `ST_MapAlgebraFct()` twice.
    The other difference is that there is one less user-defined argument being passed
    to the `callback` function, as the two-band EVI has one less coefficient.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数名不同之外，`ST_MapAlgebraFct()` 的调用方式与 `ST_MapAlgebra()` 不同。相同的栅格被传递给 `ST_MapAlgebraFct()`
    两次。另一个区别是传递给回调函数的用户定义参数少一个，因为两波段 EVI 的系数少一个。
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We demonstrated some of the advanced uses of PostGIS's map-algebra functions
    by computing the three-band and two-band EVIs from our MODIS raster. This was
    achieved using `ST_MapAlgebra()` and `ST_MapAlgebraFct()`, respectively. With
    some planning, PostGIS's map-algebra functions can be applied to other uses, such
    as edge detection and contrast stretching.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过计算 MODIS 栅格的三波段和两波段 EVI 来展示了 PostGIS 地图代数函数的一些高级用法。这是通过分别使用 `ST_MapAlgebra()`
    和 `ST_MapAlgebraFct()` 实现的。通过一些规划，PostGIS 的地图代数函数可以应用于其他用途，例如边缘检测和对比度拉伸。
- en: 'For additional practice, write your own callback function to generate an *NDVI*
    raster from the MODIS raster. The equation for NDVI is: *NDVI = ((IR - R)/(IR
    + R)) *where *IR* is the pixel value on the infrared band, and *R* is the pixel
    value on the red band. This index generates values between -1.0 and 1.0, in which
    negative values usually represent non-green elements (water, snow, clouds), and
    values close to zero represent rocks and deserted land.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行额外的练习，编写自己的回调函数，从 MODIS 栅格生成 *NDVI* 栅格。NDVI 的方程式为：*NDVI = ((IR - R)/(IR
    + R))，其中 *IR* 是红外波段的像素值，*R* 是红波段的像素值。此指数生成介于 -1.0 和 1.0 之间的值，其中负值通常表示非绿色元素（水、雪、云），而接近零的值表示岩石和荒地。
- en: Executing DEM operations
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 DEM 操作
- en: PostGIS comes with several functions for use on digital elevation model (DEM)
    rasters to solve terrain-related problems. Though these problems have historically
    been in the hydrology domain, they can now be found elsewhere; for example, finding
    the most fuel-efficient route from point A to point B or determining the best
    location on a roof for a solar panel. PostGIS 2.0 introduced `ST_Slope()`, `ST_Aspect()`,
    and `ST_HillShade()` while PostGIS 2.1 added the new functions `ST_TRI()`, `ST_TPI()`,
    and `ST_Roughness()`, and new variants of existing elevation functions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS 包含几个用于数字高程模型（DEM）栅格以解决地形相关问题的函数。虽然这些问题在历史上一直属于水文学领域，但现在它们可以在其他地方找到；例如，从点
    A 到点 B 寻找最省油的路线或确定屋顶上太阳能板的最佳位置。PostGIS 2.0 引入了 `ST_Slope()`、`ST_Aspect()` 和 `ST_HillShade()`，而
    PostGIS 2.1 添加了新的函数 `ST_TRI()`、`ST_TPI()` 和 `ST_Roughness()`，以及现有高程函数的新变体。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the SRTM raster, loaded as 100 x 100 tiles, in this chapter's first
    recipe. With it, we will generate slope and hillshade rasters using San Francisco
    as our area of interest.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一个菜谱中，我们将使用加载为 100 x 100 瓦片的 SRTM 栅格，利用它生成坡度和阴影栅格，以旧金山作为我们的兴趣区域。
- en: The next two queries in the How to do it section use variants of `ST_Slope()`
    and `ST_HillShade()` that are only available in PostGIS 2.1 or higher versions.
    The new variants permit the specification of a custom extent to constrain the
    processing area of the input raster.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在“如何做”部分接下来的两个查询中，使用的是仅在 PostGIS 2.1 或更高版本中可用的 `ST_Slope()` 和 `ST_HillShade()`
    的变体。新变体允许指定自定义范围以限制输入栅格的处理区域。
- en: How to do it...
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s generate a slope raster from a subset of our SRTM raster tiles using
    `ST_Slope()`. A slope raster computes the rate of elevation change from one pixel
    to a neighboring pixel:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `ST_Slope()` 从我们 SRTM 栅格瓦片的一个子集中生成一个坡度栅格。坡度栅格计算从一个像素到相邻像素的地面高度变化率：
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: All spatial objects in this query are projected to **California Albers** (**SRID
    3310**), a projection with units in meters. This projection eases the use of `ST_DWithin()`
    to broaden our area of interest to include the tiles within 1,000 meters of San
    Francisco's boundaries, which improves the computed slope values for the pixels
    at the edges of the San Francisco boundaries. We also use a rasterized version
    of our San Francisco boundaries as the custom extent for restricting the computed
    area. After running `ST_Slope()`, we clip the slope raster just to San Francisco.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 本查询中的所有空间对象都投影到 **加利福尼亚阿尔伯斯投影**（**SRID 3310**），该投影的单位是米。这种投影简化了 `ST_DWithin()`
    的使用，可以将我们的兴趣区域扩展到旧金山边界内 1,000 米的瓦片，从而提高了旧金山边界边缘像素的计算坡度值。我们还使用旧金山的栅格化边界作为自定义范围，以限制计算区域。运行
    `ST_Slope()` 后，我们仅裁剪坡度栅格到旧金山。
- en: 'We can reuse the `ST_Slope()` query and substitute `ST_HillShade()` for `ST_Slope()`
    to create a hillshade raster, showing how the sun would illuminate the terrain
    of the SRTM raster:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用 `ST_Slope()` 查询，并用 `ST_HillShade()` 替换 `ST_Slope()` 来创建阴影栅格，显示太阳如何照亮
    SRTM 栅格的地形：
- en: '[PRE51]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this case, `ST_HillShade()` is a drop-in replacement for `ST_Slope()` because
    we do not specify any special input parameters for either function. If we need
    to specify additional arguments for `ST_Slope()` or `ST_HillShade()`, all changes
    are confined to just one line.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`ST_HillShade()` 可以作为 `ST_Slope()` 的直接替代，因为我们没有为这两个函数指定任何特殊的输入参数。如果我们需要为
    `ST_Slope()` 或 `ST_HillShade()` 指定额外的参数，所有更改都仅限于一行。
- en: 'The following images show the SRTM raster before and after processing it with
    `ST_Slope()` and `ST_HillShade()`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了处理 `ST_Slope()` 和 `ST_HillShade()` 之前和之后的 SRTM 栅格：
- en: '![](img/593ad00d-446f-4464-b5a6-2d1efe0d96ea.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/593ad00d-446f-4464-b5a6-2d1efe0d96ea.png)'
- en: As you can see in the screenshot, the slope and hillshade rasters help us better
    understand the terrain of San Francisco.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，坡度和阴影栅格帮助我们更好地理解旧金山的地形。
- en: 'If PostGIS 2.0 is available, we can still use 2.0''s `ST_Slope()` and `ST_HillShade()`
    to create slope and hillshade rasters. But there are several differences you need
    to be aware of, which are as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有 PostGIS 2.0，我们仍然可以使用 2.0 的 `ST_Slope()` 和 `ST_HillShade()` 来创建坡度和阴影栅格。但你需要注意以下几个差异：
- en: '`ST_Slope()` and `ST_Aspect()` return a raster with values in radians instead
    of degrees'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_Slope()` 和 `ST_Aspect()` 返回的栅格值以弧度为单位，而不是度'
- en: Some input parameters of `ST_HillShade()` are expressed in radians instead of
    degrees
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ST_HillShade()` 的某些输入参数以弧度表示，而不是度'
- en: The computed raster from `ST_Slope()`, `ST_Aspect()`, or `ST_HillShade()` has
    an empty 1-pixel border on all four sides
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `ST_Slope()`、`ST_Aspect()` 或 `ST_HillShade()` 计算出的栅格在所有四边都有一个空的 1 像素边界
- en: 'We can adapt our `ST_Slope()` query from the beginning of this recipe by removing
    the creation and application of the custom extent. Since the custom extent constrained
    the computation to just a specific area, the inability to specify such a constraint
    means PostGIS 2.0''s `ST_Slope()` will perform slower:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除自定义范围的创建和应用来调整本菜谱开头的 `ST_Slope()` 查询。由于自定义范围将计算限制在特定区域，无法指定此类约束意味着 PostGIS
    2.0 的 `ST_Slope()` 将执行得更慢：
- en: '[PRE52]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The DEM functions in PostGIS allowed us to quickly analyze our SRTM raster.
    In the basic use cases, we were able to swap one function for another without
    any issues.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS 中的 DEM 函数使我们能够快速分析我们的 SRTM 栅格。在基本用例中，我们能够交换一个函数用于另一个函数而不会出现任何问题。
- en: What is impressive about these DEM functions is that they are all wrappers around
    `ST_MapAlgebra()`. The power of `ST_MapAlgebra()` is in its adaptability to different
    problems.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这些DEM函数令人印象深刻之处在于，它们都是围绕`ST_MapAlgebra()`的包装器。`ST_MapAlgebra()`的强大之处在于其适应不同问题的能力。
- en: Sharing and visualizing rasters through SQL
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过SQL共享和可视化栅格
- en: In [Chapter 4](68182eea-7041-4488-9f05-188b0a493ba5.xhtml), *Working with Vector
    Data – Advanced Recipes*, we used `gdal_translate` to export PostGIS rasters to
    a file. This provides a method for transferring files from one user to another,
    or from one location to another. The only problem with this method is that you
    may not have access to the `gdal_translate` utility.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](68182eea-7041-4488-9f05-188b0a493ba5.xhtml)中，*处理矢量数据 - 高级配方*，我们使用了`gdal_translate`将PostGIS栅格导出到文件。这提供了一种将文件从一个用户传输到另一个用户或从一个位置传输到另一个位置的方法。这种方法的问题在于，您可能无法访问`gdal_translate`实用程序。
- en: A different but equally functional approach is to use the `ST_AsGDALRaster()`
    family of functions available in PostGIS. In addition to `ST_AsGDALRaster()`,
    PostGIS provides `ST_AsTIFF()`, `ST_AsPNG()`, and `ST_AsJPEG()` to support the
    most common raster file formats.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种但同样功能的方法是使用PostGIS中可用的`ST_AsGDALRaster()`函数族。除了`ST_AsGDALRaster()`之外，PostGIS还提供了`ST_AsTIFF()`、`ST_AsPNG()`和`ST_AsJPEG()`以支持最常见的栅格文件格式。
- en: To easily visualize raster files without the need for a GIS application, PostGIS
    2.1 and later versions provide `ST_ColorMap()`. This function applies a built-in
    or user-specified color palette to a raster, that upon exporting with `ST_AsGDALRaster()`,
    can be viewed with any image viewer, such as a web browser.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松可视化栅格文件而无需GIS应用程序，PostGIS 2.1及更高版本提供了`ST_ColorMap()`函数。此函数将内置或用户指定的调色板应用于栅格，当使用`ST_AsGDALRaster()`导出时，可以使用任何图像查看器查看，例如网页浏览器。
- en: Getting ready
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use `ST_AsTIFF()` and `ST_AsPNG()`to export rasters
    to GeoTIFF and PNG file formats, respectively. We will also apply the `ST_ColorMap()`
    so that we can see them in any image viewer.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用`ST_AsTIFF()`和`ST_AsPNG()`将栅格导出为GeoTIFF和PNG文件格式，分别。我们还将应用`ST_ColorMap()`，以便我们可以在任何图像查看器中查看它们。
- en: 'To enable GDAL drivers in PostGIS, you should run the following command in
    `pgAdmin`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要在PostGIS中启用GDAL驱动程序，您应该在`pgAdmin`中运行以下命令：
- en: '[PRE53]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The following queries can be run in a standard SQL client, such as **psql**
    or **pgAdminIII**; however, we can't use the returned output because the output
    has escaped, and these clients do not undo the escaping. Applications with lower-level
    API functions can unescape the query output. Examples of this would be a PHP script,
    a pass-a-record element to `pg_unescape_bytea()`, or a Python script using Psycopg2's
    implicit decoding while fetching a record. A sample PHP script (`save_raster_to_file.php`)
    can be found in this chapter's `data` directory.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询可以在标准SQL客户端中运行，例如**psql**或**pgAdminIII**；然而，我们无法使用返回的输出，因为输出已转义，而这些客户端无法撤销转义。具有较低级别API函数的应用程序可以取消转义查询输出。此类示例包括PHP脚本、将记录传递给`pg_unescape_bytea()`的pass-a-record元素，或使用Psycopg2的隐式解码在获取记录时使用的Python脚本。本章的`data`目录中可以找到一个示例PHP脚本（`save_raster_to_file.php`）。
- en: How to do it...
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let us say that a colleague asks for the monthly minimum temperature data for
    San Francisco during the summer months as a single raster file. This entails restricting
    our PRISM rasters to June, July, and August, clipping each monthly raster to San
    Francisco''s boundaries, creating one raster with each monthly raster as a band,
    and then outputting the combined raster to a portable raster format. We will convert
    the combined raster to the GeoTIFF format:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一位同事要求在夏季月份获取旧金山的月度最低温度数据作为一个单独的栅格文件。这涉及到将我们的PRISM栅格限制在六月、七月和八月，将每个月度的栅格裁剪到旧金山的边界内，创建一个包含每个月度栅格作为通道的栅格，然后将组合栅格输出到可移植栅格格式。我们将组合栅格转换为GeoTIFF格式：
- en: '[PRE54]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: To filter our PRISM rasters, we use `ST_Intersects()` to keep only those raster
    tiles that spatially intersect San Francisco's boundaries. We also remove all
    rasters whose relevant month is not June, July, or August. We then use `ST_AddBand()`
    to create a new raster with each summer month's new raster band. Finally, we pass
    the combined raster to `ST_AsTIFF()` to generate a GeoTIFF.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤我们的PRISM栅格，我们使用`ST_Intersects()`仅保留与旧金山东边界空间相交的栅格瓦片。我们还移除了所有相关月份不是六月、七月或八月的栅格。然后，我们使用`ST_AddBand()`创建一个新的栅格，其中包含每个夏季月份的新栅格通道。最后，我们将组合栅格传递给`ST_AsTIFF()`以生成GeoTIFF。
- en: 'If you output the returned value from `ST_AsTIFF()` to a file, run `gdalinfo`
    on that file. The `gdalinfo` output shows that the GeoTIFF file has three bands,
    and the coordinate system of SRID 4322:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将 `ST_AsTIFF()` 返回的值输出到文件，在该文件上运行 `gdalinfo`。`gdalinfo` 输出显示 GeoTIFF 文件有三个波段，SRID
    4322 的坐标系：
- en: '[PRE55]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The problem with the GeoTIFF raster is that we generally can't view it in a
    standard image viewer. If we use `ST_AsPNG()` or `ST_AsJPEG()`, the image generated
    is much more readily viewable. But PNG and JPEG images are limited by the supported
    pixel types 8BUI and 16BUI (PNG only). Both formats are also limited to, at the
    most, three bands (four, if there is an alpha band).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: GeoTIFF 栅格的问题是我们通常无法在标准图像查看器中查看它。如果我们使用 `ST_AsPNG()` 或 `ST_AsJPEG()`，生成的图像更容易查看。但
    PNG 和 JPEG 图像受支持的像素类型 8BUI 和 16BUI（仅限 PNG）的限制。这两种格式也最多限于三个波段（如果有 alpha 波段，则为四个波段）。
- en: To help get around various file format limitations, we can use `ST_MapAlgebra()`,
    `ST_Reclass()` , or `ST_ColorMap()`, for this recipe. The `ST_ColorMap()` function
    converts a raster band of any pixel type to a set of up to four 8BUI bands. This
    facilitates creating a grayscale, RGB, or RGBA image that is then passed to `ST_AsPNG()`,
    or `ST_AsJPEG()`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助克服各种文件格式限制，我们可以使用 `ST_MapAlgebra()`、`ST_Reclass()` 或 `ST_ColorMap()` 来完成这个配方。`ST.ColorMap()`
    函数将任何像素类型的栅格波段转换为最多四个 8BUI 波段。这有助于创建灰度、RGB 或 RGBA 图像，然后传递给 `ST_AsPNG()` 或 `ST_AsJPEG()`。
- en: 'Taking our query for computing a slope raster of San Francisco from our SRTM
    raster in a prior recipe, we can apply one of `ST_ColorMap()` function''s built-in
    colormaps, and then pass the resulting raster to `ST_AsPNG()` to create a PNG
    image:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的配方中，我们使用 SRTM 栅格计算旧金山的坡度栅格查询，我们可以应用 `ST_ColorMap()` 函数的内置颜色映射之一，然后将生成的栅格传递给
    `ST_AsPNG()` 创建 PNG 图像：
- en: '[PRE56]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The bluered colormap sets the minimum, median, and maximum pixel values to dark
    blue, pale white, and bright red, respectively. Pixel values between the minimum,
    median, and maximum values are assigned colors that are linearly interpolated
    from the minimum to median or median to maximum range. The resulting image readily
    shows where the steepest slopes in San Francisco are.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝红颜色映射表将最小、中值和最大像素值分别设置为深蓝色、浅白色和亮红色。介于最小、中值和最大值之间的像素值被分配为从最小到中值或从中值到最大值范围进行线性插值的颜色。生成的图像可以清楚地显示旧金山的最大坡度。
- en: 'The following is a PNG image generated by applying the bluered colormap with
    `ST_ColorMap()` and `ST_AsPNG()`. The pixels in red represent the steepest slopes:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由 `ST_ColorMap()` 和 `ST_AsPNG()` 应用蓝红颜色映射表生成的 PNG 图像。红色像素代表最陡峭的坡度：
- en: '![](img/1026d40c-71fb-443c-aa7e-30b278a7f344.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1026d40c-71fb-443c-aa7e-30b278a7f344.png)'
- en: In our use of `ST_AsTIFF()` and `ST_AsPNG()`, we passed the raster to be converted
    as the sole argument. Both of these functions have additional parameters to customize
    the output TIFF or PNG file. These additional parameters include various compression
    and data organization settings.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 `ST_AsTIFF()` 和 `ST_AsPNG()` 时，我们将要转换的栅格作为唯一参数传递。这两个函数都有额外的参数来定制输出的 TIFF
    或 PNG 文件。这些额外的参数包括各种压缩和数据组织设置。
- en: How it works...
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using `ST_AsTIFF()` and `ST_AsPNG()`, we exported rasters from PostGIS to GeoTIFF
    and PNG. The `ST_ColorMap()` function helped generate images that can be opened
    in any image viewer. If we needed to export these images to a different format
    supported by GDAL, we would use `ST_AsGDALRaster()`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ST_AsTIFF()` 和 `ST_AsPNG()`，我们将从 PostGIS 导出的栅格导出为 GeoTIFF 和 PNG。`ST_ColorMap()`
    函数帮助我们生成可以在任何图像查看器中打开的图像。如果我们需要将这些图像导出为 GDAL 支持的任何其他格式，我们将使用 `ST_AsGDALRaster()`。
