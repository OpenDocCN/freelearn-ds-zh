- en: Chapter 13. Data Around Us
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spatial data, also known as geospatial data, identifies geographic locations,
    such as natural or constructed features around us. Although all observations have
    some spatial content, such as the location of the observation, but this is out
    of most data analysis tools' range due to the complex nature of spatial information;
    alternatively, the spatiality might not be that interesting (at first sight) in
    the given research topic.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, analyzing spatial data can reveal some very important underlying
    structures of the data, and it is well worth spending time visualizing the differences
    and similarities between close or far data points.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to help with this and will use a variety of R
    packages to:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve geospatial information from the Internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualize points and polygons on a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute some spatial statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geocoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the previous chapters, we will use the `hflights` dataset to demonstrate
    how one can deal with data bearing spatial information. To this end, let''s aggregate
    our dataset, just like we did in [Chapter 12](ch12.html "Chapter 12. Analyzing
    Time-series"), *Analyzing Time-series*, but instead of generating daily data,
    let''s view the aggregated characteristics of the airports. For the sake of performance,
    we will use the `data.table` package again as introduced in [Chapter 3](ch03.html
    "Chapter 3. Filtering and Summarizing Data"), *Filtering and Summarizing Data*
    and [Chapter 4](ch04.html "Chapter 4. Restructuring Data"), *Restructuring Data*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have loaded and then immediately transformed the `hfights` dataset to
    a `data.table` object. At the same time, we aggregated by the destination of the
    flights to compute:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of cancelled flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard deviation of the elapsed time of the flights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arithmetic mean of the delays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting R object looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have 116 observations all around the world and five variables describing
    those. Although this seems to be a spatial dataset, we have no geospatial identifiers
    that a computer can understand per se, so let''s fetch the *geocodes* of these
    airports from the Google Maps API via the `ggmap` package. First, let''s see how
    it works when we are looking for the geo-coordinates of Houston:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So the `geocode` function can return the matched latitude and longitude of
    the string we sent to Google. Now let''s do the very same thing for all flight
    destinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Well, this took some time as we had to make 116 separate queries to the Google
    Maps API. Please note that Google limits you to 2,500 queries a day without authentication,
    so do not run this on a large dataset. There is a helper function in the package,
    called `geocodeQueryCheck`, which can be used to check the remaining number of
    free queries for the day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the methods and functions that we plan to use in some later sections
    of this chapter do not support `data.table`, so let''s fall back to the traditional
    `data.frame` format and also print the structure of the current object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This was pretty quick and easy, wasn't it? Now that we have the longitude and
    latitude values of all the airports, we can try to show these points on a map.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing point data in space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first time, let''s keep it simple and load some package-bundled polygons
    as the base map. To this end, we will use the `maps` package. After loading it,
    we use the `map` function to render the polygons of the United States of America,
    add a title, and then some points for the airports and also for Houston with a
    slightly modified symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Visualizing point data in space](img/2028OS_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And showing the airport names on the plot is pretty easy as well: we can use
    the well-known functions from the base `graphics` package. Let''s pass the three
    character names as labels to the text function with a slightly increased *y* value
    to shift the preceding text the previously rendered data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Visualizing point data in space](img/2028OS_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can also specify the color of the points to be rendered. This feature
    can be used to plot our first meaningful map to highlight the number of flights
    in 2011 to different parts of the USA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Visualizing point data in space](img/2028OS_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So the intensity of red shows the number of flights to the given points (airports);
    the values range from 1 to almost 10,000\. Probably it would be more meaningful
    to compute these values on a state level as there are many airports, very close
    to each other, which might be better aggregated at a higher administrative area
    level. To this end, we load the polygon of the states, match the points of interest
    (airports) with the overlaying polygons (states), and render the polygons as a
    thematic map instead of points, like we did on the previous pages.
  prefs: []
  type: TYPE_NORMAL
- en: Finding polygon overlays of point data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already have all the data we need to identify the parent state of each airport.
    The `dt` dataset includes the geo-coordinates of the locations, and we managed
    to render the states as polygons with the `map` function. Actually, this latter
    function can return the underlying dataset without rendering a plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have around 16,000 points describing the boundaries of the US states,
    but this map data is more detailed than we actually need (see for example the
    name of the polygons starting with Washington):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, the non-connecting parts of a state are defined as separate polygons.
    To this end, let''s save a list of the state names without the string after the
    colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this list as the basis of aggregation from now on. Let''s transform
    this `map` dataset into another class of object, so that we can use the powerful
    features of the `sp` package. We will use the `maptools` package to do this transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative way of getting the state polygons might be to directly load those
    instead of transforming from other data formats as described earlier. To this
    end, you may find the `raster` package especially useful to download free map
    **shapefiles** from `gadm.org` via the `getData` function. Although these maps
    are way too detailed for such a simple task, you can always simplify those—for
    example, with the `gSimplify` function of the `rgeos` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have just created an object called `us`, which includes the polygons
    of `map_data` for each state with the given **projection**. This object can be
    shown on a map just like we did previously, although you should use the general
    `plot` method instead of the `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Finding polygon overlays of point data](img/2028OS_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Besides this, however, the `sp` package supports so many powerful features!
    For example, it''s very easy to identify the overlay polygons of the provided
    points via the `over` function. As this function name conflicts with the one found
    in the `grDevices` package, it''s better to refer to the function along with the
    namespace using a double colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What happened here? First, we passed the coordinates and the whole dataset to
    the `SpatialPointsDataFrame` function, which stored our data as spatial points
    with the given longitude and latitude values. Next, we called the `over` function
    to left-join the values of `dtp` to the US states.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative way of identifying the state of a given airport is to ask for
    more detailed information from the Google Maps API. By changing the default `output`
    argument of the `geocode` function, we can get all address components for the
    matched spatial object, which of course includes the state as well. Look for example
    at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Based on this, you might want to get a similar output for all airports and filter
    the list for the short name of the state. The `rlist` package would be extremely
    useful in this task, as it offers some very convenient ways of manipulating lists
    in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem here is that we matched only one airport to the states, which
    is definitely not okay. See for example the fourth column in the earlier output:
    it shows `LAX` as the matched airport for `California` (returned by `states[4]`),
    although there are many others there as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this issue, we can do at least two things. First, we can use the
    `returnList` argument of the `over` function to return all matched rows of `dtp`,
    and we will then post-process that data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So we created and called an anonymous function that will `sum` up the `Cancelled`
    values of the `data.frame` in each element of the list returned by `over`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another, probably cleaner, approach is to redefine `dtp` to only include the
    related values and pass a function to `over` to do the summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, we have a vector to merge back to the US state names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And to update all missing values to zero (as the number of cancelled flights
    in a state without any airport is not missing data, but exactly zero for sure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Plotting thematic maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have everything to create our first *thematic* map. Let''s pass the
    `val` vector to the previously used `map` function (or `plot` it using the `us`
    object), specify a plot title, add a blue point for Houston, and then create a
    legend, which shows the quantiles of the overall number of cancelled flights as
    a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Plotting thematic maps](img/2028OS_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Please note that, instead of a linear scale, we have decided to compute the
    square root of the relative values to define the intensity of the fill color,
    so that we can visually highlight the differences between the states. This was
    necessary as most flight cancellations happened in Texas (`748`), and there were
    no more than 150 cancelled flights in any other state (with the average being
    around 45).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also easily load ESRI shape files or other geospatial vector data formats
    into R as points or polygons with a bunch of packages already discussed and a
    few others as well, such as the `maptools`, `rgdal`, `dismo`, `raster`, or `shapefile`
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Another, probably easier, way to generate country-level thematic maps, especially
    choropleth maps, is to load the `rworldmap` package made by Andy South, and rely
    on the convenient `mapCountryData` function.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering polygons around points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides thematic maps, another really useful way of presenting spatial data
    is to draw artificial polygons around the data points based on the data values.
    This is especially useful if there is no available polygon shape file to be used
    to generate a thematic map.
  prefs: []
  type: TYPE_NORMAL
- en: A level plot, contour plot, or isopleths, might be an already familiar design
    from tourist maps, where the altitude of the mountains is represented by a line
    drawn around the center of the hill at the very same levels. This is a very smart
    approach having maps present the height of hills—projecting this third dimension
    onto a 2-dimensional image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to replicate this design by considering our data points as mountains
    on the otherwise flat map. We already know the heights and exact geo-coordinates
    of the geometric centers of these hills (airports); the only challenge here is
    to draw the actual shape of these objects. In other words:'
  prefs: []
  type: TYPE_NORMAL
- en: Are these *mountains* connected?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How steep are the *hillsides*?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should we consider any underlying spatial effects in the data? In other words,
    can we actually render these as *mountains* with a 3D shape instead of plotting
    independent points in space?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the answer for the last question is positive, then we can start trying to
    answer the other questions by fine-tuning the plot parameters. For now, let's
    simply suppose that there is a spatial effect in the underlying data, and it makes
    sense to visualize the data in such a way. Later, we will have the chance to disprove
    or support this statement either by analyzing the generated plots, or by building
    some geo-spatial models—some of these will be discussed later, in the *Spatial
    Statistics* section.
  prefs: []
  type: TYPE_NORMAL
- en: Contour lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s expand our data points into a matrix with the `fields` package.
    The size of the resulting R object is defined arbitrarily but, for the given number
    of rows and columns, which should be a lot higher to generate higher resolution
    images, 256 is a good start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `as.image` function generates a special R object, which in short includes
    a 3‑dimensional matrix-like data structure, where the *x* and *y* axes represent
    the longitude and latitude ranges of the original data respectively. To simplify
    this even more, we have a matrix with 256 rows and 256 columns, where each of
    those represents a discrete value evenly distributed between the lowest and highest
    values of the latitude and longitude. And on the *z* axis, we have the `ArrDelay`
    values—which are in most cases of course missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What does this matrix look like? It''s better to see what we have at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Contour lines](img/2028OS_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, this does not seem to be useful at all. What is shown there? We rendered
    the *x* and *y* dimensions of the matrix with *z* colors here, and most tiles
    of this map are empty due to the high amount of missing values in *z*. Also, it's
    pretty straightforward now that the dataset includes many airports outside the
    USA as well. How does it look if we focus only on the USA?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Contour lines](img/2028OS_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative and more elegant approach to rendering only the US part of the
    matrix would be to drop the non-US airports from the database before actually
    creating the `out` R object. Although we will continue with this example for didactic
    purposes, with real data make sure that you concentrate on the target subset of
    your data instead of trying to smooth and model unrelated data points as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot better! So we have our data points as a tile, now let''s try to identify
    the slope of these mountain peaks, to be able to render them on a future map.
    This can be done by smoothing the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen in the preceding table, this algorithm successfully eliminated
    many missing values from the matrix. The `image.smooth` function basically reused
    our initial data point values in the neighboring tiles, and computed some kind
    of average for the conflicting overrides. This smoothing algorithm results in
    the following arbitrary map, which does not respect any political or geographical
    boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Contour lines](img/2028OS_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It would be really nice to plot these artificial polygons along with the administrative
    boundaries, so let''s clear out all cells that do not belong to the territory
    of the USA. We will use the `point.in.polygon` function from the `sp` package
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, we have loaded the main polygon of the USA without any sub-administrative
    areas, and verified our cells in the `look` object, if those are overlapping the
    polygon. Then we simply reset the value of the cell, if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to render the boundaries of the USA, plot our smoothed contour
    plot, then add some eye-candy in the means of the US states and, the main point
    of interest, the airport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Contour lines](img/2028OS_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now this is pretty neat, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Voronoi diagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative way of visualizing point data with polygons is to generate *Voronoi*
    cells between them. In short, the Voronoi map partitions the space into regions
    around the data points by aligning all parts of the map to one of the regions
    to minimize the distance from the central data points. This is extremely easy
    to interpret, and also to implement in R. The `deldir` package provides a function
    with the very same name for Delaunay triangulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Voronoi diagrams](img/2028OS_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we represented the airports with red dots, as we did before, but also
    added the Dirichlet tessellation (Voronoi cells) rendered as dark-gray dashed
    lines. For more options on how to fine-tune the results, see the `plot.deldir`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's see how to improve this plot by adding a more detailed
    background map to it.
  prefs: []
  type: TYPE_NORMAL
- en: Satellite maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many R packages on CRAN that can fetch data from Google Maps, Stamen,
    Bing, or OpenStreetMap—even some of the packages that we have previously used
    in this chapter, such as the `ggmap` package, can do this. Similarly, the `dismo`
    package also comes with both geo-coding and Google Maps API integration capabilities,
    and there are some other packages focused on that latter, such as the `RgoogleMaps`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will use the `OpenStreetMap` package, mainly because it supports not
    only the awesome OpenStreetMap database back-end, but also a bunch of other formats
    as well. For example, we can render really nice terrain maps via Stamen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So we defined the left upper and right lower corners of the map we need, and
    also specified the map style to be a satellite map. As the data by default arrives
    from the remote servers with the Mercator projections, we first have to transform
    that to WGS84 (we used this previously), so that we can render the points and
    polygons on the top of the fetched map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And showtime at last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![Satellite maps](img/2028OS_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This seems to be a lot better compared to the outline map we created previously.
    Now you can try some other map styles as well, such as `mapquest-aerial`, or some
    of the really nice-looking `cloudMade` designs.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides being able to use Web-services to download map tiles for the background
    of the maps created in R, we can also rely on some of those to generate truly
    interactive maps. One of the best known related services is the Google Visualization
    API, which provides a platform for hosting visualizations made by the community;
    you can also use it to share maps you've created with others.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Google Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In R, you can access this API via the `googleVis` package written and maintained
    by Markus Gesmann and Diego de Castillo. Most functions of the package generate
    HTML and JavaScript code that we can directly view in a Web browser as an `SVG`
    object with the `base` plot function; alternatively, we can integrate them in
    a Web page, for example via the IFRAME HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gvisIntensityMap` function takes a `data.frame` with country ISO or USA
    state codes and the actual data to create a simple intensity map. We will use
    the `cancels` dataset we created in the *Finding Polygon Overlays of Point Data*
    section, but before that, we have to do some data transformations. Let''s add
    the state name as a new column to the `data.frame`, and replace the missing values
    with zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to load the package and pass the data along with a few extra
    parameters, signifying that we want to generate a state-level US map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Querying Google Maps](img/2028OS_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The package also offers opportunities to query the Google Map API via the `gvisMap`
    function. We will use this feature to render the airports from the `dt` dataset
    as points on a Google Map with an auto-generated tooltip of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, as usual, we have to do some data transformations again. The location
    argument of the `gvisMap` function takes the latitude and longitude values separated
    by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to generate the tooltips as a new variable, which can be done
    easily with an `apply` call. We will concatenate the variable names and actual
    values separated by a HTML line break:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we just pass these arguments to the function for an instant interactive
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![Querying Google Maps](img/2028OS_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another nifty feature of the `googleVis` package is that you can easily merge
    the different visualizations into one by using the `gvisMerge` function. The use
    of this function is quite simple: specify any two `gvis` objects you want to merge,
    and also whether they are to be placed horizontally or vertically.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript mapping libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The great success of the trending JavaScript data visualization libraries is
    only partly due to their great design. I suspect other factors also contribute
    to the general spread of such tools: it''s very easy to create and deploy full-blown
    data models, especially since the release and on-going development of Mike Bostock''s
    D3.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Although there are also many really useful and smart R packages to interact
    directly with D3 and topojson (see for example my R user activity compilation
    at [http://bit.ly/countRies](http://bit.ly/countRies)). Now we will only focus
    on how to use Leaflet— probably the most used JavaScript library for interactive
    maps.
  prefs: []
  type: TYPE_NORMAL
- en: What I truly love in R is that there are many packages wrapping other tools,
    so that R users can rely on only one programming language, and we can easily use
    C++ programs and Hadoop MapReduce jobs or build JavaScript-powered dashboards
    without actually knowing anything about the underlying technology. This is especially
    true when it comes to Leaflet!
  prefs: []
  type: TYPE_NORMAL
- en: There are at least two very nice packages that can generate a Leaflet plot from
    the R console, without a single line of JavaScript. The `Leaflet` reference class
    of the `rCharts` package was developed by Ramnath Vaidyanathan, and includes some
    methods to create a new object, set the viewport and zoom level, add some points
    or polygons to the map, and then render or print the generated HTML and JavaScript
    code to the console or to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this package is not on CRAN yet, so you will have to install
    it from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As a quick example, let''s generate a Leaflet map of the airports with some
    tooltips, like we did with the Google Maps API in the previous section. As the
    `setView` method expects numeric geo-coordinates as the center of the map, we
    will use Kansas City''s airport as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![JavaScript mapping libraries](img/2028OS_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, RStudio''s `leaflet` package and the more general `htmlwidgets`
    package also provide some easy ways to generate JavaScript-powered data visualizations.
    Let''s load the library and define the steps one by one using the pipe operator
    from the `magrittr` package, which is pretty standard for all packages created
    or inspired by RStudio or Hadley Wickham:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![JavaScript mapping libraries](img/2028OS_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I especially like this preceding map, as we can load a third-party satellite
    map in the background, then render the states as polygons; we also added the original
    data points along with some useful tooltips on the very same map with literally
    a one-line R command. We could even color the state polygons based on the aggregated
    results we computed in the previous sections! Ever tried to do the same in Java?
  prefs: []
  type: TYPE_NORMAL
- en: Alternative map designs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides being able to use third-party tools, another main reason why I tend
    to use R for all my data analysis tasks is that R is extremely powerful in creating
    custom data exploration, visualization, and modeling designs.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's create a flow-map based on our data, where we will highlight
    the flights from Houston based on the number of actual and cancelled flights.
    We will use lines and circles to render these two variables on a 2-dimensional
    map, and we will also add a contour plot in the background based on the average
    time delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as usual, let''s do some data transformations first! To keep the number
    of flows at a minimal level, let''s get rid of the airports outside the USA at
    last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need the `diagram` package (to render curved arrows from Houston to
    the destination airports) and the `scales` package to create transparent colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s render the contour map described in the *Contour Lines* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And then add a curved line from Houston to each of the destination airports,
    where the width of the line represents the number of cancelled flights and the
    diameter of the target circles shows the number of actual flights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![Alternative map designs](img/2028OS_13_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, this chapter ended up being about visualizing spatial data, and not really
    about analyzing spatial data by fitting models, filtering raw data, and looking
    for spatial effects. In the last section of the chapter, let's see how one can
    start using analytical approaches with spatial data.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most exploratory data analysis projects dealing with spatial data start by looking
    for, and potentially filtering, spatial autocorrelation. In simple terms, this
    means that we are looking for spatial effects in the data—for instance, the similarities
    of some data points can be (partly) explained by the short distance between them;
    further points seem to differ a lot more. There is nothing surprising in this
    statement; probably all of you agree with this. But how can we test this on real
    data with analytical tools?
  prefs: []
  type: TYPE_NORMAL
- en: '*Moran''s I index* is a well-known and generally used measure to test whether
    spatial autocorrelation is present or not in the variable of interest. This is
    a quite simple statistical test with the null hypothesis that there is no spatial
    autocorrelation in the dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the current data structure we have, probably the easiest way to compute
    Moran''s I is to load the `ape` package, and pass the similarity matrix along
    with the variable of interest to the `Moran.I` function. First, let''s compute
    this similarity matrix by the inverse of the Euclidian distance matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s replace all possible missing values (because the number of flights
    can be one as well, resulting in zero variance) in the `TimeVar` column, and let''s
    see if there is any spatial autocorrelation in the variance of the actual elapsed
    time of the flights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This was pretty easy, wasn't it? Based on the returned `P` value, we can reject
    the null hypothesis, and the `0.19` Moran's I suggests that the variation in the
    elapsed flight time is affected by the location of the destination airports, probably
    due to the very different distances.
  prefs: []
  type: TYPE_NORMAL
- en: 'A reverse dependency of the previously mentioned `sp` package, the `spdep`
    package can also compute this index, although we have to first transform the similarity
    matrix into a list object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Although the test results are similar to the previous run, and we can reject
    the null hypothesis of zero spatial autocorrelation in the data, the Moran's I
    index and the `P` values are not identical. This is mainly due to the fact that
    the `ape` package used weight matrix for the computation, while the `moran.test`
    function was intended to be used with polygon data, as it requires the neighbor
    lists of the data. Well, as our example included point data, this is not a clean-cut
    solution. Another main difference between the approaches is that the `ape` package
    uses normal approximation, while `spdep` implements randomization. But this difference
    is still way too high, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading the function documentation reveals that we can improve the `spdep`
    approach: when converting the `matrix` into a `listw` object, we can specify the
    actual type of the originating matrix. In our case, as we are using the inverse
    distance matrix, a row-standardized style seems more appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now the differences between this and the `ape` results are in an acceptable
    range, right?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this section cannot cover related questions or other statistical
    methods dealing with spatial data, but there are many really useful books out
    there dedicated to the topic. Please be sure to check the *Appendix* at the end
    of the book for some suggested titles.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, you have just finished the last systematic chapter of the book!
    Here, we focused on how to analyze spatial data mainly with data visualization
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we can combine the methods learned in the previous chapters.
    In the final part of the book, we will analyze the R community with various data
    science tools. If you liked this chapter, I am sure you will enjoy the final one
    as well.
  prefs: []
  type: TYPE_NORMAL
