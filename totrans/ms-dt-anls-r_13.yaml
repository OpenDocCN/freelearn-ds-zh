- en: Chapter 13. Data Around Us
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spatial data, also known as geospatial data, identifies geographic locations,
    such as natural or constructed features around us. Although all observations have
    some spatial content, such as the location of the observation, but this is out
    of most data analysis tools' range due to the complex nature of spatial information;
    alternatively, the spatiality might not be that interesting (at first sight) in
    the given research topic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, analyzing spatial data can reveal some very important underlying
    structures of the data, and it is well worth spending time visualizing the differences
    and similarities between close or far data points.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to help with this and will use a variety of R
    packages to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve geospatial information from the Internet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualize points and polygons on a map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute some spatial statistics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geocoding
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the previous chapters, we will use the `hflights` dataset to demonstrate
    how one can deal with data bearing spatial information. To this end, let''s aggregate
    our dataset, just like we did in [Chapter 12](ch12.html "Chapter 12. Analyzing
    Time-series"), *Analyzing Time-series*, but instead of generating daily data,
    let''s view the aggregated characteristics of the airports. For the sake of performance,
    we will use the `data.table` package again as introduced in [Chapter 3](ch03.html
    "Chapter 3. Filtering and Summarizing Data"), *Filtering and Summarizing Data*
    and [Chapter 4](ch04.html "Chapter 4. Restructuring Data"), *Restructuring Data*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So we have loaded and then immediately transformed the `hfights` dataset to
    a `data.table` object. At the same time, we aggregated by the destination of the
    flights to compute:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The number of rows
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of cancelled flights
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard deviation of the elapsed time of the flights
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arithmetic mean of the delays
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting R object looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So we have 116 observations all around the world and five variables describing
    those. Although this seems to be a spatial dataset, we have no geospatial identifiers
    that a computer can understand per se, so let''s fetch the *geocodes* of these
    airports from the Google Maps API via the `ggmap` package. First, let''s see how
    it works when we are looking for the geo-coordinates of Houston:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So the `geocode` function can return the matched latitude and longitude of
    the string we sent to Google. Now let''s do the very same thing for all flight
    destinations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Well, this took some time as we had to make 116 separate queries to the Google
    Maps API. Please note that Google limits you to 2,500 queries a day without authentication,
    so do not run this on a large dataset. There is a helper function in the package,
    called `geocodeQueryCheck`, which can be used to check the remaining number of
    free queries for the day.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the methods and functions that we plan to use in some later sections
    of this chapter do not support `data.table`, so let''s fall back to the traditional
    `data.frame` format and also print the structure of the current object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This was pretty quick and easy, wasn't it? Now that we have the longitude and
    latitude values of all the airports, we can try to show these points on a map.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing point data in space
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first time, let''s keep it simple and load some package-bundled polygons
    as the base map. To this end, we will use the `maps` package. After loading it,
    we use the `map` function to render the polygons of the United States of America,
    add a title, and then some points for the airports and also for Houston with a
    slightly modified symbol:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Visualizing point data in space](img/2028OS_13_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'And showing the airport names on the plot is pretty easy as well: we can use
    the well-known functions from the base `graphics` package. Let''s pass the three
    character names as labels to the text function with a slightly increased *y* value
    to shift the preceding text the previously rendered data points:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Visualizing point data in space](img/2028OS_13_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can also specify the color of the points to be rendered. This feature
    can be used to plot our first meaningful map to highlight the number of flights
    in 2011 to different parts of the USA:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Visualizing point data in space](img/2028OS_13_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: So the intensity of red shows the number of flights to the given points (airports);
    the values range from 1 to almost 10,000\. Probably it would be more meaningful
    to compute these values on a state level as there are many airports, very close
    to each other, which might be better aggregated at a higher administrative area
    level. To this end, we load the polygon of the states, match the points of interest
    (airports) with the overlaying polygons (states), and render the polygons as a
    thematic map instead of points, like we did on the previous pages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Finding polygon overlays of point data
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already have all the data we need to identify the parent state of each airport.
    The `dt` dataset includes the geo-coordinates of the locations, and we managed
    to render the states as polygons with the `map` function. Actually, this latter
    function can return the underlying dataset without rendering a plot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So we have around 16,000 points describing the boundaries of the US states,
    but this map data is more detailed than we actually need (see for example the
    name of the polygons starting with Washington):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In short, the non-connecting parts of a state are defined as separate polygons.
    To this end, let''s save a list of the state names without the string after the
    colon:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will use this list as the basis of aggregation from now on. Let''s transform
    this `map` dataset into another class of object, so that we can use the powerful
    features of the `sp` package. We will use the `maptools` package to do this transformation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative way of getting the state polygons might be to directly load those
    instead of transforming from other data formats as described earlier. To this
    end, you may find the `raster` package especially useful to download free map
    **shapefiles** from `gadm.org` via the `getData` function. Although these maps
    are way too detailed for such a simple task, you can always simplify those—for
    example, with the `gSimplify` function of the `rgeos` package.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have just created an object called `us`, which includes the polygons
    of `map_data` for each state with the given **projection**. This object can be
    shown on a map just like we did previously, although you should use the general
    `plot` method instead of the `map` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Finding polygon overlays of point data](img/2028OS_13_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'Besides this, however, the `sp` package supports so many powerful features!
    For example, it''s very easy to identify the overlay polygons of the provided
    points via the `over` function. As this function name conflicts with the one found
    in the `grDevices` package, it''s better to refer to the function along with the
    namespace using a double colon:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What happened here? First, we passed the coordinates and the whole dataset to
    the `SpatialPointsDataFrame` function, which stored our data as spatial points
    with the given longitude and latitude values. Next, we called the `over` function
    to left-join the values of `dtp` to the US states.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative way of identifying the state of a given airport is to ask for
    more detailed information from the Google Maps API. By changing the default `output`
    argument of the `geocode` function, we can get all address components for the
    matched spatial object, which of course includes the state as well. Look for example
    at the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Based on this, you might want to get a similar output for all airports and filter
    the list for the short name of the state. The `rlist` package would be extremely
    useful in this task, as it offers some very convenient ways of manipulating lists
    in R.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem here is that we matched only one airport to the states, which
    is definitely not okay. See for example the fourth column in the earlier output:
    it shows `LAX` as the matched airport for `California` (returned by `states[4]`),
    although there are many others there as well.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this issue, we can do at least two things. First, we can use the
    `returnList` argument of the `over` function to return all matched rows of `dtp`,
    and we will then post-process that data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So we created and called an anonymous function that will `sum` up the `Cancelled`
    values of the `data.frame` in each element of the list returned by `over`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Another, probably cleaner, approach is to redefine `dtp` to only include the
    related values and pass a function to `over` to do the summary:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Either way, we have a vector to merge back to the US state names:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And to update all missing values to zero (as the number of cancelled flights
    in a state without any airport is not missing data, but exactly zero for sure):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Plotting thematic maps
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have everything to create our first *thematic* map. Let''s pass the
    `val` vector to the previously used `map` function (or `plot` it using the `us`
    object), specify a plot title, add a blue point for Houston, and then create a
    legend, which shows the quantiles of the overall number of cancelled flights as
    a reference:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Plotting thematic maps](img/2028OS_13_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Please note that, instead of a linear scale, we have decided to compute the
    square root of the relative values to define the intensity of the fill color,
    so that we can visually highlight the differences between the states. This was
    necessary as most flight cancellations happened in Texas (`748`), and there were
    no more than 150 cancelled flights in any other state (with the average being
    around 45).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also easily load ESRI shape files or other geospatial vector data formats
    into R as points or polygons with a bunch of packages already discussed and a
    few others as well, such as the `maptools`, `rgdal`, `dismo`, `raster`, or `shapefile`
    packages.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Another, probably easier, way to generate country-level thematic maps, especially
    choropleth maps, is to load the `rworldmap` package made by Andy South, and rely
    on the convenient `mapCountryData` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Rendering polygons around points
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides thematic maps, another really useful way of presenting spatial data
    is to draw artificial polygons around the data points based on the data values.
    This is especially useful if there is no available polygon shape file to be used
    to generate a thematic map.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: A level plot, contour plot, or isopleths, might be an already familiar design
    from tourist maps, where the altitude of the mountains is represented by a line
    drawn around the center of the hill at the very same levels. This is a very smart
    approach having maps present the height of hills—projecting this third dimension
    onto a 2-dimensional image.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to replicate this design by considering our data points as mountains
    on the otherwise flat map. We already know the heights and exact geo-coordinates
    of the geometric centers of these hills (airports); the only challenge here is
    to draw the actual shape of these objects. In other words:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Are these *mountains* connected?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How steep are the *hillsides*?
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should we consider any underlying spatial effects in the data? In other words,
    can we actually render these as *mountains* with a 3D shape instead of plotting
    independent points in space?
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the answer for the last question is positive, then we can start trying to
    answer the other questions by fine-tuning the plot parameters. For now, let's
    simply suppose that there is a spatial effect in the underlying data, and it makes
    sense to visualize the data in such a way. Later, we will have the chance to disprove
    or support this statement either by analyzing the generated plots, or by building
    some geo-spatial models—some of these will be discussed later, in the *Spatial
    Statistics* section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Contour lines
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s expand our data points into a matrix with the `fields` package.
    The size of the resulting R object is defined arbitrarily but, for the given number
    of rows and columns, which should be a lot higher to generate higher resolution
    images, 256 is a good start:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `as.image` function generates a special R object, which in short includes
    a 3‑dimensional matrix-like data structure, where the *x* and *y* axes represent
    the longitude and latitude ranges of the original data respectively. To simplify
    this even more, we have a matrix with 256 rows and 256 columns, where each of
    those represents a discrete value evenly distributed between the lowest and highest
    values of the latitude and longitude. And on the *z* axis, we have the `ArrDelay`
    values—which are in most cases of course missing:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What does this matrix look like? It''s better to see what we have at the moment:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Contour lines](img/2028OS_13_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Well, this does not seem to be useful at all. What is shown there? We rendered
    the *x* and *y* dimensions of the matrix with *z* colors here, and most tiles
    of this map are empty due to the high amount of missing values in *z*. Also, it's
    pretty straightforward now that the dataset includes many airports outside the
    USA as well. How does it look if we focus only on the USA?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Contour lines](img/2028OS_13_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative and more elegant approach to rendering only the US part of the
    matrix would be to drop the non-US airports from the database before actually
    creating the `out` R object. Although we will continue with this example for didactic
    purposes, with real data make sure that you concentrate on the target subset of
    your data instead of trying to smooth and model unrelated data points as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot better! So we have our data points as a tile, now let''s try to identify
    the slope of these mountain peaks, to be able to render them on a future map.
    This can be done by smoothing the matrix:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As can be seen in the preceding table, this algorithm successfully eliminated
    many missing values from the matrix. The `image.smooth` function basically reused
    our initial data point values in the neighboring tiles, and computed some kind
    of average for the conflicting overrides. This smoothing algorithm results in
    the following arbitrary map, which does not respect any political or geographical
    boundaries:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Contour lines](img/2028OS_13_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'It would be really nice to plot these artificial polygons along with the administrative
    boundaries, so let''s clear out all cells that do not belong to the territory
    of the USA. We will use the `point.in.polygon` function from the `sp` package
    to do so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a nutshell, we have loaded the main polygon of the USA without any sub-administrative
    areas, and verified our cells in the `look` object, if those are overlapping the
    polygon. Then we simply reset the value of the cell, if not.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to render the boundaries of the USA, plot our smoothed contour
    plot, then add some eye-candy in the means of the US states and, the main point
    of interest, the airport:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Contour lines](img/2028OS_13_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Now this is pretty neat, isn't it?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Voronoi diagrams
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative way of visualizing point data with polygons is to generate *Voronoi*
    cells between them. In short, the Voronoi map partitions the space into regions
    around the data points by aligning all parts of the map to one of the regions
    to minimize the distance from the central data points. This is extremely easy
    to interpret, and also to implement in R. The `deldir` package provides a function
    with the very same name for Delaunay triangulation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Voronoi diagrams](img/2028OS_13_10.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Here, we represented the airports with red dots, as we did before, but also
    added the Dirichlet tessellation (Voronoi cells) rendered as dark-gray dashed
    lines. For more options on how to fine-tune the results, see the `plot.deldir`
    method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's see how to improve this plot by adding a more detailed
    background map to it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Satellite maps
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many R packages on CRAN that can fetch data from Google Maps, Stamen,
    Bing, or OpenStreetMap—even some of the packages that we have previously used
    in this chapter, such as the `ggmap` package, can do this. Similarly, the `dismo`
    package also comes with both geo-coding and Google Maps API integration capabilities,
    and there are some other packages focused on that latter, such as the `RgoogleMaps`
    package.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will use the `OpenStreetMap` package, mainly because it supports not
    only the awesome OpenStreetMap database back-end, but also a bunch of other formats
    as well. For example, we can render really nice terrain maps via Stamen:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So we defined the left upper and right lower corners of the map we need, and
    also specified the map style to be a satellite map. As the data by default arrives
    from the remote servers with the Mercator projections, we first have to transform
    that to WGS84 (we used this previously), so that we can render the points and
    polygons on the top of the fetched map:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And showtime at last:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Satellite maps](img/2028OS_13_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: This seems to be a lot better compared to the outline map we created previously.
    Now you can try some other map styles as well, such as `mapquest-aerial`, or some
    of the really nice-looking `cloudMade` designs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Interactive maps
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides being able to use Web-services to download map tiles for the background
    of the maps created in R, we can also rely on some of those to generate truly
    interactive maps. One of the best known related services is the Google Visualization
    API, which provides a platform for hosting visualizations made by the community;
    you can also use it to share maps you've created with others.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Querying Google Maps
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In R, you can access this API via the `googleVis` package written and maintained
    by Markus Gesmann and Diego de Castillo. Most functions of the package generate
    HTML and JavaScript code that we can directly view in a Web browser as an `SVG`
    object with the `base` plot function; alternatively, we can integrate them in
    a Web page, for example via the IFRAME HTML tag.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gvisIntensityMap` function takes a `data.frame` with country ISO or USA
    state codes and the actual data to create a simple intensity map. We will use
    the `cancels` dataset we created in the *Finding Polygon Overlays of Point Data*
    section, but before that, we have to do some data transformations. Let''s add
    the state name as a new column to the `data.frame`, and replace the missing values
    with zero:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now it''s time to load the package and pass the data along with a few extra
    parameters, signifying that we want to generate a state-level US map:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Querying Google Maps](img/2028OS_13_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: The package also offers opportunities to query the Google Map API via the `gvisMap`
    function. We will use this feature to render the airports from the `dt` dataset
    as points on a Google Map with an auto-generated tooltip of the variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, as usual, we have to do some data transformations again. The location
    argument of the `gvisMap` function takes the latitude and longitude values separated
    by a colon:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also have to generate the tooltips as a new variable, which can be done
    easily with an `apply` call. We will concatenate the variable names and actual
    values separated by a HTML line break:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And now we just pass these arguments to the function for an instant interactive
    map:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Querying Google Maps](img/2028OS_13_13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'Another nifty feature of the `googleVis` package is that you can easily merge
    the different visualizations into one by using the `gvisMerge` function. The use
    of this function is quite simple: specify any two `gvis` objects you want to merge,
    and also whether they are to be placed horizontally or vertically.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript mapping libraries
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The great success of the trending JavaScript data visualization libraries is
    only partly due to their great design. I suspect other factors also contribute
    to the general spread of such tools: it''s very easy to create and deploy full-blown
    data models, especially since the release and on-going development of Mike Bostock''s
    D3.js.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Although there are also many really useful and smart R packages to interact
    directly with D3 and topojson (see for example my R user activity compilation
    at [http://bit.ly/countRies](http://bit.ly/countRies)). Now we will only focus
    on how to use Leaflet— probably the most used JavaScript library for interactive
    maps.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: What I truly love in R is that there are many packages wrapping other tools,
    so that R users can rely on only one programming language, and we can easily use
    C++ programs and Hadoop MapReduce jobs or build JavaScript-powered dashboards
    without actually knowing anything about the underlying technology. This is especially
    true when it comes to Leaflet!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: There are at least two very nice packages that can generate a Leaflet plot from
    the R console, without a single line of JavaScript. The `Leaflet` reference class
    of the `rCharts` package was developed by Ramnath Vaidyanathan, and includes some
    methods to create a new object, set the viewport and zoom level, add some points
    or polygons to the map, and then render or print the generated HTML and JavaScript
    code to the console or to a file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this package is not on CRAN yet, so you will have to install
    it from GitHub:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As a quick example, let''s generate a Leaflet map of the airports with some
    tooltips, like we did with the Google Maps API in the previous section. As the
    `setView` method expects numeric geo-coordinates as the center of the map, we
    will use Kansas City''s airport as a reference:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![JavaScript mapping libraries](img/2028OS_13_14.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, RStudio''s `leaflet` package and the more general `htmlwidgets`
    package also provide some easy ways to generate JavaScript-powered data visualizations.
    Let''s load the library and define the steps one by one using the pipe operator
    from the `magrittr` package, which is pretty standard for all packages created
    or inspired by RStudio or Hadley Wickham:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![JavaScript mapping libraries](img/2028OS_13_15.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: I especially like this preceding map, as we can load a third-party satellite
    map in the background, then render the states as polygons; we also added the original
    data points along with some useful tooltips on the very same map with literally
    a one-line R command. We could even color the state polygons based on the aggregated
    results we computed in the previous sections! Ever tried to do the same in Java?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Alternative map designs
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides being able to use third-party tools, another main reason why I tend
    to use R for all my data analysis tasks is that R is extremely powerful in creating
    custom data exploration, visualization, and modeling designs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's create a flow-map based on our data, where we will highlight
    the flights from Houston based on the number of actual and cancelled flights.
    We will use lines and circles to render these two variables on a 2-dimensional
    map, and we will also add a contour plot in the background based on the average
    time delay.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as usual, let''s do some data transformations first! To keep the number
    of flows at a minimal level, let''s get rid of the airports outside the USA at
    last:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will need the `diagram` package (to render curved arrows from Houston to
    the destination airports) and the `scales` package to create transparent colors:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, let''s render the contour map described in the *Contour Lines* section:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And then add a curved line from Houston to each of the destination airports,
    where the width of the line represents the number of cancelled flights and the
    diameter of the target circles shows the number of actual flights:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Alternative map designs](img/2028OS_13_16.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Well, this chapter ended up being about visualizing spatial data, and not really
    about analyzing spatial data by fitting models, filtering raw data, and looking
    for spatial effects. In the last section of the chapter, let's see how one can
    start using analytical approaches with spatial data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Spatial statistics
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most exploratory data analysis projects dealing with spatial data start by looking
    for, and potentially filtering, spatial autocorrelation. In simple terms, this
    means that we are looking for spatial effects in the data—for instance, the similarities
    of some data points can be (partly) explained by the short distance between them;
    further points seem to differ a lot more. There is nothing surprising in this
    statement; probably all of you agree with this. But how can we test this on real
    data with analytical tools?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '*Moran''s I index* is a well-known and generally used measure to test whether
    spatial autocorrelation is present or not in the variable of interest. This is
    a quite simple statistical test with the null hypothesis that there is no spatial
    autocorrelation in the dataset.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'With the current data structure we have, probably the easiest way to compute
    Moran''s I is to load the `ape` package, and pass the similarity matrix along
    with the variable of interest to the `Moran.I` function. First, let''s compute
    this similarity matrix by the inverse of the Euclidian distance matrix:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then let''s replace all possible missing values (because the number of flights
    can be one as well, resulting in zero variance) in the `TimeVar` column, and let''s
    see if there is any spatial autocorrelation in the variance of the actual elapsed
    time of the flights:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This was pretty easy, wasn't it? Based on the returned `P` value, we can reject
    the null hypothesis, and the `0.19` Moran's I suggests that the variation in the
    elapsed flight time is affected by the location of the destination airports, probably
    due to the very different distances.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'A reverse dependency of the previously mentioned `sp` package, the `spdep`
    package can also compute this index, although we have to first transform the similarity
    matrix into a list object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Although the test results are similar to the previous run, and we can reject
    the null hypothesis of zero spatial autocorrelation in the data, the Moran's I
    index and the `P` values are not identical. This is mainly due to the fact that
    the `ape` package used weight matrix for the computation, while the `moran.test`
    function was intended to be used with polygon data, as it requires the neighbor
    lists of the data. Well, as our example included point data, this is not a clean-cut
    solution. Another main difference between the approaches is that the `ape` package
    uses normal approximation, while `spdep` implements randomization. But this difference
    is still way too high, isn't it?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试结果与之前的运行相似，我们可以拒绝数据中零空间自相关的零假设，但Moran's I指数和`P`值并不相同。这主要是因为`ape`包使用了权重矩阵进行计算，而`moran.test`函数旨在与多边形数据一起使用，因为它需要数据的邻域列表。嗯，由于我们的例子包括点数据，这不是一个干净利落的解决方案。这两种方法之间的另一个主要区别是，`ape`包使用正态近似，而`spdep`实现随机化。但这个差异仍然太高，不是吗？
- en: 'Reading the function documentation reveals that we can improve the `spdep`
    approach: when converting the `matrix` into a `listw` object, we can specify the
    actual type of the originating matrix. In our case, as we are using the inverse
    distance matrix, a row-standardized style seems more appropriate:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读函数文档可以发现，我们可以改进`spdep`方法：在将`matrix`转换为`listw`对象时，我们可以指定原始矩阵的实际类型。在我们的案例中，因为我们使用的是逆距离矩阵，所以行标准化样式似乎更合适：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now the differences between this and the `ape` results are in an acceptable
    range, right?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`ape`结果与我们的差异在可接受的范围内，对吧？
- en: Unfortunately, this section cannot cover related questions or other statistical
    methods dealing with spatial data, but there are many really useful books out
    there dedicated to the topic. Please be sure to check the *Appendix* at the end
    of the book for some suggested titles.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，本节无法涵盖与空间数据相关的其他问题或统计方法，但市面上有许多专门针对这一主题的非常有用的书籍。请务必查看本书末尾的*附录*，以获取一些推荐的标题。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations, you have just finished the last systematic chapter of the book!
    Here, we focused on how to analyze spatial data mainly with data visualization
    tools.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经完成了本书的最后一章系统性的章节！在这里，我们主要关注了如何使用数据可视化工具来分析空间数据。
- en: Now let's see how we can combine the methods learned in the previous chapters.
    In the final part of the book, we will analyze the R community with various data
    science tools. If you liked this chapter, I am sure you will enjoy the final one
    as well.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将前几章学到的方法结合起来。在本书的最后部分，我们将使用各种数据科学工具来分析R社区。如果你喜欢这一章，我确信你也会喜欢最后一章。
