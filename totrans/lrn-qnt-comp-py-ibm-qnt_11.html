<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer885" class="Basic-Text-Frame">
    <h1 class="chapterNumber">11</h1>
    <h1 id="_idParaDest-181" class="chapterTitle">Understanding Quantum Algorithms</h1>
    <p class="normal">If you’ve been reading the news about quantum computing, you will have noticed many articles from various companies, both large and small, all working on different projects related to quantum computing. The reason is largely based on the potential computing power that quantum systems offer when compared to classical systems. The potential to provide speedup, quality, and scalability are the main areas of interest that most companies and research institutions are looking heavily into now.</p>
    <p class="normal">By grasping the intricacies of the various quantum algorithms and learning how to apply them to a specific problem set or industry, researchers and developers can then look at extending what they learned about the small problems and apply them to large real-world enterprise solutions. This era of solving real-world problems using quantum computers that <a id="_idIndexMarker1190"/>are intractable to classic computers is referred to as <strong class="keyWord">quantum advantage</strong>. Currently, most of the work being done centers on understanding and creating quantum computation algorithms, which are usually focused on smaller <strong class="keyWord">toy problems</strong>, as they are commonly referred to.</p>
    <p class="normal">However, in 2021, IBM Quantum introduced a 127-qubit processor that broke the 100-qubit barrier. This signifies a great move forward as it represents a barrier in which classical simulations may no longer mimic a quantum computer of equal size. Early evidence of this was found in 2023 when a 127-qubit Eagle processor was able to perform exact solutions to computational problems beyond classical brute force. Details about this can be found in the Nature article <em class="italic">Evidence for the utility of quantum computing before fault tolerance</em> (<a href="https://www.nature.com/articles/s41586-023-06096-3"><span class="url">https://www.nature.com/articles/s41586-023-06096-3</span></a> ). </p>
    <p class="normal">This brings us a step closer to the quantum advantage phase that everyone is racing to achieve. Of course, this will vary as some problems might require more quantum computational power than others, but, over time, different industries will eventually achieve it soon enough. To get yourselves suited up and in the race, you’ll need to understand some of the foundational quantum algorithms and how they are applied to solve general problems.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Understanding the meaning of outperforming classical systems</li>
      <li class="bulletList">Learning about the Deutsch algorithm</li>
      <li class="bulletList">Understanding the Deutsch-Jozsa algorithm</li>
      <li class="bulletList">Learning about the foundational oracle-based quantum algorithm</li>
    </ul>
    <p class="normal">In this chapter, we will review the various quantum algorithms in use today. One of the most difficult hurdles to overcome while learning about quantum algorithms is that it is not a lift and shift from classical to quantum. Simply implementing a classical algorithm’s steps from a classic system onto a quantum system, such as a simple adder, will not automatically make it a quantum speedup algorithm. There’s a bit more to it than that.</p>
    <p class="normal">In <em class="chapterRef">Chapter 5</em>, <em class="italic">Understanding the Qubit</em>, we discussed how quantum states are manipulated, and in <em class="chapterRef">Chapter 7</em>, <em class="italic">Programming with Qiskit</em>, we covered how to run a circuit on a quantum system. We will now put all those pieces together to learn about and create quantum algorithms and illustrate how they can outperform classical algorithms in this chapter. We will begin by providing an example of a quantum algorithm that is foundational and illustrate how quantum systems perform operations much faster <a id="_idIndexMarker1191"/>by reviewing both the <strong class="keyWord">Deutsch</strong> and <strong class="keyWord">Deutsch-Jozsa</strong> algorithms. We’ll <a id="_idIndexMarker1192"/>follow that up with more generalized <a id="_idIndexMarker1193"/>algorithms that focus on solving simple problems with the <strong class="keyWord">Bernstein</strong>-<strong class="keyWord">Vazirani</strong> algorithm.</p>
    <p class="normal">This is by no means an exhaustive list of quantum algorithms, but this chapter will provide you with the early foundational algorithms that will help you understand the advanced algorithms and how they compare to classical algorithms. Should you want to see a more complete algorithm list, refer to <em class="chapterRef">Appendix A,</em> <em class="italic">Resources</em>, for some links to sites that keep track of quantum algorithms and research. Of course, as the technology and algorithms advance, new algorithms will be discovered that may have different methods than the following, but in all of these, it is ideal to understand the basics to get you up and running without having to delve too deep into the physics.</p>
    <h1 id="_idParaDest-182" class="heading-1">Technical requirements</h1>
    <p class="normal">In this chapter, it is expected that you have a basic understanding of linear algebra to understand the equations of each algorithm. You should also have some experience in programming basic circuits and executing them on your local simulator and a quantum device available <a id="_idIndexMarker1194"/>on the <strong class="keyWord">IBM Quantum</strong> platform. Finally, you should be familiar <a id="_idIndexMarker1195"/>with both classical bit notation and logic, quantum <strong class="keyWord">Dirac notation</strong> (or Bra-Ket notation), and understand the basic quantum computing principles such as superposition, entanglement, and interference that were covered in the previous chapters.</p>
    <p class="normal">Here is the full source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition"><span class="url">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</span></a>.</p>
    <h1 id="_idParaDest-183" class="heading-1">Understanding the meaning of outperforming classical systems</h1>
    <p class="normal">In this section, we will learn about the potential advantages that a quantum system has over classical systems by studying some of the early examples that illustrate quantum speedup <a id="_idIndexMarker1196"/>versus classical systems, albeit some of the examples are simple illustrations of the advantages that, in themselves, do not have any practical usage.</p>
    <p class="normal">Claims such as <a id="_idIndexMarker1197"/>quantum systems potentially solving equations at rapid speeds over classical systems or having the capability of a larger computation space all sound fascinating. However, recall that, at the time of writing this chapter, there are still no quantum systems available that can outperform current classical systems in solving real-world commercial problems. “<em class="italic">So why all the chatter?</em>” you ask.</p>
    <p class="normal">The answer is simple—potential. Theoretically speaking, there are quantum algorithms that describe solutions to problems that illustrate quantum speedup, such as Shor’s algorithm. However, it is expected that we will see quantum advantage before we will see quantum breaks in encryption. This is because reaching quantum advantage is based on a specific problem. It will not be specific data for all; it will evolve as the technology is able to compute very large and complex circuits. To implement complex circuits or algorithms, we will require systems that contain error mitigation, suppression, and, eventually, correction in order to obtain accurate results. This, of course, could be similar to most new technologies. A good example of this is <strong class="keyWord">video streaming</strong>.</p>
    <p class="normal">Multimedia compression has been around for decades, with video streaming invented in the early 1990s. When video compression was first made commercially available, internet bandwidth had increased and was more widely available, albeit the quality of the video and the audio was not as rich as it is today; the resolution was around 150 x 76 pixels, with a refresh rate of around 8–12 frames per second with poor audio quality. The limitation back then was both the compression technique to decrease the quality of the multimedia and the bandwidth to stream the multimedia content to multiple viewers simultaneously.</p>
    <p class="normal">The infrastructure to ensure proper decompression and minimize information loss was dependent on error correction, and a proper protocol to avoid low-quality and often jittery resolution. Now, of course, just a little over two decades later, we can see the progress: <a id="_idIndexMarker1198"/>we can stream live multimedia events with low errors and high resolution. Streaming to your home theater system with a large 4K high-definition screen where you don’t have to worry too much about the quality of the video is something of a norm nowadays.</p>
    <p class="normal">Quantum systems share this same <em class="italic">roadmap</em>, where we have the hardware (quantum systems) and the algorithms to do things at a <em class="italic">medium resolution</em> now. The difference here is that we have something we did not have back then: a global infrastructure in which anyone, anywhere, has access to a quantum system via the cloud. IBM quantum computers are available for anyone to access by simply registering for a free account.</p>
    <p class="normal">In the early days of video streaming, very few had access to bandwidth. Those who did were limited by the infrastructure to collaborate. By having cloud-accessible systems, many industries and academic institutions are doing more research on quantum hardware and algorithms. Of course, back in the early days of multimedia streaming, the solutions being solved were classified as toy problems. However, don’t let the name fool you. These toy problems are far from just something to play with and show off to your colleagues. They are the stepping stones to real-world solutions.</p>
    <p class="normal">For example, if you find a solution that illustrates quantum speedup vis-à-vis classical, with just a handful of qubits and very little quantum volume, then that might not be useful for solving many of today’s commercial or real-world problems.</p>
    <p class="normal">What it does provide is the foundational information needed to scale your solution to a system with the necessary quantum volume to solve a real-world problem. To understand what that roadmap to quantum advantage is, where a quantum solution exists that can outperform a classical system in solving a real-world problem, it’s important to first understand the foundational quantum algorithms and how they not only differ from classical algorithms but also provide an advantage over them. This will simplify your understanding of other, more complex algorithms and how they are used to solve problems in various industries.</p>
    <p class="normal">In the next section, we will <a id="_idIndexMarker1199"/>discuss the various types of foundational quantum algorithms, starting with the original algorithms that demonstrate an advantage over classical systems.</p>
    <h2 id="_idParaDest-184" class="heading-2">Learning about Deutsch’s algorithm</h2>
    <p class="normal">David Deutsch, a physicist <a id="_idIndexMarker1200"/>at the <strong class="keyWord">University of Oxford</strong>, first discovered <a id="_idIndexMarker1201"/>a problem that could be solved by a quantum computer faster than a classical computer. The problem itself has no importance or use in any computer problems, but it did serve to illustrate the advantage that quantum computation has over classical computation. Let’s understand that problem in the next section.</p>
    <h3 id="_idParaDest-185" class="heading-3">Understanding the problem</h3>
    <p class="normal">The problem <a id="_idIndexMarker1202"/>is very simple. We’ll use a simple analogy to explain it. Imagine someone is hiding a coin in each hand. Each coin, when revealed, will either be heads or tails. Since there are two coins, one in each hand, there are four possible results, as shown in the following table:</p>
    <table id="table001-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Events</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Left hand</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Right hand</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heads</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heads</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heads</p>
          </td>
          <td class="table-cell">
            <p class="normal">Tails</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
          <td class="table-cell">
            <p class="normal">Tails</p>
          </td>
          <td class="table-cell">
            <p class="normal">Heads</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">4</p>
          </td>
          <td class="table-cell">
            <p class="normal">Tails</p>
          </td>
          <td class="table-cell">
            <p class="normal">Tails</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 11.1: All four possible outcomes</p>
    <p class="normal">From the preceding list of events, we can see there are two categories. The first and fourth events are an example of a constant outcome, where both the left and right produce the same result of either heads or tails. The second and third events are examples of balanced outcomes.</p>
    <p class="normal">Here, the event results are the opposite of one another, indicating that if one is heads, then the other will be tails, or vice versa. Using this same analogy, if I were to reveal one hand at a time, let’s say the left hand, then by just viewing the results of the left hand, you would not have enough information to determine whether the result will be constant or balanced because you still need to know what is in the other hand.</p>
    <p class="normal">Now, imagine there were 100 hands in front of you and you had to examine each hand one at a time in order to determine if there are a balanced number of heads and tails, or if all of the hands contain only heads or only tails. In the best-case scenario, you would get it on the first two tries, meaning if the first hand had heads and the second had tails, you can conclude that the results of the other hands will be balanced. On the other hand (pun intended), if the first two hands revealed the same, either heads or tails, then you cannot conclude that it is balanced or constant.</p>
    <p class="normal">You would have to, in a worst-case scenario, continue until the 51<sup class="superscript">st</sup> hand is revealed, because if the first 50 hands are heads, then the 51<sup class="superscript">st</sup> would indicate whether the whole set is constant (if the 51<sup class="superscript">st</sup> is heads) or balanced (if the 51<sup class="superscript">st</sup> is tails). However, we are jumping ahead a little bit, so let’s stick to the current scope of the problem of just two events.</p>
    <p class="normal">Using a quantum algorithm, which is what Deutsch proposed here, to solve this problem is the same <a id="_idIndexMarker1203"/>as opening all the hands at once and determining whether the first two qubits are constant or balanced. <em class="italic">Interesting, isn’t it?</em> Let’s see how this works!</p>
    <p class="normal">We’ll begin by migrating the analogy of the problem to a mathematical equation. This will simplify the description of the solution later:</p>
    <ol>
      <li class="numberedList" value="1">First, substitute heads and tails with binary notations of 0 and 1, respectively.</li>
      <li class="numberedList">Next, we’ll refer to the result of each hand as a function <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1204"/>, where the argument can refer to left or right, <img src="../Images/B18420_11_003.png" alt="" width="42" height="25"/><a id="_idIndexMarker1205"/> or <img src="../Images/B18420_11_004.png" alt="" width="42" height="25"/><a id="_idIndexMarker1206"/>, respectively.</li>
    </ol>
    <p class="normal">Therefore, the results are as follows. In this case, the function <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1207"/> is <img src="../Images/B18420_11_006.png" alt="" width="42" height="25"/><a id="_idIndexMarker1208"/>, where the argument <em class="italic">x</em> can be either a 0 or 1 (left or right). The results represent each of the events that have a different result, where each one is either balanced or constant:</p>
    <table id="table002" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Events</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B18420_11_007.png" alt="" width="44" height="25"/><a id="_idIndexMarker1209"/><strong class="keyWord"> </strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><img src="../Images/B18420_11_008.png" alt="" width="40" height="25"/><a id="_idIndexMarker1210"/></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Results</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">Constant</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">Balanced</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">Balanced</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">4</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">Constant</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 11.2: Mathematical representation of outcomes</p>
    <p class="normal">As you can see from the preceding table, now we can restate our problem as a function <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1211"/> that maps <a id="_idIndexMarker1212"/>a single bit {0,1} to a result of either {0,1}, the results of which would be constant if the results for both <img src="../Images/B18420_11_003.png" alt="" width="42" height="25"/><a id="_idIndexMarker1213"/> and <img src="../Images/B18420_11_004.png" alt="" width="42" height="25"/><a id="_idIndexMarker1214"/> are the same, such as <em class="italic">Event 1</em> and <em class="italic">Event 4</em> (from the preceding table), or the results would be balanced otherwise. Now that we understand the problem, let’s figure out the solution.</p>
    <h3 id="_idParaDest-186" class="heading-3">Defining the problem</h3>
    <p class="normal">We now know that if <img src="../Images/B18420_11_003.png" alt="" width="42" height="25"/><a id="_idIndexMarker1215"/> = <img src="../Images/B18420_11_004.png" alt="" width="42" height="25"/><a id="_idIndexMarker1216"/>, then we say <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1217"/> is <em class="italic">constant</em>; otherwise, <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1218"/> is <em class="italic">balanced</em>. The problem <a id="_idIndexMarker1219"/>becomes interesting if we were to <a id="_idIndexMarker1220"/>introduce a <strong class="keyWord">black box</strong>, sometimes referred to as an oracle, that is hidden from us. We don’t know whether the function, hidden in the black box, is either constant or balanced, which is the problem we are asked to solve. The following diagram is a graphical example of our input value, <em class="italic">x</em>, going into the black box function, <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1221"/>, and outputting the result value, <img src="../Images/B18420_11_006.png" alt="" width="42" height="25"/><a id="_idIndexMarker1222"/>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_01.png" alt="Figure 13.5 – Black box representation of our problem " width="511" height="255"/></figure>
    <p class="packt_figref">Figure 11.1: Black box representation of our problem</p>
    <p class="normal">As you can see in the preceding diagram, this problem can be solved classically. However, it will need to have two queries to determine whether <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1223"/> is constant or balanced, where each query would view the results of both <img src="../Images/B18420_11_003.png" alt="" width="42" height="25"/><a id="_idIndexMarker1224"/> and <img src="../Images/B18420_11_004.png" alt="" width="42" height="25"/><a id="_idIndexMarker1225"/> to conclude whether it is constant or balanced. When using Deutsch’s quantum algorithm, we will see whether we can determine <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1226"/> using just one query that leverages the superposition principle. Let’s see how in the next section.</p>
    <h3 id="_idParaDest-187" class="heading-3">Describing the problem as a quantum problem</h3>
    <p class="normal">Since we are working with quantum computations, we’ll have to first switch to representing <a id="_idIndexMarker1227"/>our functions and values using vectors. Therefore, our constant function, where both inputs result in the same output, can be represented in vector form as follows:</p>
    <p class="center"><img src="../Images/B18420_11_022.png" alt="" width="144" height="42"/><a id="_idIndexMarker1228"/></p>
    <p class="normal">The results of this function with a different input having the same result can be represented as follows:</p>
    <p class="center"><img src="../Images/B18420_11_023.png" alt="" width="131" height="42"/><a id="_idIndexMarker1229"/></p>
    <p class="normal">The function <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1230"/> can therefore be represented by the following matrix:</p>
    <p class="center"><img src="../Images/B18420_11_025.png" alt="" width="81" height="42"/><a id="_idIndexMarker1231"/></p>
    <p class="normal">Equally, the following is an example of a balanced function, where the results are the opposites of the two input values:</p>
    <p class="center"><img src="../Images/B18420_11_026.png" alt="" width="131" height="40"/><a id="_idIndexMarker1232"/></p>
    <p class="center"><img src="../Images/B18420_11_027.png" alt="" width="131" height="42"/><a id="_idIndexMarker1233"/></p>
    <p class="normal"><img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1234"/> will be our black box, or oracle function. To do this, we will need to extend our previous diagram to include the extra components necessary to create our oracle:</p>
    <ol>
      <li class="numberedList" value="1">First, we will convert our input and output registers into Dirac <strong class="keyWord">ket notation</strong>, <img src="../Images/B18420_11_029.png" alt="" width="23" height="25"/><a id="_idIndexMarker1235"/>.</li>
      <li class="numberedList">Next, we will create two input registers, <img src="../Images/B18420_11_029.png" alt="" width="23" height="25"/><a id="_idIndexMarker1236"/> and <img src="../Images/B18420_11_031.png" alt="" width="23" height="25"/><a id="_idIndexMarker1237"/>, where the input registers will feed into our black box, or oracle function, <img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1238"/>, and the <img src="../Images/B18420_11_031.png" alt="" width="23" height="25"/><a id="_idIndexMarker1239"/> register is used as an ancillary qubit. Ancilla qubits are extra bits used to store information that might be used later or to track information throughout the quantum circuit.</li>
      <li class="numberedList">Finally, we’ll define our two output registers: one that is just the same as the input <img src="../Images/B18420_11_029.png" alt="" width="23" height="25"/><a id="_idIndexMarker1240"/>, and the other that is the <strong class="keyWord">XOR</strong> of the input register <em class="italic">x</em> and the input register x <em class="italic">XORed</em> with the function <img src="../Images/B18420_11_006.png" alt="" width="42" height="25"/><a id="_idIndexMarker1241"/>, as <img src="../Images/B18420_11_036.png" alt="" width="108" height="25"/><a id="_idIndexMarker1242"/>.</li>
    </ol>
    <p class="normal-one">Therefore, we can now define the oracle function as follows:</p>
    <p class="center"><img src="../Images/B18420_11_037.png" alt="" width="283" height="25"/><a id="_idIndexMarker1243"/></p>
    <p class="normal">This is illustrated as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_02.png" alt="Figure 13.6 – Graphical representation of the Deutsch algorithm " width="465" height="191"/></figure>
    <p class="packt_figref">Figure 11.2: Graphical representation of the Deutsch algorithm</p>
    <p class="normal">Another <a id="_idIndexMarker1244"/>requirement is that the function should be reversible and we can test to see if it is by working it out in reverse:</p>
    <p class="center"><img src="../Images/B18420_11_038.png" alt="" width="229" height="27"/><a id="_idIndexMarker1245"/></p>
    <p class="normal">Now that we have our function defined as a quantum function for our problem, we’ll see how Deutsch’s algorithm works.</p>
    <h3 id="_idParaDest-188" class="heading-3">Implementing Deutsch’s algorithm</h3>
    <p class="normal">In this section, we will implement the algorithm with a balanced function as an example but will <a id="_idIndexMarker1246"/>leave it to you to update the code to implement a constant function. We’ll examine the Deutsch algorithm and step through each task as we build the algorithm on the IQL as follows:</p>
    <ol>
      <li class="numberedList" value="1">Open a new Jupyter notebook where you have Qiskit installed, and in the first cell, include the helper file:
        <pre class="programlisting code-one"><code class="hljs-code">%run helper_file_1.0.ipynb
</code></pre>
      </li>
      <li class="numberedList">Next, we will create a 2-qubit circuit and prepare each input, the first to <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker1247"/> and the second to <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker1248"/>. We will use the identity gate to represent the <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker1249"/>, which is the initial state, and an X-gate to represent the initial state of <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker1250"/>:
        <pre class="programlisting code-one"><code class="hljs-code"># Implement Deutsch's algorithm for a balanced function
qc = QuantumCircuit(2,1)
# Prepare the input qubits, where q0=0, q1=1
print('Step 1: Prepare the input qubits, where q0=0, q1=1')
qc.id(<span class="hljs-number">0</span>)
qc.x(<span class="hljs-number">1</span>)
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This results in the following circuit diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_03.png" alt="Figure 13.7 – Initializing the qubits to 0 and 1 " width="261" height="186"/></figure>
    <p class="packt_figref">Figure 11.3: Initializing the qubits to 0 and 1</p>
    <p class="normal-one">As you can see from the preceding diagram, <strong class="keyWord">q</strong><sub class="subscript">0</sub> is set to <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker1251"/> and <strong class="keyWord">q</strong><sub class="subscript">1</sub> is set to <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker1252"/>, which creates the first state at the barrier (<img src="../Images/B18420_11_045.png" alt="" width="21" height="25"/><a id="_idIndexMarker1253"/>) as <img src="../Images/B18420_11_046.png" alt="" width="33" height="25"/><a id="_idIndexMarker1254"/>. The use of the barrier is just to indicate checkpoints as we traverse through each operation in the circuit.</p>
    <ol>
      <li class="numberedList" value="3">Now that <a id="_idIndexMarker1255"/>our inputs are set, we will place them in a superposition state using Hadamard gates. This will allow us to iterate through once while leveraging all four states, rather than iterating through each of them one at a time:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Place each qubit in superposition by applying a</span>
<span class="hljs-comment"># Hadamard</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Step 2: Place each qubit in superposition by     applying a Hadamard'</span>)
qc.h(<span class="hljs-number">0</span>)
qc.h(<span class="hljs-number">1</span>)
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result of the preceding code is illustrated in the following diagram. The barriers are used to separate each step so as to simplify reading the circuit:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_04.png" alt="Figure 13.8 – Applying Hadamard to both qubits " width="339" height="163"/></figure>
    <p class="packt_figref">Figure 11.4: Applying Hadamard gates to both qubits</p>
    <p class="normal-one">As you can see from the preceding diagram, the Hadamard gate transforms the basis vectors for each qubit as follows:</p>
    <p class="center"><img src="../Images/B18420_11_047.png" alt="" width="342" height="50"/><a id="_idIndexMarker1256"/></p>
    <p class="normal-one">This generates <a id="_idIndexMarker1257"/>the following state at the second barrier as <img src="../Images/B18420_11_048.png" alt="" width="21" height="25"/><a id="_idIndexMarker1258"/>, where <img src="../Images/B18420_11_049.png" alt="" width="40" height="25"/><a id="_idIndexMarker1259"/> describes a single qubit:</p>
    <p class="center"><img src="../Images/B18420_11_050.png" alt="" width="342" height="50"/><a id="_idIndexMarker1260"/></p>
    <ol>
      <li class="numberedList" value="4">After the qubits have applied the preceding Hadamard gates, the resulting value for the quantum registers will be as follows:</li>
    </ol>
    <p class="center"><img src="../Images/B18420_11_051.png" alt="" width="265" height="50"/><a id="_idIndexMarker1261"/></p>
    <p class="normal-one">One thing to note here is that we now have the second qubit in a <img src="../Images/B18420_11_052.png" alt="" width="28" height="24"/><a id="_idIndexMarker1262"/> superposition, <img src="../Images/B18420_11_053.png" alt="" width="36" height="23"/><a id="_idIndexMarker1263"/>. This allows us to define the first and second qubit out of <img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1264"/>, as follows:</p>
    <p class="center"><img src="../Images/B18420_11_055.png" alt="" width="333" height="56"/><a id="_idIndexMarker1265"/></p>
    <p class="normal-one">From the preceding equation, you can see that the second qubit, grouped in the second set of parentheses, has the same value, which is the <img src="../Images/B18420_11_056.png" alt="" width="31" height="25"/><a id="_idIndexMarker1266"/> superposition, <img src="../Images/B18420_11_049.png" alt="" width="40" height="25"/><a id="_idIndexMarker1267"/>.</p>
    <p class="normal-one">However, the first qubit we see has an interesting result. Let’s dig a little deeper to understand what this means.</p>
    <p class="normal-one">Here, we see that if <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1268"/> is constant, we’ll have the following:</p>
    <p class="center"><img src="../Images/B18420_11_059.png" alt="" width="238" height="54"/><a id="_idIndexMarker1269"/></p>
    <p class="normal-one">If <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1270"/> is balanced, then we’ll have the following:</p>
    <p class="center"><img src="../Images/B18420_11_061.png" alt="" width="238" height="54"/><a id="_idIndexMarker1271"/></p>
    <p class="normal-one">Note that the second qubit is always the same, but the first has a phase kickback from positive if constant, and negative if balanced. This phase kickback is a common trick used in many quantum algorithms, so rest assured we will see this again.</p>
    <ol>
      <li class="numberedList" value="5">Next, by applying a Hadamard gate to the first qubit, we can see something interesting <a id="_idIndexMarker1272"/>as a result. Let’s look at this one at a time.</li>
    </ol>
    <p class="normal-one">For a constant function, the first qubit is set to the following:</p>
    <p class="center"><img src="../Images/B18420_11_062.png" alt="" width="104" height="54"/><a id="_idIndexMarker1273"/></p>
    <p class="normal-one">We recall that applying a Hadamard gate to this superposition state will return us to the <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker1274"/> state.</p>
    <p class="normal-one">For the balanced function, the first qubit is set to the following superposition state:</p>
    <p class="center"><img src="../Images/B18420_11_064.png" alt="" width="104" height="54"/><a id="_idIndexMarker1275"/></p>
    <p class="normal-one">We can also recall that applying a Hadamard gate to the previous superposition state will return us to the <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker1276"/> state.</p>
    <p class="normal-one">This means that measuring only the first qubit after applying a Hadamard gate to it will provide us with a resulting state of either <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker1277"/> or <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker1278"/>, constant or balanced, respectively.</p>
    <ol>
      <li class="numberedList" value="6">Let’s implement this using our Qiskit notebook.</li>
    </ol>
    <p class="normal-one">This is where we wish to set a quantum gate that would operate on q<sub class="subscript">1</sub>, which represents the <em class="italic">y</em> value, based on the value of q<sub class="subscript">0</sub>, which represents the <em class="italic">x</em> value. Therefore, this operator, which we’ll call <img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1279"/>, will have inputs (<em class="italic">x</em>, <em class="italic">y</em>). The gate we will use to represent this <a id="_idIndexMarker1280"/>will be a <strong class="keyWord">Control-Not</strong> (<strong class="keyWord">CNOT</strong>) gate. The reason for using this for the balanced function is because it produces the Bell states 01 and 10 with the input qubits. And, of course, this could be switched to the other two Bell states, 00 and 11, by adding an X gate, which would make this a constant function.</p>
    <p class="normal-one">In this case, we are working to create a balanced function, one to one, which equates to the following:</p>
    <p class="center"><img src="../Images/B18420_11_069.png" alt="" width="104" height="27"/><a id="_idIndexMarker1281"/></p>
    <p class="normal-one">To accomplish this, we will need to define our state operator, <img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1282"/>, as follows:</p>
    <p class="center"><img src="../Images/B18420_11_071.png" alt="" width="123" height="88"/><a id="_idIndexMarker1283"/></p>
    <p class="normal-one">Now, we will <a id="_idIndexMarker1284"/>place a CNOT gate with the control on the first qubit, <strong class="keyWord">q</strong><sub class="subscript">0</sub>, and the target on the second qubit, <strong class="keyWord">q</strong><sub class="subscript">1</sub>:</p>
    <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Add a CNOT gate with the Control on q0 and Target on q1</span>
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
<span class="hljs-comment"># Draw the circuit</span>
qc.draw(output='mpl')
</code></pre>
    <p class="normal-one">This should now include the CNOT gate that generates the function type (balanced) and renders the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_05.png" alt="Figure 13.9 – Defining the function type (balanced) " width="455" height="165"/></figure>
    <p class="packt_figref">Figure 11.5: Defining the function type (balanced)</p>
    <ol>
      <li class="numberedList" value="7">Next, we’ll add Hadamard gates to all qubits and a measurement operator to the first qubit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Add the Hadamard gates to all qubits</span>
qc.h(<span class="hljs-number">0</span>)
qc.h(<span class="hljs-number">1</span>)
qc.barrier()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As we saw in our equation earlier, we only need to apply a Hadamard gate to the first qubit, as we will only be measuring the one qubit:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_06.png" alt="Figure 13.10 – Applying the Hadamard gate to the qubits before measuring " width="556" height="171"/></figure>
    <p class="packt_figref">Figure 11.6: Applying the Hadamard gate to the qubits before measuring</p>
    <p class="normal-one">This results <a id="_idIndexMarker1285"/>in the following state, <img src="../Images/B18420_11_072.png" alt="" width="25" height="25"/><a id="_idIndexMarker1286"/>:</p>
    <p class="center"><img src="../Images/B18420_11_073.png" alt="" width="379" height="50"/><a id="_idIndexMarker1287"/></p>
    <p class="center"> <img src="../Images/B18420_11_074.png" alt="" width="283" height="38"/><a id="_idIndexMarker1288"/></p>
    <p class="center"> <img src="../Images/B18420_11_075.png" alt="" width="285" height="38"/><a id="_idIndexMarker1289"/></p>
    <p class="center"> <img src="../Images/B18420_11_076.png" alt="" width="296" height="38"/><a id="_idIndexMarker1290"/></p>
    <p class="normal-one">Let’s now apply some algebra to simplify our results:</p>
    <p class="center"><img src="../Images/B18420_11_077.png" alt="" width="321" height="46"/><a id="_idIndexMarker1291"/></p>
    <p class="normal-one">Since we will only be measuring the first qubit, we can throw the second qubit away or just not measure it as it is just an ancillary qubit in this case.</p>
    <ol>
      <li class="numberedList" value="8">Let’s take a measurement of the first qubit, shown as follows, the result of which will determine the category of the function as either balanced (<code class="inlineCode">1</code>) or constant (<code class="inlineCode">0</code>):
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Add measurement operator to the first qubit</span>
qc.measure(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">We already know from the previous equation that this should equate to a balanced function:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_07.png" alt="Figure 13.11 – Applying the measurement operator to just the first qubit " width="603" height="169"/></figure>
    <p class="packt_figref">Figure 11.7: Applying the measurement operator to just the first qubit</p>
    <ol>
      <li class="numberedList" value="9">Next, to simplify a few things, let’s define a function to run our circuits on a Sampler <a id="_idIndexMarker1292"/>installed on your local machine. We’ll use the following function, which leverages the <code class="inlineCode">StatevectorSampler</code>:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Run on a Sampler</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">run_on_sampler</span>(<span class="hljs-params">circuit</span>):
    <span class="hljs-keyword">from</span> qiskit.primitives <span class="hljs-keyword">import</span> StatevectorSampler
    <span class="hljs-comment"># Construct a Statevector Sampler</span>
    sampler = StatevectorSampler()
    <span class="hljs-comment"># Run using the Sampler</span>
    result = sampler.run([circuit]).result()
    <span class="hljs-keyword">return</span> result
</code></pre>
      </li>
      <li class="numberedList">Now we can run the preceding circuit and verify our results by using the following code:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Execute the quantum circuit on the simulator first to</span>
<span class="hljs-comment"># confirm our results.</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Step 6: Execute the circuit to view results.'</span>)
result = run_on_sampler(qc)
counts = result[0].data.c.get_counts()
<span class="hljs-comment"># Print and plot our results</span>
<span class="hljs-built_in">print</span>(counts)
plot_distribution(counts, title=<span class="hljs-string">'Balanced function'</span>)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As calculated previously, the results of this experiment indicate a balanced function, as indicated by the result <code class="inlineCode">1</code>, rather than <code class="inlineCode">0</code>.</p>
    <p class="normal-one">This results in the following output:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_08.png" alt="A blue rectangular graph with white text  Description automatically generated" width="760" height="538"/></figure>
    <p class="packt_figref">Figure 11.8: Result of value 1, indicating a balanced function</p>
    <p class="normal-one">As expected, we see that our result is <strong class="screenText">1</strong>, indicating a balanced function.</p>
    <p class="normal">Observe that to retrieve the counts from the results, we need to map to the data object and then to <a id="_idIndexMarker1293"/>the name of the classical register that we wish to extract the counts from.</p>
    <p class="normal">From the preceding output, the result shows the same as what we expected for the given function we provided, which, in this case, is the balanced function, where 1 has a higher probability. There is an exercise in the <em class="italic">Questions</em> section where you are required to create a constant function.</p>
    <p class="normal">What we have shown here is the potential of a quantum algorithm to perform operations faster than a classical system, which would otherwise need to calculate each function in series for each input. Naturally, this exercise does not offer any real-world applications, but it does help in understanding how these systems have potential speedup properties. In the next section, we will look at generalizing this example by applying it to more than one qubit.</p>
    <h2 id="_idParaDest-189" class="heading-2">Understanding the Deutsch-Jozsa algorithm</h2>
    <p class="normal">In the previous section, the Deutsch algorithm provided us with an example of quantum speedup where we <a id="_idIndexMarker1294"/>use two qubits but only measure one qubit. Here, the <strong class="keyWord">Deutsch-Jozsa</strong> algorithm provides a more generalized form of the algorithm. It can be applied to more than one qubit. Originally proposed by David Deutsch and Richard Jozsa in 1992, with improvements by Richard Cleve, Artur Ekert, Chiara Macchiavello, and Michele Mosca in 1998, the problem is still the same, but as we mentioned at the end of the previous section, the problem is now extended to more than just a single qubit. The Deutsch-Jozsa algorithm will operate on multiple qubits at once, and, of course, will still provide a quantum speedup compared with classical computing as it would need to calculate each event in series, as we will see in the next section.</p>
    <h3 id="_idParaDest-190" class="heading-3">Understanding the Deutsch-Jozsa problem</h3>
    <p class="normal">In this example, we will extend the previous definition of the problem. Previously, we defined our <a id="_idIndexMarker1295"/>problem on a single-bit value function to determine whether a function was constant or balanced, as follows:</p>
    <p class="center"><img src="../Images/B18420_11_078.png" alt="" width="131" height="25"/><a id="_idIndexMarker1296"/></p>
    <p class="normal">In this case, we will expand the problem to include more than one bit as an input, such that:</p>
    <p class="center"><img src="../Images/B18420_11_079.png" alt="" width="142" height="25"/><a id="_idIndexMarker1297"/></p>
    <p class="normal">You can see from the preceding equation that <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1298"/> is <em class="italic">constant</em> if <img src="../Images/B18420_11_006.png" alt="" width="42" height="25"/><a id="_idIndexMarker1299"/>is the same for all, that is, <img src="../Images/B18420_11_082.png" alt="" width="85" height="25"/><a id="_idIndexMarker1300"/>. Otherwise, <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1301"/> is <em class="italic">balanced</em> if <img src="../Images/B18420_11_084.png" alt="" width="83" height="25"/><a id="_idIndexMarker1302"/> for half of x, and <img src="../Images/B18420_11_085.png" alt="" width="83" height="25"/><a id="_idIndexMarker1303"/> for the other half of x. For example, if we set <em class="italic">n</em> equal to 2 in our input values, <img src="../Images/B18420_11_086.png" alt="" width="52" height="25"/><a id="_idIndexMarker1304"/>, then this will result in four different input values, that is, 00, 01, 10, and 11.</p>
    <p class="normal">Based on these four possible input values of x, to create a balanced function, we can set the first half of the results to 0, such that:</p>
    <table id="table003" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Input 1</strong></p>
          </td>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Input 2</strong></p>
          </td>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Output</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center">0</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center">0</p>
          </td>
          <td class="table-cell">
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">We can set the second half of the results to 1:</p>
    <table id="table004" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Input 1</strong></p>
          </td>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Input 2</strong></p>
          </td>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Output</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
          </td>
          <td class="table-cell">
            <p class="center">1</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center">1</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">If we were <a id="_idIndexMarker1305"/>to solve this classically, we would need <img src="../Images/B18420_11_087.png" alt="" width="73" height="25"/><a id="_idIndexMarker1306"/> queries to determine whether the results are constant or balanced. On the other hand, the Deutsch-Jozsa algorithm will only require one query in order to determine whether the function is constant or balanced, just as in the Deutsch algorithm.</p>
    <h3 id="_idParaDest-191" class="heading-3">Generating a quantum solution using the Deutsch-Jozsa algorithm</h3>
    <p class="normal">To generate <a id="_idIndexMarker1307"/>our quantum <a id="_idIndexMarker1308"/>circuit to implement the Deutsch-Jozsa algorithm, we will use some of the same components as before:</p>
    <ol>
      <li class="numberedList" value="1">Let’s start with our inputs to our black box (oracle). The first input register is an <em class="italic">n</em>-bit string representing the input X. We denote this with a capital X, as most texts refer to single qubit or bit values with a lowercase variable such as <img src="../Images/B18420_11_029.png" alt="" width="23" height="25"/><a id="_idIndexMarker1309"/>, whereas multi-qubits are represented by uppercase variables such as <img src="../Images/B18420_11_089.png" alt="" width="25" height="25"/><a id="_idIndexMarker1310"/>.</li>
    </ol>
    <p class="normal-one">The second <a id="_idIndexMarker1311"/>input register is a single-bit string representing the input y, which, as before, is initialized to 1. This is commonly referred to as an <strong class="keyWord">ancilla qubit</strong>.</p>
    <ol>
      <li class="numberedList" value="2">Next, we define the function of the oracle similar to how we did in the previous form. However, the difference here is that <img src="../Images/B18420_11_029.png" alt="" width="23" height="25"/><a id="_idIndexMarker1312"/> is now a multi-qubit input, <img src="../Images/B18420_11_089.png" alt="" width="25" height="25"/><a id="_idIndexMarker1313"/>. <img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1314"/> is then defined as follows:</li>
    </ol>
    <p class="center"><img src="../Images/B18420_11_093.png" alt="" width="221" height="27"/><a id="_idIndexMarker1315"/></p>
    <p class="normal-one">So, our output would similarly map to two outputs. The first is the same as the first input <img src="../Images/B18420_11_089.png" alt="" width="25" height="25"/><a id="_idIndexMarker1316"/>, and the second output is our function <img src="../Images/B18420_11_095.png" alt="" width="92" height="25"/><a id="_idIndexMarker1317"/>. This results in the following graphical representation:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_09.png" alt="Figure 13.14 – Graphical representation of the Deutsch-Jozsa algorithm " width="451" height="220"/></figure>
    <p class="packt_figref">Figure 11.9: Graphical representation of the Deutsch-Jozsa algorithm</p>
    <p class="normal">Now <a id="_idIndexMarker1318"/>that we have defined <a id="_idIndexMarker1319"/>our components, let’s implement this block digram as a circuit in the next section.</p>
    <h3 id="_idParaDest-192" class="heading-3">Implementing the Deutsch-Jozsa algorithm</h3>
    <p class="normal">In this example we will implement the Deutsch-Jozsa algorithm to determine that a given function <a id="_idIndexMarker1320"/>is constant in one query, whereas determining the same on a classical system will require multiple queries, therefore illustrating how using quantum computing can provide a speedup.</p>
    <p class="normal">In order to implement the Deutsch-Jozsa algorithm, create a new Qiskit notebook and run the boilerplate cell to load up all our Qiskit modules. Once the setup is complete, let’s create our circuit step by step and see how it resolves our problem as we go:</p>
    <ol>
      <li class="numberedList" value="1">First, let’s set our input values. We will start by creating a quantum circuit with two inputs, the first set to <code class="inlineCode">X</code>, which we will create as a 4-qubit input, followed by a single qubit representing <code class="inlineCode">y</code>, which we will initialize to <code class="inlineCode">1</code>. Then we will apply a Hadamard gate to all the input qubits:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Create the quantum circuit with both input registers X,</span>
<span class="hljs-comment"># and y</span>
input_qubits = <span class="hljs-number">4</span>  <span class="hljs-comment"># Refers to our X input register,</span>
<span class="hljs-comment">#4-qubits</span>
ancilla_qubit = <span class="hljs-number">1</span> <span class="hljs-comment"># Refers to our y input register,</span>
<span class="hljs-comment">#1--qubit</span>
<span class="hljs-comment"># Total qubits in our quantum circuit</span>
total_qubits = input_qubits + ancilla_qubit
<span class="hljs-comment"># Generate the circuit</span>
qc = QuantumCircuit(total_qubits, input_qubits)
<span class="hljs-comment"># Set the X qubits in superposition</span>
<span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(input_qubits):
    qc.h(idx)
   
<span class="hljs-comment"># Set the y qubit to 1, then apply a Hadamard</span>
qc.x(input_qubits)
qc.h(input_qubits)
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will <a id="_idIndexMarker1321"/>result in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_10.png" alt="Figure 13.15 – Preparing the input values of our quantum circuit " width="369" height="436"/></figure>
    <p class="packt_figref">Figure 11.10: Preparing the input values of our quantum circuit</p>
    <p class="normal-one">The input state results in the following:</p>
    <p class="center"><img src="../Images/B18420_11_096.png" alt="" width="123" height="27"/><a id="_idIndexMarker1322"/></p>
    <p class="normal-one">When we apply a Hadamard gate to the preceding equation, it breaks out into the following:</p>
    <p class="center"><img src="../Images/B18420_11_097.png" alt="" width="548" height="50"/><a id="_idIndexMarker1323"/></p>
    <p class="normal-one">When we apply a Hadamard gate to the single qubit <img src="../Images/B18420_11_098.png" alt="" width="23" height="25"/><a id="_idIndexMarker1324"/>, this gives us the following equation:</p>
    <p class="center"><img src="../Images/B18420_11_099.png" alt="" width="179" height="50"/><a id="_idIndexMarker1325"/></p>
    <p class="normal-one">Simplifying both <img src="../Images/B18420_11_100.png" alt="" width="63" height="27"/><a id="_idIndexMarker1326"/> and <img src="../Images/B18420_11_101.png" alt="" width="40" height="25"/><a id="_idIndexMarker1327"/> gives us the following equation:</p>
    <p class="center"><img src="../Images/B18420_11_102.png" alt="" width="417" height="63"/><a id="_idIndexMarker1328"/></p>
    <ol>
      <li class="numberedList" value="2">Next, we will create the oracle <img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1329"/> function for our circuit similar to how we created it in the previous section on the Deutsch algorithm. We will use the same here, only this time, we have the ket X, which is more than a single bit of information:</li>
    </ol>
    <p class="center"><img src="../Images/B18420_11_104.png" alt="" width="338" height="63"/><a id="_idIndexMarker1330"/></p>
    <p class="normal-one">The value of x is the bit representation of the bit string X of 0 or 1.</p>
    <ol>
      <li class="numberedList" value="3">Let’s now set our input state using a bit string to represent the balanced <img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1331"/> function—in this case, <code class="inlineCode">'1010'</code>, which we construct by placing an X gate with the set bits <a id="_idIndexMarker1332"/>and Identity gates with the others. This will allow us to determine whether the input is balanced or constant—in this case, since we have an equal number of 1s and 0s, it is balanced. You can also just not add an Identity gate, but for now, we will add one just to visually indicate the <code class="inlineCode">0</code> values of the bit string:
        <pre class="programlisting code-one"><code class="hljs-code"># Set the bit string which we wish to evaluate,
# in this case set '1010', where I indicates value 0,
# and x indicates value 1.
qc.id(0)
qc.x(1)
qc.id(2)
qc.x(3)
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will render the following addition to our circuit, where the added section represents setting the input state <img src="../Images/B18420_11_106.png" alt="" width="54" height="25"/><a id="_idIndexMarker1333"/> based on the bit string <code class="inlineCode">1010</code>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_11.png" alt="Figure 13.16 – State representation |1010 of bit string 1010 " width="396" height="338"/></figure>
    <p class="packt_figref">Figure 11.11: State representation <img src="../Images/B18420_11_106.png" alt="" width="54" height="25"/><a id="_idIndexMarker1334"/> of the bit string 1010</p>
    <ol>
      <li class="numberedList" value="4">Next, we will apply our oracle. In this case, we will set it to a constant output <a id="_idIndexMarker1335"/>where all outputs should be 1s, with zero probability of 0s. We’ll do so by adding CNOT gates, where the Control is applied to each qubit and the Target is set to the last qubit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Set oracle to either constant (output = 0s)</span>
<span class="hljs-comment"># or balanced (output = 1s)</span>
<span class="hljs-comment"># In this example we will choose a balanced function</span>
<span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(input_qubits):
    qc.cx(idx, input_qubits)
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result of this should be as follows, where we set each Control of the CNOT gate to all qubits and the Target to our ancilla qubit, <strong class="keyWord">q</strong><sub class="subscript">4</sub>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_12.png" alt="Figure 13.17 – Representation of the added balanced oracle " width="758" height="386"/></figure>
    <p class="packt_figref">Figure 11.12: Representation of the added balanced oracle</p>
    <ol>
      <li class="numberedList" value="5">Next, we will <a id="_idIndexMarker1336"/>set the closing bit string, which we use to wrap our oracle—in this case, <code class="inlineCode">'1010'</code>:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Set the closing bit string we selected earlier to</span>
<span class="hljs-comment"># evaluate</span>
qc.id(<span class="hljs-number">0</span>)
qc.x(<span class="hljs-number">1</span>)
qc.id(<span class="hljs-number">2</span>)
qc.x(<span class="hljs-number">3</span>)
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will give us the following diagram, just as we expected, where the oracle is bound by the bit string:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_13.png" alt="Figure 13.18 – Oracle bounded by bit string representation " width="759" height="295"/></figure>
    <p class="packt_figref">Figure 11.13: Oracle bounded by the bit string representation</p>
    <ol>
      <li class="numberedList" value="6">Next, we will <a id="_idIndexMarker1337"/>apply the Hadamard gates to all the qubits:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Add the Hadamard gates to complete wrapping the oracle</span>
<span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):
    qc.h(idx)
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result of this is rendered as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_14.png" alt="Figure 13.19 – Completed quantum circuit of the Deutsch-Jozsa algorithm for a balanced function " width="758" height="285"/></figure>
    <p class="packt_figref">Figure 11.14: A complete quantum circuit of the Deutsch-Jozsa algorithm for a balanced function</p>
    <ol>
      <li class="numberedList" value="7">Finally, we will add our measurements so that we can read out the results. We will apply the measurements only to the first four qubits:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Add measurements only to our inputs</span>
qc.measure(<span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>),<span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>))
<span class="hljs-comment"># Draw the circuit</span>
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Therefore, our final quantum circuit should be as follows. Each step in creating the Deutsch-Jozsa algorithm is separated by the barriers, where the first is the <a id="_idIndexMarker1338"/>preparation, the second is to set the bit string <code class="inlineCode">1010</code>, the third is to set our oracle <img src="../Images/B18420_11_028.png" alt="" width="21" height="27"/><a id="_idIndexMarker1339"/>, and then we reverse the first two steps, followed by our measurements:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_15.png" alt="Figure 13.20 – Final circuit for the Deutsch-Jozsa algorithm " width="758" height="227"/></figure>
    <p class="packt_figref">Figure 11.15: Final circuit for the Deutsch-Jozsa algorithm</p>
    <ol>
      <li class="numberedList" value="8">Now that we have created our quantum circuit for the Deutsch-Jozsa algorithm, let’s execute the circuit on a simulator first to visualize what results we get back:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Run the circuit</span>
result = run_on_sampler(qc)
counts = result[0].data.c.get_counts()
<span class="hljs-comment"># Print and plot results</span>
<span class="hljs-built_in">print</span>(counts)
plot_distribution(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As expected, our results returned a probability of 100% of 1s for a balanced circuit:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_16.png" alt="A blue rectangular graph with white lines  Description automatically generated" width="706" height="507"/></figure>
    <p class="packt_figref">Figure 11.16: Results from the simulator of a balanced function</p>
    <p class="normal">As expected, we see that we have a high quasi-probability of <code class="inlineCode">1111</code>. This was computed using a single query, as opposed to the multiple queries that we would have needed to compute the same thing classically.</p>
    <p class="normal">Now that we <a id="_idIndexMarker1340"/>have completed both the Deutsch and Deutsch-Jozsa algorithms, we can see that there is some speedup when compared to classical systems. However, we can also see that there are no practical or real-world examples where we can apply these algorithms. That said, we have understood how the use of superposition and entanglement can speed up certain functions compared to classical techniques. We’ll expand our understanding of algorithms into something that is a bit more of a generalized quantum algorithm, namely, Bernstein-Vazirani, in the next section.</p>
    <h1 id="_idParaDest-193" class="heading-1">Learning about the foundational oracle-based quantum algorithm</h1>
    <p class="normal">We learned in the previous section that the very early quantum algorithms illustrated quantum <a id="_idIndexMarker1341"/>speedup vis-à-vis classical systems in relation to a simple problem. In this section, we will expand on this to look <a id="_idIndexMarker1342"/>at a more complex problem. To do this, we will learn about another oracle-based algorithm, <strong class="keyWord">Bernstein-Vazirani</strong>. The difference between this one and the previous foundational algorithms is that the Bernstein-Vazirani algorithm will identify a hidden bit string using an oracle function in a single query.</p>
    <h2 id="_idParaDest-194" class="heading-2">Learning about the Bernstein-Vazirani algorithm</h2>
    <p class="normal">Originally invented in 1992 by Ethan Bernstein and Umesh Vazirani, the Bernstein-Vazirani <a id="_idIndexMarker1343"/>algorithm extends the Deutsch-Jozsa algorithm to a generalization to find an unknown or secret bit string. Where the Deutsch-Jozsa algorithm worked to solve the problem of determining whether a given function is constant or balanced, the Bernstein-Vazirani algorithm works to determine a secret number by applying a function that maps an input to its output.</p>
    <h3 id="_idParaDest-195" class="heading-3">Understanding the Bernstein-Vazirani problem</h3>
    <p class="normal">The problem that the Bernstein-Vazirani algorithm addresses is straightforward and similar to the <a id="_idIndexMarker1344"/>previous problem. Given an unknown function, or black box (oracle), similar to the Deutsch-Jozsa oracle, an input string of bits results in an output of either 0 or 1. A simple example could be a logical expression that maps the input values to a single output value of either 0 or 1:</p>
    <p class="center"><img src="../Images/B18420_11_109.png" alt="" width="131" height="25"/><a id="_idIndexMarker1345"/></p>
    <p class="normal">For this function <img src="../Images/B18420_11_002.png" alt="" width="13" height="25"/><a id="_idIndexMarker1346"/>, we are guaranteed that the following applies:</p>
    <p class="center"><img src="../Images/B18420_11_111.png" alt="" width="163" height="25"/><a id="_idIndexMarker1347"/></p>
    <p class="normal">From the preceding equation, <em class="italic">s</em> is an unknown or secret string such that:</p>
    <p class="center"><img src="../Images/B18420_11_112.png" alt="" width="83" height="25"/><a id="_idIndexMarker1348"/></p>
    <p class="normal">The problem, therefore, is to find the secret value <em class="italic">s</em>.</p>
    <p class="normal">Solving this classically is the same as the previous examples, where we would have to check each value one bit at a time to determine the secret value, <em class="italic">s</em>. However, as we have seen in the previous examples, we can solve this with a quantum algorithm executing a <a id="_idIndexMarker1349"/>single query. Let’s walk through the example to see how we can solve this using the Bernstein-Vazirani algorithm.</p>
    <h3 id="_idParaDest-196" class="heading-3">Generating a quantum solution using the Bernstein-Vazirani algorithm</h3>
    <p class="normal">The <a id="_idIndexMarker1350"/>Bernstein-Vazirani algorithm is very similar to Deutsch-Jozsa in that it performs the <a id="_idIndexMarker1351"/>same steps to create the quantum circuit for the algorithm:</p>
    <ol>
      <li class="numberedList" value="1">Initialize all <em class="italic">n</em> input qubits to the ground state <img src="../Images/B18420_09_039.png" alt="" width="23" height="25"/><a id="_idIndexMarker1352"/>.</li>
      <li class="numberedList">Initialize the ancilla qubit to the excited state <img src="../Images/B18420_09_034.png" alt="" width="23" height="25"/><a id="_idIndexMarker1353"/>.</li>
      <li class="numberedList">Apply a Hadamard gate to all input qubits and the ancilla qubit, <img src="../Images/B18420_11_115.png" alt="" width="115" height="27"/><a id="_idIndexMarker1354"/>.</li>
      <li class="numberedList">Query the oracle to apply a phase change based on the secret string value using CNOT gates.</li>
      <li class="numberedList">Apply another set of Hadamard gates to the input qubits.</li>
      <li class="numberedList">Measure the input qubits to obtain the secret string.</li>
    </ol>
    <p class="normal">As you can see from the preceding steps, the algorithm is very similar. However, the main differentiator here is <em class="italic">steps 4</em> and <em class="italic">5</em>. When a qubit hits the secret key, we then apply a phase shift, that is, when <img src="../Images/B18420_11_116.png" alt="" width="50" height="25"/><a id="_idIndexMarker1355"/>, where <em class="italic">s</em><sub class="subscript-italic" style="font-style: italic;">i</sub> is the <em class="italic">i</em>th term of the secret string. Then, in <em class="italic">step 5</em>, when we apply the second set of Hadamard gates, the qubit will return from <img src="../Images/B18420_09_035.png" alt="" width="25" height="25"/><a id="_idIndexMarker1356"/> to <img src="../Images/B18420_09_034.png" alt="" width="23" height="25"/><a id="_idIndexMarker1357"/> if <img src="../Images/B18420_11_116.png" alt="" width="50" height="25"/><a id="_idIndexMarker1358"/>, or from <img src="../Images/B18420_11_120.png" alt="" width="25" height="25"/><a id="_idIndexMarker1359"/> to <img src="../Images/B18420_09_039.png" alt="" width="23" height="25"/><a id="_idIndexMarker1360"/> if <img src="../Images/B18420_11_122.png" alt="" width="52" height="25"/><a id="_idIndexMarker1361"/>.</p>
    <p class="normal">Let’s implement these steps one at a time and review the changes to the state. As before, we will use barriers to separate each step so that we can visualize each step along the way.</p>
    <h3 id="_idParaDest-197" class="heading-3">Implementing the Bernstein-Vazirani algorithm</h3>
    <p class="normal">The <a id="_idIndexMarker1362"/>following steps are a step-by-step guide to creating the <strong class="keyWord">Bernstein-Vazirani</strong> algorithm and describe the outcome of each step to help you understand how each step affects the state, which will eventually produce the secret string:</p>
    <ol>
      <li class="numberedList" value="1">Start by creating a new Qiskit notebook with the usual boilerplate cell that will load much of the base Qiskit modules and our account, so that we can execute the quantum circuit on an actual quantum computer.</li>
    </ol>
    <p class="normal-one">First, we will create our quantum circuit, which will be made up of four qubits, and one <a id="_idIndexMarker1363"/>ancilla qubit, and we will define our <strong class="keyWord">secret bit string</strong> (<code class="inlineCode">shh</code>):</p>
    <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Create your secret number</span>
shh = <span class="hljs-string">'1010'</span>
<span class="hljs-comment"># Set the number of qubits to represent secret number and</span>
<span class="hljs-comment"># an ancilla qubit</span>
input_qubits = <span class="hljs-built_in">len</span>(shh)
ancilla_qubit = <span class="hljs-number">1</span>
total_qubits = input_qubits + ancilla_qubit
<span class="hljs-comment"># Create the quantum circuit</span>
qc = QuantumCircuit(total_qubits, input_qubits)
</code></pre>
    <p class="normal-one">The preceding code creates our base quantum circuit, <code class="inlineCode">qc</code>, which we will use to construct <a id="_idIndexMarker1364"/>the Bernstein-Vazirani algorithm. The input qubits must be at least the length of our secret string, which, in this case, is the value <code class="inlineCode">1010</code>. Our input register will need to be at least this many qubits in length. We then added an ancilla qubit, which, in the previous examples, we referred to as the output qubit. Moving forward, we will start referring to this qubit as an ancilla qubit in that it is more of a utility qubit that will not be measured or output to our results.</p>
    <ol>
      <li class="numberedList" value="2">Next, we will add Hadamard gates to the input qubits to ensure that all input qubits are set to a superposition state:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Add Hadamard gates to the input qubits</span>
<span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(input_qubits):
    qc.h(idx)
<span class="hljs-comment"># Draw the input circuit</span>
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will render our quantum circuit as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_17.png" alt="Figure 13.23 – Initializing the input qubits state from |0 to a superposition state, |+ " width="221" height="393"/></figure>
    <p class="packt_figref">Figure 11.17: Initializing the input qubits’ state from <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker1365"/> to a superposition state, <img src="../Images/B18420_11_124.png" alt="" width="31" height="25"/><a id="_idIndexMarker1366"/></p>
    <ol>
      <li class="numberedList" value="3">Next, we <a id="_idIndexMarker1367"/>will need to prepare our ancilla qubit, <strong class="keyWord">q</strong><sub class="subscript">4</sub>, just as we did before, by first initializing it to the state <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker1368"/>, followed by a Hadamard gate, which will prepare the state of the ancilla qubit to <img src="../Images/B18420_11_056.png" alt="" width="31" height="25"/><a id="_idIndexMarker1369"/>:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Prepare the ancilla qubit of the circuit</span>
qc.x(total_qubits-<span class="hljs-number">1</span>)
qc.h(total_qubits-<span class="hljs-number">1</span>)
qc.barrier()
 
<span class="hljs-comment"># Draw the prepared circuit</span>
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will render the following circuit, which we see is the same initialization of our circuit as before. This is how most quantum algorithms are initialized, which allows working with all possible combinations of qubit states. The barrier is added simply to view the various state changes:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_18.png" alt="Figure 13.24 – Initialization of all qubits " width="373" height="416"/></figure>
    <p class="packt_figref">Figure 11.18: Initialization of all qubits</p>
    <p class="normal-one">The state <a id="_idIndexMarker1370"/>at the first barrier is now set to the following, where the input qubits are as follows:</p>
    <p class="center"><img src="../Images/B18420_11_127.png" alt="" width="177" height="60"/><a id="_idIndexMarker1371"/></p>
    <p class="normal-one">The ancilla qubit is set to:</p>
    <p class="center"><img src="../Images/B18420_11_128.png" alt="" width="131" height="52"/><a id="_idIndexMarker1372"/></p>
    <ol>
      <li class="numberedList" value="4">Next, we need to make a quick bit order adjustment before we apply our oracle function. Since the qubits are ordered from right to left, we will need to reverse the order of our secret number:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Before creating the oracle, we need to adjust the</span>
<span class="hljs-comment"># qubits. Since they are ordered from left to right,</span>
<span class="hljs-comment"># we will reverse the secret number's current value</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Secret before reverse: '</span>, shh)
<span class="hljs-comment"># Reverse order</span>
shh = shh[::-<span class="hljs-number">1</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Secret after reverse: '</span>, shh)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As you can see from the following output, the order is now <code class="inlineCode">0101</code>, so we can now apply our oracle function:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Secret before reverse:  <span class="hljs-number">1010</span>
Secret after reverse:  0101
</code></pre>
    <ol>
      <li class="numberedList" value="5">To apply the oracle function, we want to trigger a phase shift each time we hit a <code class="inlineCode">'1'</code> in the secret string. To do that, we will apply a CNOT gate to each qubit, where the Control is set to each qubit and the Target is linked to the ancilla. In our case, the secret string has <code class="inlineCode">'1'</code> set on <strong class="keyWord">qubit 1</strong> (q<sub class="subscript">1</sub>) and <strong class="keyWord">qubit 3</strong> (q<sub class="subscript">3</sub>):
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Now that we have the right order,</span>
<span class="hljs-comment"># let's create the oracle by applying a CNOT,</span>
<span class="hljs-comment"># where the qubits set to '1' are the source</span>
<span class="hljs-comment"># and the target would be the ancilla qubit</span>
<span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(input_qubits):
    <span class="hljs-keyword">if</span> shh[idx] == <span class="hljs-string">'1'</span>:
        qc.cx(idx, input_qubits)
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding <a id="_idIndexMarker1373"/>code renders the quantum circuit up to the oracle:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_19.png" alt="Figure 13.25 – Oracle applying CNOT where the secret string is set to '1' " width="435" height="310"/></figure>
    <p class="packt_figref">Figure 11.19: Oracle applying CNOT where the secret string is set to ‘1’</p>
    <p class="normal-one">Since all our qubits are in a superposition state, by applying the phase shift based on the secret string |S⟩, we get the following equation:</p>
    <p class="center"><img src="../Images/B18420_11_129.png" alt="" width="650" height="54"/><a id="_idIndexMarker1374"/></p>
    <p class="normal-one">Therefore, from the preceding equation, our secret string <img src="../Images/B18420_11_130.png" alt="" width="21" height="25"/><a id="_idIndexMarker1375"/> will apply a phase shift to each qubit where the string is set. This will shift the <img src="../Images/B18420_11_124.png" alt="" width="31" height="25"/><a id="_idIndexMarker1376"/> to <img src="../Images/B18420_11_056.png" alt="" width="31" height="25"/><a id="_idIndexMarker1377"/> whenever the input bit x and the secret string s are equal to 1.</p>
    <ol>
      <li class="numberedList" value="6">Finally, in our last step before applying measurements to the input qubits, we apply another set of Hadamard gates. What this set of Hadamard gates achieves is that it will return the state of each qubit back to either the <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker1378"/> or <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker1379"/> state.</li>
    </ol>
    <p class="normal-one">This is <a id="_idIndexMarker1380"/>entirely dependent on whether the qubit experienced a phase shift while passing through the oracle. If it did not, then the state would change from <img src="../Images/B18420_11_124.png" alt="" width="31" height="25"/><a id="_idIndexMarker1381"/> to <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker1382"/>, or from <img src="../Images/B18420_11_056.png" alt="" width="31" height="25"/><a id="_idIndexMarker1383"/> to <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker1384"/>:</p>
    <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Now let's close up our circuit with Hadamard gates</span>
<span class="hljs-comment"># applied to the input qubits</span>
<span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(input_qubits):
    qc.h(idx)
qc.barrier()
<span class="hljs-comment"># Finally, let's add measurements to our input qubits</span>
qc.measure(<span class="hljs-built_in">range</span>(input_qubits), <span class="hljs-built_in">range</span>(input_qubits))
qc.draw(output='mpl')
</code></pre>
    <p class="normal-one">This will render the following circuit diagram, which completes the steps to implement the Bernstein-Vazirani algorithm along with the measurement operators:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_20.png" alt="Figure 13.26 – Final circuit that implements the Bernstein-Vazirani algorithm " width="760" height="317"/></figure>
    <p class="packt_figref">Figure 11.20: Final circuit that implements the Bernstein-Vazirani algorithm</p>
    <ol>
      <li class="numberedList" value="7">Now that <a id="_idIndexMarker1385"/>the circuit is complete and ready to go, we can execute the circuit on your local simulator and then on a real quantum device:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Execute the circuit and plot the results</span>
result = run_on_sampler(qc)
counts = result[0].data.c.get_counts()
plot_distribution(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results should have a 100% probability for the value of our secret string, as illustrated in the following histogram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_11_21.png" alt="A blue rectangular graph with white text  Description automatically generated" width="673" height="484"/></figure>
    <p class="packt_figref">Figure 11.21: Result identifies with 100% probability the value of our secret string</p>
    <p class="normal">As you can <a id="_idIndexMarker1386"/>see from the preceding result, like the earlier quantum algorithms, we can solve certain problems in a single query, whereas it would take classical systems a few queries to solve. These problems leveraged <strong class="keyWord">phase kickback</strong>, where we used the phase to solve the question of whether the function was balanced or constant.</p>
    <p class="normal">Looking back at the step where we applied the last layer of Hadamard gates, it appears as if the control qubit got flipped instead of the other qubit.</p>
    <p class="normal">In this section, we learned about the foundational oracle-based algorithms and how they illustrate quantum advantage over classical systems to solve problems. We also learned about how oracles and ancilla qubits are leveraged to obtain some of the solutions, which will, in turn, help you understand the more complex algorithms as you expand your knowledge and research. Although these were simple problems that have no commercial value by themselves, they did, however, manage to trigger an interest in the quantum information science field that is still growing to this day.</p>
    <h1 id="_idParaDest-198" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered some of the many quantum algorithms that employ common techniques that are used in a variety of other quantum algorithms.</p>
    <p class="normal">The goal of this chapter was to explore each of them systematically so you could have a good understanding of the problem each algorithm solves. The topics here are, of course, foundational and oracle-based, although the techniques are commonly found in many other quantum algorithms.</p>
    <p class="normal">In the next chapter, we will step away from the oracle-based foundational algorithms and look at another form of algorithm that solves similar problems. However, rather than using phases to identify the solution, they will instead leverage periodicity, which is primarily why they are called <strong class="keyWord">periodic algorithms</strong>.</p>
    <h1 id="_idParaDest-199" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">Which algorithm would you use to determine whether an <em class="italic">n</em>-bit string is balanced?</li>
      <li class="numberedList">Implement the Bernstein-Vazirani algorithm to find the state <code class="inlineCode">170</code>.</li>
      <li class="numberedList">How many oracle functions are there?</li>
    </ol>
    <h1 id="_idParaDest-200" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_11.xhtml"><span class="url">https://packt.link/3FyN1</span></a></p>
    <p class="normal"><img src="../Images/QR_Code2617625996838265933.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>