- en: 5 Using Regular Expressions in Power BI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, many data cleansing tasks involve carrying out complex searches and substitutions
    between strings. The usual search and replace tools are sometimes not enough to
    get the desired results. For instance, let's suppose you need to match strings,
    not in an exact way (for instance, via equality conditions) but using similar
    criteria between them. Knowing how to use tools such as regular expressions (alias
    regex) or fuzzy string searches can make all the difference in projects that require
    high-quality data. Thanks to R and Python, you can add these tools to your arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to regexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating data using regex in Power BI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading complex log files using regex in Power BI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting values from text using regex in Power BI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter requires you to have a working internet connection and **Power
    BI Desktop** already installed on your machine. You need to properly configure
    the R and Python engines and IDEs, as outlined in *Chapter 2*, *Configuring R
    with Power BI*, and *Chapter 3*, *Configuring Python with Power BI*.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to regexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **regular expression** (usually shortened to **regex**) is defined by a series
    of characters that *identify an abstract search pattern*. Essentially, it is a
    mathematical technique that was developed in 1951 by experts of formal language
    and theoretical computer science. It is used to **validate** input data or to
    *search for and extract* information from texts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t know the syntax of a regex, at first glance, it might look really
    tricky:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – An example of a regex pattern](img/file112.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – An example of a regex pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there are online regex visualization tools that make it easier
    to understand patterns (you can find one of them at [https://regexper.com](https://regexper.com)).
    For example, the regex highlighted in *Figure 5.1* can be visualized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A visualization of a regex](img/file113.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – A visualization of a regex
  prefs: []
  type: TYPE_NORMAL
- en: From *Figure 5.2*, it is enough to intuit that the regex in *Figure 5.1* will
    identify email addresses in a piece of text.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use regexes like a pro is certainly not easy, and it is not
    the purpose of this section. Here, we will explain the basic rules that will allow
    you to create simple, yet effective, search patterns. For more details, please
    refer to the *References* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of regexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will try to explain the basic principles of regexes through the use of examples,
    which is perhaps the most immediate way to start using them. Each subsequent subsection
    will explain a function of regexes. To test our regex, we will use the tool made
    available at [https://www.regexpal.com/](https://www.regexpal.com/). Let's get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: Literal characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To include one or more literal characters in a regex, it is necessary to make
    use of the "search" feature. Let''s try searching for the *owe* string inside
    the *May the power of extending Power BI with Python and R be with you!* text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Searching for "owe" using a regex](img/file114.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Searching for "owe" using a regex
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the tool uses the **Global search** **flag** in the search by default.
    A specific flag is indicated with a letter (in our case, **g**) right after the
    regex delimiters, **/.../**. The possible flags that can be used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**g (global)**: This will match all of the occurrences, keeping the index of
    the last match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**m (multiline)**: When enabled, the string anchors (you''ll see them later)
    will match the start and end of a line instead of the whole string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**i (ignore case)**: This searches the pattern irrespective of the case (lower
    or upper) of the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bear in mind that not all programming languages use flag syntax, as mentioned
    earlier. For example, Python''s `re` package (the default one for regexes) provides
    parameters in the `search`, `match`, and `sub` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same for R''s `regex()` function of the `stringr` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use **global modifiers** directly in line with your regex pattern.
    These are `(?i)` for case-insensitive and `(?m)` for multiline. For example, in
    R, you can also run the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that Python doesn’t allow inline global modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Special characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Regex uses 12 special characters (also called **metacharacters**) where each
    has a special meaning. They are the pipe, `|`; the backslash, `\`; the dollar
    sign, `$`; the question mark, `?`; the caret, `^`; the asterisk, `*`; the plus
    sign, `+`; the dot, `.`; the parentheses, `(` and `)`; the opening square bracket,
    `[`; and the opening curly bracket, `{`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to search for one of the previously mentioned characters, you have
    to escape it using the backslash. So, if you want to match exactly `123$`, you
    need to use `123\$` as the regex pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn about the meaning and use of metacharacters.
  prefs: []
  type: TYPE_NORMAL
- en: The ^ and $ anchors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Anchor characters are special characters in that they are used to place the
    regex match at a certain position in the string. The caret, `^`, is used to indicate
    *the beginning of the string* (or line), and the dollar sign, `$`, is used to
    indicate *the end of the string* (or line). An example visualization is worth
    a thousand words:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Case-insensitive and global search](img/file115.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Case-insensitive and global search
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.4*, the "ignore case" flag is set by clicking on the **flags**
    icon and then checking "ignore case." In this way, both the occurrences are matched.
    Now, add a caret, `^`, before the `m` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Case-insensitive and global search using the caret, ^](img/file116.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Case-insensitive and global search using the caret, ^
  prefs: []
  type: TYPE_NORMAL
- en: In this case, only the first occurrence (that is, the one at the beginning of
    the string) is matched.
  prefs: []
  type: TYPE_NORMAL
- en: If you also add a dollar sign at the end of the regex, nothing will be matched,
    as you are asking for a match of the `may the power` string that is at the beginning
    and that also ends the text.
  prefs: []
  type: TYPE_NORMAL
- en: OR operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might need to match one of the individual sets of characters or strings.
    For example, to match any of the `s` and `t` characters after the `ye` string,
    you should use the **character class** of `[st]` inside the `ye[st]` regex. This
    is so that it will match both the `yes` and `yet` strings. Character classes can
    also be used to match an occurrence in a range of characters using the hyphen,
    `-`. For example, `[0-9]` matches a single digit between 0 and 9, while `[A-Z]`
    matches a single uppercase letter from A to Z. Additionally, you can combine multiple
    ranges into one character class. For instance, `[A-Z0-9]` matches only a digit
    or an uppercase letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to match one of two strings, you can use the pipe, `|`, to separate
    them within opening and closing parentheses, such as `(string1|string2)`. Here
    is a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – A complete example of OR operators](img/file117.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A complete example of OR operators
  prefs: []
  type: TYPE_NORMAL
- en: The character class can also be used to match any character different from a
    specific character that is given. This is thanks to the **Negated Character Class**.
  prefs: []
  type: TYPE_NORMAL
- en: Negated character classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The caret that appears just after the opening square bracket negates the content
    of the character class. For example, the `[^"]` regex matches every character
    that isn't a double quote.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand character classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are some character classes that are used very often. For this reason,
    we have defined some abbreviations to allow you to include them in regexes quickly.
    Here is a list of the most used ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\w`: This matches an alphanumeric character, including the underscore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\W`: This is the opposite of `\w`, so it matches a single non-alphanumeric
    character, excluding the underscore. For example, it can match spacing and punctuation
    marks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d`: This matches a single digit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\D`: This is the opposite of `\d`, so it matches a single non-digit character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s`: This matches "whitespace characters" such as space, tab, newline, and
    carriage return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use shorthand character classes relatively often throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Quantifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Quantifiers indicate the number of times a *character* or *expression* must
    be matched. Here is a list of the most used ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+`: This matches what precedes it one or more times. For example, `test\d+`
    will match the `test` string followed by one or more digits. The `test(-\d\d)+`
    regex will match the `test` string followed by one or more times a dash that is
    then followed by two digits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Repeating a group of characters using +](img/file118.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.7 – Repeating a group of characters using +
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{n}`: This matches what precedes it *n* times. For example, `\d{4}` will match
    any integer number made up of 4 digits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,m}`: This matches what precedes it between *n* and *m* times. For example,
    `prod-\d{2,6}` will match the `prod-` string followed by an integer number made
    up of between 2 and 6 digits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n,}`: This matches *n* or more times what precedes it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?`: This matches one or zero times what precedes it. For example, `Mar(ch)?`
    will match both `March` and `Mar`. Alternatively, the `colou?red` regex will match
    both `colored` and `coloured`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: This matches zero or more times what precedes it. For example, `code\d*`
    will match `code`, `code1`, or `code173846`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dot
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The dot corresponds to a single character, regardless of what that character
    is, except for line break characters. It's a very powerful regex metacharacter
    and gives you a chance to be lazy. This is precisely why you have to be careful
    not to abuse it because, sometimes, you might include unintended results in the
    matches.
  prefs: []
  type: TYPE_NORMAL
- en: Greedy and lazy matches
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `+`, `*`, and repetition of `{…}` are **greedy quantifiers**. Greedy means
    that *they will consume the longest possible string*. Let''s suppose that you
    only want to match the tags used in the `<em>Power BI rocks</em>` string. The
    first attempt a beginner would make is to use the `<.+>` regex, which, expressed
    in words, becomes "get the `<`, then get any non-newline character one or more
    times, and finally, in the end, get the `>`." The expected result is made by two
    matches, `<em>` and `</em>`. Let''s take a look at the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The greediness of .+](img/file119.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The greediness of .+
  prefs: []
  type: TYPE_NORMAL
- en: It is evident that the combination of `.+` captures everything contained between
    *the first* occurrence of `<` and the last occurrence of `>`, hence the definition
    of the **greediness** of the quantifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, is it possible to force a greedy quantifier to stop at the first detected
    occurrence of the next character, preventing it from "eating" anything until the
    last occurrence of the same? In other words, is it possible to turn a greedy quantifier
    into a **lazy** one? The answer is "yes," it is possible to do so by adding the
    `?` metacharacter just after the `+`. So, the `<.+>` regex becomes `<.+?>`. Here
    is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Making a greedy quantifier lazy thanks to the ? metacharacter](img/file120.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Making a greedy quantifier lazy thanks to the ? metacharacter
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind, however, that *lazy quantifiers are underperforming*. Whenever
    possible, it is always preferable to *use negated character classes instead*.
    In our example, simply using the `<[^>]+>` regex (that is, a `<` character, any
    non-`>` character one or more times, and a `>` character) will achieve the same
    result without consuming computational resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Using a negated character class instead of a lazy quantifier](img/file121.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Using a negated character class instead of a lazy quantifier
  prefs: []
  type: TYPE_NORMAL
- en: So far, with what you've learned about regexes, you have the minimum foundation
    required to understand the more complex regexes that we'll be using in the next
    few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the validity of email addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you were asked to validate an email address using the concepts you just
    learned, one of your first attempts might look like the following: `^.+@.+\..+$`.
    Translating this regex into spoken language gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: This matches the beginning of the string or a line if the multiline flag
    is enabled.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.+`: This matches any character one or more times, except the line break.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@`: This matches an "@" character.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.+`: This matches any character one or more times, except the line break.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\.`: This matches a "." character.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.+`: This matches any character one or more times, except the line break.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course, this regex will validate a correct email address. But are you sure
    it can also detect the obvious syntactic errors of bad emails? Let''s perform
    a test in [https://www.regexpal.com/](https://www.regexpal.com/) with the wrong
    email, `example@example.c` (the top-level domain, that is, the portion of the
    domain after the dot, must contain a minimum of two characters):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Using a simple regex to validate a wrong email address](img/file122.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Using a simple regex to validate a wrong email address
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that''s not much of an outcome: an obviously wrong email would pass as
    correct. For this reason, it is often necessary to use more complex regexes that
    can respect well-defined syntactic rules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this specific case, we''ll use a specific regex for email validation that
    we often adopt in production. It also takes into account whether the domain IP
    is used. For the purpose of displaying it in full, the regex is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this regex is sure to cause confusion. However, if we attempt
    to break it down into its essential parts, it becomes much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you think that this regex is really complex, take a look at the
    one that takes into account all, and I mean all, the syntactic rules provided
    by the *Standard for the Format of Arpa Internet Text Messages*, which you can
    find at [http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html](http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html)!
    Pretty impressive, huh?
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of an email address is defined as *local-part@domain*. You can find
    the complete specifications on Wikipedia at [https://en.wikipedia.org/wiki/Email_address](https://en.wikipedia.org/wiki/Email_address).
    We are going to match the minimum number of rules (not all of them!) that will
    allow us to validate a significantly different number of email addresses. So,
    considering we''re going to match the domain name or the domain IP, the general
    structure of the regex is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The structure of the complex regex for email validation](img/file123.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The structure of the complex regex for email validation
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.11*, the `{0}`, `{1}`, and `{2}` strings are just placeholders,
    not characters to match. That said, let''s start by defining each token:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{0}` token matches the **local-part** regex of the email. In this case,
    it''s much easier to explain what the *local-part* regex does with a diagram rather
    than with words. In *Figure 5.12*, the labels explain every single detail of the
    subparts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The local-part regex explained in detail](img/file124.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.12 – The local-part regex explained in detail
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bear in mind that *parentheses group regex patterns together*. Parentheses allow
    you to apply regex operators to the entire grouped expression and to get a part
    of the match as a separate item in the result array. The text that corresponds
    to the regex expression is captured within them as a **numbered group**, and it
    can be reused with a numbered backreference. You'll learn how to use this feature
    later.Remember that, in order to have the match of a metacharacter be a real character,
    the escape backslash must be placed before it. So, for example, `\]` will be the
    `]` character.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `{1}` token matches the **domain name** of the email. Again, we will use
    a diagram to explain what the domain name regex does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The domain name regex explained in detail](img/file125.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.13 – The domain name regex explained in detail
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `{2}` token matches the **domain IP** of the email. It is the easier sub-regex,
    and you can find out what it matches by looking at *Figure 5.14*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.14 – The domain IP regex explained in detail](img/file126.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – The domain IP regex explained in detail
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to view the whole regex in a visualization, please refer to the
    following one, which is taken from [https://jex.im/regulex](https://jex.im/regulex):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – A visualization of the whole email regex](img/file127.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – A visualization of the whole email regex
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s proceed with the validation of another important type of information,
    which is very often subject to typing errors: **dates**.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the validity of dates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even in the case of dates, the clueless regex developer might think that the
    following regex is enough to validate dates (in the format of `dd-mm-yyyy`): `^\d{1,2}([\-\/])\d{1,2}\1(?:\d{4}|\d{2})$`.
    There are two new expressions, never before encountered, that are worth exploring:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\1`: This is the **backreference** to group 1\. As we explained in the previous
    section, parentheses also help capture a portion of the string, which you can
    reference during the rest of the regex. In this case, the `\1` syntax indicates
    that, at exactly that position, you can expect the same portion of the string
    matched by the first pair of parentheses. Bear in mind that, in Python, you need
    to use the `\g<1>` syntax instead of `\1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?: … )`: This is the so-called **non-capturing group**. Sometimes, you need
    parentheses to correctly apply a quantifier, but you don''t want their contents
    to be reported in the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Translating the whole regex into spoken language gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: This matches the beginning of the string or a line if the multiline flag
    is enabled.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\d{1,2}`: This matches any digit between 1 and 2 repetitions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`([\-\/])`: This matches any character between `-` and `/`, and captures the
    result as group 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\d{1,2}`: This matches any digit between 1 and 2 repetitions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\1`: This backreferences to the captured group 1\. So, it expects any character
    between `-` and `/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.+`: This matches any character one or more times, except the line break.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(?:\d{4}|\d{2})`: This matches one of the following two alternatives: any
    digit for exactly 4 repetitions and any digit for exactly 2 repetitions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can visualize the whole regex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – A visualization of the first attempt of a regex for validating
    dates](img/file128.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – A visualization of the first attempt of a regex for validating
    dates
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have guessed, this regex validates dates in the following formats:
    `dd-mm-yyyy`, `dd-mm-yy`, `d-m-yyyy`, and `d-m-yy`, using `/` or `-` as separators.
    However, it does not account for errors due to invalid dates, such as February
    30 or September 31.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a regex that also accounts for these errors, then you must use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, viewed in this way, this regex is difficult to interpret. However, looking
    at it "from above" a bit more, you realize that it consists of four alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – The structure of the complex regex for date validation](img/file129.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – The structure of the complex regex for date validation
  prefs: []
  type: TYPE_NORMAL
- en: Also, in this case, the `{0}`, `{1}`, `{2}`, and `{3}` strings are just placeholders,
    not characters to match. That said, let's start by defining the `{0}` token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{0}` token matches the dates that have the 31st day. As in previous cases,
    it''s much easier to explain what this regex does with a visualization rather
    than with words. In *Figure 5.17*, the labels explain every single detail of the
    subparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – The regex part for dates that have the 31st day explained in
    detail](img/file130.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – The regex part for dates that have the 31st day explained in detail
  prefs: []
  type: TYPE_NORMAL
- en: 'The regexes used for the other placeholders are very similar to the one we
    just explained. Therefore, we will leave the explanation of the others as an exercise
    for the reader. If you want to see the whole regex in a visualization, please
    refer to the following diagram, which is taken from [https://jex.im/regulex](https://jex.im/regulex):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – The visualization of the whole date regex](img/file131.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – The visualization of the whole date regex
  prefs: []
  type: TYPE_NORMAL
- en: The regex that we just examined allows the validation of the `dd-mm-yyyy` format
    with all of its variants. In the code, we will demonstrate how you can implement
    date validation in Power BI. Additionally, you will find regexes that allow you
    to validate dates in the `mm-dd-yyyy` and `yyyy-mm-dd` formats with all of their
    variants (where the year is made of two digits, the month is made of one digit,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what's behind the complex regexes presented earlier,
    let's move on to implementing them in Power BI to validate your data.
  prefs: []
  type: TYPE_NORMAL
- en: Validating data using regex in Power BI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To date, Power BI has no native feature in Power Query to perform operations
    via regexes. There are cases when you can't avoid using regexes to extract useful
    information from data in text form. The only way to be able to use regexes is
    through R scripts or Python scripts. The only cons you have in this case is that,
    if you need to publish the report on the Power BI service, to allow Power Query
    to use external R or Python engines, you must also install the on-premises data
    gateway in personal mode.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's get right into it with real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose you work at a retail company where there is a team dedicated to
    identifying fraudulent customers. As soon as a team member identifies a fraudster,
    they fill out an Excel spreadsheet, in which the *Email* and *BannedDate* columns
    are included along with others. Your task is to load the data from this Excel
    file into Power BI and, from other data sources, select only the fraudster's information
    in order to carry out specific analysis on their purchases.
  prefs: []
  type: TYPE_NORMAL
- en: Having the correct fraudster emails within the Excel file is critically important
    to be able to properly join with the other data. Having the correct ban dates
    is also important in order to know whether further orders from that fraudster
    have slipped through the cracks after that date. As you know, the filling in of
    an Excel file by several users is done without any kind of validation of the entered
    data; therefore, it is subject to human errors. So, identifying any errors when
    filling out certain fields and highlighting them allows the fraud team to be able
    to correct them. It is precisely in this case that regexes come to your aid.
  prefs: []
  type: TYPE_NORMAL
- en: Using regex in Power BI to validate emails with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the repository that comes with this book, you can find the `Users.xlsx`
    Excel file inside the `Chapter05` folder. Its content is similar to *Figure 5.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – The content of the Users.xlsx file](img/file132.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – The content of the Users.xlsx file
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus exclusively on the `Email` column. This contains
    the email addresses of fraudsters entered manually by the fraud team, which was
    described at the beginning of the section. These email addresses are not all syntactically
    correct. Moreover, in the Excel file, there is also the `IsEmailValidByDefinition`
    column, whose values (*1=yes*; *0=no*) indicate whether the email in correspondence
    of that value is actually valid or not.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a built-in package, called `re`, which contains all the functions
    you need to work with regexes. Additionally, in `pandas`, there are several methods
    for a series or dataframe object, which accept regexes to find a pattern in a
    string. These methods work in the same way as the ones you will find in Python's
    `re` module. We will be using the `match` method shortly.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about the use of the `r'...'` syntax to create strings. This
    is a **raw string** that allows you to treat the backslash (`\`) as a literal
    character and not as an escape character.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, open your Power BI Desktop, make sure the Python environment you use is
    `pbi_powerquery_env`, and let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the ribbon, click on the **Excel** icon to import data from Excel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Importing data from Excel](img/file133.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.20 – Importing data from Excel
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the **Open** dialog box, select the previously mentioned `Users.xlsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Navigator** window, select the **Users** sheet and then click on
    **Transform Data**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Selecting the Users sheet and clicking on Transform Data](img/file134.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.21 – Selecting the Users sheet and clicking on Transform Data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Transform** menu, and then click on **Run Python Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, copy and paste the following code into the Python script editor and click
    on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also find this Python script in the `01-validate-emails-with-regex-with-python.py`
    file, which is inside the repository that comes with the book, in the `Chapter05\validating-data-using-regex`
    folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Power BI Desktop might display an alert that says the following: **Information
    is required about data privacy**. If so, click on **Continue**, and follow *Step
    2*; otherwise, you can jump to *Step 3*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Privacy levels** window pops up. Here, you'll specify an isolation level
    that defines the degree to which one data source will be isolated from other data
    sources. You could select to *ignore Privacy Levels checks*, but this might expose
    confidential data to unauthorized persons. You will be asked to select a privacy
    level for both the Python script and the dataset loaded from Excel. If you select
    the **Organizational** level for both, everything works fine on Power BI Desktop.
    However, if you plan to publish your reports to the *Power BI service (or Embedded)*,
    you *must use the "Public" level*. For more details, please refer to [http://bit.ly/pbi-privacy-levels](http://bit.ly/pbi-privacy-levels).
    For now, select the **Organizational** level for both options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For now, we are only interested in the `df` dataset. So, click on its **Table**
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Selecting the df dataset as a result of the Python script transformation](img/file135.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.22 – Selecting the df dataset as a result of the Python script transformation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As you can see, the **isEmailValidFromRegex** column is added and it contains
    the Boolean values resulting from the validation of the emails through your regex.
    If you do a check, you will see that they coincide with the values given by definition
    in the **IsEmailValidByDefinition** column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.23 – The regex validation results for emails](img/file136.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.23 – The regex validation results for emails
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your regex did a great job! Now you can go back to the **Home** menu and click
    on **Close & Apply**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Thanks to the **isEmailValidFromRegex** column, you can now appropriately filter
    the correct and incorrect email addresses, perhaps even reporting the matter to
    the fraud team in a dedicated report.
  prefs: []
  type: TYPE_NORMAL
- en: Using regex in Power BI to validate emails with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use R for your email validation using regex, the process is pretty
    much the same except for a few things.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, *R only allows the use of raw strings as of version 4.0.0*. Additionally,
    the syntax for raw strings is slightly different. Instead of `r'...'`, you can
    use `r'(...)'`, `r'[...]'`, or `r'{...}'` indiscriminately. Additionally, instead
    of using numeric placeholders in curly brackets inside the string and then assigning
    them via the `format()` function, as you would in Python, in R, you can simply
    use the variable names in curly brackets directly as placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, the second thing you need to pay attention to is the following:
    you have to be careful so that, in R, not only `]` is considered a metacharacter,
    but also `[`. Therefore, when you want to use both square brackets as literal
    characters, you must prepend the backslash escape character (`\`) for both. Therefore,
    the part of the regex that identifies the character class in the local-part regex
    of the email is slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – You must escape the opened square bracket when it is a literal
    character in R](img/file137.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – You must escape the opened square bracket when it is a literal
    character in R
  prefs: []
  type: TYPE_NORMAL
- en: 'R:Base provides two functions that enable you to use regexes: `grep()` and
    `grepl()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`grepl()` returns a Boolean value based on whether a pattern exists in a character
    string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep()` returns the indexes of the occurrences in the vector of characters
    that contains a match or the specific strings that have the match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we want to adopt the *Tidyverse paradigm*, we will use the wrapper functions
    provided by the **stringr** package, which are `str_detect()` and `str_which()`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having clarified these differences, the process to validate the emails present
    in the `Users.xlsx` Excel file in Power BI using the R script is practically the
    same as that discussed in the previous section where we used Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *Steps 1 to 3* of the previous section to import the data contained in
    the `Users.xlsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Transform** menu, and then click on **Run R Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, copy and paste the following code into the R script editor and click
    on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You also can find this R script in the `02-validate-emails-with-regex-with-r.R`
    file, which is the repository that comes with the book, in the `Chapter05\validating-data-using-regex`
    folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Power BI Desktop might display a notice that says the following: **Information
    is required about data privacy**. If so, click on **Continue**, and follow the
    instructions here. Otherwise, you can jump to *Step 5*. Also, select the *Organizational*
    level for R scripts. Sometimes, you might find that the compatibility levels of
    datasets and analytical scripts are not compatible with each other. In this case,
    Power BI might give you an alert, such as **Formula.Firewall: Query ''XXX'' (step
    ''YYY'') is accessing data sources that have privacy levels which cannot be used
    together. Please rebuild this data combination**. In this case, simply open the
    **Data source settings** window, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Opening the Power Query Data source settings window](img/file138.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.25 – Opening the Power Query Data source settings window
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After that, you have to make sure that all data sources have the same level
    of privacy (in our case, *Organizational*), changing it for each of them, if necessary,
    through the **Edit Permissions…** option:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Editing the privacy permissions for the data sources](img/file139.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.26 – Editing the privacy permissions for the data sources
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, you can refresh the preview data by clicking on **Refresh Preview**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, in this case, we are only interested in the `df` dataset. So,
    click on its **Table** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Selecting the df dataset as a result of the R script transformation](img/file140.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.27 – Selecting the df dataset as a result of the R script transformation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the `isEmailValidFromRegex` column has been added, and it contains
    the Boolean values (transformed to 1 and 0) resulting from the validation of the
    emails through your regex. If you do a check, they coincide with the values given
    by definition in the `IsEmailValidByDefinition` column. Your regex did a great
    job! Now you can go back to the **Home** menu and click on **Close & Apply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks to the `isEmailValidFromRegex` column, you can now appropriately filter
    the correct and incorrect email addresses in your reports.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how to validate dates in Power BI with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using regex in Power BI to validate dates with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example of the dates to validate, we will use the `Users.xlsx` Excel file
    that we used earlier. It contains the *BannedDate* column that has string values
    representing dates in the `mm/dd/yyyy` format with all its variants. Moreover,
    in the Excel file, there is also the *IsDateValidByDefinition* column, whose values
    (*1=yes*; *0=no*) indicate whether the date matching that value is valid or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you already know the Python functions needed to use a regex. So, let’s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *Steps 1 to 3* of the *Using regex in Power BI to validate emails with
    Python* section to import the data contained in the `Users.xlsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Transform** menu and then click on **Run Python Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, copy and paste the following code into the Python script editor and click
    on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find a more exhaustive Python script in the `03-validate-dates-with-regex-with-python.py`
    file, which can be found in the repository that comes with the book, in the `Chapter05\validating-data-using-regex`
    folder. That script handles dates in the formats of `mm-dd-yyyy`, `dd-mm-yyyy`,
    and `yyyy-mm-dd` with all their variances, including both `-` and `/` as separators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If Power BI requires you to provide it with data privacy information, you already
    know how to proceed based on what we've discussed in the previous sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, the `isValidDateFromRegex` column has been added, and it contains
    the Boolean values resulting from the validation of the emails through your regex.
    If you do a check, they coincide with the values given by definition in the `IsDateValidByDefinition`
    column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.28 – The regex validation results for the dates](img/file141.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.28 – The regex validation results for the dates
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your regex did a great job! Now you can go back to the **Home** menu and click
    on **Close & Apply**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Thanks to the `isValidDateFromRegex` column, you can now filter the correct
    and incorrect email addresses and work appropriately with them.
  prefs: []
  type: TYPE_NORMAL
- en: Using regex in Power BI to validate dates with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to use R for your date validation using regex, in this case, the
    process is pretty much the same except for what you have already learned in the
    *Using regex in Power BI to validate emails with R* section. Starting from the
    same `Users.xlsx` Excel file that we used in the previous section, here are the
    steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *Steps 1 to 3* of the *Using regex in Power BI to validate emails with
    Python* section to import the data contained in the `Users.xlsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Transform** menu, and then click on **Run R Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, copy and paste the following code into the R script editor and click
    on **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find a more exhaustive R script in the `04-validate-dates-with-regex-with-r.R`
    file, which can be found in the repository that comes with the book, in the `Chapter05\validating-data-using-regex`
    folder. That script handles dates in the formats of `mm-dd-yyyy`, `dd-mm-yyyy`,
    and `yyyy-mm-dd` with all their variances, including both `-` and `/` as separators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If Power BI requires you to provide it with data privacy information, you already
    know how to proceed based on what we've discussed in the previous sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the **isValidDateFromRegex** column has been added, and it contains
    the Boolean values resulting from the validation of the emails through your regex.
    If you do a check, they coincide with the values given by definition in the **IsDateValidByDefinition**
    column. Your regex did a great job! Now you can go back to the **Home** menu and
    click on **Close & Apply**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks to the **isDateValidFromRegexegex** column, you can now appropriately
    filter the correct and incorrect dates in your reports.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to import the contents of a semi-structured
    log file using Python and R.
  prefs: []
  type: TYPE_NORMAL
- en: Loading complex log files using regex in Power BI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log files are a very useful tool for developers and administrators of computer
    systems. They record what happened to the system, when it happened, and which
    user actually generated the event. Thanks to these files, you can find information
    about any system failure, thus allowing a faster diagnosis of the causes of these
    faults.
  prefs: []
  type: TYPE_NORMAL
- en: Logs are often **semi-structured data**, that is, information that cannot be
    persisted in a relational database in the format in which it is generated. In
    order to be analyzed with the usual tools, first, this data must be transformed
    into a more suitable format.
  prefs: []
  type: TYPE_NORMAL
- en: Since they are not structured data, it is difficult for them to be imported
    into Power BI as is, unless someone has developed a custom connector to do so.
    It is in these scenarios that using a regex in languages such as Python or R can
    help us get the desired results.
  prefs: []
  type: TYPE_NORMAL
- en: Apache access logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s suppose your company has a website published through an Apache web server.
    Your manager asks you to carry out an analysis regarding which web pages of the
    site are the most clicked on. The only way to get this information is to analyze
    the *access log file*. This file records data about all requests made to the web
    server. Here is an example of an Apache access log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – An example of an Apache access log](img/file142.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29 – An example of an Apache access log
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, at first glance, there is a fairly organized structure to the
    information in this log. If no one has customized the output of the Apache log
    files, it uses the **Common Log Format** (**CLF**) by default. You can find a
    real example of an Apache access log in the `apache_logs.txt` file, which is inside
    the repository that comes with this book, in the `Chapter05\loading-complex-log-files-using-regex`
    folder. We found it in the GitHub repository at [http://bit.ly/apache-access-log](http://bit.ly/apache-access-log)
    (click on **Download** to view it).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go ahead and read the documentation of those log files, you will deduce
    that the information recorded in the access log follows the *NCSA extended/combined
    log format*. So, the data that is recorded is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The remote hostname (the IP address).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remote logname (if empty, you'll find a dash; it is not used in the sample
    file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remote user if the request was authenticated (if empty, you'll find a dash).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The datetime that the request was received, in the `[18/Sep/2011:19:18:28 -0400]`
    format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first line of the request made to the server between double quotes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The HTTP status code for the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The size of the response in bytes, excluding the HTTP headers (could be a dash).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Referer` HTTP request header, which contains the absolute or partial address
    of the page making the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `User-Agent` HTTP request header, which contains a string that identifies
    the application, operating system, vendor, and/or version of the requesting user
    agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you know both the nature of the information written in the log and the
    form in which it is written, you can take advantage of the powerful tools provided
    by regexes to better structure this information and import it into Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Apache access logs in Power BI with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, you can find a real example of an Apache access log in
    the `apache_logs.txt` file, which is inside the repository that comes with this
    book, in the `Chapter05\loading-complex-log-files-using-regex` folder. You will
    load the information in this file using a Python script, not a Power BI connector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to what you''ve learned before about regexes and Python, in the `01-apache-access-log-parser-python.py`
    Python script (which you''ll find in the preceding folder), you''ll encounter
    these new constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to read a text file line by line in Python, you'll use the `open(file,
    mode)` functions and the `readlines()` method. Specifically, you're going to read
    the `apache_logs.txt` file as read-only (`'r'`) and read each of its lines to
    store them in a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In regexes, it is possible to refer to groups identified by round brackets
    not only by a numerical index but also *by a name.* This is thanks to **named
    capturing groups**. Usually, the regex syntax that is used to assign a name to
    a group is `(?<group-name>…)`. In Python, it is `(?P<group-name>…)`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, you can define a list of regex parts that can be merged together
    (`join`) using a separator, which is defined by a regex itself (`\s+`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that, in this case, the `re.compile()` function is used since the match
    must be done many times on all lines of the log; therefore, precompiling the regex
    could have computational advantages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pattern matching is done for each line in the log:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `groupdict()` method returns a dictionary with the group names as the key
    and the matched strings as the value for that key. All the dictionaries for each
    line are appended to the `log_data` list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We leave it to the reader to interpret how each individual regex part goes about
    capturing the desired string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve clarified a few points in the code, let''s import the log into
    Power BI:'
  prefs: []
  type: TYPE_NORMAL
- en: In Power BI Desktop, be sure to use the `pbi_powerquery_env` environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Get Data** and select the Python script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the script from the `01-apache-access-log-parser-python.py` file
    into the Python script editor and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select the **df** dataframe from the **Navigator** window and click on
    **Load**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.30 – Selecting the df dataframe returned by the Python script](img/file143.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.30 – Selecting the df dataframe returned by the Python script
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you click on the **Data** icon, you can view the entire log loaded as a
    structured table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.31 – The Apache access log is loaded in Power BI with Python](img/file144.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.31 – The Apache access log is loaded in Power BI with Python
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! Thanks to the power of regex, you've just managed to easily import
    into Power BI what looked like a complex log file to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Apache access logs in Power BI with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you will load the information of the `apache_logs.txt` file,
    but this time, using an R script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to what you''ve learned previously about regexes in R, in the `02-apache-access-log-parser-r.R`
    script (which you''ll find in the same preceding folder), you''ll encounter these
    new constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to read a text file line by line in R, you'll use the `read_lines()`
    function from the `readr` package. Specifically, you're going to read each line
    of the `apache_logs.txt` file in order to persist them to a vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to take full advantage of named capturing groups in R, you need to
    install and use the features of a new package, called **namedCapture**. Thanks
    to this package, both regex syntaxes for named groups are allowed: the standard
    `(?<group-name>…)` regex syntax and the `(?P<group-name>…)` regex syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just as we did in the Python script, in R, you''ll also define a vector of
    regex parts, which you''ll merge with the `paste(..., collapse = ''...'')` function.
    This function has the task of joining regex parts together through the `\s+` separator.
    After merging all of the parts, the `$` character is added to the end of the resulting
    string using the `paste0(…)` function. Remember that raw strings have a different
    syntax in R than in Python. In this case, we will use the `r''{...}''` syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pattern matching is done using the `str_match_named()` function of the `namedCapture`
    package over the whole log vector, using a single-line command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, we leave it to the reader to interpret how each individual regex part
    goes about capturing the desired string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve clarified a few points in the code, let''s import the log into
    Power BI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install the `namedCapture` package. So, open RStudio and
    make sure that the engine being referenced is the latest one in **Global Options**.
    Then, run the following code in a new script to temporarily set CRAN as the repository
    to download packages from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All this has been done to download the latest version of the `namedCapture`
    package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, go to the console and enter and run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open Power BI Desktop, go to **Get Data**, and select the R script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy and paste the script from the `02-apache-access-log-parser-r.R` file into
    the R script editor and then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select the **df** dataframe from the **Navigator** window and click on
    **Load**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.32 – Selecting the df dataframe returned by the R script](img/file145.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.32 – Selecting the df dataframe returned by the R script
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you click on the **Data** icon, you can view the entire log loaded as a
    structured table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.33 – The Apache access log loaded in Power BI with R](img/file146.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.33 – The Apache access log loaded in Power BI with R
  prefs: []
  type: TYPE_NORMAL
- en: Great job! You were able to import a semi-structured log file into Power BI
    even with R.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting values from text using regex in Power BI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last use case we want to present happens very often when dealing with shipments
    of goods to customers. Sometimes, it happens that a fraudster manages to steal
    the goods addressed to a customer; therefore, the customer must be refunded by
    the company. The defrauded customer then contacts Customer Care to request a refund.
    If the management system provided to the Customer Care operator who has to manage
    the case does not allow you to enter the information of the refund in a structured
    way, the operator must resort to the only possible method: the entry of a *free
    text note* associated with the order, which specifies the *amount*, the *reason*
    and the *date* of the refund.'
  prefs: []
  type: TYPE_NORMAL
- en: You already know that information entered in free text is every analyst's nightmare,
    especially when your boss asks you to analyze the very information entered in
    these infamous notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the repository that comes with this book, you can find the `OrderNotes.xlsx`
    Excel file inside the `Chapter05` folder. Its content is similar to the content
    shown in *Figure 5.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34 – Free text notes entered by the operator for some orders](img/file147.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.34 – Free text notes entered by the operator for some orders
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, by looking at the contents of the Excel file, the relevant
    information to extract from the notes is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The refund amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The refund reason
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The refund date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The problem is that the Customer Care operators used a lot of imagination to
    enter this information, without the slightest predetermined rule of how to structure
    it. From this, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The refund amount was entered as *EUR xx.yy*, *EURxx.yy*, *xx.yy EUR*, *€ xx.yy*,
    *xx.yy€*, and *xx.yy €*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "separator" between all of the pieces of information can be made by one
    or more whitespaces or by a dash surrounded by one or more spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The refund date is always in the `dd/mm/yyyy` format (you are lucky here!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The refund reason could contain any text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given all this generality of the entered notes, is it possible to correctly
    extract the information needed for the analysis requested by your boss? The answer
    is certainly "yes" if you know how to best use regexes.
  prefs: []
  type: TYPE_NORMAL
- en: One regex to rule them all
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the experience you gathered during the previous sections, you will immediately
    understand the solution we are going to propose. Consider the following regex
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Currency**: `(?:EUR|€)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separator**: `(?:\s+)?-?(?:\s+)?`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refund amount**: `\d{1,}\.?\d{0,2}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refund reason**: `.*?`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refund date**: `\d{2}[\-\/]\d{2}[\-\/]\d{4}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember the syntax of a **non-capturing group**, `(?:…)`? Well, with this
    syntax, you''re explicitly saying to the regex engine that you don''t want to
    capture the content inside those brackets, as this isn''t important information
    to extract. That said, the final regex is nothing more than multiple alternative
    combinations of these parts, such as the one you can see in *Figure 5.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35 – The full regex structure for extracting information from notes](img/file148.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.35 – The full regex structure for extracting information from notes
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re curious to see it in full, the final complete regex is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement it in Power BI using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using regex in Power BI to extract values with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you saw from *Figure 5.35*, our regex contains named groups that are *reused
    multiple times* within it. Unfortunately, the reuse of the same named group within
    a regex is not supported by the Python `re` module, which, by the way, is the
    module that is also used behind the scenes in `pandas`. In order to use more advanced
    features of regex, such as the previously mentioned *identically named groups*
    or *lookbehind* and *lookahead* syntaxes (which are not explored in this chapter),
    you must use the `regex` module. So, first of all, you have to install it within
    your *pbi_powerquery_env* environment. Then, you have to load the `OrderNotes.xlsx`
    Excel file, which you can find in the `Chapter05` folder, into Power BI Desktop.
    After that, you can transform that dataset using a Python script. So, let''s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Anaconda Prompt, switch to your `pbi_powerquery_env` environment
    using the `conda activate pbi_powerquery_env` command, and then install the `regex`
    package using this code: `pip install regex`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your Power BI Desktop and make sure the referenced Python environment is
    `pbi_powerquery_env` in the **Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the ribbon, click on the **Excel** icon to import data from Excel and open
    the `OrderNotes.xlsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Sheet1** dataset from the **Navigator** window and click on **Transform
    Data**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.36 – Loading the order notes from Excel and transforming the data](img/file149.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.36 – Loading the order notes from Excel and transforming the data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Declare the first row of loaded data as column headers by clicking on **Use
    First Row as Headers**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.37 – The Use First Row as Headers button](img/file150.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.37 – The Use First Row as Headers button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, go to the **Transform** menu and click on **Run Python script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Python script that you can find inside the `01-order-notes-parser-python.py`
    file, which is in the `Chapter05\extracting-values-from-text-using-regex` folder.
    Copy and paste the script into the **Run Python script** editor and then click
    on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are any issues with the compatibility levels of the datasets, simply
    open the **Data source settings** window and set the permissions of each dataset
    to *Organizational* using **Edit Permissions…**. Then, click on **Refresh Preview**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are only interested in the `df` dataset. So, click on its **Table** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.38 – Selecting the df dataset as a result of the Python script transformation](img/file151.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.38 – Selecting the df dataset as a result of the Python script transformation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can see that the resulting table has three more columns, where each one
    is related to a named group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.39 – The values extracted from free notes using regex with Python](img/file152.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.39 – The values extracted from free notes using regex with Python
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, go to the **Home** menu and click on **Close & Apply**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Awesome! You've just managed to reorganize the data contained in the order notes
    using regexes in Python. Your boss will be more than satisfied!
  prefs: []
  type: TYPE_NORMAL
- en: Using regex in Power BI to extract values with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R, we can continue to use the `namedCapture` package to manage named groups
    that are reused multiple times in the same regex. We can do this by putting the
    `(?J)` modifier in front of it (this allows multiple named capturing groups to
    share the same name). Unlike Python, in R, the `str_match_named()` function of
    the `namedCapture` package does not return a one-time result captured by the named
    group. It returns as many columns as the number of times it was used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.40 – Returning as many columns as the number of times the named
    group is used](img/file153.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.40 – Returning as many columns as the number of times the named group
    is used
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we had to further manipulate the result; first, by replacing
    the empty characters with the null value of `NA`, and second, by applying the
    `coalesce()` function of `dplyr`, which merges multiple columns into one by keeping
    the non-null values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We pointed out this limitation to Toby Dylan Hocking, the author of the `namedCapture`
    package, who recently implemented the feature inside the new version of the package,
    named `nc`. You can find details of the implementation at [https://github.com/tdhock/namedCapture/issues/15](https://github.com/tdhock/namedCapture/issues/15).
    The new version of the `nc` package has not yet been published onto CRAN at the
    time of writing. Therefore, we thought it appropriate to keep the use of the `namedCapture`
    package in our code. However, feel free to adopt the new `nc` package for your
    future projects.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'That said, let''s start to extract values from the order notes using R in Power
    BI:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your Power BI Desktop and make sure the referenced R engine is the latest
    one (in our case, this is *MRO 4.0.2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the ribbon, click on the **Excel** icon to import data from Excel, and
    open the `OrderNotes.xlsx` file, which you can find in the `Chapter05` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Sheet1** dataset from the **Navigator** window, and click on **Transform
    Data**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.41 – Loading the order notes from Excel and transforming the data](img/file154.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.41 – Loading the order notes from Excel and transforming the data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Declare the first row of loaded data as column headers by clicking on **Use
    First Row as Headers**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, go to the **Transform** menu and click on **Run R script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the R script that you can find inside the `02-order-notes-parser-r.R` file,
    which is in the `Chapter05\extracting-values-from-text-using-regex` folder. Copy
    and paste the script into the **Run R script** editor and then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are only interested in the `df` dataset. So, click on its **Table** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.42 – Selecting the df dataset as a result of the R script transformation](img/file155.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.42 – Selecting the df dataset as a result of the R script transformation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can see that the resulting table has three more columns, each one related
    to a named group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.43 – The values extracted from the free notes using regex with Python](img/file156.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.43 – The values extracted from the free notes using regex with Python
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, go to the **Home** menu and click on **Close & Apply**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Amazing! You've just demonstrated that you know how to rearrange data contained
    in the order notes using regexes even with R.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the basics of how to use regexes. Using
    the bare minimum, you were able to effectively validate strings representing email
    addresses and dates in Power BI, using both Python and R.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you learned how to extract information from semi-structured log
    files through the use of regexes, and how to import the extracted information,
    in a structured way, into Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how to use regex in Python and R to extract information
    from seemingly unprocessable free text thanks to the real-world case of notes
    associated with sales orders.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to use some de-identification techniques
    in Power BI to anonymize or pseudonymize datasets that show sensitive data about
    individuals in plain text before they are imported into Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For additional reading, please refer to the following books and articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Regular Expressions: The Complete Tutorial, Jan Goyvaerts* ([https://www.princeton.edu/~mlovett/reference/Regular-Expressions.pdf](https://www.princeton.edu/~mlovett/reference/Regular-Expressions.pdf))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Data Privacy Settings In Power BI/Power Query, Part 1: Performance Implications*
    ([https://blog.crossjoin.co.uk/2017/05/24/data-privacy-settings-in-power-bipower-query-part-1-performance-implications/](https://blog.crossjoin.co.uk/2017/05/24/data-privacy-settings-in-power-bipower-query-part-1-performance-implications/))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
