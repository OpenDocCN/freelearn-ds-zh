<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Basic Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Basic Objects</h1></div></div></div><p>The first step of learning R programming is getting familiar with basic R objects and their behavior. In this chapter, you will learn the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating and subsetting atomic vectors (for example, numeric vectors, character vectors, and logical vectors), matrices, arrays, lists, and data frames.</li><li class="listitem" style="list-style-type: disc">Defining and working with functions</li></ul></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"Everything that exists is an object. Everything that happens is a function." -- John Chambers</em></span></p></blockquote></div><p>For example, in statistical analysis, we often feed a set of data to a linear regression model and obtain a group of linear coefficients.</p><p>Provided that there are different types of objects in R, when we do this, what basically happens in R is that we provide a data frame object that holds the set of data, carry it to the linear model function and get a list object consisting of the properties of the regression results, and finally extract a numeric vector, which is another type of object, from the list to represent the linear coefficients.</p><p>Every task involves various different types of objects. Each object has a different goal and behavior. It's important to understand how a basic object works in order to solve real-world problems, especially with more elegant code and fewer steps. More importantly, a more concrete understanding of object behavior allows you to spend more time on working out the solution to your problem than on getting stuck by countless minor problems while producing the right code.</p><p>In the following sections, we will see a variety of basic objects in R that represent different types of data and make it easy to analyze and visualize datasets. You will have a basic understanding of how these objects work and how they interact with each other.</p><div class="section" title="Vector"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Vector</h1></div></div></div><p>A vector is a group of primitive values of the same type. It can be a group of numbers, true/false values, texts, and values of some other type. It is one of the building blocks of all R objects.</p><p>There are several types of vectors in R. They are distinct from each other in the type of elements they store. In the following sections, we will see the most commonly used types of vectors including numeric vectors, logical vectors, and character vectors.</p><div class="section" title="Numeric vector"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Numeric vector</h2></div></div></div><p>A numeric vector is a vector of numeric values. A scalar number is the simplest numeric vector. An example is shown as follows:</p><pre class="programlisting">1.5&#13;
## [1] 1.5</pre><p>A numeric vector is the most frequently used data type and is the foundation of nearly all kinds of data analysis. In other popular programming languages, there are some scalar types such as integer, double, and string, and these scalar types are the building blocks of the container types such as vectors. In R, however, there is no formal definition of scalar types. A scalar number is only a special case of numeric vector, and it's special only because its length is 1.</p><p>When we create a value, it is natural to think of how to store it for future use. To store the value, we can use <code class="literal">&lt;-</code> to assign the value to a symbol. In other words, we create a variable named <code class="literal">x</code> of the value <code class="literal">1.5</code>:</p><pre class="programlisting">x &lt;- 1.5</pre><p>Then, the value is assigned to symbol <code class="literal">x</code>, and we can use <code class="literal">x</code> to represent the value from now on:</p><pre class="programlisting">x&#13;
## [1] 1.5</pre><p>There are multiple ways to create a numeric vector. We can call <code class="literal">numeric()</code> to create a zero vector of a given length:</p><pre class="programlisting">numeric (10)&#13;
## [1] 0 0 0 0 0 0 0 0 0 0</pre><p>We can also use <code class="literal">c()</code> to combine several vectors to make one vector. The simplest case is, for example, to combine several single-element vectors to be a multi-element vector:</p><pre class="programlisting">c(1, 2, 3, 4, 5)&#13;
## [1] 1 2 3 4 5</pre><p>We can also combine a mixture of single-element vectors and multi-element vectors and obtain a vector with the same elements as we previously created:</p><pre class="programlisting">c(1, 2, c(3, 4, 5))&#13;
## [1] 1 2 3 4 5</pre><p>To create a series of consecutive integers, the <code class="literal">:</code> operator will easily do the trick.</p><pre class="programlisting">1:5&#13;
## [1] 1 2 3 4 5</pre><p>Precisely speaking, the preceding code produces an integer vector instead of a numeric vector. In many cases, their difference is not that important. We will cover this topic later.</p><p>A more general way to produce a numeric sequence is <code class="literal">seq()</code>. For example, the following code produces a numeric vector of a sequence from 1 to 10 by increment 2:</p><pre class="programlisting">seq(1, 10, 2)&#13;
## [1] 1 3 5 7 9</pre><p>Functions like <code class="literal">seq()</code> have many arguments. We can call such a function by supplying all the arguments, but it is not necessary in most cases. Most functions provide reasonable default values for some arguments, which makes it easier for us to call them. In this case, we only need to specify the argument that we would like to modify from its default value.</p><p>For example, we can create another numeric vector that starts from <code class="literal">3</code> with the length <code class="literal">10</code> by specifying the <code class="literal">length.out</code> argument:</p><pre class="programlisting">seq(3, length.out = 10)&#13;
## [1] 3 4 5 6 7 8 9 10 11 12</pre><p>A function call like the above uses a named argument <code class="literal">length.out</code> so that other arguments are kept default and only this argument is modified.</p><p>There are many ways in which we can define numeric vectors, but we should always be careful when we use <code class="literal">:</code>, an example is shown as follows:</p><pre class="programlisting">1 + 1:5&#13;
## [1] 2 3 4 5 6</pre><p>As the result shows, <code class="literal">1 + 1:5</code> does not mean a sequence from <code class="literal">2</code> to <code class="literal">5</code>, but from <code class="literal">2</code> to <code class="literal">6</code>. It is because <code class="literal">:</code> has higher priority than <code class="literal">+</code>, which results in evaluating <code class="literal">1:5</code> first and adding <code class="literal">1</code> to each entry, yielding the sequence you see in the result. We will cover the priority of operators later.</p></div><div class="section" title="Logical vector"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Logical vector</h2></div></div></div><p>In contrast to numeric vectors, a logical vector stores a group of <code class="literal">TRUE</code> or <code class="literal">FALSE</code> values. They are basically yes or no to denote the answers to a group of logical questions.</p><p>The simplest logical vectors are <code class="literal">TRUE</code> and <code class="literal">FALSE</code> themselves:</p><pre class="programlisting">TRUE&#13;
## [1] TRUE</pre><p>A more usual way to obtain a logical vector is to ask logical questions about R objects. For example, we can ask R whether 1 is greater than 2:</p><pre class="programlisting">1 &gt; 2&#13;
## [1] FALSE</pre><p>The answer is yes, represented by <code class="literal">TRUE.</code> Sometimes, it is verbose to write <code class="literal">TRUE</code> and <code class="literal">FALSE</code>; so, we can use <code class="literal">T</code> as an abbreviation for <code class="literal">TRUE</code> and <code class="literal">F</code> for <code class="literal">FALSE</code>. If we want to perform multiple comparisons at the same time, we can directly use numeric vectors in the question:</p><pre class="programlisting">c(1, 2) &gt; 2&#13;
## [1] FALSE FALSE</pre><p>R interprets this expression as the element-wise comparison between <code class="literal">c(1, 2)</code> and <code class="literal">2</code>. In other words, it is equivalent to <code class="literal">c(1 &gt; 2, 2 &gt; 2)</code>.</p><p>We can compare two multi-element numeric vectors as long as the length of the longer vector is a multiple of that of the shorter one:</p><pre class="programlisting">c(1, 2) &gt; c(2, 1)&#13;
## [1] FALSE TRUE</pre><p>The preceding code is equivalent to <code class="literal">c(1 &gt; 2, 2 &gt; 1)</code>. To demonstrate how two vectors of different lengths are compared, see the following example::</p><pre class="programlisting">c(2, 3) &gt; c(1, 2, -1, 3)&#13;
## [1] TRUE TRUE TRUE FALSE</pre><p>This may confuse you a bit. The computing mechanism recycles the shorter vector and works like <code class="literal">c(2 &gt; 1, 3 &gt; 2, 2 &gt; -1, 3 &gt; 3)</code>. More specifically, the shorter vector will by recycled to finish all the comparisons for each element in the longer vector.</p><p>In R, several logical binary operators are defined, such as <code class="literal">==</code> to denote equality, <code class="literal">&gt;</code> for greater-than, <code class="literal">&gt;=</code> for greater-or-equals-to, <code class="literal">&lt;</code> for less-than, and <code class="literal">&lt;=</code> for less-than-or-equals-to. Moreover, R provides some other additional logical operators like <code class="literal">%in%</code> to tell whether each element in the left-hand side vector is contained by the right-hand side vector:</p><pre class="programlisting">1 %in% c(1, 2, 3)&#13;
## [1] TRUE&#13;
c(1, 4) %in% c(1, 2, 3)&#13;
## [1] TRUE FALSE</pre><p>You may notice that all the equality operators perform recycling but <code class="literal">%in%</code> does not. Instead, it always works by iterating over the vector on the left and works like <code class="literal">c(1 %in% c(1, 2, 3), 4 %in% c(1, 2, 3))</code> in the preceding example.</p></div><div class="section" title="Character vector"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Character vector</h2></div></div></div><p>A character vector is a group of strings. Here, a character does not mean literally a single letter or symbol in a language, but it means a string like <code class="literal">this is a string</code>. Both double quotation marks and single quotation mark, can be used to create a character vector, as follows:</p><pre class="programlisting">"hello, world!"&#13;
## [1] "hello, world!"&#13;
'hello, world!'&#13;
## [1] "hello, world!"</pre><p>We can also use the combine function <code class="literal">c()</code> to construct a multi-element character vector:</p><pre class="programlisting">c("Hello", "World")&#13;
## [1] "Hello" "World"</pre><p>We can use <code class="literal">==</code> to tell whether two vectors have equal values in corresponding positions; this applies to character vectors too:</p><pre class="programlisting">c("Hello", "World") == c('Hello', 'World')&#13;
## [1] TRUE TRUE</pre><p>The character vectors are equal because <code class="literal">"</code> and <code class="literal">'</code> both work to create a string and do not affect its value:</p><pre class="programlisting">c("Hello", "World") == "Hello, World"&#13;
## [1] FALSE FALSE</pre><p>The previous expression yields both <code class="literal">FALSE</code> because neither <code class="literal">Hello</code> nor <code class="literal">World</code> 
equals <code class="literal">Hello, World</code>. The only difference between the two quotation marks is the behavior when you create a string containing quotation marks.</p><p>If you use <code class="literal">"</code> to create a string (a single-element character vector) containing <code class="literal">"</code> itself, you need to type <code class="literal">"</code> to escape <code class="literal">"</code> inside the string to prevent the interpreter from regarding <code class="literal">"</code> in the string as the close quotation mark of the string.</p><p>The following examples demonstrate the escaping of quotation marks. The code uses <code class="literal">cat()</code> to print the given text:</p><pre class="programlisting">cat("Is "You" a Chinese name?")&#13;
## Is "You" a Chinese name?</pre><p>If you feel that this is not easy to read, you may well use <code class="literal">'</code> to create the string, which can be easier:</p><pre class="programlisting">cat('Is "You" a Chinese name?')&#13;
## Is "You" a Chinese name?</pre><p>In other words, <code class="literal">"</code> allows <code class="literal">'</code> in the string without escaping, and <code class="literal">'</code> allows <code class="literal">"</code> in the string without escaping.</p><p>Now we know the basic things about creating numeric vectors, logical vectors, and character vectors. In fact, we also have complex vectors and raw vectors in R. Complex vectors are vectors of complex values, such as <code class="literal">c(1 + 2i, 2 + 3i)</code>. Raw vectors basically store raw binary data that is represented in the hexadecimal form. These two types of vectors are much less frequently used, but they share many behaviors with the three types of vectors we have covered.</p><p>In the next section, you will learn several ways to access part of a vector. By subsetting vectors, you should begin to understand how different types of vectors can be related to each other.</p></div><div class="section" title="Subsetting vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Subsetting vectors</h2></div></div></div><p>If we want to access some specific entries or a subset of a vector, subsetting a vector means accessing some specific entries or a subset of the vector. In this section, we'll demonstrate various ways to subset a vector.</p><p>First, we create a simple numeric vector and assign it to <code class="literal">v1</code>:</p><pre class="programlisting">v1 &lt;- c(1, 2, 3, 4)</pre><p>Each of the following lines gets a specific subset of <code class="literal">v1</code>.</p><p>For example, we can get the second element:</p><pre class="programlisting">v1[2]&#13;
## [1] 2</pre><p>We can get the second to fourth elements:</p><pre class="programlisting">v1[2:4]&#13;
## [1] 2 3 4</pre><p>We can get all elements except the third one:</p><pre class="programlisting">v1[-3]&#13;
## [1] 1 2 4</pre><p>The patterns are clear—we can put any numeric vector inside the square brackets after the vector to extract a corresponding subset:</p><pre class="programlisting">a &lt;- c(1, 3)v1[a]&#13;
## [1] 1 3</pre><p>All the preceding examples perform subsetting by position, that is, we get a subset of a vector by specifying the positions of elements. Using negative numbers will exclude those elements. One thing to notice is that you can't use positive numbers and negative numbers together:</p><pre class="programlisting">v1[c(1, 2, -3)]&#13;
## Error in v1[c(1, 2, -3)]: only 0's may be mixed with negative subscripts</pre><p>What if we subset the vector using positions beyond the range of the vector? The following example tries to get a subset of <code class="literal">v1</code> from the third element to the nonexisting sixth element:</p><pre class="programlisting">v1[3:6]&#13;
## [1] 3 4 NA NA</pre><p>As we can see, the nonexisting positions end up in missing values represented by NA. In real-world data, missing values are common. The good part is that all arithmetic calculations with NA also result in NA for consistency. On the other hand, however, it takes extra effort to deal with data because it may not be safe to assume that the data contains no missing values.</p><p>Another way to subset a vector is using logical vectors. We can supply an equal-length logical vector to determine whether each entry should be extracted:</p><pre class="programlisting">v1[c(TRUE, FALSE, TRUE, FALSE)]&#13;
## [1] 1 3</pre><p>More than subsetting, we can overwrite a specific subset of a vector like this:</p><pre class="programlisting">v1[2] &lt;- 0</pre><p>In this case, <code class="literal">v1</code> becomes the following:</p><pre class="programlisting">v1&#13;
## [1] 1 0 3 4</pre><p>We can also overwrite multiple elements at different positions at the same time:</p><pre class="programlisting">v1[2:4] &lt;- c(0, 1, 3)</pre><p>Now, v1 becomes the following:</p><pre class="programlisting">v1&#13;
## [1] 1 0 1 3</pre><p>Like subsetting, logical selectors are also accepted for overwriting:</p><pre class="programlisting">v1[c(TRUE, FALSE, TRUE, FALSE)] &lt;- c(3, 2)</pre><p>As you may expect, <code class="literal">v1</code> becomes the following:</p><pre class="programlisting">v1&#13;
## [1] 3 0 2 3</pre><p>A useful implication of this operation is selecting entries by logical criterion. For example, the following code picks out all elements that are not greater than <code class="literal">2</code> in <code class="literal">v1</code>:</p><pre class="programlisting">v1[v1 &lt;= 2]&#13;
## [1] 0 2</pre><p>A more complex selection criterion also works. The following example picks out all elements of <code class="literal">v1</code> that satisfy <span class="emphasis"><em>x<sup>2 </sup>- x + 1 <span class="underline">&gt;</span> 0</em></span> :</p><pre class="programlisting">v1[v1 ^ 2 - v1 + 1 &gt;= 0]&#13;
## [1] 3 0 2 3</pre><p>To replace all entries that satisfy <code class="literal">x &lt;= 2</code> with <code class="literal">0</code>, we can call the following:</p><pre class="programlisting">v1[v1 &lt;= 2] &lt;- 0</pre><p>As you may expect, <code class="literal">v1</code> becomes the following:</p><pre class="programlisting">v1&#13;
## [1] 3 0 0 3</pre><p>If we overwrite the vector at a nonexisting entry, the vector will automatically expand with the unassigned value being NA as missing values:</p><pre class="programlisting">v1[10] &lt;- 8
v1&#13;
## [1] 3 0 0 3 NA NA NA NA NA 8</pre></div><div class="section" title="Named vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Named vectors</h2></div></div></div><p>A named vector is not a specific type of vector parallel to a numeric or logical vector. It is a vector with names corresponding to the elements. We can give names to a vector when we create it:</p><pre class="programlisting">x &lt;- c(a = 1, b = 2, c = 3)
x&#13;
## a b c
## 1 2 3</pre><p>Then, we can access the elements with a single-valued character vector:</p><pre class="programlisting">x["a"]&#13;
## a
## 1</pre><p>We can also get multiple elements with a character vector:</p><pre class="programlisting">x[c("a", "c")]&#13;
## a c
## 1 3</pre><p>If the character vector has duplicate elements, the selection will result in selecting duplicate elements:</p><pre class="programlisting">x[c("a", "a", "c")]&#13;
## a a c
## 1 1 3</pre><p>In addition to this, all other operations to a vector also perfectly work for named vectors.</p><p>We can get the names of a vector with <code class="literal">names()</code>:</p><pre class="programlisting">names(x)&#13;
## [1] "a" "b" "c"</pre><p>The names of a vector are not fixed. We can change the names of a vector by assigning another character vector to its names.</p><pre class="programlisting">names(x) &lt;- c("x", "y", "z")&#13;
x["z"]&#13;
## z
## 3</pre><p>If the names are no longer needed, we can simply remove the vector's names using NULL, a special object that represents undefined value:</p><pre class="programlisting">names(x) &lt;- NULL&#13;
x&#13;
## [1] 1 2 3</pre><p>You may wonder what happens when the name does not exist at all. Let's experiment with the original <code class="literal">x</code> value:</p><pre class="programlisting">x &lt;- c(a = 1, b = 2, c = 3)
x["d"]&#13;
## &lt;NA&gt;
## NA</pre><p>By intuition, accessing a nonexisting element should produce an error. However, the result is not an error but a vector of a single missing value with a missing name:</p><pre class="programlisting">names(x["d"])&#13;
## [1] NA</pre><p>If you provide a character vector in which some names exist but others do not, the resulting vector will preserve the length of the selection vector:</p><pre class="programlisting">x[c("a", "d")]&#13;
## a &lt;NA&gt;
## 1 NA</pre></div><div class="section" title="Extracting an element"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Extracting an element</h2></div></div></div><p>While <code class="literal">[]</code> creates a subset of a vector, <code class="literal">[[]]</code> extracts an element from a vector. A vector is like ten boxes of candy, <code class="literal">[]</code> gets you three boxes of candy, but <code class="literal">[[]]</code> opens a box and gets you a candy from it.</p><p>For simple vectors, using <code class="literal">[]</code> and <code class="literal">[[]]</code> to get one element will produce the same result. However, in some cases, they have different behaviors. For example, subsetting a named vector using one entry and extracting an element from it will produce different results:</p><pre class="programlisting">x &lt;- c(a =  1, b = 2, c = 3)
x["a"]&#13;
## a
## 1&#13;
x[["a"]]&#13;
## [1] 1</pre><p>The metaphor of candy boxes makes it easier to understand. The <code class="literal">x["a"]</code> argument gives you the box of candy labeled <code class="literal">"a"</code>, while <code class="literal">x[["a"]]</code> gives you the candy in the box labeled <code class="literal">"a"</code>.</p><p>Since <code class="literal">[[]]</code> only extracts one element, it does not work with vectors of more than one element:</p><pre class="programlisting">x[[c(1, 2)]]&#13;
## Error in x[[c(1, 2)]]: attempt to select more than one element</pre><p>Also, it does not work with negative integers meaning excluding elements at certain positions:</p><pre class="programlisting">x[[-1]]&#13;
## Error in x[[-1]]: attempt to select more than one element</pre><p>We already know that subsetting a vector with a nonexisting position or name will produce missing values. However, <code class="literal">[[]]</code> simply does not work when we extract an element with a position beyond the range, nor does it work with a nonexisting name:</p><pre class="programlisting">x[["d"]]&#13;
## Error in x[["d"]]: subscript out of bounds</pre><p>For many beginners, it may be confusing to see both <code class="literal">[[]]</code> and <code class="literal">[]</code> used in the code and it is easy to misuse them. Just remember the metaphor of the candy boxes.</p></div><div class="section" title="Telling the class of vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Telling the class of vectors</h2></div></div></div><p>Sometimes we need to tell which kind of vector we are dealing with before taking an action. The <code class="literal">class()</code> function tells us the class of any R object:</p><pre class="programlisting">class(c(1, 2, 3))&#13;
## [1] "numeric"&#13;
class(c(TRUE, TRUE, FALSE))&#13;
## [1] "logical"&#13;
class(c("Hello", "World"))&#13;
## [1] "character"</pre><p>If we need to ensure that an object is indeed a vector of a specific class, we can use <code class="literal">is.numeric</code>, <code class="literal">is.logical</code>, <code class="literal">is.character</code>, and some other functions with similar names:</p><pre class="programlisting">is.numeric(c(1, 2, 3))&#13;
## [1] TRUE&#13;
is.numeric(c(TRUE, TRUE, FALSE))&#13;
## [1] FALSE&#13;
is.numeric(c("Hello", "World"))&#13;
## [1] FALSE</pre></div><div class="section" title="Converting vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Converting vectors</h2></div></div></div><p>Different classes of vectors can be coerced to a specific class of vector. For example, some data are string representation of numbers, such as <code class="literal">1</code> and <code class="literal">20</code>. If we leave these strings as they are, we won't be able to perform numeric calculations with them. Fortunately, these two strings can be converted to numeric vectors. This will make R regard them as numbers rather than strings so that we can do the math with them.</p><p>To demonstrate a typical conversion, we first create a character vector:</p><pre class="programlisting">strings &lt;- c("1", "2", "3")
class(strings)&#13;
## [1] "character"</pre><p>As I mentioned, strings cannot be used to do maths directly:</p><pre class="programlisting">strings + 10&#13;
## Error in strings + 10: non-numeric argument to binary operator</pre><p>We can use <code class="literal">as.numeric()</code> to convert the character vector to a numeric vector:</p><pre class="programlisting">numbers &lt;- as.numeric(strings)&#13;
numbers&#13;
## [1] 1 2 3&#13;
class(numbers)&#13;
## [1] "numeric"</pre><p>Now we can do maths with numbers:</p><pre class="programlisting">numbers + 10&#13;
## [1] 11 12 13</pre><p>Similar to <code class="literal">is.*</code> functions (for example, <code class="literal">is.numeric</code>, <code class="literal">is.logical</code>, and <code class="literal">is.character</code>) that check the class of a given object, we can use the <code class="literal">as.*</code> function family to convert a vector from its original class to another:</p><pre class="programlisting">as.numeric(c("1", "2", "3", "a"))&#13;
## Warning: NAs introduced by coercion&#13;
## [1] 1 2 3 NA&#13;
as.logical(c(-1, 0, 1, 2))&#13;
## [1] TRUE FALSE TRUE TRUE&#13;
as.character(c(1, 2, 3))&#13;
## [1] "1" "2" "3"&#13;
as.character(c(TRUE, FALSE))&#13;
## [1] "TRUE" "FALSE"</pre><p>It seems that each type of vector can be somehow converted to all other types. However, the conversion follows a set of rules.</p><p>The first line in the preceding block of code attempts to convert the character vector to a numeric vector, just as we did in the previous example. Obviously, the last element <code class="literal">a</code> cannot be converted to a number. The conversion is done except for the last element, so a missing value is produced instead.</p><p>As for converting a numeric vector to a logical vector, the rule is that only <code class="literal">0</code> corresponds to <code class="literal">FALSE</code> and all non-zero numbers will produce <code class="literal">TRUE</code>.</p><p>Each kind of vector can be converted to a character vector since everything has a character representation. However, if a numeric vector or a logical vector is coerced to a character vector, it cannot be directly involved in the arithmetic operations with other numeric or logical vectors unless it is converted back. That is why the following code does not work, as I have just mentioned:</p><pre class="programlisting">c(2, 3) + as.character(c(1, 2))&#13;
## Error in c(2, 3) + as.character(c(1, 2)): non-numeric argument to binary operator</pre><p>From the preceding examples, I have stressed that although R does not impose strong typing rules, it does not mean that R is smart enough to do exactly what you want it to do automatically. In most cases, it is better to ensure that the type of vectors are correct in computations; otherwise, an unexpected error will occur. In other words, only when you get the right type of data objects can you do the right math.</p></div><div class="section" title="Arithmetic operators for numeric vectors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Arithmetic operators for numeric vectors</h2></div></div></div><p>The arithmetic operations of numeric vectors are very simple. They basically follow two rules: Computing in an element-wise manner and recycling the shorter vector. The following examples demonstrate the behavior of the operators working with numeric vectors:</p><pre class="programlisting">c(1, 2, 3, 4) + 2&#13;
## [1] 3 4 5 6&#13;
c(1, 2, 3) - c(2, 3, 4)&#13;
## [1] -1 -1 -1&#13;
c(1, 2, 3) * c(2, 3, 4)&#13;
## [1] 2 6 12&#13;
c(1, 2, 3) / c(2, 3, 4)&#13;
## [1] 0.5000000 0.6666667 0.7500000&#13;
c(1, 2, 3) ^ 2&#13;
## [1] 1 4 9&#13;
c(1, 2, 3) ^ c(2, 3, 4)&#13;
## [1] 1 8 81&#13;
c(1, 2, 3, 14) %% 2&#13;
## [1] 1 0 1 0</pre><p>Although vectors can have names, the operations do not function with corresponding names. Only the names of vectors on the left-hand side will remain and the names of those on the right-hand side will be ignored:</p><pre class="programlisting">c(a = 1, b = 2, c = 3) + c(b = 2, c = 3, d = 4)&#13;
## a b c
## 3 5 7&#13;
c(a = 1, b = 2, 3) + c(b = 2, c = 3, d = 4)&#13;
## a b
## 3 5 7</pre><p>We saw some basic behaviors of numeric vectors, logical vectors, and character vectors. They are the most commonly used data structures and are the building blocks of a wide variety of other useful objects. One of them is matrix, which is intensively used in the formulation of statistical and econometric theories, and it is very useful in representing two-dimensional data and solving linear systems. In the next chapter, we will see how we can create a matrix in R and how it is deeply rooted in vectors.</p></div></div></div>
<div class="section" title="Matrix"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Matrix</h1></div></div></div><p>A matrix is a vector represented and accessible in two dimensions. Therefore, what applies to vectors is most likely to apply to a matrix. For example, each type of vector (for example, numeric vector or logical vectors) has its matrix version, that is, there are numeric matrices, logical matrices, and so on.</p><div class="section" title="Creating a matrix"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Creating a matrix</h2></div></div></div><p>We can call <code class="literal">matrix()</code> to create a matrix from a vector by setting up one of its two dimensions:</p><pre class="programlisting">matrix(c(1, 2, 3, 2, 3, 4, 3, 4, 5), ncol = 3)&#13;
##      [,1] [,2] [,3]
## [1,]   1    2    3
## [2,]   2    3    4
## [3,]   3    4    5</pre><p>By specifying <code class="literal">ncol = 3</code>, we mean that the provided vector should be regarded as a matrix with 3 columns (and 3 rows automatically). You may feel the original vector is not as straightforward as its representation. To make the code more user-friendly, we can write the vector in multiple lines:</p><pre class="programlisting">matrix(c(1, 2, 3,  4, 5, 6,  7, 8, 9), nrow = 3, byrow = FALSE)&#13;
##     [,1] [,2] [,3]
## [1,]  1    4    7
## [2,]  2    5    8
## [3,]  3    6    9&#13;
matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = TRUE)&#13;
##      [,1] [,2] [,3]
## [1,]   1    2    3
## [2,]   4    5    6
## [3,]   7    8    9</pre><p>Often, we may need to create a diagonal matrix. Here, <code class="literal">diag()</code> is the most handy way to do this:</p><pre class="programlisting">diag(1, nrow = 5)&#13;
##      [,1] [,2] [,3] [,4] [,5]
## [1,]   1    0    0    0    0
## [2,]   0    1    0    0    0
## [3,]   0    0    1    0    0
## [4,]   0    0    0    1    0
## [5,]   0    0    0    0    1</pre></div><div class="section" title="Naming rows and columns"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Naming rows and columns</h2></div></div></div><p>By default, creating a matrix does not automatically give names to its rows and columns. Sometimes, it is useful and straightforward to do so when different rows and columns have different meanings. We can give row names and/or column names when creating the matrix:</p><pre class="programlisting">matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = TRUE, dimnames = list(c("r1", "r2", "r3"), c("c1", "c2", "c3")))&#13;
##    c1 c2 c3
## r1  1  2  3
## r2  4  5  6
## r3  7  8  9</pre><p>Alternatively, we can use row names and/or column names after the matrix is created:</p><pre class="programlisting">m1 &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3)&#13;
rownames(m1) &lt;- c("r1", "r2", "r3")
colnames(m1) &lt;- c("c1", "c2", "c3")</pre><p>Here, we encounter two new things: a list and a type of function, such as <code class="literal">rownames(x) &lt;-</code>. We will discuss them later in this chapter.</p></div><div class="section" title="Subsetting a matrix"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Subsetting a matrix</h2></div></div></div><p>Just as we deal with vectors, we need not only create matrices but also extract data from a matrix. This is called <span class="strong"><strong>matrix subsetting</strong></span>.</p><p>Note that a matrix is a vector that is represented and accessible in two dimensions; we not only view a matrix in two dimensions, but also access it with a two-dimensional accessor <code class="literal">[,]</code>, which is quite similar to the one-dimensional accessor, <code class="literal">[]</code> , for subsetting vectors.</p><p>To use it, we can supply two vectors for each dimension to determine a subset of a matrix. The first argument in the square bracket is the row selector, and the second is the column selector. As we tried in subsetting vectors, we can use numeric vectors, logical vectors, and character vectors in the two dimensions.</p><p>The following code demonstrates the various ways to subset the following matrix:</p><pre class="programlisting">m1&#13;
##    c1 c2 c3
## r1  1  4  7
## r2  2  5  8
## r3  3  6  9</pre><p>We can extract only one element in the first row and the second column:</p><pre class="programlisting">m1[1, 2]&#13;
## [1] 4</pre><p>We can subset it with a range of positions:</p><pre class="programlisting">m1[1:2, 2:3]&#13;
##    c2 c3
## r1  4  7
## r2  5  8</pre><p>If one dimension is left blank, all the values in that dimension will be selected:</p><pre class="programlisting">m1[1,]&#13;
## c1 c2 c3 
## 1  4  7&#13;
m1[,2]&#13;
## r1 r2 r3 
## 4  5  6&#13;
m1[1:2,]&#13;
##    c1 c2 c3
## r1  1  4  7
## r2  2  5  8&#13;
m1[, 2:3]&#13;
##    c2 c3
## r1  4  7
## r2  5  8
## r3  6  9</pre><p>Negative numbers exclude positions in a subsetting matrix, which is exactly the same as working with vectors:</p><pre class="programlisting">m1[-1,]&#13;
##    c1 c2 c3
## r2 2  5  8
## r3 3  6  9&#13;
m1[,-2]&#13;
##    c1 c3
## r1  1  7
## r2  2  8
## r3  3  9</pre><p>Note that the matrix has row names and column names, and we can use character vectors to subset it:</p><pre class="programlisting">m1[c("r1", "r3"), c("c1", "c3")]&#13;
##    c1 c3
## r1  1  7
## r3  3  9</pre><p>Note again that a matrix is a vector represented and accessible in two dimensions; however, it is still a vector in its nature. This allows us to use a one-dimensional accessor for vectors to subset a matrix:</p><pre class="programlisting">m1[1]&#13;
## [1] 1&#13;
m1[9]&#13;
## [1] 9&#13;
m1[3:7]&#13;
## [1] 3 4 5 6 7</pre><p>Since a vector only contains entries of the same type, so does a matrix. Therefore, their operations are quite similar. If you type an inequality, it will return another logical matrix of equal size:</p><pre class="programlisting">m1 &gt; 3&#13;
##       c1   c2   c3
## r1 FALSE TRUE TRUE
## r2 FALSE TRUE TRUE
## r3 FALSE TRUE TRUE</pre><p>We can use an equal-sized logical matrix for subsetting as if it is a vector:</p><pre class="programlisting">m1[m1 &gt; 3]&#13;
## [1] 4 5 6 7 8 9</pre></div><div class="section" title="Using matrix operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Using matrix operators</h2></div></div></div><p>All arithmetic operators for vectors also work with matrices as if they were vectors. These operators perform calculations element-wise, except for matrix-only operators, such as matrix product,  <code class="literal">%*%</code>:</p><pre class="programlisting">m1 + m1&#13;
##    c1 c2 c3
## r1  2  8 14
## r2  4 10 16
## r3  6 12 18&#13;
m1 - 2 * m1&#13;
##    c1 c2 c3
## r1 -1 -4 -7
## r2 -2 -5 -8
## r3 -3 -6 -9&#13;
m1 * m1&#13;
##   c1 c2 c3
## r1 1 16 49
## r2 4 25 64
## r3 9 36 81&#13;
m1 / m1&#13;
##    c1 c2 c3
## r1 1  1  1
## r2 1  1  1
## r3 1  1  1&#13;
m1 ^ 2&#13;
##    c1 c2 c3
## r1  1 16 49
## r2  4 25 64
## r3  9 36 81&#13;
m1 %*% m1&#13;
##     c1 c2 c3
## r1  30 66 102
## r2  36 81 126
## r3  42 96 150</pre><p>We can also transpose a matrix using <code class="literal">t()</code>:</p><pre class="programlisting">t(m1)&#13;
##    r1 r2 r3
## c1 1  2  3
## c2 4  5  6
## c3 7  8  9</pre><p>Vectors and matrices are sufficient for many use cases. However, some particular problems need a data structure with even higher dimensions. In this next section, we will briefly introduce arrays and you will see how these data structures share similar behaviors.</p></div></div>
<div class="section" title="Array"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Array</h1></div></div></div><p>An array is a natural extension to a matrix in its number of dimensions. More specifically, an array is a vector that is represented and accessible in a given number of dimensions (mostly more than two dimensions).</p><p>If you are already familiar with vectors and matrices, you won't be surprised to see how arrays behave.</p><div class="section" title="Creating an array"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Creating an array</h2></div></div></div><p>To create an array, we call <code class="literal">array()</code> by supplying a vector of data, how this data is arranged in different dimensions, and sometimes the names of the rows and columns of these dimensions.</p><p>Suppose we have some data (10 integers from 0 to 9) and we need to arrange them in three dimensions: 1 for the first dimension, 5 for the second, and 2 for the third:</p><pre class="programlisting">a1 &lt;- array(c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), dim = c(1, 5, 2))&#13;
a1&#13;
## , , 1
## 
##     [,1] [,2] [,3] [,4] [,5]
## [1,]  0    1    2    3    4
## 
## , , 2
## 
##     [,1] [,2] [,3] [,4] [,5]
## [1,]  5    6    7    8    9</pre><p>We can clearly see how we can access these entries by looking at the notations around them.</p><p>Moreover, we can add names for these dimensions when we create the array:</p><pre class="programlisting">a1 &lt;- array(c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), dim = c(1, 5, 2), dimnames = list(c("r1"), c("c1", "c2", "c3", "c4", "c5"), c("k1", "k2")))&#13;
a1&#13;
## , , k1
## 
##    c1 c2 c3 c4 c5
## r1  0  1  2  3  4
## 
## , , k2
## 
##    c1 c2 c3 c4 c5
## r1  5  6  7  8  9</pre><p>Alternatively, for an array that is already created, we can call <code class="literal">dimnames(x) &lt;-</code> to setup the names for each dimension by supplying a list of several character vectors:</p><pre class="programlisting">a0 &lt;- array(c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), dim = c(1, 5, 2))&#13;
dimnames(a0) &lt;- list(c("r1"), c("c1", "c2", "c3", "c4", "c5"), c("k1", "k2"))
a0&#13;
## , , k1
## 
##   c1 c2 c3 c4 c5
## r1 0  1  2  3  4
## 
## , , k2
## 
##   c1 c2 c3 c4 c5
## r1 5  6  7  8  9</pre></div><div class="section" title="Subsetting an array"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Subsetting an array</h2></div></div></div><p>The principle of subsetting an array is exactly the same as subsetting a matrix. Here, we can supply a vector for each dimension to extract a subset of an array:</p><pre class="programlisting">a1[1,,]&#13;
##    k1 k2
## c1  0 5
## c2  1 6
## c3  2 7
## c4  3 8
## c5  4 9&#13;
a1[, 2,]&#13;
## k1 k2 
## 1 6&#13;
a1[,,1]&#13;
## c1 c2 c3 c4 c5 
## 0  1  2  3  4&#13;
a1[1, 1, 1]&#13;
## [1] 0&#13;
a1[1, 2:4, 1:2]&#13;
##    k1 k2
## c2 1  6
## c3 2  7
## c4 3  8&#13;
a1[c("r1"), c("c1", "c3"), "k1"]&#13;
## c1 c3 
## 0  2</pre><p>As you may notice, atomic vectors, matrices, and arrays share almost the same set of behaviors. A fundamental common feature they share is that they are all <span class="strong"><strong>homogeneous data types</strong></span>, that is, the type of elements they store must be the same. However, there are also <span class="strong"><strong>heterogeneous data types</strong></span> in R, that is, they can store different types of elements, which makes them much more flexible but they are less memory efficient and slower to operate.</p></div></div>
<div class="section" title="Lists"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Lists</h1></div></div></div><p>A list is a generic vector that is allowed to include different types of objects, even other lists.</p><p>It is useful for its flexibility. For example, the result of a linear model fit in R is basically a list object that contains rich results of a linear regression such as linear coefficients (numeric vectors), residuals (numeric vectors), QR decomposition (a list containing a matrix and other objects), and so on.</p><p>It is very handy to extract the information without calling different functions each time because these results are all packed into a list.</p><div class="section" title="Creating a list"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Creating a list</h2></div></div></div><p>We can use <code class="literal">list()</code> to create a list, as the function name suggests. Different types of objects can be put into one list. For example, the following code creates a list that contains a single-element numeric vector, a two-entry logical vector, and a character vector of three values:</p><pre class="programlisting">l0 &lt;- list(1, c(TRUE, FALSE), c("a", "b", "c"))
l0&#13;
## [[1]]
## [1] 1
## 
## [[2]]
## [1] TRUE FALSE
## 
## [[3]]
## [1] "a" "b" "c"</pre><p>We can assign names to each list entry using named arguments:</p><pre class="programlisting">l1 &lt;- list(x = 1, y = c(TRUE, FALSE), z = c("a", "b", "c"))
l1&#13;
## $x
## [1] 1
## 
## $y
## [1] TRUE FALSE
## 
## $z
## [1] "a" "b" "c"</pre></div><div class="section" title="Extracting an element from a list"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Extracting an element from a list</h2></div></div></div><p>There are various ways to access the elements of a list. The most common way is to use a dollar-sign <code class="literal">$</code> to extract the value of a list element by name:</p><pre class="programlisting">l1 &lt;- list(x = 1, y = c(TRUE, FALSE), z = c("a", "b", "c"), m = NULL)&#13;
l1$x&#13;
## [1] 1&#13;
l1$y&#13;
## [1] TRUE FALSE&#13;
l1$z&#13;
## [1] "a" "b" "c"&#13;
l1$m&#13;
## NULL</pre><p>Note that if we ask for a non-existing element <code class="literal">m</code>, <code class="literal">NULL</code> will be returned.</p><p>Alternatively, we can supply a number in double square brackets to extract the value of the n<sup>th</sup> list member. For example, we can extract the value of the second member of list <code class="literal">l1</code>, as follows:</p><pre class="programlisting">l1[[2]]&#13;
## [1] TRUE FALSE</pre><p>With the same notation, we can also supply a name to extract the value of the list member with that name, just like using a dollar sign:</p><pre class="programlisting">l1[["y"]]&#13;
## [1] TRUE FALSE</pre><p>It can be more flexible to use double square brackets for value extraction from a list because, sometimes, we might not know which member we need to extract before a computation:</p><pre class="programlisting">member &lt;- "z" # you can dynamically determine which member to extract
l1[[member]]&#13;
## [1] "a" "b" "c"</pre><p>Here, we supply a runtime-evaluated, single-element character vector to the brackets. But why should we use double brackets here? Where are the single brackets?</p></div><div class="section" title="Subsetting a list"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Subsetting a list</h2></div></div></div><p>In many cases, we need to extract multiple elements from a list. These multiple members also construct a list as a subset of the original list.</p><p>To subset a list, we can use single-square-bracket notation, just like what we use for vectors and matrices. We can extract some elements of a list and put them into a new list.</p><p>The notation is very much consistent with how it works for vectors. We can extract elements from a list by name using a character vector, or by position using a numeric vector, or by criterion using a logical vector:</p><pre class="programlisting">l1["x"]&#13;
## $x
## [1] 1&#13;
l1[c("x", "y")]&#13;
## $x
## [1] 1
## 
## $y
## [1] TRUE FALSE&#13;
l1[1]&#13;
## $x
## [1] 1&#13;
l1[c(1, 2)]&#13;
## $x
## [1] 1
## 
## $y
## [1] TRUE FALSE&#13;
l1[c(TRUE, FALSE, TRUE)]&#13;
## $x
## [1] 1
## 
## $z
## [1] "a" "b" "c"</pre><p>To summarize, we can say that  <code class="literal">[[</code> means extracting one element from a vector or list, and <code class="literal">[</code> means subsetting a vector or list. Subsetting a vector will result in a vector. Likewise, subsetting a list will result in a list.</p></div><div class="section" title="Named lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Named lists</h2></div></div></div><p>Irrespective of whether the list members have already got names when the list is created, we can always name or rename the members of a list, by simply naming a vector:</p><pre class="programlisting">names(l1) &lt;- c("A","B","C")
l1&#13;
## $A
## [1] 1
## 
## $B
## [1] TRUE FALSE
## 
## $C
## [1] "a" "b" "c"</pre><p>To remove their names, we replace the names of <code class="literal">l1</code> with <code class="literal">NULL</code>:</p><pre class="programlisting">names(l1) &lt;- NULL
l1&#13;
## [[1]]
## [1] 1
## 
## [[2]]
## [1] TRUE FALSE
## 
## [[3]]
## [1] "a" "b" "c"</pre><p>Once the names of list members are removed, we can no longer access the list members by name but by position and logical criterion.</p></div><div class="section" title="Setting values"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Setting values</h2></div></div></div><p>Setting the values in a list is as straightforward as working with vectors:</p><pre class="programlisting">l1 &lt;- list(x = 1, y = c(TRUE, FALSE), z = c("a", "b", "c"))
l1$x &lt;- 0</pre><p>If we assign a value to a nonexisting member, we will add a new member to the list with the given name or position:</p><pre class="programlisting">l1$m &lt;- 4
l1&#13;
## $x
## [1] 0
## 
## $y
## [1] TRUE FALSE
## 
## $z
## [1] "a" "b" "c"
## 
## $m
## [1] 4</pre><p>Also, we can set multiple values at the same time:</p><pre class="programlisting">l1[c("y", "z")] &lt;- list(y = "new value for y", z = c(1, 2))
l1&#13;
## $x
## [1] 0
## 
## $y
## [1] "new value for y"
## 
## $z
## [1] 1 2
## 
## $m
## [1] 4</pre><p>If we need to remove some of the members in a list, just assign the <code class="literal">NULL</code> value to them:</p><pre class="programlisting">l1$x &lt;- NULL
l1&#13;
## $y
## [1] "new value for y"
## 
## $z
## [1] 1 2
## 
## $m
## [1] 4</pre><p>We can remove more than one member from a list altogether:</p><pre class="programlisting">l1[c("z", "m")] &lt;- NULL
l1&#13;
## $y
## [1] "new value for y"</pre></div><div class="section" title="Other functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Other functions</h2></div></div></div><p>Many functions in R are related to lists. For example, if we are not sure whether an object is a list or not, we can call <code class="literal">is.list()</code> to find out:</p><pre class="programlisting">l2 &lt;- list(a = c(1, 2, 3), b = c("x", "y", "z", "w"))
is.list(l2)&#13;
## [1] TRUE&#13;
is.list(l2$a)&#13;
## [1] FALSE</pre><p>Here, <code class="literal">l2</code> is a list, and <code class="literal">butl2$a</code> is a numeric vector rather than a list.</p><p>We can also convert a vector to a list using <code class="literal">as.list()</code>:</p><pre class="programlisting">l3 &lt;- as.list(c(a = 1, b =2, c = 3))
l3&#13;
## $a
## [1] 1
## 
## $b
## [1] 2
## 
## $c
## [1] 3</pre><p>It is also easy to coerce a list to a vector by calling <code class="literal">unlist</code> that basically converts all list members and puts them to a vector of a compatible type:</p><pre class="programlisting">l4 &lt;- list(a = 1, b = 2, c = 3)
unlist(l4)&#13;
## a b c 
## 1 2 3</pre><p>If we unlist a list of numbers and texts in mixture, all members will be converted to the closest type that each one can be converted to:</p><pre class="programlisting">l4 &lt;- list(a = 1, b = 2, c = "hello")
unlist(l4)&#13;
## a b c 
## "1" "2" "hello"</pre><p>Here, <code class="literal">l4$a</code> and <code class="literal">l4$b</code> are numbers and can be converted to a character; however,  <code class="literal">butl4$c</code> is a character vector and cannot be converted to numeric values. Therefore, their closest type that is compatible with all elements is a character vector.</p></div></div>
<div class="section" title="Data frames"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Data frames</h1></div></div></div><p>A data frame represents a set of data with a number of rows and columns. It looks like a matrix but its columns are not necessarily of the same type. This is consistent with the most commonly seen formats of datasets: each row, or data record, is described by multiple columns of various types.</p><p>The following table is an example that can be fully characterized by a data frame.</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Name</strong></span></p>
</td><td>
<p><span class="strong"><strong>Gender</strong></span></p>
</td><td>
<p><span class="strong"><strong>Age</strong></span></p>
</td><td>
<p><span class="strong"><strong>Major</strong></span></p>
</td></tr><tr><td>
<p>Ken</p>
</td><td>
<p>Male</p>
</td><td>
<p>24</p>
</td><td>
<p>Finance</p>
</td></tr><tr><td>
<p>Ashley</p>
</td><td>
<p>Female</p>
</td><td>
<p>25</p>
</td><td>
<p>Statistics</p>
</td></tr><tr><td>
<p>Jennifer</p>
</td><td>
<p>Female</p>
</td><td>
<p>23</p>
</td><td>
<p>Computer Science</p>
</td></tr></tbody></table></div><div class="section" title="Creating a data frame"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Creating a data frame</h2></div></div></div><p>To create a data frame, we can call <code class="literal">data.frame()</code> and supply the data of each column by a vector of the corresponding type:</p><pre class="programlisting">persons &lt;- data.frame(Name = c("Ken", "Ashley", "Jennifer"),
  Gender = c("Male", "Female", "Female"),
  Age = c(24, 25, 23),
  Major = c("Finance", "Statistics", "Computer Science"))
persons&#13;
##   Name     Gender  Age  Major
## 1 Ken      Male    24   Finance
## 2 Ashley   Female  25   Statistics
## 3 Jennifer Female  23   Computer Science</pre><p>Note that creating a data frame is exactly the same as creating a list. This is because, in essence, a data frame is a list in which each element is a vector and represents a table column and has the same number of elements.</p><p>Other than creating a data frame from raw data, we can also create it from a list by calling either <code class="literal">data.frame</code> directly or <code class="literal">as.data.frame</code>:</p><pre class="programlisting">l1 &lt;- list(x = c(1, 2, 3), y = c("a", "b", "c"))
data.frame(l1)&#13;
##   x y
## 1 1 a
## 2 2 b
## 3 3 c&#13;
as.data.frame(l1)&#13;
##   x y
## 1 1 a
## 2 2 b
## 3 3 c</pre><p>We can also create a data frame from a matrix with the same method:</p><pre class="programlisting">m1 &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = FALSE)
data.frame(m1)&#13;
##   X1 X2 X3
## 1 1  4  7
## 2 2  5  8
## 3 3  6  9&#13;
as.data.frame(m1)&#13;
##   V1 V2 V3
## 1  1  4  7
## 2  2  5  8
## 3  3  6  9</pre><p>Note that the conversion also automatically assigns column names to the new data frame. In fact, as you may verify, if the matrix already has column names or row names, they will be preserved in the conversion.</p></div><div class="section" title="Naming rows and columns"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Naming rows and columns</h2></div></div></div><p>Since a data frame is a list but also looks like a matrix, the ways we access these two types of objects both apply to a data frame:</p><pre class="programlisting">df1 &lt;- data.frame(id = 1:5, x = c(0, 2, 1, -1, -3), y = c(0.5, 0.2, 0.1, 0.5, 0.9))
df1&#13;
##   id  x   y
## 1  1  0  0.5
## 2  2  2  0.2
## 3  3  1  0.1
## 4  4 -1  0.5
## 5  5 -3  0.9</pre><p>We can rename the columns and rows just like we do with a matrix:</p><pre class="programlisting">colnames(df1) &lt;- c("id", "level", "score")
rownames(df1) &lt;- letters[1:5]
df1&#13;
##    id level score
## a   1    0    0.5
## b   2    2    0.2
## c   3    1    0.1
## d   4   -1    0.5
## e   5   -3    0.9</pre></div><div class="section" title="Subsetting a data frame"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Subsetting a data frame</h2></div></div></div><p>Since a data frame is a matrix-like list of column vectors, we can use both sets of notations to access the elements and subsets in a data frame.</p><div class="section" title="Subsetting a data frame as a list"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec9"/>Subsetting a data frame as a list</h3></div></div></div><p>If we would like to regard a data frame as a list of vectors, we can use list notations to extract a value or perform subsetting.</p><p>For example, we can use <code class="literal">$</code> to extract the values of one column by name, or use <code class="literal">[[</code> to do so by position:</p><pre class="programlisting">df1$id&#13;
## [1] 1 2 3 4 5&#13;
df1[[1]]&#13;
## [1] 1 2 3 4 5</pre><p>List subsetting perfectly applies to a data frame and also yields a new data frame. The subsetting operator (<code class="literal">[</code>) allows us to use a numeric vector to extract columns by position, a character vector to extract columns by name, or a logical vector to extract columns by <code class="literal">TRUE</code> and <code class="literal">FALSE</code> selection:</p><pre class="programlisting">df1[1]&#13;
##  id
## a 1
## b 2
## c 3
## d 4
## e 5&#13;
df1[1:2]&#13;
##  id level
## a 1  0
## b 2  2
## c 3  1
## d 4 -1
## e 5 -3&#13;
df1["level"]&#13;
##  level
## a  0
## b  2
## c  1
## d -1
## e -3&#13;
df1[c("id", "score")]&#13;
##  id score
## a 1  0.5
## b 2  0.2
## c 3  0.1
## d 4  0.5
## e 5  0.9&#13;
df1[c(TRUE, FALSE, TRUE)]&#13;
##   id score
## a 1  0.5
## b 2  0.2
## c 3  0.1
## d 4  0.5
## e 5  0.9</pre></div><div class="section" title="Subsetting a data frame as a matrix"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Subsetting a data frame as a matrix</h3></div></div></div><p>However, the list notation does not support row selection. In contrast, the matrix notation provides more flexibility. If we view a data frame as a matrix, the two-dimensional accessor enables us to easily access an entry of a subset, which supports both column selection and row selection.</p><p>In other words, we can use the <code class="literal">[row, column]</code> notation to subset a data frame by specifying the row selector and column selector, which can be numeric vectors, character vectors, and/or logical vectors.</p><p>For example, we can specify the column selector:</p><pre class="programlisting">df1[, "level"]&#13;
## [1] 0 2 1 -1 -3&#13;
df1[, c("id", "level")]&#13;
##  id level
## a 1  0
## b 2  2
## c 3  1
## d 4 -1
## e 5 -3&#13;
df1[, 1:2]&#13;
##  id level
## a 1  0
## b 2  2
## c 3  1
## d 4 -1
## e 5 -3</pre><p>Alternatively, we can specify the row selector:</p><pre class="programlisting">df1[1:4,]&#13;
##   id level score
## a  1   0    0.5
## b  2   2    0.2
## c  3   1    0.1
## d  4  -1    0.5&#13;
df1[c("c", "e"),]&#13;
##   id level score
## c  3   1    0.1
## e  5  -3    0.9</pre><p>We can even specify both selectors at the same time:</p><pre class="programlisting">df1[1:4, "id"]&#13;
## [1] 1 2 3 4&#13;
df1[1:3, c("id", "score")]&#13;
##   id score
## a  1  0.5
## b  2  0.2
## c  3  0.1</pre><p>Note that the matrix notation automatically simplifies the output. That is, if only one column is selected, the result won't be a data frame but the values of that column. To always keep the result as a data frame, even if it only has a single column, we can use both notations together:</p><pre class="programlisting">df1[1:4,]["id"]&#13;
##   id
## a 1
## b 2
## c 3
## d 4</pre><p>Here, the first group of brackets subsets the data frame as a matrix with the first four rows and all columns selected. The second group of brackets subsets the resultant data frame as a list with only the <code class="literal">id</code> column selected, which results in a data frame.</p><p>Another way is to specify <code class="literal">drop = FALSE</code> to avoid simplifying the results:</p><pre class="programlisting">df1[1:4, "id", drop = FALSE]&#13;
##   id
## a 1
## b 2
## c 3
## d 4</pre><p>If you expect the output of a data frame subsetting to always be a data frame, you should always set <code class="literal">drop = FALSE</code>; otherwise, some edge cases (like a user input selecting only one column) may end up in unexpected behaviors if you assume that you will get a data frame but actually get a vector.</p></div><div class="section" title="Filtering data"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Filtering data</h3></div></div></div><p>The following code filters the rows of <code class="literal">df1</code> by <code class="literal">criterionscore &gt;= 0.5</code> and selects the <code class="literal">id</code> and <code class="literal">level</code> columns:</p><pre class="programlisting">df1$score &gt;= 0.5&#13;
## [1] TRUE FALSE FALSE TRUE TRUE&#13;
df1[df1$score &gt;= 0.5, c("id", "level")]&#13;
##   id level
## a  1   0
## d  4  -1
## e  5  -3</pre><p>The following code filters the rows of <code class="literal">df1</code> by a criterion that the row name must be among <code class="literal">a</code>, <code class="literal">d</code>, or <code class="literal">e</code>, and selects the <code class="literal">id</code> and <code class="literal">score</code> columns:</p><pre class="programlisting">rownames(df1) %in% c("a", "d", "e")&#13;
## [1] TRUE FALSE FALSE TRUE TRUE&#13;
df1[rownames(df1) %in% c("a", "d", "e"), c("id", "score")]&#13;
##   id score
## a  1  0.5
## d  4  0.5
## e  5  0.9</pre><p>Both of these examples basically use matrix notation to select rows by a logical vector and select columns by a character vector.</p></div></div><div class="section" title="Setting values"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Setting values</h2></div></div></div><p>Setting the values of a subset of a data frame allows both methods working with a list and a matrix.</p><div class="section" title="Setting values as a list"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Setting values as a list</h3></div></div></div><p>We can assign new values to a list member using <code class="literal">$</code> and <code class="literal">&lt;-</code> together:</p><pre class="programlisting">df1$score &lt;- c(0.6, 0.3, 0.2, 0.4, 0.8)
df1&#13;
##   id level score
## a 1    0    0.6
## b 2    2    0.3
## c 3    1    0.2
## d 4   -1    0.4
## e 5   -3    0.8</pre><p>Alternatively, <code class="literal">[</code> works too, and it also allows multiple changes in one expression in contrast to <code class="literal">[[</code>, which only allows modifying one column at a time:</p><pre class="programlisting">df1["score"] &lt;- c(0.8, 0.5, 0.2, 0.4, 0.8)
df1&#13;
##   id level score
## a 1   0     0.8
## b 2   2     0.5
## c 3   1     0.2
## d 4  -1     0.4
## e 5  -3     0.8&#13;
df1[["score"]] &lt;- c(0.4, 0.5, 0.2, 0.8, 0.4)
df1&#13;
##   id level score
## a 1   0     0.4
## b 2   2     0.5
## c 3   1     0.2
## d 4  -1     0.8
## e 5  -3     0.4&#13;
df1[c("level", "score")] &lt;- list(level = c(1, 2, 1, 0, 0), score = c(0.1, 0.2, 0.3, 0.4, 0.5))
df1&#13;
##   id level score
## a 1    1    0.1
## b 2    2    0.2
## c 3    1    0.3
## d 4    0    0.4
## e 5    0    0.5</pre></div><div class="section" title="Setting values as a matrix"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Setting values as a matrix</h3></div></div></div><p>Using list notations to set values of a data frame has the same problem as subsetting–we can only access the columns. If we need to set values with more flexibility, we can use matrix notations:</p><pre class="programlisting">df1[1:3, "level"] &lt;- c(-1, 0, 1)
df1&#13;
##   id level score
## a 1   -1   0.1
## b 2   0    0.2
## c 3   1    0.3
## d 4   0    0.4
## e 5   0    0.5&#13;
df1[1:2, c("level", "score")] &lt;- list(level = c(0, 0), score = c(0.9, 1.0))
df1&#13;
##   id level score
## a 1   0    0.9
## b 2   0    1.0
## c 3   1    0.3
## d 4   0    0.4
## e 5   0    0.5</pre></div></div><div class="section" title="Factors"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Factors</h2></div></div></div><p>One thing to notice is that the default behavior of a data frame tries to use memory more efficiently. Sometimes, this behavior might silently lead to unexpected problems.</p><p>For example, when we create a data frame by supplying a character vector as a column, it will by default convert the character vector to a factor that only stores the same value once so that repetitions will not cost much memory. In fact, a factor is essentially an integer vector with a pre-specified set of possible values called levels to represent values of limited possibilities.</p><p>We can verify this by calling <code class="literal">str()</code> on the data frame <code class="literal">persons</code> we created in the beginning:</p><pre class="programlisting">str(persons)&#13;
## 'data.frame': 3 obs. of 4 variables:
## $ Name : Factor w/ 3 levels "Ashley","Jennifer",..: 3 1 2
## $ Gender: Factor w/ 2 levels "Female","Male": 2 1 1
## $ Age : num 24 25 23
## $ Major : Factor w/ 3 levels "Computer Science",..: 2 3 1</pre><p>As we can clearly find out that <code class="literal">Name</code>, <code class="literal">Gender</code>, and <code class="literal">Major</code> are not character vectors but factor objects. It is reasonable that <code class="literal">Gender</code> is represented by a factor because it may only be either <code class="literal">Female</code> or <code class="literal">Male</code>, so using two integers to represent these two values is more efficient than using a character vector to store all the values regardless of the repetition.</p><p>However, it may induce problems for other columns not limited to taking several possible values. For example, if we want to set a name in <code class="literal">persons</code>:</p><pre class="programlisting">persons[1, "Name"] &lt;- "John"&#13;
## Warning in `[&lt;-.factor`(`*tmp*`, iseq, value = "John"): invalid factor
## level, NA generated&#13;
persons&#13;
##    Name    Gender Age  Major
## 1 &lt;NA&gt;     Male   24   Finance
## 2 Ashley   Female 25   Statistics
## 3 Jennifer Female 23   Computer Science</pre><p>A warning message appears. This happens because in the initial <code class="literal">Name</code> dictionary, there is no word called <code class="literal">John</code>, therefore we cannot set the name of the first person to be such a non-existing value. The same thing happens when we set any <code class="literal">Gender</code> to be <code class="literal">Unknown</code>. The reason is exactly the same: when the column is initially created from a character vector when we define a data frame, the column will by default be a factor whose value must be taken from the dictionary created from the unique values in that character vector.</p><p>This behavior is sometimes very annoying and does not really help much, especially as memory is cheap today. The simplest way to avoid this behavior is to set <code class="literal">stringsAsFactors = FALSE</code> when we create a data frame using <code class="literal">data.frame()</code>:</p><pre class="programlisting">persons &lt;- data.frame(Name = c("Ken", "Ashley", "Jennifer"),
  Gender = factor(c("Male", "Female", "Female")),
  Age = c(24, 25, 23),
  Major = c("Finance", "Statistics", "Computer Science"),
  stringsAsFactors = FALSE)
str(persons)&#13;
## 'data.frame': 3 obs. of 4 variables:
## $ Name : chr "Ken" "Ashley" "Jennifer"
## $ Gender: Factor w/ 2 levels "Female","Male": 2 1 1
## $ Age : num 24 25 23
## $ Major : chr "Finance" "Statistics" "Computer Science"</pre><p>If we really want a factor object to play its role, we can explicitly call <code class="literal">factor()</code> at specific columns, just like we did previously  for the <code class="literal">Gender</code> column.</p></div><div class="section" title="Useful functions for data frames"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Useful functions for data frames</h2></div></div></div><p>There are many useful functions for a data frame. Here we only introduce a few but the most commonly used ones.</p><p>The <code class="literal">summary()</code> function works with a data frame by generating a table that shows the summary statistics of each column:</p><pre class="programlisting">summary(persons)&#13;
## Name Gender Age Major 
## Length:3 Female:2 Min. :23.0 Length:3 
## Class :character Male :1 1st Qu.:23.5 Class :character 
## Mode :character Median :24.0 Mode :character 
## Mean :24.0 
## 3rd Qu.:24.5 
## Max. :25.0</pre><p>For a factor <code class="literal">Gender</code>, the summary counts the number of rows taking each value, or level. For a numeric vector, the summary shows the important quantiles of the numbers. For other types of columns, it shows the length, class, and mode of them. Another common demand is binding multiple data frames together by either row or column. For this purpose, we can use <code class="literal">rbind()</code> and <code class="literal">cbind()</code> which, as their names suggest, perform row binding and column binding respectively.</p><p>If we want to append some rows to a data frame, in this case, add a new record of a person, we can use <code class="literal">rbind()</code>:</p><pre class="programlisting">rbind(persons, data.frame(Name = "John", Gender = "Male", Age = 25, Major = "Statistics"))&#13;
##   Name     Gender Age Major
## 1 Ken      Male    24 Finance
## 2 Ashley   Female  25 Statistics
## 3 Jennifer Female  23 Computer Science
## 4 John     Male    25 Statistics</pre><p>If we want to append some columns to a data frame, in this case, add two new columns to indicate whether each person is registered and the number of projects in hand, we can use <code class="literal">cbind()</code>:</p><pre class="programlisting">cbind(persons, Registered = c(TRUE, TRUE, FALSE), Projects = c(3, 2, 3))&#13;
##   Name    Gender  Age Major           Registered Projects
## 1 Ken      Male   24  Finance          TRUE         3
## 2 Ashley   Female 25  Statistics       TRUE         2
## 3 Jennifer Female 23  Computer Science FALSE        3</pre><p>Note that <code class="literal">rbind()</code> and <code class="literal">cbind()</code> do not modify the original data but create a new data frame with given rows or columns appended.</p><p>Another useful function is <code class="literal">expand.grid()</code>. This generates a data frame that includes all combinations of the values in the columns:</p><pre class="programlisting">expand.grid(type = c("A", "B"), class = c("M", "L", "XL"))&#13;
##   type class
## 1  A    M
## 2  B    M
## 3  A    L
## 4  B    L
## 5  A   XL
## 6  B   XL</pre><p>There are many other useful functions working with data frames. We will discuss these functions in data manipulation chapters.</p></div><div class="section" title="Loading and writing data on disk"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Loading and writing data on disk</h2></div></div></div><p>In practice, data is usually stored in files. R provides a number of functions to read a table from a file or write a data frame to a file. If a file stores a table, it is often well organized and follows some convention that specifies how rows and columns are arranged. In most cases, we don't have to read a file byte to byte but call functions such as <code class="literal">read.table()</code> or <code class="literal">read.csv()</code>.</p><p>The most popular software-neutral data format is <span class="strong"><strong>CSV</strong></span> (<span class="strong"><strong>Comma-Separated Values</strong></span>). The format is basically organized in a way that values in different columns are separated by a comma and the first row is by default regarded as the header. For example, persons may be represented in the following CSV format:</p><pre class="programlisting"> Name,Gender,Age,MajorKen,Male,24,FinanceAshley,Female,25,StatisticsJennifer,Female,23,Computer Science</pre><p>To read the data into the R environment, we only need to call <code class="literal">read.csv(file)</code> where the file is the path of the file. To ensure that the data file can be found, please place the <code class="literal">data</code> folder directly in your working directory, call <code class="literal">getwd()</code> to find out. We'll talk about this in detail in the next chapter:</p><pre class="programlisting">read.csv("data/persons.csv")&#13;
##   Name     Gender Age Major
## 1 Ken      Male   24  Finance
## 2 Ashley   Female 25  Statistics
## 3 Jennifer Female 23  Computer Science</pre><p>If we need to save a data frame to a CSV file, we may call <code class="literal">write.csv(file)</code> with some additional arguments:</p><pre class="programlisting">write.csv(persons, "data/persons.csv", row.names = FALSE, quote = FALSE)</pre><p>The argument <code class="literal">row.names = FALSE</code> avoids storing the row names which are not necessary, and the <code class="literal">argumentquote = FALSE</code> avoids quoting text in the output, both of which in most cases are not necessary.</p><p>There are a number of built-in functions and several packages related to reading and writing data in different formats. We will cover this topic in later chapters.</p></div></div>
<div class="section" title="Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Functions</h1></div></div></div><p>A function is an object you can call. Basically, it is a machine with internal logic that takes a group of inputs (parameters or arguments) and returns a value as output.</p><p>In the previous sections, we encountered some built-in functions of R. For example, <code class="literal">is.numeric()</code> takes an argument that can be any R object and returns a logical value that indicates whether the object is a numeric vector. Similarly, <code class="literal">is.function()</code> can tell whether a given R object is a function object.</p><p>In fact, in R environment, everything we use is an object, everything we do is a function, and, maybe to your surprise, all functions are still objects. Even <code class="literal">&lt;-</code> and <code class="literal">+</code> are both functions that take two arguments. Although they are called binary operators, they are essentially functions.</p><p>When we do casual, interactive data analysis, at times, we won't have to write any function on our own since the built-in functions and those provided by thousands of packages are usually enough.</p><p>However, if you need to repeat your logic or a process in data manipulation or analysis, those functions may not fully serve your purpose because they are not designed to meet the specific needs of a task or the format of a particular dataset. Then, you need to create your own functions targeting a specific set of demands.</p><div class="section" title="Creating a function"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>Creating a function</h2></div></div></div><p>It is easy to create a function in R. Suppose we define a function called <code class="literal">add</code> that simply adds two numbers <code class="literal">x</code> and <code class="literal">y</code>, respectively:</p><pre class="programlisting">add &lt;- function(x, y) {  x + y}</pre><p>The syntax function <code class="literal">(x, y)</code> specifies the arguments of the function. In other words, the function takes two arguments named <code class="literal">x</code> and <code class="literal">y</code>. The <code class="literal">{ x + y }</code> is the function body that contains a series of expressions expressed in terms of <code class="literal">x</code>, <code class="literal">y</code> and other symbols available. The value of the last expression determines the value returned by the function unless <code class="literal">return()</code> is called inside the function. Finally, the function is assigned to add so that we can call this function using add later on.</p><p>Creating such a simple function, or any more complicated functions, does not impose any difference on evaluating a vector. The function in R just acts like another object. To see what object <code class="literal">add</code> refers to, just type <code class="literal">add</code> at the console:</p><pre class="programlisting">add&#13;
## function(x, y) {&#13;
## x + y&#13;
## }</pre></div><div class="section" title="Calling a function"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>Calling a function</h2></div></div></div><p>Once the function is defined, we can call the function just as we do in math. The calling requires the same syntax: name (arg1, arg2, ...). Take a look at the following:</p><pre class="programlisting">add(2, 3)&#13;
## [1] 5</pre><p>The call is quite transparent. When we evaluate such a call, R will find out if there is a function named <code class="literal">add</code> in the environment. Then, it will figure out that <code class="literal">add</code> refers to the function we just created and creates a local environment in which <code class="literal">x</code> takes <code class="literal">2</code> and <code class="literal">y</code> takes <code class="literal">3</code>. The expression in the function body is then evaluated given the values of the arguments. Finally, the function returns the value of that expression, <code class="literal">5</code>.</p></div><div class="section" title="Dynamic typing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Dynamic typing</h2></div></div></div><p>Functions in R can be very flexible since it is not strongly typed. In other words, the type of inputs are not fixed prior to the calling. Even if the function is originally designed to work for scalar numbers, it is automatically generalized to also work with all vectors as long as <code class="literal">+</code> works with them. For example, we can run the following code without any change in the function:</p><pre class="programlisting">add(c(2, 3), 4)&#13;
## [1] 6 7</pre><p>The preceding example does not really demonstrate the flexibility of dynamic typing because scalar is also a vector in R. A more qualified example is:</p><pre class="programlisting">add(as.Date("2014-06-01"), 1)&#13;
## [1] "2014-06-02"</pre><p>The function put the two arguments into the expression without any type checking. <code class="literal">as.Date()</code> creates a <code class="literal">Date</code> object, which has a date representation. Without changing any code of <code class="literal">add</code>, it works with <code class="literal">Date</code> perfectly. The function fails only when <code class="literal">+</code> is not well-defined for the two arguments:</p><pre class="programlisting">add(list(a = 1), list(a = 2))&#13;
## Error in x + y: non-numeric argument to binary operator</pre></div><div class="section" title="Generalizing a function"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>Generalizing a function</h2></div></div></div><p>Functions are a well-defined abstraction of a particular set of logic or process intended for solving some particular problem. Developers often want a function to be general enough to adapt to a wide range of use cases so that we can easily use it to solve similar problems without writing too many specialized functions for each problem.</p><p>To make a function more widely applicable is called <span class="strong"><strong>generalization</strong></span>. It is very handy to generalize a function in a weakly-typed programming language like R, but it can be error-prone if it is incorrectly implemented.</p><p>To make <code class="literal">add()</code> more general so that it can handle various primitive algebraic operations, we can define another function called <code class="literal">calc</code>. This new function accepts three arguments where <code class="literal">x</code> and <code class="literal">y</code> are the two vectors, and <code class="literal">type</code> accepts a character vector which is the kind of algebraic operation the user wants to perform.</p><p>The following code implements such a function using <span class="strong"><strong>flow control</strong></span>, which we will cover soon, but it should be easy to understand at first look. In this code, the choice of expression to be evaluated depends on the value of <code class="literal">type</code>:</p><pre class="programlisting">calc &lt;- function(x, y, type) {&#13;
  if (type == "add") {&#13;
    x + y&#13;
  } else if (type == "minus") {&#13;
    x - y
  } else if (type == "multiply") {
    x * y
  } else if (type == "divide") {
    x / y
  } else {
    stop("Unknown type of operation")
  }
}</pre><p>Once the function is defined, we can call it by supplying appropriate arguments:</p><pre class="programlisting">calc(2, 3, "minus")&#13;
## [1] -1</pre><p>The function automatically works with numeric vectors:</p><pre class="programlisting">calc(c(2, 5), c(3, 6), "divide")&#13;
## [1] 0.6666667 0.8333333</pre><p>The function is also generalized to work with non-numeric vectors for which <code class="literal">+</code> is well-defined:</p><pre class="programlisting">calc(as.Date("2014-06-01"), 3, "add")&#13;
## [1] "2014-06-04"</pre><p>Consider supplying some invalid arguments:</p><pre class="programlisting">calc(1, 2, "what")&#13;
## Error in calc(1, 2, "what"): Unknown type of operation</pre><p>In this case, no conditions are satisfied, so the expression in the last else block will be evaluated. The <code class="literal">stop()</code> call yields an error message and terminates the whole evaluation immediately.</p><p>The functions seem to work fine and consider all possible situations with invalid arguments. However, it is not true:</p><pre class="programlisting">calc(1, 2, c("add", "minue"))&#13;
## Warning in if (type == "add") {: the condition has length &gt; 1 and only the
## first element will be used&#13;
## [1] 3</pre><p>Here, we didn't consider the case where type is given as a multi-element vector. The problem is: when such a vector is compared with another vector, it will also result in a multi-element logical vector, it will also result in a mult-element logical vector which makes an ambiguous condition for <code class="literal">if</code>. Consider what it means by <code class="literal">if(c(TRUE, FALSE))</code>?</p><p>To avoid such ambiguity explicitly, we need to refine the function so that the error will be more informative and transparent. To proceed, we just need to check whether the vector has the length <code class="literal">1</code>:</p><pre class="programlisting">calc &lt;- function(x, y, type) {
&#13;
  if (length(type) &gt; 1L) stop("Only a single type is accepted")
  if (type == "add") {
  x + y
  } else if (type == "minus") {
  x - y
  } else if (type == "multiply") {
  x * y
  } else if (type == "divide") {
  x / y
  } else {
  stop("Unknown type of operation")
  }
  }</pre><p>Then, we retry the trouble-making call and see how the exception is handled by pre-checking of arguments:</p><pre class="programlisting">calc(1, 2, c("add", "minue"))&#13;
## Error in calc(1, 2, c("add", "minue")): Only a single type is accepted</pre></div><div class="section" title="Default value for function arguments"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>Default value for function arguments</h2></div></div></div><p>Some functions are very flexible because they accept a wide range of input and meet a variety of demands. In many cases, more flexibility means an increasing number of arguments.</p><p>If we have to specify tens of arguments each time using a very flexible function, it would certainly be a mess to look at the code. In this case, reasonable default values for arguments will largely simplify the code to call a function.</p><p>To set the default value of an argument, use <code class="literal">arg = value</code>. This will make the argument optional. The following example creates a function with an optional argument:</p><pre class="programlisting">increase &lt;- function(x, y = 1) {
x + y
}</pre><p>The new function <code class="literal">increase()</code> allows us to call it with only <code class="literal">x</code>. In this case, <code class="literal">y</code> automatically takes <code class="literal">1</code> unless it is explictly specified.</p><pre class="programlisting">increase(1)&#13;
## [1] 2&#13;
increase(c(1, 2, 3))&#13;
## [1] 2 3 4</pre><p>Many R functions have multiple arguments and some of them are given default values. Sometimes, it is tricky to determine the default values of arguments because it heavily relies on the intention of most users.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, you learned the basic behaviors of numeric vectors, logical vectors, and character vectors. These vectors are homogeneous data types that can only store elements of the same type. By contrast, lists and data frames are more flexible since they store elements of different types. You learned how to subset these data structures and extract an element from them. Finally, you learned about creating and calling functions.</p><p>Now you know the rules of the game, you need to get familiar with the playground. In the next chapter, we will cover some basic yet important things about managing the workspace. I will show you some common practices of managing the working directory, the environment, and the library of packages.</p></div></body></html>