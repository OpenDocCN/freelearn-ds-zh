<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Creating Dynamic Maps</h1></div></div></div><p class="calibre9">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Accessing the map canvas</li><li class="listitem">Changing the map units</li><li class="listitem">Iterating over layers</li><li class="listitem">Symbolizing a vector layer</li><li class="listitem">Rendering a single band raster using a color ramp algorithm</li><li class="listitem">Creating a complex vector layer symbol</li><li class="listitem">Using icons as vector layer symbols</li><li class="listitem">Creating a graduated vector layer symbol</li><li class="listitem">Creating a categorized vector layer symbol</li><li class="listitem">Creating a map bookmark</li><li class="listitem">Navigating to a map bookmark</li><li class="listitem">Setting scale-based visibility for a layer</li><li class="listitem">Using SVG for layer symbols</li><li class="listitem">Using pie charts for symbols</li><li class="listitem">Using the OpenStreetMap service</li><li class="listitem">Using the Bing aerial image service</li><li class="listitem">Adding real-time weather data from OpenWeatherMap</li><li class="listitem">Labeling a feature</li><li class="listitem">Changing map layer transparency</li><li class="listitem">Adding standard map tools to the canvas</li><li class="listitem">Using a map tool to draw points on the canvas</li><li class="listitem">Using a map tool to draw polygons or lines on the canvas</li><li class="listitem">Building a custom selection tool</li><li class="listitem">Creating a mouse coordinate tracking tool</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec81" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre9">In this chapter, we'll programmatically<a id="id362" class="calibre1"/> create dynamic maps using Python to control every aspect of the QGIS map canvas. We'll learn how to use custom symbology, labels, map bookmarks, and even real-time data. We'll also go beyond the canvas to create custom map tools. You will see that every aspect of QGIS is up for grabs with Python, to write your own application. Sometimes, the PyQGIS API may not directly support your application goal, but there is nearly always a way to accomplish what you set out to do with QGIS.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec82" class="calibre1"/>Accessing the map canvas</h1></div></div></div><p class="calibre9">Maps in <a id="id363" class="calibre1"/>QGIS are<a id="id364" class="calibre1"/> controlled through the map canvas. In this recipe, we'll access the canvas and then check one of its properties to ensure that we have control over the object.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec232" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">The only thing you need to do for this recipe is to open QGIS and select <strong class="calibre2">Python Console</strong> from the <strong class="calibre2">Plugins</strong> menu.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec233" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will assign the map canvas to a variable named <code class="literal">canvas</code>. Then, we'll check the <code class="literal">size</code> property of the canvas to get its size in pixels. To do this, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Enter the following line in the QGIS <strong class="calibre2">Python Console</strong>:<div><pre class="programlisting"><strong class="calibre2">canvas = qgis.utils.iface.mapCanvas()</strong>
</pre></div></li><li class="listitem" value="2">Now, to ensure that we have properly accessed the canvas, check its size in pixels using the following line of code:<div><pre class="programlisting"><strong class="calibre2">canvas.size()</strong>
</pre></div></li><li class="listitem" value="3">Verify that QGIS returns a <code class="literal">QSize</code> object that contains the canvas's pixel size, similar to the following format:<div><pre class="programlisting"><strong class="calibre2">PyQt4.QtCore.QSize(698, 138)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec234" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Everything in QGIS centers on the canvas. The canvas is part of the QGIS interface or iface API. Anything <a id="id365" class="calibre1"/>you see on the screen when using QGIS is generated through the iface API. Note that the <code class="literal">iface</code> object is only available to scripts <a id="id366" class="calibre1"/>and plugins. When you are building a standalone application, you must initialize your own <code class="literal">QgsMapCanvas</code> object.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec83" class="calibre1"/>Changing the map units</h1></div></div></div><p class="calibre9">Changing the <a id="id367" class="calibre1"/>units of measurement on a map, or map units, is a very common operation, depending on the purpose of your map or the standards of your <a id="id368" class="calibre1"/>organization or country. In this recipe, we'll read the map units used by QGIS and then change them for your project.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec235" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">The only preparation you need for this recipe is to open QGIS and select <strong class="calibre2">Python Console</strong> from the <strong class="calibre2">Plugins</strong> menu.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec236" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In the following steps, we'll access the map canvas, check the map unit type, and then alter it to a different setting.</p><div><ol class="orderedlist"><li class="listitem" value="1">First, access the map canvas, as follows:<div><pre class="programlisting"><strong class="calibre2">canvas = iface.mapCanvas()</strong>
</pre></div></li><li class="listitem" value="2">Now, get the map units type. By default, it should be the number <strong class="calibre2">2</strong>:<div><pre class="programlisting"><strong class="calibre2">canvas.mapUnits()</strong>
</pre></div></li><li class="listitem" value="3">Now, let's set the map units to meters using the built-in enumerator:<div><pre class="programlisting"><strong class="calibre2">canvas.setMapUnits(QGis.Meters)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec237" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">QGIS has seven different map units, which are enumerated in the following order:</p><p class="calibre9">0 Meters</p><p class="calibre9">1 Feet</p><p class="calibre9">2 Degrees</p><p class="calibre9">3 UnknownUnit</p><p class="calibre9">4 DecimalDegrees</p><p class="calibre9">5 DegreesMinutesSeconds</p><p class="calibre9">6 DegreesDecimalMinutes</p><p class="calibre9">7 NauticalMiles</p><p class="calibre9">It is important to note <a id="id369" class="calibre1"/>that changing the map units just changes the unit of measurement for the measurement tool and the display in the status bar; it does not change the underlying map projection. You'll notice this difference if you try to run an operation<a id="id370" class="calibre1"/> in the Processing Toolbox, which depends on projected data in meters, if the data is unprojected. The most common use case for changing map units is to switch between imperial and metric units, depending on the user's preference.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec84" class="calibre1"/>Iterating over layers</h1></div></div></div><p class="calibre9">For <a id="id371" class="calibre1"/>many GIS operations, you need to loop through<a id="id372" class="calibre1"/> the map layers to look for specific information or to apply a change to all the layers. In this recipe, we'll loop through the layers and get information about them.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec238" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We'll need two<a id="id373" class="calibre1"/> layers in the same map projection to perform this recipe. You can download the first layer as a ZIP file from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip">https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip</a>.</p><p class="calibre9">You can download the second zipped layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/Mississippi.zip">https://geospatialpython.googlecode.com/files/Mississippi.zip</a>.</p><p class="calibre9">Unzip both of these layers into a directory named <code class="literal">ms</code> within your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec239" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will add the layers to the map through the map registry. Then, we will iterate through the map layers and print each layer's title. To do this, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, let's open the polygon and the point layer using the QGIS <strong class="calibre2">Python Console</strong>:<div><pre class="programlisting"><strong class="calibre2">lyr_1 = QgsVectorLayer("/Users/joellawhead/qgis_data/ms/mississippi.shp", "Mississippi", "ogr")</strong>
<strong class="calibre2">lyr_2 = QgsVectorLayer("/Users/joellawhead/qgis_data/ms/MSCities_Geo_Pts.shp", "Cities", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, get the map layer registry instance:<div><pre class="programlisting"><strong class="calibre2">registry = QgsMapLayerRegistry.instance()</strong>
</pre></div></li><li class="listitem" value="3">Now<a id="id374" class="calibre1"/> add the vector layers to the map:<div><pre class="programlisting"><strong class="calibre2">registry.addMapLayers([lyr_2, lyr_1])</strong>
</pre></div></li><li class="listitem" value="4">Then, we retrieve the layers as an interator:<div><pre class="programlisting"><strong class="calibre2">layers = registry.mapLayers()</strong>
</pre></div></li><li class="listitem" value="5">Finally, we <a id="id375" class="calibre1"/>loop through the layers and print the titles:<div><pre class="programlisting"><strong class="calibre2">for l in layers:</strong>
<strong class="calibre2">  printl.title()</strong>
</pre></div></li><li class="listitem" value="6">Verify that you can read the layer titles in the <strong class="calibre2">Python Console</strong>, similar to the following format:<div><pre class="programlisting"><strong class="calibre2">Cities20140904160234792</strong>
<strong class="calibre2">Mississippi20140904160234635</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec240" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Layers in QGIS are independent of the map canvas until you add them to the map layer registry. They have an ID as soon as they are created. When added to the map, they become part of the canvas, where they pick up titles, symbols, and many other attributes. In this case, you can use the map layer registry to iterate through them and access them to change the way they look or to add and extract data.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec85" class="calibre1"/>Symbolizing a vector layer</h1></div></div></div><p class="calibre9">The <a id="id376" class="calibre1"/>appearance <a id="id377" class="calibre1"/>of the layers on a QGIS map is controlled by its symbology. A layer's symbology includes the renderer and one or more symbols. The renderer provides rules dictating the appearance of symbols. The symbols describe properties, including color, shape, size, and linewidth. In this recipe, we'll load a vector layer, change its symbology, and refresh the map.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec241" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the following zipped shapefile and extract it to your <code class="literal">qgis_data</code> directory into a folder named <code class="literal">ms</code> from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/Mississippi.zip">https://geospatialpython.googlecode.com/files/Mississippi.zip</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec242" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load <a id="id378" class="calibre1"/>a layer, add it to the map layer registry, change the layer's color, and then refresh the map. To <a id="id379" class="calibre1"/>do this, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, using the QGIS <strong class="calibre2">Python Console</strong>, we must import the <code class="literal">QtGui</code> library in order to access the <code class="literal">QColor</code> object that is used to describe colors in the PyQGIS API:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtGui import *</strong>
</pre></div></li><li class="listitem" value="2">Next, we create our vector layer, as follows:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/Users/joellawhead/qgis_data/ms/mississippi.shp", "Mississippi", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Then, we add it to the map layer registry:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li><li class="listitem" value="4">Now, we access the layer's symbol list through the layer's renderer object:<div><pre class="programlisting"><strong class="calibre2">symbols = lyr.rendererV2().symbols()</strong>
</pre></div></li><li class="listitem" value="5">Next, we reference the first symbol, which in this case is the only symbol:<div><pre class="programlisting"><strong class="calibre2">sym = symbols[0]</strong>
</pre></div></li><li class="listitem" value="6">Once we have the symbol, we can set its color:<div><pre class="programlisting"><strong class="calibre2">sym.setColor(QColor.fromRgb(255,0,0))</strong>
</pre></div></li><li class="listitem" value="7">We must remember to repaint the layer in order to force the update:<div><pre class="programlisting"><strong class="calibre2">lyr.triggerRepaint()</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec243" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Changing the color of a layer sounds simple, but remember that in QGIS, anything you see must be altered through the canvas API. Therefore, we add the layer to the map and access the layer's symbology through its renderer. The map canvas is rendered as a raster image. The renderer is responsible for turning the layer data into a bitmap image, so the presentation information for a layer is stored with its renderer.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec86" class="calibre1"/>Rendering a single band raster using a color ramp algorithm</h1></div></div></div><p class="calibre9">A color ramp <a id="id380" class="calibre1"/>allows<a id="id381" class="calibre1"/> you<a id="id382" class="calibre1"/> to render a raster using just a few colors to represent different ranges of cell values that have similar meaning, in order to group them. The approach that will be used in this recipe is the most common way to render elevation data.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec244" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You can <a id="id383" class="calibre1"/>download a sample DEM from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/dem.zip">https://geospatialpython.googlecode.com/files/dem.zip</a>, which you can unzip in a directory named <code class="literal">rasters</code> in your <code class="literal">qgis_data </code>directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec245" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In the following steps, we will set up objects to color a raster, create a list establishing the color ramp ranges, apply the ramp to the layer renderer, and finally add the layer to the map. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we import the <code class="literal">QtGui</code> library for color objects in the QGIS <strong class="calibre2">Python Console</strong>:<div><pre class="programlisting"><strong class="calibre2">from PyQt4 import QtGui</strong>
</pre></div></li><li class="listitem" value="2">Next, we load the raster layer, as follows:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsRasterLayer("/Users/joellawhead/qgis_data/rasters/dem.asc", "DEM")</strong>
</pre></div></li><li class="listitem" value="3">Now, we create a generic raster shader object:<div><pre class="programlisting"><strong class="calibre2">s = QgsRasterShader()</strong>
</pre></div></li><li class="listitem" value="4">Then, we instantiate the specialized ramp shader object:<div><pre class="programlisting"><strong class="calibre2">c = QgsColorRampShader()</strong>
</pre></div></li><li class="listitem" value="5">We must name a type for the ramp shader. In this case, we use an <code class="literal">INTERPOLATED</code> shader:<div><pre class="programlisting"><strong class="calibre2">c.setColorRampType(QgsColorRampShader.INTERPOLATED)</strong>
</pre></div></li><li class="listitem" value="6">Now, we'll create a list of our color ramp definitions:<div><pre class="programlisting"><strong class="calibre2">i = []</strong>
</pre></div></li><li class="listitem" value="7">Then, we populate the list with color ramp values that correspond to elevation value ranges:<div><pre class="programlisting"><strong class="calibre2">i.append(QgsColorRampShader.ColorRampItem(400, QtGui.QColor('#d7191c'), '400'))</strong>
<strong class="calibre2">i.append(QgsColorRampShader.ColorRampItem(900, QtGui.QColor('#fdae61'), '900'))</strong>
<strong class="calibre2">i.append(QgsColorRampShader.ColorRampItem(1500, QtGui.QColor('#ffffbf'), '1500'))</strong>
<strong class="calibre2">i.append(QgsColorRampShader.ColorRampItem(2000, QtGui.QColor('#abdda4'), '2000'))</strong>
<strong class="calibre2">i.append(QgsColorRampShader.ColorRampItem(2500, QtGui.QColor('#2b83ba'), '2500'))</strong>
</pre></div></li><li class="listitem" value="8">Now <a id="id384" class="calibre1"/>we assign the color ramp to our shader:<div><pre class="programlisting"><strong class="calibre2">c.setColorRampItemList(i)</strong>
</pre></div></li><li class="listitem" value="9">Now, we<a id="id385" class="calibre1"/> tell the generic raster shader to use the color ramp:<div><pre class="programlisting"><strong class="calibre2">s.setRasterShaderFunction(c)</strong>
</pre></div></li><li class="listitem" value="10">Next, we create a raster renderer object with the shader:<div><pre class="programlisting"><strong class="calibre2">ps = QgsSingleBandPseudoColorRenderer(lyr.dataProvider(), 1,  s)</strong>
</pre></div></li><li class="listitem" value="11">We assign the renderer to the raster layer:<div><pre class="programlisting"><strong class="calibre2">lyr.setRenderer(ps)</strong>
</pre></div></li><li class="listitem" value="12">Finally, we add the layer to the canvas in order to view it:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec246" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre9">While it takes a stack of four objects to create a color ramp, this recipe demonstrates how flexible the PyQGIS API is. Typically, the more objects it takes to accomplish an operation in QGIS, the richer the API is, giving you the flexibility to make complex maps.</p><p class="calibre9">Notice that in each <code class="literal">ColorRampItem</code> object, you specify a starting elevation value, the color, and a label as the string. The range for the color ramp ends at any value less than the following item. So, in this case, the first color will be assigned to the cells with a value between 400 and 899. The following screenshot shows the applied color ramp.</p><div><img src="img/00040.jpeg" alt="How it works…" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec87" class="calibre1"/>Creating a complex vector layer symbol</h1></div></div></div><p class="calibre9">The true power<a id="id386" class="calibre1"/> of QGIS symbology lies in its ability to stack multiple symbols in order to create a single complex symbol. This<a id="id387" class="calibre1"/> ability makes it possible to create virtually any type of map symbol you can imagine. In this recipe, we'll merge two symbols to create a single symbol and begin unlocking the potential of complex symbols.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec247" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, we will need a line shapefile, which you can download and extract from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/paths.zip">https://geospatialpython.googlecode.com/svn/paths.zip</a>.</p><p class="calibre9">Add this shapefile to a directory named <code class="literal">shapes</code> in your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec248" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre9">Using the <strong class="calibre2">QGISPythonConsole</strong>,we will create a classic railroad line symbol by placing a series of short, rotated line markers along a regular line symbol. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we load our line shapefile:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/Users/joellawhead/qgis_data/shapes/paths.shp", "Route", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, we get the symbol list and reference the default symbol:<div><pre class="programlisting"><strong class="calibre2">symbolList = lyr.rendererV2().symbols()</strong>
<strong class="calibre2">symbol = symbolList[0]</strong>
</pre></div></li><li class="listitem" value="3">Then, we <a id="id388" class="calibre1"/>create a shorter variable name for the symbol layer registry:<div><pre class="programlisting"><strong class="calibre2">symLyrReg = QgsSymbolLayerV2Registry</strong>
</pre></div></li><li class="listitem" value="4">Now, we <a id="id389" class="calibre1"/>set up the line style for a simple line using a Python dictionary:<div><pre class="programlisting"><strong class="calibre2">lineStyle = {'width':'0.26', 'color':'0,0,0'}</strong>
</pre></div></li><li class="listitem" value="5">Then, we create an abstract symbol layer for a simple line:<div><pre class="programlisting"><strong class="calibre2">symLyr1Meta = symLyrReg.instance().symbolLayerMetadata("SimpleLine")</strong>
</pre></div></li><li class="listitem" value="6">We instantiate a symbol layer from the abstract layer using the line style properties:<div><pre class="programlisting"><strong class="calibre2">symLyr1 = symLyr1Meta.createSymbolLayer(lineStyle)</strong>
</pre></div></li><li class="listitem" value="7">Now, we add the symbol layer to the layer's symbol:<div><pre class="programlisting"><strong class="calibre2">symbol.appendSymbolLayer(symLyr1)</strong>
</pre></div></li><li class="listitem" value="8">Now, in order to create the rails on the railroad, we begin building a marker line style with another Python dictionary, as follows:<div><pre class="programlisting"><strong class="calibre2">markerStyle = {}</strong>
<strong class="calibre2">markerStyle['width'] = '0.26'</strong>
<strong class="calibre2">markerStyle['color'] = '0,0,0'</strong>
<strong class="calibre2">markerStyle['interval'] = '3'</strong>
<strong class="calibre2">markerStyle['interval_unit'] = 'MM'</strong>
<strong class="calibre2">markerStyle['placement'] = 'interval'</strong>
<strong class="calibre2">markerStyle['rotate'] = '1'</strong>
</pre></div></li><li class="listitem" value="9">Then, we create the marker line abstract symbol layer for the second symbol:<div><pre class="programlisting"><strong class="calibre2">symLyr2Meta = symLyrReg.instance().symbolLayerMetadata("MarkerLine")</strong>
</pre></div></li><li class="listitem" value="10">We instatiate the symbol layer, as shown here:<div><pre class="programlisting"><strong class="calibre2">symLyr2 = symLyr2Meta.createSymbolLayer(markerStyle)</strong>
</pre></div></li><li class="listitem" value="11">Now, we must work with a subsymbol that defines the markers along the marker line:<div><pre class="programlisting"><strong class="calibre2">sybSym = symLyr2.subSymbol()</strong>
</pre></div></li><li class="listitem" value="12">We must delete the default subsymbol:<div><pre class="programlisting"><strong class="calibre2">sybSym.deleteSymbolLayer(0)</strong>
</pre></div></li><li class="listitem" value="13">Now, we set <a id="id390" class="calibre1"/>up the style for our rail marker using a dictionary:<div><pre class="programlisting"><strong class="calibre2">railStyle = {'size':'2', 'color':'0,0,0', 'name':'line', 'angle':'0'}</strong>
</pre></div></li><li class="listitem" value="14">Now, we <a id="id391" class="calibre1"/>repeat the process of building a symbol layer and add it to the subsymbol:<div><pre class="programlisting"><strong class="calibre2">railMeta = symLyrReg.instance().symbolLayerMetadata("SimpleMarker")</strong>
<strong class="calibre2">rail = railMeta.createSymbolLayer(railStyle) </strong>
<strong class="calibre2">sybSym.appendSymbolLayer(rail)</strong>
</pre></div></li><li class="listitem" value="15">Then, we add the subsymbol to the second symbol layer:<div><pre class="programlisting"><strong class="calibre2">symbol.appendSymbolLayer(symLyr2)</strong>
</pre></div></li><li class="listitem" value="16">Finally, we add the layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec249" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre9">First, we must create a simple line symbol. The marker line by itself will render correctly, but the underlying simple line will be a randomly chosen color. We must also change the subsymbol of the marker line because the default subsymbol is a simple circle.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec88" class="calibre1"/>Using icons as vector layer symbols</h1></div></div></div><p class="calibre9">In addition to <a id="id392" class="calibre1"/>the default symbol types <a id="id393" class="calibre1"/>available in QGIS, you can also use TrueType fonts as map symbols. TrueType fonts are scalable vector graphics that can be used as point markers. In this recipe, we'll create this type of symbol.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec250" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You can download the point shapefile used in this recipe from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Extract it to your <code class="literal">qgis_data</code> directory in a folder named <code class="literal">nyc</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec251" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre9">We will load a point shapefile as a layer and then use the character <code class="literal">G</code> in a freely-available font called <code class="literal">Webdings</code>, which<a id="id394" class="calibre1"/> is probably already <a id="id395" class="calibre1"/>on your system, to render a building icon on each point in the layer. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll define the path to our point shapefile:<div><pre class="programlisting"><strong class="calibre2">src = "/qgis_data/nyc/NYC_MUSEUMS_GEO.shp"</strong>
</pre></div></li><li class="listitem" value="2">Then, we'll load the vector layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer(src, "Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Now, we'll use a Python dictionary to define the font properties:<div><pre class="programlisting"><strong class="calibre2">fontStyle = {}</strong>
<strong class="calibre2">fontStyle['color'] = '#000000'</strong>
<strong class="calibre2">fontStyle['font'] = 'Webdings'</strong>
<strong class="calibre2">fontStyle['chr'] = 'G'</strong>
<strong class="calibre2">fontStyle['size'] = '6'</strong>
</pre></div></li><li class="listitem" value="4">Now, we'll create a font symbol layer:<div><pre class="programlisting"><strong class="calibre2">symLyr1 = QgsFontMarkerSymbolLayerV2.create(fontStyle)</strong>
</pre></div></li><li class="listitem" value="5">Then, we'll change the default symbol layer of the vector layer to our font's symbol information:<div><pre class="programlisting"><strong class="calibre2">lyr.rendererV2().symbols()[0].changeSymbolLayer(0, symLyr1)</strong>
</pre></div></li><li class="listitem" value="6">Finally, we'll add the layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec252" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre9">The font marker symbol layer is just another type of marker layer; however, the range of possibilities with vector fonts is far broader than the built-in fonts in QGIS. Many industries define standard cartographic symbols using customized fonts as markers.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec89" class="calibre1"/>Creating a graduated vector layer symbol renderer</h1></div></div></div><p class="calibre9">A graduated vector layer symbol renderer<a id="id396" class="calibre1"/> is the <a id="id397" class="calibre1"/>vector equivalent of a raster color ramp. You can group features into similar ranges and use a limited set of colors to visually identify these ranges. In this recipe, we'll render a graduated symbol using a polygon shapefile.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec253" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You can download a shapefile containing a set of urban area polygons from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip">https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip</a>.</p><p class="calibre9">Extract this file to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec254" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will classify<a id="id398" class="calibre1"/> each<a id="id399" class="calibre1"/> urban area by population size using a graduated symbol, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we import the <code class="literal">QColor</code> object to build our color range.<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtGui import QColor</strong>
</pre></div></li><li class="listitem" value="2">Next, we load our polygon shapefile as a vector layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/ms/MS_UrbanAnC10.shp", "Urban Areas", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Now, we build some nested Python tuples that define the symbol graduation. Each item in the tuple contains a range label, range start value, range end value, and a color name, as shown here:<div><pre class="programlisting"><strong class="calibre2">population = (</strong>
<strong class="calibre2">("Village", 0.0, 3159.0, "cyan"), </strong>
<strong class="calibre2">("Small town", 3160.0, 4388.0, "blue"),</strong>
<strong class="calibre2">("Town", 43889.0, 6105.0, "green"),</strong>
<strong class="calibre2">("City", 6106.0, 10481.0, "yellow"),</strong>
<strong class="calibre2">("Large City", 10482.0, 27165, "orange"),</strong>
<strong class="calibre2">("Metropolis", 27165.0, 1060061.0, "red"))</strong>
</pre></div></li><li class="listitem" value="4">Then, we establish a Python list to hold our QGIS renderer objects:<div><pre class="programlisting"><strong class="calibre2">ranges = []</strong>
</pre></div></li><li class="listitem" value="5">Next, we loop through our range list, build the QGIS symbols, and add them to the renderer list:<div><pre class="programlisting"><strong class="calibre2">for label, lower, upper, color in population:</strong>
<strong class="calibre2">sym = QgsSymbolV2.defaultSymbol(lyr.geometryType())</strong>
<strong class="calibre2">sym.setColor(QColor(color))</strong>
<strong class="calibre2">rng = QgsRendererRangeV2(lower, upper, sym, label)</strong>
<strong class="calibre2">ranges.append(rng)</strong>
</pre></div></li><li class="listitem" value="6">Now, reference the field name containing the population values in the shapefile attributes:<div><pre class="programlisting"><strong class="calibre2">field = "POP"</strong>
</pre></div></li><li class="listitem" value="7">Then, we create the renderer:<div><pre class="programlisting"><strong class="calibre2">renderer = QgsGraduatedSymbolRendererV2(field, ranges)</strong>
</pre></div></li><li class="listitem" value="8">We assign the renderer to the layer:<div><pre class="programlisting"><strong class="calibre2">lyr.setRendererV2(renderer)</strong>
</pre></div></li><li class="listitem" value="9">Finally, we add the map to the layer:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec255" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The approach to<a id="id400" class="calibre1"/> using a graduated <a id="id401" class="calibre1"/>symbol for a vector layer is very similar to the color ramp shader for a raster layer. You can have as many ranges as you'd like by extending the Python tuple that is used to build the ranges. Of course, you can also build your own algorithms by programmatically examining the data fields first and then dividing up the values in equal intervals or some other scheme.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec90" class="calibre1"/>Creating a categorized vector layer symbol</h1></div></div></div><p class="calibre9">A categorized vector layer symbol <a id="id402" class="calibre1"/>allows you to <a id="id403" class="calibre1"/>create distinct categories with colors and labels for unique features. This approach is typically used for datasets with a limited number of unique types of features. In this recipe, we'll categorize a vector layer into three different categories.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec256" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, we'll use a land use shapefile, which you can download from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/landuse_shp.zip">https://geospatialpython.googlecode.com/svn/landuse_shp.zip</a>.</p><p class="calibre9">Extract it to a directory named <code class="literal">hancock</code> in your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec257" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the<a id="id404" class="calibre1"/> vector layer, create three categories of land use, and render them as categorized symbols. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the <code class="literal">QColor</code> object for our category colors:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtGui import QColor</strong>
</pre></div></li><li class="listitem" value="2">Then, we load the vector layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("Users/joellawhead/qgis_data/hancock/landuse.shp", "Land Use", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Next, we'll create our three land use categories using a Python dictionary with a field value as the key, color name, and label:<div><pre class="programlisting"><strong class="calibre2">landuse = {</strong>
<strong class="calibre2">  "0":("yellow", "Developed"),</strong>
<strong class="calibre2">  "1":("darkcyan", "Water"),</strong>
<strong class="calibre2">  "2":("green", "Land")}</strong>
</pre></div></li><li class="listitem" value="4">Now, we<a id="id405" class="calibre1"/> can build our categorized renderer items:<div><pre class="programlisting"><strong class="calibre2">categories = []</strong>
<strong class="calibre2">for terrain, (color, label) in landuse.items():</strong>
<strong class="calibre2">  sym = QgsSymbolV2.defaultSymbol(lyr.geometryType())</strong>
<strong class="calibre2">  sym.setColor(QColor(color))</strong>
<strong class="calibre2">  category = QgsRendererCategoryV2(terrain, sym, label)</strong>
<strong class="calibre2">  categories.append(category)</strong>
</pre></div></li><li class="listitem" value="5">We name the field containing the land use value:<div><pre class="programlisting"><strong class="calibre2">field = "DN"</strong>
</pre></div></li><li class="listitem" value="6">Next, we build the renderer:<div><pre class="programlisting"><strong class="calibre2">renderer = QgsCategorizedSymbolRendererV2(field, categories)</strong>
</pre></div></li><li class="listitem" value="7">We add the renderer to the layer:<div><pre class="programlisting"><strong class="calibre2">lyr.setRendererV2(renderer)</strong>
</pre></div></li><li class="listitem" value="8">Finally, we add the categorized layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec258" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">There are only slight differences in the configurations of the various types of renderers in QGIS. Setting them <a id="id406" class="calibre1"/>up by first defining the properties of the renderer using native Python objects makes your code easier to read and ultimately manage. The following map image illustrates the categorized symbol in this recipe:</p><div><img src="img/00041.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec91" class="calibre1"/>Creating a map bookmark</h1></div></div></div><p class="calibre9">Map bookmarks <a id="id407" class="calibre1"/>allow you to save a location on a<a id="id408" class="calibre1"/> map in QGIS, so you can quickly jump to the points you need to view repeatedly without manually panning and zooming the map. PyQGIS does not contain API commands to read, write, and zoom to bookmarks. Fortunately, QGIS stores the bookmarks in an SQLite database. Python has a built-in SQLite library that we can use to manipulate bookmarks using the database API.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec259" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You can download a census tract polygon shapefile to use with this recipe from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip">https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip</a>.</p><p class="calibre9">Extract it to your <code class="literal">qgis_data</code> directory. We are going to create a bookmark that uses an area of interest within this shapefile, so you can manually load the bookmark in order to test it out.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec260" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will access the QGIS configuration variables to get the path of the user database, which stores the <a id="id409" class="calibre1"/>bookmarks. Then, we'll connect to this database and execute a SQL query that inserts a bookmark. Finally, we'll commit the changes to the database, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, using the QGIS <strong class="calibre2">PythonConsole</strong>, we must import Python's built-in SQLite library:<div><pre class="programlisting"><strong class="calibre2">import sqlite3</strong>
</pre></div></li><li class="listitem" value="2">Next, get the path to the database:<div><pre class="programlisting"><strong class="calibre2">dbPath = QgsApplication.qgisUserDbFilePath()</strong>
</pre></div></li><li class="listitem" value="3">Now, we connect to the database:<div><pre class="programlisting"><strong class="calibre2">db = sqlite3.connect(dbPath)</strong>
</pre></div></li><li class="listitem" value="4">Then, we <a id="id410" class="calibre1"/>need a database cursor to manipulate the database:<div><pre class="programlisting"><strong class="calibre2">cursor = db.cursor()</strong>
</pre></div></li><li class="listitem" value="5">Now, we can execute the SQL query, which is a string. In the <code class="literal">VALUES</code> portion of the query, we will leave the bookmark ID as <code class="literal">NULL</code> but give it a name, then we leave the project name <code class="literal">NULL</code> and set the extents, as follows:<div><pre class="programlisting"><strong class="calibre2">cursor.execute("""INSERT INTO tbl_bookmarks(</strong>
<strong class="calibre2">  bookmark_id, name, project_name,</strong>
<strong class="calibre2">  xmin, ymin, xmax, ymax, </strong>
<strong class="calibre2">  projection_srid)</strong>
<strong class="calibre2">  VALUES(NULL, "BSL", NULL,</strong>
<strong class="calibre2">    -89.51715550010032,</strong>
<strong class="calibre2">    30.233838337125075,</strong>
<strong class="calibre2">    -89.27257255649518,</strong>
<strong class="calibre2">    30.381717490617945,</strong>
<strong class="calibre2">    4269)""")</strong>
</pre></div></li><li class="listitem" value="6">Then, we commit the changes:<div><pre class="programlisting"><strong class="calibre2">db.commit()</strong>
</pre></div></li><li class="listitem" value="7">To test the map bookmark, load the census tract layer onto the map by dragging and dropping it from your filesystem into QGIS.</li><li class="listitem" value="8">Next, click on the <strong class="calibre2">View</strong> menu in QGIS and select <strong class="calibre2">ShowBookmarks</strong>.</li><li class="listitem" value="9">Then, select the <strong class="calibre2">BSL bookmark</strong> and click on the <strong class="calibre2">ZoomTo</strong> button.</li><li class="listitem" value="10">Verify that the map snapped to an area of interest close to the polygons, with OBJECTIDs from 4625 to 4627.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec261" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Even when QGIS doesn't provide a high-level API, you can almost always use Python to dig deeper and <a id="id411" class="calibre1"/>access the<a id="id412" class="calibre1"/> information you want. QGIS is built on open source software, therefore no part of the program is truly off-limits.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec92" class="calibre1"/>Navigating to a map bookmark</h1></div></div></div><p class="calibre9">Map bookmarks store<a id="id413" class="calibre1"/> important locations on a<a id="id414" class="calibre1"/> map, so you can quickly find them later. You can programmatically navigate to bookmarks using the Python <code class="literal">sqlite3</code> library in order to access the bookmarks database table in the QGIS user database and then use the PyQGIS canvas API.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec262" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use a census tract layer to test out the bookmark navigation. You can download the zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip">https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip</a>.</p><p class="calibre9">Manually load this layer into QGIS after extracting it from the ZIP file. Also, make sure that you have completed the previous recipe, <em class="calibre10">Creating a map bookmark</em>. You will need a bookmark named BSL for an area of interest in this shapefile.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec263" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will retrieve a bookmark from the QGIS user database and then set the map's extents to this bookmark. To do this, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, import the Python <code class="literal">sqlite3</code> library:<div><pre class="programlisting"><strong class="calibre2">import sqlite3</strong>
</pre></div></li><li class="listitem" value="2">Next, get the location of the user database from the QGIS data:<div><pre class="programlisting"><strong class="calibre2">dbPath = QgsApplication.qgisUserDbFilePath()</strong>
</pre></div></li><li class="listitem" value="3">Now, we connect to the database:<div><pre class="programlisting"><strong class="calibre2">db = sqlite3.connect(dbPath)</strong>
</pre></div></li><li class="listitem" value="4">Then, we need a database cursor to run queries:<div><pre class="programlisting"><strong class="calibre2">cursor = db.cursor()</strong>
</pre></div></li><li class="listitem" value="5">Now, we can get the bookmark information for the bookmark named <strong class="calibre2">BSL</strong>:<div><pre class="programlisting"><strong class="calibre2">cursor.execute("""SELECT * FROM tbl_bookmarks WHERE name='BSL'""")</strong>
</pre></div></li><li class="listitem" value="6">Now, we'll get the complete results from the query:<div><pre class="programlisting"><strong class="calibre2">row = cursor.fetchone()</strong>
</pre></div></li><li class="listitem" value="7">Then, we split the values of the result into multiple variables:<div><pre class="programlisting"><strong class="calibre2">id,mark_name,project,xmin,ymin,xmax,ymax,srid = row</strong>
</pre></div></li><li class="listitem" value="8">Now, we <a id="id415" class="calibre1"/>can use the bookmark to create a QGIS extent rectangle:<div><pre class="programlisting"><strong class="calibre2">rect = QgsRectangle(xmin, ymin, xmax, ymax)</strong>
</pre></div></li><li class="listitem" value="9">Next, we reference the map canvas:<div><pre class="programlisting"><strong class="calibre2">canvas = qgis.utils.iface.mapCanvas()</strong>
</pre></div></li><li class="listitem" value="10">Finally, we set the extent of the canvas to the rectangle and then refresh the canvas:<div><pre class="programlisting"><strong class="calibre2">canvas.setExtent(rect)</strong>
<strong class="calibre2">canvas.refresh()</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec264" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Reading and <a id="id416" class="calibre1"/>writing bookmarks with SQLite is straightforward even though its not a part of the main PyQGIS API. Notice that bookmarks have a placeholder for a project name, which you can use to filter bookmarks by project if needed.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec93" class="calibre1"/>Setting scale-based visibility for a layer</h1></div></div></div><p class="calibre9">Sometimes, a GIS layer<a id="id417" class="calibre1"/> only makes sense<a id="id418" class="calibre1"/> when it is displayed at a certain scale, for example, a complex road network. PyQGIS supports scale-based visibility to programmatically set the scale range, in which a layer is displayed. In this recipe, we'll investigate scale-dependent layers.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec265" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need the sample census tract shapefile available as a ZIP file from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip">https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip</a>.</p><p class="calibre9">Extract the zipped layer to a directory named <code class="literal">census</code> in your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec266" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the vector layer, toggle scale-based visibility, set the visibility range, and then add the layer to the map. To do this, perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/Users/joellawhead/qgis_data/census/GIS_CensusTract_poly.shp", "Census", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, we toggle scale-based visibility:<div><pre class="programlisting"><strong class="calibre2">lyr.toggleScaleBasedVisibility(True)</strong>
</pre></div></li><li class="listitem" value="3">Then, we<a id="id419" class="calibre1"/> set the minimum and maximum map scales at which the layer is visible:<div><pre class="programlisting"><strong class="calibre2">lyr.setMinimumScale(22945.0)</strong>
<strong class="calibre2">lyr.setMaximumScale(1000000.0)</strong>
</pre></div></li><li class="listitem" value="4">Now, we add the layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li><li class="listitem" value="5">Finally, manually zoom in and out of the map to ensure that the layer disappears and reappears at the proper scales.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec267" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The map scale is<a id="id420" class="calibre1"/> a ratio of map units to physical map size, expressed as a floating-point number. You must remember to toggle scale-dependent visibility so that QGIS knows that it needs to check the range each time the map scale changes.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec94" class="calibre1"/>Using SVG for layer symbols</h1></div></div></div><p class="calibre9">
<strong class="calibre2">Scalable Vector Graphics </strong>(<strong class="calibre2">SVG)</strong> are an<a id="id421" class="calibre1"/> XML standard <a id="id422" class="calibre1"/>that defines vector graphics <a id="id423" class="calibre1"/>that can be scaled at any resolution. QGIS can use SVG files as markers for points. In this recipe, we'll use Python to apply one of the SVG symbols included with QGIS to a point layer.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec268" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, download the following zipped point shapefile layer from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Extract it to your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec269" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In the following steps, we'll load<a id="id424" class="calibre1"/> the vector layer, build a symbol layer and renderer, and add it to the layer, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll define the path to the shapefile:<div><pre class="programlisting"><strong class="calibre2">src = "/Users/joellawhead/qgis_data/NYC_MUSEUMS_GEO/NYC_MUSEUMS_GEO.shp"</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer(src, "Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Now, we define the properties of the symbol, including the location of the SVG file as a Python dictionary:<div><pre class="programlisting"><strong class="calibre2">svgStyle = {}</strong>
<strong class="calibre2">svgStyle['fill'] = '#0000ff'</strong>
<strong class="calibre2">svgStyle['name'] = 'landmark/tourism=museum.svg'</strong>
<strong class="calibre2">svgStyle['outline'] = '#000000'</strong>
<strong class="calibre2">svgStyle['outline-width'] = '6.8'</strong>
<strong class="calibre2">svgStyle['size'] = '6'</strong>
</pre></div></li><li class="listitem" value="4">Then, we create an SVG symbol layer:<div><pre class="programlisting"><strong class="calibre2">symLyr1 = QgsSvgMarkerSymbolLayerV2.create(svgStyle)</strong>
</pre></div></li><li class="listitem" value="5">Now, we<a id="id425" class="calibre1"/> change the layer renderer's default symbol layer:<div><pre class="programlisting"><strong class="calibre2">lyr.rendererV2().symbols()[0].changeSymbolLayer(0, symLyr1)</strong>
</pre></div></li><li class="listitem" value="6">Finally, we add the layer to the map in order to view the SVG symbol:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec270" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The default SVG layers are stored in the QGIS application directory. There are numerous graphics available that cover many common uses. You can also add your own graphics as well. The following map image shows the recipe's output:</p><div><img src="img/00042.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec95" class="calibre1"/>Using pie charts for symbols</h1></div></div></div><p class="calibre9">QGIS has<a id="id426" class="calibre1"/> the ability to<a id="id427" class="calibre1"/> use dynamic pie charts as symbols describing the statistics in a given region. In this recipe, we'll use pie chart symbols on a polygon layer in QGIS.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec271" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, download the following zipped shapefile and extract it to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/County10PopnHou.zip">https://geospatialpython.googlecode.com/svn/County10PopnHou.zip</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec272" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">As with other renderers, we will build a symbol layer, add it to a renderer, and display the layer on the map. The pie chart diagram renderers are more complex than other renderers but have many more options. Perform the following steps to create a pie chart map:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we import the PyQt GUI library:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtGui import *</strong>
</pre></div></li><li class="listitem" value="2">Then, we load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/Users/joellawhead/qgis_data/ms/County10PopnHou.shp", "Population", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Next, we set up categories based on attribute names:<div><pre class="programlisting"><strong class="calibre2">categories = [u'PCT_WHT', u'PCT_BLK', u'PCT_AMIND', u'PCT_ASIAN', u'PCT_HAW', u'PCT_ORA', u'PCT_MR', u'PCT_HISP']</strong>
</pre></div></li><li class="listitem" value="4">Now, we set up a list of corresponding colors for each category:<div><pre class="programlisting"><strong class="calibre2">colors = ['#3727fa','#01daae','#f849a6','#268605','#6810ff','#453990','#630f2f','#07dd45']</strong>
</pre></div></li><li class="listitem" value="5">Next, we <a id="id428" class="calibre1"/>convert the hex color values to <code class="literal">QColor</code> objects:<div><pre class="programlisting"><strong class="calibre2">qcolors = []</strong>
<strong class="calibre2">for c in colors:</strong>
<strong class="calibre2">  qcolors.append(QColor(c))</strong>
</pre></div></li><li class="listitem" value="6">Now, we reference the map canvas:<div><pre class="programlisting"><strong class="calibre2">canvas = iface.mapCanvas()</strong>
</pre></div></li><li class="listitem" value="7">Then, we create a pie diagram object:<div><pre class="programlisting"><strong class="calibre2">diagram = QgsPieDiagram()</strong>
</pre></div></li><li class="listitem" value="8">Then, we create a diagram settings object:<div><pre class="programlisting"><strong class="calibre2">ds = QgsDiagramSettings()</strong>
</pre></div></li><li class="listitem" value="9">Now, we define all the diagram settings that will be used for the renderer:<div><pre class="programlisting"><strong class="calibre2">ds.font = QFont("Helvetica", 12)</strong>
<strong class="calibre2">ds.transparency = 0</strong>
<strong class="calibre2">ds.categoryColors = qcolors</strong>
<strong class="calibre2">ds.categoryAttributes = categories</strong>
<strong class="calibre2">ds.size = QSizeF(100.0, 100.0)</strong>
<strong class="calibre2">ds.sizeType = 0 </strong>
<strong class="calibre2">ds.labelPlacementMethod = 1 </strong>
<strong class="calibre2">ds.scaleByArea = True </strong>
<strong class="calibre2">ds.minimumSize = 0 </strong>
<strong class="calibre2">ds.BackgroundColor = QColor(255,255,255,0)</strong>
<strong class="calibre2">ds.PenColor = QColor("black") </strong>
<strong class="calibre2">ds.penWidth = 0</strong>
</pre></div></li><li class="listitem" value="10">Now, we <a id="id429" class="calibre1"/>can create our diagram renderer:<div><pre class="programlisting"><strong class="calibre2">dr = QgsLinearlyInterpolatedDiagramRenderer()</strong>
</pre></div></li><li class="listitem" value="11">We must set a few size parameters for our diagrams:<div><pre class="programlisting"><strong class="calibre2">dr.setLowerValue(0.0)</strong>
<strong class="calibre2">dr.setLowerSize(QSizeF(0.0, 0.0))</strong>
<strong class="calibre2">dr.setUpperValue(2000000)</strong>
<strong class="calibre2">dr.setUpperSize(QSizeF(40,40))</strong>
<strong class="calibre2">dr.setClassificationAttribute(6)</strong>
</pre></div></li><li class="listitem" value="12">Then, we can add our diagram to the renderer:<div><pre class="programlisting"><strong class="calibre2">dr.setDiagram(diagram)</strong>
</pre></div></li><li class="listitem" value="13">Next, we add the renderer to the layer:<div><pre class="programlisting"><strong class="calibre2">lyr.setDiagramRenderer(dr)</strong>
</pre></div></li><li class="listitem" value="14">Now, we apply <a id="id430" class="calibre1"/>some additional placement settings at the layer level:<div><pre class="programlisting"><strong class="calibre2">dls = QgsDiagramLayerSettings() </strong>
<strong class="calibre2">dls.dist = 0</strong>
<strong class="calibre2">dls.priority = 0</strong>
<strong class="calibre2">dls.xPosColumn = -1  </strong>
<strong class="calibre2">dls.yPosColumn = -1</strong>
<strong class="calibre2">dls.placement = 0 </strong>
<strong class="calibre2">lyr.setDiagramLayerSettings(dls)</strong>
</pre></div></li><li class="listitem" value="15">In QGIS 2.6, the diagram renderer is tied to the new PAL labeling engine, so we need to activate this engine:<div><pre class="programlisting"><strong class="calibre2">label = QgsPalLayerSettings() </strong>
<strong class="calibre2">label.readFromLayer(lyr) </strong>
<strong class="calibre2">label.enabled = True </strong>
<strong class="calibre2">label.writeToLayer(lyr)</strong>
</pre></div></li><li class="listitem" value="16">Next, we <a id="id431" class="calibre1"/>delete any cached images that are rendered and force the layer to repaint:<div><pre class="programlisting"><strong class="calibre2">if hasattr(lyr, "setCacheImage"):</strong>
<strong class="calibre2">    lyr.setCacheImage(None)</strong>
<strong class="calibre2">    </strong>
<strong class="calibre2">lyr.triggerRepaint()</strong>
</pre></div></li><li class="listitem" value="17">Finally, we add our diagram layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec273" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The basics of pie chart diagram symbols are straightforward and work in a similar way to other types of symbols<a id="id432" class="calibre1"/> and renderers. However, it gets a little confusing as we need to apply settings at three different levels – the diagram level, the render level, and the layer level. It turns out they are actually quite complex. Most of the settings are poorly documented, if at all. Fortunately, most of them are self-explanatory. The following screenshot shows an example of the completed pie chart diagram map:</p><div><img src="img/00043.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec274" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">To learn more about<a id="id433" class="calibre1"/> what is possible with pie chart diagram symbols, you can experiment with this recipe in the Script Runner plugin, where you can change or remove settings and quickly re-render the map. You can also manually change the settings using the QGIS dialogs and then export the style to an XML file and see what settings are used. Most of them map to the Python API well.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec96" class="calibre1"/>Using the OpenStreetMap service</h1></div></div></div><p class="calibre9">Cloud-based technology is<a id="id434" class="calibre1"/> moving more and more data<a id="id435" class="calibre1"/> to the Internet, and GIS is no exception. QGIS can load web-based data using Open GIS Consortium standards, such as <strong class="calibre2">Web Map Service (WMS). </strong>The <a id="id436" class="calibre1"/>easiest way to add WMS layers is using the <strong class="calibre2">Geospatial Data Abstraction Library (GDAL</strong>) and<a id="id437" class="calibre1"/> its virtual filesystem feature to load a tiled layer.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec275" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You don't need <a id="id438" class="calibre1"/>to do any preparation for this recipe, other than opening the Python console plugin within QGIS.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec276" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will create an XML template that describes the tiled web service from OpenStreetMap we <a id="id439" class="calibre1"/>want to import. Then, we'll turn it into a GDAL virtual file and load it as a QGIS raster layer. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we import the GDAL library:<div><pre class="programlisting"><strong class="calibre2">from osgeo import gdal</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll create our XML template, describing the OpenStreetMap tiled web service:<div><pre class="programlisting">xml = """&lt;GDAL_WMS&gt;
&lt;Service name="TMS"&gt;
&lt;ServerUrl&gt;http://tile.openstreetmap.org/${z}/${x}/${y}.png&lt;/ServerUrl&gt;
&lt;/Service&gt;
&lt;DataWindow&gt;
&lt;UpperLeftX&gt;-20037508.34&lt;/UpperLeftX&gt;
&lt;UpperLeftY&gt;20037508.34&lt;/UpperLeftY&gt;
&lt;LowerRightX&gt;20037508.34&lt;/LowerRightX&gt;
&lt;LowerRightY&gt;-20037508.34&lt;/LowerRightY&gt;
&lt;TileLevel&gt;18&lt;/TileLevel&gt;
&lt;TileCountX&gt;1&lt;/TileCountX&gt;
&lt;TileCountY&gt;1&lt;/TileCountY&gt;
&lt;YOrigin&gt;top&lt;/YOrigin&gt;
&lt;/DataWindow&gt;
&lt;Projection&gt;EPSG:900913&lt;/Projection&gt;
&lt;BlockSizeX&gt;256&lt;/BlockSizeX&gt;
&lt;BlockSizeY&gt;256&lt;/BlockSizeY&gt;
&lt;BandsCount&gt;3&lt;/BandsCount&gt;
&lt;Cache /&gt;
&lt;/GDAL_WMS&gt;"""</pre></div></li><li class="listitem" value="3">Now, we'll create the path for our GDAL virtual filesystem's file:<div><pre class="programlisting"><strong class="calibre2">vfn = "/vsimem/osm.xml"</strong>
</pre></div></li><li class="listitem" value="4">Next, we use GDAL to create the virtual file using the path and the XML document:<div><pre class="programlisting"><strong class="calibre2">gdal.FileFromMemBuffer(vfn, xml)</strong>
</pre></div></li><li class="listitem" value="5">Now, we can create a raster layer from the virtual file:<div><pre class="programlisting"><strong class="calibre2">rasterLyr = QgsRasterLayer(vfn, "OSM")</strong>
</pre></div></li><li class="listitem" value="6">Before we add the layer to the map, we'll make sure that it's valid:<div><pre class="programlisting"><strong class="calibre2">rasterLyr.isValid()</strong>
</pre></div></li><li class="listitem" value="7">Finally, add<a id="id440" class="calibre1"/> the layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([rasterLyr])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec277" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">There are other<a id="id441" class="calibre1"/> ways to load tiled map services such as OpenStreetMap into QGIS programmatically, but GDAL is by far the most robust. The prefix <code class="literal">vsimem</code> tells GDAL to use a virtual file in order to manage the tiles. This approach frees you from the need to manage downloaded tiles on disk directly and allows you to focus on your application's functionality.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec97" class="calibre1"/>Using the Bing aerial image service</h1></div></div></div><p class="calibre9">While <a id="id442" class="calibre1"/>there are many services that provide street map tiles, there<a id="id443" class="calibre1"/> are far fewer services that provide imagery services. One excellent free service for both maps and, more importantly, imagery is Microsoft's Bing map services. We can access Bing imagery programmatically in QGIS using GDAL's WMS capability coupled with virtual files.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec278" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You don't need to do any preparation for this recipe other than opening the Python console plugin within QGIS.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec279" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">Similar to the approach used for the previous <em class="calibre10">Using the OpenStreetMap service</em> recipe, we will create an XML file as a string to describe the service, turn it into a GDAL virtual file, and load it as a raster in QGIS. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we import the GDAL library:<div><pre class="programlisting"><strong class="calibre2">from osgeo import gdal</strong>
</pre></div></li><li class="listitem" value="2">Next, we create the XML file, describing the Bing service as a string:<div><pre class="programlisting">xml = """&lt;GDAL_WMS&gt;
  &lt;Service name="VirtualEarth"&gt;
    &lt;ServerUrl&gt;
      http://a${server_num}.ortho.tiles.virtualearth.net/tiles/a${quadkey}.jpeg?g=90
    &lt;/ServerUrl&gt;
  &lt;/Service&gt;
  &lt;MaxConnections&gt;4&lt;/MaxConnections&gt;
  &lt;Cache/&gt;
&lt;/GDAL_WMS&gt;"""</pre></div></li><li class="listitem" value="3">Now, we<a id="id444" class="calibre1"/> create the virtual file path for the XML file:<div><pre class="programlisting"><strong class="calibre2">vfn = "/vsimem/bing.xml"</strong>
</pre></div></li><li class="listitem" value="4">Then, we turn the XML file into a GDAL virtual file:<div><pre class="programlisting"><strong class="calibre2">gdal.FileFromMemBuffer(vfn, xml)</strong>
</pre></div></li><li class="listitem" value="5">Now, we<a id="id445" class="calibre1"/> can add the file as a QGIS raster layer and check its validity:<div><pre class="programlisting"><strong class="calibre2">rasterLyr = QgsRasterLayer(vfn, "BING")</strong>
<strong class="calibre2">rasterLyr.isValid()</strong>
</pre></div></li><li class="listitem" value="6">Finally, we add the layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([rasterLyr])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec280" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">GDAL has drivers for various map services. The service name for Bing is <code class="literal">VirtualEarth</code>. The <code class="literal">${}</code> clauses in the server URL provide placeholders, which will be replaced with instance-specific data when GDAL downloads styles. When using this data, you should be aware that it has copyright restrictions. Be sure to read the Bing usage agreement online.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec98" class="calibre1"/>Adding real-time weather data from OpenWeatherMap</h1></div></div></div><p class="calibre9">Real-time data<a id="id446" class="calibre1"/> is one<a id="id447" class="calibre1"/> of the most exciting data types you can add to a modern map. Most data producers make data available through <a id="id448" class="calibre1"/>
<strong class="calibre2">Open GIS Consortium </strong>standards. One such example is OpenWeatherMap, which offers an OGC<strong class="calibre2"> Web Map Service (WMS</strong>) for<a id="id449" class="calibre1"/> different real-time weather data layers. In this recipe, we'll access this service to access a real-time weather data layer.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec281" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">To prepare for this<a id="id450" class="calibre1"/> recipe, you just need to open the QGIS <strong class="calibre2">Python Console</strong> by clicking on the <strong class="calibre2">Plugins</strong> menu and selecting <strong class="calibre2">Python Console</strong>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec282" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will add a WMS weather data layer for precipitation to a QGIS map, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we specify the parameters for the <code class="literal">service</code>:<div><pre class="programlisting"><strong class="calibre2">service = 'crs=EPSG:900913&amp;dpiMode=7&amp;featureCount=10&amp;format=image/png&amp;layers=precipitation&amp;styles=&amp;url=http://wms.openweathermap.org/service'</strong>
</pre></div></li><li class="listitem" value="2">Next, we create the raster layer, specifying <code class="literal">wms</code> as the type:<div><pre class="programlisting"><strong class="calibre2">rlayer = QgsRasterLayer(service, "precip", "wms")</strong>
</pre></div></li><li class="listitem" value="3">Finally, we add the precipitation layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([rlayer])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec283" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">A WMS request<a id="id451" class="calibre1"/> is typically an HTTP <code class="literal">GET</code> request with all of the parameters as part of the URL. In PyQGIS, you use a URL-encoded format and specify the parameters separately from the URL.</p><p class="calibre9">The following map image shows the output of the precipitation layer in QGIS:</p><div><img src="img/00044.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec99" class="calibre1"/>Labeling features</h1></div></div></div><p class="calibre9">Once<a id="id452" class="calibre1"/> your map layers are styled, the next step to creating a complete map is labeling features. We'll <a id="id453" class="calibre1"/>explore the basics of labeling in this recipe.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec284" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the following zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip">https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip</a>.</p><p class="calibre9">Extract the shapefile to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> shapefile.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec285" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the<a id="id454" class="calibre1"/> point shapefile layer, create a label object, set its properties, apply it to the layer, and then add the layer to the map. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, to save space, we'll specify the path to the shapefile:<div><pre class="programlisting"><strong class="calibre2">src = "/Users/joellawhead/qgis_data/ms/MSCities_Geo_Pts.shp"</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer(src, "Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Then, we'll create the labeling object:<div><pre class="programlisting"><strong class="calibre2">label = QgsPalLayerSettings()</strong>
</pre></div></li><li class="listitem" value="4">Now, we'll configure the labels, starting with the current layer settings being read:<div><pre class="programlisting"><strong class="calibre2">label.readFromLayer(lyr)</strong>
<strong class="calibre2">label.enabled = True</strong>
</pre></div></li><li class="listitem" value="5">Then, we specify the attribute for the label data:<div><pre class="programlisting"><strong class="calibre2">label.fieldName = 'NAME10' </strong>
</pre></div></li><li class="listitem" value="6">Then, we can set the placement and size options:<div><pre class="programlisting"><strong class="calibre2">label.placement= QgsPalLayerSettings.AroundPoint</strong>
<strong class="calibre2">label.setDataDefinedProperty(QgsPalLayerSettings.Size,True,True,'8','')</strong>
</pre></div></li><li class="listitem" value="7">Next, we<a id="id455" class="calibre1"/> commit the changes to the layer:<div><pre class="programlisting"><strong class="calibre2">label.writeToLayer(lyr)</strong>
</pre></div></li><li class="listitem" value="8">Finally, we can add the layer to the map to view the labels:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([lyr])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec286" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">An interesting <a id="id456" class="calibre1"/>part of labeling is the round-trip read and write process to access the layer data and the assignment of the labeling properties. Labeling can be quite complex, but this recipe covers the basics needed to get started.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec100" class="calibre1"/>Changing map layer transparency</h1></div></div></div><p class="calibre9">Map layer transparency<a id="id457" class="calibre1"/> allows you to<a id="id458" class="calibre1"/> change the opacity of a layer, so the items behind it are visible to some degree. A common technique is to make a vector layer polygon partially transparent in order to allow the underlying imagery or elevation data to add texture to the data.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec287" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">In a directory <a id="id459" class="calibre1"/>called <code class="literal">ms</code>, in your <code class="literal">qgis_data</code> directory, download and extract the following shapefile from</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/Mississippi.zip">https://geospatialpython.googlecode.com/files/Mississippi.zip</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec288" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">The process is extremely simple. Transparency is just a method:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we load the shapefile layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/Users/joellawhead/qgis_data/ms/mississippi.shp", "Mississippi", "ogr")</strong>
</pre></div></li><li class="listitem" value="2">Next, we set the layer's transparency to <code class="literal">50</code> percent:<div><pre class="programlisting"><strong class="calibre2">lyr.setLayerTransparency(50)</strong>
</pre></div></li><li class="listitem" value="3">Finally, we add this layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec289" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">If you set the<a id="id460" class="calibre1"/> transparency to 100 percent, the layer is completely opaque. If you set it to <code class="literal">0,</code> the layer becomes completely invisible.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec101" class="calibre1"/>Adding standard map tools to the canvas</h1></div></div></div><p class="calibre9">In this <a id="id461" class="calibre1"/>recipe, you'll learn how to add standard map navigation tools to a standalone map canvas. Creating the simplest possible <a id="id462" class="calibre1"/>interactive application provides a framework to begin building specialized geospatial applications using QGIS as a library.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec290" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the following zipped shapefile and extract it to your <code class="literal">qgis_data</code> directory into a folder named <code class="literal">ms</code> from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/Mississippi.zip">https://geospatialpython.googlecode.com/files/Mississippi.zip</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec291" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will walk through the steps required to create a map canvas, add a layer to it, and then add some tools to zoom and pan the map, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, because we are working outside the QGIS Python interpreter, we need to import some QGIS and Qt libraries:<div><pre class="programlisting"><strong class="calibre2">from qgis.gui import *</strong>
<strong class="calibre2">from qgis.core import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">from PyQt4.QtCore import SIGNAL, Qt</strong>
<strong class="calibre2">import sys, os</strong>
</pre></div></li><li class="listitem" value="2">Then, we must set the location of our main QGIS application directory. This setting is platform-dependent:<div><pre class="programlisting"><strong class="calibre2"># OSX:</strong>
<strong class="calibre2">QgsApplication.setPrefixPath("/Applications/QGIS.app/Contents/MacOS/", True)</strong>
<strong class="calibre2"># Windows:</strong>
<strong class="calibre2"># app.setPrefixPath("C:/Program Files/QGIS Valmiera/apps/qgis", True)</strong>
</pre></div></li><li class="listitem" value="3">Next, we begin initializing the class:<div><pre class="programlisting"><strong class="calibre2">class MyWnd(QMainWindow):</strong>
<strong class="calibre2">  def __init__(self):</strong>
</pre></div></li><li class="listitem" value="4">Now, we<a id="id463" class="calibre1"/> can initialize the application and create the map canvas:<div><pre class="programlisting"><strong class="calibre2">QMainWindow.__init__(self)</strong>
<strong class="calibre2">QgsApplication.setPrefixPath("/Applications/QGIS.app/Contents/MacOS/", True)</strong>
<strong class="calibre2">QgsApplication.initQgis()</strong>
<strong class="calibre2">self.canvas = QgsMapCanvas()</strong>
<strong class="calibre2">self.canvas.setCanvasColor(Qt.white)</strong>
</pre></div></li><li class="listitem" value="5">Then, we<a id="id464" class="calibre1"/> can load the shapefile layer and add it to the canvas:<div><pre class="programlisting"><strong class="calibre2">self.lyr = QgsVectorLayer("/Users/joellawhead/qgis_data/ms/mississippi.shp", "Mississippi", "ogr")</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(self.lyr)</strong>
<strong class="calibre2">self.canvas.setExtent(self.lyr.extent())</strong>
<strong class="calibre2">self.canvas.setLayerSet([QgsMapCanvasLayer(self.lyr)])</strong>
<strong class="calibre2">self.setCentralWidget(self.canvas)</strong>
</pre></div></li><li class="listitem" value="6">Next, we define the buttons that will be visible on the toolbar:<div><pre class="programlisting"><strong class="calibre2">actionZoomIn = QAction("Zoom in", self)</strong>
<strong class="calibre2">actionZoomOut = QAction("Zoom out", self)</strong>
<strong class="calibre2">actionPan = QAction("Pan", self)</strong>
<strong class="calibre2">actionZoomIn.setCheckable(True)</strong>
<strong class="calibre2">actionZoomOut.setCheckable(True)</strong>
<strong class="calibre2">actionPan.setCheckable(True)</strong>
</pre></div></li><li class="listitem" value="7">Now, we connect the signal created when the buttons are clicked to the Python methods that will provide each tool's functionality:<div><pre class="programlisting"><strong class="calibre2">actionZoomIn.triggered.connect(self.zoomIn)</strong>
<strong class="calibre2">actionZoomOut.triggered.connect(self.zoomOut)</strong>
<strong class="calibre2">actionPan.triggered.connect(self.pan)</strong>
</pre></div></li><li class="listitem" value="8">Next, we create our toolbar and add the buttons:<div><pre class="programlisting"><strong class="calibre2">self.toolbar = self.addToolBar("Canvas actions")</strong>
<strong class="calibre2">(actionZoomIn)</strong>
<strong class="calibre2">self.toolbar.addAction(actionZoomOut)</strong>
<strong class="calibre2">self.toolbar.addAction(actionPan)</strong>
</pre></div></li><li class="listitem" value="9">Then, we <a id="id465" class="calibre1"/>connect the buttons to the applications states:<div><pre class="programlisting"><strong class="calibre2">self.toolPan = QgsMapToolPan(self.canvas)</strong>
<strong class="calibre2">self.toolPan.setAction(actionPan)</strong>
<strong class="calibre2">self.toolZoomIn = QgsMapToolZoom(self.canvas, False) # false = in</strong>
<strong class="calibre2">self.toolZoomIn.setAction(actionZoomIn)</strong>
<strong class="calibre2">self.toolZoomOut = QgsMapToolZoom(self.canvas, True) # true = out</strong>
<strong class="calibre2">self.toolZoomOut.setAction(actionZoomOut)</strong>
</pre></div></li><li class="listitem" value="10">Then, we define which button will be selected when the application loads:<div><pre class="programlisting"><strong class="calibre2">self.pan()</strong>
</pre></div></li><li class="listitem" value="11">Now, we define the Python methods that control the application's behavior for each tool:<div><pre class="programlisting"><strong class="calibre2">defzoomIn(self):</strong>
<strong class="calibre2">self.canvas.setMapTool(self.toolZoomIn)</strong>
<strong class="calibre2">defzoomOut(self):</strong>
<strong class="calibre2">self.canvas.setMapTool(self.toolZoomOut)</strong>
<strong class="calibre2">def pan(self):</strong>
<strong class="calibre2">self.canvas.setMapTool(self.toolPan)</strong>
</pre></div></li><li class="listitem" value="12">Then, we <a id="id466" class="calibre1"/>create a Qt application that uses our application window class:<div><pre class="programlisting"><strong class="calibre2">class MainApp(QApplication):</strong>
<strong class="calibre2">def __init__(self):</strong>
<strong class="calibre2">QApplication.__init__(self,[],True)</strong>
<strong class="calibre2">wdg = MyWnd()</strong>
<strong class="calibre2">wdg.show()</strong>
<strong class="calibre2">self.exec_()</strong>
</pre></div></li><li class="listitem" value="13">Finally, we enter the program's main loop:<div><pre class="programlisting"><strong class="calibre2">if __name__ == "__main__":</strong>
<strong class="calibre2">import sys</strong>
<strong class="calibre2">app = MainApp()</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec292" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">An <a id="id467" class="calibre1"/>application<a id="id468" class="calibre1"/> is a continuously running program loop that ends only when we quit the application. QGIS is based on the Qt windowing library, so our application class inherits from the main window class that provides the canvas and the ability to create toolbars and dialogs.This is a lot of setup, even for an extremely simple application, but once the framework for an application is complete, it becomes much easier to extend it.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec102" class="calibre1"/>Using a map tool to draw points on the canvas</h1></div></div></div><p class="calibre9">QGIS contains <a id="id469" class="calibre1"/>a built-in functionality <a id="id470" class="calibre1"/>to zoom and pan the map in custom applications. It also contains the basic hooks to build your own interactive tools. In this recipe, we'll create an interactive point tool that lets you mark locations on the map by clicking on a point.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec293" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the application framework from the previous <em class="calibre10">Adding standard map tools to the canvas</em> recipe, so complete that recipe first. We will extend that application with a new tool. The complete version of this application is available in the code samples provided with this book.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec294" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will set up the button, signal trigger, and actions as we do with all map tools. However, because we are building a new tool, we must also define a class to define exactly what the tool does. To do this, we need to perform the following actions:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we define our point tool's button in the actions portion of our application. Place this line after the <code class="literal">QAction("Pan")</code> method:<div><pre class="programlisting"><strong class="calibre2">actionPoint = QAction("Point", self)</strong>
</pre></div></li><li class="listitem" value="2">In the next section, we make sure that when we click on the button, it stays selected:<div><pre class="programlisting"><strong class="calibre2">actionPoint.setCheckable(True)</strong>
</pre></div></li><li class="listitem" value="3">In the <a id="id471" class="calibre1"/>section after that, we define the method that is used when the button is triggered:<div><pre class="programlisting"><strong class="calibre2">self.connect(actionPoint, SIGNAL("triggered()"), self.point)</strong>
</pre></div></li><li class="listitem" value="4">Now, we<a id="id472" class="calibre1"/> add the button to the toolbar along with the other buttons:<div><pre class="programlisting"><strong class="calibre2">self.toolbar.addAction(actionPoint)</strong>
</pre></div></li><li class="listitem" value="5">Then, we link the application to our specialized tool class:<div><pre class="programlisting"><strong class="calibre2">self.toolPoint = PointMapTool(self.canvas)</strong>
<strong class="calibre2">self.toolPoint.setAction(actionPoint)</strong>
</pre></div></li><li class="listitem" value="6">We set the point tool to be selected when the application loads:<div><pre class="programlisting"><strong class="calibre2">self.point()</strong>
</pre></div></li><li class="listitem" value="7">Now, we define the method in the main application class for our tool:<div><pre class="programlisting"><strong class="calibre2">def point(self):</strong>
<strong class="calibre2">self.canvas.setMapTool(self.toolPoint)</strong>
</pre></div></li><li class="listitem" value="8">Now, we create a class that describes the type of tool we have and the output it provides. The output is a point on the canvas, defined in the <code class="literal">canvasPressEvent</code> method, that receives the button-click event. We will inherit from a generic tool called the <code class="literal">QgsMapToolEmitPoint</code> in order to create points:<div><pre class="programlisting"><strong class="calibre2">classPointMapTool(QgsMapToolEmitPoint):</strong>
<strong class="calibre2">def __init__(self, canvas):</strong>
<strong class="calibre2">self.canvas = canvas</strong>
<strong class="calibre2">QgsMapToolEmitPoint.__init__(self, self.canvas)</strong>
<strong class="calibre2">self.point = None</strong>

<strong class="calibre2">defcanvasPressEvent(self, e):</strong>
<strong class="calibre2">self.point = self.toMapCoordinates(e.pos())</strong>
<strong class="calibre2">printself.point.x(), self.point.y()</strong>
<strong class="calibre2">m = QgsVertexMarker(self.canvas)</strong>
<strong class="calibre2">m.setCenter(self.point)</strong>
<strong class="calibre2">m.setColor(QColor(0,255,0))</strong>
<strong class="calibre2">m.setIconSize(5)</strong>
<strong class="calibre2">m.setIconType(QgsVertexMarker.ICON_BOX) # or ICON_CROSS, ICON_X</strong>
<strong class="calibre2">m.setPenWidth(3)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec295" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">For custom<a id="id473" class="calibre1"/> tools, PyQGIS provides <a id="id474" class="calibre1"/>a set of generic tools for the common functions that you can extend and piece together. In this case, the EmitPoint tool handles the details of the events and map functionality when you click on a location on the map.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec103" class="calibre1"/>Using a map tool to draw polygons or lines on the canvas</h1></div></div></div><p class="calibre9">In this <a id="id475" class="calibre1"/>recipe, we'll <a id="id476" class="calibre1"/>create a tool to draw polygons on the canvas. This tool is an important tool because it opens the doors to even more advanced tools. Once you have a polygon on the canvas, you can do all sorts of operations that involve querying and geometry.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec296" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the application framework from the <em class="calibre10">Adding standard map tools to the canvas</em> recipe, so complete that recipe. We will extend that application with a new tool. The complete version of this application is available in the code samples provided with this book.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec297" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will add a new tool to the toolbar and also create a class that describes our polygon tool, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we define our polygon tool's button in the actions portion of our application. Place this line after the <code class="literal">QAction("Pan")</code> method:<div><pre class="programlisting"><strong class="calibre2">actionPoly = QAction("Polygon", self)</strong>
</pre></div></li><li class="listitem" value="2">In the next section, we make sure that when we click on the button, it stays selected:<div><pre class="programlisting"><strong class="calibre2">actionPoly.setCheckable(True)</strong>
</pre></div></li><li class="listitem" value="3">In the section after that, we define the method used when the button is triggered:<div><pre class="programlisting"><strong class="calibre2">self.connect(actionPoly, SIGNAL("triggered()"), self.poly)</strong>
</pre></div></li><li class="listitem" value="4">Now, we add the button to the toolbar along with the other buttons:<div><pre class="programlisting"><strong class="calibre2">self.toolbar.addAction(actionPoly)</strong>
</pre></div></li><li class="listitem" value="5">Then, we link the application to our specialized tool class:<div><pre class="programlisting"><strong class="calibre2">self.toolPoly = PolyMapTool(self.canvas)</strong>
<strong class="calibre2">self.toolPoly.setAction(actionPoly)</strong>
</pre></div></li><li class="listitem" value="6">We set the point tool to be selected when the application loads:<div><pre class="programlisting"><strong class="calibre2">self.poly()</strong>
</pre></div></li><li class="listitem" value="7">Now, we define the method in the main application class for our tool:<div><pre class="programlisting"><strong class="calibre2">def poly(self):</strong>
<strong class="calibre2">self.canvas.setMapTool(self.toolPoly)</strong>
</pre></div></li></ol><div></div><p class="calibre9">Now, we <a id="id477" class="calibre1"/>create a class that describes the type of tool we have and the output it provides. The output is a point <a id="id478" class="calibre1"/>on the canvas defined in the <code class="literal">canvasPressEvent</code> method, which receives the button-click event and the <code class="literal">showPoly</code> method. We will inherit from a generic tool in order to create points called the <code class="literal">QgsMapToolEmitPoint</code>; we will also use an object called <code class="literal">QgsRubberBand</code> for handling polygons:</p><div><pre class="programlisting"><strong class="calibre2">classPolyMapTool(QgsMapToolEmitPoint):</strong>
<strong class="calibre2">def __init__(self, canvas):</strong>
<strong class="calibre2">self.canvas = canvas</strong>
<strong class="calibre2">QgsMapToolEmitPoint.__init__(self, self.canvas)</strong>
<strong class="calibre2">self.rubberband = QgsRubberBand(self.canvas, QGis.Polygon)</strong>
<strong class="calibre2">self.rubberband.setColor(Qt.red)</strong>
<strong class="calibre2">self.rubberband.setWidth(1)</strong>
<strong class="calibre2">self.point = None</strong>
<strong class="calibre2">self.points = []</strong>

<strong class="calibre2">defcanvasPressEvent(self, e):</strong>
<strong class="calibre2">self.point = self.toMapCoordinates(e.pos())</strong>
<strong class="calibre2">m = QgsVertexMarker(self.canvas)</strong>
<strong class="calibre2">m.setCenter(self.point)</strong>
<strong class="calibre2">m.setColor(QColor(0,255,0))</strong>
<strong class="calibre2">m.setIconSize(5)</strong>
<strong class="calibre2">m.setIconType(QgsVertexMarker.ICON_BOX)</strong>
<strong class="calibre2">m.setPenWidth(3) </strong>
<strong class="calibre2">self.points.append(self.point)</strong>
<strong class="calibre2">self.isEmittingPoint = True</strong>
<strong class="calibre2">self.showPoly()</strong>

<strong class="calibre2">defshowPoly(self):</strong>
<strong class="calibre2">self.rubberband.reset(QGis.Polygon)</strong>
<strong class="calibre2">for point in self.points[:-1]:</strong>
<strong class="calibre2">self.rubberband.addPoint(point, False)</strong>
<strong class="calibre2">self.rubberband.addPoint(self.points[-1], True)</strong>
<strong class="calibre2">self.rubberband.show()</strong>
</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec298" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">All the settings for<a id="id479" class="calibre1"/> the polygon are contained in the custom class. There is a key property, called <strong class="calibre2">EmittingPoint</strong>, which <a id="id480" class="calibre1"/>we use to<a id="id481" class="calibre1"/> detect whether we are still adding points to the polygon. This value starts out as <code class="literal">false</code>. If this is the case, we reset our polygon object and begin drawing a new one. The following screenshot shows a polygon drawn with this tool on a map:</p><div><img src="img/00045.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec104" class="calibre1"/>Building a custom selection tool</h1></div></div></div><p class="calibre9">In this recipe, we<a id="id482" class="calibre1"/> will build a custom tool that both draws a shape on the map and interacts with other features on the map. These<a id="id483" class="calibre1"/> two basic functions are the basis for almost any map tool you would want to build, either in a standalone QGIS application like this one, or by extending the QGIS desktop application with a plugin.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec299" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the application framework from the <em class="calibre10">Adding standard map tools to the canvas</em> recipe, so complete that recipe first. We will extend that application with a new tool. The complete version of this application is available in the code samples provided with this book. It will also be beneficial to study the other two tool-related recipes, <em class="calibre10">A map tool to draw polygons or lines on the canvas</em> and <em class="calibre10">A map tool to draw points on the canvas</em>, as this recipe builds on them as well.</p><p class="calibre9">You will also need the following zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip</a>.</p><p class="calibre9">Download and extract it to your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec300" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will add a new tool to the toolbar and also create a class describing our selection tool, including how to draw the selection polygon and how to select the features. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we define our polygon tool's button in the actions portion of our application. Place this line after the <code class="literal">QAction("Pan")</code> method:<div><pre class="programlisting"><strong class="calibre2">actionSelect = QAction("Select", self)</strong>
</pre></div></li><li class="listitem" value="2">In the next section, we make sure that when we click on the button, it stays selected:<div><pre class="programlisting"><strong class="calibre2">actionSelect.setCheckable(True)</strong>
</pre></div></li><li class="listitem" value="3">In the section after that, we define the method used when the button is triggered:<div><pre class="programlisting"><strong class="calibre2">self.connect(actionSelect, SIGNAL("triggered()"), self.select)</strong>
</pre></div></li><li class="listitem" value="4">Now, we add the button to the toolbar along with the other buttons:<div><pre class="programlisting"><strong class="calibre2">self.toolbar.addAction(actionSelect)</strong>
</pre></div></li><li class="listitem" value="5">Then, we link the application to our specialized tool class:<div><pre class="programlisting"><strong class="calibre2">self.toolSelect = SelectMapTool(self.canvas, self.lyr)</strong>
<strong class="calibre2">self.toolSelect.setAction(actionSelect)</strong>
</pre></div></li><li class="listitem" value="6">We set the point tool to be selected when the application loads:<div><pre class="programlisting"><strong class="calibre2">self.select()</strong>
</pre></div></li><li class="listitem" value="7">Now, we define the method in the main application class for our tool:<div><pre class="programlisting"><strong class="calibre2">def select(self):</strong>
<strong class="calibre2">self.canvas.setMapTool(self.toolSelect)</strong>
</pre></div></li><li class="listitem" value="8">Next, we <a id="id484" class="calibre1"/>create a class that describes the type of tool we have and how it works. The output is a point on the <a id="id485" class="calibre1"/>canvas defined in the <code class="literal">canvasPressEvent</code> method, which receives the button click-event and the <code class="literal">selectPoly</code> method. We will inherit from a generic tool to create points called the <code class="literal">QgsMapToolEmitPoint</code>; we will also use an object called <code class="literal">QgsRubberBand</code> to handle polygons. However, we must also perform the selection process to highlight the features that fall within our selection polygon:<div><pre class="programlisting"><strong class="calibre2">classSelectMapTool(QgsMapToolEmitPoint):</strong>
<strong class="calibre2">def __init__(self, canvas, lyr):</strong>
<strong class="calibre2">self.canvas = canvas</strong>
<strong class="calibre2">self.lyr = lyr</strong>
<strong class="calibre2">QgsMapToolEmitPoint.__init__(self, self.canvas)</strong>
<strong class="calibre2">self.rubberband = QgsRubberBand(self.canvas, QGis.Polygon)</strong>
<strong class="calibre2">self.rubberband.setColor(QColor(255,255,0,50))</strong>
<strong class="calibre2">self.rubberband.setWidth(1)</strong>
<strong class="calibre2">self.point = None</strong>
<strong class="calibre2">self.points = []</strong>

<strong class="calibre2">defcanvasPressEvent(self, e):</strong>
<strong class="calibre2">self.point = self.toMapCoordinates(e.pos())</strong>
<strong class="calibre2">m = QgsVertexMarker(self.canvas)</strong>
<strong class="calibre2">m.setCenter(self.point)</strong>
<strong class="calibre2">m.setColor(QColor(0,255,0))</strong>
<strong class="calibre2">m.setIconSize(5)</strong>
<strong class="calibre2">m.setIconType(QgsVertexMarker.ICON_BOX)</strong>
<strong class="calibre2">m.setPenWidth(3) </strong>
<strong class="calibre2">self.points.append(self.point)</strong>
<strong class="calibre2">self.isEmittingPoint = True</strong>
<strong class="calibre2">self.selectPoly()</strong>

<strong class="calibre2">defselectPoly(self):</strong>
<strong class="calibre2">self.rubberband.reset(QGis.Polygon)</strong>
<strong class="calibre2">for point in self.points[:-1]:</strong>
<strong class="calibre2">self.rubberband.addPoint(point, False)</strong>
<strong class="calibre2">self.rubberband.addPoint(self.points[-1], True)</strong>
<strong class="calibre2">self.rubberband.show() </strong>
<strong class="calibre2">iflen(self.points) &gt; 2:</strong>
<strong class="calibre2">g = self.rubberband.asGeometry()</strong>
<strong class="calibre2">featsPnt = self.lyr.getFeatures(QgsFeatureRequest().setFilterRect(g.boundingBox()))</strong>
<strong class="calibre2">forfeatPnt in featsPnt:</strong>
<strong class="calibre2">iffeatPnt.geometry().within(g):</strong>
<strong class="calibre2">self.lyr.select(featPnt.id()) </strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec301" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">QGIS has a <a id="id486" class="calibre1"/>generic tool for highlighting features, but in this case, we can use the standard selection functionality, which simplifies our <a id="id487" class="calibre1"/>code. With the exception of a dialog to load new layers and the ability to show attributes, we have a very basic but nearly complete standalone GIS application.The following screenshot shows the selection tool in action:</p><div><img src="img/00046.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec105" class="calibre1"/>Creating a mouse coordinate tracking tool</h1></div></div></div><p class="calibre9">In this recipe, we'll <a id="id488" class="calibre1"/>build a tool that tracks <a id="id489" class="calibre1"/>and displays the mouse coordinates in real time. This tool will also demonstrate how to interact with the status bar of a QGIS application.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec302" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">We will use the application framework from the <em class="calibre10">Adding standard map tools to the canvas</em> recipe, so complete that recipe first. We will extend that application with the coordinate tracking tool. A complete version of this application is available in the code samples provided with this book. It will also be beneficial to study the other two tool-related recipes in this chapter, <em class="calibre10">A map tool to draw polygons or lines on the canvas</em> and <em class="calibre10">A map tool to draw points on the canvas</em>, as this recipe builds on them as well.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec303" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will add an event filter to the basic standalone QGIS application and use it to grab the current mouse coordinates as well as update the status bar. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">As the last line of our application's <code class="literal">__init__ </code>method, insert the following line to create a default status bar message when the application loads:<div><pre class="programlisting"><strong class="calibre2">self.statusBar().showMessage(u"x: --, y: --")</strong>
</pre></div></li><li class="listitem" value="2">Immediately<a id="id490" class="calibre1"/> after the application's <code class="literal">__init__ </code>method, we will add the following event filter method:<div><pre class="programlisting"><strong class="calibre2">defeventFilter(self, source, event):</strong>
<strong class="calibre2">ifevent.type() == QEvent.MouseMove:</strong>
<strong class="calibre2">ifevent.buttons() == Qt.NoButton:</strong>
<strong class="calibre2">pos = event.pos()</strong>
<strong class="calibre2">x = pos.x()</strong>
<strong class="calibre2">y = pos.y()</strong>
<strong class="calibre2">p = self.canvas.getCoordinateTransform().toMapCoordinates(x, y)</strong>
<strong class="calibre2">self.statusBar().showMessage(u"x: %s, y: %s" % (p.x(), p.y()))</strong>
<strong class="calibre2">else:</strong>
<strong class="calibre2">pass</strong>
<strong class="calibre2">returnQMainWindow.eventFilter(self, source, event)</strong>
</pre></div></li><li class="listitem" value="3">In the <code class="literal">MainApp</code> class, as<a id="id491" class="calibre1"/> the second-last line, we must install the event filter using the following code:<div><pre class="programlisting"><strong class="calibre2">self.installEventFilter(wdg)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec304" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">In the Qt framework, in order to watch out for mouse events, we must insert an event filter that allows us to monitor all the events in the application. Within the default event filter method, we can then process any event we want. In this case, we watch for any movements of the mouse.</p></div></div></body></html>