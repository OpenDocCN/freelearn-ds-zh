- en: Introduction to R
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 简介
- en: In a world where data is becoming increasingly important, business people and
    scientists need tools to analyze and process large volumes of data efficiently.
    R is one of the tools that has become increasingly popular in recent years for
    data processing, statistical analysis, and data science, and while R has its roots
    in academia, it is now used by organizations across a wide range of industries
    and geographical areas.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据变得越来越重要的世界里，商人和科学家需要工具来高效地分析和处理大量数据。R 是近年来在数据处理、统计分析和数据科学中越来越受欢迎的工具之一，尽管
    R 的根源在学术界，但现在它被广泛应用于各个行业和地理区域的组织中。
- en: 'Some of the important topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些重要主题如下：
- en: History of R and why it was designed the way it was
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 的历史以及为什么它被设计成这样
- en: What the interpreter and the console are and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器和控制台是什么以及如何使用它们
- en: How to work with basic data types and data structures of R
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理 R 的基本数据类型和数据结构
- en: How to divide work by using functions in different ways
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过不同的方式使用函数来划分工作
- en: How to introduce complex logic with control structures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用控制结构引入复杂的逻辑
- en: What R is and what it isn't
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 是什么以及它不是什么
- en: When it comes to choosing software for statistical computing, it's tough to
    argue against R. Who could dislike a high quality, cross-platform, open source,
    statistical software product? It has an interactive console for exploratory work.
    It can run as a scripting language to replicate processes. It has a lot of statistical
    models built in, so you don't have to reinvent the wheel, but when the base toolset
    is not enough, you have access to a rich ecosystem of external packages. And,
    it's free! No wonder R has become a favorite in the age of data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到选择统计计算软件时，很难反对 R。谁会不喜欢一个高质量、跨平台、开源的统计软件产品呢？它有一个交互式控制台用于探索性工作。它可以作为脚本语言运行以复制过程。它内置了许多统计模型，因此你不必重新发明轮子，但当基础工具集不足时，你可以访问丰富的外部包生态系统。而且，它是免费的！难怪
    R 在数据时代成为了宠儿。
- en: The inspiration for R – the S language
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 的灵感来源 – S 语言
- en: R was inspired by the S statistical language developed by John Chambers at AT&T.
    The name S is an allusion to another one-letter-name programming language also
    developed at AT&T, the famous C language. R was created by Ross Ihaka and Robert
    Gentleman in the Department of Statistics at the University of Auckland in 1991.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: R 是由约翰·查普曼在 AT&T 开发的 S 统计语言的灵感来源。S 这个名字是对在 AT&T 同样开发的一个字母命名的编程语言的暗示，那就是著名的 C
    语言。R 是由罗斯·伊哈卡和罗伯特·詹宁斯在 1991 年奥克兰大学统计学系创建的。
- en: The general S philosophy sets the stage for the design of the R language itself,
    which many programmers coming from other programming languages find somewhat odd
    and confusing. In particular, it's important to realize that S was developed to
    make data analysis as easy as possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: S 的一般哲学为 R 语言的本身设计奠定了基础，许多来自其他编程语言的程序员可能会觉得它有些奇怪和令人困惑。特别是，重要的是要认识到 S 是为了使数据分析尽可能容易而开发的。
- en: '"We wanted users to be able to begin in an interactive environment, where they
    did not consciously think of programming. Then as their needs became clearer and
    their sophistication increased, they should be able to slide gradually into programming,
    when the language and system aspects would become more important."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “我们希望用户能够从一个交互式环境中开始，在那里他们不会自觉地考虑编程。然后随着他们的需求变得更加明确，他们的复杂性增加，他们应该能够逐渐过渡到编程，当语言和系统方面变得更加重要时。”
- en: – John Chambers
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: – 约翰·查普曼
- en: The key part here is the transition from analyst to developer. They wanted to
    build a language that could easily service both types of users. They wanted to
    build language that would be suitable for interactive data analysis through a
    command line but which could also be used to program complex systems, like traditional
    programming languages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的部分是从分析师到开发者的转变。他们希望构建一种能够轻松服务于这两种类型用户的语言。他们希望构建一种既适合通过命令行进行交互式数据分析，又可用于编程复杂系统（如传统编程语言）的语言。
- en: It's no coincidence that this book is structured that way. We will start doing
    data analysis first, and we will gradually move toward developing a full and complex
    system for information retrieval with a web application on top.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的结构如此安排并非巧合。我们将首先进行数据分析，然后我们将逐步过渡到开发一个完整且复杂的系统，该系统在顶部有一个网络应用程序用于信息检索。
- en: R is a high quality statistical computing system
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 是一个高质量的统计计算系统
- en: R is comparable, and often superior, to commercial products when it comes to
    programming capabilities, complex systems development, graphic production, and
    community ecosystems. Researchers in statistics and machine learning, as well
    as many other data-related disciplines, will often publish R packages to accompany
    their publications. This translates into immediate public access to the very latest
    statistical techniques and implementations. Whatever model or graphic you're trying
    to develop, chances are that someone has already tried it, and if not, you can
    at least learn from their efforts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编程能力、复杂系统开发、图形制作和社区生态系统时，R 与商业产品相比，往往更具有可比性，甚至更优越。统计学家和机器学习研究人员，以及许多其他与数据相关的学科研究人员，通常会发布
    R 包来伴随他们的出版物。这转化为公众可以立即访问最新的统计技术和实现。无论您试图开发什么模型或图形，都有可能有人已经尝试过，如果没有，至少您可以从他们的努力中学习。
- en: R is a flexible programming language
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 是一种灵活的编程语言
- en: As we have seen, in addition to providing statistical tools, R is a general-purpose
    programming language. You can use R to extend its own functionality, automate
    processes that make use of complex systems, and many other things. It incorporates
    features from other object-oriented programming languages and has strong foundations
    for functional programming, which is well suited for solving many of the challenges
    of data analysis. R allows the user to write powerful, concise, and descriptive
    code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，除了提供统计工具外，R 还是一种通用编程语言。您可以使用 R 来扩展其自身功能，自动化使用复杂系统的流程，以及许多其他事情。它融合了其他面向对象编程语言的特点，并为函数式编程提供了坚实的基础，这对于解决数据分析中的许多挑战非常合适。R
    允许用户编写强大、简洁和描述性的代码。
- en: R is free, as in freedom and as in free beer
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 是自由的，如同自由和如同免费啤酒
- en: In many ways, a language is successful inasmuch as it creates a platform with
    which many people can create new things, and R has proven to be very successful
    in this regard. One key limitation of the S language was that it was only available
    in a commercial package, but R is free software. Free as in freedom, and free
    as in free beer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，一种语言之所以成功，是因为它创建了一个平台，许多人可以通过这个平台创造新事物，而 R 在这方面已经证明是非常成功的。S 语言的一个关键限制是它仅限于商业软件包中，但
    R 是自由软件。自由如同自由，也如同免费啤酒。
- en: 'The copyright for the primary source code for R is held by the R Foundation
    and is published under **General Public License** (**GPL**). According to the
    Free Software Foundation ([http://www.fsf.org/](http://www.fsf.org/)), with free
    software (free as in freedom) you are granted the following four freedoms:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: R 的主要源代码的版权由 R 基金会持有，并发布在 **通用公共许可证**（**GPL**）下。根据自由软件基金会（[http://www.fsf.org/](http://www.fsf.org/)），使用自由软件（自由如同自由）您被授予以下四个自由：
- en: '**Freedom 0**: Run the program for any purpose'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自由0**：为任何目的运行程序'
- en: '**Freedom 1**: Study how the program works and adapt it to your needs'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自由1**：研究程序的工作方式并将其适应您的需求'
- en: '**Freedom 2**: Redistribute copies so you can help your neighbor'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自由2**：重新分发副本，以便您可以帮助您的邻居'
- en: '**Freedom 3**: Improve the program and release your improvements to the public'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自由3**：改进程序并将您的改进发布给公众'
- en: These freedoms have allowed R to develop strong prolific communities that include
    world-class statisticians and programmers as well as many volunteers, who help
    improve and extend the language. They also allow for R to be developed and maintained
    for all popular operating systems, and to be easily used by individuals and organizations
    who wish to do so, possibly sharing their findings in a way that others can replicate
    their results. Such is the power of free software.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自由使得 R 能够发展出强大的多产社区，其中包括世界级的统计学家和程序员以及许多志愿者，他们帮助改进和扩展了该语言。它们还允许 R 在所有流行的操作系统上开发和维护，并使个人和组织能够轻松使用，可能以其他人可以复制其结果的方式分享他们的发现。这就是自由软件的力量。
- en: What R is not good for
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 不擅长的地方
- en: No programming language or system is perfect. R certainly has a number of drawbacks,
    the most common being that it can be painfully slow (when not used correctly).
    Keep in mind that R is essentially based on 40-year-old technology, going back
    to the original S system developed at Bell Labs. Therefore, several of its imperfections
    come from the fact that it was not built in anticipation for the data age we live
    in now. When R was born, disk and RAM were very expensive and the internet was
    just getting started. Notions of large-scale data analysis and high-performance
    computing were rare.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 没有编程语言或系统是完美的。R 当然有一些缺点，最常见的是它可能非常慢（如果不正确使用）。记住，R 实质上基于 40 年前的技术，追溯到贝尔实验室开发的原始
    S 系统。因此，它的许多不完美之处源于它没有为我们现在所处的数据时代做出预期。当 R 诞生时，磁盘和 RAM 非常昂贵，互联网才刚刚起步。大规模数据分析和高性能计算的概念是罕见的。
- en: Fast-forward to the present, hardware cost is just a fraction of what it used
    to be, computing power is available online for pennies, and everyone is interested
    in collecting and analyzing data at large scale. This surge in data analysis has
    brought to the forefront two of R's fundamental limitations, the fact that it's
    single-threaded and memory-bound. These two characteristics drastically slow it
    down. Furthermore, R is an interpreted dynamically typed language, which can make
    it even slower. And finally, R has object immutability and various ways to implement
    object-oriented programming, both of which can make it hard for people, specially
    those coming from other languages, to write high-quality code if they don't know
    how to deal with them. You should know that all of the characteristics mentioned
    in this paragraph are addressed in [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730),
    *Implementing an Efficient Simple Moving Average*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到现代，硬件成本只是过去的一小部分，计算能力在网上只需几分钱，每个人都对收集和分析大规模数据感兴趣。这种数据分析的激增将 R 的两个基本限制推到了前台，即它是单线程和内存受限的。这两个特性极大地减慢了它的速度。此外，R
    是一种解释型动态类型语言，这可能会使其变得更慢。最后，R 有对象不可变性和多种实现面向对象编程的方式，这两者都可能使人们，尤其是那些来自其他语言的人，在不知道如何处理它们的情况下难以编写高质量的代码。你应该知道，本段中提到的所有特性都在[第
    9 章](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730)，“实现高效的简单移动平均”中得到了解决。
- en: A double-edged sword in R, is that most of its users do not think of themselves
    as programmers, and are more concerned with results than with process (which is
    not necessarily a bad thing). This means that much of the R code you can find
    online is written without regard for elegance, speed, or readability, since most
    R users do not revise their code to address these shortcomings. This permeates
    into code that is patchy and not rigorously tested, which in turn produces many
    edge cases that you must take into account when using low-quality packages. You
    will do well to keep this in mind.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，一把双刃剑是，大多数用户并不将自己视为程序员，他们更关心结果而不是过程（这并不一定是个坏事）。这意味着你可以在网上找到的大部分 R 代码都是没有考虑到优雅、速度或可读性的，因为大多数
    R 用户不会修订他们的代码来解决这些缺点。这种情况渗透到那些零散且未经严格测试的代码中，进而产生了许多在使用低质量包时必须考虑的边缘情况。你应该牢记这一点。
- en: Comparing R with other software
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较 R 与其他软件
- en: My intention for this section is not to provide a comprehensive comparison between
    R and other software, but to simply point out a few of R's most noticeable features.
    If you can, I encourage you to test other software yourself so that you know first-hand
    what may be the best tool for the job at hand.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这一节的目的并不是要全面比较 R 与其他软件，而是简单地指出 R 的一些最显著特性。如果你能的话，我鼓励你自己测试其他软件，以便你能够亲身体验到可能最适合当前工作的最佳工具。
- en: The most noticeable feature of R compared to other statistical software such
    as SAS, Stata, SPSS, and even Python, is the very large number of packages that
    it has available. At the time of writing this, there are almost 12,000 packages
    published in The **Comprehensive R Archive Network** (**CRAN**) ([https://cran.r-project.org/](https://cran.r-project.org/)),
    and this does not include packages published in other places, such as Git repositories.
    This enables R to have a very large community and a huge number of tools for data
    analysis in areas such as finance, mathematics, machine learning, high-performance
    computing, and many others.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与SAS、Stata、SPSS以及甚至Python等其他统计软件相比，R最显著的特点是它拥有大量的可用包。在撰写本文时，**综合R档案网络**（**CRAN**）([https://cran.r-project.org/](https://cran.r-project.org/))中已发布近12,000个包，而且这还不包括在其他地方发布的包，例如Git仓库。这使得R拥有一个非常庞大的社区和大量用于数据分析的工具，这些工具涵盖了金融、数学、机器学习、高性能计算等多个领域。
- en: With the exception of Python, R has much more programming capabilities than
    SAS, Stata, SPSS, and even more so than Python in some respects (for example,
    in R, you may use different object models). However, efficient and effective R
    usage requires the use of code which implies a steep learning curve for some people,
    while Stata and SPSS have graphical user interfaces that guide the user through
    many of the tasks with point-and-click wizards. In my opinion, this hand-holding,
    although nice for beginners, quickly becomes an important restriction for people
    looking to become intermediate to advanced users, and that's where the advantage
    of programming really shines.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python之外，R在编程能力上比SAS、Stata、SPSS都要强，在某些方面甚至比Python更强（例如，在R中，你可以使用不同的对象模型）。然而，高效且有效地使用R需要使用代码，这对一些人来说意味着有一个陡峭的学习曲线，而Stata和SPSS具有图形用户界面，通过点选向导引导用户完成许多任务。在我看来，这种手把手的教学虽然对初学者很有帮助，但很快就会成为那些想要成为中级或高级用户的人的一个重要限制，这正是编程的优势所在。
- en: R has one of the best graphics systems among all existing software. The most
    popular package for producing graphs in R, which we will use extensively in this
    book, is the `ggplot2` package, but there are many other great graphing packages
    as well. This package allows the modification of virtually every aspect of a graph
    through its graphics grammar, and is far superior to anything I've seen in SPSS,
    Stata, SAS, or even Python.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: R在所有现有软件中拥有最好的图形系统之一。在R中生成图形最流行的包是`ggplot2`包，我们将在本书中广泛使用它，但还有许多其他优秀的绘图包。这个包允许通过其图形语法修改图形的几乎每个方面，并且远远优于我在SPSS、Stata、SAS甚至Python中看到过的任何东西。
- en: R is a great tool, but it's not the right tool for everything. If you're looking
    to perform data analysis but don't want to invest the time in learning to program,
    then software like SAS, Stata, or SPSS may be a better option for you. If you're
    looking to develop analytical software that is very easily integrated into larger
    systems and which needs to plug into various interfaces, then Python may be a
    better tool for the job. However, if you're looking to do a lot of complex data
    analysis and graphing, and you are going to mostly spend your time focused on
    these areas, then R is a great choice.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: R是一个伟大的工具，但它并不是适合所有事情的合适工具。如果你想要进行数据分析，但又不想投入时间去学习编程，那么SAS、Stata或SPSS等软件可能更适合你。如果你想要开发易于集成到更大系统中的分析软件，并且需要连接到各种接口，那么Python可能更适合这项工作。然而，如果你想要进行大量的复杂数据分析绘图，并且你将大部分时间都花在这些领域，那么R是一个很好的选择。
- en: The interpreter and the console
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器和控制台
- en: As I mentioned earlier, R is an interpreted language. When you enter an expression
    into the R console or execute an R script in your operating system's terminal,
    a program called the interpreter parses and executes the code. Other examples
    of interpreted languages are Lisp, Python, and JavaScript. Unlike C, C++, and
    Java, R doesn't require you to explicitly compile your programs before you execute
    them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，R是一种解释型语言。当你将表达式输入R控制台或在操作系统的终端中执行R脚本时，一个名为解释器的程序会解析并执行代码。其他解释型语言的例子包括Lisp、Python和JavaScript。与C、C++和Java不同，R不需要你在执行之前显式地编译你的程序。
- en: All R programs are composed of a series of expressions. The interpreter begins
    by parsing each expression, substituting objects for symbols where appropriate,
    evaluates them, and finally return the resulting objects. We will define each
    of these concepts in the following sections, but you should understand that this
    is the basic process through which all R programs go through.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 R 程序都是由一系列表达式组成的。解释器首先解析每个表达式，在适当的地方用对象替换符号，然后评估它们，最后返回结果对象。我们将在接下来的章节中定义这些概念，但你应该明白，这是所有
    R 程序通过的基本过程。
- en: The R console is the most important tool for using R and can be thought of as
    a wrapper around the interpreter. The console is a tool that allows you to type
    expressions directly into R and see how it responds. The interpreter will read
    the expressions and respond with a result or an error message, if there was one.
    When you execute expressions through the console, the interpreter will pass objects
    to the `print()` function automatically, which is why you can see the result printed
    below your expressions (we'll cover more on functions later).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: R 控制台是使用 R 的最重要的工具，可以将其视为解释器的一个包装器。控制台是一个允许你直接将表达式输入到 R 中并查看其响应的工具。解释器将读取表达式，如果有错误，则返回结果或错误消息。当你通过控制台执行表达式时，解释器会自动将对象传递给
    `print()` 函数，这就是为什么你可以在你的表达式下方看到结果打印出来的原因（我们将在后面更多地介绍函数）。
- en: '![](img/00005.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.jpeg)'
- en: If you've used a command line before (for example, bash in Linux of macOS or
    cmd.exe in Windows) or a language with an interactive interpreter such as Lisp,
    Python, or JavaScript, the console should look familiar since it simply is a command-line
    interface. If not, don't worry. Command-line interfaces are simple to use tools.
    They are programs that receive code and return objects whose printed representations
    you see below the code you execute.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过命令行（例如，Linux 或 macOS 中的 bash 或 Windows 中的 cmd.exe）或具有交互式解释器的语言，如 Lisp、Python
    或 JavaScript，那么控制台应该看起来很熟悉，因为它只是一个命令行界面。如果不熟悉，不要担心。命令行界面是易于使用的工具。它们是接收代码并返回对象的程序，这些对象的打印表示形式是你执行代码下方看到的。
- en: When you launch R, you will see a window with the R console. Inside the console
    you will see a message like the one shown below. This message displays some basic
    information, including the version of R you're running, license information, reminders
    about how to get help, and a Command Prompt.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动 R 时，你会看到一个带有 R 控制台的窗口。在控制台中，你会看到如下所示的消息。此消息显示一些基本信息，包括你正在运行的 R 版本、许可信息、有关如何获取帮助的提示以及命令提示符。
- en: Note that the R version in this case is 3.4.2\. The code developed during this
    book will assume this version. If you have a different version, but in case you
    end up with some problems, this could be a reason you may want to look into.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，R 的版本是 3.4.2。本书中开发的代码将假设这个版本。如果你有不同的版本，但如果你遇到一些问题，这可能是一个你可能想要调查的原因。
- en: You should note that, by default, R will display a greater-than sign (>) at
    the beginning of the last line of the console, signaling you that it's ready to
    receive commands. Since R is prompting you to type something, this is called a
    Command Prompt. When you see the greater-than symbol, R is able to receive more
    expressions as input. When you don't, it is probably because R is busy processing
    something you sent, and you should wait for it to finish before sending something
    else.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，默认情况下，R 将在控制台最后一行的开头显示一个大于号（>），这表示它已准备好接收命令。由于 R 正在提示你输入内容，这被称为命令提示符。当你看到大于符号时，R
    能够接收更多的表达式作为输入。当你看不到时，可能是因为 R 正在处理你发送的内容，你应该等待它完成后再发送其他内容。
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note the `[1]` that accompanies each returned value. It's there because the
    result is actually a vector (an ordered collection). The `[1]` means that the
    index of the first item displayed in that row is 1 (in this case, our resulting
    vector has a single value within).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个返回值旁边伴随的 `[1]`。它在那里是因为结果实际上是一个向量（一个有序集合）。`[1]` 表示显示在该行中的第一个项目的索引是 1（在这种情况下，我们的结果向量中只有一个值）。
- en: Finally, you should know that the console provides tools for looking through
    previous commands. You will probably find that the up and down arrow keys are
    the most useful. You can scroll through previous commands by pressing them. The
    up arrow lets you look at earlier commands, and the down arrow lets you look at
    later commands. If you would like to repeat a previous command with a minor change,
    or if you need to correct a mistake, you can easily do so using these keys.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该知道控制台提供了查看先前命令的工具。您可能会发现上箭头键和下箭头键是最有用的。通过按这些键，您可以滚动查看以前的命令。上箭头键让您查看较早的命令，而下箭头键让您查看较晚的命令。如果您想要对以前的命令进行轻微的修改，或者需要纠正错误，您可以使用这些键轻松地做到这一点。
- en: Tools to work efficiently with R
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与R高效工作的工具
- en: In this section we discuss the tools that will help us when working with R.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了在用R工作时将帮助我们的工具。
- en: Pick an IDE or a powerful editor
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个集成开发环境（IDE）或强大的编辑器
- en: For efficient code development, you may want to try a more powerful editor or
    an **Integrated Development Environment** (**IDE**). The most popular IDE for
    R is RStudio ([https://www.rstudio.com/](https://www.rstudio.com/)). It offers
    an impressive feature set that makes interacting with R much easier. If you're
    new to R, and programming in general, this is probably the way to go. As you can
    see in the image below it wraps the console (right side) within a larger application
    which offers a lot of functionality, and in this case, it is displaying the help
    system (left side). Furthermore, RStudio offers tabs to navigate files, browse
    installed packages, visualize plots, among other features, as well as a large
    amount of configuration options under the top menu dropdowns.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地进行代码开发，您可能想要尝试一个更强大的编辑器或一个**集成开发环境**（**IDE**）。R最流行的IDE是RStudio（[https://www.rstudio.com/](https://www.rstudio.com/)）。它提供了一套令人印象深刻的特性，使得与R的交互变得更加容易。如果您是R的新手，并且对编程也较陌生，这可能是您应该采取的方法。如图所示，它将控制台（右侧）包裹在一个更大的应用程序中，该应用程序提供了许多功能，在这种情况下，它显示的是帮助系统（左侧）。此外，RStudio还提供了标签来导航文件、浏览已安装的包、可视化绘图等功能，以及在上拉菜单下拉选项中提供的大量配置选项。
- en: Throughout this book, we will not use any functionality provided by RStudio.
    All I will show you is pure R functionality. I decided to proceed this way to
    make sure that the book is useful for any R programmer, including those who do
    not use RStudio. For RStudio users, this means that there may be easier ways to
    accomplish some of the tasks I will show, and instead of programming a few lines,
    you could simply click some buttons. If that's something you prefer, I encourage
    you to take a look through the excellent RStudio Essential webinars,which can
    be found in RStudio's website at [https://www.rstudio.com/resources/webinars/?wvideo=lxel3j2kos](https://www.rstudio.com/resources/webinars/?wvideo=lxel3j2kos),
    as well as Stanford's Introduction to R, RStudio ([https://web.stanford.edu/class/stats101/intro/intro-lab01.html](https://web.stanford.edu/class/stats101/intro/intro-lab01.html)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们不会使用RStudio提供的任何功能。我将向您展示的是纯R功能。我决定这样进行是为了确保本书对任何R程序员都有用，包括那些不使用RStudio的人。对于RStudio用户来说，这意味着可能有一些更简单的方法来完成我将展示的一些任务，而不是编写几行代码，您只需点击一些按钮即可。如果您喜欢这样做，我鼓励您查看RStudio网站上提供的优秀RStudio
    Essential网络研讨会，网址为[https://www.rstudio.com/resources/webinars/?wvideo=lxel3j2kos](https://www.rstudio.com/resources/webinars/?wvideo=lxel3j2kos)，以及斯坦福大学的R入门，RStudio版（[https://web.stanford.edu/class/stats101/intro/intro-lab01.html](https://web.stanford.edu/class/stats101/intro/intro-lab01.html)）。
- en: You should be careful to avoid the common mistake of referring to R as RStudio.
    Since many people are introduced to R through RStudio, they think that RStudio
    is actually R, which it is not. RStudio is a wrapper around R to extend it's functionality,
    and is technically known as an IDE.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该小心避免将R称为RStudio的常见错误。由于许多人通过RStudio接触到了R，他们认为RStudio实际上是R，但这并不是事实。RStudio是围绕R的一个包装器，用于扩展其功能，在技术上被称为IDE。
- en: Experienced programmers may prefer to work with other tools they already know
    and love and have used for many years. For example, in my case, I prefer to use
    Emacs ([https://www.gnu.org/software/emacs/](https://www.gnu.org/software/emacs/))
    for any programming I do. Emacs is a very powerful text editor that you can programatically
    extend to work the way you want it to by using a programming language known as
    **Elisp**, which is a Lisp extension. In case you use Emacs too, the `ess` package
    is all you really need.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的程序员可能更喜欢使用他们已经熟悉并热爱多年且一直在使用的其他工具。例如，在我的情况下，我更喜欢使用Emacs ([https://www.gnu.org/software/emacs/](https://www.gnu.org/software/emacs/))
    进行任何编程工作。Emacs是一个非常强大的文本编辑器，你可以通过使用名为**Elisp**的编程语言来编程扩展它，使其以你想要的方式工作，**Elisp**是一种Lisp扩展。如果你也使用Emacs，那么`ess`包就是你真正需要的所有东西。
- en: '![](img/00006.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00006.jpeg)'
- en: If you're going to use Emacs, I encourage you to take a look through the `ess` package's
    documentation ([https://ess.r-project.org/Manual/ess.html](https://ess.r-project.org/Manual/ess.html))
    and Johnson's presentation titled *Emacs Has No Learning Curve, University of
    Kansas, 2015* ([http://pj.freefaculty.org/guides/Rcourse/emacs-ess/emacs-ess.pdf](http://pj.freefaculty.org/guides/Rcourse/emacs-ess/emacs-ess.pdf)).
    If you use Vim, Sublime Text, Atom, or other similar tools, I'm confident you
    can find useful packages as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用Emacs，我鼓励你查阅`ess`包的文档 ([https://ess.r-project.org/Manual/ess.html](https://ess.r-project.org/Manual/ess.html))
    和Johnson的题为《Emacs Has No Learning Curve, University of Kansas, 2015》的演示 ([http://pj.freefaculty.org/guides/Rcourse/emacs-ess/emacs-ess.pdf](http://pj.freefaculty.org/guides/Rcourse/emacs-ess/emacs-ess.pdf))。如果你使用Vim、Sublime
    Text、Atom或其他类似工具，我确信你也能找到有用的包。
- en: The send to console functionality
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送到控制台的功能
- en: The base R installation provides the console environment we mentioned in the
    previous section. This console is really all you need to work with R, but it will
    quickly become cumbersome to type everything directly into it and it may not be
    your best option. To efficiently work with R, you need to be able to experiment
    and iterate as fast as you can. Doing so will accelerate your learning curve and
    productivity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R安装提供了我们在上一节中提到的控制台环境。这个控制台实际上是你与R一起工作的全部所需，但它很快就会变得繁琐，需要直接将其中的所有内容都输入进去，它可能不是你的最佳选择。为了高效地使用R，你需要能够尽可能快地进行实验和迭代。这样做将加速你的学习曲线和生产力。
- en: Whichever tool you use, the key functionality you need is to be able to easily
    send code snippets into the console without having to type them yourself, or copying
    them from your editor and pasting them into the console. In RStudio, you can accomplish
    this by clicking on the Run or Source button in the top-right corner of the code
    editor panel. In Emacs, you may use the ess-eval-region command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么工具，你需要的关键功能是能够轻松地将代码片段发送到控制台，而无需自己输入，或者从你的编辑器中复制并粘贴到控制台。在RStudio中，你可以通过点击代码编辑面板右上角的运行或源按钮来完成此操作。在Emacs中，你可以使用ess-eval-region命令。
- en: The efficient write-execute loop
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的写-执行循环
- en: 'One of the most productive ways to work with R, especially when learning it,
    is to use the *write-execute* loop, which makes use of the send to console functionality
    mentioned in the previous section. This will allow you to do two very important
    things: develop your code through small and quick iterations, which allow you
    to see step-by-step progress until you converge to the behavior you seek, and
    save the code you converged to as your final result, which can be easily reproduced
    using the source code file you used for your iterations. R source code files use
    the `.R` extension.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用R最富有成效的方法之一，尤其是在学习它的时候，是使用*写-执行*循环，该循环利用了上一节中提到的发送到控制台功能。这将允许你完成两个非常重要的事情：通过小而快速的迭代来开发你的代码，这样你可以看到逐步的进度，直到你达到你寻求的行为，并将你达到的行为保存为你的最终结果，该结果可以使用你用于迭代的源代码文件轻松地重现。R源代码文件使用`.R`扩展名。
- en: 'Assuming you have a source code file ready to send expressions to the console,
    the basic steps through the write-execute loop are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个准备将表达式发送到控制台的源代码文件，通过写-执行循环的基本步骤如下：
- en: Define what behavior you're looking to implement with code.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代码定义你想要实现的行为。
- en: Write the minimal amount of code necessary to achieve one piece of the behavior
    you seek in your implementation.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写实现你所需行为的最少代码。
- en: Use the send to console functionality to verify that the result in the console
    is what you expected, and if it's not, to identify possible causes.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用发送到控制台的功能来验证控制台中的结果是否符合你的预期，如果不符，则识别可能的原因。
- en: If it's not what you expected, go back to the second step with the purpose of
    fixing the code until it has the intended piece of behavior.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它不是你所期望的，就回到第二步，目的是修复代码，直到它具有预期的行为。
- en: If it's what you expected, go back to the second step with the purpose of extending
    the code with another piece of the behavior, until convergence.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它是你所期望的，就回到第二步，目的是通过添加另一部分行为来扩展代码，直到收敛。
- en: This write-execute loop will become second nature to you as you start using
    it, and when it does, you'll be a more productive R programmer. It will allow
    you to diagnose issues faster, to quickly experiment with a few ways to accomplishing
    the same behavior to find which one seems best for your context, and once you
    have working code, it will also allow you to clean your implementation to keep
    the same behavior but have better or more readable code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用它时，这个编写-执行循环将变得像第二本能一样自然，一旦它做到了，你将成为一个更高效的 R 程序员。它将允许你更快地诊断问题，快速尝试几种实现相同行为的方法，以找到最适合你上下文的方法，一旦你有可工作的代码，它也将允许你清理实现，以保持相同的行为但拥有更好的或更易读的代码。
- en: For experienced programmers, this should be a familiar process, and it's very
    similar to **Test-Driven Development** (**TDD**), but instead of using unit-tests
    to automatically test the code, you verify the output in the console in each iteration,
    and you don't have a set of tests to re-test each iteration. Even though TDD will
    not be used in this book, you can definitely use it in R.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经验丰富的程序员来说，这应该是一个熟悉的过程，并且它与 **测试驱动开发** (**TDD**) 非常相似，但不同的是，你不会使用单元测试来自动测试代码，而是在每个迭代中验证控制台中的输出，并且你没有一组测试来重新测试每个迭代。尽管本书中不会使用
    TDD，但你绝对可以在 R 中使用它。
- en: I encourage you to use this write-execute loop to work through the examples
    presented in this book. At times, we will show step-by-step progress so that you
    understand the code better, but it's practically impossible to show all of the
    write-execute loop iterations I went through to develop it, and much of the knowledge
    you can acquire comes from iterating this way.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你使用这个编写-执行循环来处理本书中提供的示例。有时，我们会逐步展示进度，以便你更好地理解代码，但实际上很难展示我开发过程中所经历的所有的编写-执行循环迭代，而你能够获得的大部分知识都来自于这种方式的重现。
- en: Executing R code in non-interactive sessions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在非交互式会话中执行 R 代码
- en: Once your code has the functionality you were looking to implement, executing
    it through an interactive session using the console may not be the best way to
    do so. In such cases, another option you have is to tell your computer to directly
    execute the code for you, in a non-interactive session. This means that you won't
    be able to type commands into the console, but you'll get the benefit of being
    able to configure your computer to automatically execute code for you, or to integrate
    it into larger systems where R is only one of many components. This is known as
    batch mode.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码具有你想要实现的功能，通过交互式会话使用控制台来执行它可能不是最好的方式。在这种情况下，你还有另一个选择，就是告诉你的计算机直接为你执行代码，在一个非交互式会话中。这意味着你将无法在控制台中输入命令，但你将能够配置你的计算机来自动为你执行代码，或者将其集成到更大的系统中，其中
    R 只是许多组件之一。这被称为批处理模式。
- en: 'To execute code in the batch mode, you have two options: the old R `CMD BATCH` command
    which we won''t look into, and the newer Rscript command, which we will. The **Rscript** is
    a command that you can execute within your computer''s terminal. It receives the
    name of a source code file and executes its contents.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在批处理模式下执行代码，你有两种选择：旧的 R `CMD BATCH` 命令，我们不会探讨它，以及较新的 Rscript 命令，我们将探讨这个。**Rscript**
    是一个可以在你的计算机终端中执行的命令。它接收源代码文件的名称并执行其内容。
- en: In the following example, we will make use of various concepts that we will
    explain in later sections, so if you don't feel ready to understand it, feel free
    to skip it now and come back to it later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将使用我们在后续章节中将要解释的各种概念，所以如果你现在感觉还没有准备好理解它，请现在随意跳过，稍后再回来。
- en: Suppose you have the following code in a file named greeting.R. It gets the
    arguments passed through the command line to Rscript through the args object created
    with the `commandArgs()` function, assigns the corresponding values to the greeting and
    name variables, and finally prints a vector that contains those values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为 greeting.R 的文件中的以下代码。它通过使用 `commandArgs()` 函数创建的 args 对象从命令行获取传递给 Rscript
    的参数，将相应的值分配给 greeting 和 name 变量，并最终打印包含这些值的向量。
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once ready, you may use the Rscript command to execute it from your Terminal
    (not from within your R console) as is shown ahead.  The result shows the vector
    with the greeting and name variable values you passed it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备就绪，你可以使用Rscript命令从你的终端（而不是R控制台）执行它，如下所示。结果显示了传递给它的问候和名称变量值的向量。
- en: When you see a Command Prompt that begins with the `$` symbol instead of of
    the `>` symbol, it means that you should execute that line in your computer's
    Terminal, not in the R console.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到以`$`符号而不是`>`符号开始的命令提示符时，这意味着你应该在你的计算机终端中执行该行，而不是在R控制台中。
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that if you simply execute the file without any arguments, they will be
    passed as NA values, which allows you to customize your code to deal with such
    situations:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你简单地执行文件而不带任何参数，它们将被作为NA值传递，这允许你自定义代码以处理这种情况：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This was a very simple example, but the same mechanism can be used to execute
    much more complex systems, like the one we will build in the final chapters of
    this book to constantly retrieve real-time price data from remote servers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但同样的机制可以用来执行更复杂的系统，就像我们在本书的最后一章将要构建的那样，从远程服务器持续检索实时价格数据。
- en: Finally, if you want to provide a mechanism that is closer to the one in Python,
    you may want to look into the optparse package to create command-line help pages
    as well as to parse arguments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想要提供一个更接近Python中的机制，你可能需要查看optparse包来创建命令行帮助页面以及解析参数。
- en: How to use this book
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用这本书
- en: 'To make the most out of this book, you should recreate on your own the examples
    shown throughout, and make sure that you understand what each of them is doing
    in detail. If at some point you feel confused, it''s not too difficult to do a
    couple of searches online to clarify things for yourself. However, I highly recommend
    that you look into the following books as well, which go into more detail on some
    of the concepts and ideas presented in this book, and are considered very good
    references for R programmers:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这本书，你应该自己重新创建书中展示的示例，并确保你详细理解了每个示例的具体作用。如果在某个时候你感到困惑，在网上进行一些搜索以澄清问题并不太难。然而，我强烈建议你查看以下书籍，这些书籍更详细地介绍了本书中的一些概念和想法，并且被认为是R程序员的非常好的参考书籍：
- en: '*R in a Nutshell, by Adler, O''Reilly, 2010*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《R编程艺术》，阿德勒，奥莱利，2010*'
- en: '*The Art of R Programming, by Matloff, No Starch Press, 2011*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《R编程艺术》，马托夫，No Starch Press，2011*'
- en: '*Advanced R, by  Wickham, CRC Press, 2015*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《高级R》，威克汉姆，CRC出版社，2015*'
- en: '*R Programming for Data Science, by Peng, LeanPub, 2016*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《数据科学中的R编程》，彭，LeanPub，2016*'
- en: Sometimes all you need to do to clarify something is use R's help system. To
    get help on a function, you may use the question mark notation, like `?function_name`,
    but in case you want to search for help on a topic, you may use the `help.search()` function,
    like `help.search` *(regression).* This can be helpful if you know what topic
    you're interested in but can't remember the actual name of the function you want
    to use. Another way of invoking such functionality is using the double question
    mark notation, like `??` regression.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了澄清某事，你只需要使用R的帮助系统。要获取函数的帮助，你可以使用问号符号，如`?function_name`，但如果你想要搜索某个主题的帮助，你可以使用`help.search()`函数，如`help.search`
    *(回归)*。如果你知道你感兴趣的主题，但记不起你想要使用的实际函数名，这可能会很有帮助。调用此类功能的一种另一种方式是使用双问号符号，如`??`回归。
- en: Keep in mind that topics in this book are interconnected and not linearly ordered,
    which means that at times it will seem that we are jumping around. When that happens,
    it's because a topic can be seen through different points of view. That's why,
    to make the most out of this book, you should experiment as much as you can in
    the console and build code progressively using the write-execute loop mentioned
    earlier. If you simply replicate the code exactly as is shown, you may miss some
    of the learning that you could have gotten had you built the systems step by step.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，本书中的主题是相互关联的，而不是线性排列的，这意味着有时会感觉我们在跳跃。当这种情况发生时，是因为可以从不同的角度看待一个主题。这就是为什么，为了充分利用这本书，你应该尽可能在控制台中实验，并使用前面提到的写-执行循环逐步构建代码。如果你只是完全复制显示的代码，你可能会错过一些通过逐步构建系统可以获得的学到的知识。
- en: Finally, you should know that this book is meant to show how to use R through
    somewhat real examples, and as such, does not provide too much technical depth
    or discussion on some of the topics presented. Furthermore, since my objective
    is to get you quickly working with the real examples, in this first chapter, I
    explain R fundamentals very briefly, just to introduce the minimum amount of knowledge
    you need to follow through the real examples presented in the following chapters.
    Therefore, you should not think that the explanations presented in this chapter
    are enough for you to understand R's basic constructs. If you're looking for a
    more in-depth introduction to R fundamentals, you may want to take a look at the
    references we mentioned previously.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该知道这本书的目的是通过一些相对真实的例子来展示如何使用 R，因此它不会提供太多关于所讨论主题的技术深度或讨论。此外，由于我的目标是让你快速开始使用真实例子，所以在第一章中，我非常简要地解释了
    R 的基础知识，只是为了介绍你接下来几章中需要了解的最少知识。因此，你不应该认为本章中提供的解释就足够你理解 R 的基本结构。如果你在寻找对 R 基础的更深入介绍，你可能想看看我们之前提到的参考资料。
- en: Tracking state with symbols and variables
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用符号和变量跟踪状态
- en: Like most programming languages, R lets you assign values to variables and refer
    to these objects by name. The names you use to refer to variables are called symbols in
    R. This allows you to keep some information available in case it's needed at a
    later point in time. These variables may contain any type of object available
    in R, even combinations of them when using lists, as we will see in a later section
    in this chapter. Furthermore, these objects are immutable, but that's a topic
    for [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730), *Implementing
    an Efficient Simple Moving Average*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言一样，R 允许你给变量赋值并通过名称引用这些对象。在 R 中，你用来引用变量的名称被称为符号。这允许你在需要时保留一些信息。这些变量可以包含
    R 中可用的任何类型的对象，甚至在列表中使用时，可以包含它们的组合，正如我们在本章后面的部分将看到的。此外，这些对象是不可变的，但这将是第 9 章[实现高效的简单移动平均](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730)的主题。
- en: In R, the assignment operator is `<-`, which is a less-than symbol (`<`) followed
    by a dash (`-`). If you have worked with algorithm pseudo code before, you may
    find it familiar. You may also use the single equals symbol (`=`) for assignments,
    similar to many other languages, but I prefer to stick to the `<-` operator.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，赋值运算符是 `<-`，它是一个小于符号（`<`）后面跟着一个连字符（`-`）。如果你之前曾与算法伪代码一起工作过，你可能会觉得它很熟悉。你也可以使用单个等号（`=`）进行赋值，类似于许多其他语言，但我更喜欢坚持使用
    `<-` 运算符。
- en: An expression like `x <- 1` means that the value `1` is assigned to the  `x` symbol,
    which can be thought of as a variable. You can also assign the other way around,
    meaning that with an expression like `1 -> x `we would have the same effect as
    we did earlier. However, the assignment from left to right is very rarely used,
    and is more of a convenience feature in case you forget the assignment operator
    at the beginning of a line in the console.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `x <- 1` 的意思是将值 `1` 赋给 `x` 符号，这可以被视为一个变量。你也可以反过来赋值，这意味着使用表达式 `1 -> x` 我们会得到与之前相同的效果。然而，从左到右的赋值很少使用，更多是一种方便的特性，以防你在控制台的一行开头忘记了赋值运算符。
- en: 'Note that the value substitution is done at the time when the value is assigned
    to `z`, not at the time when `z` is evaluated. If you enter the following code
    into the console, you can see that the second time `z` is printed, it still has
    the value that y had when it was used to assign to it, not the y value assigned
    afterward:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值替换是在将值赋给 `z` 的时候进行的，而不是在 `z` 被评估的时候。如果你将以下代码输入到控制台，你可以看到，当 `z` 第二次被打印时，它仍然具有当它被用来赋值时的
    y 的值，而不是之后赋给 y 的值：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's easy to use variable names like `x`, `y`, and `z`, but using them has a
    high cost for real programs. When you use names like that, you probably have a
    very good idea of what values they will contain and how they will be used. In
    other words, their intention is clear for you. However, when you give your code
    to someone else or come back to it after a long period of time, those intentions
    may not be clear, and that's when cryptic names can be harmful. In real programs,
    your names should be self descriptive and instantly communicate intention.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 `x`、`y` 和 `z` 这样的变量名很容易，但它们在真实程序中的使用成本很高。当你使用这样的名字时，你可能非常清楚它们将包含什么值以及如何使用。换句话说，它们对你来说意图是清晰的。然而，当你将代码交给别人或长时间后再次回到它时，这些意图可能不再清晰，这就是隐晦名称可能有害的地方。在真实程序中，你的名称应该是自我描述性的，并能立即传达意图。
- en: 'For a deeper discussion about this and many other topics regarding high-quality
    code, take a look at Martin''s excellent book *Clean Code: A Handbook of Agile
    Software Craftsmanship, Prentice Hall, 2008*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '若想深入了解关于高质量代码的讨论以及许多其他相关话题，请参阅马丁的杰出著作《Clean Code: A Handbook of Agile Software
    Craftsmanship, Prentice Hall, 2008》。'
- en: 'Standard object names in R should only contain alphanumeric characters (numbers
    and ASCII letters), underscores (`_`), and, depending on context, even periods
    (`.`). However, R will allow you to use very cryptic strings if you want. For
    example, in the following code, we show how the variable `!A @B #C $D %E ^F` name
    is used to contain a vector with three integers. As you can see, you are even
    allowed to use spaces. You can use this non-standard name provided that you wrap
    the string with backticks (`` ` ``):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'R 中的标准对象名称应仅包含字母数字字符（数字和 ASCII 字母）、下划线（`_`），以及根据上下文，甚至可以包含点（`.`）。然而，如果你愿意，R
    允许你使用非常隐晦的字符串。例如，在下面的代码中，我们展示了如何使用变量 `!A @B #C $D %E ^F` 的名称来包含一个包含三个整数的向量。正如你所见，你甚至可以使用空格。只要你在字符串周围加上反引号（``
    ` ``），就可以使用这种非标准名称：'
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It goes without saying that you should avoid those names, but you should be
    aware they exist because they may come in handy when using some of R''s more advanced
    features. These types of variable names are not allowed in most languages, but
    R is flexible in that way. Furthermore, the example goes to show a common theme
    around R programming: it is so flexible that if you''re not careful, you will
    end up shooting yourself in the foot. It''s not too rare for someone to be very
    confused about some code because they assumed R would behave a certain way (for
    example, raise an error under certain conditions) but don''t explicitly test for
    such behavior, and later find that it behaves differently.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，你应该避免这些名称，但你应该意识到它们的存在，因为在使用 R 的某些更高级功能时，它们可能会派上用场。这类变量名在大多数语言中是不允许的，但
    R 在这方面非常灵活。此外，这个例子也展示了 R 编程的一个常见主题：它非常灵活，如果你不小心，你可能会自己给自己挖坑。有人对某些代码感到非常困惑，因为他们假设
    R 会以某种方式（例如，在特定条件下引发错误）行为，但没有明确测试这种行为，后来发现它的行为不同。
- en: Working with data types and data structures
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据类型和数据结构
- en: This section summarizes the most important data types and data structures in
    R. In this brief overview, we won't discuss them in depth. We will only show a
    couple of examples that will allow you to understand the code shown throughout
    this book. If you want to dig deeper into them, you may look into their documentation
    or some of the references pointed out in this chapter's introduction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了 R 中最重要的数据类型和数据结构。在这个简要概述中，我们不会深入讨论它们。我们只会展示几个示例，这将帮助你理解本书中展示的代码。如果你想深入了解它们，你可以查看它们的文档或本章引言中提到的参考文献。
- en: The basic data types in R are numbers, text, and Boolean values (`TRUE` or `FALSE`),
    which R calls numerics, characters, and logicals, respectively. Strictly speaking,
    there are also types for integers, complex numbers, and raw data (bytes), but
    we won't use them explicitly in this book. The six basic data structures in R
    are vectors, factors, matrices, data frames, and lists, which we will summarize
    in the following sections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的基本数据类型是数字、文本和布尔值（`TRUE` 或 `FALSE`），R 分别称之为数值、字符和逻辑。严格来说，还有整数、复数和原始数据（字节）的类型，但在这本书中我们不会明确使用它们。R
    中的六个基本数据结构是向量、因子、矩阵、数据框和列表，我们将在以下章节中总结。
- en: Numerics
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值计算
- en: Numbers in R behave pretty much as you would mathematically expect them to.
    For example, the operation `2 / 3` performs real division, which results in `0.6666667`
    in R. This natural numeric behavior is very convenient for data analysis, as you
    don't need to pay too much attention when using numbers of different types, which
    may require special handling in other languages. Also the mathematical priorities
    for operators applies, as well the use of parenthesis.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: R中的数字的行为几乎与您在数学上期望的相同。例如，操作`2 / 3`执行实数除法，在R中结果为`0.6666667`。这种自然的数字行为对于数据分析非常方便，因为您在使用不同类型的数字时不需要过多关注，在其他语言中可能需要特殊处理。此外，运算符的数学优先级同样适用，以及括号的使用。
- en: 'The following example shows how variables can be used within operations, and
    how operator priorities are handled. As you can see, you may mix the use of variables
    with values when performing operations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在操作中使用变量，以及如何处理运算符优先级。如您所见，您可以在执行操作时混合使用变量和值：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The modulo operation can be performed with the `%%` symbol, while integer division
    can be performed with the `%/%` symbol:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算可以使用`%%`符号执行，而整数除法可以使用`%/%`符号执行：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Special values
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊值
- en: There are a few special values in R. The NA values are used to represent missing
    values, which stands for not available. If a computation results in a number that
    is too big, R will return Inf for a positive number and -Inf for a negative number,
    meaning positive and negative infinity, respectively. These are also returned
    when a number is divided by 0\. Sometimes a computation will produce a result
    that makes little sense. In these cases, we will get a NaN, which stands for not
    a number. And, finally, there is a null object, represented by NULL. The symbol
    NULL always points to the same object (which is a data type on its own) and is
    often used as a default argument in functions to mean that no value was passed
    through. You should know that `NA`, `Inf`, `-Inf`, `NaN`, and `NULL `are not substitutes
    for each other.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: R中有几个特殊值。NA值用于表示缺失值，代表不可用。如果一个计算结果为一个太大的数，R将返回正无穷大 `Inf` 和负无穷大 `-Inf`，分别表示正无穷和负无穷。当数字除以0时，这些值也会返回。有时计算会产生一个不太合理的结果。在这些情况下，我们将得到一个NaN，代表不是一个数字。最后，还有一个空对象，表示为NULL。符号NULL始终指向同一个对象（它本身就是一个数据类型）并且常用于函数中的默认参数，表示没有传递任何值。您应该知道`NA`，`Inf`，`-Inf`，`NaN`
    和 `NULL` 不能互相替代。
- en: There are specific NA values for numerics, characters, and logicals, but we
    will stick to the simple NA, which is internally treated as a logical.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值、字符和逻辑，存在特定的NA值，但我们将坚持使用简单的NA，它内部被处理为逻辑值。
- en: 'In the following example, you can see how these special values behave when
    used among themselves in R. Note that 1 / 0 results in `Inf`, `0 / 0`, `Inf -
    Inf`, and `Inf / Inf` results in undefined represented by `NaN`, but `Inf + Inf`,
    `0 / Inf`, and `Inf / 0`, result in `Inf`, `0`, and `Inf`, respectively. It''s
    no coincidence that these results resemble mathematical definitions. Also note
    that any operation including `NaN` or `NA` will also result in `NaN` and `NA`,
    respectively:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您可以看到这些特殊值在R中相互使用时的行为。请注意，1 / 0 结果为 `Inf`，`0 / 0`，`Inf - Inf` 和 `Inf
    / Inf` 结果为未定义，表示为 `NaN`，但 `Inf + Inf`，`0 / Inf` 和 `Inf / 0` 分别结果为 `Inf`，`0` 和
    `Inf`。这些结果与数学定义相似并非巧合。此外，请注意，任何包括 `NaN` 或 `NA` 的操作也将分别结果为 `NaN` 和 `NA`：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Characters
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符
- en: Text can be used just as easily, you just need to remember to use quotation
    marks (" ") around it. The following example shows how to save the text Hi, there!
    and "10" in two variables. Note that since "10.5" is surrounded by quotation marks,
    it is text and not a numeric value. To find what type of object you're actually
    dealing with you can use the `class()`, `typeof()`, and `str()` (short for structure)
    functions to get the metadata for the object in question.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 文本也可以像这样使用，只需记住在它周围使用引号(" ")。以下示例展示了如何将文本“Hi, there!”和“10”保存到两个变量中。请注意，由于“10.5”被引号包围，它被视为文本而不是数值。要找到您实际处理的对象的类型，可以使用`class()`，`typeof()`和`str()`（简称结构）函数来获取有关该对象的元数据。
- en: 'In this case, since the y variable contains text, we can''t multiply it by
    2, as is seen in the error we get. Also, if you want to know the number of characters
    in a string, you can use the `nchar()` function, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于y变量包含文本，我们不能像错误信息中看到的那样将其乘以2。此外，如果您想了解字符串中的字符数，可以使用`nchar()`函数，如下所示：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Sometimes, you may have text information, as well as numeric information that
    you want to combine into a single string. In this case, you should use the `paste()`
    function. This function receives an arbitrary number of unnamed arguments, which
    is something we will define more precisely in a later section in this chapter.
    It then transforms each of these arguments into characters, and returns a single
    string with all of them combined. The following code shows such an example. Note
    how the numeric value of 10 in y was automatically transformed into a character
    type so that it could be pasted inside the rest of the string:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能既有文本信息，也有你想要合并到单个字符串中的数值信息。在这种情况下，你应该使用`paste()`函数。这个函数接收任意数量的未命名参数，我们将在本章后面的部分中更精确地定义这一点。然后它将每个参数转换为字符，并返回一个包含所有这些参数的单个字符串。以下代码展示了这样的一个例子。注意，y中的数值10被自动转换为字符类型，以便可以将其粘贴到字符串的其余部分中：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Other times, you will want to replace some characters within a piece of text.
    In that case, you should use the `gsub()` function, which stands for global substitution.
    This function receives the string to be replaced as its first argument, the string
    to replace with as its second argument, and it will return the text in the third
    argument with the corresponding replacements:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要替换文本中的某些字符。在这种情况下，你应该使用`gsub()`函数，它代表全局替换。这个函数接受要替换的字符串作为其第一个参数，替换字符串作为其第二个参数，并将返回带有相应替换的文本作为第三个参数：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Yet other times, you will want to know whether a string contains a substring,
    in which case you should use the `gprel()` function. The name for this function
    comes from terminal command known as grep, which is an acronym for global regular
    expression print (yes, you can also use regular expressions to look for matches).
    The l at the end of `grepl()` comes from the fact that the result is a logical:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一些时候，你可能想知道一个字符串是否包含子字符串，在这种情况下你应该使用`gprel()`函数。这个函数的名字来源于一个终端命令grep，它是全局正则表达式打印的缩写（是的，你也可以使用正则表达式来查找匹配）。`grepl()`函数名末尾的l来自于结果是一个逻辑值：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Logicals
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical vectors contain Boolean values, which can only be `TRUE` or `FALSE`.
    When you want to create logical variables with such values, you must avoid using
    quotation marks around them and remember that they are all capital letters, as
    shown here. When programming in R, logical values are commonly used to test a
    condition, which is in turn used to decide which branch from a complex program
    we should take. We will look at examples for this type of behavior in a later
    section in this chapter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑向量包含布尔值，只能为`TRUE`或`FALSE`。当你想要创建具有这些值的逻辑变量时，你必须避免在它们周围使用引号，并记住它们都是大写字母，如下所示。在R语言编程中，逻辑值通常用于测试条件，这些条件反过来又用于决定我们应该从复杂的程序中采取哪个分支。我们将在本章后面的部分中查看此类行为的示例：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In R, you can easily convert values among different types with the `as.*()` functions,
    where `*` is used as a wildcard which can be replaced with character, numeric,
    or logical to convert among these types. The functions work by receiving an object
    of a different type from what the function name specifies and return the object
    parsed into the specified type if possible, or return an `NA` if it''s not possible.
    The following example shows how to convert the `TRUE` string into a logical value,
    which in this case non-surprisingly turns out to be the logical `TRUE`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，你可以使用`as.*()`函数轻松地在不同类型之间转换值，其中`*`用作通配符，可以替换为字符、数值或逻辑，以在这些类型之间进行转换。这些函数通过接收与函数名称指定的类型不同的对象，并在可能的情况下将其解析为指定类型，如果不可能，则返回`NA`。以下示例显示了如何将`TRUE`字符串转换为逻辑值，在这种情况下，不出所料，它变成了逻辑`TRUE`：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Converting from characters and numerics into logicals is one of those things
    that is not very intuitive in R. The following table shows some of this behavior.
    Note that even though the `true` string (all lowercase letters) is not a valid
    logical value when removing quotation marks, it is converted into a `TRUE` value
    when applying the `as.logical()` to it, for compatibility reasons. Also note that
    since T is a valid logical value, which is a shortcut for `TRUE`, it's corresponding
    text is also accepted as meaning such a value. The same logic applies to `false` and
    `F`. Any other string will return an `NA` value, meaning that the string could
    not be parsed as a logical value. Also note that 0 will be parsed as `FALSE`,
    but any other numeric value, including Inf, will be converted to a `TRUE` value.
    Finally, note that both `NA `and `NaN `will be parsed, returning NA in both cases.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中将字符和数值转换为逻辑值不是一件很直观的事情。下表显示了一些这种行为。请注意，尽管“true”字符串（全部小写字母）在去除引号时不是一个有效的逻辑值，但在应用
    `as.logical()` 函数时，它会被转换为 `TRUE` 值，这是为了兼容性。还请注意，由于 T 是一个有效的逻辑值，它是 `TRUE` 的快捷方式，所以相应的文本也被接受为表示这样的值。同样的逻辑也适用于
    `false` 和 `F`。任何其他字符串都将返回 `NA` 值，这意味着该字符串不能解析为逻辑值。还请注意，0 将被解析为 `FALSE`，但任何其他数值，包括
    Inf，都将转换为 `TRUE` 值。最后，请注意，`NA` 和 `NaN` 都将被解析，在两种情况下都返回 NA。
- en: The `as.character()` and `as.numeric()` functions have less counter-intuitive
    behavior, and I will leave you to explore them on your own. When you do, try to
    test as many edge cases as you can. Doing so will help you foresee possible issues
    as you develop your own programs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`as.character()` 和 `as.numeric()` 函数的行为不太直观，我将留给你自己探索。当你这样做的时候，尽量测试尽可能多的边缘情况。这样做将帮助你预见在开发自己的程序时可能遇到的问题。'
- en: '![](img/00007.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: Before we move on, you should know that these data structures can be organized
    by their dimensionality and whether they're homogeneous (all contents must be
    of the same type) or heterogeneous (the contents can be of different types). Vectors,
    matrices, and arrays are homogeneous data structures, while lists and data frames
    are heterogeneous. Vectors and lists have a single dimension, matrices and data
    frames have two dimensions, and arrays can have as many dimensions as we want.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你应该知道这些数据结构可以根据它们的维数和是否同质（所有内容必须是同一类型）或异质（内容可以是不同类型）来组织。向量、矩阵和数组是同质数据结构，而列表和数据框是异质。向量和列表具有单一维度，矩阵和数据框具有两个维度，而数组可以具有我们想要的任意多个维度。
- en: '![](img/00008.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: When it comes to dimensions, arrays in R are different from arrays in many other
    languages, where you would have to create an array of arrays to produce a two-dimensional
    structure, which is not necessary in R.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到维度时，R 中的数组与许多其他语言中的数组不同，在其他语言中，你需要创建一个数组的数组来产生二维结构，而在 R 中这是不必要的。
- en: Vectors
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: The fundamental data type in R is the vector, which is an ordered collection
    of values. The first thing you should know is that unlike other languages, single
    values for numbers, strings, and logicals, are special cases of vectors (vectors
    of length one), which means that there's no concept of scalars in R. A vector
    is a one-dimensional data structure and all of its elements are of the same data
    type.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的基本数据类型是向量，它是有序值集合。你应该知道的第一件事是，与其它语言不同，数字、字符串和逻辑值的单个值是向量的特殊情况（长度为1的向量），这意味着在
    R 中没有标量的概念。向量是一维数据结构，其所有元素都是相同的数据类型。
- en: The simplest way to create a vector is with the `c()` function, which stands
    for combine, and coerces all of its arguments into a single type. The coercion
    will happen from simpler types into more complex types. That is, if we create
    a vector which contains logicals, numerics, and characters, as the following example
    shows, our resulting vector will only contain characters, which are the more complex
    of the three types. If we create a vector that contains logicals and numerics,
    our resulting vector will be numeric, again because it's the more complex type.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建向量的最简单方法是使用 `c()` 函数，它代表组合，并将所有参数强制转换为单一类型。强制转换将从更简单的类型转换为更复杂的类型。也就是说，如果我们创建一个包含逻辑值、数值和字符的向量，如下例所示，我们的结果向量将只包含字符，因为它们是三种类型中最复杂的。如果我们创建一个包含逻辑值和数值的向量，我们的结果向量将是数值的，因为它是三种类型中最复杂的类型。
- en: Vectors can be named or unnamed. Unnamed vector elements can only be accessed
    through positional references, while named vectors can be accessed through positional
    references as well as name references. In the example below, the y vector is a
    named vector, where each element is named with a letter from A to I. This means
    that in the case of x, we can only access elements using their position (the first
    position is considered as 1 instead of the 0 used in other languages), but in
    the case of y, we may also use the names we assigned.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 向量可以是命名的或未命名的。未命名的向量元素只能通过位置引用来访问，而命名的向量可以通过位置引用以及名称引用来访问。在下面的例子中，y 向量是一个命名的向量，其中每个元素都用字母
    A 到 I 命名。这意味着在 x 的情况下，我们只能使用位置（第一个位置被视为 1 而不是其他语言中使用的 0）来访问元素，但在 y 的情况下，我们也可以使用我们分配的名称。
- en: 'Also note that the special values we mentioned before, that is NA, NULL, NaN,
    and Inf, will be coerced into characters if that''s the more complex type, except
    NA, which stays the same. In case coercion is happening toward numerics, they
    all stay the same since they are valid numeric values. Finally, if we want to
    know the length of a vector, simply call the `length()` function upon it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们之前提到的特殊值，即 NA、NULL、NaN 和 Inf，如果它们是更复杂的类型，将会被强制转换为字符，除了 NA，它保持不变。如果强制转换是向数值类型进行，它们都保持不变，因为它们是有效的数值。最后，如果我们想知道向量的长度，只需在它上面调用
    `length()` 函数即可：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Furthermore, we can select sets or ranges of elements using vectors with index
    numbers for the values we want to retrieve. For example, using the selector c(1,
    2) would retrieve the first two elements of the vector, while using the c(1, 3,
    5) would return the first, third, and fifth elements. The : function (yes, it''s
    a function even though we don''t normally use the function-like syntax we have
    seen so far in other examples to call it), is often used as a shortcut to create
    range selectors. For example, the 1:5 syntax means that we want a vector with
    elements 1 through 5, which would be equivalent to explicitly using c(1, 2, 3,
    4, 5). Furthermore, if we send a vector of logicals, which must have the same
    length as the vector we want to retrieve values from, each of the logical values
    will be associated to the corresponding position in the vector we want to retrieve
    from, and if the corresponding logical is `TRUE`, the value will be retrieved,
    but if it''s `FALSE`, it won''t be. All of these selection methods are shown in
    the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我们可以使用索引数字的向量来选择或选择元素集合或范围。例如，使用选择器 c(1, 2) 会检索向量的前两个元素，而使用 c(1, 3, 5) 会返回第一个、第三个和第五个元素。:
    函数（是的，它是一个函数，尽管我们通常不会使用我们在其他示例中看到的类似函数的语法来调用它），通常用作创建范围选择器的快捷方式。例如，1:5 语法意味着我们想要一个包含元素
    1 到 5 的向量，这相当于明确使用 c(1, 2, 3, 4, 5)。此外，如果我们发送一个逻辑向量，它必须与我们要从中检索值的向量的长度相同，每个逻辑值将与我们要从中检索的向量的相应位置相关联，如果相应的逻辑是
    `TRUE`，则检索值，但如果它是 `FALSE`，则不会检索。所有这些选择方法都在以下示例中展示：'
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next we will talk about operation among vectors. In the case of numeric vectors,
    we can apply operations element-to-element by simply using operators as we normally
    would. In this case, R will match the elements of the two vectors pairwise and
    return a vector. The following example shows how two vectors are added, subtracted,
    multiplied, and divided in an element-to-element way. Furthermore, since we are
    working with vectors of the same length, we may want to get their dot-product
    (if you don''t know what a dot-product is, you may take a look at [https://en.wikipedia.org/wiki/Dot_product](https://en.wikipedia.org/wiki/Dot_product)),
    which we can do using the `%*%` operator, which performs matrix-like multiplications,
    in this case vector-to-vector:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论向量之间的运算。在数值向量的情况下，我们可以通过简单地使用运算符来逐元素应用操作。在这种情况下，R 将成对匹配两个向量的元素并返回一个向量。以下示例展示了两个向量如何以逐元素的方式相加、相减、相乘和相除。此外，由于我们正在处理长度相同的向量，我们可能想要获取它们的点积（如果你不知道什么是点积，你可以查看[https://en.wikipedia.org/wiki/Dot_product](https://en.wikipedia.org/wiki/Dot_product)），我们可以使用
    `%*%` 运算符来完成，它执行类似矩阵的乘法，在这种情况下是向量到向量的乘法：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want to combine multiple vectors into a single one, you can simply use
    the `c()` recursively on them, and it will flatten them for you automatically.
    Let''s say we want to combine the x and y into the z such that the y elements
    appear first. Furthermore, suppose that after we do we want to sort them, so we
    apply the `sort()` function on z:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将多个向量合并成一个，你可以简单地递归地使用 `c()` 函数对它们进行操作，它将自动将它们展平。假设我们想要将 x 和 y 合并成 z，使得
    y 的元素先出现。此外，假设我们在合并之后想要对它们进行排序，那么我们对 z 应用 `sort()` 函数：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A common source for confusion is how R deals with vectors of different lengths.
    If we apply an element-to-element operation, as the ones we covered earlier, but
    using vectors of different lengths, we may expect R to throw an error, as is the
    case in other languages. However, it does not. Instead, it repeats vector elements
    in order until they all have the same length. The following example shows three
    vectors, each of different lengths, and the result of adding them together.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆的一个常见来源是 R 如何处理不同长度的向量。如果我们应用元素到元素的运算，就像我们之前提到的，但使用不同长度的向量，我们可能会期望 R 抛出一个错误，就像在其他语言中那样。然而，它并没有这样做。相反，它会按顺序重复向量元素，直到它们的长度都相同。以下示例显示了三个不同长度的向量，以及将它们相加的结果。
- en: 'The way R is configured by default, you will actually get a warning message
    to let you know that the vectors you operated on were not of the same length,
    but since R can be configured to avoid showing warnings, you should not rely on
    them:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，R 的配置方式实际上会显示一个警告消息，告诉你你操作的向量长度不同，但由于 R 可以配置为避免显示警告，因此你不应该依赖它们：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing that may come to mind is that the first vector is expanded into
    `c(1, 2, 1, 2)`, the second vector is expanded into `c(3, 4, 5, 3)`, and the third
    one is kept as is, since it's the largest one. Then if we add these vectors together,
    the result would be `c(10, 13, 14, 14)`. However, as you can see in the example,
    the result actually is `c(10, 13, 14, 13)`. So, what are we missing? The source
    of confusion is that R does this step by step, meaning that it will first perform
    the addition `c(1, 2) + c(3, 4, 5)`, which after being expanded is `c(1, 2, 1)
    + c(3, 4, 5)` and results in `c(4, 6, 6)`, then given this result, the next step
    that R performs is `c(4, 6, 6) + c(6, 7, 8, 9)`, which after being expanded is
    `c(4, 6, 6, 4) + c(6, 7, 8, 9)`, and that's where the result we get comes from.
    It can be confusing at first, but just remember to imagine the operations step
    by step.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可能出现在脑海中的想法是，第一个向量被展开为 `c(1, 2, 1, 2)`，第二个向量被展开为 `c(3, 4, 5, 3)`，而第三个向量保持不变，因为它是最长的。然后如果我们把这些向量加在一起，结果将是
    `c(10, 13, 14, 14)`。然而，正如你在示例中看到的，实际的结果实际上是 `c(10, 13, 14, 13)`。那么，我们遗漏了什么呢？混淆的来源是
    R 是逐步进行这一步骤的，这意味着它首先执行 `c(1, 2) + c(3, 4, 5)` 的加法，展开后是 `c(1, 2, 1) + c(3, 4, 5)`，结果是
    `c(4, 6, 6)`，然后基于这个结果，R 执行的下一步是 `c(4, 6, 6) + c(6, 7, 8, 9)`，展开后是 `c(4, 6, 6,
    4) + c(6, 7, 8, 9)`，这就是我们得到的结果来源。一开始可能会感到困惑，但只要记住要想象这些操作是逐步进行的。
- en: Finally, we will briefly mention a very powerful feature in R, known as vectorization.
    Vectorization means that you apply an operation to a vector at once, instead of
    independently doing so to each of its elements. This is a feature you should get
    to know quite well. Programming without it is considered to be bad R code, and
    not just for syntactic reasons, but because vectorized code takes advantage of
    many internal optimizations in R, which results in much faster code. We will show
    different ways of vectorizing code in [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730),
    *Implementing An Efficient Simple Moving Average*, and in this chapter, we will
    see an example, followed by a couple more in following sections.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要介绍 R 中一个非常强大的功能，称为向量化。向量化意味着你一次性对一个向量应用一个操作，而不是独立地对它的每个元素进行操作。这是一个你应该相当熟悉的特性。没有它的编程被认为是糟糕的
    R 代码，这不仅是因为语法原因，也因为向量化代码利用了 R 中的许多内部优化，这导致了代码运行得更快。我们将在第 9 章 [实现一个有效的简单移动平均](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730)中展示不同的向量化代码方法，本章中，我们将看到一个示例，随后在接下来的几节中还将看到更多示例。
- en: 'Even though the phrase vectorized code may seem scary or magical at first,
    in reality, R makes it quite simple to implement in some cases. For example, we
    can square each of the elements in the x vector by using the x symbol as if it
    were a single number. R is intelligent enough to understand that we want to apply
    the operation to each of the elements in the vector. Many functions in R can be
    applied using this technique:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管短语“向量化代码”一开始可能看起来令人畏惧或神奇，但实际上，R在某些情况下使其实施变得相当简单。例如，我们可以通过将x符号用作单个数字来对x向量中的每个元素进行平方。R足够智能，能够理解我们想要将操作应用于向量中的每个元素。R中的许多函数都可以使用这种技术进行应用：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will see more examples that really showcase how vectorization can shine in
    the following section about functions, where we will see how to apply vectorized
    operations even when the operations depend on other parameters.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节关于函数的部分，我们将看到更多真正展示向量化如何大放异彩的例子，我们将看到即使在操作依赖于其他参数的情况下，如何应用向量化操作。
- en: Factors
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因子
- en: When analyzing data, it's quite common to encounter categorical values. R provides
    a good way to represent categorical values using factors, which are created using
    the `factor()` function and are integer vectors with associated labels for each
    integer. The different values that the factor can take are called levels. The
    `levels()` function shows all the levels from a factor, and the levels parameter
    of the `factor()` function can be used to explicitly define their order, which
    is alphabetical in case it's not explicitly defined.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析数据时，遇到分类值是非常常见的。R提供了一个很好的方法来使用因子表示分类值，这些因子是通过`factor()`函数创建的，是具有每个整数相关标签的整数向量。因子可以取的不同值称为级别。`levels()`函数显示因子的所有级别，`factor()`函数的级别参数可以用来显式定义它们的顺序，如果未显式定义，则按字母顺序排列。
- en: Note that defining an explicit order can be important in linear modeling because
    the first level is used as the baseline level for functions like `lm()` (linear
    models), which we will use in [Chapter 3](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730),
    *Predicting Votes with Linear Models*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在线性建模中定义显式顺序可能很重要，因为第一个级别被用作`lm()`（线性模型）等函数的基线级别，这些函数我们将在[第3章](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730)，“使用线性模型预测投票”中使用。
- en: 'Furthermore, printing a factor shows slightly different information than printing
    a character vector. In particular, note that the quotes are not shown and that
    the levels are explicitly printed in order afterwards:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，打印因子显示的信息与打印字符向量略有不同。特别是请注意，引号没有显示，并且级别随后按顺序显式打印：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Factors can sometimes be tricky to work with because their types are interpreted
    differently depending on what function is used to operate on them. Remember the
    `class()` and `typeof()` functions we used before? When used on factors, they
    may produce unexpected results. As you can see below, the `class()` function will
    identify x and y as being character and factor, respectively. However, the `typeof()`
    function will let us know that they are character and integer, respectively. Confusing
    isn't it? This happens because, as we mentioned, factors are stored internally
    as integers, and use a mechanism similar to look-up tables to retrieve the actual
    string associated for each one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时因子可能难以处理，因为它们的类型取决于使用什么函数来操作它们。还记得我们之前使用的`class()`和`typeof()`函数吗？当用于因子时，它们可能会产生意外的结果。正如你所看到的，`class()`函数将x和y分别识别为字符和因子。然而，`typeof()`函数会让我们知道它们分别是字符和整数。这不是很令人困惑吗？这种情况发生是因为，正如我们之前提到的，因子在内部以整数形式存储，并使用类似于查找表的机制来检索与每个整数关联的实际字符串。
- en: Technically, the way factors store the strings associated with their integer
    values is through attributes, which is a topic we will touch on in [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730), 
    *Object-Oriented System to Track Cryptocurrencies*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，因子存储与它们的整数值关联的字符串的方式是通过属性，这是我们在[第8章](part0178.html#59O440-f494c932c729429fb734ce52cafce730)，“面向对象的系统跟踪加密货币”中将要涉及的一个主题。
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'While factors look and often behave like character vectors, as we mentioned,
    they are actually integer vectors, so be careful when treating them like strings.
    Some string methods, like `gsub()` and `grepl()`, will coerce factors to characters,
    while others, like `nchar()`, will throw an error, and still others, like `c()`,
    will use the underlying integer values. For this reason, it''s usually best to
    explicitly convert factors to the data type you need:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然因子看起来和通常的行为像字符向量，正如我们之前提到的，它们实际上是整数向量，所以在将它们当作字符串处理时要小心。一些字符串方法，如`gsub()`和`grepl()`，会将因子强制转换为字符，而其他方法，如`nchar()`，会抛出错误，还有一些方法，如`c()`，会使用其底层的整数值。因此，通常最好显式地将因子转换为所需的
    数据类型：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you did not notice, the `nchar()` applied itself to each of the elements
    in the x factor. The `"Blue"`, `"Red"`, and `"Black"` strings have 4, 3, and 5
    characters, respectively. This is another example of the vectorized operations
    we mentioned in the vectors section earlier.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有注意到，`nchar()`方法本身应用于x因子中的每个元素。字符串`"Blue"`、`"Red"`和`"Black"`分别有4、3和5个字符。这是我们在向量部分之前提到的向量运算的另一个例子。
- en: Matrices
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵
- en: Matrices are commonly used in mathematics and statistics, and much of R's power
    comes from the various operations you can perform with them. In R, a matrix is
    a vector with two additional attributes, the number of rows and the number of
    columns. And, since matrices are vectors, they are constrained to a single data
    type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵在数学和统计学中常用，R的许多功能都来自于你可以对它们执行的各种操作。在R中，矩阵是一个具有两个额外属性的向量，即行数和列数。而且，由于矩阵是向量，它们被限制为单一数据类型。
- en: You can use the `matrix()` function to create matrices. You may pass it a vector
    of values, as well as the number of rows and columns the matrix should have. If
    you specify the vector of values and one of the dimensions, the other one will
    be calculated for you automatically to be the lowest number that makes sense for
    the vector you passed. However, you may specify both of them simultaneously if
    you prefer, which may produce different behavior depending on the vector you passed,
    as can be seen in the next example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`matrix()`函数来创建矩阵。你可以传递一个值向量，以及矩阵应具有的行数和列数。如果你指定了值向量和其中一个维度，另一个维度将自动为你计算，以使向量传递的最低数字有意义。然而，如果你更喜欢同时指定两者，这可能会根据你传递的向量产生不同的行为，如下一个示例所示。
- en: 'By default, matrices are constructed column-wise, meaning that the entries
    can be thought of as starting in the upper-left corner and running down the columns.
    However, if you prefer to construct it row-wise, you can send the `byrow = TRUE` parameter.
    Also, note that you may create an empty or non-initialized matrix, by specifying
    the number of rows and columns without passing any actual data for its construction,
    and if you don''t specify anything at all, an uninitialized 1-by-1 matrix will
    be returned. Finally, note that the same element-repetition mechanism we saw for
    vectors is applied when creating matrices, so do be careful when creating them
    this way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，矩阵是按列构建的，这意味着条目可以被认为是从左上角开始并向下运行到列。然而，如果你更喜欢按行构建，你可以发送`byrow = TRUE`参数。此外，请注意，你可以通过指定行数和列数而不传递任何实际数据来创建一个空矩阵或未初始化的矩阵，如果你什么都不指定，将返回一个未初始化的1x1矩阵。最后，请注意，在创建矩阵时，我们看到的与向量相同的元素重复机制也适用，所以在以这种方式创建时要小心：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Matrix subsets can be specified in various ways. Using matrix-like notation,
    you can specify the row and column selection using the same mechanisms we showed
    before for vectors, with which you can use vectors with indexes or vectors with
    logicals, and in case you decide to use vectors with logicals the vector used
    to subset must be of the same length as the matrix's dimension you are using it
    for. Since in this case, we have two dimensions to work with, we must separate
    the selection for rows and columns by using a comma (,) between them (row selection
    goes first), and R will return their intersection.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵子集可以用各种方式指定。使用类似矩阵的表示法，你可以使用我们之前为向量显示的相同机制来指定行和列的选择，其中你可以使用带有索引的向量或带有逻辑的向量，如果你决定使用带有逻辑的向量，用于子集的向量必须与你要使用的矩阵维度相同长度。由于在这种情况下，我们有两个维度要处理，我们必须通过在它们之间使用逗号（,）来分隔行和列的选择（行选择先进行），R将返回它们的交集。
- en: 'For example, `x[1, 2]` tells R to get the element in the first row and the
    second column, `x[1:2, 1]` tells R to get the first through second elements of
    the third row, which is equivalent to using `x[c(1, 2), 3]`. You may also use
    logical vectors for the selection. For example, `x[c(TRUE, FALSE), c(TRUE, FALSE,
    TRUE)]` tells R to get the first row while avoiding the second one, and from that
    row, to get the first and third columns. An equivalent selection is `x[1, c(1,
    3)]`. Note that when you want to specify a single row or column, you can use an
    integer by itself, but if you want to specify two or more, then you must use vector
    notation. Finally, if you leave out one of the dimension specifications, R will
    interpret as getting all possibilities for that dimension:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`x[1, 2]`告诉R获取第一行第二列的元素，`x[1:2, 1]`告诉R获取第三行的第一到第二个元素，这相当于使用`x[c(1, 2), 3]`。你也可以使用逻辑向量进行选择。例如，`x[c(TRUE,
    FALSE), c(TRUE, FALSE, TRUE)]`告诉R获取第一行同时避免第二行，并从该行中获取第一和第三列。一个等效的选择是`x[1, c(1,
    3)]`。请注意，当你想指定单个行或列时，你可以单独使用一个整数，但如果你想指定两个或更多，则必须使用向量表示法。最后，如果你省略了一个维度规格，R将解释为获取该维度的所有可能性：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As mentioned earlier, matrices are basic mathematical tools, and R gives you
    a lot of flexibility when working with them. The most common matrix operation
    is transposition, which is performed using the `t()` function, and matrix-vector
    multiplication, vector-matrix multiplication, and matrix-matrix multiplication,
    which are performed with the `%*%` operator we used previously to calculate the
    dot-product of two vectors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，矩阵是基本的数学工具，R在处理矩阵时提供了很多灵活性。最常见的矩阵操作是转置，使用`t()`函数执行，还有矩阵-向量乘法、向量-矩阵乘法和矩阵-矩阵乘法，这些操作使用我们之前用来计算两个向量点积的`%*%`运算符。
- en: 'Note that the same dimensionality restrictions apply as with mathematical notation,
    meaning that in case you try to perform one of these operations and the dimensions
    don''t make mathematical sense, R will throw an error, as can be seen in the last
    part of the example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与数学符号相同的维度限制同样适用，这意味着如果你尝试执行这些操作之一，而维度在数学上没有意义，R将抛出错误，如示例的最后部分所示：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Lists
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: A list is an ordered collection of objects, like vectors, but lists can actually
    combine objects of different types. List elements can contain any type of object
    that exists in R, including data frames and functions (explained in the following
    sections). Lists play a central role in R due to their flexibility and they are
    the basis for data frames, object-oriented programming, and other constructs.
    Learning to use them properly is a fundamental skill for R programmers, and here,
    we will barely touch the surface, but you should definitely research them further.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个有序的对象集合，类似于向量，但实际上列表可以组合不同类型的对象。列表元素可以包含R中存在的任何类型的对象，包括数据框和函数（在以下章节中解释）。由于它们的灵活性和作为数据框、面向对象编程和其他结构的基础，列表在R中扮演着核心角色。学会正确使用列表是R程序员的基本技能，在这里，我们只是触及了表面，但你绝对应该进一步研究它们。
- en: For those familiar with Python, R lists are similar to Python dictionaries.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉Python的人来说，R列表类似于Python字典。
- en: Lists can be explicitly created using the `list()` function, which takes an
    arbitrary number of arguments, and we can refer to each of those elements by both
    position, and, in case they are specified, also by names. If you want to reference
    list elements by names, you can use the `$` notation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以使用`list()`函数显式创建，该函数接受任意数量的参数，并且我们可以通过位置和，如果指定了，也可以通过名称来引用这些元素。如果你想通过名称引用列表元素，可以使用`$`符号。
- en: The following example shows how flexible lists can be. It shows that a list
    that contains numerics, characters, logicals, matrices, and even other lists (these
    are known as nested lists), and as you can see, we can extract each of those elements
    to work independently from them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了列表的灵活性。它显示了一个包含数值、字符、逻辑、矩阵甚至其他列表（这些被称为嵌套列表）的列表，正如你所见，我们可以独立提取这些元素来工作。
- en: This is the first time we show a multi-line expression. As you can see, you
    can do it to preserve readability and avoid having very long lines in your code.
    Arranging code this way is considered to be a good practice. If you're typing
    this directly in the console, plus symbols (+) will appear in each new line, as
    long as you have an unfinished expression, to guide you along.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次展示多行表达式。如您所见，您可以通过这种方式保持可读性并避免在代码中拥有非常长的行。以这种方式排列代码被认为是良好的实践。如果您直接在控制台中输入，每行都会出现加号（+），只要您有一个未完成的表达式，就可以引导您继续。
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When working with lists, we can use the `lapply()` function to apply a function
    to each of the elements in a list. In this case, we want to know the class and
    type of each of the elements in the list we just created:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理列表时，我们可以使用`lapply()`函数将函数应用于列表中的每个元素。在这种情况下，我们想知道我们刚刚创建的列表中每个元素的类和类型：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Data frames
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据框
- en: Now we turn to data frames, which are a lot like spreadsheets or database tables.
    In scientific contexts, experiments consist of individual observations (rows),
    each of which involves several different variables (columns). Often, these variables
    contain different data types, which would not be possible to store in matrices
    since they must contain a single data type. A data frame is a natural way to represent
    such heterogeneous tabular data. Every element within a column must be of the
    same type, but different elements within a row may be of different types, that's
    why we say that a data frame is a heterogeneous data structure.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向数据框，它们与电子表格或数据库表非常相似。在科学环境中，实验由单个观察值（行）组成，每个观察值涉及几个不同的变量（列）。通常，这些变量包含不同的数据类型，由于矩阵必须包含单一数据类型，因此无法在矩阵中存储这些数据。数据框是表示这种异构表格数据的一种自然方式。列中的每个元素必须是同一类型，但行中的不同元素可以是不同类型，这就是为什么我们说数据框是一种异构数据结构。
- en: Technically, a data frame is a list whose elements are equal-length vectors,
    and that's why it permits heterogeneity.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，数据框是一个元素长度相等的向量列表，这就是为什么它允许异构性。
- en: 'Data frames are usually created by reading in a data using the `read.table()`,
    `read.csv()`, or other similar data-loading functions. However, they can also
    be created explicitly with the `data.frame()` function or they can be coerced
    from other types of objects such as lists. To create a data frame using the `data.frame()` function,
    note that we send a vector (which, as we know, must contain elements of a single
    type) to each of the column names we want our data frame to have, which are A,
    B, and C in this case. The data frame we create below has four rows (observations)
    and three variables, with numeric, character, and logical types, respectively.
    Finally, extract subsets of data using the matrix techniques we saw earlier, but
    you can also reference columns using the $ operator and then extract elements
    from them:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框通常是通过使用`read.table()`、`read.csv()`或其他类似的数据加载函数来创建的。然而，它们也可以通过`data.frame()`函数显式创建，或者可以从列表等其他类型的对象强制转换。要使用`data.frame()`函数创建数据框，请注意，我们将一个向量（我们知道，它必须包含单一类型的元素）发送到我们想要数据框拥有的每个列名，在这种情况下是A、B和C。我们创建的数据框下面有四行（观察值）和三个变量，分别具有数值、字符和逻辑类型。最后，使用我们之前看到的矩阵技术提取数据子集，但您也可以使用$运算符引用列，然后从中提取元素：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Depending on how the data is organized, the data frame is said to be in either
    wide or narrow formats ([https://en.wikipedia.org/wiki/Wide_and_narrow_data](https://en.wikipedia.org/wiki/Wide_and_narrow_data)).
    Finally, if you want to keep only observations for which you have complete cases,
    meaning only rows that don't contain any `NA` values for any of the variables,
    then you should use the `complete.cases()` function, which returns a logical vector
    of length equal to the number of rows, and which contains a `TRUE` value for those
    rows that don't have any `NA` values and `FALSE` for those that have at least
    one such value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据组织方式，数据框可以是宽格式或窄格式（[https://en.wikipedia.org/wiki/Wide_and_narrow_data](https://en.wikipedia.org/wiki/Wide_and_narrow_data)）。最后，如果您只想保留具有完整案例的观察值，这意味着只包含任何变量中没有任何`NA`值的行，那么您应该使用`complete.cases()`函数，它返回一个长度等于行数的逻辑向量，其中包含没有`NA`值的行的`TRUE`值，以及至少有一个此类值的行的`FALSE`值。
- en: 'Note that when we created the x data frame, the C column contains an `NA` in
    its third value. If we use the `complete.cases()` function on x, then we will
    get a `FALSE` value for that row and a `TRUE` value for all others. We can then
    use this logical vector to subset the data frame just as we have done before with
    matrices. This can be very useful when analyzing data that may not be clean, and
    for which you only want to keep those observations for which you have full information:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们创建x数据框时，C列在其第三个值中包含一个`NA`。如果我们对x使用`complete.cases()`函数，那么我们将得到该行的`FALSE`值，而对于所有其他行则是`TRUE`值。然后我们可以使用这个逻辑向量来对数据框进行子集化，就像我们之前用矩阵做的那样。这在分析可能不干净的数据时非常有用，并且你只想保留那些具有完整信息的观测值：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Divide and conquer with functions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数进行分而治之
- en: Functions are a fundamental building block of R. To master many of the more
    advanced techniques in this book, you need a solid foundation in how they work.
    We've already used a few functions above since you can't really do anything interesting
    in R without them. They are just what you remember from your mathematics classes,
    a way to transform inputs into outputs. Specifically in R, a function is an object
    that takes other objects as inputs, called arguments, and returns an output object.
    Most functions are in the following form `f(argument_1, argument_2, ...)`. Where
    f is the name of the function, and `argument_1`, `argument_2`, and so on are the
    arguments to the function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是R的基本构建块。要掌握本书中许多更高级的技术，你需要对它们的工作原理有一个坚实的基础。我们已经在上面使用了一些函数，因为你在R中不做这些事情就无法做任何有趣的事情。它们只是你从数学课上学到的，将输入转换为输出的方式。具体来说，在R中，一个函数是一个对象，它接受其他对象作为输入，称为参数，并返回一个输出对象。大多数函数具有以下形式`f(argument_1,
    argument_2, ...)`。其中f是函数的名称，而`argument_1`、`argument_2`等是函数的参数。
- en: 'Before we continue, we should briefly mention the role of curly braces ({})
    in R. Often they are used to group a set of operations in the body of a function,
    but they can also be used in other contexts (as we will see in the case of the
    web application we will build in [Chapter 10](part0271.html#82E8E0-f494c932c729429fb734ce52cafce730),
    *Adding Interactivity with Dashboards*). Curly braces are used to evaluate a series
    of expressions, which are separated by newlines or semicolons, and return only
    the last expression as a result. For example, the following line only prints the
    x + y operation to the screen, hiding the output of the x * y operation, which
    would have been printed had we typed the expressions step by step. In this sense,
    curly braces are used to encapsulate a set of behavior and only provide the result
    from the last expression:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该简要提及大括号({})在R中的作用。它们通常用于在函数体中分组一组操作，但它们也可以在其他上下文中使用（正如我们在[第10章](part0271.html#82E8E0-f494c932c729429fb734ce52cafce730)中将要构建的Web应用程序的例子中将会看到，*使用仪表板添加交互性*）。大括号用于评估一系列表达式，这些表达式由换行符或分号分隔，并仅返回最后一个表达式作为结果。例如，以下行仅将x
    + y操作打印到屏幕上，隐藏了x * y操作的输出，如果我们将表达式逐个输入，将会打印出来。从这个意义上讲，大括号用于封装一组行为，并且仅从最后一个表达式中提供结果：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can create our own function by using the `function() `constructor and assign
    it to a symbol. The `function()` constructor takes an arbitrary number of named
    arguments, which can be used within the body of the function. Unnamed arguments
    can also be passed using the "..." argument notation, but that's an advanced technique
    we won't look at in this book. Feel free to read the documentation for functions
    to learn more about them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`function()`构造函数并将其分配给一个符号来创建自己的函数。`function()`构造函数接受任意数量的命名参数，这些参数可以在函数体中使用。未命名的参数也可以使用"..."参数符号传递，但这是一种高级技术，我们在这本书中不会探讨。请随意阅读有关函数的文档以了解更多信息。
- en: When calling the function, arguments can be passed by position or by name. The
    positional order must correspond to the order provided in the function's signature
    (that is, the `function()` specification with the corresponding arguments), but
    when using named arguments, we can send them in whatever order we prefer. As the
    following example shows.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，参数可以通过位置或名称传递。位置顺序必须与函数签名中提供的顺序相对应（即带有相应参数的`function()`规范），但当我们使用命名参数时，我们可以按我们喜欢的任何顺序发送它们。以下示例将展示这一点。
- en: In the following example, we create a function that calculates the **Euclidian
    distance** ([https://en.wikipedia.org/wiki/Euclidean_distance](https://en.wikipedia.org/wiki/Euclidean_distance))
    between two numeric vectors, and we show how the order of the arguments can be
    changed if we use named arguments. To realize this effect, we use the `print()` function
    to make sure we can see in the console what R is receiving as the x and y vectors.
    When developing your own programs, using the `print() `function in similar ways
    is very useful to understand what's happening.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们创建了一个函数，用于计算两个数值向量之间的**欧几里得距离**([https://en.wikipedia.org/wiki/Euclidean_distance](https://en.wikipedia.org/wiki/Euclidean_distance))，并展示了如果我们使用命名参数，参数的顺序可以如何改变。为了实现这种效果，我们使用`print()`函数确保我们可以在控制台中看到R接收到的x和y向量。在你开发自己的程序时，以类似的方式使用`print()`函数非常有用，可以帮助你理解正在发生的事情。
- en: 'Instead of using the function name like `euclidian_distance`, we will use `l2_norm`  because
    it''s the generalized name for such an operation when working with spaces of arbitrary
    number dimensions and because it will make a follow-up example easier to understand.
    Note that even though outside the function call our vectors are called a and b,
    since they are passed into the x and y arguments, those are the names we need
    to use within our function. It''s easy for beginners to confuse these objects
    as being the same if we had used the x and y names in both places:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用像`euclidian_distance`这样的函数名，而是使用`l2_norm`，因为它是处理任意数量维度空间时此类操作的通用名称，并且它将使后续示例更容易理解。请注意，尽管在函数调用之外我们的向量被称为a和b，但由于它们被传递到x和y参数中，我们需要在函数中使用这些名称。如果我们在两个地方都使用了x和y名称，初学者很容易将这些对象混淆为相同的对象：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Functions may use the `return()` function to specify the value returned by the
    function. However, R will simply return the last evaluated expression as the result
    of a function, so you may see code that does not make use of the `return()` function
    explicitly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以使用`return()`函数来指定函数返回的值。然而，R会简单地返回最后一个评估的表达式作为函数的结果，因此你可能看到没有显式使用`return()`函数的代码。
- en: Our previous `l2_norm()` function implementation seems to be somewhat cluttered.
    If the function has a single expression, then we can avoid using the curly braces,
    which we can achieve by removing the `print()` function calls and avoid creating
    intermediate objects, and since we know that it's working fine, we can do so without
    hesitation. Furthermore, we avoid explicitly calling the `return()` function to
    simplify our code even more. If we do so, our function looks much closer to its
    mathematical definition and is easier to understand, isn't it?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的`l2_norm()`函数实现似乎有些杂乱。如果一个函数只有一个表达式，那么我们可以避免使用大括号，这可以通过移除`print()`函数调用和避免创建中间对象来实现，并且由于我们知道它运行良好，我们可以毫不犹豫地这样做。此外，我们避免显式调用`return()`函数，以进一步简化我们的代码。如果我们这样做，我们的函数看起来更接近其数学定义，也更易于理解，不是吗？
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Furthermore, in case you did not notice, since we use vectorized operations,
    we can send vectors of different lengths (dimensions), provided that both vectors
    share the same length, and the function will work just as we expect it to, without
    regard for the dimensionality of the space we''re working with. As I had mentioned
    earlier, vectorization can be quite powerful. In the following example, we show
    such behavior with vectors of dimension 1 (mathematically known as scalars), as
    well as vectors of dimension 5, created with the ":" shortcut syntax:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你没有注意到，由于我们使用了向量运算，我们可以发送不同长度的向量（维度），只要这两个向量具有相同的长度，函数将像我们预期的那样工作，而不考虑我们正在处理的空间维度。正如我之前提到的，向量运算可以非常强大。在以下示例中，我们使用维度为1的向量（在数学上称为标量）以及使用“:”快捷语法创建的维度为5的向量来展示这种行为：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Before we move on, I just want to mention that you should always make an effort
    to follow the Single Responsibility principle, which states that each object (functions
    in this case) should focus on doing a single thing, and do it very well. Whenever
    you describe a function you created as doing "*something*" and "*something else,*"
    you're probably doing it wrong since the "and" should let you know that the function
    is doing more than one thing, and you should split it into two or more functions
    that possibly call each other. To read more about good software engineering principles,
    take a look at Martin's great book title *Agile Software Development, Principles,
    Patterns, and Practices, Pearson, 2002*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想提到的是，你应该始终努力遵循单一职责原则，该原则指出每个对象（在这个例子中是函数）应该专注于做一件事情，并且做得很好。每次你描述你创建的函数时，如果它被描述为做“*某件事*”和“*另一件事,*”，你很可能是做错了，因为“和”应该让你知道该函数正在做不止一件事情，你应该将其拆分成两个或更多可能相互调用的函数。要了解更多关于良好的软件工程原则的信息，请参阅马丁的杰出著作《敏捷软件开发：原则、模式和实践，Pearson，2002》。
- en: Optional arguments
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选参数
- en: When creating functions, you may specify a default value for an argument, and
    if you do, then the argument is considered optional. If you do not specify a default
    value for an argument, and you do not specify a value when calling a function,
    you will get an error if the function attempts to use the argument.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数时，你可以为参数指定一个默认值，如果你这样做，那么这个参数就被认为是可选的。如果你没有为参数指定默认值，并且在调用函数时没有指定值，那么如果函数尝试使用该参数，你会得到一个错误。
- en: 'In the following example, we show that if a single numeric vector is passed
    to our `l2_norm()` function as it stands, it will throw an error, but if we redefine
    it to make the second vector optional, then we will simply return the first vector''s
    norm, not the distance between two different vectors To accomplish this, we will
    provide a zero-vector of length one, but because R repeats vector elements until
    all the vectors involved in an operation are of the same length, as we saw before
    in this chapter, it will automatically expand our zero-vector into the appropriate
    dimension:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们展示了如果将单个数值向量作为它目前的样子传递给我们的`l2_norm()`函数，它将引发一个错误，但如果我们重新定义它使其第二个向量成为可选的，那么我们只需简单地返回第一个向量的范数，而不是两个不同向量之间的距离。为了完成这个任务，我们将提供一个长度为1的零向量，但由于R会重复向量元素，直到所有参与操作的向量都具有相同的长度，正如我们在本章前面看到的，它将自动将我们的零向量扩展到适当的维度：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, now our function can optionally receive the `y` vector, but
    will also work as expected without it. Also, note that we introduced some comments
    into our code. Anything that comes after the `#` symbol in a line, R will ignore,
    which allows us to explain our code where need be. I prefer to avoid using comments
    because I tend to think that code should be expressive and communicate its intention
    without the need for comments, but they are actually useful every now and then.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在我们的函数可以可选地接收`y`向量，但如果没有它也会按预期工作。此外，请注意我们在代码中添加了一些注释。任何在行尾`#`符号之后的内容，R都会忽略，这允许我们在需要的地方解释我们的代码。我倾向于避免使用注释，因为我倾向于认为代码应该是表达性的，并且能够在不需要注释的情况下传达其意图，但它们实际上时不时地很有用。
- en: Functions as arguments
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为参数
- en: Sometimes when you want to generalize functions, you may want to plug in a certain
    functionality into a function. You can do that in various ways. For example, you
    may use conditionals, as we will see in the following section in this chapter,
    to provide them with different functionality based on context. However, conditional
    should be avoided when possible because they can introduce unnecessary complexity
    into our code. A better solution would be to pass a function as a parameter which
    will be called when appropriate, and if we want to change how a function behaves,
    we can change the function we're passing through for a specific task.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候当你想要泛化函数时，你可能想要将某种功能插入到一个函数中。你可以用各种方式做到这一点。例如，你可能会使用条件语句，正如我们在本章下一节中将要看到的，根据上下文为它们提供不同的功能。然而，当可能的时候应该避免使用条件语句，因为它们可能会在我们的代码中引入不必要的复杂性。一个更好的解决方案是将一个函数作为参数传递，当需要时会被调用，如果我们想要改变函数的行为，我们可以为特定任务更改传递的函数。
- en: That may sound complicated, but in reality, it's very simple. Let's start by
    creating a `l1_norm()` function that calculates the distance between two vectors
    but uses the sum of absolute differences among corresponding coordinates instead
    of the sum of squared differences as our `l2_norm()` function does. For more information,
    take a look at the *Taxicab geometry* article on Wikipedia ([https://en.wikipedia.org/wiki/Taxicab_geometry](https://en.wikipedia.org/wiki/Taxicab_geometry)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但实际上非常简单。让我们先创建一个`l1_norm()`函数，该函数计算两个向量之间的距离，但使用对应坐标的绝对差之和，而不是像我们的`l2_norm()`函数那样使用平方差之和。更多信息，请参阅维基百科上的*Taxicab
    geometry*文章（[https://en.wikipedia.org/wiki/Taxicab_geometry](https://en.wikipedia.org/wiki/Taxicab_geometry)）。
- en: 'Note that we use the same *signature* for our two functions, meaning that both
    receive the same required as well as optional arguments, which are `x` and `y`
    in this case. This is important because if we want to change the behavior by switching
    functions, we must make sure they are able to work with the same inputs, otherwise,
    we may get unexpected results or even errors:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为我们的两个函数使用了相同的*签名*，这意味着它们接收相同的必需以及可选参数，在这种情况下是`x`和`y`。这很重要，因为如果我们想通过切换函数来改变行为，我们必须确保它们能够处理相同的输入，否则我们可能会得到意外的结果或甚至错误：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that our `l2_norm()` and `l1_norm()` are built so that they can be switched
    among themselves to provide different behavior, we will create a third `distance()`
    function, which will take the two vectors as arguments, but will also receive
    a norm argument, which will contain the function we want to use to calculate the
    distance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了`l2_norm()`和`l1_norm()`函数，以便它们可以相互切换以提供不同的行为，我们将创建一个第三个`distance()`函数，该函数将接受两个向量作为参数，但也将接收一个范数参数，该参数将包含我们想要用来计算距离的函数。
- en: 'Note that we are specifying that we want to use the `l2_norm()` by default
    in case there''s no explicit selection when calling the function, and to do so
    we simply specify the symbol that contains the function object, without parenthesis.
    Finally note, that if we want to avoid sending the `y` vector, but we want to
    specify what norm should be used, then we must pass it through as a named argument,
    otherwise R would interpret the second argument as the `y` vector, not the norm
    function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们指定默认使用`l2_norm()`函数，以防在调用函数时没有进行明确选择，为此我们只需指定包含函数对象的符号，而不需要括号。最后请注意，如果我们想避免发送`y`向量，但想指定应使用哪种范数，那么我们必须通过命名参数传递它，否则R会将第二个参数解释为`y`向量，而不是范数函数：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Operators are functions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符是函数
- en: Now that you have a working understanding of how functions work. You should
    know that not all function calls look like the ones we have shown so far, where
    you use the name of the function followed by parentheses that contains the function's
    arguments. Actually, all statements in R, including setting variables and arithmetic
    operations, are functions in the background, even if we mostly call them with
    a different syntax.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对函数的工作原理有了实际的理解。你应该知道，并非所有函数调用都像我们之前展示的那样，即使用函数名后跟包含函数参数的括号。实际上，R中的所有语句，包括设置变量和算术运算，在后台都是函数，即使我们通常用不同的语法来调用它们。
- en: Remember that previously in this chapter we mentioned that R objects could be
    referred to by almost any string, but you should avoid doing so. Well here we
    show how using cryptic names can be useful under certain contexts. The following
    example shows how the assignment, selection, and addition operators are usually
    used with *sugar* syntax (a term used to describe syntax that exists for ease
    of use), but that in the background they use the functions named `[<-`, `[`, and
    `+`, respectively.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在本章之前我们提到R对象几乎可以用任何字符串来引用，但你应该避免这样做。在这里，我们展示了在特定情况下使用晦涩难懂的名字可能是有用的。以下示例展示了如何通常使用*糖语法*（一个用来描述为了方便使用而存在的语法的术语）来使用赋值、选择和加法运算符，但在后台它们使用的是名为`[<-`、`[`和`+`的函数。
- en: 'The `[<-()` function receives three arguments: the vector we want to modify,
    the position we want to modify in the vector, and the value we want it to have
    at that position. The `[()` function receives two arguments, the vector from which
    we want to retrieve a value and the position of the value we want to retrieve.
    Finally, the `+()` function receives the two values we want to add. The following
    example shows the syntax sugar, followed by the background function calls R performs
    for us:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`[<-()` 函数接收三个参数：我们想要修改的向量、在向量中想要修改的位置，以及我们想要在该位置拥有的值。`[()` 函数接收两个参数，即我们想要从中检索值的向量以及我们想要检索的值的位置。最后，`+()`
    函数接收我们想要相加的两个值。以下示例展示了语法糖，随后是 R 为我们执行的背景函数调用：'
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In practice, you would probably never write these statements as explicit function
    calls. The syntax sugar is much more intuitive and much easier to read. However,
    to use some of the advanced techniques shown in this book, it is helpful to know
    that every operation in R is a function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能永远不会将这些语句作为显式函数调用编写。语法糖更加直观，更容易阅读。然而，为了使用本书中展示的一些高级技术，了解 R 中的每个操作都是一个函数是有帮助的。
- en: Coercion
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制转换
- en: Finally, we will briefly mention what coercion is in R since it's a topic of
    confusion for newcomers. When you call a function with an argument of a different
    type than what was expected, R will try to coerce values so that the function
    will work, and this can introduce bugs if not handled correctly. R will follow
    a mechanism similar to what was used when creating vectors.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要介绍 R 中的强制转换是什么，因为它是新手的困惑主题。当你用一个与预期类型不同的参数调用函数时，R 将尝试强制转换值，以便函数可以工作，如果处理不当，这可能会引入错误。R
    将遵循与创建向量时使用的类似机制。
- en: Strongly typed languages (like Java) will raise exceptions when the object passed
    to a function is of the wrong type, and will try not to convert the object to
    a compatible type. However, as we mentioned earlier, R was designed to work out
    of the box with a lot of unforeseen contexts, so coercion was introduced.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型语言（如 Java）会在传递给函数的对象类型错误时引发异常，并尝试不将对象转换为兼容类型。然而，正如我们之前提到的，R 被设计为可以与许多未预见的上下文一起工作，因此引入了强制转换。
- en: 'In the following example, we show that if we call our `distance()` function
    and pass logical vectors instead of numeric ones, R will coerce the logical vectors
    into numeric vectors, using `TRUE` as 1 and `FALSE` as 0, and proceed with the
    calculations. To avoid this issue in your own programs, you should coerce data
    types explicitly with the `as.*()` functions we mentioned before:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们展示了如果我们调用我们的 `distance()` 函数并传递逻辑向量而不是数值向量，R 将将逻辑向量强制转换为数值向量，使用 `TRUE`
    作为 1 和 `FALSE` 作为 0，然后继续计算。为了避免在你的程序中出现此类问题，你应该使用我们之前提到的 `as.*()` 函数显式地转换数据类型：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Complex logic with control structures
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制结构的复杂逻辑
- en: The final topic we should cover is how to introduce complex logic by using control
    structures. When I write introduce complex logic, I don't mean to imply that it's
    complex to do so. Complex logic refers to code that has multiple possible paths
    of execution, but in reality, it's quite simple to implement it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该讨论的最后一个主题是使用控制结构引入复杂逻辑的方法。当我提到引入复杂逻辑时，并不意味着这样做很复杂。复杂逻辑指的是具有多个可能的执行路径的代码，但在现实中，实现它相当简单。
- en: Nearly every operation in R can be written as a function, and these functions
    can be passed through to other functions to create very complex behavior. However,
    it isn't always convenient to implement logic that way and using simple control
    structures may be a better option sometimes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎 R 中的每个操作都可以写成函数的形式，并且这些函数可以被传递给其他函数以创建非常复杂的行为。然而，以这种方式实现逻辑并不总是方便，有时使用简单的控制结构可能是一个更好的选择。
- en: The control structures we will look at are `if... else` conditionals, `for`
    loops, and `while` loops. There are also `switch` conditionals, which are very
    much like `if... else` conditionals, but we won't look at them since we won't
    use them in the examples contained in this book.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的控制结构是 `if... else` 条件语句、`for` 循环和 `while` 循环。还有 `switch` 条件语句，它们与 `if...
    else` 条件语句非常相似，但我们将不会查看它们，因为我们不会在本书的示例中使用它们。
- en: If… else conditionals
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: If… else 条件语句
- en: As their name states, if…else conditionals will check a condition, and if it
    is evaluated to be a `TRUE` value, one path of execution will be taken, but if
    the condition is evaluated to be a `FALSE` value, a different path of execution
    will be taken, and they are mutually exclusive.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，if...else 条件将检查一个条件，如果它评估为 `TRUE` 值，则将采取一条执行路径，但如果条件评估为 `FALSE` 值，则将采取不同的执行路径，并且它们是互斥的。
- en: 'To show how `if... else` conditions work, we will program the same `distance()`
    function we used before, but instead of passing it the third argument in the form
    of a function, we will pass it a string that will be checked to decide which function
    should be used. This way you can compare different ways of implementing the same
    functionality. If we pass the `l2` string to the norm argument, then the `l2_norm()`
    function will be used, but if any other string is passed through, the `l1_norm()`
    will be used. Note that we use the double equals operator (==) to check for equality.
    Don''t confuse this with a single equals, which means assignment:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `if... else` 条件的工作方式，我们将编写之前使用的相同的 `distance()` 函数，但不是以函数的形式传递第三个参数，而是传递一个字符串，该字符串将被检查以决定应该使用哪个函数。这样，你可以比较实现相同功能的不同方式。如果我们把
    `l2` 字符串传递给 norm 参数，那么将使用 `l2_norm()` 函数，但如果传递任何其他字符串，则将使用 `l1_norm()` 函数。注意，我们使用双等号运算符
    (==) 来检查相等性。不要将其与单等号混淆，它表示赋值：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As can be seen in the last line of the previous example, using conditionals
    in a non-rigorous manner can introduce potential bugs, as in this case we used
    the `l1_norm()` function, even when the norm argument in the last function call
    did not make any sense at all. To avoid such situations, we may introduce the
    more conditionals to exhaust all valid possibilities and throw an error, with
    the `stop()` function, if the `else` branch is executed, which would mean that
    no valid option was provided:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例的最后一行所示，以非严谨的方式使用条件可以引入潜在的错误，就像在这个例子中，我们使用了 `l1_norm()` 函数，即使最后一个函数调用中的
    norm 参数完全没有任何意义。为了避免这种情况，我们可能需要引入更多的条件来穷尽所有有效可能性，并在 `else` 分支执行时使用 `stop()` 函数抛出错误，这意味着没有提供有效的选项：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Sometimes, there's no need for the `else` part of the `if... else` condition.
    In that case, you can simply avoid putting it in, and R will execute the if branch
    if the condition is met and will ignore it if it's not.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，不需要 `if... else` 条件的 `else` 部分。在这种情况下，你可以简单地避免放入它，如果条件满足，R 将执行 if 分支，如果不满足，则忽略它。
- en: There are many different ways to generate the logical values that can be used
    within the `if()` check. For example, you could specify an optional argument with
    a `NULL` default value and check whether it was not sent in the function call
    by checking whether the corresponding variable still contains the `NULL` object
    at the time of the check, using the `is.null()` function. The actual condition
    would look something like `if(is.null(optional_argument))`. Other times you may
    get a logical vector, and if a single one of its values is `TRUE`, then you want
    to execute a piece of code, in that case you can use something like `if(any(logical_vector))` as
    the condition, or in case you require that all of the values in the logical vector
    are `TRUE` to execute a piece of code, then you can use something like `if(all(logical_vector))`.
    The same logic can be applied to the self-descriptive functions named `is.na()` and
    `is.nan()`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方式可以生成可以在 `if()` 检查中使用的逻辑值。例如，你可以指定一个具有 `NULL` 默认值的可选参数，并通过检查相应的变量在检查时是否仍然包含
    `NULL` 对象来检查它是否未在函数调用中发送，使用 `is.null()` 函数。实际的条件可能看起来像 `if(is.null(optional_argument))`。有时你可能得到一个逻辑向量，如果其中任何一个值是
    `TRUE`，那么你想要执行一段代码，在这种情况下，你可以使用类似 `if(any(logical_vector))` 作为条件，或者如果你需要逻辑向量中的所有值都是
    `TRUE` 才执行一段代码，那么你可以使用类似 `if(all(logical_vector))` 的方式。相同的逻辑可以应用于名为 `is.na()`
    和 `is.nan()` 的自描述函数。
- en: Another way to generate these logical values is using the comparison operators.
    These include less than (<), less than or equal to (<=), greater than (>), greater
    than or equal to (>=), exactly equal (which we have seen ,==), and not equal to
    (!=). All of these can be used to test numerics as well as characters, in which
    case alphanumerical order is used. Furthermore, logical values can be combined
    among themselves to provide more complex conditions. For example, the ! operator
    will negate a logical, meaning that if `!TRUE` is equal to `FALSE`, and `!FALSE`
    is equal to `TRUE`. Other examples of these types of operators are the OR operator
    where in case any of the logical values is `TRUE`, then the whole expression evaluates
    to `TRUE`, and the AND operator where all logical must be `TRUE` to evaluate to
    `TRUE`. Even though we don't show specific examples of the information mentioned
    in the last two paragraphs, you will see it used in the examples we will develop
    in the rest of the book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这些逻辑值的另一种方式是使用比较运算符。这些包括小于(<)，小于等于(<=)，大于(>)，大于等于(>=)，精确等于（我们之前见过的，==），以及不等于(!=)。所有这些都可以用来测试数字以及字符，在这种情况下使用字母数字顺序。此外，逻辑值可以相互组合以提供更复杂的条件。例如，!运算符将否定一个逻辑值，这意味着如果`!TRUE`等于`FALSE`，而`!FALSE`等于`TRUE`。这些类型运算符的其他例子包括OR运算符，其中如果任何逻辑值为`TRUE`，则整个表达式评估为`TRUE`，以及AND运算符，其中所有逻辑值都必须为`TRUE`才能评估为`TRUE`。尽管我们没有展示最后两段中提到的具体信息示例，但您将在本书其余部分开发的示例中看到它的使用。
- en: 'Finally, note that a vectorized form of the `if... else` conditional is available
    under the `ifelse()` function. In the following code we use the modulo operator
    in the conditional, which is the first argument to the function, to identify which
    values are even, in which case we use the `TRUE` branch which is the second argument
    to indicate that the integer is *even*, and which are not, in which case we use
    the `FALSE` branch which is the third argument to indicate that the integer is
    *odd*:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，`if... else`条件语句的向量形式可以在`ifelse()`函数下使用。在以下代码中，我们在条件中使用模运算符，这是函数的第一个参数，以识别哪些值是偶数，在这种情况下，我们使用`TRUE`分支（即第二个参数）来指示整数是*偶数*，哪些不是，在这种情况下，我们使用`FALSE`分支（即第三个参数）来指示整数是*奇数*：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For loops
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于`for`循环
- en: There are two important properties of `for` loops. First, results are not printed
    inside a loop unless you explicitly call the `print()` function. Second, the indexing
    variable used within a `for` loop will be changed, in order, after each iteration.
    Furthermore, to stop iterating you can use the keyword break, and to skip to the
    next iteration you can use the next command.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环有两个重要属性。首先，除非你明确调用`print()`函数，否则结果不会在循环内部打印。其次，在`for`循环中使用的索引变量将在每次迭代后按顺序更改。此外，要停止迭代，可以使用关键字`break`，要跳到下一个迭代，可以使用`next`命令。'
- en: 'For this first example, we create a vector of characters called `words`, and
    iterate through each of its elements in order using the for (word in words) syntax.
    Doing so will take the first element in `words`, assign it to `word`, and pass
    it through the expression defined in the block defined by the curly braces, which
    in this case print the word to the console, as well as the number of characters
    in the word. When the iteration is finished, word will be updated with the next
    word, and the loop will be repeated this way until all words have been used:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们创建了一个名为`words`的字符向量，并使用for (word in words)语法按顺序遍历其每个元素。这样做会将`words`中的第一个元素赋值给`word`，并通过花括号定义的块中的表达式传递它，在这种情况下是将单词打印到控制台，以及单词中的字符数。当迭代完成时，`word`将更新为下一个单词，循环以此方式重复，直到所有单词都被使用：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Interesting behavior can be achieved by using *nested for loops* which are
    `for` loops inside other `for` loops. In this case, the same logic applies, when
    we encounter a `for` loop we execute it until completion. It''s easier to see
    the result of such behavior than explaining it, so take a look at the behavior
    of the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用*嵌套循环*可以实现有趣的行为，这些是嵌套在其他`for`循环中的`for`循环。在这种情况下，当遇到`for`循环时，我们会执行它直到完成。与解释相比，看到这种行为的成果更容易，所以请看看以下代码的行为：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using such nested `for` loops is how people perform matrix-like operations when
    using languages that do not offer vectorized operations. Luckily, we can use the
    syntax shown in previous sections to perform those operations without having to
    use nested for-loops ourselves which can be tricky at times.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种嵌套的 `for` 循环是人们在使用不提供向量化操作的语言时执行类似矩阵操作的方式。幸运的是，我们可以使用之前章节中显示的语法来执行这些操作，而无需自己使用嵌套的
    for 循环，这在某些时候可能会很棘手。
- en: 'Now, we will see how to use the `sapply()` and `lapply()` functions to apply
    a function to each element of a vector. In this case, we will call use the `nchar()`
    function on each of the elements in the words vector we created before. The difference
    between the `sapply()` and the `lapply()` functions is that the first one returns
    a vector, while the second returns a list. Finally, note that explicitly using
    any of these functions is unnecessary, since, as we have seen before in this chapter,
    the `nchar()` function is already vectorized for us:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何使用 `sapply()` 和 `lapply()` 函数将一个函数应用于向量的每个元素。在这种情况下，我们将对之前创建的单词向量中的每个元素使用
    `nchar()` 函数。`sapply()` 和 `lapply()` 函数之间的区别在于，前者返回一个向量，而后者返回一个列表。最后，请注意，显式使用这些函数之一是不必要的，因为我们之前在本章中看到，`nchar()`
    函数已经为我们进行了向量化：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When you have a function that has not been vectorized, like our `distance()`
    function. You can still use it in a vectorized way by making use of the functions
    we just mentioned. In this case we will apply it to the x list which contains
    three different numeric vectors. We will use the `lapply()` function by passing
    it the list, followed by the function we want to apply to each of its elements
    (`distance()` in this case). Note that in case the function you are using receives
    other arguments apart from the one that will be taken from `x` and which will
    be passed as the first argument to such function, you can pass them through after
    the function name, like we do here with the `c(1, 1, 1)` and `l1_norm` arguments,
    which will be received by the `distance()` function as the `y` and `norm` arguments,
    and will remain fixed for all the elements of the `x` list:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个尚未向量化的函数，比如我们的 `distance()` 函数。你仍然可以通过使用我们刚才提到的函数以向量化的方式使用它。在这种情况下，我们将将其应用于包含三个不同数值向量的
    x 列表。我们将通过传递列表给 `lapply()` 函数，然后是我们要应用于其每个元素的函数（在这种情况下是 `distance()`）。请注意，如果你使用的函数除了从
    `x` 中获取的参数外还接收其他参数，你可以将它们在函数名称之后传递，就像我们在这里使用 `c(1, 1, 1)` 和 `l1_norm` 参数一样，这些参数将被
    `distance()` 函数作为 `y` 和 `norm` 参数接收，并且对于 `x` 列表的所有元素都是固定的：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While loops
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: Finally, we will take a look at the `while` loops which use a different way
    of looping than `for` loops. In the case of `for` loops, we know the number of
    elements in the object we use to iterate, so we know in advance the number of
    iterations that will be performed. However, there are times where we don't know
    this number before we start iterating, and instead, we will iterate based on some
    condition being true after each iteration. That's when `while` loops are useful.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨使用与 `for` 循环不同的方式循环的 `while` 循环。在 `for` 循环的情况下，我们知道我们用于迭代的对象中的元素数量，因此我们事先知道将要执行多少次迭代。然而，有时在我们开始迭代之前并不知道这个数字，而是基于每次迭代后某个条件为真来迭代。这就是
    `while` 循环有用的时候。
- en: The way `while` loops work is that we specify a condition, just as with `if…else`
    conditions, and if the condition is met, then we proceed to iterate. When the
    iteration is finished, we check the condition again, and if it continues to be
    true, then we iterate again, and so on. Note that in this case if we want to stop
    at some point, we must modify the elements used in the condition such that it
    evaluates to `FALSE` at some point. You can also use break and next inside the `while`
    loops.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环的工作方式是，我们指定一个条件，就像 `if…else` 条件一样，如果条件满足，我们就继续迭代。当迭代完成后，我们再次检查条件，如果它继续为真，我们就再次迭代，依此类推。请注意，在这种情况下，如果我们想在某个点停止，我们必须修改用于条件的元素，使得它在某个点评估为
    `FALSE`。你还可以在 `while` 循环中使用 break 和 next。'
- en: 'The following example shows how to print all integers starting at 1 and until
    10\. Note that if we start at 1 as we do, but instead of adding 1 after each iteration,
    we subtracted 1 or didn''t change `x` at all, then we would never stop iterating.
    That''s why you need to be very careful when using `while` loops since the number
    of iterations can be infinite:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何打印从1开始的整数，直到10。请注意，如果我们从1开始，就像我们这样做，但每次迭代后不是加1，而是减1或根本不改变`x`，那么我们永远不会停止迭代。这就是为什么在使用`while`循环时需要非常小心，因为迭代的次数可能是无限的：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In case you do want to execute an infinite loop, you may use the `while` loop
    with a `TRUE` value in the place of the conditional. If you do not include a `break`
    command, the code will effectively provide an infinite loop, and it will repeat
    itself until stopped with the *CTRL* + *C* keyboard command or any other stopping
    mechanism in the IDE you're using. However, in such cases, it's cleaner to use
    the repeat construct as is shown below. It may seem counter intuitive, but there
    are times when using infinite loops is useful. We will see one such case in [Chapter
    8](part0178.html#59O440-f494c932c729429fb734ce52cafce730), *Object-Oriented System
    to Track Cryptocurrencies*, but in such cases, you have an external mechanism
    used to stop the program based on a condition external to R.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想执行一个无限循环，你可以使用带有`TRUE`值的`while`循环来代替条件。如果你没有包含`break`命令，代码将实际上提供一个无限循环，并且会一直重复，直到使用*CTRL*
    + *C*键盘命令或你使用的IDE中的任何其他停止机制来停止。然而，在这种情况下，使用下面所示的方式使用`repeat`构造会更干净。这看起来可能有些反直觉，但有时使用无限循环是有用的。我们将在[第8章](part0178.html#59O440-f494c932c729429fb734ce52cafce730)，*面向对象系统追踪加密货币*中看到这样一个案例，但在这种情况下，你有一个外部机制，基于R之外的条件来停止程序。
- en: 'Executing the following example will crash your R session:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下示例将使你的R会话崩溃：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The examples in this book
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书中的示例
- en: To end this introductory chapter, I want to introduce you to the three examples
    we will develop throughout the rest of the book. The first one is the Brexit Votes
    example, in which we are going to use real Brexit votes data, and, with descriptive
    statistics and linear models, we will attempt to understand the population dynamics
    at play behind the results. If you're not familiar with Brexit, it is the popular
    term for the prospective withdrawal of the United Kingdom from the European Union
    after a referendum which took place on June 23, 2016 ([https://en.wikipedia.org/wiki/Brexit](https://en.wikipedia.org/wiki/Brexit)).
    This example will be developed through [Chapter 2](part0059.html#1O8H60-f494c932c729429fb734ce52cafce730),
    *Understanding Votes with Descriptive Statistics*, and [Chapter 3](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730),
    *Predicting Votes with Linear Models*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章的介绍，我想向你介绍我们将在本书的其余部分开发的三个示例。第一个是《英国脱欧投票》案例，我们将使用真实的英国脱欧投票数据，并通过描述性统计和线性模型，尝试理解结果背后的群体动态。如果你不熟悉英国脱欧，它是指2016年6月23日举行公投后，英国可能从欧盟撤出的流行术语（[https://en.wikipedia.org/wiki/Brexit](https://en.wikipedia.org/wiki/Brexit)）。本例将通过[第2章](part0059.html#1O8H60-f494c932c729429fb734ce52cafce730)，*使用描述性统计理解投票*和[第3章](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730)，*使用线性模型预测投票*来开发。
- en: The second one is The Food Factory example, in which you will learn how to simulate
    various kinds of data for a hypothetical company called The Food Factory, as well
    as integrate real data from other sources (customer reviews in this case) to complement
    our simulations. The data will be used to develop various kinds of visualizations,
    text analysis, and presentations that are updated automatically. This example
    will be developed through; [Chapter 4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730),
    *Simulating Sales Data and Working with Databases*; [Chapter 5](part0110.html#38STS0-f494c932c729429fb734ce52cafce730),
    *Communicating Sales with Visualizations; *[Chapter 6](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730),
    *Understanding Reviews with Text Analysis*; and Chapter 7, *Developing Automatic
    Presentations*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例是《食品工厂》案例，在这个案例中，你将学习如何为名为《食品工厂》的假设公司模拟各种类型的数据，以及如何整合来自其他来源的真实数据（在这种情况下是客户评价）来补充我们的模拟。这些数据将被用于开发各种自动更新的可视化、文本分析和演示。本例将通过以下章节开发：[第4章](part0091.html#2MP360-f494c932c729429fb734ce52cafce730)，*模拟销售数据和数据库操作*；[第5章](part0110.html#38STS0-f494c932c729429fb734ce52cafce730)，*通过可视化沟通销售；*[第6章](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730)，*通过文本分析理解评价*；以及第7章，*开发自动演示*。
- en: The third and final one is the *Cryptocurrencies Tracking System* example, in
    which we will develop an object-oriented system that will be used to retrieve
    real-time price data from cryptocurrency markets and the amount of cryptocurrencies
    assets we hold. We will then show how to compute a simple moving average efficiently
    using performance optimization techniques, and finally we will show how to build
    interactive web applications using only R. This example will be developed through
    [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730), *Object-Oriented
    System to Track Cryptocurrencies*; [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730),
    *Implementing an Efficient Simple Moving Average;* and [Chapter 10](part0271.html#82E8E0-f494c932c729429fb734ce52cafce730),
    *Adding Interactivity with Dashboards*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最后一个例子是 *加密货币跟踪系统*，在这个例子中，我们将开发一个面向对象的系统，用于从加密货币市场检索实时价格数据以及我们所持有的加密货币资产数量。然后我们将展示如何使用性能优化技术高效地计算简单移动平均，最后我们将展示如何仅使用
    R 构建交互式网络应用程序。这个例子将在[第 8 章](part0178.html#59O440-f494c932c729429fb734ce52cafce730)，*面向对象的加密货币跟踪系统*；[第
    9 章](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730)，*实现高效的简单移动平均；*以及[第
    10 章](part0271.html#82E8E0-f494c932c729429fb734ce52cafce730)，*使用仪表板添加交互性*中开发。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the book by mentioning its intended audience,
    as well as our intentions for it, which are to provide examples that you can use
    to understand how real-world R applications are built using a high-quality code,
    and the useful guidelines of what to do and not to do when building your own applications.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过提及目标受众以及我们的意图来介绍这本书，我们的意图是提供一些例子，您可以使用这些例子来理解如何使用高质量的代码构建实际的 R 应用程序，以及构建您自己的应用程序时应该做什么和不应该做什么的有用指南。
- en: We also introduced R's basic constructs and prepared the baseline we need to
    work through the examples developed in the rest of the book. Specifically, we
    looked at how to work with the console, how to create and use variables, how to
    work with R basic data types like numerics, characters, and logicals, as well
    as how to handle special values, and how to make basic use of data structures
    like vectors, factors, matrices, data frames, and lists. Finally, we showed how
    to create our own functions and how to provide multiple paths of execution with
    control structures.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了 R 的基本结构，并为我们通过本书其余部分开发的例子准备了基础。具体来说，我们探讨了如何与控制台交互，如何创建和使用变量，如何处理 R 的基本数据类型，如数值、字符和逻辑，以及如何处理特殊值，以及如何基本使用数据结构，如向量、因子、矩阵、数据框和列表。最后，我们展示了如何创建我们自己的函数以及如何使用控制结构提供多个执行路径。
- en: I hope this book is useful to you and that you enjoy reading it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书对您有用，并且您会喜欢阅读它。
