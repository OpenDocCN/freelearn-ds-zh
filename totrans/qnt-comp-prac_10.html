<html><head></head><body>
		<div><h1 id="_idParaDest-269"><em class="italic"><a id="_idTextAnchor271"/>Chapter 10</em>: Getting to Know Algorithms with Aqua</h1>
			<p>So, we have finally come to the part where we will slow down a bit on coding our own circuits and instead take a look at what is arguably the most interesting part of Qiskit®—Qiskit Aqua.  </p>
			<p>As we were building the various Grover implementations in the last chapter, we saw how that seemingly simple algorithm turned into an unwieldy beast of coding when you implemented it in Qiskit Terra. If you are building a hybrid classical/quantum program (where you just want to use the Grover search function), it would be vastly simpler if you could just import and run a Qiskit® implementation of it, or other quantum algorithms, and not have to code from scratch. </p>
			<p>So, with a fanfare and a drum roll, we now take an initial look at a couple of Qiskit Aqua algorithms (Grover and Shor) that you can use out of the box. </p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Running Grover's algorithm as an Aqua function</li>
				<li>Running Shor's algorithm as an Aqua function</li>
				<li>Exploring more Aqua algorithms</li>
			</ul>
			<p>When we are done here, you will have looked at how to incorporate Qiskit Aqua algorithms into your own code and will know where to find more algorithms to test with, and how to start exploring how the algorithms are actually built using Python inside Qiskit® code.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor272"/>Technical requirements</h1>
			<p>The quantum programs that we discuss in this chapter can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter10">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter10</a>.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor273"/>Running Grover's algorithm as an Aqua function </h1>
			<p>At the end of <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>, we promised that there was an easier way to include Grover's search<a id="_idIndexMarker796"/> algorithm in your quantum circuits. In this recipe, we will achieve the same results, but without having to build the<a id="_idIndexMarker797"/> circuit from scratch; Qiskit Aqua will set up the oracle, build the Grover circuit, and run it for us.</p>
			<p>Just like importing and calling Python classes and methods for various things, such as <code>from math import pi</code> to get access to a numerical representation of <img alt="" src="img/Formula_10_015.png"/>, you can do the same with Qiskit® components. Why reinvent the wheel and build your implementation of the Grover search algorithm when it is already included with Qiskit®?</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor274"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r1_grover_aqua.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r1_grover_aqua.py</a>.</p>
			<p>Before we jump in, let's take a look at the two forms of input that the Grover Aqua algorithm accepts to define the oracle: </p>
			<ul>
				<li><code>LogicalExpressionOracle</code> input type</li>
				<li><code>TruthTableOracle</code> input type</li>
			</ul>
			<h3>Logical strings</h3>
			<p>Here's an example of a logical expression oracle for the <img alt="" src="img/Formula_10_001.png"/> oracle that we used in the <em class="italic">The two-bit Grover</em> recipe in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>, with the least significant bit (LSB) to the<a id="_idIndexMarker798"/> left in the logic: </p>
			<pre>'~A &amp; B'</pre>
			<p>This literally translated into: NOT A and B, which then can be translated into our Dirac ket notation as first qubit (A) = 0 and second qubit (B) =1, or <img alt="" src="img/Formula_10_001.png"/>.</p>
			<h3>Bit strings</h3>
			<p>When you use truth-table oracle input, you<a id="_idIndexMarker799"/> create a bit-string that represents the expected output for the oracle. For the <img alt="" src="img/Formula_10_001.png"/> example, the bit string is as follows:</p>
			<pre>'0010' </pre>
			<p>We walked through this notation briefly for 1- and 2-qubit systems in the <em class="italic">A quick introduction to quantum gates</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>. Take a look at that if you need a refresher.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor275"/>How to do it...</h2>
			<p>To handle the creation and running of the Grover algorithm, we create four functions in the <code>ch10_r1_grover_aqua.py</code> script. Let's check out those first before we move on to test it:</p>
			<h3>The sample code</h3>
			<ol>
				<li>First, we import the <a id="_idIndexMarker800"/>classes and methods that we<a id="_idIndexMarker801"/> need, and set some global variables:<pre>from qiskit import Aer, IBMQ
from qiskit.aqua.algorithms import Grover
from qiskit.aqua.components.oracles import LogicalExpressionOracle, TruthTableOracle
from qiskit.tools.visualization import plot_histogram
from IPython.core.display import display
global oracle_method, oracle_type</pre></li>
				<li>The <code>log_length(oracle_input,oracle_method)</code> function takes as input the oracle input (log or bin) and the oracle method (logical expression or bit string) and returns the ideal number of iterations the Grover circuit needs to include. If the<a id="_idIndexMarker802"/> oracle input is a logical string, we first <a id="_idIndexMarker803"/>calculate the number of qubits by counting the number of letters in the string, excluding tilde (~), ampersand (&amp;), and space:<pre>def log_length(oracle_input,oracle_method):
    from math import sqrt, pow, pi, log
    if oracle_method=="log":
        filtered = [c.lower() for c in oracle_input if             c.isalpha()]
        result = len(filtered)
        num_iterations=int(pi/4*(sqrt(pow(2,result))))
    else:
        num_iterations = int(pi/4*(sqrt(pow(2,
            log(len(oracle_input),2)))))
    print("Iterations: ", num_iterations)
    return num_iterations</pre></li>
				<li>The <code>create_oracle(oracle_method)</code> function takes the oracle method as input and prompts for the oracle logical expression or bit string. From the input, it calls the <code>log_length(oracle_input,oracle_method)</code> function that calculates the required number of iterations based on the <img alt="" src="img/Formula_10_003.png"/>  formula.<p>This is how it looks in Python:</p><pre>def create_oracle(oracle_method):
    oracle_text={"log":"~A &amp; ~B &amp; C","bit":"00001000"}
    # set the input
    global num_iterations    
    print("Enter the oracle input string, such         as:"+oracle_text[oracle_method]+"\nor enter 'def'        for a default string.")
    oracle_input=input('\nOracle input:\n ')
    if oracle_input=="def":
        oracle_type=oracle_text[oracle_method]
    else:
        oracle_type = oracle_input
    num_iterations=log_length(oracle_type, oracle_method)
    return(oracle_type)</pre></li>
				<li>The <code>create_grover(oracle_type)</code> function takes the <code>oracle_type</code> string, for <a id="_idIndexMarker804"/>example, <code>~A&amp;B</code> as input, and <a id="_idIndexMarker805"/>uses the <code>Grover(LogicalExpressionOracle (oracle_type),num_iterations=num_iterations)</code> function to create the algorithm with the appropriate number of iterations. <p>In Python, it will look as follows:</p><pre>def create_grover(oracle_type, oracle_method):
    # Build the circuit
    if oracle_method=="log":
        algorithm = Grover(LogicalExpressionOracle(
            oracle_type),num_iterations=num_iterations)
        oracle_circuit = Grover(LogicalExpressionOracle(
            oracle_type)).construct_circuit()
    else:
        algorithm = Grover(TruthTableOracle(
            oracle_type),num_iterations=num_iterations)
        oracle_circuit = Grover(TruthTableOracle(
            oracle_type)).construct_circuit()
    display(oracle_circuit.draw(output="mpl"))
    display(algorithm)
    return(algorithm)</pre></li>
				<li>The <code>run_grover(algorithm,oracle_type)</code> function takes the algorithm that we just <a id="_idIndexMarker806"/>created as input and<a id="_idIndexMarker807"/> runs it first on a local Aer simulator, and then on the least busy IBM Quantum® backend with five qubits.<p>This is <a id="_idIndexMarker808"/>how we build <a id="_idIndexMarker809"/>that in Python:</p><pre>def run_grover(algorithm,oracle_type,oracle_method):
    # Run the algorithm on a simulator, printing the most     # frequently occurring result
    backend = Aer.get_backend('qasm_simulator')
    result = algorithm.run(backend)
    print("Oracle method:",oracle_method)
    print("Oracle for:", oracle_type)
    print("Aer Result:",result['top_measurement'])
    display(plot_histogram(result['measurement']))
    # Run the algorithm on an IBM Q backend, printing the     # most frequently occurring result
    print("Getting provider...")
    if not IBMQ.active_account():
        IBMQ.load_account()
    provider = IBMQ.get_provider()
    from qiskit.providers.ibmq import least_busy
    filtered_backend = least_busy(provider.backends(        n_qubits=5,, operational=True, simulator=False))
    result = algorithm.run(filtered_backend)
    print("Oracle method:",oracle_method)
    print("Oracle for:", oracle_type)
    print("IBMQ "+filtered_backend.name()+        " Result:",,result['top_measurement'])
    display(plot_histogram(result['measurement']))
    print(result)</pre></li>
				<li>The <code>main()</code> function prompts for<a id="_idIndexMarker810"/> the oracle method, then creates the oracle and runs the <a id="_idIndexMarker811"/>Grover algorithm:<pre>def main():
    oracle_method="log"
    while oracle_method!=0:
        print("Ch 11: Grover search with Aqua")
        print("------------------------------")    
        # set the oracle method: "Log" for logical         # expression or "Bit" for bit string. 
        oracle_method = input("Select oracle method (log             or bit):\n")
        type=create_oracle(oracle_method)
        algorithm=create_grover(type, oracle_method)        run_grover(algorithm,type, oracle_method)</pre></li>
			</ol>
			<h3>Running the code</h3>
			<p>To create and run an <a id="_idIndexMarker812"/>Aqua-generated Grover circuit using a logical expression as input, do the following:</p>
			<ol>
				<li value="1">In your Python environment, run <code>ch10_r1_grover_aqua.py</code>. </li>
				<li>When prompted, select the logical expression oracle method by entering <code>log</code>.<p>Feel free to test the same oracle with the bit string input by entering <code>bit</code>.</p></li>
				<li>Now enter a logical expression<a id="_idIndexMarker813"/> like in the previous example:<pre>~A &amp; B</pre><p>If you read out the logical expression, you get <code>NOT A AND B</code>, which corresponds to <img alt="" src="img/Formula_10_004.png"/>. Remember, A is the least significant bit, and in Qiskit® corresponds to the rightmost digit in the key notation.</p><p>For a bit string oracle, the input would be <code>0010</code>.</p></li>
				<li>The oracle input <a id="_idIndexMarker814"/>and optimal number of iterations are <a id="_idIndexMarker815"/>displayed, together with the Aqua-created oracle circuit:<div><img alt="Figure 10.1 – The Aqua-created oracle circuit for " src="img/Figure_10.1_B14436.jpg"/></div><p class="figure-caption">Figure 10.1 – The Aqua-created oracle circuit for <img alt="" src="img/Formula_10_001.png"/> </p></li>
				<li>The oracle is now run on a local Aer simulator, and the results are displayed as follows:<div><img alt="Figure 10.2 – Results of running the  oracle on your local Aer simulator&#13;&#10;" src="img/Figure_10.2_B14436.jpg"/></div><p class="figure-caption">Figure 10.2 – Results of running the <img alt="" src="img/Formula_10_001.png"/> oracle on your local Aer simulator</p></li>
				<li>The oracle is<a id="_idIndexMarker816"/> now run on the least busy IBM Quantum® backend and the results are displayed as follows:</li>
			</ol>
			<div><div><img alt="Figure 10.3 – Results of running the  oracle on an IBM Quantum® backend&#13;&#10;" src="img/Figure_10.3_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Results of running the <img alt="" src="img/Formula_10_007.png"/> oracle on an IBM Quantum® backend</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor276"/>How it works...</h2>
			<p>If you look over the <code>ch10_r1_grover_aqua.py</code> program, then you will find in the order of 100 lines<a id="_idIndexMarker817"/> of code. Most of this is not needed to run the Grover<a id="_idIndexMarker818"/> algorithm. Assuming that <a id="_idIndexMarker819"/>you get the logical expression or bit string oracle input from somewhere, you can run this in just four lines of code:</p>
			<pre>In [1]: from qiskit import Aer
In [2]: from qiskit.aqua.algorithms import Grover
In [3]: from qiskit.aqua.components.oracles import LogicalExpressionOracle
In [4]: Grover(LogicalExpressionOracle("~A&amp;B")).run(backend)["top_measurement"]
Out[5]: '10'</pre>
			<p>The first three lines of code import the required classes. This fourth line of code creates and runs the Grover circuit with a logical <a id="_idIndexMarker820"/>expression<a id="_idIndexMarker821"/> oracle as input – in this case, <code>~A&amp;B</code>, to code for <img alt="" src="img/Formula_10_008.png"/>, and pulls out<a id="_idIndexMarker822"/> the top measurement, the winner coded by the oracle. </p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor277"/>There's more…</h2>
			<p>Again, just like with your Terra-built circuits, things happen when you go from two qubits to three qubits. Let's take a look. To see what the final transpiled circuit (run on the IBM Quantum® backend) looks like, you can log in to IBM Quantum Experience® to see the fully detailed results of your run:</p>
			<ol>
				<li value="1">Go to the following URL, and then log in <a id="_idIndexMarker823"/>with your IBM Quantum Experience® account: <a href="https://quantum-computing.ibm.com/">https://quantum-computing.ibm.com/</a>.</li>
				<li>In the <strong class="bold">Welcome</strong> panel, scroll down to <strong class="bold">Latest results</strong>.</li>
				<li>Locate the job that you just ran and click it:<div><img alt="Figure 10.4 – The job results for the  oracle on an IBM Quantum® backend in IBM Quantum Experience®&#13;&#10;" src="img/Figure_10.4_B14436.jpg"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 10.4 – The job results for the <img alt="" src="img/Formula_10_001.png"/> oracle on an IBM Quantum® backend in IBM Quantum Experience®</p></li>
				<li>Compare the circuits.<p>By taking a look at your jobs here, you <a id="_idIndexMarker824"/>can compare the size of the circuits that you ran as a part of <em class="italic">Building Grover's search algorithm</em> recipe in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>, and your new Aqua-created circuit:</p><div><img alt="Figure 10.5 – 2-qubit Aqua Grover for  versus your Terra-built 2-qubit  Grover&#13;&#10;" src="img/Figure_10.5_B14436.jpg"/></div><p class="figure-caption">Figure 10.5 – 2-qubit Aqua Grover for <img alt="" src="img/Formula_10_001.png"/> versus your Terra-built 2-qubit <img alt="" src="img/Formula_10_001.png"/> Grover</p><p>For the 2-qubit circuit, the size is<a id="_idIndexMarker825"/> corresponding to what you saw with your Terra-built circuit. What you can see from the difference is that the Aqua-built circuit uses an <strong class="bold">ancillary</strong> qubit to handle the phase-shifting mechanism. This makes the circuit a<a id="_idIndexMarker826"/> little bit larger, with a depth of 15 for the Qiskit Aqua Grover versus 9 for the Qiskit Terra Grover. The size also grows to 24 from 15. </p></li>
				<li>Now, run a 3-qubit Qiskit Aqua-created Grover and take a look at the results.<p>Run the <code>ch10_r1_grover_aqua.py</code> program again, select the log oracle type, and use the following logical string to code for <img alt="" src="img/Formula_10_012.png"/> : <code>~A &amp; ~B &amp; C</code>.</p><p>The results of the Qiskit Aer-run Grover <a id="_idIndexMarker827"/>should look like the following:</p></li>
			</ol>
			<div><div><img alt="Figure 10.6 – Aer result for the Aqua-created  Grover&#13;&#10;" src="img/Figure_10.6_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – Aer result for the Aqua-created <img alt="" src="img/Formula_10_013.png"/> Grover</p>
			<p>And the result of the Grover run on an IBM Quantum® backend should look something like this:</p>
			<div><div><img alt="Figure 10.7 – IBM Quantum® result for the Aqua-created  Grover&#13;&#10;" src="img/Figure_10.7_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – IBM Quantum® result for the Aqua-created <img alt="" src="img/Formula_10_013.png"/> Grover</p>
			<p>Look at these results. They do not look like the 3-qubit results we got in <em class="italic">The three-qubit Grover</em> recipe in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>, but more like the messy 4+ qubit results we saw in the <em class="italic">Adding more qubits to the Grover search</em> recipe. As we<a id="_idIndexMarker828"/> discussed in that recipe, we have clearly exceeded the circuit depth for  a NISQ machine, getting more noise than the signal from our experiment.</p>
			<p>So, how was that for some fun? We have seen how Qiskit Aqua codes the same algorithm that we spent so much time putting together in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>. But Qiskit Aqua contains so much more.</p>
			<p>We have barely scratched the surface. If you have spent some time looking over quantum information history, you might have a few favorite algorithms picked out; one of these is likely Grover's algorithm, but the most famous one is probably Shor's algorithm, and that's <a id="_idIndexMarker829"/>what's next. Read on!</p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor278"/>Running Shor's algorithm as an Aqua function</h1>
			<p>Another one of the real luminaries <a id="_idIndexMarker830"/>of quantum computing algorithms is Peter Shor's algorithm dating back to 1984, in which he proved that with a sufficiently<a id="_idIndexMarker831"/> powerful quantum computer, you can prime factorize really large integers. This is important not only from an academic point of view but also because, for example, factorizing really large (thousands of digits) numbers into constituent prime numbers is the core behind today's RSA encryption that is used to secure online transactions, from banking and social media to the computers built into your car.</p>
			<p>At the point when these sufficiently large quantum computers enter the stage, crypto keys that would take weeks, months, years, and longer to break can theoretically be broken in a matter of minutes. </p>
			<p>To level-set our expectations here, running Shor's algorithm on today's NISQ machines is more of an academic interest. As you will notice, the Shor circuits tend to grow pretty large even for relatively small factorization exercises, and as you have seen in the previous chapters, as circuits grow, so do the errors. </p>
			<p>Through IBM Quantum Experience®, you have access to quantum computers up to 15 qubits in size and simulators up to 32. As you will see, the qubit count limits us regarding the size of the number to factorize.</p>
			<p>And a final issue to take into account is the sheer size of the simulation. The great theoretical advantage of using quantum computers is that they have the potential for exponential speedup for certain problems. On the flip side of this is the fact that simulating quantum computers gets exponentially harder for each added qubit.</p>
			<p>When we run Shor's algorithm for bigger numbers, and by bigger, here I mean once we pass 63 going upward, your local simulator will start complaining and it is time to switch to the IBM Quantum®<a id="_idIndexMarker832"/> simulator provided. </p>
			<p>Take a look at this<a id="_idIndexMarker833"/> table for some suggested numbers to test with:</p>
			<div><div><img alt="Table 10.1 – Prime factorization of numbers smaller than 40&#13;&#10;" src="img/Table_10.1_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Table 10.1 – Prime factorization of numbers smaller than 40</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">For more factorization fun, see <a href="https://www.mymathtables.com/numbers/one-hundred-factor-and-prime-factor-table.html">https://www.mymathtables.com/numbers/one-hundred-factor-and-prime-factor-table.html</a> and <a href="https://www.mathsisfun.com/prime-factorization.html">https://www.mathsisfun.com/prime-factorization.html</a>.</p>
			<p>The Qiskit Aqua Shor <a id="_idIndexMarker834"/>algorithm accepts odd numbers larger than <a id="_idIndexMarker835"/>1 as input, so the table only lists those. The numbers listed as primes themselves cannot be factorized, but the rest are fair game. Test a few of these. </p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor279"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r2_shor_aqua.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r2_shor_aqua.py</a>.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor280"/>How to do it…</h2>
			<p>To handle the creation and <a id="_idIndexMarker836"/>running of the Grover algorithm, we<a id="_idIndexMarker837"/> will build three functions in the <code>ch10_r2_shor_aqua.py</code> script. First, let's check the code and then run it.</p>
			<h3>The sample code</h3>
			<ol>
				<li value="1">First, we import the classes and methods that we need:<pre>from qiskit import Aer, IBMQ
from qiskit.aqua.algorithms import Shor
import time</pre></li>
				<li>The <code>display_shor(N)</code> function takes an integer as input and uses the <code>Shor()</code> method to construct and display the short circuit and the circuit data:<pre>def display_shor(N):
    print("Building Shor circuit...")
    shor_circuit = Shor(N=N).construct_circuit()
    print(shor_circuit)
    print("Circuit data\n\nDepth: ",shor_circuit.        depth(),"\nWidth: ",shor_circuit.width(),"\nSize:        ",shor_circuit.size())</pre></li>
				<li>The <code>run_shor(N)</code> function takes an integer as input, creates the Shor circuit, and runs it on a local simulator. The function then displays the results of the run:<pre>def run_shor(N):
    if N&lt;=64: #Arbitrarily set upper limit for local               #simulator    
        print("Getting local simulator backend...")
        backend = Aer.get_backend('qasm_simulator')
    else:
        print("Getting provider...")
        if not IBMQ.active_account():
            IBMQ.load_account()
        provider = IBMQ.get_provider()
        print("Getting IBM Q simulator backend...")
        backend = provider.get_backend(
            'ibmq_qasm_simulator')
    print("Running Shor's algorithm for",str(N),"on",        backend,"...")
    results=Shor(N=N).run(backend)
    print("\nResults:")
    if results['factors']==[]:
        print("No prime factors: ",str(N),"=",str(N))
    elif isinstance(results['factors'][0],int):
        print("Prime factors: ",str(N),"=",
            results['factors'][0],"^ 2")
    else:
        print("Prime factors: ",str(N),"=",
            results['factors'][0][0],"*",
            results['factors'][0][1])</pre></li>
				<li>The <code>main()</code> function <a id="_idIndexMarker838"/>process prompts and verifies <a id="_idIndexMarker839"/>an odd input larger than 1, and then runs the preceding functions. Start and stop times are used to measure the time it takes to construct the circuit and to run it: <pre>def main():
    number=1
    print("\nCh 11: Shor's algorithm with Aqua")     
    print("---------------------------------")   
    while number!=0:
        number=int(input("\nEnter an odd number N &gt;1 (0
            to exit):\n"))
        if number&gt;1 and number % 2&gt;0:
            type=input("Enter R to run the Shor
                algorithm, D to display the circuit.\n")
            start_time=time.time()
            if type.upper()=="D":
                display_shor(number)
            elif type.upper()=="R":
                run_shor(number)
            elif type.upper() in ["RD","DR"]:
                display_shor(number)
                run_shor(number)
            end_time=time.time()
            print("Elapsed time: ","%.2f" % (
                end_time-start_time), "s")
        else:
            print("The number must be odd 
                and larger than 1.")</pre></li>
			</ol>
			<h3>Running the code</h3>
			<ol>
				<li value="1">In your <a id="_idIndexMarker840"/>environment, run <code>ch10_r2_shor_aqua.py</code>.</li>
				<li>When prompted, enter N, an odd <a id="_idIndexMarker841"/>number larger than 1. <p>This is the number that we want to prime factorize. For starters, try the three following numbers: <strong class="bold">5</strong>, <strong class="bold">9</strong>, <strong class="bold">15</strong></p></li>
				<li>The algorithm returns one of three results:<p><strong class="bold">No prime factors</strong>: If the number that you entered is a prime number that cannot be factorized, for example:</p><div><img alt="Figure 10.8 – The result of Shor's algorithm with an input of 5&#13;&#10;" src="img/Figure_10.8_B14436.jpg"/></div><p class="figure-caption">Figure 10.8 – The result of Shor's algorithm with an input of 5</p><p><strong class="bold">Factorized square</strong>: If the number can be<a id="_idIndexMarker842"/> expressed as a factorization <a id="_idIndexMarker843"/>of a prime multiplied by itself:</p><div><img alt="Figure 10.9 – The result of Shor's algorithm with an input of 9&#13;&#10;" src="img/Figure_10.9_B14436.jpg"/></div><p class="figure-caption">Figure 10.9 – The result of Shor's algorithm with an input of 9</p><p><strong class="bold">Two prime factorization</strong>: If the number can be expressed as a factorization of two different prime numbers. This is the result that we are after:</p><div><img alt="Figure 10.10 – The result of Shor's algorithm with an input of 15&#13;&#10;" src="img/Figure_10.10_B14436.jpg"/></div><p class="figure-caption">Figure 10.10 – The result of Shor's algorithm with an input of 15</p></li>
				<li>Now try the algorithm with bigger numbers and watch how the elapsed time to build and execute the circuit increases.<p>You will notice that your<a id="_idIndexMarker844"/> local simulator finds it harder and <a id="_idIndexMarker845"/>harder to keep up as the numbers get bigger. On my workstation (Apple iMac, 16 GB RAM), I run out of memory to build the circuits beyond the number 63. The <code>run_shor(N)</code> function code has a built-in breakpoint where it switches over to the IBM Quantum® simulator backend at 64.</p><p>Feel free to move the local/IBM Quantum® breakpoint if you feel like testing the performance of your local machine. Remember that the IBM Quantum® simulator backend runs on an IBM POWER9™ server, with quite a bit of horsepower!</p></li>
			</ol>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor281"/>There's more…</h2>
			<p>Just like for the Grover algorithm that we discussed in the <em class="italic">Running Grover's algorithm as an Aqua function</em> recipe, you can run the Shor function with just a few lines of code:</p>
			<pre>In [1]: from qiskit import Aer
In [2]: from qiskit.aqua.algorithms import Shor
In [3]: backend = Aer.get_backend('qasm_simulator')
In [4]: results=Shor(N=15).run(backend)
In [5]: results['factors']</pre>
			<p>In this example, we run the Shor algorithm for the number <code>15</code>. Running this code sample should result in the following output:</p>
			<pre>Out[5] [[3, 5]]</pre>
			<p>What we have done so far is just run the Shor algorithm with one input parameter, <code>N</code> – the integer that you want to factorize. By default, if your run <code>Shor()</code>, with no input, it will default to 15, the smallest non-trivial integer that can be factorized. Verify this from the preceding table. </p>
			<p>The Shor function optionally takes<a id="_idIndexMarker846"/> another input parameter, <code>a</code>, a co-prime<a id="_idIndexMarker847"/> smaller than <code>N</code> and with a greatest common divisor of 1:</p>
			<pre>In [4]: results=Shor(N=15, a=2).run(backend)</pre>
			<p>By default, <code>a</code> is set to <code>2</code>, and for the smallish size integers that we are playing with here, it will likely make no difference, but feel free to experiment.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor282"/>See also</h2>
			<ul>
				<li>Scott Aaronson has a delightful blog entry on Shor's algorithm: <em class="italic">Shor. I'll do it</em>, at <a href="https://www.scottaaronson.com/blog/?p=208">https://www.scottaaronson.com/blog/?p=208</a>.</li>
				<li>For a nice, detailed overview of Shor's algorithm on Python and Qiskit®, see <em class="italic">Chapter 12</em>,<em class="italic"> Shor's Algorithm</em> in <em class="italic">Mastering Quantum Computing with IBM QX,</em> by Dr Christine Corbett Moran, Packt Publishing.</li>
				<li>And directly from the Qiskit® textbook, here is Shor's aglorithm broken down in Python and Qiskit®: <a href="https://qiskit.org/textbook/ch-algorithms/shor.html">https://qiskit.org/textbook/ch-algorithms/shor.html</a>.</li>
			</ul>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor283"/>Exploring more Aqua algorithms</h1>
			<p>We have now reached the <a id="_idIndexMarker848"/>end of our book, and with that, the end of our trip through Qiskit® together. On our trip, we have looked at some basic quantum programming and explored the IBM Quantum® backends – the actual quantum computers! We have run our programs on these and gotten quantum results back. </p>
			<p>We started poking at the real meat of quantum computing, the algorithms. This book, however, is not about algorithms; we have just scratched the surface with some very basic ideas of how quantum algorithms differ from their classical counterparts and how it might feel to write them. </p>
			<p>And after touching on how to write algorithms and the sometimes-counterintuitive approach to getting the answer compared to classical algorithms, we also looked into prefabricated algorithms that are included with Qiskit Aqua: Grover's algorithm and Shor's algorithm. I like to think of this part of Qiskit® as an appstore of quantum computing. </p>
			<p>This is where you go when you<a id="_idIndexMarker849"/> have a problem that might require a quantum computing solution, but you do not necessarily want to sit down and code the algorithm yourself. Just like most people do not write their own programs just to get a weather forecast; they just use a readily available weather app. </p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor284"/>Getting ready</h2>
			<p>Qiskit Aqua has more algorithms than just Grover's and Shor's. The IBM Quantum® team, and collaborators all around the world, are filling it out with implementations and pure algorithms that target promising fields for near future as well as preparing for slightly further off implementations as quantum computers grow in strength and capabilities. </p>
			<p>Firstly, the Qiskit Aqua components include a <a id="_idIndexMarker850"/>set of <code>qiskit.aqua.algorithms</code> package. </p>
			<p>Among these are the Grover and Shor algorithms that we have tested, but also other specific algorithms <a id="_idIndexMarker851"/>such as QSVM (Quantum Support Vector Machine), VQE (the Variational <a id="_idIndexMarker852"/>Quantum Eigensolver algorithm), and more. Explore this library to learn how to explore various algorithms on the backends that are available today, and to understand how to expand them for use on the universal quantum computers of the future:</p>
			<ul>
				<li><code>qiskit.chemistry</code>) lets you experiment with energy calculations on molecules using your favorite modeling tool. </li>
				<li><code>qiskit.finance</code>), which includes a set of functions that are structured in the form of Ising Hamiltonians applied to financial models.</li>
				<li><code>qiskit.ml</code>), which contains sample sets. You can use these Aqua classifiers and SVM algorithms.</li>
				<li><code>qiskit.optimization</code>). This module contains several submodules with specific algorithms, applications, problems, and more.</li>
			</ul>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor285"/>How to do it…</h2>
			<p>We won't go any deeper into these specific Qiskit Aqua modules, but to start exploring the  algorithms, you can follow this path example:</p>
			<ol>
				<li value="1">Import the package that you are interested in, for example, if you want to explore chemistry, this one:<pre>import qiskit
from qiskit.chemistry import *</pre></li>
				<li>Then take a look at the built-in docs. <p>Qiskit® provides excellent Python help where you can start your exploration; for example: </p><pre><code>help(qiskit.chemistry)</code></pre></li>
				<li>Explore the general Qiskit® resources to further explore the field that you are interested in. <p>For example, the Qiskit® tutorials here: <a href="https://qiskit.org/documentation/tutorials/chemistry/index.html">https://qiskit.org/documentation/tutorials/chemistry/index.html</a>.</p><p>And in the <em class="italic">Learn Quantum Computation Using Qiskit</em> textbook, for example: <a href="https://qiskit.org/textbook/ch-applications/vqe-molecules.html">https://qiskit.org/textbook/ch-applications/vqe-molecules.html</a>.</p></li>
				<li>And finally, experiment! <p>Pick up on the various algorithms and integrate them into your own hybrid classical/quantum Python code to suit your purposes, much like we have done throughout the various recipes in this book.</p></li>
			</ol>
			<p>There are many Qiskit® features <a id="_idIndexMarker854"/>that we have not touched yet, such as mixing in Boolean logic with your circuits, programming qubits directly with <strong class="bold">OpenPulse</strong>, more advanced <a id="_idIndexMarker855"/>error simulation, and much more. All of these features, and many more, are available for your exploration. If you do not want to go it alone, take a look around and see whether you can find some quantum computing meetups or workshops in your neighborhood. </p>
			<p>The Qiskit Slack<a id="_idIndexMarker856"/> channel at <a href="http://qiskit.slack.com">qiskit.slack.com</a> is an excellent starting point for your quantum social exploration. Sign up from the Support page on IBM Quantum Experience®: <a href="https://quantum-computing.ibm.com/support">https://quantum-computing.ibm.com/support</a>.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor286"/>There's more</h2>
			<p>The Qiskit Aqua algorithms didn't spring out of thin air; someone wrote them and added them to the collection. Qiskit® is<a id="_idIndexMarker857"/> open source and is built by an ever-growing collection of open source contributors. How about you? </p>
			<p>Even if you are not planning to become a Qiskit® contributor, do go ahead and explore the source code. If you installed Qiskit® locally, you have the source right at your fingertips. If you installed it with the suggested Anaconda, your Qiskit® source might be in a location similar to this (example from macOS):</p>
			<pre>/Users/&lt;your_user_name&gt;/opt/anaconda3/envs/&lt;your_environment&gt;/lib/python3.7/site-packages/qiskit/</pre>
			<p>Look around in the functions and classes that build the features and functions that we have used throughout the book. Who knows, perhaps you can come up with a better way to present qubit states, or come up with a brand-new algorithm, and then contribute that method back to <a id="_idIndexMarker858"/>Qiskit®.</p>
			<p>Information about how to contribute to <a id="_idIndexMarker859"/>Qiskit® is available here: <a href="https://qiskit.org/documentation/contributing_to_qiskit.html">https://qiskit.org/documentation/contributing_to_qiskit.html</a>.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor287"/>See also</h2>
			<p>Today's algorithm development is largely theoretical as we can successfully run them on the available but currently limited NISQ machines and on quantum simulators, but we do not have access to backends with hundreds or thousands of qubits. Remember that simulators size up exponentially with the number of qubits; running simulators at those circuit sizes proves immensely challenging. </p>
			<p>This might change in the not unforeseeable future, at least if IBM Quantum® gets its way. In early September 2020, IBM Quantum's Jay Gambetta presented IBM's roadmap at the yearly IBM Quantum Summit. It is a bold plan, reaching 1,121 physical qubits by late 2023. With this amount of physical qubits, it will be possible to start exploring in earnest error-corrected qubits as per the <em class="italic">Exploring your qubits to understand T1, T2, errors, and gates</em> recipe in <a href="B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220"><em class="italic">Chapter 8</em></a>, <em class="italic">Cleaning Up Your Quantum Act with Ignis</em>. So watch this space.</p>
			<p>Here's the roadmap document: <em class="italic">IBM's Roadmap For Scaling Quantum Technology</em>, September 15, 2020, Jay Gambetta: <a href="https://www.ibm.com/blogs/research/2020/09/ibm-quantum-roadmap/">https://www.ibm.com/blogs/research/2020/09/ibm-quantum-roadmap/</a>.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor288"/>Thank you!</h2>
			<p>So, dear reader, you have followed me this far, or at least you have flipped to the last page of the last chapter to see how the story ends... Spoiler alert: It's a cliffhanger! </p>
			<p>Quantum computing is still very much in its infancy, and the recipe building that you have taken part in in this book, while putting you on track for further exploration, are not enough to confidently establish your career as a quantum computing programmer; this takes time and effort. </p>
			<p>Just like a basic course in C programming might lead you onto the path of making your fortune building the next social media phenomenon, this basic dipping-your-toes-in-the-water that you have now been exposed to might do the same. With what you now have, go ahead, take the plunge, become a Qiskit Advocate, check with your college or university for courses and programs to chart out your career path as a quantum computing developer or researcher, or why not just start the next big quantum start-up in your garage? </p>
			<p>Have fun! </p>
		</div>
	</body></html>