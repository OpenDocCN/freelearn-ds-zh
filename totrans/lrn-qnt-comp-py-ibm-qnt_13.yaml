- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Understanding Quantum Utility and Qiskit Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解量子实用工具和Qiskit模式
- en: Here we are, the final chapter. If you’ve made it this far, then congratulations
    on keeping yourself focused and determined, your time was well invested! As we
    close out this chapter, and the book, I want to also make sure I don’t just leave
    you here with some basics and wish you the best. I’ve found most technical books
    seem to do that. Not that there is anything wrong with that, but I always felt
    like most don’t provide help regarding next steps or, better yet, any next best
    action. I thought I would include this chapter as a shift from education to enablement.
    In other words, where to go from here and *how*. With Qiskit 1.0 (and future updates),
    we should approach this as a transition to really getting a head start towards
    enabling you with the proper tools and patterns to evolve your current experiments
    towards ideal utility application candidates. The goal here is that this book
    will not only provide you with the education to get started, but will also provide
    you with some guidance to know what to expect and develop as the technology grows
    and new features are released.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里，这是最后一章。如果你已经走到这一步，那么恭喜你保持专注和决心，你的时间投资得很值得！当我们结束这一章，以及这本书时，我想确保我不仅仅留给你一些基础知识，并祝愿你一切顺利。我发现大多数技术书籍似乎都是这样做的。这并不是说有什么不对，但我总觉得大多数书籍没有提供关于下一步或更好的行动指南。我想将这一章作为一个从教育到赋能的转变。换句话说，从这里去哪里以及如何去做。随着Qiskit
    1.0（以及未来的更新），我们应该将其视为真正让你提前一步，获得适当的工具和模式，以将你的当前实验演变为理想的实用应用候选者的过渡。这里的目的是，这本书不仅会为你提供开始学习的教育，还会为你提供一些指导，让你知道随着技术的发展和新功能的发布，你可以期待什么并如何发展。
- en: Up to now, we have covered a *bottom-up approach* to understand quantum computing,
    where we started with the foundational quantum computational properties, gates,
    and circuits. We then moved up towards combining those to implement various quantum
    algorithms. We also covered how to use the various simulators, generate noise
    models, and mitigate readout errors. All of this helps in understanding the fundamental
    intricacies of quantum computing and how they are used to create algorithms that
    are both effective and optimal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了一种“自下而上”的方法来理解量子计算，我们从基本的量子计算属性、门和电路开始。然后我们向上移动，将它们结合起来以实现各种量子算法。我们还介绍了如何使用各种模拟器、生成噪声模型以及减轻读出错误。所有这些都帮助我们理解量子计算的基本复杂性以及它们是如何被用来创建既有效又最优的算法的。
- en: However, it is a lot to ask of a developer, solution architect, or systems integrator
    to learn all the inner workings just to understand how to integrate quantum computing
    into their application or workflow. In fact, it is often difficult to find those
    who want to wander down into the *nuts and bolts* of the quantum algorithm. Generally,
    most of us would like to just load our data into an algorithm, execute it on a
    quantum system, obtain the results, and just continue with our experiments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要求一个开发者、解决方案架构师或系统集成人员学习所有内部运作机制，只是为了理解如何将量子计算集成到他们的应用程序或工作流程中，这实在要求太高了。实际上，往往很难找到那些想要深入了解量子算法的“螺丝钉”的人。一般来说，我们大多数人只想把数据加载到算法中，在量子系统上执行它，获取结果，然后继续我们的实验。
- en: This *top-down approach* is where Qiskit Patterns comes into the picture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“自上而下”的方法正是Qiskit模式出现的地方。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Quantum Utility
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解量子实用工具
- en: Understanding Qiskit Patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Qiskit模式
- en: In this chapter, you will learn what quantum utility means and why it is key
    to getting us closer towards quantum advantage.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解量子实用工具的含义以及为什么它是我们接近量子优势的关键。
- en: We’ll also cover Qiskit Patterns and how it can simplify your development experience
    to build complex quantum circuits. As most quantum algorithms and applications
    become more complex over time, particularly now as we are entering the era of
    quantum utility, we need to understand what they are and how we can best use these
    building blocks to create scalable and efficient quantum algorithms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍Qiskit模式以及它如何简化你构建复杂量子电路的开发体验。随着大多数量子算法和应用随着时间的推移变得越来越复杂，尤其是我们现在正进入量子实用时代，我们需要了解它们是什么以及我们如何最好地使用这些构建块来创建可扩展和高效的量子算法。
- en: Finally, we’ll wrap up this chapter with a quick example using Qiskit Patterns
    using Grover’s algorithm, which we learned about in the previous chapter, as I
    do not want to finish this chapter without providing you with some code that combines
    classical and quantum together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过一个快速示例结束本章，该示例使用Qiskit模式结合了我们在上一章中学到的Grover算法，因为我不想在没有提供一些结合经典和量子代码的情况下结束本章。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, it is expected that you have an understanding of creating
    quantum circuits and general application development using Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们期望你了解使用Python创建量子电路和通用应用开发。
- en: 'The following is the source code we’ll be using throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在整本书中使用的源代码：[https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition)。
- en: Understanding quantum utility
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解量子效用
- en: Earlier, I mentioned the term **quantum utility**. I figured I would take the
    time to describe in a bit more detail what that means and, more importantly, what
    it doesn’t mean. First and foremost, let’s start by defining another term, **quantum
    advantage**. Quantum advantage is a term that describes when a quantum computer
    can solve a practical use case in science or business that is intractable to classical
    systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到了“量子效用”这个术语。我想花点时间更详细地描述一下这意味着什么，更重要的是，它不意味着什么。首先，让我们定义另一个术语，“量子优势”。量子优势是一个术语，描述了量子计算机能够解决科学或商业中的实际用例，而这些用例对于经典系统来说是难以处理的。
- en: One example of this could be Shor’s algorithm, which finds the prime factors
    of an integer. This is currently difficult for classical systems to solve due
    to the complexity of the task, which is why it is used to encrypt much of our
    digital content, such as passwords. In the example of Shor’s algorithm, where
    it is estimated to take millions of years to solve the problem using classical
    computers, some say it could take a few hours on a fault-tolerant system. Quantum
    advantage, at the time of writing, of course is a few years away, so it is good
    that you are taking the time now to learn about this new technology so when these
    systems reach quantum advantage, you’ll have a head start on solving interesting
    problems. It’s also important to note that quantum advantage will not happen all
    at once; it will be incremental and will vary based on the type of problem and
    cost compared to running on a classical system. As technology advances beyond
    quantum advantage, so will the solutions to classically intractable problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种例子之一可能是Shor算法，它用于寻找整数的质因数。由于任务的复杂性，目前经典系统难以解决这个问题，这就是为什么它被用来加密我们的大部分数字内容，例如密码。在Shor算法的例子中，有人估计使用经典计算机解决该问题可能需要数百万年，而有些人说在容错系统上可能只需要几个小时。当然，在撰写本文时，量子优势还有几年才能实现，所以你现在花时间学习这项新技术是明智的，这样当这些系统达到量子优势时，你将能够领先一步解决有趣的问题。还重要的是要注意，量子优势不会一蹴而就；它将是渐进的，并且将根据问题的类型和与经典系统运行的成本相比而变化。随着技术超越量子优势，解决经典上难以解决的问题的解决方案也将随之发展。
- en: Now that we have an idea of what quantum advantage is, let’s look at what quantum
    utility means. Back in June of 2023, researchers from IBM and UC Berkeley published
    a paper titled *Evidence for the utility of quantum computing before fault tolerance*
    ([https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)).
    In this paper, the authors were able to show that quantum computers can solve
    problems at a scale beyond brute force classical simulation. Again, this isn’t
    to say that this is quantum advantage, mostly because there are some quantum-inspired
    classical methods that provided classical approximations using other techniques
    beyond brute force. The paper used a 127-qubit quantum computer that had almost
    3,000 CX gates, which is quite a complex circuit to simulate using brute-force
    methods. There of course have been a few quantum-inspired classically based papers
    that were released that managed to reproduce the solution; however, not all the
    results from each experiment aligned for certain parameters. As a result, accuracy
    had begun to struggle, some ranging approximately 20% from each other. Furthermore,
    there have been many other papers that were published afterwards that are over
    100-qubits and contain thousands of CX gates. This highlights the fact that we
    are moving from where we first started, with small-scale circuits, which could
    very easily be simulated classically, to over 100-qubit circuits with thousands
    of CX gates. As the size of the circuits, both width (number of qubits) and depth
    (number of CX gates) grows, so does the cost of simulating the circuit classically.
    Cost here can refer to loss of accuracy or speed. This era, which is a time before
    we hit quantum advantage, is what is referred to as **Quantum Utility**. Furthermore,
    using the error mitigation techniques discussed earlier in this book, allows running
    these complex circuits on 100+ qubit systems. The era of utility means we can
    find useful quantum applications to run without having to wait for fault-tolerant
    quantum computers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对量子优势有了概念，让我们来看看量子效用意味着什么。回到2023年6月，IBM和加州大学伯克利分校的研究人员发表了一篇题为《在容错之前量子计算的效用证据》的论文（[https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)）。在这篇论文中，作者能够展示量子计算机可以解决超出蛮力经典模拟规模的难题。再次强调，这并不是说这就是量子优势，主要是因为还有一些受量子启发的经典方法，它们使用除蛮力之外的其他技术提供了经典近似。这篇论文使用了一个拥有近3000个CX门的127量子比特量子计算机，这是一个相当复杂的电路，使用蛮力方法进行模拟。当然，之后也发布了一些受量子启发的基于经典方法的论文，它们设法重现了解决方案；然而，并非每个实验的所有结果在特定参数上都一致。因此，准确性开始受到影响，一些结果彼此之间大约相差20%。此外，之后还发表了超过100量子比特且包含数千个CX门的许多其他论文。这突出了这样一个事实，即我们正在从最初的小规模电路，这些电路很容易用经典方法模拟，发展到超过100量子比特且包含数千个CX门的电路。随着电路规模的增长，无论是宽度（量子比特数量）还是深度（CX门数量），用经典方法模拟电路的成本也在增加。这里的成本可以指精度损失或速度。这个时代，在我们达到量子优势之前的时间，被称为**量子效用**。此外，使用本书前面讨论的错误缓解技术，可以在100+量子比特系统上运行这些复杂电路。效用时代意味着我们可以找到有用的量子应用来运行，而无需等待容错量子计算机。
- en: Now that we’re familiar with what quantum utility is, let’s look at what we
    as developers should understand to take advantage of this latest move forward
    in quantum technology to build these more complex quantum circuits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了量子效用是什么，让我们来看看作为开发者我们应该理解什么，以便利用量子技术这一最新进展来构建更复杂的量子电路。
- en: Understanding Qiskit Patterns
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Qiskit模式
- en: Another announcement at the 2023 IBM Quantum Summit was the introduction to
    Qiskit Patterns. Qiskit Patterns originated from the idea that as circuits get
    larger and more complex, computational scientists should not be concerned about
    what is happening at the hardware level. There is no need for a computational
    scientist to understand which gate to use on a specific qubit, or which is the
    ideal optimizer to use when transpiling the circuit to the hardware. Computational
    scientists should have tools that can be used to provide them with the latest
    hardware and software and simplify the usage of these 100+ qubit systems. These
    tools should provide a way for scientists to generate code or functions that will
    solve a specific problem or set of problems, and not create circuits qubit by
    qubit, gate by gate. Therefore, the purpose of the Qiskit Patterns is to provide
    the computational scientist with a way to inject a quantum computational routine
    into their existing applications and workflows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 2023年IBM量子峰会上的另一个公告是介绍了Qiskit模式。Qiskit模式源于这样一个想法：随着电路变得更大、更复杂，计算科学家不应关心硬件层面发生的事情。计算科学家不需要了解在特定量子比特上使用哪个门，或者当将电路转换为硬件时使用哪个优化器是理想的。计算科学家应该有可以使用的工具，这些工具可以为他们提供最新的硬件和软件，并简化这些100多量子比特系统的使用。这些工具应该为科学家提供一种生成代码或函数的方法，以解决特定问题或一系列问题，而不是一个量子比特一个量子比特、一个门一个门地创建电路。因此，Qiskit模式的目的就是为计算科学家提供一种将量子计算例程注入他们现有应用程序和工作流程的方法。
- en: Now that we know the purpose of Qiskit Patterns, let’s look at what they are
    and how to use them. Prior to stepping into the details, I do want to stress that
    this is a new feature that is always being enhanced. There may be many changes
    to the code and its usage. What I am writing here is what is current at the time
    of writing. As we know, with all coding languages there are always updates or
    changes, so I urge you to review the documentation first so you are up to speed
    on the latest development. Even if there are changes in code, the concept of the
    overall steps should still be the same.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了Qiskit模式的目的，让我们来看看它们是什么以及如何使用它们。在深入细节之前，我确实想强调这是一个一直在改进的新功能。代码及其使用可能会有很多变化。我这里写的是写作时的当前状态。正如我们所知，所有编程语言都会有更新或变化，所以我敦促您首先查看文档，以便了解最新的发展。即使代码有变化，整体步骤的概念仍然应该是相同的。
- en: 'Simply put, Qiskit Patterns are made up of 4 steps that are used to run algorithms
    on a quantum computer and provide you with a result to use as part of your application
    and/or workflow. The four steps are: **map**, **optimize**, **execute**, and **post-process**.
    We’ll learn what each of these steps does and run an example using a simple circuit.
    Of course, you can use any circuit that you wish.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Qiskit模式由4个步骤组成，用于在量子计算机上运行算法，并提供给您作为应用程序和/或工作流程一部分的结果。这四个步骤是：**映射**、**优化**、**执行**和**后处理**。我们将学习每个步骤的作用，并使用一个简单的电路运行一个示例。当然，您可以使用任何您想要的电路。
- en: Step 1, Map
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步，映射
- en: In this step, we want to map the problem to a quantum circuit. This entails
    encoding the problem and inputs into a quantum circuit or state. A simple example
    we can use is to encode a binary image. This is an image where each pixel is either
    black or white, 0 or 1, respectively. It is simple enough to read each pixel and
    if the pixel is black, we leave the state as 0 and if it is white, we add an X
    gate to change it to the 1 state. Of course, this means that we would need the
    same number of qubits as we do pixels, so this is not easy to scale to larger
    images that have millions of pixels.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们希望将问题映射到一个量子电路中。这涉及到将问题和输入编码到量子电路或状态中。我们可以使用的简单例子是编码一个二进制图像。这是一种每个像素要么是黑色要么是白色，分别对应0或1的图像。读取每个像素很简单，如果像素是黑色，我们就保持状态为0；如果是白色，我们添加一个X门将其改变为1状态。当然，这意味着我们需要与像素数量相同的量子比特，所以这并不容易扩展到拥有数百万像素的大图像。
- en: So, we would need to find ways to encode these images so that they would not
    need millions of qubits. This is where encoding comes in handy. If we can find
    a way to encode pixels into a quantum state, then this will work nicely. There
    are of course many ways to encode images, too many to list here, but by searching
    quantum image processing, you should find many forms. A few of the earliest forms
    are **NEQR**, which stands for **Novel Enhanced Quantum Representation** for digital
    images, and **FRQI**, which is short for **Flexible Representation of Quantum
    Images**. The mapping using FRQI maps the intensity value of the pixel, let’s
    say a 256-bit grayscale image, to a single qubit (i.e., pi/256 would represent
    the pixel value). In NEQR, you would map the values using 8 qubits, where each
    qubit is set as a binary value, so the qubit intensity is not represented by 1
    qubit (as in FRQI), but 8 qubits (8 qubits that map to the 8 binary values needed
    to represent the numbers from 0 to 256). These are just two, but there are so
    many more, each of which has its own advantages and disadvantages. What this means
    is that a lot of the work for you, as a computational scientist, is about selecting
    the encoding, or mapping, that you believe is best for your experiment. This mapping
    should ensure that your problem is not just encoded into a quantum state, but
    encoded in a way where it provides an optimal way to represent the problem you
    wish to solve. Once you have selected the proper mapping of your problem and input,
    a circuit is generated. We are now ready to move onto the next step in the Qiskit
    Pattern, optimization.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要找到方法来编码这些图像，这样它们就不需要数百万个量子比特。这就是编码派上用场的地方。如果我们能找到一种方法将像素编码成量子状态，那么这将非常有效。当然，编码图像的方法也有很多，多得无法在此一一列举，但通过搜索量子图像处理，你应该能找到许多形式。其中一些最早的形式是**NEQR**，代表**数字图像的新型增强量子表示**，以及**FRQI**，代表**量子图像的灵活表示**。使用FRQI的映射将像素的强度值映射到单个量子比特上，比如说一个256位的灰度图像，即π/256代表像素值。在NEQR中，你会使用8个量子比特来映射值，其中每个量子比特被设置为二进制值，因此量子比特的强度不是由1个量子比特（如在FRQI中）表示，而是由8个量子比特（8个量子比特映射到表示从0到256所需的8个二进制值）表示。这些只是其中两种，但还有很多更多，每种都有其自身的优缺点。这意味着，作为计算科学家，你大量的工作就是选择你认为最适合你实验的编码或映射。这种映射应确保你的问题不仅被编码到量子状态中，而且是以一种提供最佳方式来表示你希望解决的问题的方式编码的。一旦你选择了问题的适当映射和输入，就会生成一个电路。我们现在可以进入Qiskit模式中的下一步，即优化。
- en: Step 2, Optimize your circuit
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步，优化你的电路
- en: As we’ve covered in previous chapters, optimizing a circuit is not just one
    step of mapping the circuit to the quantum hardware; there are many different
    aspects to it. Thankfully, most of this is done automatically for us, but it also
    provides us with ways to alter them, either by setting `optimization_level` option
    values to specify the type of optimization to perform, but the recently added
    `resilience_level` option values, which allow us to also select the type of error
    suppression and error mitigation to apply to our circuit. As most of these require
    some classical resources, this provides us with a way to set how much of those
    classical resources to use. The result of the transpilation and optimization is
    called **Quantum Instruction Set Architecture** (**QISA**). This optimized circuit
    is specific to the quantum hardware we select to execute this circuit on, which
    leads us to the next step, execute.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中提到的，优化电路不仅仅是将电路映射到量子硬件上的一个步骤；它有很多不同的方面。幸运的是，其中大部分都是自动为我们完成的，但它也为我们提供了改变它们的方法，无论是通过设置`optimization_level`选项值来指定要执行优化类型，还是通过最近添加的`resilience_level`选项值，这允许我们选择要应用到电路上的错误抑制和错误缓解类型。由于这些大多数都需要一些经典资源，这为我们提供了设置使用多少这些经典资源的方法。编译和优化的结果是称为**量子指令集架构**（**QISA**）。这个优化电路是针对我们选择的执行此电路的量子硬件的，这使我们进入下一步，即执行。
- en: Step 3, Execute your circuit
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步，执行你的电路
- en: One thing to note is that when we say execute a circuit, this is not to say
    we will execute this circuit on a quantum system, particularly when running a
    variational quantum algorithm that requires some classical interactions during
    execution. This is why primitives like the Estimator and Sampler are great building
    blocks as they provide the necessary context needed to execute these circuits
    to allow classical and quantum interactions during execution time. Executing a
    circuit can use one of many modes, such as Sessions, Jobs, and Batch.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，当我们说执行一个电路时，这并不意味着我们将在量子系统上执行这个电路，尤其是在运行需要执行过程中进行一些经典交互的变分量子算法时。这就是为什么像估计器和采样器这样的原语是很好的构建块，因为它们提供了执行这些电路所需的必要上下文，以便在执行时间允许经典和量子交互。执行一个电路可以使用多种模式之一，例如会话、作业和批量。
- en: We discussed these in *Chapter 10*, *Suppressing and Mitigating Quantum Noise*,
    where we covered how circuits are run on a quantum system. Now that we have executed
    our circuit on a quantum system, we now have reached the final step in the Qiskit
    Pattern, post-processing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第10章*中讨论了这些问题，*抑制和缓解量子噪声*，其中我们介绍了电路如何在量子系统上运行。现在我们已经在一个量子系统上执行了我们的电路，我们现在已经达到了Qiskit模式中的最后一步，即后处理。
- en: Step 4, Post-process
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步，后处理
- en: This is just a matter of obtaining the results we received from executing our
    circuit and processing them into what our classical application or workflow expects.
    Up to now, we’ve been displaying our results as either graphs or as text so we
    can view them and understand what the results mean. But when integrating with
    an application or workflow, the results might need to either be formatted in a
    certain way or aggregated with other results from various other systems as a collection.
    In either case, the post-processing step is just a matter of handling the results
    and passing them back to the calling system in a way that will facilitate its
    integration into the application itself in a very robust way. This of course would
    be dependent on how the results would be used in the next step or displayed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是获取我们从执行电路中获得的结果并将它们处理成我们的经典应用程序或工作流程所期望的格式的问题。到目前为止，我们一直将结果显示为图表或文本，以便我们可以查看并理解这些结果的意义。但是，当与应用程序或工作流程集成时，结果可能需要以某种方式格式化或与其他系统中的各种结果汇总为一个集合。在两种情况下，后处理步骤只是处理结果并以一种便于将其集成到应用程序本身的方式将其传递回调用系统的问题。这当然取决于结果在下一步或显示中的使用方式。
- en: In essence, those are the 4 steps, straightforward and quite simple. But then
    again, that is the point! Ideally, you, as a developer, computational scientist,
    or quantum enthusiast, should not have to struggle with how to create, execute,
    and obtain results from a quantum system. The process should be very straightforward
    and simple. Speaking of simplifying the process, another announcement during the
    Summit was that there will soon be AI included, which would be able to auto-generate
    quantum code as well. It has not been announced when this, and other AI features,
    will go live but the code will soon include this. This should help those who are
    new and just getting started as it could serve as a tool to ask how to create
    certain circuits, i.e. Grovers, Simon’s, etc. and of course should also help those
    experienced researchers who would like to scale their existing circuits into these
    larger complex circuits, which could advance their solutions towards a path to
    quantum advantage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这4个步骤简单直接，相当简单。但话又说回来，这正是重点！理想情况下，作为开发者、计算科学家或量子爱好者，你不应该需要为如何创建、执行和从量子系统中获取结果而挣扎。这个过程应该是非常直接和简单的。说到简化过程，在峰会期间还有另一个宣布，那就是很快将包含人工智能，它能够自动生成量子代码。尚未宣布何时以及其他人工智能功能将上线，但代码很快将包含这一功能。这应该有助于那些刚开始的新手，因为它可以作为工具询问如何创建某些电路，例如格罗弗、西蒙等，当然也应该帮助那些希望将现有电路扩展到这些更大、更复杂的电路中的经验丰富的研究人员，这可能会将他们的解决方案推向量子优势的道路。
- en: Now, that all being said, I will not let you down! I did leave a little programming
    for you here so to not have a chapter without any coding. We will implement something
    that we built in the previous chapter, a simple logical expression to determine
    the optimal result using Grover’s algorithm. This is a simple example where we
    will start with a logical expression, which we can say is the classical data coming
    in. Then we will proceed to use the Sampler primitive so we can run it locally,
    define the problem, and use the Grover algorithm class to solve the problem. This
    time, we will use the methods to input the problem and provide us with the optimal
    result, which we will then print out and display visually, hence completing the
    hybrid classical-quantum application. Here we go!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，话虽如此，我不会让您失望！我确实在这里留了一些编程内容，以免在没有代码的章节中结束。我们将实现上一章中构建的内容，使用Grover算法确定最佳结果的简单逻辑表达式。这是一个简单的例子，我们将从一个逻辑表达式开始，我们可以将其称为经典数据输入。然后我们将继续使用Sampler原语，以便我们可以在本地运行它，定义问题，并使用Grover算法类来解决问题。这次，我们将使用方法输入问题并提供最佳结果，然后我们将打印出来并直观地显示，从而完成混合经典-量子应用。让我们开始吧！
- en: Implementing the logical expression oracle
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现逻辑表达式预言机
- en: Logical expressions are commonly used to describe problems, particularly those
    that have some constraints. These logical expressions can be used to construct
    a circuit and execute it on various algorithms. Let’s begin with a simple problem.
    Note that the names have been changed to protect the identities of bands who have
    trouble staying together.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式通常用于描述问题，尤其是那些有某些约束条件的问题。这些逻辑表达式可以用来构建电路并在各种算法上执行。让我们从一个简单的问题开始。请注意，名字已经更改以保护那些难以保持团结的乐队的隐私。
- en: 'Melba, a music producer, has been tasked to put together the next big rock
    band, based on the musicians who currently have a contract for a record company.
    The following musicians are available:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 梅尔巴，一位音乐制作人，被委以组建下一个大型摇滚乐队，基于目前与唱片公司有合约的音乐家。以下音乐家可供选择：
- en: '**Ivana** is a singer who has a great voice and is available to tour as soon
    as possible.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伊万娜**是一位嗓音出色的歌手，可以尽快进行巡演。'
- en: '**Karla** is also a singer with a great voice and is also available to tour
    right away.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卡拉**也是一位嗓音出色的歌手，也可以立即进行巡演。'
- en: '**Lex** is a guitar player that can play any genre and has his own tour bus.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**莱克斯**是一位可以演奏任何风格的吉他手，有自己的巡演巴士。'
- en: '**Leo** is a drummer that gets along with everyone and is very liked in the
    industry.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利奥**是一位与每个人都相处得很好的鼓手，在业界非常受欢迎。'
- en: 'Now, here is the problem you have been asked to solve by the music producer:
    Ivana and Karla tend to not get along on tour and have been known to have creative
    differences when writing music. Lex and Leo, on the other hand, get along fine
    together both in the studio and on tour. However, Ivana and Lex recently broke
    up after the last time they toured together so we can have one of the following
    options: only Ivana or Leo can participate, or neither and simply replace them
    both.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这就是音乐制作人要求您解决的问题：伊万娜和卡拉在巡演中往往相处不来，并且在创作音乐时也出现过创意分歧。另一方面，莱克斯和利奥在录音室和巡演中相处得很好。然而，伊万娜和莱克斯在最近一次巡演后分手了，因此我们可以有以下几种选择：只有伊万娜或利奥可以参加，或者两者都不参加，简单地用他们替换。
- en: What you need to do is determine which combination of these four musicians is
    best for you to put together as a band, and then have them tour with minimal issues
    based on their history together.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的是确定这四位音乐家中哪一组合最适合您组建乐队，然后根据他们共同的历史，尽量减少问题地进行巡演。
- en: 'To solve this, let’s write this out as a logical expression:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们将其写成逻辑表达式：
- en: 'We’ll map each musician to a variable such as: `A = Ivana`, `B = Karla`, `C
    = Lex`, and `D = Leo`.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每位音乐家映射到一个变量，例如：`A = 伊万娜`，`B = 卡拉`，`C = 莱克斯`，和 `D = 利奥`。
- en: 'Next, we’ll create a logical expression using logical operators to illustrate
    the constraints. To start, we know that Ivana and Karla do not get along, so this
    we can represent as follows, where ^ indicates XOR. This means we need at least
    one of them to participate, but not both at the same time: ![](img/B18420_13_001.png).'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用逻辑运算符创建一个逻辑表达式来展示约束条件。首先，我们知道伊万娜和卡拉相处不来，因此我们可以用以下方式表示，其中^表示异或。这意味着我们需要至少其中一人参与，但不能同时两人都参与：![](img/B18420_13_001.png)。
- en: 'Next, we know that Lex and Leo get along fine together, so we can represent
    them with an AND operator as follows: ![](img/B18420_13_002.png).'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们知道Lex和Leo相处得很好，因此我们可以用AND运算符来表示它们，如下所示：![](img/B18420_13_002.png).
- en: 'Finally, we know that Ivana and Lex have just ended their relationship, so
    they might not be open to working and touring together. We will represent them
    as a NAND as follows. This indicates that they cannot work together, but it will
    allow for both not to participate at all: ![](img/B18420_13_003.png).'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们知道Ivana和Lex刚刚结束了他们的关系，所以他们可能不会愿意一起工作和巡演。我们将它们表示为NAND，如下所示。这表明他们不能一起工作，但它将允许他们都不参加：![](img/B18420_13_003.png).
- en: 'By putting these all together, our complete logical expression for this example
    is as follows: ![](img/B18420_13_004.png).'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些放在一起，我们这个例子中完整的逻辑表达式如下所示：![](img/B18420_13_004.png).
- en: Now that we have defined our logical expression, let’s create an oracle on the
    logical expression so that we can use **Grover’s algorithm** to search for the
    optimal result.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的逻辑表达式，让我们在逻辑表达式中创建一个oracle，这样我们就可以使用**Grover算法**来搜索最佳结果。
- en: 'We’ll begin by importing all the necessary modules and classes needed for the
    rest of these steps and defining our logical expression:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先导入执行这些步骤所需的所有必要模块和类，并定义我们的逻辑表达式：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have defined our problem as a logical expression, let’s use this
    logical expression to create our `oracle`, which as you recall is what we use
    to describe the problem we wish to solve. In this case, it represents the logical
    expression. Note that in the code I included a cell that would install a dependency
    for using PhaseOracle (`pip install tweedledum`), as you will likely also have
    to install Qiskit algorithms (`pip install qiskit-algorithms`). I’ve commented
    the line out to install just in case you already have it installed; however, if
    you get an error when executing a cell that requires the dependency, simply install
    onto your development environment using the command-line instruction, and restart
    the kernel. This will then complete the installation and you can then run the
    code without the dependency error:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将问题定义为逻辑表达式，让我们使用这个逻辑表达式来创建我们的`oracle`，如您所回忆的那样，这是我们用来描述我们希望解决的问题的工具。在这种情况下，它代表逻辑表达式。请注意，在代码中我包含了一个用于安装PhaseOracle依赖项的单元格（`pip
    install tweedledum`），因为你可能也需要安装Qiskit算法（`pip install qiskit-algorithms`）。我已经将该行注释掉，以防你已安装；然而，如果你在执行需要依赖项的单元格时遇到错误，只需使用命令行指令在你的开发环境中安装，然后重新启动内核。这样就可以完成安装，然后你可以运行代码而不会出现依赖项错误：
- en: '[PRE1]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have created an `oracle` from the logical expression, we can create
    the problem by calling the `AmplificationProblem()` method and passing the expression
    we wish to solve as its argument:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经从逻辑表达式中创建了一个`oracle`，我们可以通过调用`AmplificationProblem()`方法并传递我们希望解决的表达式作为其参数来创建问题：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code calls the oracle from the Grover operator which contains
    the quantum circuit representation of the oracle which is illustrated as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从Grover运算符中调用oracle，其中包含oracle的量子电路表示，如下所示：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_13_01.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述由低置信度自动生成](img/B18420_13_01.png)'
- en: 'Figure 13.1: Quantum circuit representing the logical expression oracle'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：表示逻辑表达式oracle的量子电路
- en: 'We can see that this oracle describes the logical expression, where q[0], q[1],
    q[2], and q[3] represent our logical expression, where q[0] = Ivana, q[1] = Karla,
    q[2] = Lex, and q[3] = Leo. Observe that the control in q[0] is not filled in.
    This is to indicate that it is triggered when the state value of q[0] is ![](img/B18420_13_005.png),
    as opposed to the others, which are triggered when the qubit is in the ![](img/B18420_13_006.png)
    state. We can now use this oracle on any oracle-based (oracular) algorithm. Since
    we are searching for the solution to this rock band problem, let’s use Grover’s
    algorithm. First, we will set up a session and use the Sampler primitive for this
    example, and then create the Grover’s algorithm class using the sampler as the
    primitive. We’ll then pass the problem we defined in the previous cell into the
    `amplify` method, which will in essence run Grover’s algorithm, provide us with
    the result, and display it:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，这个预言者描述了逻辑表达式，其中q[0]、q[1]、q[2]和q[3]代表我们的逻辑表达式，其中q[0] = Ivana，q[1] = Karla，q[2]
    = Lex，和q[3] = Leo。注意，q[0]中的控制位没有填写。这是为了表示它在q[0]的状态值为![img/B18420_13_005.png]时被触发，而与其他不同，它们是在量子位处于![img/B18420_13_006.png]状态时被触发的。我们现在可以使用这个预言者来执行任何基于预言者（预言性）算法。由于我们正在寻找这个摇滚乐队问题的解决方案，让我们使用Grover算法。首先，我们将设置一个会话并使用Sampler原语来演示这个例子，然后使用采样器作为原语创建Grover算法类。然后，我们将之前单元格中定义的问题传递给`amplify`方法，这个方法本质上会运行Grover算法，提供结果，并显示它：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code results in the following output, which represents the value
    we are searching for: `1110`. Keep in mind that the qubit at position 0 is represented
    by the least significant bit (far right). This means that the result, `1110`,
    is equal to D=1, C=1, B=1, A=0:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出，它代表了我们要寻找的值：`1110`。请注意，位置0的量子位表示为最低有效位（最右边）。这意味着结果`1110`等于D=1，C=1，B=1，A=0：
- en: 'We also obtain the following quasi-distribution:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还获得了以下准分布：
- en: '![Table  Description automatically generated](img/B18420_13_02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成](img/B18420_13_02.png)'
- en: 'Figure 13.2: Grover solution results based on the logical expression oracle'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：基于逻辑表达式预言者的Grover解决方案结果
- en: As shown by the preceding results, the algorithm indicates our solution is **1110**.
    This states that Karla, Leo, and Lex are the three ideal musicians to recruit
    into the next band project. Melba has then decided to recruit Ivana as a solo
    career singer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的结果所示，该算法表明我们的解决方案是**1110**。这意味着Karla、Leo和Lex是下一个乐队项目的三位理想音乐家。Melba已经决定招募Ivana作为独唱歌手。
- en: This, of course, is a simple example. As you can imagine, if your expression
    is more complex, then the Grovers search would help determine that in just a few
    lines of code. As you can see, you can take a problem that’s defined by a logical
    expression on a classical system and then, by leveraging the Qiskit Runtime and
    Grover’s algorithm class, prepare the problem in a variety of ways, all of which
    can be executed on a quantum system. All of this can be done without having to
    delve into the lower layers of the quantum algorithm, i.e., quantum gates, operators,
    error mitigation, etc.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个简单的例子。正如您所想象的，如果您的表达式更复杂，那么Grovers搜索将有助于在几行代码中确定这一点。正如您所看到的，您可以将由经典系统上的逻辑表达式定义的问题，通过利用Qiskit运行时和Grover算法类，以各种方式准备该问题，所有这些都可以在量子系统上执行。所有这些都可以在不深入研究量子算法底层（即量子门、算子、错误缓解等）的情况下完成。
- en: As Qiskit continues to add many more features, algorithms, utilities, and other
    artifacts, this will help you create flexible yet modular quantum applications
    that suit all your needs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Qiskit继续添加更多功能、算法、实用工具和其他工件，这将帮助您创建灵活且模块化的量子应用程序，满足您的所有需求。
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered Qiskit Patterns, which are focused on helping you
    quickly develop robust quantum circuits to include into your applications and
    workflows. With the release of Qiskit 1.0 and future changes, I also highly recommend
    you keep up with the latest changes. Qiskit 1.0 has a nice roadmap filled with
    updates to primitives, patterns, and many features that not only help you get
    up to speed with the development process but also ensure that your circuits can
    scale up to larger utility sized circuits.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Qiskit模式，这些模式专注于帮助您快速开发健壮的量子电路，以便将其包含到您的应用程序和工作流程中。随着Qiskit 1.0的发布和未来的变化，我也强烈建议您跟上最新的变化。Qiskit
    1.0有一个很好的路线图，其中包含对原语、模式和许多功能的更新，这些更新不仅可以帮助您跟上开发过程，还可以确保您的电路可以扩展到更大的实用电路规模。
- en: Now that you have the general skills to understand how to start creating quantum
    applications and using Qiskit Patterns in a way that simplifies the creation process,
    you can start applying these features into your existing circuits, or in new circuits
    if you are just starting out.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了理解如何开始创建量子应用程序和使用Qiskit模式简化创建过程的一般技能，你可以开始将这些功能应用到现有的电路中，或者如果你是初学者，可以应用到新的电路中。
- en: Finally, we looked at a problem that we needed to solve using Grover’s quantum
    algorithm, without having to really understand how they are constructed, meaning
    we did not have to create a quantum circuit, an oracle, or diffusion operators
    to run the algorithm. The focus was on how to represent the problem, in this case
    as a logical expression, and apply it via a combination of available classes and
    methods of the algorithm to present the problem and solve it. Just keep in mind
    that as we are moving towards quantum utility, there will be more efficient and
    modern ways to implement this and future algorithms. As mentioned throughout this
    book, these are just the principles and general programming practices to help
    get you started, but as quantum computing evolves, so to will the algorithms and
    the way we think about how to program. It’s with this that you should take away
    from this book, it’s a place to start for you to take the code and keep on pushing
    towards the outer bounds of your ingenuity and imagination. But for now…
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们查看了一个需要使用Grover量子算法解决的问题，而不必真正理解它们是如何构建的，这意味着我们不必创建量子电路、预言机或扩散算子来运行该算法。重点是表示问题，在这种情况下是一个逻辑表达式，并通过算法提供的可用类和方法组合来应用它，以呈现问题并解决问题。只需记住，随着我们朝着量子实用性的方向发展，将会有更高效和现代的方法来实现这一点以及未来的算法。正如本书中提到的，这些只是帮助你入门的原则和一般编程实践，但随着量子计算的发展，算法以及我们思考编程的方式也将随之发展。这就是你应该从本书中吸取的，这是一个起点，让你可以继续推动你的独创性和想象力。但就目前而言…
- en: Congratulations! You’ve taken a very large step towards getting yourself started
    with learning and building quantum applications. Initially, we followed a bottoms-up
    approach, which is to start by creating and running quantum circuits on both a
    locally installed simulator and on a quantum computer. Doing this helped you understand
    the inner workings of how a quantum circuit is built and executed on a quantum
    system. Next, you reviewed the various algorithms and quantum computing principles
    that differentiate between classical and quantum applications. By running these
    applications, you also visualized the results and of course the effects caused
    by various environmental effects, which in turn helped you learn about the various
    features that mitigate the noisy effects of the quantum computer. And finally,
    you looked at a top-down approach offered by the Qiskit Runtime to help you quickly
    see how some of these algorithms in various domains are used to solve small problems.
    The hope here is that this book has provided you with a simple gateway to simplify
    your journey into the quantum computing world and, as always, I look forward to
    reading your research papers or perhaps your own textbook!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经迈出了非常关键的一步，开始学习和构建量子应用程序。最初，我们遵循自下而上的方法，即首先在本地安装的模拟器和量子计算机上创建和运行量子电路。这样做帮助你理解量子电路在量子系统上构建和执行的内幕。接下来，你回顾了区分经典和量子应用程序的各种算法和量子计算原理。通过运行这些应用程序，你还可视化了结果，当然还有各种环境效应引起的影响，这反过来又帮助你了解减轻量子计算机噪声效应的各种功能。最后，你查看Qiskit
    Runtime提供的自上而下的方法，帮助你快速了解这些算法在各个领域如何用于解决小问题。希望这本书为你提供了一个简单的入门途径，简化你进入量子计算世界的旅程，并且，一如既往，我期待阅读你的研究论文或可能是你自己的教科书！
- en: Welcome to quantum!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到量子世界！
- en: Questions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the four steps of Qiskit Patterns?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Qiskit模式有哪四个步骤？
- en: Which Qiskit Pattern handles mapping a quantum circuit to the hardware?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Qiskit模式处理将量子电路映射到硬件？
- en: When encoding your problem to a quantum state, which Qiskit Pattern step are
    you on?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将你的问题编码到量子状态时，你处于哪个Qiskit模式步骤？
- en: Why did we use a Sampler and not an Estimator primitive for the Grover example?
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在Grover示例中使用采样器而不是估算器原语？
- en: Join us on Discord
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](Chapter_13.xhtml)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](Chapter_13.xhtml)'
- en: '![](img/QR_Code261762599683826593.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code261762599683826593.png)'
