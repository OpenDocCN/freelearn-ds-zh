- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Quantum Utility and Qiskit Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we are, the final chapter. If you’ve made it this far, then congratulations
    on keeping yourself focused and determined, your time was well invested! As we
    close out this chapter, and the book, I want to also make sure I don’t just leave
    you here with some basics and wish you the best. I’ve found most technical books
    seem to do that. Not that there is anything wrong with that, but I always felt
    like most don’t provide help regarding next steps or, better yet, any next best
    action. I thought I would include this chapter as a shift from education to enablement.
    In other words, where to go from here and *how*. With Qiskit 1.0 (and future updates),
    we should approach this as a transition to really getting a head start towards
    enabling you with the proper tools and patterns to evolve your current experiments
    towards ideal utility application candidates. The goal here is that this book
    will not only provide you with the education to get started, but will also provide
    you with some guidance to know what to expect and develop as the technology grows
    and new features are released.
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have covered a *bottom-up approach* to understand quantum computing,
    where we started with the foundational quantum computational properties, gates,
    and circuits. We then moved up towards combining those to implement various quantum
    algorithms. We also covered how to use the various simulators, generate noise
    models, and mitigate readout errors. All of this helps in understanding the fundamental
    intricacies of quantum computing and how they are used to create algorithms that
    are both effective and optimal.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is a lot to ask of a developer, solution architect, or systems integrator
    to learn all the inner workings just to understand how to integrate quantum computing
    into their application or workflow. In fact, it is often difficult to find those
    who want to wander down into the *nuts and bolts* of the quantum algorithm. Generally,
    most of us would like to just load our data into an algorithm, execute it on a
    quantum system, obtain the results, and just continue with our experiments.
  prefs: []
  type: TYPE_NORMAL
- en: This *top-down approach* is where Qiskit Patterns comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Quantum Utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Qiskit Patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will learn what quantum utility means and why it is key
    to getting us closer towards quantum advantage.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also cover Qiskit Patterns and how it can simplify your development experience
    to build complex quantum circuits. As most quantum algorithms and applications
    become more complex over time, particularly now as we are entering the era of
    quantum utility, we need to understand what they are and how we can best use these
    building blocks to create scalable and efficient quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll wrap up this chapter with a quick example using Qiskit Patterns
    using Grover’s algorithm, which we learned about in the previous chapter, as I
    do not want to finish this chapter without providing you with some code that combines
    classical and quantum together.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, it is expected that you have an understanding of creating
    quantum circuits and general application development using Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the source code we’ll be using throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding quantum utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, I mentioned the term **quantum utility**. I figured I would take the
    time to describe in a bit more detail what that means and, more importantly, what
    it doesn’t mean. First and foremost, let’s start by defining another term, **quantum
    advantage**. Quantum advantage is a term that describes when a quantum computer
    can solve a practical use case in science or business that is intractable to classical
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this could be Shor’s algorithm, which finds the prime factors
    of an integer. This is currently difficult for classical systems to solve due
    to the complexity of the task, which is why it is used to encrypt much of our
    digital content, such as passwords. In the example of Shor’s algorithm, where
    it is estimated to take millions of years to solve the problem using classical
    computers, some say it could take a few hours on a fault-tolerant system. Quantum
    advantage, at the time of writing, of course is a few years away, so it is good
    that you are taking the time now to learn about this new technology so when these
    systems reach quantum advantage, you’ll have a head start on solving interesting
    problems. It’s also important to note that quantum advantage will not happen all
    at once; it will be incremental and will vary based on the type of problem and
    cost compared to running on a classical system. As technology advances beyond
    quantum advantage, so will the solutions to classically intractable problems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of what quantum advantage is, let’s look at what quantum
    utility means. Back in June of 2023, researchers from IBM and UC Berkeley published
    a paper titled *Evidence for the utility of quantum computing before fault tolerance*
    ([https://www.nature.com/articles/s41586-023-06096-3](https://www.nature.com/articles/s41586-023-06096-3)).
    In this paper, the authors were able to show that quantum computers can solve
    problems at a scale beyond brute force classical simulation. Again, this isn’t
    to say that this is quantum advantage, mostly because there are some quantum-inspired
    classical methods that provided classical approximations using other techniques
    beyond brute force. The paper used a 127-qubit quantum computer that had almost
    3,000 CX gates, which is quite a complex circuit to simulate using brute-force
    methods. There of course have been a few quantum-inspired classically based papers
    that were released that managed to reproduce the solution; however, not all the
    results from each experiment aligned for certain parameters. As a result, accuracy
    had begun to struggle, some ranging approximately 20% from each other. Furthermore,
    there have been many other papers that were published afterwards that are over
    100-qubits and contain thousands of CX gates. This highlights the fact that we
    are moving from where we first started, with small-scale circuits, which could
    very easily be simulated classically, to over 100-qubit circuits with thousands
    of CX gates. As the size of the circuits, both width (number of qubits) and depth
    (number of CX gates) grows, so does the cost of simulating the circuit classically.
    Cost here can refer to loss of accuracy or speed. This era, which is a time before
    we hit quantum advantage, is what is referred to as **Quantum Utility**. Furthermore,
    using the error mitigation techniques discussed earlier in this book, allows running
    these complex circuits on 100+ qubit systems. The era of utility means we can
    find useful quantum applications to run without having to wait for fault-tolerant
    quantum computers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re familiar with what quantum utility is, let’s look at what we
    as developers should understand to take advantage of this latest move forward
    in quantum technology to build these more complex quantum circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Qiskit Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another announcement at the 2023 IBM Quantum Summit was the introduction to
    Qiskit Patterns. Qiskit Patterns originated from the idea that as circuits get
    larger and more complex, computational scientists should not be concerned about
    what is happening at the hardware level. There is no need for a computational
    scientist to understand which gate to use on a specific qubit, or which is the
    ideal optimizer to use when transpiling the circuit to the hardware. Computational
    scientists should have tools that can be used to provide them with the latest
    hardware and software and simplify the usage of these 100+ qubit systems. These
    tools should provide a way for scientists to generate code or functions that will
    solve a specific problem or set of problems, and not create circuits qubit by
    qubit, gate by gate. Therefore, the purpose of the Qiskit Patterns is to provide
    the computational scientist with a way to inject a quantum computational routine
    into their existing applications and workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the purpose of Qiskit Patterns, let’s look at what they are
    and how to use them. Prior to stepping into the details, I do want to stress that
    this is a new feature that is always being enhanced. There may be many changes
    to the code and its usage. What I am writing here is what is current at the time
    of writing. As we know, with all coding languages there are always updates or
    changes, so I urge you to review the documentation first so you are up to speed
    on the latest development. Even if there are changes in code, the concept of the
    overall steps should still be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put, Qiskit Patterns are made up of 4 steps that are used to run algorithms
    on a quantum computer and provide you with a result to use as part of your application
    and/or workflow. The four steps are: **map**, **optimize**, **execute**, and **post-process**.
    We’ll learn what each of these steps does and run an example using a simple circuit.
    Of course, you can use any circuit that you wish.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1, Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this step, we want to map the problem to a quantum circuit. This entails
    encoding the problem and inputs into a quantum circuit or state. A simple example
    we can use is to encode a binary image. This is an image where each pixel is either
    black or white, 0 or 1, respectively. It is simple enough to read each pixel and
    if the pixel is black, we leave the state as 0 and if it is white, we add an X
    gate to change it to the 1 state. Of course, this means that we would need the
    same number of qubits as we do pixels, so this is not easy to scale to larger
    images that have millions of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: So, we would need to find ways to encode these images so that they would not
    need millions of qubits. This is where encoding comes in handy. If we can find
    a way to encode pixels into a quantum state, then this will work nicely. There
    are of course many ways to encode images, too many to list here, but by searching
    quantum image processing, you should find many forms. A few of the earliest forms
    are **NEQR**, which stands for **Novel Enhanced Quantum Representation** for digital
    images, and **FRQI**, which is short for **Flexible Representation of Quantum
    Images**. The mapping using FRQI maps the intensity value of the pixel, let’s
    say a 256-bit grayscale image, to a single qubit (i.e., pi/256 would represent
    the pixel value). In NEQR, you would map the values using 8 qubits, where each
    qubit is set as a binary value, so the qubit intensity is not represented by 1
    qubit (as in FRQI), but 8 qubits (8 qubits that map to the 8 binary values needed
    to represent the numbers from 0 to 256). These are just two, but there are so
    many more, each of which has its own advantages and disadvantages. What this means
    is that a lot of the work for you, as a computational scientist, is about selecting
    the encoding, or mapping, that you believe is best for your experiment. This mapping
    should ensure that your problem is not just encoded into a quantum state, but
    encoded in a way where it provides an optimal way to represent the problem you
    wish to solve. Once you have selected the proper mapping of your problem and input,
    a circuit is generated. We are now ready to move onto the next step in the Qiskit
    Pattern, optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2, Optimize your circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve covered in previous chapters, optimizing a circuit is not just one
    step of mapping the circuit to the quantum hardware; there are many different
    aspects to it. Thankfully, most of this is done automatically for us, but it also
    provides us with ways to alter them, either by setting `optimization_level` option
    values to specify the type of optimization to perform, but the recently added
    `resilience_level` option values, which allow us to also select the type of error
    suppression and error mitigation to apply to our circuit. As most of these require
    some classical resources, this provides us with a way to set how much of those
    classical resources to use. The result of the transpilation and optimization is
    called **Quantum Instruction Set Architecture** (**QISA**). This optimized circuit
    is specific to the quantum hardware we select to execute this circuit on, which
    leads us to the next step, execute.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3, Execute your circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to note is that when we say execute a circuit, this is not to say
    we will execute this circuit on a quantum system, particularly when running a
    variational quantum algorithm that requires some classical interactions during
    execution. This is why primitives like the Estimator and Sampler are great building
    blocks as they provide the necessary context needed to execute these circuits
    to allow classical and quantum interactions during execution time. Executing a
    circuit can use one of many modes, such as Sessions, Jobs, and Batch.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed these in *Chapter 10*, *Suppressing and Mitigating Quantum Noise*,
    where we covered how circuits are run on a quantum system. Now that we have executed
    our circuit on a quantum system, we now have reached the final step in the Qiskit
    Pattern, post-processing.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4, Post-process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is just a matter of obtaining the results we received from executing our
    circuit and processing them into what our classical application or workflow expects.
    Up to now, we’ve been displaying our results as either graphs or as text so we
    can view them and understand what the results mean. But when integrating with
    an application or workflow, the results might need to either be formatted in a
    certain way or aggregated with other results from various other systems as a collection.
    In either case, the post-processing step is just a matter of handling the results
    and passing them back to the calling system in a way that will facilitate its
    integration into the application itself in a very robust way. This of course would
    be dependent on how the results would be used in the next step or displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, those are the 4 steps, straightforward and quite simple. But then
    again, that is the point! Ideally, you, as a developer, computational scientist,
    or quantum enthusiast, should not have to struggle with how to create, execute,
    and obtain results from a quantum system. The process should be very straightforward
    and simple. Speaking of simplifying the process, another announcement during the
    Summit was that there will soon be AI included, which would be able to auto-generate
    quantum code as well. It has not been announced when this, and other AI features,
    will go live but the code will soon include this. This should help those who are
    new and just getting started as it could serve as a tool to ask how to create
    certain circuits, i.e. Grovers, Simon’s, etc. and of course should also help those
    experienced researchers who would like to scale their existing circuits into these
    larger complex circuits, which could advance their solutions towards a path to
    quantum advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that all being said, I will not let you down! I did leave a little programming
    for you here so to not have a chapter without any coding. We will implement something
    that we built in the previous chapter, a simple logical expression to determine
    the optimal result using Grover’s algorithm. This is a simple example where we
    will start with a logical expression, which we can say is the classical data coming
    in. Then we will proceed to use the Sampler primitive so we can run it locally,
    define the problem, and use the Grover algorithm class to solve the problem. This
    time, we will use the methods to input the problem and provide us with the optimal
    result, which we will then print out and display visually, hence completing the
    hybrid classical-quantum application. Here we go!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the logical expression oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logical expressions are commonly used to describe problems, particularly those
    that have some constraints. These logical expressions can be used to construct
    a circuit and execute it on various algorithms. Let’s begin with a simple problem.
    Note that the names have been changed to protect the identities of bands who have
    trouble staying together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Melba, a music producer, has been tasked to put together the next big rock
    band, based on the musicians who currently have a contract for a record company.
    The following musicians are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ivana** is a singer who has a great voice and is available to tour as soon
    as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Karla** is also a singer with a great voice and is also available to tour
    right away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lex** is a guitar player that can play any genre and has his own tour bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leo** is a drummer that gets along with everyone and is very liked in the
    industry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, here is the problem you have been asked to solve by the music producer:
    Ivana and Karla tend to not get along on tour and have been known to have creative
    differences when writing music. Lex and Leo, on the other hand, get along fine
    together both in the studio and on tour. However, Ivana and Lex recently broke
    up after the last time they toured together so we can have one of the following
    options: only Ivana or Leo can participate, or neither and simply replace them
    both.'
  prefs: []
  type: TYPE_NORMAL
- en: What you need to do is determine which combination of these four musicians is
    best for you to put together as a band, and then have them tour with minimal issues
    based on their history together.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, let’s write this out as a logical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll map each musician to a variable such as: `A = Ivana`, `B = Karla`, `C
    = Lex`, and `D = Leo`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we’ll create a logical expression using logical operators to illustrate
    the constraints. To start, we know that Ivana and Karla do not get along, so this
    we can represent as follows, where ^ indicates XOR. This means we need at least
    one of them to participate, but not both at the same time: ![](img/B18420_13_001.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we know that Lex and Leo get along fine together, so we can represent
    them with an AND operator as follows: ![](img/B18420_13_002.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we know that Ivana and Lex have just ended their relationship, so
    they might not be open to working and touring together. We will represent them
    as a NAND as follows. This indicates that they cannot work together, but it will
    allow for both not to participate at all: ![](img/B18420_13_003.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By putting these all together, our complete logical expression for this example
    is as follows: ![](img/B18420_13_004.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have defined our logical expression, let’s create an oracle on the
    logical expression so that we can use **Grover’s algorithm** to search for the
    optimal result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by importing all the necessary modules and classes needed for the
    rest of these steps and defining our logical expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have defined our problem as a logical expression, let’s use this
    logical expression to create our `oracle`, which as you recall is what we use
    to describe the problem we wish to solve. In this case, it represents the logical
    expression. Note that in the code I included a cell that would install a dependency
    for using PhaseOracle (`pip install tweedledum`), as you will likely also have
    to install Qiskit algorithms (`pip install qiskit-algorithms`). I’ve commented
    the line out to install just in case you already have it installed; however, if
    you get an error when executing a cell that requires the dependency, simply install
    onto your development environment using the command-line instruction, and restart
    the kernel. This will then complete the installation and you can then run the
    code without the dependency error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created an `oracle` from the logical expression, we can create
    the problem by calling the `AmplificationProblem()` method and passing the expression
    we wish to solve as its argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code calls the oracle from the Grover operator which contains
    the quantum circuit representation of the oracle which is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Quantum circuit representing the logical expression oracle'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that this oracle describes the logical expression, where q[0], q[1],
    q[2], and q[3] represent our logical expression, where q[0] = Ivana, q[1] = Karla,
    q[2] = Lex, and q[3] = Leo. Observe that the control in q[0] is not filled in.
    This is to indicate that it is triggered when the state value of q[0] is ![](img/B18420_13_005.png),
    as opposed to the others, which are triggered when the qubit is in the ![](img/B18420_13_006.png)
    state. We can now use this oracle on any oracle-based (oracular) algorithm. Since
    we are searching for the solution to this rock band problem, let’s use Grover’s
    algorithm. First, we will set up a session and use the Sampler primitive for this
    example, and then create the Grover’s algorithm class using the sampler as the
    primitive. We’ll then pass the problem we defined in the previous cell into the
    `amplify` method, which will in essence run Grover’s algorithm, provide us with
    the result, and display it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code results in the following output, which represents the value
    we are searching for: `1110`. Keep in mind that the qubit at position 0 is represented
    by the least significant bit (far right). This means that the result, `1110`,
    is equal to D=1, C=1, B=1, A=0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also obtain the following quasi-distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18420_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Grover solution results based on the logical expression oracle'
  prefs: []
  type: TYPE_NORMAL
- en: As shown by the preceding results, the algorithm indicates our solution is **1110**.
    This states that Karla, Leo, and Lex are the three ideal musicians to recruit
    into the next band project. Melba has then decided to recruit Ivana as a solo
    career singer.
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is a simple example. As you can imagine, if your expression
    is more complex, then the Grovers search would help determine that in just a few
    lines of code. As you can see, you can take a problem that’s defined by a logical
    expression on a classical system and then, by leveraging the Qiskit Runtime and
    Grover’s algorithm class, prepare the problem in a variety of ways, all of which
    can be executed on a quantum system. All of this can be done without having to
    delve into the lower layers of the quantum algorithm, i.e., quantum gates, operators,
    error mitigation, etc.
  prefs: []
  type: TYPE_NORMAL
- en: As Qiskit continues to add many more features, algorithms, utilities, and other
    artifacts, this will help you create flexible yet modular quantum applications
    that suit all your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered Qiskit Patterns, which are focused on helping you
    quickly develop robust quantum circuits to include into your applications and
    workflows. With the release of Qiskit 1.0 and future changes, I also highly recommend
    you keep up with the latest changes. Qiskit 1.0 has a nice roadmap filled with
    updates to primitives, patterns, and many features that not only help you get
    up to speed with the development process but also ensure that your circuits can
    scale up to larger utility sized circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the general skills to understand how to start creating quantum
    applications and using Qiskit Patterns in a way that simplifies the creation process,
    you can start applying these features into your existing circuits, or in new circuits
    if you are just starting out.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at a problem that we needed to solve using Grover’s quantum
    algorithm, without having to really understand how they are constructed, meaning
    we did not have to create a quantum circuit, an oracle, or diffusion operators
    to run the algorithm. The focus was on how to represent the problem, in this case
    as a logical expression, and apply it via a combination of available classes and
    methods of the algorithm to present the problem and solve it. Just keep in mind
    that as we are moving towards quantum utility, there will be more efficient and
    modern ways to implement this and future algorithms. As mentioned throughout this
    book, these are just the principles and general programming practices to help
    get you started, but as quantum computing evolves, so to will the algorithms and
    the way we think about how to program. It’s with this that you should take away
    from this book, it’s a place to start for you to take the code and keep on pushing
    towards the outer bounds of your ingenuity and imagination. But for now…
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve taken a very large step towards getting yourself started
    with learning and building quantum applications. Initially, we followed a bottoms-up
    approach, which is to start by creating and running quantum circuits on both a
    locally installed simulator and on a quantum computer. Doing this helped you understand
    the inner workings of how a quantum circuit is built and executed on a quantum
    system. Next, you reviewed the various algorithms and quantum computing principles
    that differentiate between classical and quantum applications. By running these
    applications, you also visualized the results and of course the effects caused
    by various environmental effects, which in turn helped you learn about the various
    features that mitigate the noisy effects of the quantum computer. And finally,
    you looked at a top-down approach offered by the Qiskit Runtime to help you quickly
    see how some of these algorithms in various domains are used to solve small problems.
    The hope here is that this book has provided you with a simple gateway to simplify
    your journey into the quantum computing world and, as always, I look forward to
    reading your research papers or perhaps your own textbook!
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to quantum!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the four steps of Qiskit Patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Qiskit Pattern handles mapping a quantum circuit to the hardware?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When encoding your problem to a quantum state, which Qiskit Pattern step are
    you on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we use a Sampler and not an Estimator primitive for the Grover example?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_13.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code261762599683826593.png)'
  prefs: []
  type: TYPE_IMG
