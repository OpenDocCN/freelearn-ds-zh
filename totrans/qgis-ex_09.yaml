- en: Chapter 9. Automating Analysis with Processing Scripts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced the Processing Graphical modeler, and
    you learned how to use it to automate complex geoprocessing analyses. But this
    is not the only way to automate your work. QGIS's Processing framework also allows
    you to write your own scripts in Python and use them like any other algorithm
    later. This is what we will discuss in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Python scripts in Processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the input and output
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the algorithm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing help and saving
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python scripts in Processing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have already learned how to create models and automate analysis tasks with
    the help of the graphical modeler from the QGIS Processing framework. Although
    the Processing modeler is user friendly and easy to use, it has some limitations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: In the models, you can use only algorithms that are already available in Processing.
    Moreover, some algorithms that are available from the Processing toolbox are not
    available in the modeler.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no support for conditional statements and loops.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if you need to implement something more complex and advanced, you'll need
    another tool. Fortunately, the modeler is not the only way to automate analyses
    with Processing. Processing also allows us to combine its own power with the power
    of the Python programming language by developing Python scripts. Such scripts
    can then be used like any other algorithm from the Processing toolbox or modeler,
    or executed as batch processes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing our scripts, it is necessary to understand how
    to use Processing algorithms from the QGIS Python console, because this knowledge
    is necessary for successful use of the existing Processing algorithms within scripts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the Python console by clicking on the ![Python scripts in Processing](img/image00513.jpeg)
    button on the **Plugins** toolbar. Alternatively, you can use the *Ctrl* + *Alt*
    + *P* keyboard shortcut or open it by going to **Plugins** | **Python Console**.
    A new dock widget will appear at the bottom of the QGIS window, as shown in the
    following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Python scripts in Processing](img/image00514.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: The Python console consists of two main areas. At the top, there is the output
    area, where executed commands and their output will be printed. Below it is the
    input area, where you should enter the code to be executed. Here, code is entered
    line by line. There is also a toolbar on the left-hand side of the Python console.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to learn more about the Python console, click on the **Help** button
    from its toolbar and read the built-in documentation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Processing from the Python console, we should import it with
    this command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line will load all Processing functions and make them available for us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Listing the available algorithms
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may want to run an existing Processing algorithm from your script instead
    of reimplementing its functionality yourself. To do this, it is necessary to get
    the name of that algorithm, which is not what you see in the toolbox, but a special
    name—the so-called command-line name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望从你的脚本中运行现有的 Processing 算法，而不是自己重新实现其功能。为此，需要获取该算法的名称，这并不是你在工具箱中看到的名字，而是一个特殊名称——所谓的命令行名称。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Every algorithm in Processing has two names: a human-readable and user-friendly
    name that is used in the toolbox and modeler, and another internal command-line
    name that has no ambiguous characters in it, such as spaces, semicolons, and so
    on. It also contains information about the algorithm provider. Command-line names
    are unique.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 中的每个算法都有两个名称：一个用于工具箱和模型器中的人可读且用户友好的名称，以及另一个内部命令行名称，其中不包含任何歧义字符，例如空格、分号等。它还包含有关算法提供者的信息。命令行名称是唯一的。
- en: 'To list all available Processing algorithms with their command-line names,
    run this Python console command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有可用的 Processing 算法及其命令行名称，请运行以下 Python 控制台命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will get a very long output that might look like this (truncated):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个非常长的输出，可能看起来像这样（已截断）：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To the left, you can see human-readable algorithm names that are also used in
    the toolbox, and to the right are the corresponding command-line names.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你可以看到在工具箱中也使用的人可读算法名称，而在右侧是相应的命令行名称。
- en: 'As the number of algorithms—even in a default QGIS installation—is really big,
    it may be difficult to find the command-line name of the desired algorithm. Fortunately,
    it is possible to reduce the output of the `alglist()` command. Just pass to it
    a string parameter representing a substring that should exist in the algorithm''s
    name. For example, to display only algorithms with the word `count` in their names,
    execute the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法的数量——即使在默认的 QGIS 安装中——也非常大，可能很难找到所需算法的命令行名称。幸运的是，可以通过 `alglist()` 命令减少输出。只需向其中传递一个字符串参数，表示应存在于算法名称中的子串。例如，要仅显示名称中包含“count”一词的算法，请执行以下代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result will be much shorter, and it will be easy to find the algorithm
    you are looking for:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将更短，并且更容易找到你正在寻找的算法：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we know how to get the command-line name of the required algorithm. But
    in order to run the algorithm, we will need to know some more information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何获取所需算法的命令行名称。但为了运行该算法，我们还需要了解一些更多信息。
- en: Getting information about an algorithm
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取算法信息
- en: To execute an algorithm, we need not only its name but also the syntax. This
    includes information about the list of algorithm input and output, as well as
    the order in which they should be passed to the algorithm. All of this information
    can be obtained with the help of the `processing.alghelp()` command. This command
    accepts only one argument—the command-line algorithm name—and returns a list of
    algorithm inputs and outputs, with their types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行一个算法，我们不仅需要其名称，还需要其语法。这包括有关算法输入和输出的列表，以及它们应该按何种顺序传递给算法的信息。所有这些信息都可以通过 `processing.alghelp()`
    命令获得。此命令仅接受一个参数——命令行算法名称，并返回一个包含算法输入和输出的列表，以及它们的类型。
- en: 'As an example, let''s look at the `Create grid` algorithm we used in previous
    chapters. Its command-line name is `qgis:creategrid` (you can easily check this
    using the information from the preceding section), so to get information about
    its syntax, we should execute the next command in the QGIS Python console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以往章节中使用的 `Create grid` 算法为例。它的命令行名称是 `qgis:creategrid`（你可以通过前述部分的信息轻松检查这一点），因此要获取其语法信息，我们应该在
    QGIS Python 控制台中执行下一个命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the output of this command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此命令的输出：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From this output, we can see that the human-readable algorithm name is `Create`
    `grid` and it accepts four input fields: `TYPE` (selection from a predefined list
    of values), `EXTENT` (the extent), `HSPACING`, and `VSPACING` (both of these are
    numbers). The algorithm has produced one vector output. The most interesting part,
    however, is below the parameters and outputs list; it''s the list of available
    values for the `TYPE` selection parameter. The numbers on the left are values
    that can be passed to the algorithm, and on the right, you can see the human-readable
    description of each value. For example, if you want to create a grid with the
    diamond cells, then it is necessary to pass a value of `2` to the `TYPE` parameter.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how different parameter types should be passed to the algorithm:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**Raster or vector layer and tables** (`ParameterVector`, `ParameterRaster`,
    and `ParameterTable`): It is possible to specify the name of the corresponding
    layer or table, if that layer is already loaded in QGIS. Also, you can use the
    path to the layer file. Finally, it is possible to pass an instance of the corresponding
    QGIS class, for example, `QgsVectorLayer`. If this is an optional input and you
    don''t want to use it, just use the `None` value.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selection from predefined values** (`ParameterSelection`): This should be
    represented by the numerical index of the corresponding value. Mapping between
    values and indexes is displayed as part of the `processing.alghelp()` function
    output, as shown earlier. There is also a separate command for listing such matches—the
    `processing.algoptions()` function. This command accepts only one argument—the
    command-line name of the algorithm—and its output is a match between the option
    index and value for all algorithm parameters with the selection type.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple input** (`ParameterMultipleInput`): This should be passed as a string
    delimited with semicolons (`;`). Each value can be a layer name or the path to
    the file.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field of the table** (`ParameterTableField`): This is just a string with
    the field name. Note that this values is case-sensitive.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-defined table** (`ParameterFixedTable`): This is defined as a list of
    values separated by commas and enclosed in double quotes. Also, it is possible
    to pass a 2D list or array with the values; for example, a small 2 x 2 table can
    be passed as two-dimensional Python list, like this: `[[0, 1], [2, 3]]`. Keep
    in mind that values should start from the topmost row and go from left to right.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordinate reference system** (`ParameterCrs`): Use the EPSG code of the
    corresponding CRS.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extent** (`ParameterExtent`): This is represented as string containing the
    `xmin`, `xmax`, `ymin`, and `ymax` values delimited by commas (`,`).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numerical** (`ParameterNumber`), **boolean** (`ParameterBoolean`)**, and
    string** (`ParameterString`) **parameters**: These are represented by the corresponding
    native Python data types: `int`, `float`, `boolean`, `str`, or `unicode`. Also,
    such parameters may have default values. To use them, specify `None` in the place
    of the corresponding parameter.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For output data, the rules are much simpler. If you want to save a layer, table,
    file, or HTML output in a particular place, just pass a path to the file. In the
    case of raster and vector output, the extension of the file will determine the
    output format. If the given extension is not supported by the algorithm, the output
    will be saved in the default format (which depends on the algorithm), and the
    corresponding extension will be added to the specified file path. To write the
    output to a temporary file, pass the `None` value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to define any variables for numerical and string output when
    running an algorithm from the Python console. These will be calculated and returned
    automatically, without any actions from your side. See the *Executing the algorithm
    and loading the results* section of this chapter for more information about accessing
    such kinds of output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the algorithm syntax and how to pass parameters to it, we
    can execute the algorithm from the QGIS Python console.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Executing the algorithm and loading the results
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To execute the algorithm from the QGIS Python console, we need to use the `processing.runalg()`
    method. Generally, this method is called in the following way:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `algorithm_name` is the command-line algorithm name, `param1...paramN`
    are algorithm parameters, and `output1...outputM` are algorithm outputs. Parameters
    and outputs should be passed in the same order as shown by the `alghelp()` method,
    considering information about defining input and output from the previous section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned previously, you don't need to specify any variables for numeric,
    string, or boolean outputs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: If the algorithm reports its execution progress, a message bar with the progress
    indicator will be displayed in the main QGIS window during execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Unlike algorithm execution from the toolbox, the `runalg()` method does not
    load any results into QGIS. You can load them manually with the help of the QGIS
    API or in the following way using the helper methods provided by Processing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: On successful execution of the algorithm, the `runalg()` method returns a dictionary
    in which the output names (as shown by the `alghelp()` method) are the keys and
    their values are paths to the generated files or contain calculated values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a generated raster or vector layer, pass the path to the corresponding
    file to the `load()` method. For example, if the result of algorithm execution
    is saved in the `res` variable and the output name is `OUTPUT`, then to load this
    layer into QGIS, execute this code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, the layer will be loaded into QGIS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To access numeric or string output in the results dictionary, just use the corresponding
    key names.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load data from the Brooklyn tree cadastre (this is the `trees` layer
    in our dataset), and try to understand how the next small example works and what
    it does. Run these commands in the QGIS Python console one by one. If necessary,
    use the `processing` helper methods, such as `alglist()` and `alghelp()`, and
    examine the results by printing them or loading into QGIS, as mentioned previously:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you have read the previous sections carefully, you should understand that
    these commands are used to generate a hexagonal density map from the point layer.
    In the first line, we import the `processing` module with all its algorithms.
    In the second line, the `Create grid` algorithm is executed, and it creates a
    hexagonal grid (a parameter with value equal to `3` represents hexagonal grid
    type) using the extent of the `trees` layer and cell size equal to `1000`. The
    result is saved in a temporary file, as we pass the `None` value as the last argument.
    In line `3`, the algorithm `Count points in polygon` is executed. As a polygon
    layer, it uses an output of the `Create grid` algorithm (`resGrid['OUTPUT']`),
    and as point layer, already opened trees layer in QGIS is used. Again, the result
    is stored in the temporary file. Then, in line `4`, the `Extract by attribute`
    algorithm is called to save only nonempty cells (a parameter with value `1` corresponds
    to the not equal to operator, `!=`). With the last line, the final result is loaded
    into QGIS.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Now, that you know how to get all of the necessary information about Processing
    algorithms and can use them from the QGIS Python console, we can dive into Processing
    script development.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Defining inputs and outputs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already said, despite models, you can create your own Processing
    scripts using the Python programming language. Basically, Processing script is
    Python code plus some additional metadata required by Processing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Processing script starts with a special block of metadata. This information
    is needed by Processing to register a script as an algorithm and use it from the
    toolbox, modeler, and so on. Each metadata entry is placed on a new line, starting
    with the double Python comment symbol (`##`), and has the following structure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Metadata items can be divided into three groups: items that describe the script,
    items that describe script input, and items that describe script output.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only three items that describe the script:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`group`: This is used to define the name of the subgroup inside the **Scripts**
    group in the toolbox where the script will be shown. For example, if you put the
    following line `##Density maps=group` into the script header, it will be placed
    under the **Density** maps subgroup. If this item is omitted, the script will
    be placed under the **Scripts** subgroup, which is under **User**.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This defines the script name. By default, the script name is generated
    from the name of the script file by dropping the extension and replacing underscores
    with spaces. If you don''t want to use long, descriptive filenames for your scripts
    but still want nice names in the Processing toolbox, use the `name` metadata item.
    Its syntax is the same as that in the `group` item, for example, `##Hexagonal
    density map=name`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nomodeler`: This item is a flag. Scripts with such metadata can be used only
    from the toolbox. They will be not available in the modeler. Its usage is like
    this: `##nomodeler`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of metadata items that are used to describe script input is a much
    larger. Scripts support almost all inputs available in Processing. It is necessary
    to mention that the item name will also be a variable name, and it can be used
    in the script code. The value entered or selected by the user while executing
    the script will be assigned to the corresponding variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Also, the item name will be used as as the caption for the corresponding widget
    in the algorithm execution dialog. To improve appearance, underscores will be
    replaced by spaces. So, if you have an item with the name `My_cool_parameter`
    in the script, then its widget will have a caption as **My** **cool** **parameter**.
    To access the value of this parameter, we need to use the `My_cool_parameter`
    variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the available input parameters:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`raster`: This describes the input raster layer. Here is a usage example: `##Raster_layer=raster`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector`: This describes the input vector layer. Note that this item should
    be used if your script accepts vector layers with any geometry type—point, line
    or polygon. If you want to limit the supported geometry types, use one of the
    following items. An example of its usage is `##Vector_layer=vector`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector point`: This describes the input point vector layer. This item will
    accept only layers with point geometry. Note that such a limitation is applied
    only to layers that are already loaded into QGIS. If the user wants to specify
    a file from the disk, it is their responsibility to select the layer with the
    correct geometry type. Its usage is like this: `##Vector_layer=vector point`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector line`: This describes the input line vector layer. This item will accept
    only vectors with line geometry. Again, note that such a limitation is applied
    only to layers that are already loaded into QGIS. If the user wants to specify
    a file from the disk, it is their responsibility to select the layer with the
    correct geometry type. Its usage is like this: `##Vector_layer=vector line`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector polygon`: This describes the input polygon vector layer. This item
    will accept only vectors with polygon geometry. Once again, note that such a limitation
    is applied only to layers that are already loaded in QGIS. If the user wants to
    specify a file from the disk, it is their responsibility to select the layer with
    the correct geometry type. An example usage is as follows: `##Vector_layer=vector
    polygon`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`table`: This is used to define an input geometryless table. Its usage is like
    this: `##Table_to_join=table`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple raster`: This is used to define a compound input that consists of
    several raster layers. An example usage is as follows: `##Layers_to_mosaic=multiple
    raster`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple vector`: This is used to define compound input that consists of several
    vector layers. Note that this input allows us to select any vector layer, regardless
    of its geometry type. Its usage is like this: `##Layers_to_merge=multiple vector`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection`: This describes selection from a list of predefined values. The
    values specified after the item type are separated by semicolons. An example usage
    is as follows: `##Method=selection Nearest neighbor;Average;Cubic`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`: This defines a Boolean (also often called logical) input. It is
    necessary to specify a default value. Its usage is like this: `##Smooth_results=boolean
    False`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extent`: This defines the input extent. Its usage is like this: `##Grid_extent=extent`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file`: This is used to define an input file (in text or in any other format
    that cannot be recognized by Processing as raster, vector, or table). An example
    usage is as follows: `##Index_data=file`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`folder`: This describes the input directory. Its usage is like this: `##Input_directory=directory`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: This defines a numerical (integer or floating-point) input. It is
    necessary to specify a default value. If the default value does not have a decimal
    separator, then the parameter will accept only integer values. Currently, it is
    not possible to define minimum and maximum limits for such parameters in scripts.
    An example usage is as follows: `##Width=number 1000.0`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`field`: This describes an attribute field in the vector layer or geometryless
    table. It is necessary to specify the name of the corresponding input that represents
    the parent layer or table. For example, if a vector layer is defined as `##Input_layer=vector`,
    then the field of this layer will be defined as `##Classification_field=field
    Input_layer`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: This is used to define a string input. It is necessary to specify
    a default value. Its usage is like this: `##Field_name=string NUMPOINTS`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longstring`: This defines a multiline string input. It is necessary to specify
    a default value. An example of its usage is as follows: `##Options=longstring
    my cool options`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crs`: This describes the coordinate reference system. By default, EPSG:4326
    is used. If you want another default CRS, specify its `EPSG` code. Its usage is
    like this: `##Assign_CRS=crs EPSG:3857`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input layers and tables are always passed to the script as strings containing
    paths to the corresponding files. To create a QGIS object (`QgsVectorLayer` or
    `QgsRasterLayer`) from such a string, we need to use the `processing.getObjectFromUri()`
    function. Multiple raster or vector inputs are also passed as strings that contain
    paths to individual files separated by semicolons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are all the available outputs:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '`output raster`: This represents the raster layer generated by the script.
    Its usage is like this: `##NDVI_raster=output raster`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output vector`: This represents the vector layer generated by the script.
    An example of its usage is as follows: `##Vector_grid=output vector`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output table`: This represents a geometryless table generated by the script.
    This can be, for example, a CVS or DBF table. Its usage is like this: `##Nearest_points=output
    table`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output html`: This describes the output in HTML format. Such an output is
    mainly used for different textual reports that may or may not include graphics.
    An example of its usage is as follows: `##Statistics=output html`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output file`: This is used for files in formats different from HTML and all
    others supported by QGIS formats. For example, these can be plain text files,
    LiDAR data, and so on. Its usage is like this: `##Points_connection=output file`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output directory`: This describes the output directory. It is mainly used
    for algorithms that produce many files, for example, when splitting the vector
    layer by attribute values. An example of its usage is as follows: `##Splitted_files=output
    directory`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that currently, Processing cannot load files from such output directories,
    even if these files are in the supported format. You need to manually open each
    file from the output directory.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`output number`: This represents a numerical value generated by the algorithm.
    This value not saved anywhere and can only be used as the input in another algorithm.
    For example, one can implement script to calculate optimal cell size for the vector
    grid, then the numerical output from such algorithm can be used as input in the
    Create grid algorithm. An example of its usage is as follows: `##Maximum_value=output
    number`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output string`: This is similar to the output number described previously.
    It represents a string literal generated by the algorithm. Its usage is like this:
    `##Select_condition=output string`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical and string outputs are also called hidden outputs (because they are
    not shown in QGIS and in Processing's results dialog), and are not automatically
    initialized with values. You should manually assign the corresponding values to
    them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: All other output will always be a string value with the path to the corresponding
    output file or directory. If user does not specify any filename, then the output
    will be saved to the automatically created temporary file, and the name of this
    file will be used as the output value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that after successful algorithm execution, Processing
    will automatically load all output files in the supported formats. So, you don't
    need to add any `processing.load()` function calls to your script.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the algorithm
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, when we know how to define input and output, we are ready to develop Python
    scripts for Processing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to create a script:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Use your favorite text editor or IDE
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Processing's built-in code editor
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which method to use is a matter of taste and habits. In this book, we will use
    the built-in script editor. You can open it from the Processing toolbox. Locate
    and expand the **Scripts** group, expand the **Tools** subgroup, and double-click
    on the **Create new script** item. Alternatively, you can start typing `Create
    new script` in the filter field. The toolbox's content will be filtered, and you
    can easily locate the corresponding item.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the algorithm](img/image00515.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: The **Script editor** looks like an ordinary text editor as shown in the preceding
    screenshot. There is a toolbar at the top, and all of the remaining area is used
    up by the editor itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Now we will see how to create Processing Python scripts by developing a script
    to find the shortest path between two points on the road network. Such an analysis
    is very common in many areas of application such as infrastructure planning, trip/travel
    planning, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: QGIS has a simple built-in network analysis library that allows us to find the
    shortest path between two points using **Dijkstra's algorithm**, and also perform
    some other interesting things, such as building areas of accessibility (also known
    as service areas) and matching points to the nearest lines.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to determine the script input and output. As input, we need a
    roads layer, a start point, and an end point. As Processing does not support points
    as input, the simplest workaround is to pass two vectors, one for the start point
    and the other for the end point. This solution also allows us to define multiple
    start and end points and find the shortest path between each pair of start and
    end points. As for the output, our script obviously will have only one output—a
    vector layer with the shortest path (or paths) calculated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the script header will look like this. If you have read the previous sections
    carefully, you should have no problem understanding it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first two lines, we define the group where our script will be placed
    and the script name. Then, we define the input and output. Note that we use precise
    definitions for input vector layers, so that when the user runs the script in
    the input comboboxes, they will see only layers with the geometry type that matches
    the parameter definition. For example, in the Road layer combobox only line vector
    layers will be listed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'After the script header, a script body starts. It contains Python code that
    implements the desired algorithm. The script body can be divided into two parts:
    the import section and the code itself.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本头之后，脚本主体开始。它包含实现所需算法的Python代码。脚本主体可以分为两部分：导入部分和代码本身。
- en: Only very simple scripts can be implemented by using Python's basic commands
    alone. Any more or less complex algorithm will require additional classes or libraries,
    for example, from the Python standard library, QGIS and Processing libraries,
    or even some third-party packages. To use these libraries in your code, you need
    to import them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用Python的基本命令，只能实现非常简单的脚本。任何更复杂或更简单的算法都需要额外的类或库，例如来自Python标准库、QGIS和Processing库，甚至是一些第三方包。要在您的代码中使用这些库，您需要导入它们。
- en: 'Usually, this is done on an iterative basis: you write the code, and when a
    new class or library is needed, add the corresponding import statement. As a rule,
    all import statements are placed at the very beginning of the source''s file.
    For the sake of simplicity, in our sample script, we will provide all the necessary
    imports from the start. The corresponding code will look as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是基于迭代进行的：您编写代码，当需要新的类或库时，添加相应的导入语句。通常，所有导入语句都放置在源文件的非常开始处。为了简化，在我们的示例脚本中，我们将从开始提供所有必要的导入。相应的代码将如下所示：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, all imports are divided into three logical blocks with empty
    lines between them. In the first line, we import the `QVariant` class from the
    `QtCore` package of the `PyQt4` library. This class contains the definition of
    the universal variant data type, which will be used to declare attributes of the
    vector layer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有导入都被分为三个逻辑块，它们之间用空行隔开。在第一行，我们从`PyQt4`库的`QtCore`包中导入`QVariant`类。这个类包含了通用变体数据类型的定义，它将被用来声明矢量层的属性。
- en: In the second block, we import various non-GUI classes from the QGIS core library
    (the first line of the block) and the QGIS network analysis library (the second
    line of the block). We need these QGIS core classes to construct our output vector
    features representing the shortest paths. Moreover, classes from the QGIS network
    analysis library provide us with all that is necessary for performing network
    analysis.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个块中，我们导入了来自QGIS核心库（块的第一个行）和QGIS网络分析库（块的第二个行）的各种非GUI类。我们需要这些QGIS核心类来构建表示最短路径的输出矢量特征。此外，来自QGIS网络分析库的类为我们提供了执行网络分析所需的一切。
- en: Finally, in the last block, we import some classes from different modules of
    the QGIS Processing framework. The `GeoAlgorithmExecutionException` class will
    be used to raise exceptions from our script, and `VectorWriter` is a helper class
    that allows us to easily write output vector data in any QGIS-supported format.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一个块中，我们从QGIS处理框架的不同模块中导入了一些类。`GeoAlgorithmExecutionException`类将被用来从我们的脚本中引发异常，而`VectorWriter`是一个辅助类，它允许我们轻松地将输出矢量数据写入任何QGIS支持的格式。
- en: 'Now we can implement the algorithm itself. As you learned in previous sections,
    all our inputs—the roads layer, as well as layers with the start and end points—are
    passed in the form of paths to the corresponding files, so it is necessary to
    create layer objects from them for further usage. This done with the following
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现算法本身。如您在前面章节中学到的，所有我们的输入——道路层以及起点和终点的层——都是以对应文件路径的形式传递的，因此有必要从它们中创建层对象以供进一步使用。这可以通过以下代码完成：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `getObjectFromUri()` function from the processing package. It accepts
    the path to the file or any other URI and returns a valid layer (raster or vector,
    depending on the URI) from it. Note that we specify the names of the inputs defined
    in the script header as arguments in the `getObjectFromUri()` function calls.
    As we have already mentioned in the *Defining inputs and outputs* section, the
    representing input value has the same name as the corresponding input.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用处理包中的`getObjectFromUri()`函数。它接受文件路径或任何其他URI，并从中返回一个有效的层（根据URI是栅格或矢量）。请注意，我们在`getObjectFromUri()`函数调用中将脚本头中定义的输入名称作为参数指定。正如我们在“定义输入和输出”部分中提到的，代表输入值具有与相应输入相同的名称。
- en: 'As we use separate layers for start and end points, it is necessary to verify
    that both the layers have the same number of features because if the number of
    points is different, it will be impossible to create start-point-end-point pairs;
    some points will be without pairs. Here is the code for such a check:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为起始点和结束点使用单独的层，因此有必要验证这两个层具有相同数量的特征，因为如果点的数量不同，将无法创建起始点-结束点对；一些点将没有配对。以下是此类检查的代码：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use the `featureCount()` method to get the number of features in the layers
    with the start and end points and compare them. If the numbers are not equal,
    an exception is raised and algorithm execution is aborted.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`featureCount()`方法来获取具有起始点和结束点的层的特征数量，并进行比较。如果数字不相等，将引发异常并终止算法执行。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always raise `GeoAlgorithmExecutionException` when you need to abort script
    execution because of any error. In this case, the user will see a standard dialog
    with an error message, and also the error will be stored in the log.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要由于任何错误而终止脚本执行时，始终抛出`GeoAlgorithmExecutionException`。在这种情况下，用户将看到一个带有错误消息的标准对话框，并且错误将被记录在日志中。
- en: Often, algorithms need some time to complete, so it is good practice to inform
    the user about the progress of execution and provide some information about the
    completed steps so that the user will know that the program has not frozen. To
    do this, each algorithm in Processing provides a special `progress` object. With
    its help, you can easily display different types of messages to the user (information,
    debug, ordinal text, and so on), as well as show the progress of execution with
    the progress bar.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，算法需要一些时间才能完成，因此通知用户执行进度并提供有关已完成步骤的信息是良好的实践，这样用户就会知道程序没有冻结。为此，Processing中的每个算法都提供了一个特殊的`progress`对象。借助它，您可以轻松地向用户显示不同类型的消息（信息、调试、顺序文本等），以及使用进度条显示执行进度。
- en: 'Our script is no exception. There are several potentially long-running tasks
    that should be performed during the analysis. The first is collecting the coordinates
    of all start and end points from the corresponding layers. These coordinates will
    be used later in the step of road graph generation. The corresponding code is
    given here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本也不例外。在分析过程中应执行几个可能需要较长时间的任务。首先是收集所有起始点和结束点的坐标，这些坐标将在后续的路线图生成步骤中使用。相应的代码如下：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first line, we show the user an information message with the `progress.setInfo()`
    command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们使用`progress.setInfo()`命令向用户显示一条信息消息。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are also separate commands for displaying plain text (`setText()`), debug
    information (`setDebugInfo()`), console output (`setConsoleInfo()`), and other
    message types.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示普通文本（`setText()`）、调试信息（`setDebugInfo()`）、控制台输出（`setConsoleInfo()`）和其他消息类型外，还有专门的命令。
- en: This message will be displayed in the **Log** tab of the algorithm dialog.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息将在算法对话框的**日志**选项卡中显示。
- en: Then we use an iterator on the features of the layer with the start points,
    extract the geometry of each feature, convert it into a `QgsPoint` instance, and
    store it in the `points` list.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对具有起始点的层的特征使用迭代器，提取每个特征的几何形状，将其转换为`QgsPoint`实例，并将其存储在`points`列表中。
- en: Using the same approach, we create another list, called `tmp`, with the data
    from the layer containing our end points. In the last line, we merge these two
    lists into one, so our `points` list will contain the start points and then the
    end points. We need to put all the points in a single list because later, all
    the points will have to be tied to our road network. This operation is performed
    for all points at once and at the same time as graph creation. As the number of
    points in both layers is equal, we can easily access pairs of the start and end
    points using very simple math. Assuming that the number of points in each layer
    is *N* and knowing that list indexes in Python start with *0*, we can say that
    the start points will have indexes from *0* to *N-1*, while the end points will
    have indexes will be from *N* to *2N-1*. So, if we know the index of a start point,
    it is easy to get the index of the corresponding end point by adding the total
    number of points in any input layer to the index of the start point.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'As our script will produce an output vector layer, it is necessary to prepare
    a special object for saving features in it. Fortunately, Processing has the `VectorWriter`
    class, which provides us with a convenient way to save vector data in any OGR-supported
    format or QGIS memory layer, without writing many lines of code. Here is the code
    for creating such a writer object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the first five lines of code here, we create an instance of the `QgsFields`
    container, where our attributes'' definitions will be saved, and populate it.
    Our example script output layer will have four attributes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the integer numeric identifier of the path'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startPoint`: These are the coordinates of the start point of the path in the
    (*x*, *y*) format'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endPoint`: These are the coordinates of the end point of the path in the (*x*,
    *y*) format'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`: This is the total length of the path'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last line, an instance of the `VectorWriter` class was created. We pass
    the paths to the output file defined by the user, the list of attributes that
    we created previously, the geometry type, and the coordinate reference system
    to the constructor. Note that as the path to the output file, we specify the same
    variable that we used in the script header to describe the output. Also, the coordinate
    reference system is taken from the input roads layer, so our output will be in
    the same CRS.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all the preparation steps needed for now are done, and now we can use
    the QGIS network analysis library to create a graph from our roads layer. This
    step is required because network analysis operates with the graph and not with
    the vector layer. Before creating the graph, it is necessary to instantiate all
    the required classes and adjust the settings. The following lines of code show
    you how to do this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, we instantiate the so-called director, which is a base class that adjusts
    some settings of the graph creation process. The director accepts the parameters
    explained here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The line vector layer from which a graph will be constructed.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图表的线向量层。
- en: The index of the attribute field where the road's direction is stored. As we
    don't take road directions into account, we'll pass `-1` here.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储道路方向的属性字段索引。由于我们不考虑道路方向，我们将传递`-1`。
- en: The attribute value that represents the direct road direction for one-way roads.
    Direct direction means that you can move on such a road only from the start point
    to the end point of the road. In our example, we won't use direction information,
    so we pass an empty string here.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示单行道路直接方向的属性值。直接方向意味着你只能从道路的起点移动到终点。在我们的例子中，我们不会使用方向信息，因此我们传递一个空字符串。
- en: The attribute value that represents the reverse road direction for one-way roads.
    When a road has reverse direction, you can only move from the end point to the
    start point of the road. In our example, we won't use direction information, so
    we pass an empty string here.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示单行道路反向方向的属性值。当道路有反向方向时，你只能从道路的终点移动到起点。在我们的例子中，我们不会使用方向信息，因此我们传递一个空字符串。
- en: 'The attribute value that represents bidirectional, or two-way, roads. Bidirectional
    roads are the most common roads. They allow us to move in both directions: from
    the start to the end, and from the end to the start. In our example, we don''t
    use direction information, so again we pass an empty string here.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示双向或双向道路的属性值。双向道路是最常见的道路。它们允许我们在两个方向上移动：从起点到终点，以及从终点到起点。在我们的例子中，我们不使用方向信息，因此我们在这里传递一个空字符串。
- en: 'The default road direction. This argument defines how to treat roads that have
    no direction information in the field specified by the first argument. It can
    be one of these values: `1` for direct direction, `2` for reverse direction, and
    `3` for bidirectional roads. For the sake of simplicity, we will treat all roads
    as two-way roads, so we will use the value `3`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的道路方向。此参数定义了如何处理第一个参数指定的字段中无方向信息的道路。它可以取以下值之一：`1`表示直接方向，`2`表示反向方向，`3`表示双向道路。为了简化，我们将所有道路视为双向道路，因此我们将使用值`3`。
- en: The shortest path between two points can be calculated using different criteria
    (in the QGIS network analysis library, these are called properters) or even their
    combination—length, travel time, travel cost, and so on. There is only one built-in
    criteria for now in the network analysis library—`QgsDistanceArcProperter`—which
    takes the road length into account. Of course, we can add our own criteria, but
    for the sake of simplicity in our demo script, we will use a built-in criteria.
    The properter is instantiated in the second line and added to the already created
    director in the third line.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点之间的最短路径可以使用不同的标准（在QGIS网络分析库中，这些称为属性）或甚至它们的组合——长度、旅行时间、旅行成本等来计算。目前网络分析库中只有一个内置标准——`QgsDistanceArcProperter`——它考虑道路长度。当然，我们可以添加我们自己的标准，但为了简化我们的演示脚本，我们将使用内置标准。属性在第二行实例化，并在第三行添加到已创建的导演中。
- en: In the fourth line, we create the so-called builder—a class that generates a
    graph using settings specified by the director. The only argument that we pass
    to the builder is the coordinate reference system we want to use. Usually, this
    is the same CRS as that of the input road layer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行，我们创建所谓的构建器——一个使用导演指定的设置生成图表的类。我们传递给构建器的唯一参数是我们想要使用的坐标参考系统。通常，这和输入道路层的CRS相同。
- en: 'Now that all the settings are done, we can create the graph, which will be
    used to find the shortest path, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有设置都已完成，我们可以创建图表，该图表将用于寻找最短路径，如下所示：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As graph generation is a time-consuming operation, especially on a dense road
    network and for a large number of start and end points, we show an information
    message to the user before generating the graph itself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图生成是一个耗时操作，尤其是在密集的道路网络和大量起点和终点的情况下，我们在生成图表本身之前会向用户显示一条信息消息。
- en: The most important line in this snippet is the second one, where the `makeGraph()`
    method is called. The arguments are `builder`, which holds all the settings for
    the process of graph generation, and `points`, which is a list of our start and
    end points. As points may not be located exactly on the road, it is necessary
    to match them to the nearest road link. This happens in the same step as graph
    creation, and the `makeGraph()` method returns a list of so-called tied points,
    or in other words, points that are placed exactly on the nearest road segment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: In the third line, we get the graph object itself from the builder and store
    it for further usage. As we don't need the original points now (all further work
    will be done with the tied points), we delete them in the last line to free the
    memory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about the QGIS network analysis library is available in *PyQGIS
    Developer Cookbook* at [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our road graph and points matched to the nearest road links,
    we can start finding the shortest path for each start-point-end-point pair. But
    first, we need to perform some helper actions, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first two lines are used to prepare values for progress reporting. The progress
    bar displays values from `0` to `100` percent, and we need to process `count`
    pairs of points (equal to the number of features in any input point layer). Then,
    a single step value will be equal to `100` divided to the number of pairs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the last two lines, we just prepare a vector feature instance for our output
    routes and assign previously defined attributes to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding the shortest path is done in the loop, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the first line, we inform the user about next algorithm step. In lines `3`
    and `4`, we get the next pair of the start and end points from the list of tied
    points. In the next two lines, indexes of these points on the road graph are obtained.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In line 8, the actual route calculation takes place. The `dijkstra()` method
    returns a tree with the shortest path from the tree root defined by the point
    with the `idxStart` index (this is our start point from the current point pair)
    to all other graph nodes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: From lines `10` to `23`, we go through the shortest path tree and collect all
    the points that form a way from the end point to the start point.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: After that, from lines `25` to `30`, we create a line geometry from the collected
    points, assign it to the feature, and also set its attributes. Then the feature
    is passed to the writer object and stored in the output layer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in line `32`, we update the progress bar to inform the user about the
    algorithm's execution status.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'When all the point pairs are processed, we need to carry out a cleanup and
    delete unused objects, such as the road graph and output writer:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s all! Now you can save the script and test it by clicking on the **Run**
    algorithm button on the **Script** **editor** toolbar. The algorithm dialog will
    look like what is shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the algorithm](img/image00516.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'You can load the `roads`, `start_points`, and `end_points` layers from your
    dataset and run the algorithm with this data. Alternatively, you can use your
    own layer with a road network, create two point layers for start and end points,
    populate them with features, and execute the script. Here is what the results
    may look like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the algorithm](img/image00517.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: It is necessary to mention that while the QGIS network analysis library provides
    all the necessary tools for network analysis and can easily be extended by the
    user, it also has some limitations and is not suitable for work with very large
    and dense road networks. For such situations, it is better to use more powerful
    tools, such as pgRouting.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Writing help and saving
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the case of model, it is good practice to document your scripts. A script's
    documentation contains its description as well as information about all inputs
    and outputs. This helps users to understand the purpose of the script.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: To create a help file for the script, open it in the built-in Processing script
    editor and click on the **Edit** **script** **help** button on the editor toolbar.
    A **Help** editor dialog, familiar to us from the *Filling model metadata and
    saving* section of [Chapter 8](part0062.xhtml#aid-1R42S1 "Chapter 8. Automating
    Analysis with Processing Models"), *Automating Analysis with Processing Models*,
    opens.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing help and saving](img/image00518.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: This dialog is divided into three areas. On the top, there is a preview area.
    Here the current help content is displayed so that you can see in real-time mode
    how the final result will look. In the bottom-left part is the elements tree,
    where all the help sections are listed, including algorithm description, parameters,
    input, and other information. In the bottom-right part, there is an editing area.
    Here, we will enter the description of the corresponding element.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: To edit the description of the element, select it in the elements list and enter
    some text in the **Element** **description** field. To save the changes, just
    select another element in the elements tree.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Go through all the items in the elements tree and enter the descriptions. For
    example, for **Algorithm** **description**, you can use this text:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can describe all the other fields yourself. Try to be short and, at the
    same time, give as much useful information as possible. Don't explain obvious
    things; it's better to concentrate on important details. For example, in the description
    of the start and end points layers, it is worth mentioning that the number of
    features in them should be equal. When you're done, click on the **OK** button
    to close the **Help editor** dialog.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: To save the script help, click on the **Save** button on the **Script editor**
    toolbar. The script will be saved and its help will be written alongside, with
    the script file using the same name as used by the script with the addition of
    the `.help` suffix.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Sharing scripts
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have created a useful script that may help other users, it would be good
    to share it with the community so that others don't need to reinvent the wheel.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious and easiest way to share a Processing Python script is just
    to send it to those who are interested, or upload it to any file-sharing or hosting
    site and make the link to this file available to everyone. It is necessary to
    remember that in contrast to the models, script help is stored in a separate file,
    not in the script itself. So, you should not forget to include the script help
    file when uploading or sending.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: A slightly more complex way—but at the same time, very convenient and user-friendly—is
    to publish your script on the Processing models and scripts community repository.
    This repository was created in the spring of 2014, and provides a centralized
    way to share Processing scripts and models among QGIS users.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: To put your script into the repository, you need to fork the *GitHub* repository
    ([https://github.com/qgis/QGIS-Processing](https://github.com/qgis/QGIS-Processing)),
    commit your script and its help file in your fork in the scripts directory, and
    issue a pull request.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about Git, use one of Packt Publishing''s books, for example,
    *Git: Version Control for Everyone*, by Ravishankar Somasundaram, and refer to
    the GitHub documentation at [https://help.github.com/](https://help.github.com/).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to send the model to the Qgis-developer mailing list, or send
    it directly to one of Processing's developers and ask them to put it into the
    repository.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: To get scripts from this repository, use the **Get scripts from on-line script
    collection** tool, which is located in the **Tools** subgroup under the **Scripts**
    item in the **Processing** toolbox.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to develop your own Python scripts for the
    QGIS Processing framework and automate analysis with their help. Python scripts
    are an alternative to Processing''s models and give us more flexibility than models.
    You learned how to get information about available Processing algorithms and how
    to call them from the Python console. Then, you got to know the main parts of
    a Processing script: the header with meta-information and the script body. Finally,
    we developed a simple script to calculate the shortest path between two points
    for a given road network.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will get to know another way to extent the QGIS functionality—by
    developing your own Python plugin.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
