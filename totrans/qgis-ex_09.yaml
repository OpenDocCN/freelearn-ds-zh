- en: Chapter 9. Automating Analysis with Processing Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced the Processing Graphical modeler, and
    you learned how to use it to automate complex geoprocessing analyses. But this
    is not the only way to automate your work. QGIS's Processing framework also allows
    you to write your own scripts in Python and use them like any other algorithm
    later. This is what we will discuss in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Python scripts in Processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing help and saving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python scripts in Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have already learned how to create models and automate analysis tasks with
    the help of the graphical modeler from the QGIS Processing framework. Although
    the Processing modeler is user friendly and easy to use, it has some limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: In the models, you can use only algorithms that are already available in Processing.
    Moreover, some algorithms that are available from the Processing toolbox are not
    available in the modeler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no support for conditional statements and loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if you need to implement something more complex and advanced, you'll need
    another tool. Fortunately, the modeler is not the only way to automate analyses
    with Processing. Processing also allows us to combine its own power with the power
    of the Python programming language by developing Python scripts. Such scripts
    can then be used like any other algorithm from the Processing toolbox or modeler,
    or executed as batch processes.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing our scripts, it is necessary to understand how
    to use Processing algorithms from the QGIS Python console, because this knowledge
    is necessary for successful use of the existing Processing algorithms within scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the Python console by clicking on the ![Python scripts in Processing](img/image00513.jpeg)
    button on the **Plugins** toolbar. Alternatively, you can use the *Ctrl* + *Alt*
    + *P* keyboard shortcut or open it by going to **Plugins** | **Python Console**.
    A new dock widget will appear at the bottom of the QGIS window, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python scripts in Processing](img/image00514.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Python console consists of two main areas. At the top, there is the output
    area, where executed commands and their output will be printed. Below it is the
    input area, where you should enter the code to be executed. Here, code is entered
    line by line. There is also a toolbar on the left-hand side of the Python console.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to learn more about the Python console, click on the **Help** button
    from its toolbar and read the built-in documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Processing from the Python console, we should import it with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This line will load all Processing functions and make them available for us.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the available algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may want to run an existing Processing algorithm from your script instead
    of reimplementing its functionality yourself. To do this, it is necessary to get
    the name of that algorithm, which is not what you see in the toolbox, but a special
    name—the so-called command-line name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every algorithm in Processing has two names: a human-readable and user-friendly
    name that is used in the toolbox and modeler, and another internal command-line
    name that has no ambiguous characters in it, such as spaces, semicolons, and so
    on. It also contains information about the algorithm provider. Command-line names
    are unique.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all available Processing algorithms with their command-line names,
    run this Python console command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a very long output that might look like this (truncated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To the left, you can see human-readable algorithm names that are also used in
    the toolbox, and to the right are the corresponding command-line names.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the number of algorithms—even in a default QGIS installation—is really big,
    it may be difficult to find the command-line name of the desired algorithm. Fortunately,
    it is possible to reduce the output of the `alglist()` command. Just pass to it
    a string parameter representing a substring that should exist in the algorithm''s
    name. For example, to display only algorithms with the word `count` in their names,
    execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be much shorter, and it will be easy to find the algorithm
    you are looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we know how to get the command-line name of the required algorithm. But
    in order to run the algorithm, we will need to know some more information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information about an algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute an algorithm, we need not only its name but also the syntax. This
    includes information about the list of algorithm input and output, as well as
    the order in which they should be passed to the algorithm. All of this information
    can be obtained with the help of the `processing.alghelp()` command. This command
    accepts only one argument—the command-line algorithm name—and returns a list of
    algorithm inputs and outputs, with their types.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s look at the `Create grid` algorithm we used in previous
    chapters. Its command-line name is `qgis:creategrid` (you can easily check this
    using the information from the preceding section), so to get information about
    its syntax, we should execute the next command in the QGIS Python console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From this output, we can see that the human-readable algorithm name is `Create`
    `grid` and it accepts four input fields: `TYPE` (selection from a predefined list
    of values), `EXTENT` (the extent), `HSPACING`, and `VSPACING` (both of these are
    numbers). The algorithm has produced one vector output. The most interesting part,
    however, is below the parameters and outputs list; it''s the list of available
    values for the `TYPE` selection parameter. The numbers on the left are values
    that can be passed to the algorithm, and on the right, you can see the human-readable
    description of each value. For example, if you want to create a grid with the
    diamond cells, then it is necessary to pass a value of `2` to the `TYPE` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how different parameter types should be passed to the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raster or vector layer and tables** (`ParameterVector`, `ParameterRaster`,
    and `ParameterTable`): It is possible to specify the name of the corresponding
    layer or table, if that layer is already loaded in QGIS. Also, you can use the
    path to the layer file. Finally, it is possible to pass an instance of the corresponding
    QGIS class, for example, `QgsVectorLayer`. If this is an optional input and you
    don''t want to use it, just use the `None` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selection from predefined values** (`ParameterSelection`): This should be
    represented by the numerical index of the corresponding value. Mapping between
    values and indexes is displayed as part of the `processing.alghelp()` function
    output, as shown earlier. There is also a separate command for listing such matches—the
    `processing.algoptions()` function. This command accepts only one argument—the
    command-line name of the algorithm—and its output is a match between the option
    index and value for all algorithm parameters with the selection type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple input** (`ParameterMultipleInput`): This should be passed as a string
    delimited with semicolons (`;`). Each value can be a layer name or the path to
    the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field of the table** (`ParameterTableField`): This is just a string with
    the field name. Note that this values is case-sensitive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-defined table** (`ParameterFixedTable`): This is defined as a list of
    values separated by commas and enclosed in double quotes. Also, it is possible
    to pass a 2D list or array with the values; for example, a small 2 x 2 table can
    be passed as two-dimensional Python list, like this: `[[0, 1], [2, 3]]`. Keep
    in mind that values should start from the topmost row and go from left to right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordinate reference system** (`ParameterCrs`): Use the EPSG code of the
    corresponding CRS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extent** (`ParameterExtent`): This is represented as string containing the
    `xmin`, `xmax`, `ymin`, and `ymax` values delimited by commas (`,`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numerical** (`ParameterNumber`), **boolean** (`ParameterBoolean`)**, and
    string** (`ParameterString`) **parameters**: These are represented by the corresponding
    native Python data types: `int`, `float`, `boolean`, `str`, or `unicode`. Also,
    such parameters may have default values. To use them, specify `None` in the place
    of the corresponding parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For output data, the rules are much simpler. If you want to save a layer, table,
    file, or HTML output in a particular place, just pass a path to the file. In the
    case of raster and vector output, the extension of the file will determine the
    output format. If the given extension is not supported by the algorithm, the output
    will be saved in the default format (which depends on the algorithm), and the
    corresponding extension will be added to the specified file path. To write the
    output to a temporary file, pass the `None` value.
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to define any variables for numerical and string output when
    running an algorithm from the Python console. These will be calculated and returned
    automatically, without any actions from your side. See the *Executing the algorithm
    and loading the results* section of this chapter for more information about accessing
    such kinds of output.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the algorithm syntax and how to pass parameters to it, we
    can execute the algorithm from the QGIS Python console.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the algorithm and loading the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To execute the algorithm from the QGIS Python console, we need to use the `processing.runalg()`
    method. Generally, this method is called in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `algorithm_name` is the command-line algorithm name, `param1...paramN`
    are algorithm parameters, and `output1...outputM` are algorithm outputs. Parameters
    and outputs should be passed in the same order as shown by the `alghelp()` method,
    considering information about defining input and output from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned previously, you don't need to specify any variables for numeric,
    string, or boolean outputs.
  prefs: []
  type: TYPE_NORMAL
- en: If the algorithm reports its execution progress, a message bar with the progress
    indicator will be displayed in the main QGIS window during execution.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike algorithm execution from the toolbox, the `runalg()` method does not
    load any results into QGIS. You can load them manually with the help of the QGIS
    API or in the following way using the helper methods provided by Processing.
  prefs: []
  type: TYPE_NORMAL
- en: On successful execution of the algorithm, the `runalg()` method returns a dictionary
    in which the output names (as shown by the `alghelp()` method) are the keys and
    their values are paths to the generated files or contain calculated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a generated raster or vector layer, pass the path to the corresponding
    file to the `load()` method. For example, if the result of algorithm execution
    is saved in the `res` variable and the output name is `OUTPUT`, then to load this
    layer into QGIS, execute this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, the layer will be loaded into QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: To access numeric or string output in the results dictionary, just use the corresponding
    key names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load data from the Brooklyn tree cadastre (this is the `trees` layer
    in our dataset), and try to understand how the next small example works and what
    it does. Run these commands in the QGIS Python console one by one. If necessary,
    use the `processing` helper methods, such as `alglist()` and `alghelp()`, and
    examine the results by printing them or loading into QGIS, as mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you have read the previous sections carefully, you should understand that
    these commands are used to generate a hexagonal density map from the point layer.
    In the first line, we import the `processing` module with all its algorithms.
    In the second line, the `Create grid` algorithm is executed, and it creates a
    hexagonal grid (a parameter with value equal to `3` represents hexagonal grid
    type) using the extent of the `trees` layer and cell size equal to `1000`. The
    result is saved in a temporary file, as we pass the `None` value as the last argument.
    In line `3`, the algorithm `Count points in polygon` is executed. As a polygon
    layer, it uses an output of the `Create grid` algorithm (`resGrid['OUTPUT']`),
    and as point layer, already opened trees layer in QGIS is used. Again, the result
    is stored in the temporary file. Then, in line `4`, the `Extract by attribute`
    algorithm is called to save only nonempty cells (a parameter with value `1` corresponds
    to the not equal to operator, `!=`). With the last line, the final result is loaded
    into QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that you know how to get all of the necessary information about Processing
    algorithms and can use them from the QGIS Python console, we can dive into Processing
    script development.
  prefs: []
  type: TYPE_NORMAL
- en: Defining inputs and outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already said, despite models, you can create your own Processing
    scripts using the Python programming language. Basically, Processing script is
    Python code plus some additional metadata required by Processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Processing script starts with a special block of metadata. This information
    is needed by Processing to register a script as an algorithm and use it from the
    toolbox, modeler, and so on. Each metadata entry is placed on a new line, starting
    with the double Python comment symbol (`##`), and has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Metadata items can be divided into three groups: items that describe the script,
    items that describe script input, and items that describe script output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only three items that describe the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`group`: This is used to define the name of the subgroup inside the **Scripts**
    group in the toolbox where the script will be shown. For example, if you put the
    following line `##Density maps=group` into the script header, it will be placed
    under the **Density** maps subgroup. If this item is omitted, the script will
    be placed under the **Scripts** subgroup, which is under **User**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This defines the script name. By default, the script name is generated
    from the name of the script file by dropping the extension and replacing underscores
    with spaces. If you don''t want to use long, descriptive filenames for your scripts
    but still want nice names in the Processing toolbox, use the `name` metadata item.
    Its syntax is the same as that in the `group` item, for example, `##Hexagonal
    density map=name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nomodeler`: This item is a flag. Scripts with such metadata can be used only
    from the toolbox. They will be not available in the modeler. Its usage is like
    this: `##nomodeler`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of metadata items that are used to describe script input is a much
    larger. Scripts support almost all inputs available in Processing. It is necessary
    to mention that the item name will also be a variable name, and it can be used
    in the script code. The value entered or selected by the user while executing
    the script will be assigned to the corresponding variable.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the item name will be used as as the caption for the corresponding widget
    in the algorithm execution dialog. To improve appearance, underscores will be
    replaced by spaces. So, if you have an item with the name `My_cool_parameter`
    in the script, then its widget will have a caption as **My** **cool** **parameter**.
    To access the value of this parameter, we need to use the `My_cool_parameter`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the available input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`raster`: This describes the input raster layer. Here is a usage example: `##Raster_layer=raster`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector`: This describes the input vector layer. Note that this item should
    be used if your script accepts vector layers with any geometry type—point, line
    or polygon. If you want to limit the supported geometry types, use one of the
    following items. An example of its usage is `##Vector_layer=vector`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector point`: This describes the input point vector layer. This item will
    accept only layers with point geometry. Note that such a limitation is applied
    only to layers that are already loaded into QGIS. If the user wants to specify
    a file from the disk, it is their responsibility to select the layer with the
    correct geometry type. Its usage is like this: `##Vector_layer=vector point`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector line`: This describes the input line vector layer. This item will accept
    only vectors with line geometry. Again, note that such a limitation is applied
    only to layers that are already loaded into QGIS. If the user wants to specify
    a file from the disk, it is their responsibility to select the layer with the
    correct geometry type. Its usage is like this: `##Vector_layer=vector line`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector polygon`: This describes the input polygon vector layer. This item
    will accept only vectors with polygon geometry. Once again, note that such a limitation
    is applied only to layers that are already loaded in QGIS. If the user wants to
    specify a file from the disk, it is their responsibility to select the layer with
    the correct geometry type. An example usage is as follows: `##Vector_layer=vector
    polygon`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`table`: This is used to define an input geometryless table. Its usage is like
    this: `##Table_to_join=table`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple raster`: This is used to define a compound input that consists of
    several raster layers. An example usage is as follows: `##Layers_to_mosaic=multiple
    raster`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple vector`: This is used to define compound input that consists of several
    vector layers. Note that this input allows us to select any vector layer, regardless
    of its geometry type. Its usage is like this: `##Layers_to_merge=multiple vector`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection`: This describes selection from a list of predefined values. The
    values specified after the item type are separated by semicolons. An example usage
    is as follows: `##Method=selection Nearest neighbor;Average;Cubic`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`: This defines a Boolean (also often called logical) input. It is
    necessary to specify a default value. Its usage is like this: `##Smooth_results=boolean
    False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extent`: This defines the input extent. Its usage is like this: `##Grid_extent=extent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file`: This is used to define an input file (in text or in any other format
    that cannot be recognized by Processing as raster, vector, or table). An example
    usage is as follows: `##Index_data=file`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`folder`: This describes the input directory. Its usage is like this: `##Input_directory=directory`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: This defines a numerical (integer or floating-point) input. It is
    necessary to specify a default value. If the default value does not have a decimal
    separator, then the parameter will accept only integer values. Currently, it is
    not possible to define minimum and maximum limits for such parameters in scripts.
    An example usage is as follows: `##Width=number 1000.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`field`: This describes an attribute field in the vector layer or geometryless
    table. It is necessary to specify the name of the corresponding input that represents
    the parent layer or table. For example, if a vector layer is defined as `##Input_layer=vector`,
    then the field of this layer will be defined as `##Classification_field=field
    Input_layer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: This is used to define a string input. It is necessary to specify
    a default value. Its usage is like this: `##Field_name=string NUMPOINTS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longstring`: This defines a multiline string input. It is necessary to specify
    a default value. An example of its usage is as follows: `##Options=longstring
    my cool options`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crs`: This describes the coordinate reference system. By default, EPSG:4326
    is used. If you want another default CRS, specify its `EPSG` code. Its usage is
    like this: `##Assign_CRS=crs EPSG:3857`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input layers and tables are always passed to the script as strings containing
    paths to the corresponding files. To create a QGIS object (`QgsVectorLayer` or
    `QgsRasterLayer`) from such a string, we need to use the `processing.getObjectFromUri()`
    function. Multiple raster or vector inputs are also passed as strings that contain
    paths to individual files separated by semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are all the available outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`output raster`: This represents the raster layer generated by the script.
    Its usage is like this: `##NDVI_raster=output raster`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output vector`: This represents the vector layer generated by the script.
    An example of its usage is as follows: `##Vector_grid=output vector`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output table`: This represents a geometryless table generated by the script.
    This can be, for example, a CVS or DBF table. Its usage is like this: `##Nearest_points=output
    table`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output html`: This describes the output in HTML format. Such an output is
    mainly used for different textual reports that may or may not include graphics.
    An example of its usage is as follows: `##Statistics=output html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output file`: This is used for files in formats different from HTML and all
    others supported by QGIS formats. For example, these can be plain text files,
    LiDAR data, and so on. Its usage is like this: `##Points_connection=output file`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output directory`: This describes the output directory. It is mainly used
    for algorithms that produce many files, for example, when splitting the vector
    layer by attribute values. An example of its usage is as follows: `##Splitted_files=output
    directory`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that currently, Processing cannot load files from such output directories,
    even if these files are in the supported format. You need to manually open each
    file from the output directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`output number`: This represents a numerical value generated by the algorithm.
    This value not saved anywhere and can only be used as the input in another algorithm.
    For example, one can implement script to calculate optimal cell size for the vector
    grid, then the numerical output from such algorithm can be used as input in the
    Create grid algorithm. An example of its usage is as follows: `##Maximum_value=output
    number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output string`: This is similar to the output number described previously.
    It represents a string literal generated by the algorithm. Its usage is like this:
    `##Select_condition=output string`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical and string outputs are also called hidden outputs (because they are
    not shown in QGIS and in Processing's results dialog), and are not automatically
    initialized with values. You should manually assign the corresponding values to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: All other output will always be a string value with the path to the corresponding
    output file or directory. If user does not specify any filename, then the output
    will be saved to the automatically created temporary file, and the name of this
    file will be used as the output value.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that after successful algorithm execution, Processing
    will automatically load all output files in the supported formats. So, you don't
    need to add any `processing.load()` function calls to your script.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, when we know how to define input and output, we are ready to develop Python
    scripts for Processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to create a script:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your favorite text editor or IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Processing's built-in code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which method to use is a matter of taste and habits. In this book, we will use
    the built-in script editor. You can open it from the Processing toolbox. Locate
    and expand the **Scripts** group, expand the **Tools** subgroup, and double-click
    on the **Create new script** item. Alternatively, you can start typing `Create
    new script` in the filter field. The toolbox's content will be filtered, and you
    can easily locate the corresponding item.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the algorithm](img/image00515.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **Script editor** looks like an ordinary text editor as shown in the preceding
    screenshot. There is a toolbar at the top, and all of the remaining area is used
    up by the editor itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will see how to create Processing Python scripts by developing a script
    to find the shortest path between two points on the road network. Such an analysis
    is very common in many areas of application such as infrastructure planning, trip/travel
    planning, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: QGIS has a simple built-in network analysis library that allows us to find the
    shortest path between two points using **Dijkstra's algorithm**, and also perform
    some other interesting things, such as building areas of accessibility (also known
    as service areas) and matching points to the nearest lines.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to determine the script input and output. As input, we need a
    roads layer, a start point, and an end point. As Processing does not support points
    as input, the simplest workaround is to pass two vectors, one for the start point
    and the other for the end point. This solution also allows us to define multiple
    start and end points and find the shortest path between each pair of start and
    end points. As for the output, our script obviously will have only one output—a
    vector layer with the shortest path (or paths) calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the script header will look like this. If you have read the previous sections
    carefully, you should have no problem understanding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the first two lines, we define the group where our script will be placed
    and the script name. Then, we define the input and output. Note that we use precise
    definitions for input vector layers, so that when the user runs the script in
    the input comboboxes, they will see only layers with the geometry type that matches
    the parameter definition. For example, in the Road layer combobox only line vector
    layers will be listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the script header, a script body starts. It contains Python code that
    implements the desired algorithm. The script body can be divided into two parts:
    the import section and the code itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Only very simple scripts can be implemented by using Python's basic commands
    alone. Any more or less complex algorithm will require additional classes or libraries,
    for example, from the Python standard library, QGIS and Processing libraries,
    or even some third-party packages. To use these libraries in your code, you need
    to import them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, this is done on an iterative basis: you write the code, and when a
    new class or library is needed, add the corresponding import statement. As a rule,
    all import statements are placed at the very beginning of the source''s file.
    For the sake of simplicity, in our sample script, we will provide all the necessary
    imports from the start. The corresponding code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all imports are divided into three logical blocks with empty
    lines between them. In the first line, we import the `QVariant` class from the
    `QtCore` package of the `PyQt4` library. This class contains the definition of
    the universal variant data type, which will be used to declare attributes of the
    vector layer.
  prefs: []
  type: TYPE_NORMAL
- en: In the second block, we import various non-GUI classes from the QGIS core library
    (the first line of the block) and the QGIS network analysis library (the second
    line of the block). We need these QGIS core classes to construct our output vector
    features representing the shortest paths. Moreover, classes from the QGIS network
    analysis library provide us with all that is necessary for performing network
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last block, we import some classes from different modules of
    the QGIS Processing framework. The `GeoAlgorithmExecutionException` class will
    be used to raise exceptions from our script, and `VectorWriter` is a helper class
    that allows us to easily write output vector data in any QGIS-supported format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can implement the algorithm itself. As you learned in previous sections,
    all our inputs—the roads layer, as well as layers with the start and end points—are
    passed in the form of paths to the corresponding files, so it is necessary to
    create layer objects from them for further usage. This done with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use the `getObjectFromUri()` function from the processing package. It accepts
    the path to the file or any other URI and returns a valid layer (raster or vector,
    depending on the URI) from it. Note that we specify the names of the inputs defined
    in the script header as arguments in the `getObjectFromUri()` function calls.
    As we have already mentioned in the *Defining inputs and outputs* section, the
    representing input value has the same name as the corresponding input.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we use separate layers for start and end points, it is necessary to verify
    that both the layers have the same number of features because if the number of
    points is different, it will be impossible to create start-point-end-point pairs;
    some points will be without pairs. Here is the code for such a check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We use the `featureCount()` method to get the number of features in the layers
    with the start and end points and compare them. If the numbers are not equal,
    an exception is raised and algorithm execution is aborted.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always raise `GeoAlgorithmExecutionException` when you need to abort script
    execution because of any error. In this case, the user will see a standard dialog
    with an error message, and also the error will be stored in the log.
  prefs: []
  type: TYPE_NORMAL
- en: Often, algorithms need some time to complete, so it is good practice to inform
    the user about the progress of execution and provide some information about the
    completed steps so that the user will know that the program has not frozen. To
    do this, each algorithm in Processing provides a special `progress` object. With
    its help, you can easily display different types of messages to the user (information,
    debug, ordinal text, and so on), as well as show the progress of execution with
    the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our script is no exception. There are several potentially long-running tasks
    that should be performed during the analysis. The first is collecting the coordinates
    of all start and end points from the corresponding layers. These coordinates will
    be used later in the step of road graph generation. The corresponding code is
    given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we show the user an information message with the `progress.setInfo()`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are also separate commands for displaying plain text (`setText()`), debug
    information (`setDebugInfo()`), console output (`setConsoleInfo()`), and other
    message types.
  prefs: []
  type: TYPE_NORMAL
- en: This message will be displayed in the **Log** tab of the algorithm dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Then we use an iterator on the features of the layer with the start points,
    extract the geometry of each feature, convert it into a `QgsPoint` instance, and
    store it in the `points` list.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same approach, we create another list, called `tmp`, with the data
    from the layer containing our end points. In the last line, we merge these two
    lists into one, so our `points` list will contain the start points and then the
    end points. We need to put all the points in a single list because later, all
    the points will have to be tied to our road network. This operation is performed
    for all points at once and at the same time as graph creation. As the number of
    points in both layers is equal, we can easily access pairs of the start and end
    points using very simple math. Assuming that the number of points in each layer
    is *N* and knowing that list indexes in Python start with *0*, we can say that
    the start points will have indexes from *0* to *N-1*, while the end points will
    have indexes will be from *N* to *2N-1*. So, if we know the index of a start point,
    it is easy to get the index of the corresponding end point by adding the total
    number of points in any input layer to the index of the start point.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our script will produce an output vector layer, it is necessary to prepare
    a special object for saving features in it. Fortunately, Processing has the `VectorWriter`
    class, which provides us with a convenient way to save vector data in any OGR-supported
    format or QGIS memory layer, without writing many lines of code. Here is the code
    for creating such a writer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first five lines of code here, we create an instance of the `QgsFields`
    container, where our attributes'' definitions will be saved, and populate it.
    Our example script output layer will have four attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the integer numeric identifier of the path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startPoint`: These are the coordinates of the start point of the path in the
    (*x*, *y*) format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endPoint`: These are the coordinates of the end point of the path in the (*x*,
    *y*) format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`: This is the total length of the path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last line, an instance of the `VectorWriter` class was created. We pass
    the paths to the output file defined by the user, the list of attributes that
    we created previously, the geometry type, and the coordinate reference system
    to the constructor. Note that as the path to the output file, we specify the same
    variable that we used in the script header to describe the output. Also, the coordinate
    reference system is taken from the input roads layer, so our output will be in
    the same CRS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all the preparation steps needed for now are done, and now we can use
    the QGIS network analysis library to create a graph from our roads layer. This
    step is required because network analysis operates with the graph and not with
    the vector layer. Before creating the graph, it is necessary to instantiate all
    the required classes and adjust the settings. The following lines of code show
    you how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we instantiate the so-called director, which is a base class that adjusts
    some settings of the graph creation process. The director accepts the parameters
    explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: The line vector layer from which a graph will be constructed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of the attribute field where the road's direction is stored. As we
    don't take road directions into account, we'll pass `-1` here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attribute value that represents the direct road direction for one-way roads.
    Direct direction means that you can move on such a road only from the start point
    to the end point of the road. In our example, we won't use direction information,
    so we pass an empty string here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attribute value that represents the reverse road direction for one-way roads.
    When a road has reverse direction, you can only move from the end point to the
    start point of the road. In our example, we won't use direction information, so
    we pass an empty string here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The attribute value that represents bidirectional, or two-way, roads. Bidirectional
    roads are the most common roads. They allow us to move in both directions: from
    the start to the end, and from the end to the start. In our example, we don''t
    use direction information, so again we pass an empty string here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default road direction. This argument defines how to treat roads that have
    no direction information in the field specified by the first argument. It can
    be one of these values: `1` for direct direction, `2` for reverse direction, and
    `3` for bidirectional roads. For the sake of simplicity, we will treat all roads
    as two-way roads, so we will use the value `3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shortest path between two points can be calculated using different criteria
    (in the QGIS network analysis library, these are called properters) or even their
    combination—length, travel time, travel cost, and so on. There is only one built-in
    criteria for now in the network analysis library—`QgsDistanceArcProperter`—which
    takes the road length into account. Of course, we can add our own criteria, but
    for the sake of simplicity in our demo script, we will use a built-in criteria.
    The properter is instantiated in the second line and added to the already created
    director in the third line.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth line, we create the so-called builder—a class that generates a
    graph using settings specified by the director. The only argument that we pass
    to the builder is the coordinate reference system we want to use. Usually, this
    is the same CRS as that of the input road layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all the settings are done, we can create the graph, which will be
    used to find the shortest path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As graph generation is a time-consuming operation, especially on a dense road
    network and for a large number of start and end points, we show an information
    message to the user before generating the graph itself.
  prefs: []
  type: TYPE_NORMAL
- en: The most important line in this snippet is the second one, where the `makeGraph()`
    method is called. The arguments are `builder`, which holds all the settings for
    the process of graph generation, and `points`, which is a list of our start and
    end points. As points may not be located exactly on the road, it is necessary
    to match them to the nearest road link. This happens in the same step as graph
    creation, and the `makeGraph()` method returns a list of so-called tied points,
    or in other words, points that are placed exactly on the nearest road segment.
  prefs: []
  type: TYPE_NORMAL
- en: In the third line, we get the graph object itself from the builder and store
    it for further usage. As we don't need the original points now (all further work
    will be done with the tied points), we delete them in the last line to free the
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about the QGIS network analysis library is available in *PyQGIS
    Developer Cookbook* at [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our road graph and points matched to the nearest road links,
    we can start finding the shortest path for each start-point-end-point pair. But
    first, we need to perform some helper actions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines are used to prepare values for progress reporting. The progress
    bar displays values from `0` to `100` percent, and we need to process `count`
    pairs of points (equal to the number of features in any input point layer). Then,
    a single step value will be equal to `100` divided to the number of pairs.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two lines, we just prepare a vector feature instance for our output
    routes and assign previously defined attributes to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding the shortest path is done in the loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we inform the user about next algorithm step. In lines `3`
    and `4`, we get the next pair of the start and end points from the list of tied
    points. In the next two lines, indexes of these points on the road graph are obtained.
  prefs: []
  type: TYPE_NORMAL
- en: In line 8, the actual route calculation takes place. The `dijkstra()` method
    returns a tree with the shortest path from the tree root defined by the point
    with the `idxStart` index (this is our start point from the current point pair)
    to all other graph nodes.
  prefs: []
  type: TYPE_NORMAL
- en: From lines `10` to `23`, we go through the shortest path tree and collect all
    the points that form a way from the end point to the start point.
  prefs: []
  type: TYPE_NORMAL
- en: After that, from lines `25` to `30`, we create a line geometry from the collected
    points, assign it to the feature, and also set its attributes. Then the feature
    is passed to the writer object and stored in the output layer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in line `32`, we update the progress bar to inform the user about the
    algorithm's execution status.
  prefs: []
  type: TYPE_NORMAL
- en: 'When all the point pairs are processed, we need to carry out a cleanup and
    delete unused objects, such as the road graph and output writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! Now you can save the script and test it by clicking on the **Run**
    algorithm button on the **Script** **editor** toolbar. The algorithm dialog will
    look like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the algorithm](img/image00516.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can load the `roads`, `start_points`, and `end_points` layers from your
    dataset and run the algorithm with this data. Alternatively, you can use your
    own layer with a road network, create two point layers for start and end points,
    populate them with features, and execute the script. Here is what the results
    may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the algorithm](img/image00517.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is necessary to mention that while the QGIS network analysis library provides
    all the necessary tools for network analysis and can easily be extended by the
    user, it also has some limitations and is not suitable for work with very large
    and dense road networks. For such situations, it is better to use more powerful
    tools, such as pgRouting.
  prefs: []
  type: TYPE_NORMAL
- en: Writing help and saving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the case of model, it is good practice to document your scripts. A script's
    documentation contains its description as well as information about all inputs
    and outputs. This helps users to understand the purpose of the script.
  prefs: []
  type: TYPE_NORMAL
- en: To create a help file for the script, open it in the built-in Processing script
    editor and click on the **Edit** **script** **help** button on the editor toolbar.
    A **Help** editor dialog, familiar to us from the *Filling model metadata and
    saving* section of [Chapter 8](part0062.xhtml#aid-1R42S1 "Chapter 8. Automating
    Analysis with Processing Models"), *Automating Analysis with Processing Models*,
    opens.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing help and saving](img/image00518.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This dialog is divided into three areas. On the top, there is a preview area.
    Here the current help content is displayed so that you can see in real-time mode
    how the final result will look. In the bottom-left part is the elements tree,
    where all the help sections are listed, including algorithm description, parameters,
    input, and other information. In the bottom-right part, there is an editing area.
    Here, we will enter the description of the corresponding element.
  prefs: []
  type: TYPE_NORMAL
- en: To edit the description of the element, select it in the elements list and enter
    some text in the **Element** **description** field. To save the changes, just
    select another element in the elements tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go through all the items in the elements tree and enter the descriptions. For
    example, for **Algorithm** **description**, you can use this text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can describe all the other fields yourself. Try to be short and, at the
    same time, give as much useful information as possible. Don't explain obvious
    things; it's better to concentrate on important details. For example, in the description
    of the start and end points layers, it is worth mentioning that the number of
    features in them should be equal. When you're done, click on the **OK** button
    to close the **Help editor** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: To save the script help, click on the **Save** button on the **Script editor**
    toolbar. The script will be saved and its help will be written alongside, with
    the script file using the same name as used by the script with the addition of
    the `.help` suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have created a useful script that may help other users, it would be good
    to share it with the community so that others don't need to reinvent the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious and easiest way to share a Processing Python script is just
    to send it to those who are interested, or upload it to any file-sharing or hosting
    site and make the link to this file available to everyone. It is necessary to
    remember that in contrast to the models, script help is stored in a separate file,
    not in the script itself. So, you should not forget to include the script help
    file when uploading or sending.
  prefs: []
  type: TYPE_NORMAL
- en: A slightly more complex way—but at the same time, very convenient and user-friendly—is
    to publish your script on the Processing models and scripts community repository.
    This repository was created in the spring of 2014, and provides a centralized
    way to share Processing scripts and models among QGIS users.
  prefs: []
  type: TYPE_NORMAL
- en: To put your script into the repository, you need to fork the *GitHub* repository
    ([https://github.com/qgis/QGIS-Processing](https://github.com/qgis/QGIS-Processing)),
    commit your script and its help file in your fork in the scripts directory, and
    issue a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about Git, use one of Packt Publishing''s books, for example,
    *Git: Version Control for Everyone*, by Ravishankar Somasundaram, and refer to
    the GitHub documentation at [https://help.github.com/](https://help.github.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to send the model to the Qgis-developer mailing list, or send
    it directly to one of Processing's developers and ask them to put it into the
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: To get scripts from this repository, use the **Get scripts from on-line script
    collection** tool, which is located in the **Tools** subgroup under the **Scripts**
    item in the **Processing** toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to develop your own Python scripts for the
    QGIS Processing framework and automate analysis with their help. Python scripts
    are an alternative to Processing''s models and give us more flexibility than models.
    You learned how to get information about available Processing algorithms and how
    to call them from the Python console. Then, you got to know the main parts of
    a Processing script: the header with meta-information and the script body. Finally,
    we developed a simple script to calculate the shortest path between two points
    for a given road network.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will get to know another way to extent the QGIS functionality—by
    developing your own Python plugin.
  prefs: []
  type: TYPE_NORMAL
