- en: Chapter 1. Your First Mapping Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 你的第一个地图应用
- en: Let's say you have a map. You've digitized it using ArcGIS Desktop, a sort of
    desktop mapping and analysis software provided by ESRI. You've gone through the
    painstaking process of plotting points, connecting lines, and checking the boundaries
    of polygons. You've added nice background aerial imagery, and you've applied all
    the parts that make a map readable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一张地图。你已经使用 ESRI 提供的一种桌面地图和数据分析软件 ArcGIS Desktop 对其进行了数字化处理。你已经经历了绘制点、连接线和检查多边形边界的繁琐过程。你已经添加了漂亮的背景航空影像，并应用了使地图可读的所有部分。
- en: How are you going to share this map with the general public? You could post
    it in the public information office, but citizens have complained about that location
    being too remote, and down too many flights of stairs underground. You could make
    a thousand printed copies, but that would be terribly expensive.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何与公众分享这张地图呢？你可以在公共信息办公室张贴它，但市民们抱怨说那个地方太偏远，而且地下有太多的楼梯。你也可以制作一千份印刷品，但这会非常昂贵。
- en: If you have the **ArcGIS Server** software running and connected to a web server,
    you can publish your map online, and serve it through a website running with the
    **ArcGIS JavaScript API** ([http://developers.arcgis.com/javascript](http://developers.arcgis.com/javascript)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行并连接到 Web 服务器的 **ArcGIS Server** 软件，你可以将你的地图在线发布，并通过运行 **ArcGIS JavaScript
    API** 的网站提供服务（[http://developers.arcgis.com/javascript](http://developers.arcgis.com/javascript)）。
- en: The ArcGIS JavaScript API is a JavaScript library that works with ArcGIS Server
    to connect the map maker with the general public. The map maker can use an ESRI
    product, such as ArcMap, to generate a map document. That map maker can then publish
    the map document through ArcGIS Server. From there, a web page that has been loaded
    with the ArcGIS JavaScript API can draw the map in the browser, and let the general
    public pan, identify, and interact with the map.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API 是一个与 ArcGIS Server 一起工作的 JavaScript 库，它将地图制作者与公众连接起来。地图制作者可以使用
    ESRI 的产品，例如 ArcMap，来生成地图文档。然后，该地图制作者可以通过 ArcGIS Server 发布地图文档。从那里，加载了 ArcGIS JavaScript
    API 的网页可以在浏览器中绘制地图，并让公众平移、识别和与地图交互。
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The requirements for creating a web mapping application using ArcGIS Server
    and the ArcGIS API for JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ArcGIS Server 和 ArcGIS API for JavaScript 创建网络地图应用的要求
- en: The HTML head and body content necessary to serve maps with the JavaScript API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript API 提供的 HTML head 和 body 内容来服务地图
- en: How to create a map with the ArcGIS JavaScript API and add content
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 ArcGIS JavaScript API 创建地图并添加内容
- en: How to make a map interactive
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何制作一个交互式地图
- en: Features of the API
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 的功能
- en: The ArcGIS JavaScript API provides many of the tools necessary to build robust
    web map applications. It can generate **slippy** maps, interactive maps that let
    the user pan and zoom in. The behavior is similar to Google or Bing Maps, but
    with your data. You're in control of the content, from background imagery to markers
    and popup content. With ArcGIS Server, you have control over how the maps are
    laid out, and which colors, styles, and fonts you use. The API also comes with
    custom elements that let you do everything from drawing on the map, searching
    for data, measuring things on the map, and printing the map in multiple formats.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API 提供了许多构建健壮网络地图应用所需的工具。它可以生成**可滑动**的地图，即允许用户平移和缩放的交互式地图。其行为类似于
    Google 或 Bing 地图，但使用的是你的数据。你控制着内容，从背景影像到标记和弹出内容。使用 ArcGIS Server，你可以控制地图的布局方式，以及你使用的颜色、样式和字体。该
    API 还附带了一些自定义元素，允许你从在地图上绘制、搜索数据、在地图上测量事物到以多种格式打印地图等一切操作。
- en: The ArcGIS JavaScript API is built on top of the **Dojo** framework ([www.dojotoolkit.org](http://www.dojotoolkit.org)).You
    also have access to an extensive package of free HTML form elements, controls,
    and layout elements for your web applications because Dojo comes packaged with
    the API. These Dojo user controls have been tested in multiple browsers, and include
    an entire library of items that can be used to make a mobile application. While
    the ArcGIS JavaScript API is built with Dojo, it also works well with other libraries
    such as jQuery and AngularJS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API 是基于 **Dojo** 框架构建的 ([www.dojotoolkit.org](http://www.dojotoolkit.org)).
    由于 Dojo 与 API 一起打包，您还可以访问一个广泛的免费 HTML 表单元素、控件和布局元素库，用于您的 Web 应用程序。这些 Dojo 用户控件已在多个浏览器中进行了测试，并包括一个完整的库，可用于制作移动应用程序。虽然
    ArcGIS JavaScript API 是用 Dojo 构建的，但它也与 jQuery 和 AngularJS 等其他库很好地协同工作。
- en: The ArcGIS JavaScript API was designed and built, along with an ArcGIS API,
    for Flash and Silverlight. Unlike other APIs which require specialized compilers,
    plugins, and related software, the ArcGIS JavaScript API can be written with a
    simple text editor and viewed on most common browsers without any special plugins.
    Since mobile browsers, such as Safari for iPad and Chrome for Android, do not
    support third party plugins, the ArcGIS JavaScript API is the preferred choice
    for creating interactive map websites for the mobile platform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API 是与 ArcGIS API 一起设计和构建的，用于 Flash 和 Silverlight。与其他需要专用编译器、插件和相关软件的
    API 不同，ArcGIS JavaScript API 可以用简单的文本编辑器编写，并在大多数常见浏览器上查看，无需任何特殊插件。由于移动浏览器，如 iPad
    的 Safari 和 Android 的 Chrome，不支持第三方插件，因此 ArcGIS JavaScript API 是创建移动平台交互式地图网站的优选选择。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Now, it is possible to code a website using Windows Notepad, just like it's
    possible to hike up Mount Everest without a guide. But when things go wrong, you
    will probably want to use a free text editor with syntax highlighting and other
    features, such as NotePad++ ([http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)),
    Aptana Studio 3 ([http://www.aptana.com/products/studio3.html](http://www.aptana.com/products/studio3.html)),
    or Visual Studio Code ([http://code.visualstudio.com](http://code.visualstudio.com))
    for Windows, Brackets ([http://brackets.io](http://brackets.io)) or Textmate ([http://macromates.com/](http://macromates.com/))
    for Mac, or Kate ([http://kate-editor.org/](http://kate-editor.org/)), Emacs ([http://www.gnu.org/software/emacs/](http://www.gnu.org/software/emacs/)),
    or vim ([http://www.vim.org/](http://www.vim.org/)) for Linux. If you want text
    editors that aren't free, but offer more features and support, you can check out
    Sublime Text ([http://www.sublimetext.com/](http://www.sublimetext.com/)) or Webstorm
    ([http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Windows Notepad 编写网站代码成为可能，就像在没有向导的情况下攀登珠穆朗玛峰一样。但一旦出现问题，您可能会想使用具有语法高亮和其他功能的免费文本编辑器，例如
    NotePad++ ([http://notepad-plus-plus.org/](http://notepad-plus-plus.org/))、Aptana
    Studio 3 ([http://www.aptana.com/products/studio3.html](http://www.aptana.com/products/studio3.html))
    或 Visual Studio Code ([http://code.visualstudio.com](http://code.visualstudio.com))，适用于
    Windows；Brackets ([http://brackets.io](http://brackets.io)) 或 Textmate ([http://macromates.com/](http://macromates.com/))，适用于
    Mac；Kate ([http://kate-editor.org/](http://kate-editor.org/))、Emacs ([http://www.gnu.org/software/emacs/](http://www.gnu.org/software/emacs/))
    或 vim ([http://www.vim.org/](http://www.vim.org/))，适用于 Linux。如果您想使用不免费但提供更多功能和支持的文本编辑器，可以查看
    Sublime Text ([http://www.sublimetext.com/](http://www.sublimetext.com/)) 或 Webstorm
    ([http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/))。
- en: The ArcGIS JavaScript API community
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API 社区
- en: The ArcGIS JavaScript API has an active community of developers who are willing
    to help you along the way. ESRI has blogs where they post updates, and host meetups
    in various cities across the country and around the globe. Many ArcGIS JavaScript
    developers, both inside and outside of ESRI, are active on Twitter and other social
    media outlets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API 拥有一个活跃的开发者社区，他们愿意在您学习过程中提供帮助。ESRI 有博客，在那里他们发布更新，并在全国乃至全球的各个城市举办聚会。许多
    ArcGIS JavaScript 开发者，无论是 ESRI 内部还是外部，都在 Twitter 和其他社交媒体平台上非常活跃。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find many resources to help you learn about the ArcGIS JavaScript API
    through books and the web. For books, you can check out *Building Web and Mobile
    ArcGIS Server Applications with JavaScript* by Eric Pimpler, *Building Web Applications
    with ArcGIS* by Hussein Nasser, and *ArcGIS Web Development* by Rene Rubalcava.
    For online resources, you can visit ESRI GeoNet ([https://geonet.esri.com/community/developers/content](https://geonet.esri.com/community/developers/content)),
    view the arcgis-javascript-api tag on GIS StackExchange ([http://gis.stackexchange.com/questions/tagged/arcgis-javascript-api](http://gis.stackexchange.com/questions/tagged/arcgis-javascript-api)),
    or visit the ESRI GitHub page ([https://github.com/esri](https://github.com/esri)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过书籍和网站找到许多资源来帮助您学习ArcGIS JavaScript API。对于书籍，您可以查阅Eric Pimpler的《Building
    Web and Mobile ArcGIS Server Applications with JavaScript》，Hussein Nasser的《Building
    Web Applications with ArcGIS》，以及Rene Rubalcava的《ArcGIS Web Development》。对于在线资源，您可以访问ESRI
    GeoNet（[https://geonet.esri.com/community/developers/content](https://geonet.esri.com/community/developers/content)），查看GIS
    StackExchange上的arcgis-javascript-api标签（[http://gis.stackexchange.com/questions/tagged/arcgis-javascript-api](http://gis.stackexchange.com/questions/tagged/arcgis-javascript-api)），或访问ESRI
    GitHub页面（[https://github.com/esri](https://github.com/esri)）。
- en: Our first Web Map
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一张Web地图
- en: 'Now that the introductions are out of the way, we should begin working with
    the API. In this chapter, we''re going to look at some code that will make a simple,
    interactive map. The example will be a single-page application, with all the styling
    and coding on the same page. In the real world, we would want to separate those
    into separate files. For this example, this is what the project is comprised of:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在介绍部分已经结束，我们应该开始使用API进行工作了。在本章中，我们将查看一些代码，这些代码将创建一个简单的交互式地图。示例将是一个单页应用程序，所有的样式和编码都在同一页上。在现实世界中，我们希望将这些内容分别存放在不同的文件中。对于这个示例，项目由以下内容组成：
- en: Setting up an HTML5 web page
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置HTML5网页
- en: Adding the necessary styling and the ArcGIS JavaScript library
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加必要的样式和ArcGIS JavaScript库
- en: Framing out our HTML content
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架我们的HTML内容
- en: Setting up a script to create a map
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置创建地图的脚本
- en: Loading a layer file
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载图层文件
- en: Adding a click event that collects data from the map service
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加点击事件以从地图服务收集数据
- en: Displaying that data on the map
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上显示这些数据
- en: Our assignment
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的作业
- en: We've just been asked by the Y2K historical society to make an interactive map
    application of the United States around the year 2000\. They want the application
    to show the U.S. demographics including gender, age, and ethnicity, during that
    year. After reviewing the request from the client, we determined that the 2000
    census data would provide all the mapping and demographics data we were looking
    for.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚被Y2K历史学会要求制作一个关于2000年左右美国的交互式地图应用程序。他们希望该应用程序能够显示该年的美国人口统计，包括性别、年龄和种族。在审查客户的要求后，我们确定2000年的人口普查数据将提供我们所需的全部地图和人口统计数据。
- en: After a bit of research, we found an ArcGIS Server map service that serves the
    2000 census data. We can use the ArcGIS JavaScript API to show that data on an
    HTML document. The user will be able to click on the map, and the application
    will display census data by state, census tract, and census block group.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番研究，我们找到了一个提供2000年人口普查数据的ArcGIS Server地图服务。我们可以使用ArcGIS JavaScript API在HTML文档上显示这些数据。用户将能够点击地图，应用程序将按州、人口普查区和人口普查区块组显示人口普查数据。
- en: Setting up the HTML document
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置HTML文档
- en: 'Let''s open our favorite text editor and create an HTML document. Since we''re
    working with census data, let''s call it `census.html`. We''ll start with an HTML5
    template. Browsers will recognize it as HTML5 by the appropriate document type
    at the top of the page. Our HTML5 page starts out as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们最喜欢的文本编辑器并创建一个HTML文档。由于我们正在处理人口普查数据，让我们将其命名为`census.html`。我们将从一个HTML5模板开始。浏览器将通过页面顶部的适当文档类型将其识别为HTML5。我们的HTML5页面开始如下：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Starting from the head
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从头部开始
- en: 'The head of an HTML document contains information about the page including
    the title, metadata about the page content, **Cascading Style Sheet** (**CSS**)
    links to tell the browser how to render the output, and any scripts that the developer
    needs the browser to run before it reads the rest of the page. Here is an example
    of a simple webpage:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文档的头部包含有关页面信息，包括标题、页面内容的元数据、**层叠样式表**（**CSS**）链接，告诉浏览器如何渲染输出，以及开发人员需要浏览器在读取页面其余部分之前运行的任何脚本。以下是一个简单网页的示例：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Let's take a look at each of the items separately.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别查看每个项目。
- en: Meta tags and title tags
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元标签和标题标签
- en: 'The title and meta tags in the head of the document tell browsers and search
    engines more about the page. See the following code for an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文档头部的标题和元标签向浏览器和搜索引擎提供了更多关于页面的信息。以下代码是一个示例：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Some tags tell search engines how to read and categorize the content of your
    website. Others, like the meta tags in this file, tell the browser how to display
    and manipulate the page. In the preceding code the first meta tag, we're establishing
    the character set used to render text. The second meta tag tells Internet Explorer
    browsers to load the page using the latest version available. The third meta tag
    tells mobile browsers that the content is scaled to the correct size, disabling
    the ability to pinch or spread your fingers on the screen in order to zoom the
    text in and out. This is different from zooming the map scale in and out, and
    this tag is required in most mobile browsers to zoom in and out of the map.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标签告诉搜索引擎如何读取和分类你网站的内容。其他标签，如本文件中的元标签，告诉浏览器如何显示和操作页面。在前面代码中，第一个元标签我们设置了用于渲染文本的字符集。第二个元标签告诉Internet
    Explorer浏览器使用最新版本加载页面。第三个元标签告诉移动浏览器内容已缩放到正确大小，禁用了在屏幕上用手指捏或展开来放大或缩小文本的能力。这与放大或缩小地图比例尺不同，并且大多数移动浏览器需要此标签才能放大或缩小地图。
- en: Cascading style sheets
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级联样式表
- en: 'The look of a website is determined by the CSS. These style sheets tell the
    browser how to lay elements on the page, what colors to make each element, how
    to space them out, and so on. You can see how they are arranged in the current
    document:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的样式由CSS决定。这些样式表告诉浏览器如何将元素放置在页面上，为每个元素指定颜色，如何分配空间，等等。您可以在当前文档中看到它们的排列方式：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here are three ways to organize and control the styling of elements by using
    CSS:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三种使用CSS组织和控制元素样式的办法：
- en: First, we can apply styles to individual elements on the page with inline styling,
    by adding a style attribute to the HTML element (`<div style="..."></div>` for
    instance).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以通过向HTML元素（例如`<div style="..."></div>`）添加样式属性，使用内联样式为页面上的单个元素应用样式。
- en: Second, we can apply styling to the whole page by using an internal style sheet,
    denoted by the `<style></style>` tags.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们可以通过使用内部样式表（由`<style></style>`标签表示）来为整个页面应用样式。
- en: Third, we can apply styles to multiple sheets by referring to an external style
    sheet, denoted by `<link rel="stylesheet" … />`. For our single page application,
    we'll use both our own internal style sheet, and an external one provided by ESRI.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，我们可以通过引用外部样式表（由`<link rel="stylesheet" … />`表示）来为多个样式表应用样式。对于我们的单页应用程序，我们将使用我们自己的内部样式表和由ESRI提供的外部样式表。
- en: The ArcGIS JavaScript library requires its own style sheet to properly position
    the maps on the screen. Without this file, the map will not render correctly,
    and thus show the expected results. To load the required style sheet for the library,
    add a `link` tag and set the `href` attribute to point to the `esri.css` file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript库需要它自己的样式表来正确地在屏幕上定位地图。没有这个文件，地图将无法正确渲染，因此无法显示预期结果。要加载库所需的样式表，请添加一个`link`标签，并将`href`属性设置为指向`esri.css`文件。
- en: 'If you''re using version 3.2 or later, and your map appears on the page in
    a checkerboard pattern with the map tiles showing on every other square, the most
    likely problem is that the `esri.css` style sheet did not load. Make sure you
    reference the correct `esri.css` style sheet for the library version you''re using.
    The following image shows an example of this behavior:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用3.2或更高版本，并且你的地图在页面上以棋盘图案显示，每隔一个方块显示地图瓦片，那么最可能的问题是`esri.css`样式表没有加载。请确保你引用了正确版本的`esri.css`样式表。以下图片展示了这种行为示例：
- en: '![Cascading style sheets](img/6459OT_01_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![级联样式表](img/6459OT_01_01.jpg)'
- en: The Dojo configuration script
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dojo配置脚本
- en: 'Our JavaScript code adds a variable that tells Dojo how it should load, in
    the first script tags. From this script, we can tell the browser how to interpret
    specially defined HTML elements in our document, whether we want the browser to
    cache all files, and even how to load packages and other libraries into the Dojo
    build system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 JavaScript 代码添加了一个变量，告诉 Dojo 如何加载，在第一个脚本标签中。从这个脚本中，我们可以告诉浏览器如何解释我们文档中特别定义的
    HTML 元素，我们是否希望浏览器缓存所有文件，甚至如何将包和其他库加载到 Dojo 构建系统中：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we're telling Dojo to parse any specially decorated HTML elements
    in the body, and replace them with the appropriate Dojo widgets as the page is
    loaded. Using the `cacheBust` parameter, we are also asking the browser to use
    a timestamp when it loads the files, so that the files aren't cached in the browser.
    Adding timestamps forces the browser to load a fresh copy of the JavaScript file,
    rather than relying on a cached copy. Cached scripts under active development
    may not show the most recent changes you made, slowing development and increasing
    troubleshooting time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们告诉 Dojo 在页面加载时解析 body 中任何特别装饰的 HTML 元素，并用适当的 Dojo 小部件替换它们。使用 `cacheBust`
    参数，我们还要求浏览器在加载文件时使用时间戳，这样文件就不会在浏览器中缓存。添加时间戳会强制浏览器加载 JavaScript 文件的最新副本，而不是依赖于缓存的副本。处于开发中的缓存脚本可能不会显示您所做的最新更改，这会减慢开发速度并增加故障排除时间。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The script that loads the `dojoConfig` object must come before you load the
    ArcGIS JavaScript API. If the `dojoConfig` object is created after the API script
    reference, the `dojoConfig` contents will be ignored.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 `dojoConfig` 对象的脚本必须在你加载 ArcGIS JavaScript API 之前。如果 `dojoConfig` 对象是在 API
    脚本引用之后创建的，则 `dojoConfig` 的内容将被忽略。
- en: The ArcGIS JavaScript API script
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API 脚本
- en: 'The ArcGIS JavaScript library is the main tool you''ll use to render, manipulate,
    and interact with geographic data from the ArcGIS Server:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript 库是您将用于从 ArcGIS Server 渲染、操作和与地理数据交互的主要工具：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This application, as well as other applications in the book, use version 3.13
    of the ArcGIS JavaScript API. It was the most current version available at the
    time the book was written. As you maintain these applications, be aware of version
    number updates. ESRI often releases new versions to add new features, fix bugs
    in previous versions, and to keep the API compliant with the latest browsers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用以及其他书中的应用都使用了 ArcGIS JavaScript API 的 3.13 版本。这是在编写本书时可用的新版。在维护这些应用时，请注意版本号更新。ESRI
    经常发布新版本以添加新功能，修复旧版本中的错误，并确保 API 与最新浏览器兼容。
- en: Moving from the head to the body
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 head 移动到 body
- en: With our HTML head set up, we can focus on the body of the application. We'll
    add HTML elements to the body where the map and other information should go. We'll
    style those features from an inline style sheet. Finally, we'll write a script
    to handle the map creation, census data retrieval, and reacting to map events.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 HTML head 之后，我们可以专注于应用的身体部分。我们将在身体中添加 HTML 元素，其中包含地图和其他信息。我们将从内联样式表中设置这些功能。最后，我们将编写一个脚本以处理地图创建、人口数据检索以及对地图事件的响应。
- en: Framing the HTML body
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架 HTML body
- en: 'Our client specified that they would like the app to show two panels, a main
    map panel, and a separate panel that explains what the user is supposed to do.
    We''re going to fulfill the request by blocking off the sections using HTML `div`
    elements. The `div` elements are generic blocks of content in HTML. In the first
    `div`, we''ll add a styling class of `instructions`, and fill it with the appropriate
    instructions. In the second `div`, we''ll apply the specific element `id` of `map`,
    to tell ourselves and the ArcGIS JavaScript API where to put the map:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户指定他们希望应用显示两个面板，一个主地图面板和一个单独的面板，解释用户应该做什么。我们将通过使用 HTML `div` 元素划分区域来满足这一请求。`div`
    元素是 HTML 中的通用内容块。在第一个 `div` 中，我们将添加一个 `instructions` 样式类，并填充适当的说明。在第二个 `div` 中，我们将应用特定的
    `id` 元素 `map`，以告诉我们和 ArcGIS JavaScript API 应该在哪里放置地图：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Adding a little style
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一些样式
- en: We need to add some style to the new elements we added. To do this, we'll modify
    the original internal style sheet in the head portion of the application. Our
    client wants the map to take up the whole screen, with a little space in the upper
    right-hand corner for the map title and the instructions. The client hasn't decided
    on colors yet, but they have requested the rounded corners that everybody's putting
    on their websites today.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们添加的新元素添加一些样式。为此，我们将修改应用程序头部部分的原始内部样式表。我们的客户希望地图占据整个屏幕，在右上角留出一点空间用于地图标题和说明。客户还没有决定颜色，但他们要求使用今天大家都在网站上使用的圆角。
- en: 'So, after reviewing the requirements, and looking up how to style the elements,
    let''s add the following within the `<style></style>` element. The changes have
    been highlighted to help you see what has changed in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在审查需求并查找如何设置元素样式后，让我们在`<style></style>`元素内添加以下内容。以下代码片段中的更改已被突出显示，以帮助您看到以下代码中发生了什么变化：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here's an explanation of the style we've added. We want the HTML document, the
    map `<div>` to have no margin, border, or padding, and take up the full height
    of the page. We also want the `<div>` elements with the instructions class to
    be precisely positioned in the top right corner, taking up twenty-five percent
    of the page's width, and then its height will be determined automatically. The
    instructions block will be floating 100 z-index units towards the user (putting
    it in front of our map), and its bottom-left corner will have an 8 pixel radius
    curve in the lower left corner. It will have a white background, and a little
    padding on the right and left side. Finally, the title `<h1>` will be centered
    horizontally, with a little padding above and below it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对我们添加的样式的解释。我们希望HTML文档，地图`<div>`没有边距、边框或填充，并占据整个页面的高度。我们还希望具有说明类`<div>`元素精确地定位在右上角，占据页面宽度的百分之二十五，然后其高度将自动确定。说明块将浮起100
    z-index单位向用户（将其置于我们的地图之前），其左下角将有一个8像素半径的曲线。它将有一个白色背景，并在左右两侧有一些填充。最后，标题`<h1>`将水平居中，上面和下面有一些填充。
- en: Adding a script at the end
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在末尾添加脚本
- en: If we look at our web page now, we won't see much. Just a title and instructions
    in the upper right-hand corner. We need to turn this plain page into a fully powered
    map application. To do that, we'll need to instruct the browser, by using JavaScript,
    on how to transform our map `<div>` into a map.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看我们的网页，我们不会看到太多。只有一个标题和右上角的说明。我们需要将这个普通的页面转换成一个功能齐全的地图应用程序。为此，我们需要通过JavaScript指导浏览器如何将我们的地图`<div>`转换成地图。
- en: 'Just before the end of our body tag, we''ll add a script tag where we''ll write
    our JavaScript code. We put our script near the end of our HTML document because,
    unlike images and style sheets, browsers load script tags one at a time. While
    the browser is loading the script, it doesn''t load anything else. If you put
    it at the beginning of the page, the user might notice a bit of latency, or a
    delay before the page loads. When we put a script at the end, the user is too
    distracted by the images and other elements on the page to notice when your script
    loads. This gives it the appearance of loading faster:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`<body>`标签结束之前，我们将添加一个脚本标签，在其中我们将编写我们的JavaScript代码。我们将脚本放在HTML文档的末尾，因为与图像和样式表不同，浏览器一次只加载一个脚本标签。当浏览器正在加载脚本时，它不会加载其他任何内容。如果您将其放在页面的开头，用户可能会注意到一点延迟，即在页面加载之前的延迟。当我们把脚本放在末尾时，用户会被页面上的图像和其他元素分散注意力，以至于不会注意到您的脚本何时加载。这使得它看起来加载得更快：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, why didn't we load the ArcGIS JavaScript library at the end of the page?
    There will be times, especially if you are using other parts of Dojo, when we'll
    need the library to manipulate the page as it loads in the browser. In that case,
    we put the library reference at the head of the HTML document.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们没有在页面末尾加载ArcGIS JavaScript库呢？有时，尤其是如果您正在使用Dojo的其他部分，我们需要在浏览器加载页面时操纵库。在这种情况下，我们将库引用放在HTML文档的头部。
- en: Now that we have a script tag to write some JavaScript, we can code up an interactive
    map. But, before we start writing code, we need to understand how to use the ArcGIS
    JavaScript API and Dojo. We'll start with a quick history lesson.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用于编写一些JavaScript的脚本标签，我们可以编写一个交互式地图。但是，在我们开始编写代码之前，我们需要了解如何使用ArcGIS JavaScript
    API和Dojo。我们将从一个简短的历史课开始。
- en: Back in the good old days of web development, and even continuing today, JavaScript
    libraries tried to avoid colliding into one another by creating a single global
    object (such as JQuery's `$` or Yahoo's YUI). All of the library's features would
    be built into that object. If you've used the Google Maps API, you've probably
    used `google.maps.Map()` to create a map, and `google.maps.LatLng()` to load a
    point on that map. Each subpart of the library is separated by a dot (`.`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发的美好时光里，甚至直到今天，JavaScript库试图通过创建一个全局对象（例如JQuery的`$`或Yahoo的YUI）来避免相互冲突。库的所有功能都会集成到这个对象中。如果你使用过Google
    Maps API，你可能使用过`google.maps.Map()`来创建地图，以及`google.maps.LatLng()`来在地图上加载一个点。库的每个子部分都通过点(`.`)分隔。
- en: Older versions of the ArcGIS JavaScript library were no different. All of ESRI's
    mapping libraries were loaded into the main "esri" object. You could create a
    map using `esri.map`, and load it with an `esri.layer.FeatureLayer` to show some
    data, for instance. The Dojo framework was similar, using the `dojo`, `dijit`,
    and `dojox` global objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript库的旧版本并无不同。所有ESRI的地图库都被加载到主"esri"对象中。你可以使用`esri.map`创建一个地图，并通过`esri.layer.FeatureLayer`加载它来显示一些数据，例如。Dojo框架也是类似的，使用`dojo`、`dijit`和`dojox`全局对象。
- en: But this tree-like approach to JavaScript library design has its downsides.
    As the library expands and matures, it builds up a lot of parts that developers
    didn't always use. We might use a library for one or two specific features, but
    we may not use every single tool and function the library offers. The parts of
    the library we don't use waste client bandwidth, bloat the memory, and make our
    app appear slower to load.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种类似树状结构的JavaScript库设计方法有其缺点。随着库的扩展和成熟，它会积累很多开发者并未经常使用的部分。我们可能只使用库中的一个或两个特定功能，但可能不会使用库提供的每一个工具和功能。我们未使用的库部分浪费了客户端带宽，增加了内存负担，并使得我们的应用看起来加载速度更慢。
- en: Asynchronous Module Definition
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步模块定义
- en: Both the ArcGIS JavaScript API and Dojo decided to handle the bloated library
    crisis by incorporating the concept of **Asynchronous Module Definition** (**AMD**).
    In AMD, a library is broken down into modular components. The developer can pick
    and choose which parts of library they want to include in the application. By
    loading only the parts we need, we reduce download times, free the browser memory
    of unused functionality, and improve performance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API和Dojo都决定通过引入**异步模块定义**（**AMD**）的概念来解决库膨胀的问题。在AMD中，库被分解成模块化组件。开发者可以选择他们想要包含在应用程序中的库的部分。通过只加载所需的模块，我们可以减少下载时间，释放浏览器内存中未使用的功能，并提高性能。
- en: Another advantage of AMD is name collision avoidance or the names of the variables
    where the libraries load are controlled by the developer. Also, the scope of the
    loaded libraries is limited to within the calling function, much like a self-executing
    statement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: AMD的另一个优点是避免命名冲突，或者说是控制库加载时变量名的开发者。此外，加载的库的作用域限制在调用函数内部，就像一个自执行的语句。
- en: In an AMD based application, we make a list of the library modules we want to
    use, usually in an array of strings that the library knows how to interpret. We
    then follow it up with a function that loads most or all of those modules into
    JavaScript objects. We can then use those modules within the function to get the
    results we want.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于AMD的应用程序中，我们列出我们想要使用的库模块，通常是一个字符串数组，库知道如何解释它。然后我们跟随一个函数，该函数加载大多数或所有这些模块到JavaScript对象中。我们可以在函数中使用这些模块来获取我们想要的结果。
- en: Loading required modules
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载所需模块
- en: 'To take advantage of the Dojo''s AMD style, we''re going to use Dojo''s `require`
    function. In older examples, we would create multiple `dojo.require("")` statements
    that would load the parts of the ArcGIS JavaScript library we needed (and hopefully
    by the time we wanted to use them). But with AMD style, we use a single `require`
    function that requests the list of libraries we ask for, and loads them within
    a function that runs after all the libraries are loaded in the browser:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用Dojo的AMD风格，我们将使用Dojo的`require`函数。在旧例子中，我们会创建多个`dojo.require("")`语句来加载我们需要的ArcGIS
    JavaScript库的部分（并且希望在我们想要使用它们的时候）。但使用AMD风格时，我们使用一个单一的`require`函数来请求我们请求的库列表，并在所有库在浏览器中加载后，在函数中加载它们：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `require` function takes two arguments, an array of strings that corresponds
    to folder locations in our library, and a function that runs after those libraries
    load. In the second function, we add arguments (variables within the parentheses
    after functions) that correspond to the libraries loaded in the list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 函数接受两个参数，一个字符串数组，对应于我们库中的文件夹位置，以及一个在那些库加载后运行的函数。在第二个函数中，我们添加参数（函数括号内的变量）与列表中加载的库对应。'
- en: 'So, for this application, we''ll need a few modules from the ArcGIS JavaScript
    API. We''ll need to create an empty map and add data to the map in a form we call
    layers. We''ll need to identify things on the map, retrieve the census data we
    need from the place we clicked on the map, and then display it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个应用程序，我们需要从 ArcGIS JavaScript API 中获取几个模块。我们需要创建一个空地图，并以我们称之为层的格式向地图添加数据。我们需要在地图上识别事物，从我们点击地图的位置检索所需的普查数据，然后显示它：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice the order of the libraries loaded in the require statement, and the arguments
    in the following function. The first item in the list corresponds to the first
    argument in the function. It is a common error when creating more complex applications
    to mix up the order of the elements, especially if it has been revised multiple
    times. Make sure the items correspond as you go down the list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 require 语句中加载库的顺序以及以下函数中的参数。列表中的第一项对应于函数中的第一个参数。在创建更复杂的应用程序时，混淆元素顺序是一个常见的错误，尤其是如果它已经被修改多次。确保列表中的项目随着列表的下降而对应。
- en: You may have noticed that, while there are seven libraries loaded, there are
    only six arguments. The last library that loaded, the `dojo/domReady!` library,
    tells the require statement's second function not to run until all the HTML elements
    have loaded and are rendered in the browser.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，尽管加载了七个库，但只有六个参数。最后加载的库，即 `dojo/domReady!` 库，告诉 require 语句的第二个函数不要运行，直到所有
    HTML 元素都已加载并在浏览器中渲染。
- en: The map object
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图对象
- en: 'Now that we have the components, we need to create an interactive map; let''s
    put them together. We''ll start by constructing a `map` object, which provides
    the basis and interaction platform that we''ll need to work with. The map constructor
    takes two arguments. The first parameter, either the HTML node or the `id` string
    of a node, indicates where we want to put our map. The second parameter of the
    map constructor is an `options` object, where we add the configurable options
    that make our map work as expected:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了组件，我们需要创建一个交互式地图；让我们将它们组合起来。我们将首先构建一个 `map` 对象，它为我们提供了所需的基础和交互平台。地图构造函数接受两个参数。第一个参数，要么是
    HTML 节点，要么是节点的 `id` 字符串，表示我们想要放置地图的位置。地图构造函数的第二个参数是一个 `options` 对象，我们在其中添加使地图按预期工作的可配置选项：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we''re creating a map in the `div` element with an `id`
    of `map`. In the map, we''re adding a **basemap**, or a background reference map,
    in the style of National Geographic. We''re centering the map at 45°N and 95°W,
    at a zoom level of three. We''ll go into greater depth concerning these configurations
    in later chapters. If you''re using a desktop browser to view the results, you
    should see the United States, including Alaska, and Hawaii, as in the following
    image:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在创建一个具有 `id` 为 `map` 的 `div` 元素中的地图。在地图中，我们添加了一个 **基础地图**，或背景参考地图，采用国家地理的风格。我们将地图中心定位在北纬
    45° 和西经 95°，缩放级别为三。我们将在后面的章节中更深入地讨论这些配置。如果你使用桌面浏览器查看结果，你应该看到包括阿拉斯加和夏威夷在内的美国，如下面的图像所示：
- en: '![The map object](img/6459OT_01_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![地图对象](img/6459OT_01_02.jpg)'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have experience working with Dojo, most element constructors have the
    options first, followed by the node or the `id` of the node. This is the reverse
    of how we construct a map. Remember, order is important.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有过使用 Dojo 的经验，大多数元素构造函数都有选项，然后是节点或节点的 `id`。这与我们构建地图的方式相反。记住，顺序很重要。
- en: The layers
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层
- en: Years ago, mapping departments drew maps on transparent Mylar sheets. Painstaking
    work went into drawing those sheets at the same scale. When the Mylar sheets were
    stacked on top of each other, and corresponding points on each layer were lined
    up, they would provide a visual mashup of overlapping map layers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，地图部门在透明的 Mylar 薄膜上绘制地图。绘制这些薄膜需要付出艰辛的努力，并且要保持相同的比例。当 Mylar 薄膜堆叠在一起，并且每一层的对应点对齐时，它们会提供重叠地图层的视觉混合。
- en: Today, the same effect can be created with a browser-based map application.
    Instead of clear Mylar sheets, the application takes advantage of layering image
    files and vector graphics to create the same effect. In the ArcGIS JavaScript
    API, we refer to these stackable map data sources as **layers**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们可以通过基于浏览器的地图应用程序创建相同的效果。而不是使用清晰的Mylar薄片，该应用程序利用分层图像文件和矢量图形来创建相同的效果。在ArcGIS
    JavaScript API中，我们将这些可堆叠的地图数据源称为**层**。
- en: The ArcGIS JavaScript API can accept multiple types of layer files from different
    sources. Some layers are very flexible, and can be realigned and reprojected to
    line up with other map sources. These are commonly referred to as **dynamic layers**.
    Other layers are made up of images drawn at specific scales, and are not designed
    to be so flexible. These are commonly referred to as **tiled layers**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS JavaScript API可以接受来自不同来源的多种类型的层文件。有些层非常灵活，可以被重新定位和重新投影以与其他地图源对齐。这些通常被称为**动态层**。其他层由特定比例绘制的图像组成，并不设计得那么灵活。这些通常被称为**瓦片层**。
- en: 'In our current application, the National Geographic background we added is
    considered a tiled layer. Its pre-rendered content loads quickly in the browser,
    which is one of the advantages of using a tiled layer. On the other hand, our
    data source for the census data is a dynamic layer provided by an ArcGIS Server
    map service. Its dynamic nature helps it to stretch and line up with our tiled
    background. Here''s the code we''ll use to add the layer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的当前应用程序中，我们添加的国家地理背景被认为是瓦片层。它的预渲染内容在浏览器中快速加载，这是使用瓦片层的一个优点。另一方面，我们的普查数据的数据源是由ArcGIS
    Server地图服务提供的动态层。其动态特性有助于它拉伸并与我们的瓦片背景对齐。以下是我们将用于添加层的代码：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, if we take a look at the page at this point, we should see a map of the
    world with black lines surrounding each state, census tract, and block. We can
    zoom in to see more detail in the map. Your map should look something like the
    following image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们现在查看页面，我们应该看到一个世界地图，每个州、普查区和区块周围都有黑色线条。我们可以放大地图以查看更多细节。您的地图应该看起来像以下图像：
- en: '![The layers](img/6459OT_01_03.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![层](img/6459OT_01_03.jpg)'
- en: Adding some action
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些动作
- en: At this point, we have a map that draws all the state and census block and track
    data. We need more than that. We need a way for the user to interact with the
    site. The ArcGIS JavaScript API incorporates many tools provided by the native
    JavaScript language, plus new tools provided by Dojo.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个绘制所有州、普查区块和轨迹数据的地图。我们需要更多。我们需要一种让用户与网站交互的方式。ArcGIS JavaScript API集成了由原生JavaScript语言提供的许多工具，以及由Dojo提供的新工具。
- en: Events
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: When many of us learned traditional programming, we learned that programs followed
    a linear design. They started on the first line and ended on the last line. The
    computer performed each computation in an ordered fashion, and would not go on
    to the next line until the current line had finished.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们中的许多人学习传统编程时，我们了解到程序遵循线性设计。它们从第一行开始，到最后一行结束。计算机按顺序执行每个计算，并且不会继续到下一行，直到当前行完成。
- en: But JavaScript adds something different. JavaScript adds an event loop that
    monitors for specific website interactions, such as a change in a text blank.
    We can attach a function, commonly called an **event listener**, to a known element
    event. When that event is triggered, the event listener runs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但JavaScript添加了不同的东西。JavaScript添加了一个事件循环，它监视特定的网站交互，例如文本框中的变化。我们可以将一个函数，通常称为**事件监听器**，附加到一个已知元素的事件。当该事件被触发时，事件监听器就会运行。
- en: For example, buttons have a click event, and if we attach an event listener
    to the button's click event, that function will respond every time that button
    is clicked. We can also get information about the button through the data passed
    through the click event.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，按钮有一个点击事件，如果我们为按钮的点击事件附加一个事件监听器，那么该函数将在每次点击按钮时响应。我们还可以通过通过点击事件传递的数据来获取有关按钮的信息。
- en: 'For our application, we want the map to do something when we click on it. If
    we look up the list of supported map events, we can attach an event listener using
    the `.on()` method. The `.on()` method takes two parameters, a string description
    of the event, and the event listener function we want to be called when the event
    occurs. A list of supported events can be found in the ArcGIS JavaScript API documentation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们希望地图在被点击时执行某些操作。如果我们查看支持的地图事件列表，我们可以使用 `.on()` 方法附加事件监听器。`.on()`
    方法接受两个参数，一个是事件的字符串描述，另一个是当事件发生时希望被调用的事件监听器函数。支持的事件列表可以在 ArcGIS JavaScript API
    文档中找到：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before we can do anything with the map, we need to know if it has loaded yet.
    If we're running an updated browser on our fastest computer with a high-speed
    internet connection, the map may load immediately, but if we're testing from a
    mobile browser on an older smartphone, with less than stellar internet download
    speeds, the map may not load very quickly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以对地图进行任何操作之前，我们需要知道它是否已经加载。如果我们在我们最快的计算机上运行更新的浏览器，并且有高速互联网连接，地图可能会立即加载，但如果我们从较旧的智能手机上的移动浏览器进行测试，互联网下载速度较慢，地图可能不会很快加载。
- en: 'Before we assign the click event, we''re going to test whether the map has
    loaded. If so, we''ll add the `onMapClick` function as an event listener to the
    map''s `click` event. If not, we''ll wait until the map fires its `load` event
    to set the `click` event. Just so we don''t have to repeat ourselves when adding
    the map click event, we''ll enclose that assignment in another function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分配点击事件之前，我们将测试地图是否已加载。如果是这样，我们将把 `onMapClick` 函数作为事件监听器添加到地图的 `click` 事件。如果不是，我们将等待地图触发其
    `load` 事件来设置 `click` 事件。为了在添加地图点击事件时避免重复，我们将把这个赋值放在另一个函数中：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tasks
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: While developers can write code that does a lot with JavaScript, there are some
    tasks that are best left to a server. The ArcGIS JavaScript API sends requests
    to the server through **task** objects. There are tasks for calculating the area
    and perimeter of complex shapes, tasks for querying and returning spatial and
    non-spatial data on features in a map, and tasks for creating `.pdf` documents
    containing the map we're looking at, among many others. These tasks take the burden
    off the browser to perform complex calculations that could be very slow on mobile
    devices. They also allow the library to be lighter in weight, so the library doesn't
    have to load every single set of conversion factors between one coordinate system
    and another, for example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开发者可以编写使用 JavaScript 执行大量任务的代码，但有些任务最好留给服务器。ArcGIS JavaScript API 通过 **任务**
    对象向服务器发送请求。有计算复杂形状面积和周长的任务，有查询并返回地图中特征的空间和非空间数据的任务，还有创建包含我们正在查看的地图的 `.pdf` 文档的任务，以及其他许多任务。这些任务减轻了浏览器执行可能非常慢的复杂计算的负担。它们还允许库更轻量，因此库不需要加载一个坐标系统到另一个坐标系统之间的所有转换因子的集合，例如。
- en: 'Most tasks have three parts: the task object, the task parameters, and the
    task results. The task object lets us send requests to the ArcGIS Server for specific
    tasks, and includes the constants that may need to be referenced for some tasks.
    The task object typically takes in a URL string parameter that tells the task
    to which ArcGIS Server service endpoint to send its requests. The task parameters
    object defines what information we need to get information from the task. Finally,
    after we execute the task with the task parameters, and we receive the response
    from the server, we get a structured object, or a list of objects known as the
    task''s result. Formats for the task, task parameters, and task results can be
    found in the ArcGIS JavaScript API documentation at [https://developers.arcgis.com/javascript/jsapi/](https://developers.arcgis.com/javascript/jsapi/).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数任务分为三个部分：任务对象、任务参数和任务结果。任务对象使我们能够向 ArcGIS 服务器发送特定任务的请求，并包括可能需要引用的一些任务的常量。任务对象通常接受一个
    URL 字符串参数，告诉任务将请求发送到哪个 ArcGIS 服务器服务端点。任务参数对象定义了我们从任务中需要获取的信息。最后，在执行任务并从服务器接收响应后，我们得到一个结构化对象，或称为任务结果的列表。任务、任务参数和任务结果的格式可以在
    ArcGIS JavaScript API 文档中找到，网址为 [https://developers.arcgis.com/javascript/jsapi/](https://developers.arcgis.com/javascript/jsapi/)。
- en: 'In our code, we''re going to use a task called an `IdentifyTask` method. We''ll
    tell the `IdentifyTask` method to contact ArcGIS Server through our census URL.
    Inside the map click event handler, we''ll create a task parameter object called
    an `IdentifyParameter` object. We''ll configure it with the data about the point
    we clicked, and data on the map. Finally, we''ll execute the `IdentifyTask` method,
    passing in the `IdentifyParameters` object, to retrieve census data from the location
    we clicked:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将使用一个名为 `IdentifyTask` 的任务方法。我们将告诉 `IdentifyTask` 方法通过我们的普查 URL 联系
    ArcGIS 服务器。在地图点击事件处理程序内部，我们将创建一个名为 `IdentifyParameter` 的任务参数对象。我们将使用关于我们点击的点以及地图上的数据来配置它。最后，我们将执行
    `IdentifyTask` 方法，传入 `IdentifyParameters` 对象，以从我们点击的位置检索普查数据：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deferreds and promises
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Deferreds 和承诺
- en: 'Years ago, when FORTRAN ruled the computer programming world, there was one
    statement that drove developers crazy when it came time to troubleshoot their
    code: `GOTO`. With this line of code, disrupting the flow of the application,
    the application would jump to another line of code. Jumping from one section of
    code to another made following the application''s logic difficult at best.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，当 FORTRAN 统治着计算机编程世界时，有一个语句让开发者们在调试代码时感到疯狂：`GOTO`。使用这条代码行，会打断应用程序的流程，使应用程序跳转到另一行代码。从一个代码段跳转到另一个代码段，在最好情况下也使得跟踪应用程序的逻辑变得困难。
- en: With modern JavaScript and asynchronous development, following the logic of
    some asynchronous applications can be difficult, too. The app fires one event
    when the user clicks a button, which triggers an AJAX request for data. On the
    successful return of that data, another event fires, which makes the map do something
    that takes a little time. After the map finishes, it fires off another event,
    and so on and so forth.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现代 JavaScript 和异步开发的出现，跟踪某些异步应用程序的逻辑也可能变得困难。当用户点击按钮时，应用程序会触发一个 AJAX 请求以获取数据。在数据成功返回后，另一个事件被触发，这使得地图执行一些需要一点时间的事情。地图完成后，它会触发另一个事件，以此类推。
- en: Dojo responded to this by creating **Deferreds** objects. Deferred objects return
    a promise that a result from an asynchronous process will be coming soon. The
    function waiting for the result will not be called until that promise is fulfilled.
    With functions returning Deferred results, the developer can chain functions together
    using a `.then()` statement. The `.then()` statement launches the first function
    in its parameters only after the result is fulfilled. Multiple `.then()` statements
    can be chained together with functions that return Deferred objects, leading to
    an orderly, and more easily readable coding logic.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Dojo 通过创建 **Deferreds** 对象来应对这个问题。Deferred 对象返回一个承诺，表示异步过程的结果即将到来。等待结果的函数只有在承诺得到满足后才会被调用。使用返回
    Deferred 结果的函数，开发者可以使用 `.then()` 语句将函数链接在一起。`.then()` 语句仅在结果得到满足后才会启动其参数中的第一个函数。可以将多个
    `.then()` 语句与返回 Deferred 对象的函数链接在一起，从而实现有序且更易于阅读的编码逻辑。
- en: 'In our `onMapClick` function, the `IdentifyTask` object''s execute method returns
    a Deferred object. We''ll store that deferred result in a variable, so that it
    can be used by another tool later:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `onMapClick` 函数中，`IdentifyTask` 对象的 `execute` 方法返回一个 Deferred 对象。我们将把这个延迟结果存储在一个变量中，以便稍后可以被另一个工具使用：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Showing the results
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示结果
- en: Once we have received our data, we should show the results to the user. If we
    look at the format of the data passed over the network, we'll see a list of complicated
    **JavaScript Object Notation** (**JSON**) objects. That data, in its raw form,
    would be useless in the hands of the average user. Thankfully, the ArcGIS JavaScript
    API provides tools and methods for turning this data into something more user-friendly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到数据，我们应该向用户展示结果。如果我们查看通过网络传递的数据格式，我们会看到一个复杂的 **JavaScript 对象表示法**（**JSON**）对象的列表。这些数据以原始形式，在普通用户手中将毫无用处。幸运的是，ArcGIS
    JavaScript API 提供了将此数据转换为更易于用户使用的工具和方法。
- en: The Map's infoWindow
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图的 infoWindow
- en: In the day of modern map applications such as Google Maps, Bing Maps, and OpenStreetmaps,
    users have been taught that if you click on something important on a map, a little
    box should pop up and tell you more about that item. The ArcGIS JavaScript API
    provides a similar popup control for the map called an `infoWindow` control. The
    `infoWindow` highlights feature shapes on the map, and overlays a popup window
    to show the features-related attributes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代地图应用程序如Google Maps、Bing Maps和OpenStreetmaps的时代，用户已经学会了，如果你在地图上点击某个重要位置，应该会弹出一个小窗口并告诉你更多关于该物品的信息。ArcGIS
    JavaScript API为地图提供了一个类似的弹出控制，称为`infoWindow`控制。`infoWindow`在地图上突出显示特征形状，并叠加一个弹出窗口来显示与特征相关的属性。
- en: The `infoWindow` can be accessed as a property of the map (for example, `map.infoWindow`).
    From this point, we can hide or show the popup. We can tell the `infoWindow` which
    features to highlight. The `infoWindow` provides a number of configurable and
    control points to help create a better user experience.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`infoWindow`可以作为地图的一个属性来访问（例如，`map.infoWindow`）。从这一点起，我们可以隐藏或显示弹出窗口。我们可以告诉`infoWindow`要突出显示哪些特征。`infoWindow`提供了一系列可配置和控制点，以帮助创建更好的用户体验。'
- en: 'In our application''s map click handler, we will need to convert the search
    results into a form that can be used by the `infoWindow`. We''ll do that by adding
    an `.addCallback()` call to the `IdentifyTask` object''s execute function. We''ll
    pull out the features from `IdentifyResults`, and make a list of them. From that
    point, we can pass the processed results into the `infoWindow` object''s list
    of selected features. We''ll also prompt the `infoWindow` to show where the user
    clicked:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的地图点击处理程序中，我们需要将搜索结果转换为`infoWindow`可以使用的形式。我们将通过向`IdentifyTask`对象的`execute`函数添加一个`.addCallback()`调用来实现这一点。我们将从`IdentifyResults`中提取特征，并创建一个特征列表。从那时起，我们可以将处理后的结果传递到`infoWindow`对象所选特征的列表中。我们还将提示`infoWindow`显示用户点击的位置：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can run the application now from your browser, and try clicking on one of
    the black-outlined features on the map. You should see a shape outlined in cyan
    (light blue), and a popup pointing to where you clicked. The popup will tell you
    that there is at least one record there (probably more). You can click the small
    back and forward arrows on the popup to flip through the selected results (if
    there is more than one).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以从你的浏览器中运行应用程序，并尝试点击地图上黑色轮廓线中的一个特征。你应该会看到一个用青色（浅蓝色）轮廓的形状，以及一个指向你点击位置的弹出窗口。弹出窗口会告诉你那里至少有一条记录（可能更多）。如果你点击弹出窗口上的小前后箭头，可以浏览所选结果（如果有多个）。
- en: The InfoTemplate object
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InfoTemplate`对象'
- en: As of this point, we can see the shape of our data. The problem is, we can't
    see what's inside. There is important tabular data associated with the shapes
    we're seeing in the results, but the popup hasn't been told how to show the information.
    For that, we can use an `InfoTemplate` object. An `InfoTemplate` object tells
    the popup how to format the data for display, including what title to use, and
    how we want the search results displayed. An `InfoTemplate` object is connected
    to the feature data, along with the feature's geometry and attributes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以看到我们数据的外形。问题是，我们看不到里面是什么。与我们在结果中看到的形状相关的重要表格数据，但弹出窗口还没有被告知如何显示信息。为此，我们可以使用一个`InfoTemplate`对象。`InfoTemplate`对象告诉弹出窗口如何格式化用于显示的数据，包括使用什么标题，以及我们希望如何显示搜索结果。`InfoTemplate`对象与特征数据、特征的几何形状和属性连接在一起。
- en: An `InfoTemplate` object can be constructed in different ways, but most commonly
    with a string to describe the title, and another string to show the content. The
    content can contain any valid HTML, including tables, links, and images. Since
    the title and content are templates, you can insert feature attributes within
    the template string. Surround the field names from your results with `${fieldname}`,
    where "fieldname" is the name of the field you want to use. If you want to show
    all the field names and values in the content, without any special formatting,
    set the content value of the `InfoTemplate` object to `${*}`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`InfoTemplate`对象可以通过不同的方式构建，但最常见的是使用一个字符串来描述标题，另一个字符串来显示内容。内容可以包含任何有效的HTML，包括表格、链接和图片。由于标题和内容是模板，你可以在模板字符串中插入特征属性。用`${fieldname}`包围你想要使用的字段名称，其中"fieldname"是你想要使用的字段的名称。如果你想在不进行任何特殊格式化的情况下显示所有字段名称和值，可以将`InfoTemplate`对象的内容值设置为`${*}`。'
- en: 'For our application, we''ll need to add `InfoTemplates` to the `IdentifyTask`
    results. We''ll work with the `onIdentifyComplete` callback and insert them there.
    We''ll start by inserting the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们需要将`InfoTemplates`添加到`IdentifyTask`结果中。我们将使用`onIdentifyComplete`回调并将它们插入其中。我们将首先插入以下代码：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this bit of code, we''re extracting the layer name of the results, and using
    that for the title. For the content, we''re using the "show everything" template
    to show all fields and values. If you run the web page in your browser now, and
    click on a feature, you should see something like the following image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们正在提取结果的图层名称，并使用它作为标题。对于内容，我们使用“显示所有内容”模板来显示所有字段和值。如果你现在在浏览器中运行网页，并点击一个要素，你应该看到以下图像：
- en: '![The InfoTemplate object](img/6459OT_01_04.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![InfoTemplate 对象](img/6459OT_01_04.jpg)'
- en: 'Now, there are a lot of unreadable field names, and field values we may not
    be able to understand. We could apply different content formats, based on the
    layer names of the features. Looking at the preceding example, we''re mostly interested
    in the population, the number of households, and the number of housing units:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有很多难以阅读的字段名和可能无法理解的字段值。我们可以根据要素的图层名称应用不同的内容格式。查看前面的示例，我们主要对人口、家庭数量和住房单元数量感兴趣：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you run the page again in your browser, you should see more readable results,
    at least for the census block points. Other features, such as the states, counties,
    and block groups, will show a list of field names and their corresponding values,
    separated by a colon (`:`). I'll leave the templates for the other fields as a
    homework exercise for you.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次在浏览器中运行页面，你应该看到更易读的结果，至少对于人口普查区块点来说是这样。其他要素，如州、县和区块组，将显示字段名及其对应值的列表，用冒号（`:`）分隔。我将把其他字段的模板留作你的家庭作业练习。
- en: 'In the end, your code should read as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你的代码应该如下所示：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Congratulations, if this is your first web map application using ArcGIS Server
    and JavaScript. You've worked through multiple steps to produce a working, interactive
    map application. This application should look great on all the latest browsers.
    However, older browsers may not connect with the server properly, and may require
    a proxy.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，如果你这是第一次使用 ArcGIS Server 和 JavaScript 开发的网络地图应用程序。你已经完成了多个步骤，制作了一个工作状态良好的交互式地图应用程序。这个应用程序应该适用于所有最新的浏览器。然而，较旧的浏览器可能无法正确连接到服务器，可能需要代理。
- en: A note on proxies
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于代理的注意事项
- en: 'If you''ve worked with the ArcGIS JavaScript API for any length of time, or
    had to support older browsers like Internet Explorer 9 or less, then you''ve probably
    come across proxies. Proxies are server-side applications that make web requests
    on behalf of the web browser, often transmitting and receiving data the browser
    could not collect on its own. There are three primary reasons why a browser would
    require a proxy to communicate with a server. They are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经长时间使用过 ArcGIS JavaScript API，或者不得不支持像 Internet Explorer 9 或更早的旧浏览器，那么你可能遇到过代理。代理是服务器端应用程序，代表网络浏览器进行网络请求，通常传输和接收浏览器本身无法收集的数据。浏览器需要代理与服务器通信有三个主要的原因。具体如下：
- en: The browser is an older browser that does not support **Cross Origin Resource
    Sharing** (**CORS**), and the server requests will be made to a different server
    from the one the application sits on.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器是较旧的浏览器，不支持**跨源资源共享**（**CORS**），服务器请求将发送到应用程序所在的服务器之外的其他服务器。
- en: The proxy provides additional security keys to access specific data, which might
    include secured tokens the developer doesn't want to release to the public.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理提供额外的安全密钥以访问特定数据，这可能包括开发者不希望公开的受保护令牌。
- en: The web request is much longer than the 2048+ character maximum for `GET` requests.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络请求的长度超过了`GET`请求的最大字符数2048+。
- en: The first example is common with older browsers, including Internet Explorer
    9 or lower. They can't grab data from third party servers that are separate from
    the web server, because of a security restraint. With the HTML5 specification
    for CORS, newer browsers can check to see if an application is allowed to be requested
    from a script not on the server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例在较旧的浏览器中很常见，包括 Internet Explorer 9 或更低版本。由于安全限制，它们无法从与网络服务器分离的第三方服务器获取数据。根据
    HTML5 CORS 规范，较新的浏览器可以检查是否允许从不在服务器上的脚本请求应用程序。
- en: The second example is common in large secure environments, with many security
    hoops to jump through. Department portal websites could access proxies with tokens
    unique to the department, providing an extra layer of security.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例在大型安全环境中很常见，需要跳过许多安全关卡。部门门户网站可以使用部门特有的令牌访问代理，提供额外的安全层。
- en: The third example is common when the user is passing large geometries with many
    irregular vertices. For instance, if you were to use a drawing tool to draw an
    irregular shape with the free-handed drawer, its vertices are added as you move
    around on the map. With so many points, and those points requiring a lot of characters
    to show their latitude and longitude, it's no wonder a shape request might exceed
    the browser's maximum character length.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例在用户传递具有许多不规则顶点的大几何体时很常见。例如，如果您使用绘图工具使用自由手绘工具绘制不规则形状，其顶点会在您在地图上移动时添加。由于有这么多点，并且这些点需要很多字符来显示它们的纬度和经度，所以形状请求可能超过浏览器的最大字符长度也就不足为奇了。
- en: The ArcGIS Server proxy is free to download from GitHub ([https://github.com/Esri/resource-proxy](https://github.com/Esri/resource-proxy)).
    They have versions that work with Java, .NET, and PHP. Please use the most recent
    version, and make sure it's properly configured for all the services you'll be
    using.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Server代理可以从GitHub免费下载（[https://github.com/Esri/resource-proxy](https://github.com/Esri/resource-proxy)）。它们有与Java、.NET和PHP兼容的版本。请使用最新版本，并确保它已正确配置以用于您将使用的所有服务。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If both your computer and your ArcGIS Server are behind a network firewall,
    and the ArcGIS Server has unique public and private IP addresses, your network
    firewall may block proxy connections to your ArcGIS Server. If you see network
    traffic failing only on older browsers, such as Internet Explorer 8, and only
    for internal requests, the firewall might be the issue. Contact your network administrator
    to work out the issue.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机和ArcGIS Server都位于网络防火墙之后，并且ArcGIS Server具有独特的公共和私有IP地址，您的网络防火墙可能会阻止对ArcGIS
    Server的代理连接。如果您仅在较旧的浏览器上看到网络流量失败，例如Internet Explorer 8，并且仅针对内部请求，那么防火墙可能是问题所在。请联系您的网络管理员以解决问题。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learnt the basics of writing a simple web application
    using the ArcGIS JavaScript API, and put together a map-based application. We
    learned how to set up the application in the head of the HTML document. We learned
    how to create a map on a page and how to add layers so that we can view the data.
    We learned how to retrieve feature shapes and attributes through a task, and how
    to show that data to the user.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用ArcGIS JavaScript API编写简单Web应用的基础知识，并构建了一个基于地图的应用程序。我们学习了如何在HTML文档的头部设置应用程序。我们学习了如何在页面上创建地图以及如何添加图层以便我们可以查看数据。我们还学习了如何通过任务检索要素形状和属性，以及如何向用户展示这些数据。
- en: In the next chapter, we'll look more in depth at the tools available in the
    ArcGIS JavaScript API.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨ArcGIS JavaScript API中可用的工具。
