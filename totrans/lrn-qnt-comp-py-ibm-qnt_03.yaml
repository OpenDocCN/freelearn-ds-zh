- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing and Installing Qiskit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the **Quantum Information Science Kit**
    (**Qiskit**) and its advanced features to develop and implement various quantum
    algorithms, quantum application modules, and noise models. Qiskit (pronounced
    kiss-kit) is comprised of various features that help you build quantum circuits,
    algorithms, and applications easily, and it allows you to run them on both classical
    simulators and real quantum systems and visualize the results. In this chapter,
    you’ll also see instructions on how to install Qiskit on your local machine to
    create quantum circuits and run them on a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also discuss how to contribute to the open-source community
    and the development of future quantum applications, as well as how to connect
    to other like-minded developers and enthusiasts via the **Qiskit community**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding quantum and classical system interconnections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Qiskit APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Qiskit on your local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting support from the Qiskit community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knowledge of GitHub is recommended as we will review how to contribute to the
    Qiskit open-source project, which is hosted on GitHub. Having **Agile** and **open-source
    development** practices is also recommended, but not required. Here is the source
    code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding quantum and classical system interconnections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll review how quantum computational systems are integrated
    with classical systems. As quantum computers do not have ways to store the state
    of a qubit, there is a dependency on classical systems to provide persistent storage
    for information that is sent to or received from a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: Since most data originates from classical sources, whether they are from data
    repositories or remote sensors, there is a need to prepare the data to be used
    in a quantum system. Likewise, the results from the quantum systems need to be
    returned not in a quantum state but in binary form so that they can be read back
    to a classical system for any post-processing that’s required.
  prefs: []
  type: TYPE_NORMAL
- en: 'This hybrid or interconnectivity between classical systems and quantum systems
    is what we will be reviewing in this section so that you understand how both systems
    work together to provide you with the most optimal results. Qiskit Runtime, which
    is a new feature that was introduced in early 2022, has some good examples you
    can try. There are lots of papers that describe other forms of integrating classical
    and quantum resources, such as this paper, *A Serverless Cloud Integration For
    Quantum Computing*: [https://arxiv.org/abs/2107.02007](https://arxiv.org/abs/2107.02007).'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Qiskit library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you worked on some of the previous chapters, then you would have noticed
    that we used Qiskit to create sample circuits, which we used to describe some
    quantum concepts. As Python developers, you would have also noticed that Qiskit
    is functionally no different from using any other Python libraries, such as **NumPy**,
    **scikit-learn**, and so on. How we use it within our Python notebooks is also
    the same as we would use any other package, where we can import the complete package
    or just a subset of classes and functions. By having the Qiskit modules available
    through Python, this allows us to integrate our classical algorithms and applications
    into a quantum system. Leveraging the libraries available in Qiskit to create
    quantum circuits that execute on quantum devices from a classical development
    environment such as Python makes integration with your existing classical applications
    very seamless and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit, much like most other open-source projects, is easy to set up, both as
    a package with Python or as a branch or a fork if you’re just acting as a contributor.
    It’s very compact and does not require much with respect to resources to run on
    local machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another advantage of creating it as a package for an existing platform such
    as Python is that there is no need to install a separate integrated development
    environment or set up complex build systems with confusing dependencies. For those
    of you who already have Python installed with the currently supported version,
    you can install Qiskit with a simple `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But let’s not get too ahead of ourselves. Now that we understand the purpose
    of Qiskit and its general functionality, we will work our way to installing Qiskit
    locally by first understanding how it is organized. Then, we’ll cover how it interacts
    with your classic systems such as your laptop, server, or cloud application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to organize and interact with Qiskit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use Python for most of your development, which I assume you do, based
    on the title of this book, then you will understand that most packages are created
    in some form of hierarchy. At the top level, there are the application modules,
    while the lower levels refer to the components within each module.
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit has components such as classes or objects, and under each of those components,
    you have functions and members. Qiskit is no different regarding how everything
    is organized from most other packages, which makes it very easy to find certain
    features.
  prefs: []
  type: TYPE_NORMAL
- en: At the base level you have hardware connectors; these are what connects Qiskit
    to the various quantum providers. In addition to hardware connectors are the classical
    simulators; in this book, we will be using the Qiskit Runtime service to run our
    circuits, which includes some locally installed Qiskit simulators. Of course,
    as these simulators run on classical systems, they are limited to the number of
    resources to simulate quantum circuits. As the quantum circuits become more complex,
    the cost in resources grows rather fast. This has been highlighted in various
    publications where certain complex quantum circuits can be simulated on classical
    systems; however, there are discrepancies in the accuracy across the various classical
    results. This is why having the hardware connectors available to run complex circuits
    is important, as it allows you to offload complex circuits from classical simulators
    to real quantum systems that run at utility scale. You might be asking yourself,
    *what makes a circuit complex?* Well, I can say that it does not have to do with
    relationship status. It’s more about the width of the circuit, which correlates
    to the number of qubits, and the depth of the circuit, which correlates to the
    number of operations deep, particularly the number of multi-qubit gates that entangle
    two or more qubits together. We’ll cover details about each of these in more detail
    as you progress through the book.
  prefs: []
  type: TYPE_NORMAL
- en: Above the connectors and simulators is the fundamental building block for researchers
    and developers, the Qiskit Runtime. We will go deeper into what the Qiskit Runtime
    is in later chapters, but for now just think of it as a runtime that provides
    you with a lot of features to create, run, and optimize your quantum circuits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous versions of Qiskit, the modules were set up such that the domain
    of each algorithm was spread out: by that, I mean the modules covered error correction,
    simulators, gate and circuit components, and applications. In this case, an algorithm
    developer would have to learn how to incorporate multiple modules together, therefore
    causing the developer to have to understand the various components and modules
    at the base level to incorporate them into their application. This has since changed
    after the introduction of the latest code changes to Qiskit.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to introduce the three development layers or segments, which
    allow developers to provide modules to each other to help create quantum applications.
    Having these three layers, which are not that much different from classical application
    development, allows classical developers to solely focus on their own layer, which
    eliminates the need to fully understand what is occurring at another layer. Let’s
    take a quick look at the three development layers.
  prefs: []
  type: TYPE_NORMAL
- en: A **kernel** developer is one who develops code at the lowest level of the three
    layers. They work mostly on creating quantum circuits, the composition of gates,
    hardware pulse level controls, and other features that are close to the hardware.
    Qiskit Terra is the module that the kernel developer would work with, which includes
    the circuit library that allows them to create new or use existing circuits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **algorithm** developer is one who leverages the circuits created by the
    kernel developer to create quantum algorithms. These algorithms can provide ways
    to encode classical data into a quantum state. For example, the information of
    a pixel can be represented as a quantum state where the qubits would represent
    the location and color value of each pixel of an image. They can also create a
    quantum algorithm that would not need to encode any classical data at all. The
    algorithm developer could also include some of the latest Qiskit features that
    provide infrastructure optimizations, such as the Qiskit Runtime, so that the
    integration of classical and quantum systems is robust.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **model** developer is one who applies algorithms to create applications that
    solve real-world problems. These model developers can be domain or industry experts
    that understand the problems that may be intractable for classical systems and
    determine how to apply quantum algorithms to these problems. By creating models
    for certain problems, the model developer could provide a quantum application
    that could, for example, integrate as part of a large workflow or as a service
    provider, which classical applications could call upon as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three layers working together allow the developer to focus solely within
    their layer to develop components that could provide the others with the tools
    they need to enhance their applications. This also facilitates collaboration between
    each of the developers, as they can provide feedback to each other to further
    optimize their components.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram illustrates the layers and what Qiskit libraries or components
    would generally apply to each developer type.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software  Description automatically generated](img/B18420_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Kernel, Algorithm, and Model developer layers'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the preceding information is based on the current version of Qiskit.
    In the future, like many projects, this may change. I highly recommend keeping
    up to date with the current **Application Programming Interface** (**API**) documentation
    to ensure that you are using the proper calls when writing your code. The API
    for this can be found on the Qiskit documentation page at [https://www.qiskit.org/documentation/](https://www.qiskit.org/documentation/).
  prefs: []
  type: TYPE_NORMAL
- en: The documentation page provides the latest information on the four available
    modules, often referred to as elements due to their names, as explained at the
    beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have defined the three different development layers that help simplify
    developers jumping into programming quantum applications without too much of a
    learning curve. For example, a model developer might only need to understand how
    the quantum algorithms work to create a model for a classical application rather
    than having to also learn which gates the circuits used to create the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The following section will describe the API references so that you understand
    how to leverage them in your code. The development specifics will be covered in
    future chapters, where we will talk about the functionality and operations that
    each can provide.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Qiskit APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qiskit was built for anyone who wants to work with quantum computers at every
    level and domain. By this, we mean that if a quantum researcher wanted to work
    on how the pulses are scheduled on a quantum device, they could do so very easily.
    The same can be said about users who simply want to extend their applications
    to leverage a quantum computer to compute information.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about the various APIs that are available in
    Qiskit today. As mentioned earlier, Qiskit has various layers that can be leveraged
    by any domain expert to start using quantum computing in their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take, for example, chemistry researchers who wish to compute the energy
    state of two molecules but don’t want to go through the hassle of learning about
    quantum gates and pulses. They just want to load their dataset, classically, to
    a quantum algorithm and obtain the results transparently. Qiskit was built as
    a full stack open-source software package to facilitate those and many more user-type
    scenarios using the application modules.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum physicists can experiment at the hardware level by researching ways
    to schedule pulses to single and multi-qubits. Quantum researchers can work on
    developing quantum circuits that could minimize noise, which would optimize the
    results of your quantum circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm researchers and developers usually work on creating quantum algorithms
    that can be used by various domains and industries either to solve problems faster
    or provide more accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, domain researchers such as chemists, data scientists, economists, and
    many others can integrate their classic applications into a quantum system to
    compute complex problems more optimally or accurately using various features such
    as the Qiskit Runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit, at the time of writing, has released its latest version, Qiskit 1.0\.
    This new version provides you with a lot of great features that will take your
    development skills to the next level. Most particularly to the new era of quantum
    utility!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start off by learning about the built-in simulators that are available
    in Qiskit. The simulators are great for getting started, but as your development
    skills and understanding of quantum increase, so to will your need to run more
    complex circuits where classical simulators, such as those described herein, could
    have some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Aer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before getting into what Aer is, let’s first make sure we install it, as Aer
    has moved to its own separate component and as it makes sense to run some simulations
    when starting, do install it onto your system as it is now a requirement if you
    plan to run local simulations on your classical system. Simply run `pip install
    qiskit-aer` from your command line, or Python environment, and that should be
    all you need. Aer provides a framework that can be used to develop debugging tools
    and create noise models. These tools help replicate a lot of the characteristics
    of a quantum system by simulating the noise that affects not just the qubit but
    also the environment and computations. There are generally five highly efficient
    compiled *simulator categories* available in Aer; they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AerProvider**, the main class that contains all the simulators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QasmSimulator**, a quantum simulator that allows for simulation methods and
    options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StatevectorSimulator**, an ideal quantum state vector simulator used to produce
    non-noisy results from your circuit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UnitarySimulator**, an ideal quantum unitary simulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pulse**, a simulator used to generate and schedule pulse operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, there is discussion over whether **Pulse** will be removed in the near
    future. It’s included here for the sake of completeness, but it may not always
    be available. For that reason, we will not explore Pulse further in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the differences between each simulator category in the upcoming
    sections and in *Chapter 9*, *Simulating Quantum Systems and Noise Models*, you
    will learn more about the specific simulators within each category, including
    those within Aer itself.
  prefs: []
  type: TYPE_NORMAL
- en: The Aer simulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aer itself is also a category that contains a list of its own types of simulators
    that are specific to obtaining specific information about the quantum circuit,
    such as the density matrix, matrix product state, and multiple stabilizer simulators.
    This simulator is the main simulator to reproduce how an actual backend system
    can behave and includes an `options` object, which can be used to provide parameters
    such as density matrices to reproduce noise typically found in a quantum system.
  prefs: []
  type: TYPE_NORMAL
- en: The Qasm simulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Qasm** simulator allows us to run our circuits in both clean and noisy
    simulated environments. The difference between the two is the amount of noise
    that you wish to apply to the simulator. On the one hand, it could run as an error-free
    ideal system that you can use to confirm the computational results of your circuit.
    On the other hand, you could run your circuit through a simulator that includes
    noise models so that you can replicate the noise and understand how it affects
    your computations. We will learn more about noise and noise models in *Chapter
    10*, *Understanding and Mitigating Quantum Noise*.
  prefs: []
  type: TYPE_NORMAL
- en: The Qasm simulator also has multi-functional capabilities and methods to simulate
    circuits, such as `statevector`, `density_matrix`, `stabilizer`, `matrix_product_state`,
    and many more. By allowing you the flexibility to configure the Qasm simulator
    using any of these methods, you can expect an ideal outcome from the measured
    circuits, along with any models that you wish to incorporate.
  prefs: []
  type: TYPE_NORMAL
- en: The Qasm simulator also provides a list of backend options you can use to execute
    your quantum circuit. These options include setting threshold values to truncate
    results or setting floating-point precision values and maximum value constraints
    for executing circuits. These features make Aer the ideal component for those
    who wish to develop an ideal or replicated noisy system. Typically, Aer is used
    by researchers who wish to develop noise mitigation or error correction techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Statevector simulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Statevector** simulator is, as its name suggests, a state vector simulator
    that provides the final state vector of the circuit without the measurement operation
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Results from the Statevector simulator can be visualized by leveraging the various
    visualization tools of quantum states, such as **histograms** and **cityscape**.
    The **cityscape** option provides a nice 3D view of both the real and imaginary
    components of the density matrix (![](img/Icon_1.png)). Other visualization plots
    include **Hinton** diagrams, **Pauli vector** plots, and **Bloch spheres**, to
    name a few. Some of these, such as the Bloch sphere and the qsphere and other
    visualization tools will be covered in future chapters, as they will help you
    visualize some of the effects that gates have on qubits.
  prefs: []
  type: TYPE_NORMAL
- en: The Unitary simulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Unitary** simulator is quite simply just that — it provides the unitary
    matrix result of your circuit by computing the overall matrix of the circuit.
    The idea is that a circuit with only unitary operators/gates each operating on
    a subset of the qubits can be expressed as a single unitary operator. This can
    be accomplished by multiplying all the operator matrices in the circuit to arrive
    at a single overall matrix/operator.
  prefs: []
  type: TYPE_NORMAL
- en: This is very helpful if you want to confirm that the operations you applied
    to the qubits match your expected calculations.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine how helpful this will be when you start to work on multiple
    qubits with many operators. The Unitary simulator helps provide state information
    so that you can ensure that the results are what you expected.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Qiskit on your local machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will walk you through the installation process of Qiskit.
    It is important to note that to complete the examples in this book, you will need
    to install Qiskit on your machine locally, as the IBM Quantum Platform no longer
    has a lab, nor does it have any simulators to run circuits on the cloud, only
    the actual quantum systems, which you will have limited access. The installation
    will include installing Anaconda, which is the tool used by many Qiskit developers
    to install Python, Jupyter Notebooks, Qiskit, and many other data science packages.
    It also serves as a simple way to manage packages and how they are installed on
    your local machine. In our case, it will help by installing the prepackaged dependencies
    we will need, such as Python, Jupyter Notebooks, `pip`, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can create an environment specific to quantum development
    with all the dependencies and features already installed. By having a local installation,
    you can run your circuits from the local system onto simulators on your local
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qiskit is an open-source project that is available for free to everyone. It
    is licensed under the **Apache 2.0** license ([https://apache.org/licenses/LICENSE-2.0](https://apache.org/licenses/LICENSE-2.0)).
    A copy has also been included in each Qiskit module (for example, [https://www.github.com/Qiskit/qiskit/blob/master/LICENSE.txt](https://www.github.com/Qiskit/qiskit/blob/master/LICENSE.txt)).
    This allows you to use the source code, along with all its rights and privileges,
    as defined in the license.
  prefs: []
  type: TYPE_NORMAL
- en: The installation of Qiskit is quite simple, particularly if you are already
    familiar with the package management application known as **pip**. To review the
    Qiskit metadata package information, such as its current stable version, build
    status, and other details, go to [https://pypi.org/project/qiskit](https://pypi.org/project/qiskit).
  prefs: []
  type: TYPE_NORMAL
- en: We have highlighted that you should install the full version as there have been
    issues with the mini version. You can, of course, try either, but if you get issues
    with the mini version, it is recommended that you install the full version.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Anaconda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anaconda ([https://www.anaconda.com/distribution](https://www.anaconda.com/distribution))
    is an open-source cross-platform distribution of Python. It allows the user to
    create separate environments so that they can install multiple versions of Python.
    This is very useful, particularly for those of you who are Python developers and
    already have a version of Python installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: By creating a separate environment using Anaconda, you can eliminate issues
    that may come up due to installing a different version of Python that may affect
    your existing Python projects or applications. Having separate environments also
    provides you with the ability to have multiple versions of Qiskit. You need to
    have a working version of Qiskit up and running while you install an update on
    a separate environment so that you can test if your quantum applications currently
    support the latest releases without worrying about dependency issues.
  prefs: []
  type: TYPE_NORMAL
- en: '*It is recommended to follow the installation instructions on the Anaconda
    site*. The installation steps of Anaconda also include versions of Jupyter Notebook,
    which comes in handy, as the Qiskit notebooks will not be available locally. However,
    since the Qiskit notebooks are built on Jupyter Notebooks, you shouldn’t expect
    to see much of a difference between the two.'
  prefs: []
  type: TYPE_NORMAL
- en: After installing Anaconda with the supported version of Python – at the time
    of this writing, the currently supported version is 3.9 – be sure to create an
    environment in your installation and switch to that environment before proceeding
    and installing Qiskit. Otherwise, it will install on your base environment. After
    successfully completing the installation and creating your Anaconda environment,
    you are now ready to install Qiskit!
  prefs: []
  type: TYPE_NORMAL
- en: Installing Qiskit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before installing Qiskit, be sure to check the installation page ([https://docs.quantum.ibm.com/start/install](https://docs.quantum.ibm.com/start/install))
    for any updates on either the installation or configuration steps, as things might
    change. The following steps will lead you through the installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by ensuring that you are in the environment you created. The best
    way to determine this is to launch your command line and enter the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will list all the environments on your system. You will
    see one titled `base` and another with the name of the environment that you created.
    The current environment is identified by an asterisk, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18420_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Output of the current environment command'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding screenshot, another way to identify the environment
    is to look at the far left of the command line before the machine name. There,
    in parentheses, is the current environment. In the preceding screenshot, I created
    an environment called `QiskitEnv`. Now, let’s activate the environment by running
    the following in the command line so we can enable it and start the installation
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will now activate the environment on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'For details, I recommend reviewing the documentation on getting started with
    `conda` here: [https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html](https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are in the Qiskit environment after activating it in the previous
    step, you can now run the `pip` command to install Qiskit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Based on your machine and network speed, this may take a few moments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once completed, you can verify the installation by entering the following on
    the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will list the installed Qiskit packages and their respective versions,
    which you should see includes all the various Qiskit libraries. To see the most
    current list of optional packages, just visit the Qiskit metadata package information
    page at [https://pypi.org/project/qiskit](https://pypi.org/project/qiskit).
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have installed and verified that Qiskit is installed on your
    local device. Now, you can launch a Jupyter Notebook and start using Qiskit!
  prefs: []
  type: TYPE_NORMAL
- en: '*Wait! Not so fast*. There are just a couple of steps we should cover before
    we start coding and running circuits. We want to make sure your local machine
    is configured. The first thing you need to ensure is that you have your **token
    ID** saved on your local device. This way, when you are ready to run an experiment
    on a real device or on the simulator on the cloud, you can do so very easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your local Qiskit environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll need to install some new features to leverage the latest building
    blocks and visualization packages. The IBM Runtime package and optional visualization
    package will allow you to run circuits efficiently on a quantum system and visualize
    the results from your circuit, respectively. Subsequent steps include saving your
    account information onto your local machine, which will be used to connect and
    use the IBM Quantum systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps needed to get yourselves up and running are as follows. Note for
    **Mac** users that the strings in the brackets, in this case, `visualization`,
    need to be wrapped with single quotes (i.e., `''visualization''`) – otherwise,
    you will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your terminal and run each of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the installations have been completed, you can move on to the next step,
    which is to set up your account information on your local machine by copying your
    account API token.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two places where you can obtain your API token; the first is from
    your dashboard on the IBM Quantum Platform page ([https://quantum.ibm.com](https://quantum.ibm.com)),
    as illustrated in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: API token on the dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to obtain your API token is via the **Manage account** page.
    To get to your account page, just click on your avatar at the top right of the
    page and select **Manage account** from the drop-down list, as illustrated in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18420_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: API token on the Manage account page'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the account page opens, click the **Copy token** icon located to the
    right of the **API token** field, as highlighted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18420_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Copy your account API token'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have copied your **API token**, let’s save it on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch **Jupyter Notebook** by entering the following on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we are launching this locally, we do not have the launcher here to create
    a new notebook, so we will have to create one ourselves. Let’s do that now by
    clicking **New** | **Python 3** at the top right of Jupyter Notebook, as illustrated
    in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18420_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Creating a new Python 3 notebook'
  prefs: []
  type: TYPE_NORMAL
- en: This will create a new Python 3 notebook. Note this created a blank notebook,
    so we also do not have the nice boilerplate cell that imported a lot of the commonly
    used classes and functions. We will have to either import them, as we need them,
    or you can just copy/paste in the boilerplate code from a previously created notebook
    that contains the boilerplate cell. In the following, we will just add the classes
    and functions as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it has launched, enter the following into the first cell. You will also
    want to do this on the “`setup_save_account.ipynb`" file that is included in the
    code samples you have access to. This file will be imported and used in the early
    chapters for convenience, so please be sure you update the API token information
    there as well; otherwise, you will see errors when running the sample code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be sure to include the single quotes (`'` `'`) around your API token in the
    argument; otherwise, you may get an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have saved our API token locally, we won’t have to save it to our
    local system again unless we delete or change the API token value. Remember to
    copy your token, as indicated in the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you only run this command once. If by chance, you forget and rerun
    the above function again, you may get a warning. You can find other account setting
    commands here in the Qiskit API documentation: [https://docs.quantum-computing.ibm.com/start/setup-channel#select-and-set-up-an-ibm-quantum-channel](https://docs.quantum-computing.ibm.com/start/setup-channel#select-and-set-up-an-ibm-quantum-channel).'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully configured your local version of Qiskit!
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to run circuits locally on your system. Creating and executing
    circuits can now be done locally on a simulator for those times when you are unable
    to obtain network access. Of course, once you are back online, you can use your
    local version to execute circuits on real devices. This also allows you the freedom
    to integrate with your own applications or systems with ease. By having the ability
    to run your code locally, you can integrate new code into your own local applications
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to install Anaconda, which includes a lot of
    the dependencies necessary to install Qiskit; how to create a quantum circuit;
    how to execute the circuit on a simulator; and how to execute the circuit on a
    quantum computer. Now, we’ll learn how to contribute, collaborate, and get support
    from the Qiskit global community.
  prefs: []
  type: TYPE_NORMAL
- en: Getting support from the Qiskit community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Qiskit community is a global group of developers, researchers, and pretty
    much anyone who is curious about quantum computing that comes together, collaborates,
    and supports each other to help build knowledge across all community members.
    It is also used to keep everyone up to speed on the latest in quantum research,
    education, events, and updates: [https://www.ibm.com/quantum/events](https://www.ibm.com/quantum/events).
    A recent add-on is the ability to get certified as a Qiskit developer via the
    **Qiskit Developer Certification** exam. There is currently an updated course
    based on the Qiskit 1.x version coming out in late 2024.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn about the community, its many programs, and
    how you can contribute and become a **Qiskit advocate** ([https://www.ibm.com/quantum/community#advocates](https://www.ibm.com/quantum/community#advocates)).
    Qiskit advocates are members of the Qiskit community who have passed a rigorous
    exam, have made many contributions to the Qiskit community, and have helped many
    others along the way. Let’s start by introducing you to the community itself.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Qiskit community
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ever since Qiskit was first deployed as an open-source project, the open-source
    community has contributed so many features and enhancements that it has only improved
    over time. The development ecosystem itself has flourished so much that it is
    being used in universities, industry, and governments around the world, even in
    Antarctica!
  prefs: []
  type: TYPE_NORMAL
- en: Members of the Qiskit community, often referred to as **Qiskitters**, often
    work together as a solid diverse group to ensure everyone is supported. Whether
    they are newbies to quantum computing or veteran quantum researchers, they all
    share a passion for collaborating and connecting on various projects. The link
    to information on Qiskit and the community can be found at [https://www.ibm.com/quantum/qiskit](https://www.ibm.com/quantum/qiskit),
    where you will find various links at the top and bottom of the page to tutorials
    and where to join the Qiskit community and be a part of the largest quantum ecosystem
    in the world.
  prefs: []
  type: TYPE_NORMAL
- en: One of the early projects was to create resources for those new to quantum computing.
    These resources vary from generating enablement materials to **YouTube** video
    series. The topics included both hardware and software that described what happened
    on the backend and software that described new research that others were working
    on. Along with the resources, there are also events that are planned all over
    the world at any given time. This includes events such as workshops, where communities
    join either in person or virtually to learn the latest in quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: Other events also include **hackathons** and code camps, of which the largest
    is **Qiskit Camp**, which the IBM Quantum team hosts quarterly in different continents
    around the world. The 3-to-4-day camp usually includes accommodation in very exotic
    locations, meals, transportation to and from airports, and so on. Researchers
    from **IBM Research** also participate as lecturers, coaches, and judges. Teams
    are created and brainstorm ideas for projects that they work together on during
    the weekend, where they would compete and win prizes. This is very similar to
    hackathons.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, the Qiskit community initiated the **Qiskit advocate program**. This
    program was created to provide support to individuals who have actively been involved
    with the Qiskit community and have contributed over time. To become a Qiskit advocate,
    you will need to apply online ([https://www.ibm.com/quantum/community#advocates](https://www.ibm.com/quantum/community#advocates)),
    where you will be given an exam to test your knowledge of Qiskit and specify at
    least three community contributions. These qualifications, of course, can change
    over time, so it is recommended that you check the site for any updates and application
    deadlines.
  prefs: []
  type: TYPE_NORMAL
- en: Once accepted into the Qiskit advocate program, you will have the opportunity
    to network with other experts and access core members of the Qiskit development
    team. You will also gain support and recognition from IBM through the Qiskit community,
    as well as receive invitations to special events such as Qiskit Summer School,
    seminars, and other major events where you can not only collaborate with others
    but also lead or mentor as well.
  prefs: []
  type: TYPE_NORMAL
- en: Contributing to the Qiskit community
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Support across members is key, not just for Qiskit advocates but for all members.
    The Qiskit community has set up various channels to offer support to all the members
    of the community. They have a **Slack workspace** ([https://qisk.it/join-slack](https://qisk.it/join-slack))
    that is very active and has various channels so that members can ask questions,
    post event updates, or just chat about the latest quantum research that had been
    recently published. There are also other collaborative sources that Qiskit connects
    through. The current list of collaboration tools can be found on the main quantum
    community page: [https://www.ibm.com/quantum/community](https://www.ibm.com/quantum/community).'
  prefs: []
  type: TYPE_NORMAL
- en: Specializing your skill set in the Qiskit community
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most common questions asked about contributing to the Qiskit community,
    particularly those who are interested in becoming Qiskit advocates, is, *what
    are the various ways you can contribute?* There are many ways in which you can
    contribute to the Qiskit community. Ideally, you want to become familiar with
    the different forms of contributions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code contributions**: Adding a new feature, optimizing the performance of
    a function, and bug fixes are some of the good ways to start if you are a developer.
    If you are new to coding, there is a label that the Qiskit development team has
    created for this called **good first issue**. This is an umbrella term for the
    issues that are ideal for those who are new to the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host a Qiskit event in your area or virtually**: You can host an event and
    invite a Qiskit advocate to run a workshop or talk to a group about the latest
    updates in Qiskit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Help others**: You can help others by answering questions asked by other
    community members, reporting bugs, identifying features that may enhance the development
    of circuits, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specializing in an area such as noise mitigation, error correction, or algorithm
    design is an advantage to the community. The **Qiskit Slack community** has several
    channels that focus on specific areas of quantum computing: quantum systems, the
    IBM Quantum Platform, Qiskit Runtime, quantum algorithms and applications, Qiskit
    on Raspberry Pi, and many more. If you specialize in any of these areas, you can
    join the Slack group and collaborate on many technologies and topics.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the open-source contribution process and
    how to find tasks for both beginners and experts so that everyone can contribute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the general features and capabilities provided
    by Qiskit so that you can create highly efficient quantum algorithms. You then
    learned how to install Qiskit locally, as well as how to contribute and find support
    from the Qiskit community.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned more about Qiskit and how it fits on the development stack, and
    we covered an overview of the application modules and simulators provided in the
    Qiskit libraries. This provided you with the general skills and functionality
    to create circuits, which you can then use to apply various operations to the
    qubits via gates and operators.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned about Aer, which allows us to create better simulators and
    how to execute them locally and on the IBM Quantum platform.
  prefs: []
  type: TYPE_NORMAL
- en: You learned details on how you can install your own version of Qiskit on your
    platform using Anaconda. Finally, we learned about the Qiskit community and its
    advantages to all, particularly those who are new to quantum computing and need
    a little support to understand some of the challenging content or find someone
    to collaborate with and expand their horizons.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you now have the skills to install and configure Qiskit on your local
    machine to create and execute quantum circuits in offline mode.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start delving into understanding the fundamental
    basics of quantum computing so we can learn how to create and execute quantum
    circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your own words, describe the difference between a kernel developer and an
    application developer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wanted to obtain the unitary matrix of a circuit, which simulator would
    provide the unitary matrix result?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you name and describe in your own words each of the five simulator categories
    that are provided by Aer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which module would you need to import to plot a histogram?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_3.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2617625996838265932.png)'
  prefs: []
  type: TYPE_IMG
