<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Automating Analysis with Processing Scripts"><div class="titlepage" id="aid-22O7C2"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Automating Analysis with Processing Scripts</h1></div></div></div><p>In the previous chapter, we introduced the Processing Graphical modeler, and you learned how to use it to automate complex geoprocessing analyses. But this is not the only way to automate your work. QGIS's Processing framework also allows you to write your own scripts in Python and use them like any other algorithm later. This is what we will discuss in this chapter.</p><p>In this chapter, we will go through the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Python scripts in Processing</li><li class="listitem">Defining the input and output</li><li class="listitem">Implementing the algorithm</li><li class="listitem">Writing help and saving</li><li class="listitem">Sharing scripts</li></ul></div><div class="section" title="Python scripts in Processing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Python scripts in Processing</h1></div></div></div><p>You have already learned how to<a id="id570" class="indexterm"/> create models and automate analysis tasks with the help of the graphical modeler from the QGIS Processing framework. Although the Processing modeler is user friendly and easy to use, it has some limitations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">In the models, you can use<a id="id571" class="indexterm"/> only algorithms that are already available in Processing. Moreover, some algorithms that are available from the Processing toolbox are not available in the modeler.</li><li class="listitem">There is no support for conditional statements and loops.</li></ul></div><p>So, if you need to implement something more complex and advanced, you'll need another tool. Fortunately, the modeler is not the only way to automate analyses with Processing. Processing also allows us to combine its own power with the power of the Python programming language by developing Python scripts. Such scripts can then be used like any other algorithm from the Processing toolbox or modeler, or executed as batch processes.</p><p>Before we start implementing <a id="id572" class="indexterm"/>our scripts, it is necessary to understand how to use Processing algorithms from the QGIS Python console, because this knowledge is necessary for successful use of the existing Processing algorithms within scripts.</p><p>Now, open the Python console by clicking on the <span class="inlinemediaobject"><img src="../Images/image00513.jpeg" alt="Python scripts in Processing"/></span> button on the <span class="strong"><strong>Plugins</strong></span> toolbar. Alternatively, you can use the <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>P</em></span> keyboard shortcut or open it by going to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Python Console</strong></span>. A new dock widget will appear at the bottom of the QGIS window, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00514.jpeg" alt="Python scripts in Processing"/></div><p style="clear:both; height: 1em;"> </p><p>The Python console consists of two main areas. At the top, there is the output area, where executed commands and their output will be printed. Below it is the input area, where you should enter the code to be executed. Here, code is entered line by line. There is also a toolbar on the left-hand side of the Python console.</p><div class="note" title="Note"><h3 class="title"><a id="tip29"/>Tip</h3><p>If you want to learn more about the Python console, click on the <span class="strong"><strong>Help</strong></span> button from its toolbar and read the built-in documentation.</p></div><p>To start using Processing from the Python console, we should import it with this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import processing</strong></span>
</pre></div><p>This line will load all<a id="id573" class="indexterm"/> Processing functions and make them available for us.</p><div class="section" title="Listing the available algorithms"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec54"/>Listing the available algorithms</h2></div></div></div><p>You may want to run an<a id="id574" class="indexterm"/> existing Processing algorithm from your script instead of reimplementing its functionality yourself. To do this, it is necessary to get the name of that algorithm, which is not what you see in the toolbox, but a special name—the so-called command-line name.</p><div class="note" title="Note"><h3 class="title"><a id="note38"/>Note</h3><p>Every algorithm in Processing has two names: a human-readable and user-friendly name that is used in the toolbox and modeler, and another internal command-line name that has no ambiguous characters in it, such as spaces, semicolons, and so on. It also contains information about the algorithm provider. Command-line names are unique.</p></div><p>To list all available Processing algorithms with their command-line names, run this Python console command:</p><div class="informalexample"><pre class="programlisting">processing.alglist()</pre></div><p>You will get a very long output that might look like this (truncated):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Calculator-------------------------------------------&gt;modelertools:calculator</strong></span>
<span class="strong"><strong>Raster layer bounds----------------------------------&gt;modelertools:rasterlayerbounds</strong></span>
<span class="strong"><strong>Vector layer bounds----------------------------------&gt;modelertools:vectorlayerbounds</strong></span>
<span class="strong"><strong>Add autoincremental field----------------------------&gt;qgis:addautoincrementalfield</strong></span>
<span class="strong"><strong>Add field to attributes table------------------------&gt;qgis:addfieldtoattributestable</strong></span>
<span class="strong"><strong>Advanced Python field calculator---------------------&gt;qgis:advancedpythonfieldcalculator</strong></span>
<span class="strong"><strong>Bar plot---------------------------------------------&gt;qgis:barplot</strong></span>
<span class="strong"><strong>Basic statistics for numeric fields------------------&gt;qgis:basicstatisticsfornumericfields</strong></span>
<span class="strong"><strong>Basic statistics for text fields---------------------&gt;qgis:basicstatisticsfortextfields</strong></span>
<span class="strong"><strong>Clip-------------------------------------------------&gt;qgis:clip</strong></span>
</pre></div><p>To the left, you can see human-readable algorithm names that are also used in the toolbox, and to the right are the corresponding command-line names.</p><p>As the number of algorithms—even in a default QGIS installation—is really big, it may be difficult to find the command-line name of the desired algorithm. Fortunately, it is possible to reduce the output of the <code class="literal">alglist()</code> command. Just pass to it a string parameter representing a substring that should exist in the algorithm's name. For example, to display <a id="id575" class="indexterm"/>only algorithms with the word <code class="literal">count</code> in their names, execute the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>processing.alglist('count')</strong></span>
</pre></div><p>The result will be much shorter, and it will be easy to find the algorithm you are looking for:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Count points in polygon------------------------------&gt;qgis:countpointsinpolygon</strong></span>
<span class="strong"><strong>Count points in polygon(weighted)--------------------&gt;qgis:countpointsinpolygonweighted</strong></span>
<span class="strong"><strong>Count unique points in polygon-----------------------&gt;qgis:countuniquepointsinpolygon</strong></span>
<span class="strong"><strong>v.qcount - Indices for quadrant counts of sites lists.---&gt;grass:v.qcount</strong></span>
</pre></div><p>Now we know how to get the command-line name of the required algorithm. But in order to run the algorithm, we will need to know some more information.</p></div><div class="section" title="Getting information about an algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec55"/>Getting information about an algorithm</h2></div></div></div><p>To execute an algorithm, we need not only its name but also the syntax. This includes information about<a id="id576" class="indexterm"/> the list of algorithm input and output, as well as the order in which they should be passed to the algorithm. All of this information can be obtained with the help of the <code class="literal">processing.alghelp()</code> command. This <a id="id577" class="indexterm"/>command accepts only one argument—the command-line algorithm name—and returns a list of algorithm inputs and outputs, with their types.</p><p>As an example, let's look at the <code class="literal">Create grid</code> algorithm we used in previous chapters. Its command-line name is <code class="literal">qgis:creategrid</code> (you can easily check this using the information from the preceding section), so to get information about its syntax, we should execute the next command in the QGIS Python console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>processing.alghelp('qgis:creategrid')</strong></span>
</pre></div><p>Here is the output of this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ALGORITHM: Create grid</strong></span>
<span class="strong"><strong>  TYPE &lt;ParameterSelection&gt;</strong></span>
<span class="strong"><strong>  EXTENT &lt;ParameterExtent&gt;</strong></span>
<span class="strong"><strong>  HSPACING &lt;ParameterNumber&gt;</strong></span>
<span class="strong"><strong>  VSPACING &lt;ParameterNumber&gt;</strong></span>
<span class="strong"><strong>  OUTPUT &lt;OutputVector&gt;</strong></span>


<span class="strong"><strong>TYPE(Grid type)</strong></span>
<span class="strong"><strong>  0 - Rectangle (line)</strong></span>
<span class="strong"><strong>  1 - Rectangle (polygon)</strong></span>
<span class="strong"><strong>  2 - Diamond (polygon)</strong></span>
<span class="strong"><strong>  3 - Hexagon (polygon)</strong></span>
</pre></div><p>From this output, we can see that the human-readable algorithm name is <code class="literal">Create</code> <code class="literal">grid</code> and it accepts four input fields: <code class="literal">TYPE</code> (selection from a predefined list of values), <code class="literal">EXTENT</code> (the extent), <code class="literal">HSPACING</code>, and <code class="literal">VSPACING</code> (both of these are numbers). The algorithm has produced one vector output. The most interesting part, however, is below the parameters and outputs list; it's the list of available values for the <code class="literal">TYPE</code> selection parameter. The numbers on the left are<a id="id578" class="indexterm"/> values that can be passed to the algorithm, and on the right, you can see the human-readable description of each value. For example, if you want to create a grid with the diamond cells, then it is necessary to pass a value of <code class="literal">2</code> to the <code class="literal">TYPE</code> parameter.</p><p>Now let's see how different parameter types should be passed to the algorithm:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Raster or vector layer and tables</strong></span> (<code class="literal">ParameterVector</code>, <code class="literal">ParameterRaster</code>, and <code class="literal">ParameterTable</code>): It is possible<a id="id579" class="indexterm"/> to specify the name of the corresponding layer or table, if that layer is already loaded in QGIS. Also, you can use the path to the layer file. Finally, it is possible<a id="id580" class="indexterm"/> to pass an instance of the corresponding QGIS class, for example, <code class="literal">QgsVectorLayer</code>. If this is an optional input and you don't want to use it, just use<a id="id581" class="indexterm"/> the <code class="literal">None</code> value.</li><li class="listitem"><span class="strong"><strong>Selection from predefined values</strong></span> (<code class="literal">ParameterSelection</code>): This should be represented by the numerical<a id="id582" class="indexterm"/> index of the corresponding value. Mapping between values and indexes is displayed as part of the <code class="literal">processing.alghelp()</code> function output, as shown earlier. There is also a separate command for listing such matches—the <code class="literal">processing.algoptions()</code> function. This command accepts only one argument—the command-line name of the algorithm—and its output is a match between the option index <a id="id583" class="indexterm"/>and value for all algorithm parameters with the selection type.</li><li class="listitem"><span class="strong"><strong>Multiple input</strong></span> (<code class="literal">ParameterMultipleInput</code>): This should be passed as a string delimited with<a id="id584" class="indexterm"/> semicolons (<code class="literal">;</code>). Each value can be a layer name or the path to the file.</li><li class="listitem"><span class="strong"><strong>Field of the table</strong></span> (<code class="literal">ParameterTableField</code>): This<a id="id585" class="indexterm"/> is just a string with the field name. Note that this values is case-sensitive.</li><li class="listitem"><span class="strong"><strong>User-defined table</strong></span> (<code class="literal">ParameterFixedTable</code>): This is defined as a list of values separated by commas and enclosed in double quotes. Also, it is possible to pass a 2D list or array <a id="id586" class="indexterm"/>with the values; for example, a small 2 x 2 table can be passed as two-dimensional Python list, like this: <code class="literal">[[0, 1], [2, 3]]</code>. Keep in mind that values should start from the topmost row and go from left to right.</li><li class="listitem"><span class="strong"><strong>Coordinate reference system</strong></span> (<code class="literal">ParameterCrs</code>): Use<a id="id587" class="indexterm"/> the EPSG code of the corresponding CRS.</li><li class="listitem"><span class="strong"><strong>Extent</strong></span> (<code class="literal">ParameterExtent</code>): This is <a id="id588" class="indexterm"/>represented as string containing the <code class="literal">xmin</code>, <code class="literal">xmax</code>, <code class="literal">ymin</code>, and <code class="literal">ymax</code> values delimited by commas (<code class="literal">,</code>).</li><li class="listitem"><span class="strong"><strong>Numerical</strong></span> (<code class="literal">ParameterNumber</code>), <span class="strong"><strong>boolean</strong></span> (<code class="literal">ParameterBoolean</code>)<span class="strong"><strong>, and string</strong></span> (<code class="literal">ParameterString</code>) <span class="strong"><strong>parameters</strong></span>: These are represented by the corresponding native Python data<a id="id589" class="indexterm"/> types: <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">boolean</code>, <code class="literal">str</code>, or <code class="literal">unicode</code>. Also, such parameters<a id="id590" class="indexterm"/> may have default values. To use them, specify <code class="literal">None</code> in the place of the <a id="id591" class="indexterm"/>corresponding parameter.</li></ul></div><p>For output data, the rules are<a id="id592" class="indexterm"/> much simpler. If you want to save a layer, table, file, or HTML output in a particular place, just pass a path to the file. In the case of raster and vector output, the extension of the file will determine the output format. If the given extension is not supported by the algorithm, the output will be saved in the default format (which depends on the algorithm), and the corresponding extension will be added to the specified file path. To write the output to a temporary file, pass the <code class="literal">None</code> value.</p><p>You don't need to define any variables for numerical and string output when running an algorithm from the <a id="id593" class="indexterm"/>Python console. These will be calculated and returned automatically, without any actions from your side. See the <span class="emphasis"><em>Executing the algorithm and loading the results</em></span> section of this chapter for more information about accessing such kinds of output.</p><p>Now that you know the algorithm syntax and how to pass parameters to it, we can execute the algorithm from the QGIS Python console.</p></div><div class="section" title="Executing the algorithm and loading the results"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec56"/>Executing the algorithm and loading the results</h2></div></div></div><p>To execute the algorithm from the QGIS Python console, we need to use the <code class="literal">processing.runalg()</code> method. Generally, this method is called in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>results = processing.runalg(algorithm_name, param1, param2, …, paramN, output1, output2, …, outputM)</strong></span>
</pre></div><p>Here, <code class="literal">algorithm_name</code> is the <a id="id594" class="indexterm"/>command-line algorithm name, <code class="literal">param1...paramN</code> are algorithm parameters, and <code class="literal">output1...outputM</code> are algorithm outputs. Parameters and outputs should be <a id="id595" class="indexterm"/>passed in the same order as shown by the <code class="literal">alghelp()</code> method, considering information about defining input and output from the previous section.</p><div class="note" title="Note"><h3 class="title"><a id="note39"/>Note</h3><p>As we mentioned previously, you don't need to specify any variables for numeric, string, or boolean outputs.</p></div><p>If the algorithm reports its execution progress, a message bar with the progress indicator will be displayed in the main QGIS window during execution.</p><p>Unlike algorithm execution from the toolbox, the <code class="literal">runalg()</code> method does not load any results into QGIS. You can load them manually with the help of the QGIS API or in the following way using the helper methods provided by Processing.</p><p>On successful execution of the algorithm, the <code class="literal">runalg()</code> method returns a dictionary in which the output names (as shown by the <code class="literal">alghelp()</code> method) are the keys and their values are paths to the generated files or contain calculated values.</p><p>To load a generated raster or vector layer, pass the path to the corresponding file to the <code class="literal">load()</code> method. For example, if the result of algorithm execution is saved in the <code class="literal">res</code> variable and the output name is <code class="literal">OUTPUT</code>, then to load this layer into QGIS, execute this code:</p><div class="informalexample"><pre class="programlisting">processing.load(res['OUTPUT'])</pre></div><p>Then, the layer will be loaded into QGIS.</p><p>To access numeric or string output in the results dictionary, just use the corresponding key names.</p><p>Let's load data from the Brooklyn tree cadastre (this is the <code class="literal">trees</code> layer in our dataset), and try to understand how the next small example works and what it does. Run these commands in the QGIS Python console one by one. If necessary, use the <code class="literal">processing</code> helper methods, such as <code class="literal">alglist()</code> and <code class="literal">alghelp()</code>, and examine the results by printing them or loading into QGIS, as mentioned previously:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(1) import processing</strong></span>
<span class="strong"><strong>(2) resGrid = processing.runalg('qgis:creategrid', 3, '972921.0000478327274323,1023822.9999672472476959,147696.9999549686908722,208209.0000113248825073', 1000, 1000, None)</strong></span>
<span class="strong"><strong>(3) resCount = processing.runalg('qgis:countpointsinpolygon', resGrid['OUTPUT'], 'trees', 'NUMPOINTS', None)</strong></span>
<span class="strong"><strong>(4) finalMap = processing.runalg('qgis:extractbyattribute', resCount['OUTPUT'], 'NUMPOINTS', 1, '0', None)</strong></span>
<span class="strong"><strong>(5) processing.load(finalMap['OUTPUT'])</strong></span>
</pre></div><p>If you have read the previous sections carefully, you should understand that these commands are used to generate a hexagonal density map from the point layer. In the first line, we import the <code class="literal">processing</code> module with all its algorithms. In the second line, the <code class="literal">Create grid</code> algorithm is executed, and it creates a hexagonal grid (a parameter with value equal to <code class="literal">3</code> represents hexagonal grid type) using the extent of the <code class="literal">trees</code> layer and cell size equal to <code class="literal">1000</code>. The<a id="id596" class="indexterm"/> result is saved in a temporary file, as we pass the <code class="literal">None</code> value as the last argument. In<a id="id597" class="indexterm"/> line <code class="literal">3</code>, the algorithm <code class="literal">Count points in polygon</code> is executed. As a polygon layer, it uses an output of the <code class="literal">Create grid</code> algorithm (<code class="literal">resGrid['OUTPUT']</code>), and as point layer, already opened trees layer in QGIS is used. Again, the result is stored in the temporary file. Then, in line <code class="literal">4</code>, the <code class="literal">Extract by attribute</code> algorithm is called to save only nonempty cells (a parameter with value <code class="literal">1</code> corresponds to the not equal to operator, <code class="literal">!=</code>). With the last line, the final result is loaded into QGIS.</p><p>Now, that you know how to get all of the necessary information about Processing algorithms and can use them from the QGIS Python console, we can dive into Processing script development.</p></div></div></div>
<div class="section" title="Defining inputs and outputs"><div class="titlepage" id="aid-23MNU2"><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Defining inputs and outputs</h1></div></div></div><p>As we have already said, despite<a id="id598" class="indexterm"/> models, you can create your own Processing scripts using the Python programming language. Basically, Processing script is Python code plus some additional metadata required by Processing.</p><p>Every Processing script starts with a<a id="id599" class="indexterm"/> special block of metadata. This information is needed by Processing to register a script as an algorithm and use it from the toolbox, modeler, and so on. Each metadata entry is placed on a new line, starting with the double Python comment symbol (<code class="literal">##</code>), and has the following structure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>element_name = element_type [optional_parameters]</strong></span>
</pre></div><p>Metadata items can be divided into three groups: items that describe the script, items that describe script input, and items that describe script output.</p><p>There are only three items that describe the script:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">group</code>: This is used to<a id="id600" class="indexterm"/> define the name of the subgroup inside the <span class="strong"><strong>Scripts</strong></span> group in the toolbox where the script will be shown. For example, if you put the following line <code class="literal">##Density maps=group</code> into the script header, it will be placed under the <span class="strong"><strong>Density</strong></span> maps subgroup. If this item is omitted, the script will be placed under the <span class="strong"><strong>Scripts</strong></span> subgroup, which is under <span class="strong"><strong>User</strong></span>.</li><li class="listitem"><code class="literal">name</code>: This defines the script <a id="id601" class="indexterm"/>name. By default, the script name is generated from the name of the script file by dropping the extension and replacing underscores with spaces. If you don't want to use long, descriptive filenames for your scripts but still want nice names in the Processing toolbox, use the <code class="literal">name</code> metadata item. Its syntax is the same as that in the <code class="literal">group</code> item, for example, <code class="literal">##Hexagonal density map=name</code>.</li><li class="listitem"><code class="literal">nomodeler</code>: This<a id="id602" class="indexterm"/> item is a flag. Scripts with such metadata can be used only from the<a id="id603" class="indexterm"/> toolbox. They will be not available in the modeler. Its usage is like this: <code class="literal">##nomodeler</code>.</li></ul></div><p>The number of metadata items that are used to describe script input is a much larger. Scripts support almost all inputs<a id="id604" class="indexterm"/> available in Processing. It is necessary to mention that the item name will also be a variable name, and it can be used in the script code. The value entered or selected by the user while executing the script will be assigned to the corresponding variable.</p><p>Also, the item name will be used as as the caption for the corresponding widget in the algorithm execution dialog. To improve appearance, underscores will be replaced by spaces. So, if you have an item with the name <code class="literal">My_cool_parameter</code> in the script, then its widget will have a caption as <span class="strong"><strong>My</strong></span> <span class="strong"><strong>cool</strong></span> <span class="strong"><strong>parameter</strong></span>. To access the value of this parameter, we need to use the <code class="literal">My_cool_parameter</code> variable.</p><p>Let's look at the available input parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">raster</code>: This describes the<a id="id605" class="indexterm"/> input raster layer. Here is a usage example: <code class="literal">##Raster_layer=raster</code>.</li><li class="listitem"><code class="literal">vector</code>: This describes the<a id="id606" class="indexterm"/> input vector layer. Note that this item should be used if your script accepts vector layers with any geometry type—point, line or polygon. If you want to limit the supported geometry types, use one of the following items. An example of its usage is <code class="literal">##Vector_layer=vector</code>.</li><li class="listitem"><code class="literal">vector point</code>: This describes the<a id="id607" class="indexterm"/> input point vector layer. This item will accept only layers with point geometry. Note that such a limitation is applied only to layers that are already loaded into QGIS. If the user wants to specify a file from the disk, it is their responsibility to select the layer with the correct geometry type. Its usage is like this: <code class="literal">##Vector_layer=vector point</code>.</li><li class="listitem"><code class="literal">vector line</code>: This describes<a id="id608" class="indexterm"/> the input line vector layer. This item will accept only vectors with line geometry. Again, note that such a limitation is applied only to layers that are already loaded into QGIS. If the user wants to specify a file from the disk, it is their responsibility to select the layer with the correct geometry type. Its usage is like this: <code class="literal">##Vector_layer=vector line</code>.</li><li class="listitem"><code class="literal">vector polygon</code>: This<a id="id609" class="indexterm"/> describes the input polygon vector layer. This item will accept only vectors with polygon geometry. Once again, note that such a limitation is applied only to layers that are already loaded in QGIS. If the user wants to specify a<a id="id610" class="indexterm"/> file from the disk, it is their responsibility to select the layer with the correct geometry type. An example usage is as follows: <code class="literal">##Vector_layer=vector polygon</code>.</li><li class="listitem"><code class="literal">table</code>: This is used to <a id="id611" class="indexterm"/>define an input geometryless table. Its usage is like this: <code class="literal">##Table_to_join=table</code>.</li><li class="listitem"><code class="literal">multiple raster</code>: This is <a id="id612" class="indexterm"/>used to define a compound input that consists of several raster layers. An example usage is as follows: <code class="literal">##Layers_to_mosaic=multiple raster</code>.</li><li class="listitem"><code class="literal">multiple vector</code>: This is<a id="id613" class="indexterm"/> used to define compound input that<a id="id614" class="indexterm"/> consists of several vector layers. Note that this input allows us to select any vector layer, regardless of its geometry type. Its usage is like this: <code class="literal">##Layers_to_merge=multiple vector</code>.</li><li class="listitem"><code class="literal">selection</code>: This describes selection from a list of predefined values. The values specified after the<a id="id615" class="indexterm"/> item type are separated by semicolons. An example usage is as follows: <code class="literal">##Method=selection Nearest neighbor;Average;Cubic</code>.</li><li class="listitem"><code class="literal">boolean</code>: This defines a<a id="id616" class="indexterm"/> Boolean (also often called logical) input. It is necessary to specify a default value. Its usage is like this: <code class="literal">##Smooth_results=boolean False</code>.</li><li class="listitem"><code class="literal">extent</code>: This defines the input extent. Its usage is like this: <code class="literal">##Grid_extent=extent</code>.</li><li class="listitem"><code class="literal">file</code>: This is<a id="id617" class="indexterm"/> used to define an input file (in text or in any other format that cannot be recognized by Processing as raster, vector, or table). An example usage is as follows: <code class="literal">##Index_data=file</code>.</li><li class="listitem"><code class="literal">folder</code>: This describes<a id="id618" class="indexterm"/> the input directory. Its usage is like this: <code class="literal">##Input_directory=directory</code>.</li><li class="listitem"><code class="literal">number</code>: This defines a<a id="id619" class="indexterm"/> numerical (integer or floating-point) input. It is necessary to specify a default value. If the default value does not have a decimal separator, then the parameter will accept only integer values. Currently, it is not possible to define minimum and maximum limits for such parameters in scripts. An example usage is as follows: <code class="literal">##Width=number 1000.0</code>.</li><li class="listitem"><code class="literal">field</code>: This describes<a id="id620" class="indexterm"/> an attribute field in the vector layer or geometryless table. It is<a id="id621" class="indexterm"/> necessary to specify the name of the corresponding input that represents the parent layer or table. For example, if a vector<a id="id622" class="indexterm"/> layer is defined as <code class="literal">##Input_layer=vector</code>, then the field of this layer will be defined as <code class="literal">##Classification_field=field Input_layer</code>.</li><li class="listitem"><code class="literal">string</code>: This is used to define a string input. It is necessary to specify a default value. Its usage is like this: <code class="literal">##Field_name=string NUMPOINTS</code>.</li><li class="listitem"><code class="literal">longstring</code>: This<a id="id623" class="indexterm"/> defines a multiline string input. It is necessary to specify a default value. An example of its usage is as follows: <code class="literal">##Options=longstring my cool options</code>.</li><li class="listitem"><code class="literal">crs</code>: This describes the<a id="id624" class="indexterm"/> coordinate reference system. By default, EPSG:4326 is used. If you want another default CRS, specify its <code class="literal">EPSG</code> code. Its usage is like this: <code class="literal">##Assign_CRS=crs EPSG:3857</code>.</li></ul></div><p>Input layers and tables are always passed to the script as strings containing paths to the corresponding files. To create a QGIS object (<code class="literal">QgsVectorLayer</code> or <code class="literal">QgsRasterLayer</code>) from such a string, we need to use the <code class="literal">processing.getObjectFromUri()</code> function. Multiple raster or vector inputs are also passed as strings that contain paths to individual files separated by semicolons.</p><p>Here are all the available outputs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">output raster</code>: This <a id="id625" class="indexterm"/>represents the raster layer generated by the script. Its usage is like this: <code class="literal">##NDVI_raster=output raster</code>.</li><li class="listitem"><code class="literal">output vector</code>: This represents the <a id="id626" class="indexterm"/>vector layer generated by the script. An example of its usage is as follows: <code class="literal">##Vector_grid=output vector</code>.</li><li class="listitem"><code class="literal">output table</code>: This<a id="id627" class="indexterm"/> represents a geometryless table generated by the script. This can be, for example, a CVS or DBF table. Its usage is like this: <code class="literal">##Nearest_points=output table</code>.</li><li class="listitem"><code class="literal">output html</code>: This describes<a id="id628" class="indexterm"/> the output in HTML format. Such an output is mainly used for different textual reports that may or may not include graphics. An example of its usage is as follows: <code class="literal">##Statistics=output html</code>.</li><li class="listitem"><code class="literal">output file</code>: This is used for<a id="id629" class="indexterm"/> files in formats different from HTML and all others supported by QGIS formats. For example, these can be plain text files, LiDAR data, and so on. Its usage is like this: <code class="literal">##Points_connection=output file</code>.</li><li class="listitem"><code class="literal">output directory</code>: This describes<a id="id630" class="indexterm"/> the output directory. It is mainly used for algorithms that produce many files, for example, when splitting the vector layer by attribute values. An example of its usage is as follows: <code class="literal">##Splitted_files=output directory</code>.<div class="note" title="Note"><h3 class="title"><a id="note40"/>Note</h3><p>Note that currently, Processing cannot load files from such output directories, even if these files are in the supported format. You need to manually open each file from the output directory.</p></div></li><li class="listitem"><code class="literal">output number</code>: This<a id="id631" class="indexterm"/> represents a numerical value generated by the algorithm. This value<a id="id632" class="indexterm"/> not saved anywhere and can only be used as the input in another algorithm. For example, one can implement script to calculate optimal cell size for the vector grid, then the numerical output from such algorithm can be used as input in the Create grid algorithm. An example of its usage is as follows: <code class="literal">##Maximum_value=output number</code>.</li><li class="listitem"><code class="literal">output string</code>: This is<a id="id633" class="indexterm"/> similar to the output number described previously. It represents a <a id="id634" class="indexterm"/>string literal generated by the algorithm. Its usage is like this: <code class="literal">##Select_condition=output string</code>.</li></ul></div><p>Numerical and string outputs are also called hidden outputs (because they are not shown in QGIS and in Processing's results dialog), and are not automatically initialized with values. You should manually assign the corresponding values to them.</p><p>All other output will always be a string value with the path to the corresponding output file or directory. If user does not specify any filename, then the output will be saved to the automatically created temporary file, and the name of this file will be used as the output value.</p><p>It is worth mentioning that after successful algorithm execution, Processing will automatically load all output files in the supported formats. So, you don't need to add any <code class="literal">processing.load()</code> function calls to your script.</p></div>
<div class="section" title="Implementing the algorithm"><div class="titlepage" id="aid-24L8G2"><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Implementing the algorithm</h1></div></div></div><p>Now, when we know how to define input and output, we are ready to develop Python scripts for Processing.</p><p>There are two ways to create a script:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Use your favorite text editor or IDE</li><li class="listitem">Use Processing's built-in code editor</li></ul></div><p>Which method to use is a matter of taste and habits. In this book, we will use the built-in script editor. You can open it from the Processing toolbox. Locate and expand the <span class="strong"><strong>Scripts</strong></span> group, expand the <span class="strong"><strong>Tools</strong></span> subgroup, and double-click on the <span class="strong"><strong>Create new script</strong></span> item. Alternatively, you can start typing <code class="literal">Create new script</code> in the filter field. The toolbox's content will be filtered, and you can <a id="id635" class="indexterm"/>easily locate the corresponding item.</p><div class="mediaobject"><img src="../Images/image00515.jpeg" alt="Implementing the algorithm"/></div><p style="clear:both; height: 1em;"> </p><p>The <span class="strong"><strong>Script editor</strong></span> looks like an ordinary text editor as shown in the preceding screenshot. There is a toolbar at the top, and all of the remaining area is used up by the editor itself.</p><p>Now we will see how to create Processing Python scripts by developing a script to find the shortest path between two points on the road network. Such an analysis is very common in many areas of application such as infrastructure planning, trip/travel planning, and so on.</p><p>QGIS has a simple built-in network analysis library that allows us to find the shortest path between two points using <span class="strong"><strong>Dijkstra's algorithm</strong></span>, and also perform some other interesting things, such as building areas of accessibility (also known as service areas) and matching points to the nearest lines.</p><p>First, we need to determine<a id="id636" class="indexterm"/> the script input and output. As input, we need a roads layer, a start point, and an end point. As Processing does not support points as input, the simplest workaround is to pass two vectors, one for the start point and the other for the end point. This solution also allows us to define multiple start and end points and find the shortest path between each pair of start and end points. As for the output, our script obviously will have only one output—a vector layer with the shortest path (or paths) calculated.</p><p>So, the script header will look like this. If you have read the previous sections carefully, you should have no problem understanding it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>1 ##Network analysis=group</strong></span>
<span class="strong"><strong>2 ##Shortest paths=name</strong></span>
<span class="strong"><strong>3 ##Road_layer=vector line</strong></span>
<span class="strong"><strong>4 ##Start_points=vector point</strong></span>
<span class="strong"><strong>5 ##End_points=vector point</strong></span>
<span class="strong"><strong>6 ##Shortest_paths=output vector</strong></span>
</pre></div><p>In the first two lines, we define the group where our script will be placed and the script name. Then, we define the input and output. Note that we use precise definitions for input vector layers, so that when the user runs the script in the input comboboxes, they will see only layers with the geometry type that matches the parameter definition. For example, in the Road layer combobox only line vector layers will be listed.</p><p>After the script header, a script body starts. It contains Python code that implements the desired algorithm. The script body can be divided into two parts: the import section and the code itself.</p><p>Only very simple scripts can be implemented by using Python's basic commands alone. Any more or less complex algorithm will require additional classes or libraries, for example, from the Python standard library, QGIS and Processing libraries, or even some third-party packages. To use these libraries in your code, you need to import them.</p><p>Usually, this is done on an iterative basis: you write the code, and when a new class or library is needed, add the corresponding import statement. As a rule, all import statements are placed at the very beginning of the source's file. For the sake of simplicity, in our sample script, we will provide all the necessary imports from the start. The corresponding code will look as follows:</p><div class="informalexample"><pre class="programlisting">(1) from PyQt4.QtCore import QVariant
(2)
(3) from qgis.core import QGis, QgsFeature, QgsGeometry, QgsField, QgsFields
(4) from qgis.networkanalysis import (QgsLineVectorLayerDirector,
(5)    QgsDistanceArcProperter, QgsGraphBuilder, QgsGraphAnalyzer)
(6)
(7) from processing.core import GeoAlgorithmExecutionException
(8) from processing.tools.vector import VectorWriter</pre></div><p>As you can see, all imports <a id="id637" class="indexterm"/>are divided into three logical blocks with empty lines between them. In the first line, we import the <code class="literal">QVariant</code> class from the <code class="literal">QtCore</code> package of the <code class="literal">PyQt4</code> library. This class contains the definition of the universal variant data type, which will be used to declare attributes of the vector layer.</p><p>In the second block, we import various non-GUI classes from the QGIS core library (the first line of the block) and the QGIS network analysis library (the second line of the block). We need these QGIS core classes to construct our output vector features representing the shortest paths. Moreover, classes from the QGIS network analysis library provide us with all that is necessary for performing network analysis.</p><p>Finally, in the last block, we import some classes from different modules of the QGIS Processing framework. The <code class="literal">GeoAlgorithmExecutionException</code> class will be used to raise exceptions from our script, and <code class="literal">VectorWriter</code> is a helper class that allows us to easily write output vector data in any QGIS-supported format.</p><p>Now we can implement the algorithm itself. As you learned in previous sections, all our inputs—the roads layer, as well as layers with the start and end points—are passed in the form of paths to the corresponding files, so it is necessary to create layer objects from them for further usage. This done with the following code:</p><div class="informalexample"><pre class="programlisting">(1) layerRoads = processing.getObjectFromUri(Road_layer)
(2) layerStartPoints = processing.getObjectFromUri(Start_points)
(3) layerStopPoints = processing.getObjectFromUri(End_points)</pre></div><p>We use the <code class="literal">getObjectFromUri()</code> function<a id="id638" class="indexterm"/> from the processing package. It accepts the path to the file or any other URI and returns a valid layer (raster or vector, depending on the URI) from it. Note that we specify the names of the inputs defined in the script header as arguments in the <code class="literal">getObjectFromUri()</code> function calls. As we have already mentioned in the <span class="emphasis"><em>Defining inputs and outputs</em></span> section, the representing input value has the same name as the corresponding input.</p><p>As we use separate layers for start and end points, it is necessary to verify that both the layers have the same number of features because if the number of points is different, it will be impossible to create start-point-end-point pairs; some points will be without pairs. Here is the code for such a check:</p><div class="informalexample"><pre class="programlisting">(1) if layerStartPoints.featureCount() != layerStopPoints.featureCount():
(2)    GeoAlgorithmExecutionException(
(3)       'Number of features in start and end point layers should be equal!')</pre></div><p>We use the <code class="literal">featureCount()</code> method to get the number of features in the layers with the start and end points and compare them. If the numbers are not equal, an exception is raised and algorithm<a id="id639" class="indexterm"/> execution is aborted.</p><div class="note" title="Note"><h3 class="title"><a id="tip30"/>Tip</h3><p>Always raise <code class="literal">GeoAlgorithmExecutionException</code> when you need to abort script execution because of any error. In this case, the user will see a standard dialog with an error message, and also the error will be stored in the log.</p></div><p>Often, algorithms need some time to complete, so it is good practice to inform the user about the progress of execution and provide some information about the completed steps so that the user will know that the program has not frozen. To do this, each algorithm in Processing provides a special <code class="literal">progress</code> object. With its help, you can easily display different types of messages to the user (information, debug, ordinal text, and so on), as well as show the progress of execution with the progress bar.</p><p>Our script is no exception. There are several potentially long-running tasks that should be performed during the analysis. The first is collecting the coordinates of all start and end points from the corresponding layers. These coordinates will be used later in the step of road graph generation. The corresponding code is given here:</p><div class="informalexample"><pre class="programlisting">(1) progress.setInfo('Gathering start and stop points')
(2)
(3) feats = layerStartPoints.getFeatures()
(4) points = [f.geometry().asPoint() for f in feats]
(5)
(6) feats = layerStopPoints.getFeatures()
(7) tmp = [f.geometry().asPoint() for f in feats]
(8) points.extend(tmp)</pre></div><p>In the first line, we show the user an information message with the <code class="literal">progress.setInfo()</code> command.</p><div class="note" title="Note"><h3 class="title"><a id="note41"/>Note</h3><p>There are also separate commands for displaying plain text (<code class="literal">setText()</code>), debug information (<code class="literal">setDebugInfo()</code>), console output (<code class="literal">setConsoleInfo()</code>), and other message types.</p></div><p>This message will be displayed in the <span class="strong"><strong>Log</strong></span> tab of the algorithm dialog.</p><p>Then we use an iterator on the features of the layer with the start points, extract the geometry of each feature, convert it into a <code class="literal">QgsPoint</code> instance, and store it in the <code class="literal">points</code> list.</p><p>Using the same approach, we<a id="id640" class="indexterm"/> create another list, called <code class="literal">tmp</code>, with the data from the layer containing our end points. In the last line, we merge these two lists into one, so our <code class="literal">points</code> list will contain the start points and then the end points. We need to put all the points in a single list because later, all the points will have to be tied to our road network. This operation is performed for all points at once and at the same time as graph creation. As the number of points in both layers is equal, we can easily access pairs of the start and end points using very simple math. Assuming that the number of points in each layer is <span class="emphasis"><em>N</em></span> and knowing that list indexes in Python start with <span class="emphasis"><em>0</em></span>, we can say that the start points will have indexes from <span class="emphasis"><em>0</em></span> to <span class="emphasis"><em>N-1</em></span>, while the end points will have indexes will be from <span class="emphasis"><em>N</em></span> to <span class="emphasis"><em>2N-1</em></span>. So, if we know the index of a start point, it is easy to get the index of the corresponding end point by adding the total number of points in any input layer to the index of the start point.</p><p>As our script will produce an output vector layer, it is necessary to prepare a special object for saving features in it. Fortunately, Processing has the <code class="literal">VectorWriter</code> class, which provides us with a convenient way to save vector data in any OGR-supported format or QGIS memory layer, without writing many lines of code. Here is the code for creating such a writer object:</p><div class="informalexample"><pre class="programlisting">(1) fields = QgsFields()
(2) fields.append(QgsField('id', QVariant.Int, '', 10))
(3) fields.append(QgsField('startPoint', QVariant.String, '', 254))
(4) fields.append(QgsField('endPoint', QVariant.String, '', 254))
(5) fields.append(QgsField('length', QVariant.Double, '', 20, 7))
(6)
(7) writer = VectorWriter(Shortest_paths, None, fields.toList(),
(8)                   QGis.WKBLineString, layerRoads.crs())</pre></div><p>In the first five lines of code here, we create an instance of the <code class="literal">QgsFields</code> container, where our attributes' definitions will be saved, and populate it. Our example script output layer will have four attributes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">id</code>: This is the integer numeric identifier of the path</li><li class="listitem"><code class="literal">startPoint</code>: These are the coordinates of the start point of the path in the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) format</li><li class="listitem"><code class="literal">endPoint</code>: These are the coordinates of the end point of the path in the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) format</li><li class="listitem"><code class="literal">length</code>: This is the total length of the path</li></ul></div><p>In the last line, an instance of the <code class="literal">VectorWriter</code> class was created. We pass the paths to the output file defined by the user, the list of attributes that we created previously, the geometry type, and the coordinate<a id="id641" class="indexterm"/> reference system to the constructor. Note that as the path to the output file, we specify the same variable that we used in the script header to describe the output. Also, the coordinate reference system is taken from the input roads layer, so our output will be in the same CRS.</p><p>Almost all the preparation steps needed for now are done, and now we can use the QGIS network analysis library to create a graph from our roads layer. This step is required because network analysis operates with the graph and not with the vector layer. Before creating the graph, it is necessary to instantiate all the required classes and adjust the settings. The following lines of code show you how to do this:</p><div class="informalexample"><pre class="programlisting">(1) director = QgsLineVectorLayerDirector(layerRoads, -1, '', '', '', 3)
(2) properter = QgsDistanceArcProperter()
(3) director.addProperter(properter)
(4) builder = QgsGraphBuilder(layerRoads.crs())</pre></div><p>First, we instantiate the so-called director, which is a base class that adjusts some settings of the graph creation process. The director accepts the parameters explained here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The line vector layer from which a graph will be constructed.</li><li class="listitem">The index of the attribute field where the road's direction is stored. As we don't take road directions into account, we'll pass <code class="literal">-1</code> here.</li><li class="listitem">The attribute value that represents the direct road direction for one-way roads. Direct direction means that you can move on such a road only from the start point to the end point of the road. In our example, we won't use direction information, so we pass an empty string here.</li><li class="listitem">The attribute value that represents the reverse road direction for one-way roads. When a road has reverse direction, you can only move from the end point to the start point of the road. In our example, we won't use direction information, so we pass an empty string here.</li><li class="listitem">The attribute value that represents bidirectional, or two-way, roads. Bidirectional roads are the most common roads. They allow us to move in both directions: from the start to the end, and from the end to the start. In our example, we don't use direction information, so again we pass an empty string here.</li><li class="listitem">The default road direction. This argument defines how to treat roads that have no direction information in the field specified by the first argument. It can be one of these values: <code class="literal">1</code> for direct direction, <code class="literal">2</code> for reverse direction, and <code class="literal">3</code> for bidirectional roads. For the sake of simplicity, we will treat all roads as two-way roads, so we will use the value <code class="literal">3</code>.</li></ul></div><p>The shortest path between two points can be calculated using different criteria (in the QGIS network analysis library, these are called properters) or even their combination—length, travel time, travel cost, and so on. There is only one built-in criteria for now in the network analysis library—<code class="literal">QgsDistanceArcProperter</code>—which takes the road length into account. Of course, we <a id="id642" class="indexterm"/>can add our own criteria, but for the sake of simplicity in our demo script, we will use a built-in criteria. The properter is instantiated in the second line and added to the already created director in the third line.</p><p>In the fourth line, we create the so-called builder—a class that generates a graph using settings specified by the director. The only argument that we pass to the builder is the coordinate reference system we want to use. Usually, this is the same CRS as that of the input road layer.</p><p>Now that all the settings are done, we can create the graph, which will be used to find the shortest path, as follows:</p><div class="informalexample"><pre class="programlisting">(1) progress.setInfo('Generating road graph...')
(2) tiedPoints = director.makeGraph(builder, points)
(3) graph = builder.graph()
(4) del points</pre></div><p>As graph generation is a time-consuming operation, especially on a dense road network and for a large number of start and end points, we show an information message to the user before generating the graph itself.</p><p>The most important line in this snippet is the second one, where the <code class="literal">makeGraph()</code> method is called. The arguments are <code class="literal">builder</code>, which holds all the settings for the process of graph generation, and <code class="literal">points</code>, which is a list of our start and end points. As points may not be located exactly on the road, it is necessary to match them to the nearest road link. This happens in the same step as graph creation, and the <code class="literal">makeGraph()</code> method returns a list of so-called tied points, or in other words, points that are placed exactly on the nearest road segment.</p><p>In the third line, we get the graph object itself from the builder and store it for further usage. As we don't need the original points now (all further work will be done with the tied points), we delete them in the last line to free the memory.</p><div class="note" title="Note"><h3 class="title"><a id="note42"/>Note</h3><p>More information <a id="id643" class="indexterm"/>about the QGIS network analysis library is available in <span class="emphasis"><em>PyQGIS Developer Cookbook</em></span> at <a class="ulink" href="http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html">http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html</a>.</p></div><p>Now that we have our road graph and points matched to the nearest road links, we can start finding the shortest path for each start-point-end-point pair. But first, we need to perform some helper<a id="id644" class="indexterm"/> actions, as follows:</p><div class="informalexample"><pre class="programlisting">(1) count = layerStartPoints.featureCount()
(2) total = 100.0 / float(count)
(3)
(4) ft = QgsFeature()
(5) ft.setFields(fields)</pre></div><p>The first two lines are used to prepare values for progress reporting. The progress bar displays values from <code class="literal">0</code> to <code class="literal">100</code> percent, and we need to process <code class="literal">count</code> pairs of points (equal to the number of features in any input point layer). Then, a single step value will be equal to <code class="literal">100</code> divided to the<a id="id645" class="indexterm"/> number of pairs.</p><p>In the last two lines, we just prepare a vector feature instance for our output routes and assign previously defined attributes to it.</p><p>Finding the shortest path is done in the loop, as follows:</p><div class="informalexample"><pre class="programlisting">( 1) progress.setInfo('Finding shortest paths...')
( 2) for i in xrange(count):
( 3)    nStart = tiedPoints[i]
( 4)    nStop = tiedPoints[count + i]
( 5)    idxStart = graph.findVertex(nStart)
( 6)    idxStop = graph.findVertex(nStop)
( 7)
( 8)    tree, cost = QgsGraphAnalyzer.dijkstra(graph, idxStart, 0)
( 9)
(10)    if tree[idxStop] == -1:
(11)        progress.setInfo('No path found from point ({:.6f}, {:.6f}) '
(12)           'to point ({:.6f}, {:.6f})'.format(
(13)              nStart.x(), nStart.y(), nStop.x(), nStop.y()))
(14)    else:
(15)        nodes = []
(16)        curPos = idxStop
(17)        while curPos != idxStart:
(18)           nodes.append(graph.vertex(
(19)              graph.arc(tree[curPos]).inVertex()).point())
(20)           curPos = graph.arc(tree[curPos]).outVertex()
(21)
(22)        nodes.append(nStart)
(23)        nodes.reverse()
(24)
(25)        ft.setGeometry(QgsGeometry.fromPolyline(nodes))
(26)        ft['id'] = i
(27)        ft['startPoint'] = '({:.6f}, {:.6f})'.format(nStart.x(), nStart.y())
(28)        ft['endPoint'] = '({:.6f}, {:.6f})'.format(nStop.x(), nStop.y())
(29)        ft['length'] = ft.geometry().length()
(30)        writer.addFeature(ft)
(31)
(32)        progress.setPercentage(int(i * total))</pre></div><p>In the first line, we inform the user about next algorithm step. In lines <code class="literal">3</code> and <code class="literal">4</code>, we get the next pair of the start and end points from the list of tied points. In the next two lines, indexes of these points on the road graph are obtained.</p><p>In line 8, the actual route<a id="id646" class="indexterm"/> calculation takes place. The <code class="literal">dijkstra()</code> method returns a tree with the shortest path from the tree root defined by the point with the <code class="literal">idxStart</code> index (this is our start point from the current point pair) to all other graph nodes.</p><p>From lines <code class="literal">10</code> to <code class="literal">23</code>, we go through the shortest path tree and collect all the points that form a way from the end point to the start point.</p><p>After that, from lines <code class="literal">25</code> to <code class="literal">30</code>, we create a line geometry from the collected points, assign it to the feature, and also set its attributes. Then the feature is passed to the writer object and stored in the output layer.</p><p>Finally, in line <code class="literal">32</code>, we update the progress bar to inform the user about the algorithm's execution status.</p><p>When all the point pairs are processed, we need to carry out a cleanup and delete unused objects, such as the road graph and output writer:</p><div class="informalexample"><pre class="programlisting">(1) del graph
(2) del writer</pre></div><p>That's all! Now you can save the script and test it by clicking on the <span class="strong"><strong>Run</strong></span> algorithm button on the <span class="strong"><strong>Script</strong></span> <span class="strong"><strong>editor</strong></span> toolbar. The algorithm dialog will look like what is shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00516.jpeg" alt="Implementing the algorithm"/></div><p style="clear:both; height: 1em;"> </p><p>You can load the <code class="literal">roads</code>, <code class="literal">start_points</code>, and <code class="literal">end_points</code> layers from your dataset and run the algorithm with this data. Alternatively, you can use your own layer with a road network, create two <a id="id647" class="indexterm"/>point layers for start and end points, populate them with features, and execute the script. Here is what the results may look like:</p><div class="mediaobject"><img src="../Images/image00517.jpeg" alt="Implementing the algorithm"/></div><p style="clear:both; height: 1em;"> </p><p>It is necessary to mention that while the QGIS network analysis library provides all the necessary tools for network analysis and can easily be extended by the user, it also has some limitations and is not suitable for work with very large and dense road networks. For such situations, it is <a id="id648" class="indexterm"/>better to use more powerful tools, such as pgRouting.</p></div>
<div class="section" title="Writing help and saving" id="aid-25JP21"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Writing help and saving</h1></div></div></div><p>As in the case of model, it is good <a id="id649" class="indexterm"/>practice to document your scripts. A script's documentation contains its description as well as information about all inputs <a id="id650" class="indexterm"/>and outputs. This helps users to understand the purpose of the script.</p><p>To create a help file for<a id="id651" class="indexterm"/> the script, open it in the built-in Processing script editor and click on the <span class="strong"><strong>Edit</strong></span> <span class="strong"><strong>script</strong></span> <span class="strong"><strong>help</strong></span> button on the editor toolbar. A <span class="strong"><strong>Help</strong></span> editor dialog, familiar to us from the <span class="emphasis"><em>Filling model metadata and saving</em></span> section of <a class="link" title="Chapter 8. Automating Analysis with Processing Models" href="part0062.xhtml#aid-1R42S1">Chapter 8</a>, <span class="emphasis"><em>Automating Analysis with Processing Models</em></span>, opens.</p><div class="mediaobject"><img src="../Images/image00518.jpeg" alt="Writing help and saving"/></div><p style="clear:both; height: 1em;"> </p><p>This dialog is divided into three areas. On the top, there is a preview area. Here the current help content is displayed so that you can see in real-time mode how the final result will look. In the bottom-left<a id="id652" class="indexterm"/> part is the elements tree, where all the help sections are listed, including algorithm description, parameters, input, and other information. In the bottom-right part, there is <a id="id653" class="indexterm"/>an editing area. Here, we will enter the description of the corresponding element.</p><p>To edit the description of the element, select it in the elements list and enter some text in the <span class="strong"><strong>Element</strong></span> <span class="strong"><strong>description</strong></span> field. To save the changes, just select another element in the elements tree.</p><p>Go through all the items in the elements tree and enter the descriptions. For example, for <span class="strong"><strong>Algorithm</strong></span> <span class="strong"><strong>description</strong></span>, you can use this text:</p><div class="informalexample"><pre class="programlisting">Calculates shortest path(s) between pairs of the start and end points on the given road network using QGIS network analysis library. Note: script does not takes into account road directions, all roads treated as two-ways roads.</pre></div><p>You can describe <a id="id654" class="indexterm"/>all the other fields yourself. Try to be short and, at the same time, give as much useful information as possible. Don't explain obvious things; it's better to concentrate on important details. For example, in the description of the start and end points layers, it is worth mentioning that the number of features in them should be equal. When you're done, click on the <span class="strong"><strong>OK</strong></span> button to close the <span class="strong"><strong>Help editor</strong></span> dialog.</p><p>To save the script help, click on the <span class="strong"><strong>Save</strong></span> button on the <span class="strong"><strong>Script editor</strong></span> toolbar. The script will be saved and its help will be written alongside, with the script file using the same name as used by the <a id="id655" class="indexterm"/>script with the addition of the <code class="literal">.help</code> suffix.</p></div>
<div class="section" title="Sharing scripts" id="aid-26I9K1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Sharing scripts</h1></div></div></div><p>If you have created a useful script that may help other users, it would be good to share it with the community so that others don't need to reinvent the wheel.</p><p>The most obvious and easiest<a id="id656" class="indexterm"/> way to share a Processing Python script is just to send it to those who are interested, or upload it to any file-sharing or hosting site and make the link to this file available to everyone. It is necessary to remember that in contrast to the models, script help is stored in a separate file, not in the script itself. So, you should not forget to include the script help file when uploading or sending.</p><p>A slightly more complex way—but at the same time, very convenient and user-friendly—is to publish your script on the Processing models and scripts community repository. This repository was created in the spring of 2014, and provides a centralized way to share Processing scripts and models among QGIS users.</p><p>To put your script into the repository, you<a id="id657" class="indexterm"/> need to fork the <span class="emphasis"><em>GitHub</em></span> repository (<a class="ulink" href="https://github.com/qgis/QGIS-Processing">https://github.com/qgis/QGIS-Processing</a>), commit your script and its help file in your fork in the scripts directory, and issue a pull request.</p><div class="note" title="Note"><h3 class="title"><a id="tip31"/>Tip</h3><p>To learn more about Git, use one of Packt Publishing's books, for example, <span class="emphasis"><em>Git: Version Control for Everyone</em></span>, by Ravishankar Somasundaram, and refer to the GitHub documentation<a id="id658" class="indexterm"/> at <a class="ulink" href="https://help.github.com/">https://help.github.com/</a>.</p></div><p>Another option is to send the model to the Qgis-developer mailing list, or send it directly to one of Processing's developers and ask them to put it into the repository.</p><p>To get scripts from<a id="id659" class="indexterm"/> this repository, use the <span class="strong"><strong>Get scripts from on-line script collection</strong></span> tool, which is located in the <span class="strong"><strong>Tools</strong></span> subgroup under the <span class="strong"><strong>Scripts</strong></span> item in the <span class="strong"><strong>Processing</strong></span> toolbox.</p></div>
<div class="section" title="Summary" id="aid-27GQ61"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Summary</h1></div></div></div><p>In this chapter, you learned how to develop your own Python scripts for the QGIS Processing framework and automate analysis with their help. Python scripts are an alternative to Processing's models and give us more flexibility than models. You learned how to get information about available Processing algorithms and how to call them from the Python console. Then, you got to know the main parts of a Processing script: the header with meta-information and the script body. Finally, we developed a simple script to calculate the shortest path between two points for a given road network.</p><p>In the next chapter, you will get to know another way to extent the QGIS functionality—by developing your own Python plugin.</p></div></body></html>