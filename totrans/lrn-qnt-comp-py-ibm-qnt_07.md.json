["```py\n# Load helper file\n%run helper_file_1.0.ipynb\nqc = QuantumCircuit(2,2) \n```", "```py\n# Import registers\nfrom qiskit import QuantumRegister, ClassicalRegister\nqr = QuantumRegister(2, 'my_QR')\ncr = ClassicalRegister(2, 'my_CR')\nqc = QuantumCircuit(qr,cr)\nqc.draw(output='mpl') \n```", "```py\nqc = QuantumCircuit(QuantumRegister(2, 'my_QR'), ClassicalRegister(2, 'my_CR')) \n```", "```py\n    #Create the quantum and classical registers, each with \n    #labels\n    qr1 = QuantumRegister(2, name='qr1')\n    cr1 = ClassicalRegister(2, name='cr1')\n    #Create the quantum circuit using the registers\n    qc1 = QuantumCircuit(qr1, cr1)\n    #Draw the circuit\n    qc1.draw(output='mpl') \n    ```", "```py\n    #Create two Quantum and Classical registers\n    qr2 = QuantumRegister(2, name='qr2')\n    cr2 = ClassicalRegister(2, name='cr2')\n    #Create a second circuit using the registers created \n    #above\n    qc2 = QuantumCircuit(qr2, cr2)\n    #Draw the second quantum circuit\n    qc2.draw(output='mpl') \n    ```", "```py\n    #Concatenate the two previous circuits to create a new #circuit\n    #Create an empty quantum circuit\n    qc_combined = QuantumCircuit()\n    #Add the two previous quantum and classical \n    #registers to the empty quantum circuit\n    qc_combined.add_register(qr1, qr2, cr1, cr2)\n    #Draw the concatenated circuit\n    qc_combined.draw(output='mpl') \n    ```", "```py\n#Import the random_circuit class\nfrom qiskit.circuit.random import random_circuit\n#Construct the random circuit with the number of qubits = 3\n#with a depth = 2, and include the measurement operator for \n#each qubit\nqc = random_circuit(3, 2, measure=True)\n#Draw the circuit\nqc.draw(output='mpl') \n```", "```py\n#Import the random circuit class\nfrom qiskit.circuit.random import random_circuit\n#Create two random circuits, each with 2 qubit registers and \n#random gate operator counts.\nqc1 = random_circuit(2,2)\nqc2 = random_circuit(2,4)\n#Concatenate the two random circuits into one\nqc = qc1.compose(qc2, [0,1])\n#Draw the circuit\nqc.draw(output='mpl') \n```", "```py\n#Define function to print circuit properties:\ndef print_circuit_props(qc):\n    width = qc.width()\n    depth = qc.depth()\n    num_operators = qc.count_ops()\n    circuit_size = qc.size()\n    print('Width = ', width)\n    print('Depth = ', depth)\n    print('Circuit size = ', circuit_size)\n    print('Number of operators = ', num_operators) \n```", "```py\n#Pass our quantum circuit to print out the circuit properties\nprint_circuit_props(qc) \n```", "```py\nWidth =  2\nDepth =  6\nCircuit size =  7\nNumber of operators =  OrderedDict([('cu3', 2), ('z', 1), ('tdg', 1), ('crz', 1), ('cz', 1), ('ch', 1)]) \n```", "```py\n#Use measure_all() to automatically add the barrier, \n#measurement, and classical register to our existing circuit.\nqc.measure_all()\n#Draw the circuit\nqc.draw(output='mpl') \n```", "```py\n#Print out the circuit properties\nprint_circuit_props(qc) \n```", "```py\nWidth =  4\nDepth =  7\nCircuit size =  9\nNumber of operators =  OrderedDict([('cu3', 2), ('measure', 2), ('z', 1), ('tdg', 1), ('crz', 1), ('cz', 1), ('ch', 1), ('barrier', 1)]) \n```", "```py\n    qc = QuantumCircuit(3)\n    qc.ccx(0,1,2)\n    qc.draw(output='mpl') \n    ```", "```py\n    #Print out the circuit properties\n    print_circuit_props(qc) \n    ```", "```py\nWidth = 3\nDepth = 1\nCircuit size = 1\nNumber of operators = OrderedDict([('ccx', 1)]) \n```", "```py\n    #Print out the circuit properties\n    print_circuit_props(qc.decompose()) \n    ```", "```py\nWidth = 3\nDepth = 11\nCircuit size = 15\nNumber of operators = OrderedDict([('cx', 6), ('t', 4), ('tdg', 3), ('h', 2)]) \n```", "```py\n    #Create a custom two-qubit composite gate\n    #Create the quantum register\n    qr = QuantumRegister(2, name='qr_c')\n    #Generate quantum circuit which will make up the \n    #composite gate\n    comp_qc = QuantumCircuit(qr, name='My-composite')\n    #Add any gates you wish to your composite gate\n    comp_qc.h(0)\n    comp_qc.cx(0, 1)\n    #Create the composite instructions by converting\n    #the QuantumCircuit to a list of Instructions\n    composite_inst = comp_qc.to_instruction()\n    #Draw the circuit which will represent the composite gate\n    comp_qc.draw(output='mpl') \n    ```", "```py\n    #Create your 2-qubit circuit to generate your composite gate\n    qr2 = QuantumRegister(3, 'qr')\n    #Create a quantum circuit using the quantum register\n    qc = QuantumCircuit(qr2)\n    #Add any arbitrary gates that would represent the function\n    #of the composite gate\n    qc.h(0)\n    qc.cx(0,1)\n    qc.cx(0,2)\n    #Draw the composite circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    #Append your composite gate to the specified qubits.\n    qc.append(composite_inst, [qr2[0], qr2[1]])\n    #Draw the complete circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    #Import the Parameter object\n    from qiskit.circuit import Parameter\n    #Construct the Parameter set to Theta\n    param_theta = Parameter('Ө')\n    #Create a two-qubit quantum circuit and add some gates\n    qc = QuantumCircuit(2)\n    qc.h(0)\n    qc.cx(0, 1)\n    #Include a rotation gate which we wish to apply\n    #the Parameter value\n    qc.rz(param_theta, 0)\n    qc.rz(param_theta, 1)\n    #Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    import numpy as np\n    #Bind the parameters with a value, in this case 2π\n    qc = qc.assign_parameters(parameters={param_theta: 2*np.pi})\n    #Draw the circuit with the set parameter values\n    qc.draw(output='mpl') \n    ```", "```py\n#Import pulse classes\nfrom qiskit.pulse import Waveform, DriveChannel, Play, Schedule \n```", "```py\n#Import numpy and generate the sine sample values\nimport numpy as np\nx = np.linspace(0,2*np.pi,64)\ndata = np.sin(x)\n#Generate our Waveform\nwaveform = Waveform(data, name=\"sine_64_pulse\")\n#Draw the generated waveform\nwaveform.draw() \n```", "```py\n#Import the Gaussian Square pulse from Pulse Library\nfrom qiskit.pulse.library import GaussianSquare\n#Create a Gaussian Square pulse\n#Args: duration, amp, sigma, width, name\ngaussian_square_pulse = GaussianSquare(128, 1, 2, 112, name=\"gaussian square\")\ngaussian_square_pulse.draw() \n```", "```py\n    #Create the first schedule with our Gaussian Square pulse\n    schedule_1 = Schedule(name='Schedule 1')\n    schedule_1 = schedule_1.insert(0, \n            Play(gaussian_square_pulse, DriveChannel(0)))\n    #Draw the schedule\n    schedule_1.draw() \n    ```", "```py\n    #Create a second schedule with our sample pulse\n    schedule_2 = Schedule(name='Schedule 2')\n    schedule_2 = schedule_2.insert(0, Play(waveform, DriveChannel(0)))\n    #Draw the schedule\n    schedule_2.draw() \n    ```", "```py\n    #Let's create a third schedule, where we add the first \n    #schedule and second schedules and shift the second \n    # to the right by a time of 5 after the first\n    schedule_3 = schedule_1.insert(schedule_1.duration+5, schedule_2)\n    schedule_3.draw() \n    ```", "```py\n    #We could have also combined the two using the append operator\n    #The two schedules are appended immediately after one #another\n    schedule_3_append = schedule_1.append(schedule_2)\n    schedule_3_append.draw() \n    ```", "```py\n#Run the simple quantum circuit on local Sampler\nfrom qiskit.primitives import Sampler\nsampler = Sampler()\n#Let's create a simple circuit\nqc = QuantumCircuit(1,1)\nqc.h(0)\nqc.measure([0],[0])\n#Let's run a circuit with the Sampler primitive\njob = sampler.run(qc, shots=1024)\nprint(job.status()) \n```", "```py\nJob Status: JobStatus.DONE \n```", "```py\n#From the previous output of executed jobs, obtain its job id \n#and print out information about the Job.\nprint('Print Job ID: ', job.job_id())\nprint('Print Job Status: ', job.status())\nprint('Print Job Result: ', job.result()) \n```", "```py\nPrint Job ID:  dc25c6bd-2ce6-41d5-9caf-f1326f70b90d\nPrint Job Status:  JobStatus.DONE\nPrint Job Result:  SamplerResult(quasi_dists=[{0: 0.5107421875, 1: 0.4892578125}], metadata=[{'shots': 1024}]) \n```", "```py\njob_result = job.result()\nquasi_dists = job_result.quasi_dists\n# Get result counts\ncounts = quasi_dists[0].binary_probabilities()\n#Print and plot results\nprint(counts)\nplot_distribution(counts) \n```", "```py\n{'0': 547, '1': 477} \n```"]