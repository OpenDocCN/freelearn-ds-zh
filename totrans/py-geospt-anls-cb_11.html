<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Web Analysis with GeoDjango</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up a GeoDjango web application</li><li class="listitem" style="list-style-type: disc">Creating an indoor web routing service</li><li class="listitem" style="list-style-type: disc">Visualizing an indoor routing service</li><li class="listitem" style="list-style-type: disc">Creating an indoor route-type service</li><li class="listitem" style="list-style-type: disc">Creating an indoor route from room to room</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec74"/>Introduction</h1></div></div></div><p>Our final chapter is all about extending our analysis into a web application using the <a id="id478" class="indexterm"/>
<strong>Django</strong> web framework. One of the standard Django contributed packages is known as <strong>GeoDjango</strong>
<a id="id479" class="indexterm"/> and is found in the <code class="literal">django/contrib/gis</code> package. This is a feature-packed GIS toolset for geospatial web application development. The spatial libraries used here depend on the spatial database backend that you choose. For PostgreSQL the library requirements include GEOS, PROJ.4, and PostGIS.</p><p>Django is known for its good documentation and the <code class="literal">gis contrib</code> package<a id="id480" class="indexterm"/> installation is no exception, having its own set of instructions for you to follow at <a class="ulink" href="https://docs.djangoproject.com/en/dev/ref/contrib/gis/">https://docs.djangoproject.com/en/dev/ref/contrib/gis/</a>.</p><p>Since GeoDjango is part of the standard Django installation, you will see that your first step is to install the Django framework. For any reference on installing GeoDjango, PostgreSQL, and PostGIS, take a look at <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <em>Setting Up Your Geospatial Python Environment</em>.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec75"/>Setting up a GeoDjango web application</h1></div></div></div><p>We need to get some basic <a id="id481" class="indexterm"/>Django groundwork done and this will be a very high-level fly over at setting up the required basics to start a Django web application. Check out the official Django<a id="id482" class="indexterm"/> tutorials for further information at <a class="ulink" href="https://docs.djangoproject.com/en/dev/intro/tutorial01/">https://docs.djangoproject.com/en/dev/intro/tutorial01/</a>.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>If you are not familiar with Django or GeoDjango, I would highly recommend that you read through and complete the online tutorials, starting with Django at <a class="ulink" href="https://docs.djangoproject.com/en/dev/">https://docs.djangoproject.com/en/dev/</a> followed by the GeoDjango tutorial at <a class="ulink" href="https://docs.djangoproject.com/en/dev/ref/contrib/gis/tutorial/">https://docs.djangoproject.com/en/dev/ref/contrib/gis/tutorial/</a>. For this chapter, it is assumed that you are familiar with Django, have completed the entire online Django tutorial, and are, therefore, familiar with Django concepts.</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec176"/>Getting ready</h2></div></div></div><p>We are going to <a id="id483" class="indexterm"/>build a routing web service using <a id="id484" class="indexterm"/>the <em>Django REST framework</em> (<a class="ulink" href="http://www.django-rest-framework.org/">http://www.django-rest-framework.org/</a>). All that we need to implement is a basic web service that you can install with the help of <code class="literal">pip</code>:</p><div><pre class="programlisting">
<strong>&gt;pip install djangorestframework==3.1.3</strong>
</pre></div><p>This will install version 3.1.3, the latest version. If you want to install the newest version, simply enter the following command but, beware, it might not work with this example:</p><div><pre class="programlisting">
<strong>&gt;pip install djangorestframework</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec177"/>How to do it...</h2></div></div></div><p>Let's now create a Django project using the <code class="literal">django-admin</code> tool as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">From the command line, enter the <code class="literal">/ch11/code</code> directory and execute this command:<div><pre class="programlisting">
<strong>&gt; django-admin startproject web_analysis</strong>
</pre></div></li><li class="listitem">Now you will have a <code class="literal">/ch11/code/web_analysis/web_analysis</code> directory and inside it, you'll find all the standard basic Django components.</li><li class="listitem">To create our web service, we are going to place all the services into a Django App called <code class="literal">api</code>. This app will store all our services. Creating this <code class="literal">api</code> application is as easy as typing this code:<div><pre class="programlisting">
<strong>&gt; cd web_analysis</strong>
</pre></div><p>Change into the newly created <code class="literal">web_analysis</code> directory:</p><div><pre class="programlisting">
<strong>&gt; django-admin startapp api</strong>
</pre></div><p>Now create your new application called "api".</p></li><li class="listitem">This creates a new <code class="literal">/ch11/code/web_analysis/api</code> folder and inside it you will find the default installed Django app files. Next, we need to tell Django <a id="id485" class="indexterm"/>about the Django REST Framework, GeoDjango gis app, and our new <code class="literal">api</code> application; we do this in our <code class="literal">/ch11/code/web_analysis/web_analysis/settings.py</code> file. Let's add the lines <code class="literal">'django.contrib.gis'</code>, <code class="literal">'rest_framework'</code>, and <code class="literal">'api'</code> to our <code class="literal">INSTALLED_APPS</code> variable as follows:<div><pre class="programlisting">
<strong>INSTALLED_APPS = (</strong>
<strong>    'django.contrib.admin',</strong>
<strong>    'django.contrib.auth',</strong>
<strong>    'django.contrib.contenttypes',</strong>
<strong>    'django.contrib.sessions',</strong>
<strong>    'django.contrib.messages',</strong>
<strong>    'django.contrib.staticfiles',</strong>

<strong>    #### GeoDjango Contrib APP</strong>
<strong>    # 'django.contrib.gis',</strong>

<strong>    #### third party apps</strong>
<strong>    'rest_framework',</strong>
<strong>    </strong>
<strong>    ##### our local apps</strong>
<strong>    'api', </strong>
<strong>    </strong>
<strong>)</strong>
</pre></div></li><li class="listitem">To enable the GeoDjango spatial models and spatial capabilities, <code class="literal">'django.contrib.gis'</code> will allow us to access the rich geospatial framework. We have it commented out at this point since we are not going to use it until later, but feel free to uncomment it as this will do no harm. This spatial framework requires a spatial database and we will use PostgreSQL with PostGIS as our backend. Let's go ahead and change the database connection now in our <code class="literal">settings.py</code> as follows:<div><pre class="programlisting">DATABASES = {
    'default': {
        # PostgreSQL with PostGIS
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': 'py_geoan_cb', # DB name
        'USER': 'saturn', # DB user name
        'PASSWORD': 'secret', # DB user password
        'HOST': 'localhost',
        'PORT': '5432',
    }
}</pre></div><div><div><h3 class="title"><a id="note45"/>Note</h3><p>The database here is referencing the same <em>PostgreSQL + PostGIS</em> database that we created earlier on in <a class="link" href="ch03.html" title="Chapter 3. Moving Spatial Data from One Format to Another">Chapter 3</a>, <em>Moving Spatial Data from One Format to Another</em>. Visit the <em>Converting a Shapefile to a PostGIS table using ogr2ogr,</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. Moving Spatial Data from One Format to Another">Chapter 3</a>, <em>Moving Spatial Data from One Format to Another</em> where we created the <code class="literal">py_geoan_cb</code> database, if you are going to skip ahead to this section.</p></div></div></li><li class="listitem">Our final <code class="literal">settings.py</code> configuration is set up to log errors and exceptions to a log file, catching errors<a id="id486" class="indexterm"/> if any occur. First up, we'll create a new folder called <code class="literal">/web_analysis/logs</code> and add two new files called <code class="literal">debug.log</code> and <code class="literal">verbose.log</code>. We will write any errors that occur into these two files and log a request or simply print out an error to these files. So, go ahead and copy this code into the bottom of your <code class="literal">/web_analysis/web_analysis/settings.py</code> file as follows:<div><pre class="programlisting">LOGGING_CONFIG = None

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format' : "[%(asctime)s] %(levelname)s [%(name)s:%(lineno)s] %(message)s",
            'datefmt' : "%d/%b/%Y %H:%M:%S"
        },
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
    },
    'handlers': {
        'file_verbose': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': 'logs/verbose.log',
            'formatter': 'verbose'
        },
        'file_debug': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': 'logs/debug.log',
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'django': {
            'handlers':['file_verbose'],
            'propagate': True,
            'level':'DEBUG',
        },
        'api': {
            'handlers': ['file_debug'],
            'propagate': True,
            'level': 'DEBUG',
        },

    }
}

import logging.config
logging.config.dictConfig(LOGGING)</pre></div></li><li class="listitem">Next up, let's <a id="id487" class="indexterm"/>create a new database user and a separate PostgreSQL schema to store all our Django-related tables; otherwise, all the new Django tables will automatically be created in the PostgreSQL default schema public. Our new user is called <code class="literal">saturn</code> and can log in with the <code class="literal">secret</code> password. To create a new user, you can use the command-line tool that's run as the <code class="literal">postgres</code> user:<div><pre class="programlisting">
<strong>&gt;createuser saturn</strong>
</pre></div><p>You can also use the PGAdmin free tool. On Ubuntu, don't forget to change to the <code class="literal">postgres</code> user that will allow you to create a new user on your database.</p></li><li class="listitem">Now, let's <a id="id488" class="indexterm"/>create a new schema called <code class="literal">django</code> that will store all our Django application tables. Use PGAdmin or the SQL command to do this as follows:<div><pre class="programlisting">
<strong>CREATE SCHEMA django AUTHORIZATION saturn;</strong>
</pre></div></li><li class="listitem">With this new schema in place, we only need to assign the PostgreSQL <code class="literal">search_path</code> variable order to set the <code class="literal">django</code> schema as the first priority. To accomplish this, we need to use the SQL <code class="literal">ALTER ROLE </code>command as follows:<div><pre class="programlisting">ALTER ROLE saturn SET search_path = django, geodata, public, topology;</pre></div></li><li class="listitem">This sets the <code class="literal">search_path</code> order defining <code class="literal">django</code> as the first schema, <code class="literal">geodata</code> as the second, and so forth. This order is for all database connections for the <code class="literal">saturn</code> user. When we create our new Django tables, all of them will now automatically be created inside the <code class="literal">django</code> schema.</li><li class="listitem">Let's go ahead now and initialize our Django project and create all the tables as follows:<div><pre class="programlisting">
<strong>&gt; python manage.py migrate</strong>
</pre></div></li><li class="listitem">The built-in Django <code class="literal">manage.py</code> command calls the <code class="literal">migrate</code> function and performs the sync in one go. Next, let's create a superuser for our application who can login and have full control of the entire web application. Then, follow the command-line instructions to enter the username, e-mail, and password as follows:<div><pre class="programlisting">
<strong>&gt; python manage.py createsuperuser</strong>
</pre></div></li><li class="listitem">With all these steps now completed, we are ready to actually get something done and build our online routing application. To test whether everything is working, run this command:<div><pre class="programlisting">
<strong>&gt; python manage.py runserver 8000</strong>
</pre></div></li><li class="listitem">Open up your local web browser and see the welcome Django default page.</li></ol></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec76"/>Creating an indoor web routing service</h1></div></div></div><p>Let's take all the <a id="id489" class="indexterm"/>effort we put into <a class="link" href="ch08.html" title="Chapter 8. Network Routing Analysis">Chapter 8</a>, <em>Network Routing Analysis</em>, out onto the World Wide Web. Our routing service will simply accept a starting point location, an <em>x</em>, <em>y</em> coordinate pair, a floor level, and a destination location. The indoor routing service will then calculate the shortest path and return a complete route in the form of a GeoJSON file.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec178"/>Getting ready</h2></div></div></div><p>To layout the tasks ahead, let's list out what we need to accomplish at a high level so that we're clear about where we are going:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a URL pattern to call a route service.</li><li class="listitem">Build a view to handle an incoming URL request and deliver the appropriate GeoJSON route web response:<div><ol class="orderedlist arabic"><li class="listitem">Accept incoming request parameters.<p>Start <em>x</em> coordinate.</p><p>Start <em>y</em> coordinate.</p><p>Start floor number.</p><p>End <em>x</em> coordinate.</p><p>End <em>y</em> coordinate.</p><p>End floor number.</p></li><li class="listitem">Return GeoJSON LineString.<p>Route geometry.</p><p>Route length.</p><p>Route walk time.</p></li></ol></div><p>We also need to let our new database user named <code class="literal">saturn</code> in order to have access to the tables located in the PostgreSQL geodata schema created in <a class="link" href="ch08.html" title="Chapter 8. Network Routing Analysis">Chapter 8</a>, <em>Network Routing Analysis</em>. Currently, only the user named <code class="literal">postgres</code> is the owner and almighty one. This needs to change so that we can keep on trucking without needing to recreate our tables as created in <a class="link" href="ch08.html" title="Chapter 8. Network Routing Analysis">Chapter 8</a>, <em>Network Routing Analysis</em>. So, let's go ahead and simply make the <code class="literal">saturn</code> user the owner of each of these tables as follows:</p><div><pre class="programlisting">
<strong>ALTER TABLE geodata.ch08_e01_networklines OWNER TO saturn;</strong>
<strong>ALTER TABLE geodata.ch08_e01_networklines_vertices_pgr OWNER TO saturn;</strong>
<strong>ALTER TABLE geodata.ch08_e02_networklines OWNER TO saturn;</strong>
<strong>ALTER TABLE geodata.ch08_e02_networklines_vertices_pgr  OWNER TO saturn;</strong>
<strong>ALTER TABLE geodata.networklines_3857 OWNER TO saturn;</strong>
<strong>ALTER TABLE geodata.networklines_3857_vertices_pgr OWNER TO saturn;</strong>
</pre></div><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>If you are looking for a way to allow both the <code class="literal">saturn</code> user and any other user to gain access to these tables, you could create a PostgreSQL group role and assign the user to this role as follows:</p><div><pre class="programlisting">
<strong>CREATE ROLE gis_edit   VALID UNTIL 'infinity';</strong>
<strong>GRANT ALL ON SCHEMA geodata TO GROUP gis_edit;</strong>
<strong>GRANT gis_edit TO saturn;
GRANT ALL ON TABLE geodata.ch08_e01_networklines TO GROUP gis_edit;</strong>
<strong>GRANT ALL ON TABLE geodata.ch08_e01_networklines_vertices_pgr TO GROUP gis_edit;</strong>
<strong>GRANT ALL ON TABLE geodata.ch08_e02_networklines TO GROUP gis_edit;</strong>
<strong>GRANT ALL ON TABLE geodata.ch08_e02_networklines_vertices_pgr TO GROUP gis_edit;</strong>
<strong>GRANT ALL ON TABLE geodata.networklines_3857 TO GROUP gis_edit;</strong>
<strong>GRANT ALL ON TABLE geodata.networklines_3857_vertices_pgr TO GROUP gis_edit;</strong>
</pre></div></div></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec179"/>How to do it...</h2></div></div></div><p>Our code is now in<a id="id490" class="indexterm"/> one folder in a structure that's common to all Django web projects, so following these steps should be straightforward:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's begin by wiring up our new URL. Go ahead and open up the <code class="literal">urls.py</code> file inside your <code class="literal">ch11/code/web_analysis/</code> folder. Inside the file, you will need to enter the main URL configuration for our new web page. This file was automatically created when we created the project. Django fills in some helper text, as you can see, that shows you some basic configuration options. We need to add the <code class="literal">admin</code> app, which we will use later, and the URL for our new API. The API application will have its very own URL configuration file as you can see in the <code class="literal">api.urls</code> references, which we will create next. The <code class="literal">/web_analysis/urls.py</code>  file should look like this:<div><pre class="programlisting">"""web_analysis URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/1.8/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')
Including another URLconf
    1. Add an import:  from blog import urls as blog_urls
    2. Add a URL to urlpatterns:  url(r'^blog/', include(blog_urls))
"""
from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r'^admin/', include(admin.site.urls)),
    url(r'^api/', include('api.urls')),
]</pre></div></li><li class="listitem">Next up, let's<a id="id491" class="indexterm"/> create the <code class="literal">/web_analysis/api/urls.py</code> api URLs. This file is not automatically generated so we'll create this file now. The content of this <code class="literal">/api/urls.py</code> file will be as follows:<div><pre class="programlisting">from django.conf.urls import patterns, url
from rest_framework.urlpatterns import format_suffix_patterns

urlpatterns = patterns('api.views',
    #  ex valid call from to /api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2
    url(r'^directions/(?P&lt;start_coord&gt;[-]?\d+\.?\d+,\d+\.\d+),(?P&lt;start_floor&gt;\d+)&amp;(?P&lt;end_coord&gt;[-]?\d+\.?\d+,\d+\.\d+),(?P&lt;end_floor&gt;\d+)/$', 'create_route', name='directions'),


)

urlpatterns = format_suffix_patterns(urlpatterns)</pre></div></li><li class="listitem">The regular<a id="id492" class="indexterm"/> expression looks wild as most regular expressions do. If you need some help understanding it, try referring<a id="id493" class="indexterm"/> to <a class="ulink" href="https://regex101.com/#python">https://regex101.com/#python</a>. Go ahead and paste this regular expression in the regular expression field:<div><pre class="programlisting">(?P&lt;start_coord&gt;[-]?\d+\.?\d+,\d+\.\d+),(?P&lt;start_floor&gt;\d+)&amp;(?P&lt;end_coord&gt;[-]?\d+\.?\d+,\d+\.\d+),(?P&lt;end_floor&gt;\d+)</pre></div></li><li class="listitem">To test your URL string, simply paste this text in the <strong>TEST STRING</strong> field:<div><pre class="programlisting">1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2</pre></div></li><li class="listitem"> If it's lit up in some funky colors, you are good to go:<div><img src="img/50790OS_11_01.jpg" alt="How to do it..."/></div><p>Django's use of regular expressions for URL configuration is quite handy but not always obvious and explicit to read. Our URL is explained in a textual manner and would read like this:</p><div><pre class="programlisting">
<strong>/api/directions/start_x,start_y,start_floor&amp;end_x,end_y,end_floor</strong>
</pre></div><p>This is a real example from your development machine. When calling the URL, it will look like this:</p><div><pre class="programlisting">
<strong>http://localhost:8000/api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2</strong>
</pre></div><p>The start and end location information is separated with an <code class="literal">&amp;</code> symbol, while the contents of each start parameter and end parameter are separated by a comma.</p><p>Going forward, in terms of complexity, we now need to enter the logic part of our API. Django handles this in the views. Our <code class="literal">/web_analysis/api/views.py</code> code contains the code to handle the request and response.</p></li><li class="listitem">The main <code class="literal">def create_route</code> function should look familiar as it is taken directly<a id="id494" class="indexterm"/> from <a class="link" href="ch08.html" title="Chapter 8. Network Routing Analysis">Chapter 8</a>, <em>Network Routing Analysis,</em> with some modifications. A new <code class="literal">helper</code> function is created called <code class="literal">find_closest_network_node</code>. This new function is more robust and faster than our previous SQL that we used to find the node closest to any given <em>x</em>, <em>y</em> coordinate entered by a user:<div><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import traceback
from django.http import HttpResponseNotFound
from rest_framework.decorators import api_view
from rest_framework.response import Response
from geojson import loads, Feature, FeatureCollection
import logging
logger = logging.getLogger(__name__)
from django.db import connection


def find_closest_network_node(x_coord, y_coord, floor):
    """
    Enter a given coordinate x,y and floor number and
    find the nearest network node
    to start or end the route on
    :param x_coord: float  in epsg 3857
    :param y_coord: float  in epsg 3857
    :param floor: integer value equivalent to floor such as
	2  = 2nd floor
    :return: node id as an integer
    """
    # connect to our Database
    logger.debug("now running function find_closest_network_node")
    cur = connection.cursor()

    # find nearest node on network within 200 m
    # and snap to nearest node
    query = """ SELECT
        verts.id as id
        FROM geodata.networklines_3857_vertices_pgr AS verts
        INNER JOIN
          (select ST_PointFromText('POINT(%s %s %s)', 3857)as geom) AS pt
        ON ST_DWithin(verts.the_geom, pt.geom, 200.0)
        ORDER BY ST_3DDistance(verts.the_geom, pt.geom)
        LIMIT 1;"""

    # pass 3 variables to our %s %s %s place holder in query
    cur.execute(query, (x_coord, y_coord, floor,))

    # get the result
    query_result = cur.fetchone()

    # check if result is not empty
    if query_result is not None:
        # get first result in tuple response there is only one
        point_on_networkline = int(query_result[0])
        return point_on_networkline
    else:
        logger.debug("query is none check tolerance value of 200")
        return False


# use the rest_framework decorator to create our api
#  view for get, post requests
@api_view(['GET', 'POST'])
def create_route(request, start_coord, start_floor, end_coord, end_floor):
    """
    Generate a GeoJSON indoor route passing in a start x,y,floor
    followed by &amp;  then the end x,y,floor
    Sample request: http:/localhost:8000/api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2
    :param request:
    :param start_coord: start location x,y
    :param start_floor: floor number  ex)  2
    :param end_coord: end location x,y
    :param end_floor: end floor ex)  2
    :return: GeoJSON route
    """

    if request.method == 'GET' or request.method == 'POST':

        cur = connection.cursor()

        # parse the incoming coordinates and floor using
        # split by comma
        x_start_coord = float(start_coord.split(',')[0])
        y_start_coord = float(start_coord.split(',')[1])
        start_floor_num = int(start_floor)

        x_end_coord = float(end_coord.split(',')[0])
        y_end_coord = float(end_coord.split(',')[1])
        end_floor_num = int(end_floor)

        # use our helper function to get vertices
        # node id for start and end nodes
        start_node_id = find_closest_network_node(x_start_coord,
                           y_start_coord,
                           start_floor_num)

        end_node_id = find_closest_network_node(x_end_coord,
                           y_end_coord,
                           end_floor_num)

        routing_query = '''
            SELECT seq, id1 AS node, id2 AS edge,
              total_cost AS cost, layer,
              type_id, ST_AsGeoJSON(wkb_geometry) AS geoj
              FROM pgr_dijkstra(
                'SELECT ogc_fid as id, source, target,
                     st_length(wkb_geometry) AS cost,
                     layer, type_id
                 FROM geodata.networklines_3857',
                %s, %s, FALSE, FALSE
              ) AS dij_route
              JOIN  geodata.networklines_3857 AS input_network
              ON dij_route.id2 = input_network.ogc_fid ;
          '''

        # run our shortest path query
        if start_node_id or end_node_id:
            cur.execute(routing_query, (start_node_id, end_node_id))
        else:
            logger.error("start or end node is None "
                         + str(start_node_id))
            return HttpResponseNotFound('&lt;h1&gt;Sorry NO start or end  node'
                            ' found within 200m&lt;/h1&gt;')

        # get entire query results to work with
        route_segments = cur.fetchall()

        # empty list to hold each segment for our GeoJSON output
        route_result = []

        # loop over each segment in the result route segments
        # create the list of our new GeoJSON
        for segment in route_segments:
            seg_cost = segment[3]      # cost value
            layer_level = segment[4]   # floor number
            seg_type = segment[5]
            geojs = segment[6]         # geojson coordinates
            geojs_geom = loads(geojs)  # load string to geom
            geojs_feat = Feature(geometry=geojs_geom,
                                 properties={'floor': layer_level,
                                              'length': seg_cost,
                                              'type_id': seg_type})
            route_result.append(geojs_feat)

        # using the geojson module to create our GeoJSON Feature Collection
        geojs_fc = FeatureCollection(route_result)

        try:
            return Response(geojs_fc)
        except:
            logger.error("error exporting to json model: "+ str(geojs_fc))
            logger.error(traceback.format_exc())
            return Response({'error': 'either no JSON or no key params in your JSON'})
    else:
        retun HttpResponseNotFound('&lt;h1&gt;Sorry not a GET or POST request&lt;/h1&gt;')</pre></div><p>The resulting <a id="id495" class="indexterm"/>API call has a nice web interface that's automatically generated by the <strong>Django REST Framework</strong> as shown in the following screenshot. The URL you need to call is also shown and should return a GeoJSON result.</p><div><img src="img/50790OS_11_02.jpg" alt="How to do it..."/></div><p>The <a id="id496" class="indexterm"/>following URL will return GeoJSON to your browser; in Chrome, it will normally just show up as simple text. IE users may download it as a file by simply opening it in Notepad++ or a local text editor to see the contents of GeoJSON:</p><div><pre class="programlisting">
<strong>http://localhost:8000/api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2/?format=json</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec180"/>How it works...</h2></div></div></div><p>Our view handles the request and response using the Django REST Framework. There are two functions that do all the hard work without ever using the Django<a id="id497" class="indexterm"/> <strong>Object Relational Mapper</strong> (<strong>ORM</strong>). The reason for this is two-fold: first, to show you the basics of direct Database usage without<a id="id498" class="indexterm"/> too much abstraction and the inner workings of what is going on; second, because we are using functions of PostGIS that are not available directly through the ORM of GeoDjango, such as <code class="literal">ST_3DDistance</code> or <code class="literal">ST_PointFromText</code>. We could use some of the fancy Django helpers, such as <code class="literal">.extra()</code>, but this would confuse everyone but an experienced Django user.</p><p>Let's discuss the first <code class="literal">find_closest_network_node</code> function that takes three parameters: <code class="literal">x_coord</code>, <code class="literal">y_coord</code>, and <code class="literal">floor</code>. The <em>x</em> and <em>y</em> coordinates should be double precision float values, while the floor is an integer. Our regular expression URL limits any request to digits so there is no need to do any extra format checking in our code.</p><p>The SQL query that finds the nearest node and returns its ID limits the search radius to 200 m, which would equal one huge room or auditorium. Then, we order by the 3D distance between the points and <code class="literal">LIMIT</code> the result to one since we are not routing to multiple locations.</p><p>This feeds our second function called <code class="literal">create_route</code> where we pass it the start coordinate, start floor integer, end coordinate, and end floor number. Our URL at <code class="literal">/web_analysis/api/urls.py</code> uses a regular expression named <code class="literal">groups</code> that corresponds to the same names used in the request parameters of our function. This keeps things more explicit so that you know what values belong where in a query.</p><p>We begin with parsing the incoming parameters to get the exact values as floats and integers to feed our routing query. The routing query itself is unchanged from <a class="link" href="ch08.html" title="Chapter 8. Network Routing Analysis">Chapter 8</a>, <em>Network Routing Analysis,</em> so refer to this chapter for more details. The Django REST framework response sends the GeoJSON back to the client and has the ability to return it as raw text as well.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Visualizing an indoor routing service</h1></div></div></div><p>With our wonderful API<a id="id499" class="indexterm"/> created, it's time now to visualize this indoor route returned as GeoJSON on a map. We will now dive into the Django template components to create the HTML, JS, and CSS for our front-facing web page that displays a simple slippy web map using Openlayers 3.4.0. and Bootstrap CSS.</p><p>Our new web map will display the GeoJSON on the map with a nice style alongside a menu bar where we will include later functionality.</p><div><img src="img/50790OS_11_03.jpg" alt="Visualizing an indoor routing service"/></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec181"/>Getting ready</h2></div></div></div><p>We need to build a few<a id="id500" class="indexterm"/> new folders and files to store new static and template content for our Django web application. Let's begin doing this by creating the <code class="literal">/web_analysis/templates</code> folder followed by the <code class="literal">/web_analysis/static</code> folder.</p><p>Inside our <code class="literal">/static/</code> folder, we will place the nondynamic content of the JavaScript and CSS files. The <code class="literal">/templates/</code> folder will store the HTML template files used to create our web pages.</p><p>Next up, let's tell Django <code class="literal">/web_analysis/settings.py</code> about the location of our new templates folder; add the <code class="literal">os.path.join(BASE_DIR,  'templates')</code> value to the <code class="literal">'DIRS'</code> key shown here so that the <code class="literal">TEMPLATES</code> variable looks like this:</p><div><pre class="programlisting">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR,  'templates'),],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]</pre></div><p>To manage our maps, lets<a id="id501" class="indexterm"/> create a new Django application called <code class="literal">maps</code> where we can store all our map information as follows:</p><div><pre class="programlisting">
<strong>&gt; python manage.py startapp maps</strong>
</pre></div><p>Next, register your new app in the <code class="literal">/web_analysis/web_analysis/settings.py INSTALLED APPS</code> variable by adding this under the <code class="literal">api</code> entry <code class="literal">'maps'</code>, under the entry <code class="literal">'api'</code>.</p><p>The <code class="literal">/maps/urls.py</code> file is not automatically created so let's do this now and fill in some content as follows:</p><div><pre class="programlisting">from django.conf.urls import patterns, url
from rest_framework.urlpatterns import format_suffix_patterns

urlpatterns = patterns('maps.views',
    #  ex valid call from to /api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2
    url(r'^(?P&lt;map_name&gt;\w+)/$', 'route_map', name='route-map'),

)

urlpatterns = format_suffix_patterns(urlpatterns)</pre></div><p>We need to assign <code class="literal">maps/urls.py</code> within our main <code class="literal">/web_analysis/web_analysis/urls.py</code> so that we can freely create any URL for all our mapping needs.</p><p>Add this line to the <code class="literal">/web_analysis/web_analysis/urls.py</code> file as follows:</p><div><pre class="programlisting">    url(r'^maps/', include('maps.urls')),</pre></div><p>This means that all the URL's inside our <code class="literal">/maps/urls.py</code> will start with <code class="literal">http://localhost:8000/maps/</code>.</p><p>We are now ready to set up <a id="id502" class="indexterm"/>the static files and static contents inside <code class="literal">settings.py</code> as follows:</p><div><pre class="programlisting">STATIC_URL = '/static/'
STATIC_FOLDER = 'static'

STATICFILES_DIRS = [
   os.path.join(BASE_DIR, STATIC_FOLDER),
]

# finds all static folders in all apps
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)</pre></div><p>You should have the following folders and files now in the <code class="literal">/static/</code> folder:</p><div><pre class="programlisting">static
+---css
|       bootstrap-responsive.min.css
|       bootstrap.min.css
|       custom-layout.css
|       font-awesome.min.css
|       ol.css
|
+---img
\---js
        bootstrap.min.js
        jquery-1.11.2.min.js
        jquery.min.js
        ol340.js</pre></div><p>This should be enough to set up your Django project in order for it to serve up a static map.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec182"/>How to do it...</h2></div></div></div><p>Actually serving up the <a id="id503" class="indexterm"/>map requires us to create an HTML page. We use the built-in Django template engine to build two HTML pages. The first page template is <code class="literal">base.html</code> that will hold the basics of our web map page, making it a very important part of our frontend design. What's included in this page is a set of block tags, each for separate content place holders. This allows us to quickly create new map pages based on our base template, which sets up our basic template architecture.</p><div><ol class="orderedlist arabic"><li class="listitem">Here is the <code class="literal">/templates/base.html</code> file:<div><pre class="programlisting">{% load staticfiles %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    {% block head %}

    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta name="description" content="Sample Map"&gt;
    &lt;meta name="author" content="Michael Diener"&gt;
    &lt;meta charset="UTF-8"&gt;

    &lt;title&gt;{% block title %}Default Title{% endblock %}&lt;/title&gt;

    &lt;script src="img/{% static "js/jquery-1.11.2.min.js" %}"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" href="{% static "css/bootstrap.min.css" %}"&gt;
    &lt;script src="img/{% static "js/bootstrap.min.js" %}"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" href="{% static "css/ol.css" %}" type="text/css"&gt;
    &lt;link rel="stylesheet" href="{% static "css/custom-layout.css" %}" type="text/css"&gt;
    &lt;script src="img/{% static "js/ol340.js" %}"&gt;&lt;/script&gt;

    {% endblock head %}
&lt;/head&gt;
&lt;body&gt;
{% block body %}

    {% block nav %}
        &lt;nav class="navbar navbar-inverse navbar-fixed-top"&gt;
          &lt;div class="container"&gt;
            &lt;div class="navbar-header"&gt;
              &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"&gt;
                &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt;
                &lt;span class="icon-bar"&gt;&lt;/span&gt;
                &lt;span class="icon-bar"&gt;&lt;/span&gt;
                &lt;span class="icon-bar"&gt;&lt;/span&gt;
              &lt;/button&gt;
              &lt;a class="navbar-brand" href="#"&gt;Indoor Project&lt;/a&gt;
            &lt;/div&gt;
            &lt;div id="navbar" class="collapse navbar-collapse"&gt;
              &lt;ul class="nav navbar-nav"&gt;
                &lt;li&gt;&lt;a href="#about"&gt;About&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#contact"&gt;Contact&lt;/a&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;&lt;!--/.nav-collapse --&gt;
          &lt;/div&gt;
        &lt;/nav&gt;
    {% endblock nav %}


{% endblock body %}
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Now, let's <a id="id504" class="indexterm"/>move on to the actual map. A new template called <code class="literal">/templates/route-map.html</code> contains all the actual Django template blocks that are filled with HTML content as follows:<div><pre class="programlisting">{% extends "base.html" %}
{% load staticfiles %}

{% block title %}Simple route map{% endblock %}

{% block body %}

{{ block.super }}

&lt;div class="container-fluid"&gt;

    &lt;div class="row"&gt;
      &lt;div class="col-md-2"&gt;
        &lt;div id="directions" class="directions"&gt;
            &lt;form&gt;
                &lt;div class="radio"&gt;
                  &lt;label&gt;
                    &lt;input type="radio" name="typeRoute" id="routeTypeStandard" value="0" checked&gt;
                    Standard Route
                  &lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="radio"&gt;
                  &lt;label&gt;
                    &lt;input type="radio" name="typeRoute" id="routeTypeBarrierFree" value="1"&gt;
                    Barrier Free Route
                  &lt;/label&gt;
                &lt;/div&gt;
              &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;
                &lt;br&gt;
            &lt;/form&gt;

        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="col-md-10"&gt;
        &lt;div id="map" class="map"&gt;&lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;
&lt;/div&gt;



    &lt;script&gt;

           var routeUrl = '/api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2&amp;' + sel_Val2  + '/?format=json';

          map.getLayers().push(new ol.layer.Vector({
                    source: new ol.source.GeoJSON({url: routeUrl, crossDomain: true,}),
                    style:  new ol.style.Style({
                        stroke: new ol.style.Stroke({
                          color: 'blue',
                          width: 4
                        })
                      }),
                    title: "Route",
                    name: "Route"
                }));

        });
        var vectorLayer = new ol.layer.Vector({
                        source: new ol.source.GeoJSON({url: geojs_url}),
                        style:  new ol.style.Style({
                            stroke: new ol.style.Stroke({
                              color: 'red',
                              width: 4
                            })
                          }),
                        title: "Route",
                        name: "Route"
                    });

        var map = new ol.Map({
          layers: [
            new ol.layer.Tile({
              source: new ol.source.OSM()
            }),
            vectorLayer
          ],
          target: 'map',
          controls: ol.control.defaults({
            attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
              collapsible: false
            })
          }),
          view: new ol.View({
            center: [1587927.09817072,5879650.90059265],
            zoom: 18
          })
        });

        &lt;/script&gt;

{% endblock body %}</pre></div></li><li class="listitem">For our application to actually show these templates, we need to create a view. The view handles the request and serves <code class="literal">route-map.html</code> in return. Now, our simple view is complete:<div><pre class="programlisting">from django.shortcuts import render

def route_map(request):
    return render(request, 'route-map.html')</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec183"/>How it works...</h2></div></div></div><p>Starting with <a id="id505" class="indexterm"/>the <code class="literal">base.html</code> template, we set out the basic building blocks for map making. The static files and resources were set up to handle serving our JavaScript and CSS code. The <code class="literal">base.html</code> file is designed to allow us to add elements that are shared between multiple HTML pages such as a master page in Microsoft PowerPoint. The more blocks, that is, place holders, the better your base.</p><p>Our <code class="literal">route-map.html</code> contains the actual code referencing our <code class="literal">api</code> by calling it with a predefined, hardcoded from, <code class="literal">to URL</code>:</p><div><pre class="programlisting">var geojs_url = "http://localhost:8000/api/directions/1587898.414,5879564.080,1&amp;1588005.547,5879736.039,2/?format=json"</pre></div><p>The <code class="literal">/maps/views.py</code> code is where any map logic, variables, or parameters are passed around to the template. In our code, we simply take in a request and return an HTML page. Now you have a rudimentary indoor routing service and visualization client to show off to your friends.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Creating an indoor route-type service</h1></div></div></div><p>Building a route based<a id="id506" class="indexterm"/> on a specified type value, such as a <strong>Barrier Free Route</strong> or <strong>Standard Pedestrian Route</strong> value, is great for your users. How to build different route types is based on the available data connected to our indoor graph of ways. This example will allow a user to select the barrier-free route and our service will generate a path, avoiding obstacles such as stairs:</p><div><img src="img/50790OS_11_04.jpg" alt="Creating an indoor route-type service"/></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec184"/>Getting ready</h2></div></div></div><p>We need to access some more data on our network to allow routing types. The type of route is based on a network line type, which is stored as an attribute on each LineString. To classify our route types, we have the following lookup table schema:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Value</p>
</th><th style="text-align: left" valign="bottom">
<p>Route type</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Indoor route</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">1</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Outdoor route</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">2</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Elevator</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">3</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Stairs</p>
</td></tr></tbody></table></div><p>Therefore, we want to avoid any stairs segments, which technically means avoiding <code class="literal">type_id = 3</code>.</p><div><div><h3 class="title"><a id="note46"/>Note</h3><p>Optionally, you could create a lookup table to store all the possible types and their equivalent weights. These values could then be included in the calculation of the total cost value to influence the route outcome.</p></div></div><p>Now we can control<a id="id507" class="indexterm"/> how the route is generated based on certain preferences as well. A standard route search can now be set for preferences, such as taking the stairs over the elevator or vice versa, depending on your needs:</p><div><pre class="programlisting">
<strong>ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN total_cost double precision;</strong>
<strong>ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN total_cost double precision;</strong>

<strong>update geodata.networklines_3857 set total_cost = st_length(wkb_geometry)*88</strong>
<strong>where type_id = 2;</strong>

<strong>update geodata.networklines_3857 set total_cost = st_length(wkb_geometry)*1.8</strong>
<strong>where type_id = 3;</strong>
</pre></div><p>If you update <code class="literal">geodata.networklines_3857</code>, make sure the user <code class="literal">saturn</code> is the owner or has access; otherwise, your API call will break.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec185"/>How to do it...</h2></div></div></div><p>The least-cost path from any point is controlled by a basic property called <code class="literal">cost</code>. For a standard route, the cost is equal to the distance of a segment. We search for the least-cost path, which means finding the shortest path to our destination.</p><p>To control the path, we set the cost values. Creating a barrier-free route involves setting all segment types equal to <code class="literal">stairs</code> at an extraordinarily high value so that the path, that is, the distance, is huge and is, therefore, excluded in the shortest path route finding process. Our other option is to add a <code class="literal">WHERE</code> clause to the query and only accept values where <code class="literal">type_id</code> is not equal to <code class="literal">3</code>, which means that it is not of the type <code class="literal">stairs</code>. We are going to use this option in our upcoming code.</p><p>Therefore our data needs to be clean in order to allow us to assign specific costs to specific segment types in our network lines.</p><p>Now, we need to add a new parameter to capture the route type:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll update the <code class="literal">/api/views.py</code> function, <code class="literal">create route()</code>, and add a new parameter called <code class="literal">route_type</code>. Next up is the actual query that needs to accept this new parameter. We set up a new variable called <code class="literal">barrierfree_q</code> to hold the <code class="literal">WHERE</code> clause that we will add to our original query:<div><pre class="programlisting">def create_route(request, start_coord, start_floor, end_coord, end_floor, route_type):
        base_route_q = """SELECT ogc_fid as id, source, target,
                         total_cost AS cost,
                         layer, type_id
                         FROM geodata.networklines_3857"""

        # set default query
        barrierfree_q = "WHERE 1=1"
        if route_type == "1":
            # exclude all networklines of type stairs
            barrierfree_q = "WHERE type_id not in (3,4)"


        routing_query = '''
            SELECT seq, id1 AS node, id2 AS edge,
              ST_Length(wkb_geometry) AS cost, layer,
              type_id, ST_AsGeoJSON(wkb_geometry) AS geoj
              FROM pgr_dijkstra('
                {normal} {type}', %s, %s, FALSE, FALSE
              ) AS dij_route
              JOIN  geodata.networklines_3857 AS input_network
              ON dij_route.id2 = input_network.ogc_fid ;
          '''.format(normal=base_route_q, type=barrierfree_q)</pre></div></li><li class="listitem">We'll update <a id="id508" class="indexterm"/>our <code class="literal">/api/urls.py</code> to input our new URL parameter, <code class="literal">route_type</code>. The newly added named group regular expression is naturally called <code class="literal">route_type</code> and only accepts numbers from 0 to 9. This then, of course, also limits you to 10 route types. So, if you want to add more types, you will need to update your <code class="literal">regex</code> as follows:<div><pre class="programlisting">from django.conf.urls import patterns, url
from rest_framework.urlpatterns import format_suffix_patterns

urlpatterns = patterns('api.views',
    #  ex valid call from to /api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2
    url(r'^directions/(?P&lt;start_coord&gt;[-]?\d+\.?\d+,\d+\.\d+),(?P&lt;start_floor&gt;\d+)&amp;(?P&lt;end_coord&gt;[-]?\d+\.?\d+,\d+\.\d+),(?P&lt;end_floor&gt;\d+)&amp;(?P&lt;route_type&gt;[0-9])/$', 'create_route', name='directions'),

)

urlpatterns = format_suffix_patterns(urlpatterns)</pre></div></li><li class="listitem">The <code class="literal">/maps/views.py</code> function needs a facelift too so that we can pass in the parameters. Now, it will accept <code class="literal">route_type</code> as defined in our <code class="literal">/api/urls.py</code>:<div><pre class="programlisting">from django.shortcuts import render


def route_map(request, route_type = "0"):

    return render(request, 'route-map.html', {'route_type': route_type})</pre></div></li><li class="listitem">It's time to <a id="id509" class="indexterm"/>update <code class="literal">route-map.html</code> to include radio buttons that allow a user to select either a <strong>Standard Route</strong> or <strong>Barrier Free Route</strong>. The map will then update the route as soon as you click on the route type radio button:<div><pre class="programlisting">{% extends "base.html" %}
{% load staticfiles %}

{% block title %}Simple route map{% endblock %}

{% block body %}

{{ block.super }}

&lt;div class="container-fluid"&gt;

    &lt;div class="row"&gt;
      &lt;div class="col-md-2"&gt;
        &lt;div id="directions" class="directions"&gt;
            &lt;form&gt;
                &lt;div class="radio"&gt;
                  &lt;label&gt;
                    &lt;input type="radio" name="typeRoute" id="routeTypeStandard" value="0" checked&gt;
                    Standard Route
                  &lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="radio"&gt;
                  &lt;label&gt;
                    &lt;input type="radio" name="typeRoute" id="routeTypeBarrierFree" value="1"&gt;
                    Barrier Free Route
                  &lt;/label&gt;
                &lt;/div&gt;
              &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;
                &lt;br&gt;
            &lt;/form&gt;

        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="col-md-10"&gt;
        &lt;div id="map" class="map"&gt;&lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;
&lt;/div&gt;

    &lt;script&gt;
        var url_base = "/api/directions/";
        var start_coord = "1587848.414,5879564.080,2";
        var end_coord =  "1588005.547,5879736.039,2";
        var r_type = {{ route_type }};
        var geojs_url = url_base + start_coord + "&amp;" + end_coord + "&amp;" + sel_Val + '/?format=json';
        var sel_Val = $( "input:radio[name=typeRoute]:checked" ).val();

        $( ".radio" ).change(function() {
           map.getLayers().pop();
           var sel_Val2 = $( "input:radio[name=typeRoute]:checked" ).val();
           var routeUrl = '/api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2&amp;' + sel_Val2  + '/?format=json';

          map.getLayers().push(new ol.layer.Vector({
                    source: new ol.source.GeoJSON({url: routeUrl, crossDomain: true,}),
                    style:  new ol.style.Style({
                        stroke: new ol.style.Stroke({
                          color: 'blue',
                          width: 4
                        })
                      }),
                    title: "Route",
                    name: "Route"
                }));

        });
        var vectorLayer = new ol.layer.Vector({
                        source: new ol.source.GeoJSON({url: geojs_url}),
                        style:  new ol.style.Style({
                            stroke: new ol.style.Stroke({
                              color: 'red',
                              width: 4
                            })
                          }),
                        title: "Route",
                        name: "Route"
                    });

        var map = new ol.Map({
          layers: [
            new ol.layer.Tile({
              source: new ol.source.OSM()
            }),
            vectorLayer
          ],
          target: 'map',
          controls: ol.control.defaults({
            attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
              collapsible: false
            })
          }),
          view: new ol.View({
            center: [1587927.09817072,5879650.90059265],
            zoom: 18
          })
        });

        &lt;/script&gt;

{% endblock body %}</pre></div><p>Our<a id="id510" class="indexterm"/> results for <code class="literal">type = 0</code> or a route using stairs should look like this:</p><div><img src="img/50790OS_11_05.jpg" alt="How to do it..."/></div><p>The barrier-free route will use <code class="literal">type = 1</code>, which means forced elevator use and avoiding all stairs. Your result should then look like this:</p><div><img src="img/50790OS_11_06.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec186"/>How it works...</h2></div></div></div><p>The main part to<a id="id511" class="indexterm"/> understand here is that we need to add an option route type to our API call. This API call must accept a specific route type that we have defined as a number from 0 to 9. This route type number is then passed to our URL as a parameter and <code class="literal">api/views.py</code> runs the call. The API then generates a new route based on the route type.</p><p>All our changes are made inside the <code class="literal">/api/view.py</code> code that now includes a SQL <code class="literal">WHERE</code> clause and excludes <code class="literal">networklines</code> with a <code class="literal">type_id = 3</code>—that is, <code class="literal">stairs</code>. This query change keeps our app fast without actually increasing any Django middleware code in our views.</p><p>The frontend needs the user to select a route type with the default route type set to a standard value, such as <code class="literal">0</code>, as in the case of <code class="literal">stairs</code>. This default type is used because in most indoor environments the stairs are usually shorter. You can, of course, change this default to whatever value or criteria you'd like at any time. A radio select box is used to restrain the choice to either a standard route or a barrier-free route. Upon selecting a route type, the map automatically removes the old route and creates a new route.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec79"/>Creating an indoor route from room to room</h1></div></div></div><p>Routing from room A to <a id="id512" class="indexterm"/>room B in an indoor routing web application over multiple floors with routing types brings together all our work up to this point. We will import some room data and utilize our network to then allow a user to select a room, route from one room to the next, and select a type of route.</p><div><img src="img/50790OS_11_07.jpg" alt="Creating an indoor route from room to room"/></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec187"/>Getting ready</h2></div></div></div><p>We need to import a set of room polygons for both the first and second floor as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Import a Shapefile of the first floor room polygons as follows:<div><pre class="programlisting">
<strong>ogr2ogr -a_srs EPSG:3857 -lco "SCHEMA=geodata" -lco "COLUMN_TYPES=name=varchar,room_num=integer,floor=integer" -nlt POLYGON -nln ch11_e01_roomdata -f PostgreSQL "PG:host=localhost port=5432 user=saturn dbname=py_geoan_cb password=secret" e01_room_data.shp</strong>
</pre></div></li><li class="listitem">Import a Shapefile of the second floor room polygons as follows:<div><pre class="programlisting">
<strong>ogr2ogr -a_srs EPSG:3857 -lco "SCHEMA=geodata" -lco "COLUMN_TYPES=name=varchar,room_num=integer,floor=integer" -nlt POLYGON -nln ch11_e02_roomdata -f PostgreSQL "PG:host=localhost port=5432 user=saturn dbname=py_geoan_cb password=secret" e02_room_data.shp</strong>
</pre></div></li><li class="listitem">Create a new PostgreSQL view to merge all the new room data into one table so that we can query all the rooms at once:<div><pre class="programlisting">
<strong>CREATE OR REPLACE VIEW  geodata.search_rooms_v AS</strong>
<strong>SELECT floor, wkb_geometry, room_num FROM geodata.ch11_e01_roomdata </strong>
<strong>UNION</strong>
<strong>SELECT floor, wkb_geometry, room_num FROM geodata.ch11_e02_roomdata ;</strong>
<strong>ALTER TABLE geodata.search_rooms_v OWNER TO saturn;</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec188"/>How to do it...</h2></div></div></div><p>To allow a user to route <a id="id513" class="indexterm"/>from A to B, we need to enable a route from a field and a route to a field, as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new URL to accept the new parameter of the start and end room number. The first URL for example will look like <code class="literal">http://localhost:8000/api/directions/10010&amp;20043&amp;0</code>, which means that the route from room number <code class="literal">10010</code> to room number <code class="literal">20042</code> using the standard route type equals to zero.<div><div><h3 class="title"><a id="note47"/>Note</h3><p>The second URL is an extra function that you can call to only return the center coordinate of a room when you pass in the room number like this: <code class="literal">http://localhost:8000/directions/10010</code>.</p><p>This function in the view <em>does not exist</em> and is left for you to do as homework.</p></div></div><div><pre class="programlisting">    url(r'^directions/(?P&lt;start_room_num&gt;\d{5})&amp;(?P&lt;end_room_num&gt;\d{5})&amp;(?P&lt;route_type&gt;[0-9])/$', 'route_room_to_room', name='route-room-to-room'),
    url(r'^directions/(?P&lt;room_num&gt;\d{5})/$', 'get_room_centroid_node', name='room-center'),</pre></div></li><li class="listitem">Build <a id="id514" class="indexterm"/>a new <code class="literal">/api/views.py</code> function to find a room center coordinate and return the nearest node on <code class="literal">networklines</code> to this coordinate:<div><pre class="programlisting">def get_room_centroid_node(room_number):
    '''
    Find the room center point coordinates
    and find the closest route node point
    :param room_number: integer value of room number
    :return: Closest route node to submitted room number
    '''

    room_center_q = """SELECT  floor,
            ST_asGeoJSON(st_centroid(wkb_geometry))
            AS geom FROM geodata.search_rooms_v
            WHERE room_num = %s;"""

    cur = connection.cursor()
    cur.execute(room_center_q, (room_number,))

    res = cur.fetchall()

    res2 = res[0]

    room_floor = res2[0]
    room_geom_x = json.loads(res2[1])
    room_geom_y = json.loads(res2[1])

    x_coord = float(room_geom_x['coordinates'][0])
    y_coord = float(room_geom_y['coordinates'][1])

    room_node = find_closest_network_node(x_coord, y_coord, room_floor)
    try:
        return room_node
    except:
        logger.error("error get room center " + str(room_node))
        logger.error(traceback.format_exc())
        return {'error': 'error get room center'}</pre></div></li><li class="listitem">Build the<a id="id515" class="indexterm"/> function inside <code class="literal">/api/views.py</code> to accept a start node ID, end node ID, and a route type that will then return a GeoJSON of the final route as follows:<div><pre class="programlisting">def run_route(start_node_id, end_node_id, route_type):
    '''

    :param start_node_id:
    :param end_node_id:
    :param route_type:
    :return:
    '''

    cur = connection.cursor()
    base_route_q = """SELECT ogc_fid AS id, source, target,
                     total_cost AS cost,
                     layer, type_id
                     FROM geodata.networklines_3857"""

    # set default query
    barrierfree_q = "WHERE 1=1"
    if route_type == "1":
        # exclude all networklines of type stairs
        barrierfree_q = "WHERE type_id not in (3,4)"

    routing_query = '''
        SELECT seq, id1 AS node, id2 AS edge,
          ST_Length(wkb_geometry) AS cost, layer,
          type_id, ST_AsGeoJSON(wkb_geometry) AS geoj
          FROM pgr_dijkstra('
            {normal} {type}', %s, %s, FALSE, FALSE
          ) AS dij_route
          JOIN  geodata.networklines_3857 AS input_network
          ON dij_route.id2 = input_network.ogc_fid ;
      '''.format(normal=base_route_q, type=barrierfree_q)

    # run our shortest path query
    if start_node_id or end_node_id:
        cur.execute(routing_query, (start_node_id, end_node_id))
    else:
        logger.error("start or end node is None "
                     + str(start_node_id))
        return HttpResponseNotFound('&lt;h1&gt;Sorry NO start or end node'
                                    ' found within 200m&lt;/h1&gt;')

    # get entire query results to work with
    route_segments = cur.fetchall()

    # empty list to hold each segment for our GeoJSON output
    route_result = []

    # loop over each segment in the result route segments
    # create the list of our new GeoJSON
    for segment in route_segments:
        seg_cost = segment[3]  # cost value
        layer_level = segment[4]  # floor number
        seg_type = segment[5]
        geojs = segment[6]  # geojson coordinates
        geojs_geom = loads(geojs)  # load string to geom
        geojs_feat = Feature(geometry=geojs_geom,
                             properties={'floor': layer_level,
                                         'length': seg_cost,
                                         'type_id': seg_type})
        route_result.append(geojs_feat)

    # using the geojson module to create our GeoJSON Feature Collection
    geojs_fc = FeatureCollection(route_result)

    return geojs_fc</pre></div></li><li class="listitem">At last, we <a id="id516" class="indexterm"/>can create a function that our API will call to generate a response:<div><pre class="programlisting">@api_view(['GET', 'POST'])
def route_room_to_room(request, start_room_num, end_room_num, route_type):
    '''
    Generate a GeoJSON route from room number
    to room number
    :param request: GET or POST request
    :param start_room_num: an integer room number
    :param end_room_num: an integer room number
    :param route_type: an integer room type
    :return: a GeoJSON linestring of the route
    '''

    if request.method == 'GET' or request.method == 'POST':

        start_room = int(start_room_num)
        end_room = int(end_room_num)

        start_node_id = get_room_centroid_node(start_room)
        end_node_id = get_room_centroid_node(end_room)

        res = run_route(start_node_id, end_node_id, route_type)

        try:
            return Response(res)
        except:
            logger.error("error exporting to json model: " + str(res))
            logger.error(traceback.format_exc())
            return Response({'error': 'either no JSON or no key params in your JSON'})
    else:
        return HttpResponseNotFound('&lt;h1&gt;Sorry not a GET or POST request&lt;/h1&gt;')</pre></div></li><li class="listitem">Add a URL to <code class="literal">/api/urls.py</code> to access a list of all available rooms:<div><pre class="programlisting">    url(r'^rooms/$', 'room_list', name='room-list'),</pre></div></li><li class="listitem">Create an API service to return a JSON array of all room numbers. This array is used in autocomplete fields, <code class="literal">route-from</code>, and <code class="literal">route-to</code>. We use the Twitter <code class="literal">Typeahead.js</code> JavaScript library to handle our autocomplete dropdown type hinting. As a user, all you need to do is<a id="id517" class="indexterm"/> type 1, for example, and all the rooms beginning with 1 will show up as <code class="literal">10010</code> (check this out at <a class="ulink" href="http://twitter.github.io/typeahead.js/examples/">http://twitter.github.io/typeahead.js/examples/</a>):<div><pre class="programlisting">@api_view(['GET', 'POST'])
def room_list(request):
    '''
    http://localhost:8000/api/rooms
    :param request: no parameters GET or POST
    :return: JSON Array of room numbers
    '''
    cur = connection.cursor()
    if request.method == 'GET' or request.method == 'POST':

        room_query = """SELECT room_num FROM geodata.search_rooms_v"""

        cur.execute(room_query)
        room_nums = cur.fetchall()

        room_num_list = []
        for x in room_nums:
            v = x[0]
            room_num_list.append(v)

        try:
            return Response(room_num_list)
        except:
            logger.error("error exporting to json model: " + str(room_num_list))
            logger.error(traceback.format_exc())
            return Response({'error': 'either no JSON or no key params in your JSON'})</pre></div></li><li class="listitem">Our final <code class="literal">base.html</code> template<a id="id518" class="indexterm"/> is complete, containing all the spice needed for our final route from room to room as follows:<div><pre class="programlisting">{% load staticfiles %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    {% block head %}

    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta name="description" content="Sample Map"&gt;
    &lt;meta name="author" content="Michael Diener"&gt;
    &lt;meta charset="UTF-8"&gt;

    &lt;title&gt;{% block title %}Default Title{% endblock %}&lt;/title&gt;

    &lt;script src="img/{% static "js/jquery-1.11.2.min.js" %}"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" href="{% static "css/bootstrap.min.css" %}"&gt;
    &lt;script src="img/{% static "js/bootstrap.min.js" %}"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" href="{% static "css/ol.css" %}" type="text/css"&gt;
    &lt;link rel="stylesheet" href="{% static "css/custom-layout.css" %}" type="text/css"&gt;
    &lt;script src="img/{% static "js/ol340.js" %}"&gt;&lt;/script&gt;

    {% endblock head %}
&lt;/head&gt;
&lt;body&gt;
{% block body %}

    {% block nav %}
        &lt;nav class="navbar navbar-inverse navbar-fixed-top"&gt;
          &lt;div class="container"&gt;
            &lt;div class="navbar-header"&gt;
              &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"&gt;
                &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt;
                &lt;span class="icon-bar"&gt;&lt;/span&gt;
                &lt;span class="icon-bar"&gt;&lt;/span&gt;
                &lt;span class="icon-bar"&gt;&lt;/span&gt;
              &lt;/button&gt;
              &lt;a class="navbar-brand" href="http://www.indrz.com" target="_blank"&gt;Indoor Project&lt;/a&gt;
            &lt;/div&gt;
            &lt;div id="navbar" class="collapse navbar-collapse"&gt;
              &lt;ul class="nav navbar-nav"&gt;
                &lt;li&gt;&lt;a href="#about" target="_blank"&gt;About&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="https://github.com/mdiener21/" target="_blank"&gt;Contact&lt;/a&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;&lt;!--/.nav-collapse --&gt;
          &lt;/div&gt;
        &lt;/nav&gt;
    {% endblock nav %}


{% endblock body %}
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Now we'll <a id="id519" class="indexterm"/>create our final <code class="literal">route-map.html</code> template and the JavaScript that goes with it as follows:<div><pre class="programlisting">{% extends "base.html" %}
{% load staticfiles %}

{% block title %}Simple route map{% endblock %}

{% block head %}
{{ block.super }}
    &lt;script src="img/{% static "js/bloodhound.min.js" %}"&gt;&lt;/script&gt;
    &lt;script src="img/{% static "js/typeahead.bundle.min.js" %}"&gt;&lt;/script&gt;
{% endblock head %}

{% block body %}

{{ block.super }}

&lt;div class="container-fluid"&gt;

    &lt;div class="row"&gt;
      &lt;div class="col-md-2"&gt;
        &lt;div id="directions" class="directions"&gt;
            &lt;form id="submitForm"&gt;
              &lt;div id="rooms-prefetch" class="form-group"&gt;
                &lt;label for="route-to"&gt;Route From:&lt;/label&gt;
                &lt;input type="text" class="typeahead form-control" id="route-to" placeholder="Enter Room Number"&gt;
              &lt;/div&gt;
              &lt;div id="rooms-prefetch" class="form-group"&gt;
                &lt;label for="route-from"&gt;Route To:&lt;/label&gt;
                &lt;input type="text" class="typeahead form-control" id="route-from" placeholder="Enter Room Number"&gt;
              &lt;/div&gt;

                &lt;div class="radio"&gt;
                  &lt;label&gt;
                    &lt;input type="radio" name="typeRoute" id="routeTypeStandard" value="0" checked&gt;
                    Standard Route
                  &lt;/label&gt;
                &lt;/div&gt;
                &lt;div class="radio"&gt;
                  &lt;label&gt;
                    &lt;input type="radio" name="typeRoute" id="routeTypeBarrierFree" value="1"&gt;
                    Barrier Free Route
                  &lt;/label&gt;
                &lt;/div&gt;
              &lt;button id="enterRoute" type="submit" class="btn btn-default"&gt;Go !&lt;/button&gt;
                &lt;br&gt;
            &lt;/form&gt;

        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="col-md-10"&gt;
        &lt;div id="map" class="map"&gt;&lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;  {% include 'routing.js' %} &lt;/script&gt;


&lt;script&gt;
    var roomNums = new Bloodhound({
      datumTokenizer: Bloodhound.tokenizers.whitespace,
      queryTokenizer: Bloodhound.tokenizers.whitespace,
      prefetch: 'http://localhost:8000/api/rooms/?format=json'
    });

    // passing in `null` for the `options` arguments will result in the default
    // options being used
    $('#rooms-prefetch .typeahead').typeahead(null, {
      name: 'countries',
        limit: 100,
      source: roomNums
    });


    $( "#submitForm" ).submit(function( event ) {
    {#  alert( "Handler for .submit() called."  );#}
        var startNum = $('#route-from').val();
        var endNum = $('#route-to').val();
        var rType = $( "input:radio[name=typeRoute]:checked" ).val();
         addRoute(startNum, endNum, rType);
      event.preventDefault();
    });


&lt;/script&gt;


{% endblock body %}</pre></div></li><li class="listitem">Our <code class="literal">maps/templates/routing.js</code> contains the functions needed to call the<a id="id520" class="indexterm"/> routing API as follows:<div><pre class="programlisting">        var url_base = "/api/directions/";
        var start_coord = "1587848.414,5879564.080,2";
        var end_coord =  "1588005.547,5879736.039,2";
        var sel_Val = $( "input:radio[name=typeRoute]:checked" ).val();
        var geojs_url = url_base + start_coord + "&amp;" + end_coord + "&amp;" + sel_Val + '/?format=json';

// uncomment this code if you want to reactivate
// the quick static demo switcher
        //$( ".radio" ).change(function() {
        //   map.getLayers().pop();
        //   var sel_Val2 = $( "input:radio[name=typeRoute]:checked" ).val();
        //   var routeUrl = '/api/directions/1587848.414,5879564.080,2&amp;1588005.547,5879736.039,2&amp;' + sel_Val2  + '/?format=json';
        //
        //  map.getLayers().push(new ol.layer.Vector({
        //            source: new ol.source.GeoJSON({url: routeUrl}),
        //            style:  new ol.style.Style({
        //                stroke: new ol.style.Stroke({
        //                  color: 'blue',
        //                  width: 4
        //                })
        //              }),
        //            title: "Route",
        //            name: "Route"
        //        }));
        //
        //});

        var vectorLayer = new ol.layer.Vector({
                        source: new ol.source.GeoJSON({url: geojs_url}),
                        style:  new ol.style.Style({
                            stroke: new ol.style.Stroke({
                              color: 'red',
                              width: 4
                            })
                          }),
                        title: "Route",
                        name: "Route"
                    });

        var map = new ol.Map({
          layers: [
            new ol.layer.Tile({
              source: new ol.source.OSM()
            })
              ,
            vectorLayer
          ],
          target: 'map',
          controls: ol.control.defaults({
            attributionOptions: /** @type {olx.control.AttributionOptions} */ ({
              collapsible: false
            })
          }),
          view: new ol.View({
            center: [1587927.09817072,5879650.90059265],
            zoom: 18
          })
        });

function addRoute(fromNumber, toNumber, routeType) {
    map.getLayers().pop();
    console.log("addRoute big"+ String(fromNumber));
    var baseUrl = 'http://localhost:8000/api/directions/';
    var geoJsonUrl = baseUrl + fromNumber + '&amp;' + toNumber + '&amp;' + routeType +'/?format=json';
    console.log("final url " + geoJsonUrl);
    map.getLayers().push(new ol.layer.Vector({
                source: new ol.source.GeoJSON({url: geoJsonUrl}),
                style:  new ol.style.Style({
                    stroke: new ol.style.Stroke({
                      color: 'purple',
                      width: 4
                    })
                  }),
                title: "Route",
                name: "Route"
            }));
    }</pre></div></li><li class="listitem">Now, go ahead<a id="id521" class="indexterm"/> and enter <code class="literal">1</code> and see the autocomplete in action; then, select <strong>Route To:</strong> and enter <code class="literal">2</code> to see the second floor options. Finally, click on <strong>GO!</strong> and see the magic happen:<div><img src="img/50790OS_11_08.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec189"/>How it works...</h2></div></div></div><p>The internal workings of each step are shown, so let's go through all of them one at a time. We start off with the data import of our new room dataset as the basic starting and ending points of our new indoor routing tool. We lay out the top-level structure of our API with some new URLs, defining how we will call the new routing service, and then define these variables. Our regular expressions handle the correct data types that are passed in the URL without any exceptions.</p><p>These URL patterns are then used by <code class="literal">api/views.py</code> to actually accept the incoming room numbers and route types to generate our new route. This generation is split up into a few functions to increase usability. The <code class="literal">get_room_centroid_node()</code> function is necessary so that we can find the middle point of the room and then find the next nearest node on a network. We could also simply use the polygon geometry to find the nearest node but this can lead to ambiguity if the rooms are large and the entrances are close to each other. The <code class="literal">centroid</code> method is much more reliable and does not add too much overhead.</p><p>The <code class="literal">run_route()</code> function actually then runs <code class="literal">find_closest_network_node()</code>, which we created earlier, making things work well together. The <code class="literal">run_route</code> function then generates our GeoJSON result as it is passed in the start node ID, end node ID, and the route type.</p><p>The <code class="literal">route_room_to_room()</code> function is small as the heavy lifting has already been completed by our other functions. It simply inputs the URL parameters called by our API call, as seen in <code class="literal">http://localhost:8000/api/directions/10010&amp;20043&amp;0</code>. The final steps after step<a id="id522" class="indexterm"/> 6 are for the user interface. We need to provide the user with a list of rooms that are available to route from and to. The /<code class="literal">api/rooms</code> URL provides exactly this, delivering a JSON array of room numbers. The input fields are bootstrap inputs with Twitter <code class="literal">Typeahead.js</code> and <code class="literal">Bloodhound.js</code> to prefetch remote data. As a user, you simply enter a number and, bingo, a list appears. More detailed instructions on the JavaScript side of things are a little beyond the scope of this book, but these are, thankfully, kept to a minimum.</p><p>All in all, you now have a fully functional indoor mapping web application with a basic set of indoor 3D routing functions that you can expand on at any time.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="appA"/>Appendix A. Other Geospatial Python Libraries</h1></div></div></div><p>We have covered many libraries and examples but we haven't covered them all. This appendix is meant to quickly go over the other libraries out there that play a special role in the Python geospatial working environment. This list is definitely not complete and I have not had the pleasure of working with all these libraries at the time of writing.</p><p>The listing is a resource for further reading and experiments that will, hopefully, provide you with a step in the right direction to solve your specific problems. Each description of a library starts with the official library name followed by a short description and a link to the web page:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Library name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Website</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Rtree</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a id="id523" class="indexterm"/>Python wrapper of <code class="literal">libspatialindex</code> that provides<a id="id524" class="indexterm"/> advanced spatial <a id="id525" class="indexterm"/>indexing features</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://toblerity.org/rtree">http://toblerity.org/rtree</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>rasterio</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a id="id526" class="indexterm"/>Mapbox <a id="id527" class="indexterm"/>creation that aims at working with rasters in an easier<a id="id528" class="indexterm"/> manner</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/mapbox/rasterio">https://github.com/mapbox/rasterio</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Fiona</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id529" class="indexterm"/>focuses on <a id="id530" class="indexterm"/>reading and writing data in the standard <a id="id531" class="indexterm"/>Python I/O style</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://toblerity.org/fiona">http://toblerity.org/fiona</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>geopy</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id532" class="indexterm"/>helps geocoding in <a id="id533" class="indexterm"/>Python</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.geopy.org">http://www.geopy.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PyQGIS</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id534" class="indexterm"/> the Python interface to QGIS (formerly known as Quantum GIS) that <a id="id535" class="indexterm"/>helps extend QGIS<a id="id536" class="indexterm"/> and more</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://pythongisbook.com">http://pythongisbook.com</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GeoPandas</p>
</td><td style="text-align: left" valign="top">
<p>This is an <a id="id537" class="indexterm"/>extension of the pandas library<a id="id538" class="indexterm"/> and<a id="id539" class="indexterm"/> handles geospatial database</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://geopandas.org/">http://geopandas.org/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MapFish</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id540" class="indexterm"/> Python's <a id="id541" class="indexterm"/>geospatial <a id="id542" class="indexterm"/>web framework</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://mapfish.org">http://mapfish.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PyWPS</p>
</td><td style="text-align: left" valign="top">
<p>This client<a id="id543" class="indexterm"/> interacts <a id="id544" class="indexterm"/>with various open geospatial <a id="id545" class="indexterm"/>standard services</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://pywps.wald.intevation.org">http://pywps.wald.intevation.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>pycsw</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id546" class="indexterm"/> provides a<a id="id547" class="indexterm"/> metadata catalog <a id="id548" class="indexterm"/>interface</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://pycsw.org">http://pycsw.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GeoNode</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id549" class="indexterm"/>provides Python geospatial <a id="id550" class="indexterm"/>content management for the Web and is built on the Django <a id="id551" class="indexterm"/>web framework and GeoServer</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://geonode.org">http://geonode.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>mapnik</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a id="id552" class="indexterm"/>map visualization library to create maps for <a id="id553" class="indexterm"/>web tile <a id="id554" class="indexterm"/>cache</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://mapnik.org">http://mapnik.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>cartopy</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id555" class="indexterm"/> is<a id="id556" class="indexterm"/> mapping made <a id="id557" class="indexterm"/>easy in Python-shapely</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://scitools.org.uk/cartopy">http://scitools.org.uk/cartopy</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Kartograph</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id558" class="indexterm"/>creates SVG<a id="id559" class="indexterm"/> maps <a id="id560" class="indexterm"/>or web maps</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://kartograph.org">http://kartograph.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>basemap</p>
</td><td style="text-align: left" valign="top">
<p>This is an<a id="id561" class="indexterm"/> extension <a id="id562" class="indexterm"/>of matplotlib in<a id="id563" class="indexterm"/> combination with descartes</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://matplotlib.org/basemap">http://matplotlib.org/basemap</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SciPy</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a id="id564" class="indexterm"/>collection of Python libraries for scientific data<a id="id565" class="indexterm"/> analysis that are bundled or available as <a id="id566" class="indexterm"/>individual installations</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.scipy.org">http://www.scipy.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GeoAlchemy</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id567" class="indexterm"/>a spatial extension to SQLAlchemy<a id="id568" class="indexterm"/> that works with the spatial <a id="id569" class="indexterm"/>database PostGIS</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://geoalchemy.org">http://geoalchemy.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>pyspatialite</p>
</td><td style="text-align: left" valign="top">
<p>This helps <a id="id570" class="indexterm"/>you work with spatialite <a id="id571" class="indexterm"/>databases of<a id="id572" class="indexterm"/> geospatial data</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://pypi.python.org/pypi/pyspatialite">https://pypi.python.org/pypi/pyspatialite</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>gpxpy</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id573" class="indexterm"/>helps when working with GPS data in the <a id="id574" class="indexterm"/>standard GPX format in a Python - <a id="id575" class="indexterm"/>friendly format</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.trackprofiler.com/gpxpy/index.html">http://www.trackprofiler.com/gpxpy/index.html</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>ShaPy</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a id="id576" class="indexterm"/>pure <a id="id577" class="indexterm"/>Python version of Shapely with no <a id="id578" class="indexterm"/>dependencies</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/karimbahgat/Shapy">https://github.com/karimbahgat/Shapy</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>pyshp</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id579" class="indexterm"/>reads and<a id="id580" class="indexterm"/> writes<a id="id581" class="indexterm"/> Shapefiles in pure Python</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/GeospatialPython/pyshp">https://github.com/GeospatialPython/pyshp</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>TileCache</p>
</td><td style="text-align: left" valign="top">
<p>This is an <a id="id582" class="indexterm"/>implementation<a id="id583" class="indexterm"/> of a <a id="id584" class="indexterm"/>WMS-C (catalog) <strong>Tile Mapping Server</strong> (<strong>TMS</strong>) server</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://tilecache.org">http://tilecache.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>TileStache</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id585" class="indexterm"/> Python-based server application <a id="id586" class="indexterm"/>that can serve up map tiles based on<a id="id587" class="indexterm"/> rendered geographic data</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.tilestache.org">http://www.tilestache.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>FeatureServer</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id588" class="indexterm"/> restful feature service to easily <a id="id589" class="indexterm"/>get, edit, delete, and update features <a id="id590" class="indexterm"/>over the Web with  the help of HTTP</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://featureserver.org">http://featureserver.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GeoScript</p>
</td><td style="text-align: left" valign="top">
<p>This is an<a id="id591" class="indexterm"/> implementation of Python, giving <a id="id592" class="indexterm"/>spatial analysis functionality to<a id="id593" class="indexterm"/> other scripting languages and Python is one of them; it is similar to Shapely</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.geoscript.org">http://www.geoscript.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>karta</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id594" class="indexterm"/> is <a id="id595" class="indexterm"/>a Leatherman for<a id="id596" class="indexterm"/> geographic analyses</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://ironicmtn.com/karta">http://ironicmtn.com/karta</a>
</p>
</td></tr></tbody></table></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="appB"/>Appendix B. Mapping Icon Libraries</h1></div></div></div><p>Finding the perfect mapping icon set is hard. The following list provides some of the better map symbols around, for your web map application:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Library name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Website</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>map-icons</p>
</td><td style="text-align: left" valign="top">
<p>This is an<a id="id597" class="indexterm"/> icon font that's used with the Google<a id="id598" class="indexterm"/> Maps API and Google Places API using SVG markers and icon labels</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://map-icons.com/">http://map-icons.com/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Maki </p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id599" class="indexterm"/> creates Mapbox Pixel-perfect icons for <a id="id600" class="indexterm"/>web cartography</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.mapbox.com/maki">https://www.mapbox.com/maki</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>map icons</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id601" class="indexterm"/> focuses on reading and writing data in the standard<a id="id602" class="indexterm"/> Python IO style</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://mapicons.mapsmarker.com/">https://mapicons.mapsmarker.com/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Integration and Application Network</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id603" class="indexterm"/>creates 2782<a id="id604" class="indexterm"/> custom vector symbols</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://ian.umces.edu/symbols/">http://ian.umces.edu/symbols/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>OSM icons</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id605" class="indexterm"/>a set of free SVG icons that are used for <a id="id606" class="indexterm"/>OSM maps</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://osm-icons.org/wiki/Icons">http://osm-icons.org/wiki/Icons</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>OSGeo map symbol set</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id607" class="indexterm"/> collection of links to <a id="id608" class="indexterm"/>map icons</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://wiki.osgeo.org/wiki/OSGeo_map_symbol_set">http://wiki.osgeo.org/wiki/OSGeo_map_symbol_set</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>SJJB collection</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a id="id609" class="indexterm"/>set of PD/CC0 SVG map icons and<a id="id610" class="indexterm"/> tools to generate PNG icons</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/twain47/Open-SVG-Map-Icons">https://github.com/twain47/Open-SVG-Map-Icons</a> and <a class="ulink" href="http://www.sjjb.co.uk/mapicons/contactsheet">http://www.sjjb.co.uk/mapicons/contactsheet</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>OSM map-icons</p>
</td><td style="text-align: left" valign="top">
<p>This creates an <a id="id611" class="indexterm"/>OpenStreetMap set<a id="id612" class="indexterm"/> of icons</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/openstreetmap/map-icons/tree/master/svg">https://github.com/openstreetmap/map-icons/tree/master/svg</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>opensreetmap-carto</p>
</td><td style="text-align: left" valign="top">
<p>Andy Allan created these set of mapping icons in PNG<a id="id613" class="indexterm"/>
<a id="id614" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/gravitystorm/openstreetmap-carto/tree/master/symbols">https://github.com/gravitystorm/openstreetmap-carto/tree/master/symbols</a>
</p>
</td></tr></tbody></table></div></div></div>
</body></html>