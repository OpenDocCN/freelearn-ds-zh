- en: Chapter 10. Recommender Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering using explicit feedback
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative filtering using implicit feedback
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is Wikipedia''s definition of recommender systems:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '*"Recommender systems are a subclass of information filtering system that seek
    to predict the ''rating'' or ''preference'' that user would give to an item."*'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Recommender systems have gained immense popularity in recent years. Amazon
    uses them to recommend books, Netflix for movies, and Google News to recommend
    news stories. As the proof is in the pudding, here are some examples of the impact
    recommendations can have (source: Celma, Lamere, 2008):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Two-thirds of the movies watched on Netflix are recommended
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 38 percent of the news clicks on Google News are recommended
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 35 percent of the sales at Amazon sales are the result of recommendations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have seen in the previous chapters, features and feature selection play
    a major role in the efficacy of machine learning algorithms. Recommender engine
    algorithms discover these features, called **latent features**, automatically.
    In short, there are latent features responsible for a user to like one movie and
    dislike another. If another user has corresponding latent features, there is a
    good chance that this person will also have a similar taste for movies.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s look at some sample movie ratings:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '| Movie | Rich | Bob | Peter | Chris |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| *Titanic* | 5 | 3 | 5 | ? |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| *GoldenEye* | 3 | 2 | 1 | 5 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| *Toy Story* | 1 | ? | 2 | 2 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| *Disclosure* | 4 | 4 | ? | 4 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| *Ace Ventura* | 4 | ? | 4 | ? |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: 'Our goal is to predict the missing entries shown with the ? symbol. Let''s
    see if we can find some features associated with movies. At first, you will look
    at the genres, as shown here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '| Movie | Genre |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| *Titanic* | Action, Romance |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| *GoldenEye* | Action, Adventure, Thriller |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| *Toy Story* | Animation, Children''s, Comedy |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| *Disclosure* | Drama, Thriller |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| *Ace Ventura* | Comedy |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: Now each movie can be rated for each genre from 0 to 1\. For example, *GoldenEye*
    is not primarily a romance, so it may have 0.1 rating for romance, but 0.98 rating
    for action. Therefore, each movie can be represented as a feature vector.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we are going to use the MovieLens dataset from [grouplens.org/datasets/movielens/](http://grouplens.org/datasets/movielens/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The InfoObjects big data sandbox comes loaded with 100k movie ratings. From
    GroupLens you can also download 1 million-or even up to 10 million-ratings if
    you would like to analyze bigger dataset for better predictions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use two files from this dataset:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '`u.data`: This has a tab-separated list of movie ratings in the following format:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since we are not going to need the time stamp, we are going to filter it out
    from the data in our recipe
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`u.item`: This has a tab-separated list of movies in the following format:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This chapter will cover how we can make recommendations using MLlib, the Spark's
    machine learning library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering using explicit feedback
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collaborative filtering is the most commonly used technique for recommender
    systems. It has an interesting property—it learns the features on its own. So,
    in the case of movie ratings, we do not need to provide actual human feedback
    on whether the movie is romantic or action.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the *Introduction* section that movies have some latent features,
    such as genre, in the same way users have some latent features, such as age, gender,
    and more. Collaborative filtering does not need them, and figures out latent features
    on its own.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use an algorithm called **Alternating Least Squares** (**ALS**)
    in this example. This algorithm explains the association between a movie and a
    user based on a small number of latent features. It uses three training parameters:
    rank, number of iterations, and lambda (explained later in the chapter). The best
    way to figure out the optimum values of these three parameters is to try different
    values and see which value has the smallest amount of **Root Mean Square Error**
    (**RMSE**). This error is like a standard deviation, but it is based on model
    results rather than actual data.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Upload the `moviedata` downloaded from GroupLens to the `moviedata` folder
    in `hdfs`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are going to add some personalized ratings to this database so that we can
    test the accuracy of the recommendations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: You can look at `u.item` to pick some movies and rate them. The following are
    some movies I chose, alongside my ratings. Feel free to choose the movies you
    would like to rate and provide your own ratings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '| Movie ID | Movie name | Rating (1-5) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| 313 | *Titanic* | 5 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| 2 | *GoldenEye* | 3 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| 1 | *Toy Story* | 1 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| 43 | *Disclosure* | 4 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| 67 | *Ace Ventura* | 4 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| 82 | *Jurassic Park* | 5 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| 96 | *Terminator 2* | 5 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| 121 | *Independence Day* | 4 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| 148 | *The Ghost and the Darkness* | 4 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: 'The highest user ID is 943, so we are going to add the new user as 944\. Let''s
    create a new comma-separated file `p.data` with the following data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Upload the personalized movie data to `hdfs`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Import the ALS and rating classes:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Load the rating data into an RDD:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Transform the `val data` into the RDD of rating:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Load the personalized rating data into the RDD:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Transform the data into the RDD of personalized rating:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Combine ratings with personalized ratings:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Build the model using ALS with rank 5 and 10 iterations and 0.01 as lambda:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's predict what my rating would be for a given movie based on this model.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with original *Terminator* with movie ID 195:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since I rated *Terminator* *2* 5, this is a reasonable prediction.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try *Ghost* with movie ID 402:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It's a reasonable guess.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try *The Ghost and the Darkness*, the movie I already rated, with the
    ID 148:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Very close prediction, knowing that I rated the movie 4.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use more movies to the `train` dataset. There are also 1 million and
    10 million rating datasets available that will refine the algorithm even more.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering using implicit feedback
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the feedback available is not in the form of ratings but in the form
    of audio tracks played, movies watched, and so on. This data, at first glance,
    may not look as good as explicit ratings by users, but this is much more exhaustive.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to use million song data from [http://www.kaggle.com/c/msdchallenge/data](http://www.kaggle.com/c/msdchallenge/data).
    You need to download three files:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`kaggle_visible_evaluation_triplets`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kaggle_users.txt`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kaggle_songs.txt`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now perform the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `songdata` folder in `hdfs` and put all the three files here:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Upload the song data to `hdfs`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We still need to do some more preprocessing. ALS in MLlib takes both user and
    product IDs as integer. The `Kaggle_songs.txt` file has song IDs and sequence
    number next to it, The `Kaggle_users.txt` file does not have it. Our goal is to
    replace the `userid` and `songid` in `triplets` data with the corresponding integer
    sequence numbers. To do this, follow these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `kaggle_songs` data as an RDD:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Load the user data as an RDD:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Load the triplets (user, song, plays) data as an RDD:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Convert the song data into the `PairRDD`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Collect the `songIndex` as Map:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Convert the user data into the `PairRDD`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Collect the `userIndex` as Map:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will need both `songMap` and `userMap` to replace `userId` and `songId` in
    triplets. Spark will automatically make both these maps available on the cluster
    as needed. This works fine but is expensive to send across the cluster every time
    it is needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: A better approach is to use a Spark feature called `broadcast` variables. The
    `broadcast` variables allow the Spark job to keep a read-only copy of a variable
    cached on each machine, rather than shipping a copy with each task. Spark distributes
    broadcast variables using efficient broadcast algorithms, so communication cost
    over the network is negligible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can guess, both `songMap` and `userMap` are good candidates to be wrapped
    around the `broadcast` variables. Perform the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadcast the `userMap`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Broadcast the `songMap`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Convert the `triplet` into an array:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Import the rating:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Convert the `triplet` array into an RDD of rating objects:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, our data is ready to do the modeling and prediction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import ALS:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Build a model using the ALS with rank 10 and 10 iterations:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Extract the user and song tuples from the triplet:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Make predictions for the user and song tuples:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our model takes four parameters to work, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter name | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| Rank | Number of latent features in the model |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| Iterations | Number of iterations for this factorization to run |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| Lambda | Over fitting parameter |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| Alpha | Relative weight of observed interactions |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: As you saw in the case of gradient descent, these parameters need to be set
    by hand. We can try different values, but the value that works best is rank=50,
    iterations=30, lambda=0.00001, and alpha= 40.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在梯度下降的例子中所看到的，这些参数需要手动设置。我们可以尝试不同的值，但最佳值是 rank=50，iterations=30，lambda=0.00001，以及
    alpha= 40。
- en: There's more…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One way to test different parameters quickly is to spawn a spark cluster on
    Amazon EC2\. This gives you flexibility to go with a powerful instance to test
    these parameters fast. I have created a public s3 bucket `com.infoobjects.songdata`
    to pull data to Spark.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试不同参数的一种方法是在 Amazon EC2 上启动一个 Spark 集群。这让你有灵活性，可以选择一个强大的实例来快速测试这些参数。我已经创建了一个公共的
    s3 存储桶 `com.infoobjects.songdata`，用于将数据拉入 Spark。
- en: 'Here are the steps you need to follow to load the data from S3 and run the
    ALS:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要遵循以下步骤从 S3 加载数据并运行 ALS：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These are the predictions made on the `usersSongs` matrix.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基于 `usersSongs` 矩阵做出的预测。
