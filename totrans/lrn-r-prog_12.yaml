- en: Chapter 12. Data Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章 数据操作
- en: In the previous chapter, you learned the methods used to access different types
    of databases such as relational databases (SQLite and MySQL) and non-relational
    databases (MongoDB and Redis). Relational databases usually return data in a tabular
    form, while non-relational databases may support nested data structures and other
    features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了访问不同类型数据库的方法，例如关系型数据库（SQLite 和 MySQL）和非关系型数据库（MongoDB 和 Redis）。关系型数据库通常以表格形式返回数据，而非关系型数据库可能支持嵌套数据结构和其他功能。
- en: Even though the data is loaded into memory, it is usually far from ready for
    data analysis. Most data at this stage still needs cleaning and transforming,
    which, in fact, may take a large proportion of time before any statistical model
    and visualization can be applied. In this chapter, you'll learn about a set of
    built-in functions and several packages for data manipulation. The packages are
    extremely powerful. However, to better work with these packages, we need a concrete
    understanding of the knowledge introduced in the previous chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据已经加载到内存中，通常也远未准备好进行数据分析。在这个阶段，大多数数据仍然需要清洗和转换，实际上，这可能占去在应用任何统计模型和可视化之前的大部分时间。在本章中，你将学习到一组内置函数和几个用于数据操作的工具包。这些工具包非常强大。然而，为了更好地使用这些工具包，我们需要对前几章中介绍的知识有一个具体的理解。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using basic functions to manipulate data frames
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本函数操作数据框
- en: Using SQL to query data frames via the `sqldf` package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQL 通过 `sqldf` 包查询数据框
- en: Using `data.table` to manipulate data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `data.table` 操作数据
- en: Using `dplyr` pipelines to manipulate data frames
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dplyr` 管道操作数据框
- en: Using `rlist` to work with nested data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `rlist` 处理嵌套数据结构
- en: Using built-in functions to manipulate data frames
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置函数操作数据框
- en: Previously, you learned the basics of data frames. Here, we will review the
    built-in functions used to filter a data frame. Although a data frame is essentially
    a list of vectors, we can access it like a matrix since all column vectors are
    of the same length. To select rows that meet certain conditions, we will supply
    a logical vector as the first argument of `[]`, while the second is left empty.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你学习了数据框的基本知识。在这里，我们将回顾用于过滤数据框的内置函数。尽管数据框本质上是一个向量的列表，但由于所有列向量长度相同，我们可以像访问矩阵一样访问它。为了选择满足某些条件的行，我们将提供一个逻辑向量作为
    `[]` 的第一个参数，而第二个参数留空。
- en: In R, these operations can be done with built-in functions. In this section,
    we will introduce some built-in functions that are most helpful to manipulate
    data into the form we need as model input or for presentation. Some of the functions
    or techniques are already presented in the previous chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，这些操作可以使用内置函数完成。在本节中，我们将介绍一些最有助于将数据操作成所需形式作为模型输入或用于展示的内置函数。其中一些函数或技术已在之前的章节中介绍过。
- en: 'Most of the code in this section and subsequent sections are based on a group
    of fictitious data about some products. We will use the `readr` package to load
    the data for better handling of column types. If you don''t have this package
    installed, run `install.packages("readr")`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本节和随后的部分中的大部分代码都是基于一组关于某些产品的虚构数据。我们将使用 `readr` 包来加载数据，以便更好地处理列类型。如果你还没有安装此包，请运行
    `install.packages("readr")`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the data is loaded into memory as a data frame, we can take a look at
    its column types:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据以数据框的形式加载到内存中，我们可以查看其列类型：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `readr::read_csv` argument has different behavior from the built-in function `read.csv`.
    For example, it does not automatically convert string columns to factors (which
    can be problematic, but adds little value). Therefore, I recommend that you use
    functions provided by `readr` to read tabular data from file into R. If we were
    using the `read.csv` file, then all these columns would be factors with limited
    possible values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`readr::read_csv` 参数与内置函数 `read.csv` 的行为不同。例如，它不会自动将字符串列转换为因子（这可能会引起问题，但价值不大）。因此，我建议你使用
    `readr` 提供的函数从文件中读取表格数据到 R。如果我们使用 `read.csv` 文件，那么所有这些列都会是具有有限可能值的因子。'
- en: Using built-in functions to manipulate data frames
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置函数操作数据框
- en: Previously, you learned the basics of data frames. In this section, we will
    review the built-in functions to filter a data frame. Although a data frame is
    essentially a list of vectors, we can access it like a matrix since all column
    vectors are of the same length. To select rows that meet certain conditions, we
    will supply a logical vector as the first argument of `[]`, while the second is
    left empty. In the following examples, we will use a series of product information
    points and statistics we introduced earlier to demonstrate basic data-filtering
    methods and summary techniques.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你学习了数据框的基础知识。在本节中，我们将回顾用于过滤数据框的内置函数。尽管数据框本质上是一系列向量，但由于所有列向量长度相同，我们可以像访问矩阵一样访问它。要选择满足某些条件的行，我们将提供一个逻辑向量作为
    `[]` 的第一个参数，而第二个参数留空。在以下示例中，我们将使用我们之前介绍的一系列产品信息和统计数据来演示基本的数据过滤方法和汇总技术。
- en: 'For example, we will take out all rows of `toy` type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将取出所有 `toy` 类型的行：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, we could take out all rows that are not released:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以取出所有未发布的行：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To filter columns, we will supply a character vector as the second argument
    while the first is left empty, which is exactly what we did when we subset a matrix:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤列，我们将提供一个字符向量作为第二个参数，而第一个参数留空，这正是我们在子集化矩阵时所做的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, we can filter the data frame by regarding it as a list. We will
    supply only one character vector of column names in `[]` and omit the comma:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将数据框视为列表来过滤数据。我们只提供一个包含列名的字符向量 `[]`，并省略逗号：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To filter a data frame by both row and column, we will supply a vector as the
    first argument to select rows and a vector as the second to select columns:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过行和列过滤数据框，我们将提供一个向量作为第一个参数来选择行，并提供一个向量作为第二个参数来选择列：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the row-filtering condition is based on values of certain columns, the preceding
    code can be very redundant, especially when the condition gets more complicated.
    Another built-in function that simplifies code is `subset`, as we introduced previously:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果行过滤条件基于某些列的值，前面的代码可能会非常冗余，尤其是当条件变得更加复杂时。另一个简化代码的内置函数是 `subset`，正如我们之前所介绍的：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `subset` function uses non-standard evaluation so that we can directly use
    the columns of the data frame without typing `product_info` many times, because
    the expressions are meant to be evaluated in the context of the data frame.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`subset` 函数使用非标准评估，这样我们就可以直接使用数据框的列，而无需多次输入 `product_info`，因为表达式是在数据框的上下文中被评估的。'
- en: 'Similarly, we can use `with` to evaluate an expression in the context of the
    data frame, that is, the columns of the data frame can be used as symbols in the
    expression without repeatedly specifying the data frame:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `with` 在数据框的上下文中评估一个表达式，也就是说，数据框的列可以在表达式中作为符号使用，而无需反复指定数据框：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The expression can be more than a simple subsetting. We can summarize the data
    by counting the occurrences of each possible value of a vector. For example, we
    can create a table of the occurrences of types of records that are released:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以不仅仅是简单的子集化。我们可以通过计算向量的每个可能值的出现次数来总结数据。例如，我们可以创建一个记录类型的出现次数表：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In addition to the table of product information, we also have a table of product
    statistics that describe some properties of each product:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了产品信息表之外，我们还有一个描述每个产品某些属性的产品统计表：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, think how we can get the names of products with the top three largest
    sizes. One way is to sort the records in `product_stats` by size in descending
    order, select `id` values of the top three records, and use these values to filter
    rows of `product_info` by `id`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，思考一下我们如何获取最大三个尺寸的产品名称。一种方法是对 `product_stats` 中的记录按尺寸降序排序，选择前三个记录的 `id` 值，并使用这些值通过
    `id` 过滤 `product_info` 的行：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Although it works as supposed, this approach looks quite redundant. Note that
    `product_info` and `product_stats` actually describe the same set of products
    from different perspectives. The connection between these two tables is the `id`
    column. Each `id` is unique and refers to the same product. To access both sets
    of information, we can put the two tables together into one data frame. The simplest
    way to do this is use `merge`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它按预期工作，但这种方法看起来相当冗余。请注意，`product_info` 和 `product_stats` 实际上是从不同角度描述相同产品集合的。这两个表之间的联系是
    `id` 列。每个 `id` 都是唯一的，并指代相同的产品。要访问这两组信息，我们可以将两个表合并到一个数据框中。最简单的方法是使用 `merge`：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we create a new data frame that is a combined version of `product_table`
    and `product_info`, with a shared `id` column. In fact, if you reorder the records
    in the second table, the two tables still can be correctly merged.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个新的数据框，它是`product_table`和`product_info`的合并版本，具有共享的`id`列。实际上，如果你重新排列第二个表中的记录，这两个表仍然可以正确合并。
- en: 'With the combined version, we can do things more easily. For example, with
    the merged version, we can sort the data frame with any column in one table that
    we loaded without having to manually work with the other:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合并版本，我们可以更容易地做事情。例如，使用合并版本，我们可以对任何我们加载的表格中的任何列进行排序，而无需手动处理其他列：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To solve the problem, we can directly use the merged table and get the same
    answer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，我们可以直接使用合并后的表格并得到相同的结果：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The merged data frame allows us to sort the records by a column in one data
    frame and filter the records by a column in the other. For example, we will first
    sort the product records by weight in descending order and select all records
    of the `model` type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 合并后的数据框允许我们根据一个数据框中的列对记录进行排序，并按另一个数据框中的列过滤记录。例如，我们将首先按重量降序对产品记录进行排序，并选择所有`model`类型的记录：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Sometimes, the column values are literal but can be converted to standard R
    data structures to better represent the data. For example, the `released` column
    in `product_info` only takes `yes` and `no`, which can be better represented with
    a logical vector. We can use `<-` to modify the column values, as you learned
    previously. However, it is usually better to create a new data frame with the
    existing columns properly adjusted and new columns added without polluting the
    original data. To do this, we can use `transform`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，列值是字面值，但可以转换为标准的R数据结构以更好地表示数据。例如，`product_info`中的`released`列只接受`yes`和`no`，这可以用逻辑向量更好地表示。我们可以使用`<-`来修改列值，就像你之前学过的那样。然而，通常更好的做法是创建一个新的数据框，其中现有的列已适当调整，并添加了新列，而不污染原始数据。为此，我们可以使用`transform`：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result is a new data frame with `released` converted to a logical vector
    and a new column, `density`, added. You can easily verify that `product_table`
    is not modified at all.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新的数据框，其中`released`被转换为逻辑向量，并添加了一个新的列`density`。你可以轻松验证`product_table`没有被修改。
- en: Also, note that `transform` works in a way similar to `subset` because both
    functions use non-standard evaluation to allow direct use of data frame columns
    as symbols in the arguments so that we don't have to type `product_table$` before
    columns all the time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，`transform`的工作方式与`subset`类似，因为这两个函数都使用非标准评估，允许直接在参数中使用数据框列作为符号，这样我们就不必在所有列前都输入`product_table$`。
- en: 'In the preceding data, a number of columns contain missing values represented
    by `NA`. Under many circumstances, we don''t want any missing values to be present
    in our data. Therefore, we need to somehow deal with them. To demonstrate the
    various techniques, we will load another table that contains missing values. The
    table is the test results of the quality, durability, and waterproofing of each
    product in the previous dataset we used. It is the test results of the quality,
    durability, and waterproofing of each product. We will store the data in `product_tests`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据中，许多列包含用`NA`表示的缺失值。在许多情况下，我们不想在我们的数据中存在任何缺失值。因此，我们需要以某种方式处理它们。为了展示各种技术，我们将加载另一个包含缺失值的表。这个表是我们之前使用的数据集中每个产品的质量、耐用性和防水测试结果。它是每个产品的质量、耐用性和防水测试结果。我们将数据存储在`product_tests`中：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that the values in both `quality` and `durability` contain missing values
    (`NA`). To exclude all rows with missing values, we can use `na.omit()`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`quality`和`durability`中的值都包含缺失值（`NA`）。为了排除所有包含缺失值的行，我们可以使用`na.omit()`：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another way is to use `complete.cases()` to get a logical vector, indicating
    all complete rows (without any missing value):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`complete.cases()`来获取一个逻辑向量，指示所有完整行（没有任何缺失值）：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we can use this logical vector to filter the data frame. For example,
    we can get the `id` of all complete rows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个逻辑向量来过滤数据框。例如，我们可以获取所有完整行的`id`：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, we can get the id of all incomplete rows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以获取所有不完整行的`id`：
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that `product_info`, `product_stats`, and `product_tests` all share an `id`
    column; we can merge them all together. Unfortunately, there''s no built-in function
    to merge an arbitrary number of data frames. We can only merge two existing data
    frames at a time, or we''ll have to merge them recursively:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`product_info`、`product_stats`和`product_tests`都共享一个`id`列；我们可以将它们全部合并在一起。不幸的是，没有内置的函数可以合并任意数量的数据框。我们一次只能合并两个现有的数据框，或者我们必须递归地合并它们：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the fully merged table, we can use `tapply`, another apply-family function
    specialized to work with tabular data, to summarize the data using certain methods
    over given columns. For example, we can calculate the mean value of `quality`
    of each `type`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全合并的表中，我们可以使用`tapply`，另一个专门用于处理表格数据的apply族函数，通过给定的列使用某些方法来总结数据。例如，我们可以计算每个`type`的`quality`的平均值：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that we not only supply `mean` but also specify `na.rm = TRUE` to ignore
    the missing values in `quality`. The result looks like a numeric vector. We will
    use `str()`, so let''s take a look at its structure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不仅提供了`mean`，还指定了`na.rm = TRUE`来忽略`quality`中的缺失值。结果看起来像一个数值向量。我们将使用`str()`，让我们看看它的结构：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In fact, it is a one-dimensional array:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它是一个一维数组：
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `tapply` function produces an array instead of a simple numeric vector,
    because it can be easily generalized to work with multiple grouping. For example,
    we can compute the mean value of `quality` for each `type` and `class` pair:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`tapply`函数产生一个数组而不是简单的数值向量，因为它可以很容易地推广到处理多个分组。例如，我们可以计算每个`type`和`class`对的`quality`的平均值：'
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we have a two-dimensional array, whose values can be extracted by two
    arguments:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个二维数组，其值可以通过两个参数提取：
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Moreover, we can supply more columns for grouping. In the following code, we
    will use the `with()` function to reduce redundant typing of `product_full`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以提供更多用于分组的列。在下面的代码中，我们将使用`with()`函数来减少对`product_full`的冗余输入：
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, a three-dimensional array is produced. Even though `na.rm = TRUE` is specified,
    many cells are still missing values. This is because no value is present for the
    grouping:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，生成了一个三维数组。尽管指定了`na.rm = TRUE`，但许多单元格仍然有缺失值。这是因为分组中没有值：
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can access the cell value by supplying three arguments:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供三个参数来访问单元格值：
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In summary,`tapply` groups the input data frame with `n` specified variables
    and produces an array with `n` dimensions. This approach to summarizing data can
    be hard to work with, especially when there are more columns for grouping. This
    is mostly because array is usually high-dimensional, hard to represent, and not
    flexible for further manipulation. Later in this chapter, you will learn several
    different methods that make group summary much easier.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`tapply`使用`n`个指定的变量对输入数据框进行分组，并产生一个具有`n`维度的数组。这种方法总结数据可能很难处理，特别是当有更多用于分组的列时。这主要是因为数组通常是高维的，难以表示，并且不灵活，不适合进一步的操作。在本章的后面部分，你将学习几种不同的方法，这些方法可以使分组总结变得更容易。
- en: Reshaping data frames using reshape2
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用reshape2重塑数据框
- en: Previously, you learned how to filter, sort, merge, and summarize data frames.
    These operations only work on rows and columns separately. Sometimes, however,
    we need to do something more complex.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你学习了如何过滤、排序、合并和总结数据框。这些操作仅在行和列上单独工作。然而，有时我们需要做更复杂的事情。
- en: 'For example, the following code loads a dataset of tests on quality and durability
    on different dates of two products:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码加载了两个产品在不同日期上关于质量和耐久性的测试数据集：
- en: '[PRE31]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Each row of the preceding data frame represents a record of tests of a particular
    product (`id`) on a certain `date`. If we need to compare the quality or durability
    of the two products at the same time, it can be hard to work with such format
    of data. Instead, we need the data to be transformed like the following code so
    that we can compare the values of the two products more easily:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据框的每一行代表了一个特定产品（`id`）在特定`date`上的测试记录。如果我们需要同时比较两个产品的质量或耐用性，处理这种数据格式可能会很困难。相反，我们需要数据像以下代码那样转换，以便更容易地比较两个产品的值：
- en: '[PRE32]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `reshape2` package is designed for such a transform. If you don''t have
    it installed, run the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape2`包就是为了这种转换而设计的。如果您还没有安装它，请运行以下命令：'
- en: '[PRE33]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the package is installed, we can use `reshape2::dcast` to transform the
    data so that we can easily compare the `quality` of different products on the
    same `date`. More specifically, it reshapes `toy_tests` so that the `date` column
    is shared, the values in `id` are spread as columns, and the values for each `date`
    and `id` are `quality` data:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了包，我们就可以使用`reshape2::dcast`转换数据，这样我们就可以轻松地比较同一`date`上不同产品的`quality`。更具体地说，它将`toy_tests`重新排列，使得`date`列是共享的，`id`中的值作为列展开，每个`date`和`id`的值是`quality`数据：
- en: '[PRE34]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, `toy_tests` is immediately transformed. The `quality` values
    of both products are aligned with `date`. Although each month the two products
    conduct a test, the date may not exactly match with each other. This results in
    missing values if one product has a value on a day, but the other has no corresponding
    value on exactly the same day.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`toy_tests`立即被转换。两个产品的`quality`值与`date`对齐。尽管每个月两个产品都会进行测试，但日期可能并不完全匹配。如果一个产品在某一天有值，而另一个产品在同一天没有相应的值，这会导致缺失值。
- en: 'One way to fill the missing value is to use the approach called **Last Observation
    Carried Forward** (**LOCF**), which means that if a non-missing value is followed
    by a missing value, then the non-missing value is carried forward to replace the
    missing value, until all subsequent missing values are replaced. One implementation
    of LOCF is provided by the `zoo` package. Run the following command to install
    the package if you don''t have it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 填充缺失值的一种方法是用称为**最后观测值前推**（**LOCF**）的方法，这意味着如果一个非缺失值后面跟着一个缺失值，那么非缺失值将被前推以替换缺失值，直到所有后续的缺失值都被替换。`zoo`包提供了一个LOCF的实现。如果您还没有安装此包，请运行以下命令进行安装：
- en: '[PRE35]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To demonstrate how it works, we will use `zoo::na.locf()` to perform this technique
    over a very simple numeric vector with missing values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示它是如何工作的，我们将使用`zoo::na.locf()`在具有缺失值的非常简单的数值向量上执行此技术：
- en: '[PRE36]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It is straightforward that all missing values are replaced with previous non-missing
    values. To do the same thing with `T01` and `T02` columns of `toy_quality`, we
    can sub-assign the processed vector to the columns:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，所有缺失值都被替换为前面的非缺失值。为了用`T01`和`T02`列的`toy_quality`做同样的事情，我们可以将处理后的向量子赋值给这些列：
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, if `toy_tests` contains thousands of products, it is ridiculous to
    write thousands of lines of code to do similar things like this. A better practice
    would be using exclusive sub-assignment as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`toy_tests`包含成千上万的产品，编写数千行代码来做类似的事情是荒谬的。更好的做法是使用专用的子赋值，如下所示：
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will use `lapply()` to perform LOCF over all columns of `toy_quality`, except `date`,
    and assign the resulting list to the subset of `toy_quality` without the `date`
    column. This works because sub-assignment of a data frame accepts a list and still
    preserves the class of data frame.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`lapply()`对`toy_quality`的所有列（除了`date`列）执行LOCF，并将结果列表分配给没有`date`列的`toy_quality`子集。这是因为数据框的子赋值接受一个列表，并且仍然保留数据框的类。
- en: However, although the data does not contain any missing values, the meaning
    of each row is changed. Originally, product `T01` does not take a test on `20160303`.
    The value should be interpreted as the last test value of quality on or before
    the day. Another drawback is that in the original data, both products take tests
    every month, but the preceding reshaped data frame is not aligned to `date` of
    regular frequency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管数据中不包含任何缺失值，但每一行的含义发生了变化。最初，产品`T01`在`20160303`这一天没有进行测试。这个值应该被解释为在该日或之前最后一次质量测试的值。另一个缺点是，在原始数据中，两种产品每个月都会进行测试，但重新排列后的数据框并没有与`date`的常规频率对齐。
- en: 'One way to fix the drawbacks is to use year-month data instead of an exact
    date. In the following code, we will create a new column `ym`, that is, the first
    6 characters of `toy_tests`. For example, `substr(20160101, 1, 6)` will result
    in `201601`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这些缺点的一种方法是用年月数据而不是确切的日期。在下面的代码中，我们将创建一个新的列`ym`，即`toy_tests`的前6个字符。例如，`substr(20160101,
    1, 6)`将得到`201601`：
- en: '[PRE39]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This time, we will use the `ym` column for alignment instead of `date`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用`ym`列进行对齐而不是`date`：
- en: '[PRE40]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, the missing values are gone, and the quality scores of both products in
    each month are naturally presented.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，缺失值已经消失，每个月两个产品的质量分数自然呈现。
- en: 'Sometimes, we need to combine a number of columns into one that indicates the
    measure and another that stores the value. For example, the following code uses
    `reshape2::melt` to combine the two measures (`quality` and `durability`) of the
    original data into a column named `measure` and a column of the measured value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要将多个列组合成一个表示度量，另一个存储值的列。例如，以下代码使用 `reshape2::melt` 将原始数据的两个度量（`quality`
    和 `durability`）组合到一个名为 `measure` 的列和一个测量值列中：
- en: '[PRE41]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The variable names are now contained in the data, which can be directly used
    by some packages. For example, we can use `ggplot2` to plot data in such a format.
    The following code is an example of a scatter plot with facet grid of different
    combination of factors:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名现在包含在数据中，可以直接被一些包使用。例如，我们可以使用 `ggplot2` 来绘制这种格式的数据。以下代码是一个具有不同因素组合的面板网格散点图的示例：
- en: '[PRE42]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we can see a scatter plot grouped by product `id` and `measure` with `ym`
    as *x* values and `value` as *y* values:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以看到一个按产品 `id` 和 `measure` 分组的散点图，其中 `ym` 作为 *x* 值，`value` 作为 *y* 值：
- en: '![Reshaping data frames using reshape2](img/image_12_001.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用 reshape2 重新塑形数据框](img/image_12_001.jpg)'
- en: 'The plot can be easily manipulated because the grouping factor (`measure`)
    is contained as data rather than columns, which is easier to represent from the
    perspective of the `ggplot2` package:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分组因素（`measure`）包含在数据中而不是列中，因此绘图可以轻松操作，这从 `ggplot2` 包的角度来看更容易表示：
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This time, we will present the points of the two products in different colors:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将以不同的颜色展示两个产品的点：
- en: '![Reshaping data frames using reshape2](img/image_12_002.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![使用 reshape2 重新塑形数据框](img/image_12_002.jpg)'
- en: Using SQL to query data frames via the sqldf package
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 sqldf 包使用 SQL 查询数据框
- en: In the previous chapter, you learned how to compose SQL statements to query
    data from relational databases such as SQLite and MySQL. Is there a way to directly
    use SQL to query data frames in R as if these data frames are tables in relational
    databases? The `sqldf` package says yes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何编写 SQL 语句来查询诸如 SQLite 和 MySQL 这样的关系型数据库中的数据。有没有一种方法可以直接使用 SQL 来查询
    R 中的数据框，就像这些数据框是关系型数据库中的表一样？`sqldf` 包表示这是可能的。
- en: 'This package takes advantage of SQLite, thanks to its lightweight structure
    and easiness to embed into an R session. Run the following command to install
    this package if you don''t have it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包利用了 SQLite 的优势，得益于其轻量级结构和易于嵌入 R 会话的特性。如果你还没有这个包，请运行以下命令来安装它：
- en: '[PRE44]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'First, let''s attach the package, as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们按照以下代码所示附加该包：
- en: '[PRE45]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that when we attach `sqldf`, a number of other packages are automatically
    loaded. The `sqldf` package depends on these packages, because what it does is
    basically transferring data and converting data types between R and SQLite.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们附加 `sqldf` 时，会自动加载许多其他包。`sqldf` 包依赖于这些包，因为它基本上是在 R 和 SQLite 之间传输数据和转换数据类型。
- en: 'Then, we will reload the product tables we used in the previous sections:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将重新加载我们在前几节中使用的产品表：
- en: '[PRE46]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The magic of this package is that we can directly query the data frames in
    our working environment with SQL. For example, we can select all records of `product_info`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包的神奇之处在于我们可以直接使用 SQL 查询我们工作环境中的数据框。例如，我们可以选择 `product_info` 的所有记录：
- en: '[PRE47]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `sqldf` package supports simple select queries that are supported by SQLite.
    For example, we can select a certain set of columns:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqldf` 包支持 SQLite 支持的简单选择查询。例如，我们可以选择一组特定的列：'
- en: '[PRE48]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can filter records by a certain condition:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据特定条件过滤记录：
- en: '[PRE49]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can compute a new column and give it a name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算一个新的列并给它命名：
- en: '[PRE50]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can sort records by certain columns in given orders:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按给定顺序对记录进行排序：
- en: '[PRE51]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The package also supports querying multiple data frames such as `join`. In
    the following code, we will merge `product_info` and `product_stats` by `id`,
    just like what we did with `merge()` previously:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该包还支持查询多个数据框，如 `join`。在以下代码中，我们将通过 `id` 合并 `product_info` 和 `product_stats`，就像我们之前使用
    `merge()` 所做的那样：
- en: '[PRE52]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Moreover, it also supports nested query. In the following code, we will select
    all records in `product_info` that are made of wood:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还支持嵌套查询。在以下代码中，我们将选择所有由木材制成的 `product_info` 中的记录：
- en: '[PRE53]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Alternatively, we can use `join` with the same `where` condition to achieve
    the same goal. For many relational databases, `join` usually works faster than `in`
    when the data is large:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用具有相同 `where` 条件的 `join` 来达到相同的目的。对于许多关系型数据库，当数据量大时，`join` 通常比 `in`
    更快：
- en: '[PRE54]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In addition to `join`, we can easily summarize data by group. For example,
    we group `product_tests` by `waterproof` into two groups: `yes` and `no`. For
    each group, we compute the average values of `quality` and `durability`, respectively:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`join`之外，我们还可以轻松地按组汇总数据。例如，我们将`product_tests`按`waterproof`分组为两组：`yes`和`no`。对于每个组，我们分别计算`quality`和`durability`的平均值：
- en: '[PRE55]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For the `toy_tests` data, it is easy to aggregate data for each product. Here
    is an example of averaging `quality` and `durability` values across time for each
    product:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`toy_tests`数据，按每个产品汇总数据很容易。以下是一个示例，展示如何计算每个产品随时间变化的`quality`和`durability`值的平均值：
- en: '[PRE56]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To make the results more informative, we can join `product_info` with the grouped
    summary table so that the product information and average measures are presented
    together:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使结果更加信息丰富，我们可以将`product_info`与分组汇总表连接起来，这样就可以一起展示产品信息和平均度量：
- en: '[PRE57]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using `sqldf` and SQL to query data frames looks very handy, but the limitations
    are obvious too.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sqldf`和SQL查询数据框看起来非常方便，但局限性也很明显。
- en: First, since `sqldf` is, by default, based on SQLite, the limitation of the
    package is also the limitation of SQLite database, that is, the built-in group
    aggregate functions are limited. The official webpage ([https://sqlite.org/lang_aggfunc.html](https://sqlite.org/lang_aggfunc.html))
    provides a list of functions: `avg()`, `count()`, `group_concat()`, `max()`, `min()`, `sum()`,
    and `total()`. If we need more than that, for example, `quantile()`, it won't
    be easy. In R, we can use much more advanced algorithms to aggregate columns.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于`sqldf`默认基于SQLite，该包的限制也是SQLite数据库的限制，即内置的分组聚合函数有限。官方网页([https://sqlite.org/lang_aggfunc.html](https://sqlite.org/lang_aggfunc.html))提供了一系列函数：`avg()`、`count()`、`group_concat()`、`max()`、`min()`、`sum()`和`total()`。如果我们需要更多，例如`quantile()`，那就不会很容易。在R中，我们可以使用更先进的算法来聚合列。
- en: Second, since we need to supply a string of select statements to query data,
    it is not very convenient to generate SQL dynamically when part of it is determined
    by R variables. Therefore, we need to use `sprintf()` to allow the values of R
    variables to appear in the SQL statement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，由于我们需要提供一个选择语句的字符串来查询数据，当其中一部分由R变量确定时，动态生成SQL并不方便。因此，我们需要使用`sprintf()`来允许R变量的值出现在SQL语句中。
- en: Third, the limitation of `sqldf` is also the limitation of SQL. It is hard to
    compute new columns with more complex algorithms. For example, if we need to compute
    a ranking column based on an existing numeric column, it would not be very easy
    to implement. However, in R, we just need `order()`. Another thing is that it
    is hard or verbose to implement more complex filter operations such as ranking-based
    data filtering. For example, how do you select the first one or two products ordered
    by `size` in descending order grouped by `material`? Such a query requires a lot
    more thinking and tricks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`sqldf`的限制也是SQL的限制。使用更复杂的算法计算新列比较困难。例如，如果我们需要根据现有的数值列计算排名列，那么实现起来可能不会很容易。然而，在R中，我们只需要`order()`。另一件事是，实现更复杂的过滤操作，如基于排名的数据过滤，可能很困难或很冗长。例如，如何根据`material`分组按`size`降序选择前一个或两个产品？这样的查询需要更多的思考和技巧。
- en: 'However, if we use the `plyr` package, such a task is a piece of cake. If you
    have the package installed, run the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用`plyr`包，这样的任务就变得轻而易举。如果您已经安装了该包，请运行以下代码：
- en: '[PRE58]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To demonstrate how simple it is, we will use `plyr::ddply` to do this. We will
    supply `material` as the data splitter, that is, `product_stats` is divided into
    several parts for each value taken by `material`. We also supply a function to
    transform the input data frame (each part) to a new data frame. Then, the `ddply`
    function combines these data frames together:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示其简单性，我们将使用`plyr::ddply`来完成这个任务。我们将`material`作为数据拆分器，也就是说，`product_stats`根据`material`的每个值被分成几个部分。我们还提供了一个函数来将输入数据框（每个部分）转换为新的数据框。然后，`ddply`函数将这些数据框组合在一起：
- en: '[PRE59]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The anonymous function we supplied is called with three parts of `product_stats`
    with distinct `material`, each part having identical `material`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的匿名函数使用三个不同的`product_stats`部分调用，每个部分具有不同的`material`，每个部分都有相同的`material`。
- en: 'Another example is to select top two test results with the most samples:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是选择具有最多样本的前两个测试结果：
- en: '[PRE60]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The anonymous function we supplied is called with two parts of `toy_tests`:
    one part is a data frame with `id` being `T01` and the other `T02`. For each part,
    we order the sub-dataframe by `sample` in the descending order and take the top
    two records. The task is easily finished.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的匿名函数使用 `toy_tests` 的两部分调用：一部分是 `id` 为 `T01` 的数据框，另一部分是 `T02`。对于每一部分，我们按
    `sample` 降序对子数据框进行排序，并取前两条记录。任务很容易完成。
- en: In addition, `ddply`, `plyr` provides a variety of functions of many possible
    pairs of input-output data types. To learn more, visit [http://had.co.nz/plyr/](http://had.co.nz/plyr/)
    and [https://github.com/hadley/plyr](https://github.com/hadley/plyr).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ddply`、`plyr` 提供了多种输入-输出数据类型对的功能。要了解更多信息，请访问 [http://had.co.nz/plyr/](http://had.co.nz/plyr/)
    和 [https://github.com/hadley/plyr](https://github.com/hadley/plyr)。
- en: Using data.table to manipulate data
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `data.table` 操作数据
- en: In the first section, we reviewed some built-in functions used to manipulate
    data frames. Then, we introduced `sqldf`, which makes simple data query and summary
    easier. However, both approaches have their limitations. Using built-in functions
    can be verbose and slow, and it is not easy to summarize data because SQL is not
    as powerful as the full spectrum of R functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们回顾了一些用于操作数据框的内置函数。然后，我们介绍了 `sqldf`，它使简单的数据查询和汇总变得更容易。然而，这两种方法都有其局限性。使用内置函数可能会很冗长且速度较慢，而且由于
    SQL 不如 R 函数的全谱系强大，因此很难汇总数据。
- en: 'The `data.table` package provides a powerful enhanced version of `data.frame`.
    It is blazing fast and has the ability to handle large data that fits into memory.
    It invents a natural syntax of data manipulation using `[]`. Run the following
    command to install the package from CRAN if you don''t have it yet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 包提供了一种强大的增强版 `data.frame`。它速度极快，能够处理适合内存的大型数据。它通过使用 `[]` 创造了一种自然的数据操作语法。如果您还没有安装此包，请运行以下命令从
    CRAN 安装：'
- en: '[PRE61]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the package is successfully installed, we will load the package and see
    what it offers:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功安装了包，我们将加载包并查看它提供了什么：
- en: '[PRE62]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we previously loaded the `reshape2` package in which `dcast` and `melt`
    are defined. The `data.table` package also provides enhanced version of `dcast`
    and `melt` with more powerful functionality, better performance, and higher memory
    efficiency. We'll take a look at them later in this section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们之前加载了 `reshape2` 包，其中定义了 `dcast` 和 `melt`。`data.table` 包也提供了 `dcast` 和
    `melt` 的增强版本，具有更强大的功能、更好的性能和更高的内存效率。我们将在本节稍后查看它们。
- en: 'Creating `data.table` is very much like creating `data.frame`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `data.table` 与创建 `data.frame` 非常相似：
- en: '[PRE63]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can see its structure with `str()`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `str()` 来查看其结构：
- en: '[PRE64]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It is clear that `dt` is of class `data.table` and `data.frame`, which means
    that `data.table` inherits from `data.frame`. In other words, it inherits some
    behaviors of `data.frame`, but override others as enhancements.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`dt` 是 `data.table` 和 `data.frame` 类，这意味着 `data.table` 继承自 `data.frame`。换句话说，它继承了
    `data.frame` 的一些行为，但作为增强也覆盖了其他行为。
- en: 'First, we still load the product data. However, this time, we will use `fread()`
    provided by `data.table` package. The `fread()` function is super-fast, has great
    memory efficiency, and directly returns `data.table`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们仍然加载产品数据。然而，这次我们将使用 `data.table` 包提供的 `fread()`。`fread()` 函数非常快，内存效率高，并直接返回
    `data.table`：
- en: '[PRE65]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If we take a look at `product_info`, its appearance is only slightly different
    from that of a data frame:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `product_info`，它的外观与数据框的略有不同：
- en: '[PRE66]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Again, we will look at its structure:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将查看其结构：
- en: '[PRE67]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As compared to `data.frame`, if we supply only one argument to subset `data.table`,
    it means selecting rows rather than columns:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `data.frame` 相比，如果我们只为 `data.table` 的子集提供单个参数，这意味着选择行而不是列：
- en: '[PRE68]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If the number we supply in `[]` is negative, it means excluding the record,
    which is fully consistent with subsetting a vector:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `[]` 中提供的数字是负数，这意味着排除记录，这与子集向量的操作完全一致：
- en: '[PRE69]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In addition, `data.table` also provides a number of symbols that represent
    important components of `data.table`. One of the most useful symbols is `.N`,
    which means the number of rows. If we want to select the last row, we no longer
    need `nrow(product_info)`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`data.table` 还提供了一些表示 `data.table` 重要组件的符号。其中最有用的符号之一是 `.N`，它表示行数。如果我们想选择最后一行，我们不再需要
    `nrow(product_info)`：
- en: '[PRE70]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can easily select the first and last rows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地选择第一行和最后一行：
- en: '[PRE71]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The syntax of `data.table` subsetting automatically evaluates the expressions
    in the context of the data, that is, we can directly use column names as symbols,
    just like how we use `subset`, `transform`, and `with`. For example, we can directly
    use `released` in the first argument to select rows of products that are released:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 子集的语法会自动评估数据上下文中的表达式，即我们可以直接使用列名作为符号，就像我们使用 `subset`、`transform`
    和 `with` 一样。例如，我们可以直接使用 `released` 作为第一个参数来选择已发布产品的行：'
- en: '[PRE72]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The first argument in the square brackets is a row filter, while the second
    is evaluated within the context of the filtered data. For example, we can directly
    use `id` to represent `product_info$id` because `id` is evaluated within the context
    of `product_info`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的第一个参数是一个行过滤器，而第二个参数在过滤数据的上下文中进行评估。例如，我们可以直接使用 `id` 来代表 `product_info$id`，因为
    `id` 在 `product_info` 的上下文中进行评估：
- en: '[PRE73]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The way to select columns of a data frame does not work here. If we put a character
    vector in the second argument, then we''ll get the character vector itself because
    a string is indeed a string:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数据框列的方法在这里不适用。如果我们把一个字符向量放在第二个参数中，那么我们会得到一个字符向量本身，因为字符串确实是一个字符串：
- en: '[PRE74]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To disable this behavior, we can specify `with = FALSE` so that the second
    argument accepts a character vector to select columns, and it always returns a `data.table`,
    no matter how many columns are specified:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用此行为，我们可以指定 `with = FALSE`，这样第二个参数接受一个字符向量来选择列，并且无论指定多少列，它总是返回一个 `data.table`：
- en: '[PRE75]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can also write some other expressions as the second argument. For example,
    we can generate a table of the number of released products for each combination
    of `type` and `class`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将一些其他表达式作为第二个参数。例如，我们可以生成一个按 `type` 和 `class` 的组合生成的发布产品数量的表格：
- en: '[PRE76]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'However, if a list is produced, it will be transformed to `data.table` instead:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果生成了一个列表，它将被转换为 `data.table`：
- en: '[PRE77]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In this way, we can easily create a new `data.table` package with existing
    columns replaced:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以轻松地创建一个新的 `data.table` 包，并用现有列替换：
- en: '[PRE78]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can also easily create a new `data.table` package with new columns based
    on existing columns:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以轻松地基于现有列创建一个新的 `data.table` 包，并添加新列：
- en: '[PRE79]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For simplicity, `data.table` provides `.()` to be short for `list()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，`data.table` 提供了 `.()` 来代表 `list()`：
- en: '[PRE80]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'By supplying the ordered indices, we can easily sort the records by the given
    criterion:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供有序索引，我们可以轻松地按给定标准对记录进行排序：
- en: '[PRE81]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Previously, we always created a new `data.table` package after subsetting.
    The `data.table` package also provides `:=` for in-place assignment of columns.
    For example, the original data of `product_stats` is shown as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们总是在子集化后创建一个新的 `data.table` 包。`data.table` 包还提供了 `:=` 用于列的就地赋值。例如，`product_stats`
    的原始数据如下所示：
- en: '[PRE82]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We will use `:=` to create a new column directly in `product_stats`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `:=` 在 `product_stats` 中直接创建一个新列：
- en: '[PRE83]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Nothing shows here, but the original `data.table` package is modified:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显示任何内容，但原始的 `data.table` 包已被修改：
- en: '[PRE84]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can use `:=` to replace an existing column:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `:=` 来替换现有列：
- en: '[PRE85]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `data.table` package provides `:=` mainly because in-place modification
    has a much higher performance since it avoids unnecessary copies of data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 包提供 `:=` 主要是因为就地修改具有更高的性能，因为它避免了数据的不必要复制。'
- en: Using key to access rows
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用键访问行
- en: 'Another distinct feature of `data.table` is the support of indexing, that is,
    we can create a key on `data.table`, so accessing records by key can be extremely
    efficient. For example, we will use `setkey()` to make `id` the key of `product_info`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 的另一个独特特性是支持索引，即我们可以在 `data.table` 上创建键，因此通过键访问记录可以非常高效。例如，我们将使用
    `setkey()` 将 `id` 设置为 `product_info` 的键：'
- en: '[PRE86]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Note that the function behaves in a very different way from most R functions.
    It does not return a new copy of the data table but directly installs a key to
    the original input. The data frame, however, looks unchanged:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数的行为与大多数 R 函数非常不同。它不会返回数据表的新副本，而是直接在原始输入上安装一个键。然而，数据框看起来没有变化：
- en: '[PRE87]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Also, its key is created:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它的键也被创建：
- en: '[PRE88]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we can use a key to access the records in `product_info`. For example,
    we can directly write a value of `id` to get the records with that `id`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用键来访问 `product_info` 中的记录。例如，我们可以直接写入一个 `id` 的值来获取具有该 `id` 的记录：
- en: '[PRE89]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If we use this with a `data.table` package without a key, an error occurs and
    reminds you to set a key:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在没有键的 `data.table` 包上使用此操作，将发生错误并提示您设置键：
- en: '[PRE90]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can also use `setkeyv()` to set key, but it only accepts a character vector:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `setkeyv()` 来设置键，但它只接受字符向量：
- en: '[PRE91]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This function is much easier to use if we have a dynamically determined vector
    to be the key. Now, we can use key to access `product_stats` too:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个动态确定的向量作为键，这个函数将更容易使用。现在，我们可以使用键来访问 `product_stats`：
- en: '[PRE92]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If two tables have the same key, we can easily join them together:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个表有相同的键，我们可以轻松地将它们连接起来：
- en: '[PRE93]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The key of a `data.table` package can be more than one element. For example,
    to locate a record of `toy_tests`, we need to specify both `id` and `date`. In
    the following code, we will set a key of the two columns on `toy_tests`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 包的键可以包含多个元素。例如，为了定位 `toy_tests` 的记录，我们需要指定 `id` 和 `date`。在下面的代码中，我们将为
    `toy_tests` 设置两个列的键：'
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we can get a row by supplying both elements in the key:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过提供键中的两个元素来获取一行：
- en: '[PRE95]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If we only supply the first element, we would get a subset of the data with
    all records that match the first element:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只提供第一个元素，我们将得到一个数据子集，其中包含所有与第一个元素匹配的记录：
- en: '[PRE96]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'However, if we only supply the second element, we can''t get anything but an
    error. It is because the algorithm it behind requires the key to be ordered:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只提供第二个元素，我们除了错误之外什么也得不到。这是因为背后的算法要求键是有序的：
- en: '[PRE97]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Also, we cannot get any data if we supply a key in a wrong order:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们提供一个错误的键顺序，我们无法获取任何数据：
- en: '[PRE98]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Summarizing data by groups
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按组汇总数据
- en: 'Another important argument of subsetting a `data.table` is `by`, which is used
    to split the data into multiple parts, and for each part, evaluate the second
    argument. In this section, we''ll demonstrate how the `by` syntax makes it much
    easier to summarize data by groups. For example, the simplest usage of `by` is
    counting the records in each group. In the following code, we will count the number
    of both released and unreleased products:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 子集化 `data.table` 的另一个重要参数是 `by`，它用于将数据分割成多个部分，并对每个部分评估第二个参数。在本节中，我们将演示 `by`
    语法如何使按组汇总数据变得更加容易。例如，`by` 的最简单用法是计算每个组中的记录数。在下面的代码中，我们将计算已发布和未发布产品的数量：
- en: '[PRE99]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The group can be defined by more than one variable. For example, a tuple of
    `type` and `class` can be a group, and for each group, we will count the number
    of records:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 组可以由多个变量定义。例如，`type` 和 `class` 的元组可以是一个组，并且对于每个组，我们将计算记录数：
- en: '[PRE100]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can also perform statistical calculations for each group. Here, we will
    compute the mean value of quality for both waterproof products and non-waterproof
    ones:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为每个组执行统计计算。在这里，我们将计算防水产品和非防水产品的质量平均值：
- en: '[PRE101]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Note that the mean values are stored in `V1` because we didn''t supply a name
    for the column, so the package uses its default column names. To avoid that, we
    will use expression in form of `.(y = f(x))` instead:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，平均值存储在 `V1` 中，因为我们没有为该列提供名称，因此包使用了其默认列名。为了避免这种情况，我们将使用形式为 `.(y = f(x))` 的表达式：
- en: '[PRE102]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We can chain multiple `[]` in turn. In the following example, we will first
    join `product_info` and `product_tests` by shared key `id` and then calculate
    the mean values of `quality` and `durability` for each group of `type` and `class`
    of released products:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依次链式使用多个 `[]`。在以下示例中，我们将首先通过共享键 `id` 将 `product_info` 和 `product_tests`
    连接起来，然后计算已发布产品中 `type` 和 `class` 每个组的 `quality` 和 `durability` 的平均值：
- en: '[PRE103]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Note that the values of `by` columns will be unique in the resulting `data.table`.
    We can use `keyby` instead of `by` to ensure it is automatically used as key by
    the resulted `data.table`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`by` 列的值在结果 `data.table` 中将是唯一的。我们可以使用 `keyby` 代替 `by` 来确保它自动用作结果 `data.table`
    的键：
- en: '[PRE104]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, we can directly use a tuple of key values to access the records:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以直接使用键值的元组来访问记录：
- en: '[PRE105]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: You can clearly see that using keys can be much more convenient than using logical
    comparisons when we try to find certain records in a table. However, its true
    advantage is not demonstrated yet because the data is not large enough. Using
    key to search records can be much faster than iterative logical comparison for
    large data, because searching by key takes advantage of binary search while iteration
    wastes a lot of time doing unnecessary computation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清楚地看到，当我们试图在表中查找特定记录时，使用键比使用逻辑比较要方便得多。然而，它的真正优势尚未体现，因为数据量不够大。对于大量数据，使用键搜索记录可以比迭代逻辑比较快得多，因为键搜索利用了二分搜索，而迭代则浪费了大量时间进行不必要的计算。
- en: 'Here is an example to make a contrast. First, we will create a data of 10 million
    rows with an index column `id` and two numeric columns filled with random numbers:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来做一个对比。首先，我们将创建一个包含1000万行、索引列`id`和两个填充随机数的数值列的数据：
- en: '[PRE106]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, we want to see find a row of `id` being `8765432`. Let''s see how long
    it takes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想找到`id`为`8765432`的行。让我们看看这需要多长时间：
- en: '[PRE107]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: It seems no big deal, but suppose you need to frequently do this, say, hundreds
    of times per second, then your machine simply can't return a result in time.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎没什么大不了的，但假设你需要频繁地这样做，比如说每秒几百次，那么你的机器就无法及时返回结果。
- en: 'Then, we will use `data.table` to do this. First, we will call `setDT()` to
    transform  `data.frame` to `data.table`. This function performs some magic to
    transform the object in place, no copy made. When we use the `setDT()` function,
    we also provide a key `id` so that the resulted `data.table` has `id` as its keyed
    column:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`data.table`来完成这个任务。首先，我们将调用`setDT()`将`data.frame`转换为`data.table`。这个函数会对对象进行一些魔法般的转换，就地转换，不创建副本。当我们使用`setDT()`函数时，我们还提供了一个键`id`，以便结果`data.table`以`id`作为其键列：
- en: '[PRE108]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now, `test1` is transformed to `data.table`. Then, we will search the same
    element:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`test1`已转换为`data.table`。然后，我们将搜索相同的元素：
- en: '[PRE109]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The results are the same, but the time `data.table` takes is much shorter than `data.frame`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相同，但`data.table`所需的时间比`data.frame`短得多。
- en: Reshaping data.table
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重塑data.table
- en: Previously, you learned how to reshape a data frame with the `reshape2` package.
    The `data.table` package provides faster and more powerful implementations of `dcast`
    and `melt` for the `data.table` object.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你学习了如何使用`reshape2`包重塑数据框。`data.table`包为`data.table`对象提供了更快、更强大的`dcast`和`melt`实现。
- en: 'For example, we will reshape `toy_tests` by aligning the quality scores of
    each product to year-month tuples:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将通过将每个产品的质量分数与年月元组对齐来重塑`toy_tests`。
- en: '[PRE110]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: First, we used `:=` to create a new column `ym` directly in `toy_tests` and
    use `dcast` to transform it in the same way with the previous example of `reshape2`. The
    result looks the same with the output of `reshape2::dcast` for `data.frame`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`toy_tests`中直接使用`:=`创建了一个新的列`ym`，并使用`dcast`以与之前`reshape2`的示例相同的方式进行转换。结果看起来与`reshape2::dcast`对`data.frame`的输出相同。
- en: 'While `reshape2::dcast` does not support multi-value `value.var`, `data.table::dcast`
    works with multiple value variables, as shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`reshape2::dcast`不支持多值`value.var`，但`data.table::dcast`可以处理多个值变量，如下所示：
- en: '[PRE111]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The column names, except the first, are no longer values of `id` but are value
    variables with values of `id` concatenated by the underscore symbol. In addition,
    the key of the output `data.table` is automatically set to the variables that
    appear on the left-hand side of the reshaping formula  `ym ~ id`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个之外，列名不再是`id`的值，而是由下划线符号连接的`id`值变量。此外，输出`data.table`的键自动设置为重塑公式`ym ~ id`左侧出现的变量：
- en: '[PRE112]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The key implies that we can access the records directly by supplying a value
    of `ym`. However, the following code ends up with an error:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 键意味着我们可以通过提供一个`ym`的值直接访问记录。然而，以下代码最终导致错误：
- en: '[PRE113]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'There''s something wrong with the data types. We can run the following code
    to see the class of each column:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型存在问题。我们可以运行以下代码来查看每列的数据类型：
- en: '[PRE114]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The problem lies in the class of `ym:`. It is a character vector, but we supplied
    a key of numeric values. Therefore, the search fails with unmatched data types.
    If we supply a string, we can get the corresponding record:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在`ym`的类上。它是一个字符向量，但我们提供了一个数值型键。因此，由于数据类型不匹配，搜索失败。如果我们提供一个字符串，我们就可以得到相应的记录：
- en: '[PRE115]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'But how did `ym` become a character vector in the first place? Recall `ym :=
    substr(date, 1, 6)` where `date` is an integer vector, but `substr()` will coerce `date`
    to a character vector and then take out the first six characters. Therefore, it
    is natural that the result is a character vector. This is simply demonstrated
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但`ym`最初是如何成为字符向量的？回想一下`ym := substr(date, 1, 6)`，其中`date`是一个整数向量，但`substr()`会将`date`强制转换为字符向量，然后取出前六个字符。因此，结果是字符向量是自然的。这简单地如下所示：
- en: '[PRE116]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The point here is that we need to be careful about the data types of the key
    columns.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，我们需要注意关键列的数据类型。
- en: Using in-place set functions
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用就地设置函数
- en: If we use `data.frame`, to change the names or the column order will cause copies
    of the data structure. In recent R versions, the copy is made fewer when we rename
    columns, but it is still hard to reorder the columns of a data frame without making
    a new copy. This should not be a problem when the data is small, but if the data
    is very large, the performance and memory pressure it imposes can really be an
    issue.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `data.frame`，更改名称或列顺序将导致数据结构副本。在最近的 R 版本中，当我们重命名列时，复制的次数较少，但仍然很难在不创建新副本的情况下重新排序数据框的列。当数据量较小时，这通常不会成为问题，但如果数据量非常大，它施加的性能和内存压力可能真的成为一个问题。
- en: An enhanced version of `data.frame`, `data.table` provides a family of `set`
    functions with reference semantics, that is, they modify `data.table` in place
    and avoid unnecessary copying, thus exhibiting astonishing performance.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 是 `data.frame` 的增强版本，提供了一组具有引用语义的 `set` 函数，即它们就地修改 `data.table`
    并避免不必要的复制，从而展现出惊人的性能。'
- en: 'Take `product_stats` as an example. We can call `setDF()` to change `data.table`
    to `data.frame` in place without making copies:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `product_stats` 为例。我们可以调用 `setDF()` 在不创建副本的情况下就地将 `data.table` 转换为 `data.frame`：
- en: '[PRE117]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We can call `setDT()` to make any `data.frame` to `data.table` and set up a
    key if specified:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `setDT()` 将任何 `data.frame` 转换为 `data.table`，并如果指定的话设置一个键：
- en: '[PRE118]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We can call `setnames` to change the name of the given columns to their new
    names:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `setnames` 来更改指定列的名称为其新名称：
- en: '[PRE119]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'If we add a new column, the column should appear as the last one. For example,
    we will add an index column for all rows using `.I` representing `1:.N`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一个新列，该列应作为最后一列出现。例如，我们将使用代表 `1:.N` 的 `.I` 为所有行添加一个索引列：
- en: '[PRE120]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'By convention, the index column should, in most cases, appear as the first
    column. We can supply a new order of column names to `setcolorder()` so that the
    columns are directly reordered without making copies:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，索引列在大多数情况下应作为第一列出现。我们可以向 `setcolorder()` 提供新的列名顺序，以便直接重新排序列而不创建副本：
- en: '[PRE121]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Understanding dynamic scoping of data.table
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 data.table 的动态作用域
- en: The most commonly used syntax of `data.table` is `data[i, j, by]`, where `i`, `j`,
    and `by` are all evaluated with dynamic scoping. In other words, we can use not
    only the columns directly, but also the predefined symbols such as `.N`, `.I`,
    and `.SD` to refer to important components of the data, as well as symbols and
    functions that can be accessed in the calling environment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table` 最常用的语法是 `data[i, j, by]`，其中 `i`、`j` 和 `by` 都使用动态作用域进行评估。换句话说，我们不仅可以直接使用列，还可以使用预定义的符号，如
    `.N`、`.I` 和 `.SD` 来引用数据的重要组件，以及可以在调用环境中访问的符号和函数。'
- en: 'Before demonstrating this, we will create a new `data.table` named `market_data`
    with a consecutive column of `date`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示这一点之前，我们将创建一个新的名为 `market_data` 的 `data.table`，其中包含连续的 `date` 列：
- en: '[PRE122]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Then, we will add two new columns to `market_data` by calling `:=` as a function:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过调用 `:=` 作为函数来向 `market_data` 添加两个新列：
- en: '[PRE123]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Note that `price` is a simple random walk, and `volume` is randomly drawn from
    a binomial distribution:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`price` 是一个简单的随机游走，而 `volume` 是从二项分布中随机抽取的：
- en: '[PRE124]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Then, we will plot the data:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将绘制数据：
- en: '[PRE125]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The plot generated is shown as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下所示：
- en: '![Understanding dynamic scoping of data.table](img/image_12_003.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![理解 data.table 的动态作用域](img/image_12_003.jpg)'
- en: Once the data is ready, we can aggregate the data and see how dynamic scoping
    can be used to make things easier.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据准备就绪，我们就可以汇总数据，看看动态作用域如何被用来使事情变得更简单。
- en: 'First, we will look at the range of the `date` column:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看 `date` 列的范围：
- en: '[PRE126]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The data can be reduced to monthly **open-high-low-close** (**OHLC**) data
    easily by group aggregate:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分组聚合，数据可以轻松地减少到每月的 **开盘价-最高价-最低价-收盘价**（**OHLC**）数据：
- en: '[PRE127]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In the `j` expression, we can generate an OHLC record with each `data.table`
    grouped by `year` and `month`. If the output of `j` is a `list`, or `data.frame`,
    or `data.table`, then the output will be stacked together to result in one `data.table`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `j` 表达式中，我们可以通过按 `year` 和 `month` 分组每个 `data.table` 来生成一个 OHLC 记录。如果 `j` 的输出是
    `list`、`data.frame` 或 `data.table`，则输出将堆叠在一起，最终形成一个 `data.table`。
- en: 'In fact, the `j` expression can be anything, even with `by` specified. More
    specifically, `j` is evaluated within the context of each `data.table` as a subset
    of the original data split by the value of the `by` expression. For example, the
    following code does not aggregate data by group, but plot a price chart for each
    year:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`j` 表达式可以是任何内容，甚至当指定了 `by` 时也是如此。更具体地说，`j` 在每个 `data.table` 的上下文中被评估，作为原始数据的一个子集，该子集由
    `by` 表达式的值分割。例如，以下代码不是按组聚合数据，而是为每年的价格绘制图表：
- en: '[PRE128]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The plot generated is shown as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下所示：
- en: '![Understanding dynamic scoping of data.table](img/image_12_004.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![理解data.table的动态作用域](img/image_12_004.jpg)'
- en: Note that we don't specify the `data` argument of `plot` because it is evaluated
    in the context of `market_data` grouped by `year` where `price` and `date` are
    already defined.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有指定 `plot` 的 `data` 参数，因为它在按 `year` 分组的 `market_data` 上下文中进行评估，其中 `price`
    和 `date` 已经定义。
- en: 'Moreover, the `j` expression can be model-fitting code. Here is an example
    of batch fitting of linear models. First, we will load `diamonds` data from the `ggplot2`
    package:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`j` 表达式可以是模型拟合代码。以下是一个批量拟合线性模型的示例。首先，我们将从 `ggplot2` 包中加载 `diamonds` 数据：
- en: '[PRE129]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The data contains 53940 records of diamonds with 10 properties. Here, we will
    fit linear regression models on each group of `cut` to see how `carat` and `depth`
    may provide some information of `log(price)` in each group.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包含53940条钻石记录，具有10个属性。在这里，我们将对每个 `cut` 组拟合线性回归模型，以查看 `carat` 和 `depth` 如何为每个组提供
    `log(price)` 的信息。
- en: 'In the following code, the `j` expression involves fitting a linear model and
    coercing its coefficients into a list. Note that the `j` expression is evaluated
    for each value of the `keyby` expression. Since a list is returned, the estimated
    linear coefficients for each group will be stacked as one `data.table` is shown
    as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`j` 表达式涉及拟合线性模型并将其系数强制转换为列表。请注意，`j` 表达式为 `keyby` 表达式的每个值进行评估。由于返回了一个列表，因此每个组的估计线性系数将堆叠为一个
    `data.table`，如下所示：
- en: '[PRE130]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Dynamic scoping also allows us to combine the use of symbols that are predefined,
    inside or outside `data.table`. For example, we can define a function to calculate
    the annual average values of a user-defined column of `market_data`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 动态作用域还允许我们结合使用在 `data.table` 内部或外部预定义的符号。例如，我们可以定义一个函数来计算 `market_data` 中用户定义列的年度平均值：
- en: '[PRE131]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: In the preceding `j` expression, `.SD` means the grouped `data.table` for each
    value of `year`. We can use `.SD[[x]]` to extract the values of column `x`, just
    like extracting an element by name from a list.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `j` 表达式中，`.SD` 表示每个 `year` 值的分组 `data.table`。我们可以使用 `.SD[[x]]` 来提取列 `x`
    的值，就像从列表中按名称提取元素一样。
- en: 'Then, we can run the following code to calculate the average prices for each
    year:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行以下代码来计算每年平均价格：
- en: '[PRE132]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We will just change the argument to `volume` to calculate the average volumes
    for each year:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将参数更改为 `volume`，就可以计算每年的平均数量：
- en: '[PRE133]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Also, we can use a specially invented syntax to create a dynamic number of columns
    with dynamically determined names.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用特别发明的语法来创建具有动态数量的列，这些列的名称也是动态确定的。
- en: 'Suppose we add three new alternative price columns, each adds some random noise
    to the original `price` values. Instead of repeat calling `market_data[, price1
    := ...]` and `market_data[, price2 := ...]`, we can use `market_data[, (columns)
    := list(...)]` to set columns dynamically, where `columns` is a character vector
    of column names and `list(...)` is the values for each corresponding column in `columns`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们添加了三个新的替代价格列，每个列都向原始 `price` 值添加了一些随机噪声。我们不必重复调用 `market_data[, price1 :=
    ...]` 和 `market_data[, price2 := ...]`，而是可以使用 `market_data[, (columns) := list(...)]`
    来动态设置列，其中 `columns` 是列名的字符向量，`list(...)` 是 `columns` 中每个相应列的值：
- en: '[PRE134]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'On the other hand, if we get a table with many columns and we need to perform
    some computation on a subset of them, we can also use similar syntax to solve
    the problem. Imagine that the price-related columns may have missing values. We
    need to perform `zoo::na.locf()` on each price column. First, we will use regular
    expression to get all the price columns:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们得到一个具有许多列的表，并且我们需要对其中的一小部分进行一些计算，我们也可以使用类似的语法来解决问题。想象一下，价格相关的列可能存在缺失值。我们需要对每个价格列执行
    `zoo::na.locf()`。首先，我们将使用正则表达式获取所有价格列：
- en: '[PRE135]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then, we will use similar syntax but add an additional argument, `.SDcols =
    price_cols`, in order to limit the columns of `.SD` to be only the price columns
    we get. The following code calls `zoo::na.locf()` on each price column, and the
    old values of each column are replaced:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用类似的语法，但添加一个额外的参数`.SDcols = price_cols`，以限制`.SD`的列仅为我们获取的价格列。以下代码对每个价格列调用`zoo::na.locf()`，并替换每个列的旧值：
- en: '[PRE136]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In this section, we have demonstrated the usage of `data.table` and how it makes
    data manipulation much easier. To see the full feature list of `data.table`, visit
     [https://github.com/Rdatatable/data.table/wiki](https://github.com/Rdatatable/data.table/wiki).
    To quickly review the usage, go through the data table cheat sheet ([https://www.datacamp.com/community/tutorials/data-table-cheat-sheet](https://www.datacamp.com/community/tutorials/data-table-cheat-sheet)).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了`data.table`的使用方法以及它如何使数据处理变得更加容易。要查看`data.table`的完整功能列表，请访问[https://github.com/Rdatatable/data.table/wiki](https://github.com/Rdatatable/data.table/wiki)。要快速复习使用方法，请查看数据表速查表([https://www.datacamp.com/community/tutorials/data-table-cheat-sheet](https://www.datacamp.com/community/tutorials/data-table-cheat-sheet))。
- en: Using dplyr pipelines to manipulate data frames
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dplyr管道操作数据框
- en: Another popular package is `dplyr`, which invents a grammar of data manipulation.
    Instead of using the subset function (`[]`), `dplyr` defines a set of basic `erb`
    functions as the building blocks of data operations and imports a pipeline operator
    to chain these functions to perform complex multistep tasks.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的包是`dplyr`，它发明了一种数据处理语法。而不是使用子集函数（`[]`），`dplyr`定义了一组基本`erb`函数作为数据操作的基本构建块，并引入了一个管道操作符来将这些函数链接起来以执行复杂的多步骤任务。
- en: 'Run the following code to install `dplyr` from CRAN if you don''t have it yet:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装`dplyr`，请运行以下代码从CRAN安装：
- en: '[PRE137]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'First, we will reload the product tables again to reset all data to their original
    forms:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重新加载产品表以重置所有数据到其原始形式：
- en: '[PRE138]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Then, we will load the `dplyr` package:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将加载`dplyr`包：
- en: '[PRE139]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The following output indicates that `dplyr` generalizes a number of built-in
    functions, so they are masked after the package is attached.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出表明`dplyr`泛化了许多内置函数，因此在包附加后它们会被遮蔽。
- en: 'Now, we can start to play with the verb functions it provides. First, we will
    use `select` to select columns from the provided data frame by creating a new
    table with the given columns:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始使用它提供的动词函数进行操作。首先，我们将使用`select`通过创建一个包含给定列的新表来从提供的数据框中选择列：
- en: '[PRE140]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The printing of the preceding table is a bit different from the way both `data.frame`
    and `data.table` are printed. It not only shows the table itself, but also includes
    a header indicating the size of the data frame and the data types of each column.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个表的打印方式与`data.frame`和`data.table`的打印方式略有不同。它不仅显示了表本身，还包括一个标题，指示数据框的大小以及每列的数据类型。
- en: It is clear that `select()` uses non-standard evaluation that allows us to directly
    use column names of the given data frame as arguments. It works in a way similar
    to how `subset()`, `transform()`, and `with()` work.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`select()`使用非标准评估，允许我们直接使用给定数据框的列名作为参数。它的工作方式与`subset()`、`transform()`和`with()`类似。
- en: 'We can use `filter` to filter the data frame by logical condition, which is
    also evaluated in the context of the data frame:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`filter`通过逻辑条件过滤数据框，该条件也在数据框的上下文中进行评估：
- en: '[PRE141]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If we want to filter records with multiple conditions, we only need to write
    each condition as an argument of `filter()`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要根据多个条件过滤记录，我们只需要将每个条件作为`filter()`函数的参数：
- en: '[PRE142]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The `mutate` function is used to create a new data frame with new columns added
    or existing columns replaced, like `transform`, but also supports in-place assignment, `:=`,
    if the provided data is a `data.table`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutate`函数用于创建一个新的数据框，添加新列或替换现有列，类似于`transform`，但如果提供的数据是`data.table`，也支持就地赋值，`:=`：'
- en: '[PRE143]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The `arrange` function is used to create a new data frame sorted by one or
    more columns. The `desc()` function indicates the descending order:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrange`函数用于根据一个或多个列创建一个新的数据框，按顺序排列。`desc()`函数表示降序：'
- en: '[PRE144]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The `dplyr` function provides a rich set of join operations, including  `inner_join`, `left_join`, `right_join`, `full_join`, `semi_join`,
    and `anti_join`. If two tables to join have records that do not match, these join
    operations may behave very differently. For `product_info` and `product_tests`,
    the records match exactly, so `left_join` should return the same results as `merge`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 函数提供了一套丰富的连接操作，包括 `inner_join`、`left_join`、`right_join`、`full_join`、`semi_join`
    和 `anti_join`。如果两个要连接的表中有不匹配的记录，这些连接操作可能会有很大的不同。对于 `product_info` 和 `product_tests`，记录完全匹配，因此
    `left_join` 应该返回与 `merge` 相同的结果：'
- en: '[PRE145]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: To know more about the difference between those join operations, run `?dplyr::join`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这些连接操作之间的区别，请运行 `?dplyr::join`。
- en: 'To summarize the data by groups, we need to first create a grouped table by
    `group_by()`. Then, we will use `summarize()` to aggregate the data. For example,
    we will divide `product_info_tests` with `type` and `class`, and then for each
    type class group, we will calculate the average values of `quality` and `durability`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要按组总结数据，我们首先需要通过 `group_by()` 创建一个分组表。然后，我们将使用 `summarize()` 来聚合数据。例如，我们将按 `type`
    和 `class` 对 `product_info_tests` 进行划分，然后对于每个类型类别的组，我们将计算 `quality` 和 `durability`
    的平均值：
- en: '[PRE146]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: From the preceding code examples, you learned the verb functions `select()`, `filter()`, `mutate()`, `arrange()`, `group_by()`,
    and `summarize()`. Each of them is designed to do a small thing, but together
    they can perform comprehensive data operations when properly composed. Apart from
    these functions, `dplyr` imports the pipeline operator `%>%` from the `magrittr`
    package to compose functions into pipelines.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码示例中，你学习了动词函数 `select()`、`filter()`、`mutate()`、`arrange()`、`group_by()`
    和 `summarize()`。每个函数都设计来做一件小事情，但在一起，当适当组合时，它们可以执行全面的数据操作。除了这些函数之外，`dplyr` 从 `magrittr`
    包中导入了管道操作符 `%>%` 来将函数组合成管道。
- en: 'Suppose we have `product_info` and `product_tests`. We need to analyze the
    released product by computing the average values of quality and durability for
    each type class group, and present the summary data in descending order of the
    average quality. This can be done nicely with the `dplyr` verb functions composed
    by the pipeline operator:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个表 `product_info` 和 `product_tests`。我们需要通过计算每个类型类组的质量和耐用性的平均值来分析发布的产品，并以平均质量的降序展示汇总数据。这可以通过由管道操作符组成的
    `dplyr` 动词函数很好地完成：
- en: '[PRE147]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'But how does `%>%` work? The pipeline operator basically does only one thing:
    put the result on the left-hand side of the first argument of the function call
    on the right-hand side, that is, `x %>% f(...)` will be basically evaluated as `f(x,
    ...)`. Since `%>%` is a package-defined binary operator, it allows us to chain
    function calls to either avoid redundant intermediate values or decompose nested
    calls.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `%>%` 是如何工作的呢？管道操作符基本上只做一件事：将结果放在右侧函数调用第一个参数的左侧，即 `x %>% f(...)` 将基本上被评估为
    `f(x, ...)`。由于 `%>%` 是一个包定义的二进制操作符，它允许我们将函数调用链式连接，以避免冗余的中间值或分解嵌套调用。
- en: 'Suppose we need to transform `d0` to `d3` through three steps. In each step,
    we need to call a function with the previous result and an argument. If we manipulate
    data like this, there will be many intermediate results, and sometimes, it consumes
    a lot of memory when the data is large:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要通过三个步骤将 `d0` 转换为 `d3`。在每一步中，我们需要调用一个函数，该函数使用前一个结果和一个参数。如果我们这样处理数据，将会有很多中间结果，而且当数据量大时，有时会消耗大量的内存：
- en: '[PRE148]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'If we want to avoid intermediate results, we''ll have to write nested calls.
    This task does not look straightforward at all, especially when there are numerous
    arguments in each function call:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要避免中间结果，我们就必须编写嵌套调用。这项任务看起来一点也不直接，尤其是在每个函数调用中都有许多参数时：
- en: '[PRE149]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Using the pipeline operator, the workflow can be rearranged as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道操作符，工作流程可以重新排列如下：
- en: '[PRE150]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The code looks much cleaner and straightforward. The whole expression not only
    looks like a pipeline but also works like a pipeline. The `d0 %>% f1(arg1)` equation
    is evaluated as `f1(d0, arg1)`, which is sent to `f2(., arg2)`, which is sent
    to `f3(., arg3)`. The output of each step becomes the input of the next step.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来更简洁、更直接。整个表达式不仅看起来像管道，而且实际上也像管道一样工作。`d0 %>% f1(arg1)` 等式被评估为 `f1(d0, arg1)`，然后被发送到
    `f2(., arg2)`，再发送到 `f3(., arg3)`。每个步骤的输出成为下一个步骤的输入。
- en: 'Therefore, the pipeline operator not only works with `dplyr` functions, but
    also works with all other functions. Suppose we want to make a density plot of
    the diamond prices:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，管道操作符不仅与`dplyr`函数一起工作，还与其他所有函数一起工作。假设我们想要绘制钻石价格的密度图：
- en: '[PRE151]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The plot generated is shown as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下所示：
- en: '![Using dplyr pipelines to manipulate data frames](img/image_12_005.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![使用dplyr管道操作数据框](img/image_12_005.jpg)'
- en: 'Using the pipeline operator, we can rewrite code as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道操作符，我们可以将代码重写如下：
- en: '[PRE152]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Like `data.table`, `dplyr` also supplies `do()` to perform arbitrary operation
    on each group of data. For example, we can group `diamonds` by `cut`, and for
    each group, we can fit a linear model of `log(price) ~ carat`. Different from `data.table`,
    we need to specify the names of such operations so that the results can be stored
    as columns. Also, the expression in `do()` is not directly evaluated in the context
    of the grouped data. Instead, we need to use `.` to represent the data:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 与`data.table`类似，`dplyr`也提供了`do()`来对每组数据执行任意操作。例如，我们可以按`cut`对`diamonds`进行分组，并且对于每个组，我们可以拟合`log(price)
    ~ carat`的线性模型。与`data.table`不同，我们需要指定此类操作的名称，以便结果可以存储为列。此外，`do()`中的表达式不是在分组数据的上下文中直接评估的。相反，我们需要使用`.`来表示数据：
- en: '[PRE153]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Note that a new column `lmod` is created. It is not a typical data column of
    atomic vectors. Rather, it is a list of linear model objects, that is, the model
    for each value of `cut` is stored in the list-typed column `lmod`. We can access
    each model using an index:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，创建了一个新的列`lmod`。它不是一个典型的原子向量的数据列。相反，它是一个线性模型对象的列表，即每个`cut`值的模型存储在列表类型的列`lmod`中。我们可以使用索引访问每个模型：
- en: '[PRE154]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `do()` function can be very helpful to perform highly customized operations.
    For example, suppose we need to analyze `toy_tests` data by summarizing the quality
    and durability for each product. Consider what we should do if, we only need the
    top three test records with most samples, and the quality and durability of each
    product should be a weighted average of the measure and the sample.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`do()`函数在执行高度定制化的操作时非常有帮助。例如，假设我们需要通过总结每个产品的质量和耐用性来分析`toy_tests`数据。考虑一下，如果我们只需要具有最多样本的前三个测试记录，并且每个产品的质量和耐用性应该是测量值和样本的加权平均值，我们应该怎么做。'
- en: 'Using `dplyr` functions and pipeline, the preceding task can be easily done
    with the following code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dplyr`函数和管道，前面的任务可以很容易地用以下代码完成：
- en: '[PRE155]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Note that when the data is grouped, all subsequent operations are performed
    by group. To see the intermediate result, we will run the code before `do(head(.,
    3))`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当数据分组时，所有后续操作都是按组执行的。为了查看中间结果，我们将运行`do(head(., 3))`之前的代码：
- en: '[PRE156]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'We get all records sorted by `sample` in descending order. Then, `do(head(.,
    3))` will evaluate `head(., 3)` for each group where `.` represents the data in
    the group:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按`sample`降序排序获取所有记录。然后，`do(head(., 3))`将为每个组中的`head(., 3)`进行评估，其中`.`代表组中的数据：
- en: '[PRE157]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Now, we will get the top three records with most samples. It is handy to summarize
    the data as supposed.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将获取具有最多样本的前三个记录。将数据总结如下是方便的。
- en: The `dplyr` function defines a very intuitive grammar of data manipulation and
    provides high-performance verb functions that are designed for use in pipeline.
    To learn more, I recommend that you read the package vignettes ([https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html))
    and visit the interactive tutorial ([https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial](https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial))
    at DataCamp.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`函数定义了一种非常直观的数据操作语法，并提供了一组为在管道中使用而设计的性能动词函数。要了解更多信息，我建议您阅读该包的vignettes（[https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)）并访问DataCamp上的交互式教程（[https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial](https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial)）。'
- en: Using rlist to work with nested data structures
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用rlist处理嵌套数据结构
- en: In the previous chapter, you learned about both relational databases that store
    data in tables and non-relational databases that support nested data structures.
    In R, the most commonly used nested data structure is a list object. All previous
    sections focus on manipulating tabular data. In this section, let's play with
    the `rlist` package I developed, which is designed for manipulating non-tabular
    data.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了存储在表中的关系型数据库和非关系型数据库，后者支持嵌套数据结构。在 R 中，最常用的嵌套数据结构是列表对象。所有前面的部分都集中在操作表格数据上。在本节中，让我们玩一玩我开发的
    `rlist` 包，该包旨在操作非表格数据。
- en: 'The design of `rlist` is very similar to `dplyr`. It provides mapping, filtering,
    selecting, sorting, grouping, and aggregating functionality for list objects.
    Run the following code to install the `rlist` package from CRAN:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`rlist` 的设计非常类似于 `dplyr`。它为列表对象提供映射、过滤、选择、排序、分组和聚合功能。运行以下代码从 CRAN 安装 `rlist`
    包：'
- en: '[PRE158]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We have the non-tabular version of the product data stored in `data/products.json`.
    In this file, each product has a JSON representation as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将非表格版本的产品数据存储在 `data/products.json` 中。在这个文件中，每个产品都有一个如下的 JSON 表示：
- en: '[PRE159]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'All products are stored in an JSON array like `[ {...}, {...} ]`. Instead of
    storing data in different tables, we put everything relating to a product in one
    object. To work with data in this format, we can use `rlist` functions. First,
    let''s load the `rlist` package:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 所有产品都存储在一个 JSON 数组中，例如 `[ {...}, {...} ]`。我们不是将数据存储在不同的表中，而是将所有与产品相关的信息放在一个对象中。要处理这种格式的数据，我们可以使用
    `rlist` 函数。首先，让我们加载 `rlist` 包：
- en: '[PRE160]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'To load the data into R as a list, we can use `jsonlite::fromJSON()` or simply `list.load()`
    provided by `rlist`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据加载到 R 中作为列表，我们可以使用 `jsonlite::fromJSON()` 或简单地使用 `rlist` 提供的 `list.load()`：
- en: '[PRE161]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Now, `products` contains the information of all products. Each element of `products`
    represents a product with all related information.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`products` 包含了所有产品的信息。`products` 的每个元素代表一个包含所有相关信息的产品。
- en: 'To evaluate an expression within the context of each element, we can call `list.map()`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 要在元素上下文中评估表达式，我们可以调用 `list.map()`：
- en: '[PRE162]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'It iteratively evaluates `id` on each element of `products` and returns a new
    list containing all the corresponding results. The `list.mapv()` function simplifies
    the list and only returns a vector:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 它迭代地在 `products` 的每个元素上评估 `id` 并返回一个包含所有相应结果的新列表。`list.mapv()` 函数简化了列表并仅返回一个向量：
- en: '[PRE163]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'To filter `products`, we can call `list.filter()` with logical conditions.
    All elements of `products` for which the conditions yield `TRUE` will be picked
    out:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要过滤 `products`，我们可以使用带有逻辑条件的 `list.filter()`。对于 `products` 中条件返回 `TRUE` 的所有元素将被挑选出来：
- en: '[PRE164]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Note that `rlist` functions have design similar to `dplyr` functions, that
    is, the input data is always the first argument. We can, thus, use a pipeline
    operator to pipe the results forward:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`rlist` 函数的设计类似于 `dplyr` 函数，即输入数据总是第一个参数。因此，我们可以使用管道操作符将结果传递下去：
- en: '[PRE165]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'We can use `list.select()` to select the given fields of each element of the
    input list:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `list.select()` 来选择输入列表中每个元素的给定字段：
- en: '[PRE166]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Alternatively, we can make new fields in `list.select()` based on the existing
    fields:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在 `list.select()` 中根据现有字段创建新字段：
- en: '[PRE167]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'We can also sort the list elements by certain fields or values using `list.sort()`
    and stack all elements into a data frame using `list.stack()`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `list.sort()` 和 `list.stack()` 将列表元素按某些字段或值排序，并将所有元素堆叠到一个数据框中：
- en: '[PRE168]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'To group a list, we will call `list.group()` to make a nested list in which
    all elements are divided by the values of the field:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 要对列表进行分组，我们将调用 `list.group()` 来创建一个嵌套列表，其中所有元素都按字段的值进行划分：
- en: '[PRE169]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The `rlist` function also provides many other functions that try to make non-tabular
    data manipulation easier. For example, `list.table()` enhances `table()` to directly
    work with a list of elements:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`rlist` 函数还提供了许多其他函数，旨在使非表格数据操作更容易。例如，`list.table()` 增强 `table()` 以直接处理元素列表：'
- en: '[PRE170]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'It also supports multi-dimensional tables by evaluating each argument in the
    context of the input list:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持通过在输入列表的上下文中评估每个参数来评估多维表格：
- en: '[PRE171]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Although the storage of data is non-tabular, we can easily perform comprehensive
    data manipulation and get the results presented in the tabular form. For example,
    suppose we need to compute the mean score and number of scores of the top two
    products with the highest mean scores but also with at least five scores.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据存储不是表格形式，但我们仍然可以轻松地进行全面的数据操作，并将结果以表格形式呈现。例如，假设我们需要计算平均分数最高的前两个产品的平均分数和分数数量，但至少有五个分数。
- en: 'We can decompose such a task into smaller data manipulation subtasks, which
    can be easily done by `rlist` functions. Due to the number of steps involved in
    the data operations, we will use pipeline to organize the workflow:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这样的任务分解成更小的数据处理子任务，这可以通过 `rlist` 函数轻松完成。由于数据操作中涉及的步骤数量，我们将使用管道来组织工作流程：
- en: '[PRE172]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The code looks straightforward, and it is easy to predict or analyze what happens
    in each step. If the final result can be represented in the tabular form, we can
    call `list.stack()` to bind all list elements together into a data frame.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来很简单，可以很容易地预测或分析每一步会发生什么。如果最终结果可以用表格形式表示，我们就可以调用 `list.stack()` 来将所有列表元素绑定在一起形成一个数据框。
- en: To learn more about `rlist` functions, read the `rlist` tutorial ([https://renkun.me/rlist-tutorial/](https://renkun.me/rlist-tutorial/)).
    There are other packages that deal with nested data structures but may have different
    philosophy, such as purrr ([https://github.com/hadley/purrr](https://github.com/hadley/purrr)).
    If you are interested, visit and learn more on their websites.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `rlist` 函数的信息，请阅读 `rlist` 教程（[https://renkun.me/rlist-tutorial/](https://renkun.me/rlist-tutorial/)）。还有其他处理嵌套数据结构的包，但可能具有不同的哲学，例如
    purrr ([https://github.com/hadley/purrr](https://github.com/hadley/purrr))。如果您感兴趣，请访问并了解他们的网站。
- en: Summary
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a number of basic functions and various packages
    for data manipulation. Using built-in functions to manipulate data can be redundant.
    Several packages are tailored for filtering and aggregating data based on different
    techniques and philosophies. The `sqldf` packages use embedded SQLite databases
    so that we can directly write SQL statements to query data frame in our working
    environment. On the other hand, `data.table` provides an enhanced version of `data.frame`
    and a powerful syntax, and `dplyr` defines a grammar of data manipulation by providing
    a set of pipeline friendly verb functions. The `rlist` class provides a set of
    pipeline friendly functions for non-tabular data manipulation. No single package
    is best for all situations. Each of them represents a way of thinking, and which
    best fits a certain problem depends on how you understand the problem and your
    experience of working with data.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了大量的基本函数和用于数据操作的各种包。使用内置函数来操作数据可能是多余的。有几个包专门针对基于不同技术和哲学的数据过滤和聚合。`sqldf`
    包使用嵌入式 SQLite 数据库，这样我们就可以直接在我们的工作环境中编写 SQL 语句来查询数据框。另一方面，`data.table` 提供了 `data.frame`
    的增强版本和强大的语法，而 `dplyr` 通过提供一组管道友好的动词函数来定义数据操作语法。`rlist` 类提供了一组针对非表格数据操作的管道友好函数。没有哪个包适用于所有情况。每个包都代表了一种思维方式，最适合某个问题的方法取决于您如何理解问题以及您与数据工作的经验。
- en: Processing data and doing simulation require considerable computing power. However,
    from the beginning to today, performance is not the top priority for R. Although
    R is very powerful in interactive analysis, visualization, and reporting, its
    implementation is considered slow compared to some other popular scripting languages
    when it is used to process a large amount of data. In the next chapter, we'll
    introduce several techniques from performance measure and profiling to vectorization,
    MKL-powered R kernel, parallel computing, and Rcpp. These techniques will help
    you achieve high performance when you really need it.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理和模拟需要相当的计算能力。然而，从开始到今天，性能并不是 R 的首要任务。尽管 R 在交互式分析、可视化和报告方面非常强大，但与其他一些流行的脚本语言相比，当用于处理大量数据时，其实现被认为是较慢的。在下一章中，我们将介绍从性能度量到分析、向量化、MKL
    加速的 R 内核、并行计算和 Rcpp 等几种技术。这些技术将帮助您在真正需要时实现高性能。
