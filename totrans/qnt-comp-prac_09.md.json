["```py\ndef display_circuit(circuit,psi,unitary):\n    disp=True\n    if disp:\n        display(circuit.draw(output=\"mpl\"))\n        if psi:\n            get_psi(circuit,\"Q\")\n        if unitary:\n            print_unitary(circuit)\n```", "```py\n    from qiskit import QuantumCircuit\n    from ch9_grover_functions import display_circuit\n    ```", "```py\n    qc1 = QuantumCircuit(1)\n    display_circuit(qc1,True,False)\n    ```", "```py\n    qc1.h(0)\n    display_circuit(qc1,True,False)\n    ```", "```py\n    qc1.z(0)\n    ```", "```py\n    qc = QuantumCircuit(2)\n    qc.h([0,1])\n    qc.z(1)\n    qc.z(0)\n    ```", "```py\n    qc = QuantumCircuit(2)\n    qc.h([0,1])\n    qc.z(1)\n    qc.cx(0,1)\n    ```", "```py\n    Searching in a scrambled database with 4 entries:\n     ('00', '01', '10', '11')\n    Enter a two bit string for the two qubit state to search for, such as '10' ('Exit' to stop):\n    10\n    Number of searches to test:\n    20\n    ```", "```py\n    for m in range(searches):\n        database=random.sample(values,len(values))\n        result=simple_search(database, oracle)\n        average.append(result+1)\n        search.append(m+1)\n    ```", "```py\n    def simple_search(database, oracle):\n        for position, post in enumerate(database):\n            if post == oracle:\n                return position\n    ```", "```py\n    def plot_results(average,search,values):\n        import matplotlib.pyplot as plt\n        from statistics import mean \n        print(\"Average searches to find:\", mean(average))\n        # Plot the search data\n        plt.bar(search, average, align='center', alpha=0.5)\n        plt.ylabel('Searches')\n        plt.title(str(mean(average))+' average searches\\nto         find one item among '+str(len(values)))\n        plt.axhline(mean(average))\n        plt.show()\n    ```", "```py\ndef create_oracle(oracle_type,size):\n    from qiskit import QuantumCircuit, ClassicalRegister,        QuantumRegister\n    global qr, cr\n    qr = QuantumRegister(size)\n    cr = ClassicalRegister(size)\n    oracleCircuit=QuantumCircuit(qr,cr)\n    oracle_type_rev=oracle_type[::-1]\n    for n in range(size-1,-1,-1):\n        if oracle_type_rev[n] ==\"0\":\n            oracleCircuit.x(qr[n])\n    oracleCircuit.h(qr[size-1])\n    if size==2: \n        oracleCircuit.cx(qr[size-2],qr[size-1]);\n    if size==3:\n        oracleCircuit.ccx(qr[size-3],qr[size-2],qr[size-1])\n    if size==4:\n        oracleCircuit.mcx([qr[size-4],qr[size-3],\n            qr[size-2]],qr[size-1])\n    if size>=5:\n        oracleCircuit.mcx([qr[size-5],qr[size-4],\n            qr[size-3],qr[size-2]],qr[size-1])\n    oracleCircuit.h(qr[size-1])\n    for n in range(size-1,-1,-1):\n        if oracle_type_rev[n] ==\"0\":\n            oracleCircuit.x(qr[n])\n    return(oracleCircuit)\n```", "```py\ndef create_amplifier(size):\n    from qiskit import QuantumCircuit\n    # Let's create the amplifier circuit for two qubits.\n    amplifierCircuit=QuantumCircuit(qr,cr)\n    amplifierCircuit.barrier(qr)\n    amplifierCircuit.h(qr)\n    amplifierCircuit.x(qr)\n    amplifierCircuit.h(qr[size-1])\n    if size==2: \n        amplifierCircuit.cx(qr[size-2],qr[size-1]);\n    if size==3:\n        amplifierCircuit.ccx(qr[size-3],qr[size-2],qr[size-1])\n    if size==4:\n        amplifierCircuit.mcx([qr[size-4],qr[size-3],\n            qr[size-2]],qr[size-1])\n    if size>=5:\n        amplifierCircuit.mcx([qr[size-5],qr[size-4],\n            qr[size-3],qr[size-2]],qr[size-1])\n    amplifierCircuit.h(qr[size-1])\n    amplifierCircuit.barrier(qr)\n    amplifierCircuit.x(qr)\n    amplifierCircuit.h(qr)\n    return(amplifierCircuit)\n```", "```py\ndef create_grover(oracleCircuit,amplifierCircuit,showstep):\n    from qiskit import QuantumCircuit\n    from math import sqrt, pow, pi\n    groverCircuit = QuantumCircuit(qr,cr)\n    # Initiate the Grover with Hadamards\n    if showstep: display_circuit(groverCircuit,True,False)\n    groverCircuit.h(qr)\n    groverCircuit.barrier(qr)\n    if showstep: display_circuit(groverCircuit,True,False)\n    # Add the oracle and the inversion\n    for n in range(int(pi/4*(sqrt(pow(2,\n            oracleCircuit.num_qubits))))):\n        groverCircuit+=oracleCircuit\n        if showstep: display_circuit(groverCircuit,True,False)\n        groverCircuit+=amplifierCircuit\n        if showstep: display_circuit(groverCircuit,True,False)\n    # Add measurements\n    groverCircuit.measure(qr,cr)\n    return(groverCircuit)\n```", "```py\n    …\n    if size==2: \n            amplifierCircuit.cx(qr[size-2],qr[size-1]);\n    …\n    ```", "```py\n    def mitigated_results(backend,circuit,results,\n            results_sim):\n        # Import the required classes\n        from qiskit.providers.aer.noise import NoiseModel\n        from qiskit.ignis.mitigation.measurement import\n            (complete_meas_cal,CompleteMeasFitter)\n        # Get noise model for backend\n        noise_model = NoiseModel.from_backend(backend)\n        # Create the measurement fitter\n        qr = QuantumRegister(circuit.num_qubits)\n        meas_calibs, state_labels = complete_meas_cal(\n            qr=qr, circlabel='mcal')\n        job = execute(meas_calibs,\n            backend=Aer.get_backend('qasm_simulator'), \n            shots=8192, noise_model=noise_model)\n        cal_results = job.result()\n        meas_fitter = CompleteMeasFitter(cal_results, \n            state_labels, circlabel='mcal')\n        print(meas_fitter.cal_matrix)\n        # Get the filter object\n        meas_filter = meas_fitter.filter\n        # Results with mitigation\n        mitigated_results = meas_filter.apply(results)\n        mitigated_counts = mitigated_results.get_counts(0)\n        return(mitigated_counts)\n    ```", "```py\n    def transpile_circuit(circuit,backend):\n        from qiskit.compiler import transpile\n        trans_circ = transpile(circuit, backend)\n        display(trans_circ.draw(output=\"mpl\"))\n        print(\"Circuit data\\n\\nDepth: \",trans_circ.depth(),\"\\nWidth: \",trans_circ.width(),\"\\nSize: \",trans_circ.size())\n    ```", "```py\nDepth:  9 \nWidth:  7 \nSize:  15\n```", "```py\n    from qiskit import QuantumCircuit, Aer, execute\n    from IPython.core.display import display\n    from qiskit.tools.visualization import plot_histogram\n    ```", "```py\n    qc=QuantumCircuit(3,2)\n    qc.h([0,1])\n    qc.x(2)\n    ```", "```py\n    qc.barrier([0,1,2])\n    qc.x(0)\n    qc.barrier([0,1,2])\n    ```", "```py\n    qc.h(2)\n    qc.ccx(0,1,2)\n    qc.h(2)\n    ```", "```py\n    qc.barrier([0,1,2])\n    qc.x(0)\n    qc.barrier([0,1,2])\n    ```", "```py\n    qc.h([0,1])\n    qc.x([0,1])\n    qc.h(1)\n    qc.cx(0,1)\n    qc.h(1)\n    qc.barrier([0,1,2])\n    qc.x([0,1])\n    qc.h([0,1])\n    ```", "```py\n    qc.measure([0,1],[0,1])\n    ```", "```py\n    display(qc.draw('mpl'))\n    backend = Aer.get_backend('qasm_simulator')\n    job = execute(qc, backend, shots=1)\n    result = job.result()\n    counts = result.get_counts(qc)\n    display(plot_histogram(counts))\n    ```", "```py\n    Circuit data\n    Depth:  49 \n    Size:  76\n    ```", "```py\nquantum_circuit.mcx([control qubits], target qubit)\n```", "```py\n>> help(QuantumCircuit.mcx)\n```", "```py\nCircuit data\nDepth:  311 \nSize:  409\n```", "```py\nCircuit data\nDepth:  830 \nSize:  1024\n```", "```py\n    from ch9_grover_functions import *\n    oracle=create_oracle(\"01\",2)\n    amplifier=create_amplifier(2)\n    grover=create_grover(oracle,amplifier,False)\n    print(grover)\n    ```"]