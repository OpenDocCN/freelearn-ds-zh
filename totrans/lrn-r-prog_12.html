<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Data Manipulation</h1></div></div></div><p>In the previous chapter, you learned the methods used to access different types of databases such as relational databases (SQLite and MySQL) and non-relational databases (MongoDB and Redis). Relational databases usually return data in a tabular form, while non-relational databases may support nested data structures and other features.</p><p>Even though the data is loaded into memory, it is usually far from ready for data analysis. Most data at this stage still needs cleaning and transforming, which, in fact, may take a large proportion of time before any statistical model and visualization can be applied. In this chapter, you'll learn about a set of built-in functions and several packages for data manipulation. The packages are extremely powerful. However, to better work with these packages, we need a concrete understanding of the knowledge introduced in the previous chapters.</p><p>In this chapter, we'll cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using basic functions to manipulate data frames</li><li class="listitem" style="list-style-type: disc">Using SQL to query data frames via the <code class="literal">sqldf</code> package</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">data.table</code> to manipulate data</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">dplyr</code> pipelines to manipulate data frames</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">rlist</code> to work with nested data structures</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec61"/>Using built-in functions to manipulate data frames</h1></div></div></div><p>Previously, you learned the basics of data frames. Here, we will review the built-in functions used to filter a data frame. Although a data frame is essentially a list of vectors, we can access it like a matrix since all column vectors are of the same length. To select rows that meet certain conditions, we will supply a logical vector as the first argument of <code class="literal">[]</code>, while the second is left empty.</p><p>In R, these operations can be done with built-in functions. In this section, we will introduce some built-in functions that are most helpful to manipulate data into the form we need as model input or for presentation. Some of the functions or techniques are already presented in the previous chapters.</p><p>Most of the code in this section and subsequent sections are based on a group of fictitious data about some products. We will use the <code class="literal">readr</code> package to load the data for better handling of column types. If you don't have this package installed, run <code class="literal">install.packages("readr")</code>:</p><pre class="programlisting">library(readr) &#13;
product_info &lt;- read_csv("data/product-info.csv") &#13;
product_info &#13;
##    id      name  type   class released &#13;
## 1 T01    SupCar   toy vehicle      yes &#13;
## 2 T02  SupPlane   toy vehicle       no &#13;
## 3 M01     JeepX model vehicle      yes &#13;
## 4 M02 AircraftX model vehicle      yes &#13;
## 5 M03    Runner model  people      yes &#13;
## 6 M04    Dancer model  people       no &#13;
</pre><p>Once the data is loaded into memory as a data frame, we can take a look at its column types:</p><pre class="programlisting">sapply(product_info, class) &#13;
##          id        name        type       class    released  &#13;
## "character" "character" "character" "character" "character" &#13;
</pre><p>The <code class="literal">readr::read_csv</code> argument has different behavior from the built-in function <code class="literal">read.csv</code>. For example, it does not automatically convert string columns to factors (which can be problematic, but adds little value). Therefore, I recommend that you use functions provided by <code class="literal">readr</code> to read tabular data from file into R. If we were using the <code class="literal">read.csv</code> file, then all these columns would be factors with limited possible values.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec138"/>Using built-in functions to manipulate data frames</h2></div></div></div><p>Previously, you learned the basics of data frames. In this section, we will review the built-in functions to filter a data frame. Although a data frame is essentially a list of vectors, we can access it like a matrix since all column vectors are of the same length. To select rows that meet certain conditions, we will supply a logical vector as the first argument of <code class="literal">[]</code>, while the second is left empty. In the following examples, we will use a series of product information points and statistics we introduced earlier to demonstrate basic data-filtering methods and summary techniques.</p><p>For example, we will take out all rows of <code class="literal">toy</code> type:</p><pre class="programlisting">product_info[product_info$type == "toy", ] &#13;
##    id     name type   class released &#13;
## 1 T01   SupCar  toy vehicle      yes &#13;
## 2 T02 SupPlane  toy vehicle       no &#13;
</pre><p>Alternatively, we could take out all rows that are not released:</p><pre class="programlisting">product_info[product_info$released == "no", ] &#13;
##    id     name  type   class released &#13;
## 2 T02 SupPlane   toy vehicle       no &#13;
## 6 M04   Dancer model  people       no &#13;
</pre><p>To filter columns, we will supply a character vector as the second argument while the first is left empty, which is exactly what we did when we subset a matrix:</p><pre class="programlisting">product_info[, c("id", "name", "type")] &#13;
##    id      name  type &#13;
## 1 T01    SupCar   toy &#13;
## 2 T02  SupPlane   toy &#13;
## 3 M01     JeepX model &#13;
## 4 M02 AircraftX model &#13;
## 5 M03    Runner model &#13;
## 6 M04    Dancer model &#13;
</pre><p>Alternatively, we can filter the data frame by regarding it as a list. We will supply only one character vector of column names in <code class="literal">[]</code> and omit the comma:</p><pre class="programlisting">product_info[c("id", "name", "class")] &#13;
##    id      name   class &#13;
## 1 T01    SupCar vehicle &#13;
## 2 T02  SupPlane vehicle &#13;
## 3 M01     JeepX vehicle &#13;
## 4 M02 AircraftX vehicle &#13;
## 5 M03    Runner  people &#13;
## 6 M04    Dancer  people &#13;
</pre><p>To filter a data frame by both row and column, we will supply a vector as the first argument to select rows and a vector as the second to select columns:</p><pre class="programlisting">product_info[product_info$type == "toy", c("name", "class", "released")] &#13;
##       name   class released &#13;
## 1   SupCar vehicle      yes &#13;
## 2 SupPlane vehicle       no &#13;
</pre><p>If the row-filtering condition is based on values of certain columns, the preceding code can be very redundant, especially when the condition gets more complicated. Another built-in function that simplifies code is <code class="literal">subset</code>, as we introduced previously:</p><pre class="programlisting">subset(product_info,  &#13;
  subset = type == "model" &amp; released == "yes", &#13;
  select = name:class) &#13;
##        name  type   class &#13;
## 3     JeepX model vehicle &#13;
## 4 AircraftX model vehicle &#13;
## 5    Runner model  people &#13;
</pre><p>The <code class="literal">subset</code> function uses non-standard evaluation so that we can directly use the columns of the data frame without typing <code class="literal">product_info</code> many times, because the expressions are meant to be evaluated in the context of the data frame.</p><p>Similarly, we can use <code class="literal">with</code> to evaluate an expression in the context of the data frame, that is, the columns of the data frame can be used as symbols in the expression without repeatedly specifying the data frame:</p><pre class="programlisting">with(product_info, name[released == "no"]) &#13;
## [1] "SupPlane" "Dancer" &#13;
</pre><p>The expression can be more than a simple subsetting. We can summarize the data by counting the occurrences of each possible value of a vector. For example, we can create a table of the occurrences of types of records that are released:</p><pre class="programlisting">with(product_info, table(type[released == "yes"])) &#13;
##  &#13;
## model   toy  &#13;
##     3     1 &#13;
</pre><p>In addition to the table of product information, we also have a table of product statistics that describe some properties of each product:</p><pre class="programlisting">product_stats &lt;- read_csv("data/product-stats.csv")  &#13;
product_stats  &#13;
##    id material size weight &#13;
## 1 T01    Metal  120   10.0 &#13;
## 2 T02    Metal  350   45.0 &#13;
## 3 M01 Plastics   50     NA &#13;
## 4 M02 Plastics   85    3.0 &#13;
## 5 M03     Wood   15     NA &#13;
## 6 M04     Wood   16    0.6 &#13;
</pre><p>Now, think how we can get the names of products with the top three largest sizes. One way is to sort the records in <code class="literal">product_stats</code> by size in descending order, select <code class="literal">id</code> values of the top three records, and use these values to filter rows of <code class="literal">product_info</code> by <code class="literal">id</code>:</p><pre class="programlisting">top_3_id &lt;- product_stats[order(product_stats$size, decreasing = TRUE), "id"][1:3] &#13;
product_info[product_info$id %in% top_3_id, ] &#13;
##    id      name  type   class released &#13;
## 1 T01    SupCar   toy vehicle      yes &#13;
## 2 T02  SupPlane   toy vehicle       no &#13;
## 4 M02 AircraftX model vehicle      yes &#13;
</pre><p>Although it works as supposed, this approach looks quite redundant. Note that <code class="literal">product_info</code> and <code class="literal">product_stats</code> actually describe the same set of products from different perspectives. The connection between these two tables is the <code class="literal">id</code> column. Each <code class="literal">id</code> is unique and refers to the same product. To access both sets of information, we can put the two tables together into one data frame. The simplest way to do this is use <code class="literal">merge</code>:</p><pre class="programlisting">product_table &lt;- merge(product_info, product_stats, by = "id") &#13;
product_table &#13;
##    id      name  type   class released material size weight &#13;
## 1 M01     JeepX model vehicle      yes Plastics   50     NA &#13;
## 2 M02 AircraftX model vehicle      yes Plastics   85    3.0 &#13;
## 3 M03    Runner model  people      yes     Wood   15     NA &#13;
## 4 M04    Dancer model  people       no     Wood   16    0.6 &#13;
## 5 T01    SupCar   toy vehicle      yes    Metal  120   10.0 &#13;
## 6 T02  SupPlane   toy vehicle       no    Metal  350   45.0 &#13;
</pre><p>Now, we create a new data frame that is a combined version of <code class="literal">product_table</code> and <code class="literal">product_info</code>, with a shared <code class="literal">id</code> column. In fact, if you reorder the records in the second table, the two tables still can be correctly merged.</p><p>With the combined version, we can do things more easily. For example, with the merged version, we can sort the data frame with any column in one table that we loaded without having to manually work with the other:</p><pre class="programlisting">product_table[order(product_table$size), ] &#13;
##    id      name  type   class released material size weight &#13;
## 3 M03    Runner model  people      yes     Wood   15     NA &#13;
## 4 M04    Dancer model  people       no     Wood   16    0.6 &#13;
## 1 M01     JeepX model vehicle      yes Plastics   50     NA &#13;
## 2 M02 AircraftX model vehicle      yes Plastics   85    3.0 &#13;
## 5 T01    SupCar   toy vehicle      yes    Metal  120   10.0 &#13;
## 6 T02  SupPlane   toy vehicle       no    Metal  350   45.0 &#13;
</pre><p>To solve the problem, we can directly use the merged table and get the same answer:</p><pre class="programlisting">product_table[order(product_table$size, decreasing = TRUE), "name"][1:3] &#13;
## [1] "SupPlane"  "SupCar"    "AircraftX" &#13;
</pre><p>The merged data frame allows us to sort the records by a column in one data frame and filter the records by a column in the other. For example, we will first sort the product records by weight in descending order and select all records of the <code class="literal">model</code> type:</p><pre class="programlisting">product_table[order(product_table$weight, decreasing = TRUE), ][ &#13;
  product_table$type == "model",] &#13;
##    id      name  type   class released material size weight &#13;
## 6 T02  SupPlane   toy vehicle       no    Metal  350   45.0 &#13;
## 5 T01    SupCar   toy vehicle      yes    Metal  120   10.0 &#13;
## 2 M02 AircraftX model vehicle      yes Plastics   85    3.0 &#13;
## 4 M04    Dancer model  people       no     Wood   16    0.6 &#13;
</pre><p>Sometimes, the column values are literal but can be converted to standard R data structures to better represent the data. For example, the <code class="literal">released</code> column in <code class="literal">product_info</code> only takes <code class="literal">yes</code> and <code class="literal">no</code>, which can be better represented with a logical vector. We can use <code class="literal">&lt;-</code> to modify the column values, as you learned previously. However, it is usually better to create a new data frame with the existing columns properly adjusted and new columns added without polluting the original data. To do this, we can use <code class="literal">transform</code>:</p><pre class="programlisting">transform(product_table,  &#13;
  released = ifelse(released == "yes", TRUE, FALSE), &#13;
  density = weight / size) &#13;
##    id      name  type   class released material size weight &#13;
## 1 M01     JeepX model vehicle     TRUE Plastics   50     NA &#13;
## 2 M02 AircraftX model vehicle     TRUE Plastics   85    3.0 &#13;
## 3 M03    Runner model  people     TRUE     Wood   15     NA &#13;
## 4 M04    Dancer model  people    FALSE     Wood   16    0.6 &#13;
## 5 T01    SupCar   toy vehicle     TRUE    Metal  120   10.0 &#13;
## 6 T02  SupPlane   toy vehicle    FALSE    Metal  350   45.0 &#13;
##      density &#13;
## 1         NA &#13;
## 2 0.03529412 &#13;
## 3         NA &#13;
## 4 0.03750000 &#13;
## 5 0.08333333 &#13;
## 6 0.12857143 &#13;
</pre><p>The result is a new data frame with <code class="literal">released</code> converted to a logical vector and a new column, <code class="literal">density</code>, added. You can easily verify that <code class="literal">product_table</code> is not modified at all.</p><p>Also, note that <code class="literal">transform</code> works in a way similar to <code class="literal">subset</code> because both functions use non-standard evaluation to allow direct use of data frame columns as symbols in the arguments so that we don't have to type <code class="literal">product_table$</code> before columns all the time.</p><p>In the preceding data, a number of columns contain missing values represented by <code class="literal">NA</code>. Under many circumstances, we don't want any missing values to be present in our data. Therefore, we need to somehow deal with them. To demonstrate the various techniques, we will load another table that contains missing values. The table is the test results of the quality, durability, and waterproofing of each product in the previous dataset we used. It is the test results of the quality, durability, and waterproofing of each product. We will store the data in <code class="literal">product_tests</code>:</p><pre class="programlisting">product_tests &lt;- read_csv("data/product-tests.csv")  &#13;
product_tests &#13;
##    id quality durability waterproof &#13;
## 1 T01      NA         10         no &#13;
## 2 T02      10          9         no &#13;
## 3 M01       6          4        yes &#13;
## 4 M02       6          5        yes &#13;
## 5 M03       5         NA        yes &#13;
## 6 M04       6          6        yes &#13;
</pre><p>Note that the values in both <code class="literal">quality</code> and <code class="literal">durability</code> contain missing values (<code class="literal">NA</code>). To exclude all rows with missing values, we can use <code class="literal">na.omit()</code>:</p><pre class="programlisting">na.omit(product_tests) &#13;
##    id quality durability waterproof &#13;
## 2 T02      10          9         no &#13;
## 3 M01       6          4        yes &#13;
## 4 M02       6          5        yes &#13;
## 6 M04       6          6        yes &#13;
</pre><p>Another way is to use <code class="literal">complete.cases()</code> to get a logical vector, indicating all complete rows (without any missing value):</p><pre class="programlisting">complete.cases(product_tests) &#13;
## [1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE &#13;
</pre><p>Then, we can use this logical vector to filter the data frame. For example, we can get the <code class="literal">id</code> of all complete rows:</p><pre class="programlisting">product_tests[complete.cases(product_tests), "id"] &#13;
## [1] "T02" "M01" "M02" "M04" &#13;
</pre><p>Alternatively, we can get the id of all incomplete rows:</p><pre class="programlisting">product_tests[!complete.cases(product_tests), "id"] &#13;
## [1] "T01" "M03" &#13;
</pre><p>Note that <code class="literal">product_info</code>, <code class="literal">product_stats</code>, and <code class="literal">product_tests</code> all share an <code class="literal">id</code> column; we can merge them all together. Unfortunately, there's no built-in function to merge an arbitrary number of data frames. We can only merge two existing data frames at a time, or we'll have to merge them recursively:</p><pre class="programlisting">product_full &lt;- merge(product_table, product_tests, by = "id") &#13;
product_full &#13;
##    id      name  type   class released material size weight &#13;
## 1 M01     JeepX model vehicle      yes Plastics   50     NA &#13;
## 2 M02 AircraftX model vehicle      yes Plastics   85    3.0 &#13;
## 3 M03    Runner model  people      yes     Wood   15     NA &#13;
## 4 M04    Dancer model  people       no     Wood   16    0.6 &#13;
## 5 T01    SupCar   toy vehicle      yes    Metal  120   10.0 &#13;
## 6 T02  SupPlane   toy vehicle       no    Metal  350   45.0 &#13;
##   quality durability waterproof &#13;
## 1       6          4        yes &#13;
## 2       6          5        yes &#13;
## 3       5         NA        yes &#13;
## 4       6          6        yes &#13;
## 5      NA         10         no &#13;
## 6      10          9         no &#13;
</pre><p>With the fully merged table, we can use <code class="literal">tapply</code>, another apply-family function specialized to work with tabular data, to summarize the data using certain methods over given columns. For example, we can calculate the mean value of <code class="literal">quality</code> of each <code class="literal">type</code>:</p><pre class="programlisting">mean_quality1 &lt;- tapply(product_full$quality, &#13;
  list(product_full$type), &#13;
  mean, na.rm = TRUE) &#13;
mean_quality1 &#13;
## model   toy  &#13;
##  5.75 10.00 &#13;
</pre><p>Note that we not only supply <code class="literal">mean</code> but also specify <code class="literal">na.rm = TRUE</code> to ignore the missing values in <code class="literal">quality</code>. The result looks like a numeric vector. We will use <code class="literal">str()</code>, so let's take a look at its structure:</p><pre class="programlisting">str(mean_quality1) &#13;
##  num [1:2(1d)] 5.75 10 &#13;
##  - attr(*, "dimnames")=List of 1 &#13;
##   ..$ : chr [1:2] "model" "toy" &#13;
</pre><p>In fact, it is a one-dimensional array:</p><pre class="programlisting">is.array(mean_quality1) &#13;
## [1] TRUE &#13;
</pre><p>The <code class="literal">tapply</code> function produces an array instead of a simple numeric vector, because it can be easily generalized to work with multiple grouping. For example, we can compute the mean value of <code class="literal">quality</code> for each <code class="literal">type</code> and <code class="literal">class</code> pair:</p><pre class="programlisting">mean_quality2 &lt;- tapply(product_full$quality,  &#13;
  list(product_full$type, product_full$class),  &#13;
  mean, na.rm = TRUE) &#13;
mean_quality2 &#13;
##       people vehicle &#13;
## model    5.5       6 &#13;
## toy       NA      10 &#13;
</pre><p>Now, we have a two-dimensional array, whose values can be extracted by two arguments:</p><pre class="programlisting">mean_quality2["model", "vehicle"] &#13;
## [1] 6 &#13;
</pre><p>Moreover, we can supply more columns for grouping. In the following code, we will use the <code class="literal">with()</code> function to reduce redundant typing of <code class="literal">product_full</code>:</p><pre class="programlisting">mean_quality3 &lt;- with(product_full, &#13;
  tapply(quality, list(type, material, released), &#13;
    mean, na.rm = TRUE)) &#13;
mean_quality3 &#13;
## , , no &#13;
##  &#13;
##       Metal Plastics Wood &#13;
## model    NA       NA    6 &#13;
## toy      10       NA   NA &#13;
##  &#13;
## , , yes &#13;
##  &#13;
##       Metal Plastics Wood &#13;
## model    NA        6    5 &#13;
## toy     NaN       NA   NA</pre><p>Now, a three-dimensional array is produced. Even though <code class="literal">na.rm = TRUE</code> is specified, many cells are still missing values. This is because no value is present for the grouping:</p><pre class="programlisting">str(mean_quality3) &#13;
##  num [1:2, 1:3, 1:2] NA 10 NA NA 6 NA NA NaN 6 NA ... &#13;
##  - attr(*, "dimnames")=List of 3 &#13;
##   ..$ : chr [1:2] "model" "toy" &#13;
##   ..$ : chr [1:3] "Metal" "Plastics" "Wood" &#13;
##   ..$ : chr [1:2] "no" "yes" &#13;
</pre><p>We can access the cell value by supplying three arguments:</p><pre class="programlisting">mean_quality3["model", "Wood", "yes"] &#13;
## [1] 5 &#13;
</pre><p>In summary,<code class="literal">tapply</code> groups the input data frame with <code class="literal">n</code> specified variables and produces an array with <code class="literal">n</code> dimensions. This approach to summarizing data can be hard to work with, especially when there are more columns for grouping. This is mostly because array is usually high-dimensional, hard to represent, and not flexible for further manipulation. Later in this chapter, you will learn several different methods that make group summary much easier.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec139"/>Reshaping data frames using reshape2</h2></div></div></div><p>Previously, you learned how to filter, sort, merge, and summarize data frames. These operations only work on rows and columns separately. Sometimes, however, we need to do something more complex.</p><p>For example, the following code loads a dataset of tests on quality and durability on different dates of two products:</p><pre class="programlisting">toy_tests &lt;- read_csv("data/product-toy-tests.csv") &#13;
toy_tests &#13;
##    id     date sample quality durability &#13;
## 1 T01 20160201    100       9          9 &#13;
## 2 T01 20160302    150      10          9 &#13;
## 3 T01 20160405    180       9         10 &#13;
## 4 T01 20160502    140       9          9 &#13;
## 5 T02 20160201     70       7          9 &#13;
## 6 T02 20160303     75       8          8 &#13;
## 7 T02 20160403     90       9          8 &#13;
## 8 T02 20160502     85      10          9 &#13;
</pre><p>Each row of the preceding data frame represents a record of tests of a particular product (<code class="literal">id</code>) on a certain <code class="literal">date</code>. If we need to compare the quality or durability of the two products at the same time, it can be hard to work with such format of data. Instead, we need the data to be transformed like the following code so that we can compare the values of the two products more easily:</p><pre class="programlisting">date      T01   T02 &#13;
20160201    9     9 &#13;
20160301    10    9 &#13;
</pre><p>The <code class="literal">reshape2</code> package is designed for such a transform. If you don't have it installed, run the following command:</p><pre class="programlisting">install.packages("reshape2") &#13;
</pre><p>Once the package is installed, we can use <code class="literal">reshape2::dcast</code> to transform the data so that we can easily compare the <code class="literal">quality</code> of different products on the same <code class="literal">date</code>. More specifically, it reshapes <code class="literal">toy_tests</code> so that the <code class="literal">date</code> column is shared, the values in <code class="literal">id</code> are spread as columns, and the values for each <code class="literal">date</code> and <code class="literal">id</code> are <code class="literal">quality</code> data:</p><pre class="programlisting">library(reshape2) &#13;
toy_quality &lt;- dcast(toy_tests, date ~ id, value.var = "quality") &#13;
toy_quality &#13;
##       date T01 T02 &#13;
## 1 20160201   9   7 &#13;
## 2 20160302  10  NA &#13;
## 3 20160303  NA   8 &#13;
## 4 20160403  NA   9 &#13;
## 5 20160405   9  NA &#13;
## 6 20160502   9  10 &#13;
</pre><p>As you can see, <code class="literal">toy_tests</code> is immediately transformed. The <code class="literal">quality</code> values of both products are aligned with <code class="literal">date</code>. Although each month the two products conduct a test, the date may not exactly match with each other. This results in missing values if one product has a value on a day, but the other has no corresponding value on exactly the same day.</p><p>One way to fill the missing value is to use the approach called <strong>Last Observation Carried Forward</strong> (<strong>LOCF</strong>), which means that if a non-missing value is followed by a missing value, then the non-missing value is carried forward to replace the missing value, until all subsequent missing values are replaced. One implementation of LOCF is provided by the <code class="literal">zoo</code> package. Run the following command to install the package if you don't have it:</p><pre class="programlisting">install.packages("zoo") &#13;
</pre><p>To demonstrate how it works, we will use <code class="literal">zoo::na.locf()</code> to perform this technique over a very simple numeric vector with missing values:</p><pre class="programlisting">zoo::na.locf(c(1, 2, NA, NA, 3, 1, NA, 2, NA)) &#13;
## [1] 1 2 2 2 3 1 1 2 2 &#13;
</pre><p>It is straightforward that all missing values are replaced with previous non-missing values. To do the same thing with <code class="literal">T01</code> and <code class="literal">T02</code> columns of <code class="literal">toy_quality</code>, we can sub-assign the processed vector to the columns:</p><pre class="programlisting">toy_quality$T01 &lt;- zoo::na.locf(toy_quality$T01) &#13;
toy_quality$T02 &lt;- zoo::na.locf(toy_quality$T02) &#13;
</pre><p>However, if <code class="literal">toy_tests</code> contains thousands of products, it is ridiculous to write thousands of lines of code to do similar things like this. A better practice would be using exclusive sub-assignment as follows:</p><pre class="programlisting">toy_quality[-1] &lt;- lapply(toy_quality[-1], zoo::na.locf) &#13;
toy_quality &#13;
##       date T01 T02 &#13;
## 1 20160201   9   7 &#13;
## 2 20160302  10   7 &#13;
## 3 20160303  10   8 &#13;
## 4 20160403  10   9 &#13;
## 5 20160405   9   9 &#13;
## 6 20160502   9  10 &#13;
</pre><p>We will use <code class="literal">lapply()</code> to perform LOCF over all columns of <code class="literal">toy_quality</code>, except <code class="literal">date</code>, and assign the resulting list to the subset of <code class="literal">toy_quality</code> without the <code class="literal">date</code> column. This works because sub-assignment of a data frame accepts a list and still preserves the class of data frame.</p><p>However, although the data does not contain any missing values, the meaning of each row is changed. Originally, product <code class="literal">T01</code> does not take a test on <code class="literal">20160303</code>. The value should be interpreted as the last test value of quality on or before the day. Another drawback is that in the original data, both products take tests every month, but the preceding reshaped data frame is not aligned to <code class="literal">date</code> of regular frequency.</p><p>One way to fix the drawbacks is to use year-month data instead of an exact date. In the following code, we will create a new column <code class="literal">ym</code>, that is, the first 6 characters of <code class="literal">toy_tests</code>. For example, <code class="literal">substr(20160101, 1, 6)</code> will result in <code class="literal">201601</code>:</p><pre class="programlisting">toy_tests$ym &lt;- substr(toy_tests$date, 1, 6) &#13;
toy_tests &#13;
##    id     date sample quality durability     ym &#13;
## 1 T01 20160201    100       9          9 201602 &#13;
## 2 T01 20160302    150      10          9 201603 &#13;
## 3 T01 20160405    180       9         10 201604 &#13;
## 4 T01 20160502    140       9          9 201605 &#13;
## 5 T02 20160201     70       7          9 201602 &#13;
## 6 T02 20160303     75       8          8 201603 &#13;
## 7 T02 20160403     90       9          8 201604 &#13;
## 8 T02 20160502     85      10          9 201605 &#13;
</pre><p>This time, we will use the <code class="literal">ym</code> column for alignment instead of <code class="literal">date</code>:</p><pre class="programlisting">toy_quality &lt;- dcast(toy_tests, ym ~ id,  &#13;
    value.var = "quality") &#13;
toy_quality &#13;
##       ym T01 T02 &#13;
## 1 201602   9   7 &#13;
## 2 201603  10   8 &#13;
## 3 201604   9   9 &#13;
## 4 201605   9  10 &#13;
</pre><p>Now, the missing values are gone, and the quality scores of both products in each month are naturally presented.</p><p>Sometimes, we need to combine a number of columns into one that indicates the measure and another that stores the value. For example, the following code uses <code class="literal">reshape2::melt</code> to combine the two measures (<code class="literal">quality</code> and <code class="literal">durability</code>) of the original data into a column named <code class="literal">measure</code> and a column of the measured value:</p><pre class="programlisting">toy_tests2 &lt;- melt(toy_tests, id.vars = c("id", "ym"),  &#13;
  measure.vars = c("quality", "durability"), &#13;
  variable.name = "measure") &#13;
toy_tests2 &#13;
##     id     ym    measure value &#13;
## 1  T01 201602    quality     9 &#13;
## 2  T01 201603    quality    10 &#13;
## 3  T01 201604    quality     9 &#13;
## 4  T01 201605    quality     9 &#13;
## 5  T02 201602    quality     7 &#13;
## 6  T02 201603    quality     8 &#13;
## 7  T02 201604    quality     9 &#13;
## 8  T02 201605    quality    10 &#13;
## 9  T01 201602 durability     9 &#13;
## 10 T01 201603 durability     9 &#13;
## 11 T01 201604 durability    10 &#13;
## 12 T01 201605 durability     9 &#13;
## 13 T02 201602 durability     9 &#13;
## 14 T02 201603 durability     8 &#13;
## 15 T02 201604 durability     8 &#13;
## 16 T02 201605 durability     9 &#13;
</pre><p>The variable names are now contained in the data, which can be directly used by some packages. For example, we can use <code class="literal">ggplot2</code> to plot data in such a format. The following code is an example of a scatter plot with facet grid of different combination of factors:</p><pre class="programlisting">library(ggplot2) &#13;
ggplot(toy_tests2, aes(x = ym, y = value)) +  &#13;
  geom_point() + &#13;
  facet_grid(id ~ measure) &#13;
</pre><p>Then, we can see a scatter plot grouped by product <code class="literal">id</code> and <code class="literal">measure</code> with <code class="literal">ym</code> as <em>x</em> values and <code class="literal">value</code> as <em>y</em> values:</p><div><img src="img/image_12_001.jpg" alt="Reshaping data frames using reshape2"/></div><p>The plot can be easily manipulated because the grouping factor (<code class="literal">measure</code>) is contained as data rather than columns, which is easier to represent from the perspective of the <code class="literal">ggplot2</code> package:</p><pre class="programlisting">ggplot(toy_tests2, aes(x = ym, y = value, color = id)) +  &#13;
  geom_point() + &#13;
  facet_grid(. ~ measure) &#13;
</pre><p>This time, we will present the points of the two products in different colors:</p><div><img src="img/image_12_002.jpg" alt="Reshaping data frames using reshape2"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec62"/>Using SQL to query data frames via the sqldf package</h1></div></div></div><p>In the previous chapter, you learned how to compose SQL statements to query data from relational databases such as SQLite and MySQL. Is there a way to directly use SQL to query data frames in R as if these data frames are tables in relational databases? The <code class="literal">sqldf</code> package says yes.</p><p>This package takes advantage of SQLite, thanks to its lightweight structure and easiness to embed into an R session. Run the following command to install this package if you don't have it:</p><pre class="programlisting">install.packages("sqldf") &#13;
</pre><p>First, let's attach the package, as shown in the following code:</p><pre class="programlisting">library(sqldf) &#13;
## Loading required package: gsubfn &#13;
## Loading required package: proto &#13;
## Loading required package: RSQLite &#13;
## Loading required package: DBI &#13;
</pre><p>Note that when we attach <code class="literal">sqldf</code>, a number of other packages are automatically loaded. The <code class="literal">sqldf</code> package depends on these packages, because what it does is basically transferring data and converting data types between R and SQLite.</p><p>Then, we will reload the product tables we used in the previous sections:</p><pre class="programlisting">product_info &lt;- read_csv("data/product-info.csv") &#13;
product_stats &lt;- read_csv("data/product-stats.csv") &#13;
product_tests &lt;- read_csv("data/product-tests.csv") &#13;
toy_tests &lt;- read_csv("data/product-toy-tests.csv") &#13;
</pre><p>The magic of this package is that we can directly query the data frames in our working environment with SQL. For example, we can select all records of <code class="literal">product_info</code>:</p><pre class="programlisting">sqldf("select * from product_info") &#13;
## Loading required package: tcltk &#13;
##    id      name  type   class released &#13;
## 1 T01    SupCar   toy vehicle      yes &#13;
## 2 T02  SupPlane   toy vehicle       no &#13;
## 3 M01     JeepX model vehicle      yes &#13;
## 4 M02 AircraftX model vehicle      yes &#13;
## 5 M03    Runner model  people      yes &#13;
## 6 M04    Dancer model  people       no &#13;
</pre><p>The <code class="literal">sqldf</code> package supports simple select queries that are supported by SQLite. For example, we can select a certain set of columns:</p><pre class="programlisting">sqldf("select id, name, class from product_info") &#13;
##    id      name   class &#13;
## 1 T01    SupCar vehicle &#13;
## 2 T02  SupPlane vehicle &#13;
## 3 M01     JeepX vehicle &#13;
## 4 M02 AircraftX vehicle &#13;
## 5 M03    Runner  people &#13;
## 6 M04    Dancer  people &#13;
</pre><p>We can filter records by a certain condition:</p><pre class="programlisting">sqldf("select id, name from product_info where released = 'yes'") &#13;
##    id      name &#13;
## 1 T01    SupCar &#13;
## 2 M01     JeepX &#13;
## 3 M02 AircraftX &#13;
## 4 M03    Runner &#13;
</pre><p>We can compute a new column and give it a name:</p><pre class="programlisting">sqldf("select id, material, size / weight as density from product_stats") &#13;
##    id material   density &#13;
## 1 T01    Metal 12.000000 &#13;
## 2 T02    Metal  7.777778 &#13;
## 3 M01 Plastics        NA &#13;
## 4 M02 Plastics 28.333333 &#13;
## 5 M03     Wood        NA &#13;
## 6 M04     Wood 26.666667 &#13;
</pre><p>We can sort records by certain columns in given orders:</p><pre class="programlisting">sqldf("select * from product_stats order by size desc") &#13;
##    id material size weight &#13;
## 1 T02    Metal  350   45.0 &#13;
## 2 T01    Metal  120   10.0 &#13;
## 3 M02 Plastics   85    3.0 &#13;
## 4 M01 Plastics   50     NA &#13;
## 5 M04     Wood   16    0.6 &#13;
## 6 M03     Wood   15     NA &#13;
</pre><p>The package also supports querying multiple data frames such as <code class="literal">join</code>. In the following code, we will merge <code class="literal">product_info</code> and <code class="literal">product_stats</code> by <code class="literal">id</code>, just like what we did with <code class="literal">merge()</code> previously:</p><pre class="programlisting">sqldf("select * from product_info join product_stats using (id)") &#13;
##    id      name  type   class released material size weight &#13;
## 1 T01    SupCar   toy vehicle      yes    Metal  120   10.0 &#13;
## 2 T02  SupPlane   toy vehicle       no    Metal  350   45.0 &#13;
## 3 M01     JeepX model vehicle      yes Plastics   50     NA &#13;
## 4 M02 AircraftX model vehicle      yes Plastics   85    3.0 &#13;
## 5 M03    Runner model  people      yes     Wood   15     NA &#13;
## 6 M04    Dancer model  people       no     Wood   16    0.6 &#13;
</pre><p>Moreover, it also supports nested query. In the following code, we will select all records in <code class="literal">product_info</code> that are made of wood:</p><pre class="programlisting">sqldf("select * from product_info where id in  &#13;
  (select id from product_stats where material = 'Wood')") &#13;
##    id   name  type  class released &#13;
## 1 M03 Runner model people      yes &#13;
## 2 M04 Dancer model people       no &#13;
</pre><p>Alternatively, we can use <code class="literal">join</code> with the same <code class="literal">where</code> condition to achieve the same goal. For many relational databases, <code class="literal">join</code> usually works faster than <code class="literal">in</code> when the data is large:</p><pre class="programlisting">sqldf("select * from product_info join product_stats using (id)  &#13;
  where material = 'Wood'") &#13;
##    id   name  type  class released material size weight &#13;
## 1 M03 Runner model people      yes     Wood   15     NA &#13;
## 2 M04 Dancer model people       no     Wood   16    0.6 &#13;
</pre><p>In addition to <code class="literal">join</code>, we can easily summarize data by group. For example, we group <code class="literal">product_tests</code> by <code class="literal">waterproof</code> into two groups: <code class="literal">yes</code> and <code class="literal">no</code>. For each group, we compute the average values of <code class="literal">quality</code> and <code class="literal">durability</code>, respectively:</p><pre class="programlisting">sqldf("select waterproof, avg(quality), avg(durability) from product_tests &#13;
  group by waterproof") &#13;
##   waterproof avg(quality) avg(durability) &#13;
## 1         no        10.00             9.5 &#13;
## 2        yes         5.75             5.0 &#13;
</pre><p>For the <code class="literal">toy_tests</code> data, it is easy to aggregate data for each product. Here is an example of averaging <code class="literal">quality</code> and <code class="literal">durability</code> values across time for each product:</p><pre class="programlisting">sqldf("select id, avg(quality), avg(durability) from toy_tests  &#13;
  group by id") &#13;
##    id avg(quality) avg(durability) &#13;
## 1 T01         9.25            9.25 &#13;
## 2 T02         8.50            8.50 &#13;
</pre><p>To make the results more informative, we can join <code class="literal">product_info</code> with the grouped summary table so that the product information and average measures are presented together:</p><pre class="programlisting">sqldf("select * from product_info join  &#13;
  (select id, avg(quality), avg(durability) from toy_tests  &#13;
    group by id) using (id)") &#13;
##    id     name type   class released avg(quality) &#13;
## 1 T01   SupCar  toy vehicle      yes         9.25 &#13;
## 2 T02 SupPlane  toy vehicle       no         8.50 &#13;
##   avg(durability) &#13;
## 1            9.25 &#13;
## 2            8.50 &#13;
</pre><p>Using <code class="literal">sqldf</code> and SQL to query data frames looks very handy, but the limitations are obvious too.</p><p>First, since <code class="literal">sqldf</code> is, by default, based on SQLite, the limitation of the package is also the limitation of SQLite database, that is, the built-in group aggregate functions are limited. The official webpage (<a class="ulink" href="https://sqlite.org/lang_aggfunc.html">https://sqlite.org/lang_aggfunc.html</a>) provides a list of functions: <code class="literal">avg()</code>, <code class="literal">count()</code>, <code class="literal">group_concat()</code>, <code class="literal">max()</code>, <code class="literal">min()</code>, <code class="literal">sum()</code>, and <code class="literal">total()</code>. If we need more than that, for example, <code class="literal">quantile()</code>, it won't be easy. In R, we can use much more advanced algorithms to aggregate columns.</p><p>Second, since we need to supply a string of select statements to query data, it is not very convenient to generate SQL dynamically when part of it is determined by R variables. Therefore, we need to use <code class="literal">sprintf()</code> to allow the values of R variables to appear in the SQL statement.</p><p>Third, the limitation of <code class="literal">sqldf</code> is also the limitation of SQL. It is hard to compute new columns with more complex algorithms. For example, if we need to compute a ranking column based on an existing numeric column, it would not be very easy to implement. However, in R, we just need <code class="literal">order()</code>. Another thing is that it is hard or verbose to implement more complex filter operations such as ranking-based data filtering. For example, how do you select the first one or two products ordered by <code class="literal">size</code> in descending order grouped by <code class="literal">material</code>? Such a query requires a lot more thinking and tricks.</p><p>However, if we use the <code class="literal">plyr</code> package, such a task is a piece of cake. If you have the package installed, run the following code:</p><pre class="programlisting">install.packages("plyr") &#13;
</pre><p>To demonstrate how simple it is, we will use <code class="literal">plyr::ddply</code> to do this. We will supply <code class="literal">material</code> as the data splitter, that is, <code class="literal">product_stats</code> is divided into several parts for each value taken by <code class="literal">material</code>. We also supply a function to transform the input data frame (each part) to a new data frame. Then, the <code class="literal">ddply</code> function combines these data frames together:</p><pre class="programlisting">plyr::ddply(product_stats, "material",  &#13;
  function(x) { &#13;
    head(x[order(x$size, decreasing = TRUE),], 1L) &#13;
  }) &#13;
##    id material size weight &#13;
## 1 T02    Metal  350   45.0 &#13;
## 2 M02 Plastics   85    3.0 &#13;
## 3 M04     Wood   16    0.6 &#13;
</pre><p>The anonymous function we supplied is called with three parts of <code class="literal">product_stats</code> with distinct <code class="literal">material</code>, each part having identical <code class="literal">material</code>.</p><p>Another example is to select top two test results with the most samples:</p><pre class="programlisting">plyr::ddply(toy_tests, "id",  &#13;
  function(x) { &#13;
    head(x[order(x$sample, decreasing = TRUE), ], 2) &#13;
  }) &#13;
##    id     date sample quality durability &#13;
## 1 T01 20160405    180       9         10 &#13;
## 2 T01 20160302    150      10          9 &#13;
## 3 T02 20160403     90       9          8 &#13;
## 4 T02 20160502     85      10          9 &#13;
</pre><p>The anonymous function we supplied is called with two parts of <code class="literal">toy_tests</code>: one part is a data frame with <code class="literal">id</code> being <code class="literal">T01</code> and the other <code class="literal">T02</code>. For each part, we order the sub-dataframe by <code class="literal">sample</code> in the descending order and take the top two records. The task is easily finished.</p><p>In addition, <code class="literal">ddply</code>, <code class="literal">plyr</code> provides a variety of functions of many possible pairs of input-output data types. To learn more, visit <a class="ulink" href="http://had.co.nz/plyr/">http://had.co.nz/plyr/</a> and <a class="ulink" href="https://github.com/hadley/plyr">https://github.com/hadley/plyr</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec63"/>Using data.table to manipulate data</h1></div></div></div><p>In the first section, we reviewed some built-in functions used to manipulate data frames. Then, we introduced <code class="literal">sqldf</code>, which makes simple data query and summary easier. However, both approaches have their limitations. Using built-in functions can be verbose and slow, and it is not easy to summarize data because SQL is not as powerful as the full spectrum of R functions.</p><p>The <code class="literal">data.table</code> package provides a powerful enhanced version of <code class="literal">data.frame</code>. It is blazing fast and has the ability to handle large data that fits into memory. It invents a natural syntax of data manipulation using <code class="literal">[]</code>. Run the following command to install the package from CRAN if you don't have it yet:</p><pre class="programlisting">install.packages("data.table") &#13;
</pre><p>Once the package is successfully installed, we will load the package and see what it offers:</p><pre class="programlisting">library(data.table) &#13;
##  &#13;
## Attaching package: 'data.table' &#13;
## The following objects are masked from 'package:reshape2': &#13;
##  &#13;
##     dcast, melt &#13;
</pre><p>Note that we previously loaded the <code class="literal">reshape2</code> package in which <code class="literal">dcast</code> and <code class="literal">melt</code> are defined. The <code class="literal">data.table</code> package also provides enhanced version of <code class="literal">dcast</code> and <code class="literal">melt</code> with more powerful functionality, better performance, and higher memory efficiency. We'll take a look at them later in this section.</p><p>Creating <code class="literal">data.table</code> is very much like creating <code class="literal">data.frame</code>:</p><pre class="programlisting">dt &lt;- data.table(x = 1:3, y = rnorm(3), z = letters[1:3]) &#13;
dt &#13;
##    x           y z &#13;
## 1: 1 -0.50219235 a &#13;
## 2: 2  0.13153117 b &#13;
## 3: 3 -0.07891709 c &#13;
</pre><p>We can see its structure with <code class="literal">str()</code>:</p><pre class="programlisting">str(dt) &#13;
## Classes 'data.table' and 'data.frame':   3 obs. of  3 variables: &#13;
##  $ x: int  1 2 3 &#13;
##  $ y: num  -0.5022 0.1315 -0.0789 &#13;
##  $ z: chr  "a" "b" "c" &#13;
##  - attr(*, ".internal.selfref")=&lt;externalptr&gt; &#13;
</pre><p>It is clear that <code class="literal">dt</code> is of class <code class="literal">data.table</code> and <code class="literal">data.frame</code>, which means that <code class="literal">data.table</code> inherits from <code class="literal">data.frame</code>. In other words, it inherits some behaviors of <code class="literal">data.frame</code>, but override others as enhancements.</p><p>First, we still load the product data. However, this time, we will use <code class="literal">fread()</code> provided by <code class="literal">data.table</code> package. The <code class="literal">fread()</code> function is super-fast, has great memory efficiency, and directly returns <code class="literal">data.table</code>:</p><pre class="programlisting">product_info &lt;- fread("data/product-info.csv") &#13;
product_stats &lt;- fread("data/product-stats.csv") &#13;
product_tests &lt;- fread("data/product-tests.csv") &#13;
toy_tests &lt;- fread("data/product-toy-tests.csv") &#13;
</pre><p>If we take a look at <code class="literal">product_info</code>, its appearance is only slightly different from that of a data frame:</p><pre class="programlisting">product_info &#13;
##     id      name  type   class released &#13;
## 1: T01    SupCar   toy vehicle      yes &#13;
## 2: T02  SupPlane   toy vehicle       no &#13;
## 3: M01     JeepX model vehicle      yes &#13;
## 4: M02 AircraftX model vehicle      yes &#13;
## 5: M03    Runner model  people      yes &#13;
## 6: M04    Dancer model  people       no &#13;
</pre><p>Again, we will look at its structure:</p><pre class="programlisting">str(product_info) &#13;
## Classes 'data.table' and 'data.frame':   6 obs. of  5 variables: &#13;
##  $ id      : chr  "T01" "T02" "M01" "M02" ... &#13;
##  $ name    : chr  "SupCar" "SupPlane" "JeepX" "AircraftX" ... &#13;
##  $ type    : chr  "toy" "toy" "model" "model" ... &#13;
##  $ class   : chr  "vehicle" "vehicle" "vehicle" "vehicle" ... &#13;
##  $ released: chr  "yes" "no" "yes" "yes" ... &#13;
##  - attr(*, ".internal.selfref") =&lt; externalptr&gt; &#13;
</pre><p>As compared to <code class="literal">data.frame</code>, if we supply only one argument to subset <code class="literal">data.table</code>, it means selecting rows rather than columns:</p><pre class="programlisting">product_info[1] &#13;
##     id   name type   class released &#13;
## 1: T01 SupCar  toy vehicle      yes &#13;
product_info[1:3] &#13;
##     id     name  type   class released &#13;
## 1: T01   SupCar   toy vehicle      yes &#13;
## 2: T02 SupPlane   toy vehicle       no &#13;
## 3: M01    JeepX model vehicle      yes &#13;
</pre><p>If the number we supply in <code class="literal">[]</code> is negative, it means excluding the record, which is fully consistent with subsetting a vector:</p><pre class="programlisting">product_info[-1] &#13;
##     id      name  type   class released &#13;
## 1: T02  SupPlane   toy vehicle       no &#13;
## 2: M01     JeepX model vehicle      yes &#13;
## 3: M02 AircraftX model vehicle      yes &#13;
## 4: M03    Runner model  people      yes &#13;
## 5: M04    Dancer model  people       no &#13;
</pre><p>In addition, <code class="literal">data.table</code> also provides a number of symbols that represent important components of <code class="literal">data.table</code>. One of the most useful symbols is <code class="literal">.N</code>, which means the number of rows. If we want to select the last row, we no longer need <code class="literal">nrow(product_info)</code>:</p><pre class="programlisting">product_info[.N] &#13;
##     id   name  type  class released &#13;
## 1: M04 Dancer model people       no &#13;
</pre><p>We can easily select the first and last rows:</p><pre class="programlisting">product_info[c(1, .N)] &#13;
##     id   name  type   class released &#13;
## 1: T01 SupCar   toy vehicle      yes &#13;
## 2: M04 Dancer model  people       no &#13;
</pre><p>The syntax of <code class="literal">data.table</code> subsetting automatically evaluates the expressions in the context of the data, that is, we can directly use column names as symbols, just like how we use <code class="literal">subset</code>, <code class="literal">transform</code>, and <code class="literal">with</code>. For example, we can directly use <code class="literal">released</code> in the first argument to select rows of products that are released:</p><pre class="programlisting">product_info[released == "yes"] &#13;
##     id      name  type   class released &#13;
## 1: T01    SupCar   toy vehicle      yes &#13;
## 2: M01     JeepX model vehicle      yes &#13;
## 3: M02 AircraftX model vehicle      yes &#13;
## 4: M03    Runner model  people      yes &#13;
</pre><p>The first argument in the square brackets is a row filter, while the second is evaluated within the context of the filtered data. For example, we can directly use <code class="literal">id</code> to represent <code class="literal">product_info$id</code> because <code class="literal">id</code> is evaluated within the context of <code class="literal">product_info</code>:</p><pre class="programlisting">product_info[released == "yes", id] &#13;
## [1] "T01" "M01" "M02" "M03" &#13;
</pre><p>The way to select columns of a data frame does not work here. If we put a character vector in the second argument, then we'll get the character vector itself because a string is indeed a string:</p><pre class="programlisting">product_info[released == "yes", "id"] &#13;
## [1] "id" &#13;
</pre><p>To disable this behavior, we can specify <code class="literal">with = FALSE</code> so that the second argument accepts a character vector to select columns, and it always returns a <code class="literal">data.table</code>, no matter how many columns are specified:</p><pre class="programlisting">product_info[released == "yes", "id", with = FALSE] &#13;
##     id &#13;
## 1: T01 &#13;
## 2: M01 &#13;
## 3: M02 &#13;
## 4: M03 &#13;
product_info[released == "yes", c("id", "name"), with = FALSE] &#13;
##     id      name &#13;
## 1: T01    SupCar &#13;
## 2: M01     JeepX &#13;
## 3: M02 AircraftX &#13;
## 4: M03    Runner &#13;
</pre><p>We can also write some other expressions as the second argument. For example, we can generate a table of the number of released products for each combination of <code class="literal">type</code> and <code class="literal">class</code>:</p><pre class="programlisting">product_info[released == "yes", table(type, class)] &#13;
##        class &#13;
## type    people vehicle &#13;
##   model      1       2 &#13;
##   toy        0       1 &#13;
</pre><p>However, if a list is produced, it will be transformed to <code class="literal">data.table</code> instead:</p><pre class="programlisting">product_info[released == "yes", list(id, name)] &#13;
##     id      name &#13;
## 1: T01    SupCar &#13;
## 2: M01     JeepX &#13;
## 3: M02 AircraftX &#13;
## 4: M03    Runner &#13;
</pre><p>In this way, we can easily create a new <code class="literal">data.table</code> package with existing columns replaced:</p><pre class="programlisting">product_info[, list(id, name, released = released == "yes")] &#13;
##     id      name released &#13;
## 1: T01    SupCar     TRUE &#13;
## 2: T02  SupPlane    FALSE &#13;
## 3: M01     JeepX     TRUE &#13;
## 4: M02 AircraftX     TRUE &#13;
## 5: M03    Runner     TRUE &#13;
## 6: M04    Dancer    FALSE &#13;
</pre><p>We can also easily create a new <code class="literal">data.table</code> package with new columns based on existing columns:</p><pre class="programlisting">product_stats[, list(id, material, size, weight,  &#13;
  density = size / weight)] &#13;
##     id material size weight   density &#13;
## 1: T01    Metal  120   10.0 12.000000 &#13;
## 2: T02    Metal  350   45.0  7.777778 &#13;
## 3: M01 Plastics   50     NA        NA &#13;
## 4: M02 Plastics   85    3.0 28.333333 &#13;
## 5: M03     Wood   15     NA        NA &#13;
## 6: M04     Wood   16    0.6 26.666667 &#13;
</pre><p>For simplicity, <code class="literal">data.table</code> provides <code class="literal">.()</code> to be short for <code class="literal">list()</code>:</p><pre class="programlisting">product_info[, .(id, name, type, class)] &#13;
##     id      name  type   class &#13;
## 1: T01    SupCar   toy vehicle &#13;
## 2: T02  SupPlane   toy vehicle &#13;
## 3: M01     JeepX model vehicle &#13;
## 4: M02 AircraftX model vehicle &#13;
## 5: M03    Runner model  people &#13;
## 6: M04    Dancer model  people &#13;
product_info[released == "yes", .(id, name)] &#13;
##     id      name &#13;
## 1: T01    SupCar &#13;
## 2: M01     JeepX &#13;
## 3: M02 AircraftX &#13;
## 4: M03    Runner &#13;
</pre><p>By supplying the ordered indices, we can easily sort the records by the given criterion:</p><pre class="programlisting">product_stats[order(size, decreasing = TRUE)] &#13;
##     id material size weight &#13;
## 1: T02    Metal  350   45.0 &#13;
## 2: T01    Metal  120   10.0 &#13;
## 3: M02 Plastics   85    3.0 &#13;
## 4: M01 Plastics   50     NA &#13;
## 5: M04     Wood   16    0.6 &#13;
## 6: M03     Wood   15     NA &#13;
</pre><p>Previously, we always created a new <code class="literal">data.table</code> package after subsetting. The <code class="literal">data.table</code> package also provides <code class="literal">:=</code> for in-place assignment of columns. For example, the original data of <code class="literal">product_stats</code> is shown as follows:</p><pre class="programlisting">product_stats &#13;
##     id material size weight &#13;
## 1: T01    Metal  120   10.0 &#13;
## 2: T02    Metal  350   45.0 &#13;
## 3: M01 Plastics   50     NA &#13;
## 4: M02 Plastics   85    3.0 &#13;
## 5: M03     Wood   15     NA &#13;
## 6: M04     Wood   16    0.6 &#13;
</pre><p>We will use <code class="literal">:=</code> to create a new column directly in <code class="literal">product_stats</code>:</p><pre class="programlisting">product_stats[, density := size / weight] &#13;
</pre><p>Nothing shows here, but the original <code class="literal">data.table</code> package is modified:</p><pre class="programlisting">product_stats &#13;
##     id material size weight   density &#13;
## 1: T01    Metal  120   10.0 12.000000 &#13;
## 2: T02    Metal  350   45.0  7.777778 &#13;
## 3: M01 Plastics   50     NA        NA &#13;
## 4: M02 Plastics   85    3.0 28.333333 &#13;
## 5: M03     Wood   15     NA        NA &#13;
## 6: M04     Wood   16    0.6 26.666667 &#13;
</pre><p>We can use <code class="literal">:=</code> to replace an existing column:</p><pre class="programlisting">product_info[, released := released == "yes"] &#13;
product_info &#13;
##     id      name  type   class released &#13;
## 1: T01    SupCar   toy vehicle     TRUE &#13;
## 2: T02  SupPlane   toy vehicle    FALSE &#13;
## 3: M01     JeepX model vehicle     TRUE &#13;
## 4: M02 AircraftX model vehicle     TRUE &#13;
## 5: M03    Runner model  people     TRUE &#13;
## 6: M04    Dancer model  people    FALSE &#13;
</pre><p>The <code class="literal">data.table</code> package provides <code class="literal">:=</code> mainly because in-place modification has a much higher performance since it avoids unnecessary copies of data.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec140"/>Using key to access rows</h2></div></div></div><p>Another distinct feature of <code class="literal">data.table</code> is the support of indexing, that is, we can create a key on <code class="literal">data.table</code>, so accessing records by key can be extremely efficient. For example, we will use <code class="literal">setkey()</code> to make <code class="literal">id</code> the key of <code class="literal">product_info</code>:</p><pre class="programlisting">setkey(product_info, id) &#13;
</pre><p>Note that the function behaves in a very different way from most R functions. It does not return a new copy of the data table but directly installs a key to the original input. The data frame, however, looks unchanged:</p><pre class="programlisting">product_info &#13;
##     id      name  type   class released &#13;
## 1: M01     JeepX model vehicle     TRUE &#13;
## 2: M02 AircraftX model vehicle     TRUE &#13;
## 3: M03    Runner model  people     TRUE &#13;
## 4: M04    Dancer model  people    FALSE &#13;
## 5: T01    SupCar   toy vehicle     TRUE &#13;
## 6: T02  SupPlane   toy vehicle    FALSE &#13;
</pre><p>Also, its key is created:</p><pre class="programlisting">key(product_info) &#13;
## [1] "id" &#13;
</pre><p>Now, we can use a key to access the records in <code class="literal">product_info</code>. For example, we can directly write a value of <code class="literal">id</code> to get the records with that <code class="literal">id</code>:</p><pre class="programlisting">product_info["M01"] &#13;
##     id  name  type   class released &#13;
## 1: M01 JeepX model vehicle     TRUE &#13;
</pre><p>If we use this with a <code class="literal">data.table</code> package without a key, an error occurs and reminds you to set a key:</p><pre class="programlisting">product_stats["M01"] &#13;
## Error in `[.data.table`(product_stats, "M01"): When i is a data.table (or character vector), x must be keyed (i.e. sorted, and, marked as sorted) so data.table knows which columns to join to and take advantage of x being sorted. Call setkey(x,...) first, see ?setkey. &#13;
</pre><p>We can also use <code class="literal">setkeyv()</code> to set key, but it only accepts a character vector:</p><pre class="programlisting">setkeyv(product_stats, "id") &#13;
</pre><p>This function is much easier to use if we have a dynamically determined vector to be the key. Now, we can use key to access <code class="literal">product_stats</code> too:</p><pre class="programlisting">product_stats["M02"] &#13;
##     id material size weight  density &#13;
## 1: M02 Plastics   85      3 28.33333 &#13;
</pre><p>If two tables have the same key, we can easily join them together:</p><pre class="programlisting">product_info[product_stats] &#13;
##     id      name  type   class released material size &#13;
## 1: M01     JeepX model vehicle     TRUE Plastics   50 &#13;
## 2: M02 AircraftX model vehicle     TRUE Plastics   85 &#13;
## 3: M03    Runner model  people     TRUE     Wood   15 &#13;
## 4: M04    Dancer model  people    FALSE     Wood   16 &#13;
## 5: T01    SupCar   toy vehicle     TRUE    Metal  120 &#13;
## 6: T02  SupPlane   toy vehicle    FALSE    Metal  350 &#13;
##    weight   density &#13;
## 1:     NA        NA &#13;
## 2:    3.0 28.333333 &#13;
## 3:     NA        NA &#13;
## 4:    0.6 26.666667 &#13;
## 5:   10.0 12.000000 &#13;
## 6:   45.0  7.777778 &#13;
</pre><p>The key of a <code class="literal">data.table</code> package can be more than one element. For example, to locate a record of <code class="literal">toy_tests</code>, we need to specify both <code class="literal">id</code> and <code class="literal">date</code>. In the following code, we will set a key of the two columns on <code class="literal">toy_tests</code>:</p><pre class="programlisting">setkey(toy_tests, id, date) &#13;
</pre><p>Now, we can get a row by supplying both elements in the key:</p><pre class="programlisting">toy_tests[.("T01", 20160201)] &#13;
##     id     date sample quality durability &#13;
## 1: T01 20160201    100       9          9 &#13;
</pre><p>If we only supply the first element, we would get a subset of the data with all records that match the first element:</p><pre class="programlisting">toy_tests["T01"] &#13;
##     id     date sample quality durability &#13;
## 1: T01 20160201    100       9          9 &#13;
## 2: T01 20160302    150      10          9 &#13;
## 3: T01 20160405    180       9         10 &#13;
## 4: T01 20160502    140       9          9 &#13;
</pre><p>However, if we only supply the second element, we can't get anything but an error. It is because the algorithm it behind requires the key to be ordered:</p><pre class="programlisting">toy_tests[.(20160201)] &#13;
## Error in bmerge(i, x, leftcols, rightcols, io, xo, roll, rollends, nomatch, : x.'id' is a character column being joined to i.'V1' which is type 'double'. Character columns must join to factor or character columns. &#13;
</pre><p>Also, we cannot get any data if we supply a key in a wrong order:</p><pre class="programlisting">toy_tests[.(20160201, "T01")] &#13;
## Error in bmerge(i, x, leftcols, rightcols, io, xo, roll, rollends, nomatch, : x.'id' is a character column being joined to i.'V1' which is type 'double'. Character columns must join to factor or character columns. &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec141"/>Summarizing data by groups</h2></div></div></div><p>Another important argument of subsetting a <code class="literal">data.table</code> is <code class="literal">by</code>, which is used to split the data into multiple parts, and for each part, evaluate the second argument. In this section, we'll demonstrate how the <code class="literal">by</code> syntax makes it much easier to summarize data by groups. For example, the simplest usage of <code class="literal">by</code> is counting the records in each group. In the following code, we will count the number of both released and unreleased products:</p><pre class="programlisting">product_info[, .N, by = released] &#13;
##    released N &#13;
## 1:     TRUE 4 &#13;
## 2:    FALSE 2 &#13;
</pre><p>The group can be defined by more than one variable. For example, a tuple of <code class="literal">type</code> and <code class="literal">class</code> can be a group, and for each group, we will count the number of records:</p><pre class="programlisting">product_info[, .N, by = .(type, class)] &#13;
##     type   class N &#13;
## 1: model vehicle 2 &#13;
## 2: model  people 2 &#13;
## 3:   toy vehicle 2 &#13;
</pre><p>We can also perform statistical calculations for each group. Here, we will compute the mean value of quality for both waterproof products and non-waterproof ones:</p><pre class="programlisting">product_tests[, mean(quality, na.rm = TRUE),  &#13;
  by = .(waterproof)] &#13;
##    waterproof    V1 &#13;
## 1:         no 10.00 &#13;
## 2:        yes  5.75 &#13;
</pre><p>Note that the mean values are stored in <code class="literal">V1</code> because we didn't supply a name for the column, so the package uses its default column names. To avoid that, we will use expression in form of <code class="literal">.(y = f(x))</code> instead:</p><pre class="programlisting">product_tests[, .(mean_quality = mean(quality, na.rm = TRUE)), &#13;
  by = .(waterproof)] &#13;
##    waterproof mean_quality &#13;
## 1:         no        10.00 &#13;
## 2:        yes         5.75 &#13;
</pre><p>We can chain multiple <code class="literal">[]</code> in turn. In the following example, we will first join <code class="literal">product_info</code> and <code class="literal">product_tests</code> by shared key <code class="literal">id</code> and then calculate the mean values of <code class="literal">quality</code> and <code class="literal">durability</code> for each group of <code class="literal">type</code> and <code class="literal">class</code> of released products:</p><pre class="programlisting">product_info[product_tests][released == TRUE, &#13;
  .(mean_quality = mean(quality, na.rm = TRUE), &#13;
    mean_durability = mean(durability, na.rm = TRUE)), &#13;
  by = .(type, class)] &#13;
##     type   class mean_quality mean_durability &#13;
## 1:   toy vehicle          NaN            10.0 &#13;
## 2: model vehicle            6             4.5 &#13;
## 3: model  people            5             NaN &#13;
</pre><p>Note that the values of <code class="literal">by</code> columns will be unique in the resulting <code class="literal">data.table</code>. We can use <code class="literal">keyby</code> instead of <code class="literal">by</code> to ensure it is automatically used as key by the resulted <code class="literal">data.table</code>:</p><pre class="programlisting">type_class_tests &lt;- product_info[product_tests][released == TRUE, &#13;
  .(mean_quality = mean(quality, na.rm = TRUE), &#13;
    mean_durability = mean(durability, na.rm = TRUE)), &#13;
  keyby = .(type, class)] &#13;
type_class_tests &#13;
##     type   class mean_quality mean_durability &#13;
## 1: model  people            5             NaN &#13;
## 2: model vehicle            6             4.5 &#13;
## 3:   toy vehicle          NaN            10.0 &#13;
key(type_class_tests) &#13;
## [1] "type"  "class" &#13;
</pre><p>Then, we can directly use a tuple of key values to access the records:</p><pre class="programlisting">type_class_tests[.("model", "vehicle"), mean_quality] &#13;
## [1] 6 &#13;
</pre><p>You can clearly see that using keys can be much more convenient than using logical comparisons when we try to find certain records in a table. However, its true advantage is not demonstrated yet because the data is not large enough. Using key to search records can be much faster than iterative logical comparison for large data, because searching by key takes advantage of binary search while iteration wastes a lot of time doing unnecessary computation.</p><p>Here is an example to make a contrast. First, we will create a data of 10 million rows with an index column <code class="literal">id</code> and two numeric columns filled with random numbers:</p><pre class="programlisting">n &lt;- 10000000 &#13;
test1 &lt;- data.frame(id = 1:n, x = rnorm(n), y = rnorm(n)) &#13;
</pre><p>Now, we want to see find a row of <code class="literal">id</code> being <code class="literal">8765432</code>. Let's see how long it takes:</p><pre class="programlisting">system.time(row &lt;- test1[test1$id == 876543, ]) &#13;
##    user  system elapsed  &#13;
##   0.156   0.036   0.192 &#13;
row &#13;
##            id          x        y &#13;
## 876543 876543 0.02300419 1.291588 &#13;
</pre><p>It seems no big deal, but suppose you need to frequently do this, say, hundreds of times per second, then your machine simply can't return a result in time.</p><p>Then, we will use <code class="literal">data.table</code> to do this. First, we will call <code class="literal">setDT()</code> to transform
 <code class="literal">data.frame</code> to <code class="literal">data.table</code>. This function performs some magic to transform the object in place, no copy made. When we use the <code class="literal">setDT()</code> function, we also provide a key <code class="literal">id</code> so that the resulted <code class="literal">data.table</code> has <code class="literal">id</code> as its keyed column:</p><pre class="programlisting">setDT(test1, key = "id") &#13;
class(test1) &#13;
## [1] "data.table" "data.frame" &#13;
</pre><p>Now, <code class="literal">test1</code> is transformed to <code class="literal">data.table</code>. Then, we will search the same element:</p><pre class="programlisting">system.time(row &lt;- test1[.(8765432)]) &#13;
##    user  system elapsed  &#13;
##   0.000   0.000   0.001 &#13;
row &#13;
##         id         x         y &#13;
## 1: 8765432 0.2532357 -2.121696 &#13;
</pre><p>The results are the same, but the time <code class="literal">data.table</code> takes is much shorter than <code class="literal">data.frame</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec142"/>Reshaping data.table</h2></div></div></div><p>Previously, you learned how to reshape a data frame with the <code class="literal">reshape2</code> package. The <code class="literal">data.table</code> package provides faster and more powerful implementations of <code class="literal">dcast</code> and <code class="literal">melt</code> for the <code class="literal">data.table</code> object.</p><p>For example, we will reshape <code class="literal">toy_tests</code> by aligning the quality scores of each product to year-month tuples:</p><pre class="programlisting">toy_tests[, ym := substr(date, 1, 6)] &#13;
toy_quality &lt;- dcast(toy_tests, ym ~ id, value.var = "quality") &#13;
toy_quality &#13;
##        ym T01 T02 &#13;
## 1: 201602   9   7 &#13;
## 2: 201603  10   8 &#13;
## 3: 201604   9   9 &#13;
## 4: 201605   9  10 &#13;
</pre><p>First, we used <code class="literal">:=</code> to create a new column <code class="literal">ym</code> directly in <code class="literal">toy_tests</code> and use <code class="literal">dcast</code> to transform it in the same way with the previous example of <code class="literal">reshape2</code>. The result looks the same with the output of <code class="literal">reshape2::dcast</code> for <code class="literal">data.frame</code>.</p><p>While <code class="literal">reshape2::dcast</code> does not support multi-value <code class="literal">value.var</code>, <code class="literal">data.table::dcast</code> works with multiple value variables, as shown here:</p><pre class="programlisting">toy_tests2 &lt;- dcast(toy_tests, ym ~ id, value.var = c("quality", "durability")) &#13;
toy_tests2 &#13;
##        ym quality_T01 quality_T02 durability_T01 &#13;
## 1: 201602           9           7              9 &#13;
## 2: 201603          10           8              9 &#13;
## 3: 201604           9           9             10 &#13;
## 4: 201605           9          10              9 &#13;
##    durability_T02 &#13;
## 1:              9 &#13;
## 2:              8 &#13;
## 3:              8 &#13;
## 4:              9 &#13;
</pre><p>The column names, except the first, are no longer values of <code class="literal">id</code> but are value variables with values of <code class="literal">id</code> concatenated by the underscore symbol. In addition, the key of the output <code class="literal">data.table</code> is automatically set to the variables that appear on the left-hand side of the reshaping formula 
<code class="literal">ym ~ id</code>:</p><pre class="programlisting">key(toy_tests2) &#13;
## [1] "ym" &#13;
</pre><p>The key implies that we can access the records directly by supplying a value of <code class="literal">ym</code>. However, the following code ends up with an error:</p><pre class="programlisting">toy_tests2[.(201602)] &#13;
## Error in bmerge(i, x, leftcols, rightcols, io, xo, roll, rollends, nomatch, : x.'ym' is a character column being joined to i.'V1' which is type 'double'. Character columns must join to factor or character columns. &#13;
</pre><p>There's something wrong with the data types. We can run the following code to see the class of each column:</p><pre class="programlisting">sapply(toy_tests2, class) &#13;
##             ym    quality_T01    quality_T02 durability_T01  &#13;
##    "character"      "integer"      "integer"      "integer"  &#13;
## durability_T02  &#13;
##      "integer" &#13;
</pre><p>The problem lies in the class of <code class="literal">ym:</code>. It is a character vector, but we supplied a key of numeric values. Therefore, the search fails with unmatched data types. If we supply a string, we can get the corresponding record:</p><pre class="programlisting">toy_tests2["201602"] &#13;
##        ym quality_T01 quality_T02 durability_T01 &#13;
## 1: 201602           9           7              9 &#13;
##    durability_T02 &#13;
## 1:              9 &#13;
</pre><p>But how did <code class="literal">ym</code> become a character vector in the first place? Recall <code class="literal">ym := substr(date, 1, 6)</code> where <code class="literal">date</code> is an integer vector, but <code class="literal">substr()</code> will coerce <code class="literal">date</code> to a character vector and then take out the first six characters. Therefore, it is natural that the result is a character vector. This is simply demonstrated as follows:</p><pre class="programlisting">class(20160101) &#13;
## [1] "numeric" &#13;
class(substr(20160101, 1, 6)) &#13;
## [1] "character" &#13;
</pre><p>The point here is that we need to be careful about the data types of the key columns.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec143"/>Using in-place set functions</h2></div></div></div><p>If we use <code class="literal">data.frame</code>, to change the names or the column order will cause copies of the data structure. In recent R versions, the copy is made fewer when we rename columns, but it is still hard to reorder the columns of a data frame without making a new copy. This should not be a problem when the data is small, but if the data is very large, the performance and memory pressure it imposes can really be an issue.</p><p>An enhanced version of <code class="literal">data.frame</code>, <code class="literal">data.table</code> provides a family of <code class="literal">set</code> functions with reference semantics, that is, they modify <code class="literal">data.table</code> in place and avoid unnecessary copying, thus exhibiting astonishing performance.</p><p>Take <code class="literal">product_stats</code> as an example. We can call <code class="literal">setDF()</code> to change <code class="literal">data.table</code> to <code class="literal">data.frame</code> in place without making copies:</p><pre class="programlisting">product_stats &#13;
##     id material size weight   density &#13;
## 1: M01 Plastics   50     NA        NA &#13;
## 2: M02 Plastics   85    3.0 28.333333 &#13;
## 3: M03     Wood   15     NA        NA &#13;
## 4: M04     Wood   16    0.6 26.666667 &#13;
## 5: T01    Metal  120   10.0 12.000000 &#13;
## 6: T02    Metal  350   45.0  7.777778 &#13;
setDF(product_stats) &#13;
class(product_stats) &#13;
## [1] "data.frame" &#13;
</pre><p>We can call <code class="literal">setDT()</code> to make any <code class="literal">data.frame</code> to <code class="literal">data.table</code> and set up a key if specified:</p><pre class="programlisting">setDT(product_stats, key = "id") &#13;
class(product_stats) &#13;
## [1] "data.table" "data.frame" &#13;
</pre><p>We can call <code class="literal">setnames</code> to change the name of the given columns to their new names:</p><pre class="programlisting">setnames(product_stats, "size", "volume") &#13;
product_stats &#13;
##     id material volume weight   density &#13;
## 1: M01 Plastics     50     NA        NA &#13;
## 2: M02 Plastics     85    3.0 28.333333 &#13;
## 3: M03     Wood     15     NA        NA &#13;
## 4: M04     Wood     16    0.6 26.666667 &#13;
## 5: T01    Metal    120   10.0 12.000000 &#13;
## 6: T02    Metal    350   45.0  7.777778 &#13;
</pre><p>If we add a new column, the column should appear as the last one. For example, we will add an index column for all rows using <code class="literal">.I</code> representing <code class="literal">1:.N</code>:</p><pre class="programlisting">product_stats[, i := .I] &#13;
product_stats &#13;
##     id material volume weight   density i &#13;
## 1: M01 Plastics     50     NA        NA 1 &#13;
## 2: M02 Plastics     85    3.0 28.333333 2 &#13;
## 3: M03     Wood     15     NA        NA 3 &#13;
## 4: M04     Wood     16    0.6 26.666667 4 &#13;
## 5: T01    Metal    120   10.0 12.000000 5 &#13;
## 6: T02    Metal    350   45.0  7.777778 6 &#13;
</pre><p>By convention, the index column should, in most cases, appear as the first column. We can supply a new order of column names to <code class="literal">setcolorder()</code> so that the columns are directly reordered without making copies:</p><pre class="programlisting">setcolorder(product_stats,  &#13;
  c("i", "id", "material", "weight", "volume", "density")) &#13;
product_stats &#13;
##    i  id material weight volume   density &#13;
## 1: 1 M01 Plastics     NA     50        NA &#13;
## 2: 2 M02 Plastics    3.0     85 28.333333 &#13;
## 3: 3 M03     Wood     NA     15        NA &#13;
## 4: 4 M04     Wood    0.6     16 26.666667 &#13;
## 5: 5 T01    Metal   10.0    120 12.000000 &#13;
## 6: 6 T02    Metal   45.0    350  7.777778 &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec144"/>Understanding dynamic scoping of data.table</h2></div></div></div><p>The most commonly used syntax of <code class="literal">data.table</code> is <code class="literal">data[i, j, by]</code>, where <code class="literal">i</code>, <code class="literal">j</code>, and <code class="literal">by</code> are all evaluated with dynamic scoping. In other words, we can use not only the columns directly, but also the predefined symbols such as <code class="literal">.N</code>, <code class="literal">.I</code>, and <code class="literal">.SD</code> to refer to important components of the data, as well as symbols and functions that can be accessed in the calling environment.</p><p>Before demonstrating this, we will create a new <code class="literal">data.table</code> named <code class="literal">market_data</code> with a consecutive column of <code class="literal">date</code>:</p><pre class="programlisting">market_data &lt;- data.table(date = as.Date("2015-05-01") + 0:299) &#13;
head(market_data) &#13;
##          date &#13;
## 1: 2015-05-01 &#13;
## 2: 2015-05-02 &#13;
## 3: 2015-05-03 &#13;
## 4: 2015-05-04 &#13;
## 5: 2015-05-05 &#13;
## 6: 2015-05-06 &#13;
</pre><p>Then, we will add two new columns to <code class="literal">market_data</code> by calling <code class="literal">:=</code> as a function:</p><pre class="programlisting">set.seed(123) &#13;
market_data[, `:=`( &#13;
  price = round(30 * cumprod(1 + rnorm(300, 0.001, 0.05)), 2), &#13;
  volume = rbinom(300, 5000, 0.8) &#13;
)] &#13;
</pre><p>Note that <code class="literal">price</code> is a simple random walk, and <code class="literal">volume</code> is randomly drawn from a binomial distribution:</p><pre class="programlisting">head(market_data) &#13;
##          date price volume &#13;
## 1: 2015-05-01 29.19   4021 &#13;
## 2: 2015-05-02 28.88   4000 &#13;
## 3: 2015-05-03 31.16   4033 &#13;
## 4: 2015-05-04 31.30   4036 &#13;
## 5: 2015-05-05 31.54   3995 &#13;
## 6: 2015-05-06 34.27   3955 &#13;
</pre><p>Then, we will plot the data:</p><pre class="programlisting">plot(price ~ date, data = market_data,  &#13;
  type = "l", &#13;
  main = "Market data") &#13;
</pre><p>The plot generated is shown as follows:</p><div><img src="img/image_12_003.jpg" alt="Understanding dynamic scoping of data.table"/></div><p>Once the data is ready, we can aggregate the data and see how dynamic scoping can be used to make things easier.</p><p>First, we will look at the range of the <code class="literal">date</code> column:</p><pre class="programlisting">market_data[, range(date)] &#13;
## [1] "2015-05-01" "2016-02-24" &#13;
</pre><p>The data can be reduced to monthly <strong>open-high-low-close</strong> (<strong>OHLC</strong>) data easily by group aggregate:</p><pre class="programlisting">monthly &lt;- market_data[,  &#13;
  .(open = price[[1]], high = max(price),  &#13;
    low = min(price), close = price[[.N]]), &#13;
  keyby = .(year = year(date), month = month(date))] &#13;
head(monthly) &#13;
##    year month  open  high   low close &#13;
## 1: 2015     5 29.19 37.71 26.15 28.44 &#13;
## 2: 2015     6 28.05 37.63 28.05 37.21 &#13;
## 3: 2015     7 36.32 40.99 32.13 40.99 &#13;
## 4: 2015     8 41.52 50.00 30.90 30.90 &#13;
## 5: 2015     9 30.54 34.46 22.89 27.02 &#13;
## 6: 2015    10 25.68 33.18 24.65 29.32 &#13;
</pre><p>In the <code class="literal">j</code> expression, we can generate an OHLC record with each <code class="literal">data.table</code> grouped by <code class="literal">year</code> and <code class="literal">month</code>. If the output of <code class="literal">j</code> is a <code class="literal">list</code>, or <code class="literal">data.frame</code>, or <code class="literal">data.table</code>, then the output will be stacked together to result in one <code class="literal">data.table</code>.</p><p>In fact, the <code class="literal">j</code> expression can be anything, even with <code class="literal">by</code> specified. More specifically, <code class="literal">j</code> is evaluated within the context of each <code class="literal">data.table</code> as a subset of the original data split by the value of the <code class="literal">by</code> expression. For example, the following code does not aggregate data by group, but plot a price chart for each year:</p><pre class="programlisting">oldpar &lt;- par(mfrow = c(1, 2)) &#13;
market_data[, { &#13;
  plot(price ~ date, type = "l", &#13;
    main = sprintf("Market data (%d)", year)) &#13;
}, by = .(year = year(date))] &#13;
par(oldpar) &#13;
</pre><p>The plot generated is shown as follows:</p><div><img src="img/image_12_004.jpg" alt="Understanding dynamic scoping of data.table"/></div><p>Note that we don't specify the <code class="literal">data</code> argument of <code class="literal">plot</code> because it is evaluated in the context of <code class="literal">market_data</code> grouped by <code class="literal">year</code> where <code class="literal">price</code> and <code class="literal">date</code> are already defined.</p><p>Moreover, the <code class="literal">j</code> expression can be model-fitting code. Here is an example of batch fitting of linear models. First, we will load <code class="literal">diamonds</code> data from the <code class="literal">ggplot2</code> package:</p><pre class="programlisting">data("diamonds", package = "ggplot2") &#13;
setDT(diamonds) &#13;
head(diamonds) &#13;
##    carat       cut color clarity depth table price    x &#13;
## 1:  0.23     Ideal     E     SI2  61.5    55   326 3.95 &#13;
## 2:  0.21   Premium     E     SI1  59.8    61   326 3.89 &#13;
## 3:  0.23      Good     E     VS1  56.9    65   327 4.05 &#13;
## 4:  0.29   Premium     I     VS2  62.4    58   334 4.20 &#13;
## 5:  0.31      Good     J     SI2  63.3    58   335 4.34 &#13;
## 6:  0.24 Very Good     J    VVS2  62.8    57   336 3.94 &#13;
##       y    z &#13;
## 1: 3.98 2.43 &#13;
## 2: 3.84 2.31 &#13;
## 3: 4.07 2.31 &#13;
## 4: 4.23 2.63 &#13;
## 5: 4.35 2.75 &#13;
## 6: 3.96 2.48 &#13;
</pre><p>The data contains 53940 records of diamonds with 10 properties. Here, we will fit linear regression models on each group of <code class="literal">cut</code> to see how <code class="literal">carat</code> and <code class="literal">depth</code> may provide some information of <code class="literal">log(price)</code> in each group.</p><p>In the following code, the <code class="literal">j</code> expression involves fitting a linear model and coercing its coefficients into a list. Note that the <code class="literal">j</code> expression is evaluated for each value of the <code class="literal">keyby</code> expression. Since a list is returned, the estimated linear coefficients for each group will be stacked as one <code class="literal">data.table</code> is shown as follows:</p><pre class="programlisting">diamonds[, { &#13;
  m &lt;- lm(log(price) ~ carat + depth) &#13;
  as.list(coef(m)) &#13;
}, keyby = .(cut)] &#13;
##          cut (Intercept)    carat        depth &#13;
## 1:      Fair    7.730010 1.264588 -0.014982439 &#13;
## 2:      Good    7.077469 1.973600 -0.014601101 &#13;
## 3: Very Good    6.293642 2.087957 -0.002890208 &#13;
## 4:   Premium    5.934310 1.852778  0.005939651 &#13;
## 5:     Ideal    8.495409 2.125605 -0.038080022 &#13;
</pre><p>Dynamic scoping also allows us to combine the use of symbols that are predefined, inside or outside <code class="literal">data.table</code>. For example, we can define a function to calculate the annual average values of a user-defined column of <code class="literal">market_data</code>:</p><pre class="programlisting">average &lt;- function(column) { &#13;
  market_data[, .(average = mean(.SD[[column]])), &#13;
    by = .(year = year(date))] &#13;
} &#13;
</pre><p>In the preceding <code class="literal">j</code> expression, <code class="literal">.SD</code> means the grouped <code class="literal">data.table</code> for each value of <code class="literal">year</code>. We can use <code class="literal">.SD[[x]]</code> to extract the values of column <code class="literal">x</code>, just like extracting an element by name from a list.</p><p>Then, we can run the following code to calculate the average prices for each year:</p><pre class="programlisting">average("price") &#13;
##    year  average &#13;
## 1: 2015 32.32531 &#13;
## 2: 2016 32.38364 &#13;
</pre><p>We will just change the argument to <code class="literal">volume</code> to calculate the average volumes for each year:</p><pre class="programlisting">average("volume") &#13;
##    year  average &#13;
## 1: 2015 3999.931 &#13;
## 2: 2016 4003.382 &#13;
</pre><p>Also, we can use a specially invented syntax to create a dynamic number of columns with dynamically determined names.</p><p>Suppose we add three new alternative price columns, each adds some random noise to the original <code class="literal">price</code> values. Instead of repeat calling <code class="literal">market_data[, price1 := ...]</code> and <code class="literal">market_data[, price2 := ...]</code>, we can use <code class="literal">market_data[, (columns) := list(...)]</code> to set columns dynamically, where <code class="literal">columns</code> is a character vector of column names and <code class="literal">list(...)</code> is the values for each corresponding column in <code class="literal">columns</code>:</p><pre class="programlisting">price_cols &lt;- paste0("price", 1:3) &#13;
market_data[, (price_cols) := lapply(1:3,  &#13;
  function(i) round(price + rnorm(.N, 0, 5), 2))] &#13;
head(market_data) &#13;
##          date price volume price1 price2 price3 &#13;
## 1: 2015-05-01 29.19   4021  30.55  27.39  33.22 &#13;
## 2: 2015-05-02 28.88   4000  29.67  20.45  36.00 &#13;
## 3: 2015-05-03 31.16   4033  34.31  26.94  27.24 &#13;
## 4: 2015-05-04 31.30   4036  29.32  29.01  28.04 &#13;
## 5: 2015-05-05 31.54   3995  36.04  32.06  34.79 &#13;
## 6: 2015-05-06 34.27   3955  30.12  30.96  35.19 &#13;
</pre><p>On the other hand, if we get a table with many columns and we need to perform some computation on a subset of them, we can also use similar syntax to solve the problem. Imagine that the price-related columns may have missing values. We need to perform <code class="literal">zoo::na.locf()</code> on each price column. First, we will use regular expression to get all the price columns:</p><pre class="programlisting">cols &lt;- colnames(market_data) &#13;
price_cols &lt;- cols[grep("^price", cols)] &#13;
price_cols &#13;
## [1] "price"  "price1" "price2" "price3" &#13;
</pre><p>Then, we will use similar syntax but add an additional argument, <code class="literal">.SDcols = price_cols</code>, in order to limit the columns of <code class="literal">.SD</code> to be only the price columns we get. The following code calls <code class="literal">zoo::na.locf()</code> on each price column, and the old values of each column are replaced:</p><pre class="programlisting">market_data[, (price_cols) := lapply(.SD, zoo::na.locf), &#13;
  .SDcols = price_cols] &#13;
</pre><p>In this section, we have demonstrated the usage of <code class="literal">data.table</code> and how it makes data manipulation much easier. To see the full feature list of <code class="literal">data.table</code>, visit
 <a class="ulink" href="https://github.com/Rdatatable/data.table/wiki">https://github.com/Rdatatable/data.table/wiki</a>. To quickly review the usage, go through the data table cheat sheet (<a class="ulink" href="https://www.datacamp.com/community/tutorials/data-table-cheat-sheet">https://www.datacamp.com/community/tutorials/data-table-cheat-sheet</a>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec64"/>Using dplyr pipelines to manipulate data frames</h1></div></div></div><p>Another popular package is <code class="literal">dplyr</code>, which invents a grammar of data manipulation. Instead of using the subset function (<code class="literal">[]</code>), <code class="literal">dplyr</code> defines a set of basic <code class="literal">erb</code> functions as the building blocks of data operations and imports a pipeline operator to chain these functions to perform complex multistep tasks.</p><p>Run the following code to install <code class="literal">dplyr</code> from CRAN if you don't have it yet:</p><pre class="programlisting">install.packages("dplyr") &#13;
</pre><p>First, we will reload the product tables again to reset all data to their original forms:</p><pre class="programlisting">library(readr) &#13;
product_info &lt;- read_csv("data/product-info.csv") &#13;
product_stats &lt;- read_csv("data/product-stats.csv") &#13;
product_tests &lt;- read_csv("data/product-tests.csv") &#13;
toy_tests &lt;- read_csv("data/product-toy-tests.csv") &#13;
</pre><p>Then, we will load the <code class="literal">dplyr</code> package:</p><pre class="programlisting">library(dplyr) &#13;
##  &#13;
## Attaching package: 'dplyr' &#13;
## The following objects are masked from 'package:data.table': &#13;
##  &#13;
##     between, last &#13;
## The following objects are masked from 'package:stats': &#13;
##  &#13;
##     filter, lag &#13;
## The following objects are masked from 'package:base': &#13;
##  &#13;
##     intersect, setdiff, setequal, union &#13;
</pre><p>The following output indicates that <code class="literal">dplyr</code> generalizes a number of built-in functions, so they are masked after the package is attached.</p><p>Now, we can start to play with the verb functions it provides. First, we will use <code class="literal">select</code> to select columns from the provided data frame by creating a new table with the given columns:</p><pre class="programlisting">select(product_info, id, name, type, class) &#13;
## Source: local data frame [6 x 4] &#13;
##  &#13;
##      id      name  type   class &#13;
##   (chr)     (chr) (chr)   (chr) &#13;
## 1   T01    SupCar   toy vehicle &#13;
## 2   T02  SupPlane   toy vehicle &#13;
## 3   M01     JeepX model vehicle &#13;
## 4   M02 AircraftX model vehicle &#13;
## 5   M03    Runner model  people &#13;
## 6   M04    Dancer model  people &#13;
</pre><p>The printing of the preceding table is a bit different from the way both <code class="literal">data.frame</code> and <code class="literal">data.table</code> are printed. It not only shows the table itself, but also includes a header indicating the size of the data frame and the data types of each column.</p><p>It is clear that <code class="literal">select()</code> uses non-standard evaluation that allows us to directly use column names of the given data frame as arguments. It works in a way similar to how <code class="literal">subset()</code>, <code class="literal">transform()</code>, and <code class="literal">with()</code> work.</p><p>We can use <code class="literal">filter</code> to filter the data frame by logical condition, which is also evaluated in the context of the data frame:</p><pre class="programlisting">filter(product_info, released == "yes") &#13;
## Source: local data frame [4 x 5] &#13;
##  &#13;
##      id      name  type   class released &#13;
##   (chr)     (chr) (chr)   (chr)    (chr) &#13;
## 1   T01    SupCar   toy vehicle      yes &#13;
## 2   M01     JeepX model vehicle      yes &#13;
## 3   M02 AircraftX model vehicle      yes &#13;
## 4   M03    Runner model  people      yes &#13;
</pre><p>If we want to filter records with multiple conditions, we only need to write each condition as an argument of <code class="literal">filter()</code>:</p><pre class="programlisting">filter(product_info, &#13;
  released == "yes", type == "model") &#13;
## Source: local data frame [3 x 5] &#13;
##  &#13;
##      id      name  type   class released &#13;
##   (chr)     (chr) (chr)   (chr)    (chr) &#13;
## 1   M01     JeepX model vehicle      yes &#13;
## 2   M02 AircraftX model vehicle      yes &#13;
## 3   M03    Runner model  people      yes &#13;
</pre><p>The <code class="literal">mutate</code> function is used to create a new data frame with new columns added or existing columns replaced, like <code class="literal">transform</code>, but also supports in-place assignment, <code class="literal">:=</code>, if the provided data is a <code class="literal">data.table</code>:</p><pre class="programlisting">mutate(product_stats, density = size / weight) &#13;
## Source: local data frame [6 x 5] &#13;
##  &#13;
##      id material  size weight   density &#13;
##   (chr)    (chr) (int)  (dbl)     (dbl) &#13;
## 1   T01    Metal   120   10.0 12.000000 &#13;
## 2   T02    Metal   350   45.0  7.777778 &#13;
## 3   M01 Plastics    50     NA        NA &#13;
## 4   M02 Plastics    85    3.0 28.333333 &#13;
## 5   M03     Wood    15     NA        NA &#13;
## 6   M04     Wood    16    0.6 26.666667 &#13;
</pre><p>The <code class="literal">arrange</code> function is used to create a new data frame sorted by one or more columns. The <code class="literal">desc()</code> function indicates the descending order:</p><pre class="programlisting">arrange(product_stats, material, desc(size), desc(weight)) &#13;
## Source: local data frame [6 x 4] &#13;
##  &#13;
##      id material  size weight &#13;
##   (chr)    (chr) (int)  (dbl) &#13;
## 1   T02    Metal   350   45.0 &#13;
## 2   T01    Metal   120   10.0 &#13;
## 3   M02 Plastics    85    3.0 &#13;
## 4   M01 Plastics    50     NA &#13;
## 5   M04     Wood    16    0.6 &#13;
## 6   M03     Wood    15     NA &#13;
</pre><p>The <code class="literal">dplyr</code> function provides a rich set of join operations, including
 <code class="literal">inner_join</code>, <code class="literal">left_join</code>, <code class="literal">right_join</code>, <code class="literal">full_join</code>, <code class="literal">semi_join</code>, and <code class="literal">anti_join</code>. If two tables to join have records that do not match, these join operations may behave very differently. For <code class="literal">product_info</code> and <code class="literal">product_tests</code>, the records match exactly, so <code class="literal">left_join</code> should return the same results as <code class="literal">merge</code>:</p><pre class="programlisting">product_info_tests &lt;- left_join(product_info, product_tests, by = "id") &#13;
product_info_tests &#13;
## Source: local data frame [6 x 8] &#13;
##  &#13;
##      id      name  type   class released quality durability &#13;
##   (chr)     (chr) (chr)   (chr)    (chr)   (int)      (int) &#13;
## 1   T01    SupCar   toy vehicle      yes      NA         10 &#13;
## 2   T02  SupPlane   toy vehicle       no      10          9 &#13;
## 3   M01     JeepX model vehicle      yes       6          4 &#13;
## 4   M02 AircraftX model vehicle      yes       6          5 &#13;
## 5   M03    Runner model  people      yes       5         NA &#13;
## 6   M04    Dancer model  people       no       6          6 &#13;
## Variables not shown: waterproof (chr) &#13;
</pre><p>To know more about the difference between those join operations, run <code class="literal">?dplyr::join</code>.</p><p>To summarize the data by groups, we need to first create a grouped table by <code class="literal">group_by()</code>. Then, we will use <code class="literal">summarize()</code> to aggregate the data. For example, we will
divide <code class="literal">product_info_tests</code> with <code class="literal">type</code> and <code class="literal">class</code>, and then for each type class group, we will calculate the average values of <code class="literal">quality</code> and <code class="literal">durability</code>:</p><pre class="programlisting">summarize(group_by(product_info_tests, type, class), &#13;
  mean_quality = mean(quality, na.rm = TRUE), &#13;
  mean_durability = mean(durability, na.rm = TRUE)) &#13;
## Source: local data frame [3 x 4] &#13;
## Groups: type [?] &#13;
##  &#13;
##    type   class mean_quality mean_durability &#13;
##   (chr)   (chr)        (dbl)           (dbl) &#13;
## 1 model  people          5.5             6.0 &#13;
## 2 model vehicle          6.0             4.5 &#13;
## 3   toy vehicle         10.0             9.5 &#13;
</pre><p>From the preceding code examples, you learned the verb functions <code class="literal">select()</code>, <code class="literal">filter()</code>, <code class="literal">mutate()</code>, <code class="literal">arrange()</code>, <code class="literal">group_by()</code>, and <code class="literal">summarize()</code>. Each of them is designed to do a small thing, but together they can perform comprehensive data operations when properly composed. Apart from these functions, <code class="literal">dplyr</code> imports the pipeline operator <code class="literal">%&gt;%</code> from the <code class="literal">magrittr</code> package to compose functions into pipelines.</p><p>Suppose we have <code class="literal">product_info</code> and <code class="literal">product_tests</code>. We need to analyze the released product by computing the average values of quality and durability for each type class group, and present the summary data in descending order of the average quality. This can be done nicely with the <code class="literal">dplyr</code> verb functions composed by the pipeline operator:</p><pre class="programlisting">product_info %&gt;% &#13;
  filter(released == "yes") %&gt;% &#13;
  inner_join(product_tests, by = "id") %&gt;% &#13;
  group_by(type, class) %&gt;% &#13;
  summarize( &#13;
    mean_quality = mean(quality, na.rm = TRUE), &#13;
    mean_durability = mean(durability, na.rm = TRUE)) %&gt;% &#13;
  arrange(desc(mean_quality)) &#13;
## Source: local data frame [3 x 4] &#13;
## Groups: type [2] &#13;
##  &#13;
##    type   class mean_quality mean_durability &#13;
##   (chr)   (chr)        (dbl)           (dbl) &#13;
## 1 model vehicle            6             4.5 &#13;
## 2 model  people            5             NaN &#13;
## 3   toy vehicle          NaN            10.0 &#13;
</pre><p>But how does <code class="literal">%&gt;%</code> work? The pipeline operator basically does only one thing: put the result on the left-hand side of the first argument of the function call on the right-hand side, that is,
<code class="literal">x %&gt;% f(...)</code> will be basically evaluated as <code class="literal">f(x, ...)</code>. Since <code class="literal">%&gt;%</code> is a package-defined binary operator, it allows us to chain function calls to either avoid redundant intermediate values or decompose nested calls.</p><p>Suppose we need to transform <code class="literal">d0</code> to <code class="literal">d3</code> through three steps. In each step, we need to call a function with the previous result and an argument. If we manipulate data like this, there will be many intermediate results, and sometimes, it consumes a lot of memory when the data is large:</p><pre class="programlisting">d1 &lt;- f1(d0, arg1) &#13;
d2 &lt;- f2(d1, arg2) &#13;
d3 &lt;- f3(d2, arg3) &#13;
</pre><p>If we want to avoid intermediate results, we'll have to write nested calls. This task does not look straightforward at all, especially when there are numerous arguments in each function call:</p><pre class="programlisting">f3(f2(f1(d0, arg1), arg2), arg3) &#13;
</pre><p>Using the pipeline operator, the workflow can be rearranged as follows:</p><pre class="programlisting">d0 %&gt;% &#13;
  f1(arg1) %&gt;% &#13;
  f2(arg2) %&gt;% &#13;
  f3(arg3) &#13;
</pre><p>The code looks much cleaner and straightforward. The whole expression not only looks like a pipeline but also works like a pipeline. The <code class="literal">d0 %&gt;% f1(arg1)</code> equation is evaluated as <code class="literal">f1(d0, arg1)</code>, which is sent to <code class="literal">f2(., arg2)</code>, which is sent to <code class="literal">f3(., arg3)</code>. The output of each step becomes the input of the next step.</p><p>Therefore, the pipeline operator not only works with <code class="literal">dplyr</code> functions, but also works with all other functions. Suppose we want to make a density plot of the diamond prices:</p><pre class="programlisting">data(diamonds, package = "ggplot2") &#13;
plot(density(diamonds$price, from = 0), &#13;
  main = "Density plot of diamond prices") &#13;
</pre><p>The plot generated is shown as follows:</p><div><img src="img/image_12_005.jpg" alt="Using dplyr pipelines to manipulate data frames"/></div><p>Using the pipeline operator, we can rewrite code as follows:</p><pre class="programlisting">diamonds$price %&gt;% &#13;
  density(from = 0) %&gt;% &#13;
  plot(main = "Density plot of diamonds prices") &#13;
</pre><p>Like <code class="literal">data.table</code>, <code class="literal">dplyr</code> also supplies <code class="literal">do()</code> to perform arbitrary operation on each group of data. For example, we can group <code class="literal">diamonds</code> by <code class="literal">cut</code>, and for each group, we can fit a linear model of <code class="literal">log(price) ~ carat</code>. Different from <code class="literal">data.table</code>, we need to specify the names of such operations so that the results can be stored as columns. Also, the expression in <code class="literal">do()</code> is not directly evaluated in the context of the grouped data. Instead, we need to use <code class="literal">.</code> to represent the data:</p><pre class="programlisting">models &lt;- diamonds %&gt;% &#13;
  group_by(cut) %&gt;% &#13;
  do(lmod = lm(log(price) ~ carat, data = .)) &#13;
models &#13;
## Source: local data frame [5 x 2] &#13;
## Groups: &lt;by row&gt; &#13;
##  &#13;
##         cut    lmod &#13;
##      (fctr)   (chr) &#13;
## 1      Fair &lt;S3:lm&gt; &#13;
## 2      Good &lt;S3:lm&gt; &#13;
## 3 Very Good &lt;S3:lm&gt; &#13;
## 4   Premium &lt;S3:lm&gt; &#13;
## 5     Ideal &lt;S3:lm&gt; &#13;
</pre><p>Note that a new column <code class="literal">lmod</code> is created. It is not a typical data column of atomic vectors. Rather, it is a list of linear model objects, that is, the model for each value of <code class="literal">cut</code> is stored in the list-typed column <code class="literal">lmod</code>. We can access each model using an index:</p><pre class="programlisting">models$lmod[[1]] &#13;
##  &#13;
## Call: &#13;
## lm(formula = log(price) ~ carat, data = .) &#13;
##  &#13;
## Coefficients: &#13;
## (Intercept)        carat   &#13;
##       6.785        1.251 &#13;
</pre><p>The <code class="literal">do()</code> function can be very helpful to perform highly customized operations. For example, suppose we need to analyze <code class="literal">toy_tests</code> data by summarizing the quality and durability for each product. Consider what we should do if, we only need the top three test records with most samples, and the quality and durability of each product should be a weighted average of the measure and the sample.</p><p>Using <code class="literal">dplyr</code> functions and pipeline, the preceding task can be easily done with the following code:</p><pre class="programlisting">toy_tests %&gt;% &#13;
  group_by(id) %&gt;% &#13;
  arrange(desc(sample)) %&gt;% &#13;
  do(head(., 3)) %&gt;% &#13;
  summarize( &#13;
    quality = sum(quality * sample) / sum(sample),  &#13;
    durability = sum(durability * sample) / sum(sample)) &#13;
## Source: local data frame [2 x 3] &#13;
##  &#13;
##      id  quality durability &#13;
##   (chr)    (dbl)      (dbl) &#13;
## 1   T01 9.319149   9.382979 &#13;
## 2   T02 9.040000   8.340000 &#13;
</pre><p>Note that when the data is grouped, all subsequent operations are performed by group. To see the intermediate result, we will run the code before <code class="literal">do(head(., 3))</code>:</p><pre class="programlisting">toy_tests %&gt;% &#13;
  group_by(id) %&gt;% &#13;
  arrange(desc(sample)) &#13;
## Source: local data frame [8 x 5] &#13;
## Groups: id [2] &#13;
##  &#13;
##      id     date sample quality durability &#13;
##   (chr)    (int)  (int)   (int)      (int) &#13;
## 1   T01 20160405    180       9         10 &#13;
## 2   T01 20160302    150      10          9 &#13;
## 3   T01 20160502    140       9          9 &#13;
## 4   T01 20160201    100       9          9 &#13;
## 5   T02 20160403     90       9          8 &#13;
## 6   T02 20160502     85      10          9 &#13;
## 7   T02 20160303     75       8          8 &#13;
## 8   T02 20160201     70       7          9 &#13;
</pre><p>We get all records sorted by <code class="literal">sample</code> in descending order. Then, <code class="literal">do(head(., 3))</code> will evaluate <code class="literal">head(., 3)</code> for each group where <code class="literal">.</code> represents the data in the group:</p><pre class="programlisting">toy_tests %&gt;% &#13;
  group_by(id) %&gt;% &#13;
  arrange(desc(sample)) %&gt;% &#13;
  do(head(., 3)) &#13;
## Source: local data frame [6 x 5] &#13;
## Groups: id [2] &#13;
##  &#13;
##      id     date sample quality durability &#13;
##   (chr)    (int)  (int)   (int)      (int) &#13;
## 1   T01 20160405    180       9         10 &#13;
## 2   T01 20160302    150      10          9 &#13;
## 3   T01 20160502    140       9          9 &#13;
## 4   T02 20160403     90       9          8 &#13;
## 5   T02 20160502     85      10          9 &#13;
## 6   T02 20160303     75       8          8 &#13;
</pre><p>Now, we will get the top three records with most samples. It is handy to summarize the data as supposed.</p><p>The <code class="literal">dplyr</code> function defines a very intuitive grammar of data manipulation and provides high-performance verb functions that are designed for use in pipeline. To learn more, I recommend that you read the package vignettes (<a class="ulink" href="https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html">https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html</a>) and visit the interactive tutorial (<a class="ulink" href="https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial">https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial</a>) at DataCamp.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec65"/>Using rlist to work with nested data structures</h1></div></div></div><p>In the previous chapter, you learned about both relational databases that store data in tables and non-relational databases that support nested data structures. In R, the most commonly used nested data structure is a list object. All previous sections focus on manipulating tabular data. In this section, let's play with the <code class="literal">rlist</code> package I developed, which is designed for manipulating non-tabular data.</p><p>The design of <code class="literal">rlist</code> is very similar to <code class="literal">dplyr</code>. It provides mapping, filtering, selecting, sorting, grouping, and aggregating functionality for list objects. Run the following code to install the <code class="literal">rlist</code> package from CRAN:</p><pre class="programlisting">install.packages("rlist") &#13;
</pre><p>We have the non-tabular version of the product data stored in <code class="literal">data/products.json</code>. In this file, each product has a JSON representation as follows:</p><pre class="programlisting">{ &#13;
    "id": "T01", &#13;
    "name": "SupCar", &#13;
    "type": "toy", &#13;
    "class": "vehicle", &#13;
    "released": true, &#13;
    "stats": { &#13;
      "material": "Metal", &#13;
      "size": 120, &#13;
      "weight": 10 &#13;
    }, &#13;
    "tests": { &#13;
      "quality": null, &#13;
      "durability": 10, &#13;
      "waterproof": false &#13;
    }, &#13;
    "scores": [8, 9, 10, 10, 6, 5] &#13;
  } &#13;
</pre><p>All products are stored in an JSON array like <code class="literal">[ {...}, {...} ]</code>. Instead of storing data in different tables, we put everything relating to a product in one object. To work with data in this format, we can use <code class="literal">rlist</code> functions. First, let's load the <code class="literal">rlist</code> package:</p><pre class="programlisting">library(rlist) &#13;
</pre><p>To load the data into R as a list, we can use <code class="literal">jsonlite::fromJSON()</code> or simply <code class="literal">list.load()</code> provided by <code class="literal">rlist</code>:</p><pre class="programlisting">products &lt;- list.load("data/products.json") &#13;
str(products[[1]]) &#13;
## List of 8 &#13;
##  $ id      : chr "T01" &#13;
##  $ name    : chr "SupCar" &#13;
##  $ type    : chr "toy" &#13;
##  $ class   : chr "vehicle" &#13;
##  $ released: logi TRUE &#13;
##  $ stats   :List of 3 &#13;
##   ..$ material: chr "Metal" &#13;
##   ..$ size    : int 120 &#13;
##   ..$ weight  : int 10 &#13;
##  $ tests   :List of 3 &#13;
##   ..$ quality   : NULL &#13;
##   ..$ durability: int 10 &#13;
##   ..$ waterproof: logi FALSE &#13;
##  $ scores  : int [1:6] 8 9 10 10 6 5 &#13;
</pre><p>Now, <code class="literal">products</code> contains the information of all products. Each element of <code class="literal">products</code> represents a product with all related information.</p><p>To evaluate an expression within the context of each element, we can call <code class="literal">list.map()</code>:</p><pre class="programlisting">str(list.map(products, id)) &#13;
## List of 6 &#13;
##  $ : chr "T01" &#13;
##  $ : chr "T02" &#13;
##  $ : chr "M01" &#13;
##  $ : chr "M02" &#13;
##  $ : chr "M03" &#13;
##  $ : chr "M04" &#13;
</pre><p>It iteratively evaluates <code class="literal">id</code> on each element of <code class="literal">products</code> and returns a new list containing all the corresponding results. The <code class="literal">list.mapv()</code> function simplifies the list and only returns a vector:</p><pre class="programlisting">list.mapv(products, name) &#13;
## [1] "SupCar"    "SupPlane"  "JeepX"     "AircraftX" &#13;
## [5] "Runner"    "Dancer" &#13;
</pre><p>To filter <code class="literal">products</code>, we can call <code class="literal">list.filter()</code> with logical conditions. All elements of <code class="literal">products</code> for which the conditions yield <code class="literal">TRUE</code> will be picked out:</p><pre class="programlisting">released_products &lt;- list.filter(products, released) &#13;
list.mapv(released_products, name) &#13;
## [1] "SupCar"    "JeepX"     "AircraftX" "Runner" &#13;
</pre><p>Note that <code class="literal">rlist</code> functions have design similar to <code class="literal">dplyr</code> functions, that is, the input data is always the first argument. We can, thus, use a pipeline operator to pipe the results forward:</p><pre class="programlisting">products %&gt;% &#13;
  list.filter(released) %&gt;% &#13;
  list.mapv(name) &#13;
## [1] "SupCar"    "JeepX"     "AircraftX" "Runner" &#13;
</pre><p>We can use <code class="literal">list.select()</code> to select the given fields of each element of the input list:</p><pre class="programlisting">products %&gt;% &#13;
  list.filter(released, tests$waterproof) %&gt;% &#13;
  list.select(id, name, scores) %&gt;% &#13;
  str() &#13;
## List of 3 &#13;
##  $ :List of 3 &#13;
##   ..$ id    : chr "M01" &#13;
##   ..$ name  : chr "JeepX" &#13;
##   ..$ scores: int [1:6] 6 8 7 9 8 6 &#13;
##  $ :List of 3 &#13;
##   ..$ id    : chr "M02" &#13;
##   ..$ name  : chr "AircraftX" &#13;
##   ..$ scores: int [1:7] 9 9 10 8 10 7 9 &#13;
##  $ :List of 3 &#13;
##   ..$ id    : chr "M03" &#13;
##   ..$ name  : chr "Runner" &#13;
##   ..$ scores: int [1:10] 6 7 5 6 5 8 10 9 8 9 &#13;
</pre><p>Alternatively, we can make new fields in <code class="literal">list.select()</code> based on the existing fields:</p><pre class="programlisting">products %&gt;% &#13;
  list.filter(mean(scores) &gt;= 8) %&gt;% &#13;
  list.select(name, scores, mean_score = mean(scores)) %&gt;% &#13;
  str() &#13;
## List of 3 &#13;
##  $ :List of 3 &#13;
##   ..$ name      : chr "SupCar" &#13;
##   ..$ scores    : int [1:6] 8 9 10 10 6 5 &#13;
##   ..$ mean_score: num 8 &#13;
##  $ :List of 3 &#13;
##   ..$ name      : chr "SupPlane" &#13;
##   ..$ scores    : int [1:5] 9 9 10 10 10 &#13;
##   ..$ mean_score: num 9.6 &#13;
##  $ :List of 3 &#13;
##   ..$ name      : chr "AircraftX" &#13;
##   ..$ scores    : int [1:7] 9 9 10 8 10 7 9 &#13;
##   ..$ mean_score: num 8.86 &#13;
</pre><p>We can also sort the list elements by certain fields or values using <code class="literal">list.sort()</code> and stack all elements into a data frame using <code class="literal">list.stack()</code>:</p><pre class="programlisting">products %&gt;% &#13;
  list.select(name, mean_score = mean(scores)) %&gt;% &#13;
  list.sort(-mean_score) %&gt;% &#13;
  list.stack() &#13;
##        name mean_score &#13;
## 1  SupPlane   9.600000 &#13;
## 2 AircraftX   8.857143 &#13;
## 3    SupCar   8.000000 &#13;
## 4    Dancer   7.833333 &#13;
## 5     JeepX   7.333333 &#13;
## 6    Runner   7.300000 &#13;
</pre><p>To group a list, we will call <code class="literal">list.group()</code> to make a nested list in which all elements are divided by the values of the field:</p><pre class="programlisting">products %&gt;% &#13;
  list.select(name, type, released) %&gt;% &#13;
  list.group(type) %&gt;% &#13;
  str() &#13;
## List of 2 &#13;
##  $ model:List of 4 &#13;
##   ..$ :List of 3 &#13;
##   .. ..$ name    : chr "JeepX" &#13;
##   .. ..$ type    : chr "model" &#13;
##   .. ..$ released: logi TRUE &#13;
##   ..$ :List of 3 &#13;
##   .. ..$ name    : chr "AircraftX" &#13;
##   .. ..$ type    : chr "model" &#13;
##   .. ..$ released: logi TRUE &#13;
##   ..$ :List of 3 &#13;
##   .. ..$ name    : chr "Runner" &#13;
##   .. ..$ type    : chr "model" &#13;
##   .. ..$ released: logi TRUE &#13;
##   ..$ :List of 3 &#13;
##   .. ..$ name    : chr "Dancer" &#13;
##   .. ..$ type    : chr "model" &#13;
##   .. ..$ released: logi FALSE &#13;
##  $ toy  :List of 2 &#13;
##   ..$ :List of 3 &#13;
##   .. ..$ name    : chr "SupCar" &#13;
##   .. ..$ type    : chr "toy" &#13;
##   .. ..$ released: logi TRUE &#13;
##   ..$ :List of 3 &#13;
##   .. ..$ name    : chr "SupPlane" &#13;
##   .. ..$ type    : chr "toy" &#13;
##   .. ..$ released: logi FALSE &#13;
</pre><p>The <code class="literal">rlist</code> function also provides many other functions that try to make non-tabular data manipulation easier. For example, <code class="literal">list.table()</code> enhances <code class="literal">table()</code> to directly work with a list of elements:</p><pre class="programlisting">products %&gt;% &#13;
  list.table(type, class) &#13;
##        class &#13;
## type    people vehicle &#13;
##   model      2       2 &#13;
##   toy        0       2 &#13;
</pre><p>It also supports multi-dimensional tables by evaluating each argument in the context of the input list:</p><pre class="programlisting">products %&gt;% &#13;
  list.filter(released) %&gt;% &#13;
  list.table(type, waterproof = tests$waterproof) &#13;
##        waterproof &#13;
## type    FALSE TRUE &#13;
##   model     0    3 &#13;
##   toy       1    0 &#13;
</pre><p>Although the storage of data is non-tabular, we can easily perform comprehensive data manipulation and get the results presented in the tabular form. For example, suppose we need to compute the mean score and number of scores of the top two products with the highest mean scores but also with at least five scores.</p><p>We can decompose such a task into smaller data manipulation subtasks, which can be easily done by <code class="literal">rlist</code> functions. Due to the number of steps involved in the data operations, we will use pipeline to organize the workflow:</p><pre class="programlisting">products %&gt;% &#13;
  list.filter(length(scores) &gt;= 5) %&gt;% &#13;
  list.sort(-mean(scores)) %&gt;% &#13;
  list.take(2) %&gt;% &#13;
  list.select(name,  &#13;
    mean_score = mean(scores), &#13;
    n_score = length(scores)) %&gt;% &#13;
  list.stack() &#13;
##        name mean_score n_score &#13;
## 1  SupPlane   9.600000       5 &#13;
## 2 AircraftX   8.857143       7 &#13;
</pre><p>The code looks straightforward, and it is easy to predict or analyze what happens in each step. If the final result can be represented in the tabular form, we can call <code class="literal">list.stack()</code> to bind all list elements together into a data frame.</p><p>To learn more about <code class="literal">rlist</code> functions, read the <code class="literal">rlist</code> tutorial (<a class="ulink" href="https://renkun.me/rlist-tutorial/">https://renkun.me/rlist-tutorial/</a>). There are other packages that deal with nested data structures but may have different philosophy, such as purrr (<a class="ulink" href="https://github.com/hadley/purrr">https://github.com/hadley/purrr</a>). If you are interested, visit and learn more on their websites.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec66"/>Summary</h1></div></div></div><p>In this chapter, you learned a number of basic functions and various packages for data manipulation. Using built-in functions to manipulate data can be redundant. Several packages are tailored for filtering and aggregating data based on different techniques and philosophies. The <code class="literal">sqldf</code> packages use embedded SQLite databases so that we can directly write SQL statements to query data frame in our working environment. On the other hand, <code class="literal">data.table</code> provides an enhanced version of <code class="literal">data.frame</code> and a powerful syntax, and <code class="literal">dplyr</code> defines a grammar of data manipulation by providing a set of pipeline friendly verb functions. The <code class="literal">rlist</code> class provides a set of pipeline friendly functions for non-tabular data manipulation. No single package is best for all situations. Each of them represents a way of thinking, and which best fits a certain problem depends on how you understand the problem and your experience of working with data.</p><p>Processing data and doing simulation require considerable computing power. However, from the beginning to today, performance is not the top priority for R. Although R is very powerful in interactive analysis, visualization, and reporting, its implementation is considered slow compared to some other popular scripting languages when it is used to process a large amount of data. In the next chapter, we'll introduce several techniques from performance measure and profiling to vectorization, MKL-powered R kernel, parallel computing, and Rcpp. These techniques will help you achieve high performance when you really need it.</p></div></body></html>