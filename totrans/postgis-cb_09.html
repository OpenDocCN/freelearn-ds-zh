<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">PostGIS and the Web</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating WMS and WFS services with MapServer</li>
<li>Creating WMS and WFS services with GeoServer</li>
<li>Creating a WMS Time service with MapServer</li>
<li>Consuming WMS services with OpenLayers</li>
<li>Consuming WMS services with Leaflet</li>
<li>Consuming WFS-T services with OpenLayers</li>
<li>Developing web applications with GeoDjango – part 1</li>
<li>Developing web applications with GeoDjango – part 2</li>
<li>Developing a web GPX viewer with Mapbox</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will try to give you an overview of how you can use PostGIS to develop powerful GIS web applications, using <strong>Open Geospatial Consortium</strong> (<strong>OGC</strong>) web standards such as <strong>Web Map Service</strong> (<strong>WMS</strong>) and <strong>Web Feature Service</strong> (<strong>WFS</strong>).</p>
<p>In the first two recipes, you will get an overview of two very popular open source web-mapping engines, <strong>MapServer</strong> and <strong>GeoServer</strong>. In both these recipes, you will see how to implement WMS and WFS services using PostGIS layers.</p>
<p>In the third recipe, you will implement a <strong>WMS Time</strong> service using MapServer to expose time-series data.</p>
<p>In the next two recipes, you will learn how to consume these web services to create web map viewers with two very popular JavaScript clients. In the fourth recipe, you will use a WMS service with <strong>OpenLayers</strong>, while in the fifth recipe, you will do the same thing using <strong>Leaflet</strong>.</p>
<p>In the sixth recipe, you will explore the power of transactional WFS to create web-mapping applications to enable editing data.</p>
<p>In the next two recipes, you will unleash the power of the popular <strong>Django</strong> web framework, which is based on Python, and its nice <strong>GeoDjango</strong> library, and see how it is possible to implement a powerful <strong>CRUD</strong> GIS web application. In the seventh recipe, you will create the back office for this application using the Django Admin site, and in the last recipe of the chapter, you will develop a frontend for users to display data from the application in a web map based on Leaflet.</p>
<p>Finally, in the last recipe, you will learn how to import your PostGIS data into Mapbox using <strong>OGR</strong> to create a custom web GPX viewer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating WMS and WFS services with MapServer</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will see how to create a WMS and WFS from a PostGIS layer, using the popular MapServer open source web-mapping engine.</p>
<p>You will then use the services, testing their exposed requests, using first a browser and then a desktop tool such as QGIS (you could do this using other software, such as uDig, gvSIG, and OpenJUMP GIS).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Follow these steps before getting ready:</p>
<ol>
<li>Create a schema for this chapter within the <kbd>postgis_cookbook</kbd> database using the following command:</li>
</ol>
<pre>      <strong>postgis_cookbook=# create schema chp09;</strong></pre>
<ol start="2">
<li>Be sure to have Apache HTTP installed (MapServer will run on it as a CGI) and check whether it is working by visiting its home page at <kbd>http://localhost</kbd> (typically, an <kbd>It works!</kbd> message will be displayed if you still have not customized any features).</li>
<li>Install MapServer as per its installation guide (<a href="http://mapserver.org/installation/index.html"><span class="URLPACKT">http://mapserver.org/installation/index.html</span></a>).</li>
</ol>
<div class="packt_infobox">A handy way to have MapServer up and running in Apache for Windows is to install the OSGeo4W (<a href="http://trac.osgeo.org/osgeo4w/"><span class="URLPACKT">http://trac.osgeo.org/osgeo4w/</span></a>) or MS4W (<a href="http://www.maptools.org/ms4w/"><span class="URLPACKT">http://www.maptools.org/ms4w/</span></a>) packages.<br/>
For Linux, there are packages for almost any kind of distribution.<br/>
For macOS, you can use again the CMake app to build the installation or use Homebrew with the following command (note the flags needed to compile it with Postgres support):<br/>
<kbd>brew install mapserver --with-postgresql --with-geos</kbd></div>
<ol start="4">
<li>Check whether MapServer has been installed correctly and has <kbd>POSTGIS</kbd>, <kbd>WMS_SERVER</kbd>, and <kbd>WFS_SERVER</kbd> support enabled, by running it as a command-line tool with the <kbd>-v</kbd> option.</li>
</ol>
<p style="padding-left: 60px">On Linux, run the <kbd>$ /usr/lib/cgi-bin/mapserv -v</kbd> command and check for the following output:</p>
<pre>    <strong>MapServer version 7.0.7 OUTPUT=GIF OUTPUT=PNG OUTPUT=JPEG SUPPORTS=PROJ <br/>    SUPPORTS=GD SUPPORTS=AGG SUPPORTS=FREETYPE SUPPORTS=CAIRO <br/>    SUPPORTS=SVG_SYMBOLS <br/>    SUPPORTS=ICONV SUPPORTS=FRIBIDI SUPPORTS=WMS_SERVER SUPPORTS=WMS_CLIENT <br/>    SUPPORTS=WFS_SERVER SUPPORTS=WFS_CLIENT SUPPORTS=WCS_SERVER <br/>    SUPPORTS=SOS_SERVER SUPPORTS=FASTCGI SUPPORTS=THREADS SUPPORTS=GEOS <br/>    INPUT=JPEG INPUT=POSTGIS INPUT=OGR INPUT=GDAL INPUT=SHAPEFILE</strong></pre>
<p style="padding-left: 60px">On Windows, run the following command:</p>
<pre>      <strong>c:\ms4w\Apache\cgi-bin\mapserv.exe -v</strong></pre>
<p style="padding-left: 60px">On macOS, use the <kbd>$ mapserv -v</kbd> command:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/9605c5be-1509-4b2b-814f-cbaa205e7f41.png" style="width:45.08em;height:9.42em;"/></div>
<ol start="5">
<li>Now check whether MapServer is working from within HTTPD, using <kbd>http://localhost/cgi-bin/mapserv</kbd> (<kbd>http://localhost/cgi-bin/mapserv.exe</kbd> for Windows). If you get a <kbd>No query information to decode. QUERY_STRING is set, but empty</kbd> response message, MapServer is correctly working as a CGI script in Apache and is ready to accept HTTP requests.</li>
<li>Download the world countries shapefile from <a href="http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip"><span class="URLPACKT">http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip</span></a>. A copy of this shapefile is included in the book dataset for <a href="38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml">Chapter 1</a>, <em>Moving Data In and Out of PostGIS</em>. Extract the shapefile to the <kbd>working/chp09</kbd> directory and import it in PostGIS using the <strong>shp2pgsql</strong> tool (be sure to specify the spatial reference system, <em>EPSG:4326</em>, with the <kbd>-s</kbd> option), as follows:</li>
</ol>
<pre>      <strong>$ shp2pgsql -s 4326 -W LATIN1 -g the_geom -I TM_WORLD_BORDERS-0.3.shp <br/>      chp09.countries &gt; countries.sql</strong>
      <strong>Shapefile type: Polygon</strong>
      <strong>Postgis type: MULTIPOLYGON[2]</strong>
      <strong>$ psql -U me -d postgis_cookbook -f countries.sql</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>MapServer exposes its map services using <kbd>mapfile</kbd>, a text file format, with which it is possible to define the PostGIS layers on the web, enable any vector and raster format supported by GDAL, and specify which services (WMS/WFS/WCS) to expose per layer. Create a new text file named <kbd>countries.map</kbd> and add the following code:</li>
</ol>
<pre>        MAP # Start of mapfile 
        NAME 'population_per_country_map' 
        IMAGETYPE         PNG 
        EXTENT            -180 -90 180 90 
        SIZE              800 400 
        IMAGECOLOR        255 255 255 
 
        # map projection definition 
        PROJECTION 
          'init=epsg:4326' 
        END 
 
        # web section: here we define the ows services 
        WEB 
          # WMS and WFS server settings 
          METADATA 
            'ows_enable_request'          '*' 
            'ows_title'                   'Mapserver sample map' 
            'ows_abstract'                'OWS services about <br/>                                          population per <br/>                                          country map' 
            'wms_onlineresource'          'http://localhost/cgi-<br/>                                            bin/mapserv?map=/var<br/>                                            /www/data/<br/>                                            countries.map&amp;' 
            'ows_srs'                     'EPSG:4326 EPSG:900913 <br/>                                          EPSG:3857' 
            'wms_enable_request'          'GetCapabilities, <br/>                                          GetMap, <br/>                                          GetFeatureInfo' 
            'wms_feature_info_mime_type'  'text/html' 
          END 
        END 
 
        # Start of layers definition 
        LAYER # Countries polygon layer begins here 
          NAME            countries 
          CONNECTIONTYPE  POSTGIS 
          CONNECTION      'host=localhost dbname=postgis_cookbook <br/>                           user=me password=mypassword port=5432'<br/>          DATA            'the_geom from chp09.countries' 
          TEMPLATE 'template.html' 
          METADATA 
            'ows_title' 'countries' 
            'ows_abstract' 'OWS service about population per <br/>              country map in 2005' 
            'gml_include_items' 'all' 
          END 
          STATUS          ON 
          TYPE            POLYGON 
          # layer projection definition 
          PROJECTION 
            'init=epsg:4326' 
          END 
 
          # we define 3 population classes based on the pop2005  
            attribute 
          CLASSITEM 'pop2005' 
          CLASS # first class 
            NAME '0 - 50M inhabitants' 
            EXPRESSION ( ([pop2005] &gt;= 0) AND ([pop2005] &lt;= <br/>              50000000) ) 
            STYLE 
              WIDTH 1 
              OUTLINECOLOR 0 0 0 
              COLOR 254 240 217 
            END # end of style 
          END # end of first class 
          CLASS # second class 
            NAME '50M - 200M inhabitants' 
            EXPRESSION ( ([pop2005] &gt; 50000000) AND <br/>              ([pop2005] &lt;= 200000000) ) 
            STYLE 
              WIDTH 1 
              OUTLINECOLOR 0 0 0 
              COLOR 252 141 89 
            END # end of style 
          END # end of second class 
          CLASS # third class 
            NAME '&gt; 200M inhabitants' 
            EXPRESSION ( ([pop2005] &gt; 200000000) ) 
            STYLE 
              WIDTH 1 
              OUTLINECOLOR 0 0 0 
              COLOR 179 0 0 
            END # end of style 
          END # end of third class 
 
        END # Countries polygon layer ends here 
 
        END # End of mapfile</pre>
<ol start="2">
<li>Save the file we just created in a location that is accessible to the Apache user. For example, in Debian, it is <kbd>/var/www/data</kbd>, while in Windows, it can be <kbd>C:\ms4w\Apache\htdocs</kbd>; for macOS, you should use <kbd>/Library/WebServer/Documents</kbd>.</li>
</ol>
<p style="padding-left: 60px">Be sure that both the file and the directory containing it are accessible to the Apache user.</p>
<ol start="3">
<li>Create a file named <kbd>template.html</kbd> in the same location as the <kbd>mapfile</kbd> and enter the following code in it (this file is used by the <kbd>GetFeatureInfo</kbd> WMS request to output an HTML response to the client):</li>
</ol>
<pre>       &lt;!-- MapServer Template --&gt; 
       &lt;ul&gt; 
         &lt;li&gt;&lt;strong&gt;Name: &lt;/strong&gt;[item name=name]&lt;/li&gt; 
         &lt;li&gt;&lt;strong&gt;ISO2: &lt;/strong&gt;[item name=iso2]&lt;/li&gt; 
         &lt;li&gt;&lt;strong&gt;ISO3: &lt;/strong&gt;[item name=iso3]&lt;/li&gt; 
         &lt;li&gt; 
           &lt;strong&gt;Population 2005:&lt;/strong&gt; [item name=pop2005] 
         &lt;/li&gt; 
        &lt;/ul&gt; </pre>
<ol start="4">
<li>With the <kbd>mapfile</kbd> you just created, you exposed the <kbd>countries</kbd> PostGIS layer, both as a WMS and WFS service. Both of these services expose to the user a series of requests and you will now test them using a browser. First, without invoking any services, test whether the <kbd>mapfile</kbd> is working correctly by typing the following URL in the browser:
<ul>
<li><kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&amp;layer=countries&amp;mode=map</kbd> <span>(for Linux)</span></li>
<li><kbd>http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdocs\countries.map&amp;layer=countries&amp;mode=map</kbd> <span>(for Windows)</span></li>
<li><kbd>http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/countries.map&amp;layer=countries&amp;mode=map</kbd> <a href="http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/countries.map&amp;layer=countries&amp;mode=map"><span>(for macOS)</span></a></li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">You should see the <kbd>countries</kbd> layer rendered with the three symbology classes defined in the <kbd>mapfile</kbd>, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e3f45c7a-ea25-4f2e-8ebd-c67a78a640d4.png" style="width:39.92em;height:24.33em;"/></div>
<p style="padding-left: 60px">As you can see, there is a small difference between the URLs used in Windows, Linux, and macOS. We will refer to Linux from now on, but you can easily adapt the URLs to Windows or macOS.</p>
<ol start="5">
<li>Now you will start testing the WMS service; you will try running the <kbd>GetCapabilities</kbd>, <kbd>GetMap</kbd>, and <kbd>GetFeatureInfo</kbd> requests. To test the <kbd>GetCapabilities</kbd> request, type the URL in the browser: <kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</kbd>. You should receive a long XML response (as follows) from the server, where the more important fragments are the WMS service definitions in the <kbd>&lt;Service&gt;</kbd> section, the requests are enabled in the <kbd>&lt;Capability&gt;</kbd> section, and the layers exposed and their main details (for example, name, abstract, projection, and extent) are in the <kbd>&lt;Layer&gt;</kbd> section of each of the layers:</li>
</ol>
<pre>        &lt;WMT_MS_Capabilities version="1.1.1"&gt; 
          ... 
          &lt;Service&gt; 
            &lt;Name&gt;OGC:WMS&lt;/Name&gt; 
            &lt;Title&gt;Population per country map&lt;/Title&gt; 
            &lt;Abstract&gt;Map server sample map&lt;/Abstract&gt; 
            &lt;OnlineResource <br/>              <br/>             xlink:href="http://localhost/cgi-<br/>             bin/mapserv?map=/var/www/data/countries.map&amp;amp;"/&gt; 
            &lt;ContactInformation&gt; &lt;/ContactInformation&gt; 
          &lt;/Service&gt; 
          &lt;Capability&gt; 
            &lt;Request&gt; 
              &lt;GetCapabilities&gt; 
                ... 
              &lt;/GetCapabilities&gt; 
              &lt;GetMap&gt; 
                &lt;Format&gt;image/png&lt;/Format&gt; 
                ... 
                &lt;Format&gt;image/tiff&lt;/Format&gt; 
                ... 
              &lt;/GetMap&gt; 
              &lt;GetFeatureInfo&gt; 
                &lt;Format&gt;text/plain&lt;/Format&gt; 
                ... 
              &lt;/GetFeatureInfo&gt; 
              ... 
            &lt;/Request&gt; 
            ... 
            &lt;Layer&gt; 
              &lt;Name&gt;population_per_country_map&lt;/Name&gt; 
              &lt;Title&gt;Population per country map&lt;/Title&gt; 
              &lt;Abstract&gt;OWS service about population per country map <br/>               in 2005&lt;/Abstract&gt; 
              &lt;SRS&gt;EPSG:4326&lt;/SRS&gt; 
              &lt;SRS&gt;EPSG:3857&lt;/SRS&gt; 
              &lt;LatLonBoundingBox minx="-180" miny="-90" maxx="180" <br/>               maxy="90" /&gt; 
              ... 
            &lt;/Layer&gt; 
          &lt;/Layer&gt; 
          &lt;/Capability&gt; 
        &lt;/WMT_MS_Capabilities&gt;</pre>
<ol start="6">
<li>Now test the WMS service with its typical <kbd>GetMap</kbd> WMS request, used on many clients to display a map to the user. Type the URL <kbd>http://localhost//cgi-bin/mapserv?map=/var/www/data/countries.map&amp;SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetMap&amp;BBOX=-26,-111,36,-38&amp;CRS=EPSG:4326&amp;WIDTH=1000&amp;HEIGHT=800&amp;LAYERS=countries&amp;STYLES=&amp;FORMAT=image/png</kbd></li>
<li>Into the browser and check the image that is sent back in response by the MapServer <kbd>GetMap</kbd> request, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/45ee2c30-3a5b-4464-b702-215b62607c43.png" style="width:49.83em;height:37.50em;"/></div>
<ol start="8">
<li>Another typical WMS request is <kbd>GetFeatureInfo</kbd>, used by clients to query the map layer at the given coordinates (points). Type the following URL and you should see the field values for a given feature as the output (the output is built using the <kbd>template.html</kbd> file):</li>
</ol>
<pre>      <strong>http://localhost/cgi-bin/mapserv?map=/var/www/data/<br/>      countries.map&amp;layer=countries&amp;REQUEST=GetFeatureInfo&amp;<br/>      SERVICE=WMS&amp;VERSION=1.1.1&amp;LAYERS=countries&amp;<br/>      QUERY_LAYERS=countries&amp;SRS=EPSG:4326&amp;BBOX=-122.545074509804, <br/>      37.6736653056517,-122.35457254902,37.8428758708189&amp;<br/>      X=652&amp;Y=368&amp;WIDTH=1020&amp;HEIGHT=906&amp;INFO_FORMAT=text/html</strong></pre>
<p style="padding-left: 60px">The output should be as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/6bf9f74b-7418-4290-9160-1652f97e6b55.png" style="width:12.75em;height:5.25em;"/></div>
<ol start="9">
<li>Now, you will use QGIS to use the WMS service. Launch QGIS, click on the <span class="packt_screen">Add WMS layer</span> button (alternatively, navigate to <span class="packt_screen">Layer</span> | <span class="packt_screen">Add WMS Layer</span> or use the QGIS browser), and create a new WMS connection, as shown in the following screenshot. Type something such as <kbd>MapServer on localhost</kbd> in the <span class="packt_screen">Name</span> field and <kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities</kbd> in the <span class="packt_screen">URL</span> field, and click on the <span class="packt_screen">OK</span> button (remember to adjust the Apache URL according to the configuration of your OS; check step 4):</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/641af38a-fedf-49ae-b089-371abd584fe3.png" style="width:40.83em;height:29.58em;"/></div>
<ol start="10">
<li>Now click on the <span class="packt_screen">Connect</span> button, as shown in the following screenshot. Then, select the <span class="packt_screen">countries</span> layer and add it to the QGIS map window using the <span class="packt_screen">Add</span> button, making sure to select the coordinate system EPSG:4326:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/06b1e728-cc8e-45e9-8820-3bb239f38d5a.png"/></div>
<ol start="11">
<li>Now browse to your WMS countries layer and try to perform some identification operations. QGIS will raise the needed <kbd>GetMap</kbd> and <kbd>GetFeatureInfo</kbd> WMS requests for you behind the scenes to give the following output:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/33ad34f9-2943-40dc-8188-b3e8ab039c41.png"/></div>
<ol start="12">
<li>Having seen how the WMS service works, you will now start using WFS. Like WMS, WFS offers the user a <kbd>GetCapabilities</kbd> request as well, resulting in a similar output to the <kbd>GetCapabilities</kbd> request of WMS. Type the URL <kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&amp;SERVICE=WFS&amp;VERSION=1.0.0&amp;REQUEST=GetCapabilities</kbd> into the browser window to inspect the XML response.</li>
<li>The main WFS request is <kbd>GetFeature</kbd>. It lets you query the map layer using several criteria, returning a collection of features in response as <strong>Geography Markup Language</strong> <span class="NormalPACKTChar1">(</span><strong>GML</strong>) output. Test the request by typing this URL in the browser: <kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&amp;SERVICE=WFS&amp;VERSION=1.0.0&amp;REQUEST=getfeature&amp;TYPENAME=countries&amp;MAXFEATURES=5</kbd>.</li>
<li>You should get an XML (GML) response from the browser, as shown in the following code, with a <kbd>&lt;wfs:FeatureCollection&gt;</kbd> element composed of five <kbd>&lt;gml:featureMember&gt;</kbd> elements (as indicated in the <kbd>MAXFEATURES</kbd> parameter of the request), each representing one country. For each feature, the WFS returns the geometry and all of the field values (this behavior was specified by setting the <kbd>gml_include_items</kbd> variable in the <kbd>METADATA</kbd> layer directive in the <kbd>mapfile</kbd>). You will see a geometry as follows:</li>
</ol>
<pre>        &lt;gml:featureMember&gt; 
          &lt;ms:countries&gt; 
            &lt;gml:boundedBy&gt; 
              &lt;gml:Box srsName="EPSG:4326"&gt; 
                &lt;gml:coordinates&gt;-61.891113,16.989719 -<br/>                 61.666389,17.724998&lt;/gml:coordinates&gt; 
              &lt;/gml:Box&gt; 
            &lt;/gml:boundedBy&gt; 
 
            &lt;ms:msGeometry&gt; 
              &lt;gml:MultiPolygon srsName="EPSG:4326"&gt; 
                &lt;gml:polygonMember&gt; 
                  &lt;gml:Polygon&gt; 
                    &lt;gml:outerBoundaryIs&gt; 
                      &lt;gml:LinearRing&gt; 
                        &lt;gml:coordinates&gt; 
                          -61.686668,17.024441 ... 
                        &lt;/gml:coordinates&gt; 
                      &lt;/gml:LinearRing&gt; 
                    &lt;/gml:outerBoundaryIs&gt; 
                  &lt;/gml:Polygon&gt; 
                &lt;/gml:polygonMember&gt; 
                ... 
              &lt;/gml:MultiPolygon&gt; 
            &lt;/ms:msGeometry&gt; 
            &lt;ms:gid&gt;1&lt;/ms:gid&gt; 
            &lt;ms:fips&gt;AC&lt;/ms:fips&gt; 
            &lt;ms:iso2&gt;AG&lt;/ms:iso2&gt; 
            &lt;ms:iso3&gt;ATG&lt;/ms:iso3&gt; 
            &lt;ms:un&gt;28&lt;/ms:un&gt; 
            &lt;ms:name&gt;Antigua and Barbuda&lt;/ms:name&gt; 
            &lt;ms:area&gt;44&lt;/ms:area&gt; 
            &lt;ms:pop2005&gt;83039&lt;/ms:pop2005&gt; 
            &lt;ms:region&gt;19&lt;/ms:region&gt; 
            &lt;ms:subregion&gt;29&lt;/ms:subregion&gt; 
            &lt;ms:lon&gt;-61.783&lt;/ms:lon&gt; 
            &lt;ms:lat&gt;17.078&lt;/ms:lat&gt; 
          &lt;/ms:countries&gt; 
        &lt;/gml:featureMember&gt; </pre>
<ol start="15">
<li>As a result of the WFS <kbd>GetFeature</kbd> request executed in the previous step, MapServer has returned only the first five features of the <kbd>countries</kbd> layers. Now, use the <kbd>GetFeature</kbd> request to make a query to the layer using a filter and get back the corresponding features. By typing the URL <kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&amp;SERVICE=WFS&amp;VERSION=1.0.0&amp;REQUEST=getfeature&amp;TYPENAME=countries&amp;MAXFEATURES=5&amp;Filter=&lt;Filter&gt; &lt;PropertyIsEqualTo&gt;&lt;PropertyName&gt;name&lt;/PropertyName&gt; &lt;Literal&gt;Italy&lt;/Literal&gt;&lt;/PropertyIsEqualTo&gt;&lt;/Filter&gt;</kbd>, you will get the feature in the database that has the <kbd>name</kbd> field set to <kbd>Italy</kbd>.</li>
</ol>
<p> </p>
<ol start="16">
<li>After testing the WFS requests in a browser, try to open the WFS service in QGIS using the <span class="packt_screen">Add WFS Layer</span> button (alternatively, navigate to <span class="packt_screen">Layer</span> | <span class="packt_screen">Add WFS Layer</span> or use the QGIS browser). You should see the same <span class="packt_screen">MapServer on Localhost</span> connection you created a few steps earlier. Click on the <span class="packt_screen">Connect</span> button and select the <span class="packt_screen">countries</span> layer, add it to the QGIS project, and browse through it by zooming, panning, and identifying some features. The biggest difference when compared to WMS is that, with WFS, you receive the feature geometries from the server and not just an image, so you can even export the layer to a different format, such as a shapefile or spatialite! The <span class="packt_screen">Add WFS layer from a Server</span> window is as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/b33d2e02-85a1-4451-9fed-b784d1b40722.png" style="width:46.25em;height:36.42em;"/></div>
<p class="packt_figure" style="padding-left: 60px">You should now be able to see the vector map in QGIS and inspect the features:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c1a28131-5c43-4291-8664-9b3c5a6019b3.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you implemented WMS and WFS services for a PostGIS layer using the MapServer open source web-mapping engine. WMS and WFS are the two core concepts to consider when you want to develop a web GIS that is interoperable across many organizations. <strong>Open Geospatial Consortium</strong> (<strong>OGC</strong>) defined these two standards (and many others) to make web-mapping services exposed in an open, standard way. This way these services can be used by different applications; for example, you have seen in this recipe that a GIS Desktop tool such as QGIS can browse and query those services because it understands these OGC standards (you can get exactly the same results with other tools, such as gvSIG, uDig, OpenJUMP, and ArcGIS Desktop, among others). In the same way, Javascript API libraries, most notably OpenLayers and Leaflet (you will be using these in the other recipes in this chapter), can use these services in a standard way to provide web-mapping features to web applications.</p>
<p>WMS is a service that is used to generate the maps to be displayed by clients. Those maps are generated using image formats, such as PNG, JPEG, and many others. Some of the most typical WMS requests are as follows:</p>
<ul>
<li><kbd>GetCapabilities</kbd>: This offers an overview of the services offered by WMS, particularly a list of the available layers and some of the details of each layer (layer extent, coordinate reference systems, URI of the data, and so on).</li>
<li><kbd>GetMap</kbd>: This returns a map image representing one or more layers for a specified extent and spatial reference, in a specified image file format and size.</li>
<li><kbd>GetFeatureInfo</kbd>: This is an optional request by WMS that returns, in different formats, the attribute values for the features of a given point in the map. You have seen how to customize the response by introducing a template file that must be set in the <kbd>mapfile</kbd>.</li>
</ul>
<p>WFS provides a convenient, standard way to access the features of a vector layer with a web request. The service response streams to the client the requested features using GML (an XML markup defined by OGC to define geographical features).</p>
<p>Some WFS requests are as follows:</p>
<ul>
<li><kbd>GetCapabilities</kbd>: This gives a description of the services and layers offered by the WFS service</li>
<li><kbd>GetFeature</kbd>: This allows the client to get a set of features of a given layer, corresponding to a given criteria</li>
</ul>
<p>These WMS and WFS requests can be consumed by the client using the HTTP protocol. You have seen how to query and get a response from the client by typing a URL in a browser with several parameters appended to it. As an example, the following WMS <kbd>GetMap</kbd> request will return a map image of the layers (using the <kbd>LAYERS</kbd> parameter) in a specified format (using the <kbd>FORMAT</kbd> parameter), size (using the <kbd>WIDTH</kbd> and <kbd>HEIGHT</kbd> parameters), extent (using the <kbd>BBOX</kbd> parameter), and spatial reference system (using <kbd>CRS</kbd>):</p>
<pre><strong>http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&amp;&amp;SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetMap&amp;BBOX=-26,-111,36,-38&amp;CRS=EPSG:4326&amp;WIDTH=806&amp;HEIGHT=688&amp;LAYERS=countries&amp;STYLES=&amp;FORMAT=image/png</strong></pre>
<p>In MapServer, you can create WMS and WFS services in the <kbd>mapfile</kbd> using its directives. The <kbd>mapfile</kbd> is a text file that is composed of several sections and is the heart of MapServer. In the beginning of the <kbd>mapfile</kbd>, it is necessary to define general properties for the map, such as its title, extent, spatial reference, output-image formats, and dimensions to be returned to the user.</p>
<p>Then, it is possible to define which OWS (OGC web services such as WMS, WFS, and WCS) requests to expose.</p>
<p>Then there is the main section of the <kbd>mapfile</kbd>, where the layers are defined (every layer is defined in the <kbd>LAYER</kbd> directive). You have seen how to define a PostGIS layer. It is necessary to define its connection information (database, user, password, and so on), the SQL definition in the database (it is possible to use just a PostGIS table name, but you could eventually use a query to define the set of features and attributes defining the layer), the geometric type, and the projection.</p>
<p>A whole directive (<kbd>CLASS</kbd>) is used to define how the layer features will be rendered. You may use different classes, as you did in this recipe, to render features differently, based on an attribute defined with the <kbd>CLASSITEM</kbd> setting. In this recipe, you defined three different classes, each representing a population class, using different colors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>You can find more information about using MapServer by using its extensive documentation at its project home page (<a href="http://mapserver.org/it/index.html"><span class="URLPACKT">http://mapserver.org/it/index.html</span></a>). You will find the mapfile documentation at <a href="http://www.mapserver.org/mapfile/"><span class="URLPACKT">http://www.mapserver.org/mapfile/</span></a> very useful to read.</li>
<li>A good tutorial to understand how to generate <span>mapfile</span><span>s can be found at <a href="http://mapserver.org/tutorial/example1-1.html"><span class="URLPACKT">http://mapserver.org/tutorial/example1-1.html</span></a>.</span></li>
<li>In case you want to gain a better understanding of the WMS and WFS standards, check their specifications at the OGC website. For the WMS service, go to <a href="http://www.opengeospatial.org/standards/wms"><span class="URLPACKT">http://www.opengeospatial.org/standards/wms</span></a>, whereas for WFS, go to <a href="http://www.opengeospatial.org/standards/wfs"><span class="URLPACKT">http://www.opengeospatial.org/standards/wfs</span></a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating WMS and WFS services with GeoServer</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, you created WMS and WFS from a PostGIS layer using MapServer. In this recipe, you will do it using another popular open source web-mapping engine-GeoServer. You will then use the created services as you did with MapServer, testing their exposed requests, first using a browser and then the QGIS desktop tool (you can do this with other software, such as uDig, gvSIG, OpenJUMP GIS, and ArcGIS Desktop).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>While MapServer is written in the C language and uses Apache as its web server, GeoServer is written in Java and you therefore need to install the <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) in your system; it must be used from a servlet container, such as <em>Jetty</em> and <em>Tomcat</em>. After installing the servlet container, you will be able to deploy the GeoServer application to it. For example, in Tomcat, you can deploy GeoServer by copying the GeoServer <strong>WAR</strong> (<strong>web archive</strong>) file to Tomcat's <kbd>webapps</kbd> directory. For this recipe, we will suppose that you have a working GeoServer in your system; if this is not the case, follow the detailed GeoServer installation steps for your OS at the GeoServer website (<a href="http://docs.geoserver.org/stable/en/user/installation/"><span class="URLPACKT">http://docs.geoserver.org/stable/en/user/installation/</span></a>) and then return to this recipe. Follow these steps:</p>
<ol>
<li>Download the USA counties shapefile from the <a href="https://nationalmap.gov/">https://nationalmap.gov/</a> website at <a href="http://dds.cr.usgs.gov/pub/data/nationalatlas/countyp020_nt00009.tar.gz"><span class="URLPACKT">http://dds.cr.usgs.gov/pub/data/nationalatlas/countyp020_nt00009.tar.gz</span></a> (this archive is included in the book's code bundle). Extract the archive from <kbd>working/chp09</kbd> and import it to PostGIS using the <kbd>ogr2ogr</kbd> command, as follows:</li>
</ol>
<pre>      <strong>$ ogr2ogr -f PostgreSQL -a_srs EPSG:4326 -lco GEOMETRY_NAME=the_geom <br/>      -nln chp09.counties PG:"dbname='postgis_cookbook' user='me' <br/>      password='mypassword'" countyp020.shp</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>Open the GeoServer administrative interface, which is typically located at <kbd>http://localhost:8080/geoserver</kbd>, in your favorite browser and log in using your credentials (<kbd>admin</kbd> as the username and <kbd>geoserver</kbd> as the password) if you are just using the GeoServer default installation and have not customized things. After starting GeoServer, you should see the following:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0c14f51e-d987-4f22-b69d-1007285368fc.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">GeoServer welcome screen viewed in a browser</div>
<ol start="2">
<li>After successfully logging in, create a workspace by clicking on the <span class="packt_screen">Workspace</span> link under <span class="packt_screen">Work</span> (in the left-hand-side panel of the GeoServer application's main menu) and then click on the <span class="packt_screen">Add new workspace</span> link. In the text boxes of the form that appears, specify the following values and then click on the <span class="packt_screen">Submit</span> button:
<ul>
<li>Enter <kbd>postgis_cookbook</kbd> <span>in the</span> <span class="packt_screen">Name</span> <span>field</span></li>
<li>Enter the URL <span class="URLPACKT"><a href="https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook">https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook</a> </span>in the <span class="packt_screen">Namespace URI</span> field</li>
</ul>
</li>
<li>Now, to create a PostGIS store, click on the <span class="packt_screen">Stores</span> link under <span class="packt_screen">Data</span> (in the left-hand-side panel of the GeoServer application's main menu). Now, click on the <span class="packt_screen">Add new store</span> link, and then on the <span class="packt_screen">PostGIS</span> link under <span class="packt_screen">Vector Data Sources,</span> as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d9d4876a-99c6-4371-bf25-bd379f7640fc.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">GeoServer screen to configure new data sources</div>
<ol start="4">
<li>In the <span class="packt_screen">New Vector Data Source</span> page, complete the form's fields, as follows:
<ol>
<li>Select <span class="packt_screen">postgis_cookbook</span> <span>from the</span> <span class="packt_screen">Workspace</span> <span>drop-down list.</span></li>
<li>Enter <kbd>postgis_cookbook</kbd> <span>in the</span> <span class="packt_screen">Data Source Name</span> <span>field.</span></li>
<li>Enter <kbd>localhost</kbd> <span>in the</span> <span class="packt_screen">host</span> <span>field.</span></li>
<li>Enter <kbd>5432</kbd> <span>in the</span> <span class="packt_screen">port</span> <span>field.</span></li>
<li>Enter <kbd>postgis_cookbook</kbd> <span>in the</span> <span class="packt_screen">database</span> <span>field.</span></li>
<li>Enter <kbd>chp09</kbd> <span>in the</span> <span class="packt_screen">schema</span> <span>field.</span></li>
<li>Enter <kbd>me</kbd> <span>in the</span> <span class="packt_screen">user</span> <span>field.</span></li>
<li>Enter <kbd>mypassword</kbd> <span>in the</span> <span class="packt_screen">passwd</span> <span>field.</span></li>
</ol>
</li>
</ol>
<p style="padding-left: 60px">The <span class="packt_screen">New Vector Data Source</span> page is shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/86b686de-bf22-4356-86fb-84a3b231b629.png" style="width:37.08em;height:44.17em;"/></div>
<ol start="5">
<li>Now, click on the <span class="packt_screen">Save</span> button to successfully create your PostGIS store.</li>
<li>Now, you are ready to publish the PostGIS <kbd>counties</kbd> layer as WMS and WFS. On the <span class="packt_screen">Layers</span> page, click on the <span class="packt_screen">Add a new resource</span> link. Now, select <span class="packt_screen">postgis_cookbook</span> from the <span class="packt_screen">Add layer from</span> drop-down list. Click on the <span class="packt_screen">Publish</span> link to the right of the <kbd>counties</kbd> layer.</li>
<li>On the <span class="packt_screen">Edit Layer</span> page, shown in the following screenshot, click on the links <span class="packt_screen">Compute from data</span> and <span class="packt_screen">Compute from native bounds</span>, and then click on the <span class="packt_screen">Save</span> button:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/1bc14616-fcaf-4d05-a931-8d36b0609e04.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">GeoServer screen to edit the countries layer for publishing</div>
<ol start="8">
<li>Now, you need to define the style used to display the layer to the user. Unlike MapServer, GeoServer uses the OGC-standard <strong>Styled Layer Descriptor</strong> (<strong>SLD</strong>) notation. Click on the <span class="packt_screen">Styles</span> link under <span class="packt_screen">Data</span> and then on the <span class="packt_screen">Add new style</span> link. Fill the text fields in the form, as follows:
<ul>
<li>Enter <kbd>Counties classified per size</kbd> <span>in the</span> <span class="packt_screen">Name</span> <span>field.</span></li>
<li>Enter <kbd>postgis_cookbook</kbd> <span>in the</span> <span class="packt_screen">Workspace</span> <span><span>field</span></span></li>
</ul>
</li>
</ol>
<ol start="9">
<li>In the text area for the SLD, add the following XML code defining the style for the <kbd>counties</kbd> layer. Then, click on the <span class="packt_screen">Validate</span> button to check whether your SLD definition is correct and then click on the <span class="packt_screen">Submit</span> button to save the new style:</li>
</ol>
<pre>        &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
        &lt;sld:StyledLayerDescriptor  <br/>          <br/>          <br/>          version="1.0.0"&gt; 
          &lt;sld:NamedLayer&gt; 
            &lt;sld:Name&gt;county_classification&lt;/sld:Name&gt; 
            &lt;sld:UserStyle&gt; 
              &lt;sld:Name&gt;county_classification&lt;/sld:Name&gt; 
              &lt;sld:Title&gt;County area classification&lt;/sld:Title&gt; 
              &lt;sld:FeatureTypeStyle&gt; 
                &lt;sld:Name&gt;name&lt;/sld:Name&gt; 
                &lt;sld:Rule&gt; 
                  &lt;sld:Title&gt;Large counties&lt;/sld:Title&gt; 
                  &lt;ogc:Filter&gt; 
                    &lt;ogc:PropertyIsGreaterThanOrEqualTo&gt; 
                      &lt;ogc:PropertyName&gt;square_mil&lt;/ogc:PropertyName&gt; 
                      &lt;ogc:Literal&gt;5000&lt;/ogc:Literal&gt; 
                    &lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt; 
                  &lt;/ogc:Filter&gt; 
                  &lt;sld:PolygonSymbolizer&gt; 
                    &lt;sld:Fill&gt; 
                      &lt;sld:CssParameter <br/>                       name="fill"&gt;#FF0000&lt;/sld:CssParameter&gt; 
                    &lt;/sld:Fill&gt; 
                    &lt;sld:Stroke/&gt; 
                  &lt;/sld:PolygonSymbolizer&gt; 
                &lt;/sld:Rule&gt; 
                &lt;sld:Rule&gt; 
                  &lt;sld:Title&gt;Small counties&lt;/sld:Title&gt;<br/>                  &lt;ogc:Filter&gt; 
                    &lt;ogc:PropertyIsLessThan&gt; 
                       &lt;ogc:PropertyName&gt;square_mil&lt;/ogc:PropertyName&gt; 
                      &lt;ogc:Literal&gt;5000&lt;/ogc:Literal&gt; 
                    &lt;/ogc:PropertyIsLessThan&gt;<br/>                  &lt;/ogc:Filter&gt; 
                  &lt;sld:PolygonSymbolizer&gt; 
                    &lt;sld:Fill&gt; 
                      &lt;sld:CssParameter <br/>                       name="fill"&gt;#0000FF&lt;/sld:CssParameter&gt; 
                    &lt;/sld:Fill&gt; 
                    &lt;sld:Stroke/&gt; 
                  &lt;/sld:PolygonSymbolizer&gt; 
                &lt;/sld:Rule&gt; 
              &lt;/sld:FeatureTypeStyle&gt; 
            &lt;/sld:UserStyle&gt; 
          &lt;/sld:NamedLayer&gt; 
        &lt;/sld:StyledLayerDescriptor&gt; </pre>
<p style="padding-left: 60px">The following screenshot shows how the new style looks on the <span class="packt_screen">New style</span> GeoServer page:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/8ebe49df-a1fc-495d-8c51-ba5b77fa79dc.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">GeoServer screen for creating a new style as an SLD document</div>
<ol start="10">
<li>Now you need to associate the created style with the <kbd>counties</kbd> layer. Go back to the layer page (<span class="packt_screen">Data</span> | <span class="packt_screen">Layers</span>), click on the <kbd>counties</kbd> layer link, and then, on the <span class="packt_screen">Edit Layer</span> page, click on the <span class="packt_screen">Publishing</span> section. Select <span class="packt_screen">Counties classified per size</span> in the <span class="packt_screen">Default style</span> drop-down list and then click on the <span class="packt_screen">Save</span> button.</li>
</ol>
<p> </p>
<ol start="11">
<li>Now that your WMS and WFS services for the PostGIS <kbd>counties</kbd> layer are ready, it is time to start using them! First, test the <kbd>GetCapabilities</kbd> WMS request. To do this, you can click on one of the links on the right-hand-side panel on the GeoServer web application home page. You can click on the link for either WMS version 1.1.1 or WMS version 1.3.0. Click on one of the links or type the <kbd>GetCapabilities</kbd> request directly in the browser as <kbd>http://localhost:8080/geoserver/ows?service=wms&amp;version=1.3.0&amp;request=GetCapabilities</kbd>.</li>
<li>Now, we will investigate the <kbd>GetCapabilities</kbd> response, shown as follows. You will find a lot of information about WMS is available on your GeoServer instance, such as the WMS-supported requests, projections, and a lot of other information about each published layer. In the case of the <kbd>counties</kbd> layer, the following code is an extract from the <kbd>GetCapabilities</kbd> document. Note the main layer information, such as the name, title, abstract (you could redefine all of these using the GeoServer web application), the supported <strong>Coordinate Reference Systems</strong> <span class="NormalPACKTChar1">(</span><strong>CRS</strong><span class="NormalPACKTChar1">)</span>, the geographic extent, and the associated style:</li>
</ol>
<pre>        &lt;Layer queryable="1"&gt; 
          &lt;Name&gt;postgis_cookbook:counties&lt;/Name&gt; 
          &lt;Title&gt;counties&lt;/Title&gt; 
          &lt;Abstract/&gt; 
          &lt;KeywordList&gt; 
            &lt;Keyword&gt;counties&lt;/Keyword&gt; 
            &lt;Keyword&gt;features&lt;/Keyword&gt; 
          &lt;/KeywordList&gt; 
          &lt;CRS&gt;EPSG:4326&lt;/CRS&gt; 
          &lt;CRS&gt;CRS:84&lt;/CRS&gt; 
          &lt;EX_GeographicBoundingBox&gt; 
            &lt;westBoundLongitude&gt;-179.133392333984<br/>            &lt;/westBoundLongitude&gt;            
            &lt;eastBoundLongitude&gt;-64.566162109375<br/>            &lt;/eastBoundLongitude&gt; 
            &lt;southBoundLatitude&gt;17.6746921539307<br/>            &lt;/southBoundLatitude&gt; 
            &lt;northBoundLatitude&gt;71.3980484008789<br/>            &lt;/northBoundLatitude&gt; 
          &lt;/EX_GeographicBoundingBox&gt; 
          &lt;BoundingBox CRS="CRS:84" minx="-179.133392333984" <br/>           miny="17.6746921539307" maxx="-64.566162109375" <br/>           maxy="71.3980484008789"/&gt; 
          &lt;BoundingBox CRS="EPSG:4326" minx="17.6746921539307" <br/>           miny="-179.133392333984" maxx="71.3980484008789" maxy="-<br/>           64.566162109375"/&gt; 
          &lt;Style&gt; 
            &lt;Name&gt;Counties classified per size&lt;/Name&gt; 
            &lt;Title&gt;County area classification&lt;/Title&gt; 
            &lt;Abstract/&gt; 
            &lt;LegendURL width="20" height="20"&gt; 
              &lt;Format&gt;image/png&lt;/Format&gt; 
              &lt;OnlineResource <br/>                <br/>               xlink:type="simple" xlink:href=<br/>               "http://localhost:8080/geoserver/<br/>                ows?service=WMS&amp;amp;request=GetLegendGraphic&amp;amp;<br/>                 format=image%2Fpng&amp;amp;width=20&amp;amp;height=20&amp;amp;<br/>                layer=counties"/&gt; 
            &lt;/LegendURL&gt; 
          &lt;/Style&gt; 
        &lt;/Layer&gt; </pre>
<ol start="13">
<li>To test the <kbd>GetMap</kbd> and <kbd>GetFeatureInfo</kbd> WMS requests, the GeoServer web application offers you a very handy way with the <span class="packt_screen">Layer Preview</span> page. Navigate to <span class="packt_screen">Data</span> | <span class="packt_screen">Layer Preview</span> and then click on the <span class="packt_screen">OpenLayers</span> link next to the <kbd>counties</kbd> layer. The <span class="packt_screen">Layer Preview</span> page is based on the <span class="NormalPACKTChar1">OpenLayers JavaScript</span> library and lets you experiment with the <kbd>GetMap</kbd> and <kbd>GetFeatureInfo</kbd> requests.</li>
<li>Try to navigate the map; at each zoom and pan action, GeoServer will stream out a new image provided by the response output to a <kbd>GetMap</kbd> request. By clicking on the map, you can perform a <kbd>GetFeatureInfo</kbd> request and the user interface will display the feature's attributes corresponding to the point on the map on which you clicked. A very effective way to check how the requests are sent to GeoServer as you navigate the map is by using the Firefox Firebug plugin or the Chrome (or Chromium if you are using Linux) Developer Tools. With these tools, you will be able to identify the <kbd>GetMap</kbd> and <kbd>GetFeatureInfo</kbd> requests that are being sent behind the scenes from the <span class="packt_screen">OpenLayers</span> viewer to GeoServer. One such map is shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/5af96157-29eb-4046-b8ba-ca8c21ea9618.png"/></div>
<p style="padding-left: 60px">Here is what you get when inspecting the requests with any in-browser developer tool, check the request URL, and verify the parameters sent to geoserver; this is how it looks with Firefox:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/216a52c9-ba61-47a8-8eb9-4d553da53aac.png"/></div>
<ol start="15">
<li>Now, try a WMS <kbd>GetMap</kbd> request by typing the URL <kbd>http://localhost:8080/geoserver/postgis_cookbook/wms?LAYERS=postgis_cookbook%3Acounties&amp;STYLES=&amp;FORMAT=image%2Fpng&amp;SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetMap&amp;SRS=EPSG%3A4326&amp;BBOX=-200.50286594033,7.6152902245522,-43.196688503029,81.457450330258&amp;WIDTH=703&amp;HEIGHT=330</kbd> in your browser.</li>
<li>Try a WMS <kbd>GetFeatureInfo</kbd> request, as well, by typing the URL <kbd>http://localhost:8080/geoserver/postgis_cookbook/wms?REQUEST=GetFeatureInfo&amp;EXCEPTIONS=application%2Fvnd.ogc.se_xml&amp;BBOX=-126.094303%2C37.16812%2C-116.262667%2C41.783255&amp;SERVICE=WMS&amp;INFO_FORMAT=text%2Fhtml&amp;QUERY_LAYERS=postgis_cookbook%3Acounties&amp;FEATURE_COUNT=50&amp;Layers=postgis_cookbook%3Acounties&amp;WIDTH=703&amp;HEIGHT=330&amp;format=image%2Fpng&amp;styles=&amp;srs=EPSG%3A4326&amp;version=1.1.1&amp;x=330&amp;y=158.</kbd></li>
</ol>
<p style="padding-left: 60px">This will be displayed by prompting the previous URL:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/5f347c04-adad-4a07-acf2-794521794387.png" style="width:35.00em;height:5.25em;"/></div>
<ol start="17">
<li>Now, as you did for the MapService WMS, test the GeoServer WMS in QGIS. Create a WMS connection named <kbd>GeoServer on localhost</kbd>, pointing to the GeoServer <kbd>GetCapabilities</kbd> document (<kbd>http://localhost:8080/geoserver/ows?service=wms&amp;version=1.3.0&amp;request=GetCapabilities</kbd>). Then, connect to the WMS server (for example, from the QGIS browser), select <kbd>counties</kbd> from the <span class="packt_screen">Layers</span> list, and add it to the map, as shown in the following screenshot; then navigate the layer and try to identify some of the features:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/9f2dcd78-4399-4edf-ad1c-8e72aa855614.png"/></div>
<ol start="18">
<li>Having used WMS, try to test a couple of WFS requests. A typical WFS <kbd>GetCapability</kbd> request can be executed by typing the URL <kbd>http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.1.0&amp;request=GetCapabilities</kbd>. You could also click on one of the WFS links on the home page of the GeoServer web interface.</li>
<li>Investigate the XML <kbd>GetCapabilities</kbd> response and try to identify the information about your layer. You should have a <kbd>&lt;FeatureType&gt;</kbd> element, such as the following, corresponding to the <kbd>counties</kbd> layer:</li>
</ol>
<pre>        &lt;FeatureType&gt; 
          &lt;Name&gt;postgis_cookbook:counties&lt;/Name&gt; 
          &lt;Title&gt;counties&lt;/Title&gt; 
          &lt;Abstract/&gt; 
          &lt;Keywords&gt;counties, features&lt;/Keywords&gt; 
          &lt;SRS&gt;EPSG:4326&lt;/SRS&gt; 
          &lt;LatLongBoundingBox minx="-179.133392333984" <br/>           miny="17.6746921539307" maxx="-64.566162109375" <br/>           maxy="71.3980484008789"/&gt; 
        &lt;/FeatureType&gt;</pre>
<ol start="20">
<li>As shown in the previous recipe, a typical WFS request is <kbd>GetFeature</kbd>, which will result in a GML response. Try it by typing the URL <kbd>http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.0.0&amp;request=GetFeature&amp;typeName=postgis_cookbook:counties&amp;maxFeatures=5</kbd> in your browser. You will receive a GML output composed of a <kbd>&lt;wfs:FeatureCollection&gt;</kbd> element and a collection of <kbd>&lt;gml:featureMember&gt;</kbd> elements (possibly five elements, as specified in the <kbd>maxFeatures</kbd> request's parameter). You will get an output that is similar to the following code:</li>
</ol>
<pre>        &lt;gml:featureMember&gt; 
          &lt;postgis_cookbook:counties fid="counties.3962"&gt; 
            &lt;postgis_cookbook:the_geom&gt; 
              &lt;gml:Polygon srsName="http://www.opengis.net/<br/>               gml/srs/epsg.xml#4326"&gt; 
                &lt;gml:outerBoundaryIs&gt; 
                  &lt;gml:LinearRing&gt; 
                    &lt;gml:coordinates xmlns:gml=<br/>                     "http://www.opengis.net/gml" <br/>                     decimal="." cs="," ts=""&gt; 
                     -101.62554932,36.50246048 -<br/>                     101.0908432,36.50032043 ... 
                     ... 
                     ... 
                    &lt;/gml:coordinates&gt; 
                  &lt;/gml:LinearRing&gt; 
                &lt;/gml:outerBoundaryIs&gt; 
              &lt;/gml:Polygon&gt; 
            &lt;/postgis_cookbook:the_geom&gt; 
             &lt;postgis_cookbook:area&gt;0.240&lt;/postgis_cookbook:area&gt; 
            &lt;postgis_cookbook:perimeter&gt;1.967<br/>            &lt;/postgis_cookbook:perimeter&gt; 
            &lt;postgis_cookbook:co2000p020&gt;3963.0<br/>            &lt;/postgis_cookbook:co2000p020&gt; 
             &lt;postgis_cookbook:state&gt;TX&lt;/postgis_cookbook:state&gt; 
            &lt;postgis_cookbook:county&gt;Hansford <br/>             County&lt;/postgis_cookbook:county&gt; 
             &lt;postgis_cookbook:fips&gt;48195&lt;/postgis_cookbook:fips&gt; 
            &lt;postgis_cookbook:state_fips&gt;48<br/>            &lt;/postgis_cookbook:state_fips&gt; 
            &lt;postgis_cookbook:square_mil&gt;919.801<br/>            &lt;/postgis_cookbook:square_mil&gt; 
          &lt;/postgis_cookbook:counties&gt; 
        &lt;/gml:featureMember&gt;</pre>
<ol start="21">
<li>Now, as you did with WMS, try the <span class="packt_screen">counties</span> WFS in QGIS (or in your favorite desktop GIS client). Create a new WFS connection by using either the QGIS browser or the <span class="packt_screen">Add WFS Layer</span> button and then clicking on the <span class="packt_screen">New Connection</span> button. In the <span class="packt_screen">Create a new WFS connection</span> dialog box, type <kbd>GeoServer on localhost</kbd> in the <span class="packt_screen">Name</span> field and add the WFS <kbd>GetCapabilities</kbd> URL (<kbd>http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.1.0&amp;request=GetCapabilities</kbd>) in the <span class="packt_screen">URL</span> field.</li>
<li>Add the WFS <kbd>counties</kbd> layer from the previous dialog box and, as a test, select some of the counties and export them to a new shapefile using the <span class="packt_screen">Save As</span> command from the layer's context menu, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/febf1b0e-d10c-4b74-83b0-f53424461ea6.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, you were introduced to the basic concepts of the OGC WMS and WFS standards using MapServer. In this recipe, you have done the same using another popular open source web-mapping engine, GeoServer.</p>
<p>Unlike MapServer, which is written in C and can be used from web servers such as Apache HTTP (HTTPD) or Microsoft <strong>Internet Information Server</strong> (<strong>IIS</strong>) as a CGI program, GeoServer is written in Java and needs a servlet container such as Apache Tomcat or Eclipse Jetty to work.</p>
<p>GeoServer not only offers the user a highly scalable and standard web-mapping engine implementation, but does so with a nice user interface, the Web Administration interface. Therefore, it is generally easier for a beginner to create WMS and WFS services compared to MapServer, where it is necessary to master the mapfile syntax.</p>
<p>The GeoServer workflow to create WMS and WFS services for a PostGIS layer is to first create a PostGIS store, where you need to associate the main PostGIS connection parameters (server name, schema, user, and so on). After the store is correctly created, you can publish the layers that are available for that PostGIS store. You have seen in this recipe how easy the whole process is using the GeoServer Web Administration interface.</p>
<p>To define the layer style to render features, GeoServer uses the SLD schema, an OGC standard based on XML. We have written two distinct rules in this recipe to render the counties that have an area greater than 5,000 square miles an area greater than 5,000 square miles in a different way from the others. For the purpose of rendering the counties in a different way, we have used two <kbd>&lt;ogc:Rule&gt;</kbd> SLD elements in which you have defined an <kbd>&lt;ogc:Filter&gt;</kbd> element. For each of these elements, you have defined the criteria to filter the layer features, using the <kbd>&lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;</kbd> and <kbd>&lt;ogc:PropertyIsLessThan&gt;</kbd> elements. A very handy way to generate an SLD for a layer is using desktop GIS tools that are able to export an SLD file for a layer (QGIS can do this). After exporting the file, you can upload it to GeoServer by copying the SLD file content to the <span class="packt_screen">Add a new style</span> page.</p>
<p>Having created the WMS and WFS services for the counties layer, you have been testing them by generating the requests using the handy Layer Preview GeoServer interface (based on OpenLayers) and then typing the requests directly in a browser. You can modify each service request's parameters from the Layer Preview interface or just by changing them in the URL query string.</p>
<p>Finally, you tested the services using QGIS and have seen how it is possible to export some of the layer's features using the WFS service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>If you want more information about GeoServer, you can check out its excellent documentation at <a href="http://docs.geoserver.org/"><span class="URLPACKT">http://docs.geoserver.org/</span></a> or get the wonderful <em>GeoServer Beginner's Guide</em> book by Packt Publishing (<a href="http://www.packtpub.com/geoserver-share-edit-geospatial-data-beginners-guide/book"><span class="URLPACKT">http://www.packtpub.com/geoserver-share-edit-geospatial-data-beginners-guide/book</span></a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a WMS Time service with MapServer</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will implement a WMS Time with MapServer. For time-series data, and whenever you have geographic data that is updated continuously and you need to expose it as a WMS in a Web GIS, WMS Time is the way to go. This is possible by providing the <kbd>TIME</kbd> parameter a time value in the WMS requests, typically in the <kbd>GetMap</kbd> request.</p>
<p>Here, you will implement a WMS Time service for the hotspots, representing possible fire data acquired by NASA's <strong>Earth Observing System Data and Information System</strong> (<strong>EOSDIS</strong>). This excellent system provides data derived from MODIS images from the last 24 hours, 48 hours, and 7 days, which can be downloaded in shapefile, KML, WMS, or text file formats. You will load a bunch of this data to PostGIS, create a WMS Time service with MapServer, and test the WMS <kbd>GetCapabilities</kbd> and <kbd>GetMap</kbd> requests using a common browser.</p>
<div class="packt_infobox">If you are new to the WMS standard, please check the previous two recipes to get more information.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>First, download one week's worth of active fire data (hotspots) from the EOSDIS website. For example, Firedata from EOSDIS can be found in this link: <a href="https://earthdata.nasa.gov/earth-observation-data/near-real-time/firms/active-fire-data">https://earthdata.nasa.gov/earth-observation-data/near-real-time/firms/active-fire-data</a>. A copy of this shapefile is included in the book code bundle. Use that if you want to use the SQL and WMS parameters that have been used in the following steps.</li>
<li>Extract the shapefile from the <kbd>Global_7d.zip</kbd> archive to the <kbd>working/chp09</kbd> directory and import this shapefile in PostGIS using the <kbd>shp2pgsql</kbd> command, as follows:</li>
</ol>
<pre>      <strong>$ shp2pgsql -s 4326 -g the_geom -I <br/>      MODIS_C6_Global_7d.shp chp09.hotspots &gt; hotspots.sql</strong>
      <strong>$ psql -U me -d postgis_cookbook -f hotspots.sql</strong></pre>
<ol start="3">
<li>When the import is completed, check the point fire data (hotspots) you just imported in PostGIS. Each hotspot contains a bunch of useful information, most notably the geometry and the acquisition date and time stored in the <kbd>acq_date</kbd> and <kbd>acq_time</kbd> fields. You can easily see that the features loaded from the shapefile span eight consecutive days using the following command:</li>
</ol>
<pre>      <strong>postgis_cookbook=# SELECT acq_date, count(*) AS hotspots_count <br/>      FROM chp09.hotspots GROUP BY acq_date ORDER BY acq_date;</strong></pre>
<p style="padding-left: 60px">The previous command will produce the following output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/b4076998-8aa8-4191-a0e4-d675f64a9e67.png" style="width:15.33em;height:15.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>We will first create a WMS for the PostGIS hotspot layer. Create a <kbd>mapfile</kbd> named <kbd>hotspots.map</kbd> in a directory accessible to the HTTPD (or IIS) user (for example, <kbd>/var/www/data</kbd> in Linux, <kbd>/Library/WebServer/Documents/</kbd> for macOS, and <kbd>C:\ms4w\Apache\htdocs</kbd> in Windows), by executing the following code after adjusting the database connection settings:</li>
</ol>
<pre>        MAP # Start of mapfile 
          NAME 'hotspots_time_series' 
          IMAGETYPE         PNG 
          EXTENT            -180 -90 180 90 
          SIZE              800 400 
          IMAGECOLOR        255 255 255 
 
          # map projection definition 
          PROJECTION 
            'init=epsg:4326' 
          END 
 
          # a symbol for hotspots 
          SYMBOL 
            NAME "circle" 
            TYPE ellipse 
            FILLED true 
            POINTS 
              1 1 
            END 
          END 
 
          # web section: here we define the ows services 
          WEB 
            # WMS and WFS server settings 
            METADATA 
              'wms_name'                'Hotspots' 
              'wms_title'               'World hotspots time <br/>                                         series' 
              'wms_abstract'            'Active fire data detected <br/>                                        by NASA Earth Observing <br/>                                        System Data and Information <br/>                                        System (EOSDIS)' 
              'wms_onlineresource'      'http://localhost/cgi-bin/<br/>                                        mapserv?map=/var/www/data/<br/>                                        hotspots.map&amp;' 
              'wms_srs'                 'EPSG:4326 EPSG:3857' 
              'wms_enable_request' '*' 
              'wms_feature_info_mime_type'  'text/html' 
            END 
          END 
 
          # Start of layers definition 
          LAYER # Hotspots point layer begins here 
            NAME            hotspots 
            CONNECTIONTYPE  POSTGIS 
            CONNECTION      'host=localhost dbname=postgis_cookbook <br/>                             user=me 
                             password=mypassword port=5432' 
            DATA            'the_geom from chp09.hotspots' 
            TEMPLATE 'template.html' 
            METADATA 
              'wms_title'                   'World hotspots time <br/>                                             series' 
              'gml_include_items' 'all' 
            END 
            STATUS          ON 
            TYPE            POINT 
            CLASS 
              SYMBOL 'circle' 
              SIZE 4 
              COLOR        255 0 0 
            END # end of class 
 
          END # hotspots layer ends here 
 
        END # End of mapfile </pre>
<ol start="2">
<li>Check whether the WMS GetCapabilities request for this mapfile is working well by typing the following URLs in the browser:
<ul>
<li><kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&amp;SERVICE=WMS&amp;VERSION=1.0.0&amp;REQUEST=GetCapabilities</kbd> <span>(in Linux)</span></li>
<li><kbd>http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdoc\shotspots.map&amp;SERVICE=WMS&amp;VERSION=1.0.0&amp;REQUEST=GetCapabilities</kbd> <span>(in Windows)</span></li>
<li><kbd>http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/hotspots.map&amp; SERVICE=WMS&amp;VERSION=1.0.0&amp;REQUEST=GetCapabilities</kbd> <span>(in macOS)</span></li>
</ul>
</li>
</ol>
<p>In the following steps, we will be referring to Linux. If you are using Windows, you just need to replace <kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map</kbd> with <kbd>http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdoc\shotspots.map</kbd>; or if using macOS, replace it with <kbd>http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/hotsposts.map</kbd> in every request:</p>
<ol>
<li>Now query the WMS service with a <kbd>GetMap</kbd> request. Type the following URL in the browser. If everything is correct, MapServer should return an image with some hotspots as a response. The URL is <kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&amp;&amp;SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetMap&amp;BBOX=-25,-100,35,-35&amp;CRS=EPSG:4326&amp;WIDTH=1000&amp;HEIGHT=800&amp;LAYERS=hotspots&amp;STYLES=&amp;FORMAT=image/png</kbd>.</li>
</ol>
<p style="padding-left: 60px">The map displayed on your browser will look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e87157b9-e037-468c-96d7-d43bf066454b.png"/></div>
<ol start="2">
<li>Until now, you have implemented a simple WMS service. Now, to make the <kbd>TIME</kbd> parameter available for WMS Time requests, add the <kbd>wms_timeextent</kbd>, <kbd>wms_timeitem</kbd> and <kbd>wms_timedefault</kbd> variables in the <kbd>LAYER METADATA</kbd> section, as follows:</li>
</ol>
<pre>        METADATA 
          'wms_title'                   'World hotspots time <br/>                                         series' 
          'gml_include_items' 'all' 
          'wms_timeextent' '2000-01-01/2020-12-31' # time extent <br/>            for which the service will give a response 
          'wms_timeitem' 'acq_date' # layer field to use to filter <br/>            on the TIME parameter 
          'wms_timedefault' '2013-05-30' # default parameter if not <br/>            added to the request 
        END </pre>
<ol start="3">
<li>Having added these parameters in the <kbd>LAYER METADATA</kbd> mapfile section, the WMS <kbd>GetCapabilities</kbd> response should change. Now, the hotspots layer definition includes the time dimension, defined by the <kbd>&lt;Dimension&gt;</kbd> and <kbd>&lt;Extent&gt;</kbd> elements. You will get a response, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e238ef42-eef4-4b4e-b1ab-9d837b6dadb7.png" style="text-align: center;font-size: 1em;width:42.25em;height:21.17em;"/></div>
<ol start="4">
<li>You can finally test the WMS service with time support. You only need to remember to add the <kbd>TIME</kbd> parameter in the <kbd>GetMap</kbd> request (otherwise, <kbd>GetMap</kbd> will filter out the data using the default date, which is <kbd>2017-12-12</kbd> in this example) using the URL <kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&amp;&amp;SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetMap&amp;BBOX=-25,-100,35,-35&amp;CRS=EPSG:4326&amp;WIDTH=1000&amp;HEIGHT=800&amp;LAYERS=hotspots&amp;STYLES=&amp;FORMAT=image/png&amp;TIME=2017-12-10</kbd>.</li>
<li>Play for a while with the <kbd>TIME</kbd> parameter in the preceding URL and try to see how the GetMap image response changes day by day. Remember that, for the dataset we imported, the <kbd>acq_date</kbd> range is from <kbd>2017-12-07</kbd> to <kbd>2017-12-14</kbd>; but in your case, if you didn't use the hostpots shapefile included in the book dataset, the time range will be different!<br/>
The following are different outputs for the mentioned dates and the full URLs used to query the service:
<ul>
<li><kbd>http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&amp;&amp;SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetMap&amp;BBOX=-25,-100,35,-35&amp;CRS=EPSG:4326&amp;WIDTH=1000&amp;HEIGHT=800&amp;LAYERS=hotspots&amp;STYLES=&amp;FORMAT=image/png&amp;TIME=2017-12-14</kbd>. The output is as follows (2017-12-14):</li>
</ul>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/04511f88-e1af-4723-82cf-036066eea89f.png" style="width:82.08em;height:50.08em;"/></div>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd><span>http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&amp;&amp;SERVICE=WMS&amp;VERSION=1.3.0&amp;REQUEST=GetMap&amp;BBOX=-25,-100,35,-35&amp;CRS=EPSG:4326&amp;WIDTH=1000&amp;HEIGHT=800&amp;LAYERS=hotspots&amp;STYLES=&amp;FORMAT=image/png&amp;TIME=2017-12-07</span></kbd><span>. The output is as follows (2017-12-07):</span></li>
</ul>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d25c2dbd-3f54-4402-8524-366b585e7519.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you have seen how to create a WMS Time service using the MapServer open source web-mapping engine. A WMS Time service is useful for whenever you have temporal series and geographic data varying in the time. WMS Time lets the user filter the requested data by providing a <kbd>TIME</kbd> parameter with a time value in the WMS requests.</p>
<p>For this purpose, you first created a plain WMS; if you are new to the WMS standard, mapfile, and MapServer, you can check out the first recipe in this chapter. You have imported in PostGIS a points shapefile with one week's worth of hotspots derived from the MODIS satellite and created a simple WMS for this layer.</p>
<p>After verifying that this WMS works well by testing the WMS <kbd>GetCapabilities</kbd> and <kbd>GetMap</kbd> requests, you have time enabled the WMS by adding three parameters in the <kbd>LAYER METADATA</kbd> mapfile section: <kbd>wms_timeextent</kbd>, <kbd>wms_timeitem</kbd>, and <kbd>wms_timedefault</kbd>.</p>
<p>The <kbd>wms_timeextent</kbd> parameter is the duration of time in which the service will give a response. It defines the PostGIS <kbd>table</kbd> field to be used to filter the <kbd>TIME</kbd> parameter (the <kbd>acq_date</kbd> field in this case). The <kbd>wms_timedefault</kbd> parameter specifies a default time value to be used when the request to the WMS service does not provide the <kbd>TIME</kbd> parameter.</p>
<p>At this point, the WMS is time enabled; this means that the WMS GetCapabilities request now includes the time-dimension definition for the PostGIS hotspots layer and, more importantly, the GetMap WMS request lets the user add the <kbd>TIME</kbd> parameter to query the layer for a specific date.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming WMS services with OpenLayers</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will use the MapServer and Geoserver WMS you created in the first two recipes of this chapter using the OpenLayers open source JavaScript API.</p>
<p>This excellent library helps developers quickly assemble web pages using mapping viewers and features. In this recipe, you will create an HTML page, add an OpenLayers map in it and a bunch of controls in that map for navigation, switch the layers, and identify features of the layers. We will also look at two WMS layers pointing to the PostGIS tables, implemented with MapServer and GeoServer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>MapServer uses <em>PROJ.4</em> (<a href="https://trac.osgeo.org/proj/)"><span class="URLPACKT">https://trac.osgeo.org/proj/</span>)</a> for projection management. This library does not exist by default with the <em>Spherical Mercator</em> projection (<em>EPSG:900913</em>) defined. Such a projection is commonly used by commercial map API providers, such as GoogleMaps, Yahoo! Maps, and Microsoft Bing, and can provide excellent base layers for your maps.</p>
<p>For this recipe, we need to have under consideration the following:</p>
<ol>
<li>Due to security restrictions in JavaScript, it is not possible to retrieve information from remote domains using <kbd>XMLHttpRequest</kbd>. You will encounter this issue in the recipe when you send a WMS <kbd>GetFeatureInfo</kbd> request to a GeoServer that is typically running on Tomcat at port 8080 and also send a request from an HTML page running on Apache or ISS at port 80. Therefore, unless you run your GeoServer instance using HTTPD URL rewriting, the solution is to create a proxy script.</li>
<li>Copy the proxy script included in the book dataset to the web <kbd>cgi</kbd> directory of your computer (in Linux, at <kbd>/usr/lib/cgi-bin</kbd>/, in macOS, at <kbd>/Library/WebServer/CGI-Executables,</kbd> and in Windows, at <kbd>C:\ms4w\Apache\cgi-bin</kbd>), open the proxy.<kbd>cgi</kbd> file, and add <kbd>localhost:8080</kbd> to the <kbd>allowedHosts</kbd> list.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>Create the <kbd>openlayers.html</kbd> file and add the <kbd>&lt;head&gt;</kbd> and <kbd>&lt;body&gt;</kbd> tags. In the <kbd>&lt;head&gt;</kbd> tag, import the OpenLayers JavaScript library by executing the following code:</li>
</ol>
<pre>        &lt;!doctype html&gt; 
        &lt;html&gt; 
          &lt;head&gt; 
            &lt;title&gt;OpenLayers Example&lt;/title&gt; 
            &lt;script src="http://openlayers.org/api/OpenLayers.js"&gt;<br/>            &lt;/script&gt; 
          &lt;/head&gt; 
          &lt;body&gt; 
          &lt;/body&gt; 
        &lt;/html&gt; </pre>
<ol start="2">
<li>First, add a <kbd>&lt;div&gt;</kbd> element in the <kbd>&lt;body&gt;</kbd> tag that will contain the OpenLayers map. The map should be given a width of 900 pixels and a height of 500 pixels, using the following code:</li>
</ol>
<pre>        &lt;div style="width:900px; height:500px" id="map"&gt;&lt;/div&gt;</pre>
<ol start="3">
<li>Just after the map is placed in <kbd>&lt;div&gt;</kbd>, add a JavaScript script and create an OpenLayers <kbd>map</kbd> object. In the map constructor parameters, you will add an empty <kbd>controls</kbd> array and declare that the map has a Spherical Mercator's projection, as shown in the following code:</li>
</ol>
<pre>        &lt;script defer="defer" type="text/javascript"&gt; 
          // instantiate the map object 
          var map = new OpenLayers.Map("map", { 
            controls: [], 
            projection: new OpenLayers.Projection("EPSG:3857") 
          }); 
        &lt;/script&gt; </pre>
<ol start="4">
<li>Right after the <kbd>map</kbd> variable is declared, add some OpenLayers controls to the map. For the web GIS viewer you are creating, you will add the <kbd>Navigation</kbd> control (which handles map browsing with mouse events, such as dragging, double-clicking, and scrolling the wheel), the <kbd>PanZoomBar</kbd> control (a four-direction navigation using the arrows present above the zooming vertical slider), the <kbd>LayerSwitcher</kbd> control (which handles the switching on and off of layers added to the map), and the <kbd>MousePosition</kbd> control (which displays the map coordinates as they change while the user is moving the mouse), using the following code:</li>
</ol>
<pre>        // add some controls on the map 
        map.addControl(new OpenLayers.Control.Navigation()); 
        map.addControl(new OpenLayers.Control.PanZoomBar()), 
        map.addControl(new OpenLayers.Control.LayerSwitcher( 
           {"div":OpenLayers.Util.getElement("layerswitcher")})); 
        map.addControl(new OpenLayers.Control.MousePosition()); </pre>
<ol start="5">
<li>Now create an OSM base layer, using the following code:</li>
</ol>
<pre>        // set the OSM layer 
        var osm_layer = new OpenLayers.Layer.OSM();</pre>
<ol start="6">
<li>Set two variables for the WMS GeoServer and the MapServer URL that you will use (they are the URLs of the services you created in the first two recipes of this chapter):</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>For Linux, add the following code:</li>
</ul>
</li>
</ul>
<pre>                // set the WMS 
                var geoserver_url = "http://localhost:8080/geoserver/wms"; 
                var mapserver_url = http://localhost/cgi-<br/>                bin/mapserv?map=/var/www/data/countries.map&amp; </pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>For Windows, add the following code:</li>
</ul>
</li>
</ul>
<pre>                // set the WMS 
                var geoserver_url = "http://localhost:8080/geoserver/wms"; 
                var mapserver_url = http://localhost/cgi-<br/>                bin/mapserv.exe?map=C:\\ms4w\\Apache\\<br/>                htdocs\\countries.map&amp;</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>For macOS, add the following code:</li>
</ul>
</li>
</ul>
<pre>               // set the WMS 
               var geoserver_url = "http://localhost:8080/geoserver/wms"; 
               var mapserver_url = http://localhost/cgi-<br/>               bin/mapserv? map=/Library/WebServer/<br/>               Documents/countries.map&amp; </pre>
<ol start="7">
<li>Now, create a WMS GeoServer layer to display the OpenLayers map the counties from the PostGIS layer. You will set an opacity for this layer, so that it is possible to see the other layer (counties) behind it. The <kbd>isBaseLayer</kbd> property is set to <kbd>false</kbd>, since you want to have this layer over the Google Maps base layers and not as an alternative to them (by default, all of the WMS layers in OpenLayers are considered to be base layers). Create the WMS GeoServer layer, using the following code:</li>
</ol>
<pre>        // set the GeoServer WMS 
        var geoserver_wms = new OpenLayers.Layer.WMS( "GeoServer WMS", 
        geoserver_url, 
        { 
          layers: "postgis_cookbook:counties", 
          transparent: "true", 
          format: "image/png", 
        }, 
        { 
          isBaseLayer: false, 
          opacity: 0.4 
        } ); </pre>
<ol start="8">
<li>Now, create a WMS MapServer layer to display the countries from the PostGIS layer in the OpenLayers map, using the following code:</li>
</ol>
<pre>        // set the MapServer WMS 
        var mapserver_wms = new OpenLayers.Layer.WMS( "MapServer WMS", 
        mapserver_url, 
        { 
          layers: "countries", 
          transparent: "true", 
          format: "image/png", 
        }, 
        { 
          isBaseLayer: false 
        } ); </pre>
<ol start="9">
<li>After creating the OSM and WMS layers, you need to add all of them to the map, using the following code:</li>
</ol>
<pre>        // add all of the layers to the map 
        map.addLayers([mapserver_wms, geoserver_wms, osm_layer]); 
        map.zoomToMaxExtent(); 
        Proxy... 
        // add the WMSGetFeatureInfo control 
        OpenLayers.ProxyHost = "/cgi-bin/proxy.cgi?url="; </pre>
<ol start="10">
<li>You want to provide the user the possibility to identify features of the counties WMS. Add the <kbd>WMSGetFeatureInfo</kbd> OpenLayers control (which will send <kbd>GetFeatureInfo</kbd> requests to the WMS behind the scenes) that points to the counties PostGIS layer served by the GeoServer WMS, using the following code:</li>
</ol>
<pre>        var info = new OpenLayers.Control.WMSGetFeatureInfo({ 
          url: geoserver_url, 
          title: 'Identify', 
          queryVisible: true, 
          eventListeners: { 
            getfeatureinfo: function(event) { 
              map.addPopup(new OpenLayers.Popup.FramedCloud( 
                "WMSIdentify", 
                map.getLonLatFromPixel(event.xy), 
                null, 
                event.text, 
                null, 
                true 
              )); 
            } 
          } 
        }); 
        map.addControl(info); 
        info.activate(); </pre>
<ol start="11">
<li>Finally, set the center of the map and its initial zoom level, using the following code:</li>
</ol>
<pre>        // center map 
        var cpoint = new OpenLayers.LonLat(-11000000, 4800000); 
        map.setCenter(cpoint, 3); </pre>
<p>Your HTML file should now look like the <kbd>openlayers.html</kbd> file contained in <kbd>data/chp09</kbd>. You can finally deploy this file to your web server (Apache HTTPD or IIS). If you are using Apache HTTPD in Linux, you could copy the file to the <kbd>data</kbd> directory under <kbd>/var/www</kbd>, and if you are using Windows, you could copy it to the data directory under <kbd>C:\ms4w\Apache\htdocs</kbd> (create the <kbd>data</kbd> directory if it does not already exist). Then, access it using the URL <kbd>http://localhost/data/openlayers.html</kbd>.</p>
<p>Now, access the <kbd>openlayers</kbd> web page using your favorite browser. Start browsing the map: zoom, pan, try to switch the base and overlays layers on and off using the layer switcher control, and try to click on a point to identify one feature from the counties PostGIS layer. A map is shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/85867693-84b9-4bb5-a267-ea322c71b098.png" style="width:40.50em;height:22.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works..</h1>
                </header>
            
            <article>
                
<p>You have seen how to create a web map viewer with the <em>OpenLayers</em> JavaScript library. This library lets the developer define the various map components, using JavaScript in an HTML page. The core object is a map that is composed of <em>controls</em> and <em>layers</em>.</p>
<p>OpenLayers comes with a great number of controls (<a href="http://dev.openlayers.org/docs/files/OpenLayers/Control-js.html"><span class="URLPACKT">http://dev.openlayers.org/docs/files/OpenLayers/Control-js.html</span></a>), and it is even possible to create custom ones.</p>
<p>Another great OpenLayers feature is the ability to add a good number of geographic data sources as layers in the map (you added just a couple of its types to the map, such as OpenStreetMap and WMS) and you could add sources, such as WFS, GML, KML, GeoRSS, OSM data, ArcGIS Rest, TMS, WMTS, and WorldWind, just to name a few.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming WMS services with Leaflet</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, you have seen how to create a webGIS using the OpenLayers JavaScript API and then added the WMS PostGIS layers served from MapServer and GeoServer .</p>
<p>A lighter alternative to the widespread OpenLayers JavaScript API was created, named <strong>Leaflet</strong>. In this recipe, you will see how to use this JavaScript API to create a webGIS, add a WMS layer from PostGIS to this map, and implement an <em>identify tool,</em> sending a <kbd>GetFeatureInfo</kbd> request to the MapServer WMS. However, unlike OpenLayers, Leaflet does not come with a <kbd>WMSGetFeatureInfo</kbd> control, so we will see in this recipe how to create this functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>Create a new HTML file and name it <kbd>leaflet.html</kbd> (available in the book source code package). Open it and add the <kbd>&lt;head&gt;</kbd> and <kbd>&lt;body&gt;</kbd> tags. In the <kbd>&lt;head&gt;</kbd> section, import the Leaflet CSS and JavaScript libraries and the jQuery JavaScript library (you will use jQuery to send an AJAX request to the <kbd>GetFeatureInfo</kbd> from the MapServer WMS):</li>
</ol>
<pre>        &lt;html&gt; 
          &lt;head&gt; 
            &lt;title&gt;Leaflet Example&lt;/title&gt; <br/>            &lt;link rel="stylesheet" <br/>             href= "https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" /&gt; <br/>            &lt;script src= "https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"&gt;<br/>            &lt;/script&gt; <br/>            &lt;script src="http://ajax.googleapis.com/ajax/<br/>                    libs/jquery/1.9.1/jquery.min.js"&gt;<br/>            &lt;/script&gt; 
          &lt;/head&gt; 
          &lt;body&gt; 
          &lt;/body&gt; 
        &lt;/html&gt; </pre>
<ol start="2">
<li>Start adding a <kbd>&lt;div&gt;</kbd> tag in the <kbd>&lt;body&gt;</kbd> element to include the Leaflet map in your file, as shown in the following code; the map will have a width of 800 pixels and a height of 500 pixels:</li>
</ol>
<pre>        &lt;div id="map" style="width:800px; height:500px"&gt;&lt;/div&gt; </pre>
<ol start="3">
<li>Just after the <kbd>&lt;div&gt;</kbd> element containing the map, add the following JavaScript code. Create a Leaflet <kbd>tileLayer</kbd> object using the <kbd>tile.osm.org</kbd> service based on <kbd>OpenStreetMap</kbd> data:</li>
</ol>
<pre>        &lt;script defer="defer" type="text/javascript"&gt; 
          // osm layer 
          var osm = L.tileLayer('http://{s}.tile.osm.org<br/>                    /{z}/{x}/{y}.png', { 
            maxZoom: 18, 
            attribution: "Data by OpenStreetMap" 
          }); 
        &lt;/script&gt;</pre>
<ol start="4">
<li>Create a second layer that will use the MapServer WMS you created a few recipes ago in this chapter. You will need to set the <kbd>ms_url</kbd> variable differently if you're using Linux, Windows, or macOS:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>For Linux, use the following code:</li>
</ul>
</li>
</ul>
<pre>                // mapserver layer 
                var ms_url = "http://localhost/cgi-bin/mapserv?<br/>                  map=/var/www/data/countries.map&amp;"; 
                var countries = L.tileLayer.wms(ms_url, { 
                  layers: 'countries', 
                  format: 'image/png', 
                  transparent: true, 
                  opacity: 0.7 
                }); </pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>For Windows, use the following code:</li>
</ul>
</li>
</ul>
<pre>                // mapserver layer 
                var ms_url = "http://localhost<br/>                  /cgi-bin/mapserv.exe?map=C:%5Cms4w%5CApache%5<br/>                  Chtdocs%5Ccountries.map&amp;"; 
                var countries = L.tileLayer.wms(ms_url, { 
                  layers: 'countries', 
                  format: 'image/png', 
                  transparent: true, 
                  opacity: 0.7 
                }); </pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>For macOS, use the following code:</li>
</ul>
</li>
</ul>
<pre>                // mapserver layer 
                var ms_url = "http://localhost/cgi-bin/mapserv?<br/>                  map=/Library/WebServer/Documents/countries.map&amp;"; 
                var countries = L.tileLayer.wms(ms_url, { 
                  layers: 'countries', 
                  format: 'image/png', 
                  transparent: true, 
                  opacity: 0.7 
                });</pre>
<ol start="5">
<li>Create the Leaflet <kbd>map</kbd> and add layers to it, as shown in the following code:</li>
</ol>
<pre>        // map creation 
        var map = new L.Map('map', { 
          center: new L.LatLng(15, 0), 
          zoom: 2, 
          layers: [osm, countries], 
          zoomControl: true 
        }); </pre>
<ol start="6">
<li>Now, associate the mouse-click event with a function that will perform the <kbd>GetFeatureInfo</kbd> WMS request on the <kbd>countries</kbd> layer, by executing the following code:</li>
</ol>
<pre>        // getfeatureinfo event 
        map.addEventListener('click', Identify); 
 
        function Identify(e) { 
          // set parameters needed for GetFeatureInfo WMS request 
          var BBOX = map.getBounds().toBBoxString(); 
          var WIDTH = map.getSize().x; 
          var HEIGHT = map.getSize().y; 
          var X = map.layerPointToContainerPoint(e.layerPoint).x; 
          var Y = map.layerPointToContainerPoint(e.layerPoint).y; 
          // compose the URL for the request 
          var URL = ms_url + 'SERVICE=WMS&amp;VERSION=1.1.1&amp;<br/>          REQUEST=GetFeatureInfo&amp;LAYERS=countries&amp;<br/>           QUERY_LAYERS=countries&amp;BBOX='+BBOX+'&amp;FEATURE_COUNT=1&amp;<br/>          HEIGHT='+HEIGHT+'&amp;WIDTH='+WIDTH+'&amp;<br/>           INFO_FORMAT=text%2Fhtml&amp;SRS=EPSG%3A4326&amp;X='+X+'&amp;Y='+Y; 
          //send the asynchronous HTTP request using <br/>          jQuery $.ajax 
          $.ajax({ 
            url: URL, 
            dataType: "html", 
            type: "GET", 
            success: function(data) { 
              var popup = new L.Popup({ 
                maxWidth: 300 
              }); 
              popup.setContent(data); 
              popup.setLatLng(e.latlng); 
              map.openPopup(popup); 
            } 
          }); 
        }</pre>
<ol start="7">
<li>Your HTML file should now look like the <kbd>leaflet.html</kbd> file contained in <kbd>data/chp09</kbd>. You can now deploy this file to your web server (that is, Apache HTTPD or IIS). If you are using Apache HTTPD in Linux, you could copy the file to the <kbd>/var/www/data directory</kbd>; if you are running macOS, copy it to <kbd>/Library/WebServer/Documents/data</kbd> ;and if you are using Windows, you could copy it to <kbd>C:\ms4w\Apache\htdocs\data</kbd> (create the data directory if it does not already exist). Then, access it with the URL <kbd>http://localhost/data/leaflet.html</kbd>.</li>
<li>Open the web page using your favorite browser, and start navigating the map; zoom, pan, and try to click on a point to identify one feature from the <kbd>countries</kbd> PostGIS layer, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/a8a53d0f-03f9-4596-a63c-8a45d3ed0927.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you have seen how to use the Leaflet JavaScript API library to add a map in an HTML page. First, you created one layer from an external server to use as the base map. Then, you created another layer using the MapServer WMS you implemented in a previous recipe to expose a PostGIS layer to the web. Then, you created a new map object and added it to these two layers. Finally, using jQuery, you implemented an AJAX call to the <kbd>GetFeatureInfo</kbd> WMS request and displayed the results in a Leaflet <kbd>Popup</kbd> object.</p>
<p>Leaflet is a very nice and compact alternative to the OpenLayers library and gives very good results when your webGIS service needs to be used from mobile devices, such as tablets and smart phones. Additionally, it has a plethora of plugins and can be easily integrated with JavaScript libraries, such as Raphael and JS3D.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Consuming WFS-T services with OpenLayers</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will create the <strong>Transactional Web Feature Service</strong> (<strong>WFS-T</strong>) from a PostGIS layer with the GeoServer open source web-mapping engine and then an OpenLayers basic application that will be able to use this service.</p>
<p>This way, the user of the application will be able to manage transactions on the remote PostGIS layer. WFS-T allows for the creation, deletion, and updating of features. In this recipe, you will allow the user to only to add features, but this recipe should put you on your way to creating more composite use cases.</p>
<p>If you are new to GeoServer and OpenLayers, you should first read the <em>Creating WMS and WFS services with GeoServer</em> and <em>Consuming WMS services with OpenLayers</em> recipes and then return to this one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>Create the proxy script and deploy it to your web server (that is, HTTPD or IIS), as indicated in the <em>Getting ready</em> section of the <em>Consuming WMS services with OpenLayers</em> recipe.</li>
<li>Create the following PostGIS points layer named <kbd>sites</kbd>:</li>
</ol>
<pre><strong>        CREATE TABLE chp09.sites 
        ( 
          gid serial NOT NULL, 
          the_geom geometry(Point,4326), 
          CONSTRAINT sites_pkey PRIMARY KEY (gid ) 
        ); 
        CREATE INDEX sites_the_geom_gist ON chp09.sites 
        USING gist (the_geom );</strong> </pre>
<ol start="3">
<li>Now create a PostGIS layer in GeoServer for the <kbd>chp09.sites</kbd> table. For more information on this, refer to the <em>Creating WMS and WFS services with GeoServer</em> recipe in this chapter.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>Create a new file named <kbd>wfst.html</kbd>. Open it and add the <kbd>&lt;head&gt;</kbd> and <kbd>&lt;body&gt;</kbd> tags. In the <kbd>&lt;head&gt;</kbd> tag, import the following <kbd>OpenLayers</kbd> library:</li>
</ol>
<pre>        &lt;html&gt; 
          &lt;head&gt; 
            &lt;title&gt;Consuming a WFS-T with OpenLayers&lt;/title&gt; 
            &lt;script <br/>             src="http://openlayers.org/api/OpenLayers.js"&gt;<br/>            &lt;/script&gt; 
          &lt;/head&gt; 
          &lt;body&gt; 
          &lt;/body&gt; 
        &lt;/html&gt; </pre>
<ol start="2">
<li>Add a <kbd>&lt;div&gt;</kbd> tag in the <kbd>&lt;body&gt;</kbd> tag to contain the OpenLayers map, as shown in the following code; the map will have a width of 700 pixels and a height of 400 pixels:</li>
</ol>
<pre>        &lt;div style="width:700px; height:400px" id="map"&gt;&lt;/div&gt;</pre>
<ol start="3">
<li>Just after the <kbd>&lt;div&gt;</kbd> tag is made to contain the map, add a JavaScript script. Inside the script, start setting <kbd>ProxyHost</kbd> to the web location where you deployed your proxy script. Then create a new OpenLayers map, as shown in the following code:</li>
</ol>
<pre>        &lt;script type="text/javascript"&gt; 
          // set the proxy 
          OpenLayers.ProxyHost = "/cgi-bin/proxy.cgi?url="; 
          // create the map 
          var map = new OpenLayers.Map('map'); 
        &lt;/script&gt; </pre>
<ol start="4">
<li>Now, in the script, after creating the map, create an <kbd>OpenStreetMap</kbd> layer that you will use in the map as the base layer, using the following code:</li>
</ol>
<pre>       // create an OSM base layer 
       var osm = new OpenLayers.Layer.OSM();</pre>
<ol start="5">
<li>Now, create the WFS-T layer's <kbd>OpenLayers</kbd> object using the <kbd>StyleMap</kbd> object to render the PostGIS layer features with red points, as shown in the following screenshot:</li>
</ol>
<pre>        // create the wfs layer 
        var saveStrategy = new OpenLayers.Strategy.Save(); 
        var wfs = new OpenLayers.Layer.Vector("Sites", 
        { 
          strategies: [new OpenLayers.Strategy.BBOX(), saveStrategy], 
          projection: new OpenLayers.Projection("EPSG:4326"), 
                      styleMap: new OpenLayers.StyleMap({ 
            pointRadius: 7, 
            fillColor: "#FF0000" 
          }), 
          protocol: new OpenLayers.Protocol.WFS({ 
            version: "1.1.0", 
            srsName: "EPSG:4326", 
            url: "http://localhost:8080/geoserver/wfs", 
            featurePrefix: 'postgis_cookbook', 
            featureType: "sites", 
            featureNS: "https://www.packtpub.com/application-development/<br/>                        postgis-cookbook-second-edition", 
            geometryName: "the_geom" 
          }) 
        });</pre>
<ol start="6">
<li>Add the WFS layer to the map, center align the map, and set the initial zoom. You can use the <kbd>geometry</kbd> transform method to convert a point from <kbd>EPSG:4326</kbd>, in which the layer is stored, to <kbd>ESPG:900913</kbd>, which is used by the viewer, as shown in the following code:</li>
</ol>
<pre>      // add layers to map and center it 
      map.addLayers([osm, wfs]); 
      var fromProjection = new OpenLayers.Projection("EPSG:4326"); 
      var toProjection   = new OpenLayers.Projection("EPSG:900913"); 
      var cpoint = new OpenLayers.LonLat(12.5, 41.85).transform( <br/>                   fromProjection, toProjection); 
      map.setCenter(cpoint, 10);</pre>
<ol start="7">
<li>Now, you will create a panel with a <em>Draw Point</em> tool (to add new features) and a <em>Save Features</em> tool (to save the features to the underlying WFS-T). We first create the panel, as shown in the following code:</li>
</ol>
<pre>        // create a panel for tools 
        var panel = new OpenLayers.Control.Panel({ 
          displayClass: "olControlEditingToolbar" 
        }); </pre>
<ol start="8">
<li>Now, we will create the <em>Draw Point</em> tool, as shown in the following code:</li>
</ol>
<pre>        // create a draw point tool 
        var draw = new OpenLayers.Control.DrawFeature( 
          wfs, OpenLayers.Handler.Point, 
          { 
            handlerOptions: {freehand: false, multi: false}, 
            displayClass: "olControlDrawFeaturePoint" 
          } 
        ); </pre>
<ol start="9">
<li>Then, we will create the <em>Save Features</em> tool, using the following code:</li>
</ol>
<pre>        // create a save tool 
        var save = new OpenLayers.Control.Button({ 
          title: "Save Features", 
          trigger: function() { 
            saveStrategy.save(); 
          }, 
          displayClass: "olControlSaveFeatures" 
        });</pre>
<ol start="10">
<li>Finally, add the tools to the panel, including a navigation control, and the panel as a control to the map, using the following code:</li>
</ol>
<pre>       // add tools to panel and add it to map 
       panel.addControls([ 
         new OpenLayers.Control.Navigation(), 
         save, draw 
       ]); 
       map.addControl(panel);</pre>
<ol start="11">
<li>Your HTML file should now look like the <kbd>wfst.html</kbd> file contained in the <kbd>chp09</kbd> directory. Deploy this file to your web server (that is, Apache HTTPD or IIS). If you are using Apache HTTPD in Linux, you could copy the file to the <kbd>data</kbd> directory under <kbd>/var/www</kbd>, whereas if you are using Windows, you could copy it to the data directory under <kbd>C:\ms4w\Apache\htdocs</kbd> (create the <kbd>data</kbd> directory if it does not already exist). Then, access it using <kbd>http://localhost/data/wfst.html</kbd>.</li>
<li>Open the web page using your favorite browser and start adding some points to the map. Now, click on the <span class="packt_screen">Save</span> button and reload the page; the previously added points should still be there, as they had been stored in the underlying <kbd>PostGIS</kbd> table by WFS-T, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-305 image-border" src="assets/abea301e-c5df-4a8b-8187-b7265c629b58.png" style="width:42.17em;height:23.92em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Added points using OpenLayers controls viewed on a browser</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you first created a point <kbd>PostGIS</kbd> table and then published it as WFS-T, using GeoServer. You then created a basic OpenLayers application, using the WFS-T layer, allowing the user to add features to the underlying PostGIS layer.</p>
<p>In OpenLayers, the core object needed to implement such a service is the vector layer by defining a WFS protocol. When defining the WFS protocol, you have to provide the WFS version that is using the spatial reference system of the dataset, the URI of the service, the name of the layer (for GeoServer, the name is a combination of the layer workspace, <kbd>FeaturePrefix</kbd>, and the layer name, <kbd>FeatureType</kbd>), and the name of the <kbd>geometry</kbd> field that will be modified. You also can pass to the Vector layer constructor a <kbd>StyleMap</kbd> value to define the layer's rendering behavior.</p>
<p>You then tested the application by adding some points to the OpenLayers map and checked that those points were effectively stored in PostGIS. When adding the points using the WFS-T layer, with the help of tools such as Firefox Firebug or Chrome (Chromium) Developer Tools, you could dig in detail into the requests that you are making to the WFS-T and its responses.</p>
<p>For example, when adding a point, you will see that an <kbd>Insert</kbd> request is sent to WFS-T. The following XML is sent to the service (note how the point geometry is inserted in the body of the <kbd>&lt;wfs:Insert&gt;</kbd> element):</p>
<pre>&lt;wfs:Transaction  <br/> service="WFS" version="1.1.0" <br/> xsi:schemaLocation="http://www.opengis.net/wfs <br/> http://schemas.opengis.net/wfs/1.1.0/wfs.xsd" <br/> &gt; 
  &lt;wfs:Insert&gt; 
    &lt;feature:sites &gt; 
      &lt;feature:the_geom&gt; 
<strong>        &lt;gml:Point  <br/>         srsName="EPSG:4326"&gt;<br/></strong><strong>          &lt;gml:pos&gt;12.450561523436999 41.94302128455888&lt;/gml:pos&gt;<br/></strong><strong>        &lt;/gml:Point&gt;</strong> 
              &lt;/feature:the_geom&gt; 
            &lt;/feature:sites&gt; 
          &lt;/wfs:Insert&gt; 
        &lt;/wfs:Transaction&gt; </pre>
<p>The <kbd>&lt;wfs:TransactionResponse&gt;</kbd> response, as shown in the following code, will be sent from WFS-T if the process has transpired smoothly and the features have been stored (note that the <kbd>&lt;wfs:totalInserted&gt;</kbd> element value in this case is set to <kbd>1</kbd>, as only one feature was stored):</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;wfs:TransactionResponse version="1.1.0" ...[CLIP]... &gt; 
<strong>  &lt;wfs:TransactionSummary&gt;</strong><strong>   <br/>    &lt;wfs:totalInserted&gt;1&lt;/wfs:totalInserted&gt;<br/></strong><strong>    &lt;wfs:totalUpdated&gt;0&lt;/wfs:totalUpdated&gt;<br/></strong><strong>    &lt;wfs:totalDeleted&gt;0&lt;/wfs:totalDeleted&gt;<br/></strong><strong>  &lt;/wfs:TransactionSummary&gt;</strong> 
  &lt;wfs:TransactionResults/&gt; 
  &lt;wfs:InsertResults&gt; 
    &lt;wfs:Feature&gt; 
      &lt;ogc:FeatureId fid="sites.17"/&gt; 
    &lt;/wfs:Feature&gt; 
  &lt;/wfs:InsertResults&gt; 
&lt;/wfs:TransactionResponse&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing web applications with GeoDjango – part 1</h1>
                </header>
            
            <article>
                
<p>In this recipe and the next, you will use the <strong>Django</strong> web framework to create a web application to manage wildlife sightings using a PostGIS data store. In this recipe, you will build the back office of the web application, based on the Django admin site.</p>
<p>Upon accessing the back office, an administrative user will be able to, after authentication, manage (insert, update, and delete) the main entities (animals and sightings) of the database. In the next part of the recipe, you will build a front office that displays the sightings on a map based on the <strong>Leaflet</strong> JavaScript library.</p>
<div class="packt_infobox">You can find a copy of the whole project that you are going to build in the code bundle under <kbd>chp09/wildlife</kbd>. Refer to it if a concept is not clear or if you want to copy and paste the code as you go through the steps of the recipe, rather than typing code from scratch.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>If you are new to Django, check out the official Django tutorial at <a href="https://docs.djangoproject.com/en/dev/intro/tutorial01/"><span class="URLPACKT">https://docs.djangoproject.com/en/dev/intro/tutorial01/</span></a> and then return to this recipe.</li>
</ol>
<p> </p>
<ol start="2">
<li>Create a Python <em>virtualenv</em> (<a href="http://www.virtualenv.org/en/latest/"><span class="URLPACKT">http://www.virtualenv.org/en/latest/</span></a>) to create an isolated Python environment to use with the web application you will build in this recipe and the next. Then, activate the environment as follows:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>Use the following commands in Linux:</li>
</ul>
</li>
</ul>
<pre><strong>                $ cd ~/virtualenvs/</strong>
<strong>                $ virtualenv --no-site-packages chp09-env</strong>
<strong>                $ source chp09-env/bin/activate</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>Type the following commands in Windows (for steps to install <kbd>virtualenv</kbd> on Windows, refer to <a href="https://zignar.net/2012/06/17/install-python-on-windows/"><span class="URLPACKT">https://zignar.net/2012/06/17/install-python-on-windows/</span></a>):</li>
</ul>
</li>
</ul>
<pre><strong>                cd c:\virtualenvs</strong>
                <strong>C:\Python27\Scripts\virtualenv.exe <br/>                -no-site-packages chp09-env</strong>
                <strong>chp09-env\Scripts\activate</strong></pre>
<ol start="3">
<li>Once activated, you can install the Python packages that you will use for this recipe as well as the next, using the <kbd>pip</kbd> tool (<a href="http://www.pip-installer.org/en/latest/"><span class="URLPACKT">http://www.pip-installer.org/en/latest/</span></a>).</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>In Linux, the command would be as follows:</li>
</ul>
</li>
</ul>
<pre><strong>                (chp09-env)$ pip install django==1.10</strong>
                <strong>(chp09-env)$ pip install psycopg2==2.7</strong>
                <strong>(chp09-env)$ pip install Pillow</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>In Windows, the command would be as follows:</li>
</ul>
</li>
</ul>
<pre>                <strong>(chp09-env) C:\virtualenvs&gt; pip install django==1.10</strong>
                <strong>(chp09-env) C:\virtualenvs&gt; pip install psycopg2=2.7</strong>
                <strong>(chp09-env) C:\virtualenvs&gt; easy_install Pillow</strong></pre>
<ol start="4">
<li>If you haven't done it so far, download the world countries shapefile from <a href="http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip"><span class="URLPACKT">http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip</span></a>. A copy of this shapefile is included in the code bundle of this book. Extract the shapefile to the <kbd>working/chp09</kbd> directory.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>Create a Django project using the <kbd>django-admin</kbd> command with the <kbd>startproject</kbd> option. Name the project <kbd>wildlife</kbd>. The command for creating the project will be as follows:</li>
</ol>
<pre>      <strong>(chp09-env)$ cd ~/postgis_cookbook/working/chp09</strong>
      <strong>(chp09-env)$ django-admin.py startproject wildlife</strong></pre>
<ol start="2">
<li>Create a Django application using the <kbd>django-admin</kbd> command with the <kbd>startapp</kbd> option. Name the application <kbd>sightings</kbd>. The command will be as follows:</li>
</ol>
<pre>      <strong>(chp09-env)$ cd wildlife/</strong>
      <strong>(chp09-env)$ django-admin.py startapp sightings</strong></pre>
<p style="padding-left: 60px">Now you should have the following directory structure:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13f78c11-6d72-4453-8a85-771f9cb472cb.png" style="width:10.25em;height:26.67em;"/></div>
<ol start="3">
<li>You will need to edit some files. Open your favorite editor (<strong>Sublime Text</strong> does the job) and go to the settings in the <kbd>settings.py</kbd> file in the code bundle under <kbd>chp09/wildlife/wildlife</kbd>. First, the <kbd>DATABASES</kbd> settings should be as shown in the following code, in order to use the <kbd>postgis_cookbook</kbd> PostGIS database for your application data:</li>
</ol>
<pre>        DATABASES = { 
          'default': { 
            'ENGINE': 'django.contrib.gis.db.backends.postgis', 
            'NAME': 'postgis_cookbook', 
            'USER': 'me', 
            'PASSWORD': 'mypassword', 
            'HOST': 'localhost', 
            'PORT': '', 
          } 
        } </pre>
<ol start="4">
<li>Add the following two lines of code at the top of the <kbd>wildlife/settings.py</kbd> file (<kbd>PROJECT_PATH</kbd> is the variable in which you will enter the project's path in the settings menu):</li>
</ol>
<pre>        import os 
        PROJECT_PATH = os.path.abspath(os.path.dirname(__file__)) </pre>
<ol start="5">
<li>Make sure that in the <kbd>settings.py</kbd> file under <kbd>chp09/wildlife/wildlife</kbd>, <kbd>MEDIA_ROOT</kbd>, and <kbd>MEDIA_URL</kbd> are correctly set, as shown the following code (this is to set the media files' path and URLs for the images that the administrative user will upload):</li>
</ol>
<pre>        MEDIA_ROOT = os.path.join(PROJECT_PATH, "media") 
        MEDIA_URL = '/media/'</pre>
<ol start="6">
<li>Make sure that the <kbd>INSTALLED_APPS</kbd> setting looks as shown in the following code in the <kbd>settings.py</kbd> file. You will use the Django admin site (<kbd>django.contrib.admin</kbd>), the GeoDjango core library (<kbd>django.contrib.gis</kbd>), and the sightings application you are creating in this recipe and the next. For this purpose, add the last three lines:</li>
</ol>
<pre>        INSTALLED_APPS = ( 
          'django.contrib.admin', 
          'django.contrib.auth', 
          'django.contrib.contenttypes', 
          'django.contrib.sessions', 
          'django.contrib.messages', 
          'django.contrib.staticfiles', 
          'django.contrib.gis', 
          'sightings', 
        ) </pre>
<ol start="7">
<li>Now, synchronize the database using the Django <kbd>migrations</kbd> management commands. When prompted to create a <em>superuser</em>, answer <kbd>yes</kbd> and choose a preferred administrative username and password:</li>
</ol>
<pre>      <strong>(chp09-env)$ python manage.py makemigrations</strong>
      <strong>(chp09-env)$ python manage.py migrate</strong></pre>
<ol start="8">
<li>Now you will add the models needed by the application. Edit the <kbd>models.py</kbd> file under <kbd>chp09/wildlife/sightings</kbd> and add the following code:</li>
</ol>
<pre>        from django.db import models 
        from django.contrib.gis.db import models as gismodels 
 
        class Country(gismodels.Model): 
          """ 
            Model to represent countries. 
          """ 
          isocode = gismodels.CharField(max_length=2) 
          name = gismodels.CharField(max_length=255) 
          geometry = gismodels.MultiPolygonField(srid=4326) 
          objects = gismodels.GeoManager() 
 
          def __unicode__(self): 
            return '%s' % (self.name) 
 
        class Animal(models.Model): 
          """ 
            Model to represent animals. 
          """ 
          name = models.CharField(max_length=255) 
          image = models.ImageField(upload_to='animals.images') 
 
          def __unicode__(self): 
            return '%s' % (self.name) 
 
          def image_url(self): 
            return u'&lt;img src="%s" alt="%s" width="80"&gt;&lt;/img&gt;' % <br/>                   (self.image.url, self.name) 
            image_url.allow_tags = True 
 
          class Meta: 
            ordering = ['name'] 
 
        class Sighting(gismodels.Model): 
          """ 
            Model to represent sightings. 
          """ 
          RATE_CHOICES = ( 
            (1, '*'), 
            (2, '**'), 
            (3, '***'), 
          ) 
          date = gismodels.DateTimeField() 
          description = gismodels.TextField() 
          rate = gismodels.IntegerField(choices=RATE_CHOICES) 
          animal = gismodels.ForeignKey(Animal) 
          geometry = gismodels.PointField(srid=4326) 
          objects = gismodels.GeoManager() 
 
          def __unicode__(self): 
            return '%s' % (self.date) 
 
          class Meta: 
            ordering = ['date'] </pre>
<ol start="9">
<li>Each model will become a table in the database with the corresponding fields defined using the <kbd>models</kbd> and <kbd>gismodels</kbd> class. Note that the <kbd>geometry</kbd> variable in the <kbd>county</kbd> and <kbd>sighting</kbd> layers will become the <kbd>MultiPolygon</kbd> and <kbd>Point</kbd> PostGIS geometry columns, thanks to the GeoDjango library.</li>
</ol>
<p> </p>
<ol start="10">
<li>Create an <kbd>admin.py</kbd> file under <kbd>chp09/wildlife/sightings</kbd> and add the following code to it. The classes in this file will define and customize the behavior of the Django admin site when browsing the application models or tables (fields to display, fields to be used to filter records, and fields to order records). Create the file by executing the following code:</li>
</ol>
<pre>        from django.contrib import admin 
        from django.contrib.gis.admin import GeoModelAdmin 
        from models import Country, Animal, Sighting 
 
        class SightingAdmin(GeoModelAdmin): 
          """ 
            Web admin behavior for the Sighting model. 
          """ 
          model = Sighting 
          list_display = ['date', 'animal', 'rate'] 
          list_filter = ['date', 'animal', 'rate'] 
          date_hierarchy = 'date' 
 
        class AnimalAdmin(admin.ModelAdmin): 
          """ 
            Web admin behavior for the Animal model. 
          """ 
          model = Animal 
          list_display = ['name', 'image_url',] 
 
        class CountryAdmin(GeoModelAdmin): 
          """ 
            Web admin behavior for the Country model. 
          """ 
          model = Country 
          list_display = ['isocode', 'name'] 
          ordering = ('name',) 
 
          class Meta: 
            verbose_name_plural = 'countries' 
 
        admin.site.register(Animal, AnimalAdmin) 
        admin.site.register(Sighting, SightingAdmin) 
        admin.site.register(Country, CountryAdmin)</pre>
<ol start="11">
<li>Now, to synchronize the database, execute the following commands in the Django project folder:</li>
</ol>
<pre><strong>      (chp09-env)$ python manage.py makemigrations 
      (chp09-env)$ python manage.py migrate</strong></pre>
<p style="padding-left: 60px">The output should be as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/be6bc8f8-9be1-40b2-b90f-4a246c4bda3b.png" style="width:28.25em;height:16.92em;"/></div>
<ol start="12">
<li>Now, for each model in <kbd>models.py</kbd>, a PostgreSQL table should have been created. Check whether your PostgreSQL database effectively contains the three tables created in the preceding commands using your favorite client (that is, <kbd>psql</kbd> or <kbd>pgAdmin</kbd>) and whether or not the <kbd>sightings_sighting</kbd> and <kbd>sightings_country</kbd> tables contain PostGIS geometric fields.</li>
<li>Any web application needs the definition of URLs where the pages can be accessed. Therefore, edit your <kbd>urls.py</kbd> file under <kbd>chp09/wildlife/wildlife</kbd> by adding the following code:</li>
</ol>
<pre class="mce-root">        from django.conf.urls import url<br/>        from django.contrib import admin<br/>        import settings<br/>        from django.conf.urls.static import static<br/>        admin.autodiscover()<br/>        urlpatterns = [<br/>          url(r'^admin/', admin.site.urls),<br/>        ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</pre>
<p class="mce-root" style="padding-left: 60px">In the <kbd>urls.py</kbd> file, you basically defined the location of the back office (which was built using the Django admin application) and the media (images) files' location uploaded by the Django administrator when adding new animal entities in the database. Now run the Django development server, using the following <kbd>runserver</kbd> management command:</p>
<pre class="mce-root">      <strong>(chp09-env)$ python manage.py runserver</strong></pre>
<ol start="14">
<li>Access the Django admin site at <kbd>http://localhost:8000/admin/</kbd> and log in with the superuser credentials you furnished in an earlier step in this recipe (<em>step 7</em>).</li>
<li>Now, navigate to <kbd>http://localhost:8000/admin/sightings/animal/</kbd> and add some animals using the <span class="packt_screen">Add animal</span> button. For each animal, define a name and an image that will be used by the frontend that you will build in the next recipe. You created this page with almost no code, thanks to the Django admin! The following screenshot shows what the <span class="packt_screen">Animals</span> list page will look like after adding some entities:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/57846f01-681a-4a75-b4f7-d3d22e44efab.png"/></div>
<ol start="16">
<li>Navigate to <kbd>http://localhost:8000/admin/sightings/sighting/</kbd> and add some sightings using the <span class="packt_screen">Add sighting</span> button. For each sighting, define the <span class="packt_screen">Date</span>, <span class="packt_screen">Time</span>, the name of the animal that was spotted, <span class="packt_screen">Rate</span>, and the location. GeoDjango has added the map widget to the Django Admin site for you, based on the OpenLayers JavaScript library, to add or modify geometric features. The <span class="packt_screen">Sightings</span> page is shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d8f11d04-1b65-4d87-a88d-9474a4ab206c.png"/></div>
<ol start="17">
<li>The <span class="packt_screen">Sightings</span> list page, thanks to the Django admin's efficiency, will provide the administrative user with useful features to sort, filter, and navigate the date hierarchy of all of the sightings in the system, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/faf66318-a650-40a0-9434-b1a6bb618a5f.png"/></div>
<ol start="18">
<li>Now, you will import the <kbd>countries</kbd> shapefile to its model. In the next recipe, you will use this model to find the country where each sighting occurred. Before going ahead in this recipe, investigate the shapefile structure; you will need to import just the <kbd>NAME</kbd> and <kbd>ISO2</kbd> attributes to the model as the <kbd>name</kbd> and <kbd>isocode</kbd> attributes, using the following command:</li>
</ol>
<pre class="mce-root">      <strong>$ ogrinfo TM_WORLD_BORDERS-0.3.shp TM_WORLD_BORDERS-0.3 -al -so</strong></pre>
<div class="mce-root CDPAlignCenter CDPAlign"><strong><strong><img src="assets/9f3be64f-4aa1-4522-9dee-479df76c3b7f.png" style="width:36.83em;height:31.42em;"/></strong></strong></div>
<ol start="19">
<li>Add a <kbd>load_countries.py</kbd> file under <kbd>chp09/wildlife/sightings</kbd> and import the shapefile to PostGIS, using the <kbd>LayerMapping</kbd> GeoDjango utility, using the following code:</li>
</ol>
<pre class="mce-root">        """ 
        Script to load the data for the country model from a shapefile. 
        """ 
 
        from django.contrib.gis.utils import LayerMapping 
        from models import Country 
 
        country_mapping = { 
          'isocode' : 'ISO2', 
          'name' : 'NAME', 
          'geometry' : 'MULTIPOLYGON', 
        } 
 
        country_shp = 'TM_WORLD_BORDERS-0.3.shp' 
        country_lm =  LayerMapping(Country, country_shp, country_mapping, 
                                   transform=False, encoding='iso-8859-1') 
        country_lm.save(verbose=True, progress=True) </pre>
<ol start="20">
<li>You should have the <kbd>TM_WORLD_BORDERS-0.3.shp</kbd> file placed under <kbd>chp09/wildlife</kbd> for this code to work. Enter the Python Django shell and run the <kbd>utils.py</kbd> script. Then, check whether the countries have been correctly inserted in the <kbd>sightings_country</kbd> table in your PostgreSQL database, using the following command:</li>
</ol>
<pre class="mce-root"><strong>      (chp09-env)$ python manage.py shell<br/></strong>      <strong>&gt;&gt;&gt; from sightings import load_countries</strong> <br/><strong>      Saved: Antigua and Barbuda</strong> <br/><strong>      Saved: Algeria</strong> <strong>Saved: Azerbaijan</strong> <br/><strong>      ...</strong> <br/><strong>      Saved: Taiwan</strong></pre>
<p style="padding-left: 60px">Now, you should see the countries in the administrative interface at <kbd>http://localhost:8000/admin/sightings/country/</kbd>, while running the Django server with:</p>
<pre class="mce-root"><strong>      (chp09-env)$ python manage.py runserver</strong> </pre>
<div class="mce-root CDPAlignCenter CDPAlign"><strong><img src="assets/be44025b-b8a3-48cc-aec5-d67ba8ff1dbe.png"/></strong></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you have seen how quick and efficient it is to assemble a back office application using <strong>Django</strong>, one of the most popular Python web frameworks; this is thanks to its object-relational mapper, which automatically created the database tables needed by your application and an automatic API to manage (insert, update, and delete) and query the entities without using SQL.</p>
<p>Thanks to the <strong>GeoDjango</strong> library, two of the application models, County and Sighting, have been geo-enabled with their introduction in the database tables of <kbd>geometric</kbd> PostGIS fields.</p>
<p>You have customized the powerful <strong>automatic administrative interface</strong> to quickly assemble the back-office pages of your application. Using the <strong>Django URL Dispatcher</strong>, you have defined the URL routes for your application in a concise manner.</p>
<p>As you may have noticed, what is extremely nice about the Django abstraction is the automatic implementation of the data-access layer API using the models. You can now add, update, delete, and query records using Python code, without having any knowledge of SQL. Try this yourself, using the Django Python shell; you will select an animal from the database, add a new sighting for that animal, and then finally delete the sighting. You can investigate the SQL generated by Django, behind the scenes, any time, using the <kbd>django.db</kbd>.connection class with the following command:</p>
<pre class="mce-root"><strong>(chp09-env-bis)$ python manage.py shell</strong> <br/><strong>&gt;&gt;&gt; from django.db import connection</strong> <br/><strong>&gt;&gt;&gt; from datetime import datetime</strong> <br/><strong>&gt;&gt;&gt; from sightings.models import Sighting, Animal</strong> <br/><strong>&gt;&gt;&gt; an_animal = Animal.objects.all()[0]</strong> <br/><strong>&gt;&gt;&gt; an_animal</strong> <br/><strong>&lt;Animal: Lion&gt;</strong> <br/><strong>&gt;&gt;&gt; print connection.queries[-1]['sql']</strong> <br/><strong>SELECT "sightings_animal"."id", "sightings_animal"."name", "sightings_animal"."image" FROM "sightings_animal" ORDER BY "sightings_animal"."name" ASC LIMIT 1'</strong> <br/><strong>my_sight = Sighting(date=datetime.now(), description='What a lion I have seen!', rate=1, animal=an_animal, geometry='POINT(10 10)')</strong> <br/><strong>&gt;&gt;&gt; my_sight.save()</strong> <br/><strong>print connection.queries[-1]['sql']</strong> <br/><strong>INSERT INTO "sightings_sighting" ("date", "description", "rate", "animal_id", "geometry") VALUES ('2013-06-12 14:37:36.544268-05:00', 'What a lion I have seen!', 1, 2, ST_GeomFromEWKB('\x0101000020e610000000000000000024400000000000002440'::bytea)) RETURNING "sightings_sighting"."id"</strong> <br/><strong>&gt;&gt;&gt; my_sight.delete()</strong> <br/><strong>&gt;&gt;&gt; print connection.queries[-1]['sql']</strong> <br/><strong>DELETE FROM "sightings_sighting" WHERE "id" IN (5)</strong></pre>
<p>Do you like Django as much as we do? In the next recipe, you will create the frontend of the application. The user will be able to browse the sightings in a map, implemented with the Leaflet JavaScript library. So keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing web applications with GeoDjango – part 2</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will create the front office for the web application you created using <strong>Django</strong> in the previous recipe.</p>
<p>Using HTML and the <strong>Django template language</strong>, you will create a web page displaying a map, implemented with Leaflet, and a list for the user containing all of the sightings available in the system. The user will be able to navigate the map and identify the sightings to get more information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>Make sure you have gone through every single step of the previous recipe and have kept the back office of the web application working and its database populated with some entities.</li>
<li>Activate the <kbd>virtualenv</kbd> you created in the <em>Developing web applications with GeoDjango –Part 1)</em> recipe, as follows:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>Use the following command for Linux:</li>
</ul>
</li>
</ul>
<pre class="mce-root"><strong>                $ cd ~/virtualenvs/</strong> <strong>$ source chp09-env/bin/activate</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>Use the following command for Windows:</li>
</ul>
</li>
</ul>
<pre class="mce-root"><strong>                cd c:\virtualenvs</strong> <strong>&gt; chp09-env\Scripts\activate</strong></pre>
<ol start="3">
<li>Install the libraries that you will use in this recipe; you will need the <kbd>simplejson</kbd> and <kbd>vectorformats</kbd> Python libraries to produce a GeoJSON (<a href="http://www.geojson.org/"><span class="URLPACKT">http://www.geojson.org/</span></a>) response that will feed the sighting layer in Leaflet:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>Use the following command for Linux:</li>
</ul>
</li>
</ul>
<pre class="mce-root"><strong>                (chp09-env)$ pip install simplejson</strong> <br/><strong>                (chp09-env)$ pip install vectorformats</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>Use the following command for Windows:</li>
</ul>
</li>
</ul>
<pre class="mce-root"><strong>                (chp09-env) C:\virtualenvs&gt; pip install simplejson</strong> <br/><strong>                (chp09-env) C:\virtualenvs&gt; pip install vectorformats</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>You will now create the front page of your web application, as follows:</p>
<ol>
<li>Go to the directory containing the Django wildlife web application and add the following lines to the <kbd>urls.py</kbd> file under <kbd>chp09/wildlife/wildlife</kbd>:</li>
</ol>
<pre class="mce-root">        from django.conf.urls import patterns, include, url <br/>        from django.conf import settings <br/>        from sightings.views import get_geojson, home <br/>        from django.contrib import admin <br/>        admin.autodiscover() <br/>        urlpatterns = [<br/>          url(r'^admin/', admin.site.urls), <br/>          url(r'^geojson/', get_geojson), <br/>          url(r'^$', home), <br/>        ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) <br/>          # media files</pre>
<ol start="2">
<li>Open the <kbd>views.py</kbd> file under <kbd>chp09/wildlife/sightings</kbd> and add the following code. The <kbd>home</kbd> view will return the home page of your application, with the list of sightings and the Leaflet map. The <kbd>sighting</kbd> layer in the map will display the GeoJSON response given by the <kbd>get_geojson</kbd> view:</li>
</ol>
<pre class="mce-root">        from django.shortcuts import render <br/>        from django.http import HttpResponse <br/>        from  vectorformats.Formats import Django, GeoJSON <br/>        from models import Sighting <br/><br/>        def home(request): <br/>          """<br/>            Display the home page with the list and a map of the sightings. <br/>          """ <br/>          sightings = Sighting.objects.all() <br/>          return render("sightings/home.html", {'sightings' : sightings}) <br/><br/>        def get_geojson(request): <br/>          """ <br/>            Get geojson (needed by the map) for all of the sightings. <br/>          """ <br/>          sightings = Sighting.objects.all() <br/>          djf = Django.Django(geodjango='geometry',<br/>            properties=['animal_name', 'animal_image_url', 'description', <br/>                        'rate', 'date_formatted', 'country_name'])<br/>          geoj = GeoJSON.GeoJSON() <br/>          s = geoj.encode(djf.decode(sightings)) <br/>          return HttpResponse(s)</pre>
<ol start="3">
<li>Add the following <kbd>@property</kbd> definitions to the <kbd>Sighting</kbd> class in the <kbd>models.py</kbd> file under <kbd>chp09/wildlife/sightings</kbd>. The <kbd>get_geojson</kbd> view will need to use these properties to compose the GeoJSON view needed from the Leaflet map and the information popup. Note how in the <kbd>country_name</kbd> property, you are using GeoDjango, which contains a spatial lookup <kbd>QuerySet</kbd> operator to detect the country where the sighting happened:</li>
</ol>
<pre class="mce-root">        @property <br/>        def date_formatted(self): <br/>          return self.date.strftime('%m/%d/%Y')<br/><br/>        @property <br/>        def animal_name(self): <br/>          return self.animal.name <br/><br/>        @property <br/>        def animal_image_url(self): <br/>          return self.animal.image_url() <br/><br/>        @property <br/>        def country_name(self): <br/>          country = Country.objects.filter<br/>            (geometry__contains=self.geometry)[0] <br/>          return country.name</pre>
<ol start="4">
<li>Add a <kbd>home.html</kbd> file, containing the following code, under <kbd>sightings/templates/sightings</kbd>. Using the Django template language, you will display the number of sightings in the system, a list of these sightings with the main information for each of them, and the Leaflet map. Using the Leaflet JavaScript API, you add a base OpenStreetMap layer to the map. Then, you make an asynchronous call, using jQuery, to the <kbd>get_geojson</kbd> view (accessed by adding <kbd>/geojson</kbd> to the request URL). If the query is successful, it will feed a Leaflet GeoJSON layer with the features from the sighting PostGIS layer and associate with each feature an informative popup. This popup will open any time the user clicks on a point on the map representing a sighting, displaying the main information for that entity:</li>
</ol>
<pre class="mce-root">        &lt;!DOCTYPE html&gt;<br/>        &lt;html&gt;<br/>          &lt;head&gt;<br/>            &lt;title&gt;Wildlife's Sightings&lt;/title&gt; <br/>            &lt;link rel="stylesheet" <br/>             href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" <br/>             integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh<br/>             22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT<br/>             /fJISVA1r/zQ==" crossorigin=""/&gt; <br/>            &lt;script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"<br/>             integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUup<br/>             EVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log==" crossorigin=""&gt;<br/>            &lt;/script&gt; <br/>            &lt;script src="http://ajax.googleapis.com/ajax/libs<br/>             /jquery/1.9.1/jquery.min.js"&gt;<br/>            &lt;/script&gt; <br/>          &lt;/head&gt; <br/>          &lt;body&gt; <br/>            &lt;h1&gt;Wildlife's Sightings&lt;/h1&gt; <br/>            &lt;p&gt;There are {{ sightings.count }} sightings <br/>               in the database.&lt;/p&gt; <br/>            &lt;div id="map" style="width:800px; height:500px"&gt;&lt;/div&gt; <br/>            &lt;ul&gt; <br/>              {% for s in sightings %} <br/>              &lt;li&gt;&lt;strong&gt;{{ s.animal }}&lt;/strong&gt;, <br/>                seen in {{ s.country_name }} on {{ s.date }} <br/>                and rated {{ s.rate }}<br/>              &lt;/li&gt; {% endfor %} <br/>            &lt;/ul&gt; <br/>            &lt;script type="text/javascript"&gt; <br/>              // OSM layer <br/>              var osm = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}<br/>                                               .png', {<br/>                maxZoom: 18, <br/>               attribution: "Data by OpenStreetMap" <br/>              }); <br/>              // map creation <br/>              var map = new L.Map('map', { <br/>                center: new L.LatLng(15, 0), <br/>                zoom: 2, <br/>                layers: [osm], <br/>                zoomControl: true <br/>              }); <br/>              // add GeoJSON layer <br/>              $.ajax({ <br/>                type: "GET", <br/>                url: "geojson", <br/>                dataType: 'json', <br/>                success: function (response) {<br/>                  geojsonLayer = L.geoJson(response, { <br/>                    style: function (feature) { <br/>                      return {color: feature.properties.color}; <br/>                    }, <br/>                    onEachFeature: function (feature, layer) {<br/>                      var html = "&lt;strong&gt;" +<br/>                                 feature.properties.animal_name + <br/>                                 "&lt;/strong&gt;&lt;br /&gt;" + <br/>                                 feature.properties.animal_image_url + <br/>                                 "&lt;br /&gt;&lt;strong&gt;Description:&lt;/strong&gt; " + <br/>                                 feature.properties.description + <br/>                                 "&lt;br /&gt;&lt;strong&gt;Rate:&lt;/strong&gt; " + <br/>                                 feature.properties.rate + <br/>                                 "&lt;br /&gt;&lt;strong&gt;Date:&lt;/strong&gt; " + <br/>                                 feature.properties.date_formatted + <br/>                                 "&lt;br /&gt;&lt;strong&gt;Country:&lt;/strong&gt; " +<br/>                                 feature.properties.country_name <br/>                                 layer.bindPopup(html); <br/>                    }<br/>                  }).addTo(map);<br/>                }<br/>              }); <br/>            &lt;/script&gt;<br/>          &lt;/body&gt; <br/>        &lt;/html&gt;</pre>
<ol start="5">
<li>Now that your frontend page is completed, you can finally access it at <kbd>http://localhost:8000/</kbd>. Navigate the map and try to identify some of the displayed sightings to check whether the popup opens, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/29b9fe1f-aa0b-47a1-82ce-ddc3da0b476c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You created an HTML front page for the web application you developed in the previous recipe. The HTML is dynamically created using the Django template language (<a href="https://docs.djangoproject.com/en/dev/topics/templates/"><span class="URLPACKT">https://docs.djangoproject.com/en/dev/topics/templates/</span></a>) and the map was implemented with the Leaflet JavaScript library.</p>
<p>The Django template language uses the response from the home view to generate a list of all of the sightings in the system.</p>
<p>The map was created using Leaflet. First, an OpenStreetMap layer was used as a base map. Then, using jQuery, you fed a GeoJSON layer that displays all of the features generated by the <kbd>get_geojson</kbd> view. You associated a popup with the layer that opens every time the user clicks on a sighting entity. The popup displays the main information for that sighting, including a picture of the sighted animal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a web GPX viewer with Mapbox</h1>
                </header>
            
            <article>
                
<p>For this recipe, we will use the way points dataset from <a href="68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml">Chapter 3</a>, <em>Working with Vector Data – The Basics</em>. Refer to the script in the recipe named <em>Working with GPS data</em> to learn how to import <kbd>.gpx</kbd> files tracks into PostGIS. You will also need a Mapbox token; for this, go to their site (<a href="https://www.mapbox.com">https://www.mapbox.com</a>) and sign up for one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root"><span>To prepare the data for Mapbox's GeoJSON format, export the table tracks from <a href="68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml">Chapter 3</a>, <em>Working with Vector Data – The Basics</em> using <kbd>ogr2ogr</kbd> with the following code:</span></li>
</ol>
<pre><strong>      ogr2ogr -f GeoJSON tracks.json \</strong><br/><strong>      "PG:host=localhost dbname=postgis_cookbook user=me" \</strong><br/><strong>      -sql "select * from chp03.tracks</strong></pre>
<ol start="2">
<li>Remove the <kbd>crs</kbd> definition line on the new <kbd>.json</kbd> with your favorite editor:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/44c050ce-b50e-4725-96c5-cea5247a64c5.png" style="width:48.92em;height:10.00em;"/></div>
<ol start="3">
<li>Go to your Mapbox account and upload in the Datasets menu the <kbd>tracks.json</kbd> file. After a successful upload, you will see the following message:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/93df2e72-9f49-495c-a719-308c9219b476.png" style="width:32.83em;height:18.25em;"/></div>
<ol start="4">
<li>Create the dataset and export it to a tileset:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f8d5f46a-768a-439a-97f6-a552775ec5aa.png" style="width:15.50em;height:11.42em;"/></div>
<ol start="5">
<li>Now, create a new style with the outdoors template:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50901ea0-7a5d-492c-8229-dc9cf0a9ca66.png" style="width:39.08em;height:40.75em;"/></div>
<ol start="6">
<li>Add the tracks layer and publish it. Note the style URL that you can use to share or further develop your map; copy it to use it in your code.</li>
<li>Now we are ready to create a mapbox.html file; add the following in the head section to use Mapbox JS and CSS libraries:</li>
</ol>
<pre>      &lt;script src='https://api.mapbox.com/mapbox-gl-js<br/>             /v0.42.0/mapbox-gl.js'&gt;&lt;/script&gt;<br/>      &lt;link href='https://api.mapbox.com/mapbox-gl-js<br/>            /v0.42.0/mapbox-gl.css' rel='stylesheet' /&gt;</pre>
<ol start="8">
<li>Insert a <kbd>map</kbd> with your token and the style we've just created in the body:</li>
</ol>
<pre>        &lt;div id='map' style='width: 800px; height: 600px;'&gt;&lt;/div&gt;<br/>        &lt;script&gt;<br/>          mapboxgl.accessToken = YOUR_TOKEN';<br/>          var map = new mapboxgl.Map({<br/>            container: 'map',<br/>            style: 'YOUR_STYLE_URL'<br/>          });<br/>          // Add zoom and rotation controls to the map.<br/>          map.addControl(new mapboxgl.NavigationControl());<br/>        &lt;/script&gt;</pre>
<ol start="9">
<li>That's it, you can double-click and open the HTML with your favorite browser and the Mapbox API will serve your map:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b21495be-2867-4e35-87f6-48be916877f6.png" style="width:39.33em;height:35.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To quickly publish and visualize data in a webGIS, you can use the Mapbox API to create beautiful maps with your own data; you will have to keep a GeoJSON format and not exceed the offered bandwidth capacity. In this recipe, you've learned how to export your PostGIS data to publish it in Mapbox as a JS.</p>


            </article>

            
        </section>
    </body></html>