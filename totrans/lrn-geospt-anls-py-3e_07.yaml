- en: Python and Geographic Information Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on applying Python to functions that are typically performed
    by a **geographic information system** (**GIS**) such as QGIS or ArcGIS. These
    functions are the heart and soul of geospatial analysis. We will continue to use
    as few external dependencies as possible outside of Python itself so that you
    have tools that are as reusable as possible in different environments. In this
    book, we separate GIS analysis and remote sensing from a programming perspective,
    which means that, in this chapter, we'll mostly focus on vector data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other chapters in this book, the items presented here are core
    functions that serve as building blocks that you can recombine to solve challenges
    that you will encounter beyond this book. The topics in this chapter include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring distance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reprojecting vector data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing shapefiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting data from within larger datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating thematic maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spreadsheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversion of non-GIS data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geocoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiprocessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter contains many code samples. In addition to the text, code comments
    are included as guides within the samples. This chapter covers more ground than
    any other chapter in this book. It covers everything from measuring the earth
    to editing data and creating maps, to using scaled up multiprocessing for faster
    analysis. By the end of this chapter, you'll be a geospatial analyst ready to
    learn about the more advanced techniques in the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python UTM library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python OGR library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Shapefile library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Fiona library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python PNGCanvas library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Pillow library (Python Imaging Library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Folium library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Pymea library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Geocoder library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python GeoPy library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essence of geospatial analysis is discovering the relationships of objects
    on Earth. Items that are closer together tend to have a stronger relationship
    than those that are farther apart. This concept is known as **Tobler's First Law
    of Geography**. Therefore, measuring distance is a critical function of geospatial
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have learned, every map is a model of the Earth and they are all wrong
    to some degree. For this reason, measuring the accurate distance between two points
    on the Earth while sitting in front of a computer is impossible. Even professional
    land surveyors (who go out in the field with both traditional sighting equipment
    and very precise GPS equipment) fail to account for every anomaly in the Earth''s
    surface between point A and point B. So, to measure distance, we must look at
    the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are we measuring?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much are we measuring?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much accuracy do we need?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to calculate distance, there are three models of the Earth that we can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: Flat plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spherical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ellipsoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the flat plane model, standard Euclidean geometry is used. The Earth is
    considered a flat plane with no curvature, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abac7e8a-364b-4d65-afb6-545b8e4afbb6.png)'
  prefs: []
  type: TYPE_IMG
- en: This model makes math quite simple because you work with straight lines. The
    most common format for geospatial coordinates is decimal degrees. However, decimal
    degree coordinates are reference measurements on a sphere taken as angles – between
    the longitude and the prime meridian—and the latitude and equator. Furthermore,
    the lines of longitude converge toward zero at the poles. The circumference of
    each line of latitude becomes smaller toward the poles as well. These facts mean
    decimal degrees are not a valid coordinate system for Euclidean geometry, which
    uses infinite planes.
  prefs: []
  type: TYPE_NORMAL
- en: Map projections attempt to simplify the issues of dealing with a 3D ellipsoid
    in a 2D plane, either on paper or on a computer screen. As we discussed in [Chapter
    1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning about Geospatial Analysis
    with Python*, map projections flatten a round model of the Earth to a plane and
    introduce distortion in exchange for the convenience of a map. Once this projection
    is in place and decimal degrees are traded for a Cartesian coordinate system with
    *x* and *y* coordinates, we can use the simplest forms of Euclidean geometry—namely,
    the Pythagorean theorem.
  prefs: []
  type: TYPE_NORMAL
- en: At a large enough scale, a sphere or ellipsoid like the Earth appears more like
    a plane than a sphere. In fact, for centuries, everyone thought the Earth was
    flat! If the difference in degrees of longitude is small enough, you can often
    get away with using Euclidean geometry and then converting the measurements into
    meters, kilometers, or miles. This method is generally not recommended but the
    decision is ultimately up to you and your requirements for accuracy as an analyst.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spherical model approach tries to better approximate reality by avoiding
    the problems resulting from smashing the Earth onto a flat surface. As the name
    suggests, this model uses a perfect sphere for representing the Earth (similar
    to a physical globe), which allows us to work with degrees directly. This model
    ignores the fact that the Earth is really more of an egg-shaped ellipsoid with
    varying degrees of thickness in its crust. But by working with distance on the
    surface of a sphere, we can begin to measure longer distances with more accuracy.
    The following screenshot illustrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f4a15ce-8515-4c9a-a240-1086fc87eb42.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the ellipsoid model of the Earth, analysts strive for the best model of
    the Earth's surface. There are several ellipsoid models, which are called datums.
    A **datum** is a set of values that define an estimated shape for the Earth, also
    known as a **geodetic system**. Like any other georeferencing system, a datum
    can be optimized for a localized area. The most commonly used datum is called
    **WGS84**, which is designed for global use. You should be aware that WGS84 is
    occasionally updated as assessment techniques and technology improves. The most
    recent revision occurred in 2004.
  prefs: []
  type: TYPE_NORMAL
- en: In North America, the NAD83 datum is used to optimize referencing over the continent.
    In the Eastern Hemisphere, the **European Terrestrial Reference System 1989**
    (**ETRS89**) is used more frequently. ETRS89 is fixed to the stable part of the
    **Eurasian Plate**. Maps of Europe based on ETRS89 are immune to continental drift,
    which changes up to 2.5 cm per year as the Earth's crust shifts.
  prefs: []
  type: TYPE_NORMAL
- en: An ellipsoid does not have a constant radius from the center. This fact means
    the formulas used in the spherical model of the Earth begin to have issues in
    the ellipsoid model. Though not a perfect approximation, it is much closer to
    reality than the spherical model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a generic ellipsoid model denoted by a black
    line contrasted against a representation of the Earth''s uneven crust, which is
    using a red line to represent the geoid. Although we will not use it for these
    examples, another model is the geoid model. The geoid is the most precise and
    accurate model of the Earth, which is based on the Earth''s surface with no influencing
    factors except gravity and rotation. The following diagram is a representation
    of a geoid, ellipsoid, and spherical model to illustrate their differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c85e437-d07d-40f5-9a93-e62c78ed294b.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding these models of the Earth is critical to everything else in this
    book because we're modeling the Earth, after all.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed these different models of the Earth and the issues
    with measuring them, let's look at some solutions using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Pythagorean theorem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by measuring with the simplest method, that is, the Pythagorean
    theorem, also known as Euclidean distance. If you remember your geometry lessons
    from school, the Pythagorean theorem asserts the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this assertion, the variables *a*, *b*, and *c* are all sides of a triangle.
    You can solve any one side if you know the other two.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll start with two projected points in the **Mississippi
    Transverse Mercator** (**MSTM**) projection. The units of this projection are
    in meters. The *x*-axis locations are measured from the central meridian defined
    by the westernmost location in the state. The *y*-axis is defined from the NAD83
    horizontal datum. The first point, defined as (*x*1,*y*1), represents Jackson, the
    state capital of Mississippi. The second point, defined as (*x*2,*y*2) represents
    the city of Biloxi, which is a coastal town, as shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6a11c12-f5cb-4e57-9386-3005535b2ed6.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following example, the double-asterisk (**) in Python is the syntax for
    exponents, which we'll use to square the distances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll import the Python math module for its square root function called `sqrt()`.
    Then, we''ll calculate the *x*-axis and *y*-axis distances. Finally, we''ll use
    these variables to execute the Euclidean distance formula to get the distance
    across the bounding box in meters from an *x*, *y* origin, which will be used
    in the MSTM projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, the distance is approximately 240,202 meters, which is around 240.2 kilometers
    or 150 miles. This calculation is reasonably accurate because this projection
    is optimized for measuring distance and area in Mississippi using Cartesian coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: We can also measure distance using decimal degrees, but we must perform a few
    additional steps. To measure using degrees, we must convert the angles into radians,
    which account for the curved surface distance between the coordinates. We'll also
    multiply our output in radians times the radius of the Earth in meters to convert
    back from radians.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about radians at [http://en.wikipedia.org/wiki/Radian](http://en.wikipedia.org/wiki/Radian).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll perform this conversion using the Python `math.radians()` method in
    the following code when we calculate the *x* and *y* distances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so this time, we came up with around 251 kilometers, which is 11 kilometers
    more than our first measurement. So, as you can see, your choice of measurement
    algorithm and Earth model can have significant consequences. Using the same equation,
    we come up with radically different answers, depending on our choice of coordinate
    system and Earth model.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about Euclidean distance at [http://mathworld.wolfram.com/Distance.html](http://mathworld.wolfram.com/Distance.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's check out the haversine formula next.
  prefs: []
  type: TYPE_NORMAL
- en: Using the haversine formula
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Part of the problem with using the Pythagorean theorem to measure distance
    on the Earth, which is a sphere, is the concept of great circle distance. A great
    circle is the shortest distance between two points on a sphere. Another important
    feature that defines a great circle is that the circle, if followed all of the
    way around the sphere, will bisect the sphere into two equal halves, as shown
    in the following Wikipedia illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e646971-a86b-466e-8cc3-1f4241fcdff7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, what is the right way to measure a line on a curved sphere? The most popular
    method is to use the **haversine formula**, which uses trigonometry to calculate
    the Great Circle distance using coordinates defined in decimal degrees as input.
    The haversine formula is *haversine(θ) = sin²(θ/2)*, where θ is the central angle
    between two points on a sphere. Once again, we''ll convert the axis distances
    from degrees into radians before we apply the formula, just like in the previous
    example. But this time, we''ll also convert the latitude (*y*-axis) coordinates
    into radians separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Wow! We get 240.6 kilometers using the haversine formula, compared to 240.2
    kilometers using the optimized and more accurate projection. This difference is
    less than half a kilometer, which is not bad for a distance calculation of two
    cities 150 miles apart. The haversine formula is the most commonly used distance
    measuring formula because it is relatively lightweight from a coding perspective
    and reasonably accurate in most cases. It is considered to be accurate to within
    about a meter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize what we''ve learned so far, most of the point coordinates you
    encounter as an analyst are in unprojected decimal degrees. So, your options for
    measurement are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reproject to a distance-accurate Cartesian projection and measure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just use the haversine formula and see how far it takes you for your analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the even more precise Vincenty formula.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's right! There's another formula that seeks to provide an even better measurement
    than haversine.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Vincenty formula
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we've examined distance measurement using the Pythagorean theorem (flat
    Earth model) and the haversine formula (spherical Earth model). The Vincenty formula
    accounts for the ellipsoid model of the Earth. And if you are using a localized
    ellipsoid, it can be accurate to much less than a meter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following implementation of this formula, you can change the semi-major
    axis value and flattening ratio to fit the definition of any ellipsoid. Let''s
    see what the distance is when we measure using the Vincenty formula on the NAD83
    ellipsoid in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import the `math` module, which allows us to work in radians,
    and the other `math` functions we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to set up our variables, including the variable that holds our
    distance value, the two points we''re measuring, the constants describing the
    Earth, and the derivative formulas we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now begins the Vincenty formula. There''s just no easy way to do this and the
    math is a little complicated, but it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after all that, we have our distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the Vincenty formula, our measurement came to 240.1 kilometers, which
    is only 100 meters off from our projected measurement using Euclidean distance.
    Impressive! While many times more mathematically complex than the haversine formula,
    you can see that it is also much more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pure Python geopy module includes an implementation of the Vincenty formula
    and has the ability to geocode locations by turning place names into latitude
    and longitude coordinates: [http://geopy.readthedocs.org/en/latest/](http://geopy.readthedocs.org/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: The points that were used in these examples are reasonably close to the equator.
    As you move toward the poles or work with larger distances or extremely small
    distances, the choices you make become increasingly more important. If you're
    just trying to make a radius around a city to select locations for a marketing
    campaign promoting a concert, then an error of a few kilometers is probably okay.
    However, if you're trying to estimate fuel required for an airplane to make a
    flight between two airports, then you want to be spot on!
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to learn more about issues with measuring distance and direction,
    and how to work around them with programming, visit the following site: [http://www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html).
  prefs: []
  type: TYPE_NORMAL
- en: On this site, Chris Veness goes into great detail on this topic and provides
    online calculators, as well as examples written in JavaScript, which can easily
    be ported to Python. The Vincenty formula implementation that we just saw is ported
    from the JavaScript on this site.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the full pure mathematical notation for the Vincenty formula here: [https://en.wikipedia.org/wiki/Vincenty%27s_formulae](https://en.wikipedia.org/wiki/Vincenty%27s_formulae).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to calculate distance, we need to understand how to calculate
    the direction of a line to relate objects on Earth by distance and location for
    geospatial analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating line direction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to distance, you will often want to know the bearing of a line
    between its endpoints. We can calculate this line direction from one of the points
    using only the Python `math` module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the `math` functions we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up some variables for our two points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll calculate the angle between the two points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll calculate the bearing of the line in degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you end up with a negative bearing value. To avoid this issue, we
    add `360` to the result to avoid a negative number and use the Python modulo operator
    to keep the value from climbing to over `360`.
  prefs: []
  type: TYPE_NORMAL
- en: The `math` in the angle calculation is reverse engineering a right triangle
    and then figuring out the acute angle of the triangle. The following URL provides
    an explanation of the elements of this formula, along with an interactive example
    at the end: [https://www.mathsisfun.com/sine-cosine-tangent.html](http://www.movable-type.co.uk/scripts/latlong.html).
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to calculate the location of features on the Earth. Next, we'll
    learn how to integrate data from different sources, starting with coordinate conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding coordinate conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coordinate conversion allows you to convert point coordinates between different
    coordinate systems. When you start working with multiple datasets, you'll inevitably
    end up with data in different coordinate systems and projections. You can convert
    back and forth between two of the most common coordinate systems, UTM and geographic
    coordinates (latitude and longitude), using a pure Python module called `utm`.
    You can install it using `easy_install` or `pip` from PyPI: [https://pypi.python.org/pypi/utm](https://pypi.python.org/pypi/utm).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `utm` module is straightforward to use. To convert from UTM into latitude
    and longitude, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The UTM zones are numbered horizontally. However, vertically, the bands of
    latitude are ordered by the English alphabet with a few exceptions. For example,
    the letters *A*, *B*, *Y*, and *Z* are used to label the Earth''s poles. The letters
    *I* and *O* are omitted because they look too much like *1* and *0*. Letters *N*
    through *X* are in the Northern Hemisphere while *C* through *M* are in the Southern
    Hemisphere. The following screenshot, from the website *Atlas Florae Europaeae*,
    illustrates the UTM zones over Europe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c13b8e9-cba9-442b-9c94-b80f2812f216.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Converting from latitude and longitude is even easier. We just pass the latitude
    and longitude to the `from_latlon()` method, which returns a tuple with the same
    parameters that are accepted by the `to_latlon()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The algorithms that were used in this Python implementation are described in
    detail at [http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM](http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM).
  prefs: []
  type: TYPE_NORMAL
- en: Converting between UTM and latitude/longitude just scratches the surface of
    transforming datasets from different sources so that they can be overlaid nicely
    on a map. To go beyond the basics, we'll need to perform map projections.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to calculate line direction, let's see how reprojection
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reprojection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In GIS, reprojection is all about changing the coordinates in a dataset from
    one coordinate system to another. While reprojection is less common these days
    due to more advanced methods of data distribution, sometimes you need to reproject
    a shapefile. The pure Python `utm` module works for reference system conversion,
    but for a full reprojection, we need some help from the OGR Python API. The OGR
    API contained in the `osgeo` module also provides the Open Spatial Reference module,
    also known as `osr`, which we'll use for reprojection.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we'll use a point shapefile containing New York City museum and
    gallery locations in the Lambert conformal projection. We'll reproject it to WGS84
    geographic (or un-project, it rather). You can download this zipped shapefile
    at [https://git.io/vLbT4](https://git.io/vLbT4).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following minimalist script reprojects the shapefile. The geometry is transformed
    and then written to the new file, but the `.dbf` file is simply copied to the
    new name as we aren''t changing it. The standard Python `shutil` module, short
    for shell utilities, is used to copy `.dbf`. The source and target shapefile names
    are variables at the beginning of the script. The target projection is also near
    the top, which is set using an EPSG code. The script assumes there is a `.prj`
    projection file, which defines the source projection. If not, you could manually
    define it using the same syntax as the target projection. We''ll walk through
    projecting a dataset step by step. Each section is marked with comments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import our libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define our shapefile names as variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create our target spatial reference using the `osr` module as EPSG
    code `4326`, which is WGS84 Geographic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set up our shapefile `Reader` object using `ogr` and get the spatial
    reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we check whether our target shapefile already exists from a previous
    test run and delete it if it does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can begin building our target layer for the shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can loop through the features in our source shapefile, reproject them
    using the `Transform()` method, and add them to the new shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create a shapefile `.prj` file containing projection information
    as a shapefile has no inherent way to store it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can just make a copy of the `.dbf` source with the new filename
    as the attributes are part of the reprojection process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the reprojected points in QGIS with satellite
    imagery in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e38dd1d3-50b4-4bfd-b5e5-d7bea52744a8.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are working with a set of points, you can reproject them programmatically
    instead of reprojecting a shapefile using PyProj: [https://jswhit.github.io/pyproj/](https://jswhit.github.io/pyproj/).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to converting coordinates into different projections, you often
    need to convert them among different formats, which we'll look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding coordinate format conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Map coordinates were traditionally represented as degrees, minutes, and seconds
    (DMS) for maritime navigation. However, in GIS (which is computer-based), latitude
    and longitude are represented as decimal numbers known as **decimal degrees**.
    The degrees, minutes, and seconds format is still used. Sometimes, you have to
    convert between that format and decimal degrees to perform calculations and output
    reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll create two functions that can convert either format
    into the other:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the `math` module to do conversions and the `re` regular expression
    module to parse the coordinate string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have our function to convert decimal degrees into a `degrees`, `minutes`,
    and `seconds` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have our function to go the other way and convert degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to convert decimal degrees into DMS, it''s as simple as using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To go the other direction, you just type the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that, because the DMS coordinates contain both single and double quotes
    to represent minutes and seconds, we have to use the Python string convention
    of using triple quotes on each latitude and longitude coordinate to contain both
    types of quotes so that they are parsed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinates are the fundamental units of a GIS dataset. They are used to build
    points, lines, and polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the area of a polygon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have one more calculation before we move on to editing GIS data. The most
    basic unit of GIS is a point. Two points can form a line. Multiple lines that
    share endpoints can form a polyline, and polylines can form polygons. Polygons
    are used to represent everything from a house to an entire country in geospatial
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the area of a polygon is one of the most useful operations in GIS
     if we wish to understand the relative size of features. But in GIS, area calculations
    go beyond basic geometry. The polygon lies on the Earth, which is a curved surface.
    The polygon must be projected to account for that curvature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a pure Python module simply called `area` that handles
    these complications for us. And because it''s pure Python, you can look at the
    source code to see how it works. The `area` module''s `area()` function accepts
    a GeoJSON string with a list of points that form a polygon and then returns the
    area. The following steps will show you how to calculate the area of a polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the `area` module using `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we''ll import the `area` function from the `area` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a variable called `polygon` that''s contained in a GeoJSON
    geometry for our polygon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re able to pass the polygon points string to the area function to
    calculate the area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The area that''s returned is `80235.13927976067` square meters. We can then
    use Python''s built-in `round()` function to round the long floating-point value
    to two decimal places to get **80235.14**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You now have the tools to do the math regarding the distance and size for geospatial
    data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at editing datasets in one of the most popular
    GIS data formats—shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Editing shapefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Shapefiles are one of the most common data formats in GIS, both for exchanging
    data as well as performing GIS analysis. In this section, we''ll learn how to
    work with these files extensively. In [Chapter 2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml),
    *Learning Geospatial Data*, we discussed shapefiles as a format that can have
    many different file types associated with it. For editing shapefiles, and most
    other operations, we are only concerned with two file types:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.shp` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.dbf` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.shp` file contains the geometry while the `.dbf` file contains the attributes
    of the corresponding geometry. For each geometry record in a shapefile, there
    is one `.dbf` record. The records aren't numbered or identified in any way. This
    means that, when adding and deleting information from a shapefile, you must be
    careful to remove or add a record to each file type to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml),
    *Geospatial Python Toolbox*, there are two libraries we can use to edit shapefiles
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: One is the Python bindings to the OGR library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other is the PyShp library, which is written in pure Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use PyShp in order to stick with the *pure Python when possible* theme
    of this book. To install PyShp, use `easy_install` or `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin editing shapefiles, we''ll start with a point shapefile containing
    cities for the state of Mississippi, which you can download as a ZIP file. Download
    the following file to your working directory and unzip it: [http://git.io/vLbU4](http://git.io/vLbU4).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The points we are working with can be seen in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06c2c998-8899-449c-974f-3b25085cc87c.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing the shapefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do anything with a shapefile, we''ll need to access it as a data source.
    To access the shapefile, we''ll use PyShp to open it. In PyShp, we''ll add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We created a shapefile `Reader` object instance and set it to the `r` variable. Notice
    that, when we passed the filename to the `Reader` class, we didn't use any file
    extensions. Remember that we are dealing with at least two different files ending
    in `.shp` and `.dbf`. So, the base filename without the extension that is common
    to these two files is all we really need.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, use a file extension. PyShp will just ignore it and use the
    base filename. So, why would you add an extension? Most operating systems allow
    an arbitrary number of periods in a filename. For example, you might have a shapefile
    with the following base name: `myShapefile.version.1.2`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, PyShp will try to interpret the characters after the last period
    as a file extension, which would be `.2`. This issue will prevent you from opening
    the shapefile. So, if your shapefile has periods in the base name, you would need
    to add a file extension such as `.shp` or `.dbf` to the filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have opened a shapefile and created a `Reader` object, you can get
    some information about the geographic data. In the following sample, we''ll get
    the bounding box, shape type, and the number of records in the shapefile from
    our `Reader` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The bounding box, which is stored in the `r.bbox` property, is returned as a
    list containing the minimum *x* value, minimum *y* value, maximum *x* value, and
    maximum *y* value. The shape type, which is available as the `shapeType` property,
    is a numeric code defined by the official shapefile specification. In this case,
    `1` represents a point shapefile, `3` represents lines, and `5` represents polygons.
    And finally, the `numRecords` property tells us there are `298` records in this
    shapefile. Because it is a simple point shapefile, we know there are `298` points,
    each with their own `.dbf` record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the different geometry types for shapefiles, along
    with their corresponding numeric code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Geometry** | **Numeric Code** |'
  prefs: []
  type: TYPE_TB
- en: '| `NULL` | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `POINT` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `POLYLINE` | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `POLYGON` | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| `MULTIPOINT` | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `POINTZ` | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| `POLYLINEZ` | 13 |'
  prefs: []
  type: TYPE_TB
- en: '| `POLYGONZ` | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| `MULTIPOINTZ` | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| `POINTM` | 21 |'
  prefs: []
  type: TYPE_TB
- en: '| `POLYLINEM` | 23 |'
  prefs: []
  type: TYPE_TB
- en: '| `POLYGONM` | 25 |'
  prefs: []
  type: TYPE_TB
- en: '| `MULTIPOINTM` | 28 |'
  prefs: []
  type: TYPE_TB
- en: '| `MULTIPATCH` | 31 |'
  prefs: []
  type: TYPE_TB
- en: Now that we know how to access it, let's see how we can read these files.
  prefs: []
  type: TYPE_NORMAL
- en: Reading shapefile attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.dbf` file is a simple database format that is structured in a similar
    way to a spreadsheet with rows and columns, with each column as a label defining
    what information it contains. We can view that information by checking the fields
    property of the `Reader` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fields` property returns quite a bit of information. The fields contain
    a list of information about each field, called **field descriptors**. For each
    field, the following information is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Field name:** This is the name of the field as text, which can be no longer
    than 10 characters for shapefiles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field type:** This is the type of the field, which can be text, number, date,
    floating-point number, or Boolean represented as C, N, D, F, and L, respectively.
    The shapefile specification says it uses the `.dbf` format specified as dBASE
    III, but most GIS software seems to support dBASE IV. In version IV (4), the number
    and floating-point types are equivalent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field length:** This is the length of the data in characters or digits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decimal length:** This is the number of decimal places in a number or floating-point
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first field descriptor outlines a hidden field that is part of the `.dbf`
    file format specification. `DeletionFlag` allows the software to mark records
    for deletion without actually deleting them. That way, the information is still
    in the file but can be removed from the displayed record list or search queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we just want the field name and not the other metadata, we can use Python
    list comprehensions to return just the first item in the descriptor and ignore
    the `DeletionFlag` field. This example creates a list comprehension that returns
    the first item in each descriptor (field name), starting with the second descriptor
    to ignore the deletion flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have just the field names, which are much easier to read. For clarity,
    the field names all contain the number `10` because this is version 2010 of this
    shapefile, which is created as a part of each census. These kinds of abbreviations
    are common in shapefile `.dbf` files due to the `10` character limit on the field
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s examine some of the records that these fields describe. We can
    view an individual record using the `r.record()` method. We know from the first
    example that there are `298` records. So, let''s examine the third record as an
    example. The records are accessed using list indexes. In Python, indexes start
    at `0`, so we have to subtract one from the desired record number to get the index.
    For record 3, the index would be `2`. You just pass the index to the `record()`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the field names are stored separately from the actual records.
    If you want to select a record value, you need its index. The index of the city
    name in each record is `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But counting indexes is tedious. It''s much easier to reference a value by
    the field name. There are several ways we can associate a field name with the
    value of a particular record. The first is to use the `index()` method in Python
    lists to programmatically get the index using the field name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way we can associate field names to values is by using Python''s built-in
    `zip()` method, which matches corresponding items in two or more lists and merges
    them into a list of tuples. Then, we can loop through that list, check the name,
    and then grab the associated value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also loop through `.dbf` records using the `r.records()` method. In
    this example, we''ll loop through the list returned by the `records()` method
    but limit the results using Python array slicing to the first three records. As
    we mentioned previously, shapefiles don''t contain record numbers, so we''ll also
    enumerate the records list and create a record number on the fly, so the output
    is a little easier to read. In this example, we''ll use the `enumerate()` method,
    which will return tuples containing an index and the record, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This kind of enumeration trick is what most GIS software packages use when displaying
    records in a table. Many GIS analysts assume shapefiles store the record number
    because every GIS program displays one. But if you delete a record, for example,
    record number 5 in ArcGIS or QGIS, and save the file, when you open it again,
    you'll find what was formerly record number 6 is now record 5\. Some spatial databases
    may assign a unique identifier to records. Often, a unique identifier is helpful.
    You can always create another field and column in `.dbf` and assign your own number,
    which remains constant even when records are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are working with very large shapefiles, PyShp has iterator methods that
    access data more efficiently. The default `records()` method reads all the records
    into the RAM at once, which is fine for the small `.dbf` files but becomes difficult
    to manage even with a few thousand records. Any time you''d use the `records()`
    method, you can also use the `r.iterRecords()` method the same way. This method
    holds the minimum amount of information needed to provide the record at hand rather
    than the whole dataset. In this quick example, we''re using the `iterRecords()`
    method to count the number of records to verify the count in the file header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can read one half of the shapefile, that is, the attributes, we're
    ready to look at the other half, that is, the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Reading shapefile geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the geometry. Previously, we looked at the header
    information and determined this shapefile was a point shapefile. So, we know that
    each record contains a single point. Let''s examine the first geometry record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In each geometry record, also known as `shape`, the points are stored in a list
    called `points`, even if there is only one point, as in this case. Points are
    stored as *x*, *y* pairs, so longitude comes before latitude if that coordinate
    system is used.
  prefs: []
  type: TYPE_NORMAL
- en: The shapefile specification also allows for 3D shapes. Elevation values are
    along the *z*-axis and often called *z* values. So, a 3D point is typically described
    as *x*, *y*, *z*. In the shapefile format, *z* values are stored in a separate
    *z* attribute if they're allowed by the shape type. If the shape type doesn't
    allow for *z* values, then that attribute is never set when the records are read
    by PyShp. Shapefiles with *z* values also contain measure values or *m* values,
    which are rarely used and are not used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: A measure is a user-assigned value that may be associated with a shape. An example
    would be a temperature recorded at a given location. There is another class of
    shape types that allow for adding *m* values to each shape but not *z* values.
    This class of shape types is called an **M shape type**. Just like the *z* values,
    if the data is there, the *m* attribute is created; otherwise, it's not. You don't
    typically run into shapefiles with *z* values and you rarely come across shapefiles
    with *m* values set. But sometimes you do, so it's good to be aware of them. And
    just like our fields and records `.dbf` example, if you don't like having the
    *z* and *m* values stored in separate lists, from the points list, you can use
    the `zip()` method to combine them. The `zip` method can take multiple lists as
    parameters separated by commas, as demonstrated when we looped through the records
    previously and joined the field names and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a `Reader` object with PyShp, it is read-only. You can change
    any values in the `Reader` object, but they are not written to the original shapefile.
    In the next subsection, we'll see how we can make changes in the original shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a shapefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a shapefile, you need to also create a `Writer` object. You can change
    values in either a `Reader` or `Writer` object; they are just dynamic Python data
    types. But at some point, you must copy the values from `Reader` to `Writer`.
    PyShp automatically handles all of the header information, such as the bounding
    box and record count. You only need to worry about the geometry and attributes.
    You'll find that this method is much simpler than the OGR example we used previously.
    However, it is also limited to UTM projections.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this concept, we'll read in a shapefile containing points with
    units in degrees and convert it into the UTM reference system in a `Writer` object
    before saving it. We'll use PyShp and the UTM module we discussed previously in
    this chapter. The shapefile we'll use is the New York City museums shapefile,
    which we reprojected to a WGS84 geographic. You can also just download it as a
    ZIP file, which is available at [https://git.io/vLd8Y](https://git.io/vLd8Y).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll read in the shapefile, create a writer for
    the converted shapefile, copy the fields over and then the records, and finally
    convert each point and write it as a geometry record before saving the converted
    shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to print out the first point of the first shape, you would see
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The point is returned as a list containing four numbers. The first two are
    the *x* and *y* values, while the last two are placeholders, in this case for
    elevation and measure values, respectively, which are used when you write those
    types of shapefiles. Also, we did not write a PRJ projection file, as we did in
    the preceding reprojection example. Here''s a simple way to create a PRJ file
    using the EPSG code from [https://spatialreference.org/](https://spatialreference.org/).
    The `zone` variable in the preceding example tells us that we are working in UTM
    Zone 18, which is EPSG code 26918\. The following code will create a `prj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As another example, we can add a new feature to a shapefile. In this example,
    we'll add a second polygon to a shapefile representing a tropical storm. You can
    download the zipped shapefile for this example here: [https://git.io/vLdlA](https://git.io/vLdlA).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll read the shapefile, copy it to a `Writer` object, add the new polygon,
    and write it back out with the same filename using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is how we do the changes in the original shapefile. Now, let's see how
    we can add new fields in the shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: Adding fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very common operation on shapefiles is to add additional fields to them.
    This operation is easy but there''s one important element to remember. When you
    add a field, you must also loop through the records and either create an empty
    cell or add a value for that column. As an example, let''s add a reference latitude
    and longitude column to the UTM version of the New York City museums shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll open the shapefile and create a new `Writer` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add the fields as float types with a length of `8` for the entire
    field and a maximum precision of `5` decimal places:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll open the geographic version of the shapefile and grab the coordinates
    from each record. We''ll add these to the corresponding attribute record in the
    UTM version''s `.dbf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the next subsection, we'll see how we can merge multiple shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Merging shapefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregating multiple related shapefiles of the same type into one larger shapefile
    is another very useful technique. You might be working as part of a team that
    divides up an area of interest and then assembles the data at the end of the day.
    Or, you might aggregate data from a series of sensors out in the field, such as
    weather stations.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we'll use a set of building footprints for a county that is
    maintained separately in four different quadrants (northwest, northeast, southwest,
    and southeast). You can download these shapefiles as a single ZIP file at [http://git.io/vLbUE](http://git.io/vLbUE).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you unzip these files, you''ll see they are named by quadrant. The following
    script uses PyShp to merge them into a single shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, merging a set of shapefiles is very straightforward. However,
    we didn't do any sanity checks to make sure the shapefiles were all of the same
    type, which you might want to do if this script was used for a repeated automated
    process, instead of just a quick one-off process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another note about this example is how we invoked the `Writer` object. In the
    other examples, we used a numeric code to define a shape type. You can define
    that number directly (for example, 1 for point shapefiles) or call one of the
    PyShp constants. The constants are the type of shapefile in all caps. For example,
    a polygon is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the value of that constant is 5\. When copying data from a `Reader`
    to a `Writer` object, you''ll notice the shape type definition is simply referenced,
    as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This method makes your script more robust as the script has one less variable that
    needs to be changed if you later change the script or the dataset. In the merging
    example, we don't have the benefit of having a `Reader` object available when
    we invoke `Writer`.
  prefs: []
  type: TYPE_NORMAL
- en: We could open the first shapefile in the list and check its type, but that would
    add several more lines of code. An easier way is just to omit the shape type.
    If the `Writer` shape type isn't saved, PyShp will ignore it until you save the
    shapefile. At that time, it will check the individual header of a geometry record
    and determine it from that.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can use this method in special cases, it''s better to define the
    shape type explicitly when you can, for clarity, and just to be safe to prevent
    any outlier case errors. The following illustration is a sample of this dataset
    so that you get a better idea of what the data looks like, as we will be using
    it more next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6dbb7db-b1ed-478d-8481-d53f7976afc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's see how to do this with the `.dbfpy` files.
  prefs: []
  type: TYPE_NORMAL
- en: Merging shapefiles with dbfpy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.dbf` portion of PyShp can occasionally run into issues with `.dbf` files
    that are  produced by certain software. Fortunately, PyShp allows you to manipulate
    the different shapefile types separately. There's a more robust `.dbf` library,
    named `dbfpy3`, which we discussed in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml), *Geospatial
    Python Toolbox*. You can use PyShp to handle the `.shp` and `.shx` files, while
    `.dbfpy` handles more complex `.dbf` files. You can download the module here: [https://github.com/GeospatialPython/dbfpy3/archive/master.zip](https://github.com/GeospatialPython/dbfpy3/archive/master.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach takes more code but it will often succeed where PyShp alone fails
    with `.dbf` issues. This example uses the same shapefiles from the previous example.
    In the following example, we''ll merge a shapefile using only its attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the libraries we need, get a list of shapefiles using the
    glob module, and create a shapefile `Writer` object using PyShp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re going to open only the `.``shp` files and copy the geometries to
    the writer. We''ll circle back and get the attributes using the `dbypy3` module
    later to demonstrate working with shapefile components separately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all of the geometry has been copied over to the writer, we can save the
    `.shp` file and have PyShp create an index file for the geometry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can get a list of `.dbf` files using the `glob` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll use the first `.dbf` file in the list as a template to get the
    field data and use it to set the properties of the shapefile writer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Then, we simply loop through the `.dbf` files and copy the records to `Writer:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to merge shapefiles, let's check out how to split them.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting shapefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may also need to split larger shapefiles to make it easier for
    you to focus on a subset of interest. This splitting, or subsetting, can be done
    spatially or by attributes, depending on which aspect of the data is of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Subsetting spatially
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to extract part of a dataset is to use spatial attributes such as size.
    In the following example, we'll subset the southeast quadrant file we merged.
    We'll filter the building footprint polygons by area and export any buildings
    with a 100 square meters or less (about 1,000 square feet) profile to a new shapefile.
    We'll use the `footpints_se` shapefile for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyShp has a signed area method that accepts a list of coordinates and returns
    either a positive or negative area. We''ll use the `utm` module to convert the
    coordinates into meters. Normally, the positive or negative area denotes whether
    the point order of the polygon is clockwise or counterclockwise, respectively.
    But point order doesn''t matter here, so we''ll use the absolute value using the
    `abs()` function, as shown here, when we get the area value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the difference in the number of records between the original and
    the subset shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We now have some substantial building blocks for geospatial analysis with vector
    data, as well as attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Performing selections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous subsetting example is one way to select data. There are many other
    ways to subset data for further analysis. In this section, we'll examine selecting
    subsets of data that are critical for efficient data processing to reduce the
    size of a large dataset down to just our area of interest for a given dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The point-in-polygon formula
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly discussed the point-in-polygon formula in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, as a common type of geospatial
    operation. You'll find it is one of the most useful formulas out there. The formula
    is relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function performs this check using the **Ray Casting** method.
    This method draws a line from the test point all of the way through the polygon
    and counts the number of times it crosses the polygon boundary. If the count is
    even, the point is outside the polygon. If it is odd, then it''s inside. This
    particular implementation also checks to see whether the point is on the edge
    of the polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use the `point_in_poly()` function to test a point in Chile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the point is inside. Let''s also verify that edge points will
    be detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You'll find new uses for this function all the time. It's definitely one to
    keep in your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Bounding box selections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A bounding box is the smallest rectangle that can completely contain a feature.
    We can use it as an efficient way to subset one or more individual features from
    a larger dataset. We'll look at one more example of using a simple bounding box
    to isolate a complex set of features and save it in a new shapefile. In this example,
    we'll subset the roads on the island of Puerto Rico from the mainland US Major
    Roads shapefile. You can download the shapefile here: [https://github.com/GeospatialPython/Learn/raw/master/roads.zip](https://github.com/GeospatialPython/Learn/raw/master/roads.zip).
  prefs: []
  type: TYPE_NORMAL
- en: 'Floating-point coordinate comparisons can be expensive, but because we are
    using a box and not an irregular polygon, this code is efficient enough for most
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've used geometry to select features, let's do it another way by
    using attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute selections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now seen two different ways of subsetting a larger dataset, resulting
    in a smaller one based on spatial relationships. But we can also select data using
    the attribute fields. So, let's examine a quick way to subset vector data using
    the attribute table. In this example, we'll use a polygon shapefile that has densely
    populated urban areas within Mississippi. You can download this zipped shapefile
    from [http://git.io/vLbU9](http://git.io/vLbU9).
  prefs: []
  type: TYPE_NORMAL
- en: 'This script is really quite simple. It creates the `Reader` and `Writer` objects,
    copies the `.dbf` fields, loops through the records for matching attributes, and
    then adds them to `Writer`. We''ll select urban areas with a population of less
    than `5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Attribute selections are typically fast. Spatial selections are computationally
    expensive because of floating-point calculations. Whenever possible, make sure
    you are unable to use attribute selection to subset first. The following illustration
    shows the starting shapefile containing all urban areas on the left with a state
    boundary, and the urban areas with less than 5,000 people on the right, after
    the previous attribute selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c80699c3-d955-4f23-b462-5a852a566dd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see what that same example looks like using `fiona`, which takes advantage
    of the OGR library. We''ll use nested `with` statements to reduce the amount of
    code needed to properly open and close the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, we know how to combine discrete datasets as well as split larger datasets
    apart. What else can we do? We can aggregate features within a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GIS vector datasets are typically composed of point, line, or polygon features.
    One of the principles of GIS is that things that are closer together geographically
    are more related than things that are further apart. When you have a set of related
    features, often, it's too much detail for the analysis you're trying to accomplish.
    It can be useful to generalize them to speed up processing or simplify a map.
    This type of operation is called **aggregation**. A common example of aggregation
    is to combine a set of local political boundaries into a larger political boundary
    such as counties into a state or states into a country or countries into continents.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll do just that. We'll convert a dataset comprising all
    of the counties in the US state of Mississippi into a single polygon representing
    the entire state. The Python Shapely library is perfect for this kind of operation;
    however, it can only manipulate geometry and doesn't read or write data files.
    To read and write data files, we'll use the Fiona library. If you don't have Shapely
    or Fiona installed, use `pip` to install them. You can download the counties dataset
    here: [https://git.io/fjt3b](https://git.io/fjt3b).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration shows what the counties dataset looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a61c8ea-f3ce-495b-9d9d-623950104a65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following steps will show you how to merge the individual county polygons
    into a single polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we import the libraries we need, including the different
    portions of the `shapely` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll open the counties GeoJSON file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll copy the schema of the source file, which defines all of the metadata
    for the dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need to alter that metadata copy to change the attributes  in order
    to define a single attribute for the state name. We also need to alter the geometry
    type from *MultiPolygon* to *Polygon*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll open our output dataset GeoJSON file named `combined.geojson`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll extract all of the polygons and attributes and combine all of the
    polygons into one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we'll write the combined polygon out with the new attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll import our libraries, including `OrderDict`, so that we can maintain
    control of the shapefile attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We open our GeoJSON file and copy the metadata:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our new field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the new field to the metadata:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can open the combined GeoJSON file and write out our results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The output dataset will look similar to the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bedbcd4d-abae-4cd7-910e-4504a3a4e5e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know all about reading, editing, and writing GIS data, we can begin
    visualizing it in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating images for visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we're moving from calculations and data editing to something we can see!
    We'll begin by creating different types of maps. In [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, we visualized our SimpleGIS
    program using the Tkinter module that's included with Python. In [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml),
    *Geospatial Python Toolbox*, we examined a few other methods for creating images.
    Now, we'll examine these tools in more depth by creating two specific types of
    thematic maps. The first is a dot density map and the second is a choropleth map.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's start with the dot density map.
  prefs: []
  type: TYPE_NORMAL
- en: Dot density calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dot density map shows concentrations of subjects within a given area. If an
    area is divided up into polygons containing statistical information, you can model
    that information using randomly distributed dots within that area using a fixed
    ratio across the dataset. This type of map is commonly used for population density
    maps.
  prefs: []
  type: TYPE_NORMAL
- en: The cat map in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning
    about Geospatial Analysis with Python*, is a dot density map. Let's create a dot
    density map from scratch using pure Python. Pure Python allows you to work with
    much more lightweight libraries that are generally easier to install and are more
    portable. For this example, we'll use a US Census Bureau Tract shapefile along
    the US Gulf Coast, which contains population data. We'll also use the point-in-polygon
    algorithm to ensure the randomly distributed points are within the proper census
    tract. Finally, we'll use the `PNGCanvas` module to write out our image.
  prefs: []
  type: TYPE_NORMAL
- en: The `PNGCanvas` module is excellent and fast. However, it doesn't have the ability
    to fill in polygons beyond simple rectangles. You can implement a fill algorithm
    but it is very slow in pure Python. However, for a quick outline and point plot,
    it does a great job.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll also see the `world2screen()` method, which is similar to the coordinates-to-mapping
    algorithm we used in SimpleGIS in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python. *In this example, we''ll read
    in a shapefile and write it back out as an image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the libraries we need, including `pngcanvas`, to draw a map
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define our point-in-polygon function, which we''ve used before. In
    this example, we''ll use it to randomly distribute population values within a
    location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a function to scale our geospatial coordinates to the map image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we read in the shapefile and set the size of our output map image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to determine the index of the population field so that we can
    get the population count for each area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we calculate the population density value. We want to create a dot on
    the map for every 100 people:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We will loop through each polygon and randomly distribute the points to create
    a density map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to create our output image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Our dots have been created. Now, we need to create the outlines of the census
    tract:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll save the output image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This script outputs an outline of the census tract, along with the density
    dots, to show population concentration very effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59b0b86e-4854-46c0-ab62-a32cd4ffbd3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s check out the second type of map: choropleth maps.'
  prefs: []
  type: TYPE_NORMAL
- en: Choropleth maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A choropleth uses shading, coloring, or symbols to show an average value or
    quantity within an area. They make it easy for us to visualize large amounts of
    data as a summary. This method is useful if related data spans multiple polygons.
    For example, in a worldwide population density map by country, many countries
    have disconnected polygons (for example, Hawaii is an island state of the US).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll use the **Python Imaging Library** (**PIL**) we discussed
    in [Chapter 3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml), *The Geospatial Technology
    Landscape*. PIL is not purely Python but is designed specifically for Python.
    We''ll recreate our previous dot density example as a choropleth map. We''ll calculate
    a density ratio for each census tract based on the number of people (population)
    per square kilometer and use that value to adjust the color. Dark is more densely
    populated while lighter is less. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import our libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll need our geospatial coordinates to image coordinates conversion
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we open our shapefile and set our output image size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We then set up PIL to draw our map image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like our previous example, we need to get the index of the population
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can draw the polygons, shade them according to population density,
    and save the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This script produces the following diagram with the relative density of tracks.
    You can adjust the color using the R, G, and B variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53ca2791-0a19-4602-ae26-99d663441ae3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we can show statistical data from shapefiles, we can look at a statistical
    data source that is even more common than shapefiles: spreadsheets.'
  prefs: []
  type: TYPE_NORMAL
- en: Using spreadsheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spreadsheets such as Microsoft Office Excel and Open Office Calc are inexpensive
    (even free), ubiquitous, easy to use, and great for recording structured data.
    For these reasons, spreadsheets are widely used to collect data for entry into
    a GIS format. As an analyst, you will find yourself working with spreadsheets
    frequently.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed the CSV format, which is a text file
    with the same basic rows and columns data structure as a spreadsheet. For CSV
    files, you use Python's built-in `csv` module. But most of the time, people don't
    bother exporting a true spreadsheet to a generic CSV file. That's where the pure
    Python `xlrd` module comes into play. The name `xlrd` is short for **Excel Reader**
    and is available from PyPI. There is also an accompanying module, the `xlwt` (Excel
    Writer) module, for writing spreadsheets. These two modules make reading and writing
    Excel spreadsheets a snap. Combine it with PyShp and you can move back and forth
    between spreadsheets and shapefiles with ease. This example demonstrates converting
    a spreadsheet into a shapefile. We'll use a spreadsheet version of the New York
    City museum point data available at [https://git.io/Jemi9](https://git.io/Jemi9).
  prefs: []
  type: TYPE_NORMAL
- en: 'The spreadsheet contains the attribute data, followed by an *x* column with
    the longitude and a *y* column with the latitude. To export it to a shapefile,
    we''ll execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the spreadsheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a shapefile `Writer` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capture the first row of the spreadsheet as the `dbf` columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through each row of the spreadsheet and copy the attributes to `dbf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a point from the *x* and *y* spreadsheet columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting a shapefile into a spreadsheet is a much less common operation,
    though not difficult. To convert a shapefile into a spreadsheet, you need to make
    sure you have an *x* and *y* column by using the *Adding fields* example from
    the *Editing shapefiles* section in this chapter. You would loop through the shapes
    and add the *x*, *y* values to those columns. Then, you would read the field names
    and column values from `dbf` into an `xlwt` spreadsheet object or a CSV file using
    the `csv` module. The coordinate columns are labeled in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e854dbdf-2cce-4df8-9e10-3178bdca4126.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll use a spreadsheet as an input data source.
  prefs: []
  type: TYPE_NORMAL
- en: Creating heat maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heat map is used to show the geographic clustering of data using a raster
    image that shows density. The clustering can also be weighed by using a field
    in the data to not only show geographic density but also an intensity factor.
    In this example, we'll use bear sighting data contained in the CSV dataset, which
    stores the data as points to create a heat map of the frequency of bear sightings
    in different areas of Mississippi. This dataset is so simple that's we're going
    to treat the CSV file as a text file, which is one of the nice features of a CSV
    file.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the dataset here: [https://git.io/fjtGL](https://git.io/fjtGL).
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is going to be a simple HTML web map that you can open in any web
    browser. The web map will be based on the excellent Leaflet JavaScript library.
    On top of that, we''ll use the Python Folium library, which makes it easy  for
    us to create Leaflet web maps, in order to generate the HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will create a file called `heatmap.html`. Open it in any web browser
    to see a similar image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2a59cc9-3722-430d-80af-409a4160d16f.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we'll learn how to use data generated by a GPS to collect field data such
    as the information in the preceding heatmap.
  prefs: []
  type: TYPE_NORMAL
- en: Using GPS data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common type of GPS data these days is the Garmin GPX format. We covered
    this XML format in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml), *Geospatial
    Python Toolbox*, which has become an unofficial industry standard. Because it
    is an XML format, all of the well-documented rules of XML apply to it. However,
    there is another type of GPS data that pre-dates XML and GPX, called the **National
    Marine Electronics Association** (**NMEA**). This data is ASCII text sentences
    that are designed to be streamed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You occasionally bump into this format from time to time because even though
    it is older and esoteric, it is still very much alive and well, especially for
    communicating ship locations via the **Automated Identification System** (**AIS**),
    which tracks ships globally. But as usual, you have a good option in pure Python.
    The `pynmea` module is available on PyPI. The following code is a small sample
    of NMEA sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the `pynmea` module from PyPI and download the complete sample file,
    you can view the following URL: [http://git.io/vLbTv](http://git.io/vLbTv). Then,
    you can run the following sample, which will parse the `NMEA` sentences into objects.
    The NMEA sentences contain a wealth of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The latitudes and longitudes are stored in a format called **degrees decimal
    minutes**. For example, this random coordinate, 4533.35, is 45 degrees and 33.35
    minutes. 0.35 of a minute is exactly 21 seconds. In another example, 16708.033
    is 167 degrees and 8.033 minutes. 0.033 of a minute is approximately 2 seconds.
    You can find more information about the NMEA format at [http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/).
  prefs: []
  type: TYPE_NORMAL
- en: GPS data is an important location data source, but there's another way we can
    describe a point on the Earth using a street address. The method for locating
    a street address on the Earth is called geocoding.
  prefs: []
  type: TYPE_NORMAL
- en: Geocoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Geocoding is the process of converting a street address into latitude and longitude.
    This operation is critical to in-vehicle navigation systems and online driving
    direction websites. Python has two excellent geocoder libraries available named
    `geocoder` and `geopy`. Both take advantage of online geocoding services to allow
    you to geocode addresses programmatically. The geopy library even lets you reverse
    geocode to match a latitude and longitude to the nearest address:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s do a quick example with the `geocoder` library, which defaults
    to using Google Maps as its engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Here, we print the GeoJSON record for that address, which contains all known
    information in Google's database. Then, we print out the returned latitude and
    longitude as a WKT string, which could be used as input to other operations such
    as checking whether the address is inside of a flood plain polygon. The documentation
    for this library also shows you how to switch to other online geocoding services
    such as Bing or Yahoo. Some of these services require an API key and may have
    request limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `geopy` library. In this example, we''ll geocode against
    the `OpenStreetMap` database. Once we match the address to a location, we''ll
    turn around and reverse geocode it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know of several different ways to geocode, let's look at speeding
    up the process. If you have thousands of addresses to geocode, it can take a while.
    Using multiprocessing, you can reduce a geocoding process that might take days
    into a few hours.
  prefs: []
  type: TYPE_NORMAL
- en: Multiprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geospatial datasets are very large. Processing them can take time, which can
    be hours or sometimes even days. But there's a way you can speed processing up
    for certain operations. Python's built-in multiprocessing module can spawn multiple
    processes on your computer to take advantage of all of the available processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'One operation that works really well with the multiprocessing module is geocoding.
    In this example, we''ll geocode a list of cities and split that processing across
    all of the processors on your machine. We''ll use the same geocoding technique
    as before, but this time, we''ll add the multiprocessing module to increase the
    potential for greater speed and scalability. The following code will geocode a
    list of cities simultaneously across multiple processors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the modules we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create our geocoder object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a function to geocode and individual address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create our list of cities to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set up our processor pool based on the number of processors available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we map our list of cities to the geocode function though the processor
    pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can print the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This technique can be very powerful, but not every type of processing can be
    performed this way. The type of processing  you use has to support operations
    that can be broken apart into discrete calculations. But when you can break problems
    apart, like we did in this example, the results are orders of magnitude faster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the critical components of GIS analysis. We examined the
    challenges of measuring on the curved surface of the Earth using different approaches.
    We looked at the basics of coordinate conversion and full reprojection using OGR,
    the `utm` module with PyShp, and Fiona, which simplifies OGR. We edited shapefiles
    and performed spatial and attribute selections. We created thematic maps from
    scratch using only Python. We also imported data from spreadsheets. Then, we parsed
    GPS data from NMEA streams. Finally, we used geocoding to convert street addresses
    into locations and back.
  prefs: []
  type: TYPE_NORMAL
- en: As a geospatial analyst, you may be familiar with both GIS and remote sensing,
    but most analysts specialize in one field or the other. That is why this book
    approaches the fields in separate chapters – so that we can focus on their differences.
    As we mentioned in the introduction, the techniques in this chapter are the building
    blocks for all geospatial analysis and will give you the tools you need so that
    you can learn about any aspect of this field.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml), *Python and Remote
    Sensing*, we'll tackle remote sensing. In GIS, we have been able to explore this
    field using pure Python modules. In remote sensing, we'll become more dependent
    on bindings to compiled modules written in C due to the sheer size and complexity
    of the data.
  prefs: []
  type: TYPE_NORMAL
