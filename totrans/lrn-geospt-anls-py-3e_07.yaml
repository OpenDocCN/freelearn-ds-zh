- en: Python and Geographic Information Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python和地理信息系统
- en: This chapter will focus on applying Python to functions that are typically performed
    by a **geographic information system** (**GIS**) such as QGIS or ArcGIS. These
    functions are the heart and soul of geospatial analysis. We will continue to use
    as few external dependencies as possible outside of Python itself so that you
    have tools that are as reusable as possible in different environments. In this
    book, we separate GIS analysis and remote sensing from a programming perspective,
    which means that, in this chapter, we'll mostly focus on vector data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于将Python应用于通常由地理信息系统（GIS）如QGIS或ArcGIS执行的功能。这些功能是地理空间分析的核心和灵魂。我们将尽可能减少Python本身之外的外部依赖，以便你拥有尽可能可重用的工具，在不同的环境中使用。在本书中，我们从编程的角度将GIS分析和遥感分离，这意味着在本章中，我们将主要关注矢量数据。
- en: 'As with the other chapters in this book, the items presented here are core
    functions that serve as building blocks that you can recombine to solve challenges
    that you will encounter beyond this book. The topics in this chapter include the
    following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他章节一样，这里展示的项目是核心功能，它们作为构建块，你可以重新组合来解决本书之外遇到的挑战。本章的主题包括以下内容：
- en: Measuring distance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量距离
- en: Converting coordinates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标转换
- en: Reprojecting vector data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重投影矢量数据
- en: Measuring area
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量面积
- en: Editing shapefiles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑shapefile
- en: Selecting data from within larger datasets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从更大的数据集中选择数据
- en: Creating thematic maps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建专题地图
- en: Using spreadsheets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电子表格
- en: Conversion of non-GIS data types
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非GIS数据类型的转换
- en: Geocoding
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理编码
- en: Multiprocessing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多进程
- en: This chapter contains many code samples. In addition to the text, code comments
    are included as guides within the samples. This chapter covers more ground than
    any other chapter in this book. It covers everything from measuring the earth
    to editing data and creating maps, to using scaled up multiprocessing for faster
    analysis. By the end of this chapter, you'll be a geospatial analyst ready to
    learn about the more advanced techniques in the rest of this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含许多代码示例。除了文本外，代码注释还包括在示例中的指南。本章覆盖的范围比本书中的任何其他章节都要广。它涵盖了从测量地球到编辑数据、创建地图，到使用扩展的多进程以加快分析速度的各个方面。到本章结束时，你将是一名准备学习本书其余部分更高级技术的地理空间分析师。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: Python 3.7
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7
- en: The Python UTM library
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python UTM库
- en: The Python OGR library
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python OGR库
- en: The Python Shapefile library
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Shapefile库
- en: The Python Fiona library
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Fiona库
- en: The Python PNGCanvas library
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python PNGCanvas库
- en: The Python Pillow library (Python Imaging Library)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Pillow库（Python图像库）
- en: The Python Folium library
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Folium库
- en: The Python Pymea library
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Pymea库
- en: The Python Geocoder library
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Geocoder库
- en: The Python GeoPy library
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python GeoPy库
- en: Measuring distance
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量距离
- en: The essence of geospatial analysis is discovering the relationships of objects
    on Earth. Items that are closer together tend to have a stronger relationship
    than those that are farther apart. This concept is known as **Tobler's First Law
    of Geography**. Therefore, measuring distance is a critical function of geospatial
    analysis.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间分析的本质是发现地球上物体的关系。彼此更近的物体往往比彼此更远的物体有更强的关系。这个概念被称为**托布勒地理第一定律**。因此，测量距离是地理空间分析的一个关键功能。
- en: 'As we have learned, every map is a model of the Earth and they are all wrong
    to some degree. For this reason, measuring the accurate distance between two points
    on the Earth while sitting in front of a computer is impossible. Even professional
    land surveyors (who go out in the field with both traditional sighting equipment
    and very precise GPS equipment) fail to account for every anomaly in the Earth''s
    surface between point A and point B. So, to measure distance, we must look at
    the following questions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，每张地图都是地球的一个模型，它们在某种程度上都是错误的。因此，坐在电脑前测量地球上两点之间的准确距离是不可能的。即使是专业的土地测量员（他们带着传统的观测设备和非常精确的GPS设备到野外）也无法考虑到A点和B点之间地球表面的每一个异常。因此，为了测量距离，我们必须考虑以下问题：
- en: What are we measuring?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在测量什么？
- en: How much are we measuring?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在测量多少？
- en: How much accuracy do we need?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要多少精度？
- en: 'Now, to calculate distance, there are three models of the Earth that we can
    use:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要计算距离，我们可以使用以下三种地球模型：
- en: Flat plane
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面
- en: Spherical
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球形
- en: Ellipsoid
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭球体
- en: 'In the flat plane model, standard Euclidean geometry is used. The Earth is
    considered a flat plane with no curvature, as shown in the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在平面模型中，使用的是标准的欧几里得几何。地球被视为一个没有曲率的平面，如下面的图所示：
- en: '![](img/abac7e8a-364b-4d65-afb6-545b8e4afbb6.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abac7e8a-364b-4d65-afb6-545b8e4afbb6.png)'
- en: This model makes math quite simple because you work with straight lines. The
    most common format for geospatial coordinates is decimal degrees. However, decimal
    degree coordinates are reference measurements on a sphere taken as angles – between
    the longitude and the prime meridian—and the latitude and equator. Furthermore,
    the lines of longitude converge toward zero at the poles. The circumference of
    each line of latitude becomes smaller toward the poles as well. These facts mean
    decimal degrees are not a valid coordinate system for Euclidean geometry, which
    uses infinite planes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个模型中你工作的是直线，所以数学变得相当简单。地理坐标最常用的格式是十进制度数。然而，十进制度数坐标是在球体上作为角度的参考测量——经度和本初子午线之间，以及纬度和赤道之间。此外，经线在两极会聚于零。纬线的周长在两极也会变得更小。这些事实意味着十进制度数对于使用无限平面的欧几里得几何来说不是一个有效的坐标系。
- en: Map projections attempt to simplify the issues of dealing with a 3D ellipsoid
    in a 2D plane, either on paper or on a computer screen. As we discussed in [Chapter
    1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning about Geospatial Analysis
    with Python*, map projections flatten a round model of the Earth to a plane and
    introduce distortion in exchange for the convenience of a map. Once this projection
    is in place and decimal degrees are traded for a Cartesian coordinate system with
    *x* and *y* coordinates, we can use the simplest forms of Euclidean geometry—namely,
    the Pythagorean theorem.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 地图投影试图简化在二维平面上处理三维椭球体的问题，无论是在纸张上还是在计算机屏幕上。正如我们在[第1章](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml)中讨论的，《使用Python学习地理空间分析》，地图投影将地球的圆形模型展平到平面上，并为了地图的便利性而引入了扭曲。一旦这个投影到位，十进制度数被交换为具有*x*和*y*坐标的笛卡尔坐标系，我们就可以使用最简单的欧几里得几何形式——即勾股定理。
- en: At a large enough scale, a sphere or ellipsoid like the Earth appears more like
    a plane than a sphere. In fact, for centuries, everyone thought the Earth was
    flat! If the difference in degrees of longitude is small enough, you can often
    get away with using Euclidean geometry and then converting the measurements into
    meters, kilometers, or miles. This method is generally not recommended but the
    decision is ultimately up to you and your requirements for accuracy as an analyst.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在足够大的尺度上，像地球这样的球体或椭球体看起来更像是一个平面而不是一个球体。事实上，几个世纪以来，人们都认为地球是平的！如果经度度的差异足够小，你通常可以使用欧几里得几何，然后将测量值转换为米、千米或英里。这种方法通常不推荐，但最终的决定取决于你作为分析师对精度的要求。
- en: 'The spherical model approach tries to better approximate reality by avoiding
    the problems resulting from smashing the Earth onto a flat surface. As the name
    suggests, this model uses a perfect sphere for representing the Earth (similar
    to a physical globe), which allows us to work with degrees directly. This model
    ignores the fact that the Earth is really more of an egg-shaped ellipsoid with
    varying degrees of thickness in its crust. But by working with distance on the
    surface of a sphere, we can begin to measure longer distances with more accuracy.
    The following screenshot illustrates this concept:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 球形模型方法试图通过避免将地球压扁到平面上所产生的问题来更好地逼近现实。正如其名所示，该模型使用一个完美的球体来表示地球（类似于物理地球仪），这使得我们可以直接使用度数。这个模型忽略了地球实际上更像是具有不同厚度地壳的椭圆形，而不是一个完美的球体。但是，通过在球体表面工作距离，我们可以开始以更高的精度测量更长的距离。以下截图说明了这个概念：
- en: '![](img/0f4a15ce-8515-4c9a-a240-1086fc87eb42.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f4a15ce-8515-4c9a-a240-1086fc87eb42.png)'
- en: Using the ellipsoid model of the Earth, analysts strive for the best model of
    the Earth's surface. There are several ellipsoid models, which are called datums.
    A **datum** is a set of values that define an estimated shape for the Earth, also
    known as a **geodetic system**. Like any other georeferencing system, a datum
    can be optimized for a localized area. The most commonly used datum is called
    **WGS84**, which is designed for global use. You should be aware that WGS84 is
    occasionally updated as assessment techniques and technology improves. The most
    recent revision occurred in 2004.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地球椭球体模型，分析师们努力寻找地球表面的最佳模型。有几个椭球体模型，被称为基准。**基准**是一组定义地球估计形状的值，也称为**大地测量系统**。像任何其他地理参考系统一样，基准可以针对局部区域进行优化。最常用的基准是称为
    **WGS84** 的基准，它设计用于全球使用。你应该知道，随着评估技术和技术的改进，WGS84 有时会更新。最近的修订发生在 2004 年。
- en: In North America, the NAD83 datum is used to optimize referencing over the continent.
    In the Eastern Hemisphere, the **European Terrestrial Reference System 1989**
    (**ETRS89**) is used more frequently. ETRS89 is fixed to the stable part of the
    **Eurasian Plate**. Maps of Europe based on ETRS89 are immune to continental drift,
    which changes up to 2.5 cm per year as the Earth's crust shifts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在北美，NAD83 基准用于优化大陆上的参考。在东半球，更频繁地使用 **欧洲大地测量参考系统 1989** (**ETRS89**)。ETRS89 被固定在
    **欧亚板块** 的稳定部分。基于 ETRS89 的欧洲地图不受大陆漂移的影响，大陆漂移每年变化可达 2.5 厘米，因为地球的地壳在移动。
- en: An ellipsoid does not have a constant radius from the center. This fact means
    the formulas used in the spherical model of the Earth begin to have issues in
    the ellipsoid model. Though not a perfect approximation, it is much closer to
    reality than the spherical model.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 椭球体从中心到边缘没有恒定的半径。这个事实意味着在地球的球体模型中使用的公式在椭球体模型中开始出现问题。虽然这不是一个完美的近似，但它比球体模型更接近现实。
- en: 'The following screenshot shows a generic ellipsoid model denoted by a black
    line contrasted against a representation of the Earth''s uneven crust, which is
    using a red line to represent the geoid. Although we will not use it for these
    examples, another model is the geoid model. The geoid is the most precise and
    accurate model of the Earth, which is based on the Earth''s surface with no influencing
    factors except gravity and rotation. The following diagram is a representation
    of a geoid, ellipsoid, and spherical model to illustrate their differences:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个用黑色线条表示的通用椭球模型，与用红色线条表示的地球不均匀地壳进行了对比。虽然我们不会在这些例子中使用它，但另一个模型是大地水准面模型。大地水准面是地球上最精确和最准确的模型，它基于地球表面，除了重力和旋转外，没有其他影响因素。以下图示展示了大地水准面、椭球体和球体模型，以说明它们之间的差异：
- en: '![](img/2c85e437-d07d-40f5-9a93-e62c78ed294b.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c85e437-d07d-40f5-9a93-e62c78ed294b.png)'
- en: Understanding these models of the Earth is critical to everything else in this
    book because we're modeling the Earth, after all.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些地球模型对于本书中的其他内容至关重要，因为毕竟我们是在模拟地球。
- en: Now that we've discussed these different models of the Earth and the issues
    with measuring them, let's look at some solutions using Python.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了这些不同的地球模型以及测量它们的问题，让我们看看一些使用 Python 的解决方案。
- en: Using the Pythagorean theorem
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用勾股定理
- en: 'We''ll start by measuring with the simplest method, that is, the Pythagorean
    theorem, also known as Euclidean distance. If you remember your geometry lessons
    from school, the Pythagorean theorem asserts the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的方法开始测量，即勾股定理，也称为欧几里得距离。如果你还记得你从学校学到的几何课程，勾股定理断言以下内容：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this assertion, the variables *a*, *b*, and *c* are all sides of a triangle.
    You can solve any one side if you know the other two.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个断言中，变量 *a*、*b* 和 *c* 都是三角形的边。如果你知道另外两边，你可以解出任意一边。
- en: 'In this example, we''ll start with two projected points in the **Mississippi
    Transverse Mercator** (**MSTM**) projection. The units of this projection are
    in meters. The *x*-axis locations are measured from the central meridian defined
    by the westernmost location in the state. The *y*-axis is defined from the NAD83
    horizontal datum. The first point, defined as (*x*1,*y*1), represents Jackson, the
    state capital of Mississippi. The second point, defined as (*x*2,*y*2) represents
    the city of Biloxi, which is a coastal town, as shown in the following illustration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6a11c12-f5cb-4e57-9386-3005535b2ed6.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: In the following example, the double-asterisk (**) in Python is the syntax for
    exponents, which we'll use to square the distances.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll import the Python math module for its square root function called `sqrt()`.
    Then, we''ll calculate the *x*-axis and *y*-axis distances. Finally, we''ll use
    these variables to execute the Euclidean distance formula to get the distance
    across the bounding box in meters from an *x*, *y* origin, which will be used
    in the MSTM projection:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, the distance is approximately 240,202 meters, which is around 240.2 kilometers
    or 150 miles. This calculation is reasonably accurate because this projection
    is optimized for measuring distance and area in Mississippi using Cartesian coordinates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: We can also measure distance using decimal degrees, but we must perform a few
    additional steps. To measure using degrees, we must convert the angles into radians,
    which account for the curved surface distance between the coordinates. We'll also
    multiply our output in radians times the radius of the Earth in meters to convert
    back from radians.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about radians at [http://en.wikipedia.org/wiki/Radian](http://en.wikipedia.org/wiki/Radian).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll perform this conversion using the Python `math.radians()` method in
    the following code when we calculate the *x* and *y* distances:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Okay, so this time, we came up with around 251 kilometers, which is 11 kilometers
    more than our first measurement. So, as you can see, your choice of measurement
    algorithm and Earth model can have significant consequences. Using the same equation,
    we come up with radically different answers, depending on our choice of coordinate
    system and Earth model.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about Euclidean distance at [http://mathworld.wolfram.com/Distance.html](http://mathworld.wolfram.com/Distance.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Let's check out the haversine formula next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Using the haversine formula
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Part of the problem with using the Pythagorean theorem to measure distance
    on the Earth, which is a sphere, is the concept of great circle distance. A great
    circle is the shortest distance between two points on a sphere. Another important
    feature that defines a great circle is that the circle, if followed all of the
    way around the sphere, will bisect the sphere into two equal halves, as shown
    in the following Wikipedia illustration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e646971-a86b-466e-8cc3-1f4241fcdff7.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'So, what is the right way to measure a line on a curved sphere? The most popular
    method is to use the **haversine formula**, which uses trigonometry to calculate
    the Great Circle distance using coordinates defined in decimal degrees as input.
    The haversine formula is *haversine(θ) = sin²(θ/2)*, where θ is the central angle
    between two points on a sphere. Once again, we''ll convert the axis distances
    from degrees into radians before we apply the formula, just like in the previous
    example. But this time, we''ll also convert the latitude (*y*-axis) coordinates
    into radians separately:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何正确地测量曲面上的一条线呢？最流行的方法是使用**哈弗辛公式**，它使用三角学来计算以十进制度数定义的坐标的大圆距离。哈弗辛公式是*haversine(θ)
    = sin²(θ/2)*，其中θ是球面上两点之间的中心角。再次提醒，在我们应用公式之前，我们将轴距离从度数转换为弧度，就像上一个例子一样。但这次，我们还将纬度(*y*-轴)坐标单独转换为弧度：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Wow! We get 240.6 kilometers using the haversine formula, compared to 240.2
    kilometers using the optimized and more accurate projection. This difference is
    less than half a kilometer, which is not bad for a distance calculation of two
    cities 150 miles apart. The haversine formula is the most commonly used distance
    measuring formula because it is relatively lightweight from a coding perspective
    and reasonably accurate in most cases. It is considered to be accurate to within
    about a meter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们使用哈弗辛公式得到了240.6公里，而使用优化且更精确的投影方法得到了240.2公里。这个差异不到半公里，对于一个相距150英里的两个城市的距离计算来说已经很不错了。哈弗辛公式是最常用的距离测量公式，因为它在编码方面相对简单，并且在大多数情况下相当准确。它被认为精确到大约一米的范围内。
- en: 'To summarize what we''ve learned so far, most of the point coordinates you
    encounter as an analyst are in unprojected decimal degrees. So, your options for
    measurement are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总结到目前为止我们所学的，作为分析师，你遇到的点坐标大多数都是未投影的十进制度数。因此，你的测量选项如下：
- en: Reproject to a distance-accurate Cartesian projection and measure.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其重新投影到距离精确的笛卡尔投影中并测量。
- en: Just use the haversine formula and see how far it takes you for your analysis.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需使用哈弗辛公式，看看它如何帮助你的分析。
- en: Use the even more precise Vincenty formula.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更加精确的文森蒂公式。
- en: That's right! There's another formula that seeks to provide an even better measurement
    than haversine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对了！还有一个公式试图提供比哈弗辛公式更好的测量结果。
- en: Using the Vincenty formula
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文森蒂公式
- en: So, we've examined distance measurement using the Pythagorean theorem (flat
    Earth model) and the haversine formula (spherical Earth model). The Vincenty formula
    accounts for the ellipsoid model of the Earth. And if you are using a localized
    ellipsoid, it can be accurate to much less than a meter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经检查了使用勾股定理（平坦地球模型）和哈弗辛公式（球形地球模型）进行距离测量的方法。文森蒂公式考虑了地球的椭球体模型。如果你使用的是局部椭球体，它可以精确到小于一米的程度。
- en: 'In the following implementation of this formula, you can change the semi-major
    axis value and flattening ratio to fit the definition of any ellipsoid. Let''s
    see what the distance is when we measure using the Vincenty formula on the NAD83
    ellipsoid in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下公式的实现中，你可以更改半长轴值和扁平率，以适应任何椭球体的定义。让我们看看在以下示例中使用文森蒂公式在NAD83椭球体上测量时的距离是多少：
- en: 'First, we will import the `math` module, which allows us to work in radians,
    and the other `math` functions we''ll need:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入`math`模块，这允许我们在弧度下工作，以及我们需要的其他`math`函数：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we need to set up our variables, including the variable that holds our
    distance value, the two points we''re measuring, the constants describing the
    Earth, and the derivative formulas we need:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要设置我们的变量，包括包含距离值的变量、我们正在测量的两个点、描述地球的常数以及我们需要的一阶导数公式：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now begins the Vincenty formula. There''s just no easy way to do this and the
    math is a little complicated, but it works:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始文森蒂公式。没有简单的方法来做这件事，数学有点复杂，但它有效：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, after all that, we have our distance:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在完成所有这些之后，我们得到了我们的距离：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the Vincenty formula, our measurement came to 240.1 kilometers, which
    is only 100 meters off from our projected measurement using Euclidean distance.
    Impressive! While many times more mathematically complex than the haversine formula,
    you can see that it is also much more accurate.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文森蒂公式，我们的测量结果是240.1公里，这比我们使用欧几里得距离预测的测量结果只差100米。令人印象深刻！虽然它比哈弗辛公式在数学上复杂得多，但你也可以看到它更加精确。
- en: 'The pure Python geopy module includes an implementation of the Vincenty formula
    and has the ability to geocode locations by turning place names into latitude
    and longitude coordinates: [http://geopy.readthedocs.org/en/latest/](http://geopy.readthedocs.org/en/latest/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The points that were used in these examples are reasonably close to the equator.
    As you move toward the poles or work with larger distances or extremely small
    distances, the choices you make become increasingly more important. If you're
    just trying to make a radius around a city to select locations for a marketing
    campaign promoting a concert, then an error of a few kilometers is probably okay.
    However, if you're trying to estimate fuel required for an airplane to make a
    flight between two airports, then you want to be spot on!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to learn more about issues with measuring distance and direction,
    and how to work around them with programming, visit the following site: [http://www.movable-type.co.uk/scripts/latlong.html](http://www.movable-type.co.uk/scripts/latlong.html).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: On this site, Chris Veness goes into great detail on this topic and provides
    online calculators, as well as examples written in JavaScript, which can easily
    be ported to Python. The Vincenty formula implementation that we just saw is ported
    from the JavaScript on this site.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: You can see the full pure mathematical notation for the Vincenty formula here: [https://en.wikipedia.org/wiki/Vincenty%27s_formulae](https://en.wikipedia.org/wiki/Vincenty%27s_formulae).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to calculate distance, we need to understand how to calculate
    the direction of a line to relate objects on Earth by distance and location for
    geospatial analysis.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Calculating line direction
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to distance, you will often want to know the bearing of a line
    between its endpoints. We can calculate this line direction from one of the points
    using only the Python `math` module:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the `math` functions we''ll need:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we set up some variables for our two points:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''ll calculate the angle between the two points:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we''ll calculate the bearing of the line in degrees:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sometimes, you end up with a negative bearing value. To avoid this issue, we
    add `360` to the result to avoid a negative number and use the Python modulo operator
    to keep the value from climbing to over `360`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The `math` in the angle calculation is reverse engineering a right triangle
    and then figuring out the acute angle of the triangle. The following URL provides
    an explanation of the elements of this formula, along with an interactive example
    at the end: [https://www.mathsisfun.com/sine-cosine-tangent.html](http://www.movable-type.co.uk/scripts/latlong.html).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to calculate the location of features on the Earth. Next, we'll
    learn how to integrate data from different sources, starting with coordinate conversion.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Understanding coordinate conversion
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coordinate conversion allows you to convert point coordinates between different
    coordinate systems. When you start working with multiple datasets, you'll inevitably
    end up with data in different coordinate systems and projections. You can convert
    back and forth between two of the most common coordinate systems, UTM and geographic
    coordinates (latitude and longitude), using a pure Python module called `utm`.
    You can install it using `easy_install` or `pip` from PyPI: [https://pypi.python.org/pypi/utm](https://pypi.python.org/pypi/utm).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标转换允许你在不同的坐标系之间转换点坐标。当你开始处理多个数据集时，你不可避免地会得到不同坐标系和投影的数据。你可以使用一个名为`utm`的纯Python模块在两个最常用的坐标系之间进行转换，即UTM和地理坐标（纬度和经度）。你可以使用`easy_install`或从PyPI的`pip`安装它：[https://pypi.python.org/pypi/utm](https://pypi.python.org/pypi/utm)。
- en: 'The `utm` module is straightforward to use. To convert from UTM into latitude
    and longitude, you can use the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`utm`模块的使用非常简单。要将UTM坐标转换为纬度和经度，可以使用以下代码：'
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The UTM zones are numbered horizontally. However, vertically, the bands of
    latitude are ordered by the English alphabet with a few exceptions. For example,
    the letters *A*, *B*, *Y*, and *Z* are used to label the Earth''s poles. The letters
    *I* and *O* are omitted because they look too much like *1* and *0*. Letters *N*
    through *X* are in the Northern Hemisphere while *C* through *M* are in the Southern
    Hemisphere. The following screenshot, from the website *Atlas Florae Europaeae*,
    illustrates the UTM zones over Europe:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: UTM区域是水平编号的。然而，垂直方向上，纬度带按英文字母顺序排列，有一些例外。例如，字母*A*、*B*、*Y*和*Z*用于标记地球的极点。字母*I*和*O*被省略，因为它们看起来太像*1*和*0*。字母*N*到*X*位于北半球，而字母*C*到*M*位于南半球。以下截图来自网站*Atlas
    Florae Europaeae*，展示了欧洲的UTM区域：
- en: '![](img/9c13b8e9-cba9-442b-9c94-b80f2812f216.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c13b8e9-cba9-442b-9c94-b80f2812f216.png)'
- en: 'Converting from latitude and longitude is even easier. We just pass the latitude
    and longitude to the `from_latlon()` method, which returns a tuple with the same
    parameters that are accepted by the `to_latlon()` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从纬度和经度转换甚至更简单。我们只需将纬度和经度传递给`from_latlon()`方法，该方法返回一个元组，包含与`to_latlon()`方法接受的相同参数：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The algorithms that were used in this Python implementation are described in
    detail at [http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM](http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在此Python实现中使用的算法在[http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM](http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM)上进行了详细描述。
- en: Converting between UTM and latitude/longitude just scratches the surface of
    transforming datasets from different sources so that they can be overlaid nicely
    on a map. To go beyond the basics, we'll need to perform map projections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在UTM和纬度/经度之间转换只是将来自不同来源的数据集转换以便在地图上很好地叠加的表面工作。要超越基础，我们需要执行地图投影。
- en: Now that we know how to calculate line direction, let's see how reprojection
    is done.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何计算线方向，让我们看看重投影是如何进行的。
- en: Understanding reprojection
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解重投影
- en: In GIS, reprojection is all about changing the coordinates in a dataset from
    one coordinate system to another. While reprojection is less common these days
    due to more advanced methods of data distribution, sometimes you need to reproject
    a shapefile. The pure Python `utm` module works for reference system conversion,
    but for a full reprojection, we need some help from the OGR Python API. The OGR
    API contained in the `osgeo` module also provides the Open Spatial Reference module,
    also known as `osr`, which we'll use for reprojection.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在GIS中，重投影就是将数据集中的坐标从一个坐标系转换到另一个坐标系。尽管由于数据分布的更先进方法，重投影现在不太常见，但有时你需要重投影一个shapefile。纯Python的`utm`模块适用于参考系统转换，但对于完整的重投影，我们需要OGR
    Python API的帮助。包含在`osgeo`模块中的OGR API还提供了开放空间参考模块，也称为`osr`，我们将使用它来进行重投影。
- en: As an example, we'll use a point shapefile containing New York City museum and
    gallery locations in the Lambert conformal projection. We'll reproject it to WGS84
    geographic (or un-project, it rather). You can download this zipped shapefile
    at [https://git.io/vLbT4](https://git.io/vLbT4).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用一个包含纽约市博物馆和画廊位置的Lambert正形投影点shapefile。我们将将其重投影到WGS84地理（或更确切地说，取消投影）。你可以在此处下载此zip文件：[https://git.io/vLbT4](https://git.io/vLbT4)。
- en: 'The following minimalist script reprojects the shapefile. The geometry is transformed
    and then written to the new file, but the `.dbf` file is simply copied to the
    new name as we aren''t changing it. The standard Python `shutil` module, short
    for shell utilities, is used to copy `.dbf`. The source and target shapefile names
    are variables at the beginning of the script. The target projection is also near
    the top, which is set using an EPSG code. The script assumes there is a `.prj`
    projection file, which defines the source projection. If not, you could manually
    define it using the same syntax as the target projection. We''ll walk through
    projecting a dataset step by step. Each section is marked with comments:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最简化的脚本，用于重新投影shapefile。几何形状被转换后写入新文件，但`.dbf`文件只是简单地复制到新名称，因为我们没有改变它。我们使用了标准的Python
    `shutil`模块，简称shell工具，用于复制`.dbf`。源shapefile名称和目标shapefile名称在脚本的开头作为变量。目标投影也接近顶部，它使用EPSG代码设置。该脚本假设存在一个`.prj`投影文件，它定义了源投影。如果没有，你可以使用与目标投影相同的语法手动定义它。我们将逐步讲解投影数据集的过程。每个部分都有注释：
- en: 'First, we import our libraries:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的库：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we define our shapefile names as variables:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将shapefile名称定义为变量：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we create our target spatial reference using the `osr` module as EPSG
    code `4326`, which is WGS84 Geographic:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`osr`模块和EPSG代码`4326`创建我们的目标空间参考，它是WGS84地理坐标：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we set up our shapefile `Reader` object using `ogr` and get the spatial
    reference:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`ogr`设置我们的shapefile `Reader`对象并获取空间参考：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we check whether our target shapefile already exists from a previous
    test run and delete it if it does:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查目标shapefile是否已从之前的测试运行中存在，如果存在则删除它：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can begin building our target layer for the shapefile:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始构建我们的目标图层：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we can loop through the features in our source shapefile, reproject them
    using the `Transform()` method, and add them to the new shapefile:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以遍历源shapefile中的要素，使用`Transform()`方法重新投影它们，并将它们添加到新shapefile中：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we need to create a shapefile `.prj` file containing projection information
    as a shapefile has no inherent way to store it:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个包含投影信息的shapefile `.prj`文件，因为shapefile没有固有的方式来存储它：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we can just make a copy of the `.dbf` source with the new filename
    as the attributes are part of the reprojection process:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需将`.dbf`源复制到新文件名，因为属性是重投影过程的一部分：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following screenshot shows the reprojected points in QGIS with satellite
    imagery in the background:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了QGIS中重新投影的点，背景为卫星影像：
- en: '![](img/e38dd1d3-50b4-4bfd-b5e5-d7bea52744a8.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e38dd1d3-50b4-4bfd-b5e5-d7bea52744a8.png)'
- en: If you are working with a set of points, you can reproject them programmatically
    instead of reprojecting a shapefile using PyProj: [https://jswhit.github.io/pyproj/](https://jswhit.github.io/pyproj/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理一组点，你可以通过编程方式重新投影它们，而不是使用PyProj重新投影shapefile：[https://jswhit.github.io/pyproj/](https://jswhit.github.io/pyproj/)。
- en: In addition to converting coordinates into different projections, you often
    need to convert them among different formats, which we'll look at next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将坐标转换为不同的投影外，你通常还需要在不同格式之间进行转换，我们将在下一部分进行探讨。
- en: Understanding coordinate format conversion
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解坐标格式转换
- en: Map coordinates were traditionally represented as degrees, minutes, and seconds
    (DMS) for maritime navigation. However, in GIS (which is computer-based), latitude
    and longitude are represented as decimal numbers known as **decimal degrees**.
    The degrees, minutes, and seconds format is still used. Sometimes, you have to
    convert between that format and decimal degrees to perform calculations and output
    reports.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 地图坐标传统上以度、分、秒（DMS）的形式表示，用于海上导航。然而，在GIS（基于计算机的）中，纬度和经度以称为十进制度数的十进制数表示。度、分、秒格式仍然在使用。有时，你必须在这两种格式之间进行转换，以执行计算和输出报告。
- en: 'In this example, we''ll create two functions that can convert either format
    into the other:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建两个函数，可以将一种格式转换为另一种格式：
- en: 'First, we import the `math` module to do conversions and the `re` regular expression
    module to parse the coordinate string:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`math`模块进行转换和`re`正则表达式模块解析坐标字符串：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have our function to convert decimal degrees into a `degrees`, `minutes`,
    and `seconds` string:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个函数可以将十进制度数转换为`度`、`分`和`秒`字符串：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we have our function to go the other way and convert degrees:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个函数用于反向转换度数：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, if we want to convert decimal degrees into DMS, it''s as simple as using
    the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想将十进制度数转换为DMS，就像使用以下代码一样简单：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To go the other direction, you just type the following function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行相反的操作，你只需输入以下函数：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that, because the DMS coordinates contain both single and double quotes
    to represent minutes and seconds, we have to use the Python string convention
    of using triple quotes on each latitude and longitude coordinate to contain both
    types of quotes so that they are parsed correctly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于DMS坐标包含单引号和双引号来表示分钟和秒，我们必须使用Python字符串约定，在每个纬度和经度坐标上使用三引号来包含这两种引号，以便它们被正确解析。
- en: Coordinates are the fundamental units of a GIS dataset. They are used to build
    points, lines, and polygons.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标是GIS数据集的基本单位。它们用于构建点、线和多边形。
- en: Calculating the area of a polygon
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算多边形的面积
- en: We have one more calculation before we move on to editing GIS data. The most
    basic unit of GIS is a point. Two points can form a line. Multiple lines that
    share endpoints can form a polyline, and polylines can form polygons. Polygons
    are used to represent everything from a house to an entire country in geospatial
    operations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编辑GIS数据之前，我们还有一个计算要做。GIS的最基本单位是一个点。两个点可以形成一条线。共享端点的多条线可以形成多段线，多段线可以形成多边形。多边形用于在地理空间操作中表示从一栋房子到整个国家的一切。
- en: Calculating the area of a polygon is one of the most useful operations in GIS
     if we wish to understand the relative size of features. But in GIS, area calculations
    go beyond basic geometry. The polygon lies on the Earth, which is a curved surface.
    The polygon must be projected to account for that curvature.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 计算多边形的面积是GIS中最有用的操作之一，如果我们想了解特征的相对大小。但在GIS中，面积计算不仅限于基本几何。多边形位于地球表面，这是一个曲面的表面。多边形必须进行投影以考虑这种曲率。
- en: 'Fortunately, there is a pure Python module simply called `area` that handles
    these complications for us. And because it''s pure Python, you can look at the
    source code to see how it works. The `area` module''s `area()` function accepts
    a GeoJSON string with a list of points that form a polygon and then returns the
    area. The following steps will show you how to calculate the area of a polygon:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个纯Python模块，简单地称为`area`，为我们处理这些复杂问题。由于它是纯Python，你可以查看源代码来了解它是如何工作的。`area`模块的`area()`函数接受一个GeoJSON字符串，其中包含构成多边形的点列表，然后返回面积。以下步骤将展示如何计算多边形的面积：
- en: 'You can install the `area` module using `pip`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`pip`安装`area`模块：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we''ll import the `area` function from the `area` module:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`area`模块导入`area`函数：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we''ll create a variable called `polygon` that''s contained in a GeoJSON
    geometry for our polygon:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为`polygon`的变量，它包含在GeoJSON几何形状中，用于我们的多边形：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we''re able to pass the polygon points string to the area function to
    calculate the area:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将多边形点字符串传递给面积函数来计算面积：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The area that''s returned is `80235.13927976067` square meters. We can then
    use Python''s built-in `round()` function to round the long floating-point value
    to two decimal places to get **80235.14**:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的面积是`80235.13927976067`平方米。然后我们可以使用Python的内置`round()`函数将长浮点值四舍五入到两位小数，得到**80235.14**：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You now have the tools to do the math regarding the distance and size for geospatial
    data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有了进行地理空间数据距离和尺寸计算的数学工具。
- en: In the next section, we'll look at editing datasets in one of the most popular
    GIS data formats—shapefiles.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看编辑最流行的GIS数据格式之一——shapefiles中的数据集。
- en: Editing shapefiles
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑shapefiles
- en: 'Shapefiles are one of the most common data formats in GIS, both for exchanging
    data as well as performing GIS analysis. In this section, we''ll learn how to
    work with these files extensively. In [Chapter 2](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml),
    *Learning Geospatial Data*, we discussed shapefiles as a format that can have
    many different file types associated with it. For editing shapefiles, and most
    other operations, we are only concerned with two file types:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Shapefiles是GIS中最常见的数据格式之一，无论是用于数据交换还是进行GIS分析。在本节中，我们将学习如何广泛地处理这些文件。在[第2章](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml)《学习地理空间数据》中，我们讨论了shapefiles作为一种可以与其关联许多不同文件类型的格式。对于编辑shapefiles以及大多数其他操作，我们只关心两种文件类型：
- en: The `.shp` file
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.shp`文件'
- en: The `.dbf` file
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dbf`文件'
- en: The `.shp` file contains the geometry while the `.dbf` file contains the attributes
    of the corresponding geometry. For each geometry record in a shapefile, there
    is one `.dbf` record. The records aren't numbered or identified in any way. This
    means that, when adding and deleting information from a shapefile, you must be
    careful to remove or add a record to each file type to match.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`.shp`文件包含几何信息，而`.dbf`文件包含相应几何体的属性。在shapefile中的每个几何记录都有一个`.dbf`记录。记录没有编号或以任何方式标识。这意味着，当从shapefile中添加和删除信息时，你必须小心地删除或添加每个文件类型的记录以匹配。'
- en: 'As we discussed in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml),
    *Geospatial Python Toolbox*, there are two libraries we can use to edit shapefiles
    in Python:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第4章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)中讨论的，*地理空间Python工具箱*，我们可以使用以下两个库在Python中编辑shapefile：
- en: One is the Python bindings to the OGR library.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个是OGR库的Python绑定。
- en: The other is the PyShp library, which is written in pure Python.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是PyShp库，它完全是用Python编写的。
- en: We'll use PyShp in order to stick with the *pure Python when possible* theme
    of this book. To install PyShp, use `easy_install` or `pip`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用PyShp来保持本书*尽可能使用纯Python*的主题。要安装PyShp，请使用`easy_install`或`pip`。
- en: 'To begin editing shapefiles, we''ll start with a point shapefile containing
    cities for the state of Mississippi, which you can download as a ZIP file. Download
    the following file to your working directory and unzip it: [http://git.io/vLbU4](http://git.io/vLbU4).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编辑shapefile，我们将从一个包含密西西比州城市的点shapefile开始，你可以将其作为ZIP文件下载。将以下文件下载到你的工作目录并解压它：[http://git.io/vLbU4](http://git.io/vLbU4)。
- en: 'The points we are working with can be seen in the following illustration:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的点可以在以下插图看到：
- en: '![](img/06c2c998-8899-449c-974f-3b25085cc87c.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06c2c998-8899-449c-974f-3b25085cc87c.png)'
- en: Accessing the shapefile
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问shapefile
- en: 'To do anything with a shapefile, we''ll need to access it as a data source.
    To access the shapefile, we''ll use PyShp to open it. In PyShp, we''ll add the
    following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要对shapefile进行任何操作，我们需要将其作为数据源访问。要访问shapefile，我们将使用PyShp打开它。在PyShp中，我们将添加以下代码：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We created a shapefile `Reader` object instance and set it to the `r` variable. Notice
    that, when we passed the filename to the `Reader` class, we didn't use any file
    extensions. Remember that we are dealing with at least two different files ending
    in `.shp` and `.dbf`. So, the base filename without the extension that is common
    to these two files is all we really need.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个shapefile `Reader`对象实例并将其设置为`r`变量。请注意，当我们向`Reader`类传递文件名时，我们没有使用任何文件扩展名。记住，我们至少在处理两个以`.shp`和`.dbf`结尾的不同文件。因此，这些两个文件共有的基本文件名是我们真正需要的所有。
- en: 'You can, however, use a file extension. PyShp will just ignore it and use the
    base filename. So, why would you add an extension? Most operating systems allow
    an arbitrary number of periods in a filename. For example, you might have a shapefile
    with the following base name: `myShapefile.version.1.2`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用文件扩展名。PyShp将忽略它并使用基本文件名。那么，为什么你要添加扩展名呢？大多数操作系统允许文件名中有任意数量的点号。例如，你可能有一个以下基本名称的shapefile：`myShapefile.version.1.2`。
- en: In this case, PyShp will try to interpret the characters after the last period
    as a file extension, which would be `.2`. This issue will prevent you from opening
    the shapefile. So, if your shapefile has periods in the base name, you would need
    to add a file extension such as `.shp` or `.dbf` to the filename.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，PyShp将尝试解释最后一个点号之后的字符作为文件扩展名，这将导致`.2`。这个问题将阻止你打开shapefile。所以，如果你的shapefile在基本名称中有点，你需要在文件名中添加文件扩展名，如`.shp`或`.dbf`。
- en: 'Once you have opened a shapefile and created a `Reader` object, you can get
    some information about the geographic data. In the following sample, we''ll get
    the bounding box, shape type, and the number of records in the shapefile from
    our `Reader` object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你打开了shapefile并创建了一个`Reader`对象，你可以从`Reader`对象获取一些关于地理数据的信息。在以下示例中，我们将从我们的`Reader`对象获取shapefile的边界框、形状类型和记录数：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The bounding box, which is stored in the `r.bbox` property, is returned as a
    list containing the minimum *x* value, minimum *y* value, maximum *x* value, and
    maximum *y* value. The shape type, which is available as the `shapeType` property,
    is a numeric code defined by the official shapefile specification. In this case,
    `1` represents a point shapefile, `3` represents lines, and `5` represents polygons.
    And finally, the `numRecords` property tells us there are `298` records in this
    shapefile. Because it is a simple point shapefile, we know there are `298` points,
    each with their own `.dbf` record.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the different geometry types for shapefiles, along
    with their corresponding numeric code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '| **Geometry** | **Numeric Code** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `NULL` | 0 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `POINT` | 1 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| `POLYLINE` | 3 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| `POLYGON` | 5 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| `MULTIPOINT` | 8 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| `POINTZ` | 11 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| `POLYLINEZ` | 13 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| `POLYGONZ` | 15 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| `MULTIPOINTZ` | 18 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| `POINTM` | 21 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| `POLYLINEM` | 23 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `POLYGONM` | 25 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `MULTIPOINTM` | 28 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `MULTIPATCH` | 31 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: Now that we know how to access it, let's see how we can read these files.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Reading shapefile attributes
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.dbf` file is a simple database format that is structured in a similar
    way to a spreadsheet with rows and columns, with each column as a label defining
    what information it contains. We can view that information by checking the fields
    property of the `Reader` object:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `fields` property returns quite a bit of information. The fields contain
    a list of information about each field, called **field descriptors**. For each
    field, the following information is presented:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**Field name:** This is the name of the field as text, which can be no longer
    than 10 characters for shapefiles.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field type:** This is the type of the field, which can be text, number, date,
    floating-point number, or Boolean represented as C, N, D, F, and L, respectively.
    The shapefile specification says it uses the `.dbf` format specified as dBASE
    III, but most GIS software seems to support dBASE IV. In version IV (4), the number
    and floating-point types are equivalent.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field length:** This is the length of the data in characters or digits.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decimal length:** This is the number of decimal places in a number or floating-point
    field.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first field descriptor outlines a hidden field that is part of the `.dbf`
    file format specification. `DeletionFlag` allows the software to mark records
    for deletion without actually deleting them. That way, the information is still
    in the file but can be removed from the displayed record list or search queries.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'If we just want the field name and not the other metadata, we can use Python
    list comprehensions to return just the first item in the descriptor and ignore
    the `DeletionFlag` field. This example creates a list comprehension that returns
    the first item in each descriptor (field name), starting with the second descriptor
    to ignore the deletion flag:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, we have just the field names, which are much easier to read. For clarity,
    the field names all contain the number `10` because this is version 2010 of this
    shapefile, which is created as a part of each census. These kinds of abbreviations
    are common in shapefile `.dbf` files due to the `10` character limit on the field
    names.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有字段名，这要容易阅读得多。为了清晰起见，字段名都包含数字 `10`，因为这是该 shapefile 的 2010 年版本，它是每个普查的一部分。这类缩写由于字段名长度限制为
    `10` 个字符而在 shapefile `.dbf` 文件中很常见。
- en: 'Next, let''s examine some of the records that these fields describe. We can
    view an individual record using the `r.record()` method. We know from the first
    example that there are `298` records. So, let''s examine the third record as an
    example. The records are accessed using list indexes. In Python, indexes start
    at `0`, so we have to subtract one from the desired record number to get the index.
    For record 3, the index would be `2`. You just pass the index to the `record()`
    method, as shown in the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查这些字段描述的一些记录。我们可以使用 `r.record()` 方法查看单个记录。我们知道从第一个例子中，有 `298` 条记录。所以，让我们以第三条记录为例。记录是通过列表索引访问的。在
    Python 中，索引从 `0` 开始，所以我们必须从所需的记录号中减去 `1` 以获得索引。对于记录 3，索引将是 `2`。您只需将索引传递给 `record()`
    方法，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, the field names are stored separately from the actual records.
    If you want to select a record value, you need its index. The index of the city
    name in each record is `4`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，字段名是独立于实际记录存储的。如果您想选择一个记录值，您需要它的索引。每个记录中城市名称的索引是 `4`：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But counting indexes is tedious. It''s much easier to reference a value by
    the field name. There are several ways we can associate a field name with the
    value of a particular record. The first is to use the `index()` method in Python
    lists to programmatically get the index using the field name:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但是计数索引是枯燥的。通过字段名引用值要容易得多。我们可以用几种方法将字段名与特定记录的值关联起来。第一种方法是使用 Python 列表的 `index()`
    方法，通过字段名来程序化地获取索引：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Another way we can associate field names to values is by using Python''s built-in
    `zip()` method, which matches corresponding items in two or more lists and merges
    them into a list of tuples. Then, we can loop through that list, check the name,
    and then grab the associated value, as shown in the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 Python 的内置 `zip()` 方法将字段名与值关联起来，该方法将两个或多个列表中的对应项匹配并合并到一个元组列表中。然后，我们可以遍历该列表，检查名称，然后获取相关的值，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also loop through `.dbf` records using the `r.records()` method. In
    this example, we''ll loop through the list returned by the `records()` method
    but limit the results using Python array slicing to the first three records. As
    we mentioned previously, shapefiles don''t contain record numbers, so we''ll also
    enumerate the records list and create a record number on the fly, so the output
    is a little easier to read. In this example, we''ll use the `enumerate()` method,
    which will return tuples containing an index and the record, as shown in the following
    code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `r.records()` 方法遍历 `.dbf` 记录。在这个例子中，我们将通过 Python 数组切片限制 `records()`
    方法返回的列表的结果，只遍历前三个记录。正如我们之前提到的，shapefiles 不包含记录号，因此我们还将枚举记录列表，并动态创建记录号，以便输出更易于阅读。在这个例子中，我们将使用
    `enumerate()` 方法，它将返回包含索引和记录的元组，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This kind of enumeration trick is what most GIS software packages use when displaying
    records in a table. Many GIS analysts assume shapefiles store the record number
    because every GIS program displays one. But if you delete a record, for example,
    record number 5 in ArcGIS or QGIS, and save the file, when you open it again,
    you'll find what was formerly record number 6 is now record 5\. Some spatial databases
    may assign a unique identifier to records. Often, a unique identifier is helpful.
    You can always create another field and column in `.dbf` and assign your own number,
    which remains constant even when records are deleted.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种枚举技巧是大多数 GIS 软件包在表格中显示记录时使用的。许多 GIS 分析师认为 shapefiles 存储记录号，因为每个 GIS 程序都会显示一个。但是，如果您删除了一个记录，例如在
    ArcGIS 或 QGIS 中删除记录号 5，并保存文件，当您再次打开它时，您会发现之前记录号 6 的现在变成了记录 5。一些空间数据库可能为记录分配一个唯一的标识符。通常，唯一的标识符很有帮助。您始终可以在
    `.dbf` 中创建另一个字段和列，并分配您自己的数字，即使记录被删除，这个数字也会保持不变。
- en: 'If you are working with very large shapefiles, PyShp has iterator methods that
    access data more efficiently. The default `records()` method reads all the records
    into the RAM at once, which is fine for the small `.dbf` files but becomes difficult
    to manage even with a few thousand records. Any time you''d use the `records()`
    method, you can also use the `r.iterRecords()` method the same way. This method
    holds the minimum amount of information needed to provide the record at hand rather
    than the whole dataset. In this quick example, we''re using the `iterRecords()`
    method to count the number of records to verify the count in the file header:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理非常大的shapefile，PyShp有迭代方法可以更有效地访问数据。默认的`records()`方法一次将所有记录读入RAM，这对于小的`.dbf`文件来说是可行的，但即使只有几千条记录，管理起来也变得困难。每次你使用`records()`方法时，你也可以同样使用`r.iterRecords()`方法。这种方法只保留提供当前记录所需的最小信息量，而不是整个数据集。在这个快速示例中，我们使用`iterRecords()`方法来计算记录数，以验证文件头部中的计数：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that we can read one half of the shapefile, that is, the attributes, we're
    ready to look at the other half, that is, the geometry.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以读取shapefile的一半，即属性，我们准备查看另一半，即几何形状。
- en: Reading shapefile geometry
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取shapefile几何形状
- en: 'Now, let''s take a look at the geometry. Previously, we looked at the header
    information and determined this shapefile was a point shapefile. So, we know that
    each record contains a single point. Let''s examine the first geometry record:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看几何形状。之前，我们查看了一些头部信息，并确定这个shapefile是一个点shapefile。所以，我们知道每个记录包含一个单独的点。让我们检查第一个几何形状记录：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In each geometry record, also known as `shape`, the points are stored in a list
    called `points`, even if there is only one point, as in this case. Points are
    stored as *x*, *y* pairs, so longitude comes before latitude if that coordinate
    system is used.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个几何形状记录中，也称为`shape`，即使只有一个点，如本例所示，点也存储在名为`points`的列表中。点以*x*，*y*对的形式存储，因此如果使用该坐标系，经度在纬度之前。
- en: The shapefile specification also allows for 3D shapes. Elevation values are
    along the *z*-axis and often called *z* values. So, a 3D point is typically described
    as *x*, *y*, *z*. In the shapefile format, *z* values are stored in a separate
    *z* attribute if they're allowed by the shape type. If the shape type doesn't
    allow for *z* values, then that attribute is never set when the records are read
    by PyShp. Shapefiles with *z* values also contain measure values or *m* values,
    which are rarely used and are not used in this example.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: shapefile规范还允许3D形状。高程值沿着*z*-轴，通常称为*z*值。所以，一个3D点通常描述为*x*，*y*，*z*。在shapefile格式中，如果形状类型允许，*z*值存储在单独的*z*属性中。如果形状类型不允许*z*值，那么在PyShp读取记录时，该属性永远不会设置。带有*z*值的shapefile还包含度量值或*m*值，这些值很少使用，且在本示例中未使用。
- en: A measure is a user-assigned value that may be associated with a shape. An example
    would be a temperature recorded at a given location. There is another class of
    shape types that allow for adding *m* values to each shape but not *z* values.
    This class of shape types is called an **M shape type**. Just like the *z* values,
    if the data is there, the *m* attribute is created; otherwise, it's not. You don't
    typically run into shapefiles with *z* values and you rarely come across shapefiles
    with *m* values set. But sometimes you do, so it's good to be aware of them. And
    just like our fields and records `.dbf` example, if you don't like having the
    *z* and *m* values stored in separate lists, from the points list, you can use
    the `zip()` method to combine them. The `zip` method can take multiple lists as
    parameters separated by commas, as demonstrated when we looped through the records
    previously and joined the field names and attributes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个度量是一个用户分配的值，可能与一个形状相关联。一个例子就是在特定位置记录的温度。还有另一类形状类型，允许为每个形状添加*m*值，但不能添加*z*值。这类形状类型被称为**M形状类型**。就像*z*值一样，如果数据存在，则创建*m*属性；否则，则不会创建。你通常不会遇到带有*z*值的shapefile，也很少会遇到带有*m*值设置的shapefile。但有时你会遇到，所以了解它们是好的。就像我们的字段和记录`.dbf`示例一样，如果你不喜欢将*z*和*m*值存储在单独的列表中，你可以从点列表中使用`zip()`方法将它们合并。`zip`方法可以接受多个列表作为参数，这些参数由逗号分隔，正如我们在之前循环记录时演示的那样，将字段名称和属性连接起来。
- en: When you create a `Reader` object with PyShp, it is read-only. You can change
    any values in the `Reader` object, but they are not written to the original shapefile.
    In the next subsection, we'll see how we can make changes in the original shapefile.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用PyShp创建`Reader`对象时，它是只读的。您可以在`Reader`对象中更改任何值，但它们不会被写入原始shapefile。在下一个子节中，我们将看到我们如何在原始shapefile中进行更改。
- en: Changing a shapefile
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改shapefile
- en: To create a shapefile, you need to also create a `Writer` object. You can change
    values in either a `Reader` or `Writer` object; they are just dynamic Python data
    types. But at some point, you must copy the values from `Reader` to `Writer`.
    PyShp automatically handles all of the header information, such as the bounding
    box and record count. You only need to worry about the geometry and attributes.
    You'll find that this method is much simpler than the OGR example we used previously.
    However, it is also limited to UTM projections.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个shapefile，您还需要创建一个`Writer`对象。您可以在`Reader`或`Writer`对象中更改值；它们只是动态的Python数据类型。但您必须在某个时候，将`Reader`中的值复制到`Writer`中。PyShp自动处理所有标题信息，例如边界框和记录计数。您只需关注几何和属性。您会发现这种方法比我们之前使用的OGR示例要简单得多。然而，它也仅限于UTM投影。
- en: To demonstrate this concept, we'll read in a shapefile containing points with
    units in degrees and convert it into the UTM reference system in a `Writer` object
    before saving it. We'll use PyShp and the UTM module we discussed previously in
    this chapter. The shapefile we'll use is the New York City museums shapefile,
    which we reprojected to a WGS84 geographic. You can also just download it as a
    ZIP file, which is available at [https://git.io/vLd8Y](https://git.io/vLd8Y).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个概念，我们将读取一个包含以度为单位单位的点的shapefile，并将其转换为`Writer`对象中的UTM参考系统，然后保存它。我们将使用PyShp和本章之前讨论的UTM模块。我们将使用的shapefile是纽约市博物馆的shapefile，我们将其重投影到WGS84地理坐标系。您也可以直接下载ZIP文件，该文件可在[https://git.io/vLd8Y](https://git.io/vLd8Y)找到。
- en: 'In the following example, we''ll read in the shapefile, create a writer for
    the converted shapefile, copy the fields over and then the records, and finally
    convert each point and write it as a geometry record before saving the converted
    shapefile:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将读取shapefile，为转换后的shapefile创建一个writer，复制字段，然后是记录，最后在保存转换后的shapefile之前将每个点转换为几何记录。以下是代码：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you were to print out the first point of the first shape, you would see
    the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要打印第一个shape的第一个点，您将看到以下内容：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The point is returned as a list containing four numbers. The first two are
    the *x* and *y* values, while the last two are placeholders, in this case for
    elevation and measure values, respectively, which are used when you write those
    types of shapefiles. Also, we did not write a PRJ projection file, as we did in
    the preceding reprojection example. Here''s a simple way to create a PRJ file
    using the EPSG code from [https://spatialreference.org/](https://spatialreference.org/).
    The `zone` variable in the preceding example tells us that we are working in UTM
    Zone 18, which is EPSG code 26918\. The following code will create a `prj` file:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 点以包含四个数字的列表形式返回。前两个是*x*和*y*值，而最后两个是占位符，在这种情况下分别用于高程和测量值，这些值在写入这些类型的shapefile时使用。此外，我们没有编写PRJ投影文件，就像我们在先前的重投影示例中所做的那样。以下是一个使用[https://spatialreference.org/](https://spatialreference.org/)中的EPSG代码创建PRJ文件的方法。先前的示例中的`zone`变量告诉我们我们正在使用UTM
    Zone 18，即EPSG代码26918。以下代码将创建一个`prj`文件：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As another example, we can add a new feature to a shapefile. In this example,
    we'll add a second polygon to a shapefile representing a tropical storm. You can
    download the zipped shapefile for this example here: [https://git.io/vLdlA](https://git.io/vLdlA).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个示例，我们可以在shapefile中添加一个新功能。在这个例子中，我们将向表示热带风暴的shapefile中添加第二个多边形。您可以在此处下载此示例的压缩shapefile：[https://git.io/vLdlA](https://git.io/vLdlA)。
- en: 'We''ll read the shapefile, copy it to a `Writer` object, add the new polygon,
    and write it back out with the same filename using the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将读取shapefile，将其复制到`Writer`对象中，添加新的多边形，并使用以下代码以相同的文件名将其写回：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is how we do the changes in the original shapefile. Now, let's see how
    we can add new fields in the shapefile.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在原始shapefile中进行更改的方法。现在，让我们看看我们如何在shapefile中添加新字段。
- en: Adding fields
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加字段
- en: 'A very common operation on shapefiles is to add additional fields to them.
    This operation is easy but there''s one important element to remember. When you
    add a field, you must also loop through the records and either create an empty
    cell or add a value for that column. As an example, let''s add a reference latitude
    and longitude column to the UTM version of the New York City museums shapefile:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在形状文件上执行的一个非常常见的操作是向它们添加额外的字段。这个操作很简单，但有一个重要的元素需要记住。当你添加一个字段时，你也必须遍历记录并为该列创建一个空单元格或添加一个值。作为一个例子，让我们向纽约市博物馆的UTM版本形状文件添加一个参考纬度和经度列：
- en: 'First, we''ll open the shapefile and create a new `Writer` object:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将打开形状文件并创建一个新的`Writer`对象：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we''ll add the fields as float types with a length of `8` for the entire
    field and a maximum precision of `5` decimal places:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将字段作为长度为`8`的浮点类型添加，整个字段的精度最高为`5`位小数：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we''ll open the geographic version of the shapefile and grab the coordinates
    from each record. We''ll add these to the corresponding attribute record in the
    UTM version''s `.dbf`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将打开地理版本的形状文件并从每个记录中获取坐标。我们将这些坐标添加到UTM版本`.dbf`中的相应属性记录中：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the next subsection, we'll see how we can merge multiple shapefiles.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将看到如何合并多个形状文件。
- en: Merging shapefiles
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并形状文件
- en: Aggregating multiple related shapefiles of the same type into one larger shapefile
    is another very useful technique. You might be working as part of a team that
    divides up an area of interest and then assembles the data at the end of the day.
    Or, you might aggregate data from a series of sensors out in the field, such as
    weather stations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个相同类型的相关形状文件聚合到一个更大的形状文件中是另一种非常有用的技术。你可能是在一个团队中工作，该团队将感兴趣的区域划分成几个部分，然后在一天结束时组装数据。或者，你可能从一系列现场传感器（如气象站）中聚合数据。
- en: For this example, we'll use a set of building footprints for a county that is
    maintained separately in four different quadrants (northwest, northeast, southwest,
    and southeast). You can download these shapefiles as a single ZIP file at [http://git.io/vLbUE](http://git.io/vLbUE).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用一套县建筑足迹，该县分别维护在四个不同的象限（西北、东北、西南和东南）。你可以将这些形状文件作为一个单独的ZIP文件下载，链接为[http://git.io/vLbUE](http://git.io/vLbUE)。
- en: 'When you unzip these files, you''ll see they are named by quadrant. The following
    script uses PyShp to merge them into a single shapefile:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你解压这些文件时，你会看到它们按象限命名。以下脚本使用PyShp将它们合并成一个形状文件：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, merging a set of shapefiles is very straightforward. However,
    we didn't do any sanity checks to make sure the shapefiles were all of the same
    type, which you might want to do if this script was used for a repeated automated
    process, instead of just a quick one-off process.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，合并一系列形状文件非常直接。然而，我们没有进行任何合理性检查以确保所有形状文件都是同一类型，如果你打算将此脚本用于重复的自动化过程，而不是仅仅是一次性过程，你可能需要这样做。
- en: 'Another note about this example is how we invoked the `Writer` object. In the
    other examples, we used a numeric code to define a shape type. You can define
    that number directly (for example, 1 for point shapefiles) or call one of the
    PyShp constants. The constants are the type of shapefile in all caps. For example,
    a polygon is as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个示例的另一个注意事项是我们如何调用`Writer`对象。在其他示例中，我们使用一个数字代码来定义形状类型。你可以直接定义那个数字（例如，对于点形状文件为1）或调用PyShp的一个常量。常量是大写字母表示的形状文件类型。例如，多边形如下所示：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this case, the value of that constant is 5\. When copying data from a `Reader`
    to a `Writer` object, you''ll notice the shape type definition is simply referenced,
    as shown in this example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，该常数的值是5。当从`Reader`对象复制数据到`Writer`对象时，你会注意到形状类型定义只是简单地引用，如下面的示例所示：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This method makes your script more robust as the script has one less variable that
    needs to be changed if you later change the script or the dataset. In the merging
    example, we don't have the benefit of having a `Reader` object available when
    we invoke `Writer`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使你的脚本更加健壮，因为如果以后更改脚本或数据集，脚本中有一个更少的变量需要更改。在合并示例中，当我们调用`Writer`时，我们没有`Reader`对象可用的好处。
- en: We could open the first shapefile in the list and check its type, but that would
    add several more lines of code. An easier way is just to omit the shape type.
    If the `Writer` shape type isn't saved, PyShp will ignore it until you save the
    shapefile. At that time, it will check the individual header of a geometry record
    and determine it from that.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打开列表中的第一个shapefile并检查其类型，但这会增加几行代码。更简单的方法是省略形状类型。如果`Writer`的形状类型没有保存，PyShp将忽略它，直到你保存shapefile。那时，它将检查单个几何记录的标题并据此确定。
- en: 'While you can use this method in special cases, it''s better to define the
    shape type explicitly when you can, for clarity, and just to be safe to prevent
    any outlier case errors. The following illustration is a sample of this dataset
    so that you get a better idea of what the data looks like, as we will be using
    it more next:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在特殊情况下使用这种方法，但当你能明确定义形状类型时，为了清晰和确保安全，防止任何异常情况错误，最好明确定义形状类型。以下插图是此数据集的样本，以便你更好地了解数据的外观，因为我们将在接下来的使用中更多地使用它：
- en: '![](img/d6dbb7db-b1ed-478d-8481-d53f7976afc3.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6dbb7db-b1ed-478d-8481-d53f7976afc3.png)'
- en: Now, let's see how to do this with the `.dbfpy` files.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`.dbfpy`文件来完成这个操作。
- en: Merging shapefiles with dbfpy
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dbfpy合并shapefiles
- en: The `.dbf` portion of PyShp can occasionally run into issues with `.dbf` files
    that are  produced by certain software. Fortunately, PyShp allows you to manipulate
    the different shapefile types separately. There's a more robust `.dbf` library,
    named `dbfpy3`, which we discussed in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml), *Geospatial
    Python Toolbox*. You can use PyShp to handle the `.shp` and `.shx` files, while
    `.dbfpy` handles more complex `.dbf` files. You can download the module here: [https://github.com/GeospatialPython/dbfpy3/archive/master.zip](https://github.com/GeospatialPython/dbfpy3/archive/master.zip).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: PyShp的`.dbf`部分有时会遇到与某些软件生成的`.dbf`文件相关的问题。幸运的是，PyShp允许你分别操作不同的shapefile类型。有一个更健壮的`.dbf`库，名为`dbfpy3`，我们在[第4章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)“地理空间Python工具箱”中讨论过。你可以使用PyShp来处理`.shp`和`.shx`文件，而`.dbfpy`处理更复杂的`.dbf`文件。你可以从这里下载模块：[https://github.com/GeospatialPython/dbfpy3/archive/master.zip](https://github.com/GeospatialPython/dbfpy3/archive/master.zip)。
- en: 'This approach takes more code but it will often succeed where PyShp alone fails
    with `.dbf` issues. This example uses the same shapefiles from the previous example.
    In the following example, we''ll merge a shapefile using only its attributes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法需要更多的代码，但它通常会在PyShp单独处理`.dbf`问题时失败的地方成功。本例使用与上一个示例相同的shapefiles。在下面的示例中，我们将仅使用其属性合并一个shapefile：
- en: 'First, we import the libraries we need, get a list of shapefiles using the
    glob module, and create a shapefile `Writer` object using PyShp:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库，使用glob模块获取shapefiles列表，并使用PyShp创建一个shapefile `Writer`对象：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we''re going to open only the `.``shp` files and copy the geometries to
    the writer. We''ll circle back and get the attributes using the `dbypy3` module
    later to demonstrate working with shapefile components separately:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将只打开`.shp`文件并复制几何数据到writer。稍后我们将使用`dbfpy3`模块来获取属性，以演示分别处理shapefile组件：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once all of the geometry has been copied over to the writer, we can save the
    `.shp` file and have PyShp create an index file for the geometry:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有几何数据都复制到writer中，我们就可以保存`.shp`文件，并让PyShp为几何创建索引文件：
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we can get a list of `.dbf` files using the `glob` module:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`glob`模块获取`.dbf`文件列表：
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we''ll use the first `.dbf` file in the list as a template to get the
    field data and use it to set the properties of the shapefile writer:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用列表中的第一个`.dbf`文件作为模板来获取字段数据，并使用它来设置shapefile writer的属性：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then, we simply loop through the `.dbf` files and copy the records to `Writer:`
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们简单地遍历`.dbf`文件并将记录复制到`Writer:`中
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that we know how to merge shapefiles, let's check out how to split them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何合并shapefiles，让我们来看看如何分割它们。
- en: Splitting shapefiles
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割shapefiles
- en: Sometimes, you may also need to split larger shapefiles to make it easier for
    you to focus on a subset of interest. This splitting, or subsetting, can be done
    spatially or by attributes, depending on which aspect of the data is of interest.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能还需要分割较大的shapefiles，以便更容易地关注感兴趣的子集。这种分割，或子集化，可以是空间上的，也可以是按属性进行的，具体取决于对数据的哪个方面感兴趣。
- en: Subsetting spatially
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间子集化
- en: One way to extract part of a dataset is to use spatial attributes such as size.
    In the following example, we'll subset the southeast quadrant file we merged.
    We'll filter the building footprint polygons by area and export any buildings
    with a 100 square meters or less (about 1,000 square feet) profile to a new shapefile.
    We'll use the `footpints_se` shapefile for this.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'PyShp has a signed area method that accepts a list of coordinates and returns
    either a positive or negative area. We''ll use the `utm` module to convert the
    coordinates into meters. Normally, the positive or negative area denotes whether
    the point order of the polygon is clockwise or counterclockwise, respectively.
    But point order doesn''t matter here, so we''ll use the absolute value using the
    `abs()` function, as shown here, when we get the area value:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s see the difference in the number of records between the original and
    the subset shapefile:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We now have some substantial building blocks for geospatial analysis with vector
    data, as well as attributes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Performing selections
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous subsetting example is one way to select data. There are many other
    ways to subset data for further analysis. In this section, we'll examine selecting
    subsets of data that are critical for efficient data processing to reduce the
    size of a large dataset down to just our area of interest for a given dataset.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The point-in-polygon formula
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly discussed the point-in-polygon formula in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, as a common type of geospatial
    operation. You'll find it is one of the most useful formulas out there. The formula
    is relatively straightforward.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function performs this check using the **Ray Casting** method.
    This method draws a line from the test point all of the way through the polygon
    and counts the number of times it crosses the polygon boundary. If the count is
    even, the point is outside the polygon. If it is odd, then it''s inside. This
    particular implementation also checks to see whether the point is on the edge
    of the polygon:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s use the `point_in_poly()` function to test a point in Chile:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This shows that the point is inside. Let''s also verify that edge points will
    be detected:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You'll find new uses for this function all the time. It's definitely one to
    keep in your toolbox.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Bounding box selections
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A bounding box is the smallest rectangle that can completely contain a feature.
    We can use it as an efficient way to subset one or more individual features from
    a larger dataset. We'll look at one more example of using a simple bounding box
    to isolate a complex set of features and save it in a new shapefile. In this example,
    we'll subset the roads on the island of Puerto Rico from the mainland US Major
    Roads shapefile. You can download the shapefile here: [https://github.com/GeospatialPython/Learn/raw/master/roads.zip](https://github.com/GeospatialPython/Learn/raw/master/roads.zip).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Floating-point coordinate comparisons can be expensive, but because we are
    using a box and not an irregular polygon, this code is efficient enough for most
    operations:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点坐标比较可能很昂贵，但由于我们使用的是矩形而不是不规则多边形，这段代码对于大多数操作来说已经足够高效：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now that we've used geometry to select features, let's do it another way by
    using attributes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用几何形状选择了要素，让我们换一种方式，通过使用属性来操作。
- en: Attribute selections
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性选择
- en: We've now seen two different ways of subsetting a larger dataset, resulting
    in a smaller one based on spatial relationships. But we can also select data using
    the attribute fields. So, let's examine a quick way to subset vector data using
    the attribute table. In this example, we'll use a polygon shapefile that has densely
    populated urban areas within Mississippi. You can download this zipped shapefile
    from [http://git.io/vLbU9](http://git.io/vLbU9).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了两种不同的方法来子集化更大的数据集，基于空间关系得到一个更小的数据集。但我们也可以使用属性字段来选择数据。因此，让我们快速检查一下使用属性表来子集化矢量数据的方法。在这个例子中，我们将使用一个多边形形状文件，它包含密密麻麻的城市地区在密西西比州内。你可以从这个链接下载这个压缩的形状文件
    [http://git.io/vLbU9](http://git.io/vLbU9)。
- en: 'This script is really quite simple. It creates the `Reader` and `Writer` objects,
    copies the `.dbf` fields, loops through the records for matching attributes, and
    then adds them to `Writer`. We''ll select urban areas with a population of less
    than `5000`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本实际上非常简单。它创建了 `Reader` 和 `Writer` 对象，复制 `.dbf` 字段，遍历记录以匹配属性，然后将它们添加到 `Writer`。我们将选择人口少于
    `5000` 的城市地区：
- en: '[PRE66]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Attribute selections are typically fast. Spatial selections are computationally
    expensive because of floating-point calculations. Whenever possible, make sure
    you are unable to use attribute selection to subset first. The following illustration
    shows the starting shapefile containing all urban areas on the left with a state
    boundary, and the urban areas with less than 5,000 people on the right, after
    the previous attribute selection:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 属性选择通常很快。空间选择由于浮点计算而计算成本高昂。尽可能确保你首先无法使用属性选择来子集化。以下插图显示了包含所有城市区域的起始形状文件，左侧有一个州边界，以及之前的属性选择后，右侧人口少于
    5,000 的人的城市区域：
- en: '![](img/c80699c3-d955-4f23-b462-5a852a566dd6.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c80699c3-d955-4f23-b462-5a852a566dd6.png)'
- en: 'Let''s see what that same example looks like using `fiona`, which takes advantage
    of the OGR library. We''ll use nested `with` statements to reduce the amount of
    code needed to properly open and close the files:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `fiona` 的相同示例，它利用了 OGR 库。我们将使用嵌套的 `with` 语句来减少正确打开和关闭文件所需的代码量：
- en: '[PRE67]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, we know how to combine discrete datasets as well as split larger datasets
    apart. What else can we do? We can aggregate features within a dataset.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经知道如何组合离散数据集以及将更大的数据集拆分。我们还能做什么？我们可以在数据集内部聚合要素。
- en: Aggregating geometry
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合几何
- en: GIS vector datasets are typically composed of point, line, or polygon features.
    One of the principles of GIS is that things that are closer together geographically
    are more related than things that are further apart. When you have a set of related
    features, often, it's too much detail for the analysis you're trying to accomplish.
    It can be useful to generalize them to speed up processing or simplify a map.
    This type of operation is called **aggregation**. A common example of aggregation
    is to combine a set of local political boundaries into a larger political boundary
    such as counties into a state or states into a country or countries into continents.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: GIS 矢量数据集通常由点、线或多边形要素组成。GIS 的一个原则是，地理位置上更接近的事物比地理位置上更远的事物关系更密切。当你有一组相关要素时，通常，对于你试图完成的分析来说，细节太多。将它们概括以加快处理速度或简化地图是有用的。这种操作称为**聚合**。聚合的一个常见例子是将一组地方政治边界合并成更大的政治边界，例如将县合并成州，或将州合并成国家，或国家合并成洲。
- en: In this example, we'll do just that. We'll convert a dataset comprising all
    of the counties in the US state of Mississippi into a single polygon representing
    the entire state. The Python Shapely library is perfect for this kind of operation;
    however, it can only manipulate geometry and doesn't read or write data files.
    To read and write data files, we'll use the Fiona library. If you don't have Shapely
    or Fiona installed, use `pip` to install them. You can download the counties dataset
    here: [https://git.io/fjt3b](https://git.io/fjt3b).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将做的是将包括美国密西西比州所有县的数据集转换成一个代表整个州的单个多边形。Python的Shapely库非常适合这种操作；然而，它只能操作几何形状，不能读取或写入数据文件。为了读取和写入数据文件，我们将使用Fiona库。如果您还没有安装Shapely或Fiona，请使用`pip`安装它们。您可以从这里下载县数据集：[https://git.io/fjt3b](https://git.io/fjt3b)。
- en: 'The following illustration shows what the counties dataset looks like:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图显示了县数据集的外观：
- en: '![](img/5a61c8ea-f3ce-495b-9d9d-623950104a65.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a61c8ea-f3ce-495b-9d9d-623950104a65.png)'
- en: 'The following steps will show you how to merge the individual county polygons
    into a single polygon:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向您展示如何将单个县多边形合并成一个多边形：
- en: In the following code, we import the libraries we need, including the different
    portions of the `shapely` library.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们导入所需的库，包括`shapely`库的不同部分。
- en: Then, we'll open the counties GeoJSON file.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将打开县GeoJSON文件。
- en: Next, we'll copy the schema of the source file, which defines all of the metadata
    for the dataset.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将复制源文件的架构，它定义了数据集的所有元数据。
- en: Then, we need to alter that metadata copy to change the attributes  in order
    to define a single attribute for the state name. We also need to alter the geometry
    type from *MultiPolygon* to *Polygon*.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要修改元数据副本以更改属性，以便定义一个用于州名的单个属性。我们还需要将几何类型从*MultiPolygon*更改为*Polygon*。
- en: Then, we'll open our output dataset GeoJSON file named `combined.geojson`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将打开我们的输出数据集GeoJSON文件，命名为`combined.geojson`。
- en: Next, we'll extract all of the polygons and attributes and combine all of the
    polygons into one.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将提取所有多边形和属性，并将所有多边形合并成一个。
- en: Finally, we'll write the combined polygon out with the new attribute.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用新属性将合并的多边形写出来。
- en: 'We''ll import our libraries, including `OrderDict`, so that we can maintain
    control of the shapefile attributes:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导入我们的库，包括`OrderDict`，以便我们可以控制shapefile属性：
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We open our GeoJSON file and copy the metadata:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开我们的GeoJSON文件并复制元数据：
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, we create our new field:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的新字段：
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we can add the new field to the metadata:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将新字段添加到元数据中：
- en: '[PRE71]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, we can open the combined GeoJSON file and write out our results:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以打开合并的GeoJSON文件并写出我们的结果：
- en: '[PRE72]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output dataset will look similar to the following illustration:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 输出数据集将类似于以下插图：
- en: '![](img/bedbcd4d-abae-4cd7-910e-4504a3a4e5e2.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bedbcd4d-abae-4cd7-910e-4504a3a4e5e2.png)'
- en: Now that we know all about reading, editing, and writing GIS data, we can begin
    visualizing it in the upcoming sections.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了关于读取、编辑和写入GIS数据的一切，我们可以在接下来的章节中开始可视化它。
- en: Creating images for visualization
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于可视化的图像
- en: Now, we're moving from calculations and data editing to something we can see!
    We'll begin by creating different types of maps. In [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, we visualized our SimpleGIS
    program using the Tkinter module that's included with Python. In [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml),
    *Geospatial Python Toolbox*, we examined a few other methods for creating images.
    Now, we'll examine these tools in more depth by creating two specific types of
    thematic maps. The first is a dot density map and the second is a choropleth map.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正从计算和数据编辑转向我们可以看到的东西！我们将从创建不同类型的地图开始。在[第1章](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml)，*使用Python学习地理空间分析*，我们使用Python附带的自带Tkinter模块可视化了我们的SimpleGIS程序。在[第4章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)，*地理空间Python工具箱*，我们检查了创建图像的几种其他方法。现在，我们将通过创建两种特定的主题地图来更深入地研究这些工具。第一种是点密度图，第二种是面状图。
- en: First, let's start with the dot density map.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从点密度图开始。
- en: Dot density calculations
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点密度计算
- en: A dot density map shows concentrations of subjects within a given area. If an
    area is divided up into polygons containing statistical information, you can model
    that information using randomly distributed dots within that area using a fixed
    ratio across the dataset. This type of map is commonly used for population density
    maps.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 点密度图显示了给定区域内主题的集中情况。如果一个区域被划分为包含统计信息的多边形，你可以使用在该区域内使用固定比例随机分布的点来模拟该信息。这种类型的地图通常用于人口密度图。
- en: The cat map in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning
    about Geospatial Analysis with Python*, is a dot density map. Let's create a dot
    density map from scratch using pure Python. Pure Python allows you to work with
    much more lightweight libraries that are generally easier to install and are more
    portable. For this example, we'll use a US Census Bureau Tract shapefile along
    the US Gulf Coast, which contains population data. We'll also use the point-in-polygon
    algorithm to ensure the randomly distributed points are within the proper census
    tract. Finally, we'll use the `PNGCanvas` module to write out our image.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml)，“使用Python学习地理空间分析”，中的猫图是一个点密度图。让我们从头开始使用纯Python创建一个点密度图。纯Python允许你使用更轻量级的库，这些库通常更容易安装，并且更便携。在这个例子中，我们将使用美国人口普查局沿美国墨西哥湾沿岸的普查区形状文件，其中包含人口数据。我们还将使用点在多边形内算法来确保随机分布的点位于适当的人口普查区内。最后，我们将使用`PNGCanvas`模块来输出我们的图像。
- en: The `PNGCanvas` module is excellent and fast. However, it doesn't have the ability
    to fill in polygons beyond simple rectangles. You can implement a fill algorithm
    but it is very slow in pure Python. However, for a quick outline and point plot,
    it does a great job.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`PNGCanvas`模块非常出色且速度快。然而，它没有填充简单矩形以外的多边形的能力。你可以实现一个填充算法，但在纯Python中它非常慢。然而，对于快速轮廓和点绘图，它做得很好。'
- en: 'You''ll also see the `world2screen()` method, which is similar to the coordinates-to-mapping
    algorithm we used in SimpleGIS in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python. *In this example, we''ll read
    in a shapefile and write it back out as an image:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到`world2screen()`方法，这与我们在[第1章](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml)，“使用Python学习地理空间分析”中的SimpleGIS中使用的坐标到映射算法类似。在这个例子中，我们将读取形状文件并将其作为图像写回：
- en: 'First, we import the libraries we need, including `pngcanvas`, to draw a map
    image:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们需要的库，包括`pngcanvas`，以绘制地图图像：
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, we define our point-in-polygon function, which we''ve used before. In
    this example, we''ll use it to randomly distribute population values within a
    location:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的点在多边形内函数，我们之前已经使用过。在这个例子中，我们将使用它来在位置内随机分布人口值：
- en: '[PRE74]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we need a function to scale our geospatial coordinates to the map image:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数来将我们的地理空间坐标缩放到地图图像：
- en: '[PRE75]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we read in the shapefile and set the size of our output map image:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们读取形状文件并设置输出地图图像的大小：
- en: '[PRE76]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, we need to determine the index of the population field so that we can
    get the population count for each area:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定人口字段的索引，以便我们可以获取每个区域的人口计数：
- en: '[PRE77]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, we calculate the population density value. We want to create a dot on
    the map for every 100 people:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们计算人口密度值。我们希望在地图上为每100人创建一个点：
- en: '[PRE78]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We will loop through each polygon and randomly distribute the points to create
    a density map:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将遍历每个多边形，随机分布点以创建密度图：
- en: '[PRE79]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We''re now ready to create our output image:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们的输出图像：
- en: '[PRE80]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Our dots have been created. Now, we need to create the outlines of the census
    tract:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经创建了点。现在，我们需要创建人口普查区的轮廓：
- en: '[PRE81]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we''ll save the output image:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将保存输出图像：
- en: '[PRE82]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This script outputs an outline of the census tract, along with the density
    dots, to show population concentration very effectively:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本输出人口普查区的轮廓，以及密度点，以非常有效地展示人口集中情况：
- en: '![](img/59b0b86e-4854-46c0-ab62-a32cd4ffbd3e.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59b0b86e-4854-46c0-ab62-a32cd4ffbd3e.png)'
- en: 'Now, let''s check out the second type of map: choropleth maps.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看地图的第二种类型：渐变图。
- en: Choropleth maps
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐变图
- en: A choropleth uses shading, coloring, or symbols to show an average value or
    quantity within an area. They make it easy for us to visualize large amounts of
    data as a summary. This method is useful if related data spans multiple polygons.
    For example, in a worldwide population density map by country, many countries
    have disconnected polygons (for example, Hawaii is an island state of the US).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 水色图使用阴影、着色或符号来显示一个区域内平均的值或数量。它们使我们能够将大量数据作为总结来可视化。如果相关数据跨越多个多边形，这种方法很有用。例如，在按国家划分的全球人口密度地图中，许多国家有断开的多边形（例如，夏威夷是美国的一个岛国）。
- en: 'In this example, we''ll use the **Python Imaging Library** (**PIL**) we discussed
    in [Chapter 3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml), *The Geospatial Technology
    Landscape*. PIL is not purely Python but is designed specifically for Python.
    We''ll recreate our previous dot density example as a choropleth map. We''ll calculate
    a density ratio for each census tract based on the number of people (population)
    per square kilometer and use that value to adjust the color. Dark is more densely
    populated while lighter is less. Follow these steps:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用我们在第3章中讨论的**Python Imaging Library**（**PIL**），*地理空间技术景观*。PIL不是纯Python编写的，但它是专门为Python设计的。我们将重新创建我们之前的点密度示例，作为水色图。我们将根据每平方公里的人数（人口）计算每个普查区的密度比率，并使用该值调整颜色。深色表示人口密集，浅色表示人口稀疏。按照以下步骤操作：
- en: 'First, we will import our libraries:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入我们的库：
- en: '[PRE83]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, we''ll need our geospatial coordinates to image coordinates conversion
    function:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要我们的地理坐标到图像坐标转换函数：
- en: '[PRE84]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we open our shapefile and set our output image size:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们打开我们的形状文件并设置输出图像大小：
- en: '[PRE85]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We then set up PIL to draw our map image:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置PIL来绘制我们的地图图像：
- en: '[PRE86]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Just like our previous example, we need to get the index of the population
    field:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前的例子一样，我们需要获取人口字段的索引：
- en: '[PRE87]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, we can draw the polygons, shade them according to population density,
    and save the image:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以绘制多边形，根据人口密度着色，并保存图像：
- en: '[PRE88]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This script produces the following diagram with the relative density of tracks.
    You can adjust the color using the R, G, and B variables:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用相对密度绘制以下图表。您可以使用R、G和B变量调整颜色：
- en: '![](img/53ca2791-0a19-4602-ae26-99d663441ae3.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53ca2791-0a19-4602-ae26-99d663441ae3.png)'
- en: 'Now that we can show statistical data from shapefiles, we can look at a statistical
    data source that is even more common than shapefiles: spreadsheets.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够从形状文件中展示统计数据，我们可以看看比形状文件更常见的统计数据源：电子表格。
- en: Using spreadsheets
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用电子表格
- en: Spreadsheets such as Microsoft Office Excel and Open Office Calc are inexpensive
    (even free), ubiquitous, easy to use, and great for recording structured data.
    For these reasons, spreadsheets are widely used to collect data for entry into
    a GIS format. As an analyst, you will find yourself working with spreadsheets
    frequently.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如Microsoft Office Excel和Open Office Calc之类的电子表格便宜（甚至免费）、无处不在、易于使用，非常适合记录结构化数据。出于这些原因，电子表格被广泛用于收集数据以输入GIS格式。作为一名分析师，您会发现您经常需要与电子表格打交道。
- en: In the previous chapters, we discussed the CSV format, which is a text file
    with the same basic rows and columns data structure as a spreadsheet. For CSV
    files, you use Python's built-in `csv` module. But most of the time, people don't
    bother exporting a true spreadsheet to a generic CSV file. That's where the pure
    Python `xlrd` module comes into play. The name `xlrd` is short for **Excel Reader**
    and is available from PyPI. There is also an accompanying module, the `xlwt` (Excel
    Writer) module, for writing spreadsheets. These two modules make reading and writing
    Excel spreadsheets a snap. Combine it with PyShp and you can move back and forth
    between spreadsheets and shapefiles with ease. This example demonstrates converting
    a spreadsheet into a shapefile. We'll use a spreadsheet version of the New York
    City museum point data available at [https://git.io/Jemi9](https://git.io/Jemi9).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了CSV格式，它是一种与电子表格具有相同基本行和列数据结构的文本文件。对于CSV文件，您使用Python的内置`csv`模块。但大多数时候，人们不会费心将真正的电子表格导出为通用的CSV文件。这就是纯Python的`xlrd`模块发挥作用的地方。`xlrd`这个名字是**Excel
    Reader**的缩写，可以从PyPI获取。还有一个配套的模块，即`xlwt`（Excel Writer）模块，用于编写电子表格。这两个模块使得读写Excel电子表格变得轻而易举。结合PyShp，您可以轻松地在电子表格和形状文件之间转换。本例演示了将电子表格转换为形状文件的过程。我们将使用纽约市博物馆点数据的电子表格版本，该版本可在[https://git.io/Jemi9](https://git.io/Jemi9)找到。
- en: 'The spreadsheet contains the attribute data, followed by an *x* column with
    the longitude and a *y* column with the latitude. To export it to a shapefile,
    we''ll execute the following steps:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格包含属性数据，后面跟着一个*x*列（经度）和一个*y*列（纬度）。要将其导出为形状文件，我们将执行以下步骤：
- en: Open the spreadsheet.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开电子表格。
- en: Create a shapefile `Writer` object.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个形状文件`Writer`对象。
- en: Capture the first row of the spreadsheet as the `dbf` columns.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电子表格的第一行作为`dbf`列。
- en: Loop through each row of the spreadsheet and copy the attributes to `dbf`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历电子表格的每一行，并将属性复制到`dbf`。
- en: Create a point from the *x* and *y* spreadsheet columns.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从电子表格的*x*和*y*列创建一个点。
- en: 'The script is as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本如下：
- en: '[PRE89]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Converting a shapefile into a spreadsheet is a much less common operation,
    though not difficult. To convert a shapefile into a spreadsheet, you need to make
    sure you have an *x* and *y* column by using the *Adding fields* example from
    the *Editing shapefiles* section in this chapter. You would loop through the shapes
    and add the *x*, *y* values to those columns. Then, you would read the field names
    and column values from `dbf` into an `xlwt` spreadsheet object or a CSV file using
    the `csv` module. The coordinate columns are labeled in the following screenshot:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 将形状文件转换为电子表格是一个不太常见的操作，尽管并不困难。要将形状文件转换为电子表格，您需要确保使用*添加字段*示例，该示例来自本章*编辑形状文件*部分，您有一个*x*和*y*列。您将遍历形状，并将*x*、*y*值添加到这些列中。然后，您将读取字段名称和`dbf`中的列值到一个`xlwt`电子表格对象或CSV文件中，使用`csv`模块。坐标列在以下屏幕截图中有标签：
- en: '![](img/e854dbdf-2cce-4df8-9e10-3178bdca4126.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e854dbdf-2cce-4df8-9e10-3178bdca4126.png)'
- en: In the next section, we'll use a spreadsheet as an input data source.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用电子表格作为输入数据源。
- en: Creating heat maps
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建热图
- en: A heat map is used to show the geographic clustering of data using a raster
    image that shows density. The clustering can also be weighed by using a field
    in the data to not only show geographic density but also an intensity factor.
    In this example, we'll use bear sighting data contained in the CSV dataset, which
    stores the data as points to create a heat map of the frequency of bear sightings
    in different areas of Mississippi. This dataset is so simple that's we're going
    to treat the CSV file as a text file, which is one of the nice features of a CSV
    file.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 热图用于使用显示密度的栅格图像来显示数据的地理聚类。聚类还可以通过使用数据中的一个字段来权衡，不仅显示地理密度，还显示强度因子。在这个例子中，我们将使用包含在CSV数据集中的熊目击数据来创建密西西比州不同地区的熊目击频率热图。这个数据集非常简单，我们将把CSV文件当作文本文件处理，这是CSV文件的一个很好的特性。
- en: You can download the dataset here: [https://git.io/fjtGL](https://git.io/fjtGL).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处下载数据集：[https://git.io/fjtGL](https://git.io/fjtGL)。
- en: 'The output is going to be a simple HTML web map that you can open in any web
    browser. The web map will be based on the excellent Leaflet JavaScript library.
    On top of that, we''ll use the Python Folium library, which makes it easy  for
    us to create Leaflet web maps, in order to generate the HTML page:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个简单的HTML网络地图，您可以在任何网络浏览器中打开。该网络地图将基于优秀的Leaflet JavaScript库。在此基础上，我们将使用Python
    Folium库，这使得我们能够轻松创建Leaflet网络地图，以生成HTML页面：
- en: '[PRE90]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This script will create a file called `heatmap.html`. Open it in any web browser
    to see a similar image:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将创建一个名为`heatmap.html`的文件。在任何网络浏览器中打开它，您将看到类似的图像：
- en: '![](img/c2a59cc9-3722-430d-80af-409a4160d16f.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2a59cc9-3722-430d-80af-409a4160d16f.png)'
- en: Next, we'll learn how to use data generated by a GPS to collect field data such
    as the information in the preceding heatmap.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用GPS生成数据来收集如前述热图中的现场数据。
- en: Using GPS data
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPS数据
- en: The most common type of GPS data these days is the Garmin GPX format. We covered
    this XML format in [Chapter 4](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml), *Geospatial
    Python Toolbox*, which has become an unofficial industry standard. Because it
    is an XML format, all of the well-documented rules of XML apply to it. However,
    there is another type of GPS data that pre-dates XML and GPX, called the **National
    Marine Electronics Association** (**NMEA**). This data is ASCII text sentences
    that are designed to be streamed.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常见的GPS数据类型是Garmin GPX格式。我们在[第4章](ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml)，*地理空间Python工具箱*中介绍了这种XML格式，它已成为非官方的行业标准。因为它是一种XML格式，所以所有XML的良好文档规则都适用于它。然而，还有一种比XML和GPX更早的GPS数据类型，称为**国家海洋电子协会**（**NMEA**）。这些数据是设计为流式传输的ASCII文本句子。
- en: 'You occasionally bump into this format from time to time because even though
    it is older and esoteric, it is still very much alive and well, especially for
    communicating ship locations via the **Automated Identification System** (**AIS**),
    which tracks ships globally. But as usual, you have a good option in pure Python.
    The `pynmea` module is available on PyPI. The following code is a small sample
    of NMEA sentences:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你偶尔会遇到这种格式，尽管它较老且较为晦涩，但它仍然非常活跃，尤其是在通过**自动识别系统**（**AIS**）通信船舶位置时，AIS跟踪全球的船舶。但通常，你有一个纯Python的好选择。`pynmea`模块可在PyPI上找到。以下代码是NMEA语句的一个小样本：
- en: '[PRE91]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To install the `pynmea` module from PyPI and download the complete sample file,
    you can view the following URL: [http://git.io/vLbTv](http://git.io/vLbTv). Then,
    you can run the following sample, which will parse the `NMEA` sentences into objects.
    The NMEA sentences contain a wealth of information:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要从PyPI安装`pynmea`模块并下载完整的样本文件，你可以查看以下URL：[http://git.io/vLbTv](http://git.io/vLbTv)。然后，你可以运行以下样本，它将解析NMEA语句到对象。NMEA语句包含大量信息：
- en: '[PRE92]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The latitudes and longitudes are stored in a format called **degrees decimal
    minutes**. For example, this random coordinate, 4533.35, is 45 degrees and 33.35
    minutes. 0.35 of a minute is exactly 21 seconds. In another example, 16708.033
    is 167 degrees and 8.033 minutes. 0.033 of a minute is approximately 2 seconds.
    You can find more information about the NMEA format at [http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度和经度以称为**度分十分之一度**的格式存储。例如，这个随机的坐标4533.35，是45度和33.35分。一分之一的0.35是21秒。在另一个例子中，16708.033是167度和8.033分。一分之一的0.033大约是2秒。你可以在[http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/)找到更多关于NMEA格式的信息。
- en: GPS data is an important location data source, but there's another way we can
    describe a point on the Earth using a street address. The method for locating
    a street address on the Earth is called geocoding.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: GPS数据是一个重要的位置数据源，但我们可以使用街道地址来描述地球上的一个点。在地球上定位街道地址的方法称为地理编码。
- en: Geocoding
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理编码
- en: 'Geocoding is the process of converting a street address into latitude and longitude.
    This operation is critical to in-vehicle navigation systems and online driving
    direction websites. Python has two excellent geocoder libraries available named
    `geocoder` and `geopy`. Both take advantage of online geocoding services to allow
    you to geocode addresses programmatically. The geopy library even lets you reverse
    geocode to match a latitude and longitude to the nearest address:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 地理编码是将街道地址转换为纬度和经度的过程。这个操作对于车载导航系统和在线驾驶方向网站至关重要。Python有两个优秀的地理编码库，名为`geocoder`和`geopy`。这两个库都利用在线地理编码服务，允许你以编程方式地理编码地址。geopy库甚至允许你进行反向地理编码，将纬度和经度匹配到最近的地址：
- en: 'First, let''s do a quick example with the `geocoder` library, which defaults
    to using Google Maps as its engine:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们用一个简单的例子来演示`geocoder`库，它默认使用谷歌地图作为其引擎：
- en: '[PRE93]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we print the GeoJSON record for that address, which contains all known
    information in Google's database. Then, we print out the returned latitude and
    longitude as a WKT string, which could be used as input to other operations such
    as checking whether the address is inside of a flood plain polygon. The documentation
    for this library also shows you how to switch to other online geocoding services
    such as Bing or Yahoo. Some of these services require an API key and may have
    request limits.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打印出该地址的GeoJSON记录，其中包含谷歌数据库中所有已知信息。然后，我们以WKT字符串的形式打印出返回的纬度和经度，这可以用作其他操作的输入，例如检查地址是否位于洪水平原多边形内。该库的文档还展示了如何切换到其他在线地理编码服务，如Bing或Yahoo。其中一些服务需要API密钥，并且可能有请求限制。
- en: 'Now, let''s look at the `geopy` library. In this example, we''ll geocode against
    the `OpenStreetMap` database. Once we match the address to a location, we''ll
    turn around and reverse geocode it:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看`geopy`库。在这个例子中，我们将使用`OpenStreetMap`数据库进行地理编码。一旦我们将地址匹配到位置，我们将反过来进行反向地理编码：
- en: '[PRE94]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now that we know of several different ways to geocode, let's look at speeding
    up the process. If you have thousands of addresses to geocode, it can take a while.
    Using multiprocessing, you can reduce a geocoding process that might take days
    into a few hours.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了多种不同的地理编码方法，让我们看看如何加快这个过程。如果你有数千个地址需要地理编码，这可能需要一段时间。使用多进程，你可以将可能需要几天的时间缩短到几个小时。
- en: Multiprocessing
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多进程
- en: Geospatial datasets are very large. Processing them can take time, which can
    be hours or sometimes even days. But there's a way you can speed processing up
    for certain operations. Python's built-in multiprocessing module can spawn multiple
    processes on your computer to take advantage of all of the available processors.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间数据集非常大。处理它们可能需要时间，这可能需要数小时，有时甚至需要数天。但有一种方法可以加快某些操作的处理速度。Python 内置的 multiprocessing
    模块可以在您的计算机上生成多个进程，以利用所有可用的处理器。
- en: 'One operation that works really well with the multiprocessing module is geocoding.
    In this example, we''ll geocode a list of cities and split that processing across
    all of the processors on your machine. We''ll use the same geocoding technique
    as before, but this time, we''ll add the multiprocessing module to increase the
    potential for greater speed and scalability. The following code will geocode a
    list of cities simultaneously across multiple processors:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 与 multiprocessing 模块配合得非常好的操作之一是地理编码。在这个例子中，我们将对城市列表进行地理编码，并将该处理分散到您机器上的所有处理器。我们将使用之前相同的地理编码技术，但这次，我们将添加
    multiprocessing 模块以增加速度和可扩展性的潜力。以下代码将在多个处理器上同时地理编码城市列表：
- en: 'First, we import the modules we need:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的模块：
- en: '[PRE95]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we create our geocoder object:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的地理编码器对象：
- en: '[PRE96]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, we need a function to geocode and individual address:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数来地理编码单个地址：
- en: '[PRE97]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Next, we create our list of cities to process:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建要处理的城市的列表：
- en: '[PRE98]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, we set up our processor pool based on the number of processors available:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们根据可用的处理器数量设置处理器池：
- en: '[PRE99]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, we map our list of cities to the geocode function though the processor
    pool:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将城市列表映射到地理编码函数，通过处理器池进行：
- en: '[PRE100]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, we can print the results:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以打印结果：
- en: '[PRE101]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This technique can be very powerful, but not every type of processing can be
    performed this way. The type of processing  you use has to support operations
    that can be broken apart into discrete calculations. But when you can break problems
    apart, like we did in this example, the results are orders of magnitude faster.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可能非常强大，但并非所有类型的处理都可以以这种方式执行。您使用的处理类型必须支持可以分解为离散计算的运算。但当您可以将问题分解，就像我们在本例中所做的那样，结果将快得多。
- en: Summary
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the critical components of GIS analysis. We examined the
    challenges of measuring on the curved surface of the Earth using different approaches.
    We looked at the basics of coordinate conversion and full reprojection using OGR,
    the `utm` module with PyShp, and Fiona, which simplifies OGR. We edited shapefiles
    and performed spatial and attribute selections. We created thematic maps from
    scratch using only Python. We also imported data from spreadsheets. Then, we parsed
    GPS data from NMEA streams. Finally, we used geocoding to convert street addresses
    into locations and back.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 GIS 分析的关键组件。我们探讨了使用不同方法在地球曲面上测量的挑战。我们研究了坐标转换的基本原理和全重投影，使用了 OGR、PyShp 的
    `utm` 模块和 Fiona，后者简化了 OGR。我们编辑了 shapefile 并执行了空间和属性选择。我们仅使用 Python 从头创建主题地图。我们还从电子表格中导入数据。然后，我们从
    NMEA 流中解析 GPS 数据。最后，我们使用地理编码将街道地址转换为位置，反之亦然。
- en: As a geospatial analyst, you may be familiar with both GIS and remote sensing,
    but most analysts specialize in one field or the other. That is why this book
    approaches the fields in separate chapters – so that we can focus on their differences.
    As we mentioned in the introduction, the techniques in this chapter are the building
    blocks for all geospatial analysis and will give you the tools you need so that
    you can learn about any aspect of this field.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 作为地理空间分析师，您可能熟悉 GIS 和遥感，但大多数分析师专注于一个领域或另一个领域。这就是为什么本书将这两个领域分开成单独的章节——这样我们就可以专注于它们之间的差异。正如我们在引言中提到的，本章的技术是所有地理空间分析的基础，并将为您提供学习该领域任何方面的工具。
- en: In [Chapter 6](13990656-5786-445c-878b-8b262ad6f3c0.xhtml), *Python and Remote
    Sensing*, we'll tackle remote sensing. In GIS, we have been able to explore this
    field using pure Python modules. In remote sensing, we'll become more dependent
    on bindings to compiled modules written in C due to the sheer size and complexity
    of the data.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](13990656-5786-445c-878b-8b262ad6f3c0.xhtml) *Python 和遥感* 中，我们将探讨遥感。在
    GIS 中，我们已经能够使用纯 Python 模块来探索这个领域。在遥感中，由于数据的大小和复杂性，我们将更多地依赖于用 C 编写的编译模块的绑定。
