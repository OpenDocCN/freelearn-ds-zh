- en: Chapter 5. Creating Dynamic Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the map canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the map units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolizing a vector layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a single band raster using a color ramp algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a complex vector layer symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using icons as vector layer symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a graduated vector layer symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a categorized vector layer symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a map bookmark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to a map bookmark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting scale-based visibility for a layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SVG for layer symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pie charts for symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the OpenStreetMap service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Bing aerial image service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding real-time weather data from OpenWeatherMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labeling a feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing map layer transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding standard map tools to the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a map tool to draw points on the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a map tool to draw polygons or lines on the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom selection tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a mouse coordinate tracking tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll programmatically create dynamic maps using Python to
    control every aspect of the QGIS map canvas. We'll learn how to use custom symbology,
    labels, map bookmarks, and even real-time data. We'll also go beyond the canvas
    to create custom map tools. You will see that every aspect of QGIS is up for grabs
    with Python, to write your own application. Sometimes, the PyQGIS API may not
    directly support your application goal, but there is nearly always a way to accomplish
    what you set out to do with QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the map canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maps in QGIS are controlled through the map canvas. In this recipe, we'll access
    the canvas and then check one of its properties to ensure that we have control
    over the object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only thing you need to do for this recipe is to open QGIS and select **Python
    Console** from the **Plugins** menu.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will assign the map canvas to a variable named `canvas`. Then, we''ll check
    the `size` property of the canvas to get its size in pixels. To do this, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following line in the QGIS **Python Console**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to ensure that we have properly accessed the canvas, check its size in
    pixels using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that QGIS returns a `QSize` object that contains the canvas''s pixel
    size, similar to the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything in QGIS centers on the canvas. The canvas is part of the QGIS interface
    or iface API. Anything you see on the screen when using QGIS is generated through
    the iface API. Note that the `iface` object is only available to scripts and plugins.
    When you are building a standalone application, you must initialize your own `QgsMapCanvas`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the map units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Changing the units of measurement on a map, or map units, is a very common operation,
    depending on the purpose of your map or the standards of your organization or
    country. In this recipe, we'll read the map units used by QGIS and then change
    them for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only preparation you need for this recipe is to open QGIS and select **Python
    Console** from the **Plugins** menu.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following steps, we'll access the map canvas, check the map unit type,
    and then alter it to a different setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, access the map canvas, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, get the map units type. By default, it should be the number **2**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s set the map units to meters using the built-in enumerator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'QGIS has seven different map units, which are enumerated in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 Meters
  prefs: []
  type: TYPE_NORMAL
- en: 1 Feet
  prefs: []
  type: TYPE_NORMAL
- en: 2 Degrees
  prefs: []
  type: TYPE_NORMAL
- en: 3 UnknownUnit
  prefs: []
  type: TYPE_NORMAL
- en: 4 DecimalDegrees
  prefs: []
  type: TYPE_NORMAL
- en: 5 DegreesMinutesSeconds
  prefs: []
  type: TYPE_NORMAL
- en: 6 DegreesDecimalMinutes
  prefs: []
  type: TYPE_NORMAL
- en: 7 NauticalMiles
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that changing the map units just changes the unit of
    measurement for the measurement tool and the display in the status bar; it does
    not change the underlying map projection. You'll notice this difference if you
    try to run an operation in the Processing Toolbox, which depends on projected
    data in meters, if the data is unprojected. The most common use case for changing
    map units is to switch between imperial and metric units, depending on the user's
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many GIS operations, you need to loop through the map layers to look for
    specific information or to apply a change to all the layers. In this recipe, we'll
    loop through the layers and get information about them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need two layers in the same map projection to perform this recipe. You
    can download the first layer as a ZIP file from [https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the second zipped layer from [https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip both of these layers into a directory named `ms` within your `qgis_data`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add the layers to the map through the map registry. Then, we will iterate
    through the map layers and print each layer''s title. To do this, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s open the polygon and the point layer using the QGIS **Python
    Console**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, get the map layer registry instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the vector layers to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we retrieve the layers as an interator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we loop through the layers and print the titles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that you can read the layer titles in the **Python Console**, similar
    to the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layers in QGIS are independent of the map canvas until you add them to the map
    layer registry. They have an ID as soon as they are created. When added to the
    map, they become part of the canvas, where they pick up titles, symbols, and many
    other attributes. In this case, you can use the map layer registry to iterate
    through them and access them to change the way they look or to add and extract
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolizing a vector layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The appearance of the layers on a QGIS map is controlled by its symbology. A
    layer's symbology includes the renderer and one or more symbols. The renderer
    provides rules dictating the appearance of symbols. The symbols describe properties,
    including color, shape, size, and linewidth. In this recipe, we'll load a vector
    layer, change its symbology, and refresh the map.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the following zipped shapefile and extract it to your `qgis_data` directory
    into a folder named `ms` from [https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load a layer, add it to the map layer registry, change the layer''s
    color, and then refresh the map. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, using the QGIS **Python Console**, we must import the `QtGui` library
    in order to access the `QColor` object that is used to describe colors in the
    PyQGIS API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create our vector layer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add it to the map layer registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we access the layer''s symbol list through the layer''s renderer object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we reference the first symbol, which in this case is the only symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have the symbol, we can set its color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must remember to repaint the layer in order to force the update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changing the color of a layer sounds simple, but remember that in QGIS, anything
    you see must be altered through the canvas API. Therefore, we add the layer to
    the map and access the layer's symbology through its renderer. The map canvas
    is rendered as a raster image. The renderer is responsible for turning the layer
    data into a bitmap image, so the presentation information for a layer is stored
    with its renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a single band raster using a color ramp algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A color ramp allows you to render a raster using just a few colors to represent
    different ranges of cell values that have similar meaning, in order to group them.
    The approach that will be used in this recipe is the most common way to render
    elevation data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download a sample DEM from [https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip),
    which you can unzip in a directory named `rasters` in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following steps, we will set up objects to color a raster, create a
    list establishing the color ramp ranges, apply the ramp to the layer renderer,
    and finally add the layer to the map. To do this, we need to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the `QtGui` library for color objects in the QGIS **Python
    Console**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we load the raster layer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a generic raster shader object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we instantiate the specialized ramp shader object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must name a type for the ramp shader. In this case, we use an `INTERPOLATED`
    shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll create a list of our color ramp definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we populate the list with color ramp values that correspond to elevation
    value ranges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we assign the color ramp to our shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we tell the generic raster shader to use the color ramp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a raster renderer object with the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We assign the renderer to the raster layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the layer to the canvas in order to view it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it takes a stack of four objects to create a color ramp, this recipe demonstrates
    how flexible the PyQGIS API is. Typically, the more objects it takes to accomplish
    an operation in QGIS, the richer the API is, giving you the flexibility to make
    complex maps.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in each `ColorRampItem` object, you specify a starting elevation
    value, the color, and a label as the string. The range for the color ramp ends
    at any value less than the following item. So, in this case, the first color will
    be assigned to the cells with a value between 400 and 899\. The following screenshot
    shows the applied color ramp.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a complex vector layer symbol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The true power of QGIS symbology lies in its ability to stack multiple symbols
    in order to create a single complex symbol. This ability makes it possible to
    create virtually any type of map symbol you can imagine. In this recipe, we'll
    merge two symbols to create a single symbol and begin unlocking the potential
    of complex symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will need a line shapefile, which you can download and extract
    from [https://geospatialpython.googlecode.com/svn/paths.zip](https://geospatialpython.googlecode.com/svn/paths.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Add this shapefile to a directory named `shapes` in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the **QGISPythonConsole**,we will create a classic railroad line symbol
    by placing a series of short, rotated line markers along a regular line symbol.
    To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load our line shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we get the symbol list and reference the default symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a shorter variable name for the symbol layer registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we set up the line style for a simple line using a Python dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create an abstract symbol layer for a simple line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We instantiate a symbol layer from the abstract layer using the line style
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add the symbol layer to the layer''s symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in order to create the rails on the railroad, we begin building a marker
    line style with another Python dictionary, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create the marker line abstract symbol layer for the second symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We instatiate the symbol layer, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must work with a subsymbol that defines the markers along the marker
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must delete the default subsymbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we set up the style for our rail marker using a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we repeat the process of building a symbol layer and add it to the subsymbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add the subsymbol to the second symbol layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we must create a simple line symbol. The marker line by itself will render
    correctly, but the underlying simple line will be a randomly chosen color. We
    must also change the subsymbol of the marker line because the default subsymbol
    is a simple circle.
  prefs: []
  type: TYPE_NORMAL
- en: Using icons as vector layer symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the default symbol types available in QGIS, you can also use
    TrueType fonts as map symbols. TrueType fonts are scalable vector graphics that
    can be used as point markers. In this recipe, we'll create this type of symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the point shapefile used in this recipe from [https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Extract it to your `qgis_data` directory in a folder named `nyc`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load a point shapefile as a layer and then use the character `G` in
    a freely-available font called `Webdings`, which is probably already on your system,
    to render a building icon on each point in the layer. To do this, we need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define the path to our point shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll load the vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll use a Python dictionary to define the font properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll create a font symbol layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll change the default symbol layer of the vector layer to our font''s
    symbol information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll add the layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The font marker symbol layer is just another type of marker layer; however,
    the range of possibilities with vector fonts is far broader than the built-in
    fonts in QGIS. Many industries define standard cartographic symbols using customized
    fonts as markers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a graduated vector layer symbol renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A graduated vector layer symbol renderer is the vector equivalent of a raster
    color ramp. You can group features into similar ranges and use a limited set of
    colors to visually identify these ranges. In this recipe, we'll render a graduated
    symbol using a polygon shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download a shapefile containing a set of urban area polygons from [https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Extract this file to a directory named `ms` in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will classify each urban area by population size using a graduated symbol,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the `QColor` object to build our color range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we load our polygon shapefile as a vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we build some nested Python tuples that define the symbol graduation.
    Each item in the tuple contains a range label, range start value, range end value,
    and a color name, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we establish a Python list to hold our QGIS renderer objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we loop through our range list, build the QGIS symbols, and add them
    to the renderer list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, reference the field name containing the population values in the shapefile
    attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create the renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We assign the renderer to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the map to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach to using a graduated symbol for a vector layer is very similar
    to the color ramp shader for a raster layer. You can have as many ranges as you'd
    like by extending the Python tuple that is used to build the ranges. Of course,
    you can also build your own algorithms by programmatically examining the data
    fields first and then dividing up the values in equal intervals or some other
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a categorized vector layer symbol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A categorized vector layer symbol allows you to create distinct categories with
    colors and labels for unique features. This approach is typically used for datasets
    with a limited number of unique types of features. In this recipe, we'll categorize
    a vector layer into three different categories.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll use a land use shapefile, which you can download from
    [https://geospatialpython.googlecode.com/svn/landuse_shp.zip](https://geospatialpython.googlecode.com/svn/landuse_shp.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Extract it to a directory named `hancock` in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the vector layer, create three categories of land use, and render
    them as categorized symbols. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the `QColor` object for our category colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we load the vector layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create our three land use categories using a Python dictionary
    with a field value as the key, color name, and label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can build our categorized renderer items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We name the field containing the land use value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we build the renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add the renderer to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the categorized layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are only slight differences in the configurations of the various types
    of renderers in QGIS. Setting them up by first defining the properties of the
    renderer using native Python objects makes your code easier to read and ultimately
    manage. The following map image illustrates the categorized symbol in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a map bookmark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Map bookmarks allow you to save a location on a map in QGIS, so you can quickly
    jump to the points you need to view repeatedly without manually panning and zooming
    the map. PyQGIS does not contain API commands to read, write, and zoom to bookmarks.
    Fortunately, QGIS stores the bookmarks in an SQLite database. Python has a built-in
    SQLite library that we can use to manipulate bookmarks using the database API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download a census tract polygon shapefile to use with this recipe from
    [https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Extract it to your `qgis_data` directory. We are going to create a bookmark
    that uses an area of interest within this shapefile, so you can manually load
    the bookmark in order to test it out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will access the QGIS configuration variables to get the path of the user
    database, which stores the bookmarks. Then, we''ll connect to this database and
    execute a SQL query that inserts a bookmark. Finally, we''ll commit the changes
    to the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, using the QGIS **PythonConsole**, we must import Python''s built-in
    SQLite library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, get the path to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we connect to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need a database cursor to manipulate the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can execute the SQL query, which is a string. In the `VALUES` portion
    of the query, we will leave the bookmark ID as `NULL` but give it a name, then
    we leave the project name `NULL` and set the extents, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we commit the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To test the map bookmark, load the census tract layer onto the map by dragging
    and dropping it from your filesystem into QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **View** menu in QGIS and select **ShowBookmarks**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select the **BSL bookmark** and click on the **ZoomTo** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the map snapped to an area of interest close to the polygons, with
    OBJECTIDs from 4625 to 4627.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even when QGIS doesn't provide a high-level API, you can almost always use Python
    to dig deeper and access the information you want. QGIS is built on open source
    software, therefore no part of the program is truly off-limits.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to a map bookmark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Map bookmarks store important locations on a map, so you can quickly find them
    later. You can programmatically navigate to bookmarks using the Python `sqlite3`
    library in order to access the bookmarks database table in the QGIS user database
    and then use the PyQGIS canvas API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use a census tract layer to test out the bookmark navigation. You can
    download the zipped shapefile from [https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Manually load this layer into QGIS after extracting it from the ZIP file. Also,
    make sure that you have completed the previous recipe, *Creating a map bookmark*.
    You will need a bookmark named BSL for an area of interest in this shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will retrieve a bookmark from the QGIS user database and then set the map''s
    extents to this bookmark. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the Python `sqlite3` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, get the location of the user database from the QGIS data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we connect to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need a database cursor to run queries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can get the bookmark information for the bookmark named **BSL**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll get the complete results from the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we split the values of the result into multiple variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the bookmark to create a QGIS extent rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we reference the map canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we set the extent of the canvas to the rectangle and then refresh
    the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading and writing bookmarks with SQLite is straightforward even though its
    not a part of the main PyQGIS API. Notice that bookmarks have a placeholder for
    a project name, which you can use to filter bookmarks by project if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting scale-based visibility for a layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a GIS layer only makes sense when it is displayed at a certain scale,
    for example, a complex road network. PyQGIS supports scale-based visibility to
    programmatically set the scale range, in which a layer is displayed. In this recipe,
    we'll investigate scale-dependent layers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need the sample census tract shapefile available as a ZIP file from
    [https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Extract the zipped layer to a directory named `census` in your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the vector layer, toggle scale-based visibility, set the visibility
    range, and then add the layer to the map. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we toggle scale-based visibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set the minimum and maximum map scales at which the layer is visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add the layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, manually zoom in and out of the map to ensure that the layer disappears
    and reappears at the proper scales.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The map scale is a ratio of map units to physical map size, expressed as a floating-point
    number. You must remember to toggle scale-dependent visibility so that QGIS knows
    that it needs to check the range each time the map scale changes.
  prefs: []
  type: TYPE_NORMAL
- en: Using SVG for layer symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scalable Vector Graphics** (**SVG)** are an XML standard that defines vector
    graphics that can be scaled at any resolution. QGIS can use SVG files as markers
    for points. In this recipe, we''ll use Python to apply one of the SVG symbols
    included with QGIS to a point layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, download the following zipped point shapefile layer from [https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Extract it to your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following steps, we''ll load the vector layer, build a symbol layer
    and renderer, and add it to the layer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define the path to the shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll load the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define the properties of the symbol, including the location of the
    SVG file as a Python dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create an SVG symbol layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we change the layer renderer''s default symbol layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the layer to the map in order to view the SVG symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default SVG layers are stored in the QGIS application directory. There
    are numerous graphics available that cover many common uses. You can also add
    your own graphics as well. The following map image shows the recipe''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using pie charts for symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QGIS has the ability to use dynamic pie charts as symbols describing the statistics
    in a given region. In this recipe, we'll use pie chart symbols on a polygon layer
    in QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, download the following zipped shapefile and extract it to a
    directory named `ms` in your `qgis_data` directory from [https://geospatialpython.googlecode.com/svn/County10PopnHou.zip](https://geospatialpython.googlecode.com/svn/County10PopnHou.zip).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with other renderers, we will build a symbol layer, add it to a renderer,
    and display the layer on the map. The pie chart diagram renderers are more complex
    than other renderers but have many more options. Perform the following steps to
    create a pie chart map:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the PyQt GUI library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we load the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set up categories based on attribute names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we set up a list of corresponding colors for each category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we convert the hex color values to `QColor` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we reference the map canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a pie diagram object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a diagram settings object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define all the diagram settings that will be used for the renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create our diagram renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must set a few size parameters for our diagrams:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can add our diagram to the renderer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add the renderer to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we apply some additional placement settings at the layer level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In QGIS 2.6, the diagram renderer is tied to the new PAL labeling engine, so
    we need to activate this engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we delete any cached images that are rendered and force the layer to
    repaint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add our diagram layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basics of pie chart diagram symbols are straightforward and work in a similar
    way to other types of symbols and renderers. However, it gets a little confusing
    as we need to apply settings at three different levels – the diagram level, the
    render level, and the layer level. It turns out they are actually quite complex.
    Most of the settings are poorly documented, if at all. Fortunately, most of them
    are self-explanatory. The following screenshot shows an example of the completed
    pie chart diagram map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about what is possible with pie chart diagram symbols, you can
    experiment with this recipe in the Script Runner plugin, where you can change
    or remove settings and quickly re-render the map. You can also manually change
    the settings using the QGIS dialogs and then export the style to an XML file and
    see what settings are used. Most of them map to the Python API well.
  prefs: []
  type: TYPE_NORMAL
- en: Using the OpenStreetMap service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud-based technology is moving more and more data to the Internet, and GIS
    is no exception. QGIS can load web-based data using Open GIS Consortium standards,
    such as **Web Map Service (WMS).** The easiest way to add WMS layers is using
    the **Geospatial Data Abstraction Library (GDAL**) and its virtual filesystem
    feature to load a tiled layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't need to do any preparation for this recipe, other than opening the
    Python console plugin within QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an XML template that describes the tiled web service from OpenStreetMap
    we want to import. Then, we''ll turn it into a GDAL virtual file and load it as
    a QGIS raster layer. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the GDAL library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create our XML template, describing the OpenStreetMap tiled web
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll create the path for our GDAL virtual filesystem''s file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we use GDAL to create the virtual file using the path and the XML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create a raster layer from the virtual file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we add the layer to the map, we''ll make sure that it''s valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other ways to load tiled map services such as OpenStreetMap into QGIS
    programmatically, but GDAL is by far the most robust. The prefix `vsimem` tells
    GDAL to use a virtual file in order to manage the tiles. This approach frees you
    from the need to manage downloaded tiles on disk directly and allows you to focus
    on your application's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Bing aerial image service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are many services that provide street map tiles, there are far fewer
    services that provide imagery services. One excellent free service for both maps
    and, more importantly, imagery is Microsoft's Bing map services. We can access
    Bing imagery programmatically in QGIS using GDAL's WMS capability coupled with
    virtual files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't need to do any preparation for this recipe other than opening the
    Python console plugin within QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the approach used for the previous *Using the OpenStreetMap service*
    recipe, we will create an XML file as a string to describe the service, turn it
    into a GDAL virtual file, and load it as a raster in QGIS. To do this, we need
    to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the GDAL library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create the XML file, describing the Bing service as a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create the virtual file path for the XML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we turn the XML file into a GDAL virtual file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the file as a QGIS raster layer and check its validity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GDAL has drivers for various map services. The service name for Bing is `VirtualEarth`.
    The `${}` clauses in the server URL provide placeholders, which will be replaced
    with instance-specific data when GDAL downloads styles. When using this data,
    you should be aware that it has copyright restrictions. Be sure to read the Bing
    usage agreement online.
  prefs: []
  type: TYPE_NORMAL
- en: Adding real-time weather data from OpenWeatherMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-time data is one of the most exciting data types you can add to a modern
    map. Most data producers make data available through **Open GIS Consortium** standards.
    One such example is OpenWeatherMap, which offers an OGC **Web Map Service (WMS**)
    for different real-time weather data layers. In this recipe, we'll access this
    service to access a real-time weather data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, you just need to open the QGIS **Python Console**
    by clicking on the **Plugins** menu and selecting **Python Console**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add a WMS weather data layer for precipitation to a QGIS map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we specify the parameters for the `service`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create the raster layer, specifying `wms` as the type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the precipitation layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A WMS request is typically an HTTP `GET` request with all of the parameters
    as part of the URL. In PyQGIS, you use a URL-encoded format and specify the parameters
    separately from the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following map image shows the output of the precipitation layer in QGIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Labeling features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once your map layers are styled, the next step to creating a complete map is
    labeling features. We'll explore the basics of labeling in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the following zipped shapefile from [https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Extract the shapefile to a directory named `ms` in your `qgis_data` shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will load the point shapefile layer, create a label object, set its properties,
    apply it to the layer, and then add the layer to the map. To do this, we need
    to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to save space, we''ll specify the path to the shapefile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll load the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll create the labeling object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll configure the labels, starting with the current layer settings
    being read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we specify the attribute for the label data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can set the placement and size options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we commit the changes to the layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can add the layer to the map to view the labels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interesting part of labeling is the round-trip read and write process to
    access the layer data and the assignment of the labeling properties. Labeling
    can be quite complex, but this recipe covers the basics needed to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Changing map layer transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Map layer transparency allows you to change the opacity of a layer, so the items
    behind it are visible to some degree. A common technique is to make a vector layer
    polygon partially transparent in order to allow the underlying imagery or elevation
    data to add texture to the data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a directory called `ms`, in your `qgis_data` directory, download and extract
    the following shapefile from
  prefs: []
  type: TYPE_NORMAL
- en: '[https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process is extremely simple. Transparency is just a method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load the shapefile layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set the layer''s transparency to `50` percent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add this layer to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you set the transparency to 100 percent, the layer is completely opaque.
    If you set it to `0,` the layer becomes completely invisible.
  prefs: []
  type: TYPE_NORMAL
- en: Adding standard map tools to the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you'll learn how to add standard map navigation tools to a standalone
    map canvas. Creating the simplest possible interactive application provides a
    framework to begin building specialized geospatial applications using QGIS as
    a library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the following zipped shapefile and extract it to your `qgis_data` directory
    into a folder named `ms` from [https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will walk through the steps required to create a map canvas, add a layer
    to it, and then add some tools to zoom and pan the map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, because we are working outside the QGIS Python interpreter, we need
    to import some QGIS and Qt libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must set the location of our main QGIS application directory. This
    setting is platform-dependent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we begin initializing the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can initialize the application and create the map canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can load the shapefile layer and add it to the canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define the buttons that will be visible on the toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we connect the signal created when the buttons are clicked to the Python
    methods that will provide each tool''s functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create our toolbar and add the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we connect the buttons to the applications states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define which button will be selected when the application loads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define the Python methods that control the application''s behavior
    for each tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a Qt application that uses our application window class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we enter the program''s main loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An application is a continuously running program loop that ends only when we
    quit the application. QGIS is based on the Qt windowing library, so our application
    class inherits from the main window class that provides the canvas and the ability
    to create toolbars and dialogs.This is a lot of setup, even for an extremely simple
    application, but once the framework for an application is complete, it becomes
    much easier to extend it.
  prefs: []
  type: TYPE_NORMAL
- en: Using a map tool to draw points on the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: QGIS contains a built-in functionality to zoom and pan the map in custom applications.
    It also contains the basic hooks to build your own interactive tools. In this
    recipe, we'll create an interactive point tool that lets you mark locations on
    the map by clicking on a point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the application framework from the previous *Adding standard map
    tools to the canvas* recipe, so complete that recipe first. We will extend that
    application with a new tool. The complete version of this application is available
    in the code samples provided with this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will set up the button, signal trigger, and actions as we do with all map
    tools. However, because we are building a new tool, we must also define a class
    to define exactly what the tool does. To do this, we need to perform the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define our point tool''s button in the actions portion of our application.
    Place this line after the `QAction("Pan")` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next section, we make sure that when we click on the button, it stays
    selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the section after that, we define the method that is used when the button
    is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add the button to the toolbar along with the other buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we link the application to our specialized tool class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set the point tool to be selected when the application loads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define the method in the main application class for our tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a class that describes the type of tool we have and the output
    it provides. The output is a point on the canvas, defined in the `canvasPressEvent`
    method, that receives the button-click event. We will inherit from a generic tool
    called the `QgsMapToolEmitPoint` in order to create points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For custom tools, PyQGIS provides a set of generic tools for the common functions
    that you can extend and piece together. In this case, the EmitPoint tool handles
    the details of the events and map functionality when you click on a location on
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: Using a map tool to draw polygons or lines on the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a tool to draw polygons on the canvas. This tool
    is an important tool because it opens the doors to even more advanced tools. Once
    you have a polygon on the canvas, you can do all sorts of operations that involve
    querying and geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the application framework from the *Adding standard map tools to
    the canvas* recipe, so complete that recipe. We will extend that application with
    a new tool. The complete version of this application is available in the code
    samples provided with this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add a new tool to the toolbar and also create a class that describes
    our polygon tool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define our polygon tool''s button in the actions portion of our application.
    Place this line after the `QAction("Pan")` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next section, we make sure that when we click on the button, it stays
    selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the section after that, we define the method used when the button is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add the button to the toolbar along with the other buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we link the application to our specialized tool class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set the point tool to be selected when the application loads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define the method in the main application class for our tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a class that describes the type of tool we have and the output
    it provides. The output is a point on the canvas defined in the `canvasPressEvent`
    method, which receives the button-click event and the `showPoly` method. We will
    inherit from a generic tool in order to create points called the `QgsMapToolEmitPoint`;
    we will also use an object called `QgsRubberBand` for handling polygons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the settings for the polygon are contained in the custom class. There is
    a key property, called **EmittingPoint**, which we use to detect whether we are
    still adding points to the polygon. This value starts out as `false`. If this
    is the case, we reset our polygon object and begin drawing a new one. The following
    screenshot shows a polygon drawn with this tool on a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building a custom selection tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will build a custom tool that both draws a shape on the map
    and interacts with other features on the map. These two basic functions are the
    basis for almost any map tool you would want to build, either in a standalone
    QGIS application like this one, or by extending the QGIS desktop application with
    a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the application framework from the *Adding standard map tools to
    the canvas* recipe, so complete that recipe first. We will extend that application
    with a new tool. The complete version of this application is available in the
    code samples provided with this book. It will also be beneficial to study the
    other two tool-related recipes, *A map tool to draw polygons or lines on the canvas*
    and *A map tool to draw points on the canvas*, as this recipe builds on them as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need the following zipped shapefile from [https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Download and extract it to your `qgis_data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add a new tool to the toolbar and also create a class describing our
    selection tool, including how to draw the selection polygon and how to select
    the features. To do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define our polygon tool''s button in the actions portion of our application.
    Place this line after the `QAction("Pan")` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next section, we make sure that when we click on the button, it stays
    selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the section after that, we define the method used when the button is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add the button to the toolbar along with the other buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we link the application to our specialized tool class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set the point tool to be selected when the application loads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define the method in the main application class for our tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a class that describes the type of tool we have and how it
    works. The output is a point on the canvas defined in the `canvasPressEvent` method,
    which receives the button click-event and the `selectPoly` method. We will inherit
    from a generic tool to create points called the `QgsMapToolEmitPoint`; we will
    also use an object called `QgsRubberBand` to handle polygons. However, we must
    also perform the selection process to highlight the features that fall within
    our selection polygon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'QGIS has a generic tool for highlighting features, but in this case, we can
    use the standard selection functionality, which simplifies our code. With the
    exception of a dialog to load new layers and the ability to show attributes, we
    have a very basic but nearly complete standalone GIS application.The following
    screenshot shows the selection tool in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a mouse coordinate tracking tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll build a tool that tracks and displays the mouse coordinates
    in real time. This tool will also demonstrate how to interact with the status
    bar of a QGIS application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the application framework from the *Adding standard map tools to
    the canvas* recipe, so complete that recipe first. We will extend that application
    with the coordinate tracking tool. A complete version of this application is available
    in the code samples provided with this book. It will also be beneficial to study
    the other two tool-related recipes in this chapter, *A map tool to draw polygons
    or lines on the canvas* and *A map tool to draw points on the canvas*, as this
    recipe builds on them as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will add an event filter to the basic standalone QGIS application and use
    it to grab the current mouse coordinates as well as update the status bar. To
    do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last line of our application''s `__init__` method, insert the following
    line to create a default status bar message when the application loads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately after the application''s `__init__` method, we will add the following
    event filter method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `MainApp` class, as the second-last line, we must install the event
    filter using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Qt framework, in order to watch out for mouse events, we must insert
    an event filter that allows us to monitor all the events in the application. Within
    the default event filter method, we can then process any event we want. In this
    case, we watch for any movements of the mouse.
  prefs: []
  type: TYPE_NORMAL
