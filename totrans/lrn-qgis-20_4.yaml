- en: Chapter 4. Spatial Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start with raster processing and analysis tasks such
    as clipping and terrain analysis. We will cover the essentials of converting between
    raster and vector formats, and then continue with common vector geoprocessing
    tasks such as generating heatmaps and calculating area shares within a region.
    We will finish the chapter with an introduction to automating geoprocessing workflows
    using the QGIS Processing modeler.
  prefs: []
  type: TYPE_NORMAL
- en: Clipping rasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common task in raster processing is clipping a raster with a polygon. This
    task is well covered by the Clipper tool located in **Raster** | **Extraction**
    | **Clipper**. This tool supports clipping to a specified extent or clipping using
    a polygon mask layer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The extent can be set manually or by selecting it in the map. To do that, we
    just drag open a rectangle in the map area of the main QGIS window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mask layer can be any polygon layer that is currently loaded in the project
    or any other polygon layer, which can be specified using **Select…**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If we only want to clip a raster to a certain extent (the current map view extent
    or any other), we can also use the raster **Save as ...**, as shown in [Chapter
    3](ch03.html "Chapter 3. Data Creation and Editing"), *Data Creation and Editing*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a quick exercise, we will clip the hillshade raster using the Alaska Shapefile
    (both from our sample data) as a mask layer. At the bottom of the window, we can
    see the concrete **gdalwarp** command that QGIS uses to clip the raster. This
    is very useful if you also want to learn how to use GDAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default **No data value** is **0**, but we can override it if necessary.
    Another good option is to **Create an output alpha band**, which will set all
    areas outside the mask to transparent, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clipping rasters](img/7488_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The resulting layer will be loaded automatically since we enabled the **Load
    into canvas when finished** option. QGIS should also automatically recognize the
    alpha layer we created, and the raster areas that fall outside the Alaska land
    mass should be transparent. If, for some reason, QGIS fails to automatically recognize
    the alpha layer, we can enable it manually using the **Transparency band** option
    in the raster layer properties'' **Transparency** section. This dialog is also
    the right place to specify any **No data value** we want to be used, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Clipping rasters](img/7488_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Analyzing elevation / terrain data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raster terrain analysis can be used to calculate the slope, aspect, hillshade,
    ruggedness index, and relief from elevation rasters, as shown in the following
    screenshot. These tools are available through the **Raster** | **Terrain analysis**
    plugin, which comes with QGIS by default, but we have to enable it in the Plugin
    Manager.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing elevation / terrain data](img/7488_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Terrain analysis includes the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slope**: This tool calculates the slope angle for each cell in degrees (based
    on the first order derivative estimation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect**: This tool calculates the exposition (in degrees counter-clockwise,
    starting with 0 for north)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hillshade**: This tool creates a basic hillshade raster with lighted areas
    and shadows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relief**: This tool creates a shaded relief map with varying colors for different
    elevation ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ruggedness Index**: This tool calculates the ruggedness index for each cell
    by summarizing the elevation changes within a 3 x 3 cell grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, to use any of these terrain analysis tools, we need an elevation
    raster. If you don't have any at hand, you can simply download a dataset from
    the NASA **Shuttle Radar Topography Mission** (**SRTM**)using [http://dwtkns.com/srtm/](http://dwtkns.com/srtm/)
    or any of the other SRTM download services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to replicate the results in the following exercise exactly, please
    get the dataset called `srtm_05_01.zip`, which covers a small part of Alaska.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important element in all terrain analysis tools is the **Z factor**. The
    z factor is used if the x/y units are different from the z (elevation) unit. For
    example, if we tried to create a relief from elevation data where x/y are in degrees
    and z is in meters, the resulting relief would look grossly exaggerated. The values
    for the z factor are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If x/y and z are either all in meters or all in feet, use the default z factor
    1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If x/y are in degrees and z is in feet, use the z factor 370,400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If x/y are in degrees and z is in meters, use the z factor 111,120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the SRTM rasters are provided in WGS84 EPSG:4326, we need to use a **Z
    factor** of `111120` in our exercise. Let's create a relief! The tool can calculate
    relief color ranges automatically; we just need to click on **Create automatically**,
    as shown in the following screenshot. Of course, we can still edit the elevation
    ranges' upper and lower bounds, as well as the colors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing elevation / terrain data](img/7488_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While relief maps are three-banded rasters, which are primarily used for visualization
    purposes, slope rasters are a common intermediate step in spatial analysis workflows.
    We will now create a slope raster, which we can use in our example workflow through
    the following sections. The resulting slope raster will be loaded in grayscale
    automatically, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing elevation / terrain data](img/7488_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raster calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By going to **Raster** | **Raster Calculator**, we can create a new raster layer
    based on values in one or more rasters that are loaded in the current QGIS project.
    All available raster bands are presented in a list in the top-left corner of the
    dialog in the form `raster_name@band_number` as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing from our previous exercise in which we created a slope raster, we
    can, for example, find areas at elevations above 1,000 meters and with a slope
    of less than 5 degrees using the following expression (you might have to adjust
    the values depending on the dataset you are using):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Cells that meet both criteria of high elevation and evenness will be assigned
    a value of 1 in the resulting raster, while cells that fail to meet a criterion
    will be set to 0\. The only bigger areas with a value of 1 are found in the southern
    part of the raster layer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Raster calculator](img/7488_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another typical use case is reclassifying a raster. For example, we could want
    to reclassify the landcover raster in our sample data so that all areas with a
    landcover class from 1 to 5 get the value 100, areas from 6 to 10 get 101, and
    areas over 11 get a new value of 102\. We will use the following code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding raster calculator expression has three parts, consisting of a
    check and a multiplication. For each cell, only one of the three checks can be
    true, and true is represented as 1\. Therefore, if a landcover cell has a value
    of 4, the first check will be true and the expression evaluates to `1*100 + 0*101
    + 0*102 = 100`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between rasters and vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tools for converting between raster and vector formats are available in **Raster**
    | **Conversion** and are called Rasterize and Polygonize. Like the raster clipper
    tool we used before, this tool is also based on GDAL and displays the command
    at the bottom of the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polygonize converts a raster into a polygon layer; depending on the size of
    the raster, the conversion can take some time. When the process is finished, QGIS
    will notify us with a pop up. For a quick test, we can, for example, convert the
    reclassified landcover raster to polygons. The resulting vector polygon layer
    contains multiple polygon features with a single attribute we called `lc`, which
    depends on the original raster value, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting between rasters and vectors](img/7488_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Rasterize tool is very similar to the Polygonize tool. The only difference
    is that we get to specify the size of the resulting raster in pixels/cells. We
    can also specify the attribute field, which will provide input for the raster
    cell value. The **cat** attribute of our `alaska.shp` dataset is rather meaningless,
    but you get the idea of how the tool works, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting between rasters and vectors](img/7488_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing raster and vector layer statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we get a new dataset, it is useful to examine the layer statistics
    to get a feeling for the data. Raster layer statistics are readily available in
    the **Layer Properties** dialog, specifically in the following tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Metadata** shows the minimum and maximum cell value as well as the mean and
    the standard deviation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Histogram** presents the distribution of raster values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For vector layers, we can get summary statistics using two tools in **Vector**
    | **Analysis Tools**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basics statistics** is very useful for numeric fields. It calculates parameters
    such as mean and median, min and max, the feature count *n* and the number of
    unique values, and so on for all the features of a layer or for the selected features
    only.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List unique values** is useful to get all the unique values of a certain
    field.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In both the tools, we can easily copy the results using *Ctrl* + *C* and paste
    them into a text file or spreadsheet. The following screenshots show examples
    exploring the contents of our airport sample dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing raster and vector layer statistics](img/7488_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a heatmap from points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heatmaps are great for visualizing the distribution of points. To create them,
    QGIS provides a simple to use **Heatmap Plugin** , which we have to activate in
    **Plugin Manager** , and then we can access it by going to **Raster** | **Heatmap**
    | **Heatmap**. The plugin offers different kernel shapes to choose from and allows
    us to control the raster size in cells as well as the cell size. The **Heatmap
    Plugin** looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a heatmap from points](img/7488_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Vector geoprocessing with Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most comprehensive set of spatial analysis tools is accessible via the Processing
    plugin, which we can also enable in **Plugin Manager**. When the plugin is enabled,
    we find an **Analysis** menu where we can activate the toolbox, as shown in the
    following screenshot. In the toolbox, it is easy to find spatial analysis tools
    by their name thanks to the dynamic search box at the top. This makes finding
    tools in the toolbox easier than in the vector or raster menu. Another advantage
    of getting accustomed to the Processing tools is that they can be automated in
    Python and in geoprocessing models.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector geoprocessing with Processing](img/7488_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the preceding screenshot shows the advanced interface of the toolbox.
    You can switch from the simplified interface to the advanced interface using the
    drop-down button at the bottom of the toolbox. I prefer using the advanced version
    as it exposes all available algorithms and clearly displays how individual tools
    are related to the different components such as GDAL/OGR or GRASS.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will cover a selection of the available geoprocessing
    tools and see how we can use the modeler to automate our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying features in the proximity of others
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common spatial analysis task is to identify features in the proximity of
    certain other features. One example would be to find all the airports near rivers.
    Using `airports.shp` and `majrivers.shp` from our sample data, we can find airports
    within 5,000 feet of a river using a combination of the **Fixed distance buffer**
    and **Select by location** tools, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying features in the proximity of others](img/7488_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After buffering the airport point locations, the **Select by location** option
    selects all the airport buffers that intersect a river. As a result, 14 out of
    the 76 airports are selected. This information is displayed in the information
    area at the bottom of the QGIS main window as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying features in the proximity of others](img/7488_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you ever forget which settings you used or need to check that you used the
    correct input layer, you can go to **Analysis** | **history and log**. The **ALGORITHM**
    section lists all the algorithms we have been running as well as the used settings.
    This is also the right place to look for error messages in the **WARNING** section,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying features in the proximity of others](img/7488_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The commands listed under **ALGORITHM** can also be used to call Processing
    tools from the QGIS Python console by going to **Plugins** **|** **Python Console**.
    The Python commands shown in the following screenshot run the buffer algorithm
    and load the result into the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying features in the proximity of others](img/7488_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raster sampling at point locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common task is to sample a raster at specific point locations. Using
    Processing, we can solve this problem using a GRASS tool called v.sample. To use
    GRASS tools, make sure GRASS is installed and Processing is configured correctly
    in **Analysis** | **options and configuration**. On an OSGeo4W default system,
    the configuration will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raster sampling at point locations](img/7488_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this exercise, let's imagine we want to sample the landcover layer at the
    airport locations of our sample data. All we have to do is specify the vector
    layer containing the sample points and the raster layer that should be sampled.
    For this example, we can leave all other settings to their defaults. The tool
    will not only sample the raster, it also compares point attributes with the sampled
    raster value, but we don't need this comparison in our current example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialog will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raster sampling at point locations](img/7488_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mapping density with hexagonal grids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mapping the density of points using a hexagonal grid has become a quite popular
    alternative to creating heatmaps. Processing offers us a fast way to create such
    an analysis. There is already a pre-made script called **Hex grid from layer bounds**,
    which we can use to first create a hexagonal grid that covers all points in the
    input layer. The dataset of populated places, `popp.shp`, is a good sample dataset
    for this exercise. Once the grid is ready, we can run **Count points in polygon**
    to calculate the statistics. In case you cannot see the resulting layer, go to
    the **Layer Properties** | **General** tab and make sure the **CRS** field is
    set to **NAD 27 / Alaska Albers**. The tools dialog will look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping density with hexagonal grids](img/7488_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating area shares within a region
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another spatial analysis task we often encounter is calculating area shares
    within a certain region, for example, landcover shares along one specific river.
    Using `majrivers.shp` and `trees.shp`, we can calculate the share of wooded area
    in a 5,000 feet strip of land along the `Susitna River` value parameter. We first
    define the analysis region by selecting the river and buffering it. Note that
    the **Dissolve result** option should be set to **Yes** to ensure that the buffer
    result is one continuous polygon, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: QGIS Processing will only apply buffers to the selected features of the input
    layer. This default behavior can be changed in **Analysis** | **options and configuration**
    by disabling the **Use only selected features** option.
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating area shares within a region](img/7488_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we calculate the size of the strip of land around our river. This can
    be done using the **Export/Add geometry columns** tool, which adds the area and
    parameter to the attribute table. Then we can calculate the **Intersection** field
    between the area along the river and the wooded areas in `trees.shp`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating area shares within a region](img/7488_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the **Dissolve** tool, we can recombine all areas from the intersection
    results into one big polygon representing the total wooded area around the river.
    Finally, we can calculate the final share of wooded area using **Advanced Python
    field calculator**. The formula `value = $geom.area()/<area>` divides the area
    of the final polygon (`$geom.area()`) by the value in the "area" attribute (`<area>`),
    which we created in a previous step by running **Export/Add geometry columns**.
    The tools will appear as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating area shares within a region](img/7488_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This calculation results in a wood share of 0.31601 for **Deciduous** and 0.09666
    for **Mixed** trees. Therefore, we can conclude that in total, 41.27 percent of
    the land along `Susitna River` is wooded.
  prefs: []
  type: TYPE_NORMAL
- en: Automated geoprocessing with the graphical modeler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the graphical modeler, we can turn whole geoprocessing and analysis workflows
    into automated models. To create a model, we go to **Analysis** | **Graphical
    modeler** to open the modeler where we can select from different **Inputs** and
    **Algorithms** for our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a model that automates the creation of hexagonal heatmaps! By
    double-clicking on the **Vector layer** entry in the **Inputs** list, we can add
    an input field for the point layer. It''s a good idea to use descriptive parameter
    names so we can recognize which input is first and which is later in the model.
    It is also useful to restrict the **Shape type** field where appropriate. In our
    example, we restrict the input to **Point**. This will enable Processing to prefilter
    the available layers and present us only with layers of the correct type. The
    second input we need is a **Number** field to specify the desired hexagonal cell
    size. The tool will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automated geoprocessing with the graphical modeler](img/7488_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After adding the inputs, we can now continue creating the model by assembling
    the algorithms. In the **Algorithms** section, we can use the filter at the top
    to narrow down our search for the correct algorithm. To add an algorithm to the
    model, we simply double-click on the entry in the list of algorithms. This opens
    the algorithm dialog where we have to specify the inputs and further algorithm-specific
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we want to use the point vector layer as the **input** layer,
    and the number input **hex cell size** as the **cellsize** parameter. We can access
    the available inputs through the drop-down list. Alternatively, it's also possible
    to hardcode parameters such as the cell size.
  prefs: []
  type: TYPE_NORMAL
- en: '![Automated geoprocessing with the graphical modeler](img/7488_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While adding the following algorithms, it is important to always choose the
    correct **input** layer based on the previous processing step. We can verify the
    correct workflow using the arrow connections in the model diagram that the **modeler**
    draws automatically. The tool will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automated geoprocessing with the graphical modeler](img/7488_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To finish the model, we should enter a model name (for example, `Create hexagonal
    heatmap`) and a group name (for example, `my models`). Processing will use the
    group name to organize all the models we create. Once we have picked a name and
    group, we can save the model and then run it. After closing the modeler, we can
    run the saved models from the toolbox like any other tool. It is even possible
    to use one model as a building block in another model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful feature is that we can specify a layer style, which should be
    applied to the processing results automatically. This default style can be set
    using **Edit rendering styles for outputs** in the context menu of the created
    model in the toolbox, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automated geoprocessing with the graphical modeler](img/7488_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered various raster and vector geoprocessing and analysis
    tools and how to apply them in common tasks. We saw how to use the Processing
    toolbox to run individual tools as well as the modeler to create complex geoprocessing
    models from multiple tools. Using the modeler, we can automate our workflows and
    increase our productivity, especially with respect to reoccurring tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will learn how to bring all our knowledge together
    to create beautiful maps using advanced styles and map compositioning features.
  prefs: []
  type: TYPE_NORMAL
