<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Working with Strings"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Strings</h1></div></div></div><p>In the previous chapter, you learned many built-in functions in several categories to work with basic objects. You learned how to access object classes, types, and dimensions; how to do logical, math, and basic statistical calculations; and how to perform simple analytic tasks such as root solving. These functions are the building blocks of our solution to specific problems.</p><p>String-related functions are a very important category of functions. They will be introduced in this chapter. In R, texts are stored in character vectors, and a good number of functions and techniques are useful to manipulate and analyze texts. In this chapter, you will learn the basics and useful techniques of working with strings, including the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic manipulation of character vectors</li><li class="listitem" style="list-style-type: disc">Converting between date/time objects and their string representations</li><li class="listitem" style="list-style-type: disc">Using regular expressions to extract information from texts</li></ul></div><div class="section" title="Getting started with strings"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Getting started with strings</h1></div></div></div><p>Character vectors in R are used to store text data. You previously learned that in contrast with many other programming languages, a character vector is not a vector of single characters, letters, or alphabet symbols such as a, b, c. Rather, it is a vector of strings.</p><p>R also provides a variety of built-in functions to deal with character vectors. Many of them also perform vectorized operations so they can process numerous string values in one step.</p><p>In this section, you will learn more about printing, combining, and transforming texts stored in character vectors.</p><div class="section" title="Printing texts"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Printing texts</h2></div></div></div><p>Perhaps the most basic thing we can do with texts is to view them. R provides several ways to view texts in the console.</p><p>The simplest way is to directly type the string in quotation marks:</p><pre class="programlisting">"Hello"&#13;
## [1] "Hello"</pre><p>Like a numeric vector of floating numbers, a character vector is a vector of character values, or strings. <code class="literal">Hello</code> is in the first position and is the only element of the character vector we created earlier.</p><p>We can also print a string value stored in a variable by simply evaluating it:</p><pre class="programlisting">str1 &lt;- "Hello" &#13;
str1&#13;
## [1] "Hello"</pre><p>However, simply writing a character value in a loop does not print it iteratively. It does not print anything at all:</p><pre class="programlisting">for (i in 1:3) {&#13;
  "Hello"&#13;
}</pre><p>That's because R only automatically prints the <span class="emphasis"><em>value</em></span> of an expression as it is being typed in the console. A for loop does not explicitly return a value. This behavior also explains the difference between the printing behaviors when the following two functions are called, respectively:</p><pre class="programlisting">test1 &lt;- function(x) {&#13;
  "Hello"&#13;
  x&#13;
}&#13;
<span class="strong"><strong>test1</strong></span>("World")&#13;
## [1] "World"</pre><p>In the preceding output, <code class="literal">test1</code> does not print <code class="literal">Hello</code>, but it prints <code class="literal">World</code> because <code class="literal">test1("World")</code> returns the value of the last expression <code class="literal">x</code>, which is given as <code class="literal">World</code>, the value of the function call and R automatically prints this value. Let's assume we remove <code class="literal">x</code> from the function as follows:</p><pre class="programlisting">test2 &lt;- function(x) {&#13;
  "Hello" &#13;
}&#13;
<span class="strong"><strong>test2</strong></span>("World")&#13;
## [1] "Hello"</pre><p>Then, <code class="literal">test2</code> always returns <code class="literal">Hello</code>, no matter what value <code class="literal">x</code> takes. As a result, R automatically prints the value of expression <code class="literal">test2("World")</code>, that is, <code class="literal">Hello</code>.</p><p>If we want to explicitly print an object, we should use <code class="literal">print()</code>:</p><pre class="programlisting">print(str1)&#13;
## [1] "Hello"</pre><p>Then, the character vector is printed with a position <code class="literal">[1]</code>. This works in a loop too:</p><pre class="programlisting">for (i in 1:3) {&#13;
  <span class="strong"><strong>print</strong></span>(str1) &#13;
}&#13;
## [1] "Hello" &#13;
## [1] "Hello" &#13;
## [1] "Hello"</pre><p>It also works in a function:</p><pre class="programlisting">test3 &lt;- function(x) {&#13;
<span class="strong"><strong>  print</strong></span>("Hello")&#13;
  x&#13;
}&#13;
<span class="strong"><strong>test3</strong></span>("World")&#13;
## [1] "Hello"&#13;
## [1] "World"</pre><p>In some cases, we want the texts to appear as a message rather than a character vector with indices. In such cases, we can call <code class="literal">cat()</code> or <code class="literal">message()</code>:</p><pre class="programlisting">
<span class="strong"><strong>cat</strong></span>("Hello")&#13;
## Hello</pre><p>We can construct the message in a more flexible way:</p><pre class="programlisting">name &lt;- "Ken"&#13;
language &lt;- "R"&#13;
<span class="strong"><strong>cat</strong></span>("Hello,", name, "- a user of", language)&#13;
## Hello, Ken - a user of R</pre><p>We change the input to print a more formal sentence:</p><pre class="programlisting">
<span class="strong"><strong>cat</strong></span>("Hello, ", name, ", a user of ", language, ".")&#13;
## Hello, Ken , a user of R .</pre><p>It looks like the concatenated string appears to use unnecessary spaces between different arguments. It is because the space character is used by default as the separator between the input strings. We can change it by specifying the <code class="literal">sep=</code> argument. In the following example, we will avoid the default space separator and manually write spaces in the input strings to create a correct version:</p><pre class="programlisting">
<span class="strong"><strong>cat</strong></span>("Hello, ", name, ", a user of ", language, ".", sep = "")&#13;
## Hello, Ken, a user of R.</pre><p>An alternative function is <code class="literal">message()</code>, which is often used in serious situations such as an important event. The output text has a more conspicuous appearance. It is distinct from <code class="literal">cat()</code>, in that, it does not automatically use space separators to concatenate input strings:</p><pre class="programlisting">message("Hello, ", name, ", a user of ", language, ".")&#13;
## Hello, Ken, a user of R.</pre><p>Using <code class="literal">message()</code>, we need to write the separators manually in order to show the same text as earlier.</p><p>Another difference in the behavior between <code class="literal">cat()</code> and <code class="literal">message()</code> is that <code class="literal">message()</code> automatically ends the text with a new line while <code class="literal">cat()</code> does not.</p><p>The following two examples demonstrate the difference. We want to print the same contents but get different results:</p><pre class="programlisting">for (i in 1:3) {&#13;
  cat(letters[[i]]) &#13;
}&#13;
## abc&#13;
for (i in 1:3) {&#13;
  message(letters[[i]]) &#13;
}&#13;
## a&#13;
## b&#13;
## c</pre><p>It is obvious that each time <code class="literal">cat()</code> is called, it prints the input string without a new line appended. The effect is that the three letters show in the same line. By contrast, each time <code class="literal">message()</code> is called, it appends a new line to the input string. As a result, the three letters show in three lines. To print each letter in a new line using <code class="literal">cat()</code>, we need to explicitly add a new line character in the input. The following code prints exactly the same contents as <code class="literal">message()</code> did in the previous example:</p><pre class="programlisting">for (i in 1:3) {&#13;
  cat(letters[[i]], "\n", sep = "") &#13;
}&#13;
## a &#13;
## b &#13;
## c</pre></div><div class="section" title="Concatenating strings"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Concatenating strings</h2></div></div></div><p>In practice, we often need to concatenate several strings to build a new one. The <code class="literal">paste()</code> function is used to concatenate several character vectors together. This function also uses space as the default separator:</p><pre class="programlisting">
<span class="strong"><strong>paste</strong></span>("Hello", "world")&#13;
## [1] "Hello world"&#13;
<span class="strong"><strong>paste</strong></span>("Hello", "world", sep = "-")&#13;
## [1] "Hello-world"</pre><p>If we don't want the separator, we can set <code class="literal">sep=""</code> or alternatively call <code class="literal">paste0()</code>:</p><pre class="programlisting">
<span class="strong"><strong>paste0</strong></span>("Hello", "world")&#13;
## [1] "Helloworld"</pre><p>Maybe you are confused by <code class="literal">paste()</code> and <code class="literal">cat()</code> because they both are capable of concatenating strings. But what's the difference? Although both functions concatenate strings, the difference is that <code class="literal">cat()</code> only prints the string to the console, but <code class="literal">paste()</code> returns the string for further uses. The following code demonstrates that <code class="literal">cat()</code> prints the concatenated string but returns <code class="literal">NULL</code>:</p><pre class="programlisting">value1 &lt;- <span class="strong"><strong>cat</strong></span>("Hello", "world")&#13;
## Hello world&#13;
value1&#13;
## NULL</pre><p>In other words, <code class="literal">cat()</code> only prints strings, but <code class="literal">paste()</code> creates a new character vector.</p><p>The previous examples show the behavior of <code class="literal">paste()</code> working with single-element character vectors. What about working with multi-element ones? Let's see how this is done:</p><pre class="programlisting">
<span class="strong"><strong>paste</strong></span>(<span class="strong"><strong>c</strong></span>("A", "B"), <span class="strong"><strong>c</strong></span>("C", "D"))&#13;
## [1] "A C" "B D"</pre><p>We can see that <code class="literal">paste()</code> works element-wise, that is, <code class="literal">paste("A", "C")</code> first, then <code class="literal">paste("B", "D")</code>, and finally, the results are collected to build a character vector of two elements.</p><p>If we want the results to be put together in one string, we can specify how these two elements are again concatenated by setting <code class="literal">collapse=</code>:</p><pre class="programlisting">
<span class="strong"><strong>paste</strong></span>(<span class="strong"><strong>c</strong></span>("A", "B"), <span class="strong"><strong>c</strong></span>("C", "D"),collapse = ", ")&#13;
## [1] "A C, B D"</pre><p>If we want to put them in two lines, we can set <code class="literal">collapse</code> to be <code class="literal">\n</code> (new line):</p><pre class="programlisting">result &lt;- <span class="strong"><strong>paste</strong></span>(<span class="strong"><strong>c</strong></span>("A", "B"), <span class="strong"><strong>c</strong></span>("C", "D"), collapse = "\n") result&#13;
## [1] "A C\nB D"</pre><p>The new character vector <code class="literal">result</code> is a two-lined string, but the text representation of it is still written in one line. The new line is represented by <code class="literal">\n</code> as we specified. To view the text we created, we need to call <code class="literal">cat()</code>:</p><pre class="programlisting">
<span class="strong"><strong>cat</strong></span>(result)&#13;
## A C ## B D</pre><p>Now, the two-lined string is printed to the console in its intended format. The same thing also works with <code class="literal">paste0()</code>.</p></div><div class="section" title="Transforming texts"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Transforming texts</h2></div></div></div><p>Turning texts into another form is useful in many cases. It is easy to perform a number of basic types of transformation on texts.</p><div class="section" title="Changing cases"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec25"/>Changing cases</h3></div></div></div><p>When we process data with texts, the input may not comply with our standard as supposed. For example, we expect all products to be graded in capital letters, from A to F, but the actual input may consist of these letters in both cases. Changing cases is useful to ensure that the input strings are consistent in cases.</p><p>The <code class="literal">tolower()</code> function changes the texts to lowercase letters, while <code class="literal">toupper()</code> does the opposite:</p><pre class="programlisting">
<span class="strong"><strong>tolower</strong></span>("Hello")&#13;
## [1] "hello"&#13;
<span class="strong"><strong>toupper</strong></span>("Hello")&#13;
## [1] "HELLO"</pre><p>This is particularly useful when a function accepts character input. For example, we can define a function that returns <code class="literal">x + y</code> when type is <code class="literal">add</code> in all possible cases. It returns <code class="literal">x * y</code> when type is <code class="literal">times</code> in all possible cases. The best way to do it is to always convert <code class="literal">type</code> to lowercase or uppercase, no matter what the input value is:</p><pre class="programlisting">calc &lt;- function(type, x, y) {&#13;
  type &lt;- <span class="strong"><strong>tolower</strong></span>(type)&#13;
  if (type == "add") {&#13;
    x + y &#13;
  }else if (type == "times") {&#13;
    x * y&#13;
  } else {&#13;
    stop("Not supported type of command")&#13;
  }&#13;
}&#13;
<span class="strong"><strong>c</strong></span>(<span class="strong"><strong>calc</strong></span>("add", 2, 3), <span class="strong"><strong>calc</strong></span>("Add", 2, 3), calc("TIMES", 2, 3))&#13;
## [1] 5 5 6</pre><p>This gives more tolerance to similar inputs only in different cases so that <code class="literal">type</code> is
case-insensitive.</p><p>In addition, the two functions are vectorized, that is, it changes the cases of each string element of the given character vector:</p><pre class="programlisting">
<span class="strong"><strong>toupper</strong></span>(<span class="strong"><strong>c</strong></span>("Hello", "world"))&#13;
## [1] "HELLO" "WORLD"</pre></div><div class="section" title="Counting characters"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec26"/>Counting characters</h3></div></div></div><p>Another useful function is <code class="literal">nchar()</code>, which simply counts the number of characters of each element of a character vector:</p><pre class="programlisting">
<span class="strong"><strong>nchar</strong></span>("Hello")&#13;
## [1] 5</pre><p>Like <code class="literal">toupper()</code> and <code class="literal">tolower()</code>, <code class="literal">nchar()</code> is also vectorized:</p><pre class="programlisting">
<span class="strong"><strong>nchar</strong></span>(<span class="strong"><strong>c</strong></span>("Hello", "R", "User"))&#13;
## [1] 5 1 4</pre><p>This function is often used to check whether an argument is supplied a valid string. For example, the following function takes some personal information of a student and stores it in the database:</p><pre class="programlisting">store_student &lt;- function(name, age) {&#13;
<span class="strong"><strong>  stopifnot</strong></span>(<span class="strong"><strong>length</strong></span>(name) == 1, <span class="strong"><strong>nchar</strong></span>(name) &gt;= 2,&#13;
<span class="strong"><strong>    is.numeric</strong></span>(age), age &gt; 0) &#13;
  # store the information in the database &#13;
}</pre><p>Before storing the information in the database, the function uses <code class="literal">stopifnot()</code> to check whether <code class="literal">name</code> and <code class="literal">age</code> are provided valid values. If the user does not provide a meaningful name (for example, no less than two letters), the function would stop with an error:</p><pre class="programlisting">
<span class="strong"><strong>store_student</strong></span>("James", 20)&#13;
<span class="strong"><strong>store_student</strong></span>("P", 23)&#13;
## Error: nchar(name) &gt;= 2 is not TRUE</pre><p>Note that <code class="literal">nchar(x) == 0</code> is equivalent to <code class="literal">x == ""</code>. To check against an empty string, both methods work.</p></div><div class="section" title="Trimming leading and trailing whitespaces"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec27"/>Trimming leading and trailing whitespaces</h3></div></div></div><p>In the previous example, we used <code class="literal">nchar()</code> to check whether <code class="literal">name</code> is valid. However, sometimes, the input data comes with useless whitespaces. This adds more noise to the data and requires a careful checking of string arguments. For example, <code class="literal">store_student()</code> in the previous section makes pass of a name such as <code class="literal">" P"</code>, which is as invalid as a straight <code class="literal">"P"</code> argument, but <code class="literal">nchar(" P")</code> returns <code class="literal">3</code>:</p><pre class="programlisting">
<span class="strong"><strong>store_student</strong></span>(" P", 23)</pre><p>To take the possibility into account, we need to refine <code class="literal">store_student</code>. In R 3.2.0, <code class="literal">trimws()</code> is introduced to trim leading and/or trailing whitespaces of given strings:</p><pre class="programlisting">store_student2 &lt;- function(name, age) {&#13;
<span class="strong"><strong>  stopifnot</strong></span>(<span class="strong"><strong>length</strong></span>(name) == 1, <span class="strong"><strong>nchar</strong></span>(<span class="strong"><strong>trimws</strong></span>(name)) &gt;= 2,&#13;
<span class="strong"><strong>    is.numeric</strong></span>(age), age &gt; 0) &#13;
  # store the information in the database &#13;
}</pre><p>Now, the function is more robust to noisy data:</p><pre class="programlisting">
<span class="strong"><strong>store_student2</strong></span>(" P", 23)&#13;
## Error: nchar(trimws(name)) &gt;= 2 is not TRUE</pre><p>The function, by default, trims both the leading and trailing whitespaces, which can be spaces and tabs. You can specify whether "left" or "right" to only trim one side of the strings:</p><pre class="programlisting">
<span class="strong"><strong>trimws</strong></span>(<span class="strong"><strong>c</strong></span>(" Hello", "World "), which = "left")&#13;
## [1] "Hello" "World "</pre></div><div class="section" title="Substring"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec28"/>Substring</h3></div></div></div><p>In previous chapters, you learned how to subset vectors and lists. We can also subset the texts in a character vector by calling <code class="literal">substr()</code>. Suppose we have several dates in the following form:</p><pre class="programlisting">dates &lt;- <span class="strong"><strong>c</strong></span>("Jan 3", "Feb 10", "Nov 15")</pre><p>All the months are represented by three-letter abbreviations. We can use <code class="literal">substr()</code> to extract the months:</p><pre class="programlisting">
<span class="strong"><strong>substr</strong></span>(dates, 1, 3)&#13;
## [1] "Jan" "Feb" "Nov"</pre><p>To extract the day, we need to use <code class="literal">substr()</code> and <code class="literal">nchar()</code> together:</p><pre class="programlisting">
<span class="strong"><strong>substr</strong></span>(dates, 5, <span class="strong"><strong>nchar</strong></span>(dates))&#13;
## [1] "3" "10" "15"</pre><p>Now that we can extract both months and days in the input strings, it is useful to write a function to transform the strings in such format to numeric values to represent the same date. The following function uses many functions and ideas you learned previously:</p><pre class="programlisting">get_month_day &lt;- function(x) {&#13;
  months &lt;- <span class="strong"><strong>vapply</strong></span>(<span class="strong"><strong>substr</strong></span>(<span class="strong"><strong>tolower</strong></span>(x), 1, 3), function(md) { &#13;
    switch(md, jan = 1, feb = 2, mar = 3, apr = 4, may = 5,&#13;
    jun = 6, jul = 7, aug = 8, sep = 9, oct = 10, nov = 11, dec = 12) &#13;
  }, <span class="strong"><strong>numeric</strong></span>(1), USE.NAMES = FALSE) &#13;
  days &lt;- <span class="strong"><strong>as.numeric</strong></span>(<span class="strong"><strong>substr</strong></span>(x, 5,<span class="strong"><strong>nchar</strong></span>(x)))&#13;
<span class="strong"><strong>  data.frame</strong></span>(month = months, day = days) &#13;
}&#13;
<span class="strong"><strong>get_month_day</strong></span>(dates)&#13;
##   month day &#13;
## 1   1    3 &#13;
## 2   2   10 &#13;
## 3  11   15</pre><p>The <code class="literal">substr()</code> function also has a counterpart function to replace the substrings with a given character vector:</p><pre class="programlisting">
<span class="strong"><strong>substr</strong></span>(dates, 1, 3) &lt;- c("Feb", "Dec", "Mar") dates&#13;
## [1] "Feb 3" "Dec 10" "Mar 15"</pre></div><div class="section" title="Splitting texts"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec29"/>Splitting texts</h3></div></div></div><p>In many cases, the lengths of string parts to extract are not fixed. For example, person names such as "Mary Johnson" or "Jack Smiths" have no fixed lengths for the first names and last names. It is more difficult to use <code class="literal">substr()</code>, as you learned in the previous section, to separate and extract both parts. Texts in such format have a regular separator such as space or a comma. To extract the useful parts, we need to split the texts and make each part accessible. The <code class="literal">strsplit()</code> function is used to split texts by specific separators given as a character vector:</p><pre class="programlisting">
<span class="strong"><strong>strsplit</strong></span>("a,bb,ccc", split = ",")&#13;
## [[1]] &#13;
## [1] "a" "bb" "ccc"</pre><p>The function returns a list. Each element in the list is a character vector produced from splitting that element in the original character vector. It is because <code class="literal">strsplit()</code>, like all previous string functions we have introduced, is also vectorized, that is, it returns a list of character vectors as a result of the splitting:</p><pre class="programlisting">students &lt;- <span class="strong"><strong>strsplit</strong></span>(<span class="strong"><strong>c</strong></span>("Tony, 26, Physics", "James, 25, Economics"),&#13;
split = ", ") &#13;
students&#13;
## [[1]] &#13;
## [1] "Tony" "26" "Physics" &#13;
## &#13;
## [[2]] &#13;
## [1] "James" "25" "Economics"</pre><p>The <code class="literal">strsplit()</code> function returns a list of character vectors containing split parts by working element-wise. In practice, splitting is only the first step to extract or reorganize data. To continue, we can use <code class="literal">rbind</code> to put the data into a matrix and give appropriate names to the columns:</p><pre class="programlisting">students_matrix &lt;- do.call(rbind, students)<span class="strong"><strong>colnames</strong></span>(students_matrix) &lt;- c("name", "age", "major")students_matrix&#13;
##       name   age   major 
## [1,] "Tony"  "26"  "Physics" 
## [2,] "James" "25"  "Economics"</pre><p>Then, we will convert the matrix to a data frame so that we can transform each column to more proper types:</p><pre class="programlisting">students_df &lt;- data.frame(students_matrix, stringsAsFactors = FALSE)students_df$age &lt;- as.numeric(students_df$age)students_df&#13;
##   name  age major
## 1 Tony  26  Physics
## 2 James 25  Economics</pre><p>Now, raw string input students are transformed into a more organized and more useful data frame <code class="literal">students_df</code>.</p><p>One small trick to split the whole string into single characters is to use an empty <code class="literal">split</code> argument:</p><pre class="programlisting">
<span class="strong"><strong>strsplit</strong></span>(<span class="strong"><strong>c</strong></span>("hello", "world"), split = "")&#13;
## [[1]] &#13;
## [1] "h" "e" "l" "l" "o" &#13;
## &#13;
## [[2]] &#13;
## [1] "w" "o" "r" "l" "d"</pre><p>In fact, <code class="literal">strsplit()</code> is more powerful than is shown. It also supports <span class="emphasis"><em>regular expressions</em></span>, a very powerful framework to process text data. We will cover this topic in the last section of this chapter.</p></div></div><div class="section" title="Formatting texts"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Formatting texts</h2></div></div></div><p>Concatenating texts with <code class="literal">paste()</code> is sometimes not a good idea because the text has to be broken into pieces and it becomes harder to read as the format gets longer.</p><p>For example, let's assume we need to print each record in <code class="literal">students_df</code> in the following format:</p><pre class="programlisting">#1, name: Tony, age: 26, major: Physics</pre><p>In this case, using <code class="literal">paste()</code> will be a pain:</p><pre class="programlisting">
<span class="strong"><strong>cat</strong></span>(<span class="strong"><strong>paste</strong></span>("#", 1:<span class="strong"><strong>nrow</strong></span>(students_df), ", name: ", students_df$name, ", age: ", students_df$age, ", major: ", students_df$major, sep = ""), sep = "\n")&#13;
## #1, name: Tony, age: 26, major: Physics &#13;
## #2, name: James, age: 25, major: Economics</pre><p>The code looks messy, and it is hard to get the general template at first glance. By contrast, <code class="literal">sprintf()</code> supports a formatting template and solves the problem in a nice way:</p><pre class="programlisting">
<span class="strong"><strong>cat</strong></span>(<span class="strong"><strong>sprintf</strong></span>("#%d, name: %s, age: %d, major: %s", &#13;
  1:<span class="strong"><strong>nrow</strong></span>(students_df), students_df$name, students_df$age, &#13;
students_df$major), sep = "\n")&#13;
#1, name: Tony, age: 26, major: Physics&#13;
## #2, name: James, age: 25, major: Economics</pre><p>In the preceding code, <code class="literal">#%d, name: %s, age: %d, major: %s</code> is the formatting template in which <code class="literal">%d</code> and <code class="literal">%s</code> are placeholders to represent the input arguments to appear in the string. The <code class="literal">sprintf()</code> function is especially easy to use because it prevents the template string from tearing apart, and each part to replace is specified as a function argument. In fact, this function uses C style formatting rules as described in detail at <a class="ulink" href="https://en.wikipedia.org/wiki/Printf_format_string">https://en.wikipedia.org/wiki/Printf_format_string</a>.</p><p>In the preceding example, <code class="literal">%s</code> stands for string and <code class="literal">%d</code> for digits (integers). Moreover, <code class="literal">sprintf()</code> is also very flexible in formatting numeric values using <code class="literal">%f</code>. For example, <code class="literal">%.1f</code> means to round the number to 0.1:</p><pre class="programlisting">
<span class="strong"><strong>sprintf</strong></span>("The length of the line is approximately %.1fmm", 12.295)&#13;
## [1] "The length of the line is approximately 12.3mm"</pre><p>In fact, there is a formatting syntax of different types of values. The following table shows the most commonly used syntax:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Format</strong></span></p>
</td><td>
<p><span class="strong"><strong>Output</strong></span></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%s", "A")</code></p>
</td><td>
<p><code class="literal">A</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%d", 10)</code></p>
</td><td>
<p><code class="literal">10</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%04d", 10)</code></p>
</td><td>
<p><code class="literal">0010</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%f", pi)</code></p>
</td><td>
<p><code class="literal">3.141593</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%.2f", pi)</code></p>
</td><td>
<p><code class="literal">3.14</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%1.0f", pi)</code></p>
</td><td>
<p><code class="literal">3</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%8.2f", pi)</code></p>
</td><td>
<p><code class="literal">3.14</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%08.2f", pi)</code></p>
</td><td>
<p><code class="literal">00003.14</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%+f", pi)</code></p>
</td><td>
<p><code class="literal">+3.141593</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%e", pi)</code></p>
</td><td>
<p><code class="literal">3.141593e+00</code></p>
</td></tr><tr><td>
<p><code class="literal">sprintf("%E", pi)</code></p>
</td><td>
<p><code class="literal">3.141593E+00</code></p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note3"/>Note</h3><p>The official documentation (<a class="ulink" href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/sprintf.html">https://stat.ethz.ch/R-manual/R-devel/library/base/html/sprintf.html</a>) gives a full description of the supported formats.</p></div></div><p>Note that <code class="literal">%</code> in the format text is a special character and will be interpreted as the initial character of a place holder. What if we really mean <code class="literal">%</code> in the string? To avoid formatting interpretation, we need to use <code class="literal">%%</code> to represent a literal <code class="literal">%</code>. The following code is an example:</p><pre class="programlisting">
<span class="strong"><strong>sprintf</strong></span>("The ratio is %d%%", 10)&#13;
## [1] "The ratio is 10%"</pre><div class="section" title="Using Python string functions in R"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec30"/>Using Python string functions in R</h3></div></div></div><p>The <code class="literal">sprintf()</code> function is powerful but not perfect for all use cases. For example, if some parts have to appear multiple times in the template, you will need to write the same arguments multiple times. This often makes the code more redundant and a bit hard to modify:</p><pre class="programlisting">
<span class="strong"><strong>sprintf</strong></span>("%s, %d years old, majors in %s and loves %s.", "James", 25, "Physics", "Physics")&#13;
## [1] "James, 25 years old, majors in Physics and loves Physics."</pre><p>There are other ways to represent the placeholders. The <code class="literal">pystr</code> package provides the <code class="literal">pystr_format()</code> function to format strings in Python formatting style using either numeric or named placeholders. The preceding example can be rewritten with this function in two ways:</p><p>One is using numeric placeholders:</p><pre class="programlisting"># install.packages("pystr")&#13;
<span class="strong"><strong>library</strong></span>(pystr)&#13;
<span class="strong"><strong>pystr_format</strong></span>("{1}, {2} years old, majors in {3} and loves {3}.", "James", 25, "Physics", "Physics")&#13;
## [1] "James, 25 years old, majors in Physics and loves Physics."</pre><p>The other is using named placeholders:</p><pre class="programlisting">
<span class="strong"><strong>pystr_format</strong></span>("{name}, {age} years old, majors in {major} and loves {major}.", &#13;
name = "James", age = 25, major = "Physics")&#13;
## [1] "James, 25 years old, majors in Physics and loves Physics."</pre><p>In both cases, no argument has to repeat, and the position the input appears at can be easily moved to other places in the template string.</p></div></div></div></div>
<div class="section" title="Formatting date/time"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Formatting date/time</h1></div></div></div><p>In data analysis, it is common to encounter date and time data types. Perhaps, the simplest functions related with date are <code class="literal">Sys.Date()</code>, which returns the current date, and <code class="literal">Sys.time()</code>, which returns the current time.</p><p>As the book is being rendered, the date is printed as follows:</p><pre class="programlisting">
<span class="strong"><strong>Sys.Date()&#13;
</strong></span>## [1] "2016-02-26"</pre><p>And the time is:</p><pre class="programlisting">
<span class="strong"><strong>Sys.time()&#13;
</strong></span>## [1] "2016-02-26 22:12:25 CST"</pre><p>From the output, the date and time look like character vectors, but actually they are not:</p><pre class="programlisting">current_date &lt;- Sys.Date()
as.numeric(current_date)&#13;
## [1] 16857&#13;
current_time &lt;- Sys.time()
as.numeric(current_time)&#13;
## [1] 1456495945</pre><p>They are, in essence, numeric values relative to an origin and have special methods to do date/time calculations. For a date, its numeric value means the number of days passed after 1970-01-01. For a time, its numeric value means the number of seconds passed after 1970-01-01 00:00.00 UTC.</p><div class="section" title="Parsing text as date/time"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Parsing text as date/time</h2></div></div></div><p>We can create a date relative to a customized origin:</p><pre class="programlisting">
<span class="strong"><strong>as.Date</strong></span>(1000, "1970-01-01")&#13;
## [1] "1972-09-27"</pre><p>However, in more cases, we create date and time from a standard text representation:</p><pre class="programlisting">my_date &lt;- <span class="strong"><strong>as.Date</strong></span>("2016-02-10") &#13;
my_date&#13;
## [1] "2016-02-10"</pre><p>But if we can represent time in string such as 2016-02-10, then why do we need to create a <code class="literal">Date</code> object like we did earlier? It is because a date has more features: we can do date math with them. Suppose we have a date object, we can add or minus a number of days and get a new date:</p><pre class="programlisting">my_date + 3&#13;
## [1] "2016-02-13"&#13;
my_date + 80&#13;
## [1] "2016-04-30"&#13;
my_date - 65&#13;
## [1] "2015-12-07"</pre><p>We can directly subtract a date from another to get the difference in number of days between two dates:</p><pre class="programlisting">date1 &lt;- <span class="strong"><strong>as.Date</strong></span>("2014-09-28") &#13;
date2 &lt;- <span class="strong"><strong>as.Date</strong></span>("2015-10-20") &#13;
date2 - date1&#13;
## Time difference of 387 days</pre><p>The output of <code class="literal">date2 - date1</code> looks like a message, but it is actually a numeric value. We can make it explicit using <code class="literal">as.numeric()</code>:</p><pre class="programlisting">
<span class="strong"><strong>as.numeric</strong></span>(date2 - date1)&#13;
## [1] 387</pre><p>Time is similar, but there is no function called <code class="literal">as.Time()</code>. To create a date time from a text representation, we can use either <code class="literal">as.POSIXct()</code> or <code class="literal">as.POSIXlt()</code>. These two functions are different implementations of a date/time object under the POSIX standard. In the following example, we use <code class="literal">as.POSIXlt</code> to create a date/time object:</p><pre class="programlisting">my_time &lt;- <span class="strong"><strong>as.POSIXlt</strong></span>("2016-02-10 10:25:31") &#13;
my_time&#13;
## [1] "2016-02-10 10:25:31 CST"</pre><p>This type of object also defines <code class="literal">+</code> and <code class="literal">-</code> for simple time calculations. Unlike the date object, it works at the unit of seconds rather than days:</p><pre class="programlisting">my_time + 10&#13;
## [1] "2016-02-10 10:25:41 CST"&#13;
my_time + 12345&#13;
## [1] "2016-02-10 13:51:16 CST"&#13;
my_time - 1234567&#13;
## [1] "2016-01-27 03:29:24 CST"</pre><p>Given a string representation of date or time in data, we have to convert it to date or date/time objects, which enable us to do calculations. Often, however, what we get in raw data is not always the format that can be directly recognized by <code class="literal">as.Date()</code> or <code class="literal">as.POSIXlt()</code>. In this case, we need to use a set of special letters as placeholders to represent certain parts of a date or time, just like we did with <code class="literal">sprintf()</code>.</p><p>For example, for the input <code class="literal">2015.07.25</code>, <code class="literal">as.Date()</code> will produce an error if no format string is supplied:</p><pre class="programlisting">
<span class="strong"><strong>as.Date</strong></span>("2015.07.25")&#13;
## Error in charToDate(x): character string is not in a standard unambiguous format</pre><p>We can use a format string as a template to tell <code class="literal">as.Date()</code> how to parse the string to a date:</p><pre class="programlisting">
<span class="strong"><strong>as.Date</strong></span>("2015.07.25", format = "%Y.%m.%d")&#13;
## [1] "2015-07-25"</pre><p>Similarly, for a non-standard date/time string, we also need to specify a template string to tell <code class="literal">as.POSIXlt()</code> how to handle it:</p><pre class="programlisting">
<span class="strong"><strong>as.POSIXlt</strong></span>("7/25/2015 09:30:25", format = "%m/%d/%Y %H:%M:%S")&#13;
## [1] "2015-07-25 09:30:25 CST"</pre><p>An alternative (and more direct) function to convert a string to a date/time is <code class="literal">strptime()</code>:</p><pre class="programlisting">
<span class="strong"><strong>strptime</strong></span>("7/25/2015 09:30:25", "%m/%d/%Y %H:%M:%S")&#13;
## [1] "2015-07-25 09:30:25 CST"</pre><p>In fact, <code class="literal">as.POSIXlt()</code> is only a wrapper of <code class="literal">strptime()</code> for character input, but <code class="literal">strptime()</code> always requires that you supply the format string, while <code class="literal">as.POSIXlt()</code> works for standard formats without a supplied template.</p><p>Just like numeric vectors, date and date/time are vectors too. You can supply a character vector to <code class="literal">as.Date()</code> and get a vector of dates:</p><pre class="programlisting">
<span class="strong"><strong>as.Date</strong></span>(<span class="strong"><strong>c</strong></span>("2015-05-01", "2016-02-12"))&#13;
## [1] "2015-05-01" "2016-02-12"</pre><p>The math is also vectorized. In the following code, we will add some consecutive integers to the date, and we get consecutive dates as expected:</p><pre class="programlisting">
<span class="strong"><strong>as.Date</strong></span>("2015-01-01") + 0:2&#13;
## [1] "2015-01-01" "2015-01-02" "2015-01-03"</pre><p>The same feature also applies to date/time objects:</p><pre class="programlisting">
<span class="strong"><strong>strptime</strong></span>("7/25/2015 09:30:25", "%m/%d/%Y %H:%M:%S") + 1:3&#13;
## [1] "2015-07-25 09:30:26 CST" "2015-07-25 09:30:27 CST" ## [3] "2015-07-25 09:30:28 CST"</pre><p>Sometimes, the data uses integer representations of date and time. It makes parsing the date and time trickier. For example, to parse <code class="literal">20150610</code>, we will run the following code:</p><pre class="programlisting">
<span class="strong"><strong>as.Date</strong></span>("20150610", format = "%Y%m%d")&#13;
## [1] "2015-06-10"</pre><p>To parse <code class="literal">20150610093215</code>, we can specify the template to describe such a format:</p><pre class="programlisting">
<span class="strong"><strong>strptime</strong></span>("20150610093215", "%Y%m%d%H%M%S")&#13;
## [1] "2015-06-10 09:32:15 CST"</pre><p>A trickier example is to parse the date/time in the following data frame:</p><pre class="programlisting">datetimes &lt;- data.frame(&#13;
date = c(20150601, 20150603), &#13;
time = c(92325, 150621))</pre><p>If we use <code class="literal">paste0()</code>on the columns of <code class="literal">datetimes</code> and directly call <code class="literal">strptime()</code> with the template used in the previous example, we will get a missing value that indicates that the first element is not consistent with the format:</p><pre class="programlisting">dt_text &lt;- paste0(datetimes$date, datetimes$time)dt_text&#13;
## [1] "2015060192325" "20150603150621"&#13;
strptime(dt_text, "%Y%m%d%H%M%S")&#13;
## [1] NA "2015-06-03 15:06:21 CST"</pre><p>The problem lies in <code class="literal">92325</code>, which should be <code class="literal">092325</code>. We need to use <code class="literal">sprintf()</code> to make sure a leading zero is present when necessary:</p><pre class="programlisting">dt_text2 &lt;- paste0(datetimes$date, sprintf("%06d", datetimes$time))dt_text2&#13;
## [1] "20150601092325" "20150603150621"&#13;
strptime(dt_text2, "%Y%m%d%H%M%S")&#13;
## [1] "2015-06-01 09:23:25 CST" "2015-06-03 15:06:21 CST"</pre><p>Finally, the conversion works as supposed.</p></div><div class="section" title="Formatting date/time to strings"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Formatting date/time to strings</h2></div></div></div><p>In the previous section, you learned how to convert strings to date and date/time objects. In this section, you will learn the opposite: converting date and date/time objects back to strings according to a specific template.</p><p>Once a date object is created, every time we print it, it is always represented in the standard format:</p><pre class="programlisting">my_date&#13;
## [1] "2016-02-10"</pre><p>We can convert the date to a string in a standard representation with <code class="literal">as.character()</code>:</p><pre class="programlisting">date_text &lt;- <span class="strong"><strong>as.character</strong></span>(my_date) &#13;
date_text&#13;
## [1] "2016-02-10"</pre><p>From the output, <code class="literal">my_date</code> looks the same, but the string is now merely a plain text and no longer supports date calculations:</p><pre class="programlisting">date_text + 1&#13;
## Error in date_text + 1: non-numeric argument to binary operator</pre><p>Sometimes, we need to format the date in a non-standard way:</p><pre class="programlisting">
<span class="strong"><strong>as.character</strong></span>(my_date, format = "%Y.%m.%d")&#13;
## [1] "2016.02.10"</pre><p>In fact, <code class="literal">as.character()</code> calls <code class="literal">format()</code> directly behind the scenes. We will get exactly the same result using <code class="literal">format()</code>, and this is recommended in most cases:</p><pre class="programlisting">
<span class="strong"><strong>format</strong></span>(my_date, "%Y.%m.%d")&#13;
## [1] "2016.02.10"</pre><p>The same thing also applies to a date/time object. We can further customize the template to include more texts other than the placeholders:</p><pre class="programlisting">my_time&#13;
## [1] "2016-02-10 10:25:31 CST"&#13;
<span class="strong"><strong>format</strong></span>(my_time, "date: %Y-%m-%d, time: %H:%M:%S")&#13;
## [1] "date: 2016-02-10, time: 10:25:31"</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note4"/>Note</h3><p>The format placeholders are much more than we mentioned. Read the documentation by typing in <code class="literal">?strptime</code> for detailed information.</p></div></div><p>There are a number of packages to make dealing with date and time much easier. I recommend the <code class="literal">lubridate</code> package (<a class="ulink" href="https://cran.r-project.org/web/packages/lubridate">https://cran.r-project.org/web/packages/lubridate</a>) because it provides almost all the functions you need to work with date and time objects.</p><p>In the previous sections, you learned a number of basic functions to deal with strings and date/time objects. These functions are useful but much less flexible than regular expressions. You will learn this very powerful technique in the next section.</p></div></div>
<div class="section" title="Using regular expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Using regular expressions</h1></div></div></div><p>For research, you may need to download data from open-access websites or authentication-required databases. These data sources provide data in various formats, and most of the data supplied are very likely well-organized. For example, many economic and financial databases provide data in the CSV format, which is a widely supported text format to represent tabular data. A typical CSV format looks like this:</p><pre class="programlisting">id,name,score &#13;
1,A,20 &#13;
2,B,30 &#13;
3,C,25</pre><p>In R, it is convenient to call <code class="literal">read.csv()</code> to import a CSV file as a data frame with the right header and data types because the format is a natural representation of a data frame.</p><p>However, not all data files are well organized, and dealing with poorly organized data is painstaking. Built-in functions such as <code class="literal">read.table()</code> and <code class="literal">read.csv()</code> work in many situations, but they may not help at all for such format-less data.</p><p>For example, if you need to analyze raw data (<code class="literal">messages.txt</code>) organized in a CSV-like format as shown here, you had better be careful when you call <code class="literal">read.csv()</code>:</p><pre class="programlisting">2014-02-01,09:20:25,James,Ken,Hey, Ken! &#13;
2014-02-01,09:20:29,Ken,James,Hey, how are you? &#13;
2014-02-01,09:20:41,James,Ken, I'm ok, what about you? &#13;
2014-02-01,09:21:03,Ken,James,I'm feeling excited! &#13;
2014-02-01,09:21:26,James,Ken,What happens?</pre><p>Suppose you want to import this file as a data frame in the following format which is nicely organized:</p><pre class="programlisting">      Date      Time     Sender   Receiver   Message &#13;
1  2014-02-01  09:20:25  James    Ken        Hey, Ken! &#13;
2  2014-02-01  09:20:29  Ken      James      Hey, how are you? &#13;
3  2014-02-01  09:20:41  James    Ken        I'm ok, what about you? &#13;
4  2014-02-01  09:21:03  Ken      James      I'm feeling excited! &#13;
5  2014-02-01  09:21:26  James    Ken        What happens?</pre><p>However, if you blindly call <code class="literal">read.csv()</code>, then you will see that it does not work out correctly. This dataset is somehow special in the message column. There are extra commas that will be mistakenly interpreted as separators in a CSV file. Here is the data frame translated from the raw text:</p><pre class="programlisting">
<span class="strong"><strong>read.csv</strong></span>("data/messages.txt", header = FALSE)&#13;
## V1V2V3V4V5V6 &#13;
## 1 2014-02-01 09:20:25 James Ken Hey Ken! &#13;
## 2 2014-02-01 09:20:29 Ken James Hey how are you? &#13;
## 3 2014-02-01 09:20:41 James Ken I'm ok what about you?&#13;
## 4 2014-02-01 09:21:03 Ken James I'm feeling excited! &#13;
## 5 2014-02-01 09:21:26 James Ken What happens?</pre><p>There are various methods to tackle this problem. You may consider using <code class="literal">strsplit()</code> for each line and manually take out the first several elements and paste others for each line split into multiple parts. But one of the simplest and most robust ways is to use the so-called Regular Expression (<a class="ulink" href="https://en.wikipedia.org/wiki/Regular_expression">https://en.wikipedia.org/wiki/Regular_expression</a>). Don't worry if you feel strange about the terminology. Its usage is very simple: describe the pattern that matches the text and extract the desired part from that text.</p><p>Before we apply the technique, we need some basic knowledge. The best way to motivate yourself is look at a simpler problem and consider what is needed to solve the problem.</p><p>Suppose we are dealing with the following text (<code class="literal">fruits.txt</code>) that describes the number or status of some fruits:</p><pre class="programlisting">apple: 20 &#13;
orange: missing &#13;
banana: 30 &#13;
pear: sent to Jerry &#13;
watermelon: 2 &#13;
blueberry: 12 &#13;
strawberry: sent to James</pre><p>Now, we want to pick out all fruits with a number rather than with status information. Although we can easily finish the task visually, it is not that easy for a computer. If the number of lines exceeds two thousand, it can be easy for a computer with the appropriate technique applied and, by contrast, be hard, time-consuming, and error prone for a human.</p><p>The first thing that should come to our mind is that we need to distinguish fruits with numbers and fruits with no numbers. In general, we need to distinguish texts that match a particular pattern from the ones that do not. Here, regular expression is definitely the right technique to work with.</p><p>Regular expressions solve problems using two steps: the first is to find a pattern to match the text and the second is to group the patterns to extract the information in need.</p><div class="section" title="Finding a string pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec95"/>Finding a string pattern</h2></div></div></div><p>To solve the problem, our computer does not have to understand what fruits actually are. We only need to find out a pattern that describes what we want. Literally, we want to get all lines that start with a word followed by a semicolon and a space, and end with an integer rather than words or other symbols.</p><p>Regular expression provides a set of symbols to represent patterns. The preceding pattern can be described with <code class="literal">^\w+:\s\d+$</code> where meta-symbols are used to represent a class of symbols:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">^</code>: This symbol is used at the beginning of the line</li><li class="listitem" style="list-style-type: disc"><code class="literal">\w</code>: This symbol represents a word character</li><li class="listitem" style="list-style-type: disc"><code class="literal">\s</code>: This symbol is a space character</li><li class="listitem" style="list-style-type: disc"><code class="literal">\d</code>: This symbol is a digit character</li><li class="listitem" style="list-style-type: disc"><code class="literal">$</code>: This symbol is used at the end of the line</li></ul></div><p>Moreover, <code class="literal">\w+</code> means one or more word characters, <code class="literal">:</code> is exactly the symbol we expect to see after the word, and <code class="literal">\d+</code> means one or more digit characters. See, this pattern is so magical that it represents all the cases we want and excludes all the cases we don't want.</p><p>More specifically, this pattern matches lines such as <code class="literal">abc: 123</code> but excludes lines otherwise. To pick out the desired cases in R, we use <code class="literal">grep()</code> to get which strings match the pattern:</p><pre class="programlisting">fruits &lt;- <span class="strong"><strong>readLines</strong></span>("data/fruits.txt") fruits&#13;
## [1] "apple: 20" "orange: missing" &#13;
## [3] "banana: 30" "pear: sent to Jerry" &#13;
## [5] "watermelon: 2" "blueberry: 12" &#13;
## [7] "strawberry: sent to James"&#13;
matches &lt;- <span class="strong"><strong>grep</strong></span>("^\\w+:\\s\\d+$", fruits) &#13;
matches&#13;
## [1] 1 3 5 6</pre><p>Note that <code class="literal">\</code> in R should be written as <code class="literal">\\</code> to avoid escaping. Then, we can filter <code class="literal">fruits</code> by <code class="literal">matches</code>:</p><pre class="programlisting">fruits[matches]&#13;
## [1] "apple: 20" "banana: 30" "watermelon: 2" "blueberry: 12"</pre><p>Now, we successfully distinguish desirable lines from undesirable ones. The lines that match the pattern are chosen, and those that do not match the pattern are omitted.</p><p>Note that we specify a pattern that starts with <code class="literal">^</code> and ends with <code class="literal">$</code> because we don't want a partial matching. In fact, regular expressions perform partial matching by default, that is, if any part of the string matches the pattern, the whole string is considered to match the pattern. For example, the following code attempts to find out which strings match the two patterns respectively:</p><pre class="programlisting">grep("\\d", c("abc", "a12", "123", "1"))&#13;
## [1] 2 3 4&#13;
grep("^\\d$", c("abc", "a12", "123", "1"))&#13;
## [1] 4</pre><p>The first pattern matches strings that include any digit (partial matching), while the second pattern with <code class="literal">^</code> and <code class="literal">$</code> matches strings that have only one digit.</p><p>Once the pattern works correctly, we go to the next step: using groups to extract the data.</p></div><div class="section" title="Using groups to extract the data"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec96"/>Using groups to extract the data</h2></div></div></div><p>In the pattern string, we can make marks to identify the parts we want to extract from the texts using parenthesis. In this problem, we can modify the pattern to <code class="literal">(\w+):\s(\d+)</code>, where two groups are marked: one is the fruit name matched by <code class="literal">\w+</code> and the other is the number of the fruit matched by <code class="literal">\d+</code>.</p><p>Now, we can use this modified version of the pattern to extract the information we want. Although it is perfectly possible to use built-in functions in R to do the job, I strongly recommend using functions in the <code class="literal">stringr</code> package. This package makes it substantially easier to use regular expressions. We call <code class="literal">str_match()</code> with the modified pattern with groups:</p><pre class="programlisting">library(stringr)&#13;
matches &lt;- str_match(fruits, "^(\\w+):\\s(\\d+)$")&#13;
matches&#13;
##      [,1]            [,2]         [,3]&#13;
## [1,] "apple: 20"     "apple"      "20"&#13;
## [2,] NA              NA           NA  &#13;
## [3,] "banana: 30"    "banana"     "30"&#13;
## [4,] NA              NA           NA  &#13;
## [5,] "watermelon: 2" "watermelon" "2" &#13;
## [6,] "blueberry: 12" "blueberry"  "12"&#13;
## [7,] NA              NA           NA</pre><p>This time the matches are a matrix with more than one column. The groups in parenthesis are extracted from the text and are put to columns 2 and 3. Now, we can easily transform this character matrix to a data frame with the right header and data types:</p><pre class="programlisting"># transform to data frame
fruits_df &lt;- data.frame(na.omit(matches[, -1]), stringsAsFactors =FALSE)
# add a header
colnames(fruits_df) &lt;- c("fruit","quantity")
# convert type of quantity from character to integer
fruits_df$quantity &lt;- as.integer(fruits_df$quantity)</pre><p>Now, <code class="literal">fruits_df</code> is a data frame with the right header and data types:</p><pre class="programlisting">fruits_df&#13;
##    fruit  quantity
## 1  apple      20
## 2  banana     30
## 3  watermelon  2
## 4  blueberry  12</pre><p>If you are not sure about the intermediate results in the preceding code, you can run the code line by line and see what happens in each step. Finally, this problem is perfectly solved with regular expressions.</p><p>From the previous example, we see that the magic of regular expressions is but a group of identifiers used to represent different kinds of characters and symbols. In addition to the meta-symbols we have mentioned, the following are also useful:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">[0-9]</code>: This symbol represents a single integer from 0 to 9</li><li class="listitem" style="list-style-type: disc"><code class="literal">[a-z]</code>: This symbol represents a single lower capital letter from a to z</li><li class="listitem" style="list-style-type: disc"><code class="literal">[A-Z]</code>: This symbol represents a single upper capital letter from A to Z</li><li class="listitem" style="list-style-type: disc"><code class="literal">.</code>: This symbol represents any single symbol</li><li class="listitem" style="list-style-type: disc"><code class="literal">*</code>: This symbol represents a pattern, which may appear zero, one, or more times</li><li class="listitem" style="list-style-type: disc"><code class="literal">+</code>: This is a pattern, which appears one or more than one time</li><li class="listitem" style="list-style-type: disc"><code class="literal">{n}</code>: This is a pattern that appears <code class="literal">n</code> times</li><li class="listitem" style="list-style-type: disc"><code class="literal">{m,n}</code>: This is a pattern that appears at least <code class="literal">m</code> times and at most <code class="literal">n</code> times</li></ul></div><p>With these meta-symbols, we can easily check or filter string data. For example, suppose we have some telephone numbers from two countries that are mixed together. If the pattern of telephone numbers in one country is different from that of the other, regular expressions can be helpful to split them into two categories:</p><pre class="programlisting">telephone &lt;- <span class="strong"><strong>readLines</strong></span>("data/telephone.txt") &#13;
telephone&#13;
## [1] "123-23451" "1225-3123" "121-45672" "1332-1231" "1212-3212" "123456789"</pre><p>Note that there is an exception in the data. The number has no <code class="literal">-</code> in the middle. For unexceptional cases, it should be easy to figure out the pattern of the two types of telephone numbers:</p><pre class="programlisting">telephone[<span class="strong"><strong>grep</strong></span>("^\\d{3}-\\d{5}$", telephone)]&#13;
## [1] "123-23451" "121-45672"&#13;
telephone[<span class="strong"><strong>grep</strong></span>("^\\d{4}-\\d{4}$", telephone)]&#13;
## [1] "1225-3123" "1332-1231" "1212-3212"</pre><p>To find out the exceptional cases, <code class="literal">grepl()</code> is more useful because it returns a logical vector to indicate whether each element matches the pattern. Therefore, we can use this function to choose all records that do not match the given patterns:</p><pre class="programlisting">telephone[!<span class="strong"><strong>grepl</strong></span>("^\\d{3}-\\d{5}$", telephone) &amp; !<span class="strong"><strong>grepl</strong></span>("^\\d{4}-\\d{4}$", telephone)]&#13;
## [1] "123456789"</pre><p>The preceding code basically says that all records that do not match the two patterns are considered exceptional. Imagine we have millions of records to check. Exceptional cases may be in any format, so it is more robust to use this method: excluding all valid records to find out invalid records.</p></div><div class="section" title="Reading data in customizable ways"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec97"/>Reading data in customizable ways</h2></div></div></div><p>Now, let's go back to the problem we faced at the very beginning of this section. The procedure is exactly the same with the fruits example: finding the pattern and making groups.</p><p>First, let's look at a typical line of the raw data:</p><pre class="programlisting">2014-02-01,09:20:29,Ken,James,Hey, how are you?</pre><p>It is obvious that all lines are based on the same format, that is, date, time, sender, receiver, and message are separated by commas. The only special thing is that commas may appear in the message, but we don't want our code to interpret it as separators.</p><p>Note that regular expressions perfectly works with this purpose as it did in the previous example. To represent one or more symbols that follow the same pattern, just place a plus sign (<code class="literal">+</code>) after the symbolic identifier. For example, <code class="literal">\d+</code> represents a string consisting of one or more digital characters between "0" and "9". For example,"1","23", and"456" all match this pattern, while"word" does not. There are also situations where a pattern may or may not appear at all. Then, we need to place a <code class="literal">*</code> after the symbolic identifier to mark that this particular pattern may appear once or more, or may not appear, in order to match a wide range of texts.</p><p>Now, let's go back to our problem. We need to recognize a sufficiently general pattern of a typical line. The following is the pattern with grouping we should figure out:</p><pre class="programlisting">(\d+-\d+-\d+),(\d+:\d+:\d+),(\w+),(\w+),\s*(.+)</pre><p>Now, we need to import the raw texts in exactly the same way as we did in the fruits example using <code class="literal">readLines()</code>:</p><pre class="programlisting">messages &lt;- <span class="strong"><strong>readLines</strong></span>("data/messages.txt")</pre><p>Then, we need to work out the pattern that represents the text and the information we want to extract from the text:</p><pre class="programlisting">pattern &lt;- "^(\\d+-\\d+-\\d+),(\\d+:\\d+:\\d+),(\\w+),(\\w+),\\s*(.+)$"
matches &lt;- <span class="strong"><strong>str_match</strong></span>(messages, pattern)
messages_df &lt;- <span class="strong"><strong>data.frame</strong></span>(matches[, -1])<span class="strong"><strong>
colnames</strong></span>(messages_df) &lt;- c("Date", "Time", "Sender", "Receiver", "Message")</pre><p>The pattern here looks like some secret code. Don't worry. That's exactly how regular expression works, and it should make some sense now if you go through the previous examples.</p><p>The regular expression works perfectly. The <code class="literal">messages_df</code> file looks like the following structure:</p><pre class="programlisting">messages_df&#13;
##      Date        Time    Sender   Receiver    Message &#13;
## 1 2014-02-01   09:20:25  James    Ken         Hey, Ken! &#13;
## 2 2014-02-01   09:20:29  Ken      James       Hey, how are you? &#13;
## 3 2014-02-01   09:20:41  James    Ken         I'm ok, what about you? &#13;
## 4 2014-02-01   09:21:03  Ken      James       I'm feeling excited! &#13;
## 5 2014-02-01   09:21:26  James    Ken         What happens?</pre><p>The pattern we use is comparable to a key. The hard part of any regular expression application is to find the key. Once we get it, we are able to open the door and extract as much information as we want from the messy texts. Generally speaking, how difficult it is to find that key largely relies on the difference between the positive cases and negative cases. If the difference is quite obvious, a few symbols will solve the problem. If the difference is subtle and many special cases are involved, just like most real-world problems, you need more experience, harder thinking, and many trials and errors to work out the solution.</p><p>Through the motivating examples mentioned earlier, you should now grasp the idea of regular expressions. You don't have to understand how it works internally, but it is very useful to become familiar with the related functions, whether they are built in or provided by certain packages.</p><p>If you want to learn more, RegexOne (<a class="ulink" href="http://regexone.com/">http://regexone.com/</a>) is a very good place to learn the basics in an interactive manner. To learn more specific examples and the full set of identifiers, this website (<a class="ulink" href="http://www.regular-expressions.info/">http://www.regular-expressions.info/</a>) is a good reference. To find out good patterns to solve your problem, you can visit RegExr (<a class="ulink" href="http://www.regexr.com/">http://www.regexr.com/</a>) to test your patterns interactively online.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, you learned about a number of built-in functions for manipulating character vectors and converting between date/time objects and their string representations. You also learned about the basic idea of regular expressions, a very powerful tool to check and filter string data and extract information from raw texts.</p><p>With the vocabulary we built in this and previous chapters, we are now able to work with basic data structures. In the next chapter, you will learn about some tools and techniques to work with data. We will get started with reading and writing simple data files, producing graphics of various types, applying basic statistical analysis and data-mining models on simple datasets, and using numeric methods to solve root-solving and optimization problems.</p></div></body></html>