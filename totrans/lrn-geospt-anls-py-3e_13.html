<html><head></head><body><div><h1 class="header-title">Putting It All Together</h1>
                
            
            
                
<p>Throughout the book, we have touched all the important aspects of geospatial analysis and we've used a variety of different techniques in Python to analyze different types of geospatial data. In this final chapter, we will draw on nearly all of the topics we have covered to produce a real-world product that has become very popular: a GPS route analysis report.</p>
<p>These reports are common to dozens of mobile app services, GPS watches, in-car navigation systems, and other GPS-based tools. A GPS typically records location, time, and elevation. From these values, we can derive a vast amount of ancillary information about what happened along the route on which that data was recorded. Fitness apps including RunKeeper, MapMyRun, Strava, and Nike Plus all use similar reports to present GPS-tracked exercise data from running, hiking, biking, and walking.</p>
<p>We will create one of these reports using Python. This program is nearly 500 lines of code, our longest yet, so we will step through it in pieces. We will combine the following techniques:</p>
<ul>
<li>Understanding a typical GPS report</li>
<li>Building a GPS reporting tool</li>
</ul>
<p>As we step through this program, all of the techniques used will be familiar, but we will be using them in new ways.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>We'll be needing the following things for this chapter:</p>
<ul>
<li>Python 3.6 or higher</li>
<li>RAM: Minimum – 6 GB (Windows), 8 GB (macOS); recommended 8 GB</li>
<li>Storage: Minimum 7200 RPM SATA with 20 GB of available space, recommended SSD with 40 GB of available space</li>
<li class="mce-root">Processor: Minimum Intel Core i3 2.5 GHz, recommended Intel Core i5</li>
<li>PIL: The Python Imaging Library</li>
<li>NumPy: A multidimensional and array-processing library</li>
<li><kbd>pygooglechart</kbd>: A Python wrapper for the excellent Google Chart API</li>
<li>FPDF: A simple and pure-Python PDF writer</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding a typical GPS report</h1>
                
            
            
                
<p>A typical GPS report has common elements including a route map, elevation profile, and speed profile. The following screenshot is a report from a typical route logged through RunKeeper (<a href="https://runkeeper.com/index">https://runkeeper.com/index</a>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c9ab8e4f-557d-4506-acfe-d5d07f510d3a.png" width="701" height="538"/></p>
<p class="mce-root"/>
<p>Our report will be similar, but we'll add a twist. We'll include the route map and elevation profile like this service, but we'll also add the weather conditions that occurred on that route when it was recorded and a geolocated photo taken on route.</p>
<p>Now that we know what a GPS report is, let's learn how to build it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Building a GPS reporting tool</h1>
                
            
            
                
<p>The name of our program is <kbd>GPX-Reporter.py</kbd>. If you remember the <em>Tag and markup-based formats </em>section in <a href="a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml">Chapter 2</a>, <em>Learning Geospatial Data</em>, the <strong>GPX</strong> format is the most common way to store GPS route information. Nearly every program and device relying on GPS data can convert to and from GPX.</p>
<p>For this example, you can download a sample GPX file from: <a href="http://git.io/vl7qi">http://git.io/vl7qi</a>. Also, you will need to install a few Python libraries from PyPI. </p>
<p>You should simply use <kbd>easy_install</kbd> or <kbd>pip</kbd> to install these tools. We will also be using a module called <kbd>SRTM.py</kbd>. This module is a utility for working with near-global elevation data collected during the 11-day <strong>Shuttle Radar Topography Mission</strong> (<strong>SRTM</strong>) in 2000 by the space shuttle Endeavor. Install the SRTM module using <kbd>pip</kbd>:</p>
<pre><strong>pip install srtm.py</strong></pre>
<p>Alternatively, you can also download the zipped file, extract it, and copy the <kbd>srtm</kbd> folder to your Python <kbd>site-packages</kbd> directory or your working directory: <a href="http://git.io/vl5Ls">http://git.io/vl5Ls</a>.</p>
<p>You will also need to register for a free Dark Sky API. This free service provides unique tools. It is the only service that provides global, historical weather data for nearly any point location with up to 1,000 requests per day for free: <a href="https://darksky.net/dev">https://darksky.net/dev</a>.</p>
<p><strong>Dark Sky</strong> will provide you with a text key that you insert into a variable called <kbd>api_key</kbd> in the GPX-Reporter program before running it. Finally, as per Dark Sky's terms of service, you'll need to download a logo image to be inserted into the report: <a href="https://raw.githubusercontent.com/GeospatialPython/Learn/master/darksky.png">https://raw.githubusercontent.com/GeospatialPython/Learn/master/darksky.png</a>.</p>
<p>You can review the Dark Sky <em>Terms of Service</em> here: <a href="https://darksky.net/dev/docs/terms">https://darksky.net/dev/docs/terms</a>.</p>
<p class="mce-root"/>
<p>Now, we're ready to work through the GPX-Reporter program. Like other scripts in this book, this program tries to minimize functions so you can mentally trace the program better and modify it with less effort. The following list contains the major steps in the program: </p>
<ol>
<li>Setting up the Python <kbd>logging</kbd> module</li>
<li>Establishing our helper functions</li>
<li>Parsing the GPX data file</li>
<li>Calculating the route bounding box</li>
<li>Buffering the bounding box</li>
<li>Converting the box to meters</li>
<li>Downloading the basemap</li>
<li>Downloading the elevation data</li>
<li>Hillshading the elevation data</li>
<li>Increasing the hillshade contrast</li>
<li>Blending the hillshade and basemap</li>
<li>Drawing the GPX track on a separate image</li>
<li>Blending the track image and basemap</li>
<li>Drawing the start and finish points</li>
<li>Saving the map image</li>
<li>Calculating the route mile markers</li>
<li>Building the elevation profile chart</li>
<li>Getting the weather data for the route time period</li>
<li>Generating the PDF report</li>
</ol>
<p>The next subsection takes you through the first step.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Initial setup</h1>
                
            
            
                
<p>The beginning of the program is <kbd>import</kbd> statements followed by the Python <kbd>logging</kbd> module. The <kbd>logging</kbd> module provides a more robust way to track and log program status than simple <kbd>print</kbd> statements. In this part of the program, we configure it as shown in the following steps:</p>
<ol>
<li>We first need to install all the libraries we need, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px">from xml.dom import minidom<br/>import json<br/>import urllib.request<br/>import urllib.parse<br/>import urllib.error<br/>import math<br/>import time<br/>import logging<br/>import numpy as np<br/>import srtm # Python 3 version: http://git.io/vl5Ls<br/>import sys<br/>from pygooglechart import SimpleLineChart<br/>from pygooglechart import Axis<br/>import fpdf<br/>import glob<br/>import os<br/>try:<br/> import Image<br/> import ImageFilter<br/> import ImageEnhance<br/> import ImageDraw<br/>except:<br/> from PIL import Image<br/> from PIL import ImageFilter<br/> from PIL import ImageEnhance<br/> from PIL import ImageDraw<br/> from PIL.ExifTags import TAGS</pre>
<ol start="2">
<li>Now we can configure the Python <kbd>logging</kbd> module to tell us what's going on throughout the process, as shown here:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Python logging module.<br/># Provides a more advanced way<br/># to track and log program progress.<br/># Logging level - everything at or below<br/># this level will output. INFO is below.<br/>level = logging.DEBUG<br/># The formatter formats the log message.<br/># In this case we print the local time, logger name, and message<br/>formatter = logging.Formatter("%(asctime)s - %(name)s - %(message)s")<br/># Establish a logging object and name it<br/>log = logging.getLogger("GPX-Reporter")<br/># Configure our logger<br/>log.setLevel(level)<br/># Print to the command line<br/>console = logging.StreamHandler()<br/>console.setLevel(level)<br/>console.setFormatter(formatter)<br/>log.addHandler(console)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This logger prints to the console, but with a few simple modifications you can have it print to a file, or even a database, just by altering the configuration in this section. This module is built into Python and is documented here: <a href="https://docs.python.org/3/howto/logging.html">https://docs.python.org/3/howto/logging.html</a>.</p>
<p class="mce-root">Next, we have several utility functions that are used several times throughout the program.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with utility functions</h1>
                
            
            
                
<p>All of the following functions, except the functions related to time, have been used in previous chapters in some form. Let's see how to use utility functions in our example:</p>
<ol>
<li>First, the <kbd>ll2m()</kbd> function converts latitude and longitude to meters:</li>
</ol>
<pre style="padding-left: 60px">def ll2m(lat, lon):<br/> """Lat/lon to meters"""<br/> x = lon * 20037508.34 / 180.0<br/> y = math.log(math.tan((90.0 + lat) *<br/> math.pi / 360.0)) / (math.pi / 180.0)<br/> y = y * 20037508.34 / 180<br/> return (x, y)</pre>
<ol start="2">
<li>The <kbd>world2pixel()</kbd> function converts geospatial coordinates to pixel coordinates on our output map image:</li>
</ol>
<pre style="padding-left: 60px">def world2pixel(x, y, w, h, bbox):<br/> """Converts world coordinates<br/> to image pixel coordinates"""<br/> # Bounding box of the map<br/> minx, miny, maxx, maxy = bbox<br/> # world x distance<br/> xdist = maxx - minx<br/> # world y distance<br/> ydist = maxy - miny<br/> # scaling factors for x, y<br/> xratio = w/xdist<br/> yratio = h/ydist<br/> # Calculate x, y pixel coordinate<br/> px = w - ((maxx - x) * xratio)<br/> py = (maxy-y) * yratio<br/> return int(px), int(py)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>Then, we have <kbd>get_utc_epoch()</kbd> and <kbd>get_local_time()</kbd> to convert the UTC time stored in the GPX file to local time along the route:</li>
</ol>
<pre style="padding-left: 60px">def get_utc_epoch(timestr):<br/> """Converts a GPX timestamp to Unix epoch seconds<br/> in Greenwich Mean Time to make time math easier"""<br/> # Get time object from ISO time string<br/> utctime = time.strptime(timestr, '%Y-%m-%dT%H:%M:%S.000Z')<br/> # Convert to seconds since epoch<br/> secs = int(time.mktime(utctime))<br/> return secs</pre>
<ol start="4">
<li>Now we have a haversine distance function and our simple <kbd>wms</kbd> function to retrieve map images:</li>
</ol>
<pre style="padding-left: 60px">def haversine(x1, y1, x2, y2):<br/> """Haversine distance formula"""<br/> x_dist = math.radians(x1 - x2)<br/> y_dist = math.radians(y1 - y2)<br/> y1_rad = math.radians(y1)<br/> y2_rad = math.radians(y2)<br/> a = math.sin(y_dist/2)**2 + math.sin(x_dist/2)**2 \<br/> * math.cos(y1_rad) * math.cos(y2_rad)<br/> c = 2 * math.asin(math.sqrt(a))<br/> # Distance in miles. Just use c * 6371<br/> # for kilometers<br/> distance = c * (6371/1.609344) # Miles<br/> return distance</pre>
<ol start="5">
<li>The <kbd>wms()</kbd> function retrieves map images with the following code:</li>
</ol>
<pre style="padding-left: 60px">def wms(minx, miny, maxx, maxy, service, lyr, epsg, style, img, w, h):<br/> """Retrieve a wms map image from<br/> the specified service and saves it as a JPEG."""<br/> wms = service<br/> wms += "?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetMap&amp;"<br/> wms += "LAYERS={}".format(lyr)<br/> wms += "&amp;STYLES={}&amp;".format(style)<br/> wms += "SRS=EPSG:{}&amp;".format(epsg)<br/> wms += "BBOX={},{},{},{}&amp;".format(minx, miny, maxx, maxy)<br/> wms += "WIDTH={}&amp;".format(w)<br/> wms += "HEIGHT={}&amp;".format(h)<br/> wms += "FORMAT=image/jpeg"<br/> wmsmap = urllib.request.urlopen(wms)<br/> with open(img + ".jpg", "wb") as f:<br/>   f.write(wmsmap.read())</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="6">
<li>Next, we have an <kbd>exif()</kbd> function to extract the metadata from the photo:</li>
</ol>
<pre style="padding-left: 60px">def exif(img):<br/> """Return EXIF metatdata from image"""<br/> exif_data = {}<br/> try: <br/> i = Image.open(img)<br/> tags = i._getexif()<br/> for tag, value in tags.items():<br/> decoded = TAGS.get(tag, tag)<br/> exif_data[decoded] = value<br/> except:<br/> pass<br/> return exif_data</pre>
<ol start="7">
<li>Then we have a <kbd>dms2dd()</kbd> function to convert degrees/minutes/seconds coordinates to decimal degrees because that's how the photo coordinates are stored:</li>
</ol>
<pre style="padding-left: 60px">def dms2dd(d, m, s, i):<br/> """Convert degrees/minutes/seconds to<br/> decimal degrees"""<br/> s *= .01<br/> sec = float((m * 60.0) + s)<br/> dec = float(sec / 3600.0)<br/> deg = float(d + dec)<br/> if i.upper() == 'W':<br/> deg = deg * -1.0<br/> elif i.upper() == 'S':<br/> deg = deg * -1.0<br/> return float(deg)</pre>
<ol start="8">
<li>And finally, we have a <kbd>gps()</kbd> function to extract the coordinates from the photo metadata:</li>
</ol>
<pre style="padding-left: 60px">def gps(exif):<br/> """Extract GPS info from EXIF metadat"""<br/> lat = None<br/> lon = None<br/> if exif['GPSInfo']: <br/> # Lat<br/> coords = exif['GPSInfo']<br/> i = coords[1]<br/> d = coords[2][0][0]<br/> m = coords[2][1][0]<br/> s = coords[2][2][0]<br/> lat = dms2dd(d, m ,s, i)<br/> # Lon<br/> i = coords[3]<br/> d = coords[4][0][0]<br/> m = coords[4][1][0]<br/> s = coords[4][2][0]<br/> lon = dms2dd(d, m ,s, i)<br/> return lat, lon</pre>
<ol start="9">
<li>Next, we have our program variables. We will be accessing an <strong>OpenStreetMap WMS</strong> service provided for free by a company named <strong>Mundalis</strong> as well as the SRTM data provided by NASA.</li>
</ol>
<div><p>We access the WMS services in this book using Python's <kbd>urllib</kbd> library for simplicity, but if you plan to use OGC web services frequently, you should use the Python package OWSLib available through PyPI: <a href="https://pypi.python.org/pypi/OWSLib">https://pypi.python.org/pypi/OWSLib</a>.</p>
</div>
<p>Now let's perform the followings steps to set up the WMS web service:</p>
<ol>
<li>We will output several intermediate products and images. These variables are used in those steps. The <kbd>route.gpx</kbd> file is defined in this section as the <kbd>gpx</kbd> variable. First, we set up some conversion constants for degrees to radians conversion and back with the following code:</li>
</ol>
<pre style="padding-left: 60px"># Needed for numpy conversions in hillshading<br/>deg2rad = 3.141592653589793 / 180.0<br/>rad2deg = 180.0 / 3.141592653589793</pre>
<ol start="2">
<li>Next, we set up the name of our <kbd>.gpx</kbd> file as follows:</li>
</ol>
<pre style="padding-left: 60px"># Program Variables<br/><br/># Name of the gpx file containing a route.<br/># https://git.io/fjwHW<br/>gpx = "route.gpx"</pre>
<ol start="3">
<li>Now, we begin setting up the WMS web service, which will retrieve the map:</li>
</ol>
<pre style="padding-left: 60px"># NOAA OpenStreetMap Basemap<br/><br/># OSM WMS service<br/>osm_WMS = "http://ows.mundialis.de/services/service"<br/><br/># Name of the WMS street layer<br/># streets = "osm"<br/>osm_lyr = "OSM-WMS"<br/><br/># Name of the basemap image to save<br/>osm_img = "basemap"<br/><br/># OSM EPSG code (spatial reference system)<br/>osm_epsg = 3857<br/><br/># Optional WMS parameter<br/>osm_style = ""</pre>
<ol start="4">
<li>Next, we set up our hillshade parameters, which will determine the angle and direction of our artificial sun:</li>
</ol>
<pre style="padding-left: 60px"># Shaded elevation parameters<br/>#<br/># Sun direction<br/>azimuth = 315.0<br/><br/># Sun angle<br/>altitude = 45.0<br/><br/># Elevation exageration<br/>z = 5.0<br/><br/># Resolution<br/>scale = 1.0</pre>
<ol start="5">
<li>Then we set up the <kbd>no_data</kbd> value where there is no elevation information:</li>
</ol>
<pre style="padding-left: 60px"># No data value for output<br/>no_data = 0</pre>
<ol start="6">
<li>Next, we set up the name of our output image as follows:</li>
</ol>
<pre style="padding-left: 60px"># Output elevation image name<br/>elv_img = "elevation"</pre>
<ol start="7">
<li>Now we create the colors for our minimum and maximum elevation values with the following code:</li>
</ol>
<pre style="padding-left: 60px"># RGBA color of the SRTM minimum elevation<br/>min_clr = (255, 255, 255, 0)<br/><br/># RGBA color of the SRTM maximum elevation<br/>max_clr = (0, 0, 0, 0)<br/><br/># No data color<br/>zero_clr = (255, 255, 255, 255)</pre>
<ol start="8">
<li>Then we set up our output image size, as follows:</li>
</ol>
<pre style="padding-left: 60px"># Pixel width and height of the<br/><br/># output images<br/>w = 800<br/>h = 800</pre>
<p>Now that we understand how the functions work, let's parse the GPX.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Parsing the GPX</h1>
                
            
            
                
<p>Now, we'll parse the GPX file, which is just XML, using the <kbd>built-in xml.dom.minidom</kbd> module. We'll extract latitude, longitude, elevation, and timestamps. We'll store them in a list for later use. The timestamps are converted to <kbd>struct_time</kbd> objects using Python's <kbd>time</kbd> module, which makes it easier to work with.</p>
<p>The following steps need to be performed for parsing:</p>
<ol>
<li>First, we parse the <kbd>gpx</kbd> file using the <kbd>minidom</kbd> module:</li>
</ol>
<pre style="padding-left: 60px"># Parse the gpx file and extract the coordinates<br/>log.info("Parsing GPX file: {}".format(gpx))<br/>xml = minidom.parse(gpx)</pre>
<ol start="2">
<li>Next, we get all of the <kbd>"trkpt"</kbd> tags that contain the elevation information:</li>
</ol>
<pre style="padding-left: 60px"># Grab all of the "trkpt" elements<br/>trkpts = xml.getElementsByTagName("trkpt")</pre>
<ol start="3">
<li>Now, we set up the lists to store our parsed location and elevation values:</li>
</ol>
<pre style="padding-left: 60px"># Latitude list<br/>lats = []<br/># Longitude list<br/>lons = []<br/># Elevation list<br/>elvs = []<br/># GPX timestamp list<br/>times = []</pre>
<ol start="4">
<li>Then, we loop through the GPS entries in the GPX and parse the values:</li>
</ol>
<pre style="padding-left: 60px"># Parse lat/long, elevation and times<br/>for trkpt in trkpts:<br/> # Latitude<br/> lat = float(trkpt.attributes["lat"].value)<br/> # Longitude<br/> lon = float(trkpt.attributes["lon"].value)<br/> lats.append(lat)<br/> lons.append(lon)<br/> # Elevation<br/> elv = trkpt.childNodes[0].firstChild.nodeValue<br/> elv = float(elv)<br/> elvs.append(elv)</pre>
<p>The timestamp requires a little bit of extra work because we have to convert from GMT time to local time:</p>
<pre> # Times<br/> t = trkpt.childNodes[1].firstChild.nodeValue<br/> # Convert to local time epoch seconds<br/> t = get_local_time(t)<br/> times.append(t)</pre>
<p>After we parse the GPX, we need the bounding box of the route to download data from other geospatial services.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting the bounding box</h1>
                
            
            
                
<p>When we download data, we want the dataset to cover more area than the route so the map is not cropped too closely around the edges of the route. So we'll buffer the bounding box by 20% on each side. Finally, we'll need the data in Eastings and Northings to work with the WMS service. Eastings and Northings are the <em>x</em> and <em>y</em> coordinates of points in the Cartesian coordinate system in meters. They are commonly used in the UTM coordinate system:</p>
<ol>
<li>First, we get the extents from our coordinate lists as follows: </li>
</ol>
<pre style="padding-left: 60px"># Find Lat/Long bounding box of the route<br/>minx = min(lons)<br/>miny = min(lats)<br/>maxx = max(lons)<br/>maxy = max(lats)</pre>
<ol start="2">
<li>Next, we buffer the bounding box to ensure the track isn't taken close to the edge:</li>
</ol>
<pre style="padding-left: 60px"># Buffer the GPX bounding box by 20%<br/># so the track isn't too close to<br/># the edge of the image.<br/>xdist = maxx - minx<br/>ydist = maxy - miny<br/>x20 = xdist * .2<br/>y20 = ydist * .2<br/><br/># 10% expansion on each side<br/>minx -= x20<br/>miny -= y20<br/>maxx += x20<br/>maxy += y20</pre>
<ol start="3">
<li>Finally, we set up our bounding box in a variable and convert our coordinates to meters, which the web service requires:</li>
</ol>
<pre style="padding-left: 60px"># Store the bounding box in a single<br/># variable to streamline function calls<br/>bbox = [minx, miny, maxx, maxy]<br/><br/># We need the bounding box in meters<br/># for the OSM WMS service. We will<br/># download it in degrees though to<br/># match the SRTM file. The WMS spec<br/># says the input SRS should match the<br/># output but this custom service just<br/># doesn't work that way<br/>mminx, mminy = ll2m(miny, minx)<br/>mmaxx, mmaxy = ll2m(maxy, maxx)</pre>
<p>With this, we will now download our map and elevation images.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Downloading map and elevation images</h1>
                
            
            
                
<p>We'll download the OSM basemap first as our basemap, which has streets and labels:</p>
<ol>
<li>First, we'll download the OSM basemap using <kbd>log.info</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># Download the OSM basemap<br/>log.info("Downloading basemap")<br/>wms(mminx, mminy, mmaxx, mmaxy, osm_WMS, osm_lyr,<br/> osm_epsg, osm_style, osm_img, w, h)</pre>
<p style="padding-left: 60px">This section will produce an intermediate image as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/92c897fd-a697-4824-bf2c-d9d6a46ee256.png" width="813" height="809"/></p>
<ol start="2">
<li>Next, we'll download some elevation data from the <strong>SRTM</strong> dataset. SRTM is nearly global and provides a 30-90 m resolution. The <kbd>SRTM.py</kbd> Python module makes working with this data easy. <kbd>SRTM.py</kbd> downloads the data and sets it needs to make a request. Therefore, if you download data from different areas, you may need to clean out the cache located in your home directory (<kbd>~/.srtm</kbd>). This part of the script can also take up to 2-3 minutes to complete, depending on your computer and internet connection speeds:</li>
</ol>
<pre style="padding-left: 60px"># Download the SRTM image<br/><br/># srtm.py downloader<br/>log.info("Retrieving SRTM elevation data")<br/># The SRTM module will try to use a local cache<br/><br/># first and if needed download it.<br/>srt = srtm.get_data()<br/># Get the image and return a PIL Image object<br/>image = srt.get_image((w, h), (miny, maxy), (minx, maxx),<br/> 300, zero_color=zero_clr, min_color=min_clr,<br/> max_color=max_clr)<br/># Save the image<br/>image.save(elv_img + ".png")</pre>
<p style="padding-left: 60px">This portion of the script also outputs an intermediate elevation image, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2aa4c75f-0071-4a70-8f9d-44bff5d3ca43.png" style="width:22.17em;height:23.42em;" width="730" height="767"/></p>
<p>Now that we have our elevation image, we can turn it into a hillshade.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating the hillshade</h1>
                
            
            
                
<p>We can run this data through the same <strong>hillshade</strong> algorithm used in <em>Creating a shaded-relief</em> section in <a href="964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml">Chapter 7</a>, <em>Python and Elevation Data. </em>For this, let's follow these steps: </p>
<ol>
<li>First, we open our elevation image and read it into a <kbd>numpy</kbd> array:</li>
</ol>
<pre style="padding-left: 60px"># Hillshade the elevation image<br/>log.info("Hillshading elevation data")<br/>im = Image.open(elv_img + ".png").convert("L")<br/>dem = np.asarray(im)</pre>
<ol start="2">
<li>Now we set up our processing windows to move through the grid and analyze it in small sections for efficiency:</li>
</ol>
<pre style="padding-left: 60px"># Set up structure for a 3x3 windows to<br/># process the slope throughout the grid<br/>window = []<br/># x, y resolutions<br/>xres = (maxx-minx)/w<br/>yres = (maxy-miny)/h</pre>
<ol start="3">
<li>Then, we break the elevation image into windows as follows:</li>
</ol>
<pre style="padding-left: 60px"># Create the windows<br/>for row in range(3):<br/> for col in range(3):<br/> window.append(dem[row:(row + dem.shape[0]-2),<br/> col:(col + dem.shape[1]-2)])</pre>
<ol start="4">
<li>We will create arrays for our processing windows as follows:</li>
</ol>
<pre style="padding-left: 60px"># Process each cell<br/>x = ((z * window[0] + z * window[3] + z * window[3] + z * window[6]) -<br/> (z * window[2] + z * window[5] + z * window[5] + z * window[8])) \<br/> / (8.0 * xres * scale)<br/><br/>y = ((z * window[6] + z * window[7] + z * window[7] + z * window[8]) -<br/> (z * window[0] + z * window[1] + z * window[1] + z * window[2])) \<br/> / (8.0 * yres * scale)</pre>
<ol start="5">
<li>Finally, we can process them in a single pass thanks to <kbd>numpy</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># Calculate slope<br/>slope = 90.0 - np.arctan(np.sqrt(x*x + y*y)) * rad2deg<br/><br/># Calculate aspect<br/>aspect = np.arctan2(x, y)<br/><br/># Calculate the shaded relief<br/>shaded = np.sin(altitude * deg2rad) * np.sin(slope * deg2rad) \<br/> + np.cos(altitude * deg2rad) * np.cos(slope * deg2rad) \<br/> * np.cos((azimuth - 90.0) * deg2rad - aspect)<br/><br/>shaded = shaded * 255</pre>
<p>Now that we have our hillshade layer, we can begin creating maps.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating maps</h1>
                
            
            
                
<p>We have the data we need to begin building the map for our report. Our approach will be the following:</p>
<ul>
<li>Enhancing the elevation and basemap images with filters</li>
<li>Blending the images together to provide a hillshaded OSM map</li>
<li>Creating a translucent layer to draw the street route</li>
<li>Blending the route layer with the hillshaded map</li>
</ul>
<p>These tasks will all be accomplished using the PIL <kbd>Image</kbd> and <kbd>ImageDraw</kbd> modules, as shown in the following steps: </p>
<ol>
<li>First, we convert our shaded relief <kbd>numpy</kbd> array back to an image and smooth it:</li>
</ol>
<pre style="padding-left: 60px"># Convert the numpy array back to an image<br/>relief = Image.fromarray(shaded).convert("L")<br/><br/># Smooth the image several times so it's not pixelated<br/>for i in range(10):<br/> relief = relief.filter(ImageFilter.SMOOTH_MORE)<br/><br/>log.info("Creating map image")</pre>
<ol start="2">
<li>Now we'll increase the contrast in the image to make it stand out more:</li>
</ol>
<pre style="padding-left: 60px"># Increase the hillshade contrast to make<br/># it stand out more<br/>e = ImageEnhance.Contrast(relief)<br/>relief = e.enhance(2)</pre>
<ol start="3">
<li>Next, we crop the map image to the same size as our elevation image:</li>
</ol>
<pre style="padding-left: 60px"># Crop the image to match the SRTM image. We lose<br/># 2 pixels during the hillshade process<br/>base = Image.open(osm_img + ".jpg").crop((0, 0, w-2, h-2))</pre>
<ol start="4">
<li>Then we increase the contrast on the map image as well and blend it with the hillshade image:</li>
</ol>
<pre style="padding-left: 60px"># Enhance basemap contrast before blending<br/>e = ImageEnhance.Contrast(base)<br/>base = e.enhance(1)<br/><br/># Blend the the map and hillshade at 90% opacity<br/>topo = Image.blend(relief.convert("RGB"), base, .9)</pre>
<ol start="5">
<li>Now we're ready to draw the GPS tracks on our blended map by first converting our points to pixels:</li>
</ol>
<pre style="padding-left: 60px"># Draw the GPX tracks<br/># Convert the coordinates to pixels<br/>points = []<br/>for x, y in zip(lons, lats):<br/> px, py = world2pixel(x, y, w, h, bbox)<br/> points.append((px, py))</pre>
<ol start="6">
<li>We also need to subtract the buffer from the edge buffer from the tracks image we are about to create:</li>
</ol>
<pre style="padding-left: 60px"># Crop the image size values to match the map<br/>w -= 2<br/>h -= 2</pre>
<ol start="7">
<li>Next, we create a transparent image and draw our track as a red line:</li>
</ol>
<pre style="padding-left: 60px"># Set up a translucent image to draw the route.<br/># This technique allows us to see the streets<br/># and street names under the route line.<br/><br/>track = Image.new('RGBA', (w, h))<br/><br/>track_draw = ImageDraw.Draw(track)<br/><br/># Route line will be red at 50% transparency (255/2=127)<br/>track_draw.line(points, fill=(255, 0, 0, 127), width=4)</pre>
<ol start="8">
<li>Now we can paste the track on our image with the following code:</li>
</ol>
<pre style="padding-left: 60px"># Paste onto the basemap using the drawing layer itself<br/># as a mask.<br/>topo.paste(track, mask=track)</pre>
<ol start="9">
<li>Now we'll draw a starting point on the route like so:</li>
</ol>
<pre style="padding-left: 60px"># Now we'll draw start and end points directly on top<br/># of our map - no need for transparency<br/>topo_draw = ImageDraw.Draw(topo)<br/><br/># Starting circle<br/>start_lon, start_lat = (lons[0], lats[0])<br/>start_x, start_y = world2pixel(start_lon, start_lat, w, h, bbox)<br/>start_point = [start_x-10, start_y-10, start_x+10, start_y+10]<br/>topo_draw.ellipse(start_point, fill="lightgreen", outline="black")<br/>start_marker = [start_x-4, start_y-4, start_x+4, start_y+4]<br/>topo_draw.ellipse(start_marker, fill="black", outline="white")</pre>
<ol start="10">
<li>Following is the code snippet for the ending point:</li>
</ol>
<pre style="padding-left: 60px"># Ending circle<br/>end_lon, end_lat = (lons[-1], lats[-1])<br/>end_x, end_y = world2pixel(end_lon, end_lat, w, h, bbox)<br/>end_point = [end_x-10, end_y-10, end_x+10, end_y+10]<br/>topo_draw.ellipse(end_point, fill="red", outline="black")<br/>end_marker = [end_x-4, end_y-4, end_x+4, end_y+4]<br/>topo_draw.ellipse(end_marker, fill="black", outline="white")</pre>
<p>Now that we have our track drawn, we're ready to place our geotagged photo.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Locating the photo</h1>
                
            
            
                
<p>We'll use a photo taken with a cell phone that adds GPS location coordinates. You can download it from: <br/>
<a href="https://raw.githubusercontent.com/GeospatialPython/Learn/master/RoutePhoto.jpg">https://raw.githubusercontent.com/GeospatialPython/Learn/master/RoutePhoto.jpg</a>.</p>
<p>Place the image in a directory named <kbd>photos</kbd> at the same level as the script. We'll only use one photo but the script can handle as man images as you want. We'll draw and place a photo icon on the map and then save the completed basemap, as shown in the following steps:</p>
<ol>
<li>First, we get a list of images with the following code:</li>
</ol>
<pre style="padding-left: 60px"># Photo icon<br/>images = glob.glob("photos/*.jpg")</pre>
<ol start="2">
<li>Next, we loop through each image and grab its GPS information:</li>
</ol>
<pre style="padding-left: 60px">for i in images:<br/> e = exif(i)</pre>
<ol start="3">
<li>Then, we parse the location info using our GPS function as follows:</li>
</ol>
<pre style="padding-left: 60px"> photo_lat, photo_lon = gps(e)<br/> #photo_lat, photo_lon = 30.311364, -89.324786</pre>
<ol start="4">
<li>Now, we can convert the photo coordinates to image pixel coordinates:</li>
</ol>
<pre style="padding-left: 60px"> photo_x, photo_y = world2pixel(photo_lon, photo_lat, w, h, bbox)</pre>
<ol start="5">
<li>Then we'll draw an icon for the location of the photo with the following code:</li>
</ol>
<pre style="padding-left: 60px"> topo_draw.rectangle([photo_x - 12, photo_y - 10, photo_x + 12, \<br/> photo_y + 10], fill="black", outline="black")<br/> topo_draw.rectangle([photo_x - 9, photo_y - 8, photo_x + 9, \<br/> photo_y + 8], fill="white", outline="white")<br/> topo_draw.polygon([(photo_x-8,photo_y+7), (photo_x-3,photo_y-1), (photo_x+2,photo_y+7)], fill = "black")<br/> topo_draw.polygon([(photo_x+2,photo_y+7), (photo_x+7,photo_y+3), (photo_x+8,photo_y+7)], fill = "black")</pre>
<ol start="6">
<li>And finally, we'll save our map like so:</li>
</ol>
<pre style="padding-left: 60px"># Save the topo map<br/>topo.save("{}_topo.jpg".format(osm_img))</pre>
<p>While not saved to the filesystem, the hillshaded elevation looks like the following: </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/141f8503-fd68-4964-8328-5bba99f03a99.png" style="width:36.67em;height:35.42em;" width="770" height="744"/></p>
<p>The blended topographic map looks like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/11b32a49-185b-4b05-8516-0f64e779769f.png" width="815" height="816"/></p>
<p>While hillshade mapping gives us an idea of the elevation, it doesn't give us any quantitative data. To get more detailed, we'll create a simple elevation chart.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Measuring elevation</h1>
                
            
            
                
<p>Using the excellent Google Chart API, we can quickly build a nice elevation profile chart showing how the elevation changes across the route:</p>
<ol>
<li>First, we'll create the <kbd>chart</kbd> object for our elevation profile:</li>
</ol>
<pre style="padding-left: 60px"># Build the elevation chart using the Google Charts API<br/>log.info("Creating elevation profile chart")<br/>chart = SimpleLineChart(600, 300, y_range=[min(elvs), max(elvs)])</pre>
<ol start="2">
<li>Now, we need to create a line for our minimum value like so:</li>
</ol>
<pre style="padding-left: 60px"># API quirk - you need 3 lines of data to color<br/># in the plot so we add a line at the minimum value<br/># twice.<br/>chart.add_data([min(elvs)]*2)<br/>chart.add_data(elvs)<br/>chart.add_data([min(elvs)]*2)<br/><br/># Black lines<br/>chart.set_colours(['000000'])</pre>
<ol start="3">
<li>Next, we can fill in our elevation profile as follows:</li>
</ol>
<pre style="padding-left: 60px"># fill in the elevation area with a hex color<br/>chart.add_fill_range('80C65A', 1, 2)</pre>
<ol start="4">
<li>Then we can set up the elevation labels as follows and assign them to an axis:</li>
</ol>
<pre style="padding-left: 60px"># Set up labels for the minimum elevation, halfway value, and max value<br/>elv_labels = int(round(min(elvs))), int(min(elvs)+((max(elvs)-min(elvs))/2))<br/><br/># Assign the labels to an axis<br/>elv_label = chart.set_axis_labels(Axis.LEFT, elv_labels)</pre>
<ol start="5">
<li>Next, we can label the axis itself with the following code:</li>
</ol>
<pre style="padding-left: 60px"># Label the axis<br/>elv_text = chart.set_axis_labels(Axis.LEFT, ["FEET"])<br/># Place the label at 30% the distance of the line<br/>chart.set_axis_positions(elv_text, [30])</pre>
<p class="mce-root"/>
<ol start="6">
<li>Now we can calculate the distance between the track points:</li>
</ol>
<pre style="padding-left: 60px"># Calculate distances between track segments<br/>distances = []<br/>measurements = []<br/>coords = list(zip(lons, lats))<br/>for i in range(len(coords)-1):<br/> x1, y1 = coords[i]<br/> x2, y2 = coords[i+1]<br/> d = haversine(x1, y1, x2, y2)<br/> distances.append(d)<br/>total = sum(distances)<br/>distances.append(0)<br/>j = -1</pre>
<p>We have the elevation profile, but we need to add the distance markers along the <em>x </em>axis so we know where along the route the profile changed.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Measuring distance</h1>
                
            
            
                
<p>In order to understand the elevation data chart, we need reference points along the <em>x </em>axis to help us determine the elevation along the route. We will calculate the mile splits along the route and place those at the appropriate location on the x axis of our charts. Let's have a look at the following steps:</p>
<ol>
<li>First, we locate the mile markers along the axis as follows:</li>
</ol>
<pre style="padding-left: 60px"># Locate the mile markers<br/>for i in range(1, int(round(total))):<br/> mile = 0<br/> while mile &lt; i:<br/> j += 1<br/> mile += distances[j]<br/> measurements.append((int(mile), j))<br/> j = -1</pre>
<ol start="2">
<li>Next, we set up labels for the mile markers:</li>
</ol>
<pre style="padding-left: 60px"># Set up labels for the mile points<br/><br/>positions = []<br/>miles = []<br/>for m, i in measurements:<br/> pos = ((i*1.0)/len(elvs)) * 100<br/> positions.append(pos)<br/> miles.append(m)<br/><br/># Position the mile marker labels along the x axis<br/>miles_label = chart.set_axis_labels(Axis.BOTTOM, miles)<br/>chart.set_axis_positions(miles_label, positions)</pre>
<ol start="3">
<li>Now we can label the mile markers as follows:</li>
</ol>
<pre style="padding-left: 60px"># Label the x axis as "Miles"<br/>miles_text = chart.set_axis_labels(Axis.BOTTOM, ["MILES", ])<br/>chart.set_axis_positions(miles_text, [50, ])<br/><br/># Save the chart<br/>chart.download('{}_profile.png'.format(elv_img))</pre>
<p>Our chart should now look like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/242e1586-6859-4016-887f-be8b58640ae8.png" width="614" height="320"/></p>
<p>Our first chart is complete. Now, let's look at weather data along the route.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Retrieving weather data</h1>
                
            
            
                
<p>In this section, we will retrieve our final data element: the weather. As mentioned earlier, we will use the Dark Sky service, which allows us to gather historical weather reports for any place in the world. The weather API is REST and JSON-based, so we'll use the <kbd>urllib</kbd> module to request data and the <kbd>json</kbd> library to parse it. Of note in this section is that we cache the data locally, so you can run the script offline for testing if need be. Early on in this section is where you place your Dark Sky API key that is flagged by the <kbd>YOUR KEY HERE</kbd> text. Let's have a look at the following steps:</p>
<ol>
<li>First, we need the center of our area of interest:</li>
</ol>
<pre style="padding-left: 60px">log.info("Creating weather summary")<br/><br/># Get the bounding box centroid for georeferencing weather data<br/>centx = minx + ((maxx-minx)/2)<br/>centy = miny + ((maxy-miny)/2)</pre>
<ol start="2">
<li>Now, we set up the free Dark API key as follows so we can retrieve weather data:</li>
</ol>
<pre style="padding-left: 60px"># DarkSky API key<br/># You must register for free at DarkSky.net<br/># to get a key to insert here.<br/>api_key = "YOUR API KEY GOES HERE"</pre>
<ol start="3">
<li>Then, we grab the latest timestamp from our data that we'll use for our weather query:</li>
</ol>
<pre style="padding-left: 60px"># Grab the latest route time stamp to query weather history<br/>t = times[-1]</pre>
<ol start="4">
<li>Now we're ready to do our weather data query as follows:</li>
</ol>
<pre style="padding-left: 60px">history_req = "https://api.darksky.net/forecast/{}/".format(api_key)<br/>#name_info = [t.tm_year, t.tm_mon, t.tm_mday, route_url.split(".")[0]]<br/>#history_req += "/history_{0}{1:02d}{2:02d}/q/{3}.json" .format(*name_info)<br/>history_req += "{},{},{}".format(centy, centx, t)<br/>history_req += "?exclude=currently,minutely,hourly,alerts,flags"<br/>request = urllib.request.urlopen(history_req)<br/>weather_data = request.read()</pre>
<ol start="5">
<li>We'll cache the weather data like so just in case we want to look at it later:</li>
</ol>
<pre style="padding-left: 60px"># Cache weather data for testing<br/>with open("weather.json", "w") as f:<br/> f.write(weather_data.decode("utf-8"))</pre>
<ol start="6">
<li>Then we parse the weather JSON data as follows:</li>
</ol>
<pre style="padding-left: 60px"># Retrieve weather data<br/>js = json.loads(open("weather.json").read())<br/>history = js["daily"]</pre>
<ol start="7">
<li>All we need is the weather summary, which is the first item in the list:</li>
</ol>
<pre style="padding-left: 60px"># Grab the weather summary data.<br/># First item in a list.<br/>daily = history["data"][0]</pre>
<ol start="8">
<li>Now, we'll get the specific weather attributes as follows:</li>
</ol>
<pre style="padding-left: 60px"># Max temperature in Imperial units (Farenheit).<br/># Celsius would be metric: "maxtempm"<br/>maxtemp = daily["temperatureMax"]<br/><br/># Minimum temperature<br/>mintemp = daily["temperatureMin"]<br/><br/># Maximum humidity<br/>maxhum = daily["humidity"]<br/><br/># Precipitation in inches (cm = precipm)<br/>if "precipAccumulation" in daily:<br/> precip = daily["precipAccumulation"]<br/>else:<br/> precip = "0.0"</pre>
<ol start="9">
<li>Now that we have the weather data stored in variables, we can complete the final step: adding it all to a PDF report. </li>
</ol>
<p>The <kbd>fpdf</kbd> library has no dependencies except PIL in some cases. For our purposes, it will work quite well. We are going to proceed down the page and add the elements. <kbd>fpdf.ln()</kbd> separates rows, while <kbd>fpdf.cells</kbd> contains text and allows for more precise layouts.</p>
<p class="mce-root"/>
<p>We're finally ready to create our PDF report with the following steps: </p>
<ol>
<li>First, we set up our <kbd>pdf</kbd> object as follows:</li>
</ol>
<pre style="padding-left: 60px"># Simple fpdf.py library for our report.<br/># New pdf, portrait mode, inches, letter size<br/># (8.5 in. x 11 in.)<br/>pdf = fpdf.FPDF("P", "in", "Letter")</pre>
<ol start="2">
<li>Then, we'll add a page for our report and set our font preferences:</li>
</ol>
<pre style="padding-left: 60px"># Add our one report page<br/>pdf.add_page()<br/><br/># Set up the title<br/>pdf.set_font('Arial', 'B', 20)</pre>
<ol start="3">
<li>We'll create a title for our report with the following code:</li>
</ol>
<pre style="padding-left: 60px"># Cells contain text or space items horizontally<br/>pdf.cell(6.25, 1, 'GPX Report', border=0, align="C")<br/><br/># Lines space items vertically (units are in inches)<br/>pdf.ln(h=1)<br/>pdf.cell(1.75)<br/><br/># Create a horizontal rule line<br/>pdf.cell(4, border="T")<br/>pdf.ln(h=0)<br/>pdf.set_font('Arial', style='B', size=14)</pre>
<ol start="4">
<li>Now, we can add the route map like so:</li>
</ol>
<pre style="padding-left: 60px"># Set up the route map<br/>pdf.cell(w=1.2, h=1, txt="Route Map", border=0, align="C")<br/>pdf.image("{}_topo.jpg".format(osm_img), 1, 2, 4, 4)<br/>pdf.ln(h=4.35)</pre>
<ol start="5">
<li>Next, we add the elevation chart as follows:</li>
</ol>
<pre style="padding-left: 60px"># Add the elevation chart<br/>pdf.set_font('Arial', style='B', size=14)<br/>pdf.cell(w=1.2, h=1, txt="Elevation Profile", border=0, align="C")<br/>pdf.image("{}_profile.png".format(elv_img), 1, 6.5, 4, 2)<br/>pdf.ln(h=2.4)</pre>
<ol start="6">
<li>Then we can write the weather data summary with the following code:</li>
</ol>
<pre style="padding-left: 60px"># Write the weather summary<br/>pdf.set_font('Arial', style='B', size=14)<br/>pdf.cell(1.2, 1, "Weather Summary", align="C")<br/>pdf.ln(h=.25)<br/>pdf.set_font('Arial', style='', size=12)<br/>pdf.cell(1.8, 1, "Min. Temp.: {}".format(mintemp), align="L")<br/>pdf.cell(1.2, 1, "Max. Hum.: {}".format(maxhum), align="L")<br/>pdf.ln(h=.25)<br/>pdf.cell(1.8, 1, "Max. Temp.: {}".format(maxtemp), align="L")<br/>pdf.cell(1.2, 1, "Precip.: {}".format(precip), align="L")<br/>pdf.ln(h=.25)</pre>
<ol start="7">
<li>The Dark Sky terms require us to add a logo to our report, crediting the excellent data source:</li>
</ol>
<pre style="padding-left: 60px"># Give Dark Sky credit for a great service (https://git.io/fjwHl)<br/>pdf.image("darksky.png", 3.3, 9, 1.75, .25)</pre>
<ol start="8">
<li>Now we can add the geolocated image with the following code:</li>
</ol>
<pre style="padding-left: 60px"># Add the images for any geolocated photos<br/>pdf.ln(h=2.4)<br/>pdf.set_font('Arial', style='B', size=14)<br/>pdf.cell(1.2, 1, "Photos", align="C")<br/>pdf.ln(h=.25)<br/>for i in images:<br/> pdf.image(i, 1.2, 1, 3, 3)<br/> pdf.ln(h=.25)</pre>
<ol start="9">
<li>And finally, we can save the report and view it:</li>
</ol>
<pre style="padding-left: 60px"># Save the report<br/>log.info("Saving report pdf")<br/>pdf.output('report.pdf', 'F')</pre>
<p>You should have a PDF document in your working directory called <kbd>report.pdf</kbd> containing your finished product. It should look like the image shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ccd637ac-85cb-4d2b-937f-c9808a776901.png" style="width:20.92em;height:51.33em;" width="431" height="1059"/></p>
<p>With this, we have used all the techniqueswe've learned throughout this book and built a GPS reporting tool. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Congratulations! In this book, you pulled together the most essential tools and skills needed to be a modern geospatial analyst. Whether you use geospatial data occasionally or use it all the time, you will be better equipped to make the most of geospatial analysis. This book focuses on using open source tools almost entirely found within the PyPI directory for ease of installation and integration. But even if you are using Python as a driver for a commercial GIS package or a popular library such as GDAL, the ability to test out new concepts in pure Python will always come in handy. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Further reading</h1>
                
            
            
                
<p>Python provides a rich set of libraries for visualizing data. One of the most prominent is <strong>Matplotlib</strong>, which can produce numerous types of charts and maps and save them to PDF. Packt has several books on Matplotlib, including the <em>Matplotlib 30 Cookbook</em>: <a href="https://www.packtpub.com/big-data-and-business-intelligence/matplotlib-30-cookbook">https://www.packtpub.com/big-data-and-business-intelligence/matplotlib-30-cookbook</a>.</p>


            

            
        
    </div>



  </body></html>