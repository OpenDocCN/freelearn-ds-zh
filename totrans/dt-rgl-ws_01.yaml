- en: 1\. Introduction to Data Wrangling with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 使用Python进行数据整理的简介
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will help you understand the importance of data wrangling in data
    science. You will gain practical knowledge of how to manipulate the data structures
    that are available in Python by comparing the different implementations of the
    built-in Python data structures. Overall, this chapter describes the importance
    of data wrangling, identifies the important tasks to be performed in data wrangling,
    and introduces basic Python data structures. By the end of this chapter, you will
    be adept at working with lists, sets, and dictionaries, which are the key building
    blocks of data structures in Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你理解数据整理在数据科学中的重要性。你将通过比较Python内置数据结构的不同实现，获得如何操作Python中可用数据结构的实际知识。总体而言，本章描述了数据整理的重要性，确定了数据整理中要执行的重要任务，并介绍了基本的Python数据结构。到本章结束时，你将熟练掌握列表、集合和字典的使用，它们是Python数据结构的关键构建块。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Since data science and analytics have become key parts of our lives, the role
    of a data scientist has become even more important. Finding the source of data
    is an essential part of data science; however, it is the *science* part that makes
    you – the practitioner – truly valuable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据科学和分析已成为我们生活的重要组成部分，数据科学家的作用变得更加重要。找到数据来源是数据科学的一个基本部分；然而，正是**科学**部分使你——实践者——真正有价值。
- en: 'To practice high-quality science with data, you need to make sure it is properly
    sourced, cleaned, formatted, and pre-processed. This book will teach you the most
    essential basics of this invaluable component of the data science pipeline: data
    wrangling. In short, data wrangling is the process that ensures that the data
    is being presented in a way that is clean, accurate, formatted, and ready to be
    used for data analysis.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要用数据进行高质量的科学实践，你需要确保数据来源正确、清洗、格式化和预处理。本书将教你数据科学管道中这个宝贵组成部分的最基本知识：数据整理。简而言之，数据整理是确保数据以干净、准确、格式化且可用于数据分析的方式呈现的过程。
- en: A prominent example of data wrangling with a large amount of data is the analysis
    conducted at the Supercomputer Center of the **University of California San Diego**
    (**UCSD**) every year. Wildfires are very common in California and are caused
    mainly by the dry weather and extreme heat, especially during the summers. Data
    scientists at the UCSD Supercomputer Center run an analysis every year and gather
    data to predict the nature and spread direction of wildfires in California. The
    data comes from diverse sources, such as weather stations, sensors in the forest,
    fire stations, satellite imagery, and Twitter feeds. However, this data might
    be incomplete or missing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数据整理的一个显著例子是每年在加州大学圣地亚哥分校（**UCSD**）超级计算中心进行的数据分析。加利福尼亚州野火非常常见，主要由干燥的天气和极端高温引起，尤其是在夏季。UCSD超级计算中心的数据科学家每年都会进行一次分析，收集数据以预测加利福尼亚州野火的性质和蔓延方向。这些数据来自不同的来源，如气象站、森林中的传感器、消防站、卫星图像和Twitter流。然而，这些数据可能不完整或缺失。
- en: After collecting the data from various sources, if it is not cleaned and formatted
    using ways including scaling numbers and removing unwanted characters in strings,
    it could result in erroneous data. In cases where we might get a flawed analysis,
    we might need to reformat the data from **JavaScript Object Notation** (**JSON**)
    into **Comma Separated Value** (**CSV**); we may also need the numbers to be normalized,
    that is, centered and scaled with relation to themselves. Processing data in such
    a way might be required when we feed data to certain machine learning models.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在从各种来源收集数据后，如果未使用包括缩放数字和去除字符串中的不需要字符等方式进行清洗和格式化，可能会导致错误的数据。在可能得到错误分析的情况下，我们可能需要将数据从**JavaScript对象表示法**（**JSON**）重新格式化为**逗号分隔值**（**CSV**）；我们可能还需要对数字进行归一化，即相对于自身进行居中和缩放。当我们向某些机器学习模型提供数据时，可能需要以这种方式处理数据。
- en: This is an example of how data wrangling and data science can prove to be helpful
    and relevant. This chapter will discuss the fundamentals of data wrangling. Let's
    get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个数据整理和数据科学如何证明其有用性和相关性的例子。本章将讨论数据整理的基本原理。让我们开始吧。
- en: Importance of Data Wrangling
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据整理的重要性
- en: A common mantra of the modern age is *Data is the New Oil*, meaning data is
    now a resource that's more valuable than oil. But just as crude oil does not come
    out of the rig as gasoline and must be processed to get gasoline and other products,
    data must be curated, massaged, or cleaned and refined to be used in data science
    and products based on data science. This is known as wrangling. Most data scientists
    spend the majority of their time data wrangling.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现代时代的一个常见格言是*数据是新石油*，这意味着数据现在是一种比石油更有价值的资源。但正如原油不会直接从钻井平台流出成为汽油，必须经过加工才能得到汽油和其他产品一样，数据也必须经过整理、按摩或清洗和提炼，才能用于数据科学和基于数据科学的产品。这被称为数据清洗。大多数数据科学家将大部分时间花在数据清洗上。
- en: Data wrangling is generally done at the very first stage of a data science/analytics
    pipeline. After the data scientists have identified any useful data sources for
    solving the business problem at hand (for instance, in-house database storage,
    the internet, or streaming sensor data such as an underwater seismic sensor),
    they then proceed to extract, clean, and format the necessary data from those
    sources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据清洗通常在数据科学/分析流程的第一阶段进行。在数据科学家已经确定了解决当前业务问题（例如，内部数据库存储、互联网或水下地震传感器等流传感器数据）的有用数据源之后，他们接着从这些来源提取、清洗和格式化必要的数据。
- en: 'Generally, the task of data wrangling involves the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据清洗的任务涉及以下步骤：
- en: Scraping raw data from multiple sources (including web and database tables)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从多个来源（包括网页和数据库表）抓取原始数据
- en: Imputing (replacing missing data using various techniques), formatting, and
    transforming – basically making it ready to be used in the modeling process (such
    as advanced machine learning)
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充（使用各种技术替换缺失数据）、格式化和转换——基本上使其准备好用于建模过程（如高级机器学习）
- en: Handling read/write errors
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理读写错误
- en: Detecting outliers
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测异常值
- en: Performing quick visualizations (plotting) and basic statistical analysis to
    judge the quality of formatted data
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行快速的可视化（绘图）和基本统计分析，以判断格式化数据的质量
- en: 'The following is an illustrative representation of the positioning and the
    essential functional role of data wrangling in a typical data science pipeline:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对典型数据科学流程中数据清洗定位及其基本功能角色的说明性表示：
- en: '![Figure 1.1: Process of data wrangling'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：数据清洗过程'
- en: '](img/B15780_01_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_01_01.jpg)'
- en: 'Figure 1.1: Process of data wrangling'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：数据清洗过程
- en: The process of data wrangling includes finding the appropriate data that's necessary
    for the analysis. Often, analysis is exploratory, so there is not enough scope.
    You often need to do data wrangling for this type of analysis to be able to understand
    your data better. This could lead to more analysis or machine learning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据清洗的过程包括找到分析所需的数据。通常，分析是探索性的，因此范围有限。你通常需要为此类分析进行数据清洗，以便更好地理解你的数据。这可能导致更多的分析或机器学习。
- en: This data can be from one or multiple sources, such as tweets, bank transaction
    statements in a relational database, sensor data, and so on. This data needs to
    be cleaned. If there is missing data, we will either delete or substitute it,
    with the help of several techniques. If there are outliers, we need to detect
    them and then handle them appropriately. If the data is from multiple sources,
    we will have to combine it using Structured Query Language (SQL) operations like
    JOIN.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可以来自一个或多个来源，例如推文、关系型数据库中的银行交易报表、传感器数据等。这些数据需要被清洗。如果有缺失数据，我们将使用几种技术中的任何一种进行删除或替换。如果有异常值，我们需要检测它们并适当地处理它们。如果数据来自多个来源，我们将使用结构化查询语言（SQL）操作如JOIN进行合并。
- en: In an extremely rare situation, data wrangling may not be needed. For example,
    if the data that's necessary for a machine learning task is already stored in
    an acceptable format in an in-house database, then a simple SQL query may be enough
    to extract the data into a table, ready to be passed on to the modeling stage.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在极其罕见的情况下，可能不需要数据清洗。例如，如果机器学习任务所需的数据已经以可接受的格式存储在内部数据库中，那么一个简单的SQL查询可能就足够将数据提取到表格中，以便传递到建模阶段。
- en: Python for Data Wrangling
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据清洗的Python
- en: 'There is always a debate regarding whether to perform the wrangling process
    using an enterprise tool or a programming language and its associated frameworks.
    There are many commercial, enterprise-level tools for data formatting and preprocessing
    that do not involve much coding on the user''s part. Some of these examples include
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有人争论是否应该使用企业工具或编程语言及其相关框架来执行数据清洗过程。有许多商业级的企业工具用于数据格式化和预处理，用户不需要编写太多代码。以下是一些例子：
- en: General-purpose data analysis platforms, such as **Microsoft Excel** (with add-ins)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用数据分析平台，例如**Microsoft Excel**（带有插件）
- en: Statistical discovery package, such as **JMP** (from SAS)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计发现包，例如**JMP**（来自SAS）
- en: Modeling platforms, such as **RapidMiner**
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型平台，例如**RapidMiner**
- en: Analytics platforms from niche players that focus on data wrangling, such as
    **Trifacta**, **Paxata**, and **Alteryx**
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于数据清洗的利基玩家分析平台，例如**Trifacta**、**Paxata**和**Alteryx**
- en: 'However, programming languages such as Python and R provide more flexibility,
    control, and power compared to these off-the-shelf tools. This also explains their
    tremendous popularity in the data science domain:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与这些现成的工具相比，Python和R等编程语言提供了更多的灵活性、控制和功能。这也解释了它们在数据科学领域中的巨大流行：
- en: '![Figure 1.2: Google trends worldwide over the last 5 years'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：过去5年全球Google趋势'
- en: '](img/B15780_01_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_01_02.jpg)'
- en: 'Figure 1.2: Google trends worldwide over the last 5 years'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：过去5年全球Google趋势
- en: Furthermore, as the volume, velocity, and variety (the three Vs of **big data**)
    of data undergo rapid changes, it is always a good idea to develop and nurture
    a significant amount of in-house expertise in data wrangling using fundamental
    programming frameworks so that an organization is not beholden to the whims and
    fancies of any particular enterprise platform for as basic a task as data wrangling.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着数据量、速度和种类（大数据的三个V）的快速变化，始终开发并培养大量内部数据清洗专业知识，使用基本的编程框架，这样组织就不会对任何特定企业平台的基本任务（如数据清洗）产生依赖，这总是一个好主意。
- en: 'A few of the obvious advantages of using an open source, free programming paradigm
    for data wrangling are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开源、免费的编程范式进行数据清洗的一些明显优势如下：
- en: A general-purpose open-source paradigm puts no restrictions on any of the methods
    you can develop for the specific problem at hand.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用开源范式对您为特定问题开发的方法没有任何限制。
- en: There's a great ecosystem of fast, optimized, open-source libraries, focused
    on data analytics.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个快速、优化的开源库生态系统，专注于数据分析。
- en: There's also growing support for connecting Python to every conceivable data
    source type.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时也在不断增长，支持将Python连接到各种可能的数据源类型。
- en: There's an easy interface to basic statistical testing and quick visualization
    libraries to check data quality.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个简单的界面用于基本的统计测试和快速可视化库来检查数据质量。
- en: And there's a seamless interface of the data wrangling output with advanced
    machine learning models.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且数据清洗的输出与高级机器学习模型之间有一个无缝的接口。
- en: Python is the most popular language for machine learning and artificial intelligence
    these days. Let's take a look at a few data structures in Python.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python是目前机器学习和人工智能领域最受欢迎的语言。让我们来看看Python中的一些数据结构。
- en: Lists, Sets, Strings, Tuples, and Dictionaries
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表、集合、字符串、元组和字典
- en: Now that we have touched upon a few advantages of using Python, we will start
    by exploring various basic data structures in Python. We will also learn about
    a few techniques we can use to handle these data structures. This is invaluable
    for a data practitioner.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经提到了使用Python的一些优点，我们将从探索Python中的各种基本数据结构开始。我们还将了解我们可以用来处理这些数据结构的一些技术。这对数据从业者来说是无价的。
- en: Lists
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are fundamental Python data structures that have continuous memory locations
    and can host different data types (such as strings, numbers, floats, and doubles)
    and can be accessed by the index.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是Python的基本数据结构，具有连续的内存位置，可以容纳不同的数据类型（如字符串、数字、浮点数和双精度浮点数），并且可以通过索引访问。
- en: We will start with a list and list comprehension. A list comprehension is a
    syntactic sugar (or shorthand) for a `for` loop, which iterates over a list. We
    will generate a list of numbers, and then examine which ones among them are even.
    We will sort, reverse, and check for duplicates. We will also see the different
    ways we can access the list elements, iterating over them and checking the membership
    of an element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列表和列表推导式开始。列表推导式是`for`循环的语法糖（或简写），它遍历列表。我们将生成一个数字列表，然后检查其中哪些是偶数。我们将对它们进行排序、反转并检查重复项。我们还将看到不同的方法来访问列表元素，遍历它们并检查元素的成员资格。
- en: 'The following is an example of a simple list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单列表的示例：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is also an example of a list:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也是一个列表的示例：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, a list can contain any number of the allowed data types, such
    as `int`, `float`, `string`, and `boolean`, and a list can also be a mix of different
    data types (including nested lists).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个列表可以包含任何数量的允许的数据类型，例如`int`、`float`、`string`和`boolean`，列表也可以是不同数据类型的混合（包括嵌套列表）。
- en: If you are coming from a strongly typed language, such as C, C++, or Java, then
    this will probably be strange as you are not allowed to mix different kinds of
    data types in a single array in those languages. Lists in Python are loosely typed,
    that is, they are not restricted to a single type. Lists are somewhat like arrays
    in the sense that they are both based on continuous memory locations and can be
    accessed using indexes. But the power of Python lists comes from the fact that
    they can host different data types and you are allowed to manipulate the data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自强类型语言，如C、C++或Java，那么这可能会让你感到奇怪，因为在那些语言中不允许在单个数组中混合不同类型的数据。Python中的列表是松散类型的，也就是说，它们不受单一类型的限制。在某种程度上，列表类似于数组，因为它们都是基于连续的内存位置，并且可以使用索引进行访问。但Python列表的强大之处在于它们可以容纳不同的数据类型，并且允许你操作数据。
- en: 'In Python, there is a concept of creating a slice of a list. Here is the syntax:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一个创建列表切片的概念。以下是语法：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Known as `0` to `1` minus the total length. The first number given represents
    the first position to include in the slice. The second number is used to indicate
    which place you want to stop at, but not include. A slice can have an index of
    `–1` to indicate the last element.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为从`0`到`1`减去总长度的值。给出的第一个数字代表要包含在切片中的第一个位置。第二个数字用于指示你想要停止的位置，但不包括在内。一个切片可以有一个索引为`–1`，表示最后一个元素。
- en: 'The indices will be automatically assigned, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 索引将自动分配，如下所示：
- en: '![Figure 1.3: List showing the forward and backward indices'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：显示正向和反向索引的列表'
- en: '](img/B15780_01_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_01_03.jpg)'
- en: 'Figure 1.3: List showing the forward and backward indices'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：显示正向和反向索引的列表
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful, though, as the very power of lists, and the fact that you can mix
    different data types in a single list, can actually create subtle bugs that can
    be very difficult to track.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，列表的这种强大功能，以及你可以在单个列表中混合不同数据类型的事实，实际上可能会创建难以追踪的微妙错误。
- en: List Functions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表函数
- en: In this section, we will discuss a few basic functions for handling lists.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些处理列表的基本函数。
- en: 'You can access list elements using the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码访问列表元素：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To find out the length of a list, we simply use the `len` function. The `len`
    function in Python returns the length of the specified list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出列表的长度，我们只需使用`len`函数。Python中的`len`函数返回指定列表的长度：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can append new elements in the list. `append` is a built-in method in Python
    for the list data type:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在列表中追加新的元素。`append`是Python列表数据类型的一个内置方法：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's go through some exercises to practice these functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些练习来练习这些函数。
- en: 'Exercise 1.01: Accessing the List Members'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.01：访问列表成员
- en: 'In this exercise, we will be reading a list of social security numbers from
    the `ssn.csv` file and then observing the different ways of accessing the elements
    from the list using the forward and backward indices. We will be using our first
    Python function, `len`, which will return the length of the specified list. We
    will be starting with the basic building blocks for future exercises. Let''s go
    through the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从`ssn.csv`文件中读取一系列社会保障号码，然后观察使用正向和反向索引从列表中访问元素的不同方法。我们将使用我们的第一个Python函数`len`，它将返回指定列表的长度。我们将从未来练习的基本构建块开始。让我们按以下步骤进行：
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `ssn.csv` file can be found here: [https://packt.live/2AydLCx](https://packt.live/2AydLCx).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssn.csv`文件可在此处找到：[https://packt.live/2AydLCx](https://packt.live/2AydLCx)。'
- en: 'Open a new Jupyter Notebook and define a list called `ssn`. Read from the `ssn.csv`
    file using the `read_csv` command and print the list elements:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook，定义一个名为`ssn`的列表。使用`read_csv`命令从`ssn.csv`文件中读取，并打印列表元素：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Access the first element of `ssn` using its forward index:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正向索引访问`ssn`的第一个元素：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Access the fourth element of `ssn` using its forward index:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正向索引访问`ssn`的第四个元素：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Access the last element of `ssn` using the `len` function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`len`函数访问`ssn`的最后一个元素：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Access the last element of `ssn` using its backward index:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用反向索引访问`ssn`的最后一个元素：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Access the first three elements of `ssn` using forward indices:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正向索引访问`ssn`的前三个元素：
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Access the last two elements of `ssn` by slicing:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过切片访问`ssn`的最后两个元素：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Access the first two elements using backward indices:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用反向索引访问前两个元素：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.4: Output after using backward indices'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.4：使用反向索引后的输出'
- en: '](img/B15780_01_04.jpg)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_01_04.jpg](img/B15780_01_04.jpg)'
- en: 'Figure 1.4: Output after using backward indices'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.4：使用反向索引后的输出
- en: When we leave one side of the colon (`:`) blank, we are basically telling Python
    either to go until the end or start from the beginning of the list. It will automatically
    apply the rule of list slices that we just learned.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们在冒号（`:`）的一侧留空时，我们基本上是在告诉Python要么走到列表的末尾，要么从列表的开始处开始。它将自动应用我们刚刚学到的列表切片规则。
- en: 'Reverse the elements in the list:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转列表中的元素：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.5: Output after elements are reversed'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.5：元素反转后的输出'
- en: '](img/B15780_01_05.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_01_05.jpg](img/B15780_01_05.jpg)'
- en: 'Figure 1.5: Output after elements are reversed'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：元素反转后的输出
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3fzTvzk](https://packt.live/3fzTvzk).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3fzTvzk](https://packt.live/3fzTvzk)。
- en: You can also run this example online at [https://packt.live/2YF3zA0](https://packt.live/2YF3zA0).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在此处在线运行此示例：[https://packt.live/2YF3zA0](https://packt.live/2YF3zA0)。
- en: In this exercise, we learned how to access the list members with forward and
    backward indices. We'll create a list in the next exercise.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用正向和反向索引访问列表成员。在下一个练习中，我们将创建一个列表。
- en: 'Exercise 1.02: Generating and Iterating through a List'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.02：生成和遍历列表
- en: In this exercise, we are going to examine various ways of generating a list
    and a nested list using the same file containing the list of social security numbers
    (`ssn.csv`) that we used in the previous exercise.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将检查使用与之前练习中相同的包含社会保障号码列表的文件（`ssn.csv`）生成列表和嵌套列表的多种方法。
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `ssn.csv` file can be found here: [https://packt.live/2AydLCx](https://packt.live/2AydLCx).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssn.csv`文件可在此处找到：[https://packt.live/2AydLCx](https://packt.live/2AydLCx)。'
- en: 'We are going to use the `append` method to add new elements to the list and
    a `while` loop to iterate through the list. To do so, let''s go through the following
    steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`append`方法向列表中添加新元素，并使用`while`循环遍历列表。为此，让我们按以下步骤进行：
- en: 'Open a new Jupyter Notebook and import the necessary Python libraries. Read
    from the `ssn.csv` file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook，导入必要的Python库。从`ssn.csv`文件中读取：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a list using the `append` method. The `append` method from the Python
    library will allow you to add items to the list:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`append`方法创建一个列表。Python库中的`append`方法将允许您向列表中添加项：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will be as follows:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '![Figure 1.6: Output after creating a list using the append method'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.6：使用append方法创建列表后的输出'
- en: '](img/B15780_01_06.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_01_06.jpg)'
- en: 'Figure 1.6: Output after creating a list using the append method'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.6：使用append方法创建列表后的输出
- en: Here, we started by declaring an empty list called `ssn_2`, and then we used
    a `for` loop to append values to it after reading from the `ssn.csv` file.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们首先声明了一个名为`ssn_2`的空列表，然后使用`for`循环从`ssn.csv`文件中读取值后将其追加到它上面。
- en: 'Generate a list using the following command:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令生成列表：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.7: Output of a generated list'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.7：生成的列表输出'
- en: '](img/B15780_01_07.jpg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_01_07.jpg)'
- en: 'Figure 1.7: Output of a generated list'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.7：生成的列表输出
- en: This is list comprehension, which is a very powerful tool that we need to master.
    The power of list comprehension comes from the fact that we can use conditionals
    such as `for..in` inside the comprehension itself. This will be discussed in detail
    in *Chapter 2, Advanced Operations on Built-in Data Structures*.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一种列表推导，这是一种非常强大的工具，我们需要掌握。列表推导的强大之处在于我们可以在推导本身中使用条件，如`for..in`。这将在*第2章，内置数据结构的高级操作*中详细讨论。
- en: 'Use a `while` loop to iterate over the list:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`while`循环遍历列表：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Search all the social security numbers with the number `5` in them:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索包含数字`5`的所有社会保障号码：
- en: '[PRE29]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output will be as follows:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '![Figure 1.8: SSNs with the number 5 in them'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.8：包含数字5的社会保障号码'
- en: '](img/B15780_01_08.jpg)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_01_08.jpg)'
- en: 'Figure 1.8: SSNs with the number 5 in them'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.8：包含数字5的社会保障号码
- en: Let's explore a few more list operations. We are going to use the `+` operator
    to add the contents of two lists and use the `extend` keyword to replace the contents
    of the existing list with another list.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们探索一些更多的列表操作。我们将使用`+`运算符来添加两个列表的内容，并使用`extend`关键字用另一个列表替换现有列表的内容。
- en: 'Generate a list by adding the two lists. Here, we will just use the `+` operator:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加两个列表生成一个列表。在这里，我们只需使用`+`运算符：
- en: '[PRE30]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.9: Generated list by adding two lists'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.9：通过添加两个列表生成的列表'
- en: '](img/B15780_01_09.jpg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_01_09.jpg)'
- en: 'Figure 1.9: Generated list by adding two lists'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.9：通过添加两个列表生成的列表
- en: 'Extend a string using the `extend` keyword:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extend`关键字扩展字符串：
- en: '[PRE31]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.10: The extend string operation'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.10：extend字符串操作'
- en: '](img/B15780_01_10.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_01_10.jpg)'
- en: 'Figure 1.10: The extend string operation'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.10：extend字符串操作
- en: Note
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The `extend` operation changes the original list (`ssn_2`) and appends all the
    elements of `ssn_4` to it. So, be careful while using it.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`extend`操作会改变原始列表（`ssn_2`），并将`ssn_4`的所有元素追加到它上面。所以，在使用它时要小心。'
- en: 'Now, let''s loop over the first list and create a nested list inside that loop
    that goes over the second list:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们遍历第一个列表，并在循环内部创建一个嵌套列表，该列表遍历第二个列表：
- en: '[PRE32]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output (partially shown) is as follows:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下：
- en: '![Figure 1.11: Partial output of ssn'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.11：ssn的部分输出'
- en: '](img/B15780_01_11.jpg)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_01_11.jpg)'
- en: 'Figure 1.11: Partial output of ssn'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：ssn的部分输出
- en: Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Y6vObR](https://packt.live/2Y6vObR).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2Y6vObR](https://packt.live/2Y6vObR)。
- en: You can also run this example online at [https://packt.live/2YLJybf](https://packt.live/2YLJybf).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2YLJybf](https://packt.live/2YLJybf)上在线运行此示例。
- en: In this exercise, we used the built-in methods of Python to manipulate lists.
    In the next exercise, we'll check whether the elements or members in a dataset
    are present as per our expectations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了Python的内置方法来操作列表。在下一个练习中，我们将检查数据集中的元素或成员是否如我们所期望的那样存在。
- en: 'Exercise 1.03: Iterating over a List and Checking Membership'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.03：遍历列表并检查成员资格
- en: 'This exercise will demonstrate how we can iterate over a list and verify that
    the values are as expected. This is a manual test that can often be done while
    dealing with a reasonably sized dataset for business case scenarios. Let''s go
    through the following steps to check the membership of values and whether they
    exist in the `.csv` file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习将演示我们如何遍历列表并验证值是否符合预期。这是一个在处理合理大小的数据集时经常可以进行的手动测试，适用于业务场景。让我们按照以下步骤检查值的成员资格以及它们是否存在于`.csv`文件中：
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `car_models.csv` file can be found at [https://packt.live/3d8DUVy](https://packt.live/3d8DUVy).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`car_models.csv` 文件可以在以下链接找到：[https://packt.live/3d8DUVy](https://packt.live/3d8DUVy)。'
- en: 'Import the necessary Python libraries and read from the `car_models.csv` file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的 Python 库并从 `car_models.csv` 文件中读取：
- en: '[PRE33]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Iterate over a list:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历一个列表：
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: However, this is not very Pythonic. Being Pythonic means to follow and conform
    to a set of best practices and conventions that have been created over the years
    by thousands of capable developers. In this case, this means we could use the
    `in` keyword in the `for..in` conditional because Python does not have index initialization,
    bounds checking, or index incrementing, unlike traditional languages. Python uses
    syntactic sugar to make iterating through lists easy and readable. In other languages,
    you might have to create a variable (index initialization) as you loop over the
    list check that variable (bounds checking) since it will be incremented in the
    loop (index incrementing).
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这并不是非常符合 Python 风格。符合 Python 风格意味着遵循和遵守多年来由数千名有能力的开发者创建的一系列最佳实践和约定。在这种情况下，这意味着我们可以使用
    `in` 关键字在 `for..in` 条件中，因为 Python 没有索引初始化、边界检查或索引递增，这与传统语言不同。Python 使用语法糖来使遍历列表变得简单易读。在其他语言中，你可能需要在遍历列表时创建一个变量（索引初始化），检查该变量（边界检查），因为它将在循环中递增（索引递增）。
- en: 'Write the following code to see the Pythonic way of iterating over a list:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码以查看遍历列表的 Python 风格：
- en: '[PRE36]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that in the second method, we do not need a counter anymore to access
    the list index; instead, Python's `in` operator gives us the element at the `i`th
    position directly.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到在第二种方法中，我们不再需要计数器来访问列表索引；相反，Python 的 `in` 操作符直接给我们 `i` 位置的元素。
- en: 'Check whether the strings `D150` and `Mustang` are in the list using the `in` operator:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `in` 操作符检查字符串 `D150` 和 `Mustang` 是否在列表中：
- en: '[PRE38]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The output is `True`.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出为 `True`。
- en: '[PRE39]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output is `False`.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出为 `False`。
- en: Note
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/30TpGp5](https://packt.live/30TpGp5).
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅：[https://packt.live/30TpGp5](https://packt.live/30TpGp5)。
- en: You can also run this example online at [https://packt.live/2Y8z06L](https://packt.live/2Y8z06L).
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在此在线运行此示例：[https://packt.live/2Y8z06L](https://packt.live/2Y8z06L)。
- en: In this exercise, we've seen how to iterate over a list and verified the membership
    of each element. This is an important skill. Often, when working with large applications,
    manually checking a list could be useful. If at any time you are unsure of a list,
    you can easily verify what values are present. Now, we will see how we can perform
    a sort operation on a list.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何遍历列表并验证每个元素的成员资格。这是一个重要的技能。通常，当处理大型应用程序时，手动检查列表可能很有用。如果你在任何时候对列表不确定，你可以轻松地验证哪些值存在。现在，我们将看到如何对列表执行排序操作。
- en: 'Exercise 1.04: Sorting a List'
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.04：排序列表
- en: 'In this exercise, we will sort a list of numbers, first by using the `sort`
    method and then by using the `reverse` method. To do so, let''s go through the
    following steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过使用 `sort` 方法然后使用 `reverse` 方法来对数字列表进行排序。为此，让我们按照以下步骤进行：
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `ssn.csv` file can be found here: [https://packt.live/2AydLCx](https://packt.live/2AydLCx).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssn.csv` 文件可以在以下链接找到：[https://packt.live/2AydLCx](https://packt.live/2AydLCx)。'
- en: 'Open a new Jupyter Notebook and import the necessary Python libraries:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 并导入必要的 Python 库：
- en: '[PRE40]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the `sort` method with `reverse=True`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sort` 方法并设置 `reverse=True`：
- en: '[PRE41]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the `reverse` method directly to achieve this result:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接使用 `reverse` 方法来实现此结果：
- en: '[PRE43]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Y7HlYe](https://packt.live/2Y7HlYe).
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅：[https://packt.live/2Y7HlYe](https://packt.live/2Y7HlYe)。
- en: You can also run this example online at [https://packt.live/2YGNvOd](https://packt.live/2YGNvOd).
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在此在线运行此示例：[https://packt.live/2YGNvOd](https://packt.live/2YGNvOd)。
- en: The difference between the `sort` method and the `reverse` method is that we
    can use `sort` with customized sorting, whereas we can only use `reverse` to reverse
    a list. Also, both methods work in-place, so be aware of this while using them.
    Now, let's create a list with random numbers. Random numbers can be very useful
    in a variety of situations and preprocessing data is a common process in machine learning.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`方法和`reverse`方法之间的区别在于我们可以使用`sort`进行自定义排序，而只能使用`reverse`来反转列表。此外，这两种方法都是原地操作，所以在使用时要留意这一点。现在，让我们创建一个包含随机数的列表。随机数在许多情况下非常有用，而在机器学习中预处理数据是一个常见的过程。'
- en: 'Exercise 1.05: Generating a Random List'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.05：生成随机列表
- en: 'In this exercise, we will be generating a `list` with random numbers using
    the `random` library in Python and performing mathematical operations on them.
    To do so, let''s go through the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Python中的`random`库生成一个包含随机数的列表，并对它们执行数学运算。为此，让我们按照以下步骤进行：
- en: 'Import the `random` library:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`random`库：
- en: '[PRE45]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use the `randint` method to generate some random integers and add them to a
    list:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`randint`方法生成一些随机整数并将它们添加到一个列表中：
- en: '[PRE46]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s print the list. Note that there will be duplicate values in `list_1`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印这个列表。请注意，`list_1`中会有重复的值：
- en: '[PRE47]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The sample output (partially shown) is as follows:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 样本输出（部分显示）如下：
- en: '![Figure 1.12: List of random numbers'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 1.12: List of random numbers]'
- en: '](img/B15780_01_12.jpg)'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_01_12.jpg]'
- en: 'Figure 1.12: List of random numbers'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.12：随机数列表
- en: Note
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The output will vary with every run since we are generating random numbers.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次运行的结果都会有所不同，因为我们正在生成随机数。
- en: 'Let''s find the square of each element:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们找到每个元素的平方：
- en: '[PRE48]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.13: List of random numbers'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 1.13: List of random numbers]'
- en: '](img/B15780_01_13.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_01_13.jpg]'
- en: 'Figure 1.13: List of random numbers'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.13：随机数列表
- en: 'Now let''s find the log of the `1` elements of `list_2`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们找到`list_2`中`1`个元素的日志：
- en: '[PRE49]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output (partially shown) is as follows:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下：
- en: '![Figure 1.14: Partial output for list_2'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 1.14: Partial output for list_2]'
- en: '](img/B15780_01_14.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_01_14.jpg]'
- en: 'Figure 1.14: Partial output for list_2'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14：list_2的部分输出
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The output is susceptible to change since we are generating random numbers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能会变化，因为我们正在生成随机数。
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/37BerTD](https://packt.live/37BerTD).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅[https://packt.live/37BerTD](https://packt.live/37BerTD)。
- en: You can also run this example online at [https://packt.live/3hHwlsH](https://packt.live/3hHwlsH).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hHwlsH](https://packt.live/3hHwlsH)上运行这个示例。
- en: In this exercise, we worked on random variables, lists comprehension, and preprocessing
    data. Let's put what we have learned so far together and go through an activity
    to practice how to handle lists.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们研究了随机变量、列表推导和数据处理。让我们将我们学到的东西结合起来，通过一个活动来练习如何处理列表。
- en: 'Activity 1.01: Handling Lists'
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.01：处理列表
- en: In this activity, you will generate a list of random numbers and then generate
    another list from the first one, which only contains numbers that are divisible
    by three. Repeat the experiment 10 times; you'll see that the output varies each
    time, given that a different set of random numbers will be generated each time.
    Then, you will calculate the average difference between the lengths of the two
    lists.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将生成一个随机数列表，然后从这个列表中生成另一个列表，其中只包含能被`3`整除的数字。重复实验10次；你会看到每次输出都不同，因为每次都会生成不同的随机数集。然后，你将计算两个列表长度之间的平均差异。
- en: 'These are the steps for completing this activity:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动的步骤如下：
- en: Create a `list` of `100` random numbers.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`100`个随机数的`list`。
- en: Create a new `list` from this random `list`, with numbers that are divisible
    by `3`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个随机列表中创建一个新的`list`，包含能被`3`整除的数字。
- en: Calculate the length of these two lists and store the difference in a new variable.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算这两个列表的长度并将差值存储在一个新变量中。
- en: Using a loop, perform steps 1, 2, and 3, and find the difference variable 10
    times.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环执行步骤1、2和3，并找到差异变量10次。
- en: Find the arithmetic mean of these `10` difference values.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算这些`10`个差异值的算术平均值。
- en: 'The output (will vary with each run) should look similar to this:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（每次运行都会有所不同）应该类似于以下内容：
- en: '[PRE50]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor304).
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决这个活动的方案可以通过[这个链接](B15780_Solution_Final_RK.xhtml#_idTextAnchor304)找到。
- en: Sets
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: A set, mathematically speaking, is just a collection of well-defined distinct
    objects. Python gives us a straightforward way to deal with them using its set
    data type.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度来看，集合只是由定义明确的、不同的对象组成的集合。Python通过其集合数据类型为我们提供了一种直接处理它们的方法。
- en: Introduction to Sets
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合简介
- en: 'With the last list that we generated in the previous section; we are going
    to revisit the problem of getting rid of duplicates from it. We can achieve that
    with the following line of code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们生成的最后一个列表中；我们将重新审视从其中去除重复元素的问题。我们可以通过以下代码行实现这一点：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we print this, we will see that it only contains unique numbers. We used
    the **set** data type to turn the first list into a set, thus getting rid of all
    duplicate elements, and then used the **list** function to turn it into a list
    from a set once more:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印它，我们会看到它只包含唯一的数字。我们使用了**集合**数据类型将第一个列表转换为集合，从而去除了所有重复元素，然后使用**列表**函数再次将其从集合转换为列表：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 1.15: Section of output for list_12'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15：list_12的输出部分'
- en: '](img/B15780_01_15.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_01_15.jpg)'
- en: 'Figure 1.15: Section of output for list_12'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：list_12的输出部分
- en: In the next section, we will discuss the union and intersection of sets.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论集合的并集与交集。
- en: Union and Intersection of Sets
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的并集与交集
- en: In mathematical terms, a list of unique objects is a set. There are many ways
    of combining sets in the same mathematical term. One such way is the use of a
    union.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学术语中，唯一对象的列表是一个集合。在同一个数学术语中，有许多组合集合的方法。其中一种方法就是使用并集。
- en: 'This is what a union between two sets looks like:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是两个集合并集的样子：
- en: '![Figure 1.16: Venn diagram showing the union of two sets'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.16：展示两个集合并集的维恩图'
- en: '](img/B15780_01_16.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_01_16.jpg)'
- en: 'Figure 1.16: Venn diagram showing the union of two sets'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16：展示两个集合并集的维恩图
- en: This simply means taking everything from both sets but only taking the common
    elements once.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅意味着从两个集合中取走所有内容，但只取一次公共元素。
- en: 'We can implement this concept by using the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码实现这一概念：
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To find the union of the two sets, the following code should be used:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到两个集合的并集，应使用以下代码：
- en: '[PRE54]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output would be as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice that the common element, `Banana`, appears only once in the resulting
    set. The common elements of two sets can be identified by obtaining the intersection
    of the two sets, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，公共元素“香蕉”在结果集中只出现一次。两个集合的公共元素可以通过获取两个集合的交集来识别，如下所示：
- en: '![Figure 1.17: Venn diagram showing the intersection of two sets'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.17：展示两个集合交集的维恩图'
- en: '](img/B15780_01_17.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_01_17.jpg)'
- en: 'Figure 1.17: Venn diagram showing the intersection of two sets'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17：展示两个集合交集的维恩图
- en: 'We get the intersection of two sets in Python as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们如下获取两个集合的交集：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will give us a set with only one element. The output is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个只有一个元素的集合。输出如下：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also calculate the difference between sets (also known as complements).
    To find out more, refer to this link: https://docs.python.org/3/tutorial/datastructures.html#sets.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以计算集合之间的差异（也称为补集）。要了解更多信息，请参阅此链接：https://docs.python.org/3/tutorial/datastructures.html#sets。
- en: In this section, we went through sets and how we can do basic set functionality.
    Sets are used throughout database programming and design, and they are very useful
    for data wrangling.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了集合以及如何进行基本的集合功能。集合在数据库编程和设计中被广泛使用，并且对于数据处理非常有用。
- en: Creating Null Sets
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建空集
- en: In mathematical terms, a set that has nothing inside it is called a null set
    or an empty set.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学术语中，没有任何内容的集合被称为空集或空集。
- en: 'You can create a null set by creating a set containing no elements. You can
    do this by using the following code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建一个不包含任何元素的集合来创建一个空集。您可以通过以下代码来完成：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE59]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, to create a dictionary with null values, use the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要创建包含空值的字典，请使用以下命令：
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE61]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We are going to learn about this in detail in the next section.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细介绍这一点。
- en: Dictionary
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: A dictionary is like a list, which means it is a collection of several elements.
    However, with the dictionary, it is a collection of key-value pairs, where the
    key can be anything that can fit into memory. Generally, we use numbers or strings
    as keys.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 字典就像一个列表，这意味着它是一个由几个元素组成的集合。然而，在字典中，它是一个键值对的集合，其中键可以是任何可以适应内存的东西。通常，我们使用数字或字符串作为键。
- en: 'To create a dictionary, use the following code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个字典，请使用以下代码：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is also a valid dictionary:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个有效的字典：
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE66]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The keys must be unique in a dictionary.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的键必须是唯一的。
- en: 'Exercise 1.06: Accessing and Setting Values in a Dictionary'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.06：在字典中访问和设置值
- en: 'In this exercise, we are going to access the elements and set values in a dictionary.
    When working with dictionaries, it''s important to be able to iterate through
    each key-value pair, which will allow you to process the data as needed. To do
    so, let''s go through the following steps:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将访问字典中的元素并设置值。当与字典一起工作时，能够遍历每个键值对非常重要，这将允许你按需处理数据。为此，让我们按照以下步骤进行：
- en: 'To access a value in the dictionary, you must provide the key. Keep in mind
    there is no given order for any pair in the dictionary:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问字典中的值，你必须提供键。请注意，字典中任何一对都没有给定的顺序：
- en: '[PRE67]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Print a particular element from the `stocks` list:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `stocks` 列表中的特定元素：
- en: '[PRE68]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This will return the value associated with it, as follows:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回与之关联的值，如下所示：
- en: '[PRE69]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Set a value using the same method we use to access a value:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与访问值相同的方法设置值：
- en: '[PRE70]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define a blank dictionary and then use the key notation to assign values to
    it:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个空字典，然后使用键标记法为其赋值：
- en: '[PRE71]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2AGFaly](https://packt.live/2AGFaly).
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2AGFaly](https://packt.live/2AGFaly)。
- en: You can also run this example online at [https://packt.live/3d8fyeJ](https://packt.live/3d8fyeJ).
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3d8fyeJ](https://packt.live/3d8fyeJ)上运行此示例。
- en: As we can see, the manipulation techniques of a dictionary are pretty simple.
    Now, just like a list, iterating through a dictionary is very important in order
    to process the data.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，字典的操作技巧相当简单。现在，就像列表一样，遍历字典对于处理数据非常重要。
- en: 'Exercise 1.07: Iterating over a Dictionary'
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.07：遍历字典
- en: 'In this exercise, we are going to iterate over a dictionary and print the values
    and keys. To do so, let''s go through the following steps:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将遍历一个字典并打印其值和键。为此，让我们按照以下步骤进行：
- en: 'Open a new Jupyter Notebook and define a dictionary with the key provided along
    with it. Keep in mind there is no given order for any pair in the dictionary:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook，并定义一个包含键的字典。请注意，字典中任何一对都没有给定的顺序：
- en: '[PRE72]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Remove the `$` character from the `stocks` dictionary:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `stocks` 字典中删除 `$` 字符：
- en: '[PRE73]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output should be as follows:'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE74]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Iterate over the `stocks` dictionary again and split the value into a list
    with price (`val`) and multiplier (`mult`) as separate elements where a single
    value is assigned to each key:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次遍历 `stocks` 字典，并将值拆分为一个列表，其中价格（`val`）和乘数（`mult`）作为单独的元素，每个键分配一个值：
- en: '[PRE75]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output is as follows:'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE76]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Notice the difference between how we did the iteration on the list and how we
    are doing it here. A dictionary always contains a key-value pair, and we always
    need to access the value of any element in a dictionary with its key. In a dictionary,
    all the keys are unique.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在列表上进行的迭代与在这里进行的迭代之间的区别。字典始终包含键值对，我们始终需要使用键来访问字典中任何元素的值。在字典中，所有键都是唯一的。
- en: Note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3db0xZF](https://packt.live/3db0xZF).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3db0xZF](https://packt.live/3db0xZF)。
- en: You can also run this example online at [https://packt.live/2zDFHnU](https://packt.live/2zDFHnU).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2zDFHnU](https://packt.live/2zDFHnU)上运行此示例。
- en: In the next exercise, we will revisit the problem that we encountered with the
    list earlier in this chapter to create a list with unique values. We will look
    at another workaround to fix this problem.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将回顾本章早些时候遇到的列表问题，以创建具有唯一值的列表。我们将查看另一种解决此问题的方法。
- en: 'Exercise 1.08: Revisiting the Unique Valued List Problem'
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.08：重新审视具有唯一值的列表问题
- en: 'In this exercise, we will use the unique nature of a dictionary, and we will
    drop the duplicate values from a list. First, we will create a random list with
    duplicate values. Then, we''ll use the `fromkeys` and `keys` methods of a dictionary
    to create a unique valued list. To do so, let''s go through the following steps:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将利用字典的唯一性，并从列表中删除重复值。首先，我们将创建一个包含重复值的随机列表。然后，我们将使用字典的`fromkeys`和`keys`方法来创建一个唯一值列表。为此，让我们按照以下步骤进行：
- en: 'First, generate a random list with duplicate values:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，生成一个包含重复值的随机列表：
- en: '[PRE77]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create a unique valued list from `list_1`:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`list_1`创建一个唯一值列表：
- en: '[PRE78]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The sample output is as follows:'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 样本输出如下：
- en: '![Figure 1.18: Output showing the unique valued list'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.18：显示唯一值列表的输出'
- en: '](img/B15780_01_18.jpg)'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_01_18.jpg]'
- en: 'Figure 1.18: Output showing the unique valued list'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18：显示唯一值列表的输出
- en: Note
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The output is susceptible to change since we are generating random numbers.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能会变化，因为我们正在生成随机数。
- en: Here, we have used two useful methods of the `dict` data type in Python, `fromkeys`
    and `keys`. `fromkeys` is a built-in function in which a new dictionary is created
    from the given sequence of elements with values given by the user, while the `keys`
    method gives us the keys of a dictionary.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了Python中`dict`数据类型的两个有用的方法，`fromkeys`和`keys`。`fromkeys`是一个内置函数，它可以从给定的元素序列创建一个新的字典，用户可以指定值，而`keys`方法则给出了字典的键。
- en: Note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2URp6EA](https://packt.live/2URp6EA).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2URp6EA](https://packt.live/2URp6EA)。
- en: You can also run this example online at [https://packt.live/2UTCFmO](https://packt.live/2UTCFmO).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2UTCFmO](https://packt.live/2UTCFmO)上在线运行此示例。
- en: 'Exercise 1.09: Deleting a Value from Dict'
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.09：从Dict中删除值
- en: 'In this exercise, we are going to delete a value from `dict` using the `del`
    method. Perform the following steps:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`del`方法从`dict`中删除一个值。请执行以下步骤：
- en: 'Create `list_1` with five elements:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含五个元素的`list_1`：
- en: '[PRE79]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We will use the `del` function and specify the element we want to delete:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`del`函数并指定要删除的元素：
- en: '[PRE81]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output is as follows:'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE82]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s delete `key3` and `key4`:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们删除`key3`和`key4`：
- en: '[PRE83]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let''s print the dictionary to see its content:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打印字典以查看其内容：
- en: '[PRE84]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output should be as follows:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该是这样的输出：
- en: '[PRE85]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Nb3oqF](https://packt.live/2Nb3oqF).
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2Nb3oqF](https://packt.live/2Nb3oqF)。
- en: You can also run this example online at [https://packt.live/30Os7ct](https://packt.live/30Os7ct).
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/30Os7ct](https://packt.live/30Os7ct)上在线运行此示例。
- en: In this exercise, we learned how to delete elements from a dictionary. This
    is a very useful functionality of dictionaries, and you will find that it's used
    heavily when writing Python applications.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何从字典中删除元素。这是字典的一个非常有用的功能，你会在编写Python应用程序时发现它被大量使用。
- en: Note
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `del` operator can be used to delete a specific index from a list as well.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`del`运算符也可以用来从列表中删除一个特定的索引。'
- en: In our final exercise on `dict`, we will go over a less commonly used list comprehension
    called `dict`, which can be very useful for processing dictionaries in one line.
    There could be cases where this could be used as a range of key-value pairs of
    name and age or credit card number and credit card owner. A dictionary comprehension
    works exactly the same way as list comprehension, but we need to specify both
    the key and the value.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关于`dict`的最后一个练习中，我们将回顾一个不太常用的列表推导式，称为`dict`推导式，它对于一行内处理字典非常有用。可能存在这种情况，它可以用作姓名和年龄或信用卡号和信用卡所有者的键值对的范围。字典推导式的工作方式与列表推导式完全相同，但我们需要指定键和值。
- en: 'Exercise 1.10: Dictionary Comprehension'
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.10：字典推导式
- en: 'In this exercise, we will generate a dictionary using the following steps:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将按照以下步骤生成一个字典：
- en: 'Generate a `dict` that has `0` to `9` as the keys and the square of the key
    as the values:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个键为`0`到`9`，值为键的平方的`dict`：
- en: '[PRE86]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is as follows:'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE87]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Can you generate a `dict` using `dict` comprehension without using a list? Let's
    try this now.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你能否在不使用列表的情况下使用`dict`推导式来生成一个`dict`？现在让我们试试。
- en: 'Generate a `dictionary` using the `dict` function:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dict`函数生成一个`dictionary`：
- en: '[PRE88]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output is as follows:'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE89]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You can also a `dictionary` using the `dict` function, as follows:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以使用`dict`函数创建一个`字典`，如下所示：
- en: '[PRE90]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output is as follows:'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE91]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3hz8zPp](https://packt.live/3hz8zPp).
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3hz8zPp](https://packt.live/3hz8zPp)。
- en: You can also run this example online at [https://packt.live/3hA8WJw](https://packt.live/3hA8WJw).
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hA8WJw](https://packt.live/3hA8WJw)上在线运行此示例。
- en: Dictionaries are very flexible and can be used for a variety of tasks. The compact
    nature of comprehension makes them very popular. The strange-looking pair of values
    that just looked at (`'Harry', 300`) is called a tuple. This is another important
    fundamental data type in Python. We will learn about tuples in the next section.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 字典非常灵活，可以用于各种任务。理解简洁的特性使它们非常受欢迎。刚刚看到的看起来很奇怪的值对（`'Harry', 300`）被称为元组。这是Python中另一个重要的基本数据类型。我们将在下一节中学习元组。
- en: Tuples
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: A tuple is another data type in Python. Tuples in Python are similar to lists,
    with one key difference. A tuple is a variant of a Python list that is immutable.
    Immutable basically means you can't modify it by adding or removing from the list.
    It is sequential in nature and similar to lists.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是Python中的另一种数据类型。Python中的元组与列表类似，有一个关键的区别。元组是Python列表的一个不可变变体。不可变基本上意味着你不能通过添加或从列表中删除来修改它。它是顺序性的，类似于列表。
- en: 'A tuple consists of values separated by commas, as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 元组由逗号分隔的值组成，如下所示：
- en: '[PRE92]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Notice that, unlike lists, we did not open and close square brackets here.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与列表不同，我们在这里没有使用方括号打开和关闭。
- en: When referring to a tuple, the length of the tuple is called its **cardinality**.
    This comes from database and set theory and is a common way to reference its length.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用元组时，元组的长度被称为其**基数**。这来自数据库和集合理论，是引用其长度的常见方式。
- en: Creating a Tuple with Different Cardinalities
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建不同基数的元组
- en: 'This is how we create an empty tuple:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们创建空元组的方法：
- en: '[PRE93]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This is how we create a tuple with only one value:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们创建只有一个值的元组的方法：
- en: '[PRE94]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Notice the trailing comma here.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的尾随逗号。
- en: 'We can nest tuples, similar to lists and dicts, as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以嵌套元组，类似于列表和字典，如下所示：
- en: '[PRE95]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'One special thing about tuples is the fact that they are an immutable data
    type. So, once they''re created, we cannot change their values. We can just access
    them, as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的一个特别之处在于，它们是不可变的数据类型。因此，一旦创建，我们无法更改它们的值。我们只能像以下这样访问它们：
- en: '[PRE96]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The last line of the preceding code will result in a `TypeError` as a tuple
    does not allow modification.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的最后一行会导致`TypeError`，因为元组不允许修改。
- en: This makes the use case for tuples a bit different than lists, although they
    look and behave very similarly in a few ways.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得元组的使用案例在某种程度上与列表不同，尽管它们在几个方面看起来和行为非常相似。
- en: 'We can access the elements of a tuple in the same manner we can for lists:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用与列表相同的方式访问元组的元素：
- en: '[PRE97]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output is as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE98]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Let''s access another element:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们访问另一个元素：
- en: '[PRE99]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output will be:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE100]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Unpacking a Tuple
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包元组
- en: 'The expression "unpacking a tuple" simply means getting the values contained
    in the tuple in different variables:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式“解包元组”简单地说就是获取元组中包含的值到不同的变量中：
- en: '[PRE101]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The output is as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE102]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Of course, as soon as we do that, we can modify the values contained in those variables.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦我们这样做，我们就可以修改这些变量中的值。
- en: 'Exercise 1.11: Handling Tuples'
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.11：处理元组
- en: 'In this exercise, we will walk through the basic functionalities of tuples.
    Let''s go through the steps one by one:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将逐步介绍元组的基本功能。让我们一步一步来：
- en: 'Create a tuple to demonstrate how tuples are immutable. Unpack it to read all
    the elements, as follows:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个元组来演示元组是不可变的。解包它以读取所有元素，如下所示：
- en: '[PRE103]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output is as follows:'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE104]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Try to override a variable from the `tupleE` tuple:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试覆盖`tupleE`元组中的一个变量：
- en: '[PRE105]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This step will result in `TypeError` as the tuple does not allow modification.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一步会导致`TypeError`，因为元组不允许修改。
- en: '[PRE106]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Try to assign a series to the `tupleE` tuple:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将一系列值赋给`tupleE`元组：
- en: '[PRE107]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This step will also result in a `SyntaxError`, stating that it can''t assign
    to the literal:'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一步也会导致一个`SyntaxError`，指出它不能赋值给字面量：
- en: '[PRE108]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Print variables at `0`th and `1`st positions:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印第`0`个和第`1`个位置的变量：
- en: '[PRE109]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The output is as follows:'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE110]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3ebuvOf](https://packt.live/3ebuvOf).
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅 [https://packt.live/3ebuvOf](https://packt.live/3ebuvOf)。
- en: You can also run this example online at [https://packt.live/2URh9zo](https://packt.live/2URh9zo).
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/2URh9zo](https://packt.live/2URh9zo) 上在线运行此示例。
- en: We have seen two different types of data so far. One is represented by numbers,
    while the other is represented by textual data. Now it's time to look into textual
    data in a bit more detail.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种不同的数据类型。一种由数字表示，另一种由文本数据表示。现在我们更详细地了解一下文本数据。
- en: Strings
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: In the final section of this chapter, we will learn about strings. Strings in
    Python are similar to strings in any other programming language.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将学习字符串。Python 中的字符串与其他编程语言中的字符串类似。
- en: 'This is a string:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个字符串：
- en: '[PRE111]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'A string can also be declared in this manner:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也可以用这种方式声明：
- en: '[PRE112]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: You can use single quotes and double quotes to define a string.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用单引号和双引号来定义一个字符串。
- en: 'The start and end of a string is defined as:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的开始和结束定义为：
- en: '[PRE113]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Strings in Python behave similar to lists, apart from one big caveat. Strings
    are immutable, whereas lists are mutable data structures.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的字符串行为类似于列表，除了一个重要的注意事项。字符串是不可变的，而列表是可变的数据结构。
- en: 'Exercise 1.12: Accessing Strings'
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.12：访问字符串
- en: 'In this exercise, we are going perform mathematical operations to access strings.
    Let''s go through the following steps:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将执行数学运算来访问字符串。让我们按以下步骤进行：
- en: 'Create a string called `str_1`:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `str_1` 的字符串：
- en: '[PRE114]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output is as follows:'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE115]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You can access the elements of the string by specifying the location of the
    element, like we did for lists.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过指定元素的位置来访问字符串的元素，就像我们处理列表一样。
- en: 'Access the first member of the string:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字符串的第一个成员：
- en: '[PRE116]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE117]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Access the fifth member of the string:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字符串的第五个成员：
- en: '[PRE118]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The output is as follows:'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE119]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Access the last member of the string:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字符串的最后一个成员：
- en: '[PRE120]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output is as follows:'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE121]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Access the last member of the string, in a different way this time:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以不同的方式访问字符串的最后一个成员：
- en: '[PRE122]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is as follows:'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE123]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Note
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YHEmF9](https://packt.live/2YHEmF9).
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅 [https://packt.live/2YHEmF9](https://packt.live/2YHEmF9)。
- en: You can also run this example online at [https://packt.live/3db191p](https://packt.live/3db191p).
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/3db191p](https://packt.live/3db191p) 上在线运行此示例。
- en: Each of the preceding operations will give you the character at the specific
    index. The method for accessing the elements of a string is like accessing a list.
    Let's do a couple of more exercises to manipulate strings.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个操作都会给你特定索引处的字符。访问字符串元素的方法类似于访问列表。让我们再做一些练习来操作字符串。
- en: 'Exercise 1.13: String Slices'
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.13：字符串切片
- en: This exercise will demonstrate how we can slice strings the same way as we did
    with lists. Although strings are not lists, the functionality will work in the
    same way.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示我们如何像处理列表一样切片字符串。尽管字符串不是列表，但功能将以相同的方式工作。
- en: 'Let''s go through the following steps:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下步骤进行：
- en: 'Create a string, `str_1`:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串，`str_1`：
- en: '[PRE124]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output is as follows:'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE125]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Specify the slicing values and slice the string:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定切片值并切片字符串：
- en: '[PRE126]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The output is as follows:'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE127]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Slice a string by skipping a slice value:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过跳过切片值来切片字符串：
- en: '[PRE128]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The output is as follows:'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE129]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Use negative numbers to slice the string:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用负数来切片字符串：
- en: '[PRE130]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The output is as follows:'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE131]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Note
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2N70Bis](https://packt.live/2N70Bis).
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅 [https://packt.live/2N70Bis](https://packt.live/2N70Bis)。
- en: You can also run this example online at [https://packt.live/3d6X9Pu](https://packt.live/3d6X9Pu).
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/3d6X9Pu](https://packt.live/3d6X9Pu) 上在线运行此示例。
- en: As we can see, it is quite simple to manipulate strings with basic operations.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用基本操作来操作字符串相当简单。
- en: String Functions
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串函数
- en: 'To find out the length of a string, we simply use the `len` function:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出字符串的长度，我们只需使用 `len` 函数：
- en: '[PRE132]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The length of the string is `41`. To convert a string''s case, we can use the
    `lower` and `upper` methods:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的长度是 `41`。要转换字符串的大小写，我们可以使用 `lower` 和 `upper` 方法：
- en: '[PRE133]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The output is as follows:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE134]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'To change the case of the string, use the following code:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改字符串的大小写，请使用以下代码：
- en: '[PRE135]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The output is as follows:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE136]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'To search for a string within a string, we can use the `find` method:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符串中搜索一个字符串，我们可以使用`find`方法：
- en: '[PRE137]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The output is `-1`. Can you figure out whether the `find` method is case-sensitive
    or not? Also, what do you think the `find` method returns when it actually finds
    the string?
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`-1`。你能弄清楚`find`方法是否区分大小写吗？你认为`find`方法在找到字符串时实际上返回了什么？
- en: 'To replace one string with another, we have the `replace` method. Since we
    know that a string is an immutable data structure, `replace` actually returns
    a new string instead of replacing and returning the actual one:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 要用另一个字符串替换一个字符串，我们有`replace`方法。由于我们知道字符串是一个不可变的数据结构，`replace`实际上返回一个新的字符串，而不是替换并返回实际的字符串：
- en: '[PRE138]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output is as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE139]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Note
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should look up string methods in the standard documentation of Python 3
    to discover more about these methods. Visit [https://docs.python.org/3.7/](https://docs.python.org/3.7/).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在Python 3的标准文档中查找字符串方法，以了解更多关于这些方法的信息。访问[https://docs.python.org/3.7/](https://docs.python.org/3.7/)。
- en: 'Strings have two useful methods: `split` and `join`. Here are their definitions:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有两个有用的方法：`split`和`join`。以下是它们的定义：
- en: '[PRE140]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `seperator` argument is a delimiter that you define:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`seperator`参数是你定义的分隔符：'
- en: '[PRE141]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Let's take a look at the following exercise to practice the `split` and `join` functionalities.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下练习来练习`split`和`join`功能。
- en: 'Exercise 1.14: Splitting and Joining a String'
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.14：拆分和连接字符串
- en: 'This exercise will demonstrate how to perform split and join operations on
    a string. These two string methods need separate approaches as they allow you
    to convert a string into a list and vice versa. Let''s go through the following
    steps to do so:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习将演示如何在字符串上执行拆分和连接操作。这两个字符串方法需要分别处理，因为它们允许你将字符串转换为列表，反之亦然。让我们按照以下步骤进行：
- en: 'Create a string and convert it into a list using the `split` method:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串，并使用`split`方法将其转换为列表：
- en: '[PRE142]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The preceding code will give you a list similar to the following:'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将给出一个类似于以下列表：
- en: '[PRE143]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Combine this list into another string using the `join` method:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join`方法将此列表组合成另一个字符串：
- en: '[PRE144]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'This code will give you a string like this:'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将给出一个类似于以下字符串：
- en: '[PRE145]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2N1lprE](https://packt.live/2N1lprE).
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2N1lprE](https://packt.live/2N1lprE)。
- en: You can also run this example online at [https://packt.live/2UOOQBC](https://packt.live/2UOOQBC).
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2UOOQBC](https://packt.live/2UOOQBC)上在线运行此示例。
- en: With these, we are at the end of the second topic of this chapter. Now, we have
    the motivation to learn about data wrangling and have had a solid introduction
    to the fundamentals of data structures using Python. There is more to this topic,
    which will be covered in *Chapter 2*, *Advanced Operation on Built-In Data Structures*.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们结束了本章的第二主题。现在，我们有学习数据整理的动机，并且已经对使用Python的数据结构基础有了坚实的了解。这个主题还有更多内容，将在*第2章*，*内置数据结构的先进操作*中介绍。
- en: The next section will ensure that you have understood the various basic types
    of data structures and their manipulation techniques. We will do that by going
    through an activity that has been designed specifically for this purpose.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将确保你已经理解了各种基本数据结构及其操作技术。我们将通过一个专门为此目的设计的活动来实现这一点。
- en: 'Activity 1.02: Analyzing a Multiline String and Generating the Unique Word
    Count'
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.02：分析多行字符串并生成唯一单词计数
- en: 'In this activity, you will do the following:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将执行以下操作：
- en: Get multiline text and save it in a Python variable.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取多行文本并将其保存在Python变量中。
- en: Get rid of all new lines in it using string methods.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串方法去除所有换行符。
- en: Get all the unique words and their occurrences from the string.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中获取所有唯一的单词及其出现次数。
- en: Repeat the steps to find all unique words and occurrences, without considering
    case sensitivity.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复以下步骤以找到所有唯一的单词及其出现次数，不考虑大小写敏感性。
- en: Note
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity, the original text (which can be found at [https://www.gutenberg.org/files/1342/1342-h/1342-h.htm](https://www.gutenberg.org/files/1342/1342-h/1342-h.htm))
    has been pre-processed  bit.
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简化，原始文本（可在[https://www.gutenberg.org/files/1342/1342-h/1342-h.htm](https://www.gutenberg.org/files/1342/1342-h/1342-h.htm)找到）已经预先处理过。
- en: 'These are the steps to guide you through solving this activity:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将指导你解决此活动：
- en: Create a `mutliline_text` variable by copying the text from the first chapter
    of *Pride and Prejudice*.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制《傲慢与偏见》的第一章文本来创建一个 `mutliline_text` 变量。
- en: '**Hint**: Remember to add triple quotation marks to enter a multiline text.
    This is the only way to enter a chunk of text in Python.'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：记得添加三引号来输入多行文本。这是在 Python 中输入文本块的唯一方法。'
- en: Note
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Part of the first chapter of *Pride and Prejudice* by Jane Austen has been made
    available on this book's GitHub repository at [https://packt.live/2N6ZGP6](https://packt.live/2N6ZGP6).
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简·奥斯汀的《傲慢与偏见》的第一部分可在本书的 GitHub 仓库中找到，网址为 [https://packt.live/2N6ZGP6](https://packt.live/2N6ZGP6)。
- en: Find the type and length of the `multiline_text` string using the `type` and
    `len` commands.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `type` 和 `len` 命令查找 `multiline_text` 字符串的类型和长度。
- en: Remove all new lines and symbols using the `replace` method.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `replace` 方法删除所有换行符和符号。
- en: Find all of the words in `multiline_text` using the `split` method.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `split` 方法在 `multiline_text` 中查找所有单词。
- en: Create a list from this list that will contain only the unique words.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个列表中创建一个列表，其中只包含唯一的单词。
- en: Count the number of times the unique word has appeared in the list using the
    `key` and `value` in `dict`.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dict` 中的 `key` 和 `value` 计算唯一单词在列表中出现的次数。
- en: Find the top 25 words from the unique words that you have found using the `slice`
    method.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `slice` 方法从您找到的唯一单词中找到前 25 个单词。
- en: 'The output is as follows:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.19: Top 25 words from the unique list'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19：独特列表中的前 25 个单词'
- en: '](img/B15780_01_19.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19：独特列表中的前 25 个单词'
- en: 'Figure 1.19: Top 25 words from the unique list'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19：独特列表中的前 25 个单词
- en: Note
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor305).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可通过 [此链接](B15780_Solution_Final_RK.xhtml#_idTextAnchor305) 获取。
- en: Summary
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about data wrangling and looked at examples from
    various real-life data science situations where data wrangling is very useful.
    We moved on to learn about the different built-in data structures that Python
    has to offer. We got our hands dirty by exploring lists, sets, dictionaries, tuples,
    and strings. These are the fundamental building blocks of Python data structures,
    and we need them all the time when working and manipulating data in Python. We
    did several small hands-on exercises to learn more about them. We finished this
    chapter with carefully designed activities that let us combine a lot of different
    tricks from all the different data structures and let us observe the interplay
    between all of them. In the next chapter, we will learn about the data structures
    in Python and utilize them to solve problems.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了数据处理，并探讨了各种实际数据科学场景中的示例，在这些场景中数据处理非常有用。我们继续学习 Python 提供的不同内置数据结构。我们通过探索列表、集合、字典、元组和字符串来亲身体验。这些是
    Python 数据结构的基本构建块，我们在用 Python 工作和操作数据时需要它们。我们进行了几个小型的动手练习来了解更多关于它们的信息。我们通过精心设计的活动结束本章，这些活动让我们结合了来自所有不同数据结构的许多技巧，并让我们观察它们之间的相互作用。在下一章中，我们将学习
    Python 中的数据结构，并利用它们来解决问题。
