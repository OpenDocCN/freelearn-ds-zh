- en: 1\. Introduction to Data Wrangling with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you understand the importance of data wrangling in data
    science. You will gain practical knowledge of how to manipulate the data structures
    that are available in Python by comparing the different implementations of the
    built-in Python data structures. Overall, this chapter describes the importance
    of data wrangling, identifies the important tasks to be performed in data wrangling,
    and introduces basic Python data structures. By the end of this chapter, you will
    be adept at working with lists, sets, and dictionaries, which are the key building
    blocks of data structures in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since data science and analytics have become key parts of our lives, the role
    of a data scientist has become even more important. Finding the source of data
    is an essential part of data science; however, it is the *science* part that makes
    you – the practitioner – truly valuable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To practice high-quality science with data, you need to make sure it is properly
    sourced, cleaned, formatted, and pre-processed. This book will teach you the most
    essential basics of this invaluable component of the data science pipeline: data
    wrangling. In short, data wrangling is the process that ensures that the data
    is being presented in a way that is clean, accurate, formatted, and ready to be
    used for data analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: A prominent example of data wrangling with a large amount of data is the analysis
    conducted at the Supercomputer Center of the **University of California San Diego**
    (**UCSD**) every year. Wildfires are very common in California and are caused
    mainly by the dry weather and extreme heat, especially during the summers. Data
    scientists at the UCSD Supercomputer Center run an analysis every year and gather
    data to predict the nature and spread direction of wildfires in California. The
    data comes from diverse sources, such as weather stations, sensors in the forest,
    fire stations, satellite imagery, and Twitter feeds. However, this data might
    be incomplete or missing.
  prefs: []
  type: TYPE_NORMAL
- en: After collecting the data from various sources, if it is not cleaned and formatted
    using ways including scaling numbers and removing unwanted characters in strings,
    it could result in erroneous data. In cases where we might get a flawed analysis,
    we might need to reformat the data from **JavaScript Object Notation** (**JSON**)
    into **Comma Separated Value** (**CSV**); we may also need the numbers to be normalized,
    that is, centered and scaled with relation to themselves. Processing data in such
    a way might be required when we feed data to certain machine learning models.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of how data wrangling and data science can prove to be helpful
    and relevant. This chapter will discuss the fundamentals of data wrangling. Let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of Data Wrangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common mantra of the modern age is *Data is the New Oil*, meaning data is
    now a resource that's more valuable than oil. But just as crude oil does not come
    out of the rig as gasoline and must be processed to get gasoline and other products,
    data must be curated, massaged, or cleaned and refined to be used in data science
    and products based on data science. This is known as wrangling. Most data scientists
    spend the majority of their time data wrangling.
  prefs: []
  type: TYPE_NORMAL
- en: Data wrangling is generally done at the very first stage of a data science/analytics
    pipeline. After the data scientists have identified any useful data sources for
    solving the business problem at hand (for instance, in-house database storage,
    the internet, or streaming sensor data such as an underwater seismic sensor),
    they then proceed to extract, clean, and format the necessary data from those
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the task of data wrangling involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Scraping raw data from multiple sources (including web and database tables)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imputing (replacing missing data using various techniques), formatting, and
    transforming – basically making it ready to be used in the modeling process (such
    as advanced machine learning)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling read/write errors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detecting outliers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performing quick visualizations (plotting) and basic statistical analysis to
    judge the quality of formatted data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is an illustrative representation of the positioning and the
    essential functional role of data wrangling in a typical data science pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Process of data wrangling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: Process of data wrangling'
  prefs: []
  type: TYPE_NORMAL
- en: The process of data wrangling includes finding the appropriate data that's necessary
    for the analysis. Often, analysis is exploratory, so there is not enough scope.
    You often need to do data wrangling for this type of analysis to be able to understand
    your data better. This could lead to more analysis or machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: This data can be from one or multiple sources, such as tweets, bank transaction
    statements in a relational database, sensor data, and so on. This data needs to
    be cleaned. If there is missing data, we will either delete or substitute it,
    with the help of several techniques. If there are outliers, we need to detect
    them and then handle them appropriately. If the data is from multiple sources,
    we will have to combine it using Structured Query Language (SQL) operations like
    JOIN.
  prefs: []
  type: TYPE_NORMAL
- en: In an extremely rare situation, data wrangling may not be needed. For example,
    if the data that's necessary for a machine learning task is already stored in
    an acceptable format in an in-house database, then a simple SQL query may be enough
    to extract the data into a table, ready to be passed on to the modeling stage.
  prefs: []
  type: TYPE_NORMAL
- en: Python for Data Wrangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is always a debate regarding whether to perform the wrangling process
    using an enterprise tool or a programming language and its associated frameworks.
    There are many commercial, enterprise-level tools for data formatting and preprocessing
    that do not involve much coding on the user''s part. Some of these examples include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: General-purpose data analysis platforms, such as **Microsoft Excel** (with add-ins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistical discovery package, such as **JMP** (from SAS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling platforms, such as **RapidMiner**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analytics platforms from niche players that focus on data wrangling, such as
    **Trifacta**, **Paxata**, and **Alteryx**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, programming languages such as Python and R provide more flexibility,
    control, and power compared to these off-the-shelf tools. This also explains their
    tremendous popularity in the data science domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Google trends worldwide over the last 5 years'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: Google trends worldwide over the last 5 years'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as the volume, velocity, and variety (the three Vs of **big data**)
    of data undergo rapid changes, it is always a good idea to develop and nurture
    a significant amount of in-house expertise in data wrangling using fundamental
    programming frameworks so that an organization is not beholden to the whims and
    fancies of any particular enterprise platform for as basic a task as data wrangling.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few of the obvious advantages of using an open source, free programming paradigm
    for data wrangling are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A general-purpose open-source paradigm puts no restrictions on any of the methods
    you can develop for the specific problem at hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a great ecosystem of fast, optimized, open-source libraries, focused
    on data analytics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's also growing support for connecting Python to every conceivable data
    source type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's an easy interface to basic statistical testing and quick visualization
    libraries to check data quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And there's a seamless interface of the data wrangling output with advanced
    machine learning models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is the most popular language for machine learning and artificial intelligence
    these days. Let's take a look at a few data structures in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Lists, Sets, Strings, Tuples, and Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have touched upon a few advantages of using Python, we will start
    by exploring various basic data structures in Python. We will also learn about
    a few techniques we can use to handle these data structures. This is invaluable
    for a data practitioner.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are fundamental Python data structures that have continuous memory locations
    and can host different data types (such as strings, numbers, floats, and doubles)
    and can be accessed by the index.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a list and list comprehension. A list comprehension is a
    syntactic sugar (or shorthand) for a `for` loop, which iterates over a list. We
    will generate a list of numbers, and then examine which ones among them are even.
    We will sort, reverse, and check for duplicates. We will also see the different
    ways we can access the list elements, iterating over them and checking the membership
    of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a simple list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is also an example of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a list can contain any number of the allowed data types, such
    as `int`, `float`, `string`, and `boolean`, and a list can also be a mix of different
    data types (including nested lists).
  prefs: []
  type: TYPE_NORMAL
- en: If you are coming from a strongly typed language, such as C, C++, or Java, then
    this will probably be strange as you are not allowed to mix different kinds of
    data types in a single array in those languages. Lists in Python are loosely typed,
    that is, they are not restricted to a single type. Lists are somewhat like arrays
    in the sense that they are both based on continuous memory locations and can be
    accessed using indexes. But the power of Python lists comes from the fact that
    they can host different data types and you are allowed to manipulate the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, there is a concept of creating a slice of a list. Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Known as `0` to `1` minus the total length. The first number given represents
    the first position to include in the slice. The second number is used to indicate
    which place you want to stop at, but not include. A slice can have an index of
    `–1` to indicate the last element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The indices will be automatically assigned, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: List showing the forward and backward indices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: List showing the forward and backward indices'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful, though, as the very power of lists, and the fact that you can mix
    different data types in a single list, can actually create subtle bugs that can
    be very difficult to track.
  prefs: []
  type: TYPE_NORMAL
- en: List Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss a few basic functions for handling lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access list elements using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out the length of a list, we simply use the `len` function. The `len`
    function in Python returns the length of the specified list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can append new elements in the list. `append` is a built-in method in Python
    for the list data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through some exercises to practice these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.01: Accessing the List Members'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be reading a list of social security numbers from
    the `ssn.csv` file and then observing the different ways of accessing the elements
    from the list using the forward and backward indices. We will be using our first
    Python function, `len`, which will return the length of the specified list. We
    will be starting with the basic building blocks for future exercises. Let''s go
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ssn.csv` file can be found here: [https://packt.live/2AydLCx](https://packt.live/2AydLCx).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Jupyter Notebook and define a list called `ssn`. Read from the `ssn.csv`
    file using the `read_csv` command and print the list elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the first element of `ssn` using its forward index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the fourth element of `ssn` using its forward index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last element of `ssn` using the `len` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last element of `ssn` using its backward index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the first three elements of `ssn` using forward indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last two elements of `ssn` by slicing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the first two elements using backward indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.4: Output after using backward indices'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.4: Output after using backward indices'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we leave one side of the colon (`:`) blank, we are basically telling Python
    either to go until the end or start from the beginning of the list. It will automatically
    apply the rule of list slices that we just learned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Reverse the elements in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.5: Output after elements are reversed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.5: Output after elements are reversed'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3fzTvzk](https://packt.live/3fzTvzk).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YF3zA0](https://packt.live/2YF3zA0).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to access the list members with forward and
    backward indices. We'll create a list in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.02: Generating and Iterating through a List'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to examine various ways of generating a list
    and a nested list using the same file containing the list of social security numbers
    (`ssn.csv`) that we used in the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ssn.csv` file can be found here: [https://packt.live/2AydLCx](https://packt.live/2AydLCx).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `append` method to add new elements to the list and
    a `while` loop to iterate through the list. To do so, let''s go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Jupyter Notebook and import the necessary Python libraries. Read
    from the `ssn.csv` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list using the `append` method. The `append` method from the Python
    library will allow you to add items to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.6: Output after creating a list using the append method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.6: Output after creating a list using the append method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we started by declaring an empty list called `ssn_2`, and then we used
    a `for` loop to append values to it after reading from the `ssn.csv` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a list using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.7: Output of a generated list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.7: Output of a generated list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is list comprehension, which is a very powerful tool that we need to master.
    The power of list comprehension comes from the fact that we can use conditionals
    such as `for..in` inside the comprehension itself. This will be discussed in detail
    in *Chapter 2, Advanced Operations on Built-in Data Structures*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use a `while` loop to iterate over the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Search all the social security numbers with the number `5` in them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.8: SSNs with the number 5 in them'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.8: SSNs with the number 5 in them'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's explore a few more list operations. We are going to use the `+` operator
    to add the contents of two lists and use the `extend` keyword to replace the contents
    of the existing list with another list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a list by adding the two lists. Here, we will just use the `+` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.9: Generated list by adding two lists'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.9: Generated list by adding two lists'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extend a string using the `extend` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.10: The extend string operation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.10: The extend string operation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `extend` operation changes the original list (`ssn_2`) and appends all the
    elements of `ssn_4` to it. So, be careful while using it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s loop over the first list and create a nested list inside that loop
    that goes over the second list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output (partially shown) is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.11: Partial output of ssn'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.11: Partial output of ssn'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Y6vObR](https://packt.live/2Y6vObR).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YLJybf](https://packt.live/2YLJybf).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used the built-in methods of Python to manipulate lists.
    In the next exercise, we'll check whether the elements or members in a dataset
    are present as per our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.03: Iterating over a List and Checking Membership'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will demonstrate how we can iterate over a list and verify that
    the values are as expected. This is a manual test that can often be done while
    dealing with a reasonably sized dataset for business case scenarios. Let''s go
    through the following steps to check the membership of values and whether they
    exist in the `.csv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `car_models.csv` file can be found at [https://packt.live/3d8DUVy](https://packt.live/3d8DUVy).
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary Python libraries and read from the `car_models.csv` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate over a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, this is not very Pythonic. Being Pythonic means to follow and conform
    to a set of best practices and conventions that have been created over the years
    by thousands of capable developers. In this case, this means we could use the
    `in` keyword in the `for..in` conditional because Python does not have index initialization,
    bounds checking, or index incrementing, unlike traditional languages. Python uses
    syntactic sugar to make iterating through lists easy and readable. In other languages,
    you might have to create a variable (index initialization) as you loop over the
    list check that variable (bounds checking) since it will be incremented in the
    loop (index incrementing).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the following code to see the Pythonic way of iterating over a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that in the second method, we do not need a counter anymore to access
    the list index; instead, Python's `in` operator gives us the element at the `i`th
    position directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check whether the strings `D150` and `Mustang` are in the list using the `in` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is `True`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is `False`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/30TpGp5](https://packt.live/30TpGp5).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2Y8z06L](https://packt.live/2Y8z06L).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we've seen how to iterate over a list and verified the membership
    of each element. This is an important skill. Often, when working with large applications,
    manually checking a list could be useful. If at any time you are unsure of a list,
    you can easily verify what values are present. Now, we will see how we can perform
    a sort operation on a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.04: Sorting a List'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will sort a list of numbers, first by using the `sort`
    method and then by using the `reverse` method. To do so, let''s go through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ssn.csv` file can be found here: [https://packt.live/2AydLCx](https://packt.live/2AydLCx).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Jupyter Notebook and import the necessary Python libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `sort` method with `reverse=True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `reverse` method directly to achieve this result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Y7HlYe](https://packt.live/2Y7HlYe).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YGNvOd](https://packt.live/2YGNvOd).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The difference between the `sort` method and the `reverse` method is that we
    can use `sort` with customized sorting, whereas we can only use `reverse` to reverse
    a list. Also, both methods work in-place, so be aware of this while using them.
    Now, let's create a list with random numbers. Random numbers can be very useful
    in a variety of situations and preprocessing data is a common process in machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.05: Generating a Random List'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be generating a `list` with random numbers using
    the `random` library in Python and performing mathematical operations on them.
    To do so, let''s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `random` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `randint` method to generate some random integers and add them to a
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s print the list. Note that there will be duplicate values in `list_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output (partially shown) is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.12: List of random numbers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.12: List of random numbers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The output will vary with every run since we are generating random numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s find the square of each element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.13: List of random numbers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.13: List of random numbers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s find the log of the `1` elements of `list_2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output (partially shown) is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.14: Partial output for list_2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.14: Partial output for list_2'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The output is susceptible to change since we are generating random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/37BerTD](https://packt.live/37BerTD).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3hHwlsH](https://packt.live/3hHwlsH).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we worked on random variables, lists comprehension, and preprocessing
    data. Let's put what we have learned so far together and go through an activity
    to practice how to handle lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.01: Handling Lists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will generate a list of random numbers and then generate
    another list from the first one, which only contains numbers that are divisible
    by three. Repeat the experiment 10 times; you'll see that the output varies each
    time, given that a different set of random numbers will be generated each time.
    Then, you will calculate the average difference between the lengths of the two
    lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps for completing this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `list` of `100` random numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `list` from this random `list`, with numbers that are divisible
    by `3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the length of these two lists and store the difference in a new variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a loop, perform steps 1, 2, and 3, and find the difference variable 10
    times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the arithmetic mean of these `10` difference values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output (will vary with each run) should look similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor304).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set, mathematically speaking, is just a collection of well-defined distinct
    objects. Python gives us a straightforward way to deal with them using its set
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the last list that we generated in the previous section; we are going
    to revisit the problem of getting rid of duplicates from it. We can achieve that
    with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print this, we will see that it only contains unique numbers. We used
    the **set** data type to turn the first list into a set, thus getting rid of all
    duplicate elements, and then used the **list** function to turn it into a list
    from a set once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15: Section of output for list_12'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_01_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.15: Section of output for list_12'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss the union and intersection of sets.
  prefs: []
  type: TYPE_NORMAL
- en: Union and Intersection of Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In mathematical terms, a list of unique objects is a set. There are many ways
    of combining sets in the same mathematical term. One such way is the use of a
    union.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a union between two sets looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16: Venn diagram showing the union of two sets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_01_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.16: Venn diagram showing the union of two sets'
  prefs: []
  type: TYPE_NORMAL
- en: This simply means taking everything from both sets but only taking the common
    elements once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this concept by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the union of the two sets, the following code should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the common element, `Banana`, appears only once in the resulting
    set. The common elements of two sets can be identified by obtaining the intersection
    of the two sets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17: Venn diagram showing the intersection of two sets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_01_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.17: Venn diagram showing the intersection of two sets'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the intersection of two sets in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us a set with only one element. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also calculate the difference between sets (also known as complements).
    To find out more, refer to this link: https://docs.python.org/3/tutorial/datastructures.html#sets.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through sets and how we can do basic set functionality.
    Sets are used throughout database programming and design, and they are very useful
    for data wrangling.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Null Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In mathematical terms, a set that has nothing inside it is called a null set
    or an empty set.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a null set by creating a set containing no elements. You can
    do this by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to create a dictionary with null values, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We are going to learn about this in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dictionary is like a list, which means it is a collection of several elements.
    However, with the dictionary, it is a collection of key-value pairs, where the
    key can be anything that can fit into memory. Generally, we use numbers or strings
    as keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a dictionary, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also a valid dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The keys must be unique in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.06: Accessing and Setting Values in a Dictionary'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to access the elements and set values in a dictionary.
    When working with dictionaries, it''s important to be able to iterate through
    each key-value pair, which will allow you to process the data as needed. To do
    so, let''s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access a value in the dictionary, you must provide the key. Keep in mind
    there is no given order for any pair in the dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print a particular element from the `stocks` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the value associated with it, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a value using the same method we use to access a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a blank dictionary and then use the key notation to assign values to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2AGFaly](https://packt.live/2AGFaly).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3d8fyeJ](https://packt.live/3d8fyeJ).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we can see, the manipulation techniques of a dictionary are pretty simple.
    Now, just like a list, iterating through a dictionary is very important in order
    to process the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.07: Iterating over a Dictionary'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to iterate over a dictionary and print the values
    and keys. To do so, let''s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Jupyter Notebook and define a dictionary with the key provided along
    with it. Keep in mind there is no given order for any pair in the dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the `$` character from the `stocks` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate over the `stocks` dictionary again and split the value into a list
    with price (`val`) and multiplier (`mult`) as separate elements where a single
    value is assigned to each key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the difference between how we did the iteration on the list and how we
    are doing it here. A dictionary always contains a key-value pair, and we always
    need to access the value of any element in a dictionary with its key. In a dictionary,
    all the keys are unique.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3db0xZF](https://packt.live/3db0xZF).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2zDFHnU](https://packt.live/2zDFHnU).
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will revisit the problem that we encountered with the
    list earlier in this chapter to create a list with unique values. We will look
    at another workaround to fix this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.08: Revisiting the Unique Valued List Problem'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the unique nature of a dictionary, and we will
    drop the duplicate values from a list. First, we will create a random list with
    duplicate values. Then, we''ll use the `fromkeys` and `keys` methods of a dictionary
    to create a unique valued list. To do so, let''s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, generate a random list with duplicate values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a unique valued list from `list_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.18: Output showing the unique valued list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15780_01_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.18: Output showing the unique valued list'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The output is susceptible to change since we are generating random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used two useful methods of the `dict` data type in Python, `fromkeys`
    and `keys`. `fromkeys` is a built-in function in which a new dictionary is created
    from the given sequence of elements with values given by the user, while the `keys`
    method gives us the keys of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2URp6EA](https://packt.live/2URp6EA).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2UTCFmO](https://packt.live/2UTCFmO).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.09: Deleting a Value from Dict'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to delete a value from `dict` using the `del`
    method. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `list_1` with five elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the `del` function and specify the element we want to delete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s delete `key3` and `key4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s print the dictionary to see its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Nb3oqF](https://packt.live/2Nb3oqF).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/30Os7ct](https://packt.live/30Os7ct).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we learned how to delete elements from a dictionary. This
    is a very useful functionality of dictionaries, and you will find that it's used
    heavily when writing Python applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `del` operator can be used to delete a specific index from a list as well.
  prefs: []
  type: TYPE_NORMAL
- en: In our final exercise on `dict`, we will go over a less commonly used list comprehension
    called `dict`, which can be very useful for processing dictionaries in one line.
    There could be cases where this could be used as a range of key-value pairs of
    name and age or credit card number and credit card owner. A dictionary comprehension
    works exactly the same way as list comprehension, but we need to specify both
    the key and the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.10: Dictionary Comprehension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will generate a dictionary using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a `dict` that has `0` to `9` as the keys and the square of the key
    as the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Can you generate a `dict` using `dict` comprehension without using a list? Let's
    try this now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a `dictionary` using the `dict` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also a `dictionary` using the `dict` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3hz8zPp](https://packt.live/3hz8zPp).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3hA8WJw](https://packt.live/3hA8WJw).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dictionaries are very flexible and can be used for a variety of tasks. The compact
    nature of comprehension makes them very popular. The strange-looking pair of values
    that just looked at (`'Harry', 300`) is called a tuple. This is another important
    fundamental data type in Python. We will learn about tuples in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is another data type in Python. Tuples in Python are similar to lists,
    with one key difference. A tuple is a variant of a Python list that is immutable.
    Immutable basically means you can't modify it by adding or removing from the list.
    It is sequential in nature and similar to lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tuple consists of values separated by commas, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, unlike lists, we did not open and close square brackets here.
  prefs: []
  type: TYPE_NORMAL
- en: When referring to a tuple, the length of the tuple is called its **cardinality**.
    This comes from database and set theory and is a common way to reference its length.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Tuple with Different Cardinalities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is how we create an empty tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we create a tuple with only one value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Notice the trailing comma here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can nest tuples, similar to lists and dicts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'One special thing about tuples is the fact that they are an immutable data
    type. So, once they''re created, we cannot change their values. We can just access
    them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the preceding code will result in a `TypeError` as a tuple
    does not allow modification.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the use case for tuples a bit different than lists, although they
    look and behave very similarly in a few ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the elements of a tuple in the same manner we can for lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s access another element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Unpacking a Tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The expression "unpacking a tuple" simply means getting the values contained
    in the tuple in different variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Of course, as soon as we do that, we can modify the values contained in those variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.11: Handling Tuples'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will walk through the basic functionalities of tuples.
    Let''s go through the steps one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a tuple to demonstrate how tuples are immutable. Unpack it to read all
    the elements, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to override a variable from the `tupleE` tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This step will result in `TypeError` as the tuple does not allow modification.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to assign a series to the `tupleE` tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This step will also result in a `SyntaxError`, stating that it can''t assign
    to the literal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print variables at `0`th and `1`st positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3ebuvOf](https://packt.live/3ebuvOf).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2URh9zo](https://packt.live/2URh9zo).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have seen two different types of data so far. One is represented by numbers,
    while the other is represented by textual data. Now it's time to look into textual
    data in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the final section of this chapter, we will learn about strings. Strings in
    Python are similar to strings in any other programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'A string can also be declared in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: You can use single quotes and double quotes to define a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start and end of a string is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Strings in Python behave similar to lists, apart from one big caveat. Strings
    are immutable, whereas lists are mutable data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.12: Accessing Strings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going perform mathematical operations to access strings.
    Let''s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a string called `str_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can access the elements of the string by specifying the location of the
    element, like we did for lists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Access the first member of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the fifth member of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last member of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last member of the string, in a different way this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YHEmF9](https://packt.live/2YHEmF9).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3db191p](https://packt.live/3db191p).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each of the preceding operations will give you the character at the specific
    index. The method for accessing the elements of a string is like accessing a list.
    Let's do a couple of more exercises to manipulate strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.13: String Slices'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise will demonstrate how we can slice strings the same way as we did
    with lists. Although strings are not lists, the functionality will work in the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a string, `str_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the slicing values and slice the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Slice a string by skipping a slice value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use negative numbers to slice the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2N70Bis](https://packt.live/2N70Bis).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3d6X9Pu](https://packt.live/3d6X9Pu).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we can see, it is quite simple to manipulate strings with basic operations.
  prefs: []
  type: TYPE_NORMAL
- en: String Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find out the length of a string, we simply use the `len` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of the string is `41`. To convert a string''s case, we can use the
    `lower` and `upper` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the case of the string, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'To search for a string within a string, we can use the `find` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The output is `-1`. Can you figure out whether the `find` method is case-sensitive
    or not? Also, what do you think the `find` method returns when it actually finds
    the string?
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace one string with another, we have the `replace` method. Since we
    know that a string is an immutable data structure, `replace` actually returns
    a new string instead of replacing and returning the actual one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You should look up string methods in the standard documentation of Python 3
    to discover more about these methods. Visit [https://docs.python.org/3.7/](https://docs.python.org/3.7/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings have two useful methods: `split` and `join`. Here are their definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The `seperator` argument is a delimiter that you define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the following exercise to practice the `split` and `join` functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.14: Splitting and Joining a String'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will demonstrate how to perform split and join operations on
    a string. These two string methods need separate approaches as they allow you
    to convert a string into a list and vice versa. Let''s go through the following
    steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a string and convert it into a list using the `split` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will give you a list similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Combine this list into another string using the `join` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code will give you a string like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2N1lprE](https://packt.live/2N1lprE).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2UOOQBC](https://packt.live/2UOOQBC).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these, we are at the end of the second topic of this chapter. Now, we have
    the motivation to learn about data wrangling and have had a solid introduction
    to the fundamentals of data structures using Python. There is more to this topic,
    which will be covered in *Chapter 2*, *Advanced Operation on Built-In Data Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will ensure that you have understood the various basic types
    of data structures and their manipulation techniques. We will do that by going
    through an activity that has been designed specifically for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.02: Analyzing a Multiline String and Generating the Unique Word
    Count'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get multiline text and save it in a Python variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of all new lines in it using string methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the unique words and their occurrences from the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat the steps to find all unique words and occurrences, without considering
    case sensitivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the sake of simplicity, the original text (which can be found at [https://www.gutenberg.org/files/1342/1342-h/1342-h.htm](https://www.gutenberg.org/files/1342/1342-h/1342-h.htm))
    has been pre-processed  bit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These are the steps to guide you through solving this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `mutliline_text` variable by copying the text from the first chapter
    of *Pride and Prejudice*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Remember to add triple quotation marks to enter a multiline text.
    This is the only way to enter a chunk of text in Python.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part of the first chapter of *Pride and Prejudice* by Jane Austen has been made
    available on this book's GitHub repository at [https://packt.live/2N6ZGP6](https://packt.live/2N6ZGP6).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Find the type and length of the `multiline_text` string using the `type` and
    `len` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all new lines and symbols using the `replace` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all of the words in `multiline_text` using the `split` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a list from this list that will contain only the unique words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count the number of times the unique word has appeared in the list using the
    `key` and `value` in `dict`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the top 25 words from the unique words that you have found using the `slice`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19: Top 25 words from the unique list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15780_01_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.19: Top 25 words from the unique list'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor305).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about data wrangling and looked at examples from
    various real-life data science situations where data wrangling is very useful.
    We moved on to learn about the different built-in data structures that Python
    has to offer. We got our hands dirty by exploring lists, sets, dictionaries, tuples,
    and strings. These are the fundamental building blocks of Python data structures,
    and we need them all the time when working and manipulating data in Python. We
    did several small hands-on exercises to learn more about them. We finished this
    chapter with carefully designed activities that let us combine a lot of different
    tricks from all the different data structures and let us observe the interplay
    between all of them. In the next chapter, we will learn about the data structures
    in Python and utilize them to solve problems.
  prefs: []
  type: TYPE_NORMAL
