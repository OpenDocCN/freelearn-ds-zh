<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Using Compiled Code for Greater Speed"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using Compiled Code for Greater Speed</h1></div></div></div><p>So far, we have looked at how to optimize the computational performance of an R code. What if, after optimizing the code, it still runs too slowly? In this chapter, we will look at how to overcome the performance limitations caused by on-the-fly interpretation of an R code using a compiled code. Many CRAN packages use compiled code to offer optimum performance, so a simple way to take advantage of a compiled code is to use these packages. Sometimes, however, a specific task needs to be performed for which no package exists. It is useful to know how to write a compiled code for R in order to make R programs run faster.</p><p>We will first see how to compile R code before its execution, then we will explore how to integrate compiled languages like C/C++ into R so that we can run R programs at native CPU speed.</p><p>This chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Compiling an R code before execution</li><li class="listitem" style="list-style-type: disc">Using compiled languages in R</li></ul></div><div class="section" title="Compiling R code before execution"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Compiling R code before execution</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Understanding R's Performance – Why Are R Programs Sometimes Slow?">Chapter 1</a>, <span class="emphasis"><em>Understanding R's Performance – Why Are R Programs Sometimes Slow?</em></span> we saw how R, being an interpreted language, has to parse and evaluate code every time <a id="id71" class="indexterm"/>an R program is run. This takes a lot of CPU time and slows down the execution of R programs. R provides the <code class="literal">compiler</code> package to somewhat reduce this issue. The functions in this package allow us to compile R code beforehand and save R a step or two when we execute the code. Let's see how this works.</p><div class="section" title="Compiling functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec12"/>Compiling functions</h2></div></div></div><p>Let's define <a id="id72" class="indexterm"/>a <code class="literal">mov.avg()</code> function that calculates the moving average of a numeric series:</p><div class="informalexample"><pre class="programlisting"># Compute the n-period moving average of x
mov.avg &lt;- function(x, n=20) {
    total &lt;- numeric(length(x) - n + 1)
    for (i in 1:n) {
        total &lt;- total + x[i:(length(x) - n + i)]
    }
  total / n
}</pre></div><p>Given a numeric vector <code class="literal">x</code> and period <code class="literal">n</code>, we first calculate the <code class="literal">n</code> element's window sum of the elements of <code class="literal">x</code>. For example, if <code class="literal">x</code> is <code class="literal">[1, 2, 1, 3, 5]</code> and <code class="literal">n</code> is <code class="literal">2</code>, then we calculate <code class="literal">total</code> as <code class="literal">[1+2, 2+1, 1+3, 3+5] = [3, 3, 4, 8]</code>. We do this by looping <code class="literal">n</code> times over <code class="literal">x</code>, selecting a moving window of the elements of <code class="literal">x</code>, and adding those elements to <code class="literal">total</code>. Finally, we compute the moving average by dividing <code class="literal">total</code> by <code class="literal">n</code>.</p><p>To compile the function, we will use the <code class="literal">cmpfun()</code> function in the <code class="literal">compiler</code> package. The compilation functions provided by the <code class="literal">compiler</code> package operate on four different levels of optimization, numbered 0 to 3; the higher the number, the more the compiled code is optimized for performance.</p><p>Let's compile <code class="literal">mov.avg()</code> at different levels to see the differences in execution time. Here, we create four copies of the <code class="literal">mov.avg()</code> function compiled at different levels of optimization by passing the <code class="literal">optimize</code> argument to <code class="literal">cmpfun()</code>:</p><div class="informalexample"><pre class="programlisting">library(compiler)
mov.avg.compiled0 &lt;- cmpfun(mov.avg, options=list(optimize=0))
mov.avg.compiled1 &lt;- cmpfun(mov.avg, options=list(optimize=1))
mov.avg.compiled2 &lt;- cmpfun(mov.avg, options=list(optimize=2))
mov.avg.compiled3 &lt;- cmpfun(mov.avg, options=list(optimize=3))</pre></div><p>Next, we benchmark the performance of the original <code class="literal">mov.avg()</code> function and the four compiled versions by computing the 20-period moving average of a numeric vector with <code class="literal">100</code> elements:</p><div class="informalexample"><pre class="programlisting">library(microbenchmark)
x &lt;- runif(100)
bench &lt;- microbenchmark(mov.avg(x),
                        mov.avg.compiled0(x),
                        mov.avg.compiled1(x),
                        mov.avg.compiled2(x),
                        mov.avg.compiled3(x))
bench
## Unit: microseconds
##                  expr    min      lq  median      uq      max
##            mov.avg(x) 34.257 37.6865 41.3630 72.3015  131.101
##  mov.avg.compiled0(x) 33.500 36.9065 41.9995 72.8770 2605.917
##  mov.avg.compiled1(x) 34.643 36.8615 41.0650 71.8480  117.632
##  mov.avg.compiled2(x) 24.050 25.9040 28.3060 51.8685 3693.741
##  mov.avg.compiled3(x) 23.399 24.6540 27.7670 49.6385   89.595
##  neval
##    100
##    100
##    100
##    100
##    100</pre></div><p>Looking at <a id="id73" class="indexterm"/>the median execution times, the original function took 41.4 μs. The compiled functions at optimization levels 0 and 1 took about the same time, coming in at 42.0 μs and 41.1 μs respectively. However those at optimization levels 2 and 3 performed well, at 28.3 μs and 27.8 μs. They reduced the execution time by 32 percent and 33 percent respectively.</p><p>The minimum lower quartile and upper quartile statistics shows a similar pattern with <code class="literal">mov.avg.compiled2()</code> and <code class="literal">mov.avg.compiled3()</code> executing in less time than <code class="literal">mov.avg()</code>, <code class="literal">mov.avg.compiled0()</code>, and <code class="literal">mov.avg.compiled1()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>We should not rely on the maximum statistics because it can be unstable, producing a wide range of values every time we run <code class="literal">microbenchmark()</code>. This is due to the outliers when R's garbage collection takes place, or when the execution of the functions are slowed down by other processes competing for CPU time.</p></div></div><p>The following chart shows the distributions of the benchmarking results in an intuitive visual form.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>Generate an intuitive visualization of the benchmarking results by using the <code class="literal">autoplot()</code> function. The <code class="literal">ggplot2</code> package is needed for this:</p><div class="informalexample"><pre class="programlisting">library(ggplot2)
autoplot(bench)</pre></div></div></div><div class="mediaobject"><img src="graphics/9263OS_04_01.jpg" alt="Compiling functions"/><div class="caption"><p> Autoplot of microbenchmark() results for moving average functions</p></div></div><p>The <a id="id74" class="indexterm"/>performance gain when R code is compiled depends on what kinds of R expressions are contained in the code. In our example, we achieved modest performance gains because the <code class="literal">for</code> loop and the arithmetic operations in the <code class="literal">mov.avg()</code> function could be optimized. However, compiling code that mostly calls other functions that have already been optimized for performance (such as <code class="literal">sum()</code>) would not result in significant performance gains.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>The <code class="literal">compiler</code> package provides <a id="id75" class="indexterm"/>different functions to compile different <a id="id76" class="indexterm"/>types of R code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">cmpfun()</code> compiles an R function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">compile()</code> compiles an R expression.</li><li class="listitem" style="list-style-type: disc"><code class="literal">cmpfile()</code> compiles an R expression stored in a file.</li></ul></div></div></div></div><div class="section" title="Just-in-time (JIT) compilation of R code"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec13"/>Just-in-time (JIT) compilation of R code</h2></div></div></div><p>R also<a id="id77" class="indexterm"/> supports <span class="strong"><strong>just-in-time</strong></span> (<span class="strong"><strong>JIT</strong></span>) <span class="strong"><strong>compilation</strong></span>. When JIT compilation is enabled, R will automatically <a id="id78" class="indexterm"/>compile any code that is executed without explicitly having called one of the <code class="literal">compile</code> functions. This is convenient, as any existing R code can enjoy the performance gains of code compilation without any modification.</p><p>To activate JIT compilation, use the <code class="literal">enableJIT()</code> function in the <code class="literal">compiler</code> package:</p><div class="informalexample"><pre class="programlisting">library(compiler)
enableJIT(level=3)</pre></div><p>The <code class="literal">level</code> argument tells R how much code to compile before execution. Valid values for <code class="literal">level</code> are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">0</code>: It disables JIT.</li><li class="listitem" style="list-style-type: disc"><code class="literal">1</code>: It compiles functions before their first use.</li><li class="listitem" style="list-style-type: disc"><code class="literal">2</code>: In addition, it compiles functions before they are duplicated. This is useful for some packages like lattice that store functions in lists.</li><li class="listitem" style="list-style-type: disc"><code class="literal">3</code>: It compiles loops before they are executed.</li></ul></div><p>Let's benchmark the (uncompiled) <code class="literal">mov.avg()</code> function with the JIT compilation:</p><div class="informalexample"><pre class="programlisting">microbenchmark(mov.avg(x))
## Unit: microseconds
##        expr    min     lq median     uq      max neval
##  mov.avg(x) 23.164 24.009 24.519 25.128 6097.067   100</pre></div><p>The JIT compilation reduced the median execution time of <code class="literal">mov.avg()</code> from 41.4 μs to 24.5 μs—a 41 percent improvement!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>JIT compilation can also be enabled by setting the <code class="literal">R_ENABLE_JIT</code> environment in the operating system before starting R. The value of <code class="literal">R_ENABLE_JIT</code> should be set to the value of the <code class="literal">level</code> argument.</p></div></div></div></div></div>
<div class="section" title="Using compiled languages in R"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Using compiled languages in R</h1></div></div></div><p>Code compilation can provide modest gains in computational performance, but there are limits to <a id="id79" class="indexterm"/>these gains because the compiled code still needs to be evaluated by R in a dynamic fashion. For example, we explained in <a class="link" href="ch03.html" title="Chapter 3. Simple Tweaks to Make R Run Faster">Chapter 3</a>, <span class="emphasis"><em>Simple Tweaks to Make R Run Faster</em></span>, how R, being a <span class="strong"><strong>dynamically typed</strong></span> language, needs to check the type of an object <a id="id80" class="indexterm"/>before applying<a id="id81" class="indexterm"/> any operations. In the case of <code class="literal">mov.avg()</code>, every time R encounters the <code class="literal">+</code> operator, it needs to check that <code class="literal">x</code> is a numeric vector, as it could have been modified between each iteration of the <code class="literal">for</code> loop. In contrast, a <span class="strong"><strong>statically typed</strong></span> language performs these checks at compile time, resulting in much faster run time performance.</p><p>For this and many other reasons, R's dynamic nature poses barriers to computational performance. The only way to break through these barriers is to turn to compiled languages such as C and use them from within R. This section assumes that you have some basic knowledge of compiled languages such as C/C++, including pointers and arrays.</p><div class="section" title="Prerequisites"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec14"/>Prerequisites</h2></div></div></div><p>In order to<a id="id82" class="indexterm"/> compile the examples in this chapter, a set of development tools, including a C/C++ compiler are needed.</p><p>Windows <a id="id83" class="indexterm"/>users should <a id="id84" class="indexterm"/>download and install <code class="literal">Rtools</code> from <a class="ulink" href="http://cran.r-project.org/bin/windows/Rtools/">http://cran.r-project.org/bin/windows/Rtools/</a>. Pick the version of <code class="literal">Rtools</code> that corresponds to your version of R. Be <a id="id85" class="indexterm"/>sure to select the <span class="strong"><strong>Package authoring installation</strong></span> and <span class="strong"><strong>Edit the system PATH</strong></span> options in the installation wizard.</p><p>On Mac OS X, download<a id="id86" class="indexterm"/> and install the <span class="emphasis"><em>Xcode Command Line Tools</em></span>. If you are using Mac OS X 10.9 Mavericks or <a id="id87" class="indexterm"/>a later version, simply run <code class="literal">xcode-select –install</code> in terminal. For <a id="id88" class="indexterm"/>earlier versions of Mac OS X, create a developer account at <a class="ulink" href="http://developer.apple.com/">http://developer.apple.com/</a>. Then sign in, go to <a class="ulink" href="https://developer.apple.com/downloads/index.action">https://developer.apple.com/downloads/index.action</a> and search for command-line tools for Xcode for your OS version.</p><p>Most Linux distributions offer an easy way to install the standard development tools; consult the documentation of your distribution for instructions. If you are using Debian or Ubuntu, you can just install <code class="literal">r-base-dev</code> to get all the tools you need.</p></div><div class="section" title="Including compiled code inline"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Including compiled code inline</h2></div></div></div><p>The <code class="literal">inline</code> CRAN package <a id="id89" class="indexterm"/>allows <a id="id90" class="indexterm"/>us to embed C, C++, Objective-C, Objective-C++, and Fortran <a id="id91" class="indexterm"/>code within R. This is handy for speeding up small R functions with a bit of compiled code.</p><p>Here is an <a id="id92" class="indexterm"/>example <a id="id93" class="indexterm"/>of how to implement <code class="literal">mov.avg()</code>in C using the <code class="literal">inline</code> package:</p><div class="informalexample"><pre class="programlisting">library(inline)
mov.avg.inline &lt;- cfunction(
    sig=signature(x="numeric", n="integer"),
    body="
        /* Coerce arguments to the correct types needed.
           x needs to be a numeric vector (type REALSXP), and n
           needs to be an integer vector (type INTSXP). */
        SEXP x2 = PROTECT(coerceVector(x, REALSXP));
        SEXP n2 = PROTECT(coerceVector(n, INTSXP));
        
        /* Create accessors to the actual data being pointed to by
           the two SEXP's. */
        double *x_p = REAL(x2);
        int n_val = asInteger(n2);
        
        // Vector lengths
        int x_len = length(x2);
        int res_len = x_len - n_val + 1;
        
        /* Create and initialize a numeric vector (type REALSXP)
           of length res_len, using allocVector().
           Since memory is allocated, use PROTECT to protect the
           object from R's garbage collection. */
        SEXP res = PROTECT(allocVector(REALSXP, res_len));
        double *res_p = REAL(res);
        for (int i = 0; i &lt; res_len; i++) {
            res_p[i] = 0;
        }
        
        // Compute window sum
        for (int j = 0; j &lt; n_val; j++) {
            for (int k = 0; k &lt; res_len; k++) {
                res_p[k] += x_p[j + k];
            }
        }
        
        // Compute moving average
        for (int l = 0; l &lt; res_len; l++) {
            res_p[l] /= n_val;
        }
        
        // Unprotect allocated memory and return results
        UNPROTECT(3);
        return res;
    ',
    language="C"
    )</pre></div><p>We load the <code class="literal">inline</code> package and define <code class="literal">mov.avg.inline()</code> using <code class="literal">cfunction()</code>. A number of arguments are taken by <code class="literal">cfunction()</code>(look up the documentation for more details), but <a id="id94" class="indexterm"/>we need only three here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sig=signature(x="numeric", n="integer")</code>: This defines the signature of the function. In this case, it will look like <code class="literal">mov.avg.inline(x, n)</code>, where <code class="literal">x</code> has the numeric class and the n has integer class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">body</code>: The <code class="literal">body</code> argument <a id="id95" class="indexterm"/>contains the code for the function's body in the programming language of your choice.</li><li class="listitem" style="list-style-type: disc"><code class="literal">language="C"</code>: This specifies<a id="id96" class="indexterm"/> the programming language of the code in body. Valid values are <code class="literal">C,</code> <code class="literal">C++</code>, <code class="literal">Fortran</code>, <code class="literal">F95</code>, <code class="literal">ObjectiveC</code>, and <code class="literal">ObjectiveC++</code>.</li></ul></div><p>The first step <a id="id97" class="indexterm"/>of the <a id="id98" class="indexterm"/>function is to make sure that the arguments supplied to the function are of the correct type by calling <code class="literal">coerceVector()</code>. This function returns an <code class="literal">SEXP</code> (s-expression) pointer, which is how all R objects are represented in C and C++. These pointers point to <code class="literal">SEXPREC</code> (s-expression) record structures that store the data along with some header information. The first two lines of code define two new <code class="literal">SEXP</code> variables, <code class="literal">x2</code> and <code class="literal">n2</code>, that store pointers to new R objects created by coercing the function arguments.</p><p>Because <code class="literal">coerceVector()</code> creates new data structures in memory to store the data in the specified types, we wrap the calls to <code class="literal">coerceVector()</code> in the macro function <code class="literal">PROTECT()</code>, which protects the newly created data structures from R's garbage collection mechanisms. This is necessary because R does not know when variables are no longer needed in C, and might be overzealous in freeing memory for objects that are still needed. <code class="literal">PROTECT()</code> needs to be called every time memory is allocated for a new R object.</p><p>Now <code class="literal">x2</code> and <code class="literal">n2</code> contain <code class="literal">SEXP</code> pointers of R objects that represent the coerced arguments. Because <code class="literal">x2</code> and <code class="literal">n2</code> point to <code class="literal">SEXPREC</code> structures, we still do not have direct access to the C arrays that store the data. There are a couple of ways to get access to the data. In <code class="literal">double *x_p = REAL(x2);</code>, the <code class="literal">REAL()</code> macro returns a <code class="literal">double*</code> pointing to the first element of the double array. The <code class="literal">int n_val = asInteger(n2);</code> declaration takes a different approach by calling the <code class="literal">asInteger()</code> convenience function to return the first integer value in the array pointed to by <code class="literal">n2</code>. Notice the difference here; <code class="literal">x_p</code> is a pointer to a double array while <code class="literal">n_val</code> is an integer containing the actual value of the argument. Both styles of access to the R data can be used depending on which is more convenient.</p><p>Next, we compute the length <code class="literal">res_len</code> of the numeric vector in which we will store the results, and create the vector using <code class="literal">allocVector()</code>. Again, this is wrapped in <code class="literal">PROTECT()</code> because memory is being allocated for a new object. The result of this expression is a <code class="literal">SEXP</code> pointing to the new R numeric vector. <code class="literal">REAL(res)</code> provides access to the underlying C double array, as before.</p><p>The next pair<a id="id99" class="indexterm"/> of nested <code class="literal">for</code> loops computes the window sum with the <code class="literal">n_val</code> period. Then, the moving <a id="id100" class="indexterm"/>average is computed by dividing each element of the results array by <code class="literal">n_val</code>.</p><p>Before returning the results, there is some housekeeping that is required. <code class="literal">UNPROTECT(3)</code> tells R that the three objects for which memory was allocated in C, do not need protection from garbage collection anymore. The argument to <code class="literal">UNPROTECT()</code> must match the number of calls to <code class="literal">PROTECT()</code> in the function. In this case, it is likely that the the garbage collector will free the memory for <code class="literal">x2</code> and <code class="literal">n2</code>. The <code class="literal">res</code> object, however, is passed back to R, where the normal garbage collection mechanisms apply.</p><p>Let's do a simple test to ensure that our code works correctly by calling the original <code class="literal">mov.avg()</code> function alongside <code class="literal">mov.avg.inline()</code> and ensuring that the values match:</p><div class="informalexample"><pre class="programlisting">x &lt;- runif(100)
all(mov.avg(x, 20) == mov.avg.inline(x, 20))
## [1] TRUE</pre></div><p>How much quicker will the C code run than the original uncompiled R function? This is shown, as follows:</p><div class="informalexample"><pre class="programlisting">microbenchmark(mov.avg(x, 20), mov.avg.inline(x, 20))
## Unit: microseconds
##                  expr    min     lq  median      uq     max
##        mov.avg(x, 20) 32.909 34.113 34.8240 35.6975 130.155
## mov.avg.inline(x, 20)  1.347  1.423  1.5535  1.7015  14.169
## neval
##   100
##   100</pre></div><p>The C code took an average of just 1.55 μs compared with 34.8 μs for the R code—a 96 percent reduction in execution time! Even the maximum execution time in C (14.2 μs) is less than half of the minimum execution time in R (32.9 μs). These savings of a few microseconds might not seem like much, but the difference becomes significant when we have to process larger datasets or compute moving averages with larger periods:</p><div class="informalexample"><pre class="programlisting">y &lt;- runif(1e7)
microbenchmark(mov.avg(y, 20), mov.avg.inline(y, 20))
## Unit: milliseconds
##                  expr       min        lq    median       uq
##        mov.avg(y, 20) 2046.4608 2198.6103 <span class="strong"><strong>2252.7003</strong></span> 2318.721
## mov.avg.inline(y, 20)  272.8686  280.2837  <span class="strong"><strong>283.3647</strong></span>  292.587
##       max neval
## 3606.3911   100
##  374.0193   100</pre></div><p>When the <a id="id101" class="indexterm"/>data contains 10 million numbers, the difference is more pronounced; over 2 seconds<a id="id102" class="indexterm"/> in R and only 0.28 seconds in C. In some business contexts, every millisecond counts, and a latency of 2 seconds is not acceptable. In such situations, writing key pieces of data processing code in a compiled language like C or Fortran and embedding them into R using <code class="literal">inline</code> will give a huge boost to computational performance.</p></div><div class="section" title="Calling external compiled code"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Calling external compiled code</h2></div></div></div><p>We have <a id="id103" class="indexterm"/>seen how<a id="id104" class="indexterm"/> to use a compiled language to define functions in R. When we want to implement more complex functionality using compiled code, such as creating entire R packages or linking to external libraries, it might be easier to develop the code externally and to call it from R.</p><p>R provides a few interfaces to call the external compiled code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">.C()</code>: This <a id="id105" class="indexterm"/>calls C or C++ code with a maximum of 65 arguments. Type checking and coercion must be done in R before calling the C function. Functions called by <code class="literal">.C()</code> should not return any values; instead, when the function is called, the results stored by data structures should be supplied to the function. For example, if we were to implement <code class="literal">mov.avg()</code> using the <code class="literal">.C()</code> interface, the function call might look like <code class="literal">.C("mov_avg_C", as.numeric(x), as.integer(n), numeric(length(x) - n + 1))</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.Fortran()</code>: This is <a id="id106" class="indexterm"/>similar to <code class="literal">.C()</code> except it calls <code class="literal">Fortran</code> code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.Call()</code>: This also <a id="id107" class="indexterm"/>calls C or C++ code with a maximum of 65 arguments. Type checking and coercion can be done in R or in C/C++ (as in the <code class="literal">mov.avg.inline()</code> example). Functions called by <code class="literal">.Call()</code> can return an R object. If multiple return values are needed, an R list can be returned. For example, <code class="literal">ma &lt;- .Call("mov_avg_C", x, n)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.External()</code>: This is<a id="id108" class="indexterm"/> similar to <code class="literal">.Call()</code> except all arguments are passed in a single <code class="literal">SEXP</code>. As a result, functions called with <code class="literal">.External()</code> can accept a variable number of arguments and a practically unlimited number of arguments.</li></ul></div><p>The functions provided by the <code class="literal">inline</code> package are actually wrappers for some of the lower-level interfaces that make it easier for developers to embed a compiled code in R.</p><p>It is beyond the<a id="id109" class="indexterm"/> scope <a id="id110" class="indexterm"/>of this book to explain in detail how to use these interfaces. To learn more, read the <span class="emphasis"><em>System and foreign language interfaces</em></span> and <span class="emphasis"><em>The R API</em></span> sections of the <span class="emphasis"><em>Writing R Extensions</em></span> manual (for more information visit <a class="ulink" href="http://cran.r-project.org/doc/manuals/r-release/R-exts.html">http://cran.r-project.org/doc/manuals/r-release/R-exts.html</a>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>For Java programmers, the <code class="literal">rJava</code> package on CRAN provides an interface to Java code.</p></div></div><p>Instead, we would like to introduce the <code class="literal">Rcpp</code> package that provides a convenient, higher-level API to the <code class="literal">.Call()</code> interface for C++ code. Here is the moving average function implemented using <code class="literal">Rcpp</code>. Save this code in the <code class="literal">mov_avg_Rcpp.cpp</code> file:</p><div class="informalexample"><pre class="programlisting">#include &lt;Rcpp.h&gt;

// [[Rcpp::export]]
Rcpp::NumericVector mov_avg_Rcpp(Rcpp::NumericVector x,
                                 int n=20) {
    // Vector lengths
    int x_len = x.size();
    int res_len = x_len - n + 1;
    
    // Create and initialize vector for results
    Rcpp::NumericVector res(res_len);
    
    // Compute window sum
    for (int j = 0; j &lt; n; j++) {
        for (int k = 0; k &lt; res_len; k++) {
            res[k] += x[j + k];
        }
    }
    
    // Compute moving average
    for (int l = 0; l &lt; res_len; l++) {
        res[l] /= n;
    }
    
    // Return results
    return res;
}</pre></div><p>The first line <code class="literal">#include &lt;Rcpp.h&gt;</code> imports the headers required to use <code class="literal">Rcpp</code> classes and functions. The comment <code class="literal">// [[Rcpp::export]]</code> is an <code class="literal">Rcpp</code> attribute. It tells <code class="literal">Rcpp</code> that the following function should be exported to R.</p><p><code class="literal">SEXP</code> pointers <a id="id111" class="indexterm"/>are not <a id="id112" class="indexterm"/>used in <code class="literal">mov_avg_Rcpp()</code>. Instead, <code class="literal">Rcpp</code> provides classes that represent the <a id="id113" class="indexterm"/>standard R classes. We can even specify that <code class="literal">n</code> is a single integer and not an integer vector. Whenever <code class="literal">mov_avg_Rcpp()</code> is called from R, <code class="literal">Rcpp</code> will automatically check that the supplied arguments are of the correct type.</p><p>Notice that there are no calls to <code class="literal">PROTECT()</code> or <code class="literal">UNPROTECT()</code> here. When <code class="literal">Rcpp::NumericVector res(res_len);</code> creates a new numeric vector for the results, <code class="literal">Rcpp</code> takes <a id="id114" class="indexterm"/>care of the memory allocation and protection from garbage collection. It even initializes the values of the new vector to zeroes.</p><p><code class="literal">Rcpp</code> also provides direct access to the data in the <code class="literal">x</code> argument and the results vector <code class="literal">res</code> without having to ask for pointers to the data.</p><p>Using <code class="literal">Rcpp</code>, we can write more succinct and readable code than possible using the native <code class="literal">.C()</code> or <code class="literal">.Call()</code> interfaces.</p><p>Let's now see how to call this function from within R. Besides loading the <code class="literal">Rcpp</code> library, the only other thing to do is to call <code class="literal">sourceCpp()</code>, which will compile the C++ code and export the function to R:</p><div class="informalexample"><pre class="programlisting">library(Rcpp)
sourceCpp('mov_avg_Rcpp.cpp")</pre></div><p>Now, we can call <code class="literal">mov_avg_Rcpp()</code> and benchmark it against our previous versions:</p><div class="informalexample"><pre class="programlisting">x &lt;- runif(100)
microbenchmark(mov.avg(x, 20),
               mov.avg.inline(x, 20),
               mov_avg_Rcpp(x, 20))
## Unit: microseconds
##                  expr    min     lq median      uq     max
##        mov.avg(x, 20) 33.902 35.779 <code class="literal">37.472</code> 49.7340 101.325
## mov.avg.inline(x, 20)  1.327  1.513  <code class="literal">1.718</code>  1.9655  14.129
##   mov_avg_Rcpp(x, 20)  2.382  2.727  <code class="literal">2.874</code>  3.9705  11.424
## neval
##   100
##   100
##   100</pre></div><p>The <code class="literal">Rcpp</code> version runs a little slower than the inline version, but it is still much faster than our pure R code. It provides a good level of performance with a much simpler API than the other interfaces provided by R.</p><p><code class="literal">Rcpp</code> provides <a id="id115" class="indexterm"/>many <a id="id116" class="indexterm"/>more features than we can cover in this book such as package authoring tools, the <code class="literal">sugar</code> functions for common operations such as vector operations, and more. For more details, code <a id="id117" class="indexterm"/>examples, and resources, look up the <code class="literal">Rcpp</code> website at <a class="ulink" href="http://www.rcpp.org/">http://www.rcpp.org/</a>. One of the creators of <code class="literal">Rcpp</code>, Dirk Eddelbuettel, has also written the <span class="emphasis"><em>Seamless R and C++ Integration with Rcpp (use R!)</em></span> book that provides a comprehensive guide.</p></div><div class="section" title="Considerations for using compiled code"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Considerations for using compiled code</h2></div></div></div><p>There are a<a id="id118" class="indexterm"/> few things <a id="id119" class="indexterm"/>to bear in mind while using compiled code in R. We will explain the common ones here; the <span class="emphasis"><em>Writing R Extensions</em></span> manual provides a comprehensive treatment of these topics.</p><div class="section" title="R APIs"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec01"/>R APIs</h3></div></div></div><p>The C functions <a id="id120" class="indexterm"/>and macros used so far are from the header file <code class="literal">Rinternals.h</code>, found in <code class="literal">R_INCLUDE_DIR</code> which defaults to <code class="literal">R_HOME/include</code> in any standard R installation. This<a id="id121" class="indexterm"/> file, together with <code class="literal">R.h</code> and other header files in <code class="literal">R_INCLUDE_DIR</code>, provides various APIs for C/C++ code to interface with R. Together they provide a rich set <a id="id122" class="indexterm"/>of functions for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Manipulating R objects (for example, sorting vectors)</li><li class="listitem" style="list-style-type: disc">Managing memory allocation and deallocation</li><li class="listitem" style="list-style-type: disc">Math (for example, trigonometric functions)</li><li class="listitem" style="list-style-type: disc">Mathematical constants</li><li class="listitem" style="list-style-type: disc">Random number generation</li><li class="listitem" style="list-style-type: disc">Statistical distributions (for example, <code class="literal">rnorm</code> and <code class="literal">punif</code>)</li><li class="listitem" style="list-style-type: disc">BLAS, LAPACK, and LINPACK linear algebra routines</li><li class="listitem" style="list-style-type: disc">And much more</li></ul></div><p>It is worthwhile to explore these files in order to see which functionality is available for C/C++ code. Some of these can be called from Fortran as well. The <span class="emphasis"><em>Organization of header files</em></span> section of <span class="emphasis"><em>Writing R Extensions</em></span> describes each header file.</p></div><div class="section" title="R data types versus native data types"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec02"/>R data types versus native data types</h3></div></div></div><p>While <a id="id123" class="indexterm"/>working in <a id="id124" class="indexterm"/>compiled languages, it is useful to know how R types map to different native data types, as shown in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>R storage mode</p>
</th><th style="text-align: left" valign="bottom">
<p>C type</p>
</th><th style="text-align: left" valign="bottom">
<p>Fortran type</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">logical</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">int *</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">INTEGER</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">integer</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">int *</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">INTEGER</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">double</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">double *</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">DOUBLE PRECISION</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">complex</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">Rcomplex *</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">DOUBLE COMPLEX</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">character</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">char **</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">CHARACTER*255</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">raw</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">unsigned char *</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">none</code></p>
</td></tr></tbody></table></div><p>When dealing with <code class="literal">SEXP</code> pointers in C/C++ or type classes in <code class="literal">Rcpp</code>, here are the most commonly used types (look up the documentation for R or <code class="literal">Rcpp</code> for a complete list):</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>R type</p>
</th><th style="text-align: left" valign="bottom">
<p>SEXP Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Rcpp type</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">numeric</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">REALSXP</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">NumericVector / NumericMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">integer</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">INTSXP</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">IntegerVector / IntegerMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">complex</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">CPLXSXP</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ComplexVector / ComplexMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">logical</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">LGLSXP</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">LogicalVector / LogicalMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">character</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">STRSXP</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">CharacterVector / CharacterMatrix</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">list</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">VECSXP</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">List</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">data.frame</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">none</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">DataFrame</code></p>
</td></tr></tbody></table></div></div><div class="section" title="Creating R objects and garbage collection"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Creating R objects and garbage collection</h3></div></div></div><p>We have <a id="id125" class="indexterm"/>seen how R objects <a id="id126" class="indexterm"/>can be created and memory can be allocated for them by calling <code class="literal">allocVector()</code> and <code class="literal">coerceVector()</code>. <code class="literal">Rinternals.h</code> defines other memory allocation <a id="id127" class="indexterm"/>functions as <a id="id128" class="indexterm"/>well, such as <code class="literal">allocList()</code> and <code class="literal">allocArray()</code>. Any call to the <code class="literal">alloc*()</code> functions or <code class="literal">coerceVector()</code> needs to be wrapped in <code class="literal">PROTECT()</code>.</p><p>In the <code class="literal">mov.avg.inline()</code> example, <code class="literal">UNPROTECT()</code> is used to remove garbage collection protection right before returning the results. <code class="literal">UNPROTECT()</code> can also be called at any point in a function to allow the garbage collector to release R objects that are no longer needed. The protection mechanism is stack-based, so <code class="literal">UNPROTECT(n)</code> removes the protection from the last <code class="literal">n</code> objects that were protected. Alternatively, <code class="literal">UNPROTECT_PTR(p)</code> can be used to unprotect the specific object that <code class="literal">SEXP</code> <code class="literal">p</code> points to, even if it is not at the top of the stack.</p><p>In complex C/C++ code that creates many R objects, it is good practice to unprotect them once <a id="id129" class="indexterm"/>they are <a id="id130" class="indexterm"/>not needed, so that the garbage collector can do its job efficiently. However, it is the <a id="id131" class="indexterm"/>programmer's responsibility to make sure that those unprotected objects are <a id="id132" class="indexterm"/>never used again in the code, to prevent any memory errors.</p><p>Finally, always remember to match the number of the <code class="literal">PROTECT()</code> calls with the total number of objects unprotected by <code class="literal">UNPROTECT()</code> or <code class="literal">UNPROTECT_PTR()</code>.</p></div><div class="section" title="Allocating memory for non-R objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Allocating memory for non-R objects</h3></div></div></div><p>Sometimes, memory is needed to store the results of intermediate computations that do not <a id="id133" class="indexterm"/>need to be <a id="id134" class="indexterm"/>accessed from R. R provides two ways of allocating memory like this in C/C++.</p><p>The first method, <span class="strong"><strong>transient storage allocation</strong></span>, allows you to allocate memory that is automatically<a id="id135" class="indexterm"/> reclaimed by R at the end of the call to <code class="literal">.C()</code>, <code class="literal">.Call()</code> or <code class="literal">.External()</code>. To do this, use the <code class="literal">char *R_alloc(size_t n, int size)</code> function, which allocates <code class="literal">n</code> units of <code class="literal">size</code> bytes each and returns a pointer to the allocated memory. A typical usage might look like:</p><div class="informalexample"><pre class="programlisting">int *x = (int *) R_alloc(100, sizeof(int));</pre></div><p>There is no need to free the allocated memory within the C/C++ function, as R will take care of that when the function execution ends.</p><p>The <span class="strong"><strong>user-controlled memory</strong></span> mechanism provides more control over the allocation and freeing of <a id="id136" class="indexterm"/>memory. This allows memory to be freed between different parts of C/C++ code. For example, in an iterative algorithm where each stage of computation produces large amounts of intermediate data, memory from previous iterations can be freed to ensure that there is sufficient free memory to complete future iterations. There are<a id="id137" class="indexterm"/> three functions in this interface:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">type* Calloc(size_t n, type)</code>: This allocates memory of the specified size and type</li><li class="listitem" style="list-style-type: disc"><code class="literal">type* Realloc(any *p, size_t n, type)</code>: This changes the size of the memory<a id="id138" class="indexterm"/> allocated at <code class="literal">*p</code> to the specified size and type</li><li class="listitem" style="list-style-type: disc"><code class="literal">void Free(any *p)</code>: This<a id="id139" class="indexterm"/> frees the memory at <code class="literal">*p</code></li></ul></div><p>These functions are analogous to the C functions <code class="literal">calloc()</code>, <code class="literal">realloc()</code>, and <code class="literal">free()</code>, with additional error handling by R. If they return, then the memory has been successfully allocated or freed.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we covered a variety of techniques to leverage code in compiled languages for a near-native CPU performance. While the examples focused on C and C++, similar approaches can be used with Fortran or Java.</p><p>We first saw how compiling an R code before its execution by using the <code class="literal">compile</code> package can provide modest performance gains, especially for code with many loops and basic operations. JIT compilation does the same automatically for executing any R code. There is a limit, however, to how much an R code can be optimized because R is a dynamic language at its core.</p><p>Looking beyond R, we used C and C++ to achieve dramatic performance improvements. We learned how to define a C function from within R, using the <code class="literal">inline</code> package, and how to use <code class="literal">Rcpp</code> to call an external C++ function from R.</p><p>In the process, we learned about how R represents different types of data in C/C++ using <code class="literal">SEXP</code> pointers and <code class="literal">SEXPREC</code> record structures, and how to manipulate R objects using these constructs. We also learned about the intricacies of allocating memory, freeing memory, and garbage collection while working in C/C++.</p><p>Finally, we took a quick tour of the R APIs that provide rich R functionality from within C, C++, or Fortran.</p><p>This chapter covered advanced techniques to achieve optimized computational performance in R, using compiled languages. These techniques allow R programmers to tap into the power and speed of compiled languages while enjoying the simplicity and flexibility of R as a data processing environment. The huge performance gains from using compiled languages come with an equally huge responsibility to understand in detail how these techniques work, so that they can be used safely and effectively. Whole books could be written on this topic; we encourage you to look up other resources including the <span class="emphasis"><em>Writing R Extensions</em></span> manual for a deeper and more comprehensive treatment.</p><p>In the next chapter, we will look at how to leverage the computing power of <span class="strong"><strong>Graphics Processing Units</strong></span> (<span class="strong"><strong>GPUs</strong></span>) for certain types of computations.</p></div></body></html>