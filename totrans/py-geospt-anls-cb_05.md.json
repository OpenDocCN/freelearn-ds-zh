["```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    import os\n    import json\n    from shapely.geometry import asShape\n\n    # define output GeoJSON file\n    res_line_intersect = os.path.realpath(\"../geodata/ch05-01-geojson.js\")\n\n    # input GeoJSON features\n    simple_line = {\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"properties\":{\"name\":\"line to clip\"},\"geometry\":{\"type\":\"LineString\",\"coordinates\":[[5.767822265625,50.14874640066278],[11.901806640625,50.13466432216696],[4.493408203125,48.821332549646634]]}}]}\n    clip_boundary = {\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"properties\":{\"name\":\"Clipping boundary circle\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6.943359374999999,50.45750402042058],[7.734374999999999,51.12421275782688],[8.96484375,51.316880504045876],[10.1513671875,51.34433866059924],[10.8544921875,51.04139389812637],[11.25,50.56928286558243],[11.25,49.89463439573421],[10.810546875,49.296471602658094],[9.6240234375,49.03786794532644],[8.1298828125,49.06666839558117],[7.5146484375,49.38237278700955],[6.8994140625,49.95121990866206],[6.943359374999999,50.45750402042058]]]}}]}\n\n    # create shapely geometry from FeatureCollection\n    # access only the geomety part of GeoJSON\n    shape_line = asShape(simple_line['features'][0]['geometry'])\n    shape_circle = asShape(clip_boundary['features'][0]['geometry'])\n\n    # run the intersection\n    shape_intersect = shape_line.intersection(shape_circle)\n\n    # define output GeoJSON dictionary\n    out_geojson = dict(type='FeatureCollection', features=[])\n\n    # generate GeoJSON features\n    for (index_num, line) in enumerate(shape_intersect):\n        feature = dict(type='Feature', properties=dict(id=index_num))\n        feature['geometry'] = line.__geo_interface__\n        out_geojson['features'].append(feature)\n\n    # write out GeoJSON to JavaScript file\n    # this file is read in our HTML and\n    # displayed as GeoJSON on the leaflet map\n    # called /html/ch05-01-clipping.html\n    with open(res_line_intersect, 'w') as js_file:\n        js_file.write('var big_circle = {0}'.format(json.dumps(clip_boundary)))\n        js_file.write(\"\\n\")\n        js_file.write('var big_linestring = {0}'.format(json.dumps(simple_line)))\n        js_file.write(\"\\n\")\n        js_file.write('var simple_intersect = {0}'.format(json.dumps(out_geojson)))\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    import shapefile\n    import geojson\n    import os\n    # used to import dictionary data to shapely\n    from shapely.geometry import asShape\n    from shapely.geometry import mapping\n\n    # open roads Shapefile that we want to clip with pyshp\n    roads_london = shapefile.Reader(r\"../geodata/roads_london_3857.shp\")\n\n    # open circle polygon with pyshp\n    clip_area = shapefile.Reader(r\"../geodata/clip_area_3857.shp\")\n\n    # access the geometry of the clip area circle\n    clip_feature = clip_area.shape()\n\n    # convert pyshp object to shapely\n    clip_shply = asShape(clip_feature)\n\n    # create a list of all roads features and attributes\n    roads_features = roads_london.shapeRecords()\n\n    # variables to hold new geometry\n    roads_clip_list = []\n    roads_shply = []\n\n    # run through each geometry, convert to shapely geom and intersect\n    for feature in roads_features:\n        roads_london_shply = asShape(feature.shape.__geo_interface__)\n        roads_shply.append(roads_london_shply)\n        roads_intersect = roads_london_shply.intersection(clip_shply)\n\n        # only export linestrings, shapely also created points\n        if roads_intersect.geom_type == \"LineString\":\n            roads_clip_list.append(roads_intersect)\n\n    # open writer to write our new shapefile too\n    pyshp_writer = shapefile.Writer()\n\n    # create new field\n    pyshp_writer.field(\"name\")\n\n    # convert our shapely geometry back to pyshp, record for record\n    for feature in roads_clip_list:\n        geojson = mapping(feature)\n\n        # create empty pyshp shape\n        record = shapefile._Shape()\n\n        # shapeType 3 is linestring\n        record.shapeType = 3\n        record.points = geojson[\"coordinates\"]\n        record.parts = [0]\n\n        pyshp_writer._shapes.append(record)\n        # add a list of attributes to go along with the shape\n        pyshp_writer.record([\"empty record\"])\n\n    # save to disk\n    pyshp_writer.save(r\"../geodata/roads_clipped2.shp\")\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    from shapely.geometry import asShape\n    from shapely.ops import polygonize\n    import json\n    import os\n\n    # define output GeoJSON file\n    output_result = os.path.realpath(\"../geodata/ch05-02-geojson.js\")\n\n    # input GeoJSON features\n    line_geojs = {\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"properties\":{\"name\":\"line to clip\"},\"geometry\":{\"type\":\"LineString\",\"coordinates\":[[5.767822265625,50.14874640066278],[11.901806640625,50.13466432216696],[4.493408203125,48.821332549646634]]}}]}\n    poly_geojs = {\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"properties\":{\"name\":\"Clipping boundary circle\"},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[6.943359374999999,50.45750402042058],[7.734374999999999,51.12421275782688],[8.96484375,51.316880504045876],[10.1513671875,51.34433866059924],[10.8544921875,51.04139389812637],[11.25,50.56928286558243],[11.25,49.89463439573421],[10.810546875,49.296471602658094],[9.6240234375,49.03786794532644],[8.1298828125,49.06666839558117],[7.5146484375,49.38237278700955],[6.8994140625,49.95121990866206],[6.943359374999999,50.45750402042058]]]}}]}\n\n    # create shapely geometry from FeatureCollection\n    # access only the geomety part of GeoJSON\n    cutting_line = asShape(line_geojs['features'][0]['geometry'])\n    poly_to_split = asShape(poly_geojs['features'][0]['geometry'])\n\n    # convert circle polygon to linestring of circle boundary\n    bndry_as_line = poly_to_split.boundary\n\n    # combine new boundary lines with the input set of lines\n    result_union_lines = bndry_as_line.union(cutting_line)\n\n    # re-create polygons from unioned lines\n    new_polygons = polygonize(result_union_lines)\n\n    # stores the final split up polygons\n    new_cut_ply = []\n\n    # identify which new polygon we want to keep\n    for poly in new_polygons:\n        # check if new poly is inside original otherwise ignore it\n        if poly.centroid.within(poly_to_split):\n            print (\"creating polgon\")\n            # add only polygons that overlap original for export\n            new_cut_ply.append(poly)\n        else:\n            print (\"This polygon is outside of the input features\")\n\n    # define output GeoJSON dictionary\n    out_geojson = dict(type='FeatureCollection', features=[])\n\n    # generate GeoJSON features\n    for (index_num, geom) in enumerate(new_cut_ply):\n        feature = dict(type='Feature', properties=dict(id=index_num))\n        feature['geometry'] = geom.__geo_interface__\n        out_geojson['features'].append(feature)\n\n    # write out GeoJSON to JavaScript file\n    # this file is read in our HTML and\n    # displayed as GeoJSON on the leaflet map\n    # called /html/ch05-02.html\n    with open(output_result, 'w') as js_file:\n        js_file.write('var cut_poly_result = {0}'.format(json.dumps(out_geojson)))\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    from shapely.geometry import asShape\n    import json\n    import os\n    from pyproj import Proj, transform\n\n    # define the pyproj CRS\n    # our output CRS\n    wgs84 = Proj(\"+init=EPSG:4326\")\n    # output CRS\n    pseudo_mercator = Proj(\"+init=EPSG:3857\")\n\n    def transform_point(in_point, in_crs, out_crs):\n        \"\"\"\n        export a Shapely geom to GeoJSON and\n        transform to a new coordinate system with pyproj\n        :param in_point: shapely geometry as point\n        :param in_crs: pyproj crs definition\n        :param out_crs:  pyproj output crs definition\n        :return: GeoJSON transformed to out_crs\n        \"\"\"\n        geojs_geom = in_point.__geo_interface__\n\n        x1 = geojs_geom['coordinates'][0]\n        y1 = geojs_geom['coordinates'][1]\n\n        # transform the coordinate\n        x, y = transform(in_crs, out_crs, x1, y1)\n\n        # create output new point\n        new_point = dict(type='Feature', properties=dict(id=1))\n        new_point['geometry'] = geojs_geom\n        new_coord = (x, y)\n        # add newly transformed coordinate\n        new_point['geometry']['coordinates'] = new_coord\n\n        return new_point\n\n    def transform_linestring(orig_geojs, in_crs, out_crs):\n        \"\"\"\n        transform a GeoJSON linestring to\n          a new coordinate system\n        :param orig_geojs: input GeoJSON\n        :param in_crs: original input crs\n        :param out_crs: destination crs\n        :return: a new GeoJSON\n        \"\"\"\n        line_wgs84 = orig_geojs\n        wgs84_coords = []\n        # transfrom each coordinate\n        for x, y in orig_geojs['geometry']['coordinates']:\n            x1, y1 = transform(in_crs, out_crs, x, y)\n            line_wgs84['geometry']['coordinates'] = x1, y1\n            wgs84_coords.append([x1, y1])\n\n        # create new GeoJSON\n        new_wgs_geojs = dict(type='Feature', properties={})\n        new_wgs_geojs['geometry'] = dict(type='LineString')\n        new_wgs_geojs['geometry']['coordinates'] = wgs84_coords\n\n        return new_wgs_geojs\n\n    # define output GeoJSON file\n    output_result = os.path.realpath(\"../geodata/ch05-03-geojson.js\")\n\n    line_geojs = {\"type\": \"Feature\", \"properties\": {}, \"geometry\": {\"type\": \"LineString\", \"coordinates\": [[-13643703.800790818,5694252.85913249],[-13717083.34794459,6325316.964654908]]}}\n\n    # create shapely geometry from FeatureCollection\n    shply_line = asShape(line_geojs['geometry'])\n\n    # get the coordinates of each vertex in our line\n    line_original = list(shply_line.coords)\n    print line_original\n\n    # showing how to reverse a linestring\n    line_reversed = list(shply_line.coords)[::-1]\n    print line_reversed\n\n    # example of the same reversing function on a string for example\n    hello = 'hello world'\n    reverse_hello = hello[::-1]\n    print reverse_hello\n\n    # locating the point on a line based on distance from line start\n    # input in meters = to 360 Km from line start\n    point_on_line = shply_line.interpolate(360000)\n\n    # transform input linestring and new point\n    # to wgs84 for visualization on web map\n    wgs_line = transform_linestring(line_geojs, pseudo_mercator, wgs84)\n    wgs_point = transform_point(point_on_line, pseudo_mercator, wgs84)\n\n    # write to disk the results\n    with open(output_result, 'w') as js_file:\n        js_file.write('var point_on_line = {0}'.format(json.dumps(wgs_point)))\n        js_file.write('\\n')\n        js_file.write('var in_linestring = {0}'.format(json.dumps(wgs_line)))\n    ```", "```py\n[(-13643703.800790818, 5694252.85913249), (-13717083.34794459, 6325316.964654908)]\n[(-13717083.34794459, 6325316.964654908), (-13643703.800790818, 5694252.85913249)]\n\n```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    from shapely.geometry import asShape\n    import json\n    import os\n    from pyproj import Proj, transform\n\n    # define the pyproj CRS\n    # our output CRS\n    wgs84 = Proj(\"+init=EPSG:4326\")\n    # output CRS\n    pseudo_mercator = Proj(\"+init=EPSG:3857\")\n\n    def transform_point(in_point, in_crs, out_crs):\n        \"\"\"\n        export a Shapely geom to GeoJSON Feature and\n        transform to a new coordinate system with pyproj\n        :param in_point: shapely geometry as point\n        :param in_crs: pyproj crs definition\n        :param out_crs: pyproj output crs definition\n        :return: GeoJSON transformed to out_crs\n        \"\"\"\n        geojs_geom = in_point.__geo_interface__\n\n        x1 = geojs_geom['coordinates'][0]\n        y1 = geojs_geom['coordinates'][1]\n\n        # transform the coordinate\n        x, y = transform(in_crs, out_crs, x1, y1)\n\n        # create output new point\n        out_pt = dict(type='Feature', properties=dict(id=1))\n        out_pt['geometry'] = geojs_geom\n        new_coord = (x, y)\n        # add newly transformed coordinate\n        out_pt['geometry']['coordinates'] = new_coord\n\n        return out_pt\n\n    def transform_geom(orig_geojs, in_crs, out_crs):\n        \"\"\"\n        transform a GeoJSON linestring or Point to\n          a new coordinate system\n        :param orig_geojs: input GeoJSON\n        :param in_crs: original input crs\n        :param out_crs: destination crs\n        :return: a new GeoJSON\n        \"\"\"\n\n        wgs84_coords = []\n        # transfrom each coordinate\n        if orig_geojs['geometry']['type'] == \"LineString\":\n            for x, y in orig_geojs['geometry']['coordinates']:\n                x1, y1 = transform(in_crs, out_crs, x, y)\n                orig_geojs['geometry']['coordinates'] = x1, y1\n                wgs84_coords.append([x1, y1])\n            # create new GeoJSON\n            new_wgs_geojs = dict(type='Feature', properties={})\n            new_wgs_geojs['geometry'] = dict(type='LineString')\n            new_wgs_geojs['geometry']['coordinates'] = wgs84_coords\n\n            return new_wgs_geojs\n\n        elif orig_geojs['geometry']['type'] == \"Point\":\n\n            x = orig_geojs['geometry']['coordinates'][0]\n            y = orig_geojs['geometry']['coordinates'][1]\n            x1, y1 = transform(in_crs, out_crs, x, y)\n            orig_geojs['geometry']['coordinates'] = x1, y1\n            coord = x1, y1\n            wgs84_coords.append(coord)\n\n            new_wgs_geojs = dict(type='Feature', properties={})\n            new_wgs_geojs['geometry'] = dict(type='Point')\n            new_wgs_geojs['geometry']['coordinates'] = wgs84_coords\n\n            return new_wgs_geojs\n        else:\n            print(\"sorry this geometry type is not supported\")\n\n    # define output GeoJSON file\n    output_result = os.path.realpath(\"../geodata/ch05-04-geojson.js\")\n\n    line = {\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"LineString\",\"coordinates\":[[-49.21875,19.145168196205297],[-38.49609375,32.24997445586331],[-27.0703125,22.105998799750576]]}}\n    point = {\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-33.57421875,32.54681317351514]}}\n\n    new_line = transform_geom(line, wgs84, pseudo_mercator)\n    new_point = transform_geom(point, wgs84, pseudo_mercator)\n\n    shply_line = asShape(new_line['geometry'])\n    shply_point = asShape(new_point['geometry'])\n\n    # perform interpolation and project point to line\n    pt_interpolate = shply_line.interpolate(shply_line.project(shply_point))\n\n    # print coordinates and distance to console\n    print (\"origin point coordinate\")\n    print (point)\n\n    print (\"interpolted point location\")\n    print (pt_interpolate)\n\n    print \"distance from origin to interploate point\"\n    print (shply_point.distance(pt_interpolate))\n\n    # convert new point to wgs84 GeoJSON\n    snapped_pt = transform_point(pt_interpolate, pseudo_mercator, wgs84)\n\n    # our original line and point are transformed\n    # so here they are again in original coords\n    # to plot on our map\n    line_orig = {\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"LineString\",\"coordinates\":[[-49.21875,19.145168196205297],[-38.49609375,32.24997445586331],[-27.0703125,22.105998799750576]]}}\n    point_orig = {\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Point\",\"coordinates\":[-33.57421875,32.54681317351514]}}\n\n    # write to disk the results\n    with open(output_result, 'w') as js_file:\n        js_file.write('var input_pt = {0}'.format(json.dumps(snapped_pt)))\n        js_file.write('\\n')\n        js_file.write('var orig_pt = {0}'.format(json.dumps(point_orig)))\n        js_file.write('\\n')\n        js_file.write('var line = {0}'.format(json.dumps(line_orig)))\n    ```", "```py\n>>> python python-geospatial-analysis-cookbook/ch05/code/ch05-04_snap_point2line.py\n\n```", "```py\nimport math\n3d_dist = math.sqrt((x2 – x1)**2 + (y2 – y1)**2 + (z2 – z1)**2 )\n\n```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    import math\n    import os\n    from shapely.geometry import shape, Point\n    import json\n\n    def pairs(lst):\n        \"\"\"\n        yield iterator of two coordinates of linestring\n        :param lst: list object\n        :return: yield iterator of two coordinates\n        \"\"\"\n        for i in range(1, len(lst)):\n            yield lst[i - 1], lst[i]\n\n    def calc_3d_distance_2pts(x1, y1, z1, x2, y2, z2):\n        \"\"\"\n        :input two point coordinates (x1,y1,z1),(x2,y2,2)\n        :param x1: x coordinate first segment\n        :param y1: y coordiante first segment\n        :param z1: z height value first coordinate\n        :param x2: x coordinate second segment\n        :param y2: y coordinate second segment\n        :param z2: z height value second coordinate\n        :return: 3D distance between two input 3D coordinates\n        \"\"\"\n        d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)\n        return d\n\n    def readin_json(jsonfile):\n        \"\"\"\n        input: geojson or json file\n        \"\"\"\n        with open(jsonfile) as json_data:\n            d = json.load(json_data)\n            return d\n\n    geoj_27563_file = os.path.realpath(\"../geodata/velowire_stage_16_27563_utf8.geojson\")\n    print (geoj_27563_file)\n    # create python dict type from geojson file object\n    json_load = readin_json(geoj_27563_file)\n\n    # set start lengths\n    length_3d = 0.0\n    length_2d = 0.0\n\n    # go through each geometry in our linestring\n    for f in json_load['features']:\n        # create shapely shape from geojson\n        s = shape(f['geometry'])\n\n        # calculate 2D total length\n        length_2d = s.length\n\n        # set start elevation\n        elevation_gain = 0\n\n        # go through each coordinate pair\n        for vert_start, vert_end in pairs(s.coords):\n            line_start = Point(vert_start)\n            line_end = Point(vert_end)\n\n            # create input coordinates\n            x1 = line_start.coords[0][0]\n            y1 = line_start.coords[0][1]\n            z1 = line_start.coords[0][2]\n            x2 = line_end.coords[0][0]\n            y2 = line_end.coords[0][1]\n            z2 = line_end.coords[0][2]\n\n            # calculate 3d distance\n            distance = calc_3d_distance_2pts(x1, y1, z1, x2, y2, z2)\n\n            # sum distances from vertex to vertex\n            length_3d += distance\n\n            # calculate total elevation gain\n            if z1 > z2:\n                elevation_gain = ((z1 - z2) + elevation_gain )\n                z2 = z1\n            else:\n                elevation_gain = elevation_gain  # no height change\n                z2 = z1\n\n    print (\"total elevation gain is: {gain} meters\".format(gain=str(elevation_gain)))\n\n    # print coord_pair\n    distance_3d = str(length_3d / 1000)\n    distance_2d = str(length_2d / 1000)\n    dist_diff = str(length_3d - length_2d)\n\n    print (\"3D line distance is: {dist3d} meters\".format(dist3d=distance_3d))\n    print (\"2D line distance is: {dist2d} meters\".format(dist2d=distance_2d))\n    print (\"3D-2D length difference: {diff} meters\".format(diff=dist_diff))\n    ```", "```py\ntotal elevation gain is: 4322.0 meters\n3D line distance is: 244.119162551\n2D line distance is: 243.55802081\n3D-2D length difference: 561.141741137 meters\n\n```"]