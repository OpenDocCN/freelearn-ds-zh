<html><head></head><body>
		<div><h1 id="_idParaDest-46"><em class="italic"><a id="_idTextAnchor045"/>Chapter 2</em>: Quantum Computing and Qubits with Python</h1>
			<p>Quantum computing is a fairly new and fairly old field at the same time. The ideas and concepts used to achieve quantum computing (such as quantum mechanical superposition and entanglement) have been around for almost a century and the field of quantum information science was founded almost 40 years ago. Early explorers, such as Peter Shor and Lov Grover, produced quantum computing algorithms (Shor's algorithm and Grover's algorithm) that are now starting to become as well known as foundational physics concepts such as <em class="italic">E=mc</em><em class="italic">2</em>. For details, see the references at the end of the chapter.</p>
			<p>At the same time, real quantum computers that utilize these effects are a relatively recent invention. The requirements for building one were outlined by DiVincenzo in the 1990, and IBM opened up its IBM Quantum Experience® and Qiskit® in 2016, effectively the first time anyone outside of a research lab could start exploring this nascent field for real.</p>
			<p>So, what is the difference between classical computing and quantum computing? One way to start exploring is by taking a look at the basic computational elements used by each—the classical bits and the quantum qubits.</p>
			<p>In this chapter, we will contrast bits and qubits, play with some generic linear algebra to explore them in more detail, and contrast deterministic (classical) computation and probabilistic (quantum) computation. We will even take a quick look at some basic Qiskit® presentation methods to visualize a qubit.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Comparing a bit and a qubit</li>
				<li>Visualizing a qubit in Python</li>
				<li>A quick introduction to quantum gates</li>
			</ul>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Technical requirements</h1>
			<p>The recipes that we discuss in this chapter can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter02">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter02</a>.</p>
			<p>For more information about how to get the recipe sample code, refer to the <em class="italic">Downloading the code samples</em> section in <a href="B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Environment</em>.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Comparing a bit and a qubit</h1>
			<p>So, let's start with the <a id="_idIndexMarker050"/>obvious—or perhaps, not so obvious—notion that most people who read this book know what a bit is.</p>
			<p>An intuitive feeling that we have says that a bit is something that is either <strong class="bold">zero</strong> (<strong class="bold">0</strong>) or <strong class="bold">one</strong> (<strong class="bold">1</strong>). By putting many <a id="_idIndexMarker051"/>bits together, you can create bytes as well as arbitrary large binary numbers, and with those, build the most amazing computer programs, encode digital images, encrypt your love letters and bank transactions, and more.</p>
			<p>In a classical computer, a bit is realized by using low or high voltages over the transistors that make up the logic board, typically something such as 0 V and 5 V. In a hard drive, the bit might be a region magnetized in a certain way to represent 0 and the other way for 1, and so on.</p>
			<p>In books about quantum computing, the important point to drive home is that a classical bit can only be a 0 or a 1; it can never be anything else. In the computer example, you can imagine a box with an input and an output, where the box represents the program that you are running. With a classical computer (and I use the term classical here to indicate a binary computer that is not a quantum computer), the input is a string of bits, the output is another string of bits, and the box is a bunch of bits being manipulated, massaged, and organized to generate that output with some kind of algorithm. An important thing, again, to emphasize is that while in the box, the bits are still bits, always 0s or 1s, and nothing else.</p>
			<p>A qubit, as we will discover in this chapter, is something quite different. Let's go explore.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Getting ready</h2>
			<p>As recipes go, this one isn't really that much to brag about. It is just a quick Python and NumPy implementation that defines a bit as a 2x1 matrix, or a vector representing 0 or 1. We also introduce the Dirac notation of <img alt="" src="img/Formula_02_001.png"/> to represent our qubits. We then calculate the<a id="_idIndexMarker052"/> probability of getting various results when measuring the bits and qubits.</p>
			<p>The Python file for the<a id="_idIndexMarker053"/> following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r1_bits_qubits.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r1_bits_qubits.py</a>.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>How to do it...</h2>
			<ol>
				<li>Let's start by importing <code>numpy</code> and <code>math</code>, which we will need to do the calculations:<pre>import numpy as np
from math import sqrt, pow</pre></li>
				<li>Create and print the bit and qubit vectors for 0, 1, <img alt="" src="img/Formula_02_001.png"/> as <code>[1,0]</code>, <code>[0,1]</code>, <code>[1,0]</code>, <code>[0,1]</code>, and <code>[a,b]</code>, respectively:<pre># Define the qubit parameters for superposition
a = sqrt(1/2)
b = sqrt(1/2)
if round(pow(a,2)+pow(b,2),0)!=1:
    print("Your qubit parameters are not normalized.
        \nResetting to basic superposition")
    a = sqrt(1/2)
    b = sqrt(1/2)
bits = {"bit = 0":np.array([1,0]), 
    "bit = 1":np.array([0,1]), 
    "|0\u27E9":np.array([1,0]), 
    "|1\u27E9":np.array([0,1]), 
    "a|0\u27E9+b|1\u27E9":np.array([a,b])}
# Print the vectors 
for b in bits:
  print(b, ": ", bits[b].round(3)) 
print ("\n")</pre><p>Notice the Unicode entries here: <code>\u27E9</code>. We use this instead of just <code>&gt;</code> to create the nice-looking Dirac qubit rendering <img alt="" src="img/Formula_02_003.png"/> in the output.</p><p class="callout-heading">You must provide the correct a and b parameters</p><p class="callout">Note that the parameter verification code checks whether the values for <code>a</code> and <code>b</code> are <em class="italic">normalized</em>. If not, then <code>a</code> and <code>b</code> are reset to a simple 50/50 superposition by setting <img alt="" src="img/Formula_02_004.png"/> and <img alt="" src="img/Formula_02_005.png"/>.</p></li>
				<li>Measure the qubits by creating <a id="_idIndexMarker054"/>a measurement dictionary, and then<a id="_idIndexMarker055"/> calculate the probability of getting <code>0</code> and <code>1</code> from the bit vectors we created:<pre>print("'Measuring' our bits and qubits")
print("-------------------------------")
prob={}
for b in bits:
    print(b)
    print("Probability of getting:")
    for dig in range(len(bits[b])):
        prob[b]=pow(bits[b][dig],2)
        print(dig, " = ", '%.2f'%(prob[b]*100), percent") 
    print ("\n")</pre></li>
			</ol>
			<p>The preceding code should give the following output:</p>
			<div><div><img alt="Figure 2.1 – Simulating bits and qubits with NumPy&#13;&#10;" src="img/Figure_2.1_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Simulating bits and qubits with NumPy</p>
			<p>Now we <a id="_idIndexMarker056"/>know what the probabilities of getting the values of <code>0</code> or <code>1</code> are when measuring the bits and qubits. For some of these (0, 1, <img alt="" src="img/Formula_02_006.png"/>) the outcome is what we expected, 0 or 100%; the bit or qubit is either 0 or 1 and nothing else. For one (<img alt="" src="img/Formula_02_007.png"/>), which is a<a id="_idIndexMarker057"/> qubit that is in a superposition of 0 and 1, the probability of getting either is 50%. This is an outcome that can never happen for a classical bit, only for a qubit. We will explain why in the next section. </p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>How it works...</h2>
			<p>What we have seen in this recipe is that<a id="_idIndexMarker058"/> the probability of reading a classical bit will always be <em class="italic">100%</em>, either 0 or 1; there are no other options. But for a qubit that can be expressed as <img alt="" src="img/Formula_02_008.png"/> the probability of a 0 or 1 is proportional to <img alt="" src="img/Formula_02_009.png"/>. For pure <img alt="" src="img/Formula_02_010.png"/> states, <em class="italic">a</em> or <em class="italic">b</em> is always 1, and the probability of measuring each is 100%. But for the qubit that we labeled <img alt="" src="img/Formula_02_011.png"/>, a and b are both <img alt="" src="img/Formula_02_012.png"/>, giving a probability of 50% for 0 or 1 <img alt="" src="img/Formula_02_013.png"/>.</p>
			<p class="callout-heading">Measuring a bit and a qubit</p>
			<p class="callout">The word <strong class="bold">measure</strong> means two<a id="_idIndexMarker059"/> slightly different things in classical computing and quantum computing. In classical computing, you can measure your bits at any time without seriously disturbing the calculations that you are doing. For a quantum computer, measuring is a more definite act that results in your qubit reverting from a bit that behaves quantum-mechanically to a bit that behaves classically. After you measure a qubit, you are done. You can do no further quantum actions on that qubit.</p>
			<p>Due to the quantum mechanical nature of a qubit, we can describe it as a vector similar to the vector we use for a bit. To clarify that, when we are talking about qubits, we do not just use 0 and 1 as labels, but rather the Dirac <em class="italic">ket</em> notation, <img alt="" src="img/Formula_02_014.png"/> and <img alt="" src="img/Formula_02_015.png"/>, indicating that these are state vectors in a vector space.</p>
			<p>We can write out the state vector, <img alt="" src="img/Formula_02_016.png"/> (psi), of a qubit like this:</p>
			<ul>
				<li><img alt="" src="img/Formula_02_017.png"/> for a qubit in the <em class="italic">ground state</em>, representing 0</li>
				<li><img alt="" src="img/Formula_02_018.png"/> for a qubit in the <em class="italic">excited state</em>, representing 1</li>
			</ul>
			<p>Here, we have used <strong class="bold">ground state</strong> and <strong class="bold">excited state</strong> as one way of categorizing qubits. This is appropriate<a id="_idIndexMarker060"/> as the Josephson junctions that the IBM Quantum® qubits use are quantum<a id="_idIndexMarker061"/> systems with two energy levels. Depending on the underlying physical system, qubits can also be based on other two-level quantum systems, such as electron spin (up or down) or photon <a id="_idIndexMarker062"/>polarization (horizontal or vertical). </p>
			<p>So far, nothing is<a id="_idIndexMarker063"/> intuitively much different from classical bits, as each represents just the value 0 or 1. But now we add a complexity: a qubit can also be a superposition of the two states, <img alt="" src="img/Formula_02_019.png"/> and <img alt="" src="img/Formula_02_020.png"/>.</p>
			<p><img alt="" src="img/Formula_02_021.png"/>, where <em class="italic">a</em> and <em class="italic">b</em> are complex numbers. These numbers are normalized so that <img alt="" src="img/Formula_02_022.png"/>, which geometrically means that the resulting vector, <img alt="" src="img/Formula_02_023.png"/>, has a length of 1. This is important!</p>
			<p>Going back to the simplest cases, these can be described as follows:</p>
			<ul>
				<li><img alt="" src="img/Formula_02_024.png"/> for a qubit in the ground state. In this case, a=1 and b=0.</li>
				<li><img alt="" src="img/Formula_02_025.png"/> for a qubit in the excited state. In this case, a=0 and b=1.</li>
			</ul>
			<p>So far, so good, but now we add the quantum twist: superposition. The following qubit state vector is also supported:</p>
			<p><img alt="" src="img/Formula_02_026.png"/></p>
			<p>Just to check that we are still normalized, in this case,</p>
			<p><img alt="" src="img/Formula_02_027.png"/>.</p>
			<p>But what does this state vector mean?</p>
			<p>The qubit is set up in a state where it is exactly halfway between <img alt="" src="img/Formula_02_028.png"/> and <img alt="" src="img/Formula_02_029.png"/>; it exists in a superposition of the two basic states. It is behaving quantumly.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The quantum superposition state of a qubit can only be sustained while we are doing calculations on the <a id="_idIndexMarker064"/>quantum computer. The same is true for an actual particle in nature, such as a photon that behaves quantum-mechanically. For example, the polarization of the photon can be described as a superposition of horizontal and vertical orientations while the photon is in flight, but when you add a polarizer in its path, you will measure it as either horizontal or vertical, and nothing else.</p>
			<p>Going back to the computer-as-a-box example, for a quantum computer we have a similar image, a string of bits as<a id="_idIndexMarker065"/> input and another string of bits as output. The difference comes inside the box where the qubits can exist in superposition while we are doing our calculations.</p>
			<p>As soon as we<a id="_idIndexMarker066"/> measure the qubits to get that string of output bits however, the qubits must decide, quantum-mechanically, if they are a <img alt="" src="img/Formula_02_030.png"/> or a <img alt="" src="img/Formula_02_031.png"/>, and here is where those <em class="italic">a</em> and <em class="italic">b</em> parameters come in.</p>
			<p>The <img alt="" src="img/Formula_02_032.png"/> formula not <a id="_idIndexMarker067"/>only states that the vector is normalized to the length 1, but it also describes the probability of getting the <img alt="" src="img/Formula_02_033.png"/> and <img alt="" src="img/Formula_02_034.png"/> outputs. The probability of getting <img alt="" src="img/Formula_02_035.png"/> is <img alt="" src="img/Formula_02_036.png"/>, and <img alt="" src="img/Formula_02_037.png"/> is <img alt="" src="img/Formula_02_038.png"/>. This is the core of the difference between a quantum computer and a classical computer. The quantum computer is probabilistic—you cannot know in advance what the end result will be, only the probability of getting a certain result—whereas the classical computer is deterministic—you can always, at least in theory, predict what the answer will be.</p>
			<p class="callout-heading">About probabilistic computing</p>
			<p class="callout">People often get a little confused about quantum computers and probabilistic outcomes and visualize the whole<a id="_idIndexMarker068"/> quantum programming concept as qubits spinning randomly and uncontrollably in all different states at the same time. This is not a true picture; each qubit is initialized in a specific known state, <img alt="" src="img/Formula_02_144.png"/>, and then acted upon by quantum gate manipulations. Each manipulation is strictly deterministic; there is nothing random. At each stage in a quantum state evolution, we know exactly what our qubit is doing, expressed as an <img alt="" src="img/Formula_02_039.png"/> superposition. It is only at the end, when we measure and force the qubit to be either 0 or 1, that the probabilistic nature shows with the probability of measuring 0 or 1 set by the <em class="italic">a</em> and <em class="italic">b</em> parameters (<img alt="" src="img/Formula_02_040.png"/>). </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>See also</h2>
			<p>For more information about<a id="_idIndexMarker069"/> qubits and how to interpret them, refer to the following excellent books:</p>
			<ul>
				<li><em class="italic">Dancing with Qubits, How quantum computing works and how it can change the world</em>, Robert S. Sutor, Packt Publishing Ltd., 2019, <a href="B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197"><em class="italic">Chapter 7</em></a>, <em class="italic">One Qubit</em></li>
				<li><em class="italic">Quantum Computation and Quantum Information</em>, Isaac L. Chuang; Michael A. Nielsen, Cambridge University Press, 2010, <em class="italic">Chapter 1.2</em>, <em class="italic">Quantum bits</em></li>
				<li><em class="italic">Quantum Mechanics: The theoretical minimum</em>, Leonard Susskind &amp; Art Friedman, Basic Books, 2015, <em class="italic">Lecture 1: Systems and experiments</em></li>
				<li><em class="italic">Shor, I'll do it</em>, Scott <a id="_idIndexMarker070"/>Aaronson's blog, <a href="https://www.scottaaronson.com/blog/?p=208">https://www.scottaaronson.com/blog/?p=208</a></li>
				<li><em class="italic">What's a Quantum Phone Book?</em>, Lov Grover, Lucent Technologies, <a href="https://web.archive.org/web/20140201230754/http://www.bell-labs.com/user/feature/archives/lkgrover/">https://web.archive.org/web/20140201230754/http://www.bell-labs.com/user/feature/archives/lkgrover/</a></li>
				<li><em class="italic">The Physical Implementation of Quantum Computation</em>, David P. DiVincenzo, IBM, <a href="https://arxiv.org/abs/quant-ph/0002077">https://arxiv.org/abs/quant-ph/0002077</a></li>
			</ul>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Visualizing a qubit in Python</h1>
			<p>In this recipe, we <a id="_idIndexMarker071"/>will use generic Python with NumPy to create a vector and visual representation of a bit and show how it can be in only two states, 0 and 1. We will <a id="_idIndexMarker072"/>also introduce our first, smallish foray into the Qiskit® world by showing how a qubit can not only be in the unique 0 and 1 states but also in a superposition of these states. The way to do this is to take the vector form of the qubit and project it <a id="_idIndexMarker073"/>on the so-called <strong class="bold">Bloch sphere</strong>, for which there is a Qiskit® method. Let's get to work!</p>
			<p>In the preceding recipe, we defined our qubits with the help of two complex parameters—<em class="italic">a</em> and <em class="italic">b</em>. This meant that our qubits could take values other than the 0 and 1 of a classical bit. But it is hard to visualize a qubit halfway between 0 and 1, even if you know <em class="italic">a</em> and <em class="italic">b</em>.</p>
			<p>However, with a little mathematical trickery, it turns out that you can also describe a qubit using two angles—<strong class="bold">theta</strong> (<img alt="" src="img/Formula_02_041.png"/>) and <strong class="bold">phi</strong> (<img alt="" src="img/Formula_02_042.png"/>)—and visualize the qubit on a Bloch sphere. You can think of the <img alt="" src="img/Formula_02_0411.png"/> and <img alt="" src="img/Formula_02_0421.png"/> angles much as the latitude and longitude of the earth. On the Bloch sphere, we can project any possible value that the qubit can take.</p>
			<p>The equation for the transformation is as follows:</p>
			<p><img alt="" src="img/Formula_02_043.png"/></p>
			<p>Here, we use the formula we saw before:</p>
			<p><img alt="" src="img/Formula_02_044.png"/></p>
			<p><em class="italic">a</em> and <em class="italic">b</em> are, respectively, as follows:</p>
			<p><img alt="" src="img/Formula_02_045.png"/></p>
			<p><img alt="" src="img/Formula_02_046.png"/></p>
			<p>I'll leave the deeper details and math to you for further exploration:</p>
			<div><div><img alt="Figure 2.2 – The Bloch sphere" src="img/Figure_2.2_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The Bloch sphere. </p>
			<p>The poor classical bits cannot do much on a Bloch sphere as they can exist at the North and South poles only, representing the binary values 0 and 1. We will include them just for comparison.</p>
			<p>The reason 0 points up and 1 points down has peculiar and historical reasons. The qubit vector representation of <img alt="" src="img/Formula_02_047.png"/> is <img alt="" src="img/Formula_02_048.png"/>, or up, and <img alt="" src="img/Formula_02_049.png"/> is <img alt="" src="img/Formula_02_050.png"/>, or down, which is intuitively not what you expect. You would think that 1, or a more exciting qubit, would be a vector pointing upward, but this is not the case; it points down. So, I will do the same with the poor classical bits as well: 0 means up and 1 means down.</p>
			<p>The latitude, the distance<a id="_idIndexMarker074"/> to the poles from a cut straight through the Bloch sphere, corresponds to the <a id="_idIndexMarker075"/>numerical values of <em class="italic">a</em> and <em class="italic">b</em>, with <img alt="" src="img/Formula_02_051.png"/> pointing straight up for <img alt="" src="img/Formula_02_052.png"/> (a=1, b=0), <img alt="" src="img/Formula_02_053.png"/> pointing straight down for <img alt="" src="img/Formula_02_054.png"/> points to the equator for the basic superposition where <img alt="" src="img/Formula_02_055.png"/>.</p>
			<p>So, what we are adding to the equation here is the <em class="italic">phase</em> of the qubit. The <img alt="" src="img/Formula_02_042.png"/> angle cannot be directly measured and has no impact on the outcome of our initial quantum circuits. Later on in the book, in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>, we will see that you can use the phase angle to great advantage in certain algorithms. But we are getting ahead of ourselves.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Getting ready</h2>
			<p>The Python file for the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r2_visualize_bits_qubits.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r2_visualize_bits_qubits.py</a>.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>How to do it...</h2>
			<p>For this exercise, we will<a id="_idIndexMarker076"/> use the <img alt="" src="img/Formula_02_057.png"/> and <img alt="" src="img/Formula_02_058.png"/> angles as latitude and longitude coordinates on the Bloch sphere. We will code the 0, 1, <img alt="" src="img/Formula_02_059.png"/>, <img alt="" src="img/Formula_02_049.png"/>, and <img alt="" src="img/Formula_02_061.png"/> states with the <a id="_idIndexMarker077"/>corresponding angles. As we can set these angles to any latitude and longitude value we want, we can put the qubit state vector wherever we want on the Bloch sphere:</p>
			<ol>
				<li value="1">Import the classes and methods that we need, including <code>numpy</code> and <code>plot_bloch_</code><code>vector</code> from Qiskit®. We also need to use <code>cmath</code> to do some calculations on imaginary numbers:<pre>import numpy as np
import cmath 
from math import pi, sin, cos
from qiskit.visualization import plot_bloch_vector</pre></li>
				<li>Create the qubits:<pre># Superposition with zero phase
angles={"theta": pi/2, "phi":0}
# Self defined qubit
#angles["theta"]=float(input("Theta:\n"))
#angles["phi"]=float(input("Phi:\n"))
# Set up the bit and qubit vectors
bits = {"bit = 0":{"theta": 0, "phi":0}, 
    "bit = 1":{"theta": pi, "phi":0}, 
    "|0\u27E9":{"theta": 0, "phi":0}, 
    "|1\u27E9":{"theta": pi, "phi":0}, 
    "a|0\u27E9+b|1\u27E9":angles}</pre><p>From the code sample, you can see that we are using the theta angle only for now, with theta = 0 meaning that we point straight up and theta <img alt="" src="img/Formula_02_062.png"/> meaning straight down for<a id="_idIndexMarker078"/> our basic bits and qubits: 0, 1, <img alt="" src="img/Formula_02_063.png"/>, and <img alt="" src="img/Formula_02_064.png"/>. Theta <img alt="" src="img/Formula_02_065.png"/> takes us halfway, to the equator, and we use that for the superposition qubit, <img alt="" src="img/Formula_02_066.png"/>.</p></li>
				<li>Print the bits and qubits on the Bloch sphere.<p>The Bloch sphere<a id="_idIndexMarker079"/> method takes a three-dimensional vector as input, but we have to build the vector first. We can use the following formula to calculate the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> parameters to use with <code>plot_bloch_vector</code> and display the bits and qubits as Bloch sphere representations:</p><pre>bloch=[cos(bits[bit]["phi"])*sin(bits[bit]
    ["theta"]),sin(bits[bit]["phi"])*sin(bits[bit]
    ["theta"]),cos(bits[bit]["theta"])]</pre><p>We now cycle through the bits dictionary to display the Bloch sphere view of the bits and qubits, as well as the state vectors that correspond to them:</p><div><img alt="" src="img/Formula_02_069_(1).jpg"/></div><p>The state vector is <a id="_idIndexMarker080"/>calculated using the equation we saw previously:</p><div><img alt="" src="img/Formula_02_070.jpg"/></div><p>What we see<a id="_idIndexMarker081"/> now is that <em class="italic">a</em> and <em class="italic">b</em> can actually turn into complex values, just as defined.</p><p>Here's the code:</p><pre>for bit in bits:
     bloch=[cos(bits[bit]["phi"])*sin(bits[bit]
        ["theta"]),sin(bits[bit]["phi"])*sin(bits[bit]
        ["theta"]),cos(bits[bit]["theta"])]
    display(plot_bloch_vector(bloch, title=bit))
    # Build the state vector
    a = cos(bits[bit]["theta"]/2)
    b = cmath.exp(bits[bit]["phi"]*1j)*sin(bits[bit]
        ["theta"]/2)
    state_vector = [a * complex(1, 0), b * complex(1, 0)]
    print("State vector:", np.around(state_vector, 
        decimals = 3))</pre></li>
				<li>The sample code should give an output similar to the following examples. <p>First, we show the classical bits, 0 and 1:</p><div><img alt="Figure 2.3 – Bloch sphere visualization of classical bits" src="img/Figure_2.3_B14436.jpg"/></div><p class="figure-caption">Figure 2.3 – Bloch sphere visualization of classical bits</p></li>
				<li>Then, we show the quantum bits, or qubits, <img alt="" src="img/Formula_02_030.png"/> and <img alt="" src="img/Formula_02_029.png"/>:<div><img alt="Figure 2.4 – Bloch sphere visualization of qubits&#13;&#10;" src="img/Figure_2.4_B14436.jpg"/></div><p class="figure-caption">Figure 2.4 – Bloch sphere visualization of qubits</p></li>
				<li>Finally, we show a qubit in superposition, a mix of <img alt="" src="img/Formula_02_073.png"/> and <img alt="" src="img/Formula_02_074.png"/>:</li>
			</ol>
			<div><div><img alt="Figure 2.5 – Bloch sphere visualization of a qubit in superposition&#13;&#10;" src="img/Figure_2.5_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Bloch sphere visualization of a qubit in superposition</p>
			<p>So, there is<a id="_idIndexMarker082"/> very little that is earth-shattering with the simple 0, 1, <img alt="" src="img/Formula_02_075.png"/>, and <img alt="" src="img/Formula_02_076.png"/> displays. They simply point up and down to the north and south pole of the Bloch<a id="_idIndexMarker083"/> sphere as appropriate. If we check what the value of the bit or qubit is by measuring it, we will get 0 or 1 with 100% certainty.</p>
			<p>The qubit in superposition, calculated as <img alt="" src="img/Formula_02_077.png"/>, on the other hand, points to the equator. From the equator, it is an equally long distance to either pole, thus a 50/50 chance of getting a 0 or a 1. </p>
			<p>In the code, we include the following few lines, which define the <code>angles</code> variable that sets <img alt="" src="img/Formula_02_078.png"/> and <img alt="" src="img/Formula_02_079.png"/> for the <img alt="" src="img/Formula_02_080.png"/> qubit:</p>
			<pre># Superposition with zero phase
angles={"theta": pi/2, "phi":0}</pre>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>There's more…</h2>
			<p>We mentioned earlier that we weren't going to touch on the phase (<img alt="" src="img/Formula_02_058.png"/>) angle, at least not initially. But we can visualize <a id="_idIndexMarker084"/>what it does for our qubits. Remember that we can directly describe <em class="italic">a</em> and <em class="italic">b</em> using the angles <img alt="" src="img/Formula_02_082.png"/> and <img alt="" src="img/Formula_02_083.png"/>. </p>
			<p>To test this out, you can<a id="_idIndexMarker085"/> uncomment the lines that define the angles in the sample code:</p>
			<pre># Self-defined qubit
angles["theta"]=float(input("Theta:\n"))
angles["phi"]=float(input("Phi:\n"))</pre>
			<p>You can now define what your third qubit looks like by manipulating the <img alt="" src="img/Formula_02_084.png"/> and <img alt="" src="img/Formula_02_085.png"/> values. Let's test what we can do by running the script again and plugging in some angles.</p>
			<p>For example, we can try the following:</p>
			<p><img alt="" src="img/Formula_02_086.png"/></p>
			<p><img alt="" src="img/Formula_02_087.png"/></p>
			<p>You should see the final Bloch sphere look something like the following:</p>
			<div><div><img alt="Figure 2.6 – The qubit state vector rotated by   " src="img/Figure_2.6_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The qubit state vector rotated by <img alt="" src="img/Formula_02_088.png"/>  </p>
			<p>Note how the state vector is still on the equator with <img alt="" src="img/Formula_02_089.png"/> but now at <img alt="" src="img/Formula_02_090.png"/> angle to the <em class="italic">x</em> axis. You can<a id="_idIndexMarker086"/> also take a look at the state vector: [0.707+0.j    0.653+0.271j].</p>
			<p>We have now stepped<a id="_idIndexMarker087"/> away from the Bloch sphere prime meridian and out into the complex plane, and added a phase angle, which is represented by an imaginary state vector component along the <em class="italic">y</em> axis: <img alt="" src="img/Formula_02_091.png"/></p>
			<p class="callout-heading">Let's go on a trip</p>
			<p class="callout">Go ahead and experiment with different <img alt="" src="img/Formula_02_092.png"/> and <img alt="" src="img/Formula_02_093.png"/> angles to get other <em class="italic">a</em> and <em class="italic">b</em> entries and see where you end up. No need to include 10+ decimals for these rough estimates, two or three decimals will do just fine. Try plotting your hometown on the Bloch sphere. Remember that the script wants the input in radians and that theta starts at the North Pole, not at the equator. For example, the coordinates for Greenwich Observatory in England are 51.4779° N, 0.0015° W, which translates into: <img alt="" src="img/Formula_02_094.png"/>, <img alt="" src="img/Formula_02_095.png"/>.</p>
			<p>Here's Qiskit® and a globe displaying the same coordinates:</p>
			<div><div><img alt="Figure 2.7 – Greenwich quantumly and on a globe&#13;&#10;" src="img/Figure_2.7_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Greenwich quantumly and on a globe</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>See also</h2>
			<p><em class="italic">Quantum Computation and Quantum Information</em>, Isaac L. Chuang; Michael A. Nielsen, Cambridge University Press, 2010, <em class="italic">Chapter 1.2</em>, <em class="italic">Quantum bits</em>, and <em class="italic">Chapter 4.2</em>, <em class="italic">Single qubit operations</em>.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>A quick introduction to quantum gates</h1>
			<p>Now that we have <a id="_idIndexMarker088"/>sorted out the difference between bits and qubits, and have also understood how to visualize the qubit as a Bloch sphere, we know all that there is to know about qubits, correct? Well, not quite. A qubit, or for that matter, hundreds or thousands of qubits, is not the only thing you need to make a quantum computer! You need to perform logical operations on and with the qubits. For this, just like a classical computer, we need logical gates.</p>
			<p>I will not go into any great detail on how logical gates work, but suffice to say that a quantum gate, operates on the input of one or more qubits and outputs a result. </p>
			<p>In this recipe, we will work our way through the mathematical interpretation of few quantum gates by using matrix multiplication of single- and multi-qubit gates. Don't worry, we will not dig deep, just a little to scratch the surface. You will find a deeper look quantum gates in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit Gate Library</em>.</p>
			<p>Again, we will not be building any actual Qiskit quantum circuits just yet. We are still using more or less plain Python with some NumPy matrix manipulations to prove our points.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Getting ready</h2>
			<p>The Python file for the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r3_qubit_gates.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r3_qubit_gates.py</a>.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>How to do it...</h2>
			<p>This recipe will create vector and matrix representations of qubits and gates, and use simple algebra to illustrate<a id="_idIndexMarker089"/> the behavior of the qubits as gates are applied to them:</p>
			<ol>
				<li value="1">In your Python environment, run <code>ch2_r3_qubit_gates.py</code> and respond to the <strong class="bold">Press return to continue</strong> prompts to move along the program.</li>
				<li>First, we see the vector representations of three qubit states: <img alt="" src="img/Formula_02_075.png"/>, <img alt="" src="img/Formula_02_097.png"/>, and <img alt="" src="img/Formula_02_098.png"/>:<div><img alt="Figure 2.8 – Qubits as vectors&#13;&#10;" src="img/Figure_2.8_B14436.jpg"/></div><p class="figure-caption">Figure 2.8 – Qubits as vectors</p></li>
				<li>Next, we display the matrix representation of a couple of gates.<p>We will use the <code>Id</code> (does nothing), <code>X</code> (flips the qubit), and <code>H</code> (creates a superposition) gates:</p><div><img alt="Figure 2.9 – Single-qubit gates as matrices&#13;&#10;" src="img/Figure_2.9_B14436.jpg"/></div><p class="figure-caption">Figure 2.9 – Single-qubit gates as matrices</p></li>
				<li>The final step for our single-qubit setup is to see how each gate manipulates the qubits.  <p>This is done using matrix multiplication of the qubit vector and the gate matrix:</p><div><img alt="Figure 2.10 – Gates acting on qubits&#13;&#10;" src="img/Figure_2.10_B14436.jpg"/></div><p class="figure-caption">Figure 2.10 – Gates acting on qubits</p></li>
				<li>With the single <a id="_idIndexMarker090"/>qubits done, we now move on to working with combinations of two qubit states: <img alt="" src="img/Formula_02_099.png"/>:<div><img alt="Figure 2.11 – Two qubits as vectors&#13;&#10;" src="img/Figure_2.11_B14436.jpg"/></div><p class="figure-caption">Figure 2.11 – Two qubits as vectors</p></li>
				<li>Like for the single qubits, we now show the matrix representations of the two-qubit quantum gates.<p>Here, we use <code>CX</code> (controlled NOT, flips one qubit if the other is 1) and <code>swap</code> (swaps the values of the two qubits):</p><div><img alt="Figure 2.12 – Two-qubit gates as matrices&#13;&#10;" src="img/Figure_2.12_B14436.jpg"/></div><p class="figure-caption">Figure 2.12 – Two-qubit gates as matrices</p></li>
				<li>Finally, let's see gate manipulations of our multi-qubit states.<p>Again, we have a<a id="_idIndexMarker091"/> matrix multiplication of the qubits vector and the gate matrix:</p></li>
			</ol>
			<div><div><img alt="Figure 2.13 – Multi-qubit gates acting on two qubits&#13;&#10;" src="img/Figure_2.13_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13 – Multi-qubit gates acting on two qubits</p>
			<p>That's it… we have now witnessed Python-generated linear algebra that describes how our qubits are defined and how they behave when gates are applied to them.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>How it is works…</h2>
			<p>The previous section <a id="_idIndexMarker092"/>contained a lot of printed information with very little explanation of how we got those results. Let's dig into the sample code to see how the output is generated:</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The numbered steps that follow correspond to the same numbered steps in the preceding <em class="italic">How to do it…</em> section. Refer back to those steps to see the result of the code samples that follow.</p>
			<ol>
				<li value="1">Let's start by importing the math tools we need:<pre>import numpy as np
from math import sqrt</pre></li>
				<li>Set up the basic vectors for our qubits.<p>A qubit set to the value 0 is labeled <img alt="" src="img/Formula_02_100.png"/> in the Dirac ket notation and is mathematically represented by the <img alt="" src="img/Formula_02_101.png"/> vector, if it is set to 1 as <img alt="" src="img/Formula_02_102.png"/>, or the <img alt="" src="img/Formula_02_103.png"/> vector. So far, so good, still only 0 and 1. As we have seen, the real magic comes when you have a qubit set to a superposition value represented by a vector pointing to the equator of the Bloch sphere, or anywhere except the poles—for example, <img alt="" src="img/Formula_02_104.png"/>, which would be represented by the following vector: </p><div><img alt="" src="img/Formula_02_105.jpg"/></div><pre>np.array([1,0])</pre><p>Here's how we create<a id="_idIndexMarker093"/> a dictionary of our qubits in the sample:</p><pre>qubits = {"|0\u27E9":np.array([1,0]), 
    "|1\u27E9":np.array([0,1]), 
    "(|0\u27E9+|1\u27E9)/\u221a2":1/sqrt(2)*np.
    array([1,1])}
for q in qubits:
  print(q, "\n", qubits[q].round(3))</pre></li>
				<li>Set up the basic matrices for our quantum gates.<p>For qubits, any single-qubit gate can be represented by a 2x2 matrix like this: <img alt="" src="img/Formula_02_109.png"/>.</p><p>For single qubits, the math that we have implemented is a matrix operation that corresponds to the truth table for the two operations, <em class="italic">ID</em> and <em class="italic">NOT</em> (or <em class="italic">X</em>, as the quantum gate is called):</p><pre>np.array([[0, 1], [1, 0]])</pre><p>Here's how we create a dictionary of our gates in the sample:</p><pre>gates ={"id":np.array([[1, 0], [0, 1]]),
    "x":np.array([[0, 1], [1, 0]]), 
    "h":1/sqrt(2)*np.array([[1, 1], [1, -1]])}
for g in gates:
  print(g, "\n", gates[g].round(3)) </pre></li>
				<li>Now, let's use NumPy to apply the defined gates on our qubits.<p>The application of a gate on a qubit can be expressed as a vector multiplication of the qubit and the<a id="_idIndexMarker095"/> gate. Here's the NumPy matrix dot multiplication for an X gate on the <img alt="" src="img/Formula_02_120.png"/> qubit:</p><pre>np.dot(np.array([[0, 1], [1, 0]]), np.array([1,0]))</pre><p>In our sample, we step our way through the two dictionaries that we created, applying the matrix multiplication to each gate/qubit combination:</p><pre>for g in gates:
    print("Gate:",g) 
    for q in qubits:
        print(q,"\n",qubits[q].round(3),"-&gt;", 
            np.dot(gates[g],qubits[q]).round(3))</pre><p>Here, we see the expected behavior of the gates on our qubits: the ID gate does nothing, the X gate flips the qubit, and the H gate creates or uncreates a superposition. </p><p>If you want to experiment a little, you can take a look at the vector representations of the various quantum gates that we show in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>, and see whether you can add these gates to the <strong class="bold">gates</strong> dictionary.</p><p>In this first example, we took a look at how to build our single qubits and gates as vectors and matrices, and how to run our qubits through the gates by using vector multiplication. Now let's do the same with two qubits…</p></li>
				<li>Set up our multi-qubit vectors.<p>First, we expand our Dirac-noted qubit combinations: <img alt="" src="img/Formula_02_121.png"/>, <img alt="" src="img/Formula_02_122.png"/>, <img alt="" src="img/Formula_02_123.png"/>, and <img alt="" src="img/Formula_02_124.png"/>.</p><p>These represent, respectively, both qubits 0, first qubit 1 and second 0, first qubit 0 and second 1, and both qubits 1. Here, we are using the <strong class="bold">backward Qiskit® notation</strong> for our qubits, starting<a id="_idIndexMarker096"/> with the first<a id="_idIndexMarker097"/> qubit (<img alt="" src="img/Formula_02_125.png"/>) as the <strong class="bold">Least Significant Bit</strong> (<strong class="bold">LSB</strong>) in the vector<a id="_idIndexMarker098"/> notation, like this: <img alt="" src="img/Formula_02_126.png"/>.</p><p>The vector representation of these are, respectively, as follows:</p><div><img alt="" src="img/Formula_02_127.jpg"/></div><p>We already know how to build our qubits as 2x1 NumPy arrays, so let's extend that to 4x1 vectors. With NumPy, this is how we create, for example, the <img alt="" src="img/Formula_02_128.png"/> qubit vector:</p><pre>np.array([1,0,0,0])</pre><p>In the sample code, we set up a dictionary with the multi-qubit arrays:</p><pre>twoqubits = {"|00\u27E9":np.array([1,0,0,0]),
    "|01\u27E9":np.array([0,1,0,0]),
    "|10\u27E9":np.array([0,0,1,0]),
    "|11\u27E9":np.array([0,0,0,1]),
    "|PH\u27E9":np.array([0.5,-0.5,0.5,-0.5])}
for b in twoqubits:
  print(b, "\n", twoqubits[b]) </pre></li>
				<li>Set up our multi-qubit gate matrices.<p>The two-qubit quantum gates are represented by 4x4 matrices, such as the <strong class="bold">controlled-NOT</strong> (<strong class="bold">CX</strong>) gate, which flips<a id="_idIndexMarker099"/> the first qubit (<img alt="" src="img/Formula_02_129.png"/>) if the controlling second qubit (<img alt="" src="img/Formula_02_130.png"/>) is set to 1:</p><div><img alt="" src="img/Formula_02_131.jpg"/></div><p>Gate matrices like these, where one qubit acts as the control and the other as controlled, differ somewhat depending on which qubit you select as the control. If the CX gate points the other way, with the first qubit (<img alt="" src="img/Formula_02_132.png"/>) as the controlling qubit, the matrix will look like this instead:</p><div><img alt="" src="img/Formula_02_133.jpg"/></div><p>Here's how we build the gates:</p><pre>twogates ={"cx":np.array([[1, 0, 0, 0], [0, 1, 0, 0], 
    [0, 0, 0, 1], [0, 0, 1, 0]]), 
    "swap":np.array([[1, 0, 0, 0], [0, 0, 1, 0], 
    [0, 1, 0, 0], [0, 0, 0, 1]])}</pre><p>Here's a NumPy matrix dot <a id="_idIndexMarker100"/>multiplication example for a CX gate on the <img alt="" src="img/Formula_02_134.png"/> qubit:</p><pre>np.dot(np.array([[1, 0, 0, 0], [0, 1, 0, 0], 
    [0, 0, 0, 1], [0, 0, 1, 0]]), np.array([0,0,0,1]))</pre><p>Here's the sample code:</p><pre>twogates ={"cx":np.array([[1, 0, 0, 0], [0, 1, 0, 0], 
    [0, 0, 0, 1], [0, 0, 1, 0]]), 
    "swap":np.array([[1, 0, 0, 0], [0, 0, 1, 0], 
    [0, 1, 0, 0], [0, 0, 0, 1]])}
for g in twogates:
  print(g, "\n", twogates[g].round()) 
print ("\n")</pre></li>
				<li>Then, we'll apply the gates to our bits and see the results:<pre>for g in twogates:
    print("Gate:",g) 
    for b in twoqubits:
        print(b,"\n",twoqubits[b],"-&gt;", 
            np.dot(twogates[g],twoqubits[b])) 
    print("\n")</pre><p>The main takeaway with the <a id="_idIndexMarker101"/>multi-qubit matrix manipulations is that the output is a vector of the same dimensions as the input vector; no information is lost. </p></li>
			</ol>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>There's more…</h2>
			<p>One other aspect of quantum gates that is generally not true of classical gates is that they are reversible. If you run the gate backward, you end up with the input states of your qubits, and no information is lost. The final recipe in this chapter illustrates this.</p>
			<h3>The sample code</h3>
			<p>The sample file for the following<a id="_idIndexMarker102"/> recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r4_reversible_gates.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter02/ch2_r4_reversible_gates.py</a>:</p>
			<ol>
				<li value="1">Let's start by importing all we need:<pre>import numpy as np
from math import sqrt</pre></li>
				<li>Set up the basic qubit vectors and gate matrices. When printing out the gates, we compare the gate matrix with its complex conjugate. If these are the same, the gate and its inverse are identical:<pre>qubits = {"|0\u232A":np.array([1,0]), 
    "|1\u232A":np.array([0,1]), 
    "(|0\u232A+|1\u232A)/\u221a2":1/sqrt(2)*np.
    array([1,1])}
for q in qubits:
  print(q, "\n", qubits[q]) 
print ("\n")
gates ={"id":np.array([[1, 0], [0, 1]]),
    "x":np.array([[0, 1], [1, 0]]), 
    "y":np.array([[0, -1.j], [1.j, 0]]), 
    "z":np.array([[1, 0], [0, -1]]), 
    "h":1/sqrt(2)*np.array([[1, 1], [1, -1]]), 
    "s":np.array([[1, 0], [0, 1j]])}
diff=""
for g in gates:
  print(g, "\n", gates[g].round(3)) 
  if gates[g].all==np.matrix.conjugate(gates[g]).all:
      diff="(Same as original)" 
  else:
      diff="(Complex numbers conjugated)" 
  print("Inverted",g, diff, "\n",     np.matrix.conjugate(gates[g]).round(3)) 
print ("\n")</pre></li>
				<li>Demonstrate that the <a id="_idIndexMarker103"/>basic quantum gates are reversible by applying the gate then its complex conjugate, and then comparing the outcome with the input. For the quantum gates, which are reversible, this will bring the qubit back to the starting state:<pre>for g in gates:
    input("Press enter...")
    print("Gate:",g) 
    print("-------")
    for q in qubits:
        print ("\nOriginal qubit: ",q,"\n", 
            qubits[q].round(3))
        print ("Qubit after",g,"gate: \n",
            np.dot(gates[g],qubits[q]).round(3))
        print ("Qubit after inverted",g,"gate.","\n",
            np.dot(np.dot(gates[g],qubits[q]),
            np.matrix.conjugate(gates[g])).round(3))
    print("\n")</pre></li>
			</ol>
			<h3>Running the sample</h3>
			<p>When you run this <code>ch2_r4_reversible_gates.py</code> script, it will do the following:</p>
			<ol>
				<li value="1">Like before, create and <a id="_idIndexMarker104"/>print out vector and matrix representations of our qubits and quantum gates. <p>This time, we add three new gates:</p><div><img alt="" src="img/Formula_02_135.jpg"/></div><div><img alt="" src="img/Formula_02_136.jpg"/></div><div><img alt="" src="img/Formula_02_137.jpg"/></div><p>Here, <em class="italic">Y</em> and <em class="italic">Z</em> perform <img alt="" src="img/Formula_02_138.png"/> rotation around the corresponding axes, in essence acting as NOT gates along the <em class="italic">y</em> and <em class="italic">z</em> axes on the Bloch sphere. The S gate adds a new functionality to the gates, <img alt="" src="img/Formula_02_139.png"/> rotation around the <em class="italic">z</em> axis. We will return to these gates in more detail in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>:</p><div><img alt="Figure 2.14 – Quantum gates and their inverses&#13;&#10;" src="img/Figure_2.14_B14436.jpg"/></div><p class="figure-caption">Figure 2.14 – Quantum gates and their inverses</p><p>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part, so for gates with only real numbers in their matrices, the complex conjugate does nothing, and the gate is its own reverse.</p></li>
				<li>Then, for each of our qubits, we apply each gate and then its reverse gate and show that we end up<a id="_idIndexMarker105"/> with the same qubit state as we started with. <p>The examples that follow are for the X and S gates:</p></li>
			</ol>
			<div><div><img alt="Figure 2.15 – The effects of the X gate and reversed X gate on three qubit states&#13;&#10;" src="img/Figure_2.15_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15 – The effects of the X gate and reversed X gate on three qubit states</p>
			<p>The reversed X gate is simply itself, and applying it twice to a qubit brings back the original qubit state:</p>
			<div><div><img alt="Figure 2.16 – The effects of the S and reversed S gate () on three qubit states&#13;&#10;" src="img/Figure_2.16_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16 – The effects of the S and reversed S gate (<img alt="" src="img/Formula_02_140.png"/>) on three qubit states</p>
			<p>The reverse of the S gate is called the <img alt="" src="img/Formula_02_141.png"/> gate, where <img alt="" src="img/Formula_02_142.png"/> is the complex conjugation of S. Applying S followed by <img alt="" src="img/Formula_02_143.png"/> brings back the original qubit state.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>See also</h2>
			<ul>
				<li><em class="italic">Quantum Computation and Quantum Information</em>, Isaac L. Chuang; Michael A. Nielsen, Cambridge University Press, 2010, <em class="italic">Chapter 4.2</em>, <em class="italic">Single qubit operations</em>, and <em class="italic">Chapter 4.3</em>, <em class="italic">Controlled operations</em>.</li>
				<li><em class="italic">The Feynman Lectures on Physics</em>, Feynman, Richard P.; Leighton, Robert B.; Sands, Matthew, 1965, Addison-Wesley. Take a look at the online version, and the chapter on amplitudes and vectors, for more about Dirac notation: <a href="https://www.feynmanlectures.caltech.edu/III_08.html#Ch8-S1">https://www.feynmanlectures.caltech.edu/III_08.html#Ch8-S1</a>.</li>
				<li>For a quick interactive look at a single qubit Bloch sphere representation, take a look at the <strong class="bold">grok bloch</strong> application<a id="_idIndexMarker106"/> by Qiskit Advocate James Weaver: <a href="https://github.com/JavaFXpert/grok-bloch">https://github.com/JavaFXpert/grok-bloch</a>.</li>
				<li>You can install and run it from your own Python environment, or run it online here: <a href="https://javafxpert.github.io/grok-bloch/">https://javafxpert.github.io/grok-bloch/</a>.</li>
				<li>The application supports the simple X and H gates that we have tested so far, as well as additional gates that we will be touching on in the following chapters, such as Y, Z, Rx, Ry, Rz, and more. For a deeper dive into the quantum gates that are available with Qiskit®, refer to <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>.</li>
			</ul>
		</div>
	</body></html>