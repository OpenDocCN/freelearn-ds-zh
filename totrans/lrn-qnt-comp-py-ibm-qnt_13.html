<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer972" class="Basic-Text-Frame">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-214" class="chapterTitle">Understanding Quantum Utility and Qiskit Patterns</h1>
    <p class="normal">Here we are, the final chapter. If you’ve made it this far, then congratulations on keeping yourself focused and determined, your time was well invested! As we close out this chapter, and the book, I want to also make sure I don’t just leave you here with some basics and wish you the best. I’ve found most technical books seem to do that. Not that there is anything wrong with that, but I always felt like most don’t provide help regarding next steps or, better yet, any next best action. I thought I would include this chapter as a shift from education to enablement. In other words, where to go from here and <em class="italic">how</em>. With Qiskit 1.0 (and future updates), we should approach this as a transition to really getting a head start towards enabling you with the proper tools and patterns to evolve your current experiments towards ideal utility application candidates. The goal here is that this book will not only provide you with the education to get started, but will also provide you with some guidance to know what to expect and develop as the technology grows and new features are released.</p>
    <p class="normal">Up to now, we have covered a <em class="italic">bottom-up approach</em> to understand quantum computing, where we started with the foundational quantum computational properties, gates, and circuits. We then moved up towards combining those to implement various quantum algorithms. We also covered how to use the various simulators, generate noise models, and mitigate readout errors. All of this helps in understanding the fundamental intricacies of quantum computing and how they are used to create algorithms that are both effective and optimal.</p>
    <p class="normal">However, it is a lot to ask of a developer, solution architect, or systems integrator to learn all the inner workings just to understand how to integrate quantum computing into their application or workflow. In fact, it is often difficult to find those who want to wander down into the <em class="italic">nuts and bolts</em> of the quantum algorithm. Generally, most of us would like to just load our data into an algorithm, execute it on a quantum system, obtain the results, and just continue with our experiments.</p>
    <p class="normal">This <em class="italic">top-down approach </em>is where Qiskit Patterns comes into the picture. </p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Understanding Quantum Utility</li>
      <li class="bulletList">Understanding Qiskit Patterns</li>
    </ul>
    <p class="normal">In this chapter, you will learn what quantum utility means and why it is key to getting us closer towards quantum advantage.</p>
    <p class="normal">We’ll also cover Qiskit Patterns and how it can simplify your development experience to build complex quantum circuits. As most quantum algorithms and applications become more complex over time, particularly now as we are entering the era of quantum utility, we need to understand what they are and how we can best use these building blocks to create scalable and efficient quantum algorithms.</p>
    <p class="normal">Finally, we’ll wrap up this chapter with a quick example using Qiskit Patterns using Grover’s algorithm, which we learned about in the previous chapter, as I do not want to finish this chapter without providing you with some code that combines classical and quantum together.</p>
    <h1 id="_idParaDest-215" class="heading-1">Technical requirements</h1>
    <p class="normal">For this chapter, it is expected that you have an understanding of creating quantum circuits and general application development using Python.</p>
    <p class="normal">The following is the source code we’ll be using throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition"><span class="url">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</span></a>.</p>
    <h1 id="_idParaDest-216" class="heading-1">Understanding quantum utility</h1>
    <p class="normal">Earlier, I mentioned the term <strong class="keyWord">quantum utility</strong>. I figured I would take the time to describe in a bit more<a id="_idIndexMarker1484"/> detail what that means and, more importantly, what it doesn’t mean. First and foremost, let’s start by defining another term, <strong class="keyWord">quantum advantage</strong>. Quantum <a id="_idIndexMarker1485"/>advantage is a term that describes when a quantum computer can solve a practical use case in science or business that is intractable to classical systems. </p>
    <p class="normal">One example of this could be Shor’s algorithm, which finds the prime factors of an integer. This is currently difficult for classical systems to solve due to the complexity of the task, which is why it is used to encrypt much of our digital content, such as passwords. In the example of Shor’s algorithm, where it is estimated to take millions of years to solve the problem using classical computers, some say it could take a few hours on a fault-tolerant system. Quantum advantage, at the time of writing, of course is a few years away, so it is good that you are taking the time now to learn about this new technology so when these systems reach quantum advantage, you’ll have a head start on solving interesting problems. It’s also important to<a id="_idIndexMarker1486"/> note that quantum advantage will not happen all at once; it will be incremental and will vary based on the type of problem and cost compared to running on a classical system. As technology advances beyond quantum advantage, so will the solutions to classically intractable problems.</p>
    <p class="normal">Now that we have an idea of what quantum advantage is, let’s look at what quantum utility means. Back in June of 2023, researchers from IBM and UC Berkeley published a paper titled <em class="italic">Evidence for the utility of quantum computing before fault tolerance</em> (<a href="https://www.nature.com/articles/s41586-023-06096-3"><span class="url">https://www.nature.com/articles/s41586-023-06096-3</span></a>). In this paper, the authors were able to show that quantum computers can solve problems at a scale beyond brute force classical simulation. Again, this isn’t to say that this is quantum advantage, mostly because there are some quantum-inspired classical methods that provided classical approximations using other techniques beyond brute force. The paper used a 127-qubit quantum computer that had almost 3,000 CX gates, which is quite a complex circuit to simulate using brute-force methods. There of course have been a few quantum-inspired classically based papers that were released that managed to reproduce the solution; however, not all the results from each experiment aligned for certain parameters. As a result, accuracy had begun to struggle, some ranging approximately 20% from each other. Furthermore, there have been many other papers that were published afterwards that are over 100-qubits and contain thousands of CX gates. This highlights the fact that we are moving from where we first started, with small-scale circuits, which could very easily be simulated classically, to over 100-qubit circuits with thousands of CX gates. As the size of the circuits, both width (number of qubits) and depth (number of CX gates) grows, so does the cost of simulating the circuit classically. Cost here can refer to loss of accuracy or speed. This era, which is a time before we hit quantum advantage, is what is referred to as <strong class="keyWord">Quantum Utility</strong>. Furthermore, using the error mitigation techniques discussed earlier in this book, allows running these complex circuits<a id="_idIndexMarker1487"/> on 100+ qubit systems. The era of utility means we can find useful quantum applications to run without having to wait for fault-tolerant quantum computers.</p>
    <p class="normal">Now that we’re familiar with what quantum utility is, let’s look at what we as developers should understand to take advantage of this latest move forward in quantum technology to build these more complex quantum circuits.</p>
    <h1 id="_idParaDest-217" class="heading-1">Understanding Qiskit Patterns</h1>
    <p class="normal">Another announcement at the 2023 IBM Quantum Summit was the introduction to Qiskit Patterns. Qiskit Patterns originated from the idea that as circuits get larger and more complex, computational scientists <a id="_idIndexMarker1488"/>should not be concerned about what is happening at the hardware level. There is no need for a computational scientist to understand which gate to use on a specific qubit, or which is the ideal optimizer to use when transpiling the circuit to the hardware. Computational scientists should have tools that can be used to provide them with the latest hardware and software and simplify the usage of these 100+ qubit systems. These tools should provide a way for scientists to generate code or functions that will solve a specific problem or set of problems, and not create circuits qubit by qubit, gate by gate. Therefore, the purpose of the Qiskit Patterns is to provide the computational scientist with a way to inject a quantum computational routine into their existing applications and workflows.</p>
    <p class="normal">Now that we know the purpose of Qiskit Patterns, let’s look at what they are and how to use them. Prior to stepping into the details, I do want to stress that this is a new feature that is always being enhanced. There may be many changes to the code and its usage. What I am writing here is what is current at the time of writing. As we know, with all coding languages there are always updates or changes, so I urge you to review the documentation first so you are up to speed on the latest development. Even if there are changes in code, the concept of the overall steps should still be the same.</p>
    <p class="normal">Simply put, Qiskit Patterns are made up of 4 steps that are used to run algorithms on a quantum computer and provide you with a result to use as part of your application and/or workflow. The four steps are: <strong class="keyWord">map</strong>, <strong class="keyWord">optimize</strong>, <strong class="keyWord">execute</strong>, and<strong class="keyWord"> post-process</strong>. We’ll learn what each of these steps does and run an example using a simple circuit. Of course, you can use any circuit that you wish.</p>
    <h2 id="_idParaDest-218" class="heading-2">Step 1, Map</h2>
    <p class="normal">In this step,<a id="_idIndexMarker1489"/> we want to map the problem to a quantum circuit. This entails encoding the problem and inputs into a quantum circuit or state. A simple example we can use is to encode a binary <a id="_idIndexMarker1490"/>image. This is an image where each pixel is either black or white, 0 or 1, respectively. It is simple enough to read each pixel and if the pixel is black, we leave the state as 0 and if it is white, we add an X gate to change it to the 1 state. Of course, this means that we would need the same number of qubits as we do pixels, so this is not easy to scale to larger images that have millions of pixels. </p>
    <p class="normal">So, we would need to find ways to encode these images so that they would not need millions of qubits. This is where encoding comes in handy. If we can find a way to encode pixels into a quantum state, then this will work nicely. There are of course many ways to encode images, too many to list here, but by searching quantum image processing, you should find many forms. A few of the earliest forms are <strong class="keyWord">NEQR</strong>, which stands for <strong class="keyWord">Novel Enhanced Quantum Representation</strong> for digital images, and <strong class="keyWord">FRQI</strong>, which is short for <strong class="keyWord">Flexible Representation of Quantum Images</strong>. The mapping using FRQI maps the intensity value of the pixel, let’s say a 256-bit grayscale image, to a single qubit (i.e., pi/256 would represent the pixel value). In NEQR, you would map the values using 8 qubits, where each qubit is set as a binary value, so the qubit intensity is not represented by 1 qubit (as in FRQI), but 8 qubits (8 qubits that map to the 8 binary values needed to represent the numbers from 0 to 256). These are just two, but there are so many more, each of which has its own advantages and disadvantages. What this means is that a lot of the work for you, as a computational scientist, is about selecting the encoding, or mapping, that you believe is best for your experiment. This mapping should ensure that your problem is not just encoded into a quantum state, but encoded in a way where it provides an optimal way to represent the problem you wish to solve. Once you have selected the proper mapping of your problem and input, a circuit is generated. We are now ready to move onto the next step in the Qiskit Pattern, optimization.</p>
    <h2 id="_idParaDest-219" class="heading-2">Step 2, Optimize your circuit</h2>
    <p class="normal">As we’ve covered<a id="_idIndexMarker1491"/> in previous chapters, optimizing a circuit is not just one step of mapping the circuit to the quantum hardware; there are many different aspects to it. Thankfully, most of this is done automatically for us, but it also provides us with ways to alter them, either by setting <code class="inlineCode">optimization_level</code> option values to specify the type of optimization to perform, but the recently added <code class="inlineCode">resilience_level</code> option values, which allow us to also select the type of error suppression and error mitigation to apply to our circuit. As most of these require some classical resources, this <a id="_idIndexMarker1492"/>provides us with a way to set how much of those classical resources to use. The result of the transpilation and optimization is called <strong class="keyWord">Quantum Instruction Set Architecture</strong> (<strong class="keyWord">QISA</strong>). This <a id="_idIndexMarker1493"/>optimized circuit is specific to the quantum hardware we select to execute this circuit on, which leads us to the next step, execute.</p>
    <h2 id="_idParaDest-220" class="heading-2">Step 3, Execute your circuit</h2>
    <p class="normal">One thing to note is that <a id="_idIndexMarker1494"/>when we say execute a circuit, this is not to say we will execute this circuit on a quantum system, particularly when running a variational quantum algorithm that requires some classical interactions during execution. This is why primitives<a id="_idIndexMarker1495"/> like the Estimator and Sampler are great building blocks as they provide the necessary context needed to execute these circuits to allow classical and quantum interactions during execution time. Executing a circuit can use one of many modes, such as Sessions, Jobs, and Batch. </p>
    <p class="normal">We discussed these in <em class="chapterRef">Chapter 10</em>, <em class="italic">Suppressing and Mitigating Quantum Noise</em>, where we covered how circuits are run on a quantum system. Now that we have executed our circuit on a quantum system, we now have reached the final step in the Qiskit Pattern, post-processing.</p>
    <h2 id="_idParaDest-221" class="heading-2">Step 4, Post-process</h2>
    <p class="normal">This is just a <a id="_idIndexMarker1496"/>matter of obtaining the results we received from executing our circuit and processing them into what our classical application or workflow expects. Up to now, we’ve been displaying our results as either graphs or as text so we can view them and understand what the results mean. But when integrating with an application or workflow, the results might need to either be formatted in a certain way or aggregated with other results from various other systems as a collection. In either case, the post-processing step is just a matter of handling the results and passing them back to the calling system in a way that will facilitate its integration into the application itself in a very robust way. This of course would be dependent on how the results would be used in the next step or displayed.</p>
    <p class="normal">In essence, those are the 4 steps, straightforward and quite simple. But then again, that is the point! Ideally, you, as a developer, computational scientist, or quantum enthusiast, should not have to struggle with how to create, execute, and obtain results from a quantum system. The process should be very straightforward and simple. Speaking of simplifying the process, another announcement during the Summit was that there will soon be AI included, which would be able to auto-generate quantum code as well. It has not been announced when this, and other AI features, will go live but the code will soon include this. This should help those who are new and just getting started as it could serve as a tool to ask how to create certain circuits, i.e. Grovers, Simon’s, etc. and of course should also help those experienced<a id="_idIndexMarker1497"/> researchers who would like to scale their existing circuits into these larger complex circuits, which could advance their solutions towards a path to quantum advantage.</p>
    <p class="normal">Now, that all being said, I will not let you down! I did leave a little programming for you here so to not have a chapter without any coding. We will implement something that we built in the previous<a id="_idIndexMarker1498"/> chapter, a simple logical expression to determine the optimal result using Grover’s algorithm. This is a simple example where we will start with a logical expression, which we can say is the classical data coming in. Then we will proceed to use the Sampler primitive so we can run it locally, define the problem, and use the Grover algorithm class to solve the problem. This time, we will use the methods to input the problem and provide us with the optimal result, which we will then print out and display visually, hence completing the hybrid classical-quantum application. Here we go!</p>
    <h2 id="_idParaDest-222" class="heading-2">Implementing the logical expression oracle</h2>
    <p class="normal">Logical expressions are<a id="_idIndexMarker1499"/> commonly used to describe problems, particularly those that have some constraints. These logical expressions<a id="_idIndexMarker1500"/> can be used to construct a circuit and execute it on various algorithms. Let’s begin with a simple problem. Note that the names have been changed to protect the identities of bands who have trouble staying together.</p>
    <p class="normal">Melba, a music producer, has been tasked to put together the next big rock band, based on the musicians who currently have a contract for a record company. The following musicians are available:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Ivana</strong> is a singer who has a great voice and is available to tour as soon as possible.</li>
      <li class="bulletList"><strong class="keyWord">Karla</strong> is also a singer with a great voice and is also available to tour right away.</li>
      <li class="bulletList"><strong class="keyWord">Lex</strong> is a guitar player that can play any genre and has his own tour bus.</li>
      <li class="bulletList"><strong class="keyWord">Leo</strong> is a drummer that gets along with everyone and is very liked in the industry.</li>
    </ul>
    <p class="normal">Now, here is the problem you have been asked to solve by the music producer: Ivana and Karla tend to not get along on tour and have been known to have creative differences when writing music. Lex and Leo, on the other hand, get along fine together both in the studio and on tour. However, Ivana and Lex recently broke up after the last time they toured together so we can have one of the following options: only Ivana or Leo can participate, or neither and simply replace them both.</p>
    <p class="normal">What you need to do is <a id="_idIndexMarker1501"/>determine which combination of these four musicians is best for you to put together as a band, and then have them tour with minimal issues based on their history together.</p>
    <p class="normal">To solve this, let’s write<a id="_idIndexMarker1502"/> this out as a logical expression:</p>
    <ol>
      <li class="numberedList" value="1">We’ll map each musician to a variable such as: <code class="inlineCode">A = Ivana</code>, <code class="inlineCode">B = Karla</code>, <code class="inlineCode">C = Lex</code>, and <code class="inlineCode">D = Leo</code>.</li>
      <li class="numberedList">Next, we’ll create a logical expression using logical operators to illustrate the constraints. To start, we know that Ivana and Karla do not get along, so this we can represent as follows, where ^ indicates XOR. This means we need at least one of them to participate, but not both at the same time: <a id="_idIndexMarker1503"/><img src="../Images/B18420_13_001.png" alt="" width="55" height="26"/>.</li>
      <li class="numberedList">Next, we know that Lex and Leo get along fine together, so we can represent them with an AND operator as follows: <a id="_idIndexMarker1504"/><img src="../Images/B18420_13_002.png" alt="" width="60" height="26"/>.</li>
      <li class="numberedList">Finally, we know that Ivana and Lex have just ended their relationship, so they might not be open to working and touring together. We will represent them as a NAND as follows. This indicates that they cannot work together, but it will allow for both not to participate at all: <a id="_idIndexMarker1505"/><img src="../Images/B18420_13_003.png" alt="" width="80" height="26"/>.</li>
      <li class="numberedList">By putting these all together, our complete logical expression for this example is as follows: <a id="_idIndexMarker1506"/><img src="../Images/B18420_13_004.png" alt="" width="219" height="26"/>.</li>
    </ol>
    <p class="normal-one">Now that we have defined our logical expression, let’s create an oracle on the logical expression so that we can use <strong class="keyWord">Grover’s algorithm</strong> to search for the optimal result.</p>
    <ol>
      <li class="numberedList" value="6">We’ll begin by importing all the necessary modules and classes needed for the rest of these steps and defining our logical expression:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Import the necessary modules and classes</span>
<span class="hljs-keyword">from</span> qiskit <span class="hljs-keyword">import</span> QuantumCircuit
<span class="hljs-keyword">from</span> qiskit.visualization <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">from</span> qiskit_algorithms <span class="hljs-keyword">import</span> Grover, AmplificationProblem
<span class="hljs-keyword">from</span> qiskit.circuit.library.phase_oracle <span class="hljs-keyword">import</span> PhaseOracle
<span class="hljs-comment"># State the SAT problem into a logical expression</span>
<span class="hljs-comment"># A = </span><span class="hljs-comment">Ivana, B = Karla, C = Leo, D = Lex</span>
expression = <span class="hljs-string">'((A ^ B) &amp; (C &amp; D) &amp; ~(A &amp; C))'</span>
</code></pre>
      </li>
      <li class="numberedList">Now that we have defined our problem as a logical expression, let’s use this logical expression to create our <code class="inlineCode">oracle</code>, which as you recall is what we use to describe the <a id="_idIndexMarker1507"/>problem we wish to solve. In this case, it represents the logical expression. Note that in the code I included a cell that would install a dependency for using PhaseOracle (<code class="inlineCode">pip install tweedledum</code>), as you will likely also have to install Qiskit algorithms (<code class="inlineCode">pip install qiskit-algorithms</code>). I’ve commented the line out to install just in case you already have it installed; however, if you get an error <a id="_idIndexMarker1508"/>when executing a cell that requires the dependency, simply install onto your development environment using the command-line instruction, and restart the kernel. This will then complete the installation and you can then run the code without the dependency error:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Create a PhaseOracle based on the logical expression</span>
oracle = PhaseOracle(expression)
</code></pre>
      </li>
      <li class="numberedList">Now that we have created an <code class="inlineCode">oracle</code> from the logical expression, we can create the problem by calling the <code class="inlineCode">AmplificationProblem()</code> method and passing the expression we wish to solve as its argument:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Construct the amplification problem from the oracle</span>
problem = AmplificationProblem(oracle,
                 is_good_state=oracle.evaluate_bitstring)
problem.grover_operator.oracle.draw()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code calls the oracle from the Grover operator which contains the quantum circuit representation of the oracle which is illustrated as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_13_01.png" alt="A screenshot of a computer  Description automatically generated with low confidence" width="160" height="303"/></figure>
    <p class="packt_figref">Figure 13.1: Quantum circuit representing the logical expression oracle</p>
    <ol>
      <li class="numberedList" value="9">We can see that this oracle describes the logical expression, where q<sub class="subscript">0</sub>, q<sub class="subscript">1</sub>, q<sub class="subscript">2</sub>, and q<sub class="subscript">3</sub> represent our logical expression, where q<sub class="subscript">0</sub> = Ivana, q<sub class="subscript">1</sub> = Karla, q<sub class="subscript">2</sub> = Lex, and q<sub class="subscript">3</sub> = Leo. Observe<a id="_idIndexMarker1509"/> that the control in q<sub class="subscript">0 </sub>is not filled in. This is to indicate that it is triggered when the state value of q<sub class="subscript">0</sub> is <a id="_idIndexMarker1510"/><img src="../Images/B18420_13_005.png" alt="" width="24" height="26"/>, as opposed to the others, which are triggered when the qubit is in the <a id="_idIndexMarker1511"/><img src="../Images/B18420_13_006.png" alt="" width="24" height="26"/> state. We can now use this oracle on any<a id="_idIndexMarker1512"/> oracle-based (oracular) algorithm. Since we are searching for the solution to this rock band problem, let’s use Grover’s algorithm. First, we will set up a session and use the Sampler primitive for this example, and then create the Grover’s algorithm class using the sampler as the primitive. We’ll then pass the problem we defined in the previous cell into the <code class="inlineCode">amplify</code> method, which will in essence run Grover’s algorithm, provide us with the result, and display it:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Using the Sampler to run circuit</span>
<span class="hljs-string">from </span>qiskit.primitives <span class="hljs-string">import </span>Sampler
<span class="hljs-comment"># Set the Options</span>
sampler = Sampler()grover = Grover(sampler=sampler)
result = grover.amplify(problem)
plot_distribution(result.circuit_results[0])
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code results in the following output, which represents the value we are searching for: <code class="inlineCode">1110</code>. Keep in mind that the qubit at position 0 is<a id="_idIndexMarker1513"/> represented by the least significant bit (far right). This means that the result, <code class="inlineCode">1110</code>, is equal to D=1, C=1, B=1, A=0:</p>
    <p class="normal-one">We also obtain the following quasi-distribution:</p>
    <figure class="mediaobject"> <img src="../Images/B18420_13_02.png" alt="Table  Description automatically generated" width="756" height="542"/></figure>
    <p class="packt_figref">Figure 13.2: Grover solution results based on the logical expression oracle</p>
    <p class="normal">As shown by the preceding results, the algorithm indicates our solution is <strong class="keyWord">1110</strong>. This states that Karla, Leo, and Lex are the three ideal musicians to recruit into the next band project. Melba has then <a id="_idIndexMarker1514"/>decided to recruit Ivana as a solo career singer.</p>
    <p class="normal">This, of course, is a simple example. As you can imagine, if your expression is more complex, then the Grovers search would help determine that in just a few lines of code. As you can see, you can take a problem that’s defined by a logical expression on a classical system and then, by leveraging the Qiskit Runtime and Grover’s algorithm class, prepare the problem in a variety of ways, all of which can be executed on a quantum system. All of this can be done without having to delve into the lower layers of the quantum algorithm, i.e., quantum gates, operators, error mitigation, etc.</p>
    <p class="normal">As Qiskit continues to add <a id="_idIndexMarker1515"/>many more features, algorithms, utilities, and <a id="_idIndexMarker1516"/>other artifacts, this will help you create flexible yet modular quantum applications that suit all your needs.</p>
    <h1 id="_idParaDest-223" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered Qiskit Patterns, which are focused on helping you quickly develop robust quantum circuits to include into your applications and workflows. With the release of Qiskit 1.0 and future changes, I also highly recommend you keep up with the latest changes. Qiskit 1.0 has a nice roadmap filled with updates to primitives, patterns, and many features that not only help you get up to speed with the development process but also ensure that your circuits can scale up to larger utility sized circuits.</p>
    <p class="normal">Now that you have the general skills to understand how to start creating quantum applications and using Qiskit Patterns in a way that simplifies the creation process, you can start applying these features into your existing circuits, or in new circuits if you are just starting out.</p>
    <p class="normal">Finally, we looked at a problem that we needed to solve using Grover’s quantum algorithm, without having to really understand how they are constructed, meaning we did not have to create a quantum circuit, an oracle, or diffusion operators to run the algorithm. The focus was on how to represent the problem, in this case as a logical expression, and apply it via a combination of available classes and methods of the algorithm to present the problem and solve it. Just keep in mind that as we are moving towards quantum utility, there will be more efficient and modern ways to implement this and future algorithms. As mentioned throughout this book, these are just the principles and general programming practices to help get you started, but as quantum computing evolves, so to will the algorithms and the way we think about how to program. It’s with this that you should take away from this book, it’s a place to start for you to take the code and keep on pushing towards the outer bounds of your ingenuity and imagination. But for now…</p>
    <p class="normal">Congratulations! You’ve taken a very large step towards getting yourself started with learning and building quantum applications. Initially, we followed a bottoms-up approach, which is to start by creating and running quantum circuits on both a locally installed simulator and on a quantum computer. Doing this helped you understand the inner workings of how a quantum circuit is built and executed on a quantum system. Next, you reviewed the various algorithms and quantum computing principles that differentiate between classical and quantum applications. By running these applications, you also visualized the results and of course the effects caused by various environmental effects, which in turn helped you learn about the various features that mitigate the noisy effects of the quantum computer. And finally, you looked at a top-down approach offered by the Qiskit Runtime to help you quickly see how some of these algorithms in various domains are used to solve small problems. The hope here is that this book has provided you with a simple gateway to simplify your journey into the quantum computing world and, as always, I look forward to reading your research papers or perhaps your own textbook!</p>
    <p class="normal">Welcome to quantum!</p>
    <h1 id="_idParaDest-224" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">What are the four steps of Qiskit Patterns?</li>
      <li class="numberedList">Which Qiskit Pattern handles mapping a quantum circuit to the hardware?</li>
      <li class="numberedList">When encoding your problem to a quantum state, which Qiskit Pattern step are you on?</li>
      <li class="numberedList">Why did we use a Sampler and not an Estimator primitive for the Grover example?</li>
    </ol>
    <h1 id="_idParaDest-225" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_13.xhtml"><span class="url">https://packt.link/3FyN1</span></a></p>
    <p class="normal"><img src="../Images/QR_Code261762599683826593.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>