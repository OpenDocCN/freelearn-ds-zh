# 第6章. 掌握QGIS Python API

在本章中，我们将探讨PyQGIS库的许多更高级的方面，以及使用Python操作QGIS的各种技术。特别是，我们将学习：

+   如何与符号层一起工作

+   使用符号在地图上绘制矢量数据的高级方法

+   如何在Python中实现自己的符号和渲染器

+   如何使用Python创建自定义地图层

+   如何实现自己的自定义地图画布项

+   如何使用内存数据提供者

# 使用符号层进行工作

在前面的章节中，我们通过实例化`QgsSymbolV2`的三个基本子类之一来创建符号以显示矢量要素：

+   `QgsMarkerSymbolV2`用于点几何形状

+   `QgsLineSymbolV2`用于线几何形状

+   `QgsFillSymbolV2`用于多边形几何形状

我们这样做是通过调用前面类的一个静态`createSimple()`方法，或者通过请求`QgsSymbolV2`类为我们提供一个给定几何类型的默认符号。无论我们如何操作，结果都是一个现成的符号对象，用于显示给定的矢量几何类型。

内部，符号由一个或多个符号层组成，这些层一个接一个地显示，以绘制矢量要素：

![使用符号层](img/00056.jpeg)

### 注意

符号层按它们添加到符号中的顺序绘制。因此，在这个例子中，**符号层1**将在**符号层2**之前绘制。这会导致第二个符号层在第一个符号层之上绘制。确保你正确地排列了符号层的顺序，否则你可能会发现符号层被另一个层完全遮挡。

虽然我们迄今为止所使用的符号只有一个层，但你可以使用多层符号执行一些巧妙的技巧。我们将在*组合符号层*这一节中查看多层符号。

当你创建一个符号时，它将自动使用默认的符号层进行初始化。例如，一个线符号（`QgsLineSymbolV2`的一个实例）将创建一个单层的`QgsSimpleLineSymbolLayerV2`类型。这个层用于在地图上绘制线要素。

要使用符号层，你需要移除这个默认层，并用你自己的符号层或多个符号层替换它。例如：

[PRE0]

可以使用以下方法来操作符号内的层：

+   `symbol.symbolLayerCount()`: 这将返回此符号中符号层的数量。

+   `symbol.symbolLayer(index)`: 这将返回符号中的给定符号层。请注意，第一个符号层的索引为零。

+   `symbol.changeSymbolLayer(index, symbol_layer)`: 这将替换符号中的指定符号层。

+   `symbol.appendSymbolLayer(symbol_layer)`: 这将在符号中追加一个新的符号层。

+   `symbol.insertSymbolLayer(index, symbol_layer)`: 这将在指定的索引处插入一个符号层。

+   `symbol.deleteSymbolLayer(index)`: 这将移除给定索引处的符号层。

    ### 注意

    记住，一旦创建符号，你需要创建一个适当的渲染器，然后将该渲染器分配给你的地图层。例如：

    [PRE1]

以下符号层类可供您使用：

| PyQGIS类 | 描述 | 示例 |
| --- | --- | --- |
| `QgsSimpleMarkerSymbolLayerV2` | 这将点几何形状显示为一个小彩色的圆圈。 | ![使用符号层](img/00057.jpeg) |
| `QgsEllipseSymbolLayerV2` | 这将点几何形状显示为椭圆。 | ![使用符号层](img/00058.jpeg) |
| `QgsFontMarkerSymbolLayerV2` | 这将点几何形状显示为单个字符。你可以选择要显示的字体和字符。 | ![使用符号层](img/00059.jpeg) |
| `QgsSvgMarkerSymbolLayerV2` | 这使用单个SVG格式图像显示点几何形状。 | ![使用符号层](img/00060.jpeg) |
| `QgsVectorFieldSymbolLayer` | 这通过绘制**位移线**来显示点几何形状。线的一端是点的坐标，而另一端使用特征的属性计算得出。 | ![使用符号层](img/00061.jpeg) |
| `QgsSimpleLineSymbolLayerV2` | 这使用给定颜色、宽度和样式的线条显示线几何形状或多边形几何形状的轮廓。 | ![使用符号层](img/00062.jpeg) |
| `QgsMarkerLineSymbolLayerV2` | 这通过沿线的长度重复绘制标记符号来显示线几何形状或多边形几何形状的轮廓。 | ![使用符号层](img/00063.jpeg) |
| `QgsSimpleFillSymbolLayerV2` | 这通过填充给定实心颜色并在周围绘制线条来显示多边形几何形状。 | ![使用符号层](img/00064.jpeg) |
| `QgsGradientFillSymbolLayerV2` | 这使用颜色或灰度渐变填充多边形几何形状的内部。 | ![使用符号层](img/00065.jpeg) |
| `QgsCentroidFillSymbolLayerV2` | 这将在多边形几何形状的质心处绘制一个简单的点。 | ![使用符号层](img/00066.jpeg) |
| `QgsLinePatternFillSymbolLayer` | 这使用重复的线绘制多边形几何形状的内部。你可以选择用于线的角度、宽度和颜色。 | ![使用符号层](img/00067.jpeg) |
| `QgsPointPatternFillSymbolLayer` | 这使用重复的点绘制多边形几何形状的内部。 | ![使用符号层](img/00068.jpeg) |
| `QgsSVGFillSymbolLayer` | 这使用重复的SVG格式图像绘制多边形几何形状的内部。 | ![使用符号层](img/00069.jpeg) |

这些预定义的符号层，无论是单独使用还是以各种组合方式，都为你提供了在显示特征时的巨大灵活性。然而，如果您觉得这些还不够，您也可以使用Python实现自己的符号层。我们将在本章后面讨论如何实现。

# 符号层的组合

通过组合符号层，你可以实现一系列复杂的视觉效果。例如，你可以将`QgsSimpleMarkerSymbolLayerV2`的一个实例与`QgsVectorFieldSymbolLayer`的一个实例结合起来，同时使用两个符号来显示点几何图形：

![组合符号层](img/00070.jpeg)

符号层的主要用途之一是绘制不同的LineString或PolyLine符号来表示不同类型的道路。例如，你可以通过组合多个符号层来绘制复杂的道路符号，如下所示：

![组合符号层](img/00071.jpeg)

这种效果是通过使用三个独立的符号层实现的：

![组合符号层](img/00072.jpeg)

这里是用于生成前面地图符号的Python代码：

[PRE2]

如你所见，你可以设置线宽、颜色和样式来创建你想要的效果。像往常一样，你必须按正确的顺序定义层，最底层的符号层首先定义。通过这种方式组合线符号层，你可以创建几乎任何类型的道路符号。

你也可以在显示多边形几何图形时使用符号层。例如，你可以在`QgsSimpleFillSymbolLayerV2`之上绘制`QgsPointPatternFillSymbolLayer`，以便在简单填充多边形上重复出现点，如下所示：

![组合符号层](img/00073.jpeg)

最后，你可以利用**透明度**来使各种符号层（或整个符号）相互融合。例如，你可以通过组合两个符号层来创建点状条纹效果，如下所示：

[PRE3]

结果相当微妙且视觉上令人愉悦：

![组合符号层](img/00074.jpeg)

除了为符号层更改透明度外，你还可以更改整个符号的透明度。这通过使用`setAlpha()`方法完成，如下所示：

[PRE4]

结果看起来像这样：

![组合符号层](img/00075.jpeg)

### 注意

注意，`setAlpha()`接受一个介于0.0和1.0之间的浮点数，而`QColor`对象（如我们之前使用的）的透明度是通过介于0和255之间的alpha值指定的。

# 在Python中实现符号层

如果内置的符号层不足以满足你的需求，你可以使用Python实现自己的符号层。为此，你创建适当的符号层类型的子类（`QgsMarkerSymbolLayerV2`、`QgsLineSymbolV2`或`QgsFillSymbolV2`）并自行实现各种绘图方法。例如，这里是一个简单的标记符号层，用于绘制点几何图形的十字：

[PRE5]

在你的代码中使用这个自定义符号层很简单：

[PRE6]

运行此代码将在每个点几何图形的位置绘制一个十字，如下所示：

![在Python中实现符号层](img/00076.jpeg)

当然，这是一个简单的例子，但它展示了如何使用在Python中实现的自定义符号层。现在让我们更仔细地看看`CrossSymbolLayer`类的实现，并看看每个方法的作用：

+   `__init__()`: 注意 `__init__` 方法接受参数来定制符号层的工作方式。这些参数，它们应该始终分配有默认值，是与符号层关联的 **属性**。如果你想使你的自定义符号在 **QGIS 图层属性** 窗口中可用，你需要注册你的自定义符号层并告诉 QGIS 如何编辑符号层的属性。我们很快就会看到这一点。

+   `layerType()`: 此方法返回你的符号层的唯一名称。

+   `properties()`: 这应该返回一个包含此符号层使用的各种属性的字典。此方法返回的属性将存储在 QGIS 项目文件中，并在以后用于恢复符号层。

+   `clone()`: 此方法应返回符号层的副本。由于我们已经将属性定义为 `__init__` 方法的参数，实现此方法只需创建一个新实例的类，并将当前符号层的属性复制到新实例中。

+   `startRender()`: 在渲染地图层中的第一个要素之前调用此方法。这可以用来定义绘制要素所需的任何对象。与其每次都创建这些对象，不如只创建一次以渲染所有要素，这样更高效（因此更快）。在这个例子中，我们创建了将用于绘制点几何形状的 `QPen` 对象。

+   `stopRender()`: 在渲染最后一个要素之后调用此方法。这可以用来释放由 `startRender()` 方法创建的对象。

+   `renderPoint()`: 这是绘制点几何形状的所有工作所在。正如你所见，此方法接受两个参数：绘制符号的点，以及用于绘制符号的 **渲染上下文**（`QgsSymbolV2RenderContext` 的实例）。

+   渲染上下文提供了各种方法来访问正在显示的要素，以及有关渲染操作、当前比例因子等信息。最重要的是，它允许你访问用于在屏幕上实际绘制符号的 PyQt `QPainter` 对象。

`renderPoint()` 方法仅用于绘制点几何形状的符号层。对于线几何形状，你应该实现 `renderPolyline()` 方法，该方法的签名如下：

[PRE7]

`points` 参数将是一个包含构成 LineString 的各个点的 `QPolygonF` 对象，而 `context` 将是用于绘制几何形状的渲染上下文。

如果你的符号层旨在与多边形一起工作，你应该实现 `renderPolygon()` 方法，其外观如下：

[PRE8]

在这里，`outline`是一个包含构成多边形外部的点的`QPolygonF`对象，而`rings`是一个包含定义多边形内部环或“洞”的`QPolygonF`对象列表。一如既往地，`context`是在绘制几何形状时使用的渲染上下文。

以这种方式创建的自定义符号层，如果您只想在自己的外部PyQGIS应用程序中使用它，将正常工作。但是，如果您想在运行的QGIS副本中使用自定义符号层，特别是如果您想允许最终用户使用**图层属性**窗口与符号层一起工作，您需要采取一些额外步骤，如下所述：

+   如果您希望在用户点击符号时符号在视觉上突出显示，您需要更改符号层的`renderXXX()`方法，以查看正在绘制的要素是否被用户选中，如果是，则更改其绘制方式。最简单的方法是更改几何形状的颜色。例如：

    [PRE9]

+   要允许用户编辑符号层的属性，您应该创建`QgsSymbolLayerV2Widget`的子类，它定义了编辑属性的用户界面。例如，可以定义一个简单的用于编辑`CrossSymbolLayer`长度和宽度的用户界面小部件，如下所示：

    [PRE10]

    我们使用标准的`__init__()`初始化器定义我们小部件的内容。如您所见，我们定义了两个字段，`lengthField`和`widthField`，允许用户分别更改符号层的`length`和`width`属性。

    `setSymbolLayer()`方法告诉小部件使用哪个`QgsSymbolLayerV2`对象，而`symbolLayer()`方法返回小部件正在编辑的`QgsSymbolLayerV2`对象。最后，当用户更改字段值时，会调用两个`XXXChanged()`方法，使我们能够更新符号层的属性以匹配用户设置的值。

+   最后，您需要注册您的符号层。为此，创建`QgsSymbolLayerV2AbstractMetadata`的子类，并将其传递给`QgsSymbolLayerV2Registry`对象的`addSymbolLayerType()`方法。以下是我们`CrossSymbolLayer`类的元数据示例实现，以及将其在QGIS中注册的代码：

    [PRE11]

注意，`QgsSymbolLayerV2AbstractMetadata.__init__()`方法的参数如下：

+   `name`: 符号层的唯一名称，它必须与符号层的`layerType()`方法返回的名称匹配。

+   `visibleName`: 这是此符号层的显示名称，在**图层属性**窗口中向用户展示。

+   `type`: 此符号层将要使用的符号类型。

`createSymbolLayer()`方法用于根据在项目保存时存储在QGIS项目文件中的属性恢复符号层。调用`createSymbolLayerWidget()`方法来创建用户界面小部件，允许用户查看和编辑符号层的属性。

# 在 Python 中实现渲染器

如果你需要根据比内置渲染器提供的更复杂的标准选择符号，你可以使用 Python 编写自己的自定义 `QgsFeatureRendererV2` 子类。例如，以下 Python 代码实现了一个简单的渲染器，该渲染器在显示点特征时交替使用奇数和偶数符号：

[PRE12]

使用此渲染器将导致各种点几何图形以交替颜色显示，例如：

![在 Python 中实现渲染器](img/00077.jpeg)

让我们更仔细地看看这个类是如何实现的，以及各种方法的作用：

+   `__init__()`: 这是你的标准 Python 初始化器。注意，在调用 `QgsFeatureRendererV2.__init__()` 方法时，我们必须为渲染器提供一个唯一的名称；这用于在 QGIS 本身中跟踪各种渲染器。

+   `clone()`: 这将创建此渲染器的副本。如果你的渲染器使用属性来控制其工作方式，则此方法应将这些属性复制到新的渲染器对象中。

+   `symbolForFeature()`: 这返回用于绘制给定特征的符号。

+   `startRender()`: 这为你提供了在渲染特征之前准备你的渲染器和任何你使用的符号的机会。请注意，你必须为你的渲染器使用的每个符号调用 `startRender()` 方法；因为渲染器可以使用多个符号，所以你需要实现这一点，以便你的符号也有机会为渲染做准备。

+   `stopRender()`: 这完成了特征的渲染。同样，你需要实现这一点，以便你的符号在渲染过程完成后有机会进行清理。

+   `usedAttributes()`: 应实现此方法以返回渲染器使用的特征属性列表。如果你的渲染器不使用属性在各个符号之间进行选择，则不需要实现此方法。

如果你愿意，你也可以实现自己的小部件，让用户能够更改渲染器的工作方式。这是通过子类化 `QgsRendererV2Widget` 并设置小部件来编辑渲染器的各种属性来完成的，就像我们实现了 `QgsSymbolLayerV2Widget` 的子类来编辑符号层的属性一样。你还需要通过子类化 `QgsRendererV2AbstractMetadata` 为你的新渲染器提供元数据，并使用 `QgsRendererV2Registry` 对象来注册你的新渲染器。如果你这样做，用户将能够为新地图层选择你的自定义渲染器，并通过编辑渲染器的属性来更改渲染器的工作方式。

# 与自定义地图图层一起工作

与使用具有数据提供者、特征、符号等的标准地图层不同，您可以使用 Python 完全实现自己的**自定义地图层**。自定义地图层通常用于绘制作为矢量格式数据表示过于复杂的特定数据，或者用于在地图上绘制特殊视觉特征，如网格或水印。

通过继承 `QgsPluginLayer` 类来实现自定义地图层。实际上，这个过程非常简单，尽管您需要在不同坐标之间进行转换，以便您在 Python 层中绘制的项目与画布中其他层绘制的特征相匹配。

### 注意

不要被名称所迷惑；您不需要编写 QGIS 插件来创建自己的 `QgsPluginLayer` 子类。

让我们看看我们如何创建自己的 `QgsPluginLayer` 子类。我们将创建一个简单的网格，它可以作为地图中的一个层出现。让我们首先定义 `QgsPluginLayer` 子类本身：

[PRE13]

在我们的 `__init__()` 方法中，我们给插件层赋予一个唯一名称（`"GridLayer"`）和一个用户可见名称（`"Grid Layer"`），然后告诉 QGIS 该层是有效的。

接下来，我们需要设置我们层的坐标参考系统和范围。由于我们正在创建一个覆盖整个地球的网格，我们将使用标准的 EPSG 4236 坐标系统（即纬度/经度坐标），并将层的范围设置为覆盖整个地球表面：

[PRE14]

现在，我们准备好定义绘制层内容的方法了。正如您所想象的，这个方法被称为 `draw()`。让我们首先获取我们将用于实际绘制的 `QPainter` 对象：

[PRE15]

接下来，我们想要找到当前可见的地球表面部分：

[PRE16]

这为我们提供了想要绘制的网格部分。为了确保网格线位于整个纬度和经度上，我们将范围向上和向下取整到最接近的整数，如下所示：

[PRE17]

接下来，我们需要设置绘图器来绘制网格线：

[PRE18]

现在，我们几乎准备好开始绘制网格了。但是，为了绘制网格线，我们需要一种方法来在经纬度值和计算机屏幕上的像素坐标之间进行转换。我们将使用 `QgsMapToPixel` 对象来完成这项工作，我们可以从渲染上下文中获取它：

[PRE19]

现在，我们终于准备好绘制网格线了。让我们从在每个整度经度上绘制一条垂直网格线开始：

[PRE20]

我们可以为水平网格线做同样的操作：

[PRE21]

我们需要做的最后一件事是告诉 QGIS 我们已成功绘制了该层。我们通过让我们的 `draw()` 方法返回 `True` 来完成此操作：

[PRE22]

这完成了我们对 `GridLayer` 类的实现。如果您想在 QGIS 脚本或插件中使用此类，您需要注册该类，以便 QGIS 了解它。幸运的是，这样做很简单：

[PRE23]

如果您在 QGIS 中运行此程序并将 `GridLayer` 添加到您的项目中，您将看到地图上绘制的网格线：

![使用自定义地图层](img/00078.jpeg)

仔细观察前面的图像；您会看到网格线是在多边形之前、圆之后绘制的。这是实现自己的地图层而不是使用地图画布项的主要好处之一；您可以选择哪些图层出现在您的自定义地图层的前面或后面。

# 创建自定义地图画布项

地图画布项是放置在地图画布上的项。标准地图画布项包括文本注释、顶点标记以及特征的视觉突出显示。您还可以通过继承 `QgsMapCanvasItem` 来创建自己的自定义地图画布项。为了了解这是如何工作的，让我们创建一个地图画布项，在地图上绘制罗盘玫瑰：

![创建自定义地图画布项](img/00079.jpeg)

我们将首先创建基本的 `QgsMapCanvasItem` 子类：

[PRE24]

如您所见，我们通过定义 `center` 和 `size` 实例变量将罗盘玫瑰放置在地图画布上，并提供方法来检索和设置这些值。我们还实现了所需的 `boundingRect()` 方法，它返回画布项的整体边界矩形，以屏幕坐标表示。

这就留下了 `paint()` 方法，它负责绘制罗盘玫瑰。虽然此方法有三个参数，但我们只会使用第一个参数，即我们将用于绘制罗盘玫瑰的 `QPainter` 对象。

罗盘玫瑰可能看起来相当复杂，但实现它的代码相当简单。最复杂的部分是确定 `"N"`、`"S"`、`"E"` 和 `"W"` 标签的尺寸，以便我们为罗盘玫瑰本身留出足够的空间。让我们先计算一下将要显示的标签的一些基本信息：

[PRE25]

我们计算用于标签的字体大小（以点为单位），然后设置我们的画家使用该大小的粗体 `"Times"` 字体。然后我们获取一个 `QFontMetrics` 对象，我们将使用它来计算标签的尺寸，并定义一个硬编码的像素边距，以便我们在标签和罗盘玫瑰本身之间留出间隙。

接下来，我们希望用浅灰色和黑色分别绘制罗盘玫瑰的两个中心部分。为此，我们将使用 `QPainterPath` 对象来定义要填充的区域：

[PRE26]

最后，我们希望在四个罗盘点上绘制标签：

[PRE27]

这就完成了我们的 `QgsMapCanvasItem` 子类的实现。要使用它，我们只需创建并初始化一个新的 `CompassRoseItem`。以下是如何在地图画布中显示 `CompassRoseItem` 的示例：

[PRE28]

您的新 `QgsMapCanvasItem` 在对象初始化时将自动添加到地图画布上——您不需要显式将其添加到画布。要移除地图画布上的罗盘玫瑰，您可以执行以下操作：

[PRE29]

注意，地图画布项浮在地图图层之上，不幸的是，它们不能直接与用户交互——你不能使用地图画布项拦截和响应用户的鼠标事件。

# 使用基于内存的图层

通常，地图图层会显示来自外部数据源（如shapefile、栅格DEM文件或数据库）的地理空间数据，但也可以直接从你的Python代码中创建地理空间要素。例如，想象你编写了一个程序来显示道路的中点。这个中点可以用 `QgsPoint` 几何体表示，它将使用适当的标记符号在地图上显示。由于你正在计算这个点，所以这不是你想要存储在shapefile或数据库中的要素。相反，要素是在程序运行时计算并显示的。

这是一种理想的基于内存图层的应用。这种类型的图层在内存中存储地理空间要素，允许你在运行时创建新要素并在地图图层中显示它们。

要创建一个基于内存的地图图层，实例化一个新的 `QgsVectorLayer` 对象，就像正常一样。这个类的初始化器看起来如下所示：

[PRE30]

### 注意

这只是稍微简化了一下——还有一个参数 `loadDefaultStyleFlag`，它不适用于基于内存的图层。幸运的是，这个参数有一个默认值，所以我们可以忽略它。

让我们看看创建基于内存的地图图层所需的三个参数：

+   `path`：这个字符串提供了创建基于内存图层所需的信息，包括图层将存储的信息类型。我们将在稍后详细讨论这个参数。

+   `baseName`：这是用于基于内存图层的名称。名称可以是任何你喜欢的，尽管用户会在QGIS图层列表中看到它。

+   `providerLib`：对于基于内存的图层，应该设置为 `"memory"`。

要创建一个简单的基于内存的图层，你可以这样做：

[PRE31]

这将创建一个名为 `"My Layer"` 的基于内存的图层，其中存储没有属性的多边形要素。

`path` 参数将使我们能够做比仅仅定义要存储在图层中的几何类型更多的事情。`path` 参数具有以下总体语法：

[PRE32]

这种类似于URL的语法以几何类型开始，可以包含任意数量的键/值对，这些键/值对提供了关于内存图层的额外信息。目前支持以下几何类型：

+   `Point`

+   `LineString`

+   `Polygon`

+   `MultiPoint`

+   `MultiLineString`

+   `MultiPolygon`

使用键/值对，你还可以定义：

+   图层应使用的坐标参考系统。例如：

    [PRE33]

    坐标参考系统可以使用CRS权威代码定义，就像前面的例子一样，或者你可以指定WKT格式的CRS，例如：`crs=+proj=longlat +a=69000 +b=55000 +no_defs`。

    ### 注意

    如果您以这种方式没有定义坐标参考系统，当您的程序运行时，QGIS将提示用户选择一个CRS。这可能会使用户感到非常困惑，因此您在创建内存层时应该始终指定一个CRS。

+   在层内为每个特征存储的属性。以下是一个属性定义的示例：

    [PRE34]

    当前支持以下类型的字段：

    +   `integer`

    +   `double`

    +   `string`

    您还可以通过列出这些属性来指定字段长度和精度，例如，`field=height:double(10,2)`或`field=name:string(50)`。

    如果您想要有多个属性，您只需为要定义的每个属性有一个`field=...`条目即可。

    ### 注意

    内存层的数据提供者有一个`addAttributes()`方法，您可能会认为您会使用它来定义属性。然而，`addAttributes()`方法只将属性添加到数据提供者，而不是地图层，这可能导致QGIS崩溃。为了避免这种情况，最好在设置地图层时在路径中定义您的属性，而不是尝试稍后添加它们。

+   该层特征的空问索引：

    [PRE35]

让我们使用这个方法来创建一个更复杂的内存层，该层使用指定的坐标参考系统、空间索引和一些属性来存储点几何形状。以下是我们可以如何实现这一点：

[PRE36]

一旦我们实例化了我们的内存层，我们就可以创建我们想要显示的各种特征，然后将它们添加到层中。以下伪代码显示了如何完成此操作：

[PRE37]

如您所见，我们定义了各种特征（它们是`QgsFeature`的实例），然后一次性将它们全部添加到内存层中。当然，您也可以逐个添加特征，但通常定义一个特征列表并一次性添加它们会更有效率。

现在我们来看看我们如何创建一个特征。我们首先定义特征将要显示的底层几何形状。有各种创建几何形状的方法，包括：

+   实例化一个`QgsPoint`、`QgsPolyLine`、`QgsPolygon`或相关对象，然后使用`QgsGeometry.fromXXX()`方法之一来创建`QgsGeometry`对象。例如：

    [PRE38]

+   创建一个表示几何形状的WKT格式字符串，然后使用该字符串创建`QgsGeometry`对象。例如：

    [PRE39]

+   通过使用几何形状操作方法之一从现有几何形状中创建一个新的`QgsGeometry`对象。例如：

    [PRE40]

一旦我们有了几何形状，我们就可以创建`QgsFeature`对象本身：

[PRE41]

接下来，我们想要设置该特征的属性。在我们能够这样做之前，我们需要告诉特征它将存储哪些属性。这是以下方式完成的：

[PRE42]

最后，我们可以设置属性值。例如：

[PRE43]

将所有这些放在一起，让我们构建一个完整的示例程序，该程序创建一个内存层，用几个`QgsPoint`特征填充它，并更新地图画布以显示这些点。以下是此示例程序：

[PRE44]

在 QGIS 内运行此程序将创建一个名为 `"Point Layer"` 的新基于记忆的地图层，其中包含三个要素，代表西欧三个著名塔的位置：

![使用基于记忆的层](img/00080.jpeg)

为了使这个例子更有用，我们会添加符号以更有意义的方式绘制塔，并且可能还会在每个点的旁边显示名称和高度作为标签。然而，您可以看到如何使用记忆层在程序内部创建空间数据并将其作为地图中的一个图层包含进来。

注意，您不仅限于使用基于记忆的层来表示实际的地理空间数据。您同样可以使用记忆层来显示不表示位置的信息。例如，您可以使用记忆层在地图上绘制箭头，或者使用半透明多边形来阴影地图的某些区域。基于记忆的地图层是一个非常强大的工具，您在编写基于 QGIS 的程序时经常会使用它。

# 摘要

在本章中，我们探讨了 QGIS Python API 的许多高级功能。我们学习了如何使用各种内置符号层在地图上绘制几何形状，如何以有用的方式组合符号层，以及如何使用 Python 实现自己的符号层。然后，我们探讨了编写自己的自定义渲染器以选择每个要素应使用的符号，以及如何使用 Python 代码创建自己的自定义地图层。我们研究了创建自定义地图画布项，然后看到了如何使用基于记忆的地图层以编程方式将要素添加到地图中。

通过这种方式，我们完成了对 PyQGIS 更高级方面的探索。在下一章中，我们将学习如何创建自定义地图工具，使用户能够在 PyQGIS 应用程序中选择、添加、编辑和删除要素。
