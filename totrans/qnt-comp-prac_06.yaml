- en: '*Chapter 6*: Understanding the Qiskit® Gate Library'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the quantum gates that are offered out of the
    Qiskit® box. By including a quantum gate library that features the most common
    gates, Qiskit® makes coding your circuits easy.
  prefs: []
  type: TYPE_NORMAL
- en: Among the gates that we will look at are the Pauli X, Y, and Z gates used for
    basic qubit flips, the H (or Hadamard) gate used to create qubit superpositions,
    and the CX (controlled-NOT) gate used to create quantum entanglement. For a quick
    refresher, take a look at [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at the specialized S and T gates, spin our qubits with R gates,
    and then show how just a minimal set of U1, U2, U3, ID, and CX basis gates are
    used to translate the other gates for direct use with a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: We will stop by the multi-qubit gates and finally end our tour with a short
    look beneath the covers to see how the simple gates that we string out in the
    Qiskit® programs get translated into much more complex sets of basis gates by
    the transpiler before we can run them on a real quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing quantum gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flipping with the Pauli X, Y, and Z gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating superpositions with the H gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed Z rotations with phase shift gates S, S†, T, and T†
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free rotation around the axes with Rx, Ry, and Rz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our circuits with the basis gates – U1, U2, U3, and ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gates on 2 qubits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gates on more than 2 qubits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What your quantum circuit really looks like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these recipes, you will be exposed to quantum gate unitary matrixes and qubit
    state vectors, both of which we discussed mathematically in the *A quick introduction
    to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*. Feel free to jump back and test the
    math again if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quantum programs that we discuss in this chapter can be found here:  [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter06](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing quantum gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help us understand quantum gates, we can use the `ch6_r1_quantum_gate_ui.py`
    sample program.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe differs a bit from the ones that we have seen so far. Up until now,
    we have mainly just used Qiskit® commands inside a Python wrapper, with no actual
    coding beyond that. This time, we start out by building a rudimentary Python implementation
    to create a very basic *before-after gate exploration UI*. When you run the program,
    it prompts you to select an initial qubit state and a gate to apply to your qubit;
    then it creates a visualization to show you the gate action on the qubit.
  prefs: []
  type: TYPE_NORMAL
- en: The script builds your circuit for you and then shows the basic minimum circuit
    that supports the gate, the state vector, and a Bloch sphere or Q-sphere visualization
    that corresponds to the gate action. The visualization highlights the qubit's
    state before the gate, and how the state changes after the gate.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid classical/quantum programs
  prefs: []
  type: TYPE_NORMAL
- en: So, what we are doing here is building a hybrid classical/quantum program, where
    we use Python to drive user input control, general logic, and presentation, and
    the Qiskit® components to access the quantum-related features. This is what we
    will be doing going forward in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we step into the visualizer, let''s spend a second discussing a few
    basic qubit states that we can initialize our qubit in. You know two of them (![](img/Formula_06_001.png)
    and ![](img/Formula_06_002.png)) well, but for an understanding of where on the
    Bloch sphere our qubit state vector points, here''s a quick introduction of the
    rest with their Dirac ket description and a Bloch sphere reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_003.png): Straight up along the *z* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_06_004.png): Straight down along the *z* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_06_005.png): Out along the + *x* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_06_006.png): In along the - *x* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_06_007.png): Right along the + *y* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_06_008.png): Left along the - *y* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The initial qubit states mapped on the Bloch sphere](img/Figure_6.1_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The initial qubit states mapped on the Bloch sphere
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will explore several interesting Qiskit® features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qiskit.visualization` class includes various methods to visualize your qubits
    and your circuits. In this recipe, we will use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bloch sphere**: Displays a single qubit as a Bloch sphere:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Q-sphere**: Displays 1 or more qubits as a state probability vector on a
    sphere:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Initialize**: Used to initialize a qubit to specific initial states:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Statevector simulator**: An **Aer** quantum simulator that is used to calculate
    the state vector of a qubit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Unitary simulator**: An **Aer** quantum simulator that lets you calculate
    the unitary matrix of a quantum circuit. If you use this simulator on a circuit
    that contains only a single gate, you can in essence pull out the matrix representation
    of that quantum gate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`QuantumCircuit.from_qasm_str(qasm_string)` method that we explored in the
    *Moving between worlds* recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *IBM Quantum® Experience – Drag and Drop Quantum Computing*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for the sample program is available here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample program is a little convoluted but running it is straightforward.
    Each step is separated by an input step to select start states and gates, or by
    a simple *Hit Enter* before the next step rolls along:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ch6_r1_quantum_gate_ui.py` sample file in your Python environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the first prompt, enter the starting state for your first qubit. If you
    pick a gate that uses more than 1 qubit, such as the CX gate, the qubit state
    that you select here is for the controlling qubit. Your options are the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The first prompt: Select a start state](img/Figure_6.2_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the second prompt, enter the gate that you want to explore, for example
    `X`:![Figure 6.3 – The second prompt: Select a gate'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The program now uses the `get unitary()` function from the sample code on a
    blank circuit to retrieve and print the unitary matrix for the gate that you selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For an X gate, the output will look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.4 – First output: The unitary for the gate](img/Figure_6.4_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.4 – First output: The unitary for the gate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compare this to the matrix version of the X gate that we calculated in [*Chapter
    2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing and Qubits
    with Python*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_06_019.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We are now ready for the meat of the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Enter* to create the initial setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program calls the `qgate(gate,start)` function to set up the circuit based
    on your input. It uses the gate input with `create_circuit(n_qubits,start)` to
    set up a 1-qubit or 2-qubit circuit, and then uses the `qgate_out(circuit,start)`
    function to display the empty circuit. At this point, the circuit will only include
    an `initialized` qubit set to the starting state you selected, and if the input
    state is ![](img/Formula_06_001.png), then we do not need to initialize the circuit
    at all.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `initialize()` method takes a vector of complex amplitudes and a target
    qubit as input and adds a circuit instruction that looks much like a gate. The
    complex amplitudes must be normalized, and in the program, we use the following
    to create the vector: `[a * complex(1, 0), b * complex(1, 0)]`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output should be something like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Second output: Initial circuit, state vector, and Bloch-sphere'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_6.5_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.5 – Second output: Initial circuit, state vector, and Bloch-sphere'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Enter* again to add the gate you selected and display the end results
    after the gate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end result of the call to the `qgate(gate,start)` function was to return
    the complete circuit. We now use the `qgate_out(circuit,start)` function to display
    the final results, after the gate is applied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the expected output for an X gate, acting on a qubit initialized to
    ![](img/Formula_06_021.png):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Third output: Circuit, state vector, and Bloch sphere after
    the gate ](img/Figure_6.6_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6 – Third output: Circuit, state vector, and Bloch sphere after the
    gate'
  prefs: []
  type: TYPE_NORMAL
- en: The result of the initial run is the qubit started out in the ![](img/Formula_06_022.png)
    state, pointing straight up, and was then flipped by the X gate to ![](img/Formula_06_002.png),
    pointing straight down.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the program, we defined several functions that run the Qiskit® specific
    functionality of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_psi(circuit)`: This is the same function that we introduced in [*Chapter
    4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting at the Ground Level
    with Terra*, with a slight twist. Instead of using it to directly plot the Bloch
    vector, we set it up to return the state vector so that we can use it elsewhere.
    The function takes as input a quantum circuit and returns the state vector of
    that circuit by using the `statevector_simulator` backend that is provided by
    Qiskit Aer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`get_unitary(circuit)`: This function takes as input a quantum circuit and
    returns the unitary matrix for that circuit by using the `unitary_simulator` Aer
    backend:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`create_circuit(n_qubits,start)`: This function creates a quantum circuit and
    initializes it to the start state that you selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We start by setting up the start vector based on the user input: `1`, `+`,
    `-`, `R`, `L`, `r`, or `d`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create the circuit for the specified number of qubits and initialize
    the qubit if the start state is not ![](img/Formula_06_001.png):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`qgate_out(circuit,start)`: In addition, we use the `print` functionality with
    some of the Qiskit® methods to create and save images of our circuits and the
    Bloch-sphere representations of the qubits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`qgate(gate,start)`: This function takes as input a gate and a start state,
    and then creates a quantum circuit from these. For single-qubit gates, the gate
    is added to the first qubit, and for 2-qubit gates, the second qubit is the controller
    qubit and the first qubit is the controlled qubit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It then compares the input gate to the `oneq_gates` list, and promptly calls
    the `create_circuit()` function to create a 1-qubit or 2-qubit circuit. At this
    point, we also create the correct 1-qubit or 2-qubit QASM string that we use to
    append the selected gate to the circuit using the `from_qasm_str()` method that
    we started looking at in the *Moving between worlds* recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *IBM Quantum Experience® – Quantum Drag and Drop*. As luck would have it, the
    QASM code for our gates corresponds one-to-one with the names of the gates. To
    add an `x` gate, we use the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Where the string addition is in the `from_qasm_string()` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This translates into the following code and appends the `x` `gate` to the circuit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `qgate()` function then returns the circuit and we can move on:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, now you are equipped with a little program that lets you set up very basic
    one-gate circuits and study the initial and final state vectors, see the unitary
    matrixes of the selected gates, and view how the gates make the Bloch vector move
    around, and visualize on a **Q-sphere** where the **Bloch sphere** is no longer
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: Now take this program for a spin by working your way through the rest of the
    recipes in this chapter to explore the base set of quantum gates that Qiskit®
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a quick interactive look at a single-qubit Bloch sphere representation
    and what certain gate operations do to it, take a look at the **grok-bloch** application
    by Qiskit Advocate James Weaver: [https://github.com/JavaFXpert/grok-bloch](https://github.com/JavaFXpert/grok-bloch).
    You can install and run it from your own Python environment or run it online here:
    [https://javafxpert.github.io/grok-bloch/](https://javafxpert.github.io/grok-bloch/).'
  prefs: []
  type: TYPE_NORMAL
- en: Flipping with the Pauli X, Y, and Z gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pauli X, Y, and Z gates all act on a single qubit, and perform an action
    similar to a classical NOT gate, which flips the value of a classical bit. For
    example, the X gate sends ![](img/Formula_06_027.png) to ![](img/Formula_06_028.png)
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: As we shall see, the X gate is actually a rotation around the *x* axis of ![](img/Formula_06_029.png)
    radians. The same is true for the Pauli Y and Z gates, but along the *y* and *z*
    axes correspondingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, the X, Y, and Z gates can be expressed as the following unitary
    matrixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_030.png) ![](img/Formula_06_031.png) ![](img/Formula_06_032.png)'
  prefs: []
  type: TYPE_IMG
- en: This recipe will serve as a sort of template for how to use the sample code
    that is provided in the chapter. The remaining recipes will largely gloss over
    the deeper details.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the Pauli X, Y, and Z gates by running the Quantum Gate
    UI sample program. It starts by setting up a plain quantum circuit with a single
    qubit initiated in a state that you select. The gate selected is then added to
    the circuit, and then the unitary simulator and state vector simulators are run
    to display the results in the form of a qubit state vector and the gate unitary
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a start state for your qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The X and Y gates work well with ![](img/Formula_06_0221.png) and ![](img/Formula_06_023.png),
    essentially acting as a NOT gate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With ![](img/Formula_06_035.png)), the X gate will do nothing, but the Y and
    Z gate will create a phase shift of ![](img/Formula_06_036.png), creating ![](img/Formula_06_037.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also test ![](img/Formula_06_038.png) and ![](img/Formula_06_039.png) to see
    what they do. If you use the **r** (**random**) or **d** (**define**) inputs,
    then you can explore the gate rotations in more detail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When prompted, enter `x`, `y`, or `z` to select the gate to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We tested the X gate in the *Visualizing the quantum gates* recipe. Now take
    a look at the others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Z gate with a random start state might produce the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The Z gate with a random start state](img/Figure_6.7_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The Z gate with a random start state
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Pauli gates cannot run directly on a quantum backend, but are automatically
    transpiled to the following unitary basis gates before you run your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For more information, see the *Building our circuits with the basis gates –
    U1,U2, U3, and ID* and *What your quantum circuit really looks like* recipes in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating superpositions with the H gate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's revisit our old friend from [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*, the **Hadamard** or **H** gate. This
    is a fairly specialized gate that we can use to make a generic qubit superposition.
    But there's more to it than that; we can also make use of the H gate to change
    the axis of measurement from the generic *z* (or computational) axis to the *x*
    axis to gain additional insights into the qubit behavior. More on that in the
    *There's more* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The H gate can be expressed as the following unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unless you are really good at interpreting matrix operations, it might not
    be entirely clear just what this gate will do with your qubits. If we describe
    the behavior as a combination of 2 qubit rotations instead, things might become
    clearer. When you apply the Hadamard gate to your qubit, you run it through two
    rotations: first a ![](img/Formula_06_041.png) rotation around the *y* axis, and
    then a ![](img/Formula_06_042.png) rotation around the *x* axis.'
  prefs: []
  type: TYPE_NORMAL
- en: For a qubit in state ![](img/Formula_06_043.png), this means that we start at
    the North Pole, and then travel down to the equator, ending up at the ![](img/Formula_06_044.png)
    location on the Bloch sphere, and finally just rotate around the *x* axis. Similarly,
    if you start at the South Pole at ![](img/Formula_06_045.png), you first move
    up to the equator but at the other extreme on the *x* axis, ending up at ![](img/Formula_06_046.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do the matrix math for ![](img/Formula_06_047.png), we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can use the following Dirac ket notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/Formula_06_050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we replace *a* and *b* with ![](img/Formula_06_051.png) from above, we get:
    ![](img/Formula_06_052.png) and ![](img/Formula_06_053.png), which corresponds
    to ![](img/Formula_06_044.png).'
  prefs: []
  type: TYPE_NORMAL
- en: If we apply the Hadamard gate to qubits in states other than pure ![](img/Formula_06_055.png)
    and ![](img/Formula_06_056.png), we rotate the qubit to a new position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore the Hadamard gate, we run the Quantum Gate program that is described
    in the *Visualizing quantum gates* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a start state for your qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The H gate works well with ![](img/Formula_06_057.png) and ![](img/Formula_06_058.png),
    placing you on the equator in an equal superposition. With ![](img/Formula_06_059.png)
    and ![](img/Formula_06_060.png), the H gate will return the equal superposition
    to the corresponding computational states, ![](img/Formula_06_0221.png) and ![](img/Formula_06_023.png).
    Try the ![](img/Formula_06_063.png), ![](img/Formula_06_0391.png), Random or Define
    inputs to explore the gate rotations in more detail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When prompted, enter *h* to select the gate to test. The H gate applied to
    ![](img/Formula_06_0221.png) will produce the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The H gate with |0> start state'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.8_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – The H gate with |0> start state
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Hadamard gate cannot run directly on a quantum backend, but is automatically
    transpiled to the following unitary basis gate before you run your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For more information, see the *Building our circuits with the basis gates –
    U1,U2, U3, and ID* and *What your quantum circuit really looks like* recipes in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Hadamard gate is also commonly used to change your measurement axis from
    the default (computational) *z* axis to the *x* axis. By measuring in the *x*
    axis, you can detect the qubit phase.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out the value of the phase, you must add one more measurement, this
    time along the *y* axis. To achieve this, you use the Hadamard gate in combination
    with the S dagger gate to shift over to Y.
  prefs: []
  type: TYPE_NORMAL
- en: The way you can visualize the changing of the measurement basis is to picture
    us rotating the qubit to match up with the axis we want to measure, and then do
    a standard Z measurement. When we measure along the *x* axis, we rotate the qubit
    to face in the ![](img/Formula_06_066.png) direction, and for the *y* axis to
    point, in the ![](img/Formula_06_156.png) direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the gate combinations that you need to apply to measure along the
    three Bloch sphere axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Measure along z (computational basis):**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 - Measure along z](img/Figure_6.9_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 - Measure along z
  prefs: []
  type: TYPE_NORMAL
- en: '**Measure along x:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure6.10 - Measure along x](img/Figure_6.10_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure6.10 - Measure along x
  prefs: []
  type: TYPE_NORMAL
- en: '**Measure along y:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 - Measure along y](img/Figure_6.11_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 - Measure along y
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For an example of measuring along different axes to measure the phase of a qubit,
    see the *Exploring quantum phase kickback* recipe of [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed z rotations with phase shift gates S, ![](img/Formula_06_0681.png), T,
    and ![](img/Formula_06_0691.png)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The S, ![](img/Formula_06_070.png), T, and ![](img/Formula_06_071.png) gates
    all perform rotations around the *z* axis of the qubit. This means that when you
    measure the qubit, there is no change in the probability of measuring the outcome
    as 1 or 0\. What does change is the phase of the qubit.
  prefs: []
  type: TYPE_NORMAL
- en: The S-gate and T-gate are not their own inverses
  prefs: []
  type: TYPE_NORMAL
- en: As the S and T gates perform set rotations around the *z* axis, they are not
    reversible. Adding two of these gates in a row does not negate them. Instead,
    Qiskit includes the S† and T† gates which serve as the reverse S and T gates.
    For a quick reminder, see the *A quick introduction to quantum gates* recipe in
    [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing
    and Qubits with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, the S and T gates can be expressed as the following unitary
    matrixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_072.png) ![](img/Formula_06_073.png) ![](img/Formula_06_074.png)
    ![](img/Formula_06_075.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore the phase shift gates, we run the Quantum Gate UI program that is
    described in the *Visualizing quantum gates* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a start state for your qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As these phase shift gates perform rotations around the *z* axis, there is very
    little point in using the default ![](img/Formula_06_0221.png) or ![](img/Formula_06_023.png)
    qubits, which are phaseless. Instead, pick a superposition state qubit such as
    **+**, **-**, **L**, **R**, **r**, or **d**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When prompted, enter `s`, `sdg`, `t`, or `tdg` to select the gate to test. The
    S gate on ![](img/Formula_06_078.png) should produce the following output:![Figure
    6.12 – The S gate with the  start state](img/Figure_6.12_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.12 – The S gate with the ![](img/Formula_06_079.png) start state
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The phase shift gates cannot run directly on a quantum backend, but are automatically
    transpiled to the following unitary basis gates before you run your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For more information, see the *Building our circuits with the basis gates –
    U1,U2, U3, and ID* and *What your quantum circuit really looks like* recipes in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Free rotation around the axes with Rx, Ry, and Rz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While all the phase gates rotate around the *z* axis to change the phase of
    the qubit, the rotation gates perform rotations around the respective axes of
    the Bloch sphere. Rx and Ry rotate the qubit ![](img/Formula_06_015.png) angle
    at the phase angle (![](img/Formula_06_080.png)) 0 and ![](img/Formula_06_081.png)
    , and Rz rotates around Z, with the special case of ![](img/Formula_06_082.png)
    and ![](img/Formula_06_083.png), corresponding to the S and T gates.
  prefs: []
  type: TYPE_NORMAL
- en: The R-gates are not their own inverses
  prefs: []
  type: TYPE_NORMAL
- en: As the R-gates perform free rotations around the X, Y, or Z axes, they are not
    reversible. Adding two of these gates in a row does not negate them. For a quick
    reminder, see the *A quick introduction to quantum gates* recipe in [*Chapter
    2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing and Qubits
    with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, the R gates can be expressed as unitary matrixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_084.jpg)![](img/Formula_06_085.jpg)![](img/Formula_06_086.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore the phase shift gates, we run the Quantum Gate program that is described
    in the *Visualizing the quantum gates* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a start state for your qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The R gates perform arbitrary rotations around the corresponding axes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As all these gates perform rotations around the corresponding axes, play around
    with ![](img/Formula_06_087.png) to get a feel for what rotates where. Then test
    with Random or Define to explore more exotic rotations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When prompted, enter `rx`, `ry`, or `rz` to select the gate to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the angle (![](img/Formula_06_088.png)) with which to rotate. The Rx gate,
    set to ![](img/Formula_06_089.png) rotation on ![](img/Formula_06_090.png), should
    produce the following output:![Figure 6.13 – The Rx gate rotating  with the  start
    state](img/Figure_6.13_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.13 – The Rx gate rotating ![](img/Formula_06_091.png) with the ![](img/Formula_06_092.png)
    start state
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, test again using various rotation angles to see the behavior by entering
    the following values for the ![](img/Formula_06_093.png) and/or ![](img/Formula_06_094.png)
    angles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_095.jpg)![](img/Formula_06_096.jpg)![](img/Formula_06_097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Pauli gates cannot run directly on a quantum backend, but are automatically
    transpiled to the following unitary basis gates before you run your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For more information, see the *Building our circuits with the basis gates –
    U1,U2, U3, and ID* and *What your quantum circuit really looks like* recipes in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building our circuits with the basis gates – U1, U2, U3, and ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by exploring three of the gates that we recognize from [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit®*. You will not be using these three basis gates, U1, U2,
    and U3, in your quantum programs. However, they serve as building blocks for all
    other single-qubit gates when you run your circuits on a quantum computer. In
    fact, every other single-qubit gate can be written using just the U3 gate. There
    is nothing explicitly stopping you from using them, but the gate collection that
    we will go through in the rest of the recipes covers all the ground that we need.
  prefs: []
  type: TYPE_NORMAL
- en: The U gates are not their own inverses
  prefs: []
  type: TYPE_NORMAL
- en: As the U gates perform free rotations around the *x*, *y*, and *z* axes, they
    are generally not reversible. Adding two of these gates in a row does not negate
    them unless the rotations add up to complete rotations. For a quick reminder,
    see the *A quick introduction to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember back when we explored the IBM Quantum® backends in [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit®*, we took a look at the so-called **basis gates** available
    for the hardware backend using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It returned something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The CX and ID gates are ordinary gates that you use in your programs, UX (Controlled
    NOT) to create entanglements, and ID to run a gate that leaves the qubit untouched
    (more on these later). The U1, U2, and U3 gates are different though.
  prefs: []
  type: TYPE_NORMAL
- en: Remember from [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, how we can see a quantum gate as a
    rotation around the ![](img/Formula_06_104.png) and ![](img/Formula_06_105.png)
    angles. This is exactly what the U gates do, with one, two, and three inputs respectively.
    In fact, single-qubit U-gate rotations and CNOT gates constitute a universal gate
    set for quantum computing. And here, the Id gate is a special case of rotation,
    with no rotation at all.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing with the basis gates is that you can program your qubits directly
    on the hardware using them. All other gates are translated into basis gates and
    then executed as you will see when we discuss the transpiler.
  prefs: []
  type: TYPE_NORMAL
- en: The U3 gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The U3 gate is really the Swiss Army knife of quantum gates. It is the foundational
    unitary matrix for qubit manipulation. Every single-qubit manipulation that can
    be done can be done with the U3 gate, which can be expressed as the following
    unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_106.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The three angles are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_093.png) = The polar angle between ![](img/Formula_06_0221.png)
    and the state vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_06_109.png) = The longitudinal angle from the *x* axis (![](img/Formula_06_078.png))'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/Formula_06_111.png) = The overall qubit phase angle (not visible on
    the Bloch sphere)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: The U2 and U1 gates are basically specializations of U3, just like the other
    quantum gates are specializations of the U gates in general.
  prefs: []
  type: TYPE_NORMAL
- en: The U2 gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the U2 gate, you can manipulate two angles at the same time. The U2 gate
    is the same as the U3 gate with ![](img/Formula_06_112.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The U2 gate can be expressed as the following unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The U1 gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the U1 gate, you can rotate the phase of the qubit around the *z* axis.
    A special case of the U1 is the Rz gate, which has the same input. The U1 gate
    is the same as the U3 gate with ![](img/Formula_06_114.png) and ![](img/Formula_06_115.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The U1 gate can be expressed as the following unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With these three gates, you can perform all possible single-qubit manipulations.
    They are not that user-friendly to read through and therefore Qiskit® includes
    translations of all relevant quantum gates for your programming ease. When you
    run your circuits, however, all the gates are translated into the collection of
    basis gates supported by the selected backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pauli Id gate is a special gate that leaves the qubit in the same state
    as it was found. The gate can be expressed using the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_117.png) = ![](img/Formula_06_118.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for the sample program is available here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r2_u_animation.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r2_u_animation.py).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we use the Pillow package to create, save, and merge images.
    For more information about Pillow, see [https://pypi.org/project/Pillow/](https://pypi.org/project/Pillow/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Pillow
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to install Pillow in your environment, you can use the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(environment_name) … $ pip install --upgrade pip`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(environment_name) … $ pip install --upgrade Pillow`'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will visualize the rotations of the U gates on a Bloch sphere.
    As you already know, we can use the `plot_bloch_multivector()` and `plot_state_qsphere()`
    methods to visualize how our state vectors behave and what the possible outcomes
    are. These both provide static views of the qubit at one moment and of the U gates
    for a specific set of angles.
  prefs: []
  type: TYPE_NORMAL
- en: In the sample program, you enter the angles input for your U gates, after which
    the program takes snapshots between 0 and the angle at a given resolution and
    produces an animated GIF that shows the movement of the qubit state vector on
    the Bloch sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this animation doesn''t really show you how a qubit vector moves
    when you apply the gate, but rather gives a view of how you can use the U gates
    to position your qubit state vector wherever you want:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by running the `ch6_r2_u_animation.py` script in your Python environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompts, enter the type of gate that you want to test, and then enter
    the required input angles for the gate. For the U3 gate, your input might look
    like this for ![](img/Formula_06_119.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the background, we are now calling the `create_images()` function, which
    takes the input you provided and then iteratively creates a set of circuits that
    iteratively apply the U gate you selected with the input angles divided into smaller
    angles as dictated by the *steps* parameter. Each circuit is then run through
    the statevector simulator in the `get_psi()` function that we created in the first
    recipe, *Visualizing the quantum gates*, and is finally saved as a Bloch sphere
    image and a Q-sphere image using `plot_bloch_multivector()` and `plot_state_qsphere()`.
    The images are continuously appended to two lists that will later be merged into
    an animation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here's how we build the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start by setting the input parameters and all internal function variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create the image and animation tools:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run the image creation loop based on the input parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create and save the animated GIFs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final step is to create the GIFs. Here we use the `save_gif(gate)` function
    to iterate through the image lists we created and let Pillow build the GIFs with
    our initial parameters. This is what we do:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final Python output might look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final result will be two animated GIFs saved in the same directory as where
    you run your script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now open the GIFs in an image viewer or web browser to take a look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Still of animated GIFs of a Bloch sphere and a Q-sphere'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_6.14_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.14 – Still of animated GIFs of a Bloch sphere and a Q-sphere
  prefs: []
  type: TYPE_NORMAL
- en: If you view the animated GIFs side by side and synchronized, the Q-sphere representation
    shows the relative probabilities and phase angle of the qubit as the U gate is
    applied to it. Play around with different angles and different loop parameters
    to see how you can make the animations work for you.
  prefs: []
  type: TYPE_NORMAL
- en: If you set the angles in the range of 0 to ![](img/Formula_06_123.png) and set
    your steps to a reasonably high number, you can create nice smooth looping effects.
    There is nothing stopping you from setting the angles really high though, which
    will result in fairly chaotic behavior in the animations. Have fun!
  prefs: []
  type: TYPE_NORMAL
- en: 'When you test the U gates with the script, remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: U3 lets you point the qubit vector anywhere on the Bloch sphere using two angles,
    ![](img/Formula_06_124.png) and ![](img/Formula_06_125.png). The third angle,
    ![](img/Formula_06_111.png), has no effect on the Bloch sphere representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: U2 is the same as U3 but with ![](img/Formula_06_015.png) set to ![](img/Formula_06_128.png)
    , which places the qubit vector on the equator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: U1 is the same as U3 but with both ![](img/Formula_06_124.png) and ![](img/Formula_06_130.png)
    set to 0\. A special case of U1 is Rz.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, in this case, there's less not more. The sample script in this recipe
    will work in your local environment, but not very well in your IBM Quantum Experience®
    notebook environment as you do not have access to the underlying filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Using gates on 2 qubits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two-qubit gates such as controlled gates are slightly different from ordinary
    1-qubit gates; they let you create interaction between your qubits. In general,
    this translates into using 1 qubit as the control qubit, and the other as the
    acted-on qubit. Mathematically, this is not super complex, but intuitively you
    might have to think once or twice about what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first 2-qubit gate that we'll touch on is the Controlled-NOT gate that we
    saw in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting
    at the Ground Level with Terra*. The CX gate is generally used to create entanglement
    between qubits if the control qubit is in a superposition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A CX gate where the controlling qubit is the second qubit and the controlled
    qubit the first can be expressed as the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This corresponds to the following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – CX gate from q_1 to q_0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – CX gate from q_1 to q_0
  prefs: []
  type: TYPE_NORMAL
- en: The way you interpret this is to run the first or controlling qubit through
    an Id gate, leaving it untouched. The second, or controlled, qubit applies an
    X gate if the first qubit is 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two matrix calculations to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the first qubit is 1 and the second 0\. The result is both qubits in
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_133.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, both qubits are 1\. The result is the first qubit is 1 and the second
    is 0.
  prefs: []
  type: TYPE_NORMAL
- en: The CX gate is one of the basis gates of the IBM Quantum® backends.
  prefs: []
  type: TYPE_NORMAL
- en: Other CX matrices
  prefs: []
  type: TYPE_NORMAL
- en: 'If the CX gate points the other way, with the first qubit as the controlling
    qubit, the matrix will look like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_134.png)'
  prefs: []
  type: TYPE_IMG
- en: To convince yourself, do the calculation. For a quick refresher, see the *A
    quick introduction to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, for the single-qubit gates, the Quantum Gate program set up a plain
    quantum circuit with one qubit initiated in the ground state ![](img/Formula_06_0221.png).
    When we start playing with multi-qubit gates, the program will initialize with
    both qubits in ![](img/Formula_06_0221.png). The gate selected is then run on
    the circuit, and results in the form of a qubit state vector and the gate unitary
    matrix are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore the control gates, we run the Quantum Gate program that is described
    in the *Visualizing quantum gates* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a start state for your controlling qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Cn gates use a single qubit as the controlling qubit and the other qubit
    as the controlled qubit. If the state of the controlling qubit is anything other
    than ![](img/Formula_06_0221.png), some action will be performed on the controlled
    qubit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to, then you can start by testing with ![](img/Formula_06_0221.png)—just
    to verify that no action is performed and that the 2-qubit state doesn't change.
    Then test with start state ![](img/Formula_06_139.png) to create a Bell state,
    as we did in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting
    at the Ground Level with Terra*. After you are done with this, play around with
    ![](img/Formula_06_140.png), Random or Define to explore other control states.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When prompted, enter `cx`, `cy`, `cz`, or `ch` to select the gate to test. For
    example, a CX gate with the controlling qubit state ![](img/Formula_06_078.png)
    will generate the following output:![Figure 6.16 – CX gate with the start state
    |+>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.16 – CX gate with the start state |+>
  prefs: []
  type: TYPE_NORMAL
- en: Here, notice that the Bloch sphere representation makes no sense after the CX
    gate has been applied. The qubits are now entangled, and we can get no further
    individual information from them. In this case, we display the Q-sphere interpretation
    for clarification, where the initial Q-sphere indicates equal probabilities of
    getting states ![](img/Formula_06_142.png) and ![](img/Formula_06_143.png), and
    after the X gate, equal probabilities of getting ![](img/Formula_06_144.png),
    as expected for a Bell state.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CX gate is just one of many possible two-qubit control gates. Among the
    others built into Qiskit® are the CY and CZ gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_145.jpg)![](img/Formula_06_146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Or why not a controlled Hadamard gate?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_147.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another handy 2-qubit gate is the SWAP gate that swaps the value of the first
    and second qubit. In this case, there is no entanglement and the individual qubits
    remain individuals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_148.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two-qubit gates can also be written as a combination of basis gates. For
    example, this is how you can code the CY gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For more information, and to test-transpile the other Cn gates, see the *What
    your quantum circuit really looks like* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Quantum Computation and Quantum Information*, 10th Anniversary Edition, Michael
    A. Nielsen & Isaac L. Chuang, *Chapter 4.3 Controlled operations*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using gates on more than 2 qubits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the single-qubit and two-qubit gates, Qiskit® also supports 3-
    and more qubit gates. We will use one of them, the Toffoli gate when we build
    the 3-qubit Grover search algorithm circuit in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*. We are including the Fredkin gate for completeness
    and will not be using it in any other examples; feel free to try it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multi-qubit gates in this recipe use 2, more, and 1 controlling qubit respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Toffoli**: Controlled-controlled NOT (**CCX**), which takes 2 qubits as input
    and flips the third if both controlling qubits are set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MCX**: Multi-controlled NOT takes a number of qubits (controlling) as input
    and flips the controlled qubit if all are set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is (in principle) no limit to the number of controlling qubits that you
    can use with your gates. In the 4- and more qubit Grover search algorithm circuit
    in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)*, Grover's Search
    Algorithm*, we build a 4-qubit **CCCX** **controlled-controlled-controlled** gate
    by using the **MCX** gate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Fredkin**: Controlled SWAP, (**CSWAP**), which takes a single qubit as input
    and swaps the other two if the controlling qubit is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your quantum programs, use the following sample code to implement these 3-qubit
    gates.
  prefs: []
  type: TYPE_NORMAL
- en: Toffoli
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Toffoli or **CCX** gate is represented by the following unitary matrix
    with the second and third qubits controlling the first qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_149.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code implements the CCX gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And the circuit looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The Toffoli gate'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – The Toffoli gate
  prefs: []
  type: TYPE_NORMAL
- en: Other CCX matrixes
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like for the CX gate, the matrix will look different depending on which
    qubits you should use to control. For example, here is the matrix for a CCX gate
    where the first and second qubits control the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_150.png)'
  prefs: []
  type: TYPE_IMG
- en: To convince yourself, do the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: MCX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MCX gate is used to build general controlled-NOT gates with more than one
    controlling gate. The Toffoli (CCX) gate is a special example where this is an
    already coded gate. For controlled-NOT gates with more than 2 controlling qubits,
    you can use the MCX gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements the MCX gate as a CCCX gate with second, third,
    and fourth qubits controlling the first qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And the circuit looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The MCX gate for 3 controlling qubits (CCCX)](img/Figure_6.18_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – The MCX gate for 3 controlling qubits (CCCX)
  prefs: []
  type: TYPE_NORMAL
- en: Fredkin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Fredkin or **CSWAP** gate is represented by the following unitary matrix
    with the controlling third qubit swapping the first and second qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code implements the CSWAP gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And the circuit looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – The Fredkin gate'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.19_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – The Fredkin gate
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like the other gates that we have looked at in this chapter, the Toffoli
    and Fredkin gates are included with the basic set of Qiskit® gates. However, they
    are not basis gates, which means that they need to be rewritten using a set of
    basis gates, such as **u1**, **u2**, **u3**, **id**, and **cx**. This is called
    **transpiling** and is what we will be doing in the next recipe, *What your quantum
    circuit really looks like*. But we're jumping ahead just a little here and displaying
    the complexity of constructing these alluringly simple gates. Do try them out
    in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Toffoli constructed from basis gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Toffoli gate can be entered as a single gate in Qiskit®, which leads you
    to believe that the execution of the gate will correspond to *a single time step*
    just like the other gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – A single Toffoli gate built from 10+ basis gates'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.20_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.20 – A single Toffoli gate built from 10+ basis gates
  prefs: []
  type: TYPE_NORMAL
- en: When we unravel the CCX like this, we see that the truth is slightly worse than
    just one time step; the single gate is translated into a circuit depth of 11.
  prefs: []
  type: TYPE_NORMAL
- en: Fredkin constructed from basis gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much like the Toffoli gate, Fredkin might be transpiled into a large number
    of basis gates when executed on a hardware backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – A single Fredkin gate built from 20+ basis gates'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.21_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – A single Fredkin gate built from 20+ basis gates
  prefs: []
  type: TYPE_NORMAL
- en: For a single Fredkin gate, the circuit depth goes from 1 to 22\. Not everything
    is easy to do on a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: What your quantum circuit really looks like
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063), *IBM Quantum
    Experience® – Quantum Drag and Drop*, and [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit®*, we touched on the concept of
    `u1`, `u2`, `u3`, `id`, and `cx`. We discussed these gates in the previous recipes
    of this chapter and even listed how the other gates can be written as implementations
    or combinations of these.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will take a look at some other aspects of the transpiling
    of circuits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple transpiling of common gates to basis gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transpiling for a simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transpiling your circuit if it doesn't match the physical layout of the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-qubit backend basis gates
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Most IBM Quantum® backends have the following basis gates: `u1`, `u2`, `u3`,
    `id`, and `cx`. One-qubit backends such as `ibmq_armonk` have no use for multi-qubit
    gates such as CX, which is not included. If you set your backend to `ibmq_armonk`
    and run the following command, you will get the corresponding output:`>>> backend.configuration().basis_gates
    Out: [''id'', ''u1'', ''u2'', ''u3'']`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we execute a quantum program on an IBM quantum computer, our code is first
    transpiled down to the core basis gates (`u1`, `u2`, `u3`, `id`, and `cx`) that
    we can execute directly on the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r3_transpiler.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r3_transpiler.py).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we build our Python sample:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the needed classes and methods, including `transpile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also load our account, if needed, and set up a backend with `5` qubits:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at the basis gates and coupling map for the selected backend.
    The coupling map specifies the possible qubit connections for two-qubit circuits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should result in an output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Basis gates and CX coupling map for a backend'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_6.22_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.22 – Basis gates and CX coupling map for a backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a single qubit gates transpiling, the coupling map is not important. This
    changes when we write quantum programs that use two-qubit gates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then set up the `build_circuit()` function to create a basic circuit, and
    selectively add gates to it depending on what circuit we want to explore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we set up the `main()` function to run the circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main function prompts for a circuit to test, calls the `build_circuit()`
    function, transpiles the returned circuit using the `transpile()` class, and then
    displays the results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build and transpile a simple X circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch6_r3_transpiler.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter `1` to pick the `Simple` `X` circuit:![Figure 6.23 – First,
    select the Simple X circuit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.23_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.23 – First, select the Simple X circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code should result in an output similar to this:![Figure 6.24 – The output
    of the simple, single X gate circuit](img/Figure_6.24_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.24 – The output of the simple, single X gate circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The resulting circuit looks pretty similar. The only real change is that the
    X gate is now a U3 gate, one of the basis gates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can get a numerical result as well, by pulling out the circuit depths and
    sizes for the circuit and the transpiled circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This code should result in the following circuit depths and sizes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Circuit depth and size](img/Figure_6.25_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – Circuit depth and size
  prefs: []
  type: TYPE_NORMAL
- en: Here, depth means the number of end-to-end steps that the quantum computer has
    to execute. Each step might include one or more gates, depending on the layout
    of the circuit. The size is just the total number of gates that are executed.
  prefs: []
  type: TYPE_NORMAL
- en: For this very simple circuit transpiling, there isn't much of a change. The
    U3 gate performs the required rotation around the *x* axis, and the circuit depth
    and size are the same. Technically, you could use the U3 gate instead of the X
    gate in your code, but it would be much less transparent.
  prefs: []
  type: TYPE_NORMAL
- en: Transpiling for a simulator?
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens if you try transpiling your circuits for a simulator backend?
    As it turns out, the simulator includes many more basis gates than the hardware
    backends, so the transpiling will be different. To test this, simply uncomment
    the following line in the script to set the backend to a simulator and run the
    program again:'
  prefs: []
  type: TYPE_NORMAL
- en: '`backend = provider.get_backend(''ibmq_qasm_simulator'')`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ibmq_qasm_simulator` supports the following basis gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[''u1'', ''u2'', ''u3'', ''cx'', ''cz'', ''id'', ''x'', ''y'', ''z'', ''h'',
    ''s'', ''sdg'', ''t'', ''tdg'', ''ccx'', ''swap'', ''unitary'', ''initialize'',
    ''kraus'']`'
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, you can provide additional parameters when running the transpiler,
    such as `basis_gates` and `coupling_map` to define the basis gates that you want
    to use and specify how the qubits are connected for use when transpiling for multi-qubit
    gates. We will not go into any details about that in this chapter, but take a
    look at the Qiskit® help for more info:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> from qiskit.compiler import transpile`'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> help(transpile)`'
  prefs: []
  type: TYPE_NORMAL
- en: Now take a look at the *There's more* section for a short showcase of how things
    can get much more complicated, quickly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This quick recipe gave a quick taste of what the transpiler does for a very
    simple quantum program, and illustrated how the transpiler translates your generic
    circuits into circuits that can be directly executed on the quantum chip.
  prefs: []
  type: TYPE_NORMAL
- en: The following quick examples illustrate the complexities that might befall the
    poor transpiler if you ask it to build circuits that do not at all match the physical
    layout of the backend. You can test these circuits in the sample code to see if
    you get similar results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the following inputs when running the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding H and H + Barrier – Multiple gates and the barrier circuit element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The transpiling of one gate doesn't leave the transpiler with a lot to do, but
    as soon as you add more gates, things quickly get more complex. Remember that
    quantum gates generically are rotations around the three axes *x*, *y*, and *z*.
    If two gates are added in a row, the transpiler seeks to simplify the circuit
    (and thus make it shorter; less deep) by combining multiple gates into single
    basis gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sample code, we extended the quantum circuit by adding a Hadamard gate
    after the X gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the circuit now, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – Simplified transpiled circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.26_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.26 – Simplified transpiled circuit
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the transpiler combined the two gates into one, simplifying
    and shortening the circuit by looking ahead at what the gate combination would
    result in, and coding that as a U gate. However, it is not always that you want
    this simplification. For example, as we saw in the *A quick introduction to quantum
    gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, two identical quantum gates in a row
    might effectively cancel each other out. In some instances, a quantum circuit
    will end up being constructed out of repeating gates, and if those repeating gates
    are removed, the circuit will not work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is the `barrier()` circuit component, which stops the transpiler
    from simplifying by combining gates. By using the *H + Barrier* option, we add
    a barrier between the X and H gates like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use the *H + Barrier* option, you should see something similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27 – Transpiler does not transpile past the barriers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.27_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.27 – Transpiler does not transpile past the barriers
  prefs: []
  type: TYPE_NORMAL
- en: The gates are now transpiled one by one, and the circuit depth is retained.
    So, no problem there, right? Well, these were pretty simple gates. What happens
    when we complicate our circuit a bit? Take a look at the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Controlled Y
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **controlled X gate** (**CX**) is a basis gate for the IBM Quantum® backends,
    but the **controlled Y** (**CY**) is not. To create a CY gate that can run on
    the backend, the transpiler adds some additional basis gates.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the *Controlled-Y* option, we add a `cy()` gate like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a CY gate that can run on the backend, the transpiler adds some additional
    basis gates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Transpiling a CY gate'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.28_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.28 – Transpiling a CY gate
  prefs: []
  type: TYPE_NORMAL
- en: Here we have the transpiler do a quick trick, adding Z rotations before and
    after the X in the CX gate. If the control qubit is 0, we will just get a rotation
    back and forth around the *z* axis. If the control qubit is 1, we get a negative
    quarter rotation around Z, a half-turn rotation around X, and then a quarter rotation
    back around Z, effectively landing us where we would have been with a half-turn
    Y rotation. Granted, a Y rotation would have been easily done with `Y(qubit)`
    `=` `U3(`![](img/Formula_06_154.png)`,` ![](img/Formula_06_154.png)`,` ![](img/Formula_06_154.png)`,`
    `qubit)`, but as the control functionality of the CX cannot be attached to the
    Y gate, we have to do this rework instead.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some other examples. These will illustrate how the transpiler
    works to convert your seemingly simple quantum circuits to circuits made out of
    basis gates that can be run on the actual IBM Quantum® hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Non-conforming CX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we set up a CX gate between two qubits that are not physically
    connected. As you have seen, CX is a base gate, so this should not require any
    transpiling, right? Well, in this case, we force the transpiler to attempt to
    build your circuit across two qubits that are not directly connected. In this
    case, the transpiler must map your CX gate across several intermediate qubits,
    which will add complexity to your circuit. In our sample code, we build this circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the sample code with the non-conforming CX input should result in something
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – Transpiling a CX gate across non-connected qubits'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.29_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.29 – Transpiling a CX gate across non-connected qubits
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how this simple, one-CX circuit all of a sudden ballooned to a circuit
    with seven CX gates. This is not the most efficient coding example. The reason
    for this is clear if you look at the coupling map for the quantum computer that
    we are transpiling for, IBM Quantum® Ourense. Qubit 4 cannot directly communicate
    with qubit 0, but has to go through 3 and 1 first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30 – The physical layout of one of the IBM Quantum® 5-qubit backends'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.30_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.30 – The physical layout of one of the IBM Quantum® 5-qubit backends
  prefs: []
  type: TYPE_NORMAL
- en: For simple circuits, there is no big difference between the original and transpiled
    circuits; try having the CX gate go from qubit 0 to qubit 1 and see what you get.
    But for more elaborate ones, the circuits quickly diverge.
  prefs: []
  type: TYPE_NORMAL
- en: But hang on!
  prefs: []
  type: TYPE_NORMAL
- en: 'For those nitpickers of you that, like me, have looked over the circuit and
    walked through what happens if qubit 0 is set to 1 to trigger the CX, you will
    have noticed that the result of the original circuit ought to be `barrier` and
    `measure` lines in the code and run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This ought to result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31 – The transpiler also moves the measurement instructions around'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.31_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.31 – The transpiler also moves the measurement instructions around
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the new mapping, qubits 1 and 3 are now measured to classical
    bits 0 and 4, just as we expected. The final measurement output will be correct.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-gate – Combined Bell and CSWAP circuit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This last example illustrates the complexity that occurs when you try to achieve
    something reasonably simple but run out of pathways to achieve it. We are creating
    a Bell state over qubits 0 and 4 and adding a controlled-SWAP gate from qubit
    3 to qubits 1 and 2 to have those qubits just swap values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The multi-gate input should give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32 – A complex transpiling of a reasonably simple Bell + CSWAP circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.32_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.32 – A complex transpiling of a reasonably simple Bell + CSWAP circuit
  prefs: []
  type: TYPE_NORMAL
- en: Well, trying this relatively simple circuit quickly took a turn for the worse.
    It ballooned from a depth of 2 to 32\. The circuit size also went up from the
    original 4 gates to an astounding 43\. Look at all those CX gates!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33 – Depth and size of the multi-gate circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.33_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.33 – Depth and size of the multi-gate circuit
  prefs: []
  type: TYPE_NORMAL
- en: Again, if you take a look at *Figure 6.33*, you can see why this happens. The
    simple act on our part of connecting qubit 0 and 4 is physically impossible as
    the quantum chip is laid out. Instead, this connection requires a chain of intermediate
    qubit connections across qubits 1, 2, and 3\. These additional connections caused
    the number of individual gates to explode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try the following circuit instead and see how that changes the counts.
    You should expect both depth and size to shrink significantly as you are now coding
    for qubits that can directly communicate with each other. Apparently, coding for
    the backend that you want to run your program on is still important in this **Noisy
    Intermediate-Scale Quantum (NISQ)** era:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.34 – A better conforming Bell + CSWAP circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.34_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.34 – A better conforming Bell + CSWAP circuit
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in this chapter, good quality programming is as important in
    quantum computing as it is in classical computing, if not more. The transpiler,
    left to its own devices, will do its best to translate your circuits to the backend
    where you plan to run them.
  prefs: []
  type: TYPE_NORMAL
- en: If it gets crowded, and you utilize all the qubits extensively, the rewriting
    of your circuit might extend the execution time beyond the T1 and T2 times, making
    your circuit produce junk results on today's **NISQ computer** even though it
    otherwise is very nicely constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum programming is definitely an art!
  prefs: []
  type: TYPE_NORMAL
