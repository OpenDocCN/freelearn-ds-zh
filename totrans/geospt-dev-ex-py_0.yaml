- en: '![Image 1](img/index-1_1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![图像1](img/index-1_1.jpg)'
- en: '**Geospatial Development By Example with**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过示例使用Python进行地理空间开发**'
- en: '**Python**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '**Table of Contents**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: '[Geospatial Development By Example with Python](#p13)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过示例使用Python进行地理空间开发](#p13)'
- en: '[Credits](#p15)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[致谢](#p15)'
- en: '[About the Author](#p17)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于作者](#p17)'
- en: '[About the Reviewers](#p19)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于审稿人](#p19)'
- en: '[www.PacktPub.com](#p21)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.PacktPub.com](#p21)'
- en: '[Support files, eBooks, discount offers, and more](#p23)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[支持文件、电子书、折扣优惠等](#p23)'
- en: '[Why subscribe?](#p24)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[为什么订阅？](#p24)'
- en: '[Free access for Packt account holders](#p25)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[Packt账户持有者的免费访问](#p25)'
- en: '[Preface](#p26)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[前言](#p26)'
- en: '[What this book covers](#p28)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[本书涵盖的内容](#p28)'
- en: '[What you need for this book](#p30)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[本书所需内容](#p30)'
- en: '[Who this book is for](#p32)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[本书面向的对象](#p32)'
- en: '[Conventions](#p34)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[约定](#p34)'
- en: '[Reader feedback](#p36)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[读者反馈](#p36)'
- en: '[Customer support](#p38)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[客户支持](#p38)'
- en: '[Downloading the example code](#p40)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[下载示例代码](#p40)'
- en: '[Downloading the color images of this book](#p41)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[下载本书的颜色图像](#p41)'
- en: '[Errata](#p42)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[勘误表](#p42)'
- en: '[Piracy](#p43)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[盗版](#p43)'
- en: '[Questions](#p44)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[问题](#p44)'
- en: '[1\. Preparing the Work Environment](#p45)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[1. 准备工作环境](#p45)'
- en: '[Installing Python](#p47)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装Python](#p47)'
- en: '[Windows](#p48)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows](#p48)'
- en: '[Ubuntu Linux](#p49)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ubuntu Linux](#p49)'
- en: '[Python packages and package manager](#p50)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python包和包管理器](#p50)'
- en: '[The repository of Python packages for Windows](#p52)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows上Python包的存储库](#p52)'
- en: '[Installing packages and required software](#p53)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装包和所需软件](#p53)'
- en: '[OpenCV](#p55)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[OpenCV](#p55)'
- en: '[Windows](#p56)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows](#p56)'
- en: '[Ubuntu Linux](#p57)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ubuntu Linux](#p57)'
- en: '[Installing NumPy](#p58)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装NumPy](#p58)'
- en: '[Windows](#p60)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows](#p60)'
- en: '[Ubuntu Linux](#p61)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ubuntu Linux](#p61)'
- en: '[Installing GDAL and OGR](#p62)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装GDAL和OGR](#p62)'
- en: '[Windows](#p66)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows](#p66)'
- en: '[Ubuntu Linux](#p67)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ubuntu Linux](#p67)'
- en: '[Installing Mapnik](#p68)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装Mapnik](#p68)'
- en: '[Windows](#p70)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows](#p70)'
- en: '[Ubuntu Linux](#p71)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ubuntu Linux](#p71)'
- en: '[Installing Shapely](#p72)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装Shapely](#p72)'
- en: '[Windows](#p74)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows](#p74)'
- en: '[Ubuntu Linux](#p75)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ubuntu Linux](#p75)'
- en: '[Installing other packages directly from pip](#p76)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[直接从pip安装其他包](#p76)'
- en: '[Windows](#p78)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows](#p78)'
- en: '[Ubuntu Linux](#p79)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ubuntu Linux](#p79)'
- en: '[Installing an IDE](#p80)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[安装IDE](#p80)'
- en: '[Windows](#p82)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[Windows](#p82)'
- en: '[Linux](#p83)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[Linux](#p83)'
- en: '[Creating the book project](#p84)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建书籍项目](#p84)'
- en: '[Programming and running your first example](#p88)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[编程和运行第一个示例](#p88)'
- en: '[Transforming the coordinate system and calculating the area of all countries](#p92)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[转换坐标系并计算所有国家的面积](#p92)'
- en: '[Sort the countries by area size](#p98)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[按面积大小排序国家](#p98)'
- en: '[Summary](#p101)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[摘要](#p101)'
- en: '[2\. The Geocaching App](#p103)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[2. 地理藏宝应用](#p103)'
- en: '[Building the basic application structure](#p105)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[构建基本应用程序结构](#p105)'
- en: '[Creating the application tree structure](#p106)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建应用程序树结构](#p106)'
- en: '[Functions and methods](#p107)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[函数和方法](#p107)'
- en: '[Documenting your code](#p108)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[记录你的代码](#p108)'
- en: '[Creating the application entry point](#p109)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建应用程序入口点](#p109)'
- en: '[Downloading geocaching data](#p112)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[下载地理藏宝数据](#p112)'
- en: '[Geocaching data sources](#p114)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[地理藏宝数据源](#p114)'
- en: '[Fetching information from a REST API](#p115)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[从REST API获取信息](#p115)'
- en: '[Downloading data from a URL](#p117)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[从URL下载数据](#p117)'
- en: '[Downloading data manually](#p119)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[手动下载数据](#p119)'
- en: '[Opening the file and getting its contents](#p122)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[打开文件并获取其内容](#p122)'
- en: '[Preparing the content for analysis](#p125)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[为分析准备内容](#p125)'
- en: '[Combining functions into an application](#p126)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[将函数组合到应用程序中](#p126)'
- en: '[Setting your current location](#p130)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置您的当前位置](#p130)'
- en: '[Finding the closest point](#p134)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[找到最近点](#p134)'
- en: '[Summary](#p140)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[摘要](#p140)'
- en: '[3\. Combining Multiple Data Sources](#p142)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[3. 结合多个数据源](#p142)'
- en: '[Representing geographic data](#p144)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[表示地理数据](#p144)'
- en: '[Representing geometries](#p146)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[表示几何形状](#p146)'
- en: '[Making data homogeneous](#p148)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[使数据同质化](#p148)'
- en: '[The concept of abstraction](#p150)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[抽象的概念](#p150)'
- en: '[Abstracting the geocache point](#p151)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[抽象化地理藏宝点](#p151)'
- en: '[Abstracting geocaching data](#p153)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[抽象化地理藏宝数据](#p153)'
- en: '[Importing geocaching data](#p154)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[导入地理藏宝数据](#p154)'
- en: '[Reading GPX attributes](#p158)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[读取GPX属性](#p158)'
- en: '[Returning the homogeneous data](index_split_001.html#p163)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[返回同质化数据](index_split_001.html#p163)'
- en: '[Converting the data into Geocache objects](index_split_001.html#p165)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[将数据转换为Geocache对象](index_split_001.html#p165)'
- en: '[Merging multiple sources of data](index_split_001.html#p167)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[合并多个数据源](index_split_001.html#p167)'
- en: '[Integrating new functionality into the application](index_split_001.html#p169)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[将新功能集成到应用程序中](index_split_001.html#p169)'
- en: '[Summary](index_split_001.html#p172)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[摘要](index_split_001.html#p172)'
- en: '[4\. Improving the App Search Capabilities](index_split_001.html#p174)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[4. 提高应用搜索能力](index_split_001.html#p174)'
- en: '[Working with polygons](index_split_001.html#p176)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理多边形](index_split_001.html#p176)'
- en: '[Knowing well-known text](index_split_001.html#p177)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[了解已知文本](index_split_001.html#p177)'
- en: '[Using Shapely to handle geometries](index_split_001.html#p180)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用Shapely处理几何形状](index_split_001.html#p180)'
- en: '[Importing polygons](index_split_001.html#p183)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[导入多边形](index_split_001.html#p183)'
- en: '[Getting the attributes’ values](index_split_001.html#p191)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[获取属性值](index_split_001.html#p191)'
- en: '[Importing lines](index_split_001.html#p194)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[导入线条](index_split_001.html#p194)'
- en: '[Converting the spatial reference system and units](index_split_001.html#p198)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[转换空间参考系统和单位](index_split_001.html#p198)'
- en: '[Geometry relationships](index_split_001.html#p203)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[几何关系](index_split_001.html#p203)'
- en: '[Touches](index_split_001.html#p205)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[触摸](index_split_001.html#p205)'
- en: '[Crosses](index_split_001.html#p206)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[交叉](index_split_001.html#p206)'
- en: '[Contains](index_split_001.html#p207)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[包含](index_split_001.html#p207)'
- en: '[Within](index_split_001.html#p208)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[在...内](index_split_001.html#p208)'
- en: '[Equals or almost equals](index_split_001.html#p209)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[等于或几乎等于](index_split_001.html#p209)'
- en: '[Intersects](index_split_001.html#p210)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[相交](index_split_001.html#p210)'
- en: '[Disjoint](index_split_001.html#p211)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[不相交](index_split_001.html#p211)'
- en: '[Filtering by attributes and relations](index_split_001.html#p212)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[按属性和关系过滤](index_split_001.html#p212)'
- en: '[Filtering by multiple attributes](index_split_001.html#p217)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[按多个属性过滤](index_split_001.html#p217)'
- en: '[Chaining filters](index_split_001.html#p219)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[链式过滤](index_split_001.html#p219)'
- en: '[Integrating with the app](index_split_001.html#p221)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[与应用集成](index_split_001.html#p221)'
- en: '[Summary](index_split_001.html#p225)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_001.html#p225)'
- en: '[5\. Making Maps](index_split_001.html#p227)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[5. 制作地图](index_split_001.html#p227)'
- en: '[Knowing Mapnik](index_split_001.html#p229)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[了解Mapnik](index_split_001.html#p229)'
- en: '[Making a map with pure Python](index_split_001.html#p230)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用纯Python制作地图](index_split_001.html#p230)'
- en: '[Making a map with a style sheet](index_split_001.html#p232)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用样式表制作地图](index_split_001.html#p232)'
- en: '[Creating utility functions to generate maps](index_split_001.html#p234)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建生成地图的实用函数](index_split_001.html#p234)'
- en: '[Changing the data source at runtime](index_split_001.html#p236)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[在运行时更改数据源](index_split_001.html#p236)'
- en: '[Automatically previewing the map](index_split_001.html#p239)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动预览地图](index_split_001.html#p239)'
- en: '[Styling maps](index_split_001.html#p241)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置地图样式](index_split_001.html#p241)'
- en: '[Map style](index_split_001.html#p243)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[地图样式](index_split_001.html#p243)'
- en: '[Polygon style](index_split_001.html#p244)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[多边形样式](index_split_001.html#p244)'
- en: '[Line styles](index_split_001.html#p246)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[线条样式](index_split_001.html#p246)'
- en: '[Text styles](index_split_001.html#p248)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[文本样式](index_split_001.html#p248)'
- en: '[Adding layers to the map](index_split_001.html#p249)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[向地图添加图层](index_split_001.html#p249)'
- en: '[Point styles](index_split_001.html#p252)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[点样式](index_split_001.html#p252)'
- en: '[Using Python objects as a source of data](index_split_001.html#p254)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用Python对象作为数据源](index_split_001.html#p254)'
- en: '[Exporting geo objects](index_split_001.html#p259)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[导出地理对象](index_split_001.html#p259)'
- en: '[Creating the Map Maker app](index_split_001.html#p263)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建Map Maker应用](index_split_001.html#p263)'
- en: '[Using PythonDatasource](index_split_002.html#p267)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用Python数据源](index_split_002.html#p267)'
- en: '[Using the app with filtering](index_split_002.html#p273)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用带有过滤器的应用](index_split_002.html#p273)'
- en: '[Summary](index_split_002.html#p275)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_002.html#p275)'
- en: '[6\. Working with Remote Sensing Images](index_split_002.html#p277)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[6. 处理遥感图像](index_split_002.html#p277)'
- en: '[Understanding how images are represented](index_split_002.html#p279)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[理解图像的表示方式](index_split_002.html#p279)'
- en: '[Opening images with OpenCV](index_split_002.html#p282)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用OpenCV打开图像](index_split_002.html#p282)'
- en: '[Knowing numerical types](index_split_002.html#p284)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[了解数值类型](index_split_002.html#p284)'
- en: '[Processing remote sensing images and data](index_split_002.html#p286)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理遥感图像和数据](index_split_002.html#p286)'
- en: '[Mosaicking images](index_split_002.html#p289)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[图像镶嵌](index_split_002.html#p289)'
- en: '[Adjusting the values of the images](index_split_002.html#p294)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[调整图像的值](index_split_002.html#p294)'
- en: '[Cropping an image](index_split_002.html#p296)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[裁剪图像](index_split_002.html#p296)'
- en: '[Creating a shaded relief image](index_split_002.html#p298)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建阴影地形图](index_split_002.html#p298)'
- en: '[Building an image processing pipeline](index_split_002.html#p300)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[构建图像处理流水线](index_split_002.html#p300)'
- en: '[Creating a RasterData class](index_split_002.html#p303)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建RasterData类](index_split_002.html#p303)'
- en: '[Summary](index_split_002.html#p310)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_002.html#p310)'
- en: '[7\. Extract Information from Raster Data](index_split_002.html#p312)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[7. 从栅格数据中提取信息](index_split_002.html#p312)'
- en: '[Getting the basic statistics](index_split_002.html#p314)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[获取基本统计信息](index_split_002.html#p314)'
- en: '[Preparing the data](index_split_002.html#p316)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[准备数据](index_split_002.html#p316)'
- en: '[Printing simple information](index_split_002.html#p317)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[打印简单信息](index_split_002.html#p317)'
- en: '[Formatting the output information](index_split_002.html#p319)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[格式化输出信息](index_split_002.html#p319)'
- en: '[Calculating quartiles, histograms, and other statistics](index_split_002.html#p321)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[计算四分位数、直方图和其他统计数据](index_split_002.html#p321)'
- en: '[Making statistics a lazy property](index_split_002.html#p323)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[将统计数据做成懒属性](index_split_002.html#p323)'
- en: '[Creating color classified images](index_split_002.html#p325)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建彩色分类图像](index_split_003.html#p325)'
- en: '[Choosing the right colors for a map](index_split_002.html#p329)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[为地图选择合适的颜色](index_split_002.html#p329)'
- en: '[Blending images](index_split_002.html#p336)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[混合图像](index_split_002.html#p336)'
- en: '[Showing statistics with colors](index_split_002.html#p339)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[用颜色显示统计数据](index_split_002.html#p339)'
- en: '[Using the histogram to colorize the image](index_split_002.html#p342)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用直方图对图像进行着色](index_split_002.html#p342)'
- en: '[Summary](index_split_002.html#p345)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_003.html#p345)'
- en: '[8\. Data Miner App](index_split_002.html#p347)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[8. 数据挖掘应用](index_split_002.html#p347)'
- en: '[Measuring execution time](index_split_002.html#p350)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[测量执行时间](index_split_002.html#p350)'
- en: '[Code profiling](index_split_002.html#p354)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码分析](index_split_002.html#p354)'
- en: '[Storing information on a database](index_split_002.html#p356)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[在数据库中存储信息](index_split_003.html#p356)'
- en: '[Creating an Object Relational Mapping](index_split_002.html#p358)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建对象关系映射](index_split_002.html#p358)'
- en: '[Preparing the environment](index_split_002.html#p359)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[准备环境](index_split_002.html#p359)'
- en: '[Changing our models](index_split_002.html#p360)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[改变我们的模型](index_split_002.html#p360)'
- en: '[Customizing a manager](index_split_002.html#p360)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义管理器](index_split_002.html#p360)'
- en: '[Generating the tables and importing data](index_split_002.html#p365)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[生成表格并导入数据](index_split_002.html#p365)'
- en: '[Filtering the data](index_split_002.html#p367)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[过滤数据](index_split_002.html#p367)'
- en: '[Importing massive amount of data](index_split_003.html#p368)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[导入大量数据](index_split_003.html#p368)'
- en: '[Optimizing database inserts](index_split_003.html#p370)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[优化数据库插入](index_split_003.html#p370)'
- en: '[Optimizing data parsing](index_split_003.html#p373)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[优化数据解析](index_split_003.html#p373)'
- en: '[Importing OpenStreetMap points of interest](index_split_003.html#p376)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[导入OpenStreetMap的兴趣点](index_split_003.html#p376)'
- en: '[Removing the test data](index_split_003.html#p380)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[移除测试数据](index_split_003.html#p380)'
- en: '[Populating the database with real data](index_split_003.html#p381)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[用真实数据填充数据库](index_split_003.html#p381)'
- en: '[Searching for data and crossing information](index_split_003.html#p385)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[搜索数据和交叉信息](index_split_003.html#p385)'
- en: '[Filtering using boundaries](index_split_003.html#p388)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用边界过滤](index_split_003.html#p388)'
- en: '[Summary](index_split_003.html#p390)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_003.html#p390)'
- en: '[9\. Processing Big Images](index_split_003.html#p392)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[9. 处理大图像](index_split_003.html#p392)'
- en: '[Working with satellite images](index_split_003.html#p394)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理卫星图像](index_split_003.html#p394)'
- en: '[Getting Landsat 8 images](index_split_003.html#p396)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[获取Landsat 8图像](index_split_003.html#p396)'
- en: '[Memory and images](index_split_003.html#p399)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[内存和图像](index_split_003.html#p399)'
- en: '[Processing images in chunks](index_split_003.html#p403)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[分块处理图像](index_split_003.html#p403)'
- en: '[Using GDAL to open images](index_split_003.html#p405)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用GDAL打开图像](index_split_003.html#p405)'
- en: '[Iterating through the whole image](index_split_003.html#p408)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[遍历整个图像](index_split_003.html#p408)'
- en: '[Creating image compositions](index_split_003.html#p412)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建图像合成](index_split_003.html#p412)'
- en: '[True color compositions](index_split_003.html#p414)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[真彩色合成](index_split_003.html#p414)'
- en: '[Processing specific regions](index_split_003.html#p417)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理特定区域](index_split_003.html#p417)'
- en: '[False color compositions](index_split_003.html#p419)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[假彩色合成](index_split_003.html#p419)'
- en: '[Summary](index_split_003.html#p422)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_003.html#p422)'
- en: '[10\. Parallel Processing](index_split_003.html#p424)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[10. 并行处理](index_split_003.html#p424)'
- en: '[Multiprocessing basics](index_split_003.html#p426)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[多进程基础](index_split_003.html#p426)'
- en: '[Block iteration](index_split_003.html#p430)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[块迭代](index_split_003.html#p430)'
- en: '[Improving the image resolution](index_split_003.html#p436)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[提高图像分辨率](index_split_003.html#p436)'
- en: '[Image resampling](index_split_003.html#p438)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[图像重采样](index_split_003.html#p438)'
- en: '[Pan sharpening](index_split_003.html#p446)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[全色增强](index_split_003.html#p446)'
- en: '[Summary](index_split_003.html#p450)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_003.html#p450)'
- en: '[Index](index_split_003.html#p452)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[索引](index_split_003.html#p452)'
- en: '**Geospatial Development By Example with**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过示例进行地理空间开发**'
- en: '**Python**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: '**Geospatial Development By Example with**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过示例进行地理空间开发**'
- en: '**Python**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**'
- en: Copyright © 2016 Packt Publishing
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 © 2016 Packt Publishing
- en: All rights reserved. No part of this book may be reproduced, stored in a retrieval
    system, or transmitted in any form or by any means, without the prior written
    permission of the publisher, except in the case of brief quotations embedded in
    critical articles or reviews.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有。未经出版者事先书面许可，本书的任何部分不得以任何形式或任何方式复制、存储在检索系统中或通过任何手段传输，除非在评论或评论中嵌入的简短引用。
- en: Every effort has been made in the preparation of this book to ensure the accuracy
    of the information presented. However, the information contained in this book
    is sold without warranty, either express or implied. Neither the author, nor Packt
    Publishing, and its dealers and distributors will be held liable for any damages
    caused or alleged to be caused directly or indirectly by this book.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备本书的过程中，我们已尽最大努力确保所提供信息的准确性。然而，本书中的信息销售不附带任何明示或暗示的保证。作者、Packt Publishing及其经销商和分销商不对由此书直接或间接造成的任何损害承担责任。
- en: Packt Publishing has endeavored to provide trademark information about all of
    the companies and products mentioned in this book by the appropriate use of capitals.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Packt Publishing已尽力通过适当使用大写字母提供本书中提到的所有公司和产品的商标信息。
- en: However, Packt Publishing cannot guarantee the accuracy of this information.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Packt Publishing不能保证此信息的准确性。
- en: 'First published: January 2016'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首次出版：2016年1月
- en: 'Production reference: 1250116'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 生产参考：1250116
- en: Published by Packt Publishing Ltd.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由Packt Publishing Ltd. 出版
- en: Livery Place
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Livery Place
- en: 35 Livery Street
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 35 Livery Street
- en: Birmingham B3 2PB, UK.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 英国伯明翰 B3 2PB。
- en: ISBN 978-1-78528-235-5
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-1-78528-235-5
- en: '[www.packtpub.com](http://www.packtpub.com)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.packtpub.com](http://www.packtpub.com)'
- en: '**Credits**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**鸣谢**'
- en: '**Author**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**作者**'
- en: Pablo Carreira
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Pablo Carreira
- en: '**Reviewers**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**审稿人**'
- en: Brylie Christopher Oxley
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Brylie Christopher Oxley
- en: Vivek Kumar Singh
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Vivek Kumar Singh
- en: Claudio Sparpaglione
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Claudio Sparpaglione
- en: '**Commissioning Editor**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**委托编辑**'
- en: Sarah Crofton
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Sarah Crofton
- en: '**Acquisition Editor**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**采购编辑**'
- en: Meeta Rajani
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Meeta Rajani
- en: '**Content Development Editor**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容开发编辑**'
- en: Rashmi Suvarna
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Rashmi Suvarna
- en: '**Technical Editor**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术编辑**'
- en: Shivani Kiran Mistry
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Shivani Kiran Mistry
- en: '**Copy Editor**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**校对编辑**'
- en: Akshata Lobo
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Akshata Lobo
- en: '**Project Coordinator**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目协调员**'
- en: Judie Jose
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Judie Jose
- en: '**Proofreader**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**校对**'
- en: Safis Editing
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Safis 编辑
- en: '**Indexer**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引编制者**'
- en: Hemangini Bari
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Hemangini Bari
- en: '**Graphics**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形设计**'
- en: Disha Haria
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Disha Haria
- en: '**Production Coordinator**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产协调员**'
- en: Nilesh Mohite
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Nilesh Mohite
- en: '**Cover Work**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**封面设计**'
- en: Nilesh Mohite
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Nilesh Mohite
- en: '**About the Author**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于作者**'
- en: '**Pablo Carreira** is a Python programmer and a full stack developer living
    in São Paulo state, Brazil. He is now the lead developer of an advanced web platform
    for precision agriculture and actively uses Python as a backend solution for efficient
    geoprocessing.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pablo Carreira** 是一位居住在巴西圣保罗州的Python程序员和全栈开发者。他现在是精准农业先进网络平台的负责人，并积极将Python作为后端解决方案用于高效的地理处理。'
- en: Born in 1980, Brazil, Pablo graduated as an agronomical engineer. Being a programming
    enthusiast and self-taught since childhood, he learned programming as a hobby
    and later honored his techniques in order to solve work tasks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 1980年出生于巴西，Pablo以农业工程师的身份毕业。作为一个自幼对编程充满热情且自学成才的人，他将编程作为爱好，后来为了解决工作任务而提升了自己的技术。
- en: Having 8 years of professional experience in geoprocessing, he uses Python along
    with geographic information systems in order to automate processes and solve problems
    related to precision agriculture, environmental analysis, and land division.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在地理处理领域拥有8年的专业经验，他使用Python以及地理信息系统来自动化流程并解决与精准农业、环境分析和土地划分相关的问题。
- en: I would like to thank my mother and father for the support given through all
    my life. I also would like to thank my wife for her help and patience in face
    of my absence during all the writing sessions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我想感谢我的父母，感谢他们在我一生中给予的支持。我还想感谢我的妻子，感谢她在所有写作过程中对我的帮助和耐心。
- en: I thank my university teacher José Paulo Molin, who first introduced me to geoprocessing
    and precision agriculture and created in me a deep interest in the area and gave
    the means for my development. Finally, I thank my good friend Gerardo F. E. Perez
    for all the opportunities that he presented me with and for the uncountable hours
    of good technical discussions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我感谢我的大学老师José Paulo Molin，是他首先向我介绍了地理处理和精准农业，并在这一领域激发了我浓厚的兴趣，并为我提供了发展的机会。最后，我要感谢我的好朋友Gerardo
    F. E. Perez，感谢他为我提供的所有机会，以及在无数个技术讨论中的陪伴。
- en: '**About the Reviewers**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于审稿人**'
- en: '**Brylie Christopher Oxley** enjoys working on technology projects that improve
    the human and environmental commons. He is dedicated to working for open source,
    open web, and open knowledge movements.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**布赖利·克里斯托弗·奥克利**喜欢从事改善人类和环境共同体的技术项目。他致力于为开源、开放Web和开放知识运动工作。'
- en: He regularly contributes to open source projects primarily built with web platform
    technologies, including a wellbeing visualization application for aging populations
    and a community portal for refugee support.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 他定期为使用Web平台技术构建的开源项目做出贡献，包括为老龄化人口的健康状况可视化应用程序和为难民支持的社区门户。
- en: Thank you Elvin, Lauri, Antti, Marjo, and Lynne for being the shining stars
    of my life.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Elvin、Lauri、Antti、Marjo和Lynne，你们是我生命中的璀璨明星。
- en: '**Vivek Kumar Singh** is a research scholar at the center of atmospheric science,
    Indian Institute of Technology, Delhi (IIT Delhi). He has completed his master’s
    in technology in Remote Sensing and GIS from the Indian Institute of Remote Sensing,
    ISRO, in Dehradun, Uttarakhand, India. He focused on the different applications
    of Remote Sensing and GIS using geocomputational modeling with satellite observations
    during his time in graduate school. His main research expertise is in the application
    of satellite remote sensing for air quality monitoring and assessment, urban heat
    island and remote sensing, and geographical systems around the world. He is also
    interested in researching the air quality in growing megacities, spatial and temporal
    trends in aerosols over urban regions, the radiative effects of aerosols, the
    development of statistical models to estimate surface level particulate matter
    air quality, aerosols and clouds data validation, and the retrieval of cloud products
    from UV satellite measurements. He is also an associate with the BhuNak science
    team on the development and validation of new GIS products for climate studies.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**维韦克·库马尔·辛格**是印度理工学院德里分校大气科学中心的科研学者。他在印度遥感研究所，印度空间研究组织（ISRO）位于乌塔拉坎德德里的分校完成了遥感与地理信息系统技术的硕士学位。在研究生期间，他专注于使用卫星观测的地理计算模型来研究遥感与GIS的不同应用。他的主要研究专长在于应用卫星遥感进行空气质量监测和评估、城市热岛和遥感，以及全球的地理信息系统。他还对研究成长中的大城市的空气质量、城市地区气溶胶的空间和时间趋势、气溶胶的辐射效应、开发统计模型来估计地表颗粒物空气质量、气溶胶和云数据验证，以及从紫外卫星测量中检索云产品感兴趣。他也是BhuNak科学团队的一员，参与开发和验证用于气候研究的新GIS产品。'
- en: He also currently participated in developing and conducting remote sensing technical
    workshops and capacity building activities for the BhuNak Program, where he teaches
    the application of satellite imagery to environmental decision-making activities
    with a focus on urban living quality.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 他目前还参与了BhuNak项目的技术研讨会和能力建设活动的开发和实施，在那里他教授使用卫星图像进行环境决策活动的应用，重点关注城市生活质量。
- en: I would like to thank Vaibhav Kumar, PhD Scholar at the Center of Urban Science
    and Engineering, Indian Institute of Technology, Bombay (IIT-Bombay), for his
    contribution (cofounder of BhuNak Research Group). A special thank you to ML Singh
    (father), Prashant Kumar Singh (brother), and Kimeera Tummala (friend) for their
    contribution in my life.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我要感谢瓦伊布哈夫·库马尔，印度理工学院孟买分校（IIT-Bombay）城市科学与工程学院的博士研究生，他为我的贡献（BhuNak研究小组的共同创始人）。特别感谢ML辛格（父亲）、普拉尚特·库马尔·辛格（兄弟）和基梅拉·图马拉（朋友）在我生活中的贡献。
- en: '**Claudio Sparpaglione** is a CTO at WalletSaver, an Italian startup rocking
    in the mobile phone tariff comparison landscape. His work experience includes
    the design and building of geospatial applications and web-oriented systems in
    the online advertisement industry.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**克劳迪奥·斯帕帕格利奥内**是意大利初创公司WalletSaver的首席技术官，该公司在移动电话资费比较领域独树一帜。他的工作经验包括在线广告行业中地理空间应用和面向Web的系统设计和构建。'
- en: A passionate Pythonista and open-source advocate, he’s a maintainer of the PyOWM
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一位充满激情的Python程序员和开源倡导者，他是PyOWM的维护者。
- en: project and actively involved in the community with contributions to projects
    such as Python-Requests and Reactive Manifesto. His main interests include high-scalable
    web architectures, APIs design, and cloud computing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 项目，并积极参与社区，为Python-Requests和Reactive Manifesto等项目做出贡献。他的主要兴趣包括高可扩展的Web架构、API设计以及云计算。
- en: '**www.PacktPub.com**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**www.PacktPub.com**'
- en: '![Image 2](img/index-23_1.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![Image 2](img/index-23_1.jpg)'
- en: '**Support files, eBooks, discount offers, and**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持文件、电子书、折扣优惠以及**'
- en: '**more**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多**'
- en: For support files and downloads related to your book, please visit [www.PacktPub.com.](http://www.PacktPub.com)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有关您书籍的支持文件和下载，请访问 [www.PacktPub.com](http://www.PacktPub.com)。
- en: Did you know that Packt offers eBook versions of every book published, with
    PDF and ePub files available? You can upgrade to the eBook version at [www.PacktPub.com](http://www.PacktPub.com)
    and as a print book customer, you are entitled to a discount on the eBook copy.
    Get in touch with us at < [service@packtpub.com](mailto:service@packtpub.com)>
    for more details.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道Packt为每本书都提供电子书版本，包括PDF和ePub文件吗？您可以在 [www.PacktPub.com](http://www.PacktPub.com)
    升级到电子书版本，并且作为印刷版书籍的顾客，您有权获得电子书副本的折扣。有关更多详情，请联系我们 <[service@packtpub.com](mailto:service@packtpub.com)>。
- en: At [www.PacktPub.com,](http://www.PacktPub.com) you can also read a collection
    of free technical articles, sign up for a range of free newsletters and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [www.PacktPub.com](http://www.PacktPub.com)，您还可以阅读一系列免费的技术文章，注册各种免费通讯，并享受Packt书籍和电子书的独家折扣和优惠。
- en: '[https://www2.packtpub.com/books/subscription/packtlib](https://www2.packtpub.com/books/subscription/packtlib)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www2.packtpub.com/books/subscription/packtlib](https://www2.packtpub.com/books/subscription/packtlib)'
- en: Do you need instant solutions to your IT questions? PacktLib is Packt’s online
    digital book library. Here, you can search, access, and read Packt’s entire library
    of books.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要即时解决您的IT问题吗？PacktLib是Packt的在线数字图书库。在这里，您可以搜索、访问和阅读Packt的整个图书库。
- en: '**Why subscribe?**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么要订阅？**'
- en: Fully searchable across every book published by Packt
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Packt出版的每本书中都可以全文搜索。
- en: Copy and paste, print, and bookmark content
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 复制粘贴、打印和收藏内容。
- en: On demand and accessible via a web browser
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 按需访问，可通过网页浏览器访问。
- en: '**Free access for Packt account holders**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**Packt账户持有者的免费访问**'
- en: If you have an account with Packt at [www.PacktPub.com,](http://www.PacktPub.com)
    you can use this to access PacktLib today and view 9 entirely free books. Simply
    use your login credentials for immediate access.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 [www.PacktPub.com](http://www.PacktPub.com) 有Packt账户，您可以使用它今天访问PacktLib并查看9本完全免费的书籍。只需使用您的登录凭证即可立即访问。
- en: '**Preface**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**前言**'
- en: From Python programming good practices to the advanced use of analysis packages,
    this book teaches how to write applications that will perform complex geoprocessing
    tasks that can be replicated and reused. The book contains three sample applications.
    [Chapter 1](#p45)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python编程的良好实践到分析包的高级使用，本书教授如何编写能够执行复杂地理处理任务的应用程序，这些任务可以复制和重用。本书包含三个示例应用程序。[第1章](#p45)
- en: shows how to prepare a development environment. From [Chapter 2](#p103) to [Chapter
    4,](index_split_001.html#p174) the reader goes deep into Python functionality
    using classes, inheritance, and other resources in order to read, manipulate,
    combine, and search information in vector data. [Chapter 5](index_split_001.html#p227)
    to
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了如何准备开发环境。从 [第2章](#p103) 到 [第4章](index_split_001.html#p174)，读者深入使用类、继承和其他资源来阅读、操作、组合和搜索矢量数据中的信息。[第5章](index_split_001.html#p227)
    到
- en: '[Chapter 7](index_split_002.html#p312) presents techniques to render beautiful
    maps, and handle and analyze raster data. In the final three chapters, the book
    approaches code optimization and presents solutions to handle large datasets common
    in geoprocessing tasks. All the examples are modular and can be rearranged to
    achieve countless different results. During the book, the code is deduced step
    by step until it reaches the final form. The reader is led to edit, change, and
    improve the code, experimenting with different solutions and organizations, subtly
    learning the mental process of the development of a geoprocessing application.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](index_split_002.html#p312) 介绍了渲染美丽地图和处理分析栅格数据的技术。在最后三章中，本书探讨了代码优化，并提出了处理地理处理任务中常见的大数据集的解决方案。所有示例都是模块化的，可以重新排列以实现无数不同的结果。在本书中，代码逐步推导，直至达到最终形式。读者被引导编辑、更改和改进代码，尝试不同的解决方案和组织方式，微妙地学习地理处理应用程序开发的心理过程。'
- en: '**What this book covers**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**本书涵盖的内容**'
- en: '[Chapter 1,](#p45) *Preparing the Work Environment*, shows the processes of
    installing all the libraries that you will need to go through the examples in
    the book, as well how to set up an integrated development environment (IDE) that
    will help organize the code and avoid mistakes. Finally, it will present the first
    contact with one of the geospatial libraries.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](#p45)，*准备工作环境*，展示了安装所有必需库的过程，以便通过书中的示例，以及如何设置一个集成开发环境（IDE），这将有助于组织代码并避免错误。最后，它将介绍与地理空间库的第一次接触。'
- en: '[Chapter 2,](#p103) *The Geocaching App*, will go through the important steps
    in geoprocessing applications, such as opening files, reading data, and preparing
    it for analysis with the tools at hand. Going through these steps, the user will
    learn how to organize and use the resources provided by the language to write
    consistent applications.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](#p103)，*地理藏宝应用*，将介绍地理处理应用中的重要步骤，例如打开文件、读取数据以及使用手头工具准备分析。通过这些步骤，用户将学习如何组织和利用语言提供的资源来编写一致的应用程序。'
- en: '[Chapter 3,](#p142) *Combining Multiple Data Sources*, will cover the process
    of combining sources, and how to use Python classes to create your own representation
    of geospatial data. Geographic data tends to be heterogeneous, so writing programs
    that are able to combine multiple sources of data is a fundamental topic in geoprocessing.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](#p142)，*结合多个数据源*，将涵盖结合数据源的过程以及如何使用Python类来创建自己的地理空间数据表示。地理数据往往具有异质性，因此编写能够结合多个数据源的程序是地理处理中的基本主题。'
- en: '[Chapter 4,](index_split_001.html#p174) *Improving the App Search Capabilities*,
    will add new functionalities to the application. Users will write a code capable
    of filtering features by geographic boundaries and by any field in the data. In
    the process, they will see how to work with polygons and how the relations between
    geometries can be analyzed in a geoprocessing application.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](index_split_001.html#p174)，*提高应用搜索能力*，将为应用程序添加新功能。用户将编写一个能够通过地理边界和任何数据字段过滤特征的代码。在这个过程中，他们将了解如何处理多边形以及如何在地理处理应用程序中分析几何形状之间的关系。'
- en: '[Chapter 5,](index_split_001.html#p227) *Making Maps*, starts a new application
    that will be able to produce nice maps from the vectors of the data. Mapnik, one
    of the most used mapping packages, will be used. The user will understand how
    it works and how to adapt it to consume the data presented in the previous chapters.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](index_split_001.html#p227)，*制作地图*，将启动一个新应用，该应用能够从数据向量生成漂亮的地图。Mapnik，最常用的地图包之一，将被使用。用户将了解其工作原理以及如何将其适应以消费前几章中展示的数据。'
- en: '[Chapter 6,](index_split_002.html#p277) *Working with Remote Sensing Images*,
    will present a process of deduction that will result in a versatile and powerful
    software structure able to combine, crop, and adjust the values of images to prepare
    them for presentation.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](index_split_002.html#p277)，*处理遥感图像*，将展示一个演绎过程，这将导致一个灵活且强大的软件结构，能够结合、裁剪和调整图像的值，以准备它们进行展示。'
- en: '[Chapter 7,](index_split_002.html#p312) *Extract Information from Raster Data*,
    will approach the process of extracting information from raster data, which can
    be analyzed in order to produce valuable information. Going beyond simple numerical
    values, it will show how to display this information on beautiful color maps.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](index_split_002.html#p312)，*从栅格数据中提取信息*，将探讨从栅格数据中提取信息的过程，这些信息可以进行分析以产生有价值的信息。它将超越简单的数值，展示如何将此信息显示在漂亮的彩色地图上。'
- en: '[Chapter 8,](index_split_002.html#p347) *Data Miner App*, will show how to
    use databases and how to import data into it in order to minimize processing time
    and allow huge datasets to be processed. Geospatial data tends to be extensive
    and its processing demands a lot of computer power. To make the code more efficient,
    the reader will learn techniques of code profiling and optimization.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](index_split_002.html#p347)，*数据挖掘应用*，将展示如何使用数据库以及如何将其导入以最小化处理时间，并允许处理大量数据集。地理空间数据往往很庞大，其处理需要大量的计算机功率。为了使代码更高效，读者将学习代码分析优化技术。'
- en: '[Chapter 9,](index_split_003.html#p392) *Processing Big Images*, will show
    how to process big satellite images. It will focus on how to perform sustainable
    image processing and how to open and make calculations with many big images while
    keeping the memory consumption low with efficient code.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](index_split_003.html#p392)，*处理大图像*，将展示如何处理大型卫星图像。它将重点介绍如何进行可持续的图像处理，以及如何在保持内存消耗低的同时，使用高效代码打开和计算许多大图像。'
- en: '[Chapter 10](index_split_003.html#p424), *Parallel Processing*, will teach
    the reader how to use the full available computer power. In order to speed up
    tasks, it will show how to distribute them among'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](index_split_003.html#p424)，*并行处理*，将教会读者如何充分利用计算机的全部可用性能。为了加快任务，它将展示如何将任务分配到'
- en: processor cores for parallel processing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 用于并行处理的处理器核心。
- en: '**What you need for this book**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**本书所需内容**'
- en: To run the examples of this book, you will only need a computer with at least
    4 GB of RAM with the Ubuntu Linux or Microsoft Windows operating system. All the
    programs and libraries that we will use are either free of charge or open source.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本书的示例，您只需要一台至少有4 GB RAM的计算机，并安装了Ubuntu Linux或Microsoft Windows操作系统。我们将使用的所有程序和库要么是免费的，要么是开源的。
- en: '**Who this book is for**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**本书面向对象**'
- en: This book is intended for beginners or advanced developers in Python, who want
    to work with geographic data. The book is suitable for professional developers
    who are new to geospatial development, for hobbyists, or for data scientists who
    want to move into simple development.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在为想要处理地理数据的Python初学者或高级开发者提供帮助。本书适合新接触地理空间开发的职业开发者、爱好者，或希望进入简单开发的科学家。
- en: '**Conventions**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**约定**'
- en: In this book, you will find a number of text styles that distinguish between
    different kinds of information. Here are some examples of these styles and an
    explanation of their meaning.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将找到多种文本样式，用于区分不同类型的信息。以下是一些这些样式的示例及其含义的解释。
- en: 'Code words in text, database table names, folder names, filenames, file extensions,
    pathnames, dummy URLs, user input, and Twitter handles are shown as follows: “A
    Python package is a directory containing one or more Python files (that is, modules)
    plus one __init__.py file.”'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟URL、用户输入和Twitter昵称的显示方式如下：“一个Python包是一个包含一个或多个Python文件（即模块）和一个__init__.py文件的目录。”
- en: 'A block of code is set as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块设置为如下：
- en: import ogr
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: import ogr
- en: Open the shapefile and get the first layer.
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开shapefile并获取第一层。
- en: datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
- en: 'print("Number of features: {}".format(layer.GetFeatureCount())) When we wish
    to draw your attention to a particular part of a code block, the relevant lines
    or items are set in bold:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("特征数量: {}".format(layer.GetFeatureCount())) 当我们希望引起您对代码块中特定部分的注意时，相关的行或项目将被设置为粗体：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: '**vector_data = PointCollection("../data/geocaching.gpx")** vector_data.print_information()'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector_data = PointCollection("../data/geocaching.gpx")** vector_data.print_information()'
- en: 'Any command-line input or output is written as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 任何命令行输入或输出都写成如下形式：
- en: '**Collecting django**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**收集 django**'
- en: '**Downloading Django-1.9-py2.py3-none-any.whl (6.6MB)**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载 Django-1.9-py2.py3-none-any.whl (6.6MB)**'
- en: '**100% |################################| 6.6MB 43kB/s** **Installing collected
    packages: django**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**100% |################################| 6.6MB 43kB/s** **安装收集的包：django**'
- en: '**Successfully installed django-1.9**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**成功安装 django-1.9**'
- en: '**New terms** and **important words** are shown in bold. Words that you see
    on the screen, for example, in menus or dialog boxes, appear in the text like
    this: “Proceed with the default options by clicking on the **Next** button.”'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**新术语**和**重要词汇**将以粗体显示。屏幕上看到的单词，例如在菜单或对话框中，在文本中显示如下：“通过点击**下一步**按钮继续使用默认选项。”'
- en: '**Note**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Warnings or important notes appear in a box like this.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 警告或重要注意事项将以如下框的形式出现。
- en: '**Tip**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Tips and tricks appear like this.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 小技巧和窍门看起来像这样。
- en: '**Reader feedback**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**读者反馈**'
- en: Feedback from our readers is always welcome. Let us know what you think about
    this book—what you liked or disliked. Reader feedback is important for us as it
    helps us develop titles that you will really get the most out of.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们欢迎读者的反馈。请告诉我们您对本书的看法——您喜欢或不喜欢的地方。读者反馈对我们非常重要，因为它帮助我们开发出您真正能从中受益的标题。
- en: To send us general feedback, simply e-mail [<feedback@packtpub.com>](mailto:feedback@packtpub.com)
    , and mention the book’s title in the subject of your message.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们发送一般反馈，只需发送电子邮件到[<feedback@packtpub.com>](mailto:feedback@packtpub.com)，并在邮件主题中提及书籍的标题。
- en: If there is a topic that you have expertise in and you are interested in either
    writing or contributing to a book, see our author guide at [www.packtpub.com/authors](http://www.packtpub.com/authors).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在某个主题上具有专业知识，并且您对撰写或为书籍做出贡献感兴趣，请参阅我们的作者指南[www.packtpub.com/authors](http://www.packtpub.com/authors)。
- en: '**Customer support**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户支持**'
- en: Now that you are the proud owner of a Packt book, we have a number of things
    to help you to get the most from your purchase.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您是Packt书籍的骄傲拥有者，我们有多个方法可以帮助您从您的购买中获得最大收益。
- en: '**Downloading the example code**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件。
- en: for all the Packt Publishing books you have purchased. If you purchased this
    book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为您购买的所有Packt Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: '**Downloading the color images of this book** We also provide you with a PDF
    file that has color images of the screenshots/diagrams used in this book. The
    color images will help you better understand the changes in the output. You can
    download this file from'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载本书的颜色图像** 我们还为您提供了一个包含本书中使用的截图/图表颜色图像的PDF文件。这些颜色图像将帮助您更好地理解输出中的变化。您可以从'
- en: '[https://www.packtpub.com/sites/default/files/downloads/GeospatialDevelopmentByExamp](https://www.packtpub.com/sites/default/files/downloads/GeospatialDevelopmentByExampleWithPython_ColorImages.pdf)leWithPython_ColorImages.pdf'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/sites/default/files/downloads/GeospatialDevelopmentByExamp](https://www.packtpub.com/sites/default/files/downloads/GeospatialDevelopmentByExampleWithPython_ColorImages.pdf)leWithPython_ColorImages.pdf'
- en: '**Errata**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**勘误**'
- en: Although we have taken every care to ensure the accuracy of our content, mistakes
    do happen. If you find a mistake in one of our books—maybe a mistake in the text
    or the code—we would be grateful if you could report this to us. By doing so,
    you can save other readers from frustration and help us improve subsequent versions
    of this book. If you find any errata, please report them by visiting [http://www.packtpub.com/submit-errata](http://www.packtpub.com/submit-errata),
    selecting your book, clicking on the **Errata Submission Form** link, and entering
    the details of your errata. Once your errata are verified, your submission will
    be accepted and the errata will be uploaded to our website or added to any list
    of existing errata under the Errata section of that title.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在我们的书中发现错误——可能是文本或代码中的错误——如果您能向我们报告这一点，我们将不胜感激。通过这样做，您可以避免其他读者的挫败感，并帮助我们改进本书的后续版本。如果您发现任何勘误，请通过访问[http://www.packtpub.com/submit-errata](http://www.packtpub.com/submit-errata)，选择您的书籍，点击**勘误提交表单**链接，并输入您的勘误详情来报告它们。一旦您的勘误得到验证，您的提交将被接受，勘误将被上传到我们的网站或添加到该标题的勘误部分现有的勘误列表中。
- en: To view the previously submitted errata, go to
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看之前提交的勘误，请访问
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)
    and enter the name of the book in the search field. The required information will
    appear under the **Errata** section.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)并在搜索字段中输入书籍名称。所需信息将出现在**勘误**部分下。'
- en: '**Piracy**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**盗版**'
- en: Piracy of copyrighted material on the Internet is an ongoing problem across
    all media. At Packt, we take the protection of our copyright and licenses very
    seriously. If you come across any illegal copies of our works in any form on the
    Internet, please provide us with the location address or website name immediately
    so that we can pursue a remedy.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上对版权材料的盗版是一个跨所有媒体的持续问题。在Packt，我们非常重视我们版权和许可证的保护。如果您在互联网上发现任何形式的非法副本，请立即向我们提供位置地址或网站名称，以便我们可以寻求补救措施。
- en: Please contact us at [<copyright@packtpub.com](mailto:copyright@packtpub.com)>
    with a link to the suspected pirated material.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请通过[<copyright@packtpub.com](mailto:copyright@packtpub.com)>与我们联系，并提供涉嫌盗版材料的链接。
- en: We appreciate your help in protecting our authors and our ability to bring you
    valuable content.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感谢您在保护我们的作者以及为我们提供有价值内容的能力方面的帮助。
- en: '**Questions**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: If you have a problem with any aspect of this book, you can contact us at
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本书的任何方面遇到问题，您可以联系
- en: '[<questions@packtpub.com](mailto:questions@packtpub.com)>, and we will do our
    best to address the problem.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[联系邮箱](mailto:questions@packtpub.com)>, 我们将尽力解决问题。'
- en: '**Chapter 1\. Preparing the Work**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 1 章\. 准备工作**'
- en: '**Environment**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境**'
- en: Working with a programming language as a tool for geoprocessing provides the
    opportunity to construct a personalized application that can more optimally perform
    the task required by the user. This means that repetitive tasks can be automated,
    file inputs and outputs can be customized, and processes can be tuned to perform
    exactly what you want to be done.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 将编程语言作为地理处理工具使用提供了构建个性化应用程序的机会，该应用程序可以更优化地执行用户所需的任务。这意味着重复性任务可以自动化，文件输入输出可以定制，并且过程可以调整以执行您想要完成的精确操作。
- en: 'Python is a powerful programming language that is gaining special attention
    as a tool for geoprocessing and scientific analysis. A number of factors may have
    contributed to its popularization, and three among them are worth mentioning:
    it’s a scripting language, it’s flexible and easy to learn, and it has a wide
    range of libraries available as open source software.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种强大的编程语言，作为地理处理和科学分析的工具有着特殊的关注度。许多因素可能促成了它的普及，其中三个值得提及：它是一种脚本语言，它灵活且易于学习，并且它拥有广泛的库作为开源软件可用。
- en: The number of available libraries and packages allow users to spend less time
    in programming basic functionalities and more in building processes and workflows
    to reach their goals.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的库和软件包数量允许用户在编程基本功能上花费更少的时间，更多的时间用于构建流程和工作流以达到他们的目标。
- en: In this first chapter, we will go through the process of installing all the
    libraries that you will need to go through the examples; it’s likely that these
    same libraries will also satisfy most of your needs in real-world applications.
    Then, we will set up an **Integrated** **Development Environment** (**IDE**) that
    will help organize code and avoid mistakes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍安装所有您将需要通过示例使用的库的过程；这些相同的库也可能满足您在现实世界应用中的大部分需求。然后，我们将设置一个 **集成** **开发环境**
    (**IDE**)，这将有助于组织代码并避免错误。
- en: 'Finally, we will write a sample program with one of the libraries. Therefore,
    here are the topics that will be covered:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用其中一个库编写一个示例程序。因此，以下是我们将要涉及的主题：
- en: Installing Python and the packages that you need for the examples in this book
    Learning the basics of the packages that you will use
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Python 以及本书示例所需的软件包
- en: Installing an IDE to write and organize your code
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 IDE 以编写和组织您的代码
- en: Creating a project for this book
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为本书创建项目
- en: Writing your first code
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 编写您的第一段代码
- en: '**Installing Python**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装 Python**'
- en: For this book, we suggest using Python 2.7; this version of Python is fully
    compatible with the libraries and packages that we will use in the examples and
    also has precompiled binary files available on the Internet for Windows users.
    We will keep all the examples as compatible as possible with Python 3.4 so that
    it would be easy to port future upgrades.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我们建议使用 Python 2.7；这个版本的 Python 与我们将要在示例中使用的库和包完全兼容，并且对于 Windows 用户，互联网上还有可用的预编译二进制文件。我们将尽可能保持所有示例与
    Python 3.4 兼容，以便于将来的升级迁移。
- en: Windows users may find compatibility problems with the 64-bit packages, so we
    recommend the 32-bit version of Python for them.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户可能会发现 64 位软件包存在兼容性问题，因此我们建议他们使用 32 位版本的 Python。
- en: For Linux users, we will show the installation procedures for Ubuntu Linux distribution
    and use package managers, so you don’t need to worry about versions and requirements;
    the package managers will do this for you.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 用户，我们将展示 Ubuntu Linux 分发的安装程序，并使用软件包管理器，这样您就不必担心版本和需求；软件包管理器会为您处理这些。
- en: The libraries that you will install are written in Python and other languages,
    the most common being C and C++. These libraries can abstract classes, methods,
    and functions to Python objects or have an extra layer that makes the connection;
    when this happens, we say that the library has *Python bindings*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要安装的库是用Python和其他语言编写的，最常见的是C和C++。这些库可以将类、方法和函数抽象为Python对象，或者有一个额外的层来建立连接；当这种情况发生时，我们说该库有*Python绑定*。
- en: '**Windows**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**'
- en: 'Here are the steps to perform for the installation of Python on Windows: 1\.
    Go to [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)
    and click on Download the latest Python 2.7 release for Windows.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上安装Python的步骤如下：1. 访问[https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)并点击下载Windows的最新Python
    2.7版本。
- en: 2\. On the next page, roll down, and you will find a list of files; make sure
    that you download **Windows x86 MSI installer**.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在下一页，向下滚动，您将找到一个文件列表；请确保您下载**Windows x86 MSI安装程序**。
- en: 3\. After the file is downloaded, open the installer by clicking on the file
    and following the instructions. Proceed with the default options by clicking on
    the **Next** button.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 文件下载完成后，通过点击文件并按照说明打开安装程序。通过点击**下一步**按钮继续使用默认选项。
- en: '**Ubuntu Linux**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ubuntu Linux**'
- en: 'Ubuntu already comes with Python installed, so there is no need to install
    it. If for any reason, it’s not available, you can install it with the following
    command: sudo apt-get install python'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu已经预装了Python，因此无需安装。如果由于任何原因它不可用，您可以使用以下命令进行安装：sudo apt-get install python
- en: 'Python 2.7.9 comes with Pip, but if you use an older version, you need to install
    Pip with the following command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.7.9自带Pip，但如果您使用的是较旧版本，则需要使用以下命令安装Pip：
- en: sudo apt-get install python-pip
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-get install python-pip
- en: '**Python packages and package manager**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python包和包管理器**'
- en: A Python package is a directory containing one or more Python files (that is,
    modules) plus one __init__.py file (this can be just an empty file). This file
    tells Python Interpreter that the directory is a package.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python包是一个包含一个或多个Python文件（即模块）和一个__init__.py文件的目录（这可以是一个空文件）。此文件告诉Python解释器该目录是一个包。
- en: When writing Python code, we can import packages and modules and use them in
    our code. The Python community does this a lot; many packages use other packages
    and so on, forming an intricate network of requirements and dependencies.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Python代码时，我们可以导入包和模块并在我们的代码中使用它们。Python社区经常这样做；许多包使用其他包，等等，形成一个复杂的依赖关系网络。
- en: In order to facilitate the installation of packages and all the requirements
    for it to run, Python has a package manager called pip.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便安装包及其运行所需的所有依赖项，Python有一个名为pip的包管理器。
- en: Pip looks for packages in a central repository (or on a user-defined place),
    downloads it, then downloads its dependencies, and installs them. Some packages
    also use libraries in other languages, such as C. In these cases, these libraries
    need to be compiled during the installation. Ubuntu users don’t have problem with
    this because many compilers are already installed on the system, but this won’t
    work on Windows by default.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Pip会在中央仓库（或用户定义的位置）中查找包，然后下载它，接着下载其依赖项，并安装它们。一些包还使用其他语言的库，例如C。在这些情况下，这些库需要在安装期间编译。Ubuntu用户不会遇到这个问题，因为系统上已经安装了许多编译器，但在Windows上默认情况下不会这样做。
- en: '**The repository of Python packages for Windows** Python makes it easy to install
    libraries and packages through pip. However, since Windows doesn’t include any
    compiler by default, the installation of packages that needs the compilation of
    libraries fails. Instead of going through the process of installing a compiler,
    which is out of this book’s scope, we can get the packages ready to use.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows的Python包仓库** Python通过pip使安装库和包变得容易。然而，由于Windows默认不包含任何编译器，需要编译库的包的安装会失败。为了避免安装编译器的过程，这超出了本书的范围，我们可以获取准备好使用的包。'
- en: These packages come prebuilt for various types of system and don’t need a compilation
    of its libraries. This type of package is called a wheel.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包为各种类型的系统预先构建，不需要编译其库。这种类型的包被称为wheel。
- en: '**Note**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Christoph Gohlke did a favor to all of us by building these packages and making
    them available for download at [http://www.lfd.uci.edu/~gohlke/pythonlibs/.](http://www.lfd.uci.edu/~gohlke/pythonlibs/)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Christoph Gohlke 通过构建这些包并将它们提供下载，为我们大家做了件好事，下载地址为 [http://www.lfd.uci.edu/~gohlke/pythonlibs/.](http://www.lfd.uci.edu/~gohlke/pythonlibs/)。
- en: '**Installing packages and required software**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装包和所需软件**'
- en: In this topic, we will go through the installation process of every package
    used in the book.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们将介绍书中使用的每个包的安装过程。
- en: '**OpenCV**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenCV**'
- en: OpenCV is an optimized C/C++ library intended for video and image processing
    with hundreds of functions ranging from simple image resizing to object recognition,
    face detection, and so on. OpenCV is a big library, and we will use its capabilities
    of reading, transforming, and writing images. It’s a good choice because its development
    is active, and it has a large user community and very good documentation.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 是一个针对视频和图像处理的优化 C/C++ 库，拥有从简单的图像缩放到对象识别、人脸检测等功能。OpenCV 是一个庞大的库，我们将使用其读取、转换和写入图像的功能。它是一个不错的选择，因为其开发活跃，拥有庞大的用户社区和非常好的文档。
- en: '**Windows**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**'
- en: 'Here is the installation procedure for Windows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Windows 的安装步骤：
- en: 1\. Go to [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 访问 [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)。
- en: 2\. Press *Ctrl* + *F* to open the search dialog of your browser and then search
    for OpenCV.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 按 *Ctrl* + *F* 打开浏览器搜索对话框，然后搜索 OpenCV。
- en: 3\. You will find a list of files; choose opencv_python-2.4.11-cp27-none-win32.whl
    or any OpenCV version that contains cp27 and win32\. This means that this is the
    32-bit version for Python 2.7\.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 你将找到一个文件列表；选择 opencv_python-2.4.11-cp27-none-win32.whl 或任何包含 cp27 和 win32
    的 OpenCV 版本。这意味着这是 Python 2.7 的 32 位版本。
- en: 4\. Save the downloaded file to a known location.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 将下载的文件保存到已知位置。
- en: '5\. Open Windows Command Prompt and run the following command: **c:\Python27\scripts\pip
    install path_to_the_file_you_downloaded.whl** 6\. You should see an output telling
    you that the installation was successful, as follows: **Processing c:\downloads\opencv_python-2.4.12-cp27-none-win32.whl**
    **Installing collected packages: opencv-python**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '5. 打开 Windows 命令提示符并运行以下命令：**c:\Python27\scripts\pip install path_to_the_file_you_downloaded.whl**
    6. 你应该会看到一个输出告诉你安装成功，如下所示：**Processing c:\downloads\opencv_python-2.4.12-cp27-none-win32.whl**
    **Installing collected packages: opencv-python**'
- en: '**Successfully installed opencv-python-2.4.12**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**Successfully installed opencv-python-2.4.12**'
- en: '**Tip**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You can drag and drop a file into the command prompt to enter its full path.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将文件拖放到命令提示符中，以输入其完整路径。
- en: '**Ubuntu Linux**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ubuntu Linux**'
- en: 'Here is the installation process for Ubuntu Linux:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Ubuntu Linux 的安装过程：
- en: 1\. Open a new terminal with *Ctrl* + *T*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 使用 *Ctrl* + *T* 打开一个新的终端。
- en: '2\. Then, enter the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后，输入以下命令：
- en: '**sudo apt-get install python-opencv**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo apt-get install python-opencv**'
- en: '**Installing NumPy**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装 NumPy**'
- en: NumPy is a package for scientific computing with Python. It handles multidimensional
    arrays of operations in a very efficient way. NumPy is required by OpenCV to run
    and will be used by many raster operations that we will perform in the examples.
    NumPy is also an efficient data container and will be our tool to calculate massive
    image data.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是一个用于科学计算的 Python 包。它以非常高效的方式处理多维数组操作。NumPy 是 OpenCV 运行所必需的，并将被我们在示例中执行的大多数栅格操作所使用。NumPy
    也是一个高效的数据容器，并将是我们计算大量图像数据的工具。
- en: '**Windows**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**'
- en: Repeat the same procedure as you did to install OpenCV; however, this time,
    search for NumPy and choose a file named numpy-1.9.2+mkl-cp27-none-win32.whl.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 重复安装 OpenCV 的相同步骤；然而，这次，搜索 NumPy 并选择一个名为 numpy-1.9.2+mkl-cp27-none-win32.whl
    的文件。
- en: '**Ubuntu Linux**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ubuntu Linux**'
- en: 'NumPy is automatically installed as a dependency of OpenCV on Ubuntu, but if
    you want to install it without OpenCV, follow these steps:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 在 Ubuntu 上作为 OpenCV 的依赖项自动安装，但如果你想在没有 OpenCV 的情况下安装它，请按照以下步骤操作：
- en: 1\. Open a new terminal with *Ctrl* + *T*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 使用 *Ctrl* + *T* 打开一个新的终端。
- en: '2\. Then, enter the following command:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后，输入以下命令：
- en: '**sudo pip install numpy**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo pip install numpy**'
- en: '**Installing GDAL and OGR**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装 GDAL 和 OGR**'
- en: '**GDAL** (**Geospatial Data Abstraction Library**) is composed of two packages
    that come together: OGR handles geospatial vector file formats, including coordinate
    system transformations and vector operations. GDAL is the raster part of the library,
    and in version 1.11, it comes packed with 139 drivers that can read, and some
    even create rasters.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**GDAL**（**地理空间数据抽象库**）由两个结合在一起的包组成：OGR处理地理空间矢量文件格式，包括坐标系转换和矢量操作。GDAL是库的栅格部分，在1.11版本中，它包含了139个驱动程序，可以读取，其中一些甚至可以创建栅格。'
- en: GDAL also comes packed with functions for raster transformations and calculations
    such as resizing, clipping, reprojecting, and so on.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL还包含用于栅格转换和计算的函数，例如调整大小、裁剪、重新投影等。
- en: 'In the following tables, there’s an excerpt of the list of GDAL and OGR drivers
    with the most common formats that you may find:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中，列出了GDAL和OGR驱动程序列表的摘录，这些驱动程序支持您可能找到的最常见的格式：
- en: '**Long format name**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**长格式名称**'
- en: '**Code**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '**Creation**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建**'
- en: Arc/Info ASCII Grid
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Arc/Info ASCII Grid
- en: AAIGrid
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: AAIGrid
- en: 'Yes'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Arc/Info Export E00 GRID
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Arc/Info 导出 E00 GRID
- en: E00GRID
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: E00GRID
- en: 'No'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: ENVI .hdr Labelled Raster
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ENVI .hdr 标签化栅格
- en: ENVI
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ENVI
- en: 'Yes'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Generic Binary (.hdr Labelled)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通用二进制 (.hdr 标签化)
- en: GENBIN
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: GENBIN
- en: 'No'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Oracle Spatial GeoRaster
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Spatial GeoRaster
- en: GEORASTER
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: GEORASTER
- en: 'Yes'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GSat File Format
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: GSat 文件格式
- en: GFF
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: GFF
- en: 'No'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Graphics Interchange Format (.gif)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图像交换格式 (.gif)
- en: GIF
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: GIF
- en: 'Yes'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GMT Compatible netCDF
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: GMT 兼容的netCDF
- en: GMT
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: GMT
- en: 'Yes'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GRASS ASCII Grid
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: GRASS ASCII Grid
- en: GRASSASCIIGrid No
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: GRASSASCIIGrid 否
- en: Golden Software ASCII Grid
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Golden Software ASCII Grid
- en: GSAG
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: GSAG
- en: 'Yes'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Golden Software Binary Grid
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Golden Software 二进制网格
- en: GSBG
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: GSBG
- en: 'Yes'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Golden Software Surfer 7 Binary Grid
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: Golden Software Surfer 7 二进制网格
- en: GS7BG
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: GS7BG
- en: 'Yes'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: TIFF / BigTIFF / GeoTIFF (.tif)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: TIFF / BigTIFF / GeoTIFF (.tif)
- en: GTiff
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: GTiff
- en: 'Yes'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GXF (Grid eXchange File)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: GXF (网格交换文件)
- en: GXF
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: GXF
- en: 'No'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Erdas Imagine (.img)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Erdas Imagine (.img)
- en: HFA
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: HFA
- en: 'Yes'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: JPEG JFIF (.jpg)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG JFIF (.jpg)
- en: JPEG
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG
- en: 'Yes'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: NOAA Polar Orbiter Level 1b Data Set (AVHRR) L1B
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: NOAA极地轨道器1b数据集(AVHRR) L1B
- en: 'No'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: NOAA NGS Geoid Height Grids
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: NOAA NGS 地球椭球高度网格
- en: NGSGEOID
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: NGSGEOID
- en: 'No'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: NITF
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: NITF
- en: NITF
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: NITF
- en: 'Yes'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: NTv2 Datum Grid Shift
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: NTv2 基准网格偏移
- en: NTv2
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: NTv2
- en: 'Yes'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: PCI .aux Labelled
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: PCI .aux 标签化
- en: PAux
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: PAux
- en: 'Yes'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: PCI Geomatics Database File
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Geomatics 数据库文件
- en: PCIDSK
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: PCIDSK
- en: 'Yes'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: PCRaster
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: PCRaster
- en: PCRaster
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: PCRaster
- en: 'Yes'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Geospatial PDF
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间PDF
- en: PDF
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: PDF
- en: 'Yes'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: NASA Planetary Data System
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: NASA行星数据系统
- en: PDS
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: PDS
- en: 'No'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Portable Network Graphics (.png)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植网络图形 (.png)
- en: PNG
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: PNG
- en: 'Yes'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: R Object Data Store
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: R对象数据存储
- en: R
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: R
- en: 'Yes'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Raster Matrix Format (*.rsw, .mtw)
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格矩阵格式 (*.rsw, .mtw)
- en: RMF
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: RMF
- en: 'Yes'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: RadarSat2 XML (product.xml)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: RadarSat2 XML (product.xml)
- en: RS2
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: RS2
- en: 'No'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Idrisi Raster
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Idrisi 栅格
- en: RST
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: RST
- en: 'Yes'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: SAGA GIS Binary format
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: SAGA GIS 二进制格式
- en: SAGA
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: SAGA
- en: 'Yes'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: USGS SDTS DEM (*CATD.DDF)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: USGS SDTS DEM (*CATD.DDF)
- en: SDTS
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: SDTS
- en: 'No'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: SGI Image Format
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: SGI 图像格式
- en: SGI
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: SGI
- en: 'Yes'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: SRTM HGT Format
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: SRTM HGT 格式
- en: SRTMHGT
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: SRTMHGT
- en: 'Yes'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Terragen Heightfield (.ter)
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Terragen 高程场 (.ter)
- en: TERRAGEN
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: TERRAGEN
- en: 'Yes'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: USGS ASCII DEM / CDED (.dem)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: USGS ASCII DEM / CDED (.dem)
- en: USGSDEM
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: USGSDEM
- en: 'Yes'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: ASCII Gridded XYZ
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 格网XYZ
- en: XYZ
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: XYZ
- en: 'Yes'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: 'The following table describes the OGR drivers:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了OGR驱动程序：
- en: '**Format name**'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式名称**'
- en: '**Code**'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '**Creation**'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建**'
- en: Arc/Info Binary Coverage
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: Arc/Info 二进制覆盖
- en: AVCBin
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: AVCBin
- en: 'No'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Arc/Info .E00 (ASCII) Coverage AVCE00
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: Arc/Info .E00 (ASCII) 覆盖AVCE00
- en: 'No'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: AutoCAD DXF
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: AutoCAD DXF
- en: DXF
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: DXF
- en: 'Yes'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Comma Separated Value (.csv) CSV
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔值 (.csv) CSV
- en: 'Yes'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: ESRI Shapefile
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: ESRI Shapefile
- en: ESRI Shapefile Yes
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: ESRI Shapefile 是
- en: GeoJSON
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON
- en: GeoJSON
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON
- en: 'Yes'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Géoconcept Export
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: Géoconcept 导出
- en: Geoconcept
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Geoconcept
- en: 'Yes'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GeoRSS
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: GeoRSS
- en: GeoRSS
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: GeoRSS
- en: 'Yes'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GML
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: GML
- en: GML
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: GML
- en: 'Yes'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GMT
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: GMT
- en: GMT
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: GMT
- en: 'Yes'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GPSBabel
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: GPSBabel
- en: GPSBabel
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: GPSBabel
- en: 'Yes'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GPX
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: GPX
- en: GPX
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: GPX
- en: 'Yes'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: GPSTrackMaker (.gtm, .gtz)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: GPSTrackMaker (.gtm, .gtz)
- en: GPSTrackMaker
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: GPSTrackMaker
- en: 'Yes'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Hydrographic Transfer Format
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 水文传输格式
- en: HTF
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: HTF
- en: 'No'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Idrisi Vector (.VCT)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: Idrisi 向量 (.VCT)
- en: Idrisi
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: Idrisi
- en: 'No'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: KML
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: KML
- en: KML
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: KML
- en: 'Yes'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Mapinfo File
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: Mapinfo 文件
- en: MapInfo File
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: MapInfo 文件
- en: 'Yes'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Microstation DGN
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: Microstation DGN
- en: DGN
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: DGN
- en: 'Yes'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: OpenAir
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAir
- en: OpenAir
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAir
- en: 'No'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: ESRI FileGDB
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ESRI FileGDB
- en: OpenFileGDB
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFileGDB
- en: 'No'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: PCI Geomatics Database File
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Geomatics 数据库文件
- en: PCIDSK
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: PCIDSK
- en: 'Yes'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: Geospatial PDF
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间PDF
- en: PDF
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: PDF
- en: 'Yes'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: PDS
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: PDS
- en: PDS
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: PDS
- en: 'No'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: PostgreSQL SQL dump
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL SQL转储
- en: PGDump
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: PGDump
- en: 'Yes'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: U.S. Census TIGER/Line
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 美国人口普查TIGER/Line
- en: TIGER
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: TIGER
- en: 'No'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: '**Note**'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the full GDAL and OGR API documentation and the complete list of
    drivers at [http://gdal.org/python/](http://gdal.org/python/).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://gdal.org/python/](http://gdal.org/python/)找到完整的GDAL和OGR API文档和驱动程序完整列表。
- en: '**Windows**'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**'
- en: 'Again, we will use a wheel for the installation. Repeat the same procedure
    as before: 1\. Go to [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/).'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用轮子进行安装。重复之前的相同步骤：1. 访问[http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)。
- en: 2\. Now, search for GDAL and download the file named
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，搜索GDAL并下载名为
- en: GDAL-1.11.3-cp27-none-win32.whl.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL-1.11.3-cp27-none-win32.whl。
- en: 3\. Finally, install it with pip, as we did before.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 最后，使用pip安装它，就像我们之前做的那样。
- en: '**Ubuntu Linux**'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ubuntu Linux**'
- en: 'Perform the following steps:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 1\. Go to the terminal or open a new one.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 前往终端或打开一个新的终端。
- en: '2\. Then, enter the following command:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后，输入以下命令：
- en: '**sudo apt-get install python-gdal**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo apt-get install python-gdal**'
- en: '**Installing Mapnik**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装Mapnik**'
- en: Mapnik is a map rendering package. It is a free toolkit to develop mapping applications.
    It produces high-quality maps and is used on many applications, including OpenStreetMaps.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik是一个地图渲染包。它是一个用于开发地图应用的免费工具包。它生成高质量的地图，并被用于许多应用中，包括OpenStreetMaps。
- en: '**Windows**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**'
- en: Mapnik isn’t available for installation as other libraries are. Instead, you
    need to go to
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik与其他库不同，不可直接安装。相反，你需要前往
- en: '[http://mapnik.org/](http://mapnik.org/) and follow the download link: 1\.
    Download the Windows 32-bit package of Mapnik 2.2\.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mapnik.org/](http://mapnik.org/)并按照下载链接：1. 下载Mapnik 2.2的Windows 32位包。'
- en: 2\. Extract the mapnik-v2.2.0 to C:\ folder.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将mapnik-v2.2.0解压到C:\文件夹。
- en: 3\. Then, rename the extracted folder c:\mapnik.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 然后，将解压的文件夹重命名为c:\mapnik。
- en: 4\. Now, add Mapnik to your **PATH**.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 现在，将Mapnik添加到你的**PATH**。
- en: 5\. Open **Control Panel** and go to **System**.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 打开**控制面板**并转到**系统**。
- en: 6\. Click on the **Advanced System Settings** link in the left-hand side column.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 点击左侧列中的**高级系统设置**链接。
- en: 7\. In the **System Properties** window, click on the **Advanced** tab.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 在**系统属性**窗口中，点击**高级**选项卡。
- en: 8\. Next, click on the **Environment Variables** button.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 接下来，点击**环境变量**按钮。
- en: '9\. In the **System variables** section, highlight the **PATH** variable and
    click on **Edit**. Add the following paths to the end of the list, each separated
    with a semicolon, as follows: **c:\mapnik\bin;c:\mapnik\lib**'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 9. 在**系统变量**部分，选中**PATH**变量并点击**编辑**。将以下路径添加到列表末尾，每个路径之间用分号分隔，如下所示：**c:\mapnik\bin;c:\mapnik\lib**
- en: 10\. Now, click on the **New** button; then, set the variable name to PYTHONPATH
    and value to c:\mapnik\python\2.7\site-packages.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 现在，点击**新建**按钮；然后，将变量名设置为PYTHONPATH，值设置为c:\mapnik\python\2.7\site-packages。
- en: '**Ubuntu Linux**'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ubuntu Linux**'
- en: 'For this, perform the following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此操作，请执行以下步骤：
- en: 1\. Go to the terminal or open a new one.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 前往终端或打开一个新的终端。
- en: '2\. Then, enter the following command:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后，输入以下命令：
- en: '**sudo apt-get install mapnik**'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo apt-get install mapnik**'
- en: '**Installing Shapely**'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装Shapely**'
- en: Shapely is a package for the manipulation and analysis of two dimensional geometries.
    It can perform operations such as union and subtraction of geometries. It also
    can perform tests and comparisons, such as when a geometry intersects other geometries.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely是一个用于二维几何操作和分析的包。它可以执行诸如几何的并集和减法等操作。它还可以执行测试和比较，例如当几何体与其他几何体相交时。
- en: '**Windows**'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**'
- en: 'Here’s what you need to do:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你需要做的是：
- en: 1\. As before, download the prebuilt wheel; this time, look for a file named
    Shapely-1.5.13-cp27-none-win32.whl.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 如前所述，下载预构建的wheel文件；这次，寻找一个名为Shapely-1.5.13-cp27-none-win32.whl的文件。
- en: 2\. Then, install it with pip.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 然后，使用pip安装它。
- en: '**Ubuntu Linux**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ubuntu Linux**'
- en: 'Here are the steps you need to perform:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你需要执行的步骤是：
- en: 1\. Go to the terminal or open a new one with *Ctrl* + *T*.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 前往终端或使用*Ctrl* + *T*打开一个新的终端。
- en: '2\. Enter the following command:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 输入以下命令：
- en: '**sudo pip install shapely**'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo pip install shapely**'
- en: '**Installing other packages directly from**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接从以下位置安装其他包**'
- en: '**pip**'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '**pip**'
- en: Some packages do not require compilation steps. For Windows users, these are
    easier to install because they can be obtained and installed directly with pip
    with a single command.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包不需要编译步骤。对于Windows用户来说，这些包更容易安装，因为它们可以直接通过pip使用单个命令获取和安装。
- en: '**Windows**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**'
- en: 'You need to simply type the following command in your Command Prompt: **c:\Python27\scripts\pip
    install django tabulate requests xmltodict psycopg2**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要在命令提示符中输入以下命令：**c:\Python27\scripts\pip install django tabulate requests
    xmltodict psycopg2**
- en: '**Ubuntu Linux**'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ubuntu Linux**'
- en: 'In the terminal, type the following command:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，输入以下命令：
- en: '**sudo pip install django tabulate requests xmltodict psycopg2**'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo pip install django tabulate requests xmltodict psycopg2**'
- en: 'For each package, you should see the progress of the installation, similar
    to the following: **Collecting django**'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个包，你应该能看到安装的进度，类似于以下内容：**收集django**
- en: '**Downloading Django-1.9-py2.py3-none-any.whl (6.6MB)**'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载Django-1.9-py2.py3-none-any.whl (6.6MB)**'
- en: '**100% |################################| 6.6MB 43kB/s** **Installing collected
    packages: django**'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '**100% |################################| 6.6MB 43kB/s** **安装收集的包：django**'
- en: '**Successfully installed django-1.9**'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '**成功安装django-1.9**'
- en: '**Installing an IDE**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装IDE**'
- en: IDEs are fancy text editors with tools and inspections regarding programming
    languages.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: IDE是带有工具和编程语言检查的时尚文本编辑器。
- en: You can surely use any text editor or IDE of your preference; none of the tasks
    in this book depends on the IDE, but an IDE will facilitate our work a lot because
    the suggested configuration will help you avoid mistakes and save time on typing,
    running, and debugging your code. The IDE checks the code for you and detects
    underlying errors; it even guesses what you are typing and completes the statements
    for you, runs the code with a simple command, and if there are exceptions, it
    provides links to the place where the exception occurred. For Windows or Linux,
    go to [http://www.jetbrains.com/pycharm/](http://www.jetbrains.com/pycharm/)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以使用你偏好的任何文本编辑器或IDE；本书中的所有任务都不依赖于IDE，但IDE将极大地简化我们的工作，因为建议的配置可以帮助你避免错误并节省在输入、运行和调试代码上的时间。IDE会为你检查代码并检测潜在的错误；它甚至可以猜测你正在输入的内容并为你完成语句，通过简单的命令运行代码，如果出现异常，它还会提供指向异常发生位置的链接。对于Windows或Linux，请访问[http://www.jetbrains.com/pycharm/](http://www.jetbrains.com/pycharm/)
- en: and click on the big orange button **Get Pycharm Now**. On the next page, select
    the free community edition.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 点击大橙色的按钮**立即获取Pycharm**。在下一页，选择免费社区版。
- en: '**Windows**'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**'
- en: 'Here are the steps you need to perform:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你需要执行的步骤：
- en: 1\. After the download finishes, open the downloaded file; the **Setup Wizard**
    will pop up.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 下载完成后，打开下载的文件；**安装向导**将会弹出。
- en: '2\. Click on **Next**, and in the installation options, check both of the boxes:
    **Create** **Desktop shortcut** and **Create associations**.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 点击**下一步**，在安装选项中，勾选两个复选框：**创建** **桌面快捷方式**和**创建关联**。
- en: 3\. Click on **Next** and continue the installation.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 点击**下一步**继续安装。
- en: '**Linux**'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux**'
- en: 'Perform the following steps:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 1\. Unpack the downloaded file in a directory.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在一个目录中解压下载的文件。
- en: 2\. To open PyCharm, run pycharm.sh from the bin subdirectory. You can create
    a shortcut to it if you wish.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 要打开PyCharm，从bin子目录运行pycharm.sh。如果你愿意，可以为其创建快捷方式。
- en: '**Tip**'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**Downloading the example code**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册以直接将文件通过电子邮件发送给你。
- en: '![Image 3](img/index-85_1.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![Image 3](img/index-85_1.jpg)'
- en: '**Creating the book project**'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建书籍项目**'
- en: 'Perform the following steps:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: '1\. After installation, open Pycharm, and you will be prompted to create your
    first project:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 安装完成后，打开Pycharm，你将被提示创建你的第一个项目：
- en: 2\. Click on create new project and then choose c:\geopy as your project location.
    In Linux, you can put the project inside your home folder—for example,
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 点击创建新项目，然后选择c:\geopy作为你的项目位置。在Linux中，你可以将项目放在你的家目录中——例如，
- en: /home/myname/geopy. Click on **Create** to create the project.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: /home/myname/geopy. 点击**创建**以创建项目。
- en: '![Image 4](img/index-86_1.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![Image 4](img/index-86_1.jpg)'
- en: '3\. In Windows, you will receive a security alert; this is Pycharm trying to
    access the Internet. It’s recommended that you allow it so that you can later
    check for updates or download plugins:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 在Windows中，你会收到一个安全警报；这是Pycharm试图访问互联网。建议你允许它，这样你以后可以检查更新或下载插件：
- en: '![Image 5](img/index-87_1.jpg)'
  id: totrans-664
  prefs: []
  type: TYPE_IMG
  zh: '![Image 5](img/index-87_1.jpg)'
- en: '![Image 6](img/index-87_2.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![Image 6](img/index-87_2.jpg)'
- en: '4\. Finally, you should see the following window on your project workspace.
    Take some time to explore the menus and buttons, try right-clicking on your project
    folder to see the options:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 最后，你应该在你的项目工作区看到以下窗口。花点时间探索菜单和按钮，尝试在你的项目文件夹上右键点击以查看选项：
- en: '**Programming and running your first**'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写和运行你的第一个**'
- en: '**example**'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: Now that we have all we need installed, we will go through our first example.
    In this example, we will test the installation and then see a glimpse of OGR’s
    capabilities.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有需要的软件，我们将通过第一个示例进行测试。在这个示例中，我们将测试安装，然后看看OGR功能的一瞥。
- en: 'To do this, we will open a vector file containing the boundaries of all the
    countries in the world and make a list of country names. The objective of this
    simple example is to present the logic behind OGR objects and functions and give
    an understanding of how geospatial files are represented. Here’s how:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, you need to copy the sample data provided with the book to your project
    folder.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: You can do this by dragging and dropping the data folder into the geopy folder.
    Make sure that the data folder is named data and that it’s inside the geopy folder.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Now, create a new directory for this chapter code, inside PyCharm. With
    your geopy project opened, right-click on the project folder and select **New**
    | **Directory**. Name it Chapter1\.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Create a new Python file. To do this, right-click on the Chapter1 folder
    and select **New** | **Python File**. Name it world_borders.py, and PyCharm will
    automatically open the file for editing.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Type the following code in this file:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: import ogr
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: Open the shapefile and get the first layer.
  id: totrans-677
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(layer.GetFeatureCount())) 5\. Now, run
    the code; in the menu bar, navigate to **Run** | **Run**, and in the dialog, choose
    world_borders. An output console will open at the bottom of the screen, and if
    everything goes fine, you should see this output:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\Python27\python.exe C:/geopy/world_borders.py**'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of features: 246**'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '**Process finished with exit code 0**'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You successfully opened a Shapefile and counted the number
    of features inside it. Now, let’s understand what this code does.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: The first line imports the ogr package. From this point on, all the functions
    are available as ogr.FunctionName(). Note that ogr doesn’t follow the Python naming
    conventions for functions.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: The line after the comment opens the OGR datasource (this opens the shapefile
    containing the data) and assigns the object to the datasource variable. Note that
    the path, even on Windows, uses a forward slash (/) and not a backslash.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: The next line gets the first layer of the data source by its index (0). Some
    data sources can
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: have many layers, but this is not the case of a Shapefile, which has only one
    layer. So, when working with Shapefiles, we always know that the layer of interest
    is layer 0\.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: In the final line, the print statement prints the number of features returned
    by layer.GetFeatureCount(). Here, we will use Python’s string formatting, where
    the curly braces are replaced by the argument passed to format().
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, perform the following steps:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In the same file, let’s type the next part of our program:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the fields available in the layer.
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: feature_definition = layer.GetLayerDefn()
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'for field_index in range(feature_definition.GetFieldCount()): field_definition
    = feature_definition.GetFieldDefn(field_index) print("\t{}\t{}\t{}".format(field_index,'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: field_definition.GetTypeName(),
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: field_definition.GetName()))
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: field_definition.GetName()))
- en: '2\. Rerun the code; you can use the *Shift* + *F10* shortcut for this. Now,
    you should see the number of features as before plus a pretty table showing information
    on all the fields in the shapefile, as follows:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 重新运行代码；你可以使用 *Shift* + *F10* 快捷键。现在，你应该看到要素数量与之前相同，并且显示 shapefile 中所有字段信息的漂亮表格，如下所示：
- en: '**Number of features: 246**'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**要素数量：246**'
- en: '**0 String FIPS**'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**0 字符串 FIPS**'
- en: '**1 String ISO2**'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 字符串 ISO2**'
- en: '**2 String ISO3**'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '**2 字符串 ISO3**'
- en: '**3 Integer UN**'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '**3 整数 UN**'
- en: '**4 String NAME**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**4 字符串 NAME**'
- en: '**5 Integer POP2005**'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**5 整数 POP2005**'
- en: '**6 Integer REGION**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '**6 整数 REGION**'
- en: '**7 Integer SUBREGION**'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**7 整数 SUBREGION**'
- en: '**Process finished with exit code 0**'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程结束，退出代码 0**'
- en: What happens in this piece of code is that feature_definition =
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中发生的事情是 feature_definition =
- en: layer.GetLayerDefn() gets the object that contains the definition of the features.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: layer.GetLayerDefn() 获取包含要素定义的对象。
- en: This object contains the definition for each field and the type of geometry.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象包含每个字段的定义和几何类型。
- en: In the for loop, we will get each field definition and print its index, name,
    and type.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for 循环中，我们将获取每个字段定义并打印其索引、名称和类型。
- en: 'Note that the object returned by layer.GetLayerDefn() is not iterable, and
    we can’t use for directly with it. So first, we will get the number of fields
    and use it in the range() function so that we can iterate through the indexes
    of the fields: 3\. Now, type the last part, as follows:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，layer.GetLayerDefn() 返回的对象不可迭代，我们不能直接使用它。因此，首先，我们将获取字段数量，并在 range() 函数中使用它，以便我们可以遍历字段的索引：3.
    现在，输入最后一部分，如下所示：
- en: Print a list of country names.
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印国家名称列表。
- en: layer.ResetReading()
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: layer.ResetReading()
- en: 'for feature in layer:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in layer:'
- en: print(feature.GetFieldAsString(4))
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: print(feature.GetFieldAsString(4))
- en: '4\. Run the code again and check the results in the output: **Number of features:
    246**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 再次运行代码并检查输出结果中的数量：**要素数量：246**
- en: '**0 String FIPS**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**0 字符串 FIPS**'
- en: '**1 String ISO2**'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 字符串 ISO2**'
- en: '**2 String ISO3**'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**2 字符串 ISO3**'
- en: '**3 Integer UN**'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '**3 整数 UN**'
- en: '**4 String NAME**'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**4 字符串 NAME**'
- en: '**5 Integer POP2005**'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '**5 整数 POP2005**'
- en: '**6 Integer REGION**'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '**6 整数 REGION**'
- en: '**7 Integer SUBREGION**'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '**7 整数 SUBREGION**'
- en: '**Antigua and Barbuda**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**安提瓜和巴布达**'
- en: '**Algeria**'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '**阿尔及利亚**'
- en: '**Azerbaijan**'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '**阿塞拜疆**'
- en: '**Albania**'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**阿尔巴尼亚**'
- en: '**Armenia**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚美尼亚**'
- en: '**Angola**'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**安哥拉**'
- en: '**...**'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: '**Saint Barthelemy**'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**圣巴泰勒米**'
- en: '**Guernsey**'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**根西岛**'
- en: '**Jersey**'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '**泽西岛**'
- en: '**South Georgia South Sandwich Islands**'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**南乔治亚和南桑威奇群岛**'
- en: '**Taiwan**'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**台湾**'
- en: '**Process finished with exit code 0**'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程结束，退出代码 0**'
- en: The layer is iterable, but first, we need to ensure that we are at the beginning
    of the layer list with layer.ResetReading() (this is one of OGR’s “gotcha” points).
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 图层是可迭代的，但首先，我们需要确保我们位于图层列表的起始位置，使用 layer.ResetReading()（这是 OGR 的“陷阱”之一）。
- en: 'The feature.GetFieldAsString(4) method returns the value of field 4 as a Python
    string. There are two ways of knowing whether the country names are in field 4:
    Looking at the data’s DBF file (by opening it with LibreOffice or Excel) Looking
    at the table that we printed in the first part of the code Your complete code
    should look similar to the following:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: The feature.GetFieldAsString(4) 方法返回字段 4 的值，作为一个 Python 字符串。有两种方式可以知道国家名称是否在字段
    4 中：查看数据的 DBF 文件（通过使用 LibreOffice 或 Excel 打开）查看我们在代码第一部分打印的表格。你的完整代码应类似于以下内容：
- en: import ogr
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: import ogr
- en: Open the shapefile and get the first layer.
  id: totrans-741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开 shapefile 并获取第一个图层。
- en: datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
- en: 'print("Number of features: {}".format(layer.GetFeatureCount()))'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("Number of features: {}".format(layer.GetFeatureCount()))'
- en: Inspect the fields available in the layer.
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查图层中可用的字段。
- en: feature_definition = layer.GetLayerDefn()
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: feature_definition = layer.GetLayerDefn()
- en: 'for field_index in range(feature_definition.GetFieldCount()): field_definition
    = feature_definition.GetFieldDefn(field_index) print("\t{}\t{}\t{}".format(field_index,'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 'for field_index in range(feature_definition.GetFieldCount()): field_definition
    = feature_definition.GetFieldDefn(field_index) print("\t{}\t{}\t{}".format(field_index,'
- en: field_definition.GetTypeName(),
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: field_definition.GetTypeName(),
- en: field_definition.GetName()))
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: field_definition.GetName()))
- en: Print a list of country names.
  id: totrans-749
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印国家名称列表。
- en: layer.ResetReading()
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: layer.ResetReading()
- en: 'for feature in layer:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in layer:'
- en: print(feature.GetFieldAsString(4))
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: print(feature.GetFieldAsString(4))
- en: '**Transforming the coordinate system and**'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换坐标系和**'
- en: '**calculating the area of all countries**'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算所有国家的面积**'
- en: Now, the objective is to know how much area is occupied by each country. However,
    the coordinates of country borders are expressed in latitude and longitude, and
    we can’t calculate areas in this coordinate system. We want the area to be in
    the metric system, so first we need to convert the spatial reference system of
    the geometries.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，目标是了解每个国家占用的面积。然而，国家边界的坐标是以纬度和经度表示的，我们无法在这个坐标系中计算面积。我们希望面积在公制系统中，因此首先需要将几何形状的空间参考系统进行转换。
- en: 'Let’s also take a step further in the programming techniques and start using
    functions to avoid the repetition of code. Perform the following steps:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在编程技术方面更进一步，开始使用函数来避免代码重复。执行以下步骤：
- en: '1\. Create a new file in the Chapter1 directory, name this file world_areas.py,
    and program this first function:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在Chapter1目录中创建一个新文件，将此文件命名为world_areas.py，并编写这个第一个函数：
- en: import ogr
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: import ogr
- en: 'def open_shapefile(file_path):'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 'def open_shapefile(file_path):'
- en: '"""Open the shapefile, get the first layer and returns the ogr datasource.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开shapefile，获取第一层并返回ogr数据源。'
- en: '"""'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在单词之间。一个命名的好提示是遵循动词_名词规则。
- en: datasource = ogr.Open(file_path)
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = ogr.Open(file_path)
- en: layer = datasource.GetLayerByIndex(0)
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: layer = datasource.GetLayerByIndex(0)
- en: print("Opening {}".format(file_path))
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在打开 {}".format(file_path))
- en: 'print("Number of features: {}".format('
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: print("要素数量：{}".format(
- en: layer.GetFeatureCount()))
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: layer.GetFeatureCount()))
- en: return datasource
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: return datasource
- en: 2\. Run the code, go to **Run** | **Run…** in the menu, and select world_areas.
    If everything is correct, nothing should happen. This is because we are not calling
    our function.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码，在菜单中选择**运行** | **运行…**，然后选择world_areas。如果一切正常，不应该发生任何事。这是因为我们没有调用我们的函数。
- en: 'Add this line of code at the end and outside the function:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数外部添加此行代码：
- en: 'datasource = open_shapefile("../data/world_borders_simple.shp") 3\. Now, run
    the code again with *Shift* + *F10* and check the output, as follows: **Opening
    ../data/world_borders_simple.shp**'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了这段代码的工作方式，但这里有几个新特性值得解释。def语句使用def function_name(arguments)：语法定义了一个函数。
- en: '**Number of features: 246**'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '**要素数量：246**'
- en: '**Process finished with exit code 0**'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程已正常结束**'
- en: That’s wonderful! You just created a piece of very useful and reusable code.
    You now have a function that can open any shapefile, print the number of features,
    and return the ogr datasource. From now on, you can reuse this function in any
    of your projects.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = open_shapefile("../data/world_borders_simple.shp") 3. 现在，再次使用 *Shift*
    + *F10* 运行代码，并检查输出，如下所示：**正在打开 ../data/world_borders_simple.shp**
- en: 'You are already familiar with how this code works, but there are a few novelties
    here that deserve an explanation. The def statement defines a function with the
    def function_name(arguments): syntax.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Remember when I told you that OGR doesn’t follow Python’s naming convention?
    Well, the convention is that function names should all be in lowercase with an
    underscore
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我告诉过你OGR不遵循Python的命名约定吗？好吧，约定是函数名应该全部小写，单词之间用下划线分隔。一个命名的好提示是遵循动词_名词规则。
- en: between words. A good hint for names is to follow the verb_noun rule.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
- en: '**Tip**'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好！你刚刚创建了一段非常有用且可重用的代码。现在，你有一个可以打开任何shapefile、打印要素数量并返回ogr数据源的函数。从现在起，你可以在任何项目中重用这个函数。
- en: These conventions are described in a document called **PEP-8**, where **PEP**
    stands for **Python Enhancement Program**. You can find this document at
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约定在名为**PEP-8**的文档中描述，其中**PEP**代表**Python增强计划**。您可以在以下位置找到此文档：
- en: '[https://www.python.org/dev/peps/pep-0008/.](https://www.python.org/dev/peps/pep-0008/)'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Right after the function’s definition, you can see a description between triple
    quotes; this is a docstring, and it is used to document the code. It’s optional
    but very useful for you to know what the function does.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义之后，您可以看到三引号之间的描述；这是一个文档字符串，用于记录代码。它是可选的，但了解函数的功能非常有用。
- en: Now, let’s get back to our code. The second important thing to point out is
    the return statement. This makes the function return the values of the variables
    listed after the statement—in this case, the datasource.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的代码。需要指出的是第二个重要的事情是返回语句。这使得函数返回语句之后列出的变量的值——在这种情况下，是数据源。
- en: '**Note**'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 非常好！你刚刚创建了一段非常有用且可重用的代码。现在，你有一个可以打开任何shapefile、打印要素数量并返回ogr数据源的函数。从现在起，你可以在任何项目中重用这个函数。
- en: It’s very important that all pieces of the OGR objects flow together through
    the program.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: OGR对象的所有部分都必须通过程序流畅地连接在一起，这非常重要。
- en: In this case, if we return only the layer, for example, we will get a runtime
    error later in our program. This happens because in OGR internals, the layer has
    a reference to the data source, and when you exit a Python function, all objects
    that don’t exit the function are trashed, and this breaks the reference.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们只返回图层，例如，我们将在程序稍后运行时得到一个运行时错误。这是因为OGR内部，图层有一个数据源的引用，当你退出Python函数时，所有未退出函数的对象都会被丢弃，这会破坏引用。
- en: 'Now, the next step is to create a function that performs the transformation.
    In OGR, the transformation is made in the feature’s geometry, so we need to iterate
    over the features, get the geometry, and transform its coordinates. We will do
    this using the following steps: 1\. Add the following function to your world_areas.py
    file just after the open_shapefile function:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一步是创建一个执行转换的函数。在OGR中，转换是在要素的几何上进行，因此我们需要遍历要素，获取几何，并转换其坐标。我们将按照以下步骤进行：1.
    将以下函数添加到您的world_areas.py文件中，在open_shapefile函数之后：
- en: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
- en: '"""Transform the coordinates of all geometries in the first layer.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将第一层中所有几何的坐标进行转换。'
- en: '"""'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Part 1
  id: totrans-789
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1部分
- en: src_srs = osr.SpatialReference()
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: src_srs = osr.SpatialReference()
- en: src_srs.ImportFromEPSG(src_epsg)
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: src_srs.ImportFromEPSG(src_epsg)
- en: dst_srs = osr.SpatialReference()
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: dst_srs = osr.SpatialReference()
- en: dst_srs.ImportFromEPSG(dst_epsg)
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: dst_srs.ImportFromEPSG(dst_epsg)
- en: transformation = osr.CoordinateTransformation(src_srs, dst_srs) layer = datasource.GetLayerByIndex(0)
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: transformation = osr.CoordinateTransformation(src_srs, dst_srs) layer = datasource.GetLayerByIndex(0)
- en: Part 2
  id: totrans-795
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分
- en: geoms = []
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: geoms = []
- en: layer.ResetReading()
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: layer.ResetReading()
- en: 'for feature in layer:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in layer:'
- en: geom = feature.GetGeometryRef().Clone()
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: geom = feature.GetGeometryRef().Clone()
- en: geom.Transform(transformation)
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: geom.Transform(transformation)
- en: geoms.append(geom)
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: geoms.append(geom)
- en: return geoms
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: return geoms
- en: 'The function takes three arguments: the ogr layer, the EPSG code of the coordinate
    system of the file, and the EPSG code for the transformation output.'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受三个参数： ogr图层，文件坐标系统的EPSG代码，以及转换输出的EPSG代码。
- en: Here, it created an osr.CoordinateTransformation object; this object contains
    the instructions to perform the transformation.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它创建了一个osr.CoordinateTransformation对象；此对象包含执行转换的指令。
- en: Probably by now, Pycharm should be complaining that osr is an unresolved reference;
    osr is the part of GDAL that deals with coordinate systems.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 可能到现在为止，Pycharm应该会抱怨osr是一个未解析的引用；osr是GDAL处理坐标系统的一部分。
- en: '2\. Now, import the module by adding this line at the top of your code: **import
    osr**'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，通过在代码顶部添加此行来导入模块：**import osr**
- en: Here, the code iterates over all features, gets a reference to the geometry,
    and performs the transformation. As we don’t want to change the original data,
    the geometry is cloned, and the transformation is made on the clone.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码遍历所有要素，获取几何引用，并执行转换。由于我们不希望更改原始数据，几何被克隆，转换在克隆上进行。
- en: Python lists are ordered; this means that the elements are in the same order
    in which they are appended to the list, and this order is always kept. This allows
    us to create a list of geometries in the same order of the features that are in
    the data source. This means that the geometries in the list and the features have
    the same index and can be related in the future by the index.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表是有序的；这意味着元素是按照它们添加到列表中的顺序排列的，并且这个顺序始终保持不变。这允许我们创建一个几何列表，其顺序与数据源中要素的顺序相同。这意味着列表中的几何和要素具有相同的索引，并且可以通过索引在未来关联。
- en: '3\. Now, let’s test the code; add the following lines at the end of the file
    (the first line is the one that you already added before):'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，让我们测试代码；在文件末尾添加以下行（第一行是您之前添加的）：
- en: datasource = open_shapefile("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = open_shapefile("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
- en: feature = layer.GetFeature(0)
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: feature = layer.GetFeature(0)
- en: print("Before transformation:")
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: print("转换前：")
- en: print(feature.GetGeometryRef())
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: print(feature.GetGeometryRef())
- en: transformed_geoms = transform_geometries(datasource, 4326, 3395) print("After
    transformation:")
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: transformed_geoms = transform_geometries(datasource, 4326, 3395) print("转换后：")
- en: print(transformed_geoms[0])
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: print(transformed_geoms[0])
- en: '4\. Finally, before you run the code, add one more import at the beginning
    of the program. It should be the first statement of your code, as follows: from
    __future__ import print_function'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 最后，在运行代码之前，在程序开头添加一个额外的导入。它应该是您代码的第一个语句，如下所示：from __future__ import print_function
- en: This import allows us to use the print() function from Python 3 with the desired
    behavior, thus maintaining the compatibility.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入允许我们使用 Python 3 的 print() 函数并具有期望的行为，从而保持兼容性。
- en: '5\. The complete code should look similar to this:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 完整的代码应该看起来像这样：
- en: from __future__ import print_function
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: from __future__ import print_function
- en: import ogr
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: import ogr
- en: import osr
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: import osr
- en: 'def open_shapefile(file_path):'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 'def open_shapefile(file_path):'
- en: '...'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
- en: '...'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: datasource = open_shapefile("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = open_shapefile("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
- en: feature = layer.GetFeature(0)
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: feature = layer.GetFeature(0)
- en: print("Before transformation:")
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: print("变换前：")
- en: print(feature.GetGeometryRef())
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: print(feature.GetGeometryRef())
- en: transformed_geoms = transform_geometries(datasource, 4326, 3395) print("After
    transformation:")
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: transformed_geoms = transform_geometries(datasource, 4326, 3395) print("After
    transformation:")
- en: print(transformed_geoms[0])
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: print(transformed_geoms[0])
- en: '6\. Run your program again by pressing *Shift* + *F10*. In the output, note
    the difference in the coordinates before and after the transformation:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 通过按 *Shift* + *F10* 重新运行你的程序。在输出中，注意变换前后的坐标差异：
- en: '**Opening ../data/world_borders_simple.shp**'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开 ../data/world_borders_simple.shp**'
- en: '**Number of features: 246**'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '**特征数量：246**'
- en: '**Before transformation:**'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换前：**'
- en: '**MULTIPOLYGON (((-61.686668 17.024441000000138… )))**'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**MULTIPOLYGON (((-61.686668 17.024441000000138… )))**'
- en: '**After transformation:**'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换后：**'
- en: '**MULTIPOLYGON (((-6866928.4704937246… )))**'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '**MULTIPOLYGON (((-6866928.4704937246… )))**'
- en: '**Process finished with exit code 0**'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '**Process finished with exit code 0**'
- en: '7\. Now, add another function. This function will calculate the area in square
    meters (because we will use the geometries that have coordinates in meters), convert
    the value (or not) to square kilometers or square miles, and store the values
    in another list with the same order as before. Execute the following code:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 现在，添加另一个函数。这个函数将计算具有米坐标的几何形状的面积（因为我们将使用具有米坐标的几何形状），将值（或不是）转换为平方公里或英里，并将值存储在另一个列表中，顺序与之前相同。执行以下代码：
- en: 'def calculate_areas(geometries, unity=''km2''):'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_areas(geometries, unity=''km2''):'
- en: '"""Calculate the area for a list of ogr geometries."""'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算 ogr 几何形状列表的面积。”'
- en: Part 1
  id: totrans-843
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: conversion_factor = {
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: conversion_factor = {
- en: '''sqmi'': 2589988.11,'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '''sqmi'': 2589988.11,'
- en: '''km2'': 1000000,'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '''km2'': 1000000,'
- en: '''m'': 1}'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '''m'': 1}'
- en: Part2
  id: totrans-848
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: 'if unity not in conversion_factor:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 'if unity not in conversion_factor:'
- en: raise ValueError(
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError(
- en: '"This unity is not defined: {}".format(unity))'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '"这个单位未定义：{}".format(unity))'
- en: Part 3
  id: totrans-852
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分
- en: areas = []
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: areas = []
- en: 'for geom in geometries:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 'for geom in geometries:'
- en: area = geom.Area()
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: area = geom.Area()
- en: areas.append(area / conversion_factor[unity])
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: areas.append(area / conversion_factor[unity])
- en: return areas
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: return areas
- en: Firstly, note that in the function definition, we use unity='km2'; this is a
    keyword argument, and when you call the functions, this argument is optional.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，在函数定义中，我们使用 unity='km2'；这是一个关键字参数，当你调用函数时，这个参数是可选的。
- en: In Part 1, a dictionary is used to define a few conversion factors for the area
    unit.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，使用字典定义了一些面积单位的转换系数。
- en: Feel free to add more units if you wish. By the way, Python doesn’t care if
    you use single or double quotes.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 随意添加更多单位，如果需要的话。顺便说一句，Python 不关心你使用单引号还是双引号。
- en: In Part 2, a verification is made to check whether the passed unity exists and
    whether it is defined in conversion_factor. Another way of doing this is catching
    the exception later; however, for now, let’s opt for readability.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，进行验证以检查传递的单位是否存在并且是否在 conversion_factor 中定义。另一种方法是稍后捕获异常；然而，现在我们选择可读性。
- en: In Part 3, the code iterates the ogr geometries, calculates the area, converts
    the values, and puts it on a list.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三部分，代码迭代 ogr 几何形状，计算面积，转换值，并将其放在列表中。
- en: 8\. Now, to test the code, edit your first line, including division to the future
    imports.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 现在，为了测试代码，编辑你的第一行，包括将导入语句移到未来。
- en: This will ensure that all divisions return floating point numbers and not integers.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保所有除法都返回浮点数而不是整数。
- en: 'Here’s how it should look:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像这样：
- en: from __future__ import print_function, division
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: from __future__ import print_function, division
- en: '9\. Then, update the testing part of your code to the following: datasource
    = open_shapefile("../data/world_borders_simple.shp") transformed_geoms = transform_geometries(datasource,
    4326, 3395) calculated_areas = calculate_areas(transformed_geoms, unity=''sqmi'')
    print(calculated_areas)'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 9. 然后，更新您的代码的测试部分，如下所示：datasource = open_shapefile("../data/world_borders_simple.shp")
    transformed_geoms = transform_geometries(datasource, 4326, 3395) calculated_areas
    = calculate_areas(transformed_geoms, unity='sqmi') print(calculated_areas)
- en: 10\. Run it, change the unity, then run again, and note how the results change.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 运行它，更改单位，然后再次运行，注意结果如何变化。
- en: Very well, unity conversion is another very important procedure in geoprocessing,
    and you just implemented it in your calculate_areas function.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，单位转换是地理处理中的另一个非常重要的程序，您已经在calculate_areas函数中实现了它。
- en: However, having a list of numbers as the output is not very useful to us. So,
    it’s time to combine everything that we did so far in order to extract valuable
    information.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以数字列表作为输出对我们来说并不很有用。因此，现在是时候将我们迄今为止所做的一切结合起来，以便提取有价值的信息。
- en: '**Sort the countries by area size**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**按面积大小排序国家**'
- en: 'You programmed three functions so far; now, let’s add another one to our list
    by converting the code that generated a list of country names to a function and
    add this function to world_areas.py, as follows:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经编写了三个函数；现在，让我们通过将生成国家名称列表的代码转换为函数并将其添加到world_areas.py中，来添加另一个函数到我们的列表中，如下所示：
- en: 'def get_country_names(datasource):'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_country_names(datasource):'
- en: '"""Returns a list of country names."""'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回一个国家名称列表。"""'
- en: layer = datasource.GetLayerByIndex(0)
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: layer = datasource.GetLayerByIndex(0)
- en: country_names = []
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: country_names = []
- en: layer.ResetReading()
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: layer.ResetReading()
- en: 'for feature in layer:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in layer:'
- en: country_names.append(feature.GetFieldAsString(4))
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: country_names.append(feature.GetFieldAsString(4))
- en: return country_names
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: return country_names
- en: 'Now, we have four functions, which are:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有四个函数，它们是：
- en: open_shapefile
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: open_shapefile
- en: transform_geometries
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: transform_geometries
- en: calculate_areas
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: calculate_areas
- en: get_country_names
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: get_country_names
- en: All these functions return iterables, with each item sharing the same index
    on all of them, thus making it easy to combine the information.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都返回可迭代对象，每个项目在所有这些对象中共享相同的索引，这使得信息组合变得容易。
- en: 'So, let’s take advantage of this feature to sort the countries by area size
    and return a list of the five biggest countries and their areas. For this, add
    another function, as follows: def get_biggest_countries(countries, areas, elements=5):'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，让我们利用这个特性按面积大小对国家进行排序，并返回五个最大国家和它们的面积列表。为此，添加另一个函数，如下所示：def get_biggest_countries(countries,
    areas, elements=5):'
- en: '"""Returns a list of n countries sorted by area size."""'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回一个按面积大小排序的国家列表。"""'
- en: countries_list = [list(country)
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: countries_list = [list(country)
- en: for country in zip(areas, countries)]
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: for country in zip(areas, countries)]
- en: sorted_countries = sorted(countries_list,
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: sorted_countries = sorted(countries_list,
- en: key=itemgetter(0), reverse=True)
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: key=itemgetter(0), reverse=True)
- en: return sorted_countries[:5]
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: return sorted_countries[:5]
- en: In the first line, the two lists are zipped together, producing a list of country-area
    pairs.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，两个列表被合并在一起，生成一个国家-面积对的列表。
- en: Then, we used the Python list’s sorted method, but as we don’t want the lists
    to be sorted by both values, we will define the key for sorting. Finally, the
    list is sliced, returning only the desired number of values.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了Python列表的sorted方法，但因为我们不希望列表按两个值排序，我们将定义排序的键。最后，列表被切片，只返回所需数量的值。
- en: '1\. In order to run this code, you need to import the itemgetter function and
    put it at the beginning of the code but after from __future__ imports, as follows:
    from operator import itemgetter'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 为了运行此代码，您需要导入itemgetter函数并将其放在代码的开头，但在from __future__导入之后，如下所示：from operator
    import itemgetter
- en: '2\. Now, edit the testing part of your code to look similar to the following:
    datasource = open_shapefile("../data/world_borders_simple.shp") transformed_geoms
    = transform_geometries(datasource, 4326, 3395) country_names = get_country_names(datasource)'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，编辑您的代码的测试部分，使其看起来类似于以下内容：datasource = open_shapefile("../data/world_borders_simple.shp")
    transformed_geoms = transform_geometries(datasource, 4326, 3395) country_names
    = get_country_names(datasource)
- en: country_areas = calculate_areas(transformed_geoms)
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: country_areas = calculate_areas(transformed_geoms)
- en: biggest_countries = get_biggest_countries(country_names,
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: biggest_countries = get_biggest_countries(country_names,
- en: 'country_areas) for item in biggest_countries:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 'country_areas) for item in biggest_countries:'
- en: print("{}\t{}".format(item[0], item[1]))
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: print("{}\t{}".format(item[0], item[1]))
- en: '3\. Now, run the code and take a look at the results, as follows: Opening ../data/world_borders_simple.shp'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，运行代码并查看结果，如下所示：打开../data/world_borders_simple.shp
- en: 'Number of features: 246'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：246
- en: 82820725.1423 Russia
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 82820725.1423 俄罗斯
- en: 51163710.3726 Canada
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 51163710.3726 加拿大
- en: 35224817.514 Greenland
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 35224817.514 格陵兰
- en: 21674429.8403 United States
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 21674429.8403 美国
- en: 14851905.8596 China
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 14851905.8596 中国
- en: Process finished with exit code 0
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码 0 完成
- en: '**Summary**'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we had a brief introduction to the libraries and packages that
    we will use in this book. By installing these libraries, you also learned the
    general procedure of how to search and install Python packages. You can use this
    procedure in other cases whenever you feel the need for other libraries in your
    applications.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了我们将在这本书中使用到的库和包。通过安装这些库，您也学习了如何搜索和安装 Python 包的一般步骤。您可以在需要其他库的情况下使用此过程。
- en: Then, we wrote code that made use of the OGR library to open a shapefile and
    perform area calculation and sorting. These simple procedures showed a little
    bit of the internal organization of OGR, how it handles geographic data, and how
    it is possible to extract information from them. In the next chapter, we will
    use some of the techniques learned here to read data and process vector points.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们编写了利用 OGR 库打开 shapefile 并执行面积计算和排序的代码。这些简单的程序展示了 OGR 的内部组织结构，它如何处理地理数据，以及如何从中提取信息。在下一章中，我们将使用在这里学到的某些技术来读取数据和处理矢量点。
- en: '**Chapter 2\. The Geocaching App**'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二章：地理藏宝应用程序**'
- en: In this chapter, we will build a geocaching app that will initially get geocache
    points from the Internet and return the coordinates and information on the point
    closest to a user’s location.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个地理藏宝应用程序，它最初将从互联网获取地理藏宝点，并返回用户位置最近的点的坐标和信息。
- en: 'We will go through some of the most important steps in every geoprocessing
    application: we will discuss opening files, reading information, preparing data
    for analysis, and performing calculations with each object in your data. To achieve
    this, you will learn how to organize your code with Python and use the resources
    provided by the language to write consistent applications.'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍每个地理处理应用程序中的一些最重要的步骤：我们将讨论打开文件、读取信息、准备数据分析，以及使用数据中的每个对象进行计算。为了实现这一点，您将学习如何使用
    Python 组织代码并使用语言提供的资源编写一致的应用程序。
- en: 'In this chapter, we will start to make use of classes, methods, functions,
    decorators, and exception handling, which will help us build an application with
    reusable components and clean code. Don’t worry if these terms are new to you;
    they will be explained in the examples. In short, here’s what we will cover:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用类、方法、函数、装饰器和异常处理，这些将帮助我们构建具有可重用组件和整洁代码的应用程序。如果您对这些术语不熟悉，它们将在示例中解释。简而言之，以下是我们将涵盖的内容：
- en: Programming the basic application structures
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 编程基本应用程序结构
- en: Downloading geocaching data
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 下载地理藏宝数据
- en: Opening geocaching files and getting their contents
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 打开地理藏宝文件并获取其内容
- en: Combining functions into an application
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数组合成应用程序
- en: Setting your current location
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您的当前位置
- en: Handling exceptions
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常
- en: Finding the closest point
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找最近的点
- en: '**Building the basic application structure** There are two main reasons to
    define a good basic structure for our application: It keeps our code organized'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建基本应用程序结构** 定义我们应用程序的良好基本结构有两个主要原因：它使我们的代码保持组织'
- en: It allows us to reuse pieces of code in later applications
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们在后续应用程序中重用代码片段
- en: Python is a flexible language in terms of code organization, and although users
    are allowed to write the whole application in a single file, it’s preferable to
    separate the functionalities into modules and packages.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在代码组织方面是一种灵活的语言，尽管用户被允许在一个文件中编写整个应用程序，但最好是将功能分离成模块和包。
- en: Modules are Python files that contain classes and functions that can be imported
    into another file with the import statement. Packages are special directories
    (folders) that contain modules. This leads to organized and well-structured code
    that is less prone to having bugs and is easier to maintain.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是包含可以导入到另一个文件中的类和函数的 Python 文件。包是包含模块的特殊目录（文件夹）。这导致代码组织良好、结构合理，更不容易出现错误，并且更容易维护。
- en: The proposed structure is to have a folder for each chapter. Inside it, we can
    create packages or files for each application; we will create a package for a
    common utility code that can be imported and reused and a directory to perform
    experiments.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的结构是每个章节都有一个文件夹。在其内部，我们可以为每个应用程序创建包或文件；我们将创建一个用于可以导入和重用的通用实用代码的包，以及一个用于进行实验的目录。
- en: '**Creating the application tree structure** Here are the steps that you need
    to perform:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建应用程序树结构** 这里是你需要执行的步骤：'
- en: If you went through [Chapter 1](#p45), *Preparing the Work Environment*, you
    should now have a PyCharm project named geopy with the Chapter1 and data directories
    located at C:\geopy in Windows or ~/geopy in Linux. Start PyCharm and open your
    project.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了[第 1 章](#p45)，*准备工作环境*，你现在应该有一个名为 geopy 的 PyCharm 项目，在 Windows 中位于 C:\geopy，在
    Linux 中位于 ~/geopy。启动 PyCharm 并打开你的项目。
- en: In the project root (the uppermost folder named geopy), right-click, select
    **New** |
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录（名为 geopy 的最顶层文件夹），右键单击，选择 **新建** |
- en: '**Directory**, and name it Chapter2\.'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**，并将其命名为 Chapter2\.'
- en: Right-click on Chapter2, select **New** | **Directory**, and name it experiments.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击 Chapter2，选择 **新建** | **目录**，并将其命名为 experiments。
- en: Again, right-click inside the Chapter2 directory; this time, select **New**
    | **Python** **Package** and name it utils.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在 Chapter2 目录内右键单击；这次，选择 **新建** | **Python 包**，并将其命名为 utils。
- en: 'Now, you should have a tree structure similar to this:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该有一个类似以下的树状结构：
- en: \geopy
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: \geopy
- en: +---Chapter1
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: +---Chapter1
- en: '| world_areas.py'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '| world_areas.py'
- en: '| world_borders.py'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '| world_borders.py'
- en: '|'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: +---Chapter2
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: +---Chapter2
- en: '| |'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '| |'
- en: '| \---experiments'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '| \---experiments'
- en: '| \---utils'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '| \---utils'
- en: '|'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: +---data
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: +---data
- en: '**Note**'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**Python Packages**'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 包**'
- en: Packages are special folders that contain another packages and modules. They
    are directories with a special file called __init__.py. This file may be empty
    and is used to denote that the package can be imported with the import statement.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 包是包含其他包和模块的特殊文件夹。它们是包含特殊文件 __init__.py 的目录。此文件可能为空，并用于表示该包可以用 import 语句导入。
- en: For example, if we have a directory called foo (with a __init__.py file) and
    we create a bar.py file inside it, we can later use import foo.bar or from foo
    import bar in our code.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个名为 foo 的目录（包含 __init__.py 文件）并且我们在其中创建了一个 bar.py 文件，我们可以在代码中稍后使用 import
    foo.bar 或 from foo import bar。
- en: '**Functions and methods**'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数和方法**'
- en: Functions and methods (which are functions inside classes) should be concise
    so that when you call them, you can trust that you will get the desired results
    or appropriate exceptions. The programmer doesn’t want to check the function’s
    contents every time they use it; they want to call it and get the anticipated
    results, which is called taking *the leap of* *faith*. For example, in this book,
    we use many external packages; when we use a given function of a package, we trust
    that this function will do what it’s supposed to do or raise an error telling
    us that something went wrong. Anything besides this is called *unexpected* *behavior*,
    and this is the most dangerous type of bug that an application can have because
    it is passed silently but has consequences later in code.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法（类内部的函数）应该简洁，这样当你调用它们时，你可以相信你会得到期望的结果或适当的异常。程序员不希望在每次使用函数时都检查函数的内容；他们希望调用它并得到预期的结果，这被称为**信仰跳跃**。例如，在这本书中，我们使用了多个外部包；当我们使用包的给定函数时，我们信任这个函数会做它应该做的事情或引发错误告诉我们出了什么问题。除此之外的一切都称为**意外行为**，这是应用程序可能具有的最危险的错误类型，因为它在代码中静默传递，但后来有后果。
- en: '**Tip**'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'So far, we saw a module that may have this kind of unexpected behavior: GDAL/OGR.'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了一个可能具有这种意外行为的模块：GDAL/OGR。
- en: The ogr.Open() function is passed silently even if the file doesn’t exist, unless
    we specifically tell OGR that we want it to raise exceptions for us.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 即使文件不存在，ogr.Open() 函数也会静默传递，除非我们明确告诉 OGR 我们希望它为我们引发异常。
- en: '**Documenting your code**'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '**记录你的代码**'
- en: 'As the application starts to gain scale, it’s very important to keep track
    of what each piece of code does. This prevents the programmer from repeating code
    and saves a lot of time later trying to find out what is going on. Also, it allows
    other people to use and improve your code. There are two crucial tools that can
    be used to document the code, and we had a glimpse of it in the first chapter:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序规模的扩大，跟踪每段代码的功能非常重要。这可以防止程序员重复代码，并在以后节省大量时间来查找发生了什么。此外，它还允许其他人使用和改进你的代码。有两种关键的工具可以用来记录代码，我们已经在第一章中简要介绍过：
- en: '**Code comments**: These are the comments inserted in code with the # symbol.'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码注释**：这些是用#符号插入代码中的注释。'
- en: 'Everything from this symbol to the next line is a comment and will be ignored
    when the program runs. The Python syntax is intuitive, and a well-written code
    requires a few comments. Here are two tips to concisely comment your code: Place
    a comment before each logical block of code telling what it’s doing Comment pieces
    of code that are hard to read or understand'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 从此符号到下一行的所有内容都是注释，并且在程序运行时将被忽略。Python语法直观，良好的代码需要少量注释。以下有两个简洁注释代码的技巧：在每个逻辑代码块之前放置注释，说明它在做什么；注释难以阅读或理解的代码片段
- en: '**Docstrings**: Docstrings are texts placed in special locations in document
    classes, functions, and methods. They have a special meaning because they can
    be interpreted by some programs and used to provide the user with help and automatically
    generate documentation. Docstrings can also be used to test your code, but this
    will not be covered in this book. In PyCharm, docstrings have a special purpose
    and provide hints for automatic code inspection. Within docstrings, you can specify
    parameters and return types (for example, strings, list, and dictionary). PyCharm
    uses this to make auto-complete suggestions and warn you about possible mistakes.'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档字符串**：文档字符串是放置在文档类、函数和方法特殊位置的文本。它们有特殊的意义，因为它们可以被某些程序解释并用于向用户提供帮助和自动生成文档。文档字符串还可以用来测试你的代码，但这本书不会涉及这一点。在PyCharm中，文档字符串有特殊的作用，并提供自动代码检查的提示。在文档字符串中，你可以指定参数和返回类型（例如，字符串、列表和字典）。PyCharm使用这些信息来提供自动完成建议并警告你可能的错误。'
- en: '**Tip**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: In this book, we will use the reStructuredText type of markup for docstrings;
    you can find more information at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用reStructuredText类型的标记来编写文档字符串；你可以在[http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html)找到更多信息。
- en: 'In the following example, you can note a class and method documented with docstrings
    (you don’t need to type this code):'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，你可以注意到一个使用文档字符串进行文档化的类和方法（你不需要输入此代码）：
- en: 'class MyClass:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MyClass:'
- en: '"""This is an example of a docstring of a class."""'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这是一个类的文档字符串示例。”'
- en: 'def __init__(self):'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: '"""You can also put docstrings in the __init__ method."""'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '"""你还可以在__init__方法中放置文档字符串。”'
- en: pass
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'def sum_values(self, arg1, arg2):'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 'def sum_values(self, arg1, arg2):'
- en: '"""This is the docstring for a method, you can describe the arguments and specify
    its types.'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这是方法的文档字符串，你可以描述参数并指定其类型。'
- en: If you do so, PyCharm will use that information
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，PyCharm将使用这些信息
- en: for autocomplete and to check your code.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 用于自动完成和检查代码。
- en: ':param float arg1: The first argument.'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: ':参数 float arg1: 第一个参数。'
- en: ':param float arg2: The second argument.'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: ':参数 float arg2: 第二个参数。'
- en: ':returns float: The sum of the arguments.'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: ':返回 float: 参数的总和。'
- en: '"""'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: return arg1 + arg2
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: return arg1 + arg2
- en: '**Creating the application entry point**'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建应用程序入口点**'
- en: The entry point of an application is the first thing executed when you run the
    program. In Python, it’s the first line of code. We can write an application that
    runs top-down, mixing function and class declarations along with other statements,
    but this would make the code harder to develop and debug, especially when it starts
    to grow more complex. It would be a better idea if we explicitly show where the
    program starts, and from this point, different parts of the program will be called
    as needed.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的入口点是当你运行程序时首先执行的部分。在Python中，它是第一行代码。我们可以编写一个自上而下运行的程序，将函数和类声明与其他语句混合，但这会使代码更难开发和调试，尤其是在代码变得复杂时。如果我们明确地显示程序开始的地方，并且从这个点开始，程序的不同部分将根据需要被调用，那会更好。
- en: 'Let’s do an experiment to understand some points on how the code is executed
    and modules are imported:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个实验来理解一些关于代码执行和模块导入的要点：
- en: 1\. Inside your Chapter2/experiments folder, create two new files named import_test.py
    and module_test.py. To do this, right-click inside the experiments folder and
    choose **New** | **Python file**.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在你的Chapter2/experiments文件夹内，创建两个新的文件，命名为import_test.py和module_test.py。为此，在experiments文件夹内右键单击并选择**新建**
    | **Python文件**。
- en: 2\. Double-click on module_test.py to open it for editing.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 双击module_test.py以打开它进行编辑。
- en: '3\. Now, type the following code:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 现在，输入以下代码：
- en: coding=utf-8
  id: totrans-985
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: 'print "I''m module_test.py and my name is: " + __name__'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 'print "我是module_test.py，我的名字是: " + __name__'
- en: 'def function1():'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 'def function1():'
- en: print "Hi, I'm inside function1."
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: print "Hi, I'm inside function1."
- en: print "Calling function1…"
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: print "调用function1…"
- en: function1()
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: function1()
- en: Every module contains a __name__ attribute, and we will print its value in the
    first line of the code of this test.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都包含一个__name__属性，我们将在测试代码的第一行打印其值。
- en: Next, we will declare a function that, when called, prints "Hi, I'm inside function1."
    to the output.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明一个函数，当调用时，将"Hi, I'm inside function1."打印到输出。
- en: Finally, we will print that the function will be called, and then we will call
    function1\.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将打印出函数将被调用，然后我们将调用function1\.
- en: '4\. Run the code, press *Alt* + *Shift* + *F10* and choose module_test from
    the list. Take a look at the output:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 运行代码，按*Alt* + *Shift* + *F10*并从列表中选择module_test。查看输出：
- en: 'I''m module_test.py and my name is: __main__'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '我是module_test.py，我的名字是: __main__'
- en: Calling function1…
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 调用function1…
- en: Hi, I'm inside function1\.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: Hi, I'm inside function1\.
- en: Process finished with exit code 0
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: '**Note**'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Note here that the __name__ attribute is equal to __main__; this is a special
    condition in Python. The module (the file) that is run is always called __main__.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，__name__属性等于__main__；这是Python中的一个特殊条件。运行的模块（文件）总是被调用为__main__。
- en: '5\. To understand more about this mechanism, create a new Python file inside
    the experiments folder, name it import_test.py, and open it for editing. Now,
    type the following code:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 要了解更多关于这个机制的信息，在experiments文件夹内创建一个新的Python文件，命名为import_test.py，并打开它进行编辑。现在，输入以下代码：
- en: coding=utf-8
  id: totrans-1002
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: 'print "I''m import_test.py and my name is: " + __name__'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 'print "我是import_test.py，我的名字是: " + __name__'
- en: print "Importing module_test"
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: print "导入module_test"
- en: import module_test
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: import module_test
- en: print "Calling function1 from within import_test"
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: print "从import_test中调用function1"
- en: module_test.function1()
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: module_test.function1()
- en: '6\. Now, run import_test.py (press *Alt* + *Shift* + *F10* and select it from
    the list) and take a look the following output:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 现在，运行import_test.py（按*Alt* + *Shift* + *F10*并从列表中选择它）并查看以下输出：
- en: 'I''m import_test.py and my name is: __main__'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '我是import_test.py，我的名字是: __main__'
- en: Importing module_test
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 导入module_test
- en: 'I''m module_test.py and my name is: module_test'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '我是module_test.py，我的名字是: module_test'
- en: Calling function1…
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 调用function1…
- en: Hi, I'm inside function1\.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: Hi, I'm inside function1\.
- en: Calling function1 from within import_test
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 从import_test中调用function1
- en: Hi, I'm inside function1\.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: Hi, I'm inside function1\.
- en: Process finished with exit code 0
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: This time it is import_test that is called __main__ because it is the file that
    is executed. Next, when we import module_test, the code in it is executed. Note
    that module_test is not called __main__ anymore; it’s called module_test.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 这次是import_test被调用为__main__，因为它是被执行的文件。接下来，当我们导入module_test时，其中的代码将被执行。注意，module_test不再被调用为__main__；它被调用为module_test。
- en: 'The behavior of this special __name__ attribute allows us to implement a technique
    in Python, which in turn allows us to execute some code when a file is run directly
    and avoid this code’s execution when this same file is imported. Let’s see how
    this works: 7\. Edit module_test.py and change its code, as follows:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的__name__属性的行为允许我们在Python中实现一种技术，这反过来又允许我们在文件直接运行时执行一些代码，并避免在导入此文件时执行此代码。让我们看看它是如何工作的：7\.
    编辑module_test.py并更改其代码，如下所示：
- en: coding=utf-8
  id: totrans-1019
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: 'print "I''m module_test.py and my name is: " + __name__'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 'print "我是module_test.py，我的名字是: " + __name__'
- en: 'def function1():'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 'def function1():'
- en: print "Hi, I'm inside function1."
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: print "Hi, I'm inside function1."
- en: 'if __name__ == ''__main__'':'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: print "Calling function1 - only if i'm __main__…"
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: print "调用function1 - 只有如果我是 __main__…"
- en: function1()
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: function1()
- en: So, if __name__ is equal to '__main__', the code inside this block is executed,
    and
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果__name__等于'__main__'，则这个块内的代码将被执行，
- en: we know that __name__ is __main__ only when the file is executed directly.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，只有当文件直接执行时，__name__才等于__main__。
- en: Therefore, the code inside this block is executed only when the file is run
    and not when it’s imported.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个块内的代码只有在文件被运行时才会执行，而不是在导入时执行。
- en: '8\. Next, run import_test.py again (to rerun the last file, press *Shift* +
    *F10*), and take a look at what happens:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. 接下来，再次运行import_test.py（要重新运行最后一个文件，请按*Shift* + *F10*），看看会发生什么：
- en: 'I''m import_test.py and my name is: __main__'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 我是import_test.py，我的名字是：__main__
- en: Importing module_test
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 导入module_test
- en: 'I''m module_test.py and my name is: module_test'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 我是module_test.py，我的名字是：module_test
- en: Calling function1 from within import_test
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 在import_test中调用function1
- en: Hi, I'm inside function1\.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: Hi, I'm inside function1\.
- en: Process finished with exit code 0
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 进程已结束，退出代码为0
- en: '9\. Now, run module_test.py (to choose the file to run, press *Alt* + *Shift*
    + *F10*) and look at the output:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. 现在，运行module_test.py（要选择要运行的文件，请按*Alt* + *Shift* + *F10*）并查看输出：
- en: 'I''m module_test.py and my name is: __main__'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 我是module_test.py，我的名字是：__main__
- en: Calling function1 - only if i'm __main__…
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我是__main__时调用function1 - ...
- en: Hi, I'm inside function1\.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: Hi, I'm inside function1\.
- en: Process finished with exit code 0
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 进程已结束，退出代码为0
- en: 'As expected, the code inside the if __name__ == ''__main__'': block ran only
    when module_test.py was run directly and not when it was imported.'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '如预期，当直接运行module_test.py时，if __name__ == ''__main__'': 块内的代码才会运行，而不是当它被导入时。'
- en: Now that we know how to make an entry point explicit in Python, let’s create
    our first file for the application and make an entry point.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在Python中显式创建入口点，让我们为应用程序创建第一个文件并创建一个入口点。
- en: 10\. Create a new file inside your Chapter2 folder and name it geocaching_app.py.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. 在你的Chapter2文件夹内创建一个新文件，并将其命名为geocaching_app.py。
- en: '11\. Then, open the file to edit and insert the following piece of code:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. 然后，打开文件进行编辑并插入以下代码片段：
- en: coding=utf-8
  id: totrans-1045
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: 'def main():'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print("Hello geocaching APP!")
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello geocaching APP!")
- en: 'if __name__ == "__main__":'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: main()
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: The purpose of the main() function is to receive the initial parameters and
    then take actions so that the program executes and produces the desired results.
    The content of the main function should be minimal and should try to express a
    clear sequence of actions. This makes the application’s logic very easy to debug.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数的目的是接收初始参数，然后采取行动，以便程序执行并产生预期的结果。main函数的内容应尽可能简单，并尝试表达一系列清晰的动作。这使得应用程序的逻辑非常容易调试。
- en: '**Tip**'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: For Windows users, the if __name__ == '__main__' technique is also required
    in order for parallel processing to work; we will discuss this in [Chapter 10,](index_split_003.html#p424)
    *Parallel Processing*.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，if __name__ == '__main__'技术也是必需的，以便并行处理能够工作；我们将在第10章中讨论这一点，*并行处理*。
- en: '**Downloading geocaching data**'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载Geocaching数据**'
- en: We now have the basic application structure with an entry point; next, we will
    start writing modules that execute the tasks that the application needs to produce
    the desired results.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了基本的应用程序结构，具有一个入口点；接下来，我们将开始编写执行应用程序需要产生预期结果的任务的模块。
- en: 'The first thing that we need is to obtain some geocaching data from the Internet,
    and we want our application to do this for us. There are two common ways of doing
    this, and they are not restricted only to geocaching data. Many geographical data
    repositories can be accessed by these methods:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要从互联网上获取一些Geocaching数据，我们希望我们的应用程序为我们完成这项工作。有两种常见的方法可以做到这一点，并且它们不仅限于Geocaching数据。许多地理数据存储库可以通过这些方法访问：
- en: '**Direct download**: This is a download similar to what you do in a browser.
    There is a link, a request is made to this link, and the download starts.'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接下载**：这是一种类似于在浏览器中进行的下载。有一个链接，向该链接发出请求，然后开始下载。'
- en: '**REST API**: Many services offer this kind of data access. **REST** (**Representational**
    **State Transfer**) is a way of serving data where a client makes requests with
    a series of constraints, and the server responds with the result. It’s particularly
    useful because it allows the user to customize the data of interest.'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST API**：许多服务提供这种数据访问方式。**REST**（**表征状态转移**）是一种服务数据的方式，其中客户端通过一系列约束发出请求，服务器响应结果。它特别有用，因为它允许用户自定义感兴趣的数据。'
- en: '**Geocaching data sources**'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '**Geocaching数据源**'
- en: 'There are many sources of geocaching data on the Internet; some are commercial,
    and some are community driven. In the following table, you can note the summary
    of some of the sources available:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多Geocaching数据来源；有些是商业的，有些是社区驱动的。在下表中，你可以注意一些可用来源的摘要：
- en: '**Site**'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '**站点**'
- en: '**REST**'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**'
- en: '**Region**'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '**区域**'
- en: '[http://www.opencaching.us/](http://www.opencaching.us/)'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencaching.us/](http://www.opencaching.us/)'
- en: Y (OKAPI) Open
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: Y (OKAPI) 开放
- en: USA
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 美国
- en: '[http://opencaching.pl/](http://opencaching.pl/)'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://opencaching.pl/](http://opencaching.pl/)'
- en: Y (OKAPI) Open
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: Y (OKAPI) Open
- en: Poland
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 波兰
- en: '[http://www.opencaching.de/](http://www.opencaching.de/)'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencaching.de/](http://www.opencaching.de/)'
- en: Y (OKAPI) Open
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: Y (OKAPI) Open
- en: Denmark
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 丹麦
- en: '[http://www.opencaching.nl/](http://www.opencaching.nl/)'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencaching.nl/](http://www.opencaching.nl/)'
- en: Y (OKAPI) Open
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: Y (OKAPI) Open
- en: Netherlands
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 荷兰
- en: '[http://www.opencaching.ro/](http://www.opencaching.ro/)'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencaching.ro/](http://www.opencaching.ro/)'
- en: Y (OKAPI) Open
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: Y (OKAPI) Open
- en: Romania
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 罗马尼亚
- en: '[http://www.opencaching.it/](http://www.opencaching.it/)'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencaching.it/](http://www.opencaching.it/)'
- en: N
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: N
- en: Open
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: Open
- en: Italy
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利
- en: '[http://www.opencachingspain.es/](http://www.opencachingspain.es/) N'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencachingspain.es/](http://www.opencachingspain.es/) N'
- en: Open
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: Open
- en: Spain
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 西班牙
- en: '[http://www.opencaching.org.uk/](http://www.opencaching.org.uk/)'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencaching.org.uk/](http://www.opencaching.org.uk/)'
- en: N
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: N
- en: Open
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: Open
- en: United Kingdom
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 英国
- en: '[http://www.opencaching.cz/](http://www.opencaching.cz/)'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencaching.cz/](http://www.opencaching.cz/)'
- en: N
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: N
- en: Open
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: Open
- en: Czech Republic
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 捷克共和国
- en: '[https://www.geocaching.com/play](https://www.geocaching.com/play) Y'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.geocaching.com/play](https://www.geocaching.com/play) Y'
- en: Commercial Global
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 商业全球
- en: '**Note**'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: OKAPI is a public API project for National Opencaching sites (also known as
    **Opencaching Nodes**).
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: OKAPI是一个面向国家Opencaching网站（也称为**Opencaching节点**）的公共API项目。
- en: It provides OC sites with a set of useful, well-documented API methods, allows
    external developers to easily read public Opencaching data, allows us to read
    and write private (that is, user-related) data with OAuth 3-legged authentication.
    The project aims to become a standard API for all National Opencaching.xx sites.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 它为OC网站提供了一套有用且文档齐全的API方法，允许外部开发者轻松读取公共Opencaching数据，并允许我们使用OAuth 3-legged认证读取和写入私有（即与用户相关的）数据。该项目旨在成为所有国家Opencaching.xx网站的标准化API。
- en: '[(http://opencaching.pl/okapi/introduction.html](http://opencaching.pl/okapi/introduction.html))'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '[(http://opencaching.pl/okapi/introduction.html](http://opencaching.pl/okapi/introduction.html))'
- en: '**Fetching information from a REST API**'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '**从REST API获取信息**'
- en: We will make a simple test to fetch data from a geocaching REST API. We won’t
    go deep into communicating with REST APIs this time because all geocaching sites
    require a user key so that users can access the data; this is in order to avoid
    abuses and misuse. For now, we will have a glimpse at how this works and request
    a method that doesn’t require a key.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一个简单的测试，从地理藏宝的REST API获取数据。这次我们不会深入探讨与REST API的通信，因为所有地理藏宝网站都需要一个用户密钥，以便用户可以访问数据；这是为了避免滥用和误用。目前，我们将简要了解其工作原理，并请求一个不需要密钥的方法。
- en: 'If you are interested in accessing the download functions, you can contact
    the site and request a key. Here’s how you can do this:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对访问下载功能感兴趣，你可以联系网站并请求一个密钥。以下是你可以这样做的步骤：
- en: 1\. Create a new file inside your Chapter2/utils directory and name it data_transfer.py.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在你的Chapter2/utils目录内创建一个新文件，命名为data_transfer.py。
- en: '2\. Type this code in the file:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在文件中输入此代码：
- en: coding=utf-8
  id: totrans-1104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from pprint import pprint
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: from pprint import pprint
- en: import requests
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: import requests
- en: 'def request_api_methods():'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 'def request_api_methods():'
- en: result = requests.get(
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: result = requests.get(
- en: '"http://www.opencaching.us/okapi/services/apiref/method_index") pprint(result.json())'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '"http://www.opencaching.us/okapi/services/apiref/method_index") pprint(result.json())'
- en: 'if __name__ == "__main__":'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: request_api_methods()
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: request_api_methods()
- en: '3\. Run this file, press *Alt* + *Shift* + *F10*, and select rest_api on the
    list. Now, take a look at the results:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 运行此文件，按*Alt* + *Shift* + *F10*，并在列表中选择rest_api。现在，看看结果：
- en: '[{u''brief_description'': u''Retrieve information on given issue'', u''name'':
    u''services/apiref/issue''},'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '[{u''brief_description'': u''检索有关给定问题的信息'', u''name'': u''services/apiref/issue''},'
- en: '{u''brief_description'': u''Get information on a given OKAPI service method'','
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '{u''brief_description'': u''获取有关给定OKAPI服务方法的信息'','
- en: 'u''name'': u''services/apiref/method''},'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 'u''name'': u''services/apiref/method''},'
- en: '{u''brief_description'': u''Get a list of OKAPI methods with brief descriptions'','
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '{u''brief_description'': u''获取带有简要描述的OKAPI方法列表'','
- en: 'u''name'': u''services/apiref/method_index''},'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 'u''name'': u''services/apiref/method_index''},'
- en: '{u''brief_description'': u''Get information on this OKAPI installation'', u''name'':
    u''services/apisrv/installation''},'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '{u''brief_description'': u''获取此OKAPI安装的信息'', u''name'': u''services/apisrv/installation''},'
- en: '...'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '{u''brief_description'': u''Retrieve information on a single user'', u''name'':
    u''services/users/user''},'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '{u''brief_description'': u''检索有关单个用户的信息'', u''name'': u''services/users/user''},'
- en: '{u''brief_description'': u''Retrieve information on multiple users'', u''name'':
    u''services/users/users''}]'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '{u''brief_description'': u''检索有关多个用户的信息'', u''name'': u''services/users/users''}]'
- en: Process finished with exit code 0
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: The URL that you see is meant to retrieve a list containing the description
    of all methods exposed by the API. The module requests makes everything much easier
    for us, and the
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的URL旨在检索包含API公开的所有方法描述的列表。requests模块使我们的一切变得容易，并且
- en: 'result.json() method converts the result of our request to a Python object
    (a list of dictionaries) and pprint (that is, pretty print) prints the list one
    item per line. Note that we made use of if __name__ == ''main'': here so that
    we can test our function; later, when this function is imported by other modules,
    all the code following if name =='
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: result.json() 方法将我们的请求结果转换为Python对象（字典列表）并pprint（即，美化打印）逐行打印列表。请注意，我们使用了if __name__
    == 'main':，这样我们就可以测试我们的函数；稍后，当这个函数被其他模块导入时，所有在if name == 'main':之后的代码将不会运行，因此我们可以安全地将所有测试放在那里。
- en: '''main'': won’t run, so we can safely put all our tests there.'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '''main'': 不会运行，因此我们可以安全地将所有测试放在那里。'
- en: '**Downloading data from a URL**'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '**从URL下载数据**'
- en: 'To avoid the API key restriction in the geocaching sites and give continuity
    to our examples, we prepared some sample data that can be downloaded directly
    from a link. The function that you write downloads a file from a given URL and
    saves it to the disk. This function will be generalized and may be used by other
    applications in the future. We want to pass the following as parameters (that
    is, arguments):'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在地理藏宝网站上的API密钥限制，并使我们的示例保持连贯，我们准备了一些可以直接从链接下载的样本数据。您编写的函数将从给定的URL下载文件并将其保存到磁盘。这个函数将被通用化，并可能在未来的其他应用程序中使用。我们希望以下内容作为参数（即，参数）传递：
- en: The URL or link to the file
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的URL或链接
- en: A path to the destination folder
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件夹的路径
- en: An override to the name of the file.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 重写文件名。
- en: 'Perform the following steps:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: '1\. In the data_transfer.py file, add the download_data function and edit the
    if __name__ == ''__main__'' block. Your code should look similar to this:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在data_transfer.py文件中，添加download_data函数并编辑if __name__ == '__main__'块。您的代码应类似于以下内容：
- en: coding=utf-8
  id: totrans-1133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from pprint import pprint
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: from pprint import pprint
- en: import requests
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: import requests
- en: from os import path
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: from os import path
- en: 'def request_api_methods():'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 'def request_api_methods():'
- en: result = requests.get(
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: result = requests.get(
- en: '"http://www.opencaching.us/okapi/services/apiref/method_index") pprint(result.json())'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '"http://www.opencaching.us/okapi/services/apiref/method_index") pprint(result.json())'
- en: 'def download_data(base_url, data_path, data_filename):'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 'def download_data(base_url, data_path, data_filename):'
- en: save_file_path = path.join(data_path, data_filename)
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: save_file_path = path.join(data_path, data_filename)
- en: request = requests.get(base_url, stream=True)
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: request = requests.get(base_url, stream=True)
- en: Save the download to the disk.
  id: totrans-1143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将下载保存到磁盘。
- en: 'with open(save_file_path, ''wb'') as save_file:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(save_file_path, ''wb'') as save_file:'
- en: 'for chunk in request.iter_content(1024):'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 'for chunk in request.iter_content(1024):'
- en: save_file.write(chunk)
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: save_file.write(chunk)
- en: 'if __name__ == "__main__":'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: download_data('https://s3.amazonaws.com/geopy/geocaching.gpx',
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: download_data('https://s3.amazonaws.com/geopy/geocaching.gpx',
- en: '''../../data'','
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data'','
- en: '''geocaching_test.gpx'')'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '''geocaching_test.gpx'')'
- en: 2\. Now, run the code and check your data directory; there should be a new file
    there named geocaching_test.gpx.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，运行代码并检查您的数据目录；那里应该有一个名为geocaching_test.gpx的新文件。
- en: What happens in the function is that first, we prepare the save_file_path variable
    using the os.path function; this function takes care of concatenating paths and
    ensuring that the result is correct for every operating system. Whenever we handle
    paths in our application,
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中发生的事情是，首先，我们使用os.path函数准备save_file_path变量；这个函数负责连接路径并确保结果对每个操作系统都是正确的。每次我们在应用程序中处理路径时，
- en: we prefer using os.path.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢使用os.path。
- en: Using the requests library, we can make a request to the desired URL. The optional
    stream=True parameter tells it that we want the download to happen in chunks,
    as we request, as opposed to downloading the whole file to the memory once. This
    is important because some files may be large in size and occupy a lot of memory.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用requests库，我们可以向所需的URL发出请求。可选的stream=True参数告诉它我们希望下载以块的形式发生，正如我们请求的那样，而不是一次性将整个文件下载到内存中。这很重要，因为某些文件可能很大，会占用大量内存。
- en: Finally, a file is opened and the chunks of data are read and written to the
    disk. The with statement is also called a **context manager** because it makes
    a given resource (a file, in this case) available only inside the block. Then,
    chunks of 1024 bytes each are read and written in the file. When the program exits
    the with block, the file is automatically closed and the save_file variable is
    deleted.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开一个文件，并将数据块读取和写入磁盘。with语句也被称为**上下文管理器**，因为它只使给定的资源（在这种情况下是文件）在块内可用。然后，以每个1024字节的数据块读取和写入文件。当程序退出with块时，文件会自动关闭，save_file变量将被删除。
- en: We don’t want the application to download the file every time we run it; this
    would be a waste of time. So, in the next part, we need to implement a verification
    to make the program skip the download if there is already a file with the chosen
    name.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望每次运行应用程序时都下载文件；这将是一种时间浪费。因此，在下一部分，我们需要实现一个验证，以便在已存在具有选定名称的文件时跳过下载。
- en: 'Edit the download_data function, as follows:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`download_data`函数，如下所示：
- en: 'def download_data(base_url, data_path, data_filename):'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '`def download_data(base_url, data_path, data_filename):`'
- en: save_file_path = path.join(data_path, data_filename)
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_file_path = path.join(data_path, data_filename)`'
- en: request = requests.get(base_url, stream=True)
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '`request = requests.get(base_url, stream=True)`'
- en: Check if the file exists.
  id: totrans-1161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件是否存在。
- en: 'if path.isfile(save_file_path):'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`path.isfile(save_file_path)`：
- en: print('File already available.')
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 打印('文件已可用。')
- en: Save the download to the disk.
  id: totrans-1164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将下载保存到磁盘。
- en: 'with open(save_file_path, ''wb'') as save_file:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '`with open(save_file_path, ''wb'') as save_file:`'
- en: 'for chunk in request.iter_content(1024):'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '`for chunk in request.iter_content(1024):`'
- en: save_file.write(chunk)
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_file.write(chunk)`'
- en: 'Now, run your application again, and you should see the following output warning
    you that the file was already downloaded:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行你的应用程序，你应该会看到以下输出警告你文件已被下载：
- en: File already available.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 文件已可用。
- en: Process finished with exit code 0
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: '![Image 7](img/index-119_1.jpg)'
  id: totrans-1171
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7](img/index-119_1.jpg)'
- en: '**Downloading data manually**'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动下载数据**'
- en: Now, you may want to choose the data specifically for your region; to do this,
    you need to go to a geocaching site, filter the data, and download the file manually.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想选择特定于你所在地区的特定数据；为此，你需要访问一个地理藏宝网站，过滤数据，并手动下载文件。
- en: As an example, we will go through the process to download data from the site
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将通过从网站下载数据的过程进行说明
- en: '[http://www.opencaching.us/.](http://www.opencaching.us/) You don’t need an
    account; just follow these steps: 1\. Open the website. In the left-hand side
    menu, click on **Seek A Cache**: 2\. This will open a page containing various
    fields. First, select the limiting factors for your search using the fields shown
    in the following image:'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opencaching.us/](http://www.opencaching.us/) 你不需要账户；只需遵循以下步骤：1.
    打开网站。在左侧菜单中，点击**寻找藏宝**：2. 这将打开一个包含各种字段的页面。首先，使用以下图片中显示的字段选择你的搜索限制因素：'
- en: '![Image 8](img/index-120_1.jpg)'
  id: totrans-1176
  prefs: []
  type: TYPE_IMG
  zh: '![图片 8](img/index-120_1.jpg)'
- en: '![Image 9](img/index-120_2.jpg)'
  id: totrans-1177
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9](img/index-120_2.jpg)'
- en: 3\. Next, you need to specify a region or criteria to search for the geocaches.
    There are many alternatives to choose from, so scroll through the page and take
    a look. You can use a zip code, coordinates, a state, and others. Let’s search
    by state; select **New York** and click on **Search**.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 接下来，你需要指定一个区域或标准来搜索地理藏宝。有许多选择可供选择，所以滚动页面并查看。你可以使用邮政编码、坐标、州等。让我们按州进行搜索；选择**纽约**并点击**搜索**。
- en: '![Image 10](img/index-121_1.jpg)'
  id: totrans-1179
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10](img/index-121_1.jpg)'
- en: 4\. A list with the results will appear. Scroll to the end of the page, and
    you will note the links to download data. Choose to download **Caches From All
    Pages** in the **GPX**
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 将出现一个包含结果的列表。滚动到页面底部，你会注意到下载数据的链接。在**GPX**中选择下载**所有页面的缓存**。
- en: 'format:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 格式：
- en: '**Opening the file and getting its contents**'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开文件并获取其内容**'
- en: Now, we will open the downloaded file and prepare it for processing. This is
    something that we already did in [Chapter 1,](#p45) *Preparing the Work Environment*,
    so we will copy our function and improve it so that we can reuse it in this application
    and the ones to come.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将打开下载的文件并为其处理做准备。这是我们已经在[第1章，](#p45) *准备工作环境*中做过的事情，所以我们将复制我们的函数并改进它，以便我们可以在本应用程序以及未来的应用程序中重用它。
- en: 'Here are the steps that we will perform:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要执行的步骤：
- en: 1\. Create a new file named geo_functions.py inside the utils directory.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在`utils`目录内创建一个名为`geo_functions.py`的新文件。
- en: 2\. Open the world_areas.py file from [Chapter 1,](#p45) *Preparing the Work
    Environment*, and copy the open_shapefile function. Then, paste it into the created
    file.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 打开[第1章](#p45)中的 *Preparing the Work Environment* 的 world_areas.py 文件，并复制
    open_shapefile 函数。然后，将其粘贴到创建的文件中。
- en: 3\. Now, change the name of the function to open_vector_file so that it makes
    more sense as we will use this function to open many kinds of file. The geocaching
    file isn’t a shapefile—it’s a GPX, and to open it, we don’t need to change anything.
    OGR
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，将函数名改为 open_vector_file，这样它就更有意义了，因为我们将会使用这个函数来打开多种类型的文件。地理藏宝文件不是shapefile，而是一个GPX文件，打开它我们不需要做任何改变。OGR
- en: will handle this for us.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 将为我们处理这个问题。
- en: 4\. Now, to keep the code well documented, change the docstring to reflect the
    function’s capabilities. Change it to something similar to "Opens a vector file
    compatible with OGR, gets the first layer, and returns the OGR data source".
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 现在，为了使代码有良好的文档记录，将docstring改为反映函数的功能。改为类似“打开与OGR兼容的矢量文件，获取第一层，并返回OGR数据源”的内容。
- en: '5\. Finally, don’t forget to import the required packages. Your code should
    look similar to this:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 最后，别忘了导入所需的包。你的代码应该看起来像这样：
- en: coding=utf-8
  id: totrans-1191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import ogr
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: import ogr
- en: import osr
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: import osr
- en: 'def open_vector_file(file_path):'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 'def open_vector_file(file_path):'
- en: '"""Opens an vector file compatible with OGR, get the first layer and returns
    the ogr datasource.'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开一个与OGR兼容的矢量文件，获取第一层并返回OGR数据源。'
- en: ':param str file_path: The full path to the file.'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: ':return: The ogr datasource.'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: ':return: 返回OGR数据源。'
- en: '"""'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: datasource = ogr.Open(file_path)
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = ogr.Open(file_path)
- en: layer = datasource.GetLayerByIndex(0)
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: layer = datasource.GetLayerByIndex(0)
- en: print("Opening {}".format(file_path))
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: print("打开 {}".format(file_path))
- en: 'print("Number of features: {}".format('
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("特征数量: {}".format('
- en: layer.GetFeatureCount()))
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: layer.GetFeatureCount()))
- en: return datasource
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: return datasource
- en: 'if __name__ == "__main__":'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: open_vector_file("../../data/geocaching.gpx")
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: open_vector_file("../../data/geocaching.gpx")
- en: '6\. Run the code again, and you should see the following output (don’t worry
    about the warnings):'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 再次运行代码，你应该会看到以下输出（不用担心警告信息）：
- en: Opening ../data/geocaching.gpx
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 ../data/geocaching.gpx
- en: 'Warning 1: Could not parse {2010-10-01T00:00:00Z} as a valid dateTime Warning
    1: Could not parse {2011-04-10T00:00:00Z} as a valid dateTime'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 1：无法解析 {2010-10-01T00:00:00Z} 为有效的dateTime 警告 1：无法解析 {2011-04-10T00:00:00Z}
    为有效的dateTime
- en: 'Warning 1: Could not parse {2010-11-21T00:00:00Z} as a valid dateTime Number
    of features: 130'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '警告 1：无法解析 {2010-11-21T00:00:00Z} 为有效的dateTime 特征数量: 130'
- en: 'Warning 1: Could not parse {2010-11-22T00:00:00Z} as a valid dateTime'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 1：无法解析 {2010-11-22T00:00:00Z} 为有效的dateTime
- en: '**Preparing the content for analysis**'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '**准备分析内容**'
- en: This application makes use of distances such as meters or miles, so we do not
    want our measurements to be in degrees. Most geocaching coordinates and point
    data come in degrees, so we need to convert the coordinate system into the metric
    system.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序使用米或英里等距离，所以我们不希望我们的测量结果以度为单位。大多数地理藏宝坐标和点数据都是以度为单位，因此我们需要将坐标系转换为公制系统。
- en: 'To do this, we will start by using a function from [Chapter 1](#p45), *Preparing
    the Work* *Environment*: transform_geometries. Perform the following: 1\. Copy
    this function and paste it into the geo_functions.py file. This function will
    iterate over the features in the data to get its geometry and then convert the
    coordinate system, returning a list with all of the converted geometries. The
    function should look similar to this:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将首先使用[第1章](#p45)中的函数 *Preparing the Work Environment*：transform_geometries。执行以下操作：1.
    复制此函数并将其粘贴到 geo_functions.py 文件中。这个函数将遍历数据中的特征以获取其几何形状，然后转换坐标系，返回包含所有转换几何形状的列表。函数看起来应该像这样：
- en: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
- en: '"""Transform the coordinates of all geometries in the first layer.'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '"""转换第一层中所有几何形状的坐标。'
- en: '"""'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Part 1
  id: totrans-1218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: src_srs = osr.SpatialReference()
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: src_srs = osr.SpatialReference()
- en: src_srs.ImportFromEPSG(src_epsg)
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: src_srs.ImportFromEPSG(src_epsg)
- en: dst_srs = osr.SpatialReference()
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: dst_srs = osr.SpatialReference()
- en: dst_srs.ImportFromEPSG(dst_epsg)
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: dst_srs.ImportFromEPSG(dst_epsg)
- en: transformation = osr.CoordinateTransformation(src_srs, dst_srs) layer = datasource.GetLayerByIndex(0)
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: transformation = osr.CoordinateTransformation(src_srs, dst_srs) layer = datasource.GetLayerByIndex(0)
- en: Part 2
  id: totrans-1224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: geoms = []
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: geoms = []
- en: layer.ResetReading()
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: layer.ResetReading()
- en: 'for feature in layer:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in layer:'
- en: geom = feature.GetGeometryRef().Clone()
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: geom = feature.GetGeometryRef().Clone()
- en: geom.Transform(transformation)
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: geom.Transform(transformation)
- en: geoms.append(geom)
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: geoms.append(geom)
- en: return geoms
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: return geoms
- en: '**Combining functions into an application**'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '**将函数组合成应用程序**'
- en: So far, we looked at very useful utility functions that perform specific tasks;
    however, to form an application, we need to combine these functions by calling
    them in an ordered manner to achieve our objectives. We need code that orchestrates
    the calls and results—
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了一些非常实用的工具函数，它们执行特定的任务；然而，为了形成一个应用程序，我们需要通过按顺序调用这些函数来组合它们，以实现我们的目标。我们需要协调调用和结果的代码——
- en: one that will make the application run.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将使应用程序运行。
- en: 'For this, we will dive into one of the most beautiful and powerful parts of
    Python programming: classes and methods.'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将深入 Python 编程中最美丽和最有力的部分之一：类和方法。
- en: 'Python is an object-oriented programming language (but it is not strict). If
    you are not familiar with the concept of object-oriented programming, don’t worry;
    the best way to understand what this is about is by examples, so I won’t go into
    theories now but teach by example instead. Perform the following steps now:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种面向对象的编程语言（但它不是严格的）。如果你不熟悉面向对象编程的概念，请不要担心；理解这个概念最好的方式是通过例子，所以我现在不会深入理论，而是通过例子来教学。现在执行以下步骤：
- en: '1\. Remember the application’s entry point? It’s in the Chapter2 folder, in
    the geochaching_app.py file. Open it for editing, and you should have this:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 记得应用程序的入口点吗？它在 Chapter2 文件夹中的 geochaching_app.py 文件里。打开它进行编辑，你应该有这个：
- en: coding=utf-8
  id: totrans-1238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: def main():print "Hello geocaching APP!"
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: def main():print "Hello geocaching APP!"
- en: 'if __name__ == "__main__":'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: main()
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '2\. Now, let’s import the modules that we have written so far so that we can
    use them in our application. Also, let’s import the other modules that we will
    need. Insert the import statements after the encoding declaration (# coding=utf-8).
    Your code should now be similar to this:'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，让我们导入我们迄今为止编写的模块，以便我们可以在应用程序中使用它们。同时，让我们导入我们还需要的其他模块。在编码声明（# coding=utf-8）之后插入导入语句。现在你的代码应该类似于这个：
- en: coding=utf-8
  id: totrans-1243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from utils.geo_functions import open_vector_file
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: from utils.geo_functions import open_vector_file
- en: from utils.geo_functions import transform_geometries
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: from utils.geo_functions import transform_geometries
- en: import numpy as np
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import math
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: 'def main():'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print "Hello geocaching APP!"
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: print "Hello geocaching APP!"
- en: 'if __name__ == "__main__":'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: main()
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '3\. Now, remove the main() function, and right after the imports, add the class
    that will represent our application:'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，删除 main() 函数，并在导入之后立即添加将代表我们应用程序的类：
- en: 'class GeocachingApp(object):'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeocachingApp(object):'
- en: 'def __init__(self, data_file=None):'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, data_file=None):'
- en: '"""Application class.'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类。'
- en: ':param data_file: An OGR compatible file'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: ':param data_file: 一个与 OGR 兼容的文件'
- en: with geocaching points.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: with geocaching points.
- en: '"""'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Part 1\.
  id: totrans-1259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。
- en: self._datasource = None
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource = None
- en: self._transformed_geoms = None
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: self._transformed_geoms = None
- en: Part 2\.
  id: totrans-1262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分。
- en: 'if data_file:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 'if data_file:'
- en: self.open_file(data_file)
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: self.open_file(data_file)
- en: 'def open_file(self, file_path):'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 'def open_file(self, file_path):'
- en: '"""Open a file containing geocaching data and prepare it for use.'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开包含地理藏宝数据的文件并准备使用。'
- en: ':param file_path:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: ':param file_path:'
- en: '"""'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self._datasource = open_vector_file(file_path)
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource = open_vector_file(file_path)
- en: self._transformed_geoms = transform_geometries(
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: self._transformed_geoms = transform_geometries(
- en: self._datasource, 4326, 3395)
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource, 4326, 3395)
- en: Here, we created a class representing our application. Inside the class, there
    is a special method called __init__. This method is called when the class is instantiated,
    which means when a new instance of the class is created. Here, we can see a parameter
    named self; this parameter is passed by the class to all instance methods, and
    self is the class instance itself. Again, don’t worry if these terms are strange
    to you, we will discuss more on them soon.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个代表我们应用程序的类。在类内部，有一个特殊的方法叫做 __init__。这个方法在类实例化时被调用，这意味着当创建类的新实例时。在这里，我们可以看到一个名为
    self 的参数；这个参数由类传递给所有实例方法，self 是类的实例本身。再次提醒，如果你对这些术语感到陌生，请不要担心，我们很快会对此进行更多讨论。
- en: In the first part, we defined two properties that any instance of this class
    may have; note that the underscore before the name denotes that a given property
    is for internal use only and should not be called from outside the class. This
    notation is only a convention, and it doesn’t really prevent the property from
    being used from outside the method. In second part, if the user passes the optional
    file, the application calls the open_file method, which in turn opens the file
    and prepares the data using the functions that we already developed.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们定义了两个任何类的实例都可能拥有的属性；注意，名称前的下划线表示该属性仅用于内部使用，不应从类外部调用。这种表示法仅是一种约定，实际上并不能真正阻止属性在方法外部被使用。在第二部分，如果用户传递可选文件，应用程序将调用
    open_file 方法，该方法反过来打开文件并使用我们已开发的函数准备数据。
- en: The way it’s coded allows us to change the file that we work on at any time.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的编写方式允许我们随时更改我们正在工作的文件。
- en: Note that as we reached this point, we have achieved a higher level of abstraction.
    First, you had the OGR library with basic functions, where many lines of code
    were needed to be written to perform a given task. Then, you have the utils package,
    which wraps ogr functions into utility functions that perform simple tasks with
    a single line of code. Now, you have the application class that combines utility
    functions into methods that automate the processes by calling each one of them
    in the right order and with the right parameters.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们达到这一点时，我们已经达到了更高的抽象层次。首先，你有 OGR 库及其基本功能，需要编写许多代码行来完成特定的任务。然后，你有 utils
    包，它将 ogr 函数封装成执行简单任务的实用函数，只需一行代码。现在，你有应用程序类，它将实用函数组合成方法，通过按正确的顺序和参数调用每个函数来自动化流程。
- en: 'At this point, you need to perform the following steps:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你需要执行以下步骤：
- en: '1\. Edit your if __name__ == ''__main__'': block with the following code: if
    __name__ == "__main__":'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 使用以下代码编辑 if __name__ == ''__main__'': 块：if __name__ == "__main__":'
- en: my_app = GeocachingApp()
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: my_app = GeocachingApp()
- en: my_app.open_file('../data/geocaching.gpx') 2\. Run the application, and take
    a look at the results.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: my_app.open_file('../data/geocaching.gpx') 2. 运行应用程序，查看结果。
- en: '**Setting your current location**'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置当前位置**'
- en: So far, the application can open a file. The next step is to define your location
    so that we can find the closest geocache. To do this, we will change the GeocachingApp
    class so that it can keep track of the current location through a property. We
    will also create methods to change the location (similar to the geometries), transform
    its coordinates, and prepare it for processing.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序可以打开文件。下一步是定义你的位置，以便我们可以找到最近的藏宝地。为此，我们将修改 GeocachingApp 类，使其能够通过属性跟踪当前位置。我们还将创建更改位置（类似于几何形状）的方法、转换其坐标，并为其处理做准备。
- en: 'Here are the steps that need to be performed:'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行以下步骤：
- en: '1\. Edit the GeocachingApp class init method using the following code:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 使用以下代码编辑 GeocachingApp 类的 init 方法：
- en: '#..'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '#..'
- en: 'def __init__(self, data_file=None, my_location=None):'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, data_file=None, my_location=None):'
- en: '"""Application class.'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类。'
- en: ':param data_file: An OGR compatible file'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: ':param data_file: 一个兼容 OGR 的文件'
- en: with geocaching points.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: with geocaching points.
- en: '"""'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self._datasource = None
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource = None
- en: self._transformed_geoms = None
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: self._transformed_geoms = None
- en: self._my_location = None
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: self._my_location = None
- en: self.distances = None
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: self.distances = None
- en: 'if data_file:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 'if data_file:'
- en: self.open_file(data_file)
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: self.open_file(data_file)
- en: 'if my_location:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 'if my_location:'
- en: self.my_location = my_location
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: self.my_location = my_location
- en: '2\. Now, add these two methods to the class:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，将这些两个方法添加到类中：
- en: '@property'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def my_location(self):'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_location(self):'
- en: return self._my_location
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: return self._my_location
- en: '@my_location.setter'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '@my_location.setter'
- en: 'def my_location(self, coordinates):'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_location(self, coordinates):'
- en: self._my_location = transform_points([coordinates])[0]
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: self._my_location = transform_points([coordinates])[0]
- en: The logic here is that the class instance should have a my_location property,
    and we want the program to automatically convert its coordinate system, as it
    does with geocaching data.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的逻辑是，类实例应该有一个 my_location 属性，我们希望程序能够自动转换其坐标系，就像处理 geocaching 数据那样。
- en: There are many ways to achieve this kind of behavior. If you have experience
    with other programming languages, you may have come across the concept of getters
    and setters.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种行为有许多方法。如果你有其他编程语言的经验，你可能已经遇到过 getters 和 setters 的概念。
- en: Getters and setters are methods designed to retrieve and set a given property
    of a class.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: Getters 和 setters 是设计用来获取和设置类给定属性的方法。
- en: The use of methods instead of direct access to the properties allows the programmer,
    among other things, to modify values or perform complex procedures when retrieving
    or changing a property.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法而不是直接访问属性，允许程序员在检索或更改属性时修改值或执行复杂的过程。
- en: We can have a getter and setter method for this property—get_my_location() and
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为这个属性提供一个获取器和设置器方法——get_my_location() 和
- en: set_my_location(), for example—but Python provides an elegant way of intervening
    in the processes of setting and getting a given property with the @property decorator.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: set_my_location()，例如——但是 Python 提供了一种优雅的方式来干预设置和获取给定属性的流程，使用 @property 装饰器。
- en: As can be noted in the preceding code, the actual value of my_location is stored
    in the _my_location property and defined in the __init__ method (the underscore
    before the name denotes that the property shouldn’t be accessed outside the class).
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，my_location 的实际值存储在 _my_location 属性中，并在 __init__ 方法中定义（名称前的下划线表示该属性不应在类外部访问）。
- en: Then, there are two methods with the same name, which is the name of the property
    that we want to expose. These functions are decorated so that the first one becomes
    a getter and the second one a setter. In the setter, we will call the functions
    that transform the coordinates of the point before storing it (we will get to
    this function in the next steps).
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个具有相同名称的方法，这是我们要公开的属性的名称。这些函数被装饰，以便第一个成为获取器，第二个成为设置器。在设置器中，我们将调用在存储之前转换点坐标的函数（我们将在下一步中了解这个函数）。
- en: 'As we did with the data, the location can be passed as an initial parameter
    to the class and changed at any time. Here’s how we can do this:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对数据进行处理一样，位置也可以作为初始参数传递给类，并且可以在任何时间进行更改。以下是我们可以如何做到这一点：
- en: '1\. Now, your complete class should be similar to this:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 现在，你的完整类应该类似于这个：
- en: 'class GeocachingApp(object):'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeocachingApp(object):'
- en: 'def __init__(self, data_file=None, my_location=None):'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, data_file=None, my_location=None):'
- en: '"""Application class.'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类。'
- en: ':param data_file: An OGR compatible file'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: ':param data_file: 一个与 OGR 兼容的文件'
- en: with geocaching points.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: with geocaching points.
- en: ':param my_location: Coordinates of your location.'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: ':param my_location: 您的位置坐标。'
- en: '"""'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self._datasource = None
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource = None
- en: self._transformed_geoms = None
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: self._transformed_geoms = None
- en: self._my_location = None
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: self._my_location = None
- en: self.distances = None
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: self.distances = None
- en: 'if data_file:'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 'if data_file:'
- en: self.open_file(data_file)
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: self.open_file(data_file)
- en: 'if my_location:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 'if my_location:'
- en: self.my_location = my_location
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: self.my_location = my_location
- en: 'def open_file(self, file_path):'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 'def open_file(self, file_path):'
- en: '"""Open a file containing geocaching data'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开包含地理藏宝数据'
- en: and prepare it for use.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 并为其使用做准备。
- en: ':param file_path:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: ':param file_path:'
- en: '"""'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self._datasource = open_vector_file(file_path)
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource = open_vector_file(file_path)
- en: self._transformed_geoms = transform_geometries(
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: self._transformed_geoms = transform_geometries(
- en: self._datasource, 4326, 3395)
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: self._datasource, 4326, 3395)
- en: '@property'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def my_location(self):'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_location(self):'
- en: return self._my_location
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: return self._my_location
- en: '@my_location.setter'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '@my_location.setter'
- en: 'def my_location(self, coordinates):'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 'def my_location(self, coordinates):'
- en: self._my_location = transform_points([coordinates])[0]
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: self._my_location = transform_points([coordinates])[0]
- en: 2\. As we don’t have a transform_points function, you should notice that PyCharm
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 由于我们没有 transform_points 函数，你应该注意到 PyCharm
- en: 'underlines transform_points in red. So, let’s create one in the geo_functions.py
    file. Also, we will avoid boilerplate code by creating another function that creates
    the OSR transformation:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 在红色下划线处标记了 transform_points。因此，让我们在 geo_functions.py 文件中创建一个。此外，我们将通过创建另一个创建
    OSR 转换的函数来避免样板代码：
- en: '**Note**'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**Boilerplate code**'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '**样板代码**'
- en: Boilerplate code, or boilerplate, are pieces of code that repeated in many places
    with little or no alteration.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 样板代码，或称为样板，是许多地方重复出现且几乎或根本不进行更改的代码片段。
- en: 'def create_transform(src_epsg, dst_epsg):'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_transform(src_epsg, dst_epsg):'
- en: '"""Creates an OSR tranformation.'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '"""创建一个 OSR 转换。'
- en: ':param src_epsg: EPSG code for the source geometry.'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: ':param src_epsg: 源几何的 EPSG 代码。'
- en: ':param dst_epsg: EPSG code for the destination geometry.'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: ':param dst_epsg: 目标几何的 EPSG 代码。'
- en: ':return: osr.CoordinateTransformation'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: ':return: osr.CoordinateTransformation'
- en: '"""'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: src_srs = osr.SpatialReference()
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: src_srs = osr.SpatialReference()
- en: src_srs.ImportFromEPSG(src_epsg)
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: src_srs.ImportFromEPSG(src_epsg)
- en: dst_srs = osr.SpatialReference()
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: dst_srs = osr.SpatialReference()
- en: dst_srs.ImportFromEPSG(dst_epsg)
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: dst_srs.ImportFromEPSG(dst_epsg)
- en: return osr.CoordinateTransformation(src_srs, dst_srs)
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: return osr.CoordinateTransformation(src_srs, dst_srs)
- en: 'def transform_points(points, src_epsg=4326, dst_epsg=3395):'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 'def transform_points(points, src_epsg=4326, dst_epsg=3395):'
- en: '"""Transform the coordinate reference system of a list of coordinates (a list
    of points)'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '"""转换坐标参考系中的一系列坐标（一系列点）'
- en: ':param src_epsg: EPSG code for the source geometry.'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: ':param src_epsg: 源几何的 EPSG 代码。'
- en: ':param dst_epsg: EPSG code for the destination geometry.'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: ':param dst_epsg: 目标几何的 EPSG 代码。'
- en: '"""'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: transform = create_transform(src_epsg, dst_srs)
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: transform = create_transform(src_epsg, dst_srs)
- en: points = transform.TransformPoints(points)
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: points = transform.TransformPoints(points)
- en: return points
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: return points
- en: The transform_points function uses an OSR function with the same name that performs
    the transformation over an array. This function is incredibly efficient and can
    transform pairs of coordinates in an order of a magnitude of millions per second
    in an ordinary home computer. The reason that we will wrap it in our function
    is that we want to avoid repeating code and add default parameters.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: transform_points 函数使用具有相同名称的 OSR 函数，该函数在数组上执行转换。这个函数非常高效，可以在普通家用电脑上以每秒数百万次的速率转换坐标对。我们将它封装在我们的函数中的原因是我们想避免代码重复并添加默认参数。
- en: Note that in the my_location setter, we put the coordinates inside a list and
    then got the first element of the returning value (self.mylocation =
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 my_location 设置器中，我们将坐标放入一个列表中，然后获取返回值的第一个元素（self.mylocation =
- en: transform_points([coordinates])[0]).
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: transform_points([coordinates])[0]).
- en: '![Image 11](img/index-135_1.jpg)'
  id: totrans-1371
  prefs: []
  type: TYPE_IMG
  zh: '![Image 11](img/index-135_1.jpg)'
- en: '![Image 12](img/index-135_2.jpg)'
  id: totrans-1372
  prefs: []
  type: TYPE_IMG
  zh: '![Image 12](img/index-135_2.jpg)'
- en: '**Finding the closest point**'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找最近点**'
- en: To find the closest point, we need to first calculate the distance between the
    current location (my location) and all points. Then, we need to find the point
    that has the smallest distance from my location.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到最近点，我们首先需要计算当前位置（我的位置）和所有点之间的距离。然后，我们需要找到离我的位置最近的点。
- en: 'So, for each of the points, we must apply an equation that returns the distance
    to my location and stores these results in the same order as the points in the
    following table: **Point index x**'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个点，我们必须应用一个返回到我位置的距离的方程，并将这些结果按以下表格中点的顺序存储：**点索引 x**
- en: '**y**'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '**y**'
- en: '**Distance to my location**'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '**到我位置的距离**'
- en: '0'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 35 44 ?
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 35 44 ?
- en: '1'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 20 92 ?
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 20 92 ?
- en: '2'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 11 77 ?
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 11 77 ?
- en: 'The distance between two points is given by the following equation: Translating
    this equation to Python, we have the following code: distance = math.sqrt((xb-xa)**2
    + (yb-ya)**2)'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 两点之间的距离由以下方程给出：将此方程转换为 Python，我们有以下代码：distance = math.sqrt((xb-xa)**2 + (yb-ya)**2)
- en: The following table illustrates the basic Python math operators **Syntax**
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了基本的 Python 数学运算符 **语法**
- en: '**Mathematical Expression Operation Name**'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学表达式运算名称**'
- en: a + b
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: a + b
- en: '*a* + *b*'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* + *b*'
- en: Addition
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 加法
- en: '![Image 13](img/index-136_1.jpg)'
  id: totrans-1390
  prefs: []
  type: TYPE_IMG
  zh: '![Image 13](img/index-136_1.jpg)'
- en: a - b
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: a - b
- en: '*a* - *b*'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* - *b*'
- en: Subtraction
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 减法
- en: a * b
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: a * b
- en: '*a* x *b*'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* x *b*'
- en: Multiplication
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法
- en: a / b
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: a / b
- en: '*a* ÷ *b*'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* ÷ *b*'
- en: Division
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 除法
- en: a ** b
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: a ** b
- en: '*a* b'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* b'
- en: Exponent
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 指数
- en: math.sqrt(a)
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: math.sqrt(a)
- en: Square root
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 平方根
- en: 'Now, insert the preceding method inside the GeocachingApp class by executing
    the following code:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过执行以下代码将前面的方法插入到 GeocachingApp 类中：
- en: '#...'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def calculate_distances(self):'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_distances(self):'
- en: '"""Calculates the distance between a'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算两点之间的距离'
- en: set of points and a given location.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 一组点和给定位置。
- en: ':return: A list of distances in the same order as'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: ':return: 按相同顺序返回距离列表'
- en: the points.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点。
- en: '"""'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: xa = self.my_location[0]
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: xa = self.my_location[0]
- en: ya = self.my_location[1]
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: ya = self.my_location[1]
- en: points = self._transformed_geoms
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: points = self._transformed_geoms
- en: distances = []
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: distances = []
- en: 'for geom in points:'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 'for geom in points:'
- en: point_distance = math.sqrt(
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: point_distance = math.sqrt(
- en: (geom.GetX() - xa)**2 + (geom.GetY() - ya))
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: (geom.GetX() - xa)**2 + (geom.GetY() - ya))
- en: distances.append(point_distance)
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: distances.append(point_distance)
- en: return distances
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: return distances
- en: '**Tip**'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**Gradual optimization of code**'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码的逐步优化**'
- en: Some equations or operations may be very complex, and they sometimes become
    hard to write, or you may need to see the results for the intermediary steps to
    debug. The tip for these situations is to not worry about writing optimized and
    fast code right away.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方程或操作可能非常复杂，有时它们变得难以编写，或者你可能需要查看中间步骤的结果来调试。这些情况下的提示是不要一开始就担心编写优化和快速的代码。
- en: Start by writing readable and clear code, separating each intermediary step
    into variables.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编写可读性和清晰的代码，将每个中间步骤分离到变量中。
- en: 'For example, consider the following equation for distance:'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下距离方程：
- en: distance = math.sqr((xb-xa)**2 + (yb-ya)**2)
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: distance = math.sqr((xb-xa)**2 + (yb-ya)**2)
- en: 'This can be broken into intermediary steps:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以分解为中间步骤：
- en: vertical_distance = yb - ya
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: horizontal_distance = xb – xa
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: distance = math.sqrt(horizontal_distance**2 + vertical_distance**2) Now, debug
    and check the results; when you are sure that the logic is correct and the result
    is what you expect, you can gradually optimize the code by replacing parts and
    trying alternative paths to improve the performance by checking whether the results
    match.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: The final part is to find the closest point in the list of distances, which
    means to find the
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: 'index of the item that has the minimum value. Add this method to the class:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: 'def find_closest_point(self):'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: '"""Find the closest point to a given location and return the cache that''s
    on that point.'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: ':return: OGR feature containing the point.'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: Part 1\.
  id: totrans-1439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: distances = self.calculate_distances()
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: index = np.argmin(distances)
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: Part 2\.
  id: totrans-1442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layer = self._datasource.GetLayerByIndex(0)
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: feature = layer.GetFeature(index)
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Closest point at: {}m".format(distances[index]) return feature'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: There is a possibility that the data contains repeated values, which will result
    in the same distance, or a remote possibility that two points have the same distance.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: So, in the first part, the np.argmin function returns the index or indexes with
    a minimum value among all points. In the second part, the program gets the feature
    at this index.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, let’s test our application and edit the if __name__ == ''__main__''
    block, as follows:'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: my_app = GeocachingApp('../data/geocaching.gpx', [-73.0, 43.0]) my_app.find_closest_point()
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, your geocaching_app.py should look similar to this:'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  id: totrans-1453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_geometries
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_points
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: import math
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeocachingApp(object):'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data_file=None, my_location=None):'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: ':param data_file: An OGR compatible file'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: with geocaching points.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: ':param my_location: Coordinates of your location.'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = None
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = None
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = None
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: self.distances = None
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: 'if data_file:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: self.open_file(data_file)
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: 'if my_location:'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: self.my_location = my_location
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_file(self, file_path):'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open a file containing geocaching data and prepare it for use.'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: ':param file_path:'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = open_vector_file(file_path)
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = transform_geometries(
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource, 4326, 3395)
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self):'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: return self._my_location
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: '@my_location.setter'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self, coordinates):'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = transform_points([coordinates])[0]
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculate_distances(self):'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculates the distance between a'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: set of points and a given location.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: ':return: A list of distances in the same order as'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: the points.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: xa = self.my_location[0]
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: ya = self.my_location[1]
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: points = self._transformed_geoms
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: distances = []
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: 'for geom in points:'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: point_distance = math.sqrt(
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: (geom.GetX() - xa)**2 + (geom.GetY() - ya))
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: distances.append(point_distance)
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: distances.append(point_distance)
- en: return distances
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: return distances
- en: 'def find_closest_point(self):'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_closest_point(self):'
- en: '"""Find the closest point to a given location and return the cache that''s
    on that point.'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '"""找到给定位置最近的点并返回该点上的缓存。'
- en: ':return: OGR feature containing the point.'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: ':返回: 包含点的 OGR 特征。'
- en: '"""'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Part 1\.
  id: totrans-1506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。
- en: distances = self.calculate_distances()
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: distances = self.calculate_distances()
- en: index = np.argmin(distances)
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: index = np.argmin(distances)
- en: Part 2\.
  id: totrans-1509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分。
- en: layer = self._datasource.GetLayerByIndex(0)
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: layer = self._datasource.GetLayerByIndex(0)
- en: feature = layer.GetFeature(index)
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: feature = layer.GetFeature(index)
- en: 'print "Closest point at: {}m".format(distances[index]) return feature'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: print "最近的点在：{}m".format(distances[index]) return feature
- en: 'if __name__ == "__main__":'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: my_app = GeocachingApp('../data/geocaching.gpx', [-73.0, 43.0]) my_app.find_closest_point()
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: my_app = GeocachingApp('../data/geocaching.gpx', [-73.0, 43.0]) my_app.find_closest_point()
- en: '3\. Run the code, press *Alt* + *Shift* + *F10*, and select geocaching_app.
    Take a look at the result in the output:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 运行代码，按 *Alt* + *Shift* + *F10*，并选择 geocaching_app。查看输出结果：
- en: 'Closest point at: 49653.3244095m'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的点在：49653.3244095m
- en: Process finished with exit code 0
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码 0
- en: '**Summary**'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: In this chapter, we discussed important concepts related to code organization
    and data manipulation. This was accomplished by writing code with an increasing
    level of abstraction until we had a class with high-level functionality.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与代码组织和数据处理相关的重要概念。这是通过编写具有递增抽象级别的代码来实现的，直到我们拥有一个具有高级功能类的代码。
- en: First, we wrote utility functions in order to automate tasks and prepare the
    data to be processed. Some of these functions were simple abstractions over the
    OGR library, which were made to avoid unnecessary code repetition.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写了实用函数，以自动化任务并准备要处理的数据。其中一些函数是 OGR 库的简单抽象，旨在避免不必要的代码重复。
- en: Then, we wrote methods in a class representing the application. These methods
    take care of performing sequences of operations to make an application work.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在代表应用程序的类中编写了方法。这些方法负责执行一系列操作，使应用程序能够运行。
- en: Finally, we presented the foundation of how to perform mathematical operations
    over the elements of data. We wrote a very efficient method that calculates the
    distance for a list of elements.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了如何在数据元素上执行数学运算的基础。我们编写了一个非常高效的方法，用于计算元素列表的距离。
- en: In the next chapter, we will improve our data abstraction and make it possible
    for the application to combine multiple sources of data.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将改进我们的数据抽象，使应用程序能够组合多个数据来源。
- en: '**Chapter 3\. Combining Multiple Data**'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 3 章. 组合多个数据**'
- en: '**Sources**'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源**'
- en: Geographic data tends to be heterogeneous. Just to cite a few factors that contribute
    to this heterogeneity, it may come from different sources, have been produced
    at different times, or even have different languages. Given this fact, writing
    programs that can combine multiple sources of data is a fundamental topic in geoprocessing.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 地理数据往往具有异质性。仅举几个导致这种异质性的因素，它可能来自不同的来源，在不同的时间产生，甚至有不同的语言。鉴于这一事实，编写能够组合多个数据来源的程序是地理处理中的基本主题。
- en: Data sources may come in different formats, such as shapefiles, text files,
    Google KML
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源可能以不同的格式存在，例如 shapefiles、文本文件、Google KML
- en: files, GPX files from GPS, and so on. They may also vary in their contents;
    for example, they may have different types of geometries, coordinate systems,
    and attributes.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 文件，来自 GPS 的 GPX 文件等。它们的内容也可能不同；例如，它们可能具有不同的几何类型、坐标系和属性。
- en: In this chapter, we will enhance our application by adding the capability to
    combine multiple sources of data from both different sites and different file
    formats. In order to achieve this, we will write code capable of identifying the
    type of data, and depending on this, we will make transformations to obtain a
    homogeneous set of data.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过添加从不同站点和不同文件格式的多个数据来源的组合能力来增强我们的应用程序。为了实现这一点，我们将编写能够识别数据类型的代码，并根据这一点进行转换，以获得一组同质数据。
- en: By extending OGR capabilities and including our own functions, we can represent
    the data in Python classes and add some smart capabilities to them that would
    make the process of combining many sources very easy for this application and
    others.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展 OGR 功能并包含我们自己的函数，我们可以在 Python 类中表示数据，并为其添加一些智能功能，使将多个来源的数据组合起来对应用程序和其他应用程序来说非常容易。
- en: 'In order to achieve these objectives, we will cover the following topics in
    this chapter: The structure of geographic data files'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，我们将在本章中介绍以下主题：地理数据文件的结构
- en: How geometries are represented
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 几何形状的表示
- en: How to transform data into Python objects
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将数据转换为Python对象
- en: How to combine multiple sources of data
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 如何组合多个数据源
- en: Using class inheritance in Python to write better code
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python中的类继承来编写更好的代码
- en: '**Representing geographic data**'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: '**地理数据的表示**'
- en: Most file formats that contain geographic data are made of a common simple structure
    consisting of a number of features, each containing a geometry and innumerous
    named properties.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数包含地理数据的文件格式都由一个常见的简单结构组成，该结构由多个特征组成，每个特征包含一个几何形状和无数个命名属性。
- en: Here, you can take a look at a sample of the contents of a GeoJSON file. This
    type of geographic file has the advantage of being human readable, allowing us
    to see exactly the structure that is being described. You don’t need to type this
    example; just take a good look at it.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看GeoJSON文件内容的样本。这种地理文件的优势在于其可读性，使我们能够确切地看到所描述的结构。您不需要输入此示例；只需仔细查看即可。
- en: 'Its structure is very similar to a Python dictionary. At the uppermost level,
    there is FeatureCollection, which contains a list of features. Each feature has
    a geometry, whose type may vary, and a *dictionary* of properties that may contain
    any arbitrary property defined by the user. In brief, it follows exactly the described
    schema of data representation as shown in the following code:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 其结构非常类似于Python字典。在最顶层，有FeatureCollection，其中包含特征列表。每个特征都有一个几何形状，其类型可能不同，以及一个可能包含用户定义的任何任意属性的*字典*。简而言之，它严格遵循以下代码所示的数据表示方案：
- en: '{"type": "FeatureCollection",'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: '{"type": "FeatureCollection",'
- en: '"features": ['
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: '"features": ['
- en: '{"type": "Feature",'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: '{"type": "Feature",'
- en: '"geometry": {'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": "Point",'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Point",'
- en: '"coordinates": [102.0, 0.5]},'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": [102.0, 0.5]},'
- en: '"properties": {"prop0": "value0"}'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": {"prop0": "value0"}'
- en: '},'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{"type": "Feature",'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: '{"type": "Feature",'
- en: '"geometry": {'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": "LineString",'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "LineString",'
- en: '"coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0]]'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0]]'
- en: '},'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"properties": {'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": {'
- en: '"prop0": "value0",'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '"prop0": "value0",'
- en: '"prop1": 0.0'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: '"prop1": 0.0'
- en: '}'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '},'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{"type": "Feature",'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '{"type": "Feature",'
- en: '"geometry": {'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '"geometry": {'
- en: '"type": "Polygon",'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "Polygon",'
- en: '"coordinates": ['
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: '"coordinates": ['
- en: '[ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: '[ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],'
- en: '[100.0, 1.0], [100.0, 0.0] ]'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: '[100.0, 1.0], [100.0, 0.0] ]'
- en: ']'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '},'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"properties": {'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: '"properties": {'
- en: '"prop0": "value0",'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '"prop0": "value0",'
- en: '"prop1": {"this": "that"}'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '"prop1": {"this": "that"}'
- en: '}'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**JSON** stands for **JavaScript Object Notation** and is a format that can
    be easily read and written in a number of programming languages. Specifically
    in Python, a JSON object can'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表**JavaScript对象表示法**，是一种易于在多种编程语言中读取和写入的格式。特别是在Python中，一个JSON对象可以'
- en: be transformed into a dictionary and vice versa.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 可以转换为字典，反之亦然。
- en: There a number of other formats that implement the same structure; some of them
    add extra functionality and some have characteristics that are very specific for
    a given purpose.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他格式实现了相同结构；其中一些增加了额外的功能，而另一些具有针对特定目的非常具体的特征。
- en: For example, the **ESRI** shapefile has indexing capabilities, the **GPX** format
    is made to work with GPS devices to store waypoints and tracks, and **SpatiLite**
    is a single file spatial database at the top of SQLite that allows objects to
    have relations with each other.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**ESRI**的shapefile具有索引功能，**GPX**格式是为了与GPS设备配合使用以存储航点和轨迹而设计的，而**SpatiLite**是SQLite之上的单文件空间数据库，允许对象之间相互关联。
- en: 'In the following table, there are some common file formats and a brief description
    of each: **Format**'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中，有一些常见的文件格式及其简要描述：**格式**
- en: '**Description**'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述**'
- en: Cartesian
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔
- en: This is a simple point cloud.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的点云。
- en: coordinate system
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标系统
- en: Digital Line
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 数字线
- en: This is a USGS format for vector data.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于矢量数据的USGS格式。
- en: Graph (DLG)
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 图形（DLG）
- en: Geography
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 地理学
- en: Markup
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 标记
- en: This is an XML-based open standard (by OpenGIS) for GIS data exchange.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于XML的开放标准（由OpenGIS制定）用于GIS数据交换。
- en: Language
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 语言
- en: GeoJSON
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON
- en: This is a lightweight format based on JSON and is used by many open source GIS
    packages.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种基于JSON的轻量级格式，并被许多开源GIS软件包所使用。
- en: This is a spatial extension to SQLite that provides vector geodatabase functionality.
    It is similar to Spatialite
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SQLite的空间扩展，提供了矢量地理数据库功能。它与Spatialite类似
- en: PostGIS, Oracle Spatial, and SQL Server with spatial extensions.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS、Oracle Spatial和具有空间扩展的SQL Server。
- en: Shapefile
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: Shapefile
- en: This is a popular vector data GIS format developed by Esri.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由Esri开发的流行的矢量数据GIS格式。
- en: '![Image 14](img/index-146_1.jpg)'
  id: totrans-1595
  prefs: []
  type: TYPE_IMG
  zh: '![Image 14](img/index-146_1.jpg)'
- en: '**Representing geometries**'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示几何形状**'
- en: As we saw before, in geographic data, each feature contains a geometry. A geometry
    is the spatial representation of a given object. For example, a point can represent
    a tree, a place of interest, or, as in our case, a geocache. A line can be a road,
    a river, and so on.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，在地理数据中，每个特征都包含一个几何形状。几何形状是给定对象的空間表示。例如，一个点可以代表一棵树、一个兴趣点，或者在我们的案例中，一个藏宝地。一条线可以是一条道路、一条河流等等。
- en: Countries, cities, states, or any other type of areas can be represented by
    polygons.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 国家、城市、州或任何其他类型的区域都可以用多边形表示。
- en: 'In this book, we will follow the geometry representation described by the simple
    features specifications standardized in ISO 19125\. It consists of two-dimensional
    geographic data made of points, lines, polygons, and aggregations or collections
    of them, as shown in the following image:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将遵循由ISO 19125标准化的简单特征规范描述的几何形状表示。它由点、线、多边形及其聚合或集合组成，如下面的图像所示：
- en: Any geometry in this format is represented by points and a linear interpolation
    between them. An example of this would be two points that form a line.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种格式中，任何几何形状都是由点和它们之间的线性插值表示的。一个例子就是形成一条线的两个点。
- en: This type of geometry is simple, very common, and easy to use. Nevertheless,
    there are noticeable flaws, and the most important one is the lack of topological
    representation.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的几何形状简单、非常常见且易于使用。尽管如此，它有一些明显的缺陷，其中最重要的是缺乏拓扑表示。
- en: For example, we may have two features representing two neighbor countries—for
    example, Canada and USA. For each feature (that is, each country) there is a polygon
    representing the whole limit of the country. By consequence, the borders shared
    by the two countries will overlap.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能有两个特征代表两个相邻的国家——例如，加拿大和美国。对于每个特征（即每个国家），都有一个多边形代表该国家的整个边界。因此，两个国家共享的边界将重叠。
- en: '![Image 15](img/index-147_1.jpg)'
  id: totrans-1603
  prefs: []
  type: TYPE_IMG
  zh: '![Image 15](img/index-147_1.jpg)'
- en: Now, think about the states in the USA and the provinces of Canada; each will
    be a polygon, their borders will also overlap, and they will, in turn, overlap
    the countries’
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑美国的州和加拿大的省；每个都将是一个多边形，它们的边界也将重叠，反过来，它们将重叠国家。
- en: 'borders. So, we will end up with the following:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 边界。因此，我们将得到以下结果：
- en: States/provinces
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 州/省
- en: Country border
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 国家边界
- en: Other country border
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 其他国家边界
- en: Other states/provinces
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 其他州/省
- en: This makes four overlapping lines; if we want to represent cities, districts,
    and so on, the number of overlapping geometries would increase. With this, we
    would have a higher probability of errors and require more space for storage.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得有四条重叠的线；如果我们想表示城市、地区等，重叠几何形状的数量将会增加。这样，我们会有更高的错误概率，并且需要更多的存储空间。
- en: This is why this type of geometry representation is also called **spaghetti
    data**; it ends with a juxtaposition of a lot of lines (similar to spaghetti).
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么这种几何形状表示也被称为**意大利面数据**；它以大量线条的并置结束（类似于意大利面）。
- en: This flaw can be solved through the topological representation of the geometries.
    The big difference is that, in this example, it wouldn’t store polygons; it would
    store the relationships between objects. You have a set of boundaries that relate
    to each other and represent an area, and two areas can have the same boundary.
    **OpenStreetMap** is a good example of a topological representation of geographic
    features.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺陷可以通过几何形状的拓扑表示来解决。最大的不同是，在这个例子中，它不会存储多边形；它会存储对象之间的关系。你有一组相互关联的边界，代表一个区域，两个区域可以拥有相同的边界。**OpenStreetMap**是地理特征拓扑表示的一个很好的例子。
- en: Although topological representation is more advanced, it is much harder to work
    with, and the vast majority of geographic analysis can be done with a simple representation.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拓扑表示更先进，但处理起来更困难，而且绝大多数地理分析都可以使用简单表示来完成。
- en: '**Making data homogeneous**'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: '**使数据同质化**'
- en: What relates the representation of data to real-life objects is the simple combination
    of geometry with the properties of a feature.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据表示与实际对象联系起来的简单方法是将几何形状与特征属性相结合。
- en: A line for example, can be a road, river, fence, and so on. The only difference
    may be the type property that tells us what it is. Alternatively, we may have
    a file named roads that lets us know that it contains roads.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一行可以是一条道路、河流、栅栏等。唯一的区别可能是类型属性，它告诉我们它是什么。或者，我们可能有一个名为roads的文件，它让我们知道它包含道路。
- en: However, the computer doesn’t know about this as it doesn’t know what the other
    properties represent or what the file is. Because of this, we need to make transformations
    in the data in order to have a common format that can be analyzed.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，计算机并不知道这一点，因为它不知道其他属性代表什么，也不知道文件是什么。因此，我们需要对数据进行转换，以便有一个可以分析的共同格式。
- en: This common format is the subject of this topic; it is how data can be represented
    in Python in an optimal way and in which the objects can be manipulated and analyzed
    to produce the expected results.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 这种常见的格式是本主题的主题；这是数据如何在Python中以最佳方式表示，以及如何操作和分析这些对象以产生预期结果。
- en: The objective is to transform the basic data representation of features, geometries,
    and properties into a representation of real-life objects and hide the details
    of the functionality under the hood in this process. In computer science, this
    is called **abstraction**.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将特征、几何形状和属性的基本数据表示转换为现实生活对象的表示，在这个过程中隐藏底层功能的细节。在计算机科学中，这被称为**抽象**。
- en: Instead of just writing some prepared code and magically performing the transformation,
    we will go step by step through the process of deduction of how the transformation
    needs to be done. This is very important because it’s the foundation of developing
    code to perform any kind of transformation on any type of geographic data that
    you can put to use in the future.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅编写一些准备好的代码并神奇地执行转换，我们将逐步通过如何进行转换的演绎过程。这非常重要，因为这是开发代码以对任何类型的地理数据进行任何类型转换的基础，这些数据可以在未来使用。
- en: '**The concept of abstraction**'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象概念**'
- en: Now that we have a clear understanding of how data is represented, let’s get
    back to our geocaching application.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地了解了数据是如何表示的，让我们回到我们的地理缓存应用。
- en: Abstraction is a programming technique intended to reduce the complexity of
    code for the programmer. It’s done by encapsulating complex code under progressive
    layers of more human-friendly solutions. The lower the level of abstraction, the
    closer to the machine language and the harder to maintain it is. The higher the
    level of abstraction, the more the code tries to mimic the behavior of real things
    or the more it resembles a natural language, thus becoming more intuitive and
    easier to maintain and extend.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是一种编程技术，旨在降低程序员编写代码的复杂性。它是通过将复杂代码封装在更符合人类友好的解决方案的渐进层中实现的。抽象级别越低，越接近机器语言，维护起来越困难。抽象级别越高，代码越试图模仿真实事物的行为，或者越接近自然语言，因此越直观，也越容易维护和扩展。
- en: Going back to the examples that we saw so far, we may notice many levels of
    abstraction
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们迄今为止看到的例子，我们可能会注意到许多抽象级别
- en: —for example, when we use the OGR library in the function we use to open shapefiles.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: ——例如，当我们使用OGR库在打开shapefiles的函数中使用时。
- en: 'Take a look at the following code:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: 'def open_vector_file(file_path):'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 'def open_vector_file(file_path):'
- en: '"""Opens an vector file compatible with OGR, get the first layer and returns
    the ogr datasource.'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与OGR兼容的矢量文件，获取第一层，并返回OGR数据源。'
- en: ':param str file_path: The full path to the file.'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: ':return: The ogr datasource.'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: ':return: OGR数据源。'
- en: '"""'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: datasource = ogr.Open(file_path)
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = ogr.Open(file_path)
- en: layer = datasource.GetLayerByIndex(0)
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: layer = datasource.GetLayerByIndex(0)
- en: print("Opening {}".format(file_path))
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在打开 {}".format(file_path))
- en: 'print("Number of features: {}".format(layer.GetFeatureCount())) return datasource'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("特征数量: {}".format(layer.GetFeatureCount())) return datasource'
- en: Just at the uppermost layers of abstraction, we have the function itself that
    hides the functionality of OGR. Then, we have the OGR Python bindings that abstract
    the OGR C
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象的最上层，我们有自己的函数，它隐藏了OGR的功能。然后，我们有OGR的Python绑定，它抽象了OGR C
- en: API, which in turn handles memory allocation, all the mathematics, and so on.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: API，它反过来处理内存分配、所有数学运算等。
- en: '![Image 16](img/index-151_1.jpg)'
  id: totrans-1638
  prefs: []
  type: TYPE_IMG
  zh: '![图像 16](img/index-151_1.jpg)'
- en: '**Abstracting the geocache point**'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象地理缓存点**'
- en: 'So, we need to handle multiple sources of data in a smart way so that: We don’t
    need to change the code for each type of data'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要以智能的方式处理多个数据源，这样我们就不需要为每种数据类型更改代码
- en: It’s possible to combine data from multiple sources
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能结合来自多个源的数据
- en: If we add extra functionality to our program, we don’t need to worry about file
    formats and data types
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为程序添加额外的功能，我们不需要担心文件格式和数据类型
- en: 'How will we do this? The answer is simple: we will abstract our data and hide
    the process of format and type handling in the internal functionality.'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何做到这一点？答案是简单的：我们将抽象我们的数据，并将格式和类型处理的流程隐藏在内部功能中。
- en: The objective is that after this point in the app, we won’t need to deal with
    OGR, layers, features, and so on. We will have one and only one type of object
    that we will use to represent our data, and all the interaction will be done with
    this object. The geocache object will represent a single geocaching point with
    the properties and methods that can be used to manipulate this object.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是，在应用程序的这个点之后，我们不再需要处理 OGR、图层、要素等。我们将只有一个类型的数据对象，我们将使用这个对象来表示我们的数据，所有的交互都将通过这个对象来完成。地理藏宝对象将表示一个单独的地理藏宝点，具有可以用来操作此对象的属性和方法。
- en: 'Now, perform the following steps:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下步骤：
- en: 1\. First, let’s organize the project structure. Open your geopy project in
    PyCharm and create a directory named Chapter3\.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 首先，让我们组织项目结构。在 PyCharm 中打开您的 geopy 项目，并创建一个名为 Chapter3 的目录。
- en: '2\. Copy all the files and directories from Chapter2 to Chapter3\. You should
    end up with a structure similar to the following:'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 将 Chapter2 中的所有文件和目录复制到 Chapter3 中。您应该得到以下类似的结构：
- en: +---Chapter3
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: +---Chapter3
- en: '| | geocaching_app.py'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: '| | geocaching_app.py'
- en: '| | __init__.py'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: '| | __init__.py'
- en: '| |'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '| |'
- en: '| +---experiments'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: '| +---experiments'
- en: '| | import_test.py'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '| | import_test.py'
- en: '| | module_test.py'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: '| | module_test.py'
- en: '| |'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: '| |'
- en: '| \---utils'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: '| \---utils'
- en: '| data_transfer.py'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: '| data_transfer.py'
- en: '| geo_functions.py'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: '| geo_functions.py'
- en: '| __init__.py'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: '| __init__.py'
- en: 3\. Inside Chapter3, create a new file named models.py (from this point on,
    we will
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在 Chapter3 中，创建一个名为 models.py 的新文件（从现在开始，我们将
- en: work inside the Chapter3 directory).
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chapter3 目录下工作）。
- en: '4\. Now, add this code to the file:'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 现在将此代码添加到文件中：
- en: 'class Geocache(object):'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Geocache(object):'
- en: '"""This class represents a single geocaching point."""'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这是一个表示单个地理藏宝点的类。"""'
- en: 'def __init__(self, x, y):'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, x, y):'
- en: self.x = x
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = x
- en: self.y = y
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = y
- en: '@property'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def coordinates(self):'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 'def coordinates(self):'
- en: return self.x, self.y
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 self.x, self.y
- en: '5\. Now, we have a geocache class with its first properties: the coordinates
    for the geocache. To test our class, we can write the following code: if __name__
    == ''__main__'':'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: '5\. 现在，我们有一个带有其第一个属性的 geocache 类：地理藏宝点的坐标。为了测试我们的类，我们可以编写以下代码：if __name__ ==
    ''__main__'':'
- en: one_geocaching_point = Geocache(20, 40)
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: one_geocaching_point = Geocache(20, 40)
- en: print(one_geocaching_point.coordinates)
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(one_geocaching_point.coordinates)
- en: '6\. Run your code, press *Alt* + *Shift* + *F10*, and select the models files.
    You should get this output in the console:'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 运行您的代码，按 *Alt* + *Shift* + *F10*，并选择模型文件。您应该在控制台看到以下输出：
- en: (20, 40)
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: (20, 40)
- en: Process finished with exit code 0
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 进程已退出，退出代码为 0
- en: '**Abstracting geocaching data**'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象地理藏宝数据**'
- en: 'As we have a single point, we also need to have a collection of points. We
    will call this PointCollection. Continuing the process of abstraction, the objective
    is to hide the operations of importing and converting the data. We will do this
    by creating a new class and encapsulating some of our utility functions inside
    it. Go to your models.py file and add the following class:'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个单独的点，我们还需要有一个点的集合。我们将称这个为 PointCollection。继续抽象的过程，目标是隐藏导入和转换数据的操作。我们将通过创建一个新的类并在其中封装一些我们的实用函数来实现这一点。转到您的
    models.py 文件，并添加以下类：
- en: 'class PointCollection(object):'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 'class PointCollection(object):'
- en: 'def __init__(self):'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: '"""This class represents a group of vector data."""'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这是一个表示一组矢量数据的类。"""'
- en: Self.data = []
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: Self.data = []
- en: It’s a simple class definition, and in the __init__ method, we will define that
    each instance of this class will have a data property. Now that we have created
    our simple abstractions, let’s add functionality to it.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类定义，在 __init__ 方法中，我们将定义这个类的每个实例都将有一个数据属性。现在我们已经创建了简单的抽象，让我们给它添加一些功能。
- en: '**Importing geocaching data**'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入地理藏宝数据**'
- en: In the previous chapter, we generalized our import function by adding the capability
    to import more types of data supported by OGR.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过添加导入更多由 OGR 支持的数据类型的功能来泛化我们的导入函数。
- en: Now, we will improve it again, make it handle some errors, make it compatible
    with our objects, and add two new capabilities. We will also convert the data
    in order to produce uniform objects.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次改进它，使其能够处理一些错误，使其与我们的对象兼容，并添加两个新功能。我们还将转换数据以生成统一的对象。
- en: To achieve our goals, we will analyze what kind of information is stored in
    the files that we want to open. We will use OGR to inspect the files and return
    some information that may help us with the data conversion.
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，我们将分析我们想要打开的文件中存储了哪些信息。我们将使用 OGR 来检查文件，并返回一些可能帮助我们进行数据转换的信息。
- en: 'First, let’s alter our open_vector_file function, allowing it to handle incorrect
    paths and filenames, which is a very a common error. Perform the following steps:
    1\. Go to the utils folder and open the geo_functions.py file.'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改我们的 open_vector_file 函数，使其能够处理不正确的路径和文件名，这是一个非常常见的错误。执行以下步骤：1. 前往 utils
    文件夹并打开 geo_functions.py 文件。
- en: '2\. Add the following import statements at the beginning of the file:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在文件开头添加以下导入语句：
- en: coding=utf-8
  id: totrans-1690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import ogr
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: import ogr
- en: import osr
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: import osr
- en: import gdal
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: import gdal
- en: import os
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: from pprint import pprint
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: from pprint import pprint
- en: '3\. Now, edit the open_vector_file function via the following code: def open_vector_file(file_path):'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: '3. 现在，通过以下代码编辑 open_vector_file 函数：def open_vector_file(file_path):'
- en: '"""Opens an vector file compatible with OGR, get the first layer and returns
    the ogr datasource.'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与 OGR 兼容的矢量文件，获取第一层并返回 OGR 数据源。'
- en: ':param str file_path: The full path to the file.'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: ':return: The ogr datasource.'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: ':return: OGR 数据源。'
- en: '"""'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: datasource = ogr.Open(file_path)
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = ogr.Open(file_path)
- en: Check if the file was opened.
  id: totrans-1702
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件是否已打开。
- en: 'if not datasource:'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not datasource:'
- en: 'if not os.path.isfile(file_path):'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not os.path.isfile(file_path):'
- en: message = "Wrong path."
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: message = "路径错误。"
- en: 'else:'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: message = "File format is invalid."
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: message = "文件格式无效。"
- en: raise IOError(
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: raise IOError(
- en: '''Error opening the file {}\n{}''.format('
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '''Error opening the file {}\n{}''.format('
- en: file_path, message))
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: file_path, message))
- en: layer = datasource.GetLayerByIndex(0)
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: layer = datasource.GetLayerByIndex(0)
- en: print("Opening {}".format(file_path))
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在打开 {}".format(file_path))
- en: 'print("Number of features: {}".format('
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("要素数量: {}".format('
- en: layer.GetFeatureCount()))
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: layer.GetFeatureCount()))
- en: return datasource
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: return datasource
- en: In this step, we added a verification to check whether the file was correctly
    opened. If the file doesn’t exist or if there are any other problems, OGR will
    be silent and the
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们添加了一个验证来检查文件是否正确打开。如果文件不存在或存在任何其他问题，OGR 将保持沉默，并且
- en: datasource will be empty. So, if the datasource is empty (None), we will know
    that something went wrong and perform another verification to see whether there
    was a mistake with the file path or something else happened. In either case, the
    program will raise an exception, preventing it from continuing with bad data.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: datasource 将会为空。所以，如果数据源为空（None），我们将知道出了些问题，并执行另一个验证来查看是否文件路径有误或其他情况发生。在任何情况下，程序将抛出异常，防止它继续使用错误的数据。
- en: '4\. Now, we will add another function to print some information about the datasource
    for us. After the open_vector_file function, add the get_datasource_information
    function with the following code:'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 现在，我们将添加另一个函数来打印有关数据源的一些信息。在 open_vector_file 函数之后，添加 get_datasource_information
    函数，代码如下：
- en: 'def get_datasource_information(datasource, print_results=False):'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_datasource_information(datasource, print_results=False):'
- en: '"""Get informations about the first layer in the datasource.'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: '"""获取数据源中第一层的信息。'
- en: ':param datasource: An OGR datasource.'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: ':param datasource: 一个 OGR 数据源。'
- en: ':param bool print_results: True to print the results on'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: ':param bool print_results: 如果为 True，则打印结果到屏幕。'
- en: the screen.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: the screen.
- en: '"""'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: info = {}
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: info = {}
- en: layer = datasource.GetLayerByIndex(0)
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: layer = datasource.GetLayerByIndex(0)
- en: bbox = layer.GetExtent()
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: bbox = layer.GetExtent()
- en: info['bbox'] = dict(xmin=bbox[0], xmax=bbox[1],
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: info['bbox'] = dict(xmin=bbox[0], xmax=bbox[1],
- en: ymin=bbox[2], ymax=bbox[3])
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: ymin=bbox[2], ymax=bbox[3])
- en: srs = layer.GetSpatialRef()
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: srs = layer.GetSpatialRef()
- en: 'if srs:'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 'if srs:'
- en: info['epsg'] = srs.GetAttrValue('authority', 1)
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: info['epsg'] = srs.GetAttrValue('authority', 1)
- en: 'else:'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: info['epsg'] = 'not available'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: info['epsg'] = 'not available'
- en: info['type'] = ogr.GeometryTypeToName(layer.GetGeomType())
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: info['type'] = ogr.GeometryTypeToName(layer.GetGeomType())
- en: Get the attributes names.
  id: totrans-1736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取属性名称。
- en: info['attributes'] = []
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: info['attributes'] = []
- en: layer_definition = layer.GetLayerDefn()
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: layer_definition = layer.GetLayerDefn()
- en: 'for index in range(layer_definition.GetFieldCount()):'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 'for index in range(layer_definition.GetFieldCount()):'
- en: info['attributes'].append(
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: info['attributes'].append(
- en: layer_definition.GetFieldDefn(index).GetName())
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: layer_definition.GetFieldDefn(index).GetName())
- en: Print the results.
  id: totrans-1742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印结果。
- en: 'if print_results:'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 'if print_results:'
- en: pprint(info)
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: pprint(info)
- en: return info
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: return info
- en: Here, we will use a number of OGR’s methods and functions to get information
    from the datasource and layer on it. This information is put in a dictionary,
    which is returned by the function. If we have print_results = True, the dictionary
    is printed with the pprint function (pretty print). This function tries to print
    Python objects in a more human-friendly way.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用OGR的许多方法和函数从数据源和层中获取信息。这些信息被放入一个字典中，该字典由函数返回。如果print_results = True，则使用pprint函数（美化打印）打印字典。此函数尝试以更人性化的方式打印Python对象。
- en: '5\. Now, to test our code, edit the if __name__ == ''__main__'': block at the
    end of the file, as follows:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: '5. 现在，为了测试我们的代码，编辑文件末尾的if __name__ == ''__main__'': 块，如下所示：'
- en: 'if __name__ == "__main__":'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: gdal.PushErrorHandler('CPLQuietErrorHandler')
- en: datasource = open_vector_file("../../data/geocaching.gpx") info = get_datasource_information(
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = open_vector_file("../../data/geocaching.gpx") info = get_datasource_information(
- en: datasource, print_results=True)
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: datasource, print_results=True)
- en: 'There is a new element here: gdal.PushErrorHandler(''CPLQuietErrorHandler'').'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个新元素：gdal.PushErrorHandler('CPLQuietErrorHandler').
- en: Geocaching files normally contain features with empty date fields. When OGR
    finds this situation, it prints a warning message. This could get pretty annoying
    when we have a lot of features. This command tells OGR/GDAL to suppress these
    messages so that we can have a clean output with only what we want to see.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 藏宝文件通常包含具有空日期字段的特征。当OGR遇到这种情况时，它会打印警告消息。当我们有很多特征时，这可能会相当烦人。此命令告诉OGR/GDAL抑制这些消息，以便我们可以得到一个干净的输出，只显示我们想要看到的内容。
- en: '6\. Run the code, press *Alt* + *Shift* + *F10*, and select **geo_functions**.
    You should get the following output showing the information that is collected:
    Opening ../../data/geocaching.gpx'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 运行代码，按*Alt* + *Shift* + *F10*，选择**geo_functions**。你应该得到以下输出，显示收集到的信息：打开 ../../data/geocaching.gpx
- en: 'Number of features: 130'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 特征数量：130
- en: '{''attributes'': [''ele'','
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '{''attributes'': [''ele'','
- en: '''time'','
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: '''time'','
- en: '''magvar'','
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: '''magvar'','
- en: '''geoidheight'','
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '''geoidheight'','
- en: '''name'','
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: '''name'','
- en: '''cmt'','
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '''cmt'','
- en: '''desc'','
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: '''desc'','
- en: '''src'','
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: '''src'','
- en: '''url'','
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: '''url'','
- en: '''urlname'','
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: '''urlname'','
- en: '''sym'','
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '''sym'','
- en: '''type'','
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: '''type'','
- en: '''fix'','
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: '''fix'','
- en: '''sat'','
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: '''sat'','
- en: '''hdop'','
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: '''hdop'','
- en: '''vdop'','
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: '''vdop'','
- en: '''pdop'','
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: '''pdop'','
- en: '''ageofdgpsdata'','
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: '''ageofdgpsdata'','
- en: '''dgpsid''],'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: '''dgpsid''],'
- en: '''bbox'': {''xmax'': -73.44602,'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: '''bbox'': {''xmax'': -73.44602,'
- en: '''xmin'': -79.3536,'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: '''xmin'': -79.3536,'
- en: '''ymax'': 44.7475,'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '''ymax'': 44.7475,'
- en: '''ymin'': 40.70558},'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '''ymin'': 40.70558},'
- en: '''epsg'': ''4326'','
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: '''epsg'': ''4326'','
- en: '''type'': ''Point''}'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: '''type'': ''Point''}'
- en: Process finished with exit code 0
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: '**Note**'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The attributes key of the dictionary contains the field names that could be
    read from the data. Every feature on our GPX file (that is, every point) contains
    this set of attributes. The bbox code is the bounding box of the data, which are
    the coordinates of the upper-left and lower-right corners of the rectangle that
    comprises the geographical extent of the data. The epsg code contains the code
    for the coordinate system of the data. Finally, type is the type of geometry identified
    by OGR.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的属性键包含可以从数据中读取的字段名。我们GPX文件上的每个要素（即每个点）都包含这个属性集。bbox代码是数据的边界框，是包含数据地理范围的矩形的左上角和右下角的坐标。epsg代码包含数据的坐标系统代码。最后，type是OGR识别的几何类型。
- en: '**Reading GPX attributes**'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取GPX属性**'
- en: Take a look at the attributes (field names) found by OGR in the previous example;
    we have a name, a description, and the time. We have some technical data about
    the GPS
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，查看OGR找到的属性（字段名）；我们有一个名称、一个描述和日期。我们有一些关于GPS的技术数据
- en: solution (pdop, hdop, sat, fix, and many more) and some other fields, but none
    of them contains in-depth information about the geocache.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: solution (pdop, hdop, sat, fix, and many more) 和一些其他字段，但它们都不包含关于藏宝地点的深入信息。
- en: 'In order to take a look at what information the GPX file contains that OGR
    is not displaying, let’s open it in PyCharm:'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看GPX文件包含的信息，OGR没有显示，让我们在PyCharm中打开它：
- en: 1\. In your geopy project, go to the data folder.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在你的geopy项目中，进入数据文件夹。
- en: 2\. Locate geocaching.gpx. To open it, either drag and drop it in the editor
    area or double-click on the filename.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 定位geocaching.gpx。要打开它，可以将它拖放到编辑区域或双击文件名。
- en: PyCharm will open it for editing but won’t recognize the file format and will
    display it in a single color; so, let’s inform it that this is an XML file.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm将打开它以进行编辑，但不会识别文件格式，并以单色显示；因此，让我们通知它这是一个XML文件。
- en: 3\. Right-click on the geocaching.gpx file. In the menu, select **Associate
    with File** **Type**, and a window with a list will pop up. Select **XML Files**
    and then click on the **OK** button.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 右键单击geocaching.gpx文件。在菜单中，选择**关联文件类型**，并弹出一个包含列表的窗口。选择**XML文件**，然后点击**确定**按钮。
- en: 'Now, the contents of the GPX file should appear with colors differentiating
    the various elements of the extended markup language. PyCharm is also capable
    of recognizing the file structure, as it does with Python. Let’s take a look via
    the following steps: 1\. Press *Alt* + *7* or navigate to the **View** | **Tool
    Windows** | **Structure** menu.'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GPX文件的内容应该以不同颜色区分扩展标记语言的各个元素显示。PyCharm也能够识别文件结构，就像它识别Python一样。让我们通过以下步骤查看：1.
    按下*Alt* + *7*或导航到**视图** | **工具窗口** | **结构**菜单。
- en: '![Image 17](img/index-159_1.jpg)'
  id: totrans-1793
  prefs: []
  type: TYPE_IMG
  zh: '![图像 17](img/index-159_1.jpg)'
- en: 2\. This is the GPX file structure. Note that after some initial tags, it contains
    all the waypoints. Click on the arrow to the left of any waypoint to expand it.
    Then, locate the waypoint’s geocache tag and expand it too.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 这是GPX文件结构。请注意，在初始标签之后，它包含所有航点。点击任何航点左侧的箭头以展开它。然后，找到航点的地理藏宝标签并展开它。
- en: '![Image 18](img/index-160_1.jpg)'
  id: totrans-1795
  prefs: []
  type: TYPE_IMG
  zh: '![图像 18](img/index-160_1.jpg)'
- en: 3\. As you can note, the geocaching point contains much more information than
    OGR is capable of reading, including the status attribute of the geocache tag.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如您所注意到的，地理藏宝点包含的信息比OGR能够读取的要多得多，包括地理藏宝标签的状态属性。
- en: 4\. Before we proceed, explore the file to get familiar with its notation. Click
    on some of the tags and look at the code editor to see the contents.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 在我们继续之前，先探索一下文件，熟悉其符号表示。点击一些标签，查看代码编辑器以查看内容。
- en: Since we can’t access these attributes directly with OGR, we will program an
    alternative.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法直接使用OGR访问这些属性，我们将编写一个替代方案。
- en: 'The objective is to read this information and flatten it in a single level
    of key/value pairs in a dictionary. GPX files are XML files, so we can use an
    XML parser to read them. The choice here is the xmltodict package; it will simply
    convert the XML file into a Python dictionary, making it easier to manipulate
    as we are very familiar with dictionaries. Now, perform the following steps:'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是读取这些信息，并将其展平为字典中的单个键/值对级别。GPX文件是XML文件，因此我们可以使用XML解析器来读取它们。这里的选择是xmltodict包；它将简单地将XML文件转换为Python字典，这使得我们更容易操作，因为我们非常熟悉字典。现在，执行以下步骤：
- en: '1\. Add the import of xmltodict at the beginning of the geo_functions.py file
    by executing the following code:'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在geo_functions.py文件的开始处添加对xmltodict的导入，执行以下代码：
- en: coding=utf-8
  id: totrans-1801
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import xmltodict
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 导入xmltodict
- en: import ogr
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 导入ogr
- en: import osr
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 导入osr
- en: import gdal
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 导入gdal
- en: import os
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 导入os
- en: from pprint import pprint
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 从pprint导入pprint
- en: '2\. Create a new function before open_vector_file and add the following code:
    def read_gpx_file(file_path):'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 在open_vector_file之前创建一个新函数，并添加以下代码：def read_gpx_file(file_path):'
- en: '"""Reads a GPX file containing geocaching points.'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: '"""读取包含地理藏宝点的GPX文件。'
- en: ':param str file_path: The full path to the file.'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'with open(file_path) as gpx_file:'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(file_path) as gpx_file:'
