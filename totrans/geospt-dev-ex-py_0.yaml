- en: '![Image 1](img/index-1_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Geospatial Development By Example with**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table of Contents**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Geospatial Development By Example with Python](#p13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Credits](#p15)'
  prefs: []
  type: TYPE_NORMAL
- en: '[About the Author](#p17)'
  prefs: []
  type: TYPE_NORMAL
- en: '[About the Reviewers](#p19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.PacktPub.com](#p21)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Support files, eBooks, discount offers, and more](#p23)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why subscribe?](#p24)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Free access for Packt account holders](#p25)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Preface](#p26)'
  prefs: []
  type: TYPE_NORMAL
- en: '[What this book covers](#p28)'
  prefs: []
  type: TYPE_NORMAL
- en: '[What you need for this book](#p30)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Who this book is for](#p32)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Conventions](#p34)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Reader feedback](#p36)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Customer support](#p38)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Downloading the example code](#p40)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Downloading the color images of this book](#p41)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Errata](#p42)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Piracy](#p43)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Questions](#p44)'
  prefs: []
  type: TYPE_NORMAL
- en: '[1\. Preparing the Work Environment](#p45)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing Python](#p47)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Windows](#p48)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](#p49)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Python packages and package manager](#p50)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The repository of Python packages for Windows](#p52)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing packages and required software](#p53)'
  prefs: []
  type: TYPE_NORMAL
- en: '[OpenCV](#p55)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Windows](#p56)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](#p57)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing NumPy](#p58)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Windows](#p60)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](#p61)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing GDAL and OGR](#p62)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Windows](#p66)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](#p67)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing Mapnik](#p68)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Windows](#p70)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](#p71)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing Shapely](#p72)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Windows](#p74)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](#p75)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing other packages directly from pip](#p76)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Windows](#p78)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ubuntu Linux](#p79)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing an IDE](#p80)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Windows](#p82)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Linux](#p83)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating the book project](#p84)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Programming and running your first example](#p88)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Transforming the coordinate system and calculating the area of all countries](#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sort the countries by area size](#p98)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#p101)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2\. The Geocaching App](#p103)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Building the basic application structure](#p105)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating the application tree structure](#p106)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Functions and methods](#p107)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Documenting your code](#p108)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating the application entry point](#p109)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Downloading geocaching data](#p112)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Geocaching data sources](#p114)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fetching information from a REST API](#p115)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Downloading data from a URL](#p117)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Downloading data manually](#p119)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Opening the file and getting its contents](#p122)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Preparing the content for analysis](#p125)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Combining functions into an application](#p126)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting your current location](#p130)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Finding the closest point](#p134)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#p140)'
  prefs: []
  type: TYPE_NORMAL
- en: '[3\. Combining Multiple Data Sources](#p142)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Representing geographic data](#p144)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Representing geometries](#p146)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Making data homogeneous](#p148)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The concept of abstraction](#p150)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Abstracting the geocache point](#p151)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Abstracting geocaching data](#p153)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Importing geocaching data](#p154)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Reading GPX attributes](#p158)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Returning the homogeneous data](index_split_001.html#p163)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Converting the data into Geocache objects](index_split_001.html#p165)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Merging multiple sources of data](index_split_001.html#p167)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Integrating new functionality into the application](index_split_001.html#p169)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p172)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4\. Improving the App Search Capabilities](index_split_001.html#p174)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with polygons](index_split_001.html#p176)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Knowing well-known text](index_split_001.html#p177)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Shapely to handle geometries](index_split_001.html#p180)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Importing polygons](index_split_001.html#p183)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Getting the attributes’ values](index_split_001.html#p191)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Importing lines](index_split_001.html#p194)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Converting the spatial reference system and units](index_split_001.html#p198)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Geometry relationships](index_split_001.html#p203)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Touches](index_split_001.html#p205)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Crosses](index_split_001.html#p206)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Contains](index_split_001.html#p207)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Within](index_split_001.html#p208)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Equals or almost equals](index_split_001.html#p209)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Intersects](index_split_001.html#p210)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Disjoint](index_split_001.html#p211)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Filtering by attributes and relations](index_split_001.html#p212)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Filtering by multiple attributes](index_split_001.html#p217)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chaining filters](index_split_001.html#p219)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Integrating with the app](index_split_001.html#p221)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p225)'
  prefs: []
  type: TYPE_NORMAL
- en: '[5\. Making Maps](index_split_001.html#p227)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Knowing Mapnik](index_split_001.html#p229)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Making a map with pure Python](index_split_001.html#p230)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Making a map with a style sheet](index_split_001.html#p232)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating utility functions to generate maps](index_split_001.html#p234)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Changing the data source at runtime](index_split_001.html#p236)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Automatically previewing the map](index_split_001.html#p239)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Styling maps](index_split_001.html#p241)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Map style](index_split_001.html#p243)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Polygon style](index_split_001.html#p244)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Line styles](index_split_001.html#p246)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Text styles](index_split_001.html#p248)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Adding layers to the map](index_split_001.html#p249)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Point styles](index_split_001.html#p252)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Python objects as a source of data](index_split_001.html#p254)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Exporting geo objects](index_split_001.html#p259)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating the Map Maker app](index_split_001.html#p263)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using PythonDatasource](index_split_002.html#p267)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the app with filtering](index_split_002.html#p273)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p275)'
  prefs: []
  type: TYPE_NORMAL
- en: '[6\. Working with Remote Sensing Images](index_split_002.html#p277)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Understanding how images are represented](index_split_002.html#p279)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Opening images with OpenCV](index_split_002.html#p282)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Knowing numerical types](index_split_002.html#p284)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Processing remote sensing images and data](index_split_002.html#p286)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mosaicking images](index_split_002.html#p289)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Adjusting the values of the images](index_split_002.html#p294)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cropping an image](index_split_002.html#p296)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating a shaded relief image](index_split_002.html#p298)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Building an image processing pipeline](index_split_002.html#p300)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating a RasterData class](index_split_002.html#p303)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p310)'
  prefs: []
  type: TYPE_NORMAL
- en: '[7\. Extract Information from Raster Data](index_split_002.html#p312)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Getting the basic statistics](index_split_002.html#p314)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Preparing the data](index_split_002.html#p316)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Printing simple information](index_split_002.html#p317)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Formatting the output information](index_split_002.html#p319)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Calculating quartiles, histograms, and other statistics](index_split_002.html#p321)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Making statistics a lazy property](index_split_002.html#p323)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating color classified images](index_split_002.html#p325)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Choosing the right colors for a map](index_split_002.html#p329)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Blending images](index_split_002.html#p336)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Showing statistics with colors](index_split_002.html#p339)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the histogram to colorize the image](index_split_002.html#p342)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_002.html#p345)'
  prefs: []
  type: TYPE_NORMAL
- en: '[8\. Data Miner App](index_split_002.html#p347)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Measuring execution time](index_split_002.html#p350)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Code profiling](index_split_002.html#p354)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Storing information on a database](index_split_002.html#p356)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating an Object Relational Mapping](index_split_002.html#p358)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Preparing the environment](index_split_002.html#p359)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Changing our models](index_split_002.html#p360)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Customizing a manager](index_split_002.html#p360)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Generating the tables and importing data](index_split_002.html#p365)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Filtering the data](index_split_002.html#p367)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Importing massive amount of data](index_split_003.html#p368)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Optimizing database inserts](index_split_003.html#p370)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Optimizing data parsing](index_split_003.html#p373)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Importing OpenStreetMap points of interest](index_split_003.html#p376)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Removing the test data](index_split_003.html#p380)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Populating the database with real data](index_split_003.html#p381)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Searching for data and crossing information](index_split_003.html#p385)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Filtering using boundaries](index_split_003.html#p388)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p390)'
  prefs: []
  type: TYPE_NORMAL
- en: '[9\. Processing Big Images](index_split_003.html#p392)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with satellite images](index_split_003.html#p394)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Getting Landsat 8 images](index_split_003.html#p396)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Memory and images](index_split_003.html#p399)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Processing images in chunks](index_split_003.html#p403)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using GDAL to open images](index_split_003.html#p405)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Iterating through the whole image](index_split_003.html#p408)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating image compositions](index_split_003.html#p412)'
  prefs: []
  type: TYPE_NORMAL
- en: '[True color compositions](index_split_003.html#p414)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Processing specific regions](index_split_003.html#p417)'
  prefs: []
  type: TYPE_NORMAL
- en: '[False color compositions](index_split_003.html#p419)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p422)'
  prefs: []
  type: TYPE_NORMAL
- en: '[10\. Parallel Processing](index_split_003.html#p424)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiprocessing basics](index_split_003.html#p426)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Block iteration](index_split_003.html#p430)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Improving the image resolution](index_split_003.html#p436)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Image resampling](index_split_003.html#p438)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pan sharpening](index_split_003.html#p446)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_003.html#p450)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Index](index_split_003.html#p452)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geospatial Development By Example with**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geospatial Development By Example with**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright © 2016 Packt Publishing
  prefs: []
  type: TYPE_NORMAL
- en: All rights reserved. No part of this book may be reproduced, stored in a retrieval
    system, or transmitted in any form or by any means, without the prior written
    permission of the publisher, except in the case of brief quotations embedded in
    critical articles or reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Every effort has been made in the preparation of this book to ensure the accuracy
    of the information presented. However, the information contained in this book
    is sold without warranty, either express or implied. Neither the author, nor Packt
    Publishing, and its dealers and distributors will be held liable for any damages
    caused or alleged to be caused directly or indirectly by this book.
  prefs: []
  type: TYPE_NORMAL
- en: Packt Publishing has endeavored to provide trademark information about all of
    the companies and products mentioned in this book by the appropriate use of capitals.
  prefs: []
  type: TYPE_NORMAL
- en: However, Packt Publishing cannot guarantee the accuracy of this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'First published: January 2016'
  prefs: []
  type: TYPE_NORMAL
- en: 'Production reference: 1250116'
  prefs: []
  type: TYPE_NORMAL
- en: Published by Packt Publishing Ltd.
  prefs: []
  type: TYPE_NORMAL
- en: Livery Place
  prefs: []
  type: TYPE_NORMAL
- en: 35 Livery Street
  prefs: []
  type: TYPE_NORMAL
- en: Birmingham B3 2PB, UK.
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-78528-235-5
  prefs: []
  type: TYPE_NORMAL
- en: '[www.packtpub.com](http://www.packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Credits**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Author**'
  prefs: []
  type: TYPE_NORMAL
- en: Pablo Carreira
  prefs: []
  type: TYPE_NORMAL
- en: '**Reviewers**'
  prefs: []
  type: TYPE_NORMAL
- en: Brylie Christopher Oxley
  prefs: []
  type: TYPE_NORMAL
- en: Vivek Kumar Singh
  prefs: []
  type: TYPE_NORMAL
- en: Claudio Sparpaglione
  prefs: []
  type: TYPE_NORMAL
- en: '**Commissioning Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: Sarah Crofton
  prefs: []
  type: TYPE_NORMAL
- en: '**Acquisition Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: Meeta Rajani
  prefs: []
  type: TYPE_NORMAL
- en: '**Content Development Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: Rashmi Suvarna
  prefs: []
  type: TYPE_NORMAL
- en: '**Technical Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: Shivani Kiran Mistry
  prefs: []
  type: TYPE_NORMAL
- en: '**Copy Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: Akshata Lobo
  prefs: []
  type: TYPE_NORMAL
- en: '**Project Coordinator**'
  prefs: []
  type: TYPE_NORMAL
- en: Judie Jose
  prefs: []
  type: TYPE_NORMAL
- en: '**Proofreader**'
  prefs: []
  type: TYPE_NORMAL
- en: Safis Editing
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexer**'
  prefs: []
  type: TYPE_NORMAL
- en: Hemangini Bari
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphics**'
  prefs: []
  type: TYPE_NORMAL
- en: Disha Haria
  prefs: []
  type: TYPE_NORMAL
- en: '**Production Coordinator**'
  prefs: []
  type: TYPE_NORMAL
- en: Nilesh Mohite
  prefs: []
  type: TYPE_NORMAL
- en: '**Cover Work**'
  prefs: []
  type: TYPE_NORMAL
- en: Nilesh Mohite
  prefs: []
  type: TYPE_NORMAL
- en: '**About the Author**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pablo Carreira** is a Python programmer and a full stack developer living
    in São Paulo state, Brazil. He is now the lead developer of an advanced web platform
    for precision agriculture and actively uses Python as a backend solution for efficient
    geoprocessing.'
  prefs: []
  type: TYPE_NORMAL
- en: Born in 1980, Brazil, Pablo graduated as an agronomical engineer. Being a programming
    enthusiast and self-taught since childhood, he learned programming as a hobby
    and later honored his techniques in order to solve work tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Having 8 years of professional experience in geoprocessing, he uses Python along
    with geographic information systems in order to automate processes and solve problems
    related to precision agriculture, environmental analysis, and land division.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to thank my mother and father for the support given through all
    my life. I also would like to thank my wife for her help and patience in face
    of my absence during all the writing sessions.
  prefs: []
  type: TYPE_NORMAL
- en: I thank my university teacher José Paulo Molin, who first introduced me to geoprocessing
    and precision agriculture and created in me a deep interest in the area and gave
    the means for my development. Finally, I thank my good friend Gerardo F. E. Perez
    for all the opportunities that he presented me with and for the uncountable hours
    of good technical discussions.
  prefs: []
  type: TYPE_NORMAL
- en: '**About the Reviewers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Brylie Christopher Oxley** enjoys working on technology projects that improve
    the human and environmental commons. He is dedicated to working for open source,
    open web, and open knowledge movements.'
  prefs: []
  type: TYPE_NORMAL
- en: He regularly contributes to open source projects primarily built with web platform
    technologies, including a wellbeing visualization application for aging populations
    and a community portal for refugee support.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you Elvin, Lauri, Antti, Marjo, and Lynne for being the shining stars
    of my life.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vivek Kumar Singh** is a research scholar at the center of atmospheric science,
    Indian Institute of Technology, Delhi (IIT Delhi). He has completed his master’s
    in technology in Remote Sensing and GIS from the Indian Institute of Remote Sensing,
    ISRO, in Dehradun, Uttarakhand, India. He focused on the different applications
    of Remote Sensing and GIS using geocomputational modeling with satellite observations
    during his time in graduate school. His main research expertise is in the application
    of satellite remote sensing for air quality monitoring and assessment, urban heat
    island and remote sensing, and geographical systems around the world. He is also
    interested in researching the air quality in growing megacities, spatial and temporal
    trends in aerosols over urban regions, the radiative effects of aerosols, the
    development of statistical models to estimate surface level particulate matter
    air quality, aerosols and clouds data validation, and the retrieval of cloud products
    from UV satellite measurements. He is also an associate with the BhuNak science
    team on the development and validation of new GIS products for climate studies.'
  prefs: []
  type: TYPE_NORMAL
- en: He also currently participated in developing and conducting remote sensing technical
    workshops and capacity building activities for the BhuNak Program, where he teaches
    the application of satellite imagery to environmental decision-making activities
    with a focus on urban living quality.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to thank Vaibhav Kumar, PhD Scholar at the Center of Urban Science
    and Engineering, Indian Institute of Technology, Bombay (IIT-Bombay), for his
    contribution (cofounder of BhuNak Research Group). A special thank you to ML Singh
    (father), Prashant Kumar Singh (brother), and Kimeera Tummala (friend) for their
    contribution in my life.
  prefs: []
  type: TYPE_NORMAL
- en: '**Claudio Sparpaglione** is a CTO at WalletSaver, an Italian startup rocking
    in the mobile phone tariff comparison landscape. His work experience includes
    the design and building of geospatial applications and web-oriented systems in
    the online advertisement industry.'
  prefs: []
  type: TYPE_NORMAL
- en: A passionate Pythonista and open-source advocate, he’s a maintainer of the PyOWM
  prefs: []
  type: TYPE_NORMAL
- en: project and actively involved in the community with contributions to projects
    such as Python-Requests and Reactive Manifesto. His main interests include high-scalable
    web architectures, APIs design, and cloud computing.
  prefs: []
  type: TYPE_NORMAL
- en: '**www.PacktPub.com**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 2](img/index-23_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Support files, eBooks, discount offers, and**'
  prefs: []
  type: TYPE_NORMAL
- en: '**more**'
  prefs: []
  type: TYPE_NORMAL
- en: For support files and downloads related to your book, please visit [www.PacktPub.com.](http://www.PacktPub.com)
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that Packt offers eBook versions of every book published, with
    PDF and ePub files available? You can upgrade to the eBook version at [www.PacktPub.com](http://www.PacktPub.com)
    and as a print book customer, you are entitled to a discount on the eBook copy.
    Get in touch with us at < [service@packtpub.com](mailto:service@packtpub.com)>
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: At [www.PacktPub.com,](http://www.PacktPub.com) you can also read a collection
    of free technical articles, sign up for a range of free newsletters and receive
    exclusive discounts and offers on Packt books and eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www2.packtpub.com/books/subscription/packtlib](https://www2.packtpub.com/books/subscription/packtlib)'
  prefs: []
  type: TYPE_NORMAL
- en: Do you need instant solutions to your IT questions? PacktLib is Packt’s online
    digital book library. Here, you can search, access, and read Packt’s entire library
    of books.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why subscribe?**'
  prefs: []
  type: TYPE_NORMAL
- en: Fully searchable across every book published by Packt
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  prefs: []
  type: TYPE_NORMAL
- en: On demand and accessible via a web browser
  prefs: []
  type: TYPE_NORMAL
- en: '**Free access for Packt account holders**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have an account with Packt at [www.PacktPub.com,](http://www.PacktPub.com)
    you can use this to access PacktLib today and view 9 entirely free books. Simply
    use your login credentials for immediate access.
  prefs: []
  type: TYPE_NORMAL
- en: '**Preface**'
  prefs: []
  type: TYPE_NORMAL
- en: From Python programming good practices to the advanced use of analysis packages,
    this book teaches how to write applications that will perform complex geoprocessing
    tasks that can be replicated and reused. The book contains three sample applications.
    [Chapter 1](#p45)
  prefs: []
  type: TYPE_NORMAL
- en: shows how to prepare a development environment. From [Chapter 2](#p103) to [Chapter
    4,](index_split_001.html#p174) the reader goes deep into Python functionality
    using classes, inheritance, and other resources in order to read, manipulate,
    combine, and search information in vector data. [Chapter 5](index_split_001.html#p227)
    to
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](index_split_002.html#p312) presents techniques to render beautiful
    maps, and handle and analyze raster data. In the final three chapters, the book
    approaches code optimization and presents solutions to handle large datasets common
    in geoprocessing tasks. All the examples are modular and can be rearranged to
    achieve countless different results. During the book, the code is deduced step
    by step until it reaches the final form. The reader is led to edit, change, and
    improve the code, experimenting with different solutions and organizations, subtly
    learning the mental process of the development of a geoprocessing application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What this book covers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1,](#p45) *Preparing the Work Environment*, shows the processes of
    installing all the libraries that you will need to go through the examples in
    the book, as well how to set up an integrated development environment (IDE) that
    will help organize the code and avoid mistakes. Finally, it will present the first
    contact with one of the geospatial libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2,](#p103) *The Geocaching App*, will go through the important steps
    in geoprocessing applications, such as opening files, reading data, and preparing
    it for analysis with the tools at hand. Going through these steps, the user will
    learn how to organize and use the resources provided by the language to write
    consistent applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3,](#p142) *Combining Multiple Data Sources*, will cover the process
    of combining sources, and how to use Python classes to create your own representation
    of geospatial data. Geographic data tends to be heterogeneous, so writing programs
    that are able to combine multiple sources of data is a fundamental topic in geoprocessing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4,](index_split_001.html#p174) *Improving the App Search Capabilities*,
    will add new functionalities to the application. Users will write a code capable
    of filtering features by geographic boundaries and by any field in the data. In
    the process, they will see how to work with polygons and how the relations between
    geometries can be analyzed in a geoprocessing application.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5,](index_split_001.html#p227) *Making Maps*, starts a new application
    that will be able to produce nice maps from the vectors of the data. Mapnik, one
    of the most used mapping packages, will be used. The user will understand how
    it works and how to adapt it to consume the data presented in the previous chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6,](index_split_002.html#p277) *Working with Remote Sensing Images*,
    will present a process of deduction that will result in a versatile and powerful
    software structure able to combine, crop, and adjust the values of images to prepare
    them for presentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7,](index_split_002.html#p312) *Extract Information from Raster Data*,
    will approach the process of extracting information from raster data, which can
    be analyzed in order to produce valuable information. Going beyond simple numerical
    values, it will show how to display this information on beautiful color maps.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8,](index_split_002.html#p347) *Data Miner App*, will show how to
    use databases and how to import data into it in order to minimize processing time
    and allow huge datasets to be processed. Geospatial data tends to be extensive
    and its processing demands a lot of computer power. To make the code more efficient,
    the reader will learn techniques of code profiling and optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9,](index_split_003.html#p392) *Processing Big Images*, will show
    how to process big satellite images. It will focus on how to perform sustainable
    image processing and how to open and make calculations with many big images while
    keeping the memory consumption low with efficient code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](index_split_003.html#p424), *Parallel Processing*, will teach
    the reader how to use the full available computer power. In order to speed up
    tasks, it will show how to distribute them among'
  prefs: []
  type: TYPE_NORMAL
- en: processor cores for parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: '**What you need for this book**'
  prefs: []
  type: TYPE_NORMAL
- en: To run the examples of this book, you will only need a computer with at least
    4 GB of RAM with the Ubuntu Linux or Microsoft Windows operating system. All the
    programs and libraries that we will use are either free of charge or open source.
  prefs: []
  type: TYPE_NORMAL
- en: '**Who this book is for**'
  prefs: []
  type: TYPE_NORMAL
- en: This book is intended for beginners or advanced developers in Python, who want
    to work with geographic data. The book is suitable for professional developers
    who are new to geospatial development, for hobbyists, or for data scientists who
    want to move into simple development.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conventions**'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you will find a number of text styles that distinguish between
    different kinds of information. Here are some examples of these styles and an
    explanation of their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code words in text, database table names, folder names, filenames, file extensions,
    pathnames, dummy URLs, user input, and Twitter handles are shown as follows: “A
    Python package is a directory containing one or more Python files (that is, modules)
    plus one __init__.py file.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'A block of code is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: Open the shapefile and get the first layer.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(layer.GetFeatureCount())) When we wish
    to draw your attention to a particular part of a code block, the relevant lines
    or items are set in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: '**vector_data = PointCollection("../data/geocaching.gpx")** vector_data.print_information()'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any command-line input or output is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collecting django**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading Django-1.9-py2.py3-none-any.whl (6.6MB)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**100% |################################| 6.6MB 43kB/s** **Installing collected
    packages: django**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Successfully installed django-1.9**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New terms** and **important words** are shown in bold. Words that you see
    on the screen, for example, in menus or dialog boxes, appear in the text like
    this: “Proceed with the default options by clicking on the **Next** button.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Warnings or important notes appear in a box like this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks appear like this.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reader feedback**'
  prefs: []
  type: TYPE_NORMAL
- en: Feedback from our readers is always welcome. Let us know what you think about
    this book—what you liked or disliked. Reader feedback is important for us as it
    helps us develop titles that you will really get the most out of.
  prefs: []
  type: TYPE_NORMAL
- en: To send us general feedback, simply e-mail [<feedback@packtpub.com>](mailto:feedback@packtpub.com)
    , and mention the book’s title in the subject of your message.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a topic that you have expertise in and you are interested in either
    writing or contributing to a book, see our author guide at [www.packtpub.com/authors](http://www.packtpub.com/authors).
  prefs: []
  type: TYPE_NORMAL
- en: '**Customer support**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are the proud owner of a Packt book, we have a number of things
    to help you to get the most from your purchase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
  prefs: []
  type: TYPE_NORMAL
- en: for all the Packt Publishing books you have purchased. If you purchased this
    book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading the color images of this book** We also provide you with a PDF
    file that has color images of the screenshots/diagrams used in this book. The
    color images will help you better understand the changes in the output. You can
    download this file from'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/sites/default/files/downloads/GeospatialDevelopmentByExamp](https://www.packtpub.com/sites/default/files/downloads/GeospatialDevelopmentByExampleWithPython_ColorImages.pdf)leWithPython_ColorImages.pdf'
  prefs: []
  type: TYPE_NORMAL
- en: '**Errata**'
  prefs: []
  type: TYPE_NORMAL
- en: Although we have taken every care to ensure the accuracy of our content, mistakes
    do happen. If you find a mistake in one of our books—maybe a mistake in the text
    or the code—we would be grateful if you could report this to us. By doing so,
    you can save other readers from frustration and help us improve subsequent versions
    of this book. If you find any errata, please report them by visiting [http://www.packtpub.com/submit-errata](http://www.packtpub.com/submit-errata),
    selecting your book, clicking on the **Errata Submission Form** link, and entering
    the details of your errata. Once your errata are verified, your submission will
    be accepted and the errata will be uploaded to our website or added to any list
    of existing errata under the Errata section of that title.
  prefs: []
  type: TYPE_NORMAL
- en: To view the previously submitted errata, go to
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)
    and enter the name of the book in the search field. The required information will
    appear under the **Errata** section.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Piracy**'
  prefs: []
  type: TYPE_NORMAL
- en: Piracy of copyrighted material on the Internet is an ongoing problem across
    all media. At Packt, we take the protection of our copyright and licenses very
    seriously. If you come across any illegal copies of our works in any form on the
    Internet, please provide us with the location address or website name immediately
    so that we can pursue a remedy.
  prefs: []
  type: TYPE_NORMAL
- en: Please contact us at [<copyright@packtpub.com](mailto:copyright@packtpub.com)>
    with a link to the suspected pirated material.
  prefs: []
  type: TYPE_NORMAL
- en: We appreciate your help in protecting our authors and our ability to bring you
    valuable content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Questions**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a problem with any aspect of this book, you can contact us at
  prefs: []
  type: TYPE_NORMAL
- en: '[<questions@packtpub.com](mailto:questions@packtpub.com)>, and we will do our
    best to address the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 1\. Preparing the Work**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Environment**'
  prefs: []
  type: TYPE_NORMAL
- en: Working with a programming language as a tool for geoprocessing provides the
    opportunity to construct a personalized application that can more optimally perform
    the task required by the user. This means that repetitive tasks can be automated,
    file inputs and outputs can be customized, and processes can be tuned to perform
    exactly what you want to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is a powerful programming language that is gaining special attention
    as a tool for geoprocessing and scientific analysis. A number of factors may have
    contributed to its popularization, and three among them are worth mentioning:
    it’s a scripting language, it’s flexible and easy to learn, and it has a wide
    range of libraries available as open source software.'
  prefs: []
  type: TYPE_NORMAL
- en: The number of available libraries and packages allow users to spend less time
    in programming basic functionalities and more in building processes and workflows
    to reach their goals.
  prefs: []
  type: TYPE_NORMAL
- en: In this first chapter, we will go through the process of installing all the
    libraries that you will need to go through the examples; it’s likely that these
    same libraries will also satisfy most of your needs in real-world applications.
    Then, we will set up an **Integrated** **Development Environment** (**IDE**) that
    will help organize code and avoid mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will write a sample program with one of the libraries. Therefore,
    here are the topics that will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python and the packages that you need for the examples in this book
    Learning the basics of the packages that you will use
  prefs: []
  type: TYPE_NORMAL
- en: Installing an IDE to write and organize your code
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project for this book
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first code
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Python**'
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we suggest using Python 2.7; this version of Python is fully
    compatible with the libraries and packages that we will use in the examples and
    also has precompiled binary files available on the Internet for Windows users.
    We will keep all the examples as compatible as possible with Python 3.4 so that
    it would be easy to port future upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: Windows users may find compatibility problems with the 64-bit packages, so we
    recommend the 32-bit version of Python for them.
  prefs: []
  type: TYPE_NORMAL
- en: For Linux users, we will show the installation procedures for Ubuntu Linux distribution
    and use package managers, so you don’t need to worry about versions and requirements;
    the package managers will do this for you.
  prefs: []
  type: TYPE_NORMAL
- en: The libraries that you will install are written in Python and other languages,
    the most common being C and C++. These libraries can abstract classes, methods,
    and functions to Python objects or have an extra layer that makes the connection;
    when this happens, we say that the library has *Python bindings*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to perform for the installation of Python on Windows: 1\.
    Go to [https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)
    and click on Download the latest Python 2.7 release for Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. On the next page, roll down, and you will find a list of files; make sure
    that you download **Windows x86 MSI installer**.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. After the file is downloaded, open the installer by clicking on the file
    and following the instructions. Proceed with the default options by clicking on
    the **Next** button.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu already comes with Python installed, so there is no need to install
    it. If for any reason, it’s not available, you can install it with the following
    command: sudo apt-get install python'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 2.7.9 comes with Pip, but if you use an older version, you need to install
    Pip with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get install python-pip
  prefs: []
  type: TYPE_NORMAL
- en: '**Python packages and package manager**'
  prefs: []
  type: TYPE_NORMAL
- en: A Python package is a directory containing one or more Python files (that is,
    modules) plus one __init__.py file (this can be just an empty file). This file
    tells Python Interpreter that the directory is a package.
  prefs: []
  type: TYPE_NORMAL
- en: When writing Python code, we can import packages and modules and use them in
    our code. The Python community does this a lot; many packages use other packages
    and so on, forming an intricate network of requirements and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In order to facilitate the installation of packages and all the requirements
    for it to run, Python has a package manager called pip.
  prefs: []
  type: TYPE_NORMAL
- en: Pip looks for packages in a central repository (or on a user-defined place),
    downloads it, then downloads its dependencies, and installs them. Some packages
    also use libraries in other languages, such as C. In these cases, these libraries
    need to be compiled during the installation. Ubuntu users don’t have problem with
    this because many compilers are already installed on the system, but this won’t
    work on Windows by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**The repository of Python packages for Windows** Python makes it easy to install
    libraries and packages through pip. However, since Windows doesn’t include any
    compiler by default, the installation of packages that needs the compilation of
    libraries fails. Instead of going through the process of installing a compiler,
    which is out of this book’s scope, we can get the packages ready to use.'
  prefs: []
  type: TYPE_NORMAL
- en: These packages come prebuilt for various types of system and don’t need a compilation
    of its libraries. This type of package is called a wheel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Christoph Gohlke did a favor to all of us by building these packages and making
    them available for download at [http://www.lfd.uci.edu/~gohlke/pythonlibs/.](http://www.lfd.uci.edu/~gohlke/pythonlibs/)
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing packages and required software**'
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will go through the installation process of every package
    used in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenCV**'
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV is an optimized C/C++ library intended for video and image processing
    with hundreds of functions ranging from simple image resizing to object recognition,
    face detection, and so on. OpenCV is a big library, and we will use its capabilities
    of reading, transforming, and writing images. It’s a good choice because its development
    is active, and it has a large user community and very good documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the installation procedure for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/).
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Press *Ctrl* + *F* to open the search dialog of your browser and then search
    for OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. You will find a list of files; choose opencv_python-2.4.11-cp27-none-win32.whl
    or any OpenCV version that contains cp27 and win32\. This means that this is the
    32-bit version for Python 2.7\.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Save the downloaded file to a known location.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Open Windows Command Prompt and run the following command: **c:\Python27\scripts\pip
    install path_to_the_file_you_downloaded.whl** 6\. You should see an output telling
    you that the installation was successful, as follows: **Processing c:\downloads\opencv_python-2.4.12-cp27-none-win32.whl**
    **Installing collected packages: opencv-python**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Successfully installed opencv-python-2.4.12**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can drag and drop a file into the command prompt to enter its full path.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the installation process for Ubuntu Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Open a new terminal with *Ctrl* + *T*.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Then, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo apt-get install python-opencv**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing NumPy**'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is a package for scientific computing with Python. It handles multidimensional
    arrays of operations in a very efficient way. NumPy is required by OpenCV to run
    and will be used by many raster operations that we will perform in the examples.
    NumPy is also an efficient data container and will be our tool to calculate massive
    image data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the same procedure as you did to install OpenCV; however, this time,
    search for NumPy and choose a file named numpy-1.9.2+mkl-cp27-none-win32.whl.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy is automatically installed as a dependency of OpenCV on Ubuntu, but if
    you want to install it without OpenCV, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Open a new terminal with *Ctrl* + *T*.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Then, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo pip install numpy**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing GDAL and OGR**'
  prefs: []
  type: TYPE_NORMAL
- en: '**GDAL** (**Geospatial Data Abstraction Library**) is composed of two packages
    that come together: OGR handles geospatial vector file formats, including coordinate
    system transformations and vector operations. GDAL is the raster part of the library,
    and in version 1.11, it comes packed with 139 drivers that can read, and some
    even create rasters.'
  prefs: []
  type: TYPE_NORMAL
- en: GDAL also comes packed with functions for raster transformations and calculations
    such as resizing, clipping, reprojecting, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following tables, there’s an excerpt of the list of GDAL and OGR drivers
    with the most common formats that you may find:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long format name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creation**'
  prefs: []
  type: TYPE_NORMAL
- en: Arc/Info ASCII Grid
  prefs: []
  type: TYPE_NORMAL
- en: AAIGrid
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Arc/Info Export E00 GRID
  prefs: []
  type: TYPE_NORMAL
- en: E00GRID
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: ENVI .hdr Labelled Raster
  prefs: []
  type: TYPE_NORMAL
- en: ENVI
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Generic Binary (.hdr Labelled)
  prefs: []
  type: TYPE_NORMAL
- en: GENBIN
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Spatial GeoRaster
  prefs: []
  type: TYPE_NORMAL
- en: GEORASTER
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GSat File Format
  prefs: []
  type: TYPE_NORMAL
- en: GFF
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: Graphics Interchange Format (.gif)
  prefs: []
  type: TYPE_NORMAL
- en: GIF
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GMT Compatible netCDF
  prefs: []
  type: TYPE_NORMAL
- en: GMT
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GRASS ASCII Grid
  prefs: []
  type: TYPE_NORMAL
- en: GRASSASCIIGrid No
  prefs: []
  type: TYPE_NORMAL
- en: Golden Software ASCII Grid
  prefs: []
  type: TYPE_NORMAL
- en: GSAG
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Golden Software Binary Grid
  prefs: []
  type: TYPE_NORMAL
- en: GSBG
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Golden Software Surfer 7 Binary Grid
  prefs: []
  type: TYPE_NORMAL
- en: GS7BG
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: TIFF / BigTIFF / GeoTIFF (.tif)
  prefs: []
  type: TYPE_NORMAL
- en: GTiff
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GXF (Grid eXchange File)
  prefs: []
  type: TYPE_NORMAL
- en: GXF
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: Erdas Imagine (.img)
  prefs: []
  type: TYPE_NORMAL
- en: HFA
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: JPEG JFIF (.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: JPEG
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: NOAA Polar Orbiter Level 1b Data Set (AVHRR) L1B
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: NOAA NGS Geoid Height Grids
  prefs: []
  type: TYPE_NORMAL
- en: NGSGEOID
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: NITF
  prefs: []
  type: TYPE_NORMAL
- en: NITF
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: NTv2 Datum Grid Shift
  prefs: []
  type: TYPE_NORMAL
- en: NTv2
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: PCI .aux Labelled
  prefs: []
  type: TYPE_NORMAL
- en: PAux
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: PCI Geomatics Database File
  prefs: []
  type: TYPE_NORMAL
- en: PCIDSK
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: PCRaster
  prefs: []
  type: TYPE_NORMAL
- en: PCRaster
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial PDF
  prefs: []
  type: TYPE_NORMAL
- en: PDF
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: NASA Planetary Data System
  prefs: []
  type: TYPE_NORMAL
- en: PDS
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: Portable Network Graphics (.png)
  prefs: []
  type: TYPE_NORMAL
- en: PNG
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: R Object Data Store
  prefs: []
  type: TYPE_NORMAL
- en: R
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Raster Matrix Format (*.rsw, .mtw)
  prefs: []
  type: TYPE_NORMAL
- en: RMF
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: RadarSat2 XML (product.xml)
  prefs: []
  type: TYPE_NORMAL
- en: RS2
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: Idrisi Raster
  prefs: []
  type: TYPE_NORMAL
- en: RST
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: SAGA GIS Binary format
  prefs: []
  type: TYPE_NORMAL
- en: SAGA
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: USGS SDTS DEM (*CATD.DDF)
  prefs: []
  type: TYPE_NORMAL
- en: SDTS
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: SGI Image Format
  prefs: []
  type: TYPE_NORMAL
- en: SGI
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: SRTM HGT Format
  prefs: []
  type: TYPE_NORMAL
- en: SRTMHGT
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Terragen Heightfield (.ter)
  prefs: []
  type: TYPE_NORMAL
- en: TERRAGEN
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: USGS ASCII DEM / CDED (.dem)
  prefs: []
  type: TYPE_NORMAL
- en: USGSDEM
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: ASCII Gridded XYZ
  prefs: []
  type: TYPE_NORMAL
- en: XYZ
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes the OGR drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Format name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creation**'
  prefs: []
  type: TYPE_NORMAL
- en: Arc/Info Binary Coverage
  prefs: []
  type: TYPE_NORMAL
- en: AVCBin
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: Arc/Info .E00 (ASCII) Coverage AVCE00
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: AutoCAD DXF
  prefs: []
  type: TYPE_NORMAL
- en: DXF
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Comma Separated Value (.csv) CSV
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: ESRI Shapefile
  prefs: []
  type: TYPE_NORMAL
- en: ESRI Shapefile Yes
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Géoconcept Export
  prefs: []
  type: TYPE_NORMAL
- en: Geoconcept
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GeoRSS
  prefs: []
  type: TYPE_NORMAL
- en: GeoRSS
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GML
  prefs: []
  type: TYPE_NORMAL
- en: GML
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GMT
  prefs: []
  type: TYPE_NORMAL
- en: GMT
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GPSBabel
  prefs: []
  type: TYPE_NORMAL
- en: GPSBabel
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GPX
  prefs: []
  type: TYPE_NORMAL
- en: GPX
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: GPSTrackMaker (.gtm, .gtz)
  prefs: []
  type: TYPE_NORMAL
- en: GPSTrackMaker
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Hydrographic Transfer Format
  prefs: []
  type: TYPE_NORMAL
- en: HTF
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: Idrisi Vector (.VCT)
  prefs: []
  type: TYPE_NORMAL
- en: Idrisi
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: KML
  prefs: []
  type: TYPE_NORMAL
- en: KML
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Mapinfo File
  prefs: []
  type: TYPE_NORMAL
- en: MapInfo File
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Microstation DGN
  prefs: []
  type: TYPE_NORMAL
- en: DGN
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: OpenAir
  prefs: []
  type: TYPE_NORMAL
- en: OpenAir
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: ESRI FileGDB
  prefs: []
  type: TYPE_NORMAL
- en: OpenFileGDB
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: PCI Geomatics Database File
  prefs: []
  type: TYPE_NORMAL
- en: PCIDSK
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial PDF
  prefs: []
  type: TYPE_NORMAL
- en: PDF
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: PDS
  prefs: []
  type: TYPE_NORMAL
- en: PDS
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL SQL dump
  prefs: []
  type: TYPE_NORMAL
- en: PGDump
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs: []
  type: TYPE_NORMAL
- en: U.S. Census TIGER/Line
  prefs: []
  type: TYPE_NORMAL
- en: TIGER
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full GDAL and OGR API documentation and the complete list of
    drivers at [http://gdal.org/python/](http://gdal.org/python/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we will use a wheel for the installation. Repeat the same procedure
    as before: 1\. Go to [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/).'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Now, search for GDAL and download the file named
  prefs: []
  type: TYPE_NORMAL
- en: GDAL-1.11.3-cp27-none-win32.whl.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Finally, install it with pip, as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to the terminal or open a new one.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Then, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo apt-get install python-gdal**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Mapnik**'
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik is a map rendering package. It is a free toolkit to develop mapping applications.
    It produces high-quality maps and is used on many applications, including OpenStreetMaps.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: Mapnik isn’t available for installation as other libraries are. Instead, you
    need to go to
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mapnik.org/](http://mapnik.org/) and follow the download link: 1\.
    Download the Windows 32-bit package of Mapnik 2.2\.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Extract the mapnik-v2.2.0 to C:\ folder.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Then, rename the extracted folder c:\mapnik.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Now, add Mapnik to your **PATH**.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Open **Control Panel** and go to **System**.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Click on the **Advanced System Settings** link in the left-hand side column.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. In the **System Properties** window, click on the **Advanced** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Next, click on the **Environment Variables** button.
  prefs: []
  type: TYPE_NORMAL
- en: '9\. In the **System variables** section, highlight the **PATH** variable and
    click on **Edit**. Add the following paths to the end of the list, each separated
    with a semicolon, as follows: **c:\mapnik\bin;c:\mapnik\lib**'
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Now, click on the **New** button; then, set the variable name to PYTHONPATH
    and value to c:\mapnik\python\2.7\site-packages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to the terminal or open a new one.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Then, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo apt-get install mapnik**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Shapely**'
  prefs: []
  type: TYPE_NORMAL
- en: Shapely is a package for the manipulation and analysis of two dimensional geometries.
    It can perform operations such as union and subtraction of geometries. It also
    can perform tests and comparisons, such as when a geometry intersects other geometries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. As before, download the prebuilt wheel; this time, look for a file named
    Shapely-1.5.13-cp27-none-win32.whl.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Then, install it with pip.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps you need to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to the terminal or open a new one with *Ctrl* + *T*.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo pip install shapely**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing other packages directly from**'
  prefs: []
  type: TYPE_NORMAL
- en: '**pip**'
  prefs: []
  type: TYPE_NORMAL
- en: Some packages do not require compilation steps. For Windows users, these are
    easier to install because they can be obtained and installed directly with pip
    with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to simply type the following command in your Command Prompt: **c:\Python27\scripts\pip
    install django tabulate requests xmltodict psycopg2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo pip install django tabulate requests xmltodict psycopg2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each package, you should see the progress of the installation, similar
    to the following: **Collecting django**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading Django-1.9-py2.py3-none-any.whl (6.6MB)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**100% |################################| 6.6MB 43kB/s** **Installing collected
    packages: django**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Successfully installed django-1.9**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing an IDE**'
  prefs: []
  type: TYPE_NORMAL
- en: IDEs are fancy text editors with tools and inspections regarding programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: You can surely use any text editor or IDE of your preference; none of the tasks
    in this book depends on the IDE, but an IDE will facilitate our work a lot because
    the suggested configuration will help you avoid mistakes and save time on typing,
    running, and debugging your code. The IDE checks the code for you and detects
    underlying errors; it even guesses what you are typing and completes the statements
    for you, runs the code with a simple command, and if there are exceptions, it
    provides links to the place where the exception occurred. For Windows or Linux,
    go to [http://www.jetbrains.com/pycharm/](http://www.jetbrains.com/pycharm/)
  prefs: []
  type: TYPE_NORMAL
- en: and click on the big orange button **Get Pycharm Now**. On the next page, select
    the free community edition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps you need to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. After the download finishes, open the downloaded file; the **Setup Wizard**
    will pop up.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Click on **Next**, and in the installation options, check both of the boxes:
    **Create** **Desktop shortcut** and **Create associations**.'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Click on **Next** and continue the installation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Unpack the downloaded file in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. To open PyCharm, run pycharm.sh from the bin subdirectory. You can create
    a shortcut to it if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 3](img/index-85_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Creating the book project**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. After installation, open Pycharm, and you will be prompted to create your
    first project:'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Click on create new project and then choose c:\geopy as your project location.
    In Linux, you can put the project inside your home folder—for example,
  prefs: []
  type: TYPE_NORMAL
- en: /home/myname/geopy. Click on **Create** to create the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 4](img/index-86_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '3\. In Windows, you will receive a security alert; this is Pycharm trying to
    access the Internet. It’s recommended that you allow it so that you can later
    check for updates or download plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 5](img/index-87_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 6](img/index-87_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '4\. Finally, you should see the following window on your project workspace.
    Take some time to explore the menus and buttons, try right-clicking on your project
    folder to see the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming and running your first**'
  prefs: []
  type: TYPE_NORMAL
- en: '**example**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all we need installed, we will go through our first example.
    In this example, we will test the installation and then see a glimpse of OGR’s
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will open a vector file containing the boundaries of all the
    countries in the world and make a list of country names. The objective of this
    simple example is to present the logic behind OGR objects and functions and give
    an understanding of how geospatial files are represented. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, you need to copy the sample data provided with the book to your project
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: You can do this by dragging and dropping the data folder into the geopy folder.
    Make sure that the data folder is named data and that it’s inside the geopy folder.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Now, create a new directory for this chapter code, inside PyCharm. With
    your geopy project opened, right-click on the project folder and select **New**
    | **Directory**. Name it Chapter1\.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Create a new Python file. To do this, right-click on the Chapter1 folder
    and select **New** | **Python File**. Name it world_borders.py, and PyCharm will
    automatically open the file for editing.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Type the following code in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: Open the shapefile and get the first layer.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(layer.GetFeatureCount())) 5\. Now, run
    the code; in the menu bar, navigate to **Run** | **Run**, and in the dialog, choose
    world_borders. An output console will open at the bottom of the screen, and if
    everything goes fine, you should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\Python27\python.exe C:/geopy/world_borders.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of features: 246**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process finished with exit code 0**'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You successfully opened a Shapefile and counted the number
    of features inside it. Now, let’s understand what this code does.
  prefs: []
  type: TYPE_NORMAL
- en: The first line imports the ogr package. From this point on, all the functions
    are available as ogr.FunctionName(). Note that ogr doesn’t follow the Python naming
    conventions for functions.
  prefs: []
  type: TYPE_NORMAL
- en: The line after the comment opens the OGR datasource (this opens the shapefile
    containing the data) and assigns the object to the datasource variable. Note that
    the path, even on Windows, uses a forward slash (/) and not a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: The next line gets the first layer of the data source by its index (0). Some
    data sources can
  prefs: []
  type: TYPE_NORMAL
- en: have many layers, but this is not the case of a Shapefile, which has only one
    layer. So, when working with Shapefiles, we always know that the layer of interest
    is layer 0\.
  prefs: []
  type: TYPE_NORMAL
- en: In the final line, the print statement prints the number of features returned
    by layer.GetFeatureCount(). Here, we will use Python’s string formatting, where
    the curly braces are replaced by the argument passed to format().
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In the same file, let’s type the next part of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the fields available in the layer.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: feature_definition = layer.GetLayerDefn()
  prefs: []
  type: TYPE_NORMAL
- en: 'for field_index in range(feature_definition.GetFieldCount()): field_definition
    = feature_definition.GetFieldDefn(field_index) print("\t{}\t{}\t{}".format(field_index,'
  prefs: []
  type: TYPE_NORMAL
- en: field_definition.GetTypeName(),
  prefs: []
  type: TYPE_NORMAL
- en: field_definition.GetName()))
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Rerun the code; you can use the *Shift* + *F10* shortcut for this. Now,
    you should see the number of features as before plus a pretty table showing information
    on all the fields in the shapefile, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of features: 246**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 String FIPS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 String ISO2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 String ISO3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 Integer UN**'
  prefs: []
  type: TYPE_NORMAL
- en: '**4 String NAME**'
  prefs: []
  type: TYPE_NORMAL
- en: '**5 Integer POP2005**'
  prefs: []
  type: TYPE_NORMAL
- en: '**6 Integer REGION**'
  prefs: []
  type: TYPE_NORMAL
- en: '**7 Integer SUBREGION**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process finished with exit code 0**'
  prefs: []
  type: TYPE_NORMAL
- en: What happens in this piece of code is that feature_definition =
  prefs: []
  type: TYPE_NORMAL
- en: layer.GetLayerDefn() gets the object that contains the definition of the features.
  prefs: []
  type: TYPE_NORMAL
- en: This object contains the definition for each field and the type of geometry.
  prefs: []
  type: TYPE_NORMAL
- en: In the for loop, we will get each field definition and print its index, name,
    and type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the object returned by layer.GetLayerDefn() is not iterable, and
    we can’t use for directly with it. So first, we will get the number of fields
    and use it in the range() function so that we can iterate through the indexes
    of the fields: 3\. Now, type the last part, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Print a list of country names.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layer.ResetReading()
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in layer:'
  prefs: []
  type: TYPE_NORMAL
- en: print(feature.GetFieldAsString(4))
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code again and check the results in the output: **Number of features:
    246**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 String FIPS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 String ISO2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 String ISO3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 Integer UN**'
  prefs: []
  type: TYPE_NORMAL
- en: '**4 String NAME**'
  prefs: []
  type: TYPE_NORMAL
- en: '**5 Integer POP2005**'
  prefs: []
  type: TYPE_NORMAL
- en: '**6 Integer REGION**'
  prefs: []
  type: TYPE_NORMAL
- en: '**7 Integer SUBREGION**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Antigua and Barbuda**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algeria**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azerbaijan**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Albania**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Armenia**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angola**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Saint Barthelemy**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Guernsey**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jersey**'
  prefs: []
  type: TYPE_NORMAL
- en: '**South Georgia South Sandwich Islands**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Taiwan**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process finished with exit code 0**'
  prefs: []
  type: TYPE_NORMAL
- en: The layer is iterable, but first, we need to ensure that we are at the beginning
    of the layer list with layer.ResetReading() (this is one of OGR’s “gotcha” points).
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature.GetFieldAsString(4) method returns the value of field 4 as a Python
    string. There are two ways of knowing whether the country names are in field 4:
    Looking at the data’s DBF file (by opening it with LibreOffice or Excel) Looking
    at the table that we printed in the first part of the code Your complete code
    should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: Open the shapefile and get the first layer.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: datasource = ogr.Open("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(layer.GetFeatureCount()))'
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the fields available in the layer.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: feature_definition = layer.GetLayerDefn()
  prefs: []
  type: TYPE_NORMAL
- en: 'for field_index in range(feature_definition.GetFieldCount()): field_definition
    = feature_definition.GetFieldDefn(field_index) print("\t{}\t{}\t{}".format(field_index,'
  prefs: []
  type: TYPE_NORMAL
- en: field_definition.GetTypeName(),
  prefs: []
  type: TYPE_NORMAL
- en: field_definition.GetName()))
  prefs: []
  type: TYPE_NORMAL
- en: Print a list of country names.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layer.ResetReading()
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in layer:'
  prefs: []
  type: TYPE_NORMAL
- en: print(feature.GetFieldAsString(4))
  prefs: []
  type: TYPE_NORMAL
- en: '**Transforming the coordinate system and**'
  prefs: []
  type: TYPE_NORMAL
- en: '**calculating the area of all countries**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the objective is to know how much area is occupied by each country. However,
    the coordinates of country borders are expressed in latitude and longitude, and
    we can’t calculate areas in this coordinate system. We want the area to be in
    the metric system, so first we need to convert the spatial reference system of
    the geometries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also take a step further in the programming techniques and start using
    functions to avoid the repetition of code. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Create a new file in the Chapter1 directory, name this file world_areas.py,
    and program this first function:'
  prefs: []
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_shapefile(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open the shapefile, get the first layer and returns the ogr datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: datasource = ogr.Open(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: print("Opening {}".format(file_path))
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format('
  prefs: []
  type: TYPE_NORMAL
- en: layer.GetFeatureCount()))
  prefs: []
  type: TYPE_NORMAL
- en: return datasource
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Run the code, go to **Run** | **Run…** in the menu, and select world_areas.
    If everything is correct, nothing should happen. This is because we are not calling
    our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this line of code at the end and outside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'datasource = open_shapefile("../data/world_borders_simple.shp") 3\. Now, run
    the code again with *Shift* + *F10* and check the output, as follows: **Opening
    ../data/world_borders_simple.shp**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of features: 246**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process finished with exit code 0**'
  prefs: []
  type: TYPE_NORMAL
- en: That’s wonderful! You just created a piece of very useful and reusable code.
    You now have a function that can open any shapefile, print the number of features,
    and return the ogr datasource. From now on, you can reuse this function in any
    of your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are already familiar with how this code works, but there are a few novelties
    here that deserve an explanation. The def statement defines a function with the
    def function_name(arguments): syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember when I told you that OGR doesn’t follow Python’s naming convention?
    Well, the convention is that function names should all be in lowercase with an
    underscore
  prefs: []
  type: TYPE_NORMAL
- en: between words. A good hint for names is to follow the verb_noun rule.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: These conventions are described in a document called **PEP-8**, where **PEP**
    stands for **Python Enhancement Program**. You can find this document at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0008/.](https://www.python.org/dev/peps/pep-0008/)'
  prefs: []
  type: TYPE_NORMAL
- en: Right after the function’s definition, you can see a description between triple
    quotes; this is a docstring, and it is used to document the code. It’s optional
    but very useful for you to know what the function does.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get back to our code. The second important thing to point out is
    the return statement. This makes the function return the values of the variables
    listed after the statement—in this case, the datasource.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: It’s very important that all pieces of the OGR objects flow together through
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, if we return only the layer, for example, we will get a runtime
    error later in our program. This happens because in OGR internals, the layer has
    a reference to the data source, and when you exit a Python function, all objects
    that don’t exit the function are trashed, and this breaks the reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the next step is to create a function that performs the transformation.
    In OGR, the transformation is made in the feature’s geometry, so we need to iterate
    over the features, get the geometry, and transform its coordinates. We will do
    this using the following steps: 1\. Add the following function to your world_areas.py
    file just after the open_shapefile function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transform the coordinates of all geometries in the first layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: src_srs = osr.SpatialReference()
  prefs: []
  type: TYPE_NORMAL
- en: src_srs.ImportFromEPSG(src_epsg)
  prefs: []
  type: TYPE_NORMAL
- en: dst_srs = osr.SpatialReference()
  prefs: []
  type: TYPE_NORMAL
- en: dst_srs.ImportFromEPSG(dst_epsg)
  prefs: []
  type: TYPE_NORMAL
- en: transformation = osr.CoordinateTransformation(src_srs, dst_srs) layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: geoms = []
  prefs: []
  type: TYPE_NORMAL
- en: layer.ResetReading()
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in layer:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = feature.GetGeometryRef().Clone()
  prefs: []
  type: TYPE_NORMAL
- en: geom.Transform(transformation)
  prefs: []
  type: TYPE_NORMAL
- en: geoms.append(geom)
  prefs: []
  type: TYPE_NORMAL
- en: return geoms
  prefs: []
  type: TYPE_NORMAL
- en: 'The function takes three arguments: the ogr layer, the EPSG code of the coordinate
    system of the file, and the EPSG code for the transformation output.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, it created an osr.CoordinateTransformation object; this object contains
    the instructions to perform the transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Probably by now, Pycharm should be complaining that osr is an unresolved reference;
    osr is the part of GDAL that deals with coordinate systems.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, import the module by adding this line at the top of your code: **import
    osr**'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the code iterates over all features, gets a reference to the geometry,
    and performs the transformation. As we don’t want to change the original data,
    the geometry is cloned, and the transformation is made on the clone.
  prefs: []
  type: TYPE_NORMAL
- en: Python lists are ordered; this means that the elements are in the same order
    in which they are appended to the list, and this order is always kept. This allows
    us to create a list of geometries in the same order of the features that are in
    the data source. This means that the geometries in the list and the features have
    the same index and can be related in the future by the index.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, let’s test the code; add the following lines at the end of the file
    (the first line is the one that you already added before):'
  prefs: []
  type: TYPE_NORMAL
- en: datasource = open_shapefile("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: feature = layer.GetFeature(0)
  prefs: []
  type: TYPE_NORMAL
- en: print("Before transformation:")
  prefs: []
  type: TYPE_NORMAL
- en: print(feature.GetGeometryRef())
  prefs: []
  type: TYPE_NORMAL
- en: transformed_geoms = transform_geometries(datasource, 4326, 3395) print("After
    transformation:")
  prefs: []
  type: TYPE_NORMAL
- en: print(transformed_geoms[0])
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Finally, before you run the code, add one more import at the beginning
    of the program. It should be the first statement of your code, as follows: from
    __future__ import print_function'
  prefs: []
  type: TYPE_NORMAL
- en: This import allows us to use the print() function from Python 3 with the desired
    behavior, thus maintaining the compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. The complete code should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: from __future__ import print_function
  prefs: []
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: import osr
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_shapefile(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: datasource = open_shapefile("../data/world_borders_simple.shp") layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: feature = layer.GetFeature(0)
  prefs: []
  type: TYPE_NORMAL
- en: print("Before transformation:")
  prefs: []
  type: TYPE_NORMAL
- en: print(feature.GetGeometryRef())
  prefs: []
  type: TYPE_NORMAL
- en: transformed_geoms = transform_geometries(datasource, 4326, 3395) print("After
    transformation:")
  prefs: []
  type: TYPE_NORMAL
- en: print(transformed_geoms[0])
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run your program again by pressing *Shift* + *F10*. In the output, note
    the difference in the coordinates before and after the transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opening ../data/world_borders_simple.shp**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of features: 246**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Before transformation:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**MULTIPOLYGON (((-61.686668 17.024441000000138… )))**'
  prefs: []
  type: TYPE_NORMAL
- en: '**After transformation:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**MULTIPOLYGON (((-6866928.4704937246… )))**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process finished with exit code 0**'
  prefs: []
  type: TYPE_NORMAL
- en: '7\. Now, add another function. This function will calculate the area in square
    meters (because we will use the geometries that have coordinates in meters), convert
    the value (or not) to square kilometers or square miles, and store the values
    in another list with the same order as before. Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculate_areas(geometries, unity=''km2''):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate the area for a list of ogr geometries."""'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: conversion_factor = {
  prefs: []
  type: TYPE_NORMAL
- en: '''sqmi'': 2589988.11,'
  prefs: []
  type: TYPE_NORMAL
- en: '''km2'': 1000000,'
  prefs: []
  type: TYPE_NORMAL
- en: '''m'': 1}'
  prefs: []
  type: TYPE_NORMAL
- en: Part2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if unity not in conversion_factor:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError(
  prefs: []
  type: TYPE_NORMAL
- en: '"This unity is not defined: {}".format(unity))'
  prefs: []
  type: TYPE_NORMAL
- en: Part 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: areas = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for geom in geometries:'
  prefs: []
  type: TYPE_NORMAL
- en: area = geom.Area()
  prefs: []
  type: TYPE_NORMAL
- en: areas.append(area / conversion_factor[unity])
  prefs: []
  type: TYPE_NORMAL
- en: return areas
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, note that in the function definition, we use unity='km2'; this is a
    keyword argument, and when you call the functions, this argument is optional.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 1, a dictionary is used to define a few conversion factors for the area
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to add more units if you wish. By the way, Python doesn’t care if
    you use single or double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 2, a verification is made to check whether the passed unity exists and
    whether it is defined in conversion_factor. Another way of doing this is catching
    the exception later; however, for now, let’s opt for readability.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 3, the code iterates the ogr geometries, calculates the area, converts
    the values, and puts it on a list.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Now, to test the code, edit your first line, including division to the future
    imports.
  prefs: []
  type: TYPE_NORMAL
- en: This will ensure that all divisions return floating point numbers and not integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: from __future__ import print_function, division
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Then, update the testing part of your code to the following: datasource
    = open_shapefile("../data/world_borders_simple.shp") transformed_geoms = transform_geometries(datasource,
    4326, 3395) calculated_areas = calculate_areas(transformed_geoms, unity=''sqmi'')
    print(calculated_areas)'
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Run it, change the unity, then run again, and note how the results change.
  prefs: []
  type: TYPE_NORMAL
- en: Very well, unity conversion is another very important procedure in geoprocessing,
    and you just implemented it in your calculate_areas function.
  prefs: []
  type: TYPE_NORMAL
- en: However, having a list of numbers as the output is not very useful to us. So,
    it’s time to combine everything that we did so far in order to extract valuable
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sort the countries by area size**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You programmed three functions so far; now, let’s add another one to our list
    by converting the code that generated a list of country names to a function and
    add this function to world_areas.py, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_country_names(datasource):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Returns a list of country names."""'
  prefs: []
  type: TYPE_NORMAL
- en: layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: country_names = []
  prefs: []
  type: TYPE_NORMAL
- en: layer.ResetReading()
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in layer:'
  prefs: []
  type: TYPE_NORMAL
- en: country_names.append(feature.GetFieldAsString(4))
  prefs: []
  type: TYPE_NORMAL
- en: return country_names
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have four functions, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: open_shapefile
  prefs: []
  type: TYPE_NORMAL
- en: transform_geometries
  prefs: []
  type: TYPE_NORMAL
- en: calculate_areas
  prefs: []
  type: TYPE_NORMAL
- en: get_country_names
  prefs: []
  type: TYPE_NORMAL
- en: All these functions return iterables, with each item sharing the same index
    on all of them, thus making it easy to combine the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s take advantage of this feature to sort the countries by area size
    and return a list of the five biggest countries and their areas. For this, add
    another function, as follows: def get_biggest_countries(countries, areas, elements=5):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Returns a list of n countries sorted by area size."""'
  prefs: []
  type: TYPE_NORMAL
- en: countries_list = [list(country)
  prefs: []
  type: TYPE_NORMAL
- en: for country in zip(areas, countries)]
  prefs: []
  type: TYPE_NORMAL
- en: sorted_countries = sorted(countries_list,
  prefs: []
  type: TYPE_NORMAL
- en: key=itemgetter(0), reverse=True)
  prefs: []
  type: TYPE_NORMAL
- en: return sorted_countries[:5]
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, the two lists are zipped together, producing a list of country-area
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we used the Python list’s sorted method, but as we don’t want the lists
    to be sorted by both values, we will define the key for sorting. Finally, the
    list is sliced, returning only the desired number of values.
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In order to run this code, you need to import the itemgetter function and
    put it at the beginning of the code but after from __future__ imports, as follows:
    from operator import itemgetter'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, edit the testing part of your code to look similar to the following:
    datasource = open_shapefile("../data/world_borders_simple.shp") transformed_geoms
    = transform_geometries(datasource, 4326, 3395) country_names = get_country_names(datasource)'
  prefs: []
  type: TYPE_NORMAL
- en: country_areas = calculate_areas(transformed_geoms)
  prefs: []
  type: TYPE_NORMAL
- en: biggest_countries = get_biggest_countries(country_names,
  prefs: []
  type: TYPE_NORMAL
- en: 'country_areas) for item in biggest_countries:'
  prefs: []
  type: TYPE_NORMAL
- en: print("{}\t{}".format(item[0], item[1]))
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, run the code and take a look at the results, as follows: Opening ../data/world_borders_simple.shp'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 246'
  prefs: []
  type: TYPE_NORMAL
- en: 82820725.1423 Russia
  prefs: []
  type: TYPE_NORMAL
- en: 51163710.3726 Canada
  prefs: []
  type: TYPE_NORMAL
- en: 35224817.514 Greenland
  prefs: []
  type: TYPE_NORMAL
- en: 21674429.8403 United States
  prefs: []
  type: TYPE_NORMAL
- en: 14851905.8596 China
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we had a brief introduction to the libraries and packages that
    we will use in this book. By installing these libraries, you also learned the
    general procedure of how to search and install Python packages. You can use this
    procedure in other cases whenever you feel the need for other libraries in your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we wrote code that made use of the OGR library to open a shapefile and
    perform area calculation and sorting. These simple procedures showed a little
    bit of the internal organization of OGR, how it handles geographic data, and how
    it is possible to extract information from them. In the next chapter, we will
    use some of the techniques learned here to read data and process vector points.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 2\. The Geocaching App**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a geocaching app that will initially get geocache
    points from the Internet and return the coordinates and information on the point
    closest to a user’s location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through some of the most important steps in every geoprocessing
    application: we will discuss opening files, reading information, preparing data
    for analysis, and performing calculations with each object in your data. To achieve
    this, you will learn how to organize your code with Python and use the resources
    provided by the language to write consistent applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will start to make use of classes, methods, functions,
    decorators, and exception handling, which will help us build an application with
    reusable components and clean code. Don’t worry if these terms are new to you;
    they will be explained in the examples. In short, here’s what we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Programming the basic application structures
  prefs: []
  type: TYPE_NORMAL
- en: Downloading geocaching data
  prefs: []
  type: TYPE_NORMAL
- en: Opening geocaching files and getting their contents
  prefs: []
  type: TYPE_NORMAL
- en: Combining functions into an application
  prefs: []
  type: TYPE_NORMAL
- en: Setting your current location
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs: []
  type: TYPE_NORMAL
- en: Finding the closest point
  prefs: []
  type: TYPE_NORMAL
- en: '**Building the basic application structure** There are two main reasons to
    define a good basic structure for our application: It keeps our code organized'
  prefs: []
  type: TYPE_NORMAL
- en: It allows us to reuse pieces of code in later applications
  prefs: []
  type: TYPE_NORMAL
- en: Python is a flexible language in terms of code organization, and although users
    are allowed to write the whole application in a single file, it’s preferable to
    separate the functionalities into modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are Python files that contain classes and functions that can be imported
    into another file with the import statement. Packages are special directories
    (folders) that contain modules. This leads to organized and well-structured code
    that is less prone to having bugs and is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The proposed structure is to have a folder for each chapter. Inside it, we can
    create packages or files for each application; we will create a package for a
    common utility code that can be imported and reused and a directory to perform
    experiments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the application tree structure** Here are the steps that you need
    to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: If you went through [Chapter 1](#p45), *Preparing the Work Environment*, you
    should now have a PyCharm project named geopy with the Chapter1 and data directories
    located at C:\geopy in Windows or ~/geopy in Linux. Start PyCharm and open your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: In the project root (the uppermost folder named geopy), right-click, select
    **New** |
  prefs: []
  type: TYPE_NORMAL
- en: '**Directory**, and name it Chapter2\.'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on Chapter2, select **New** | **Directory**, and name it experiments.
  prefs: []
  type: TYPE_NORMAL
- en: Again, right-click inside the Chapter2 directory; this time, select **New**
    | **Python** **Package** and name it utils.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you should have a tree structure similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: \geopy
  prefs: []
  type: TYPE_NORMAL
- en: +---Chapter1
  prefs: []
  type: TYPE_NORMAL
- en: '| world_areas.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| world_borders.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +---Chapter2
  prefs: []
  type: TYPE_NORMAL
- en: '| |'
  prefs: []
  type: TYPE_NORMAL
- en: '| \---experiments'
  prefs: []
  type: TYPE_NORMAL
- en: '| \---utils'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +---data
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python Packages**'
  prefs: []
  type: TYPE_NORMAL
- en: Packages are special folders that contain another packages and modules. They
    are directories with a special file called __init__.py. This file may be empty
    and is used to denote that the package can be imported with the import statement.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have a directory called foo (with a __init__.py file) and
    we create a bar.py file inside it, we can later use import foo.bar or from foo
    import bar in our code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions and methods**'
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods (which are functions inside classes) should be concise
    so that when you call them, you can trust that you will get the desired results
    or appropriate exceptions. The programmer doesn’t want to check the function’s
    contents every time they use it; they want to call it and get the anticipated
    results, which is called taking *the leap of* *faith*. For example, in this book,
    we use many external packages; when we use a given function of a package, we trust
    that this function will do what it’s supposed to do or raise an error telling
    us that something went wrong. Anything besides this is called *unexpected* *behavior*,
    and this is the most dangerous type of bug that an application can have because
    it is passed silently but has consequences later in code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we saw a module that may have this kind of unexpected behavior: GDAL/OGR.'
  prefs: []
  type: TYPE_NORMAL
- en: The ogr.Open() function is passed silently even if the file doesn’t exist, unless
    we specifically tell OGR that we want it to raise exceptions for us.
  prefs: []
  type: TYPE_NORMAL
- en: '**Documenting your code**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the application starts to gain scale, it’s very important to keep track
    of what each piece of code does. This prevents the programmer from repeating code
    and saves a lot of time later trying to find out what is going on. Also, it allows
    other people to use and improve your code. There are two crucial tools that can
    be used to document the code, and we had a glimpse of it in the first chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code comments**: These are the comments inserted in code with the # symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything from this symbol to the next line is a comment and will be ignored
    when the program runs. The Python syntax is intuitive, and a well-written code
    requires a few comments. Here are two tips to concisely comment your code: Place
    a comment before each logical block of code telling what it’s doing Comment pieces
    of code that are hard to read or understand'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docstrings**: Docstrings are texts placed in special locations in document
    classes, functions, and methods. They have a special meaning because they can
    be interpreted by some programs and used to provide the user with help and automatically
    generate documentation. Docstrings can also be used to test your code, but this
    will not be covered in this book. In PyCharm, docstrings have a special purpose
    and provide hints for automatic code inspection. Within docstrings, you can specify
    parameters and return types (for example, strings, list, and dictionary). PyCharm
    uses this to make auto-complete suggestions and warn you about possible mistakes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the reStructuredText type of markup for docstrings;
    you can find more information at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you can note a class and method documented with docstrings
    (you don’t need to type this code):'
  prefs: []
  type: TYPE_NORMAL
- en: 'class MyClass:'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This is an example of a docstring of a class."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""You can also put docstrings in the __init__ method."""'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: 'def sum_values(self, arg1, arg2):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This is the docstring for a method, you can describe the arguments and specify
    its types.'
  prefs: []
  type: TYPE_NORMAL
- en: If you do so, PyCharm will use that information
  prefs: []
  type: TYPE_NORMAL
- en: for autocomplete and to check your code.
  prefs: []
  type: TYPE_NORMAL
- en: ':param float arg1: The first argument.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param float arg2: The second argument.'
  prefs: []
  type: TYPE_NORMAL
- en: ':returns float: The sum of the arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: return arg1 + arg2
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the application entry point**'
  prefs: []
  type: TYPE_NORMAL
- en: The entry point of an application is the first thing executed when you run the
    program. In Python, it’s the first line of code. We can write an application that
    runs top-down, mixing function and class declarations along with other statements,
    but this would make the code harder to develop and debug, especially when it starts
    to grow more complex. It would be a better idea if we explicitly show where the
    program starts, and from this point, different parts of the program will be called
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do an experiment to understand some points on how the code is executed
    and modules are imported:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Inside your Chapter2/experiments folder, create two new files named import_test.py
    and module_test.py. To do this, right-click inside the experiments folder and
    choose **New** | **Python file**.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Double-click on module_test.py to open it for editing.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'print "I''m module_test.py and my name is: " + __name__'
  prefs: []
  type: TYPE_NORMAL
- en: 'def function1():'
  prefs: []
  type: TYPE_NORMAL
- en: print "Hi, I'm inside function1."
  prefs: []
  type: TYPE_NORMAL
- en: print "Calling function1…"
  prefs: []
  type: TYPE_NORMAL
- en: function1()
  prefs: []
  type: TYPE_NORMAL
- en: Every module contains a __name__ attribute, and we will print its value in the
    first line of the code of this test.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will declare a function that, when called, prints "Hi, I'm inside function1."
    to the output.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will print that the function will be called, and then we will call
    function1\.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Run the code, press *Alt* + *Shift* + *F10* and choose module_test from
    the list. Take a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m module_test.py and my name is: __main__'
  prefs: []
  type: TYPE_NORMAL
- en: Calling function1…
  prefs: []
  type: TYPE_NORMAL
- en: Hi, I'm inside function1\.
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Note here that the __name__ attribute is equal to __main__; this is a special
    condition in Python. The module (the file) that is run is always called __main__.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. To understand more about this mechanism, create a new Python file inside
    the experiments folder, name it import_test.py, and open it for editing. Now,
    type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'print "I''m import_test.py and my name is: " + __name__'
  prefs: []
  type: TYPE_NORMAL
- en: print "Importing module_test"
  prefs: []
  type: TYPE_NORMAL
- en: import module_test
  prefs: []
  type: TYPE_NORMAL
- en: print "Calling function1 from within import_test"
  prefs: []
  type: TYPE_NORMAL
- en: module_test.function1()
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Now, run import_test.py (press *Alt* + *Shift* + *F10* and select it from
    the list) and take a look the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m import_test.py and my name is: __main__'
  prefs: []
  type: TYPE_NORMAL
- en: Importing module_test
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m module_test.py and my name is: module_test'
  prefs: []
  type: TYPE_NORMAL
- en: Calling function1…
  prefs: []
  type: TYPE_NORMAL
- en: Hi, I'm inside function1\.
  prefs: []
  type: TYPE_NORMAL
- en: Calling function1 from within import_test
  prefs: []
  type: TYPE_NORMAL
- en: Hi, I'm inside function1\.
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: This time it is import_test that is called __main__ because it is the file that
    is executed. Next, when we import module_test, the code in it is executed. Note
    that module_test is not called __main__ anymore; it’s called module_test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of this special __name__ attribute allows us to implement a technique
    in Python, which in turn allows us to execute some code when a file is run directly
    and avoid this code’s execution when this same file is imported. Let’s see how
    this works: 7\. Edit module_test.py and change its code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'print "I''m module_test.py and my name is: " + __name__'
  prefs: []
  type: TYPE_NORMAL
- en: 'def function1():'
  prefs: []
  type: TYPE_NORMAL
- en: print "Hi, I'm inside function1."
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: print "Calling function1 - only if i'm __main__…"
  prefs: []
  type: TYPE_NORMAL
- en: function1()
  prefs: []
  type: TYPE_NORMAL
- en: So, if __name__ is equal to '__main__', the code inside this block is executed,
    and
  prefs: []
  type: TYPE_NORMAL
- en: we know that __name__ is __main__ only when the file is executed directly.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the code inside this block is executed only when the file is run
    and not when it’s imported.
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Next, run import_test.py again (to rerun the last file, press *Shift* +
    *F10*), and take a look at what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m import_test.py and my name is: __main__'
  prefs: []
  type: TYPE_NORMAL
- en: Importing module_test
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m module_test.py and my name is: module_test'
  prefs: []
  type: TYPE_NORMAL
- en: Calling function1 from within import_test
  prefs: []
  type: TYPE_NORMAL
- en: Hi, I'm inside function1\.
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '9\. Now, run module_test.py (to choose the file to run, press *Alt* + *Shift*
    + *F10*) and look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m module_test.py and my name is: __main__'
  prefs: []
  type: TYPE_NORMAL
- en: Calling function1 - only if i'm __main__…
  prefs: []
  type: TYPE_NORMAL
- en: Hi, I'm inside function1\.
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, the code inside the if __name__ == ''__main__'': block ran only
    when module_test.py was run directly and not when it was imported.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to make an entry point explicit in Python, let’s create
    our first file for the application and make an entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Create a new file inside your Chapter2 folder and name it geocaching_app.py.
  prefs: []
  type: TYPE_NORMAL
- en: '11\. Then, open the file to edit and insert the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello geocaching APP!")
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the main() function is to receive the initial parameters and
    then take actions so that the program executes and produces the desired results.
    The content of the main function should be minimal and should try to express a
    clear sequence of actions. This makes the application’s logic very easy to debug.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: For Windows users, the if __name__ == '__main__' technique is also required
    in order for parallel processing to work; we will discuss this in [Chapter 10,](index_split_003.html#p424)
    *Parallel Processing*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading geocaching data**'
  prefs: []
  type: TYPE_NORMAL
- en: We now have the basic application structure with an entry point; next, we will
    start writing modules that execute the tasks that the application needs to produce
    the desired results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need is to obtain some geocaching data from the Internet,
    and we want our application to do this for us. There are two common ways of doing
    this, and they are not restricted only to geocaching data. Many geographical data
    repositories can be accessed by these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct download**: This is a download similar to what you do in a browser.
    There is a link, a request is made to this link, and the download starts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**REST API**: Many services offer this kind of data access. **REST** (**Representational**
    **State Transfer**) is a way of serving data where a client makes requests with
    a series of constraints, and the server responds with the result. It’s particularly
    useful because it allows the user to customize the data of interest.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geocaching data sources**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many sources of geocaching data on the Internet; some are commercial,
    and some are community driven. In the following table, you can note the summary
    of some of the sources available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Site**'
  prefs: []
  type: TYPE_NORMAL
- en: '**REST**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Region**'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencaching.us/](http://www.opencaching.us/)'
  prefs: []
  type: TYPE_NORMAL
- en: Y (OKAPI) Open
  prefs: []
  type: TYPE_NORMAL
- en: USA
  prefs: []
  type: TYPE_NORMAL
- en: '[http://opencaching.pl/](http://opencaching.pl/)'
  prefs: []
  type: TYPE_NORMAL
- en: Y (OKAPI) Open
  prefs: []
  type: TYPE_NORMAL
- en: Poland
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencaching.de/](http://www.opencaching.de/)'
  prefs: []
  type: TYPE_NORMAL
- en: Y (OKAPI) Open
  prefs: []
  type: TYPE_NORMAL
- en: Denmark
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencaching.nl/](http://www.opencaching.nl/)'
  prefs: []
  type: TYPE_NORMAL
- en: Y (OKAPI) Open
  prefs: []
  type: TYPE_NORMAL
- en: Netherlands
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencaching.ro/](http://www.opencaching.ro/)'
  prefs: []
  type: TYPE_NORMAL
- en: Y (OKAPI) Open
  prefs: []
  type: TYPE_NORMAL
- en: Romania
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencaching.it/](http://www.opencaching.it/)'
  prefs: []
  type: TYPE_NORMAL
- en: N
  prefs: []
  type: TYPE_NORMAL
- en: Open
  prefs: []
  type: TYPE_NORMAL
- en: Italy
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencachingspain.es/](http://www.opencachingspain.es/) N'
  prefs: []
  type: TYPE_NORMAL
- en: Open
  prefs: []
  type: TYPE_NORMAL
- en: Spain
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencaching.org.uk/](http://www.opencaching.org.uk/)'
  prefs: []
  type: TYPE_NORMAL
- en: N
  prefs: []
  type: TYPE_NORMAL
- en: Open
  prefs: []
  type: TYPE_NORMAL
- en: United Kingdom
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencaching.cz/](http://www.opencaching.cz/)'
  prefs: []
  type: TYPE_NORMAL
- en: N
  prefs: []
  type: TYPE_NORMAL
- en: Open
  prefs: []
  type: TYPE_NORMAL
- en: Czech Republic
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.geocaching.com/play](https://www.geocaching.com/play) Y'
  prefs: []
  type: TYPE_NORMAL
- en: Commercial Global
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: OKAPI is a public API project for National Opencaching sites (also known as
    **Opencaching Nodes**).
  prefs: []
  type: TYPE_NORMAL
- en: It provides OC sites with a set of useful, well-documented API methods, allows
    external developers to easily read public Opencaching data, allows us to read
    and write private (that is, user-related) data with OAuth 3-legged authentication.
    The project aims to become a standard API for all National Opencaching.xx sites.
  prefs: []
  type: TYPE_NORMAL
- en: '[(http://opencaching.pl/okapi/introduction.html](http://opencaching.pl/okapi/introduction.html))'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fetching information from a REST API**'
  prefs: []
  type: TYPE_NORMAL
- en: We will make a simple test to fetch data from a geocaching REST API. We won’t
    go deep into communicating with REST APIs this time because all geocaching sites
    require a user key so that users can access the data; this is in order to avoid
    abuses and misuse. For now, we will have a glimpse at how this works and request
    a method that doesn’t require a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in accessing the download functions, you can contact
    the site and request a key. Here’s how you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create a new file inside your Chapter2/utils directory and name it data_transfer.py.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Type this code in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from pprint import pprint
  prefs: []
  type: TYPE_NORMAL
- en: import requests
  prefs: []
  type: TYPE_NORMAL
- en: 'def request_api_methods():'
  prefs: []
  type: TYPE_NORMAL
- en: result = requests.get(
  prefs: []
  type: TYPE_NORMAL
- en: '"http://www.opencaching.us/okapi/services/apiref/method_index") pprint(result.json())'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: request_api_methods()
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run this file, press *Alt* + *Shift* + *F10*, and select rest_api on the
    list. Now, take a look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[{u''brief_description'': u''Retrieve information on given issue'', u''name'':
    u''services/apiref/issue''},'
  prefs: []
  type: TYPE_NORMAL
- en: '{u''brief_description'': u''Get information on a given OKAPI service method'','
  prefs: []
  type: TYPE_NORMAL
- en: 'u''name'': u''services/apiref/method''},'
  prefs: []
  type: TYPE_NORMAL
- en: '{u''brief_description'': u''Get a list of OKAPI methods with brief descriptions'','
  prefs: []
  type: TYPE_NORMAL
- en: 'u''name'': u''services/apiref/method_index''},'
  prefs: []
  type: TYPE_NORMAL
- en: '{u''brief_description'': u''Get information on this OKAPI installation'', u''name'':
    u''services/apisrv/installation''},'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '{u''brief_description'': u''Retrieve information on a single user'', u''name'':
    u''services/users/user''},'
  prefs: []
  type: TYPE_NORMAL
- en: '{u''brief_description'': u''Retrieve information on multiple users'', u''name'':
    u''services/users/users''}]'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: The URL that you see is meant to retrieve a list containing the description
    of all methods exposed by the API. The module requests makes everything much easier
    for us, and the
  prefs: []
  type: TYPE_NORMAL
- en: 'result.json() method converts the result of our request to a Python object
    (a list of dictionaries) and pprint (that is, pretty print) prints the list one
    item per line. Note that we made use of if __name__ == ''main'': here so that
    we can test our function; later, when this function is imported by other modules,
    all the code following if name =='
  prefs: []
  type: TYPE_NORMAL
- en: '''main'': won’t run, so we can safely put all our tests there.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading data from a URL**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the API key restriction in the geocaching sites and give continuity
    to our examples, we prepared some sample data that can be downloaded directly
    from a link. The function that you write downloads a file from a given URL and
    saves it to the disk. This function will be generalized and may be used by other
    applications in the future. We want to pass the following as parameters (that
    is, arguments):'
  prefs: []
  type: TYPE_NORMAL
- en: The URL or link to the file
  prefs: []
  type: TYPE_NORMAL
- en: A path to the destination folder
  prefs: []
  type: TYPE_NORMAL
- en: An override to the name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. In the data_transfer.py file, add the download_data function and edit the
    if __name__ == ''__main__'' block. Your code should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from pprint import pprint
  prefs: []
  type: TYPE_NORMAL
- en: import requests
  prefs: []
  type: TYPE_NORMAL
- en: from os import path
  prefs: []
  type: TYPE_NORMAL
- en: 'def request_api_methods():'
  prefs: []
  type: TYPE_NORMAL
- en: result = requests.get(
  prefs: []
  type: TYPE_NORMAL
- en: '"http://www.opencaching.us/okapi/services/apiref/method_index") pprint(result.json())'
  prefs: []
  type: TYPE_NORMAL
- en: 'def download_data(base_url, data_path, data_filename):'
  prefs: []
  type: TYPE_NORMAL
- en: save_file_path = path.join(data_path, data_filename)
  prefs: []
  type: TYPE_NORMAL
- en: request = requests.get(base_url, stream=True)
  prefs: []
  type: TYPE_NORMAL
- en: Save the download to the disk.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'with open(save_file_path, ''wb'') as save_file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for chunk in request.iter_content(1024):'
  prefs: []
  type: TYPE_NORMAL
- en: save_file.write(chunk)
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: download_data('https://s3.amazonaws.com/geopy/geocaching.gpx',
  prefs: []
  type: TYPE_NORMAL
- en: '''../../data'','
  prefs: []
  type: TYPE_NORMAL
- en: '''geocaching_test.gpx'')'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Now, run the code and check your data directory; there should be a new file
    there named geocaching_test.gpx.
  prefs: []
  type: TYPE_NORMAL
- en: What happens in the function is that first, we prepare the save_file_path variable
    using the os.path function; this function takes care of concatenating paths and
    ensuring that the result is correct for every operating system. Whenever we handle
    paths in our application,
  prefs: []
  type: TYPE_NORMAL
- en: we prefer using os.path.
  prefs: []
  type: TYPE_NORMAL
- en: Using the requests library, we can make a request to the desired URL. The optional
    stream=True parameter tells it that we want the download to happen in chunks,
    as we request, as opposed to downloading the whole file to the memory once. This
    is important because some files may be large in size and occupy a lot of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a file is opened and the chunks of data are read and written to the
    disk. The with statement is also called a **context manager** because it makes
    a given resource (a file, in this case) available only inside the block. Then,
    chunks of 1024 bytes each are read and written in the file. When the program exits
    the with block, the file is automatically closed and the save_file variable is
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want the application to download the file every time we run it; this
    would be a waste of time. So, in the next part, we need to implement a verification
    to make the program skip the download if there is already a file with the chosen
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the download_data function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def download_data(base_url, data_path, data_filename):'
  prefs: []
  type: TYPE_NORMAL
- en: save_file_path = path.join(data_path, data_filename)
  prefs: []
  type: TYPE_NORMAL
- en: request = requests.get(base_url, stream=True)
  prefs: []
  type: TYPE_NORMAL
- en: Check if the file exists.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if path.isfile(save_file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: print('File already available.')
  prefs: []
  type: TYPE_NORMAL
- en: Save the download to the disk.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'with open(save_file_path, ''wb'') as save_file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for chunk in request.iter_content(1024):'
  prefs: []
  type: TYPE_NORMAL
- en: save_file.write(chunk)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run your application again, and you should see the following output warning
    you that the file was already downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: File already available.
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 7](img/index-119_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Downloading data manually**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you may want to choose the data specifically for your region; to do this,
    you need to go to a geocaching site, filter the data, and download the file manually.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will go through the process to download data from the site
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opencaching.us/.](http://www.opencaching.us/) You don’t need an
    account; just follow these steps: 1\. Open the website. In the left-hand side
    menu, click on **Seek A Cache**: 2\. This will open a page containing various
    fields. First, select the limiting factors for your search using the fields shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 8](img/index-120_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 9](img/index-120_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3\. Next, you need to specify a region or criteria to search for the geocaches.
    There are many alternatives to choose from, so scroll through the page and take
    a look. You can use a zip code, coordinates, a state, and others. Let’s search
    by state; select **New York** and click on **Search**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 10](img/index-121_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 4\. A list with the results will appear. Scroll to the end of the page, and
    you will note the links to download data. Choose to download **Caches From All
    Pages** in the **GPX**
  prefs: []
  type: TYPE_NORMAL
- en: 'format:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opening the file and getting its contents**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will open the downloaded file and prepare it for processing. This is
    something that we already did in [Chapter 1,](#p45) *Preparing the Work Environment*,
    so we will copy our function and improve it so that we can reuse it in this application
    and the ones to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps that we will perform:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create a new file named geo_functions.py inside the utils directory.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Open the world_areas.py file from [Chapter 1,](#p45) *Preparing the Work
    Environment*, and copy the open_shapefile function. Then, paste it into the created
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Now, change the name of the function to open_vector_file so that it makes
    more sense as we will use this function to open many kinds of file. The geocaching
    file isn’t a shapefile—it’s a GPX, and to open it, we don’t need to change anything.
    OGR
  prefs: []
  type: TYPE_NORMAL
- en: will handle this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Now, to keep the code well documented, change the docstring to reflect the
    function’s capabilities. Change it to something similar to "Opens a vector file
    compatible with OGR, gets the first layer, and returns the OGR data source".
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Finally, don’t forget to import the required packages. Your code should
    look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: import osr
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_vector_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR, get the first layer and returns
    the ogr datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':return: The ogr datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: datasource = ogr.Open(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: print("Opening {}".format(file_path))
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format('
  prefs: []
  type: TYPE_NORMAL
- en: layer.GetFeatureCount()))
  prefs: []
  type: TYPE_NORMAL
- en: return datasource
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: open_vector_file("../../data/geocaching.gpx")
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the code again, and you should see the following output (don’t worry
    about the warnings):'
  prefs: []
  type: TYPE_NORMAL
- en: Opening ../data/geocaching.gpx
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning 1: Could not parse {2010-10-01T00:00:00Z} as a valid dateTime Warning
    1: Could not parse {2011-04-10T00:00:00Z} as a valid dateTime'
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning 1: Could not parse {2010-11-21T00:00:00Z} as a valid dateTime Number
    of features: 130'
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning 1: Could not parse {2010-11-22T00:00:00Z} as a valid dateTime'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparing the content for analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: This application makes use of distances such as meters or miles, so we do not
    want our measurements to be in degrees. Most geocaching coordinates and point
    data come in degrees, so we need to convert the coordinate system into the metric
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will start by using a function from [Chapter 1](#p45), *Preparing
    the Work* *Environment*: transform_geometries. Perform the following: 1\. Copy
    this function and paste it into the geo_functions.py file. This function will
    iterate over the features in the data to get its geometry and then convert the
    coordinate system, returning a list with all of the converted geometries. The
    function should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def transform_geometries(datasource, src_epsg, dst_epsg):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transform the coordinates of all geometries in the first layer.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: src_srs = osr.SpatialReference()
  prefs: []
  type: TYPE_NORMAL
- en: src_srs.ImportFromEPSG(src_epsg)
  prefs: []
  type: TYPE_NORMAL
- en: dst_srs = osr.SpatialReference()
  prefs: []
  type: TYPE_NORMAL
- en: dst_srs.ImportFromEPSG(dst_epsg)
  prefs: []
  type: TYPE_NORMAL
- en: transformation = osr.CoordinateTransformation(src_srs, dst_srs) layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: geoms = []
  prefs: []
  type: TYPE_NORMAL
- en: layer.ResetReading()
  prefs: []
  type: TYPE_NORMAL
- en: 'for feature in layer:'
  prefs: []
  type: TYPE_NORMAL
- en: geom = feature.GetGeometryRef().Clone()
  prefs: []
  type: TYPE_NORMAL
- en: geom.Transform(transformation)
  prefs: []
  type: TYPE_NORMAL
- en: geoms.append(geom)
  prefs: []
  type: TYPE_NORMAL
- en: return geoms
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining functions into an application**'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we looked at very useful utility functions that perform specific tasks;
    however, to form an application, we need to combine these functions by calling
    them in an ordered manner to achieve our objectives. We need code that orchestrates
    the calls and results—
  prefs: []
  type: TYPE_NORMAL
- en: one that will make the application run.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will dive into one of the most beautiful and powerful parts of
    Python programming: classes and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is an object-oriented programming language (but it is not strict). If
    you are not familiar with the concept of object-oriented programming, don’t worry;
    the best way to understand what this is about is by examples, so I won’t go into
    theories now but teach by example instead. Perform the following steps now:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Remember the application’s entry point? It’s in the Chapter2 folder, in
    the geochaching_app.py file. Open it for editing, and you should have this:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: def main():print "Hello geocaching APP!"
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, let’s import the modules that we have written so far so that we can
    use them in our application. Also, let’s import the other modules that we will
    need. Insert the import statements after the encoding declaration (# coding=utf-8).
    Your code should now be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_geometries
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: print "Hello geocaching APP!"
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, remove the main() function, and right after the imports, add the class
    that will represent our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeocachingApp(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data_file=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param data_file: An OGR compatible file'
  prefs: []
  type: TYPE_NORMAL
- en: with geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1\.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self._datasource = None
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = None
  prefs: []
  type: TYPE_NORMAL
- en: Part 2\.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if data_file:'
  prefs: []
  type: TYPE_NORMAL
- en: self.open_file(data_file)
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_file(self, file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open a file containing geocaching data and prepare it for use.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param file_path:'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = transform_geometries(
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource, 4326, 3395)
  prefs: []
  type: TYPE_NORMAL
- en: Here, we created a class representing our application. Inside the class, there
    is a special method called __init__. This method is called when the class is instantiated,
    which means when a new instance of the class is created. Here, we can see a parameter
    named self; this parameter is passed by the class to all instance methods, and
    self is the class instance itself. Again, don’t worry if these terms are strange
    to you, we will discuss more on them soon.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we defined two properties that any instance of this class
    may have; note that the underscore before the name denotes that a given property
    is for internal use only and should not be called from outside the class. This
    notation is only a convention, and it doesn’t really prevent the property from
    being used from outside the method. In second part, if the user passes the optional
    file, the application calls the open_file method, which in turn opens the file
    and prepares the data using the functions that we already developed.
  prefs: []
  type: TYPE_NORMAL
- en: The way it’s coded allows us to change the file that we work on at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Note that as we reached this point, we have achieved a higher level of abstraction.
    First, you had the OGR library with basic functions, where many lines of code
    were needed to be written to perform a given task. Then, you have the utils package,
    which wraps ogr functions into utility functions that perform simple tasks with
    a single line of code. Now, you have the application class that combines utility
    functions into methods that automate the processes by calling each one of them
    in the right order and with the right parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit your if __name__ == ''__main__'': block with the following code: if
    __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: my_app = GeocachingApp()
  prefs: []
  type: TYPE_NORMAL
- en: my_app.open_file('../data/geocaching.gpx') 2\. Run the application, and take
    a look at the results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting your current location**'
  prefs: []
  type: TYPE_NORMAL
- en: So far, the application can open a file. The next step is to define your location
    so that we can find the closest geocache. To do this, we will change the GeocachingApp
    class so that it can keep track of the current location through a property. We
    will also create methods to change the location (similar to the geometries), transform
    its coordinates, and prepare it for processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps that need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Edit the GeocachingApp class init method using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '#..'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data_file=None, my_location=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param data_file: An OGR compatible file'
  prefs: []
  type: TYPE_NORMAL
- en: with geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = None
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = None
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = None
  prefs: []
  type: TYPE_NORMAL
- en: self.distances = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if data_file:'
  prefs: []
  type: TYPE_NORMAL
- en: self.open_file(data_file)
  prefs: []
  type: TYPE_NORMAL
- en: 'if my_location:'
  prefs: []
  type: TYPE_NORMAL
- en: self.my_location = my_location
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, add these two methods to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self._my_location
  prefs: []
  type: TYPE_NORMAL
- en: '@my_location.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self, coordinates):'
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = transform_points([coordinates])[0]
  prefs: []
  type: TYPE_NORMAL
- en: The logic here is that the class instance should have a my_location property,
    and we want the program to automatically convert its coordinate system, as it
    does with geocaching data.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to achieve this kind of behavior. If you have experience
    with other programming languages, you may have come across the concept of getters
    and setters.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters are methods designed to retrieve and set a given property
    of a class.
  prefs: []
  type: TYPE_NORMAL
- en: The use of methods instead of direct access to the properties allows the programmer,
    among other things, to modify values or perform complex procedures when retrieving
    or changing a property.
  prefs: []
  type: TYPE_NORMAL
- en: We can have a getter and setter method for this property—get_my_location() and
  prefs: []
  type: TYPE_NORMAL
- en: set_my_location(), for example—but Python provides an elegant way of intervening
    in the processes of setting and getting a given property with the @property decorator.
  prefs: []
  type: TYPE_NORMAL
- en: As can be noted in the preceding code, the actual value of my_location is stored
    in the _my_location property and defined in the __init__ method (the underscore
    before the name denotes that the property shouldn’t be accessed outside the class).
  prefs: []
  type: TYPE_NORMAL
- en: Then, there are two methods with the same name, which is the name of the property
    that we want to expose. These functions are decorated so that the first one becomes
    a getter and the second one a setter. In the setter, we will call the functions
    that transform the coordinates of the point before storing it (we will get to
    this function in the next steps).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with the data, the location can be passed as an initial parameter
    to the class and changed at any time. Here’s how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, your complete class should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeocachingApp(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data_file=None, my_location=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param data_file: An OGR compatible file'
  prefs: []
  type: TYPE_NORMAL
- en: with geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: ':param my_location: Coordinates of your location.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = None
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = None
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = None
  prefs: []
  type: TYPE_NORMAL
- en: self.distances = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if data_file:'
  prefs: []
  type: TYPE_NORMAL
- en: self.open_file(data_file)
  prefs: []
  type: TYPE_NORMAL
- en: 'if my_location:'
  prefs: []
  type: TYPE_NORMAL
- en: self.my_location = my_location
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_file(self, file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open a file containing geocaching data'
  prefs: []
  type: TYPE_NORMAL
- en: and prepare it for use.
  prefs: []
  type: TYPE_NORMAL
- en: ':param file_path:'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = transform_geometries(
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource, 4326, 3395)
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self._my_location
  prefs: []
  type: TYPE_NORMAL
- en: '@my_location.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self, coordinates):'
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = transform_points([coordinates])[0]
  prefs: []
  type: TYPE_NORMAL
- en: 2\. As we don’t have a transform_points function, you should notice that PyCharm
  prefs: []
  type: TYPE_NORMAL
- en: 'underlines transform_points in red. So, let’s create one in the geo_functions.py
    file. Also, we will avoid boilerplate code by creating another function that creates
    the OSR transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boilerplate code**'
  prefs: []
  type: TYPE_NORMAL
- en: Boilerplate code, or boilerplate, are pieces of code that repeated in many places
    with little or no alteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_transform(src_epsg, dst_epsg):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Creates an OSR tranformation.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param src_epsg: EPSG code for the source geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param dst_epsg: EPSG code for the destination geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: ':return: osr.CoordinateTransformation'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: src_srs = osr.SpatialReference()
  prefs: []
  type: TYPE_NORMAL
- en: src_srs.ImportFromEPSG(src_epsg)
  prefs: []
  type: TYPE_NORMAL
- en: dst_srs = osr.SpatialReference()
  prefs: []
  type: TYPE_NORMAL
- en: dst_srs.ImportFromEPSG(dst_epsg)
  prefs: []
  type: TYPE_NORMAL
- en: return osr.CoordinateTransformation(src_srs, dst_srs)
  prefs: []
  type: TYPE_NORMAL
- en: 'def transform_points(points, src_epsg=4326, dst_epsg=3395):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Transform the coordinate reference system of a list of coordinates (a list
    of points)'
  prefs: []
  type: TYPE_NORMAL
- en: ':param src_epsg: EPSG code for the source geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param dst_epsg: EPSG code for the destination geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: transform = create_transform(src_epsg, dst_srs)
  prefs: []
  type: TYPE_NORMAL
- en: points = transform.TransformPoints(points)
  prefs: []
  type: TYPE_NORMAL
- en: return points
  prefs: []
  type: TYPE_NORMAL
- en: The transform_points function uses an OSR function with the same name that performs
    the transformation over an array. This function is incredibly efficient and can
    transform pairs of coordinates in an order of a magnitude of millions per second
    in an ordinary home computer. The reason that we will wrap it in our function
    is that we want to avoid repeating code and add default parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the my_location setter, we put the coordinates inside a list and
    then got the first element of the returning value (self.mylocation =
  prefs: []
  type: TYPE_NORMAL
- en: transform_points([coordinates])[0]).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 11](img/index-135_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 12](img/index-135_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Finding the closest point**'
  prefs: []
  type: TYPE_NORMAL
- en: To find the closest point, we need to first calculate the distance between the
    current location (my location) and all points. Then, we need to find the point
    that has the smallest distance from my location.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for each of the points, we must apply an equation that returns the distance
    to my location and stores these results in the same order as the points in the
    following table: **Point index x**'
  prefs: []
  type: TYPE_NORMAL
- en: '**y**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distance to my location**'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: 35 44 ?
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: 20 92 ?
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 11 77 ?
  prefs: []
  type: TYPE_NORMAL
- en: 'The distance between two points is given by the following equation: Translating
    this equation to Python, we have the following code: distance = math.sqrt((xb-xa)**2
    + (yb-ya)**2)'
  prefs: []
  type: TYPE_NORMAL
- en: The following table illustrates the basic Python math operators **Syntax**
  prefs: []
  type: TYPE_NORMAL
- en: '**Mathematical Expression Operation Name**'
  prefs: []
  type: TYPE_NORMAL
- en: a + b
  prefs: []
  type: TYPE_NORMAL
- en: '*a* + *b*'
  prefs: []
  type: TYPE_NORMAL
- en: Addition
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 13](img/index-136_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: a - b
  prefs: []
  type: TYPE_NORMAL
- en: '*a* - *b*'
  prefs: []
  type: TYPE_NORMAL
- en: Subtraction
  prefs: []
  type: TYPE_NORMAL
- en: a * b
  prefs: []
  type: TYPE_NORMAL
- en: '*a* x *b*'
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication
  prefs: []
  type: TYPE_NORMAL
- en: a / b
  prefs: []
  type: TYPE_NORMAL
- en: '*a* ÷ *b*'
  prefs: []
  type: TYPE_NORMAL
- en: Division
  prefs: []
  type: TYPE_NORMAL
- en: a ** b
  prefs: []
  type: TYPE_NORMAL
- en: '*a* b'
  prefs: []
  type: TYPE_NORMAL
- en: Exponent
  prefs: []
  type: TYPE_NORMAL
- en: math.sqrt(a)
  prefs: []
  type: TYPE_NORMAL
- en: Square root
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, insert the preceding method inside the GeocachingApp class by executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculate_distances(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculates the distance between a'
  prefs: []
  type: TYPE_NORMAL
- en: set of points and a given location.
  prefs: []
  type: TYPE_NORMAL
- en: ':return: A list of distances in the same order as'
  prefs: []
  type: TYPE_NORMAL
- en: the points.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: xa = self.my_location[0]
  prefs: []
  type: TYPE_NORMAL
- en: ya = self.my_location[1]
  prefs: []
  type: TYPE_NORMAL
- en: points = self._transformed_geoms
  prefs: []
  type: TYPE_NORMAL
- en: distances = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for geom in points:'
  prefs: []
  type: TYPE_NORMAL
- en: point_distance = math.sqrt(
  prefs: []
  type: TYPE_NORMAL
- en: (geom.GetX() - xa)**2 + (geom.GetY() - ya))
  prefs: []
  type: TYPE_NORMAL
- en: distances.append(point_distance)
  prefs: []
  type: TYPE_NORMAL
- en: return distances
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gradual optimization of code**'
  prefs: []
  type: TYPE_NORMAL
- en: Some equations or operations may be very complex, and they sometimes become
    hard to write, or you may need to see the results for the intermediary steps to
    debug. The tip for these situations is to not worry about writing optimized and
    fast code right away.
  prefs: []
  type: TYPE_NORMAL
- en: Start by writing readable and clear code, separating each intermediary step
    into variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following equation for distance:'
  prefs: []
  type: TYPE_NORMAL
- en: distance = math.sqr((xb-xa)**2 + (yb-ya)**2)
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be broken into intermediary steps:'
  prefs: []
  type: TYPE_NORMAL
- en: vertical_distance = yb - ya
  prefs: []
  type: TYPE_NORMAL
- en: horizontal_distance = xb – xa
  prefs: []
  type: TYPE_NORMAL
- en: distance = math.sqrt(horizontal_distance**2 + vertical_distance**2) Now, debug
    and check the results; when you are sure that the logic is correct and the result
    is what you expect, you can gradually optimize the code by replacing parts and
    trying alternative paths to improve the performance by checking whether the results
    match.
  prefs: []
  type: TYPE_NORMAL
- en: The final part is to find the closest point in the list of distances, which
    means to find the
  prefs: []
  type: TYPE_NORMAL
- en: 'index of the item that has the minimum value. Add this method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '#...'
  prefs: []
  type: TYPE_NORMAL
- en: 'def find_closest_point(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Find the closest point to a given location and return the cache that''s
    on that point.'
  prefs: []
  type: TYPE_NORMAL
- en: ':return: OGR feature containing the point.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1\.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: distances = self.calculate_distances()
  prefs: []
  type: TYPE_NORMAL
- en: index = np.argmin(distances)
  prefs: []
  type: TYPE_NORMAL
- en: Part 2\.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layer = self._datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: feature = layer.GetFeature(index)
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Closest point at: {}m".format(distances[index]) return feature'
  prefs: []
  type: TYPE_NORMAL
- en: There is a possibility that the data contains repeated values, which will result
    in the same distance, or a remote possibility that two points have the same distance.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the first part, the np.argmin function returns the index or indexes with
    a minimum value among all points. In the second part, the program gets the feature
    at this index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Now, let’s test our application and edit the if __name__ == ''__main__''
    block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: my_app = GeocachingApp('../data/geocaching.gpx', [-73.0, 43.0]) my_app.find_closest_point()
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Now, your geocaching_app.py should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: from utils.geo_functions import open_vector_file
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_geometries
  prefs: []
  type: TYPE_NORMAL
- en: from utils.geo_functions import transform_points
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: 'class GeocachingApp(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, data_file=None, my_location=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Application class.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param data_file: An OGR compatible file'
  prefs: []
  type: TYPE_NORMAL
- en: with geocaching points.
  prefs: []
  type: TYPE_NORMAL
- en: ':param my_location: Coordinates of your location.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = None
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = None
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = None
  prefs: []
  type: TYPE_NORMAL
- en: self.distances = None
  prefs: []
  type: TYPE_NORMAL
- en: 'if data_file:'
  prefs: []
  type: TYPE_NORMAL
- en: self.open_file(data_file)
  prefs: []
  type: TYPE_NORMAL
- en: 'if my_location:'
  prefs: []
  type: TYPE_NORMAL
- en: self.my_location = my_location
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_file(self, file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open a file containing geocaching data and prepare it for use.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param file_path:'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource = open_vector_file(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: self._transformed_geoms = transform_geometries(
  prefs: []
  type: TYPE_NORMAL
- en: self._datasource, 4326, 3395)
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self._my_location
  prefs: []
  type: TYPE_NORMAL
- en: '@my_location.setter'
  prefs: []
  type: TYPE_NORMAL
- en: 'def my_location(self, coordinates):'
  prefs: []
  type: TYPE_NORMAL
- en: self._my_location = transform_points([coordinates])[0]
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculate_distances(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculates the distance between a'
  prefs: []
  type: TYPE_NORMAL
- en: set of points and a given location.
  prefs: []
  type: TYPE_NORMAL
- en: ':return: A list of distances in the same order as'
  prefs: []
  type: TYPE_NORMAL
- en: the points.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: xa = self.my_location[0]
  prefs: []
  type: TYPE_NORMAL
- en: ya = self.my_location[1]
  prefs: []
  type: TYPE_NORMAL
- en: points = self._transformed_geoms
  prefs: []
  type: TYPE_NORMAL
- en: distances = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for geom in points:'
  prefs: []
  type: TYPE_NORMAL
- en: point_distance = math.sqrt(
  prefs: []
  type: TYPE_NORMAL
- en: (geom.GetX() - xa)**2 + (geom.GetY() - ya))
  prefs: []
  type: TYPE_NORMAL
- en: distances.append(point_distance)
  prefs: []
  type: TYPE_NORMAL
- en: return distances
  prefs: []
  type: TYPE_NORMAL
- en: 'def find_closest_point(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Find the closest point to a given location and return the cache that''s
    on that point.'
  prefs: []
  type: TYPE_NORMAL
- en: ':return: OGR feature containing the point.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: Part 1\.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: distances = self.calculate_distances()
  prefs: []
  type: TYPE_NORMAL
- en: index = np.argmin(distances)
  prefs: []
  type: TYPE_NORMAL
- en: Part 2\.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layer = self._datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: feature = layer.GetFeature(index)
  prefs: []
  type: TYPE_NORMAL
- en: 'print "Closest point at: {}m".format(distances[index]) return feature'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: my_app = GeocachingApp('../data/geocaching.gpx', [-73.0, 43.0]) my_app.find_closest_point()
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Run the code, press *Alt* + *Shift* + *F10*, and select geocaching_app.
    Take a look at the result in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Closest point at: 49653.3244095m'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discussed important concepts related to code organization
    and data manipulation. This was accomplished by writing code with an increasing
    level of abstraction until we had a class with high-level functionality.
  prefs: []
  type: TYPE_NORMAL
- en: First, we wrote utility functions in order to automate tasks and prepare the
    data to be processed. Some of these functions were simple abstractions over the
    OGR library, which were made to avoid unnecessary code repetition.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we wrote methods in a class representing the application. These methods
    take care of performing sequences of operations to make an application work.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we presented the foundation of how to perform mathematical operations
    over the elements of data. We wrote a very efficient method that calculates the
    distance for a list of elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will improve our data abstraction and make it possible
    for the application to combine multiple sources of data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 3\. Combining Multiple Data**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sources**'
  prefs: []
  type: TYPE_NORMAL
- en: Geographic data tends to be heterogeneous. Just to cite a few factors that contribute
    to this heterogeneity, it may come from different sources, have been produced
    at different times, or even have different languages. Given this fact, writing
    programs that can combine multiple sources of data is a fundamental topic in geoprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Data sources may come in different formats, such as shapefiles, text files,
    Google KML
  prefs: []
  type: TYPE_NORMAL
- en: files, GPX files from GPS, and so on. They may also vary in their contents;
    for example, they may have different types of geometries, coordinate systems,
    and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will enhance our application by adding the capability to
    combine multiple sources of data from both different sites and different file
    formats. In order to achieve this, we will write code capable of identifying the
    type of data, and depending on this, we will make transformations to obtain a
    homogeneous set of data.
  prefs: []
  type: TYPE_NORMAL
- en: By extending OGR capabilities and including our own functions, we can represent
    the data in Python classes and add some smart capabilities to them that would
    make the process of combining many sources very easy for this application and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve these objectives, we will cover the following topics in
    this chapter: The structure of geographic data files'
  prefs: []
  type: TYPE_NORMAL
- en: How geometries are represented
  prefs: []
  type: TYPE_NORMAL
- en: How to transform data into Python objects
  prefs: []
  type: TYPE_NORMAL
- en: How to combine multiple sources of data
  prefs: []
  type: TYPE_NORMAL
- en: Using class inheritance in Python to write better code
  prefs: []
  type: TYPE_NORMAL
- en: '**Representing geographic data**'
  prefs: []
  type: TYPE_NORMAL
- en: Most file formats that contain geographic data are made of a common simple structure
    consisting of a number of features, each containing a geometry and innumerous
    named properties.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can take a look at a sample of the contents of a GeoJSON file. This
    type of geographic file has the advantage of being human readable, allowing us
    to see exactly the structure that is being described. You don’t need to type this
    example; just take a good look at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its structure is very similar to a Python dictionary. At the uppermost level,
    there is FeatureCollection, which contains a list of features. Each feature has
    a geometry, whose type may vary, and a *dictionary* of properties that may contain
    any arbitrary property defined by the user. In brief, it follows exactly the described
    schema of data representation as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '{"type": "FeatureCollection",'
  prefs: []
  type: TYPE_NORMAL
- en: '"features": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Point",'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": [102.0, 0.5]},'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": {"prop0": "value0"}'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "LineString",'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0]]'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"prop0": "value0",'
  prefs: []
  type: TYPE_NORMAL
- en: '"prop1": 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{"type": "Feature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"geometry": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"type": "Polygon",'
  prefs: []
  type: TYPE_NORMAL
- en: '"coordinates": ['
  prefs: []
  type: TYPE_NORMAL
- en: '[ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],'
  prefs: []
  type: TYPE_NORMAL
- en: '[100.0, 1.0], [100.0, 0.0] ]'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"properties": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"prop0": "value0",'
  prefs: []
  type: TYPE_NORMAL
- en: '"prop1": {"this": "that"}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation** and is a format that can
    be easily read and written in a number of programming languages. Specifically
    in Python, a JSON object can'
  prefs: []
  type: TYPE_NORMAL
- en: be transformed into a dictionary and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: There a number of other formats that implement the same structure; some of them
    add extra functionality and some have characteristics that are very specific for
    a given purpose.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the **ESRI** shapefile has indexing capabilities, the **GPX** format
    is made to work with GPS devices to store waypoints and tracks, and **SpatiLite**
    is a single file spatial database at the top of SQLite that allows objects to
    have relations with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, there are some common file formats and a brief description
    of each: **Format**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: Cartesian
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple point cloud.
  prefs: []
  type: TYPE_NORMAL
- en: coordinate system
  prefs: []
  type: TYPE_NORMAL
- en: Digital Line
  prefs: []
  type: TYPE_NORMAL
- en: This is a USGS format for vector data.
  prefs: []
  type: TYPE_NORMAL
- en: Graph (DLG)
  prefs: []
  type: TYPE_NORMAL
- en: Geography
  prefs: []
  type: TYPE_NORMAL
- en: Markup
  prefs: []
  type: TYPE_NORMAL
- en: This is an XML-based open standard (by OpenGIS) for GIS data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Language
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON
  prefs: []
  type: TYPE_NORMAL
- en: This is a lightweight format based on JSON and is used by many open source GIS
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: This is a spatial extension to SQLite that provides vector geodatabase functionality.
    It is similar to Spatialite
  prefs: []
  type: TYPE_NORMAL
- en: PostGIS, Oracle Spatial, and SQL Server with spatial extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Shapefile
  prefs: []
  type: TYPE_NORMAL
- en: This is a popular vector data GIS format developed by Esri.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 14](img/index-146_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Representing geometries**'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw before, in geographic data, each feature contains a geometry. A geometry
    is the spatial representation of a given object. For example, a point can represent
    a tree, a place of interest, or, as in our case, a geocache. A line can be a road,
    a river, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Countries, cities, states, or any other type of areas can be represented by
    polygons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will follow the geometry representation described by the simple
    features specifications standardized in ISO 19125\. It consists of two-dimensional
    geographic data made of points, lines, polygons, and aggregations or collections
    of them, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: Any geometry in this format is represented by points and a linear interpolation
    between them. An example of this would be two points that form a line.
  prefs: []
  type: TYPE_NORMAL
- en: This type of geometry is simple, very common, and easy to use. Nevertheless,
    there are noticeable flaws, and the most important one is the lack of topological
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we may have two features representing two neighbor countries—for
    example, Canada and USA. For each feature (that is, each country) there is a polygon
    representing the whole limit of the country. By consequence, the borders shared
    by the two countries will overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 15](img/index-147_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, think about the states in the USA and the provinces of Canada; each will
    be a polygon, their borders will also overlap, and they will, in turn, overlap
    the countries’
  prefs: []
  type: TYPE_NORMAL
- en: 'borders. So, we will end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: States/provinces
  prefs: []
  type: TYPE_NORMAL
- en: Country border
  prefs: []
  type: TYPE_NORMAL
- en: Other country border
  prefs: []
  type: TYPE_NORMAL
- en: Other states/provinces
  prefs: []
  type: TYPE_NORMAL
- en: This makes four overlapping lines; if we want to represent cities, districts,
    and so on, the number of overlapping geometries would increase. With this, we
    would have a higher probability of errors and require more space for storage.
  prefs: []
  type: TYPE_NORMAL
- en: This is why this type of geometry representation is also called **spaghetti
    data**; it ends with a juxtaposition of a lot of lines (similar to spaghetti).
  prefs: []
  type: TYPE_NORMAL
- en: This flaw can be solved through the topological representation of the geometries.
    The big difference is that, in this example, it wouldn’t store polygons; it would
    store the relationships between objects. You have a set of boundaries that relate
    to each other and represent an area, and two areas can have the same boundary.
    **OpenStreetMap** is a good example of a topological representation of geographic
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Although topological representation is more advanced, it is much harder to work
    with, and the vast majority of geographic analysis can be done with a simple representation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making data homogeneous**'
  prefs: []
  type: TYPE_NORMAL
- en: What relates the representation of data to real-life objects is the simple combination
    of geometry with the properties of a feature.
  prefs: []
  type: TYPE_NORMAL
- en: A line for example, can be a road, river, fence, and so on. The only difference
    may be the type property that tells us what it is. Alternatively, we may have
    a file named roads that lets us know that it contains roads.
  prefs: []
  type: TYPE_NORMAL
- en: However, the computer doesn’t know about this as it doesn’t know what the other
    properties represent or what the file is. Because of this, we need to make transformations
    in the data in order to have a common format that can be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: This common format is the subject of this topic; it is how data can be represented
    in Python in an optimal way and in which the objects can be manipulated and analyzed
    to produce the expected results.
  prefs: []
  type: TYPE_NORMAL
- en: The objective is to transform the basic data representation of features, geometries,
    and properties into a representation of real-life objects and hide the details
    of the functionality under the hood in this process. In computer science, this
    is called **abstraction**.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of just writing some prepared code and magically performing the transformation,
    we will go step by step through the process of deduction of how the transformation
    needs to be done. This is very important because it’s the foundation of developing
    code to perform any kind of transformation on any type of geographic data that
    you can put to use in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '**The concept of abstraction**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clear understanding of how data is represented, let’s get
    back to our geocaching application.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction is a programming technique intended to reduce the complexity of
    code for the programmer. It’s done by encapsulating complex code under progressive
    layers of more human-friendly solutions. The lower the level of abstraction, the
    closer to the machine language and the harder to maintain it is. The higher the
    level of abstraction, the more the code tries to mimic the behavior of real things
    or the more it resembles a natural language, thus becoming more intuitive and
    easier to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the examples that we saw so far, we may notice many levels of
    abstraction
  prefs: []
  type: TYPE_NORMAL
- en: —for example, when we use the OGR library in the function we use to open shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def open_vector_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR, get the first layer and returns
    the ogr datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':return: The ogr datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: datasource = ogr.Open(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: print("Opening {}".format(file_path))
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format(layer.GetFeatureCount())) return datasource'
  prefs: []
  type: TYPE_NORMAL
- en: Just at the uppermost layers of abstraction, we have the function itself that
    hides the functionality of OGR. Then, we have the OGR Python bindings that abstract
    the OGR C
  prefs: []
  type: TYPE_NORMAL
- en: API, which in turn handles memory allocation, all the mathematics, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 16](img/index-151_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Abstracting the geocache point**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to handle multiple sources of data in a smart way so that: We don’t
    need to change the code for each type of data'
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to combine data from multiple sources
  prefs: []
  type: TYPE_NORMAL
- en: If we add extra functionality to our program, we don’t need to worry about file
    formats and data types
  prefs: []
  type: TYPE_NORMAL
- en: 'How will we do this? The answer is simple: we will abstract our data and hide
    the process of format and type handling in the internal functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: The objective is that after this point in the app, we won’t need to deal with
    OGR, layers, features, and so on. We will have one and only one type of object
    that we will use to represent our data, and all the interaction will be done with
    this object. The geocache object will represent a single geocaching point with
    the properties and methods that can be used to manipulate this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, let’s organize the project structure. Open your geopy project in
    PyCharm and create a directory named Chapter3\.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Copy all the files and directories from Chapter2 to Chapter3\. You should
    end up with a structure similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: +---Chapter3
  prefs: []
  type: TYPE_NORMAL
- en: '| | geocaching_app.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| | __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| |'
  prefs: []
  type: TYPE_NORMAL
- en: '| +---experiments'
  prefs: []
  type: TYPE_NORMAL
- en: '| | import_test.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| | module_test.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| |'
  prefs: []
  type: TYPE_NORMAL
- en: '| \---utils'
  prefs: []
  type: TYPE_NORMAL
- en: '| data_transfer.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| geo_functions.py'
  prefs: []
  type: TYPE_NORMAL
- en: '| __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Inside Chapter3, create a new file named models.py (from this point on,
    we will
  prefs: []
  type: TYPE_NORMAL
- en: work inside the Chapter3 directory).
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now, add this code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Geocache(object):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a single geocaching point."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, x, y):'
  prefs: []
  type: TYPE_NORMAL
- en: self.x = x
  prefs: []
  type: TYPE_NORMAL
- en: self.y = y
  prefs: []
  type: TYPE_NORMAL
- en: '@property'
  prefs: []
  type: TYPE_NORMAL
- en: 'def coordinates(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return self.x, self.y
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now, we have a geocache class with its first properties: the coordinates
    for the geocache. To test our class, we can write the following code: if __name__
    == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: one_geocaching_point = Geocache(20, 40)
  prefs: []
  type: TYPE_NORMAL
- en: print(one_geocaching_point.coordinates)
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run your code, press *Alt* + *Shift* + *F10*, and select the models files.
    You should get this output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: (20, 40)
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstracting geocaching data**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have a single point, we also need to have a collection of points. We
    will call this PointCollection. Continuing the process of abstraction, the objective
    is to hide the operations of importing and converting the data. We will do this
    by creating a new class and encapsulating some of our utility functions inside
    it. Go to your models.py file and add the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class PointCollection(object):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""This class represents a group of vector data."""'
  prefs: []
  type: TYPE_NORMAL
- en: Self.data = []
  prefs: []
  type: TYPE_NORMAL
- en: It’s a simple class definition, and in the __init__ method, we will define that
    each instance of this class will have a data property. Now that we have created
    our simple abstractions, let’s add functionality to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing geocaching data**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we generalized our import function by adding the capability
    to import more types of data supported by OGR.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will improve it again, make it handle some errors, make it compatible
    with our objects, and add two new capabilities. We will also convert the data
    in order to produce uniform objects.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve our goals, we will analyze what kind of information is stored in
    the files that we want to open. We will use OGR to inspect the files and return
    some information that may help us with the data conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s alter our open_vector_file function, allowing it to handle incorrect
    paths and filenames, which is a very a common error. Perform the following steps:
    1\. Go to the utils folder and open the geo_functions.py file.'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Add the following import statements at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: import osr
  prefs: []
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: from pprint import pprint
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Now, edit the open_vector_file function via the following code: def open_vector_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Opens an vector file compatible with OGR, get the first layer and returns
    the ogr datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: ':return: The ogr datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: datasource = ogr.Open(file_path)
  prefs: []
  type: TYPE_NORMAL
- en: Check if the file was opened.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if not datasource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not os.path.isfile(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: message = "Wrong path."
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: message = "File format is invalid."
  prefs: []
  type: TYPE_NORMAL
- en: raise IOError(
  prefs: []
  type: TYPE_NORMAL
- en: '''Error opening the file {}\n{}''.format('
  prefs: []
  type: TYPE_NORMAL
- en: file_path, message))
  prefs: []
  type: TYPE_NORMAL
- en: layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: print("Opening {}".format(file_path))
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Number of features: {}".format('
  prefs: []
  type: TYPE_NORMAL
- en: layer.GetFeatureCount()))
  prefs: []
  type: TYPE_NORMAL
- en: return datasource
  prefs: []
  type: TYPE_NORMAL
- en: In this step, we added a verification to check whether the file was correctly
    opened. If the file doesn’t exist or if there are any other problems, OGR will
    be silent and the
  prefs: []
  type: TYPE_NORMAL
- en: datasource will be empty. So, if the datasource is empty (None), we will know
    that something went wrong and perform another verification to see whether there
    was a mistake with the file path or something else happened. In either case, the
    program will raise an exception, preventing it from continuing with bad data.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Now, we will add another function to print some information about the datasource
    for us. After the open_vector_file function, add the get_datasource_information
    function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_datasource_information(datasource, print_results=False):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Get informations about the first layer in the datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param datasource: An OGR datasource.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param bool print_results: True to print the results on'
  prefs: []
  type: TYPE_NORMAL
- en: the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: info = {}
  prefs: []
  type: TYPE_NORMAL
- en: layer = datasource.GetLayerByIndex(0)
  prefs: []
  type: TYPE_NORMAL
- en: bbox = layer.GetExtent()
  prefs: []
  type: TYPE_NORMAL
- en: info['bbox'] = dict(xmin=bbox[0], xmax=bbox[1],
  prefs: []
  type: TYPE_NORMAL
- en: ymin=bbox[2], ymax=bbox[3])
  prefs: []
  type: TYPE_NORMAL
- en: srs = layer.GetSpatialRef()
  prefs: []
  type: TYPE_NORMAL
- en: 'if srs:'
  prefs: []
  type: TYPE_NORMAL
- en: info['epsg'] = srs.GetAttrValue('authority', 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: info['epsg'] = 'not available'
  prefs: []
  type: TYPE_NORMAL
- en: info['type'] = ogr.GeometryTypeToName(layer.GetGeomType())
  prefs: []
  type: TYPE_NORMAL
- en: Get the attributes names.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: info['attributes'] = []
  prefs: []
  type: TYPE_NORMAL
- en: layer_definition = layer.GetLayerDefn()
  prefs: []
  type: TYPE_NORMAL
- en: 'for index in range(layer_definition.GetFieldCount()):'
  prefs: []
  type: TYPE_NORMAL
- en: info['attributes'].append(
  prefs: []
  type: TYPE_NORMAL
- en: layer_definition.GetFieldDefn(index).GetName())
  prefs: []
  type: TYPE_NORMAL
- en: Print the results.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if print_results:'
  prefs: []
  type: TYPE_NORMAL
- en: pprint(info)
  prefs: []
  type: TYPE_NORMAL
- en: return info
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will use a number of OGR’s methods and functions to get information
    from the datasource and layer on it. This information is put in a dictionary,
    which is returned by the function. If we have print_results = True, the dictionary
    is printed with the pprint function (pretty print). This function tries to print
    Python objects in a more human-friendly way.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. Now, to test our code, edit the if __name__ == ''__main__'': block at the
    end of the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: gdal.PushErrorHandler('CPLQuietErrorHandler')
  prefs: []
  type: TYPE_NORMAL
- en: datasource = open_vector_file("../../data/geocaching.gpx") info = get_datasource_information(
  prefs: []
  type: TYPE_NORMAL
- en: datasource, print_results=True)
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a new element here: gdal.PushErrorHandler(''CPLQuietErrorHandler'').'
  prefs: []
  type: TYPE_NORMAL
- en: Geocaching files normally contain features with empty date fields. When OGR
    finds this situation, it prints a warning message. This could get pretty annoying
    when we have a lot of features. This command tells OGR/GDAL to suppress these
    messages so that we can have a clean output with only what we want to see.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the code, press *Alt* + *Shift* + *F10*, and select **geo_functions**.
    You should get the following output showing the information that is collected:
    Opening ../../data/geocaching.gpx'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of features: 130'
  prefs: []
  type: TYPE_NORMAL
- en: '{''attributes'': [''ele'','
  prefs: []
  type: TYPE_NORMAL
- en: '''time'','
  prefs: []
  type: TYPE_NORMAL
- en: '''magvar'','
  prefs: []
  type: TYPE_NORMAL
- en: '''geoidheight'','
  prefs: []
  type: TYPE_NORMAL
- en: '''name'','
  prefs: []
  type: TYPE_NORMAL
- en: '''cmt'','
  prefs: []
  type: TYPE_NORMAL
- en: '''desc'','
  prefs: []
  type: TYPE_NORMAL
- en: '''src'','
  prefs: []
  type: TYPE_NORMAL
- en: '''url'','
  prefs: []
  type: TYPE_NORMAL
- en: '''urlname'','
  prefs: []
  type: TYPE_NORMAL
- en: '''sym'','
  prefs: []
  type: TYPE_NORMAL
- en: '''type'','
  prefs: []
  type: TYPE_NORMAL
- en: '''fix'','
  prefs: []
  type: TYPE_NORMAL
- en: '''sat'','
  prefs: []
  type: TYPE_NORMAL
- en: '''hdop'','
  prefs: []
  type: TYPE_NORMAL
- en: '''vdop'','
  prefs: []
  type: TYPE_NORMAL
- en: '''pdop'','
  prefs: []
  type: TYPE_NORMAL
- en: '''ageofdgpsdata'','
  prefs: []
  type: TYPE_NORMAL
- en: '''dgpsid''],'
  prefs: []
  type: TYPE_NORMAL
- en: '''bbox'': {''xmax'': -73.44602,'
  prefs: []
  type: TYPE_NORMAL
- en: '''xmin'': -79.3536,'
  prefs: []
  type: TYPE_NORMAL
- en: '''ymax'': 44.7475,'
  prefs: []
  type: TYPE_NORMAL
- en: '''ymin'': 40.70558},'
  prefs: []
  type: TYPE_NORMAL
- en: '''epsg'': ''4326'','
  prefs: []
  type: TYPE_NORMAL
- en: '''type'': ''Point''}'
  prefs: []
  type: TYPE_NORMAL
- en: Process finished with exit code 0
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The attributes key of the dictionary contains the field names that could be
    read from the data. Every feature on our GPX file (that is, every point) contains
    this set of attributes. The bbox code is the bounding box of the data, which are
    the coordinates of the upper-left and lower-right corners of the rectangle that
    comprises the geographical extent of the data. The epsg code contains the code
    for the coordinate system of the data. Finally, type is the type of geometry identified
    by OGR.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading GPX attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the attributes (field names) found by OGR in the previous example;
    we have a name, a description, and the time. We have some technical data about
    the GPS
  prefs: []
  type: TYPE_NORMAL
- en: solution (pdop, hdop, sat, fix, and many more) and some other fields, but none
    of them contains in-depth information about the geocache.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to take a look at what information the GPX file contains that OGR
    is not displaying, let’s open it in PyCharm:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. In your geopy project, go to the data folder.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Locate geocaching.gpx. To open it, either drag and drop it in the editor
    area or double-click on the filename.
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm will open it for editing but won’t recognize the file format and will
    display it in a single color; so, let’s inform it that this is an XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Right-click on the geocaching.gpx file. In the menu, select **Associate
    with File** **Type**, and a window with a list will pop up. Select **XML Files**
    and then click on the **OK** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the contents of the GPX file should appear with colors differentiating
    the various elements of the extended markup language. PyCharm is also capable
    of recognizing the file structure, as it does with Python. Let’s take a look via
    the following steps: 1\. Press *Alt* + *7* or navigate to the **View** | **Tool
    Windows** | **Structure** menu.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 17](img/index-159_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 2\. This is the GPX file structure. Note that after some initial tags, it contains
    all the waypoints. Click on the arrow to the left of any waypoint to expand it.
    Then, locate the waypoint’s geocache tag and expand it too.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 18](img/index-160_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3\. As you can note, the geocaching point contains much more information than
    OGR is capable of reading, including the status attribute of the geocache tag.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Before we proceed, explore the file to get familiar with its notation. Click
    on some of the tags and look at the code editor to see the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Since we can’t access these attributes directly with OGR, we will program an
    alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'The objective is to read this information and flatten it in a single level
    of key/value pairs in a dictionary. GPX files are XML files, so we can use an
    XML parser to read them. The choice here is the xmltodict package; it will simply
    convert the XML file into a Python dictionary, making it easier to manipulate
    as we are very familiar with dictionaries. Now, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Add the import of xmltodict at the beginning of the geo_functions.py file
    by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: coding=utf-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import xmltodict
  prefs: []
  type: TYPE_NORMAL
- en: import ogr
  prefs: []
  type: TYPE_NORMAL
- en: import osr
  prefs: []
  type: TYPE_NORMAL
- en: import gdal
  prefs: []
  type: TYPE_NORMAL
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: from pprint import pprint
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Create a new function before open_vector_file and add the following code:
    def read_gpx_file(file_path):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Reads a GPX file containing geocaching points.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param str file_path: The full path to the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(file_path) as gpx_file:'
  prefs: []
  type: TYPE_NORMAL
