- en: Chapter 3. Container Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container types are used to group objects together. The main difference between
    the different container types is the way individual elements are accessed and
    how operations are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list is, as the name hints, a list of objects of any kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The individual objects are enumerated by assigning each element an index. The
    first element in the list gets index 0\. This zero-based indexing is frequently
    used in mathematical notation. Consider the usual indexing of coefficients of
    a polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: 'The index allows us to access the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The bracket notation here corresponds to the use of subscripts in mathematical
    formulas. `L` is a simple list, while `M` itself contains a list so that one needs
    two indexes to access an element of the inner list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list containing subsequent integers can easily be generated by the command
    `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A more general use is to provide this command with start, stop, and step parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `len` returns the length of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slicing a list between `i` and `j` creates a new list containing the elements
    starting at `index i` and ending just before `j`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For slicing, a range of indexes has to be given. `L[i:j]` means create a list
    by taking all elements from `L` starting at `L[i]` until `L[j-1]`. In other words,
    the new list is obtained by removing the first `i` elements from `L` and taking
    the next `j-i` elements (for *j* > *i* ≥ 0). See the following figure (*Figure
    3.1*) for more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Slicing](img/slicing.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Some typical slicing situations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `L[i:]` means remove the *i* first elements, `L[:i]` means take only
    the first *i* elements, and similarly, `L[:-i]` means remove the last *i* elements,
    and `L[-i:]` means take only the last *i* elements. This may be combined in `L[i:-j]` to
    remove the first *i* and the last *j* elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One may omit the first or last bound of the slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Python allows the use of negative indexes for counting from the right. In particular,
    the element `L[-1]` is the last element in the list `L`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some list indexing descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`L[i:]` amounts to taking all elements except the *i* first ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L[:i]` amounts to taking the first *i* elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L[-i:]` amounts to taking the last *i* elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L[:-i]` amounts to taking all elements except the *i* last ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Omitting one index in the range corresponds to half-open intervals in ℝ. The
    half-open interval (∞, *a*) means, take all numbers strictly lower than *a*; this
    is similar to the syntax `L[:j]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Out of-bound slices**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you never get index errors with out-of-bound slices. Possibly, you
    may obtain empty lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful when using variables in indexing that may become negative, since
    it changes the slice completely. This might lead to unexpected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The result is `3`, `0`, `1`, `3` while one expects `0`, `0`, `1`, `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Strides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When computing slices, one may also specify a stride, which is the length of
    the step from one index to the other. The default stride is one. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the stride may also be negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to create a new list that is reversed, using a negative
    stride (find about reverse method in section *In-place operations*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Altering lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typical operations on lists are insertion and deletion of elements and list
    concatenation. With the slicing notation, list insertion and deletion become obvious;
    deletion is just replacing a part of a list by an empty list `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Insertion means replacing an empty slice with the list to be inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Two lists are concatenated by the plus operator `+` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating a list `n` times with itself motivates the use of the multiplication
    operator  `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There is no arithmetic operations on list, such as elementwise summation or
    division. For such operations we use arrays (refer to section *Array*).
  prefs: []
  type: TYPE_NORMAL
- en: Belonging to a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One may use the keywords `in` and `not in` to determine whether an element
    belongs to a list or not which is similar to ![Belonging to a list](img/in.jpg)
    and ![Belonging to a list](img/notin.jpg) in mathematics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: List methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some useful methods of the `list` type are collected in the following T*able
    3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `list.append(x)` | Add `x` to the end of the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.expand(L)` | Expand the list by the elements of the list `L`. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.insert(i,x)` | Insert `x` at position `i`. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.remove(x)` | Remove the first item from the list whose value is `x`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `list.count(x)` | The number of times `x` appears in the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.sort()` | Sort the items of the list, in place. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.reverse()` | Reverse the elements of the list, in place. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.pop()` | Remove the last element of the list, in place. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: Methods of the datatype list'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways list methods can act:'
  prefs: []
  type: TYPE_NORMAL
- en: They can directly alter the list, that is, in-place operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They produce a new object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In–place operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All methods that result in a list are in-place operating methods, for example,
    `reverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware of in-place operations. One might be tempted to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is correct Python. But it results in a possibly unintended alternation
    of `L` in a variable `newL` having the value `None`. The reason is that `sort`
    operates in-place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we demonstrate in-place operating methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`L` is altered. The `count` method is an example of a method that generates
    a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Merging lists – zip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A particularly useful function for lists is `zip`. It can be used to merge
    two given lists into a new list by pairing the elements of the original lists.
    The result is a list of tuples (refer section *Tuples* for more information):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This example also demonstrates what happens if the lists have different lengths.
    The length of the zipped list is the shorter of the two input lists. `zip` creates
    a special iterable object that can be turned into a list by applying the `list`
    function, as in the preceding example. Refer to section *Iterators* in [Chapter
    9](ch09.html "Chapter 9. Iterating"), *Iterating*, for more details on iterable
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: List comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A convenient way to build up lists is by using the list comprehension construct,
    possibly with a condition inside. The syntax of a list comprehension is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'or more generally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to have several `for` loops inside a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is of particular interest when dealing with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Set notation**'
  prefs: []
  type: TYPE_NORMAL
- en: List comprehension is closely related to the mathematical notation for sets.
    Compare:  ![List comprehension](img/set_notation.jpg)  and `L2 = [2*x for x in
    L]`.
  prefs: []
  type: TYPE_NORMAL
- en: One big difference though, is that lists are ordered while sets aren't (Refer,
    section *Sets* for more information).
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NumPy package offers arrays, which are container structures for manipulating
    vectors, matrices, or even higher order tensors in mathematics. In this section,
    we point out the similarities between arrays and lists. But arrays deserve a broader
    presentation, which will be given in [Chapter 4](ch04.html "Chapter 4. Linear
    Algebra – Arrays"), *Linear Algebra –  Arrays*, and [Chapter 5](ch05.html "Chapter 5. Advanced
    Array Concepts"), *Advanced Array Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are constructed from lists by the function `array` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an element of a vector, we need one index, while an element of a
    matrix is addressed by two indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, arrays are similar to lists, but be aware that they are different
    in a fundamental way, which can be explained by the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access to array data corresponds to that of lists, using square brackets and
    slices. They may also be used to alter the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The number of elements in a vector, or the number of rows of a matrix, is obtained
    by the function `len` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Arrays store only elements of the same numeric type (usually `float` or `complex`
    but also `int`). Refer to section *Array properties* in [Chapter 4](ch04.html
    "Chapter 4. Linear Algebra – Arrays"), *Liner Algebra – Arrays*, for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operations `+`, `*`, `/`, and `-` are all elementwise. The `dot` function
    and, in Python versions ≥ 3.5, the infix operator `@` are used for the scalar
    product and the corresponding matrix operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike lists, there is no `append` method for arrays. Nevertheless, there are
    special methods to construct arrays by stacking smaller size arrays (Refer to
    section *Stacking* in [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"),
    *Linear Algebra - Arrays*, for more information.). A related point is that arrays
    are not elastic as lists; one cannot use slices to change their length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector slices are views; that is, they may be used to modify the original array.
    Refer to section *Array views and copies* in [Chapter 5](ch05.html "Chapter 5. Advanced
    Array Concepts"), *Advanced Array Concepts*, for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tuple is an immutable list. Immutable means that it cannot be modified. A
    tuple is just a comma-separated sequence of objects (a list without brackets).
    To increase readability, one often encloses a tuple in a pair of parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The comma indicates that the object is a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples are useful when a group of values goes together; for example, they are
    used to return multiple values from functions (refer to section *Returns Values*
    in [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*. One may assign
    several variables at once by unpacking a list or tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The swapping trick**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use packing and unpacking to swap the contents of two variables: `a, b = b,
    a`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are nothing other than immutable lists with a notation without brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, lists may be used instead of tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The notation without parentheses is convenient but dangerous. You should use
    parentheses when you are not sure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists, tuples, and arrays are ordered sets of objects. The individual objects
    are inserted, accessed, and processed according to their place in the list. On
    the other hand, dictionaries are unordered sets of pairs. One accesses dictionary
    data by keys.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and altering dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For example, we may create a dictionary containing the data of a rigid body
    in mechanics, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A key/data pair is indicated by a colon, `:`. These pairs are comma separated
    and listed inside a pair of curly brackets, `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual elements are accessed by their keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'New objects are added to the dictionary by creating a new key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries are also used to provide parameters to a function (refer to section
    *Parameters and arguments* in [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*,
    for further information). Keys in a dictionary can be, among others, strings,
    functions, tuples with immutable elements, and classes. Keys cannot be lists or
    arrays. The command `dict`  generates a dictionary from a list with key/value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `zip` function may come in handy in this context (refer to section *Merging
    List*).
  prefs: []
  type: TYPE_NORMAL
- en: Looping over dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are mainly three ways to loop over dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'or equivalently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'By value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'By item, that is, key/value pairs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Please, refer to section *Shelves* in [Chapter 12](ch12.html "Chapter 12. Input
    and Output"), *Input and Output*, for a special dictionary object for file access.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sets are containers that share properties and operations with sets in mathematics.
    A mathematical set is a collection of distinct objects. Here are some mathematical
    set expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sets](img/set_operations.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And their Python counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Sets contain an element only once, corresponding to the aforementioned definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And a set is unordered; that is, the order of the elements in the set is not
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Sets in Python can contain all kinds of hashable objects, that is, numeric objects,
    strings, and Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are `union` and `intersection` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, sets can be compared using the methods `issubset` and `issuperset` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Empty set**'
  prefs: []
  type: TYPE_NORMAL
- en: An empty set is defined in Python by `empty_set=set([])` and not by `{}`, which
    would define an empty dictionary!
  prefs: []
  type: TYPE_NORMAL
- en: Container conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We summarize in the following *Table 3.2* the most important properties of the
    container types presented so far. Arrays will be treated in [Chapter 4](ch04.html
    "Chapter 4. Linear Algebra – Arrays"), *Linear Algebra – Arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Container conversions](img/Table-3.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 3.2 : Container Types'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous table, there is a difference in accessing container
    elements, and sets and dictionaries are not ordered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the different properties of the various container types, we frequently
    convert one type to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Container conversions](img/Table-3.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Type checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The direct way to see the type of a variable is to use the `type` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want to test for a variable to be of a certain type, you should
    use `isinstance` (instead of comparing the types with `type`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for using `isinstance` becomes apparent after having read [Chapter
    8](ch08.html "Chapter 8. Classes"), *Classes,* and in particular the concept of
    subclassing and inheritance in section *Subclassing and Inheritance* in [Chapter
    8](ch08.html "Chapter 8. Classes"), *Classes*. In short, often different types
    share some common properties with some basic type. The classical example is the
    type `bool`, which is derived by subclassing from the more general type `int`.
    In this situation, we see how the command `isinstance`  can be used in a more
    general way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in order to make sure that the variable `test` is as good as an integer
    (the particular type may be irrelevant), you should check that it is an instance
    of `integer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Type checking**'
  prefs: []
  type: TYPE_NORMAL
- en: Python is not a typed language. What that means is that objects are identified
    by what they can do rather than what they are. For instance, if you have a string
    manipulating function that acts on an object by using the `len` method, then your
    function will probably be useful for any objects implementing that method.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have come across different types: `float`, `int`, `bool`, `complex`,
    `list`, `tuple`, `module`, `function`, `str`, `dict`, and `array`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to work with container types, mainly lists. It
    is important to know how to fill these containers and how to access their content.
    We saw that there is access by position or by keyword.
  prefs: []
  type: TYPE_NORMAL
- en: We will meet the important concept of slicing again in the next chapter on arrays.
    These are containers specially designed for mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1 **→ Execute the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What is the content of `L3`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to predict the outcome of the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the following command do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Concatenate `L3` and `L4` to a new list `L5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ex. 2** → Use the `range` command and a list comprehension to generate a
    list with 100 equidistantly spaced values between 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3** → Assume that the following signal is stored in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the outcome of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Do this exercise by inspection only, that is, without using your Python Shell.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4** → Consider the Python statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: and assume that the variable `m` has been previously assigned an integer value.
    What is the value of `ans`? Answer this question without executing the statements
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5** → Consider the recursion formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/main_F.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with *n* = 0,..., 1000, *h*= 1/1000, and *a* = -0.5.
  prefs: []
  type: TYPE_NORMAL
- en: Create a list `u`. Store in its first three elements *e⁰*, *e^(ha)*, and *e^(2ha)*.
    These represent the starting values *u*[0], *u*[1], and *u*[2] in the given formula.
    Build up the complete list from the recursion formula.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct a second list, `td`, in which you store the values *nh*, with *n*
    = 0, ..., 1000\. Plot `td` versus `u` (refer section *Basic plotting* in [Chapter
    6](ch06.html "Chapter 6. Plotting"), *Plotting*, for more information). Make a
    second plot in which you plot the difference, that is, *|e^(at[n]) - u[n]|*, where
    *t[n]* represents the values inside the vector `td` . Set axis labels and a title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recursion is a multistep formula to solve the differential equation *u'
    = au* with the initial value *u(0) = u[0] = 1*. *u[n]* approximates *u(nh) = e^(anh)u*[0].
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 6** → Let *A* and *B* be sets. The set (A \ B) ∪ (B \ A) is called the
    symmetric difference of the two sets. Write a function that performs this operation.
    Compare your results to the result of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Ex. 7** → Verify in Python the statement that the empty set is a subset of
    any set.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 8** → Study other operations on sets. You find a complete list of those
    by using the command completion feature of `IPython`. In particular, study the `update`
    and `intersection_update` methods. What is the difference between `intersection`
    and `intersection_update`?'
  prefs: []
  type: TYPE_NORMAL
