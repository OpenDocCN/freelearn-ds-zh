<html><head></head><body>
		<div><h1 id="_idParaDest-82"><em class="italic"><a id="_idTextAnchor081"/>Chapter 4</em>: Starting at the Ground Level with Terra</h1>
			<p>After our brief exploration of the IBM Quantum Experience® composer, and installation of IBM's Qiskit®, we are now ready to start writing quantum programs with Qiskit®. We will let go of the user interface, expanding our quantum computing journey into Python – one of the world's most popular and widespread scientific programming languages.</p>
			<p>This chapter covers the basic requirements for building a quantum circuit with Qiskit®. We will walk through the making of a few minimalistic quantum programs that run on a local Qiskit Aer simulator and that display the results of the program in numeric as well as diagrammatic form. We will then take the leap and run the programs on actual IBM Quantum® hardware.</p>
			<p>The theme of this chapter is <em class="italic">quantum coin tossing</em>, based on the rudimentary quantum program that we built in IBM Quantum Experience®. These are arguably the simplest meaningful quantum programs that you can write, as they start you off with a few basic foundational quantum gates, but also demonstrate the difference between probabilistic quantum computing and deterministic classical computing.</p>
			<p>We will also expand on the minimal program by adding more gates, run the program many times to gather statistics about the outcomes, and more. The topics that we will be learning about in this chapter will be applied from the next chapter onwards.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Building a Qiskit® quantum program</li>
				<li>Quantum coin toss revisited</li>
				<li>Getting some statistics – tossing many coins in a row</li>
				<li>Implementing an upside-down coin toss</li>
				<li>Tossing two coins simultaneously</li>
				<li>Quantum-cheating in a coin toss? – Introducing the Bell state</li>
				<li>More ways to quantum-cheat – tweaking the odds</li>
				<li>Adding more coins – straight and cheating</li>
				<li>Tossing some real coins</li>
			</ul>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Technical requirements</h1>
			<p>The quantum programs that we discuss in this chapter can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter04">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter04</a>.</p>
			<p>You can run the recipes in this chapter in your local Qiskit® environment that you set up as part of <a href="B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Environment</em>, or you can run them in the notebook environment of the IBM Quantum Experience®.</p>
			<p>If you run them in your local environment, I'd recommend using the built-in Spyder iPython editor from your Anaconda installation. That is the editor used to build and run the samples in this book. </p>
			<p>In the code examples in this book, you will sometimes see the following line of code:</p>
			<pre>from IPython.core.display import display</pre>
			<p>Depending on your environment, iPython might not display graphical output directly in the output. If this is the case, you can use the <code>display()</code> method to force the output, like this:</p>
			<pre>display(qc.draw('mpl'))</pre>
			<p>This example prints the quantum circuit <code>qc</code> to the iPython console. </p>
			<p>Building a Qiskit® quantum program</p>
			<p>Generally speaking, there <a id="_idIndexMarker188"/>are just a few required building blocks to create a quantum program using Qiskit®. First, you have to set up the required infrastructure and create the quantum circuit (what we call the <strong class="bold">quantum score</strong> in IBM Quantum Experience®). Then, you have to configure a backend to run your quantum program on, and finally execute and retrieve the results of your calculations. </p>
			<p>The following <a id="_idIndexMarker189"/>section is a summary of the Python building blocks that are required to make up a quantum program.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Listing the required classes, modules, and functions</h2>
			<p>Qiskit® includes <a id="_idIndexMarker190"/>a large number of Python <a id="_idIndexMarker191"/>classes, but for our initial foray, we just need the<a id="_idIndexMarker192"/> basic ones. These are used to configure each of the components that follow:</p>
			<ul>
				<li><code>QuantumCircuit</code>: This is used to create the circuit—the program—that you will execute. You will add gates and other components to the circuit.</li>
				<li><code>QuantumRegister</code>: This represents the qubits that you can use to build your quantum program.  </li>
				<li><code>ClassicalRegister</code>: This represents the classical bits that are used to store the output of your quantum program.</li>
				<li><code>Aer</code>: This is the Qiskit® simulation layer, which we will discuss in greater detail in <a href="B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197"><em class="italic">Chapter 7</em></a>, <em class="italic">Simulating Quantum Computers with Aer</em>.</li>
				<li><code>IBMQ</code>: This module is required to execute your quantum programs on actual IBMQ hardware. It includes the tools you need to interact with IBMQ.</li>
				<li><code>execute</code>: This component lets you run your program by providing the circuit, a backend, and a number of shots.</li>
			</ul>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Working with quantum registers and classical registers</h2>
			<p>To be able<a id="_idIndexMarker193"/> to build your quantum program, you first need to decide how <a id="_idIndexMarker194"/>many qubits you want to work with, and how many classical bits you want to include to store your output. You can either set these up explicitly or use the <code>QuantumCircuit</code> class to automatically create the registers. </p>
			<p>The registers make up two sets of information-carrying bits of your quantum system:</p>
			<ul>
				<li>One set of quantum registers to hold your qubits</li>
				<li>One set of classical registers to hold your regular bits</li>
			</ul>
			<p>You will use measurement gates to read your qubits and then write the resulting classical bit to the classical registers.</p>
			<p>For most of the<a id="_idIndexMarker195"/> recipes in this book, the number of quantum and<a id="_idIndexMarker196"/> classical registers will be the same, but this is not required.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Understanding your quantum circuit</h2>
			<p>The quantum circuit<a id="_idIndexMarker197"/> instance that you create will hold the qubits and classical bits. You will manipulate each instance by adding gates.</p>
			<p>A quantum program can be assembled by combining more than one quantum circuit. You can, for example, create a circuit that holds the quantum gates and one circuit that holds the measurement gates. You can then add these circuits together to create a main quantum circuit that makes up your quantum program.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Selecting a backend to run on</h2>
			<p>To be able to <a id="_idIndexMarker198"/>execute your quantum program, you must define a backend. A backend can be a local simulator, an IBM Quantum® simulator in the cloud, or actual IBM Quantum® hardware accessed through the cloud.</p>
			<p>Initially, we will use the <code>qasm_simulator</code> backend that is included with Qiskit Aer, but we will also run our quantum programs on some of the freely available IBM Quantum® backends.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Running your circuit as a job</h2>
			<p>You run the quantum<a id="_idIndexMarker199"/> program as a job by providing the circuit, a backend, and a number of shots. If you run your quantum programs on IBM Quantum® hardware, you can also include a job monitor to keep track of your place in the queue.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Receiving the results of your job</h2>
			<p>When your job has <a id="_idIndexMarker200"/>run, the results are returned. In these initial recipes, where we use the <code>qasm_simulator</code> backend or the IBM Quantum® hardware, the returned results will be Python dictionaries. </p>
			<p>For a 1-qubit circuit, the result might look like this:</p>
			<pre>{'1': 1} </pre>
			<p>In this case, the returned result of one shot was a qubit in the state <img alt="" src="img/Formula_04_001.png"/> .</p>
			<p>The results could also look like this:</p>
			<pre>{'0': 495, '1': 505}</pre>
			<p>Here, the returned result was 1,000 shots, where 495 shots resulted in the qubit being <img alt="" src="img/Formula_04_002.png"/> , and 505 shots that resulted in <img alt="" src="img/Formula_04_001.png"/> .</p>
			<p>The returned results can be more complex. The following example is a possible result of a 3-qubit quantum program that was run 1,000 times:</p>
			<pre>{'100': 113, '111': 139, '001': 112, '101': 114, '010': 121, '011': 133, '000': 134, '110': 134}</pre>
			<p>Here, the result <img alt="" src="img/Formula_04_004.png"/> came up 113 times, <img alt="" src="img/Formula_04_005.png"/> came up 139 times, and so on.</p>
			<p>But, enough talk, let's write some quantum programs.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Quantum coin toss revisited</h1>
			<p>In this recipe, we<a id="_idIndexMarker201"/> will take a closer look at the very first quantum program we created in IBM Quantum Experience® – the <strong class="bold">quantum coin toss</strong>. Again, this is arguably the simplest quantum program that still provides real quantum computing value. It demonstrates the probabilistic nature of quantum computing. For a refresher, see <a href="B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a><em class="italic">, IBM Quantum Experience® – Quantum Drag and Drop</em>.</p>
			<p>In IBM Quantum Experience®, the coin toss program looked like this:</p>
			<div><div><img alt="Figure 4.1 – Simple coin toss circuit in the IBM Quantum Experience® composer&#13;&#10;" src="img/Figure_4.1_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Simple coin toss circuit in the IBM Quantum Experience® composer</p>
			<p>With the quantum coin toss, we will again use the <em class="italic">Hadamard gate</em> to create a quantum superposition, and a measurement gate to force the superposition to collapse into one of the two qubit states <img alt="" src="img/Formula_04_002.png"/> or <img alt="" src="img/Formula_04_001.png"/>, representing <em class="italic">heads</em> or <em class="italic">tails</em>. This time, however, we will create the circuit in Python with Qiskit®, which means that we need to also create the framework for the gates and measurement by defining and creating quantum circuits and classical circuits using Python commands.</p>
			<p>This is a quantum <a id="_idIndexMarker202"/>circuit that simulates the probabilistic nature of a single qubit in superposition. The 1-qubit circuit initializes the qubit in the ground state – <img alt="" src="img/Formula_04_002.png"/> – and then uses a Hadamard gate to put the qubit in superposition.</p>
			<p>During our calculations, the statevector of the qubit looks like this:</p>
			<div><div><img alt="Figure 4.2 – Formula for the statevector of the qubit" src="img/Figure_4.2_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Formula for the statevector of the qubit</p>
			<p>You can also write it in the vector form:</p>
			<div><div><img alt="Figure 4.3 – Statevector of the qubit in the vector form" src="img/Figure_4.3_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Statevector of the qubit in the vector form</p>
			<p>Another vector form is the Qiskit® statevector form that you will see in these examples:</p>
			<pre>[0.70710678+0.j 0.70710678+0.j]</pre>
			<p>Measuring the qubit causes it to collapse into one of the states <img alt="" src="img/Formula_04_002.png"/> or <img alt="" src="img/Formula_04_001.png"/> with a ~50% probability, that is, a coin toss. The result is displayed as a numeric readout, as a bar diagram, and as a Bloch sphere.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r1_coin_toss.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r1_coin_toss.py</a>.</p>
			<p>For a quick reminder of how to run the sample programs, see the <em class="italic">Downloading the code samples</em> recipe of <a href="B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Environment</em>.</p>
			<p>You are ready to <a id="_idIndexMarker203"/>write your first quantum program.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>How to do it...</h2>
			<p>The following steps will—to a large extent—be repeated throughout the book, based on the basic required classes and steps for basic Qiskit® management. So, expect the <em class="italic">How to do it…</em> section's bullets to be somewhat briefer going forward.</p>
			<p>There will, however, be differences depending on what program you are planning to run, and what Qiskit® components you will be using. Let's start the program now:</p>
			<ol>
				<li>Import the required Qiskit® classes.<p>First, we import the Python classes that are required to create registers and circuits, set a backend, and so on. Please refer to the <em class="italic">Listing the required Qiskit® classes, modules, and functions</em> section of the <em class="italic">Building a Qiskit® quantum program</em> recipe:</p><pre>from qiskit import QuantumRegister, ClassicalRegister
from qiskit import QuantumCircuit, Aer, execute
from qiskit.tools.visualization import plot_histogram
from IPython.core.display import display</pre><p>In addition, we also import the <code>display</code> method from <code>IPython.core.display</code>. This is used to correctly display the graphics output in our Anaconda Spyder IPython environment, and might not be required in your environment.</p></li>
				<li>Create the required registers and the quantum circuit. <p>We create two registers, one for the quantum bit and one for the classic bit. We also create a quantum circuit that is made up of the quantum register and the classic register. The quantum register is initialized in the ground state, <img alt="" src="img/Formula_04_002.png"/> , and the classical register is set to 0:</p><pre>q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)</pre></li>
				<li>Add gates to the quantum circuit. <p>For our quantum <a id="_idIndexMarker204"/>program to actually do something, we now add a Hadamard gate that will put the qubit in a superposition, and also a measurement gate that we will use to read the value of the quantum bit at the end of our program. The Hadamard gate is one of the foundational gates. We will look much more closely at that gate, and others, in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>:</p><pre>qc.h(q[0])
qc.measure(q, c)
display(qc.draw('mpl'))</pre><p>By visualizing the circuit with <code>qc.draw</code>(<code>'mpl'</code>), we see that just like in the IBM Quantum Experience® composer, we have a quantum circuit with 1 qubit and 1 classical bit, with a Hadamard gate on the qubit, and a measurement gate that will write the state of the qubit <code>q0_0</code> (<img alt="" src="img/Formula_04_002.png"/> or <img alt="" src="img/Formula_04_001.png"/> ) to the classical bit <code>c0_0</code> as a 0 or 1:</p><div><img alt="Figure 4.4 – A simple quantum coin toss circuit&#13;&#10;" src="img/Figure_4.4_B14436.jpg"/></div><p class="figure-caption">Figure 4.4 – A simple quantum coin toss circuit</p><p>In a strictly text-based Python environment, you can also print your circuit with the <code>print(qc)</code> command or use <code>qc.draw</code>(<code>'text'</code>), both of which produce ASCII text output:</p><div><img alt="Figure 4.5 – The circuit displayed as ASCII text" src="img/Figure_4.5_B14436.jpg"/></div><p class="figure-caption">Figure 4.5 – The circuit displayed as ASCII text</p></li>
				<li>Set the backend on which to run.<p>For this initial <a id="_idIndexMarker205"/>recipe, we will use the built-in <code>qasm_simulator</code> backend. We create a backend variable and call on the Aer component to get us the required backend information:</p><pre>backend = Aer.get_backend('qasm_simulator')</pre></li>
				<li>Run the job. <p>Create a quantum job for the circuit and the selected backend that runs just one shot to simulate a coin toss. We then run the job and display the returned result; either <img alt="" src="img/Formula_04_002.png"/> for heads or <img alt="" src="img/Formula_04_001.png"/> for tails. The results are returned as a Python dictionary:</p><pre>job = execute(qc, backend, shots=1)
result = job.result()
counts = result.get_counts(qc)</pre></li>
				<li>Print and visualize the results:<pre>print(counts)
display(plot_histogram(counts))</pre><p>First, we get a printout of the results:</p><pre>{'0': 1}</pre><p>Then, we get a printout<a id="_idIndexMarker206"/> of the result as a histogram:</p></li>
			</ol>
			<div><div><img alt="Figure 4.6 – The result of a single quantum &quot;coin toss&quot; as a histogram" src="img/Figure_4.6_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – The result of a single quantum "coin toss" as a histogram</p>
			<p>Success! Your very first quantum coin toss program returned a tails, or <img alt="" src="img/Formula_04_001.png"/> result.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>How it works...</h2>
			<p>We tossed a quantum coin that started out with <em class="italic">heads</em> up ( <img alt="" src="img/Formula_04_002.png"/> ), <em class="italic">spun</em> in quantum space as a superposition of <img alt="" src="img/Formula_04_002.png"/> and <img alt="" src="img/Formula_04_001.png"/>, and finally landed in a <em class="italic">tails</em> position when we measured it.</p>
			<p>So, what happened?</p>
			<p>Let's reiterate:</p>
			<ol>
				<li value="1">We created a qubit and initialized it in the ground state, <img alt="" src="img/Formula_04_002.png"/>.</li>
				<li>We then applied a Hadamard gate to the qubit, which moved the statevector from the pole to the equator of the Bloch sphere.<p>Mathematically, when you apply the Hadamard gate to your qubit, you run it through two <a id="_idIndexMarker207"/>rotations, first a <img alt="" src="img/Formula_04_021.png"/> rotation around the <em class="italic">y</em> axis, and then a <img alt="" src="img/Formula_04_022.png"/> rotation around the <em class="italic">x</em> axis. The qubit is now in a superposition of <img alt="" src="img/Formula_04_002.png"/> and <img alt="" src="img/Formula_04_001.png"/>, halfway between the poles.</p><p>For more detailed information about the Hadamard gate, see the <em class="italic">Creating superpositions with the H gate</em> recipe in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>.</p></li>
				<li>Finally, we measured the qubit. <p>By measuring, we destroyed the superposition, literally forcing nature to make up its mind, and the qubit will be either <img alt="" src="img/Formula_04_002.png"/> or <img alt="" src="img/Formula_04_001.png"/>.</p></li>
			</ol>
			<p>Now, go ahead and run your program a couple of times, noting if you get heads ( <img alt="" src="img/Formula_04_002.png"/> ) or tails ( <img alt="" src="img/Formula_04_001.png"/> ). If we have done this right, you should be simulating a coin toss pretty closely. </p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Getting some statistics – tossing many coins in a row</h1>
			<p>Alright, so far, we have<a id="_idIndexMarker208"/> done a single coin toss at a time, much like you would do in real life.</p>
			<p>But the power of quantum computing comes from running your quantum programs many times with the same initial conditions, letting the qubit superpositions play out their quantum mechanical advantages, and summarizing a large number of runs statistically.</p>
			<p>With this recipe, we will do 1,000 coin tosses in the blink of an eye and take a look at the results to see how good the coin is. Will this coin be a fair way to start, say, a game of baseball? Let's see how that works.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r2_coin_tosses.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r2_coin_tosses.py</a>.</p>
			<p>In this recipe, we will explore and expand on the <code>shots</code> job parameter. This parameter lets you control how many times you run the quantum job cycle – prepare, run, measure. So far, we have prepared our qubits in the <img alt="" src="img/Formula_04_002.png"/> state, set the backend to a simulator, and then run one shot, which represents one full cycle.</p>
			<p>In the IBM Quantum Experience® composer examples, we ran our scores 1,024 times, which is the default. We discovered that the output turned statistical. In this recipe, we will play with a different number of shots to see how the outcomes statistically change.</p>
			<p>Generally speaking, you want to increase the number of shots to improve statistical accuracy. </p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>How to do it...</h2>
			<p>Much like in the previous recipe, the following steps are all you need:</p>
			<p class="callout-heading">Code reuse</p>
			<p class="callout">And for the lazy coder, in this case, as you might have realized, the only real change to the circuit appears in <em class="italic">step 6</em>, where we set the number of shots. Feel free to reuse the previous recipe. </p>
			<ol>
				<li value="1">Import the required Qiskit® classes and methods:<pre>from qiskit import QuantumRegister, ClassicalRegister
from qiskit import QuantumCircuit, Aer, execute
from qiskit.tools.visualization import plot_histogram
from IPython.core.display import display</pre></li>
				<li>Create the required registers and the quantum circuit. Set up our quantum circuit with one qubit <a id="_idIndexMarker209"/>and one classical bit. Create the quantum circuit based on the registers:<pre>q = QuantumRegister(1)
c = ClassicalRegister(1)
qc = QuantumCircuit(q, c)</pre></li>
				<li>Add gates to the quantum circuit. Add the Hadamard and measurement gates:<pre>qc.h(q[0])
qc.measure(q, c)
display(qc.draw('mpl'))</pre><div><img alt="Figure 4.7 – The same simple quantum coin toss circuit&#13;&#10;" src="img/Figure_4.7_B14436.jpg"/></div><p class="figure-caption">Figure 4.7 – The same simple quantum coin toss circuit</p></li>
				<li>Set the backend to our local simulator to run:<pre>backend = Aer.get_backend('qasm_simulator')</pre></li>
				<li>Run the job.<p>Note that this time, we run it with <em class="italic">1,000 shots</em>. This means that we run our quantum circuit 1,000 times, collect the results, and provide the average output as our results:</p><pre>job = execute(qc, backend, shots=1000)
result = job.result()
counts = result.get_counts(qc)</pre></li>
				<li>Print and visualize the results:<pre>print(counts)
display(plot_histogram(counts))</pre><p>This time the output looks different:</p><pre>{'0': 480, '1': 520}</pre><p>And here is the<a id="_idIndexMarker210"/> output in the form of a histogram:</p></li>
			</ol>
			<div><div><img alt="Figure 4.8 – The result of 1,000 shots, a roughly even distribution of 0 and 1&#13;&#10;" src="img/Figure_4.8_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – The result of 1,000 shots, a roughly even distribution of 0 and 1</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>How it works...</h2>
			<p>This time we used the underlying Qiskit® analytics to store and process the result of each individual shot and return it as a concatenated Python dictionary. The end result is a statistical view of all the actual outcomes of your quantum program. For the coin toss, you would expect to get heads and tails with roughly equal probability if you run it enough times.</p>
			<p>Try adjusting the number of shots to 10,000 or 20,000, and see how your qubit behaves statistically.</p>
			<p>In a more complex quantum program, the result will usually indicate a preference for a specific outcome, a specific combination of qubit statistics where certain solutions are amplified and show up much more often than others. This is one of the key tricks with writing good quantum <a id="_idIndexMarker211"/>algorithms, understanding how to get the circuits to point to the correct answer.</p>
			<p>We will go into more detail on this later, starting with the<em class="italic"> Exploring quantum phase kickback </em>recipe in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>. </p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>There's more...</h2>
			<p>Generally speaking, you are<a id="_idIndexMarker212"/> usually interested in getting the statistical result of your quantum program. In this case, we are looking at the probabilistic nature of a quantum coin toss – a random number generator. But sometimes, it might be interesting to see exactly what transpired, shot by shot. </p>
			<p>You can achieve this by setting the <code>memory=True</code> parameter when you run your quantum program:</p>
			<pre>job = execute(circuit, backend, shots=10, memory=True)</pre>
			<p>This setting makes the quantum job save the individual results of each shot, and you can later retrieve these as a Python list by using the <code>result.get_memory()</code> command. For 10 shots on a 1-qubit circuit, the memory result might look like this:</p>
			<pre>['1', '1', '0', '0', '1', '1', '0', '1', '0', '0']</pre>
			<p>And for 10 shots on a 2-qubit circuit (which we will do in a later recipe), the memory result might look like this:</p>
			<pre>['10', '10', '10', '11', '11', '00', '10', '10', '01', '00']</pre>
			<p>You can then dig out any <a id="_idIndexMarker213"/>data you want from this list and process it further with other Python tools as needed.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Implementing an upside-down coin toss</h1>
			<p>In this recipe, we will<a id="_idIndexMarker214"/> tweak our very first quantum program a little bit but still keep it relatively simple. An actual coin can be tossed starting with either heads or tails facing upward. Let's do another quantum coin toss but with a different starting point, the coin facing tails up. In Dirac notation, we start with our qubit in <img alt="" src="img/Formula_04_001.png"/> instead of in <img alt="" src="img/Formula_04_002.png"/>.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r3_coin_toss_tails.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r3_coin_toss_tails.py</a>.</p>
			<p>Just like the previous recipe, this one is almost identical to the first coin toss recipe. Feel free to reuse what you have already created. The only real difference is that we add a new quantum gate, the <strong class="bold">X</strong> (or <strong class="bold">NOT</strong>) gate.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>How to do it...</h2>
			<p>The following steps are to a large extent identical to the steps from the <em class="italic">Quantum coin toss revisited</em> recipe. There are, however, differences depending on the program you are creating, and what Qiskit® components you are using. I will describe these in detail.</p>
			<p>Set up your code like the previous example and then add an X gate to flip the qubit:</p>
			<ol>
				<li value="1">Import the required Qiskit® classes and methods:<pre>from qiskit import QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram
from IPython.core.display import display</pre><p>Notice how we are not importing the <code>QuantumRegister</code> and <code>ClassicalRegister</code> methods here like we did before. In this recipe, we will take a look at a different way of creating your quantum circuit. </p></li>
				<li>Create the quantum circuit with 1 qubit and 1 classical bit:<pre>qc = QuantumCircuit(1, 1)</pre><p>Here, we are implicitly letting the <code>QuantumCircuit</code> method create the quantum and classical registers in the background; we do not have to explicitly create them. We will refer to these registers by numbers and lists going forward.</p></li>
				<li>Add the Hadamard gate, the X gate, and the measurement gates to the circuit:<pre>qc.x(0)
qc.h(0)
qc.measure(0, 0)</pre><p>So, here is the first<a id="_idIndexMarker215"/> example of using just numbers to refer to the qubits. We add the X gate to the first qubit, here referred to as 0 as Python starts numbering at 0, not 1:</p><div><img alt="Figure 4.9 – The upside-down quantum coin toss circuit&#13;&#10;" src="img/Figure_4.9_B14436.jpg"/></div><p class="figure-caption">Figure 4.9 – The upside-down quantum coin toss circuit</p></li>
				<li>Set the backend to our local simulator:<pre>backend = Aer.get_backend('qasm_simulator')</pre></li>
				<li>To run the job, this time, we go back to 1 shot to do just a single coin toss:<pre>counts = execute(qc, backend, shots=1).result().    get_counts(qc)</pre><p>Notice here how we have streamlined the code a bit and put all the execution in one row as we are only interested in the final counts.</p></li>
				<li>Visualize the results:<pre>display(plot_histogram(counts))</pre><p>The output looks like the following:</p></li>
			</ol>
			<div><div><img alt="Figure 4.11 – Setting your qubit to  by using the initialize method" src="img/Figure_4.10_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – The results of a single upside-down quantum coin toss</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>How it works...</h2>
			<p>We are introducing a <a id="_idIndexMarker216"/>new gate in this recipe, the Pauli-X gate. The X gate works just like a NOT gate in classical computing – it flips the value of a qubit.</p>
			<p>If the qubit is <img alt="" src="img/Formula_04_002.png"/>, then it is flipped to <img alt="" src="img/Formula_04_001.png"/>, and if it is in <img alt="" src="img/Formula_04_001.png"/>, then it is flipped to <img alt="" src="img/Formula_04_002.png"/>.</p>
			<p>For simple situations like this, it is intuitively easy to understand exactly what the result will be, but for more complex qubit configurations, where the Bloch vector points at an arbitrary point on the Bloch sphere, it gets a little trickier. Essentially what happens is that the qubit is rotated around the <em class="italic">x</em> axis through an angle of <img alt="" src="img/Formula_04_036.png"/> radians.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>There's more...</h2>
			<p>The X gate is handy for this, but there is another way to set your coin toss tails up. You can use the Qiskit Aer <code>initialize</code> method to set the initial state of a qubit to <img alt="" src="img/Formula_04_001.png"/> before running your circuit.</p>
			<p>The following is <a id="_idIndexMarker217"/>an example of how to do just that:</p>
			<ol>
				<li value="1">Create a Python vector that corresponds to an excited <img alt="" src="img/Formula_04_001.png"/> state and initialize the quantum circuit:<pre>initial_vector = [0.+0.j, 1.+0.j]qc.initialize(initial_vector, 0)</pre></li>
				<li>Find the following code in your circuit, and replace it with the preceding initialize code snippet:<pre>qc.x(0)</pre></li>
				<li>Now run the program as normal. The results should be similar, but your circuit printout will look like this:</li>
			</ol>
			<div><div><img alt="Figure 4.11 – Setting your qubit to  by using the initialize method&#13;&#10;" src="img/Figure_4.11_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Setting your qubit to <img alt="" src="img/Formula_04_039.png"/> by using the initialize method</p>
			<p>This way, you can initialize any number of qubits to any state you choose. The initialization vector needs to fulfill two main criteria:</p>
			<ol>
				<li value="1">It must include an entry for each of the 2n possible states. In the preceding example, with 1 qubit, all we needed was a vector with length 2. For 2 qubits, the vector must have length 4, and so on.</li>
				<li>The sum of the squares of the absolute value of the vector components must be equal to 1. Here's the initial vector from the preceding example that initialized the qubit to <img alt="" src="img/Formula_04_001.png"/>:<pre>initial_vector = [0.+0.j, 1.+0.j]</pre><p>This translates into the following:</p></li>
			</ol>
			<div><div><img alt="Figure 4.12 – Initial vector" src="img/Figure_4.12_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Initial vector</p>
			<p>This, in turn, gives <a id="_idIndexMarker218"/>the sum of probabilities:</p>
			<div><div><img alt="Figure 4.13 – Sum of probabilities&#13;&#10;" src="img/Figure_4.13_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – Sum of probabilities</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Tossing two coins simultaneously</h1>
			<p>So far, we have only <a id="_idIndexMarker219"/>played with one coin at a time, but there is nothing stopping us from adding more coins. In this recipe, we will add a coin to the simulation, and toss two coins simultaneously. We will do this by adding a second qubit, expanding the number of qubits – two of everything.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r4_two_coin_toss.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r4_two_coin_toss.py</a>.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>How to do it...</h2>
			<p>Set up your code like the previous example, but with a 2-qubit quantum circuit:</p>
			<ol>
				<li value="1">Import the classes and methods that we need:<pre>from qiskit import QuantumCircuit, Aer, execute
from qiskit.tools.visualization import plot_histogram
from IPython.core.display import display</pre></li>
				<li>Set up our quantum circuit with two qubits and two classical bits:<pre>qc = QuantumCircuit(2, 2)</pre></li>
				<li>Add the Hadamard gates and the measurement gates to the circuit:<pre>qc.h([0,1])
qc.measure([0,1],[0,1])
display(qc.draw('mpl'))</pre><p>Note how we are<a id="_idIndexMarker220"/> now using lists to reference multiple qubits and multiple bits. For example, we apply the Hadamard gate to qubits 0 and 1 by using [0,1] as input:</p><div><img alt="Figure 4.14 – A 2-qubit quantum coin toss circuit " src="img/Figure_4.14_B14436.jpg"/></div><p class="figure-caption">Figure 4.14 – A 2-qubit quantum coin toss circuit </p></li>
				<li> Set the backend to our local simulator:<pre>backend = Aer.get_backend('qasm_simulator')</pre></li>
				<li>Run the job with one shot:<pre>counts = execute(qc, backend, shots=1).result().    get_counts(qc)</pre><p>Again, we are using streamlined code as we are only interested in the counts here.</p></li>
				<li>Visualize the results:<pre>display(plot_histogram(counts))</pre><p>The histogram looks like this:</p></li>
			</ol>
			<div><div><img alt="Figure 4.15 – The  result of a double quantum coin toss&#13;&#10;" src="img/Figure_4.15_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – The <img alt="" src="img/Formula_04_041.png"/> result of a double quantum coin toss</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>How it works...</h2>
			<p>You set the number of <a id="_idIndexMarker221"/>qubits when you create the quantum circuit.</p>
			<p>When you ran the program, both qubits were supplied with Hadamard gates, creating two parallel qubits both in superposition. </p>
			<p>In Qiskit®, qubit numbering starts with 0 for the first qubit and then counts upward. A 3-qubit circuit will contain the following qubits, referred to as the first, second, and third qubits:</p>
			<ul>
				<li>If you are using <code>QuantumRegister</code> notation, like in the <em class="italic">Quantum coin toss revisited</em> recipe: <code>q[0]</code>, <code>q[1]</code>, and <code>q[2]</code></li>
				<li>If you are using the list notation: <code>[0,1,2]</code></li>
			</ul>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>There's more...</h2>
			<p>Do a little experimentation here by adding more qubits to your circuit. You will realize that you can use this simple method to create random numbers of any kind. The output will be a binary number of the same length as the number of qubits in your circuit.</p>
			<p>For example, creating a circuit with 20 qubits and running it with one shot might result in the following output:</p>
			<pre>{'00101011101110011011': 1}</pre>
			<p>This translates into the following decimal number: </p>
			<pre>179099</pre>
			<p>So, you can use quantum <a id="_idIndexMarker222"/>programs to create any type of random number. For example, you can also use this setup to create dice of different sizes following the 2n rule for a number of possible states (where n is the number of qubits). So, the calculation goes like this:</p>
			<ul>
				<li>One qubit = two possible states = coin</li>
				<li>Two qubits = four possible states = four-sided dice</li>
				<li>Three qubits = eight possible states = eight-sided dice</li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Quantum-cheating in a coin toss? Introducing the Bell state</h1>
			<p>So, now you have<a id="_idIndexMarker223"/> the ability to toss <a id="_idIndexMarker224"/>one or more quantum coins and get a probabilistic outcome. That is all well and good, and we could picture ourselves doing some gambling with this new tool of ours, betting money against the outcome of a coin toss. But with a 50/50 outcome, the possibility of earning any real money is limited, unless, of course, we tweak the odds (that is, we cheat).</p>
			<p>So how do you cheat in coin tossing? Well, knowing the outcome beforehand would be a clever way. And it turns <a id="_idIndexMarker225"/>out this is possible using a quantum phenomenon called <strong class="bold">entanglement</strong>. </p>
			<p>By entangling two qubits, we connect them in a way so that they can no longer be described separately. In the most basic sense, if you have two entangled qubits and measure one of them as <img alt="" src="img/Formula_04_002.png"/>, the result of measuring the other one will be <img alt="" src="img/Formula_04_002.png"/> as.</p>
			<p>So, how do we use this to cheat in coin tossing? Well, we create two qubits, entangle them, and then we separate them (turns out this is the tricky part to do physically, but we will ignore that for now). You bring one qubit into the gambling den, and your friend keeps the other qubit outside the room.</p>
			<p>When it is time to do a coin toss, you run your quantum circuit, entangle the qubits, and then your friend measures the qubit that they keep outside the room. They then sneakily, through some means (such as Bluetooth earphones, semaphoring, or telepathy), tell you what their measurement <a id="_idIndexMarker226"/>was, <img alt="" src="img/Formula_04_002.png"/> or <img alt="" src="img/Formula_04_001.png"/>. You will then instantly know what your qubit is, before you <a id="_idIndexMarker227"/>measure it, and can bet money on that outcome. After measuring, you will find that you were indeed right, and cash in your winnings.</p>
			<p>So, how is this done quantum <a id="_idIndexMarker228"/>programmatically? We will introduce a new gate, <strong class="bold">controlled-NOT</strong> (<strong class="bold">CX</strong>).</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r5_two_coin_toss_bell.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r5_two_coin_toss_bell.py</a>.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>How to do it...</h2>
			<p>Set up your code like the previous example, with 2 qubits and classical bits:</p>
			<ol>
				<li value="1">Import the classes and methods that we need:<pre>from qiskit import QuantumCircuit, Aer, execute
from qiskit.tools.visualization import plot_histogram
from IPython.core.display import display</pre></li>
				<li>Set up our quantum circuit with two qubits and two classical bits:<pre>qc = QuantumCircuit(2, 2)</pre></li>
				<li>Add the Hadamard gate, a controlled NOT gate, and the measurement gates to the circuit.<p>For each circuit manipulation we do, such as adding a gate, we need to indicate which qubit to perform the<a id="_idIndexMarker229"/> manipulation on. For example, to add a Hadamard gate on the first<a id="_idIndexMarker230"/> qubit, you would use the code <code>qc.h(0)</code>:</p><pre>qc.h(0)
qc.cx(0,1)
qc.measure([0,1],[0,1])
display(qc.draw('mpl'))</pre><p>The preceding code gives the following output:</p><div><img alt="Figure 4.16 – 2-qubit quantum circuit with a controlled-NOT gate to entangle the qubits" src="img/Figure_4.16_B14436.jpg"/></div><p class="figure-caption">Figure 4.16 – 2-qubit quantum circuit with a controlled-NOT gate to entangle the qubits</p></li>
				<li>Set the backend to our local simulator:<pre>backend = Aer.get_backend('qasm_simulator')</pre></li>
				<li>Run the job with one shot:<pre>counts = execute(qc, backend, shots=1).result().    get_counts(qc)</pre></li>
				<li>Visualize the results:<pre>display(plot_histogram(counts))</pre><p>The output for the histogram looks like this:</p><div><img alt="Figure 4.17 – The result of a 2-qubit entangled coin toss" src="img/Figure_4.17_B14436.jpg"/></div><p class="figure-caption">Figure 4.17 – The result of a 2-qubit entangled coin toss</p></li>
				<li>Run the circuit a couple of times and you will realize that the only result on this double <a id="_idIndexMarker231"/>quantum <a id="_idIndexMarker232"/>coin toss is <img alt="" src="img/Formula_04_046.png"/> or <img alt="" src="img/Formula_04_047.png"/>. Now run the circuit again, but with 1,000 shots, and get the results:<pre>counts = execute(qc, backend, shots=1000).result().get_counts(qc)</pre><p>You will see the following histogram as a result of your code:</p></li>
			</ol>
			<div><div><img alt="Figure 4.18 – Result of 1,000 shots. Only  and  appear!&#13;&#10;" src="img/Figure_4.18_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18 – Result of 1,000 shots. Only <img alt="" src="img/Formula_04_048.png"/> and <img alt="" src="img/Formula_04_049.png"/> appear!</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>How it works...</h2>
			<p>Let's start with the new gate, CX. This gate takes as input the quantum state of the first qubit (as indicated by the dot on the first qubit score) and then executes a NOT gate (x) on the second qubit if the quantum state is <img alt="" src="img/Formula_04_007.png"/>. If the quantum state is <img alt="" src="img/Formula_04_002.png"/>, it does nothing to the second qubit.</p>
			<p>So here's a really exciting part of this story. At a point where we expect the <code>cx</code> gate to act, we do not know the state of the first qubit yet. The Hadamard gate has put it in a nice superposition, hovering exactly between <img alt="" src="img/Formula_04_002.png"/> and <img alt="" src="img/Formula_04_001.png"/>. Not until we measure the first qubit will we know what state the qubit is in. Not even nature will know the state because the qubit isn't in a specific state; it is in a superposition of two states. </p>
			<p>So how would the CX gate know that it needed to flip the second qubit from <img alt="" src="img/Formula_04_002.png"/> to <img alt="" src="img/Formula_04_001.png"/> when we run the program? Well, that is the fascinating part of quantum computing, <em class="italic">it </em><em class="italic">didn't</em>. Only when we<a id="_idIndexMarker233"/> measure the first qubit will the gate execution take place, and the<a id="_idIndexMarker234"/> entangled the second qubit will have flipped, or not. Einstein called this very real example of quantum mechanics <em class="italic">Spooky action at a distance</em> and wanted nothing to do with it.</p>
			<p>So, the end result when running our little recipe is to get one of the two possible outcomes for these two qubits, <img alt="" src="img/Formula_04_054.png"/> or  <img alt="" src="img/Formula_04_055.png"/> with roughly equal probability. If the first qubit reads <img alt="" src="img/Formula_04_002.png"/>, then so will the second qubit, giving you the <img alt="" src="img/Formula_04_057.png"/> result. The same is true for the opposite reading of <img alt="" src="img/Formula_04_001.png"/>; both qubits will read the same, giving us <img alt="" src="img/Formula_04_059.png"/>. Once you have read 1 qubit, you immediately know what the second will be. This is how cheating is done in quantum coin tossing!</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>There's more...</h2>
			<p>But the Bell state is not locked into just the two results <img alt="" src="img/Formula_04_060.png"/> and <img alt="" src="img/Formula_04_061.png"/>. By using other gates, you can set this entanglement up to be <img alt="" src="img/Formula_04_062.png"/> and <img alt="" src="img/Formula_04_063.png"/> as well:</p>
			<pre>{'10': 542, '01': 458}</pre>
			<p>Which gate would you use, on which qubit would it act, and where in your circuit would you add it? In this case, you might want to start the qubits in different states to see what happens. Take a look at the <em class="italic">Implementing an upside-down coin toss</em> recipe for inspiration.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>See also</h2>
			<p>The results we got when running this Bell-state circuit on <code>qasm_simulator</code> (which simulates a perfect<a id="_idIndexMarker235"/> universal fault-tolerant quantum computer) gave us clear-cut results where both qubits were the same when measured all the time.</p>
			<p>In the real world, where the existing physical quantum computers are still quite far from universal fault-tolerant quantum computers, the result will be somewhat different. For a quick look, see the <em class="italic">Tossing some real coins</em> recipe.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>More ways to quantum-cheat – tweaking the odds</h1>
			<p>In the previous recipe, we <a id="_idIndexMarker236"/>used a quantum phenomenon called <a id="_idIndexMarker237"/>entanglement to cheat with our coin tossing. Admittedly, this might be complicated to set up, and people do tend to get suspicious of coin tossers with an earpiece who are obviously listening for information before catching and revealing the coin (measuring the qubit).</p>
			<p>But there are more ways to skin a cat. Remember our discussion of qubits and quantum gates. By manipulating the qubit using gates, we could adjust the state of the qubit before we measure it. The closer the vector is to either <img alt="" src="img/Formula_04_002.png"/> or <img alt="" src="img/Formula_04_001.png"/>, the higher the probability of that specific outcome when you measure.</p>
			<p>In this recipe, we will use a rotation gate, the <strong class="bold">Ry</strong> gate, to increase the probability of getting a tails outcome when we toss our coin.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r6_coin_toss_rot.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r6_coin_toss_rot.py</a>.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>How to do it...</h2>
			<p>Set up your code like the previous example and then add a <strong class="bold">Ry</strong> gate to rotate the qubit:</p>
			<ol>
				<li value="1">Import the classes and methods that we need:<pre>from qiskit import QuantumCircuit, Aer, execute
from qiskit.tools.visualization import plot_histogram
from IPython.core.display import display
from math import pi</pre></li>
				<li>Set up our quantum circuit with one qubit and one classical bit and create the quantum circuit based on the registers:<pre>qc = QuantumCircuit(1, 1)</pre></li>
				<li>Add the Hadamard gate, the Ry gate, and the measurement gates to the circuit:<pre>qc.h(0)
qc.ry(pi/8,0)
qc.measure(0, 0)
display(qc.draw('mpl'))</pre><p>The preceding<a id="_idIndexMarker238"/> code should result in the following <a id="_idIndexMarker239"/>output:</p><div><img alt="Figure 4.19 – Our cheating coin toss circuit with a Ry gate&#13;&#10;" src="img/Figure_4.19_B14436.jpg"/></div><p class="figure-caption">Figure 4.19 – Our cheating coin toss circuit with a Ry gate</p></li>
				<li>Set the backend to our local simulator:<pre>backend = Aer.get_backend('qasm_simulator')</pre></li>
				<li>Run the job with a thousand shots:<pre>counts = execute(qc, backend, shots=1000).result().    get_counts(qc)</pre></li>
				<li>Visualize the results:<pre>display(plot_histogram(counts))</pre><p>The histogram for the preceding code looks like the following:</p></li>
			</ol>
			<div><div><img alt="Figure 4.20 – A slightly skewed outcome for our cheating coin toss circuit&#13;&#10;" src="img/Figure_4.20_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.20 – A slightly skewed outcome for our cheating coin toss circuit</p>
			<p>Alright, so the odds now seem to be much in your favor for tossing a <img alt="" src="img/Formula_04_001.png"/> – almost 2 to 1.</p>
			<p>How it works...</p>
			<p>So, what is going on here? By adding the Ry gate, we managed to tweak the odds mightily in our favor. Let's take a closer look at what that gate does.</p>
			<p>Let's take a look at <a id="_idIndexMarker240"/>the Bloch vectors for the three different<a id="_idIndexMarker241"/> states that we are discussing here. In the sample code, there is this suspicious function that we have not touched upon yet. We will see more of it in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>. By calling the <code>get_psi()</code> function and using the quantum circuit that you are building, you can see the behavior of the qubit at each stage of building the circuit. The function uses another simulator, <code>statevector_simulator</code>, that calculates the behavior of the qubit at a given location in your circuit, and then we use the <code>plot_bloch_multivector()</code> method to display it as a Bloch sphere:</p>
			<pre># Function that returns the statevector (Psi) for the circuit
def get_psi(circuit):
    show_bloch=False
    if show_bloch:
        from qiskit.visualization import plot_bloch_multivector
        backend = Aer.get_backend('statevector_simulator') 
        result = execute(circuit, backend).result()
        psi = result.get_statevector(circuit)
        print(title)
        display(qc.draw('mpl'))
        display(plot_bloch_multivector(psi))  </pre>
			<p>When we call this function<a id="_idIndexMarker242"/> with a quantum circuit as an input, it <a id="_idIndexMarker243"/>will return the qubit statevector (psi or <img alt="" src="img/Formula_04_067.png"/> ) at the end of the circuit. If more than one qubit is included in the circuit, the function will include the complete statevector for all of them. </p>
			<p>To run the circuit with the <code>get_psi()</code> function enabled, change the <code>show_bloch</code> variable from <code>False</code> to <code>True</code>, and run your circuit again. The output should now look something like the following:</p>
			<ol>
				<li value="1">First, we show the qubit in the ground state:<div><img alt="Figure 4.21 – In the initial ground state, the quantum vector is pointing straight &#13;&#10;up to  as we expect&#13;&#10;" src="img/Figure_4.21_B14436.jpg"/></div><p class="figure-caption">Figure 4.21 – In the initial ground state, the quantum vector is pointing straight up to <img alt="" src="img/Formula_04_068.png"/> as we expect</p></li>
				<li>Then, we show the <a id="_idIndexMarker244"/>qubit after the Hadamard gate, now <a id="_idIndexMarker245"/>in a superposition of <img alt="" src="img/Formula_04_002.png"/> and <img alt="" src="img/Formula_04_001.png"/>:<div><img alt="Figure 4.22 – After applying the Hadamard gate, the vector is now pointing along the x axis to the Bloch sphere equator" src="img/Figure_4.22_B14436.jpg"/></div><p class="figure-caption">Figure 4.22 – After applying the Hadamard gate, the vector is now pointing along the x axis to the Bloch sphere equator</p></li>
				<li>We have seen this <a id="_idIndexMarker246"/>before. If we were to <a id="_idIndexMarker247"/>measure it now, we would get <img alt="" src="img/Formula_04_002.png"/> and <img alt="" src="img/Formula_04_001.png"/>  with roughly 50% probability:<div><img alt="Figure 4.23 – Finally, after applying the Ry gate, the vector is now pointing below &#13;&#10;the Bloch sphere equator" src="img/Figure_4.23_B14436.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 4.23 – Finally, after applying the Ry gate, the vector is now pointing below the Bloch sphere equator</p>
			<p>Now, we apply the Ry <a id="_idIndexMarker248"/>gate, rotating the vector <img alt="" src="img/Formula_04_073.png"/> radians (0.3927 in<a id="_idIndexMarker249"/> our preceding circuit diagram) around the <em class="italic">y</em> axis toward <img alt="" src="img/Formula_04_001.png"/>.</p>
			<p>So, what happens here is that we have modified the angle <img alt="" src="img/Formula_04_075.png"/> by using the Ry gate. </p>
			<p>Remember the formula from <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>?</p>
			<div><div><img alt="" src="img/Formula_04_076.jpg"/>
				</div>
			</div>
			<p>After applying the Hadamard gate, the angles were <img alt="" src="img/Formula_04_077.png"/> and <img alt="" src="img/Formula_04_078.png"/> (we haven't rotated around the <em class="italic">y</em> axis yet).</p>
			<p>The probability of measuring <img alt="" src="img/Formula_04_001.png"/> was then:</p>
			<div><div><img alt="" src="img/Formula_04_080.jpg"/>
				</div>
			</div>
			<p>Now, if we change <img alt="" src="img/Formula_04_081.png"/> to <img alt="" src="img/Formula_04_082.png"/> by adding <img alt="" src="img/Formula_04_073.png"/> , we get this:</p>
			<div><div><img alt="" src="img/Formula_04_084.jpg"/>
				</div>
			</div>
			<p>This corresponds very <a id="_idIndexMarker250"/>well with what we measured and shows <a id="_idIndexMarker251"/>us that we have indeed tweaked the probability of our quantum coin to land tails up.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>There's more...</h2>
			<p>There are three basic rotational gates—Rx, Ry, and Rz—that you can use to easily point the vector at any point on the Bloch sphere. These are described in more detail in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>.</p>
			<h4>Try your hand at these variations</h4>
			<p>Have a go at <a id="_idIndexMarker252"/>creating a couple of quantum circuits using these:</p>
			<ol>
				<li value="1">Create a 1-qubit superposition without using the Hadamard gate.</li>
				<li>Measure the circuit to make sure that the result is the same as with a Hadamard gate.</li>
				<li>Create a 1-qubit superposition using the Hadamard gate, then use an R-gate to point the vector along the <em class="italic">y</em> axis. <p>Which gate would that be, and what is the input? Can you get the same result by skipping the Hadamard gate and using only an R gate? Which one? Now, measure and see if that makes any difference to the expected outcome for a circuit in superposition.</p></li>
				<li>Look at the formula for calculating the probability of measuring <img alt="" src="img/Formula_04_001.png"/> and see if you can use the Ry gate to set up a circuit that gives <img alt="" src="img/Formula_04_001.png"/> as an outcome: <p>99% of the time</p><p>66% of the time</p><p>33% of the time </p></li>
			</ol>
			<p>Congratulations! Not only <a id="_idIndexMarker253"/>can you now cheat in quantum coin tossing, but you can also calculate your odds.</p>
			<h4>More on the get_psi() function</h4>
			<p>We started out with <a id="_idIndexMarker254"/>this very small, 1-qubit quantum circuit as an example of how to use our home-made <code>get_psi()</code> function to step your way through your circuit to understand how your qubits behave at each stage. Remember that even though people sometimes talk about qubits being 0 and 1 at the same time, what they really are referring to is the superposition math we have looked at. The important thing is that during our calculations, we place our qubits in very well-known states by manipulating their statevectors. </p>
			<p>For small circuits, it is fairly easy to envision what is going on at each step, but for larger circuits, you quickly run out of brainpower to mentally visualize how the little qubits behave.</p>
			<p>You can use the <code>get_psi()</code> function and the statevector simulator for just this. Call it from any point in your circuit design to see what your qubits are up to. If your quantum programs do not behave the way you expect, use the statevector simulator and Bloch sphere visualization to troubleshoot.</p>
			<p>As we move along <a id="_idIndexMarker255"/>through the book, we will tweak and modify the <code>get_psi()</code> function to suit our needs, and use it to display additional details about our circuits.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Adding more coins – straight and cheating</h1>
			<p>Up until now, our <a id="_idIndexMarker256"/>recipes have been mainly of the 1- or 2-qubit sort. With our simulator, there is nothing stopping us from adding more qubits to our circuits at will, with the caveat that each additional qubit will require more and more processing power from the system on which your simulator runs. For example, the IBM Quantum Experience® <code>qasm_simulator</code> runs on an IBM POWER9™ server and maxes out at around 32 qubits.</p>
			<p>In this recipe, we will create two 3-qubit quantum programs, one multi-coin toss, and one new entangled<a id="_idIndexMarker257"/> state called <strong class="bold">GHZ</strong> (for <strong class="bold">Greenberger–Horne–Zeilinger</strong> state). </p>
			<p>Instead of doing this by creating two separate files, we will take a look at a new command, <code>reset()</code>. As the name implies, using the <code>reset()</code> command with a qubit sets it back to its original state of <img alt="" src="img/Formula_04_002.png"/>, ready to start a new quantum computing round. In this example, we use <code>reset()</code> to run two quantum programs in a row, writing to two sets of three classical registers, measuring twice per run. </p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r7_three_coin_toss_ghz.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r7_three_coin_toss_ghz.py</a>.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>How to do it...</h2>
			<p>Set up your code like the previous examples, but with three qubits and classical bits:</p>
			<ol>
				<li value="1">Import the classes and methods that we need:<pre>from qiskit import QuantumCircuit, Aer, execute
from qiskit.tools.visualization import plot_histogram
from IPython.core.display import display</pre></li>
				<li>Set up our quantum circuit with three qubits and six classical bits:<pre>qc = QuantumCircuit(3, 6)</pre></li>
				<li>Add the Hadamard gates and the measurement gates to the circuit:<pre>qc.h([0,1,2])
qc.measure([0,1,2],[0,1,2])
display(qc.draw('mpl'))</pre><p>The output <a id="_idIndexMarker258"/>for the preceding code looks like this:</p><div><img alt="Figure 4.24 – A 3-qubit in superposition circuit, measuring to classical bits 0, 1, and 2 &#13;&#10;" src="img/Figure_4.24_B14436.jpg"/></div><p class="figure-caption">Figure 4.24 – A 3-qubit in superposition circuit, measuring to classical bits 0, 1, and 2 </p></li>
				<li>Set the backend to our local simulator:<pre>backend = Aer.get_backend('qasm_simulator')</pre></li>
				<li>Run the job with a thousand shots:<pre>counts = execute(qc, backend, shots=1000).result().    get_counts(qc)</pre></li>
				<li>Visualize the results:<pre>display(plot_histogram(counts))</pre><p>The histogram for the preceding code looks like the following:</p><div><img alt="Figure 4.25 – Three qubits in superposition give random results&#13;&#10;" src="img/Figure_4.25_B14436.jpg"/></div><p class="figure-caption">Figure 4.25 – Three qubits in superposition give random results</p><p>Notice here that we only see measurement results for the three first classical bits (0, 1, and 2). The three last classical bits are all 0. </p></li>
				<li>Now modify the<a id="_idIndexMarker259"/> circuit by resetting the qubits, adding a Hadamard gate to qubit 0, then adding two CX (Controlled NOT) gates, one from qubit 0 to qubit 1, and one from qubit 0 to qubit 2.<p>We will use a new circuit command to reset the qubits of our circuit back to <img alt="" src="img/Formula_04_002.png"/> and start over using <code>reset()</code>:</p><pre>qc.barrier([0,1,2])
qc.reset([0,1,2])
qc.h(0)
qc.cx(0,1)
qc.cx(0,2)
qc.measure([0,1,2],[3,4,5])
display(qc.draw('mpl'))</pre><p>Remember that when you modify just one qubit, you must specify which qubit to modify, like this <code>qc.h</code>(<code>0</code>), to add a Hadamard gate to the first qubit:</p><div><img alt="Figure 4.26 – Resetting the qubits of a quantum circuit back to   and starting over, writing to classical bits 3, 4, and 5 for the final measurement&#13;&#10;&#13;&#10;" src="img/Figure_4.26_B14436.jpg"/></div><p class="figure-caption">Figure 4.26 – Resetting the qubits of a quantum circuit back to  <img alt="" src="img/Formula_04_002.png"/> and starting over, writing to classical bits 3, 4, and 5 for the final measurement</p></li>
				<li>Run the job with 1,000 shots:<pre>counts = execute(qc, backend, shots=1000).result().    get_counts(qc)</pre></li>
				<li>Display the results:<pre>display(plot_histogram(counts))</pre><p>The histogram<a id="_idIndexMarker260"/> presentation for the previous code looks like the following:</p></li>
			</ol>
			<div><div><img alt="Figure 4.27 – The combined results of three coin toss qubits and of three entangled qubits, the GHZ state, in the first three and second three classical bits, respectively&#13;&#10;" src="img/Figure_4.27_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.27 – The combined results of three coin toss qubits and of three entangled qubits, the GHZ state, in the first three and second three classical bits, respectively</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>How it works...</h2>
			<p>There is nothing inherently new to the two circuits that we created, just more qubits, and two rounds of measurements. In the first one, we added all gates in parallel, and in the second one, we diligently specified which ones to add where. The end result was two 3-qubit circuits, one that represented even more coins tossed, and one that expanded on the Bell state we explored earlier. </p>
			<p>That last one is interesting as it shows entanglement between several qubits; none of the qubits can now be treated separately. And this type of entanglement is key to more advanced quantum algorithms where a large number of qubits are set up, which are put in superposition and then entangled. They are finally acted on by other gates to produce specific outcomes.</p>
			<p>Finally, we tested a <a id="_idIndexMarker261"/>new way of writing the outcomes to classical bits. We wrote the coin toss results to the first three classical bits and the GHZ state results to the three last ones.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>There's more...</h2>
			<p>Do a little experimentation to see how you can build larger circuits with more qubits, and how to add gates:</p>
			<ol>
				<li value="1">Create a 5-qubit circuit, with Hadamard gates on all, but measurement gates on the first, third, and fifth qubits only. How many classical registers do you really need? </li>
				<li>Create a 5-qubit circuit where you entangle the first, second, fourth, and fifth qubits with the third qubit. On which qubit do you need to add the Hadamard gate?</li>
				<li>The GHZ circuit we built as a part of this recipe gives the entangled results <img alt="" src="img/Formula_04_089.png"/>and <img alt="" src="img/Formula_04_090.png"/> only. Build a circuit that gives you the result <img alt="" src="img/Formula_04_091.png"/> or <img alt="" src="img/Formula_04_092.png"/> instead. What gate other than H and CX do you use, and where do you put it, or them?<p class="callout-heading">Tip</p><p class="callout">It might be easier to understand the workings of these circuits if you use one set of measurement commands only, and don't use the <code>reset()</code> command. </p></li>
			</ol>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Tossing some real coins</h1>
			<p>So, what do you say? Are <a id="_idIndexMarker262"/>you done simulating quantum coin tosses now, and want to do the real thing, running your Qiskit® quantum program on an actual IBM quantum computer? Let's finally get some use out of that IBM Quantum Experience® API key that you created.</p>
			<p>In this recipe, you will run the cheating coin toss or Bell state on an actual IBM Quantum® machine by using Qiskit®. We know what the expected result is on a perfectly simulated quantum computer and will now take a look at what the results of a real so-called NISQ machine look like.</p>
			<p>Finally, we will be getting some use out of that API key, introducing the IBMQ components, how to find the backends, how to select the best backend, and how to run the circuit against that backend.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r8_coin_toss_IBMQ.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r8_coin_toss_IBMQ.py</a>.</p>
			<p>To be able to run your quantum program on real IBM hardware, you need to use the API key that you are assigned with in your IBM Quantum Experience® account. If you are running Qiskit® from the IBM Quantum Experience® notebook environment, then your API key is already available to you and no further action is needed.</p>
			<p>If, however, you are running Qiskit® on your own local machine, you must store the API key locally. You might have already carried out these required steps as part of the <em class="italic">Installing your API key and accessing your provider</em> recipe in <a href="B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Environment</em>. If not, go ahead and complete the task now. We'll wait for you here.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>How to do it</h2>
			<p>Set up your code as in the previous examples, with two qubits and classical bits:</p>
			<ol>
				<li value="1">Import the classes and methods that we need:<pre>from qiskit import QuantumCircuit, execute
from qiskit import IBMQ
from qiskit.tools.monitor import job_monitor
from IPython.core.display import display</pre></li>
				<li>Retrieve the stored API key:<pre>IBMQ.load_account()
provider = IBMQ.get_provider()</pre></li>
				<li>Set up our quantum circuit with two qubits and two classical bits:<pre>qc = QuantumCircuit(2, 2)</pre></li>
				<li>Add the Hadamard <a id="_idIndexMarker263"/>gate and the CX gate to prepare for a Bell state:<pre>qc.h(0)
qc.cx(0,1)
qc.measure([0,1],[0,1])
display(qc.draw('mpl'))</pre><p>The preceding code shows the following circuit:</p><div><img alt="Figure 4.28 – 2-qubit Bell-state circuit&#13;&#10;" src="img/Figure_4.28_B14436.jpg"/></div><p class="figure-caption">Figure 4.28 – 2-qubit Bell-state circuit</p></li>
				<li> Set the backend to the least busy IBM Quantum® machine available:<pre>from qiskit.providers.ibmq import least_busy
backend = least_busy(provider.backends(n_qubits=5,    operational=True, simulator=False))
print(backend.name())
ibmq_essex</pre><p>We will revisit this way of picking an IBM Quantum® computer backend to run your circuit on in the <em class="italic">Finding the least busy backend</em> recipe of <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum Hardware® with Qiskit® Tools</em>. For now, just use the code as is.</p></li>
				<li>Run the job with 1,000 shots. Wait for the job to complete:<pre>job = execute(qc, backend, shots=1000)
job_monitor(job)
Job Status: job has successfully run</pre></li>
				<li>Get the<a id="_idIndexMarker264"/> results:<pre>result = job.result()
counts = result.get_counts(qc)
from qiskit.tools.visualization import plot_histogram
display(plot_histogram(counts))</pre><p>The histogram presentation for the preceding code looks like the following:</p></li>
			</ol>
			<div><div><img alt="Figure 4.29 – The result of running the Bell-state circuit on an actual IBM Quantum® backend&#13;&#10;" src="img/Figure_4.29_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.29 – The result of running the Bell-state circuit on an actual IBM Quantum® backend</p>
			<p>Hold your horses! We were expecting results for only <img alt="" src="img/Formula_04_093.png"/> and for <img alt="" src="img/Formula_04_094.png"/> ... What is going on here?</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>How it works...</h2>
			<p>Wow, look at those noisy qubits!</p>
			<p>What you are seeing in the noisy results of your program is just that – noise. Even though the IBM Quantum® computers are running at temperatures colder than outer space (15 millikelvin), they still suffer from random noise both when executing gates on the qubits and when measuring them. </p>
			<p>The local <code>qasm_simulator</code> that we have run our quantum programs on up until this point behaves like <a id="_idIndexMarker265"/>a perfect <strong class="bold">universal quantum computer</strong>. The real hardware, on the other hand, is what is called a <strong class="bold">Noisy Intermediate-Scale Quantum (NISQ)</strong> computer, which behaves less<a id="_idIndexMarker266"/> than<a id="_idIndexMarker267"/> perfectly.</p>
			<p>We will explore the existing IBM Quantum® backends in more detail in <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit® Tools</em>.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>There's more...</h2>
			<p>When running your job on an actual IBM Quantum® machine, things will generally differ from the controlled experience you had with your local simulator.</p>
			<h3>Get in line</h3>
			<p>As soon as you start running one or two quantum programs on the IBM Quantum® machines, you will most likely realize that you are not the only one. As it happens, there are a limited number of quantum computers available to the general public to use for free. As of this writing, a steadily growing number of physical backends and one simulator can be used. Use the <code>provider.backends()</code> command to list the ones that are currently available:</p>
			<pre>from qiskit import IBMQ
IBMQ.load_account()
provider = IBMQ.get_provider()
provider.backends()</pre>
			<p>The preceding code might give a result similar to the following:</p>
			<pre>[&lt;IBMQSimulator('ibmq_qasm_simulator') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,
 &lt;IBMQBackend('ibmqx2') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,
 &lt;IBMQBackend('ibmq_16_melbourne') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,
 &lt;IBMQBackend('ibmq_vigo') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,
 &lt;IBMQBackend('ibmq_ourense') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,
 &lt;IBMQBackend('ibmq_london') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,
 &lt;IBMQBackend('ibmq_burlington') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,
 &lt;IBMQBackend('ibmq_essex') from IBMQ(hub='ibm-q', group='open', project='main')&gt;,
 &lt;IBMQBackend('ibmq_armonk') from IBMQ(hub='ibm-q', group='open', project='main')&gt;]</pre>
			<p>Remember that you are in a timeshare here, with everyone else simultaneously running on the same machine as you. In the next chapter, we will take a closer look at these machines and explore how to figure out which one is best to use at any given moment.</p>
			<h3>Hardware details in the results</h3>
			<p>After your job is complete and you have looked at the results, you can take a quick peek at the complete returned results as well by using the <code>job.result()</code> command. It will look something like this:</p>
			<pre>namespace(backend_name='ibmq_burlington',
          backend_version='1.1.4',
          qobj_id='630c02ca-7d06-4430-91e8-8ef08b9f5a63',
          job_id='5f15dec89def8b001b437dfe',
          success=True,
          results=[namespace(shots=1000,
                        success=True,
                        data=namespace(counts=namespace(                                                       0x0=471,
                                                     0x1=529)),
                        meas_level=2,
                        header=namespace(memory_slots=2,
                                         qreg_sizes=[['q', 5]],
                                         qubit_labels=[['q',0],
                                                       ['q',1],
                                                       ['q',2],
                                                       ['q',3],
                                                      ['q',4]],
                                         name='circuit58',
                                         n_qubits=5,
                                         creg_sizes=[['c', 2]],
                                         clbit_labels=[['c',0],
                                                     ['c',1]]),
                        memory=False)],
          status='Successful completion',
          header=namespace(backend_version='1.1.4',
                        backend_name='ibmq_burlington'),
          date=datetime.datetime(2020, 7, 20, 18, 13, 44, tzinfo=datetime.timezone.utc),
          time_taken=7.400392055511475,
          execution_id='bc4d19d0-cab4-11ea-b9ba-ac1f6b46a78e')</pre>
			<p>In this result set, you can see information about the quantum computer backend that was used, the results of the run, as well as the status and date and time for the run.</p>
			<h3>What if the wait turns out to be long?</h3>
			<p>Sometimes there is just a really long queue ahead of you, and you have to wait your turn. In a sense, the IBM Quantum® machines work as a time-share setup from the early days of computing; only one program can run at the same time.</p>
			<p>But no need to despair. Your job has been submitted, and you can take a step back and let the machines do their work, picking up the thread when it suits you.</p>
			<p>This works the same as in the IBM Quantum Experience® Circuit Composer. Once submitted, your job will wait its turn, and then show up on the results page when returned. To do the same with your local Qiskit®, you first need your job ID.</p>
			<p>You can use the job ID to get your most recent job, or even retrieve earlier jobs that you have executed. The job ID is unique for each executed job. </p>
			<p>Use the <code>job.job_id()</code> command to get the job ID:</p>
			<pre>job.job_id()
Out[]: '5f15dec89def9b001b437dfe'</pre>
			<p>Now that you have a job ID, you can get back the <code>job</code> object by using the <code>retrieve_job()</code> command:</p>
			<pre>get_result=backend.retrieve_job(&lt;jobid&gt;)</pre>
			<p>And now you can get the job results just like you are used to, from the <code>job</code> object, for example:</p>
			<pre>counts = get_result.result().get_counts()
print(counts)</pre>
			<p>The preceding code might give the following output:</p>
			<pre>Out[]: {'11': 339, '10': 174, '00': 339, '01': 172}</pre>
			<p>You can also use the job ID to find the status of your job, and to see where in the queue it currently is:</p>
			<pre>print(backend.retrieve_job(&lt;jobid&gt;).status())</pre>
			<p>Here's an example:</p>
			<pre>Out[]: JobStatus.QUEUED
Out[]: JobStatus.RUNNING
Out[]: JobStatus.DONE</pre>
			<p>There are more features built in with the jobs that you can pull back from IBM Quantum Experience®. For a closer look at the backends and what you can learn about them, continue with <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit® Tools</em>.</p>
		</div>
	</body></html>