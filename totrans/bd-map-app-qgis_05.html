<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Using QGIS in an External Application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Using QGIS in an External Application</h1></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 1. Getting Started with QGIS" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with QGIS</em></span>, we looked briefly at a standalone Python program built using PyQt and the PyQGIS library. In this chapter, we will use the same technique to build a complete turnkey mapping application using PyQGIS. Along the way, we will:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Design and build a simple but complete standalone mapping application</li><li class="listitem">Learn how to use a wrapper script to handle the platform-specific dependencies before our Python program is run</li><li class="listitem">Define our application's user interface in a separate Python module so that we keep our UI separate from the application's business logic</li><li class="listitem">Dynamically show and hide map layers based on the user's preference</li><li class="listitem">Learn how to use a rule-based renderer to selectively display features based on the map's current zoom level</li><li class="listitem">See how data-defined properties can be used to calculate the font size to use for a label based on the feature's attributes</li><li class="listitem">Implement Google Maps style panning and zooming</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Using QGIS in an External Application">
<div class="book" title="Introducing Lex"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec27" class="calibre1"/>Introducing Lex</h1></div></div></div><p class="calibre8">Our mapping <a id="id305" class="calibre1"/>application will display a world map, allowing the user to zoom and pan, and display various landmarks on the map. If the user clicks on a landmark, information about that landmark will be displayed.</p><p class="calibre8">We'll call our application <span class="strong"><strong class="calibre9">Lex</strong></span>, which is short for <span class="strong"><strong class="calibre9">L</strong></span>andmark <span class="strong"><strong class="calibre9">ex</strong></span>plorer. Lex will make use of two freely available geospatial datasets: a high-resolution shaded-relief basemap, and a comprehensive database of place names, which we will use as the list of landmarks to display:</p><div class="mediaobject"><img src="../images/00047.jpeg" alt="Introducing Lex" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We will build our Lex application using PyQt, and make use of the PyQGIS libraries built into QGIS to do most of the hard work.</p><p class="calibre8">Our requirements <a id="id306" class="calibre1"/>for the Lex application are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It must run as a turnkey application. Double-clicking on the launcher script must start the PyQt program, load all the data, and present a complete working application to the user.</li><li class="listitem">The user interface must be as professional as possible, with keyboard shortcuts and good-looking toolbar icons.</li><li class="listitem">When the user clicks on a landmark, the name and jurisdiction, time zone, and latitude/longitude for that landmark should be displayed.</li><li class="listitem">The look and feel should be as similar as possible to Google Maps.<div class="note" title="Note"><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre8">This last requirement is an important point, as the zooming and panning tools built into QGIS are more complicated than what we would like to have in a turnkey mapping application. Most users are already familiar with the behavior of Google Maps, and we want to mimic this behavior rather than using the default panning and zooming tools supplied by QGIS.</p></div></li></ul></div><p class="calibre8">Without further delay, let's start building our application. Our first step will be to download the <a id="id307" class="calibre1"/>geospatial data the application will be based on.</p></div></div>
<div class="book" title="Getting the data"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec28" class="calibre1"/>Getting the data</h1></div></div></div><p class="calibre8">Lex will make <a id="id308" class="calibre1"/>use of two map layers: a <span class="strong"><strong class="calibre9">basemap layer</strong></span> that displays a shaded-relief raster image, and a <span class="strong"><strong class="calibre9">landmark layer</strong></span> that shows the individual landmarks based on a <a id="id309" class="calibre1"/>set of place names. Both of these datasets can be <a id="id310" class="calibre1"/>downloaded from the Natural Earth Data website. Visit <a class="calibre1" href="http://www.naturalearthdata.com">http://www.naturalearthdata.com</a> and click on the <span class="strong"><strong class="calibre9">Get the Data</strong></span> link to jump <a id="id311" class="calibre1"/>to the <a id="id312" class="calibre1"/>
<span class="strong"><strong class="calibre9">Downloads</strong></span> page.</p><p class="calibre8">The basemap data can <a id="id313" class="calibre1"/>be found by clicking on the <span class="strong"><strong class="calibre9">Raster</strong></span> link. We'll want the highest-resolution data available, so use the link in the <span class="strong"><strong class="calibre9">Large scale data, 1:10m</strong></span> section.</p><p class="calibre8">While you could use any of these datasets as a basemap, we will download the <span class="strong"><strong class="calibre9">Natural Earth I with Shaded Relief, Water, and Drainages</strong></span> dataset. Make sure you download the high-resolution version of this dataset so that the raster image will still look good when the user has zoomed in.</p><p class="calibre8">For the landmarks, we'll be using the "populated places" dataset. Go back to the main downloads page and click on the <span class="strong"><strong class="calibre9">Cultural</strong></span> link in the <span class="strong"><strong class="calibre9">Large scale data, 1:10m</strong></span> section. Scroll down to the <span class="strong"><strong class="calibre9">Populated Places</strong></span> section and click on the <span class="strong"><strong class="calibre9">Download Populated Places</strong></span> link.</p><p class="calibre8">Once you have finished downloading, you should have two ZIP archives on your computer:</p><p class="calibre8">
<code class="email">NE1_HR_LC_SR_W_DR.zip</code>
</p><p class="calibre8">
<code class="email">ne_10m_populated_places.zip</code>
</p><p class="calibre8">Create a folder named <code class="email">data</code>, decompress the preceding two ZIP archives, and place the resulting directories into your <code class="email">data</code> folder.</p></div>
<div class="book" title="Designing the application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec29" class="calibre1"/>Designing the application</h1></div></div></div><p class="calibre8">We now <a id="id314" class="calibre1"/>have a list of requirements for our mapping application, together with the geospatial data we want to display. Before we start coding, however, it's a good idea to step back and think about our application's user interface.</p><p class="calibre8">Our application will have one main window, which we will call <span class="strong"><strong class="calibre9">Landmark Explorer</strong></span>. To make it easy to use, we'll display a map canvas along with a simple toolbar. Our basic window layout will look like the following:</p><div class="mediaobject"><img src="../images/00048.jpeg" alt="Designing the application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Along with the <a id="id315" class="calibre1"/>main window, our Lex application will have a menu bar with the following menus:</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="Designing the application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The toolbar will make it easy for new users to work with Lex by pointing and clicking on the toolbar icons, while experienced users can make use of the extensive keyboard shortcuts to access the program's features.</p><p class="calibre8">With this design in mind, let's start coding.</p></div>
<div class="book" title="Creating the application's framework"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec30" class="calibre1"/>Creating the application's framework</h1></div></div></div><p class="calibre8">Start by <a id="id316" class="calibre1"/>creating a folder to hold your application's source code, and move the data folder you created earlier into it. Next, we want to create the basic framework for our application using the techniques we learned in <a class="calibre1" title="Chapter 1. Getting Started with QGIS" href="part0014_split_000.html#page">Chapter 1</a>, <span class="strong"><em class="calibre10">Getting Started with QGIS</em></span>. Create a module named <code class="email">lex.py</code>, and enter the following into this file:</p><div class="informalexample"><pre class="programlisting">import os, os.path, sys

from qgis.core import *
from qgis.gui import *
from PyQt4.QtGui import *
from PyQt4.QtCore import *

class MapExplorer(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)
        self.setWindowTitle("Landmark Explorer")
        self.resize(800, 400)

def main():
    QgsApplication.setPrefixPath(os.environ['QGIS_PREFIX'], True)
    QgsApplication.initQgis()

    app = QApplication(sys.argv)

    window = MapExplorer()
    window.show()
    window.raise_()

    app.exec_()
    app.deleteLater()
    QgsApplication.exitQgis()

if __name__ == "__main__":
    main()</pre></div><p class="calibre8">We're simply importing the various libraries we'll need and setting up an external PyQGIS application using the techniques we learned earlier. We then create and display a blank window so that the application will do something when it starts up.</p><p class="calibre8">Since we want the Lex application to work on any operating system, we're not going to hard-wire the path to QGIS into our source code. Instead, we'll write a <span class="strong"><strong class="calibre9">wrapper script</strong></span> that sets up the required environment variables before launching our Python program. As these wrapper scripts are operating-system dependent, you will need to create an appropriate wrapper script for your operating system.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre8">Notice that we use <code class="email">os.environ['QGIS_PREFIX']</code> in our <code class="email">lex.py</code> module to avoid hard-wiring the path to the QGIS application into our source code. Our wrapper script will take care of setting this environment variable before the application is run.</p></div><p class="calibre8">If you are using a <a id="id317" class="calibre1"/>computer with Microsoft Windows, your wrapper script will look something like the following:</p><div class="informalexample"><pre class="programlisting">SET OSGEO4W_ROOT=C:\OSGeo4W
SET QGIS_PREFIX=%OSGEO4W_ROOT%\apps\qgis
SET PATH=%QGIS_PREFIX%\bin;%OSGWO4W_ROOT\bin;%PATH%
SET PYTHONPATH=%QGIS_PREFIX%\python;%OSEO4W_ROOT%\apps\Python27;%PYTHONPATH%
SET PYTHONHOME=%OSGEO4W_ROOT%\apps\Python27
python lex.py</pre></div><p class="calibre8">Name this script something sensible, for example, <code class="email">run.bat</code>, and put it in the same directory as your <code class="email">lex.py</code> module.</p><p class="calibre8">If you are using a computer that runs Linux, your wrapper script will be named something like <code class="email">run.sh</code>, and will look like the following:</p><div class="informalexample"><pre class="programlisting">export PYTHONPATH="/path/to/qgis/build/output/python/"
export LD_LIBRARY_PATH="/path/to/qgis/build/output/lib/"
export QGIS_PREFIX="/path/to/qgis/build/output/"
python lex.py</pre></div><p class="calibre8">You will need to modify the paths to refer to the directory where QGIS has been installed.</p><p class="calibre8">For those running Mac OS X, your wrapper script will also be called <code class="email">run.sh</code>, and will contain the following:</p><div class="informalexample"><pre class="programlisting">export PYTHONPATH="$PYTHONPATH:/Applications/QGIS.app/Contents/Resources/python"
export DYLD_FRAMEWORK_PATH="/Applications/QGIS.app/Contents/Frameworks"
export QGIS_PREFIX="/Applications/QGIS.app/Contents/Resources"
python lex.py</pre></div><p class="calibre8">Notice that for Mac OS X and Linux, we have to set the framework or library paths. This allows the PyQGIS Python wrappers to find the underlying C++ shared libraries that they are based on.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre8">If you are running under Linux or Mac OS X, you'll also have to make your wrapper script executable. To do this, type <code class="email">chmod +x run.sh</code> into the bash shell or terminal window.</p></div><p class="calibre8">Once you have created your shell script, try running it. If all goes well, your PyQt application should <a id="id318" class="calibre1"/>start up and display a blank window, like the following:</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Creating the application's framework" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If it doesn't work, you will need to check your wrapper script and/or your <code class="email">lex.py</code> module. You might need to modify the directory paths to match your QGIS and Python installations.</p></div>
<div class="book" title="Adding the user interface"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec31" class="calibre1"/>Adding the user interface</h1></div></div></div><p class="calibre8">Now that <a id="id319" class="calibre1"/>our program is running, we can start implementing the user interface (UI). A typical PyQt application will make use of Qt Designer to store the application's UI in a template file, which is then compiled into a Python module for use within your application.</p><p class="calibre8">As it would take many pages to describe how to use Qt Designer to lay out our window with its toolbar and menus, we're going to cheat and create our user interface directly within Python. At the same time, however, we'll create our UI module as if it was created using Qt Designer; this keeps our application's UI separate, and also shows how our application would work if we were to use Qt Designer to design our user interface.</p><p class="calibre8">Create a new <a id="id320" class="calibre1"/>module called <code class="email">ui_explorerWindow.py</code>, and type the following code into this module:</p><div class="informalexample"><pre class="programlisting">from PyQt4 import QtGui, QtCore

import resources

class Ui_ExplorerWindow(object):
    def setupUi(self, window):
        window.setWindowTitle("Landmark Explorer")

        self.centralWidget = QtGui.QWidget(window)
        self.centralWidget.setMinimumSize(800, 400)
        window.setCentralWidget(self.centralWidget)

        self.menubar = window.menuBar()
        self.fileMenu = self.menubar.addMenu("File")
        self.viewMenu = self.menubar.addMenu("View")
        self.modeMenu = self.menubar.addMenu("Mode")

        self.toolBar = QtGui.QToolBar(window)
        window.addToolBar(QtCore.Qt.TopToolBarArea, self.toolBar)

        self.actionQuit = QtGui.QAction("Quit", window)
        self.actionQuit.setShortcut(QtGui.QKeySequence.Quit)

        self.actionShowBasemapLayer = QtGui.QAction("Basemap", window)
        self.actionShowBasemapLayer.setShortcut("Ctrl+B")
        self.actionShowBasemapLayer.setCheckable(True)

        self.actionShowLandmarkLayer = QtGui.QAction("Landmarks", window)
        self.actionShowLandmarkLayer.setShortcut("Ctrl+L")
        self.actionShowLandmarkLayer.setCheckable(True)

        icon = QtGui.QIcon(":/icons/mActionZoomIn.png")
        self.actionZoomIn = QtGui.QAction(icon, "Zoom In", window)
        self.actionZoomIn.setShortcut(QtGui.QKeySequence.ZoomIn)

        icon = QtGui.QIcon(":/icons/mActionZoomOut.png")
        self.actionZoomOut = QtGui.QAction(icon, "Zoom Out", window)
        self.actionZoomOut.setShortcut(QtGui.QKeySequence.ZoomOut)

        icon = QtGui.QIcon(":/icons/mActionPan.png")
        self.actionPan = QtGui.QAction(icon, "Pan", window)
        self.actionPan.setShortcut("Ctrl+1")
        self.actionPan.setCheckable(True)

        icon = QtGui.QIcon(":/icons/mActionExplore.png")
        self.actionExplore = QtGui.QAction(icon, "Explore", window)
        self.actionExplore.setShortcut("Ctrl+2")
        self.actionExplore.setCheckable(True)

        self.fileMenu.addAction(self.actionQuit)

        self.viewMenu.addAction(self.actionShowBasemapLayer)
        self.viewMenu.addAction(self.actionShowLandmarkLayer)
        self.viewMenu.addSeparator()
        self.viewMenu.addAction(self.actionZoomIn)
        self.viewMenu.addAction(self.actionZoomOut)

        self.modeMenu.addAction(self.actionPan)
        self.modeMenu.addAction(self.actionExplore)

        self.toolBar.addAction(self.actionZoomIn)
        self.toolBar.addAction(self.actionZoomOut)
        self.toolBar.addAction(self.actionPan)
        self.toolBar.addAction(self.actionExplore)

        window.resize(window.sizeHint())</pre></div><p class="calibre8">This module implements our Lex application's user interface, defining a <code class="email">QtAction</code> object for each toolbar and <a id="id321" class="calibre1"/>menu item, creating a widget to hold our map canvas, and laying everything out within a <code class="email">QtMainWindow</code> object. The structure of this module is identical to the way Qt Designer and the <code class="email">pyuic4</code> command-line tool make a user interface template available to Python code.</p><p class="calibre8">Notice that the <code class="email">Ui_ExplorerWindow</code> class makes use of several toolbar icons. We will need to create these icon images and define them in a resource description file, in the same way we created a <code class="email">resources.py</code> module in the previous chapter.</p><p class="calibre8">We are going to need the following icon images:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">mActionZoomIn.png</code></li><li class="listitem"><code class="email">mActionZoomOut.png</code></li><li class="listitem"><code class="email">mActionPan.png</code></li><li class="listitem"><code class="email">mActionExplore.png</code></li></ul></div><p class="calibre8">If you want, you can download these image files in SVG format from the QGIS source code repository (<a class="calibre1" href="https://github.com/qgis/QGIS/tree/master/images/themes/default">https://github.com/qgis/QGIS/tree/master/images/themes/default</a>), though you will need to convert them from <code class="email">.svg</code> to <code class="email">.png</code> in order to avoid issues with image file formats. If you don't want to convert the icons yourself, the images are available as part of the source code available with this book. Once you are done, place these four files in the main directory of your Lex application.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip17" class="calibre1"/>Tip</h3><p class="calibre8">Note that the <code class="email">mActionExplore.png</code> icon file is a converted copy of the <code class="email">mActionIdentify.svg</code> image in the source code repository. We renamed the image file to match the name of the tool in our Lex application.</p></div><p class="calibre8">Next, we need to <a id="id322" class="calibre1"/>create our <code class="email">resources.qrc</code> file so that PyQt can use these images. Create this file and enter the following into it:</p><div class="informalexample"><pre class="programlisting">&lt;RCC&gt;
    &lt;qresource prefix="/icons"&gt;
        &lt;file&gt;mActionZoomIn.png&lt;/file&gt;
        &lt;file&gt;mActionZoomOut.png&lt;/file&gt;
        &lt;file&gt;mActionPan.png&lt;/file&gt;
        &lt;file&gt;mActionExplore.png&lt;/file&gt;
    &lt;/qresource&gt;
&lt;/RCC&gt;</pre></div><p class="calibre8">You will need to compile this file using <code class="email">pyrcc4</code>. This will give you the <code class="email">resources.py</code> module required by your user interface.</p><p class="calibre8">Now that we've defined our user interface, let's modify the <code class="email">lex.py</code> module to use it. Add the following <code class="email">import</code> statements to the top of your module:</p><div class="informalexample"><pre class="programlisting">from ui_explorerWindow import Ui_ExplorerWindow
import resources</pre></div><p class="calibre8">Next, we want to replace our dummy implementation of the <code class="email">MapExplorer</code> window with one that uses our new UI. This is what the <code class="email">MapExplorer</code> class definition should look like:</p><div class="informalexample"><pre class="programlisting">class MapExplorer(QMainWindow, Ui_ExplorerWindow):
    def __init__(self):
        QMainWindow.__init__(self)

        self.setupUi(self)</pre></div><p class="calibre8">If all goes well, our <a id="id323" class="calibre1"/>application should now run with a complete user interface—a toolbar, menus, and room for our map canvas:</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="Adding the user interface" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Of course, our user interface doesn't do anything yet, but our Lex application is starting to look like a real program. Now, let's implement the behavior behind our UI.</p></div>
<div class="book" title="Connecting the actions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec32" class="calibre1"/>Connecting the actions</h1></div></div></div><p class="calibre8">You might have <a id="id324" class="calibre1"/>noticed that none of the menu commands and toolbar icons do anything yet—even the <span class="strong"><strong class="calibre9">Quit</strong></span> command doesn't work. Before our actions do anything, we have to connect them to the appropriate method. To do this, add the following to your <code class="email">MapExplorer.__init__()</code> method, immediately after the call to <code class="email">setupUi()</code>:</p><div class="informalexample"><pre class="programlisting">        self.connect(self.actionQuit,
                     SIGNAL("triggered()"), qApp.quit)
        self.connect(self.actionShowBasemapLayer,
                     SIGNAL("triggered()"), self.showBasemapLayer)
        self.connect(self.actionShowLandmarkLayer,
                     SIGNAL("triggered()"),
                     self.showLandmarkLayer)
        self.connect(self.actionZoomIn,
                     SIGNAL("triggered()"), self.zoomIn)
        self.connect(self.actionZoomOut,
                     SIGNAL("triggered()"), self.zoomOut)
        self.connect(self.actionPan,
                     SIGNAL("triggered()"), self.setPanMode)
        self.connect(self.actionExplore,
                     SIGNAL("triggered()"), self.setExploreMode)</pre></div><p class="calibre8">We're connecting our <span class="strong"><strong class="calibre9">Quit</strong></span> action to the <code class="email">qApp.quit()</code> method. For the other actions, we'll be calling methods within our <code class="email">MapExplorer</code> class itself. Let's define some placeholders for these methods:</p><div class="informalexample"><pre class="programlisting">    def showBasemapLayer(self):
        pass

    def showLandmarkLayer(self):
        pass

    def zoomIn(self):
        pass

    def zoomOut(self):
        pass

    def setPanMode(self):
        pass

    def setExploreMode(self):
        pass</pre></div><p class="calibre8">We'll implement these <a id="id325" class="calibre1"/>methods later on, once we have the map canvas up and running.</p></div>
<div class="book" title="Creating the map canvas"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec33" class="calibre1"/>Creating the map canvas</h1></div></div></div><p class="calibre8">Our <code class="email">Ui_ExplorerWindow</code> class defines an instance variable named <code class="email">centralWidget</code>, which acts <a id="id326" class="calibre1"/>as a placeholder for our window's contents. Since we want to place a QGIS map canvas into our window, let's implement the code to create our map canvas and place it into this central widget. Add the following to the end of your <code class="email">MapExplorer</code> window's <code class="email">__init__()</code> method (in <code class="email">lex.py</code>):</p><div class="informalexample"><pre class="programlisting">        self.mapCanvas = QgsMapCanvas()
        self.mapCanvas.useImageToRender(False)
        self.mapCanvas.setCanvasColor(Qt.white)
        self.mapCanvas.show()

        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.mapCanvas)
        self.centralWidget.setLayout(layout)</pre></div><p class="calibre8">Next, we want to fill our map canvas with the basemap and landmark map layers. To do this, we'll define a new method called <code class="email">loadMap()</code>, and call this at the appropriate time. Add the following method to your <code class="email">MapExplorer</code> class:</p><div class="informalexample"><pre class="programlisting">    def loadMap(self):
        cur_dir = os.path.dirname(os.path.realpath(__file__))
        filename = os.path.join(cur_dir, "data",
                                "NE1_HR_LC_SR_W_DR",
                                "NE1_HR_LC_SR_W_DR.tif")
        self.basemap_layer = QgsRasterLayer(filename, "basemap")
        QgsMapLayerRegistry.instance().addMapLayer(
                self.basemap_layer)

        filename = os.path.join(cur_dir, "data",
                                "ne_10m_populated_places",
                                "ne_10m_populated_places.shp")
        self.landmark_layer = QgsVectorLayer(filename,
                                             "landmarks", "ogr")
        QgsMapLayerRegistry.instance().addMapLayer(
               self.landmark_layer)

        self.showVisibleMapLayers()
        self.mapCanvas.setExtent(QgsRectangle(-127.7, 24.4, -79.3, 49.1))</pre></div><p class="calibre8">This method loads the raster and vector datasets we placed in our <code class="email">data</code> directory. We then call a new method, <code class="email">showVisibleMapLayers()</code>, to make those layers visible, and then set the extent of the map canvas to show the continental USA when the application first starts up.</p><p class="calibre8">Let's implement the <code class="email">showVisibleMapLayers()</code> method:</p><div class="informalexample"><pre class="programlisting">    def showVisibleMapLayers(self):
        layers = []
        if self.actionShowLandmarkLayer.isChecked():
            layers.append(QgsMapCanvasLayer(self.landmark_layer))
        if self.actionShowBasemapLayer.isChecked():
            layers.append(QgsMapCanvasLayer(self.basemap_layer))
        self.mapCanvas.setLayerSet(layers)</pre></div><p class="calibre8">As the user can choose to show or hide the basemap and landmark layers individually, we only display the layers that the user has selected to display. We also put this into a separate method so that we can call it when the user toggles the visibility of a layer.</p><p class="calibre8">There are a few more <a id="id327" class="calibre1"/>things to do before our map can be displayed. First off, add the following line to your <code class="email">main()</code> function immediately after the call to <code class="email">window.raise_()</code>:</p><div class="informalexample"><pre class="programlisting">    window.loadMap()</pre></div><p class="calibre8">This loads the map once the window has been displayed. Next, add the following to the end of your main window's <code class="email">__init__()</code> method:</p><div class="informalexample"><pre class="programlisting">        self.actionShowBasemapLayer.setChecked(True)
        self.actionShowLandmarkLayer.setChecked(True)</pre></div><p class="calibre8">This makes the two layers visible when the program starts up. Finally, let's implement the two methods we defined earlier so that the user can choose which layers are shown:</p><div class="informalexample"><pre class="programlisting">    def showBasemapLayer(self):
        self.showVisibleMapLayers()

    def showLandmarkLayer(self):
        self.showVisibleMapLayers()</pre></div><p class="calibre8">Running the program should show the two map layers, and you can show or hide each layer using the <a id="id328" class="calibre1"/>commands in the <span class="strong"><strong class="calibre9">View</strong></span> menu:</p><div class="mediaobject"><img src="../images/00052.jpeg" alt="Creating the map canvas" class="calibre11"/></div><p class="calibre12"> </p></div>
<div class="book" title="Labeling the points"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec34" class="calibre1"/>Labeling the points</h1></div></div></div><p class="calibre8">As you can see <a id="id329" class="calibre1"/>from the preceding image, each landmark is simply represented by a colored dot. To make the program more useful, we'll want to display the name of each landmark. This can be done by using the "PAL" labeling engine built into QGIS. Add the following code to your <code class="email">loadMap()</code> method, immediately before the call to <code class="email">self.showVisibleMapLayers()</code>:</p><div class="informalexample"><pre class="programlisting">        p = QgsPalLayerSettings()
        p.readFromLayer(self.landmark_layer)
        p.enabled = True
        p.fieldName = "NAME"
        p.placement = QgsPalLayerSettings.OverPoint
        p.displayAll = True
        p.setDataDefinedProperty(QgsPalLayerSettings.Size,
                                 True, True, "12", "")
        p.quadOffset = QgsPalLayerSettings.QuadrantBelow
        p.yOffset = 1
        p.labelOffsetInMapUnits = False
        p.writeToLayer(self.landmark_layer)

        labelingEngine = QgsPalLabeling()
        self.mapCanvas.mapRenderer().setLabelingEngine(labelingEngine)</pre></div><p class="calibre8">This will label each point on the map. Unfortunately, there are a lot of points, and the resulting map is <a id="id330" class="calibre1"/>completely unreadable:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="Labeling the points" class="calibre11"/></div><p class="calibre12"> </p></div>
<div class="book" title="Filtering the landmarks"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec35" class="calibre1"/>Filtering the landmarks</h1></div></div></div><p class="calibre8">The reason our <a id="id331" class="calibre1"/>labels are unreadable is because there are too many landmarks being displayed. However, not all landmarks are relevant at all zoom levels—we want to hide landmarks that are too small to be useful when the map is zoomed out, while still showing these landmarks when the user zooms in. To do this, we'll use a <code class="email">QgsRuleBasedRendererV2</code> object and make use of the <code class="email">SCALERANK</code> attribute to selectively hide features that are too small for the current zoom level.</p><p class="calibre8">Add the following code to your <code class="email">loadMap()</code> method, before the call to <code class="email">self.showVisibleMapLayers()</code>:</p><div class="informalexample"><pre class="programlisting">        symbol = QgsSymbolV2.defaultSymbol(self.landmark_layer.geometryType())
        renderer = QgsRuleBasedRendererV2(symbol)
        root_rule = renderer.rootRule()
        default_rule = root_rule.children()[0]

        rule = default_rule.clone()
        rule.setFilterExpression("(SCALERANK &gt;= 0) and (SCALERANK &lt;= 1)")
        rule.setScaleMinDenom(0)
        rule.setScaleMaxDenom(99999999)
        root_rule.appendChild(rule)

        rule = default_rule.clone()
        rule.setFilterExpression("(SCALERANK &gt;= 2) and (SCALERANK &lt;= 4)")
        rule.setScaleMinDenom(0)
        rule.setScaleMaxDenom(10000000)
        root_rule.appendChild(rule)

        rule = default_rule.clone()
        rule.setFilterExpression("(SCALERANK &gt;= 5) and (SCALERANK &lt;= 7)")
        rule.setScaleMinDenom(0)
        rule.setScaleMaxDenom(5000000)
        root_rule.appendChild(rule)

        rule = default_rule.clone()
        rule.setFilterExpression("(SCALERANK &gt;= 7) and (SCALERANK &lt;= 10)")
        rule.setScaleMinDenom(0)
        rule.setScaleMaxDenom(2000000)
        root_rule.appendChild(rule)

        root_rule.removeChildAt(0)
        self.landmark_layer.setRendererV2(renderer)</pre></div><p class="calibre8">This will have the <a id="id332" class="calibre1"/>effect of hiding landmarks that are too small (that is, which have too large a <code class="email">SCALERANK</code> value) when the map is zoomed out. Now, our map looks much more reasonable:</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="Filtering the landmarks" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">There's just one more feature we'd like to add here; at the moment, all the labels are of the same size. However, we'd <a id="id333" class="calibre1"/>like the larger landmarks to be shown with a larger label. To do this, replace the <code class="email">p.setDataDefinedProperty(...)</code> line in your program with the following:</p><div class="informalexample"><pre class="programlisting">        expr = ("CASE WHEN SCALERANK IN (0,1) THEN 18" +
                "WHEN SCALERANK IN (2,3,4) THEN 14 " +
                "WHEN SCALERANK IN (5,6,7) THEN 12 " +
                "WHEN SCALERANK IN (8,9,10) THEN 10 " +
                "ELSE 9 END")
        p.setDataDefinedProperty(QgsPalLayerSettings.Size, True,
                                 True, expr, "")</pre></div><p class="calibre8">This calculates the font size based on the feature's <code class="email">SCALERANK</code> attribute value. As you can imagine, using data-defined properties in this way can be extremely useful.</p></div>
<div class="book" title="Implementing the zoom tool"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec36" class="calibre1"/>Implementing the zoom tool</h1></div></div></div><p class="calibre8">Next, we <a id="id334" class="calibre1"/>want to support zooming in and out. As mentioned earlier, one of the requirements for our Lex application is that it must work like Google Maps rather than QGIS, and this is an example of where we have to support this. QGIS has a zoom tool, which the user clicks on and then clicks or drags on the map to zoom in or out. In Lex, the user will click on the toolbar icons directly to do the zooming. Fortunately, this is easy to do; simply implement the <code class="email">zoomIn()</code> and <code class="email">zoomOut()</code> methods in the following way:</p><div class="informalexample"><pre class="programlisting">    def zoomIn(self):
        self.mapCanvas.zoomIn()

    def zoomOut(self):
        self.mapCanvas.zoomOut()</pre></div><p class="calibre8">Now, try to run your program. As you zoom in and out, you can see the various landmarks appear <a id="id335" class="calibre1"/>and disappear, and you should also be able to see the different font sizes used for the labels based on each feature's <code class="email">SCALERANK</code> value.</p></div>
<div class="book" title="Implementing the pan tool"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec37" class="calibre1"/>Implementing the pan tool</h1></div></div></div><p class="calibre8">Panning (that is, clicking <a id="id336" class="calibre1"/>and dragging on the map to move around) is another area where the QGIS default behavior isn't quite what we want. QGIS includes a <code class="email">classQgsMapToolPan</code> class, which implements panning; however, it also includes some features that could be quite confusing for users coming from Google Maps. In particular, if the user clicks without dragging, the map is re-centered over the clicked-on point. Instead of using <code class="email">classQgsMapToolPan</code>, we will implement our own panning map tool. Fortunately, this is simple to do: simply add the following class definition to your <code class="email">lex.py</code> module after the end of your <code class="email">MapExplorer</code> class definition:</p><div class="informalexample"><pre class="programlisting">class PanTool(QgsMapTool):
    def __init__(self, mapCanvas):
        QgsMapTool.__init__(self, mapCanvas)
        self.setCursor(Qt.OpenHandCursor)
        self.dragging = False

    def canvasMoveEvent(self, event):
        if event.buttons() == Qt.LeftButton:
            self.dragging = True
            self.canvas().panAction(event)

    def canvasReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.dragging:
            self.canvas().panActionEnd(event.pos())
            self.dragging = False</pre></div><p class="calibre8">We then need to add the following to the end of our main window's <code class="email">__init__()</code> method to create an instance of our panning tool:</p><div class="informalexample"><pre class="programlisting">        self.panTool = PanTool(self.mapCanvas)
        self.panTool.setAction(self.actionPan)</pre></div><p class="calibre8">We can now implement our <code class="email">setPanMode()</code> method to use this map tool:</p><div class="informalexample"><pre class="programlisting">    def setPanMode(self):
        self.actionPan.setChecked(True)
        self.mapCanvas.setMapTool(self.panTool)</pre></div><p class="calibre8">Finally, we'll want to <a id="id337" class="calibre1"/>select the panning mode when the application starts up. To do this, add the following to your <code class="email">main()</code> function after the call to <code class="email">window.loadMap()</code>:</p><div class="informalexample"><pre class="programlisting">    window.setPanMode()</pre></div></div>
<div class="book" title="Implementing the explore mode"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec38" class="calibre1"/>Implementing the explore mode</h1></div></div></div><p class="calibre8">So far, the user <a id="id338" class="calibre1"/>can choose which map layers are displayed, and can zoom and pan the map view. The only thing missing is the entire point of the application: exploring landmarks. To do this, we'll have to implement our application's <span class="strong"><strong class="calibre9">explore</strong></span> mode.</p><p class="calibre8">In the previous chapter, we saw how we can use a <code class="email">QgsMapToolIdentify</code> subclass to respond when the user clicks on a vector feature. We're going to use the same logic here to implement a new map tool, which we'll call <code class="email">ExploreTool</code>. Add the following class definition to your <code class="email">lex.py</code> module after the <code class="email">PanTool</code> class definition:</p><div class="informalexample"><pre class="programlisting">class ExploreTool(QgsMapToolIdentify):
    def __init__(self, window):
        QgsMapToolIdentify.__init__(self, window.mapCanvas)
        self.window = window

    def canvasReleaseEvent(self, event):
        found_features = self.identify(event.x(), event.y(),
                                       self.TopDownStopAtFirst,
                                       self.VectorLayer)
        if len(found_features) &gt; 0:
            layer = found_features[0].mLayer
            feature = found_features[0].mFeature
            geometry = feature.geometry()

            info = []

            name = feature.attribute("NAME")
            if name != None: info.append(name)

            admin_0 = feature.attribute("ADM0NAME")
            admin_1 = feature.attribute("ADM1NAME")
            if admin_0 and admin_1:
                info.append(admin_1 + ", " + admin_0)

            timezone = feature.attribute("TIMEZONE")
            if timezone != None:
                info.append("Timezone: " + timezone)

            longitude = geometry.asPoint().x()
            latitude  = geometry.asPoint().y()
            info.append("Lat/Long: %0.4f, %0.4f" % (latitude,
                                                    longitude))

            QMessageBox.information(self.window,
                                    "Feature Info",
                                    "\n".join(info))</pre></div><p class="calibre8">This tool identifies the landmark feature the user clicked on, extracts the relevant attributes for that feature, and displays the results in a message box. To use our new map tool, we'll have to add the following to the end of our <code class="email">MapExplorer</code> window's <code class="email">__init__()</code> method:</p><div class="informalexample"><pre class="programlisting">        self.exploreTool = ExploreTool(self)
        self.exploreTool.setAction(self.actionExplore)</pre></div><p class="calibre8">We'll then need to <a id="id339" class="calibre1"/>implement our <code class="email">setExploreMode()</code> method to use this tool:</p><div class="informalexample"><pre class="programlisting">        def setExploreMode(self):
        self.actionPan.setChecked(False)
        self.actionExplore.setChecked(True)
        self.mapCanvas.setMapTool(self.exploreTool)</pre></div><p class="calibre8">Notice that when the user switches to the explore mode, we have to uncheck the panning mode action. This ensures that the two modes are mutually exclusive. The final step we have to take is to modify our <code class="email">setPanMode()</code> method so that it unchecks the explore mode action when the user switches back to the panning mode. To do this, add the following highlighted line to your <code class="email">setPanMode()</code> method:</p><div class="informalexample"><pre class="programlisting">    def setPanMode(self):
        self.actionPan.setChecked(True)
<span class="strong"><strong class="calibre9">        self.actionExplore.setChecked(False)</strong></span>
        self.mapCanvas.setMapTool(self.panTool)</pre></div><p class="calibre8">This completes our Lex program. The user can now zoom in and out, pan around, and click on a feature to get <a id="id340" class="calibre1"/>more information about that landmark:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Implementing the explore mode" class="calibre11"/></div><p class="calibre12"> </p></div>
<div class="book" title="Further improvements and enhancements"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec39" class="calibre1"/>Further improvements and enhancements</h1></div></div></div><p class="calibre8">Of course, while <a id="id341" class="calibre1"/>Lex is a useful and complete mapping application, it is really only a starting point. The information provided in the freely available populated places dataset doesn't make for a particularly interesting set of landmarks, and <a id="id342" class="calibre1"/>our application is still quite basic. Here are some suggested improvements you could make to the Lex application:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Add a <span class="strong"><strong class="calibre9">Search</strong></span> action, where the user can type in the name of a feature and Lex will zoom and pan the map to show that feature.</li><li class="listitem">Let the user choose any two landmarks, and display the distance between those two points in both kilometers and miles.</li><li class="listitem">Allow the user to load their own set of landmarks, either from a shapefile or an Excel spreadsheet. When loading from a shapefile, the user could be prompted to select the attribute(s) to display for each feature. When loading data from a spreadsheet (using, for example, the <code class="email">xlrd</code> library), the various columns would contain the latitude and longitude values as well as the label and other data to <a id="id343" class="calibre1"/>display for each landmark.</li><li class="listitem">See what is involved in bundling the Lex application and QGIS itself into a double-clickable <a id="id344" class="calibre1"/>installer for your operating system. The <span class="strong"><em class="calibre10">PyQGIS Developer cookbook</em></span> has some tips on how to do this, and there are various tools such as <span class="strong"><strong class="calibre9">py2exe</strong></span> and <span class="strong"><strong class="calibre9">py2app</strong></span>, which you can use as a starting point.</li></ul></div><p class="calibre8">Implementing these extra features would be a great way of learning more about PyQGIS and how to use it within your own standalone mapping programs.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec40" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we designed and implemented a simple but complete turnkey mapping application using PyQGIS. In doing this, we learned how a wrapper script can be used to keep platform-specific settings out of your Python program. We also saw how we can define our application's UI in a separate module even if we don't use Qt Designer to create our user interface templates.</p><p class="calibre8">We learned how to use the "PAL" labeling engine built into QGIS to display a label for each feature within a vector map layer. We saw that a <code class="email">QgsRuleBasedRendererV2</code> object can be used to show or hide certain features based on the map's scale factor, and that data-defined properties allow us to calculate values such as the label's font size; we also saw how the <code class="email">CASE...WHEN</code> expression can be used to calculate data-defined properties in sophisticated ways.</p><p class="calibre8">Finally, we saw how to implement Google Maps style panning and zooming within a mapping application.</p><p class="calibre8">In the next chapter, we will learn about some of the more advanced features of the QGIS Python API and how we can use them within our mapping applications.</p></div></body></html>