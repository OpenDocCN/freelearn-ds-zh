<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
<meta charset="utf-8"/>
<meta name="generator" content="packt"/>
<title>10 Calculating Columns Using Complex Algorithms</title>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>

</head>
<body>

<section id="calculating-columns-using-complex-algorithms" class="level1 pkt" data-number="11">
<h1 data-number="11">10 Calculating Columns Using Complex Algorithms</h1>
<p>The data ingestion phase allows you to gather all the information you need for your analysis from any data source. Once the various datasets have been imported, it may be that some of this information, taken as it is, isn’t useful in describing a phenomenon from an analytical point of view. It is often necessary to apply non-trivial algorithms to the data you have in order to get measures or indicators that will do the trick and Power BI often doesn’t have the tools to calculate them. Fortunately, thanks to R and Python, we have everything we need to calculate our measures.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>The distance between two geographic locations</li>
<li>Implementing distances using Python</li>
<li>Implementing distances using R</li>
<li>The basics of linear programming</li>
<li>Definition of the LP problem to solve</li>
<li>Handling optimization problems with Python</li>
<li>Solving LP problems with R</li>
</ul>
<section id="technical-requirements-9" class="level2" data-number="11.1">
<h2 data-number="11.1">Technical requirements</h2>
<p>This chapter requires you to have a working internet connection and <strong>Power BI Desktop</strong> already installed on your machine. You must have properly configured the R and Python engines and IDEs as outlined in <em>Chapter 2</em>, <em>Configuring R with Power BI</em>, and <em>Chapter 3</em>, <em>Configuring Python with Power BI</em>.</p>
</section>
<section id="the-distance-between-two-geographic-locations" class="level2" data-number="11.2">
<h2 data-number="11.2">The distance between two geographic locations</h2>
<p>It often happens that you have in your dataset coordinates expressed in longitude and latitude that identify points on the globe. Depending on the purpose of the analysis you need to complete, you can leverage these coordinates to calculate measures that best help to describe the scenario you want to deal with. For example, assuming you have the geographic coordinates of some hotels in a dataset, it might make sense to calculate the distance of each of them to the nearest airport if you want to give an additional value of interest to a visitor. Let’s start by figuring out what types of distances to consider for our case.</p>
<section id="spherical-trigonometry" class="level3" data-number="11.2.1">
<h3 data-number="11.2.1">Spherical trigonometry</h3>
<p>The study of how to measure triangles (<strong>trigonometry</strong>) has been of great interest in the past. The ancient Egyptians and Babylonians had already addressed the issues between the relationships between sides, although they did not yet have the notion of an angle. It is thanks to <strong>Hellenistic mathematics</strong> that the concepts of trigonometric functions as we know them now began to spread around the world, even reaching India and China.</p>
<p>It was the ancient Greeks who, once they had explored all the properties associated with a triangle drawn on a plane, came up with the idea of imagining a triangle drawn on a sphere. The importance of measuring distances between points on a sphere was immediately shown to be of interest in later centuries for navigation and astronomy. Therefore, several minds devoted themselves eagerly to the discovery of important properties that today can be collected under the name of <strong>spherical trigonometry</strong>.</p>
<p>If you draw a spherical triangle, you will immediately notice the differences from a flat triangle:</p>
<figure>
<img src="../media/file235.png" alt="Figure 10.1 – A spherical triangle" /><figcaption aria-hidden="true">Figure 10.1 – A spherical triangle</figcaption>
</figure>
<p>The main difference with planar triangles is that the sides of spherical triangles are arcs of <strong>great circles</strong> or <strong>geodesics</strong> (circumferences that always divide the sphere in half), and since the central angles (near the center, <em>O</em>) are proportional to the lengths of their respective arcs (<em>length = π x angle</em>), the sides <em>a</em>, <em>b</em>, and <em>c</em> are measured with <em>angle units</em> rather than linear units. If you want a visualization of the fact that the sides of the spherical triangle belong to three great circles, <em>Figure 10.2</em> can help you:</p>
<figure>
<img src="../media/file236.png" alt="Figure 10.2 – The great circles that generate a spherical triangle" /><figcaption aria-hidden="true">Figure 10.2 – The great circles that generate a spherical triangle</figcaption>
</figure>
<p>The mathematics describing spherical trigonometry makes it possible to define all the distances between two points on the sphere so far highlighted by great mathematicians of the past.</p>
<p>As for the distances between two geographical points, the reference coordinate system will be the one that makes use of <strong>latitude</strong> and <strong>longitude</strong>. Obviously, we will not go into the mathematical detail of the proofs of distances that we will propose shortly (also because some of them would be very complex indeed). We did, however, want to provide an introduction that would lay the groundwork that can be found in the most frequently used concepts of geographic distances.</p>
<p>Let’s now explore the most straightforward distance between two points, the law of Cosines distance.</p>
</section>
<section id="the-law-of-cosines-distance" class="level3" data-number="11.2.2">
<h3 data-number="11.2.2">The law of Cosines distance</h3>
<p>The <strong>law of Cosines distance</strong> (also called the <strong>great circle distance</strong>) is the shortest distance between two points on the surface of a sphere, measured along the surface of the sphere. Given two points, <em>P</em> and <em>Q</em>, a unique great circle passes through them. The two points separate the great circle into two distinct arcs. The length of the shorter arc is the distance of the great circle between the points:</p>
<figure>
<img src="../media/file237.png" alt="Figure 10.3 – The great circle distance between the points P and Q" /><figcaption aria-hidden="true">Figure 10.3 – The great circle distance between the points P and Q</figcaption>
</figure>
<p>Observe that if the two points of which to calculate the distance are at the antipodes of the sphere (the <strong>antipodal points</strong> <em>u</em> and <em>v</em>), then the great circles that pass through them are infinite and the distance between these two points is calculated very easily, as it measures exactly half the circumference of the sphere.</p>
<p>When, on the other hand, the points are not antipodal, it is possible to derive the preceding distance thanks to the <strong>spherical law of Cosines</strong> (see <em>References</em> at the end of this chapter) that governs spherical trigonometry (that’s why we also call it the law of Cosines distance). Without tediously going through the mathematical steps, the formula that calculates the law of Cosines (or great circle) distance between two points on a sphere is as follows:</p>
<figure>
<img src="../media/file238.png" alt="Figure 10.4 – The formula of the law of Cosines distance between two points" /><figcaption aria-hidden="true">Figure 10.4 – The formula of the law of Cosines distance between two points</figcaption>
</figure>
<p>Looking at it, it’s not the simplest, cleanest formula you’ve ever seen, right? Despite this, having a handy calculator available today, the preceding calculation remains feasible. Now imagine the ancient navigators who used to apply the great circle distance between various points on the globe. How could they have used the preceding formula, even though they had sine and cosine tables that would have facilitated some calculations? It would have been a very complex activity and subject to errors that could have cost the sailors their lives.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>If the two points are close together (for example, a few kilometers apart on the sphere) and you don’t have a calculator with accurate precision, you might get inaccurate results.</p>
</blockquote>
<p>For these reasons, mathematicians of the age introduced the new trigonometric <code>haversin</code> function (or <code>hav</code>), which allows you to transform and smooth out the great circle distance formula, also avoiding the previously mentioned error for small distances. Let’s see how it does this.</p>
</section>
<section id="the-law-of-haversines-distance" class="level3" data-number="11.2.3">
<h3 data-number="11.2.3">The law of Haversines distance</h3>
<p>The function called <code>haversine</code> (from <em>half-versed sine</em>) is defined as follows:</p>
<figure>
<img src="../media/file239.png" alt="Figure 10.5 – Definition of the haversine function" /><figcaption aria-hidden="true">Figure 10.5 – Definition of the haversine function</figcaption>
</figure>
<p>Thanks to this new function, it is possible to rewrite the law of Cosines distance as follows:</p>
<figure>
<img src="../media/file240.png" alt="Figure 10.6 – Definition of the law of Haversines distance" /><figcaption aria-hidden="true">Figure 10.6 – Definition of the law of Haversines distance</figcaption>
</figure>
<p>This new distance formulation is known as the <strong>law of Haversines distance</strong>. Its undoubted usefulness to navigators of the time becomes clear when you consider that, along with the tables of sines and cosines, tables of Haversines were also published. Therefore, the calculation of the distance between two points became immediate.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>Even this formula suffers from rounding errors due to the special (and somewhat unusual) case of antipodal points.</p>
</blockquote>
<p>To get a distance formula that has better accuracy than the Haversines one, you have to use Vincenty’s formula. Let’s see what this is all about.</p>
</section>
<section id="vincentys-distance" class="level3" data-number="11.2.4">
<h3 data-number="11.2.4">Vincenty’s distance</h3>
<p>The winning assumption that led the geodesist Vincenty to a more precise formula of the distance between two points was to consider the Earth as not a sphere but an ellipsoid slightly flattened at the poles (the difference is only about 21 km):</p>
<figure>
<img src="../media/file241.png" alt="Figure 10.7 – An ellipsoid representation" /><figcaption aria-hidden="true">Figure 10.7 – An ellipsoid representation</figcaption>
</figure>
<p>Unlike the Haversines method for calculating a distance on a sphere, <strong>Vincenty’s formulas</strong> describe a method that needs to converge to a solution through several iterations. In detail, a sequence of equations is calculated whose output is fed back into the same sequence of equations with the goal of minimizing the calculated value after a certain number of iterations. For this reason, Vincenty’s formulas are computationally more demanding.</p>
<p>Vincenty’s formulas are related to two problems:</p>
<ul>
<li><strong>Direct problem</strong>: Find the endpoint, <em>(Φ2, L2)</em>, and azimuth, <em>α2</em>, given an initial point, <em>(Φ1, L1)</em>, and initial azimuth, <em>α1</em>, and a distance, <em>s</em>.</li>
<li><strong>Inverse problem</strong>: Find the azimuths <em>α1</em>, <em>α2</em> and the ellipsoidal distance, <em>s</em>, given the coordinates of the two points, <em>(Φ1, L1)</em> and <em>(Φ2, L2)</em>.</li>
</ul>
<p>The reverse problem is what we are interested in as we need to calculate the distance. To get an idea of the complexity of the formulas, take a look at the <em>References</em> section at the end of the chapter.</p>
<p>Vincenty’s formulas are widely used in projects where there is a need for high precision in measurements because they are accurate to within 0.5 mm (0.020 in) of the Earth’s ellipsoid.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>If the points are nearly antipodal, the algorithm fails to converge and the error is much larger or converges slowly.</p>
</blockquote>
<p>In 2013, Karney used Newton’s method to give rapid convergence for all pairs of input points without any error.</p>
<p>At this point, the question that arises is what kind of distance is best to use and when. Let’s try to understand that in the following section.</p>
</section>
<section id="what-kind-of-distance-to-use-and-when" class="level3" data-number="11.2.5">
<h3 data-number="11.2.5">What kind of distance to use and when</h3>
<p>Considering the strong limitation that the law of Cosines distance has for short distances between two points, the most used methods today in common applications are the law of Haversines (for short, Haversine) and Vincenty’s formulas (for short, Vincenty). Here are our suggestions about which distance to use in particular scenarios:</p>
<ul>
<li>For <em>points located close to each other</em> (think short-range flights), the approximation of the Earth to a sphere is very likely. Therefore, methods based on the spherical Earth model, such as Haversine, which are computationally simpler (hence faster), will be quite adequate.</li>
<li>For <em>points located far away</em> (such as long-range flights, especially connecting opposite hemispheres), the spherical Earth model starts to be less tight and inaccurate. In these cases, Vincenty’s inverse formula for ellipsoids, which is substantially more computationally complex (hence generally slower), will give a better result. If you have computational limitations, you need to consider whether the faster models give sufficiently accurate results for your purposes.</li>
</ul>
<p>Now that you’ve become well versed in the theory, let’s move on to implementing these algorithms in Python and R.</p>
</section>
</section>
<section id="implementing-distances-using-python" class="level2" data-number="11.3">
<h2 data-number="11.3">Implementing distances using Python</h2>
<p>The scenario on which we will implement the distance algorithms just described involves a dataset of US hotels, containing the latitude and longitude of each. The goal is to enrich the dataset by adding the distances to the nearest airports.</p>
<p>The hotel data is publicly available on <em>Back4App</em> (<a href="https://bit.ly/data-hotels-usa">https://bit.ly/data-hotels-usa</a>). For convenience, we extracted only 100 hotels from New York City and we will calculate for each of them the distances from the LaGuardia and John F. Kennedy airports (you can find the airport data here: <a href="https://datahub.io/core/airport-codes">https://datahub.io/core/airport-codes</a>) using the Haversine (spherical model) and Karney (ellipsoidal model) methods. You can find the already extracted datasets for your convenience in the <code>Chapter10</code> folder of the GitHub repository. In detail, you will find the hotel data in the <code>hotels-ny.xlsx</code> file and the airport data in the <code>airport-codes.csv</code> file.</p>
<section id="calculating-distances-with-python" class="level3" data-number="11.3.1">
<h3 data-number="11.3.1">Calculating distances with Python</h3>
<p>As we mentioned earlier, we are not those that like to reinvent the wheel, especially when there is a risk of running into complexities related to the domain of the problem to be solved. Fortunately, Python has a very active community of programmers with expertise in specific scientific domains who share their artifacts publicly. This is the case of the <code>PyGeodesy</code> package (<a href="https://github.com/mrJean1/PyGeodesy">https://github.com/mrJean1/PyGeodesy</a>), created by Jean M. Brouwers, which implements in pure Python various computational tools for spherical and ellipsoidal models of the Earth that Chris Veness has made available for Java and Charles Karney himself has made available in C++.</p>
<p>To be able to use this module, you must obviously install it in your environment and, since we intend to use the distance formulas optimized by Karney, we must also install the <code>geographiclib</code> package, directly maintained by him. Therefore, proceed as follows:</p>
<ol>
<li>Open Anaconda Prompt.</li>
<li>Switch to the <code>pbi_powerquery_env</code> environment, entering the <code>conda activate pbi_powerquery_env</code> command, and then press <em>Enter</em>.</li>
<li>Install the <code>PyGeodesy</code> package, entering <code>pip install PyGeodesy</code>, and then press <em>Enter</em>.</li>
<li>Install the <code>geographiclib</code> package, entering <code>pip install geographiclib</code>, and then press <em>Enter</em>.</li>
<li>If you have not already done so, also install the <code>openpyxl</code> package by entering <code>pip install openpyxl</code>, and then press <em>Enter</em>.</li>
</ol>
<p>At this point, you can proceed with the Python code. First, note that <code>PyGeodesy</code> package contains a form with basic geodesic functions, called <code>formy</code>. In this module, there are functions that directly calculate distances according to the Haversine's and Vincenty formulas, but it doesn’t contain the variant of Karney’s formulas. Therefore, in addition to the standard pandas and NumPy modules, the following must be imported:</p>
<pre><code>from pygeodesy import formy as frm
from pygeodesy.ellipsoidalKarney import LatLon as kLatLon</code></pre>
<p>To calculate the distance according to Karney, you must use the objects provided by the <code>ellipsoidalKarney</code> module. Basically, you have to create the two points on the ellipsoid using the <code>LatLon</code> method of this model, and then calculate the distance. This is summarized in the following <code>karney</code> user-defined function:</p>
<pre><code>def karney(lat1, lng1, lat2, lng2):
return kLatLon(lat1, lng1).distanceTo(kLatLon(lat2, lng2))</code></pre>
<p>After that, a second user-defined function is created for convenience as a wrapper for the calls to the calculation of the various distances:</p>
<pre><code>def geodistance(lat1, lng1, lat2, lng2, func):
return func(lat1, lng1, lat2, lng2)</code></pre>
<p>Then, the hotels data is imported into the <code>hotel_df</code> dataframe and the airports data into the <code>airports_df</code> one. Since the airports dataframe has the <code>coordinates</code> column, which contains a string with longitude and latitude separated by a comma, these two values are split into two separate columns using the <code>split()</code> function and then appended to the same source dataframe without the <code>coordinates</code> column, now useless:</p>
<pre><code>airports_df = pd.concat([
airports_df.drop([’coordinates’], axis=1),
airports_df[’coordinates’].str.split(‘, ‘, expand=True).rename(columns={0:’longitude’, 1:’latitude’}).astype(float)], axis=1)</code></pre>
<p>In order to conveniently access the latitude and longitude values of a specific airport, the user-defined <code>airportLatLongList()</code> function has been created, which accepts as parameters both a dataframe containing the airport data with the <code>iata_code</code>, <code>latitude</code> and <code>longitude</code> columns and the specific <strong>IATA code</strong> of the airport of interest. Remember that the IATA airport code is a three-letter code that identifies many airports and metropolitan areas around the world, defined by the <strong>International Air Transport Association</strong> (<strong>IATA</strong>). Therefore, John F. Kennedy International Airport is identified by the IATA code <code>JFK</code> and LaGuardia Airport by the code <code>LGA</code>. So, in order to get the coordinates of those airports, you can use the following code:</p>
<pre><code>jfk_lat, jfk_long  = airportLatLongList(airports_df, ‘JFK’)
lga_lat, lga_long = airportLatLongList(airports_df, ‘LGA’)</code></pre>
<p>That said, thanks to the <code>geodistance()</code> function, it is enough to have the geographical coordinates of two points in order to calculate the distance between them. For example, if you want to calculate the haversine distance between point <code>A(lat1,lng1)</code> and point <code>B(lat2,lng2)</code>, you just have to use this code:</p>
<pre><code>geodistance(lat1, lng1, lat2, lng2, func=frm.harvesine)</code></pre>
<p>To be able to calculate the Karney distance between them instead, you can take advantage of the <code>karney()</code> function and use this code:</p>
<pre><code>geodistance(lat1, lng1, lat2, lng2, func=karney)</code></pre>
<p>However, how should you proceed if you no longer want to apply the <code>geodistance()</code> function to two single points, but to a series of points contained in a dataframe column and a second fixed point? Since the preceding function needs five input parameters, we could have used the <code>apply()</code> method of the pandas dataframe (as shown here: <a href="http://bit.ly/pandas-apply-lambda">http://bit.ly/pandas-apply-lambda</a>). Instead, we introduced a convenient way to evaluate a function over successive tuples of the input Series. In order to vectorize a function, you must invoke the <code>np.vectorize()</code> method and pass as a parameter the function to be applied to the geographic coordinate Series. Then, you also have to pass the parameters of the input function as follows:</p>
<pre><code>hotels_df[’haversineDistanceFromJFK’] = np.vectorize(geodistance)(
hotels_df[’latitude’],
hotels_df[’longitude’],
jfk_lat,
jfk_long,
func=frm.haversine)</code></pre>
<p>The distances (in meters) resulting from the previous calculation are stored into the new <code>haversineDistanceFromJFK</code> column of the <code>hotels_df</code> dataframe. Similarly, the Karney distance can be calculated by simply referencing the <code>karney</code> function in the code chunk.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>A <strong>vectorized function</strong> is not the same as a function used with <code>np.vectorize()</code>. A vectorized function is a function built into NumPy and executed in the underlying compiled code (C or Fortran) so that special processor registers are used to operate on several items at once. As you can imagine, vectorization is much more performant and preferable to <code>for</code> loops. For more details, check out the <em>References</em> section.</p>
</blockquote>
<p>If you run the code for the <code>01-distances-from-airports-in-python.py</code> file in the <code>Python</code> folder, you’ll get something like this:</p>
<figure>
<img src="../media/file242.png" alt="Figure 10.8 – Haversine and Karney distances from hotels to JFK and LGA airports added" /><figcaption aria-hidden="true">Figure 10.8 – Haversine and Karney distances from hotels to JFK and LGA airports added</figcaption>
</figure>
<p>Amazing! You were able to calculate both the Haversine and Karney distances in meters between all hotels and both airports using Python. At this point, it is straightforward to use similar code to calculate distances in Power BI. Let’s see how to do it.</p>
</section>
<section id="calculating-distances-in-power-bi-with-python" class="level3" data-number="11.3.2">
<h3 data-number="11.3.2">Calculating distances in Power BI with Python</h3>
<p>It’s time to implement what you’ve learned in Power BI. So, launch Power BI Desktop and let’s get going:</p>
<ol>
<li>Make sure Power BI Desktop is referencing your latest environment in <strong>Options</strong>. After that, click on <strong>Excel</strong> to import the <code>hotels-ny.xlsx</code> file, which you can find in the <code>Chapter10</code> folder. Select it and click <strong>Open</strong>.</li>
<li><p>Select the <strong>Sheet 1</strong> table from the <strong>Navigator</strong> window:</p>
<figure>
<img src="../media/file243.png" alt="Figure 10.9 – Selecting the Sheet 1 table" /><figcaption aria-hidden="true">Figure 10.9 – Selecting the Sheet 1 table</figcaption>
</figure>
<p>Then, click on <strong>Transform data</strong>.</p></li>
<li>Click on the <strong>Transform</strong> menu and then click on <strong>Run Python Script</strong>.</li>
<li>Copy the script from the <code>02-distances-from-airports-in-power-bi-with-python.py</code> file from the <code>Chapter10\Python</code> folder into the Python script editor and click <strong>OK</strong>.</li>
<li>You may be prompted to align the permissions in the Excel file with those you initially selected for the scripts (in our case, <strong>Organizational</strong>). In this case, you already know how to proceed based on what you’ve seen in <em>Chapter 5</em>, <em>Using Regular Expressions in Power BI</em>.</li>
<li>We are only interested in the data in <code>dataset</code>. So, click on its <strong>Table</strong> value.</li>
<li><p>Power Query will transform your data by adding the distances from each hotel to the two airports, <code>JFK</code> and <code>LGA</code>, for the two methodologies of Haversines and Karney:</p>
<figure>
<img src="../media/file244.png" alt="Figure 10.10 – The result of the Python script transformation" /><figcaption aria-hidden="true">Figure 10.10 – The result of the Python script transformation</figcaption>
</figure></li>
<li>You can then click <strong>Close &amp; Apply</strong> in the <strong>Home</strong> tab.</li>
</ol>
<p>Great! You just enriched your data by adding the distances between two geographical points in Power BI using Python. Let’s see how to do that in R.</p>
</section>
</section>
<section id="implementing-distances-using-r" class="level2" data-number="11.4">
<h2 data-number="11.4">Implementing distances using R</h2>
<p>The scenario will be the same as the one already described in the previous section. We will therefore enrich the data relating to some hotels in New York City with the distances separating them from the two major airports of New York, namely John F. Kennedy and LaGuardia.</p>
<p>The files containing the data to be processed can be found in the <code>Chapter10</code> folder of the GitHub repository. In detail, you will find the hotels data in the <code>hotels-ny.xlsx</code> file and the airports data in the <code>airport-codes.csv</code> file.</p>
<section id="calculating-distances-with-r" class="level3" data-number="11.4.1">
<h3 data-number="11.4.1">Calculating distances with R</h3>
<p>The R community is also fortunate to have a freely available package that implements spherical trigonometry functions for geographic applications. The package is called <code>geosphere</code> (<a href="https://cran.r-project.org/web/packages/geosphere/">https://cran.r-project.org/web/packages/geosphere/</a>) and, like the Python <code>PyGeodesy</code> package, it is inspired by the code that Chris Veness and Charles Karney have made publicly available.</p>
<p>First, you need to install this new package:</p>
<ol>
<li>Open RStudio and make sure it is referencing your latest CRAN R (version 4.0.2 in our case).</li>
<li>Click on the <strong>Console</strong> window and enter this command: <code>install.packages(‘geosphere’)</code>. Then, press <em>Enter</em>.</li>
</ol>
<p>You are now ready to develop your code in R. Apart from the usual packages that allow you to read CSV and Excel files (<code>readr</code> and <code>readxl</code>) and facilitate data transformation operations (<code>dplyr</code> and <code>purrr</code>), you must, of course, load the package you just installed.</p>
<p>You can easily import hotel data into the <code>hotels_tbl</code> tibble using the <code>read_xlsx()</code> function and airport data into the <code>airport_tbl</code> tibble using the <code>read_csv()</code> function. At this point, the first operation to do is to split the contents of the <code>coordinates</code> column of <code>airports_tbl</code> in the two new columns, <code>longitude</code> and <code>latitude</code>:</p>
<pre><code>airports_tbl &lt;- airports_tbl %&gt;% 
tidyr::separate(
col = coordinates,
into = c(‘longitude’, ‘latitude’),
sep = ‘, ‘,
remove = TRUE,
convert = TRUE )</code></pre>
<p>Note the simplicity of using the <code>separate</code> function from the <code>tidyr</code> package:</p>
<ol>
<li>The pipe passes the <code>airports_tbl</code> tibble as the first parameter for the function.</li>
<li>Declare the column to be split (<code>col = coordinates</code>).</li>
<li>Declare the two new target columns (<code>into = c(‘longitude’, ‘latitude’)</code>).</li>
<li>Declare the separator found in the values of the column to be split (<code>sep = ‘, ‘</code>).</li>
<li>Remove the column to be split when the transformation is complete (<code>remove = TRUE</code>).</li>
<li>Let the data type of the target columns convert automatically if they are numeric columns (<code>convert = TRUE</code>).</li>
</ol>
<p>All this in one operation with maximum clarity. That’s one of the reasons data analysts love R!</p>
<p>Again, we make use of a function to conveniently access the longitude and latitude values of a specific airport. It is the <code>airportLongLatVec()</code> function and it accepts as parameters both a dataframe containing the airport data with the <code>iata_code</code>, <code>latitude</code>, and <code>longitude</code> columns, and the specific <strong>IATA code</strong> of the airport of interest:</p>
<pre><code>airportLongLatVec &lt;- function(df, iata) {
ret_vec &lt;- df %&gt;% 
filter( iata_code == iata ) %&gt;% 
select( longitude, latitude ) %&gt;% 
unlist()
return(ret_vec)
}</code></pre>
<p>The output is a named vector. So, the coordinates of the two airports can be easily found in this way:</p>
<pre><code>jfk_coordinates &lt;- airportLongLatVec(airports_tbl, ‘JFK’)
lga_coordinates &lt;- airportLongLatVec(airports_tbl, ‘LGA’)</code></pre>
<p>You are pretty much ready to transform the data. From the <code>geosphere</code> package, you will use the <code>distHaversine()</code> and <code>distGeo()</code> functions. The former is self-explanatory from the name itself. The <code>distGeo()</code> function calculates the shortest distance between two points on an ellipsoid according to Karney’s formulas. Both functions accept two pairs of coordinates (in the order longitude and latitude) in vector form. To get the same results as Python, the <code>distHaversine()</code> function must accept as a parameter the same mean radius of the Earth sphere model used by default by PyGeodesy. The radius in question is <strong>R1</strong> (mean radius) defined by the <strong>International Union of Geodesy and Geophysics</strong> (<strong>IUGG</strong>), which is 6,371,008.771415 meters.</p>
<p>At this point, the enrichment operation of the <code>hotels_tbl</code> tibble can be done using the already seen family of <code>map()</code> functions of the <code>purrr</code> package. In the first step, we create a new column, <code>p1</code>, containing the longitude and latitude pairs in a vector using the <code>map2()</code> function. In the second step, we apply the <code>distHaversine()</code> and <code>distGeo()</code> functions to the newly created point, <code>p1</code>, and to the fixed points identifying the airports (<code>jfk_coordinates</code> and <code>lga_coordinates</code>) to create the new columns containing the distances. This is the code needed:</p>
<pre><code>hotels_tbl &lt;- hotels_tbl %&gt;% 
mutate(
p1 = map2(longitude, latitude, ~ c(.x, .y))
    ) %&gt;% 
mutate(
haversineDistanceFromJFK = map_dbl(p1, ~ distHaversine(p1 = .x, p2 = jfk_coordinates, r = 6371008.771415)),
karneyDistanceFromJFK = map_dbl(p1, ~ distGeo(p1 = .x, p2 = jfk_coordinates)),
haversineDistanceFromLGA = map_dbl(p1, ~ distHaversine(p1 = .x, p2 = lga_coordinates, r = 6371008.771415)),
karneyDistanceFromLGA = map_dbl(p1, ~ distGeo(p1 = .x, p2 = lga_coordinates))
    ) %&gt;%
select( -p1 )</code></pre>
<p>Recall that the <code>map2()</code> function takes two vectors as input and runs them in parallel to pass their values to the function used after the <code>~</code> symbol (in our case, the <code>c()</code> function that declares a vector). The <code>map_dbl()</code> function instead takes as input the column <code>p1</code> (which contains the geographic coordinates in vector format of the hotels) and passes its elements to the function after the <code>~</code> (in our case, <code>distGeo()</code> with other fixed parameters) transforming the output into a vector of double numeric data types.</p>
<p>If you run the code for the <code>01-distances-from-airports-in-r.R</code> file in the <code>R</code> folder, you’ll get something like this:</p>
<figure>
<img src="../media/file245.png" alt="Figure 10.11 – The enriched hotels tibble with distances" /><figcaption aria-hidden="true">Figure 10.11 – The enriched hotels tibble with distances</figcaption>
</figure>
<p>Wow! You were able to calculate both the Haversine and Karney distances between all hotels and both airports also using R. At this point, it is straightforward to use similar code to calculate distances in Power BI. Let’s see how to do it.</p>
</section>
<section id="calculating-distances-in-power-bi-with-r" class="level3" data-number="11.4.2">
<h3 data-number="11.4.2">Calculating distances in Power BI with R</h3>
<p>It’s time to implement what you’ve just learned in Power BI. So, launch Power BI Desktop and let’s get going:</p>
<ol>
<li>Make sure Power BI Desktop is referencing your latest environment in <strong>Options</strong>. After that, click on <strong>Excel</strong> to import the <code>hotels-ny.xlsx</code> file, which you can find in the <code>Chapter10</code> folder. Select it and click <strong>Open</strong>.</li>
<li><p>Select the <strong>Sheet 1</strong> table from the <strong>Navigator</strong> window:</p>
<figure>
<img src="../media/file246.png" alt="Figure 10.12 – Selecting the Sheet 1 table" /><figcaption aria-hidden="true">Figure 10.12 – Selecting the Sheet 1 table</figcaption>
</figure>
<p>Then, click on <strong>Transform data</strong>.</p></li>
<li>Click on the <strong>Transform</strong> menu and then click on <strong>Run R Script</strong>.</li>
<li>Copy the script from the <code>02-distances-from-airports-in-power-bi-with-r.R</code> file from the <code>Chapter10\R</code> folder into the R script editor and click <strong>OK</strong>.</li>
<li>We are only interested in the data in <code>hotels_df</code>. So, click on its <strong>Table</strong> value.</li>
<li><p>Power Query will transform your data by adding the distances from each hotel to the two airports, <code>JFK</code> and <code>LGA</code>, for the two methodologies of Haversines and Karney:</p>
<figure>
<img src="../media/file247.png" alt="Figure 10.13 – The result of the Python script transformation" /><figcaption aria-hidden="true">Figure 10.13 – The result of the Python script transformation</figcaption>
</figure></li>
<li>You can then click <strong>Close &amp; Apply</strong> in the <strong>Home</strong> tab.</li>
</ol>
<p>Great! You just enriched your data by adding distances between two geographical points in Power BI using R.</p>
<p>In the next section, you will see how to enrich your dataset using linear optimization algorithms.</p>
</section>
</section>
<section id="the-basics-of-linear-programming" class="level2" data-number="11.5">
<h2 data-number="11.5">The basics of linear programming</h2>
<p><strong>Linear Programming</strong> (<strong>LP</strong>) <strong>algorithms</strong> are adopted in all those areas where optimization, and therefore the economy of resources, is critical to the continuation of activities. In order to understand what this is all about, you need some math. In this way, let’s brush up on some of the geometric concepts we encountered during our youthful studies.</p>
<section id="linear-equations-and-inequalities" class="level3" data-number="11.5.1">
<h3 data-number="11.5.1">Linear equations and inequalities</h3>
<p>We all at least once in our lives have encountered the term linear equation. A <strong>linear equation</strong>, in its simplest sense, consists of a mathematical relationship between two variables, <em>x</em> and <em>y</em>, in the form <em>ax + by + c = 0</em>, which on the Cartesian plane identifies a <strong>straight line</strong>:</p>
<figure>
<img src="../media/file248.png" alt="Figure 10.14 – Representation of the linear equation 2x + y = 2" /><figcaption aria-hidden="true">Figure 10.14 – Representation of the linear equation 2x + y = 2</figcaption>
</figure>
<p>Evidently, the variables involved in a linear equation can be more than two. The representation of a linear equation is possible as long as we have three variables (the famous three dimensions we can see). In this case, a linear equation of three variables, in the form <em>ax + by + cz + d = 0</em>, represents a <strong>plane</strong> in the space:</p>
<figure>
<img src="../media/file249.png" alt="Figure 10.15 – Representation of a generic linear equation ax + by + cz + d = 0" /><figcaption aria-hidden="true">Figure 10.15 – Representation of a generic linear equation ax + by + cz + d = 0</figcaption>
</figure>
<p>When you have more than three variables in a linear equation, we commonly call its representation no longer a plane, but a <strong>hyperplane</strong>.</p>
<p>There are also <strong>linear inequalities</strong>, which are linear functions involving inequalities (identified by the symbols <code>&lt;</code>, <code>&gt;</code>, <code>≤</code>, and <code>≥</code>). Just as done for linear equations, in the same way, you can plot linear inequalities, either with two variables or with three. They represent all points on either side of the line in the case of two variables (that is, a region of the plane), or points on either side of the straight plane in the case of three variables (that is, a volume):</p>
<figure>
<img src="../media/file250.png" alt="Figure 10.16 – Representation of generic linear inequalities with two or three variables" /><figcaption aria-hidden="true">Figure 10.16 – Representation of generic linear inequalities with two or three variables</figcaption>
</figure>
<p>Observe that the regions identified by the inequalities are infinite but have an edge constituted by the linear equation that derives from the same inequality considering the <code>=</code> sign instead of the inequality sign.</p>
<p>Well, very often when you think about these concepts, you just associate them with theoretical mathematical stuff, but that’s not the case. Simple concepts related to transportation, manufacturing, shipping, and so on can be traced back to linear equations or inequalities. Let’s see an example.</p>
</section>
<section id="formulating-a-linear-optimization-problem" class="level3" data-number="11.5.2">
<h3 data-number="11.5.2">Formulating a linear optimization problem</h3>
<p>Imagine you work in a manufacturing company and you need to produce two products, P1 and P2. To produce them, you need a machine. Specifically, producing one unit of product P1 takes 30 minutes of processing time on the machine, while producing one unit of product P2 takes 25 minutes on the same machine. In addition, the number of hours for which the machine, M, can remain on is 40 hours (= 40*60 minutes). That is, 30 minutes multiplied by the number of P1 products added to 25 minutes multiplied by the number of P2 products cannot exceed 40 hours of processing time. So, given <em>x</em> number of products P1 and <em>y</em> number of products P2 produced at the end of processing, the machine hours <strong>constraint</strong> can be summarized as follows:</p>
<p>Wow! You just used a simple linear inequality to describe a constraint on a manufacturing process.</p>
<p>Now imagine that you have received demands for P1 and P2 products from customers. Specifically, adding up all the requests, you need to produce at least 45 units of P1 and 25 units of P2 to satisfy your customers. These demand constraints can be summarized as follows:</p>
<p>Awesome! You’ve added two more linear constraints to your problem. If you add a goal to these business constraints, for example, you want to maximize the total number, <em>z</em>, of units of P1 and P2, the set of constraints and goal constitute a linear optimization problem:</p>
<p>Simple as that, right? If we want to be a little more formal, LP (also called <strong>linear optimization</strong>) consists of a set of techniques useful for solving systems of linear equations and inequalities with the goal of maximizing or minimizing a linear objective function. In particular, the variables <em>x</em> and <em>y</em> are called <strong>decision variables</strong> and the objective that is set is called the <strong>objective function</strong> or <strong>cost function</strong>. In this example, the business case required only inequality constraints, but there can also be equality constraints.</p>
<p>Cool! But now that we’ve set up the problem from a mathematical standpoint, how do we solve it? First, we need to take all the inequalities and represent them on the axes (in this case you can, because they only contain two variables). As seen at the beginning, a linear inequality represents a portion of a plane bounded by the straight line considering the sign of equality in the inequality itself. Intersecting all these planes, we come to identify an area common to all the inequalities, called the <strong>feasible region</strong>. Basically, all points that are in this region satisfy all the constraints identified by the inequalities.</p>
<p>If you want to draw the feasible region associated with the constraints of the example we have just illustrated, there is no need to go over all the geometry studied in secondary school, but just use <strong>WolframAlpha</strong> (<a href="https://www.wolframalpha.com/">https://www.wolframalpha.com/</a>). Enter the following string in the search engine: <code>plot 30x+25y&lt;=2400 and x&gt;=45 and y&gt;=25</code>. All constraints must be satisfied simultaneously, hence the use of the <code>and</code> operator. Press <em>Enter</em> and you will see this result:</p>
<figure>
<img src="../media/file251.png" alt="Figure 10.17 – The feasible region drawn by WolframAlpha" /><figcaption aria-hidden="true">Figure 10.17 – The feasible region drawn by WolframAlpha</figcaption>
</figure>
<p>To the WolframAlpha result, we have added the values of the vertices of the feasible region, which is a triangle.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>It is shown that if the optimization problem is solvable, the solution that maximizes or minimizes the objective function lies precisely at one of the vertices of the feasible region.</p>
</blockquote>
<p>As you can see in <em>Figure 10.17</em>, the <em>x</em> value of vertex C is <code>59.1</code>. Clearly, it is not possible to have a fractional part of the product P1 since it is not possible to produce only a fraction of one unit. The nearest integer value should then be considered, which is 59. If, therefore, the business problem imposes to have <strong>integer values</strong> for the decision variables, then the problem becomes one of <strong>Mixed-Integer Linear Programming</strong> (<strong>MILP</strong>). In our case, then, we consider vertices <em>A</em>, <em>B</em>, and <em>C</em>*=(59,25) as possible solutions to our problem and substitute their coordinates into the objective function, <em>z = x + y</em>:</p>
<ul>
<li><em>A</em>: <em>z = 45 + 25 = 70</em></li>
<li><em>B</em>: <em>z = 45 + 42 = 87</em></li>
<li><em>C*</em>: <em>z = 59 + 25 = 84</em></li>
</ul>
<p>We infer that the solution to our problem is given by the vertex <em>B</em> with a maximum value of 87 units, namely <em>P1 = 45</em> and <em>P2 = 42</em>.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>In summary, producing 45 units of product P1 and 42 units of product P2 satisfies the machine’s hourly production constraint and the customer demand constraints, while maximizing total production.</p>
</blockquote>
<p>Did you ever think you could solve a linear optimization problem before today? Well, you’ve done it! Clearly, it is possible to solve these problems by hand when they are this simple. But when the number of decision variables grows, it is no longer possible to draw the feasible region and therefore it becomes impossible to locate the vertices in a multidimensional space by eye. In these cases, it is mathematics and, above all, the packages made available by the community for Python and R that allow us to find the solution to the problem. Let’s first look at a slightly more complex case of an LP problem.</p>
</section>
</section>
<section id="definition-of-the-lp-problem-to-solve" class="level2" data-number="11.6">
<h2 data-number="11.6">Definition of the LP problem to solve</h2>
<p>Now imagine that you are working for a company that needs to ship a product from different warehouses around the world to different countries. You have to hand the following:</p>
<ul>
<li><p>The quantities of product available in warehouses:</p>
<figure>
<img src="../media/file252.png" alt="Figure 10.18 – Quantities of product available in warehouses" /><figcaption aria-hidden="true">Figure 10.18 – Quantities of product available in warehouses</figcaption>
</figure></li>
<li><p>The quantities of product required by countries:</p>
<figure>
<img src="../media/file253.png" alt="Figure 10.19 – Quantities of product required by countries" /><figcaption aria-hidden="true">Figure 10.19 – Quantities of product required by countries</figcaption>
</figure></li>
<li>The shipping costs from each of the warehouses to all requesting countries:</li>
</ul>
<figure>
<img src="../media/file254.png" alt="Figure 10.20 – Costs from warehouses to countries" /><figcaption aria-hidden="true">Figure 10.20 – Costs from warehouses to countries</figcaption>
</figure>
<p>Your goal is to minimize your company’s costs by meeting all customer demands from different countries.</p>
<section id="formulating-the-lp-problem" class="level3" data-number="11.6.1">
<h3 data-number="11.6.1">Formulating the LP problem</h3>
<p>As seen in the previous section, you must first formulate the problem mathematically. Let’s use a couple of numerical indexes, <em>i</em> and <em>j</em>, to identify the quantities sent and costs. In detail, consider the quantity <em>x<sub>ij</sub></em> of product that is shipped from <em>Warehouse i</em> to <em>Country j</em> according to this matrix that defines the decision variables and costs:</p>
<figure>
<img src="../media/file255.png" alt="Figure 10.21 – Definition matrix of the quantity of products sent and costs" /><figcaption aria-hidden="true">Figure 10.21 – Definition matrix of the quantity of products sent and costs</figcaption>
</figure>
<p>The quantity <em>x<sub>ij</sub></em> is an integer and non-negative ().</p>
<p>Given the preceding definitions, the target of the problem is to minimize the objective function, which can be written as the sum of the product between the cost of shipping from <em>Warehouse i</em> to <em>Country j</em> (<em>Cij</em>) and the quantity of product shipped from <em>Warehouse i</em> to <em>Country j</em> (<em>xij</em>):</p>
<p>Written in full and organizing it by warehouses for reading convenience, taking the cost amounts from <em>Figure 10.21</em>, the previous objective function can be rewritten as follows:</p>
<p>To this point, you must formalize the constraints, which are of two types: the <em>warehouse supply constraints</em> and the <em>customer demand constraints</em>:</p>
<ul>
<li><strong>Warehouse supply constraints</strong>: Once a warehouse has been fixed (for example, the <em>Warehouse ITA</em>, for which <em>i = 1</em>), the sum of the products shipped from that warehouse to all countries (sum of <em>x<sub>1j</sub></em>) cannot exceed the maximum quantity of products contained in that warehouse (for <em>Warehouse ITA</em>, 50,000 products; see <em>Figure 10.18</em>). That is, for all six countries, we have the following:You will, therefore, have a similar constraint for each warehouse (four constraints in all).</li>
<li><strong>Customer demand constraints</strong>: Regardless of which warehouse the goods come from, you have to meet the demand for each country’s products. Therefore, the sum of the products sent from all the warehouses toward a given country (for example, <em>France</em>, for which <em>j = 2</em>) must be at least equal to the demand of that country (France demands at least 15,000 products; see <em>Figure 10.19</em>). And, therefore, considering all four warehouses, we have the following:You will, therefore, have a similar constraint for each country (six constraints in all).</li>
</ul>
<p>Therefore, the final linear optimization problem can be formulated as follows:</p>
<p>Awesome! You managed to formulate a non-trivial business problem in mathematical terms. Let’s now see how to solve it with Python.</p>
</section>
</section>
<section id="handling-optimization-problems-with-python" class="level2" data-number="11.7">
<h2 data-number="11.7">Handling optimization problems with Python</h2>
<p>As you’ve probably already figured out, the large community that develops Python packages never stands still. Even in this case, it provided a module that helps us solve linear optimization problems. Its name is <strong>PuLP</strong> (<a href="https://github.com/coin-or/pulp">https://github.com/coin-or/pulp</a>) and it is an LP modeler written in Python. It interfaces with the most common free and not-free engines that solve LP, <strong>Mixed Integer Programming</strong> (<strong>MIP</strong>), and other related problems, such as <strong>GNU Linear Programming Kit</strong> (<strong>GLPK</strong>), <strong>Coin-or Branch and Cut</strong> (<strong>CBC</strong>), which is the default one, and <strong>IBM ILOG CPLEX</strong>. Its use is quite straightforward. Let’s put it into practice right away with the problem from the previous section.</p>
<section id="solving-the-lp-problem-in-python" class="level3" data-number="11.7.1">
<h3 data-number="11.7.1">Solving the LP problem in Python</h3>
<p>The code that will be explained to you in this section can be found in the <code>03-linear-optimizaiont-in-python.py</code> file in the <code>Chapter10\Python</code> folder of the repository.</p>
<p>First, you have to install the <code>PuLP</code> module in your environment:</p>
<ol>
<li>Open Anaconda Prompt.</li>
<li>Enter the <code>conda activate pbi_powerquery_env</code> command.</li>
<li>Enter the <code>pip install pulp</code> command.</li>
</ol>
<p>After that, you can then define the values that will make up the constraints and costs using NumPy vectors and matrices:</p>
<pre><code>import pandas as pd
import numpy as np
import pulp as plp
warehouse_supply_df = pd.read_excel(r’D:\&lt;your-path&gt;\Chapter10\RetailData.xlsx’, sheet_name=’Warehouse Supply’, engine=’openpyxl’)
warehouse_supply = warehouse_supply_df[’product_qty’].to_numpy()
country_demands_df = pd.read_excel(r’D:\&lt;your-path&gt;\Chapter10\RetailData.xlsx’, sheet_name=’Country Demand’, engine=’openpyxl’)
country_demands = country_demands_df[’product_qty’].to_numpy()
cost_matrix_df = pd.read_excel(r’D:\&lt;your-path&gt;\Chapter10\RetailData.xlsx’, sheet_name=’Shipping Cost’, engine=’openpyxl’)
n_warehouses = cost_matrix_df.nunique()[’warehouse_name’]
n_countries = cost_matrix_df.nunique()[’country_name’]
cost_matrix = cost_matrix_df[’shipping_cost’].to_numpy().reshape(n_warehouses,n_countries)</code></pre>
<p>In the script file, you will also find the code to import the values directly from the <code>RetailData.xlsx</code> file in the <code>Chapter10</code> folder.</p>
<p>It is possible then to define an <code>LpProblem</code> object, giving it a name and the type of optimization you want to apply to the objective function (minimize or maximize):</p>
<pre><code>model = plp.LpProblem(“supply-demand-minimize-costs-problem”, plp.LpMinimize)</code></pre>
<p>To this empty object, you can add an objective function and constraints later.</p>
<p>In order to construct the objective function, we must first define the decision variables (<em>x<sub>ij</sub></em>) via the <code>LpVariable</code> function, which accepts the variable name, the full list of strings representing the variable indices, the category of the variable (continuous, integer, or binary), and any upper- or lower-bound values. The index list is simply constructed with a nested <strong>list comprehension</strong> (<a href="http://bit.ly/nested-list-comprehensions">http://bit.ly/nested-list-comprehensions</a>):</p>
<pre><code>var_indexes = [str(i)+str(j) for i in range(1, n_warehouses+1) for j in range(1, n_countries+1)]
print(“Variable indexes:”, var_indexes)</code></pre>
<p>This is the output as an example:</p>
<pre><code>Variable Indices: [’11’, ‘12’, ‘13’, ‘14’, ‘15’, ‘16’, ‘21’, ‘22’, ‘23’, ‘24’, ‘25’, ‘26’, ‘31’, ‘32’, ‘33’, ‘34’, ‘35’, ‘36’, ‘41’, ‘42’, ‘43’, ‘44’, ‘45’, ‘46’]</code></pre>
<p>It is now possible to easily define the decision variables as follows:</p>
<pre><code>decision_vars = plp.LpVariable.matrix(
name=”x”,
indexs=var_indexes,
cat=”Integer”,
lowBound=0 )</code></pre>
<p>Since the decision variables are to be multiplied by the <em>C<sub>ij</sub></em> costs defined earlier in <code>cost_matrix</code>, it is appropriate to format the <code>decision_vars</code> list in the same shape as the cost matrix in order to be able to perform element-wise multiplication, also known as the <strong>Hadamard product</strong>:</p>
<pre><code>shipping_mtx = np.array(decision_vars).reshape(n_warehouses,n_countries)
print(“Shipping quantities matrix:”)
print(shipping_mtx)</code></pre>
<p>It returns the following output:</p>
<pre><code>Shipping quantities matrix:
[[x_11 x_12 x_13 x_14 x_15 x_16]
[x_21 x_22 x_23 x_24 x_25 x_26]
[x_31 x_32 x_33 x_34 x_35 x_36]
[x_41 x_42 x_43 x_44 x_45 x_46]]</code></pre>
<p>The objective function is then defined as the sum of the element-wise product of cost and shipping matrices:</p>
<pre><code>objective_func = plp.lpSum(cost_matrix * shipping_mtx)
print(objective_func)</code></pre>
<p>The output is the following one:</p>
<pre><code>8*x_11 + 18*x_12 + 14*x_13 + 40*x_14 + 40*x_15 + 25*x_16 + 12*x_21 + 10*x_22 + 8*x_23 + 18*x_24 + 40*x_25 + 18*x_26 + 34*x_31 + 32*x_32 + 30*x_33 + 10*x_34 + 33*x_35 + 35*x_36 + 25*x_41 + 20*x_42 + 18*x_43 + 35*x_44 + 30*x_45 + 10*x_46</code></pre>
<p>If you remember correctly, this expression coincides with the objective function written in full that you saw in the previous section.</p>
<p>You can then add the objective function to the model, as follows:</p>
<pre><code>model += objective_func</code></pre>
<p>Constraint inequalities are also added in the same way:</p>
<pre><code>for i in range(n_warehouses):
model += plp.lpSum(shipping_mtx[i][j] for j in range(n_countries)) &lt;= warehouse_supply[i], “Warehouse supply constraints “ + str(i)
for j in range(n_countries):
model += plp.lpSum(shipping_mtx[i][j] for i in range(n_warehouses)) &gt;= country_demands[j] , “Country demand constraints “ + str(j)</code></pre>
<p>Finally, we can move on to solving the problem by running this simple script:</p>
<pre><code>model.solve()</code></pre>
<p>The first thing to do is to check the state of the solution, which can take the values <code>Optimal</code>, <code>Not Solved</code>, <code>Infeasible</code>, <code>Unbounded</code>, and <code>Undefined</code>:</p>
<pre><code>status = plp.LpStatus[model.status]
print(status)</code></pre>
<p>In our case, the state is <code>Optimal</code>, therefore an optimal solution has been found for the problem. So, let’s see what value the objective function takes on against the solution found:</p>
<pre><code>print(“Total Cost:”, model.objective.value())</code></pre>
<p>The value is equal to 2,270,000 euros, which corresponds to the lowest possible cost while satisfying all imposed constraints. If you want to see the solution values of the variables that make up the shipping matrix in a very readable way, you’d better transform them into a pandas dataframe:</p>
<pre><code>decision_var_results = np.empty(shape=(n_warehouses * n_countries))
z = 0
for v in model.variables():
try:
decision_var_results[z] = v.value()
z += 1
except:
print(“error couldn’t find value”)
decision_var_results = decision_var_results.reshape(n_warehouses,n_countries)
col_idxs = [’Italy’,’France’,’Germany’,’Japan’,’China’,’USA’]
row_idxs = [’Warehouse ITA’,’Warehouse DEU’,’Warehouse JPN’,’Warehouse USA’]
dv_res_df = pd.DataFrame(decision_var_results, columns=col_idxs, index=row_idxs)
dv_res_df</code></pre>
<p>The result that comes up is as follows:</p>
<figure>
<img src="../media/file256.png" alt="Figure 10.22 – Quantities shipped according to the solution found" /><figcaption aria-hidden="true">Figure 10.22 – Quantities shipped according to the solution found</figcaption>
</figure>
<p>It is easy to read, for example, that French customers must receive 10,000 units from the German warehouse and 5,000 units from the US warehouse to meet their demand.</p>
<p>If instead you want to check the total quantities shipped from each warehouse, you can run this code:</p>
<pre><code>warehouse_shipped_qty = np.zeros(shape=(n_warehouses))
z = 0
for i in range(n_warehouses):
warehouse_shipped_qty[z] = plp.lpSum(shipping_mtx[i][j].value() for j in range(n_countries)).value()
z += 1
w_shipped_df = pd.DataFrame(warehouse_shipped_qty, columns=[’qty’], index=row_idxs)
w_shipped_df</code></pre>
<p>You will get this result:</p>
<figure>
<img src="../media/file257.png" alt="Figure 10.23 – Total quantities shipped from each warehouse" /><figcaption aria-hidden="true">Figure 10.23 – Total quantities shipped from each warehouse</figcaption>
</figure>
<p>Impressive! You’ve managed to solve a non-simple linear optimization problem with just a few lines of Python code. Would you have guessed it? Let’s now look at how to apply what you learned in Power BI.</p>
</section>
<section id="solving-the-lp-problem-in-power-bi-with-python" class="level3" data-number="11.7.2">
<h3 data-number="11.7.2">Solving the LP problem in Power BI with Python</h3>
<p>Applying what we have just seen in Power BI is not as straightforward as in the other cases we have encountered in the last few chapters. To start, we have to have already loaded the data of country demand, warehouse supply, and shipping costs in the data model, which could arrive from any data source. In our case, we have them ready in Excel, so we will proceed to load them in Power BI Desktop:</p>
<ol>
<li>Click <strong>Excel Workbook</strong> on the ribbon (or <strong>Import data from Excel</strong> in the main canvas), select the <code>RetailData.xlsx</code> file in the <code>Chapter10</code> folder, and click <strong>Open</strong>.</li>
<li>Select the <strong>CountryDemand</strong>, <strong>ShippingCost</strong>, and <strong>WarehouseSupply</strong> tables (the ones with the blue header) and then click <strong>Transform data</strong>:</li>
</ol>
<figure>
<img src="../media/file258.png" alt="Figure 10.24 – Selecting the three tables from Excel" /><figcaption aria-hidden="true">Figure 10.24 – Selecting the three tables from Excel</figcaption>
</figure>
<p>You are now in the situation described previously. At this point, each of the three queries in Power Query has its own stack of steps that generated it:</p>
<figure>
<img src="../media/file259.png" alt="Figure 10.25 – The CountryDemand query with its stack of applied steps" /><figcaption aria-hidden="true">Figure 10.25 – The CountryDemand query with its stack of applied steps</figcaption>
</figure>
<p>In the previous section, you saw that in order to calculate the optimal allocations, <em>you need to be able to use all three datasets in one Python script</em>. If you add a Python script as a step in one of the three queries listed previously, you can only interact with the data from that single query in the script. How can you then create a script that can use all the data available? You have to resort to the following stratagem:</p>
<p>In order to use data belonging to more than one query in a Python script, you must first serialize each data structure derived from each of the three queries into a pickle file. Then, create a new query resulting from the merge of the three queries via joins (it is not necessary that the dataset resulting from the joins makes sense, since it will not be used). At this point, add a Python script step for this merge query, in which you deserialize all three previously serialized objects in each query. You will finally have the objects from three different data sources in one script.</p>
<p>This way, you make sure that the Python scripts that serialize the objects of the three datasets are executed first, and then the script that deserializes them is executed in order to solve the linear optimization problem.</p>
<p>Let’s see in detail how to accomplish what is described in the previous paragraphs:</p>
<ol>
<li>Select the <strong>CountryDemand</strong> query on the left, click on the <strong>Transform</strong> tab on the ribbon, and then click on <strong>Run Python Script</strong>.</li>
<li><p>Enter the following Python code in the script editor, then click <strong>OK</strong>:</p>
<pre><code>import pickle
country_demands = dataset[’product_qty’].to_numpy()
pickle.dump( country_demands, open(r”D:\&lt;your-path&gt;\Chapter10\Python\country_demands.pkl”, “wb”) )</code></pre></li>
<li>Click on <strong>Table</strong> under <strong>Value</strong> corresponding to <strong>dataset</strong>. You will always see the country demand data, but behind the scenes, a NumPy vector has been serialized with the name <code>country_demands.pkl</code> in the <code>Chapter10/Python</code> folder.</li>
<li>Select the <strong>ShippingCost</strong> query on the left, click on the <strong>Transform</strong> tab on the ribbon, and then click on <strong>Run Python Script</strong>.</li>
<li><p>Enter the following Python code in the script editor, then click <strong>OK</strong>:</p>
<pre><code>import pickle
n_warehouses = dataset.nunique()[’warehouse_name’]
n_countries = dataset.nunique()[’country_name’]
cost_matrix = dataset[’shipping_cost’].to_numpy().reshape(n_warehouses, n_countries)
pickle.dump( cost_matrix, open(r”D:\&lt;your-path&gt;\Chapter10\Python\cost_matrix.pkl”, “wb”) )</code></pre></li>
<li>Click on <strong>Table</strong> under <strong>Value</strong> corresponding to <strong>dataset</strong>. You will always see the cost matrix data, but behind the scenes, a NumPy vector has been serialized with the name <code>cost_matrix.pkl</code> in the <code>Chapter10/Python</code> folder.</li>
<li>Select the <strong>WarehouseSupply</strong> query on the left, click on the <strong>Transform</strong> tab on the ribbon, and then click on <strong>Run Python Script</strong>.</li>
<li><p>Enter the following Python code in the script editor, then click <strong>OK</strong>:</p>
<pre><code>import pickle
warehouse_supply = dataset[’product_qty’].to_numpy()
pickle.dump( warehouse_supply, open(r”D:\&lt;your-path&gt;\Chapter10\Python\warehouse_supply.pkl”, “wb”) )</code></pre></li>
<li>Click on <strong>Table</strong> under <strong>Value</strong> corresponding to <strong>dataset</strong>. You will always see the warehouse supply data, but behind the scenes, a NumPy vector has been serialized with the name <code>warehouse_supply.pkl</code> in the <code>Chapter10/Python</code> folder.</li>
<li>Right-click on the query panel on the left, select <strong>New Query</strong>, then <strong>Combine</strong>, then <strong>Merge Queries as New</strong>.</li>
<li>On the <strong>Merge</strong> window, select the <strong>CountryDemand</strong> and <strong>ShippingCost</strong> tables, click on the <code>country_name</code> column for both of them, and click <strong>OK</strong>.</li>
<li>The new <strong>Merge1</strong> query will appear. Click on it, expand the content of the <strong>ShippingCost</strong> column, and click <strong>OK</strong>.</li>
<li><p>Go to the <strong>Home</strong> tab, make sure that the <strong>Merge1</strong> query is selected, and click on <strong>Merge Queries</strong> in order to also merge <strong>WarehouseSupply</strong> too:</p>
<figure>
<img src="../media/file260.png" alt="Figure 10.26 – Merging another query to Merge1" /><figcaption aria-hidden="true">Figure 10.26 – Merging another query to Merge1</figcaption>
</figure></li>
<li>Select the <strong>WarehouseSupply</strong> table on the <strong>Merge</strong> window and click the <code>ShippingCost.warehouse_name</code> and <code>warehouse_name</code> columns on both of the tables, then click <strong>OK</strong>.</li>
<li>Expand the <strong>WarehouseSupply</strong> column, keep all selected, and click <strong>OK</strong>.</li>
<li>Click on the <strong>Transform</strong> tab on the ribbon, click on <strong>Run Python Script</strong>, and enter the script you can find into the <code>04-linear-optimization-in-power-bi-with-python.py</code> file in the <code>Chapter10\Python</code> folder.</li>
<li>You will get the following error: <strong>Formula.Firewall: Query ‘Merge1’ (step ‘Run Python script’) references other queries or steps, so it may not directly access a data source. Please rebuild this data combination</strong>.</li>
<li><p>Go to <strong>File</strong> and click <strong>Options and settings</strong> and then <strong>Options</strong>. On the <strong>Options</strong> window, select the <strong>Privacy</strong> tab and click on <strong>Always ignore Privacy Level settings</strong>:</p>
<figure>
<img src="../media/file261.png" alt="Figure 10.27 – Options in Privacy levels settings" /><figcaption aria-hidden="true">Figure 10.27 – Options in Privacy levels settings</figcaption>
</figure>
<p>You can do this safely because you are sure that you have set the permissions of all data sources to <strong>Organizational</strong>.</p></li>
<li><p>Go to the <strong>Home</strong> tab and click on <strong>Refresh Preview</strong>. After a few seconds, click on <strong>Table</strong> for the <code>result_df</code> dataframe:</p>
<figure>
<img src="../media/file262.png" alt="Figure 10.28 – Selecting the result_df table" /><figcaption aria-hidden="true">Figure 10.28 – Selecting the result_df table</figcaption>
</figure></li>
<li><p>You will see the contents of the following table, which shows the values of shipped quantities provided by the solution of the linear optimization problem for each combination of warehouse and country, and the corresponding cost:</p>
<figure>
<img src="../media/file263.png" alt="Figure 10.29 – Selecting the result_df table" /><figcaption aria-hidden="true">Figure 10.29 – Selecting the result_df table</figcaption>
</figure></li>
<li>Click on <strong>Close &amp; Apply</strong>.</li>
</ol>
<p>Remember that control over source privacy levels is disabled. You should turn it back on to <em>combine data according to each file’s privacy level settings</em> at the end of this project to be warned in case of possible data leaks due to query folding mechanisms (for more details, see the <em>References</em> section).</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>Also remember that if you want to publish your report to the Power BI service, the privacy level of all data sources must be set to <strong>Public</strong>.</p>
</blockquote>
<p>Did you know that everything you’ve seen about LP problems can also be implemented in R? Let’s see how to do it.</p>
</section>
</section>
<section id="solving-lp-problems-with-r" class="level2" data-number="11.8">
<h2 data-number="11.8">Solving LP problems with R</h2>
<p>If the Python community is very active, certainly the R community is not standing still! In fact, the <strong>Optimization Modeling Package</strong> (<strong>OMPR</strong>) is available (<a href="https://dirkschumacher.github.io/ompr/">https://dirkschumacher.github.io/ompr/</a>), which is a domain-specific language created to model and solve LP problems in R.</p>
<p>In general, all other packages developed in R that serve the same purpose are mostly matrix-oriented, forcing you to transform all objects into matrices and vectors before passing them to the solver. This task may seem simple enough at first glance, but when the problems to be solved become complex, it may become difficult to write R code to solve them.</p>
<p>The <code>ompr</code> package, on the other hand, provides enough expressive power to allow you to model your LP problems incrementally, thanks also to the use of the <code>%&gt;%</code> pipe. Therefore, you will feel like you are writing code as if you were using <code>dplyr</code> functions, forgetting about matrices and vectors.</p>
<p>In addition, the <code>ompr</code> package relies on another package called <code>ompr.roi</code> to be able to select the engine of preference for solving LP problems. This package uses, behind the scenes, a sophisticated framework for handling linear and non-linear optimization problems in R called <strong>R Optimization Infrastructure</strong> (<strong>ROI</strong>), provided by another package called <code>ROI</code> itself (<a href="http://roi.r-forge.r-project.org/">http://roi.r-forge.r-project.org/</a>).</p>
<p>In our examples, we’ll use the <strong>GLPK</strong> solver added as a plugin by <strong>ROI</strong>.</p>
<p>So, let’s see how to set up the LP problem we described in the previous sections in R using the <code>ompr</code> package.</p>
<section id="solving-the-lp-problem-in-r" class="level3" data-number="11.8.1">
<h3 data-number="11.8.1">Solving the LP problem in R</h3>
<p>First, you need to install the packages necessary for the correct functioning of <code>ompr</code>. Therefore, follow these steps:</p>
<ol>
<li>Open RStudio and make sure it is referencing your latest CRAN R version (version 4.0.2 in our case).</li>
<li>Click on the <strong>Console</strong> window and enter this command: <code>install.packages(‘ompr’)</code>. Then, press <em>Enter</em>.</li>
<li>Enter this command: <code>install.packages(‘ompr.roi’)</code>. Then, press <em>Enter</em>.</li>
<li>Enter this command: <code>install.packages(‘ROI.plugin.glpk’)</code>. Then, press <em>Enter</em>.</li>
</ol>
<p>You can find all the code that will be shown as follows in the <code>03-linear-optimization-in-r.R</code> file in the <code>Chapter10\R</code> folder.</p>
<p>First, you need to import the needed packages and the data from the Excel <code>RetailData.xlsx</code> file that you find in the <code>Chapter10</code> folder:</p>
<pre><code>library(dplyr)
library(tidyr)
library(readxl)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)
warehouse_supply_tbl = read_xlsx(r’{D:\&lt;your-path&gt;\Chapter10\RetailData.xlsx}’, sheet = ‘Warehouse Supply’)
country_demands_tbl = read_xlsx(r’{D:\&lt;your-path&gt;\Chapter10\RetailData.xlsx}’, sheet = ‘Country Demand’)
cost_matrix_tbl = read_xlsx(r’{D:\&lt;your-path&gt;\Chapter10\RetailData.xlsx}’, sheet = ‘Shipping Cost’)</code></pre>
<p>After that, you can compute the arrays and cost matrix from the tibbles, which are needed to then set up the model with <code>ompr</code>:</p>
<pre><code>n_warehouses &lt;- cost_matrix_tbl %&gt;% 
distinct(warehouse_name) %&gt;% 
count() %&gt;% 
pull(n)
n_countries &lt;- cost_matrix_tbl %&gt;% 
distinct(country_name) %&gt;% 
count() %&gt;% 
pull(n)
warehouse_supply &lt;- warehouse_supply_tbl %&gt;% 
pull(product_qty)
country_demands &lt;- country_demands_tbl %&gt;% 
pull(product_qty)
cost_matrix &lt;- data.matrix(
cost_matrix_tbl %&gt;% 
pivot_wider( names_from = country_name, values_from = shipping_cost ) %&gt;% 
select( -warehouse_name )
)
rownames(cost_matrix) &lt;- warehouse_supply_tbl %&gt;% pull(warehouse_name)</code></pre>
<p>In order to switch from the vertical form of the cost data in the <code>cost_matrix_tbl</code> tibble to the horizontal form, we used the very convenient <code>pivot_wider()</code> function provided by the <code>tidyr</code> package.</p>
<p>At this point, defining the model using the functions exposed by <code>ompr</code> is almost straightforward if we follow the mathematical model we showed in the <em>Formulating the LP problem</em> section:</p>
<pre><code>model &lt;- MIPModel() %&gt;% 
# define the x integer variables, paying attention to define also the lower bound of 0
add_variable( x[i, j], i = 1:n_warehouses, j = 1:n_countries, type = “integer”, lb = 0 ) %&gt;% 
# define the objective function, declaring also the “sense” that is the type of problem (minimize)
set_objective( sum_expr(cost_matrix[i, j] * x[i, j], i = 1:n_warehouses, j = 1:n_countries), sense = ‘min’ ) %&gt;% 
# add warehouse supply constraints
add_constraint( sum_expr(x[i, j], j = 1:n_countries) &lt;= warehouse_supply[i], i = 1:n_warehouses ) %&gt;% 
# add customer demand constraints
add_constraint( sum_expr(x[i, j], i = 1:n_warehouses) &gt;= country_demands[j], j = 1:n_countries )</code></pre>
<p>The <code>sum_expr()</code> function may seem incomprehensible at first glance. Let’s take this piece of code as an example:</p>
<pre><code>sum_expr(x[i, j], j = 1:n_countries)</code></pre>
<p>It can be read in full as follows: <em>Take the decision variables x[i,j] obtained by substituting values ranging from 1 to n_countries (that is, 6) for j, then sum the resulting variables together</em>. In summary, you are asking to calculate this:</p>
<pre><code>x[i,1] + x[i,2] + x[i,3] + x[i,4] + x[i,5] + x[i,6]</code></pre>
<p>At this point, once the model is defined, you can solve it using the <code>glpk</code> solver with this code:</p>
<pre><code>result &lt;- model %&gt;% 
solve_model(with_ROI(solver = ‘glpk’))</code></pre>
<p>The results obtained coincide (obviously, since the solution is optimal) with those already seen using Python’s <code>PuLP</code> module:</p>
<pre><code>decision_var_results &lt;- matrix(result$solution, nrow = n_warehouses, ncol = n_countries, )
rownames(decision_var_results) &lt;- warehouse_supply_tbl %&gt;% pull(warehouse_name)
colnames(decision_var_results) &lt;- country_demands_tbl %&gt;% pull(country_name)
decision_var_results</code></pre>
<p>You will surely recognize the solution already seen before:</p>
<pre><code>              Italy France Germany Japan China   USA
Warehouse ITA 40000      0   10000     0     0     0
Warehouse DEU     0  10000   15000  5000     0     0
Warehouse JPN     0      0       0 40000     0     0
Warehouse USA     0   5000       0     0 25000 25000</code></pre>
<p>Did you see that you were able to solve an LP problem in R as well? Nothing exceptionally complex, right? Very good!</p>
<p>Let’s now apply what we saw in Power BI.</p>
</section>
<section id="solving-the-lp-problem-in-power-bi-with-r" class="level3" data-number="11.8.2">
<h3 data-number="11.8.2">Solving the LP problem in Power BI with R</h3>
<p>The implementation complexities of solving our LP problem in Power BI have already been exposed in the <em>Solving the LP problem in Power BI with Python</em> section. We will therefore proceed here with the individual steps using R, without dwelling on the details:</p>
<ol>
<li>Open Power BI Desktop and make sure the privacy is set to <strong>Always ignore Privacy Level settings</strong> in <strong>Options</strong>.</li>
<li>Click <strong>Excel Workbook</strong> on the ribbon (or <strong>Import data from Excel</strong> in the main canvas), select the <code>RetailData.xlsx</code> file in the <code>Chapter10</code> folder, and click <strong>Open</strong>.</li>
<li><p>Select the <strong>CountryDemand</strong>, <strong>ShippingCost</strong>, and <strong>WarehouseSupply</strong> tables (the ones with a blue header) and then click <strong>Transform Data</strong>:</p>
<figure>
<img src="../media/file264.png" alt="Figure 10.30 – Selecting the three tables from Excel" /><figcaption aria-hidden="true">Figure 10.30 – Selecting the three tables from Excel</figcaption>
</figure></li>
<li>Select the <strong>CountryDemand</strong> query on the left, click on the <strong>Transform</strong> tab on the ribbon, and then click on <strong>Run R Script</strong>.</li>
<li><p>Enter the following R code in the script editor (change the path properly), then click <strong>OK</strong>:</p>
<pre><code>library(dplyr)
country_demands &lt;- dataset %&gt;% 
pull(product_qty)
saveRDS(country_demands, r’{D:\&lt;your-path&gt;\Chapter10\R\country_demands.rds}’)
country_demand_df &lt;- dataset</code></pre>
<p>You will see the country demand data, but behind the scenes, a vector has been serialized with the name <code>country_demands.rds</code> in the <code>Chapter10/R</code> folder.</p></li>
<li>Select the <strong>ShippingCost</strong> query on the left, click on the <strong>Transform</strong> tab on the ribbon, and then click on <strong>Run R Script</strong>.</li>
<li><p>Enter the following R code in the script editor, then click <strong>OK</strong>:</p>
<pre><code>library(dplyr)
library(tidyr)
n_warehouses &lt;- dataset %&gt;% 
distinct(warehouse_name) %&gt;% 
count() %&gt;% 
pull(n)
n_countries &lt;- dataset %&gt;% 
distinct(country_name) %&gt;% 
count() %&gt;% 
pull(n)
cost_matrix &lt;- data.matrix(
dataset %&gt;% 
pivot_wider( names_from = country_name, values_from = shipping_cost ) %&gt;% 
select( -warehouse_name )
)
rownames(cost_matrix) &lt;- dataset %&gt;% 
distinct(warehouse_name) %&gt;% 
pull(warehouse_name)
saveRDS(cost_matrix, r’{D:\&lt;your-path&gt;\Chapter10\R\cost_matrix.rds}’)
cost_matrix &lt;- dataset</code></pre>
<p>You will see the cost matrix data, but behind the scenes, a matrix has been serialized with the name <code>cost_matrix.rds</code> in the <code>Chapter10/R</code> folder.</p></li>
<li>Select the <strong>WarehouseSupply</strong> query on the left, click on the <strong>Transform</strong> tab on the ribbon, and then click on <strong>Run R Script</strong>.</li>
<li><p>Enter the following R code in the script editor, then click <strong>OK</strong>:</p>
<pre><code>library(dplyr)
warehouse_supply &lt;- dataset %&gt;% 
pull(product_qty)
saveRDS(warehouse_supply, r’{D:\&lt;your-path&gt;\Chapter10\R\warehouse_supply.rds}’)
warehouse_supply_df &lt;- dataset</code></pre>
<p>You will see the warehouse supply data, but behind the scenes, a vector has been serialized with the name <code>warehouse_supply.rds</code> in the <code>Chapter10/R</code> folder.</p></li>
<li>Right-click on the query panel on the left, select <strong>New Query</strong>, then <strong>Combine</strong>, then <strong>Merge Queries as New</strong>.</li>
<li>On the <strong>Merge</strong> window, select the <strong>CountryDemand</strong> and <strong>ShippingCost</strong> tables, then select the <code>country_name</code> column for both of them and click <strong>OK</strong>.</li>
<li>A new <strong>Merge1</strong> query will appear. Click on it, expand the content of the <strong>ShippingCost</strong> table, and click <strong>OK</strong>.</li>
<li>Go to the <strong>Home</strong> tab, make sure that the <strong>Merge1</strong> query is selected, and click on <strong>Merge Queries</strong> in order to also merge <strong>WarehouseSupply</strong> too.</li>
<li>Select the <strong>WarehouseSupply</strong> table on the <strong>Merge</strong> window and click the <code>ShippingCost.warehouse_name</code> and <code>warehouse_name</code> columns on both of the tables, then click <strong>OK</strong>.</li>
<li>Expand the <strong>WarehouseSupply</strong> column and click <strong>OK</strong>.</li>
<li>Click on the <strong>Transform</strong> tab on the ribbon, click on <strong>Run R Script</strong>, and enter the script, which you can find in the <code>04-linear-optimization-in-power-bi-with-r.R</code> file in the <code>Chapter10\R</code> folder.</li>
<li><p>You will see the contents of the following table, which shows the values of shipped quantities provided by the solution of the linear optimization problem for each combination of warehouse and country, and the corresponding cost:</p>
<figure>
<img src="../media/file265.png" alt="Figure 10.31 – Contents of the WarehouseSupply table" /><figcaption aria-hidden="true">Figure 10.31 – Contents of the WarehouseSupply table</figcaption>
</figure></li>
<li>Click on <strong>Close &amp; Apply</strong>.</li>
</ol>
<p>Remember that control over source privacy levels is disabled. You should turn it back on to <em>combine data according to each file’s privacy level settings</em> at the end of this project to be warned in case of possible data leaks due to query folding mechanisms (for more details, see the <em>References</em> section).</p>
</section>
</section>
<section id="summary-9" class="level2" data-number="11.9">
<h2 data-number="11.9">Summary</h2>
<p>In this chapter, you learned how to calculate distances between two geographic points according to the most commonly used definitions in spherical trigonometry using Python and R. You then applied this knowledge to a real-world case in Power BI.</p>
<p>You also learned how to solve the simplest LP problems through some Python and R packages. Again, you applied what you learned to a real-world case in Power BI.</p>
<p>In the next chapter, you’ll see how to add some salt to your business analytics thanks to statistics.</p>
</section>
<section id="references-6" class="level2" data-number="11.10">
<h2 data-number="11.10">References</h2>
<p>For additional reading, check out the following books and articles:</p>
<ul>
<li><em>On Spherical Trigonometry</em> (<a href="http://www.robingilbert.com/blog/2017-10-01-on-spherical-trigonometry/">http://www.robingilbert.com/blog/2017-10-01-on-spherical-trigonometry/</a>)</li>
<li><em>Calculate the Distance Between Two GPS Points with Python (Vincenty’s Inverse Formula)</em> (<a href="https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/">https://nathanrooy.github.io/posts/2016-12-18/vincenty-formula-with-python/</a>)</li>
<li><em>Vectorization and parallelization in Python with NumPy and pandas</em> (<a href="https://datascience.blog.wzb.eu/2018/02/02/vectorization-and-parallelization-in-python-with-numpy-and-pandas/">https://datascience.blog.wzb.eu/2018/02/02/vectorization-and-parallelization-in-python-with-numpy-and-pandas/</a>)</li>
<li><em>Behind the scenes of the Data Privacy Firewall</em> (<a href="https://docs.microsoft.com/en-us/power-query/dataprivacyfirewall">https://docs.microsoft.com/en-us/power-query/dataprivacyfirewall</a>)</li>
</ul>
</section>
</section>
</body>
</html>
