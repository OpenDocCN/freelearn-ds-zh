- en: Chapter 6. Answering Questions with Visibility Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visibility analysis is a valuable part of GIS analysis that answers questions
    such as "What can be seen from this location point?" In this chapter, you will
    be exposed to the basics of visibility analysis through defining the roof that
    provides the most scenic view of an area, and where the viewing platform can potentially
    be located. Throughout the chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare data to represent urban landscape features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select potential observation points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute the viewsheds to find the most scenic points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present the results in a 3D scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start, we will explore some essential principles of viewshed analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of visibility analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim of visibility analysis is to produce a coverage of an area that can
    be seen from a specified location. This coverage is called a **viewshed**, which
    is why the terms **visibility analysis** and **viewshed analysis** are used interchangeably.
    To perform a simple visibility analysis, you need to define at least two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observation point**: A point that represents an observer''s position and
    for which visibility is being analyzed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DEM**: This represents irregularities in the earth''s surface and is used
    to examine visibility along the line of sight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The idea underlying the process of this analysis is to compare the height of
    the observation point against the height of earth''s surface point along the given
    line of sight. If the height of the surface point is less than that of the observation
    point, then it will be seen from the current position; if it is higher, the visibility
    line will be blocked. Similarly, all points within a certain radius are compared
    against the observation point and divided into the two categories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Visible, with the height lower than the observation height and located below
    the visibility line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invisible, with the height higher than the observation height and located above
    the visibility line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main output of visibility analysis is a binary true/false viewshed coverage
    that usually includes visible points and excludes invisible points. Depending
    on the algorithm used and the capacity of GIS, this basic analytical approach
    can be modified and improved by the following features and outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a single observation point, multiple points and even lines can be
    used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visibility relationships between several objects can be analyzed, and then intervisibility
    coverage is produced as the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversely to the assessment of a viewshed for the current observation point,
    the earth's surface can be analyzed to provide information about points and areas
    from which a certain object can be seen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line of the horizon can be modeled as the cumulative edge of visibility zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views can be bound by a horizontal or vertical viewing angle or azimuthal values
    that limit extension of visibility lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The earth's curvature and atmospheric refraction can be taken into account to
    simulate more realistic results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most typical practical application of visibility analysis is in placement
    of communication towers, where instead of visibility, signal penetration is modeled.
    Viewsheds are also of great use in territorial and urban planning. For example,
    some features such as factories or landfills are expected to be hidden from the
    human' eye because of their unsightly appearance. In this case, the area undergoes
    a visibility analysis to find places from where such kinds of objects can't be
    seen. The more the blind spots associated with a certain point, the better it
    is for the object's location. Furthermore, instead of hiding some objects, viewsheds
    are used to detect scenery points that provide the most spectacular view of an
    area. This knowledge is then used for optimal placement of the sight places, which
    is what we are going to do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – converting a buildings' vector layer to raster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to deal with a highly urbanized landscape, whose primary features
    have been greatly transformed by humans. In the context of visibility analysis,
    this means that lines of sight are blocked mainly by buildings, while the original
    relief features play only a minor role. In our dataset, we have two layers that
    describe the area of interest, exterior, and appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lidar_dem`: This represents the bare earth only, and provides a description
    of the general relief'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`building_footprints`: These are polygons that depict all buildings, and they
    also contain information about a building''s height in feet above the bare earth''s
    surface in the `height_roo` attribute field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to add their values in order to obtain a meaningful result, but these
    layers use different data models: DEM is a raster coverage, and building footprints
    is a vector polygon layer. That is why before adding them, we should first take
    layers to a single common data model. In GIS, calculations for coverages are typically
    performed using raster algebra, which means that the `building_footprints` vector
    layer should be converted into a raster, or rasterized. Additionally, if we want
    this raster layer to contain data about building''s height, the `height_roo` attribute
    field should be used as the provider of *Z* values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also important that a newly created building footprint''s raster has
    the same extent and resolution as `lidar_dem`. To get this information about `lidar_dem`,
    go to **Layer Properties** | **Metadata**. At the bottom of the window, you will
    see the **Properties** scrolling window section, which contains all of the information
    important to know in order to work with rasters, namely **Band 1** (statistics),
    **Dimensions** (number of rows and columns), **Origin** (coordinates of the bottom-left
    corner), and so on. The parameters of particular interest to us are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pixel Size**: This contains the vertical and horizontal lengths of the pixel''s
    sides. Usually, the values are equal, which means that the pixel is a square;
    but sometimes, it can be rectangular, with unequal values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer extent (layer original source projection)**: This represents the minimum
    and maximum horizontal (*x*) and vertical (*y*) values of the raster extent, that
    is, the raster bounding box''s northern, southern, eastern, and western limits
    in the layer''s original coordinate reference system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the described parameters for the `lidar_dem`
    layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 – converting a buildings'' vector layer to raster](img/image00442.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To rasterize a layer, go to **Raster** | **Conversion** | **Rasterize (Vector
    to Raster)**. In the dialog window, adjust the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input file (shapefile)**: This is a shapefile to be rasterized. Select `building_footprints`
    from the drop-down list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Attribute field**: This defines an attribute field with the values to be
    burned into an output raster. Select `HEIGHT_ROO` from the drop-down list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Output file for rasterized vectors (raster)**: There are two possible options
    in this field. You can select an already existing file, and patches of vector
    geometry footprints with the selected values will be burned into it. It is very
    convenient if you have, for example, some gaps in the original raster layer and
    want to fill them with some values from the vector layer (such as elevation and
    surface level of water bodies). But we have to deal with the buildings'' relative
    height above the bare earth level. This means that, in order to summarize them
    with DEM, building footprints should be rasterized as an individual layer. Navigate
    to your working directory and type `building.tif` as a new layer name. You will
    be shown this message: **The output file doesn''t exist. You must set up the output
    size or resolution to create it.**. Click on **OK** and proceed to the following
    stage:![Step 1 – converting a buildings'' vector layer to raster](img/image00443.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the previous steps, you defined some major options. As we need to create
    a raster with exactly the same extent and resolution as `lidar_dem.tif`, we will
    use advanced options by editing the `gdal_rasterize` command-line parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Edit**![Step 1 – converting a buildings' vector layer to raster](img/image00444.jpeg)
    button to make the line editable. All the previous options will be deactivated
    and grayed out.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `–ts 3000 3000` option, as we are going to specify a resolution parameter
    that makes raster width and height parameters that are defined by `–ts` meaningless.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `–init 0` parameter defines the initial values of the output raster. It
    creates an empty raster with initially predefined values, and then vector values
    are burned into it. In our case, this means that building-free areas will be assigned
    zero values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The target extent is defined by the `–te` parameter described by space-separated
    bounding box values (**Xmin**, **Ymin**, **Xmax**, and **Ymax**) in georeferenced
    units. If you want to use a predefined extent, just copy its values from a piece
    of correspondent raster metadata. Don't forget to replace the commas and semicolons
    with spaces.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The target resolution (`–tr`) parameter defines the vertical and horizontal
    pixel size in units specified by the layer's CRS.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The output data type is defined by the `–ot` parameter, whose default value
    is `Float64`, but we replace it by `Float32`, which is the same as that for `lidar_dem.tif`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting line will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To convert a vector to a raster, we have used a tool called `gdal_rasterize`
    from the **Geospatial Data Abstraction Library** (**GDAL**). You can read an extended
    synopsis of the `gdal_raserize` parameters and their values from [http://www.gdal.org/gdal_rasterize.html](http://www.gdal.org/gdal_rasterize.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'After hitting **OK**, the resulting raster will be created and added to the
    map canvas. If you click on any pixel with the **Identify Features** tool selected,
    a height value of the building will be displayed, and if you click on an empty
    space, it will show `0`. The layer itself will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 – converting a buildings'' vector layer to raster](img/image00445.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Step 2 – combining the DEM and buildings layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need to combine the two layers into a single layer by adding their values.
    **Raster algebra** is a common approach to overlaying a raster layer (or layers),
    combining their values using algebraic operations (addition, subtraction, multiplication,
    division, and so on), and calculating values for a new raster layer. Modern GIS
    software uses so-called raster calculators that help create, validate, and apply
    raster algebra expressions to raster datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'QGIS also has its own raster calculator located at **Raster** | **Raster Calculator**.
    The **Calculator** dialog window consists of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raster bands**: In the top-left corner of the window, you can see the list
    of all rasters available in the project. The raster band number is separated from
    its name by an `@` sign. If the layer is a single-band raster, then only `name@1`
    appears in the list, but if it is a multiband raster, then `name@1`, `name@2`,
    and so on up to `name@n` (where *n* is the total number of bands in the multiband
    raster) will be shown for each band separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result layer**: In the top-right part of the calculator window, you can adjust
    the output raster properties. The **Current layer extent** button sets up an output
    extent from the raster layer that is currently selected in the **Raster bands**
    list on the left side. It is very useful when you are working with layers that
    have different extents, and allows you to decide which extent to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operators**: In the central part of the window, there are various operator
    buttons that can be used to construct expressions. Click on the relevant button
    to add an operator, or type it manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raster calculator expression**: In the bottom part of the calculator, there
    is the expression window, where the calculation formula to be used is displayed.
    Double-click on the relevant layer to add it to the expression (it will be shown
    in double quotes). Note that for the expression, we type only the right side of
    the calculation formula, which comes after the equal to sign. Under the expression,
    you will see the **Expression valid/ invalid** message change dynamically, and
    this helps you control the correctness of the constructed formula.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see that we apply a simple addition formula
    (`"building@1" + "liadar_dem@1"`) to combine rasterized buildings'' heights and
    DEM layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 – combining the DEM and buildings layers](img/image00446.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you''ve clicked on the **OK** button, the calculation is performed and
    a newly created `urban_surface` raster appears in the **Layers** panel. Now, we
    can check its values with the **Identify features** tool ![Step 2 – combining
    the DEM and buildings layers](img/image00447.jpeg):'
  prefs: []
  type: TYPE_NORMAL
- en: Uncheck all unnecessary layers except those from `urban_surface`, `building`,
    and `lidar_dem`. Maintaining their order simplifies the interpretation of **Identify
    Results**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Identify Results** tab. From the **Mode** drop-down list, select
    **Top down**. The identified values will be shown for all the active layers in
    order, from top to bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **View** drop-down list, select **Table**. The identified values will
    be organized into a simple table, as shown in this screenshot:![Step 2 – combining
    the DEM and buildings layers](img/image00448.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, by clicking on any point in the map canvas, you can explore values and
    make sure that they have been added properly.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – defining observation points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Observation points play an important role in visual exploration of modern cityscapes.
    Usually, they are represented by the highest points in an area that provide the
    most spectacular views. Therefore, viewing platforms in the city are usually located
    on rooftops. In this section, we are going to create a layer that contains several
    prospective viewing platforms through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an empty vector layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populating it with some points that represent the highest buildings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing them with the information on height from the `buildings_footprint`
    layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating an empty vector layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a vector layer, go to **Layer** | **Create layer**. There are three
    options available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Shapefile Layer**: Also accessible by the *Ctrl* + *Shift* + *N* keyboard
    shortcut, this creates a new empty shapefile layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New SpatiaLite Layer**: Also accessible by the *Ctrl* + *Shift* + *A* keyboard
    shortcut, this creates an empty SpatiaLite layer within a specified SpatiaLite
    database (by default, a currently connected database is specified).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New Temporary Scratch Layer**: This creates a temporary layer that can be
    used and analyzed like any other layer within a working session, but the layer
    will disappear if it is not saved before closing the project. These layers are
    meant to be drafts, and using them for testing purposes prevents cluttering your
    project. This is the option we will use to create an empty layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, you can use a relevant button from the **Manage Layers** toolbar
    and the small triangle beside it to get access to the options, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an empty vector layer](img/image00449.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After selecting **New Temporary Scratch Layer**, you will see this dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an empty vector layer](img/image00450.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider the options in the **New Temporary Scratch Layer** window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layer name**: Type in a name or leave the default as it is, because we are
    going to use the layer for temporary work and its name really doesn''t matter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: This defines the geometry type. As we are going to set up observation
    points, the default **Point** option is suitable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selected CRS**: A default projection is selected, but you need to set up
    a projection of your project in order for the layer to be processed correctly.
    To do so, select the **Project CRS** option from the drop-down combobox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After clicking on **OK**, a **New scratch layer** will be added to the **Layers**
    panel. By default, editing mode for the layer is activated (you can see it as
    a little pencil drawn above its marker symbol beside the layer's name) as shown
    in the following screenshot. Now we can proceed to the next stage and add some
    points to it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an empty vector layer](img/image00451.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Populating a layer with points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activate the **Digitizing** toolbar, if it has not already been done. You can
    do this by going to **View** | **Toolbars** | **Digitizing**, or simply by right-clicking
    somewhere on the toolbar''s panel and activating the relevant toggle. The toolbar
    contains the primary digitizing tools, and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating a layer with points](img/image00452.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This panel''s buttons provide access to the following options (from left to
    right):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current edits**: This maintains edits within a current editing session for
    the selected layer (or layers). Click on the little black triangle in the bottom-right
    corner of the button to access the **Save**, **Rollback**, or **Cancel** options
    for your edits. Note that these options are available until the **Save Layer Edits**
    button isn''t clicked on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toggle Editing**: This button activates/deactivates the editing mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Save Layer Edits**: This saves all the current edits without exiting the
    editing session. After clicking on this button, edits cannot be rolled back. It
    is inactive when there are no edits to save.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add Feature**: Use this button to draw new features on the layer. Its appearance
    depends on layer''s geometry type. Currently, it shows points because you are
    editing a point layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move Feature(s)**: When this button is selected, you can move one or several
    features. It is important to note that if you are going to move multiple features,
    they should have been previously selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node Tool**: This tool is used to add, remove, or move vertices of geometric
    features such as lines and polygons. It is unnecessary for a point layer and is
    therefore inaccessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete Selected**: This deletes the previously selected feature (or features).
    Until the edits are saved, they can be rolled back through the **Current Edits**
    button options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cut/ Copy/ Paste Features**: Similarly to other kinds of software, you can
    use these buttons to cut or copy features onto the clipboard and then paste them.
    Features must be previously selected if you want to apply these options. While
    **Cut** and **Paste** are available only in editing mode, **Copy** can be used
    with any other layer, and is of great use when moving features between layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use more complex digitizing tools and options, such as feature
    rotation, simplification, adding parts and rings, and so on. These are available
    from the **Advanced Digitizing** panel, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Populating a layer with points](img/image00453.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Moreover, the panel provides access to input tools that are similar to those
    used in **computer-aided design** (**CAD**) systems. These tools allow digitizing
    with precise numerical values of coordinates, distances, and angles; control segments;
    parallelism; and perpendicularity, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Populating a layer with points](img/image00454.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now that you are familiar with the **Digitizing** toolbar, **Toggle editing**,
    and using **Add Feature**, click on different places to locate some observation
    points. Remember that these points should be placed on the footprints of the highest
    buildings. It is recommended to use the previously created `urban_surface` raster
    as a background, as it helps locate the points properly. Now, add several points
    (five to seven are enough) by clicking on the map canvas. Click on the **Toggle
    editing** button to exit editing mode. Click on the **Save** button when you are
    asked about edits. As a result, your map will look similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating a layer with points](img/image00455.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Providing points with height values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are going to locate viewing platforms on the rooftops, taking into account
    the height of the building is of great importance to obtain realistic modeling
    results. Instead of looking for the necessary building and its height and adding
    the height value to the visibility points manually, we will automatically join
    attributes, taking into account the locations of the points. This operation—when
    you merge attributes from two different layers based on their spatial relationship—is
    very common in GIS and is called a **spatial join**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to **Vector** | **Data Management Tools** | **Join Attributes by Location**.
    In the dialog window, the following options are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target vector layer**: The layer to which attributes will be joined; in our
    case, it''s **New scratch layer**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Join vector layer**: The layer from which attributes will be taken; in our
    case, it is `building_footprints`.![Providing points with height values](img/image00456.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute Summary** deals with multiple attribute values available for joining.
    The **Take attributes of first located feature** option joins a single value,
    and this is the default action that we select. Optionally, you can activate **Take
    summary of intersection features** and select one or several summarizing functions
    (**Mean**, **Min**, **Max**, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output Shapefile** provides the path to the resulting vector layer. Click
    on the **Browse** button to select the necessary directory and type a name, for
    example, `observ_points`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output table** is responsible for the number of records in the resulting
    attribute table. We leave the **Only keep matching records** default option as
    selected because we only need records of buildings that match with the observation
    points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After clicking on **OK** and completing the spatial join, you will be informed
    that a new layer has been created and asked, "Would you like to add the new layer
    to the TOC?" Click on **Yes**, and the layer will be loaded and appear in the
    map canvas. Click on the **Close** button to exit the **Join attributes by location**
    dialog window.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you open the `observ_point` attribute table, you will see that all the
    attributes from matching buildings in the `building_footprint` layer have been
    joined to the points. This tool may be of great use when working with a large
    number of entities.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – creating viewshed coverages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply the advanced visibility analysis tools that are
    available from the **Viewshed Analysis** plugin. Install it as described in the
    *Extending functionality through plugins* section of [Chapter 1](part0014.xhtml#aid-DB7S2
    "Chapter 1. Handling Your Data"), *Handling Your Data*.
  prefs: []
  type: TYPE_NORMAL
- en: After the plugin has been installed, you can get access to its functionality
    by going to **Plugin** | **Viewshed Analysis**. The **Advanced viewshed analysis**
    dialog window consists of three tabs. The **General** tab provides access to all
    the available analysis and output options. The **Reference** tab contains brief
    descriptions of the options and a link to the project's homepage, where you can
    read detailed information about the algorithm implemented in the plugin and report
    bugs, if any. The **About** tab contains brief information about the author and
    the plugin's homepage link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following options under the **General** tab to create viewshed coverages,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elevation raster**: Select the `urban_surface` raster to represent the earth''s
    surface and buildings on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observation points**: Select the `observ_points` point layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output file**: Click on the **Browse** button, navigate to the working directory,
    and type a name for the output raster layer. Note that one output raster file
    will be created for each observation point, and the typed filename will be used
    as a template that will be accompanied by the output coverage type (viewshed,
    intervisibility, invisibility, and horizon) and index number. For this reason,
    we call the output layer `coverage`, presuming that the explanatory parameters
    (coverage type and point number) will be added automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our goal is to find the point (or points) of the most scenic view, so there
    is no need to analyze the points' intervisibility. Hence, the **Target points**
    (intervisibility) field is omitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Search radius**: This is the size of the area observed around a point in
    the layer''s measurement units (feet in our case). The higher the value, the longer
    the time taken to produce coverages. Accept the default value of 5000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer height**: This defines the height of an observation point above
    the earth''s surface. Usually, the higher the point, the better the observation.
    Instead of the predefined height, select `HEIGHT_ROO` from the field drop-down
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target height**: This is necessary when you want to know whether any target
    objects of a specific height are visible from the current position. We omit this
    option because we are more interested in the general visibility than in the visibility
    of specific objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adapt to highest point at distance of**: This option finds the highest point
    in the observer or target vicinity within a certain area, defined in pixels. It
    may be of great use when your observation points provide approximate locations,
    and you need their height values to be adjusted to the highest point within the
    surrounding area. As we already have the exact height values, this option will
    be omitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: This can be represented by the following coverages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary viewshed**: This is a simple raster coverage where all pixel values
    are assigned `0` (invisible) or `1` (visible). Activate this option to create
    viewsheds.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invisibility depth**: This measures the size an object should attain in order
    to become visible if placed in an area which is out of view. In other words, it
    defines the number of height units required for an object to become visible within
    a given radius. The output raster is a kind of inverted visibility raster where
    all visible pixels are assigned 0 as the value and all invisible pixels are assigned
    negative height values (the lower the value, the more invisible an object).![Step
    4 – creating viewshed coverages](img/image00457.jpeg)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intervisibility**: The output will be a shapefile that represents a network
    of visual relations between the observation points. In the output network, points
    that can be visible from each other are connected.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizon**: The output raster coverages represent the horizon line or the
    edge of the visibility area.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, instead of multiple coverages, a single **cumulative** raster that
    summarizes raster coverages to generalize analysis results can be created. Then,
    `0` values are assigned to invisible pixels, and positive values are assigned
    to visible pixels (higher values correspond to pixels visible from multiple observation
    points).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Use earth curvature option**: This takes into account the earth''s curvature
    and the effects of refraction of light when traveling through the atmosphere.
    Activate this option and accept the default `0.13` refraction value. After all
    the options are adjusted, click on the **OK** button and wait for the results
    to be loaded into the map canvas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, you can create the **Horizon** individual coverages. As a result,
    a total of 18 raster coverages will be added to the map canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`coverage_N_Binary`: A binary visibility raster where *N* is the number of
    observation point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coverage_N_Horizon`: A raster that represents the horizon line for the point
    *N*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the example combination of binary
    visibility (on the left) and the horizon line (on the right) coverages for the
    same observation point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 – creating viewshed coverages](img/image00458.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Step 5 – finding scenic points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we should go through all the observation points and corresponding coverages,
    adjust their visualization options, and select the point (or points) that provides
    the best view of the area of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to enumerate the points properly in order to be able
    to distinguish between them. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Open Attribute Table** from the `observ_points` by right-clicking on
    the contextual shortcut, or click on the correspondent button ![Step 5 – finding
    scenic points](img/image00459.jpeg) from the **Attributes** toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Open Field calculator**![Step 5 – finding scenic points](img/image00460.jpeg)
    from the table toolbar or use the *Ctrl* + *I* keyboard shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Field calculator** dialog window, activate the **Update existing field**
    option, and make sure that the `OBJECTID` attribute field is selected from the
    drop-down list, as shown in the following screenshot. This field already contains
    values that were joined from the `building_footprints` layer. These values are
    independent of the point number, and this is why we are using the update option
    to change the existing values to consistent values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Expression** tab, expand the **Record** group, which contains functions
    that operate on record identifiers. Select and double-click on the **$id** function
    to be added to the **Expression** window. This function returns the feature ID
    of the current row, which will help us identify the points and the correspondent
    coverages properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK** button. **Edit mode** will be automatically turned on and
    the records' values will be updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Step 5 – finding scenic points](img/image00461.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Toggle editing mode**![Step 5 – finding scenic points](img/image00462.jpeg)
    from the **Table** toolbar or use the *Ctrl* + *E* keyboard shortcut to exit editing
    mode. You will be asked whether you want to save the changes made to the `observ_points`
    layer. Click on the **Save** button and close the attribute table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `observ_points` layer to open its **Layer Properties** dialog
    window. In the **Labels** section, activate the **Label this layer with** option
    and select the `OBJECTID` field for labeling. Adjust any other labeling options,
    if needed, and click on **OK** to exit the window. When the observation points
    are labeled, it will be much easier to analyze them and their viewsheds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will adjust the symbology of the visibility layers to simplify their
    interpretation. Let''s start from the very beginning—point number `0`. Follow
    these steps to achieve meaningful results:'
  prefs: []
  type: TYPE_NORMAL
- en: Activate the `coverage_0_Horizon` and `coverage_0_Binary` layers, and deactivate
    all other visibility layers. Make sure that the layers lie under `observ_points`.
    Activate any other layers that might be of interest when analyzing visibility
    (for example, `urban_surface`, `roads`, and so on), and make sure that they underlie
    visibility rasters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the `coverage_0_Horizon` layer''s style. This layer contains only two
    values: `1` represents the horizon line (that is, the edge of the visibility area),
    and `0` represents all other areas. Double-click on its name in the **Layers**
    panel to open the **Layer Properties** dialog, go to the **Style** section, and
    adjust the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Render type** drop-down list, select **Singleband pseudocolor**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set **Color interpolation** to **Exact**, as we have only two values and want
    them to be assigned to the selected colors.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the ![Step 5 – finding scenic points](img/image00463.jpeg) button to add
    the necessary values manually. Enter `0` and double-click on its **Color** sample.
    In the **Change color** window, select black from **Standard colors**, and using
    the **Opacity slider**, set the transparency to `25%`. Click on the **OK** button
    to come back to the main styling options.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, add one more row for the value of `1`, and assign it a bright, contrasting
    color to make the horizon line distinguishable on the map. Type in the explanatory
    names for values in the **Label** field. Your color table should look similar
    to the following screenshot:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Step 5 – finding scenic points](img/image00464.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Open the `coverage_0_Binary` properties dialog by double-clicking on the layer
    name in the **Layers** panel, and go to the **Transparency** section. We will
    use **Custom transparency** options and **Transparent pixel list** to adjust the
    pixels'' transparency properties according to their values. The binary visibility
    raster contains only two values: `1` for visible areas and `0` for invisible areas.
    To add these values to the list, click on ![Step 5 – finding scenic points](img/image00463.jpeg),
    the **Add values manually** button. A new row will appear in the list. There,
    you should manually enter the **From** and **To** values, and adjust or accept
    the **Percent Transparent** value, which is set to `100` by default. As we are
    going to use values instead of ranges to set the transparency, the **From** and
    **To** entries will be identical:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first row, enter `1` and accept the 100% transparency.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on ![Step 5 – finding scenic points](img/image00463.jpeg) again to add
    the next row, enter `0` in **From** and **To**, and set the transparency to `25%`.
    As a result, your **Transparent pixel list** will look like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Step 5 – finding scenic points](img/image00465.jpeg)After making all the
    necessary adjustments, click on the **OK** button to apply them.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Apply the same styling options for the layers of the other points. Instead of
    working on every raster individually, right-click and navigate to **Styles** |
    **Copy Style** to replicate the preliminary configured visualization options from
    `coverage_0_Horizon` and `coverage_0_Horizon`. Then, go to **Styles** | **Paste
    Style** to insert them into the appropriate layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the coverages are visualized properly, we only need to visually interpret
    them and make a decision about the best points after considering several criteria.
    First of all, a point should provide a view for the vast areas, and this can be
    analyzed through binary coverages; the more the area open to the observer, the
    better. Secondly, the horizon line should be clear, solid, and not disrupted by
    artifacts, if possible. The integrity of the visibility edge ensures panoramic
    views, and it can be analyzed through horizon coverages; the straighter and simpler
    the line, the better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you should always take into account the local features represented
    by sights, open spaces, and any other possible points of interest. Regarding New
    York city''s Brooklyn borough, there are a few remarkable features that you have
    probably heard about: the Brooklyn bridge and the waterfront area where the Brooklyn
    Bridge Park is located. This area is famous for its beautiful sunsets and awe-inspiring
    views of Manhattan and the East River. Taking into consideration all of these
    criteria, point number 7 would probably be the best choice. Not only does it provide
    views of the southern and northeastern parts of the area, but it also encompasses
    the waterfront area almost entirely, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 – finding scenic points](img/image00466.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the winner among the best view is chosen, we can proceed to the following
    step and visualize the results of the analysis. Instead of representing them in
    a conventional cartographic way, we will use the power of three-dimensional visualization,
    which is of great use when dealing with urban landscapes.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – styling the results in 3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will represent our data in a 3D scene using the impressive
    capabilities of the **Qgis2threejs** plugin. Install it as described in the *Extending
    functionality through the plugins* section of [Chapter 1](part0014.xhtml#aid-DB7S2
    "Chapter 1. Handling Your Data"), *Handling Your Data*. This plugin relies on
    the `three.js` library. It allows us to export terrain data, the map canvas image,
    and vector data straight to a web browser. As a result, you can view and explore
    exported objects as a 3D scene on web browser that supports WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation is completed, the plugin is available from the **Qgis2threejs**
    menu under **Web**. There are two submenus available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Settings**: This is responsible for defining a browser that will be used
    to open generated 3D scenes. These settings should not be changed if you want
    your default browser to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qgis2threejs**: This is the main window of the plugin, and it provides access
    to its general functionality. In the left part of the window, you can see the
    list of all available control parameters and the project''s layers. The right
    part of the window provides access to their settings and changes interactively,
    depending on the item selected on the left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First of all, you need to adjust the map layers that will be used to generate
    an image draped over the terrain. For this example, we activate the following
    layers ordered from bottom to top: `water_area`, `parks`, `roads`, and `coverage_7_Binary`.
    You can always add more layers or even use the predefined WMS/ WFS or OpenLayers
    plugin coverages, for example, OpenStreetMap. These active layers will be used
    to provide background terrain.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following sections, we are going to explore only the basic settings of
    the plugin that are necessary for generating a meaningful result from the training
    data. Extended help and descriptions of the parameters are available at [https://github.com/minorua/Qgis2threejs/wiki/ExportSettings](https://github.com/minorua/Qgis2threejs/wiki/ExportSettings).
  prefs: []
  type: TYPE_NORMAL
- en: Working on the general settings of a 3D scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once all the necessary layers are active, go through the following options
    to adjust the general settings of the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template file**: Here, you can select different output templates from the
    drop-down list. Use the default **3DViewer(dat-gui).html** option, as it not only
    generates a 3D scene but also adds a control parameters panel to regulate the
    visibility and opacity of the layers and vertical movement of a custom horizontal
    plane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**World**: This item is responsible for the general appearance of the scene
    in the 3D world. The parameter we are especially interested in is **Vertical**
    **exaggeration**, as it defines the complexity of relief appearance. The bigger
    the value, the more emphasized terrain will reflect the relief features. Also,
    this value affects the *Z* positions of all vector 3D objects and 3D object heights
    of some object types with volume (points and extruded polygons). The default value
    is set to `1.5`, but our area of interest has a plane relief with smoothly changing
    values, so we enter `2` to make changes in the height more obvious.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controls**: There are two available control choices, accompanied by descriptions.
    Leave the default `OrbitControl.js` unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DEM**: From the **DEM** layer drop-down list of available rasters, select
    `lidar_dem`, which will be used to provide actual information about heights of
    the area and generate a terrain of predefined vertical exaggeration. There are
    several sections that provide parameters to regulate DEM appearance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Resampling** block is responsible for the generated surface resolution
    and provides various options for its adjustment. For the purpose of this tutorial,
    we will simply move the slider to the fourth tick, which gives an output resolution
    close to 400 x 400 pixels and resamples the original DEM to approximately 26.8
    feet. This approach is fast and produces a lightweight output, but resampling
    values affects the DEM's resolution, not the texture draped over it. If you want
    to produce more sophisticated and high-resolution results, read about the advanced
    settings, but bear in mind that high-resolution output takes more time to export,
    and also that the scene itself will require more computer resources to be responsive
    and rendered fast.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display type**: Accept all the default settings that presume use of **Map
    canvas image** as a texture.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sides and frame**: Accept the default **Build sides** option. It adds sides
    and a bottom to the DEM.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional DEM**: this option is might be of great use if you want to combine
    two rasters that contain some *Z* values (for example, absolute height and slope,
    heat maps and so on). As we are mainly interested in buildings and binary visibility
    rasters, this option is omitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting 3D visualization of the observation points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expand the **Point** item on the left side of the window to see all the available
    point layers, and activate `observ_point`. In the right part of the window, adjust
    the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: For **Object type**, accept the default **Sphere** value. The observation points
    will be represented by spheres in the 3D space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Z coordinate Mode** to **+"HEIGHT_ROO"**, which means that the height
    of a point will be obtained from the following formula: *z = elevation at vertex
    + field value + addend* *= DEM + HEIGHT_ROO*. In other words, we only summarize
    the elevation of the relief and the height of the building at a certain point,
    without any other values (*addend* is set to 0 and excluded from the second part
    of the formula). As a result, the point will take into account the local relief
    and represent the real vertical position of the observer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Style** section is responsible for the visual properties of the symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Color** to **Random** from the drop-down list, and the spheres will be
    assigned a color randomly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept the default **Feature style** option under **Transparency**. It will
    make the points solid, not transparent.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As we want all spheres to have the same size, we accept the **Fixed value**
    under **Radius** as it is. Type `50` in the **Value** field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's consider **Features that intersect with map canvas extent**. With
    this default option, only the features that are displayed on the map canvas will
    be exported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Attribute and label** section provides access to the labeling options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate **Export** attributes to enable labeling. All the attributes will be
    exported and shown when you click on the relevant object in the 3D scene.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From the **Label** field drop-down list, select the `OBJECTID` field that will
    be used for labeling.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Label height** option defines how high from the sphere its label will
    be shown. Here, we select the **Height from point** option from the drop-down
    list and set **Value** to `100`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the window will look after all the parameters
    are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adjusting 3D visualization of the observation points](img/image00467.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adjusting 3D visualization of building footprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expand the **Polygon** item on the left side of the window to see all the available
    polygon layers, and activate `building_footprints`. On the right side of the window,
    change the settings to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object type**: Set this to **Extruded**. This means that 2D polygon footprints
    will be represented as 3D parallelepipeds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mode**: Set this to **Relative to DEM**. This means that the height of the
    building will be obtained from the following formula *z = elevation at vertex
    + addend* *= DEM*. In other words, as we don''t use any additional values and
    the height is set to 0, the relative height of the building will be DEM dependent
    only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height**: Set this to `HEIGHT_ROO`. Jointly with the previous setting, this
    setting makes it possible to show buildings with their real height, relative to
    the absolute height a.s.l. obtained from the DEM.![Adjusting 3D visualization
    of building footprints](img/image00468.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After all of these settings are done, click on the **Browse** button to specify
    the path and name for the output scene. Then click on **Run**. When the scene
    is generated, it will be automatically loaded and opened in your default web browser,
    where you can visually explore the results of the analysis using the previously
    defined controls, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adjusting 3D visualization of building footprints](img/image00469.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were exposed to the basics of visibility analysis, including
    input data preparation, visibility point creation, and production and interpretation
    of visibility coverages in order to find the best observation point. Moreover,
    you learned how to represent your results through realistic 3D models, which are
    of great use in the visual exploration of urban data and the results of its analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to define a perfect location by means
    of spatial analysis.
  prefs: []
  type: TYPE_NORMAL
