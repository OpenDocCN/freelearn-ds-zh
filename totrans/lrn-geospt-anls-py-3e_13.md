# 整合所有内容

在整本书中，我们已经触及了地理空间分析的所有重要方面，并且我们使用了多种不同的 Python 技术来分析不同类型的地理空间数据。在本章的最后，我们将利用我们几乎涵盖的所有主题，来制作一个实际应用且非常受欢迎的产品：GPS 路线分析报告。

这些报告在数十个移动应用服务、GPS 手表、车载导航系统和其他基于 GPS 的工具中很常见。GPS 通常记录位置、时间和海拔。从这些值中，我们可以推导出大量关于记录数据沿途发生事件的辅助信息。包括 RunKeeper、MapMyRun、Strava 和 Nike Plus 在内的健身应用都使用类似的报告来展示跑步、徒步、骑行和步行的 GPS 追踪运动数据。

我们将使用 Python 创建这样的报告。这个程序将近 500 行代码，是我们迄今为止最长的，因此我们将分部分逐步进行。我们将结合以下技术：

+   理解典型的 GPS 报告

+   构建GPS报告工具

随着我们逐步通过这个程序，我们将使用所有熟悉的技术，但我们将以新的方式使用它们。

# 技术要求

我们在本章中需要以下东西：

+   Python 3.6 或更高版本

+   内存：最低要求 – 6 GB（Windows），8 GB（macOS）；推荐 8 GB

+   存储：最低要求 7200 RPM SATA，可用空间 20 GB，推荐 SSD，可用空间 40 GB

+   处理器：最低要求 Intel Core i3 2.5 GHz，推荐 Intel Core i5

+   PIL：Python 图像库

+   NumPy：一个多维和数组处理库

+   `pygooglechart`：Google 图表 API 的 Python 封装器

+   FPDF：一个简单且纯 Python 的 PDF 编写器

# 理解典型的 GPS 报告

一个典型的 GPS 报告包括常见的元素，如路线图、海拔剖面图和速度剖面图。以下截图是一个通过 RunKeeper 记录的典型路线的报告（[https://runkeeper.com/index](https://runkeeper.com/index)）：

![图片](img/c9ab8e4f-557d-4506-acfe-d5d07f510d3a.png)

我们的报告将与这个服务类似，但我们还会增加一个特色。我们将包括路线图和海拔剖面图，就像这个服务一样，但我们还会添加在记录该路线时发生的天气条件以及沿途拍摄的地理定位照片。

既然我们已经了解了 GPS 报告是什么，那么让我们学习如何构建它。

# 构建GPS报告工具

我们程序的名字是 `GPX-Reporter.py`。如果您还记得 [第 2 章](a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml) 中关于 *标签和标记格式* 的部分，*学习地理空间数据*，**GPX** 格式是存储 GPS 路线信息最常见的方式。几乎每个依赖 GPS 数据的程序和设备都可以转换为 GPX 格式。

对于这个示例，您可以从以下链接下载一个示例 GPX 文件：[http://git.io/vl7qi](http://git.io/vl7qi)。此外，您还需要从 PyPI 安装几个 Python 库。

您只需使用 `easy_install` 或 `pip` 安装这些工具。我们还将使用一个名为 `SRTM.py` 的模块。此模块是用于处理 2000 年由航天飞机奋进号在 11 天的 **航天飞机雷达地形测量任务**（**SRTM**）期间收集的近全球高程数据的实用工具。使用 `pip` 安装 SRTM 模块：

[PRE0]

或者，您也可以下载压缩文件，解压后，将 `srtm` 文件夹复制到您的 Python `site-packages` 目录或工作目录：[http://git.io/vl5Ls](http://git.io/vl5Ls)。

您还需要注册一个免费的 Dark Sky API。这项免费服务提供独特的工具。这是唯一提供全球、历史天气数据的服务，对于几乎任何地点，每天最多可免费请求 1,000 次：[https://darksky.net/dev](https://darksky.net/dev)。

**Dark Sky** 将为您提供一个文本密钥，您需要在运行 GPX-Reporter 程序之前将其插入到名为 `api_key` 的变量中。最后，根据 Dark Sky 的服务条款，您需要下载一个标志图像并将其插入到报告中：[https://raw.githubusercontent.com/GeospatialPython/Learn/master/darksky.png](https://raw.githubusercontent.com/GeospatialPython/Learn/master/darksky.png)。

您可以在此处查看 Dark Sky 的 *服务条款*：[https://darksky.net/dev/docs/terms](https://darksky.net/dev/docs/terms)。

现在，我们准备好通过 GPX-Reporter 程序进行工作。像本书中的其他脚本一样，此程序试图最小化函数，以便您可以更好地在心理上追踪程序并轻松修改它。以下列表包含程序中的主要步骤：

1.  设置 Python `logging` 模块

1.  建立我们的辅助函数

1.  解析 GPX 数据文件

1.  计算路线边界框

1.  缓冲边界框

1.  将框转换为米

1.  下载底图

1.  下载高程数据

1.  对高程数据进行阴影处理

1.  增加阴影对比度

1.  混合阴影和高程图

1.  在单独的图像上绘制 GPX 轨迹

1.  将轨迹图像和底图混合

1.  绘制起点和终点

1.  保存地图图像

1.  计算路线里程标记

1.  构建高程剖面图

1.  获取路线时间段内的天气数据

1.  生成 PDF 报告

下一个子节将带您了解第一步。

# 初始设置

程序的开始是 `import` 语句，然后是 Python `logging` 模块。`logging` 模块提供了一种比简单的 `print` 语句更健壮的方式来跟踪和记录程序状态。在这个程序部分，我们按照以下步骤进行配置：

1.  我们首先需要安装所有需要的库，如下面的代码所示：

[PRE1]

1.  现在，我们可以配置 Python `logging` 模块，以在整个过程中告诉我们发生了什么，如下所示：

[PRE2]

此日志记录器将输出到控制台，但通过简单的修改，你可以将其输出到文件，甚至是一个数据库，只需更改本节中的配置即可。此模块是 Python 内置的，在此处有文档：[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)。

接下来，我们有几个在程序中多次使用的实用函数。

# 使用实用函数

所有以下函数（除与时间相关的函数外）已在之前的章节中以某种形式使用过。让我们看看如何在我们的示例中使用实用函数：

1.  首先，`ll2m()` 函数将纬度和经度转换为米：

[PRE3]

1.  `world2pixel()` 函数将地理空间坐标转换为输出地图图像上的像素坐标：

[PRE4]

1.  然后，我们有 `get_utc_epoch()` 和 `get_local_time()` 函数将 GPX 文件中存储的 UTC 时间转换为沿路线的本地时间：

[PRE5]

1.  现在我们有一个 haversine 距离函数和我们的简单 `wms` 函数来检索地图图像：

[PRE6]

1.  `wms()` 函数使用以下代码检索地图图像：

[PRE7]

1.  接下来，我们有一个 `exif()` 函数用于从照片中提取元数据：

[PRE8]

1.  然后，我们有一个 `dms2dd()` 函数将度/分/秒坐标转换为十进制度，因为这是照片坐标的存储方式：

[PRE9]

1.  最后，我们有一个 `gps()` 函数用于从照片元数据中提取坐标：

[PRE10]

1.  接下来，我们有我们的程序变量。我们将访问由名为 **Mundalis** 的公司免费提供的 **OpenStreetMap WMS** 服务以及由 NASA 提供的 SRTM 数据。

在本书中，我们为了简便起见使用 Python 的 `urllib` 库来访问 WMS 服务，但如果你计划频繁使用 OGC 网络服务，你应该使用通过 PyPI 可用的 Python 包 OWSLib：[https://pypi.python.org/pypi/OWSLib](https://pypi.python.org/pypi/OWSLib)。

现在让我们执行以下步骤来设置 WMS 网络服务：

1.  我们将输出几个中间产品和图像。这些变量在这些步骤中使用。`route.gpx` 文件在本节中定义为 `gpx` 变量。首先，我们设置一些用于度到弧度转换以及反向转换的转换常量，如下所示：

[PRE11]

1.  接下来，我们设置 `.gpx` 文件的名称如下：

[PRE12]

1.  现在，我们开始设置 WMS 网络服务，它将检索地图：

[PRE13]

1.  接下来，我们设置我们的阴影参数，这将确定人工太阳的角度和方向：

[PRE14]

1.  然后，我们设置没有海拔信息的地方的 `no_data` 值：

[PRE15]

1.  接下来，我们设置输出图像的名称如下：

[PRE16]

1.  现在我们使用以下代码创建我们最小和最大海拔值对应的颜色：

[PRE17]

1.  然后，我们设置我们的输出图像大小，如下所示：

[PRE18]

现在我们了解了函数的工作原理，让我们解析 GPX。

# 解析 GPX

现在，我们将使用`内置的xml.dom.minidom`模块解析GPX文件，它只是XML。我们将提取纬度、经度、海拔和时间戳，并将它们存储在列表中以供以后使用。时间戳使用Python的`time`模块转换为`struct_time`对象，这使得处理更加容易。

解析需要执行以下步骤：

1.  首先，我们使用`minidom`模块解析`gpx`文件：

[PRE19]

1.  接下来，我们获取所有包含海拔信息的`"trkpt"`标签：

[PRE20]

1.  现在，我们设置列表以存储我们解析的位置和海拔值：

[PRE21]

1.  然后，我们遍历GPX中的GPS条目并解析值：

[PRE22]

时间戳需要一点额外的工作，因为我们必须将GMT时间转换为本地时间：

[PRE23]

解析GPX后，我们需要路线的边界框以从其他地理空间服务下载数据。

# 获取边界框

当我们下载数据时，我们希望数据集覆盖的区域比路线更广，这样地图就不会在路线的边缘裁剪得太紧。因此，我们将边界框的每侧缓冲20%。最后，我们需要以东西和南北方向的数据来与WMS服务一起工作。东西和南北是笛卡尔坐标系中点的*x*和*y*坐标，以米为单位。它们在UTM坐标系中常用：

1.  首先，我们按照以下方式从坐标列表中获取范围：

[PRE24]

1.  接下来，我们缓冲边界框以确保轨迹不会靠近边缘：

[PRE25]

1.  最后，我们在变量中设置我们的边界框并将坐标转换为米，这是网络服务所要求的：

[PRE26]

通过这种方式，我们现在将下载我们的地图和海拔图像。

# 下载地图和海拔图像

我们首先下载作为底图的OSM底图，它包含街道和标签：

1.  首先，我们将使用`log.info`下载OSM底图：

[PRE27]

本节将生成如下截图所示的中间图像：

![图片](img/92c897fd-a697-4824-bf2c-d9d6a46ee256.png)

1.  接下来，我们将从**SRTM**数据集中下载一些海拔数据。SRTM几乎覆盖全球，提供30-90米的分辨率。`SRTM.py` Python模块使得处理这些数据变得容易。`SRTM.py`下载数据并设置请求。因此，如果您从不同地区下载数据，您可能需要清理位于您家目录中的缓存（`~/.srtm`）。这部分脚本可能需要2-3分钟才能完成，具体取决于您的计算机和互联网连接速度：

[PRE28]

脚本的这一部分也会输出中间海拔图像，如下截图所示：

![图片](img/2aa4c75f-0071-4a70-8f9d-44bff5d3ca43.png)

现在我们有了海拔图像，我们可以将其转换为阴影图。

# 创建阴影图

我们可以将这些数据通过与[第7章](964b7276-1604-4df5-b549-6d8f61d5e9cb.xhtml)中*创建阴影图*部分相同的**阴影图**算法运行。为此，让我们遵循以下步骤：

1.  首先，我们打开我们的高程图像并将其读入一个`numpy`数组：

[PRE29]

1.  现在我们设置我们的处理窗口以通过网格移动并高效地分析小部分：

[PRE30]

1.  然后，我们将高程图像分割成如下窗口：

[PRE31]

1.  我们将创建用于处理的窗口数组如下：

[PRE32]

1.  最后，由于`numpy`，我们可以一次性处理它们：

[PRE33]

现在我们有了等高线层，我们可以开始创建地图。

# 创建地图

我们已经有了开始构建报告地图所需的数据。我们的方法如下：

+   使用过滤器增强高程和底图图像

+   将图像混合在一起以提供等高线阴影OSM地图

+   创建一个半透明层来绘制街道路线

+   将路线层与等高线阴影地图混合

这些任务都将使用PIL `Image`和`ImageDraw`模块完成，如下所示：

1.  首先，我们将阴影高程`numpy`数组转换回图像并平滑它：

[PRE34]

1.  现在我们将增加图像的对比度，使其更加突出：

[PRE35]

1.  接下来，我们将地图图像裁剪到与高程图像相同的大小：

[PRE36]

1.  然后我们增加地图图像的对比度，并将其与等高线图像混合：

[PRE37]

1.  现在我们准备在混合地图上绘制GPS轨迹，首先将我们的点转换为像素：

[PRE38]

1.  我们还需要从即将创建的轨迹图像的边缘缓冲区中减去缓冲区：

[PRE39]

1.  接下来，我们创建一个透明图像，并将我们的轨迹作为红线绘制：

[PRE40]

1.  现在我们可以使用以下代码将轨迹粘贴到我们的图像上：

[PRE41]

1.  现在我们将在路线上绘制一个起点，如下所示：

[PRE42]

1.  下面的代码片段是终点：

[PRE43]

现在我们已经绘制了轨迹，我们准备放置我们的地理标记照片。

# 定位照片

我们将使用带有GPS位置坐标的手机照片。你可以从以下链接下载：

[https://raw.githubusercontent.com/GeospatialPython/Learn/master/RoutePhoto.jpg](https://raw.githubusercontent.com/GeospatialPython/Learn/master/RoutePhoto.jpg)。

将图像放置在与脚本同一级别的名为`photos`的目录中。我们只会使用一张照片，但脚本可以处理你想要的任意多张图片。我们将在地图上绘制并放置一个照片图标，然后按照以下步骤保存完成的底图：

1.  首先，我们使用以下代码获取图像列表：

[PRE44]

1.  然后，我们遍历每个图像并获取其GPS信息：

[PRE45]

1.  然后，我们使用我们的GPS函数如下解析位置信息：

[PRE46]

1.  现在，我们可以将照片坐标转换为图像像素坐标：

[PRE47]

1.  然后，我们将使用以下代码为照片位置绘制一个图标：

[PRE48]

1.  最后，我们将以如下方式保存我们的地图：

[PRE49]

尽管没有保存到文件系统，但等高线高程看起来如下：

![图片](img/141f8503-fd68-4964-8328-5bba99f03a99.png)

混合地形地图看起来如下截图：

![图片](img/11b32a49-185b-4b05-8516-0f64e779769f.png)

虽然阴影映射可以给我们一个关于海拔的印象，但它不提供任何定量数据。为了更详细，我们将创建一个简单的高程图表。

# 测量海拔

使用出色的Google Chart API，我们可以快速构建一个很好的高程剖面图表，显示海拔在路线上的变化：

1.  首先，我们将创建用于高程剖面的`chart`对象：

[PRE50]

1.  现在，我们需要创建一个表示最小值的线，如下所示：

[PRE51]

1.  接下来，我们可以按照以下方式填写我们的高程剖面：

[PRE52]

1.  然后，我们可以按照以下方式设置高程标签并将它们分配给一个轴：

[PRE53]

1.  接下来，我们可以使用以下代码为轴本身添加标签：

[PRE54]

1.  现在，我们可以计算轨迹点之间的距离：

[PRE55]

我们已经有了高程剖面，但我们需要在*x*轴上添加距离标记，以便我们知道剖面在路线上的变化位置。

# 测量距离

为了理解海拔数据图表，我们需要*x*轴上的参考点来帮助我们确定路线上的海拔。我们将计算路线上的英里分割，并将它们放置在图表x轴的适当位置。让我们看看以下步骤：

1.  首先，我们按照以下方式在轴上定位英里标记：

[PRE56]

1.  接下来，我们设置英里标记的标签：

[PRE57]

1.  现在，我们可以按照以下方式为英里标记添加标签：

[PRE58]

我们的图表现在应该看起来像以下截图：

![](img/242e1586-6859-4016-887f-be8b58640ae8.png)

我们的第一张图表已经完成。现在，让我们看看路线上的天气数据。

# 获取天气数据

在本节中，我们将检索我们的最终数据元素：天气。如前所述，我们将使用Dark Sky服务，该服务允许我们收集世界上任何地方的天气历史报告。天气API是基于REST和JSON的，因此我们将使用`urllib`模块来请求数据，并使用`json`库来解析它。在本节中值得注意的是，我们将在本地缓存数据，这样您就可以在需要时离线运行脚本进行测试。在本节早期，您需要放置您的Dark Sky API密钥，该密钥由`YOUR KEY HERE`文本标记。让我们看看以下步骤：

1.  首先，我们需要我们感兴趣区域的中心：

[PRE59]

1.  现在，我们按照以下方式设置免费的Dark API密钥，以便我们可以检索天气数据：

[PRE60]

1.  然后，我们获取我们用于天气查询的数据中的最新时间戳：

[PRE61]

1.  现在我们已经准备好按照以下方式执行我们的天气数据查询：

[PRE62]

1.  我们将像这样缓存天气数据，以防我们以后想查看它：

[PRE63]

1.  然后，我们按照以下方式解析天气JSON数据：

[PRE64]

1.  我们需要的只是天气摘要，这是列表中的第一项：

[PRE65]

1.  现在，我们将按照以下方式获取特定的天气属性：

[PRE66]

1.  现在我们已经将天气数据存储在变量中，我们可以完成最后一步：将其全部添加到PDF报告中。

在某些情况下，`fpdf`库除了PIL没有其他依赖。就我们的目的而言，它将工作得相当好。我们将继续向下添加页面元素。`fpdf.ln()`用于分隔行，而`fpdf.cells`包含文本，并允许更精确的布局。

我们终于准备好按照以下步骤创建我们的PDF报告：

1.  首先，我们按照以下方式设置我们的`pdf`对象：

[PRE67]

1.  然后，我们将为我们的报告添加一个页面并设置我们的字体偏好：

[PRE68]

1.  我们将使用以下代码为我们的报告创建一个标题：

[PRE69]

1.  现在，我们可以添加路线图，如下所示：

[PRE70]

1.  接下来，我们添加如下所示的高程图：

[PRE71]

1.  然后，我们可以使用以下代码编写天气数据摘要：

[PRE72]

1.  暗黑天空条款要求我们在报告中添加一个标志，以感谢优秀的数据来源：

[PRE73]

1.  现在，我们可以使用以下代码添加地理定位的图片：

[PRE74]

1.  最后，我们可以保存报告并查看它：

[PRE75]

你应该在你的工作目录中有一个名为`report.pdf`的PDF文档，其中包含你的成品。它应该看起来像以下截图所示的图片：

![图片](img/ccd637ac-85cb-4d2b-937f-c9808a776901.png)

通过这种方式，我们已经使用了本书中学到的所有技术，并构建了一个GPS报告工具。

# 摘要

恭喜！在这本书中，你汇集了成为一名现代地理空间分析师所需的最基本工具和技能。无论你偶尔使用地理空间数据还是一直使用它，你都将更好地利用地理空间分析。本书主要关注使用开源工具，这些工具几乎都可以在PyPI目录中找到，以便于安装和集成。但即使你使用Python作为商业GIS软件包或GDAL等流行库的驱动程序，纯Python测试新概念的能力也总是很有用的。

# 进一步阅读

Python提供了一套丰富的库用于数据可视化。其中最突出的是**Matplotlib**，它可以生成多种类型的图表和地图，并将它们保存到PDF中。Packt有几本关于Matplotlib的书，包括《Matplotlib 30个食谱》：[https://www.packtpub.com/big-data-and-business-intelligence/matplotlib-30-cookbook](https://www.packtpub.com/big-data-and-business-intelligence/matplotlib-30-cookbook)。
