- en: Chapter 2. Digging into the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**) defines the operations, formats,
    and data structures available from a networked service. The developer writes code
    using the API to tell a server to accomplish a task. An API is built on top of
    an existing programming language, and uses the syntax and features of the language
    to make communications with a computer easier to code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At one point, ESRI had three web-based APIs to communicate with ArcGIS Server:
    Flash, Silverlight, and JavaScript. With the rise of the mobile web and improvements
    in browsers, the ArcGIS JavaScript API won as the browser of choice. To make the
    best use of the ArcGIS Server map features, it''s best to learn what''s available
    from the JavaScript API. We''re going to take a tour through the API, to become
    familiar with what it has to offer.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other chapters in this book, this chapter provides more of a reference
    than a programming exercise. Short code snippets have been added to show how to
    use modules within the API. If you don't absorb every little crumb of information
    out of this chapter, don't worry. Just come back and reread parts of it for reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How maps are created and configured in the ArcGIS JavaScript API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to display geographic data from ArcGIS Server through tiled, dynamic, and
    graphics layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The building blocks of graphics on a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to communicate with ArcGIS Server services through tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How packaged UI controls called **dijits** can save development time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the ArcGIS JavaScript API, including examples that
    you can build on your own, check out *Building Web and Mobile ArcGIS Server Applications
    with JavaScript* by Eric Pimpler or *ArcGIS Web Development* by Rene Rubalcava.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the ArcGIS JavaScript API documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the documentation for the ArcGIS API for JavaScript by visiting
    [https://developers.arcgis.com/javascript/jsapi/](https://developers.arcgis.com/javascript/jsapi/).
    There, you'll find information on the latest version of the API, a list of changes
    since the previous version, and related documents to help you create apps. The
    organization is logical, and information is relatively easy to find with their
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation for each element in the ArcGIS API is laid out in an organized
    fashion. Links to the API components are on the left-hand side. The documentation
    for each element defaults to the AMD style, but provides links to the older legacy
    development style. With the AMD style, the top of the page shows how to load the
    module into your code. Following that is a description of the module, a link to
    samples that use the module, and a class hierarchy diagram showing the modules
    the current module inherits.
  prefs: []
  type: TYPE_NORMAL
- en: Object constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the module requires a JavaScript object to be constructed, the documentation
    provides information on what is needed to call the module's constructor. The documentation
    provides details on the parameters required to create the objects, including parameter
    names, object types, whether they're optional or not, and what they do.
  prefs: []
  type: TYPE_NORMAL
- en: CSS classes and data- attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Following any constructor information, the documentation provides data on the
    CSS class attributes for anything that the module may show on the map, as well
    as any HTML5 data-* attributes the module might employ. The CSS classes help you
    to modify the appearance of widgets and visual elements on the module, by giving
    you a class hook to modify with your custom styling. The data-* attributes give
    other JavaScript scripts access to information about your widget, without having
    to load the whole widget into memory. For instance, by clicking on a map graphic
    while using another library, you could access the geometry's type by looking at
    the element's data-geometry-type attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an ArcGIS API object is created using the constructor, it will have certain
    properties, or variable parameters assigned to the object. Some properties are
    set when the object is created. Other properties are set as the object is modified,
    or certain methods are run. The API documentation lists object properties that
    are actively maintained, and will not be removed without sufficient notice of
    depreciation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use web developer tools in your browser, such as Firebug for Firefox,
    or Chrome Developer tools, you might find that these ArcGIS API objects have more
    properties than are listed in the documentation. Many properties considered private
    will have one or two underscore (`_`) characters before the name. If the properties
    and methods are not listed in the documentation, they may not be there when the
    next version of the API is released. Don't count on undocumented properties and
    methods in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides certain properties, objects created with the ArcGIS API modules will
    probably contain methods, which are JavaScript functions assigned to the object,
    often using other parts of the object they're assigned to. The documentation will
    list public methods attached to the object, as well as what parameters they accept,
    what values they return, and a description of what task or function they perform.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the modules have documented events, where the module emits a notification
    that something has happened. These are similar to a HTML button's `onClick` event,
    or a browser's `onLoad` event. In older versions of the API, events were listened
    to using `dojo.connect`. But as the library has matured, Dojo is depreciating
    the connect function and replacing it with the **dojo/on** library ([http://dojotoolkit.org/reference-guide/1.10/dojo/on.html](http://dojotoolkit.org/reference-guide/1.10/dojo/on.html)).
    The `dojo/on` module actually delivers a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the dojo/on function, you attach events by calling it with the following
    parameters: the HTML DOM elements or Dojo widgets you want to listen to, the name
    of the event as a string, and a function that will be called when the event occurs.
    If you want to stop the event, you need a variable to accept the returned value
    of the dojo/on call, ahead of time. When you''re ready to stop listening, call
    that return variable''s `remove()` method. Some modules contain their own `on()`
    method, which implements the `dojo/on` module for event handling. Here''s an example
    code snippet using the `dojo/on` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know what to expect when we're reading the documentation, let's
    look at the different tools available in the ArcGIS API for JavaScript. Since
    ArcGIS applications work with geographic data, we'll start off by looking at the
    map.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with the ArcGIS JavaScript API, one of the first things you'll
    want to do is to create a map. The map transforms a simple div element into an
    interactive canvas where you can display, request, and even edit geographic data.
    The map is a complicated object, so we'll spend a significant amount of time focusing
    on it. Let's learn how to make a map in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a map is first created using the ArcGIS JavaScript API, the developer has
    numerous parameters that can be used to configure the map. We were exposed to
    some of those parameters in the previous chapter, when we created our first map
    application. Let's look into a few of them a little more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Autoresize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Autoresize** function, which by default is true, tells the map whether
    it should resize itself when the browser changes size or orientation. If you have
    a full screen map application, and you maximize or resize your browser, the map
    will automatically adjust and fill the space assigned to it. The map will keep
    the same zoom level, but more or less only the edges of the map will be visible
    when you resize your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your application hides, moves, or animates your maps' appearance onto or
    off the screen, the autoresize functionality could lead to some strange behavior
    in the map. For example, if the map is made to slide in from the right, the mouse
    scroll and some zoom functionality may zoom to the center-left point, rather than
    the center of the map. With map animations on and off screen, it is best to set
    the autoresize to false.
  prefs: []
  type: TYPE_NORMAL
- en: Basemap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **basemap** is an optional string value that provides background imagery
    to lay your data on. ESRI serves a variety of background imagery, depending on
    how you want to frame your data. All of ESRI''s basemaps are tiled images published
    in the Web Mercator projection (WKID 102100). For best performances, layers added
    on top of an ESRI basemap should be in the same projection. Otherwise, ArcGIS
    Server will have to reproject dynamic map services, and tiled map services may
    not show up if the spatial references do not match. You can see an example highlighted
    from the previous chapter in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The background imagery options available from ESRI include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`street`: An ESRI street map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`satellite`: Satellite/Aerial photography'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hybrid`: Combination of street map and satellite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`topo`: Topographic map with elevation and contours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gray`: Light gray/minimalist background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oceans`: Oceans and bathymetry background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national-geographic`: National Geographic-themed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`osm`: OpenStreetMap-themed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the center, extent, zoom, and scale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **center**, **extent**, **zoom**, and **scale** parameters can be used
    to override the other map layer settings and set what area is displayed on the
    map. The *center* can be either a two number array containing the longitude and
    the latitude of the center point, or an ESRI point. The *extent* describes in
    map coordinates which edges of the map should be shown: right, left, top or bottom.
    If a tiled layer is present, the *zoom* instructs which level of display, from
    furthest out to furthest in, the map should show. The *scale* tells the map how
    many units of measure relate to one unit in reality (for example, a scale value
    of 500 means that 1 inch on the map represents 500 inches in real life).'
  prefs: []
  type: TYPE_NORMAL
- en: LODs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a map loads layers, the **levels of details** (**LODs**) are defined by
    the first tiled layer loaded in the map. You can override those LODs when creating
    a map, by passing an array of objects containing a level (number: 0, 1, 2, and
    so on), a scale (number: for 1:500 scale, you would use 500), and a corresponding
    resolution (number). This is helpful if you want to limit the user''s ability
    to zoom way outside the view of your map, or if some of your tiled data has a
    finer resolution than your basemap will show.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned how adjust the parameters of a map object, let's look
    at its different parts.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The map object provides a number of properties that can be used in a mapping
    application. Some are read-only, and tell the status of the map. Others can be
    manipulated, and the changes can have significant impact on the map. While there
    are far more properties, we'll take a look at a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: loaded
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After you've created a map object, there are some things you can't do to the
    map until it has at least one layer **loaded**. When a map loads its first layer,
    it sets its loaded property to true. Then you can manipulate the map, pan around,
    search for layers, and modify its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common programming error is not testing whether the map is loaded before
    doing something to it, like adding search result graphics from a query. If you
    have an extremely fast internet connection, and your ArcGIS Server is right next
    to you, the map might be loaded right after you add a layer. But, for internet
    users outside your server room, the map may not load that quickly. It''s best
    to check the loaded property before continuing, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: layerIds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The map object keeps a list of references to the layers added to it. Map layer
    references are stored as an array of strings called `layerIds`. The first layerId
    in the list refers to the bottom most layer in the stack, while the last id string
    in the list refers to the top layer visible on the map. This is handy if you need
    to search for a particular layer in the list, or if you need to do something to
    all the layers loaded in the map.
  prefs: []
  type: TYPE_NORMAL
- en: spatialReference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The map's `spatialReference` property refers to the long list of mathematical
    equations used to represent a round earth on a flat map. This attribute is often
    (but not always) shared by the map and the layers and graphics contained within.
    We'll go into more depth studying spatial reference in the *Geometry spatial reference*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The map object has a number of useful methods, which are functions tied into
    the map object. These methods help you add items to the map, move around, zoom
    in and out, and manipulate map behavior. Let's take a look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding, removing, and retrieving layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Layers can be added and removed from the map as needed. If you want to add one
    map layer at a time, you can call on the map's `addLayer()` method. To add multiple
    layers at once, you have to put all those layers in an array and call the map's
    `addLayers()` method. Map layers can be removed with the `removeLayer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving layers is as simple as calling the map's `getLayer()` method. The
    `getLayer()` method is passed an id string for the layer. A list of the valid
    ids can be found in the map's `layerIds` array, or in the map's `GraphicsLayerId`
    property. If no layers are found that match the `getLayer()` parameter, the method
    returns a null.
  prefs: []
  type: TYPE_NORMAL
- en: Moving around the map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The map contains several methods for navigating the map. Some affect the location
    on the map, and others affect how zoomed in the user is. Here is a list of the
    most common methods used to manipulate your position on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setZoom()`: This sets the map zoom level, moving further in or further out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setScale()`: Similar to `setZoom()`, but tries to change the map''s scale
    to match the value passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setLevel()`: Similar to `setZoom()`, but works only in maps with a tiled service.
    Based on the integer passed into the function, the map will zoom to the corresponding
    zoom level, if the map has tiled layers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setExtent()`: When passed a bounding box, this message will attempt to set
    the map''s boundaries to match the bounding box. This affects both zoom level
    and position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`centerAndZoom()`: Accepts a center point and a zoom level, then centers the
    map on that point and attempts to zoom to the zoom level. This affects both position
    and zoom level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`centerAt()`: When this function accepts a point, it attempts to pan the map
    over so that the point is in the center of the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that, for the `setExtent()`, `centerAndZoom()`, and `centerAt()`
    methods, the points and bounding boxes need to be in the same coordinate system
    as the map.
  prefs: []
  type: TYPE_NORMAL
- en: Updating settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many map navigation actions that can be enabled or disabled using
    map methods. You can control what happens when the user clicks, double-clicks,
    or shift-double-clicks on the map. You can enable or disable panning with the
    mouse, as well as scrolling with the scroll wheel. You can even disable an enable-all
    navigation event for the map. There may be times you want to disable navigation.
    For instance, if your map is navigated by clicking on links, you may not want
    the user to wander too far on your map.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that these settings cannot be modified until the map is loaded. But
    if the map hasn't loaded yet, how are we supposed to know when it loads? For an
    answer, we'll look into a feature common to most JavaScript libraries, events.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Events are important when working with asynchronous programming in JavaScript.
    The map object has a number of events it fires before, during, and after it makes
    some important changes, or finishes certain tasks. These events can be listened
    to through the map''s built-in `on()` function. Let''s look at some of the more
    common events you''ll be working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`load`: A map event that fires after the map has loaded its first layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`click`: This fires when the user clicks on the map. Among other event items,
    it returns the point the user clicked as a `mapPoint` property of the event object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extent-change`: This fires when the map either changes location, or changes
    zoom level. Both of these factor into calculating the map''s extent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layer-add`: This fires when any new layer is added to the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layers-add-result`: This fires after multiple layers are loaded using the
    `addLayers()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mouse-over`: This fires when the mouse is moved over the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update-start`: This event fires before layers are loaded, either by adding
    new layers, or by moving around the map and triggering the map to download more
    map data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update-end`: This event fires after the map loads the data from its map services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No map is complete without data to show. Data is added to the map through layers.
    Layers refer to data sources that include geographic, symbolic, and even tabular
    data. The ArcGIS API for JavaScript contains a number of modules for interpreting
    different kinds of common geographic data sources. Some of the layer modules work
    with data provided by ArcGIS Server, and others can display data from other sources,
    such as KML, **Web Map Service** (**WMS**), and CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Common ArcGIS Server layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ArcGIS Server provides map layer data through Map Services. Map Services provide
    data published from an ArcMap map document (`.mxd`). The visual map data, legend,
    and underlying data tables are served through ArcGIS Server, and can be consumed
    through the browser when the layer data source is loaded into the map. Different
    layer types have different functionalities. We will review those layers in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: ArcGISDynamicMapServiceLayer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `ArcGISDynamicMapServiceLayer` is the default type of map published through
    the ArcGIS Server. It is a dynamic map, meaning that its content is updated whenever
    the map is refreshed. Because it is dynamic, the data can also be reprojected
    to fit on another map layer that is not in the same spatial reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because the data within an `ArcGISDynamicMapServiceLayer` is dynamic, ArcGIS
    Server redraws what the layer should look like every time the map looks at the
    data from a different location and zoom level. If this layer contains lots of
    labels, annotation, complicated graphics, or raster data (like aerial imagery,
    for instance), ArcGIS Server will require more system resources to render the
    map layer. This will lead to noticeably slower performance. Other services, like
    tiled map services, are recommended for that kind of data.
  prefs: []
  type: TYPE_NORMAL
- en: ArcGISTiledMapServiceLayer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ArcGIS Server allows map services to be tiled. An `ArcGISTiledMapServiceLayer`
    has its content already drawn into images at scales defined when the map service
    is published. These images are stored on a hard drive for quick retrieval. The
    benefit is that these pre-rendered tiles are served quickly and with little effort
    on the part of the server. More map services can be run from the same machine
    with little effect on performance. See an example in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tiled map services have some disadvantages. First, the data displayed through
    tiled map services doesn't change until the tiles are rebuilt. If a park boundary
    changes in the data, but the tiles aren't rebuilt, the service will still show
    the old boundary. Second, tiled map services restrict the map to specific zoom
    scales, with no easy way to view the map in between zoom scales. Third, if another
    tiled map is stacked on top of the first one, it not only has to be in the same
    spatial reference, but also the zoom scales have to overlap exactly within overlapping
    scale ranges. That means that a map built with scales of 1:500 and 1:1000 can
    be loaded with a map built with scales of 1:1000 and 1:2000, but a tiled layer
    with scales 1:750, 1:1500, and 1:3000 will not be seen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot load a dynamic map service layer as an `ArcGISTiledMapServiceLayer`,
    or else it will throw an error. However, a tiled map service can be loaded as
    an `ArcGISDynamicMapServiceLayer`. You lose performance when zooming and panning,
    but it will help you view scales in between the tiled scales.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen ArcGIS layers that provide image data. Let's turn our attention to
    layers that handle more vector data.
  prefs: []
  type: TYPE_NORMAL
- en: GraphicsLayers and FeatureLayers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you don't want to work with representative images of maps. Sometimes
    you want to work with the shape of your data directly. That's where `GraphicsLayers`
    and `FeatureLayers` come in. These layers render vector graphics directly in your
    browser. You can click on them, modify them, and even add data to an ArcGIS service
    through them. Let's look a little closer at them.
  prefs: []
  type: TYPE_NORMAL
- en: GraphicsLayers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GraphicsLayers` provide a simple way to add custom vector graphics to your
    map. You can manage the graphics by calling `add()` and `remove()` methods on
    those graphics. You can also search through the list of graphics on the map by
    searching through the `GraphicsLayer.graphics` array.'
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, the map object has a built-in `GraphicsLayer`. You can access
    that `GraphicsLayer` through the `map.graphics` property.
  prefs: []
  type: TYPE_NORMAL
- en: FeatureLayers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FeatureLayers` are specialized layers built on a `GraphicsLayer` that provide
    much more functionality. They have the custom vector graphics of a `GraphicsLayer`,
    plus they have an ArcGIS Server data source to populate the data. You can query
    for data by either location or attributes, add it to the map using custom graphics,
    and control popup content and styling. You can even edit data on your server.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike ArcGIS Tiled and dynamic layers, which can mash up multiple layers at
    once, each `FeatureLayer` can only work with one map service layer. `FeatureLayers`
    can work with individual layers in a map service, or special editable map services
    called **Feature Services**. Feature Services provide more details about the map
    layer, including endpoints for querying results. If ArcGIS Server is configured
    to allow editing on the features, and the map service is published to allow editing,
    `FeatureLayers` that consume these services will let you modify both shape and
    tabular data.
  prefs: []
  type: TYPE_NORMAL
- en: Because `FeatureLayers` query data from ArcGIS Server, they are limited in the
    number of features they can return. Typically, ArcGIS Server limits the number
    of results returned in a query to one or two thousand, depending on the version.
    Server settings can be altered to show more results, but more `FeatureLayer` graphics
    on the map mean more memory is consumed, and the app may be slow and unresponsive.
    Careful thought must be put into using the `FeatureLayer` with your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way that the `FeatureLayer` refines the number of features returned is
    by setting its mode. The `FeatureLayer` has three primary modes of feature selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MODE_ONDEMAND`: Only features that fit within the map extent, time extent,
    and/or definition query are downloaded. This is the most common way of interacting
    with features visible within the map extent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODE_SELECTION`: Only features that are selected by interacting with the map
    (by click, touch, or query, for instance) are downloaded and their data is shown
    on the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODE_SNAPSHOT`: All features are initially downloaded into memory. This method
    is popular for smaller datasets, and requires fewer server calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODE_AUTO`: It automatically picks between `MODE_ONDEMAND` and `MODE_SNAPSHOT`
    and is fairly new to the ArcGIS API for JavaScript, depending on the size and
    content of the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look into `FeatureLayers` more closely in [Chapter 5](ch05.html "Chapter 5. Editing
    Map Data"), *Editing Map Data* when we discuss editing.
  prefs: []
  type: TYPE_NORMAL
- en: Other layer types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ArcGIS API for JavaScript works well with data published through ArcGIS
    Server. But not all geographic data available in the world is published through
    ArcGIS Server. The API has a number of other layer types that can consume these
    different data sources. Some of the more common types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KMLLayer`: Services written with the **Keyhole Markup Language** (**KML**).
    KML was made famous by Google Earth. The format uses the markup to store and symbolize
    geographic data. Many services publish KML data, including the **National Oceanic
    and Atmospheric Administration** (**NOAA**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CSVLayer`: A fairly recent addition, it transforms a comma-delimited text
    file into points on the map. To show the data on a map, the `CSVLayer` expects
    a latitude and longitude column to show the coordinates in decimal places. This
    tool, combined with HTML5''s drag-and-drop API, could make it possible for you
    to map any compliant data you toss into a `.csv` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WMSLayer` and `WMTSLayer`: Web Map Services (**WMS**) and Web Map Tiled Services
    (**WMTS**) published using the **Open Geospatial Consortium** (**OGC**) compliant
    standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that if you load the layer using just the URL of the OGC Web Map
    Service, you'll need to use a proxy (see [Chapter 1](ch01.html "Chapter 1. Your
    First Mapping Application"), *Your First Mapping Application*). This is because
    the module first requests `GetCapabilities` on the layer to grab metadata from
    the map service. This request requires a proxy. However, if you load the `WMSLayer`
    with an optional `resourceInfo` parameter, that automatically describes the service
    for you, and the proxy will not be necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`StreamLayer`: A layer displaying live streaming data from an ArcGIS GeoEvent
    Processor Extension. `StreamLayer` takes advantage of the latest in HTML5 WebSockets,
    which provide real-time updates from the server to the client. You can view Twitter
    responses to specific events, or real-time locations of emergency response vehicles
    with tracking devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that most up-to-date modern browsers support WebSockets technology, but
    older browsers typically do not. You can visit [http://www.websocket.org/echo.html](http://www.websocket.org/echo.html)
    to see if your browser supports WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A graphic object represents an individual point, line, or polygon feature drawn
    on the webmap. The graphic object has four main parts: its geometry, symbol, attributes,
    and `infoTemplate`. They are used in many parts of the API. If you draw something
    on the map, you create a graphic. If you query a map service for something, it
    returns a list of graphics. Some modules even accept lists of graphics as arguments
    for other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The graphic object can be constructed with up to four optional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`geometry`: It describes the shape of the graphic drawn on the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol`: It describes the graphic''s color, thickness, and features that affect
    the appearance of the graphic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attribute`: A JavaScript object containing name-value pairs of tabular data
    that correspond with the feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`infoTemplate`: It formats the look of the graphic attributes when highlighted
    by the map''s `InfoWindow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look more closely at these graphic features in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing geometry objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Geometry objects are a collection of coordinates that describe where something
    is in the world. They give shape to the data we''re looking for. They can be used
    for displaying graphics on a map, or to provide spatial data for queries, or even
    for geoprocessing services. Geometry objects come in five basic types: point,
    line, polygon, extent, and multipoint. Any shapes are built on these basic types.
    Let''s take a closer look.'
  prefs: []
  type: TYPE_NORMAL
- en: Point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the ArcGIS API for JavaScript, a point is the simplest geometry object. It
    contains the *x* and *y* coordinates of the point, as well as the point's spatial
    reference. A point can be constructed with *x* and *y* coordinates, plus a spatial
    reference. It can also be defined by longitude and latitude.
  prefs: []
  type: TYPE_NORMAL
- en: Polyline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A polyline geometry is a collection of one or more arrays of point coordinates.
    Each array of point coordinates is called a path, and would look like a line when
    drawn out. Multiple paths can be stored in the same geometry, giving the appearance
    of multiple lines. The individual point coordinates are stored as array of *x*
    and *y* values.
  prefs: []
  type: TYPE_NORMAL
- en: Polygon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polygons are made up of one or more arrays of points that loop back on themselves.
    Each array of points is referred to as a ring, and the first and last point in
    a ring must have the same coordinate. Polygons made up of more than one ring are
    referred to as multipart-polygons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the many properties and methods that control the polygon''s shape are
    two useful methods: `.getCentroid()` and `.contains()`,`.getCentroid()` returns
    a point that is roughly in the middle of the polygon. The formula used to calculate
    the centroid''s position can be found on the Wikipedia page for centroids: ([http://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon](http://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon)).
    The `.contains()` method takes a point as an input, and returns a `boolean` value
    based on whether the point is inside the polygon or not.'
  prefs: []
  type: TYPE_NORMAL
- en: Extent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An extent is a rectangular polygon, which only uses four numbers to describe
    its shape. The extent is described by its minimum *x* value (`xmin`), maximum
    *x* value (`xmax`), minimum *y* value (`ymin`), and maximum *y* value (`ymax`).
    When viewed on a map, extents typically look like a box.
  prefs: []
  type: TYPE_NORMAL
- en: Extents are used by many different parts of the API. All other geometry objects
    other than points have a `getExtent()` method, which is used to collect the bounding
    box of the geometry. You can zoom to a specific location on a map by setting the
    map's extent. Extents are also used to define an area of interest when identifying
    things on a map.
  prefs: []
  type: TYPE_NORMAL
- en: Multipoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you need a cluster of points to show on the map. For that, the multipoint
    is your answer. You can add and remove points using the `addPoint()` and `removePoint()`
    methods. You can also get the general area the points cover with the `getExtent()`
    method. They're useful for collecting random points in an area, and for selecting
    unconnected features on a map.
  prefs: []
  type: TYPE_NORMAL
- en: Geometry spatial reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides coordinates of a geometry's location, the geometry object also packs
    information on the object's spatial reference. The spatial reference describes
    the mathematical models used to describe the Earth within the mapped region. Instead
    of containing all those formulas and constants, the spatial reference stores a
    reference to those formulas through either a **well-known ID** (**WKID**), or
    a **well-known text** (**WKT**).
  prefs: []
  type: TYPE_NORMAL
- en: Spatial Reference plays a crucial role when displaying data on a map. Tiled
    map service layers must have the same spatial reference as the map, in order to
    be displayed. Dynamic map service layers must be reprojected, adding to the server
    time and workload. Graphics also need to be in the same spatial reference as the
    map to appear in the correct places on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols and renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ArcGIS API provides some basic graphics tools to define how features look
    on your map. If you are creating your own custom graphics, or modifying some existing
    ones, this portion of the API tells you how to define their **symbols**. The API
    also provides custom **renderers**, which help you define what symbols are used,
    based on rules applied by the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Simple symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ArcGIS API uses symbols to define the colors, thicknesses, and other visual
    features of graphics, independent of their shape. In fact, without a symbol assigned,
    the graphics would not show up. The API defines three simple symbols to highlight
    points, line, and polygons. Let's look at the Simple Symbols.
  prefs: []
  type: TYPE_NORMAL
- en: SimpleLineSymbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SimpleLineSymbol` defines the symbology of line and polyline graphics added
    to the map. It may seem strange to start with line symbology, but the other two
    Simple symbols make use of a line symbol as well. The primary `SimpleLineSymbol`'s
    properties are its color, its width (in pixels), and its style. Styles include
    lines that are solid, dashed, dotted, and combinations of those as well.
  prefs: []
  type: TYPE_NORMAL
- en: SimpleMarkerSymbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SimpleMarkerSymbol` defines the symbology of point and multipoint graphics
    on the map. The symbol can generate different shapes, depending on the style that
    is set. While this symbol defaults to a circle, the `SimpleMarkerSymbol` can generate
    squares, diamonds, x's, and crosses. Other properties that can be manipulated
    within this symbol include the size in pixels, its outline as a `SimpleLineSymbol`,
    and its color.
  prefs: []
  type: TYPE_NORMAL
- en: SimpleFillSymbol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SimpeFillSymbols` define the symbology of polygon graphics on the map. The
    style of the `SimpleFillSymbol` reflects how the inside of the shape is shown.
    It can be solid (completely filled in), null (completely empty), or have lines
    running horizontally, vertically, diagonally, or crossing. Please note that a
    graphic with a null-styled symbol does not respond to clicks in the center. The
    symbol can also be modified by a `SimpleLineSymbol` outline, and if the style
    of the `SimpleFillSymbol` is solid, its fill color can be modified as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look a little further at the colors we'll use to define these symbols.
  prefs: []
  type: TYPE_NORMAL
- en: esri/Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `esri/Color` module allows you to customize the colors of the graphics you
    add to your map. The `esri/Color` module is an extension of the `dojo/_base/Color`
    module, and adds some unique tools to blend, create, and calculate color formats
    in different ways. Older versions of the library used the `dojo/_base/Color` module
    to set colors, and is still usable in the current version.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for the `esri/Color` module can accept a variety of values.
    You can assign common color names, such as "blue" or "red". You can use hex strings
    (for example `#FF00FF` for purple), like you would find in css colors. You can
    also create colors using three or four number arrays. The first three numbers
    in the array assign the red, green, and blue values from 0 to 255 ([0, 0, 0] is
    black, [255, 255, 255] is white). The fourth optional number in the array indicates
    the alpha, or the opacity of the color. Values in this range are from 0.0 to 1.0,
    with 1.0 being completely opaque, and 0.0 being completely transparent.
  prefs: []
  type: TYPE_NORMAL
- en: The `esri/Color` module has some interesting enhancements on the old `dojo/_base/Color`
    module. For instance, you can create a blend of two existing colors with the `blendColors()`
    method. It takes two colors, and a decimal number between 0.0 and 1.0, where 0.5
    is an even blend of the two colors. This could be useful, for instance, on a voting
    map where green represents yes, and red represents no, and voting districts could
    be colored by percentages of yes or no votes.
  prefs: []
  type: TYPE_NORMAL
- en: The `esri/Color` modules also have ways to translate colors from one format
    to another. For instance, you could click on a feature, get its graphic color,
    and use `toHex()` or `toCss()` to get the color string. From there, you could
    apply that color to the background color of an information `<div>` which is used
    to show the attributes of that graphic.
  prefs: []
  type: TYPE_NORMAL
- en: Picture symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If pictures speak to you more than colors, you can use Picture Symbols in your
    graphics. With these symbols, you can use picture icons and custom graphics to
    add interesting and memorable data points on your graph. Points and polygons can
    be symbolized using Picture Symbols, using the modules `esri/symbols/PictureMarkerSymbol`
    and `esri/symbols/PictureFillSymbol` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `PictureMarkerSymbol` module adds simple picture graphics for points on
    the map. It is typically constructed with three arguments, a URL pointing to the
    image file (such as `.jpg`, `.png`, or `.gif`), and an integer width and height
    in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: The `PictureFillSymbol` module fills the content of a polygon with a repeating
    graphic. The `PictureFillSymbol` takes four arguments. The first is a URL string
    pointing to an image file. The second input is a line symbol, like the `esri/symbols/SimpleLineSymbol`.
    The final two arguments are integer width and the height of the image in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Renderers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you don't want to assign graphic symbols one at a time. If you know
    what type of graphics you're adding, and how the graphics should look ahead of
    time, it makes sense to assign the symbology ahead of time. That's where renderers
    come in. Renderers can be assigned to `GraphicsLayers` as a way to assign a common
    style to all graphics inside them. Renderers depend on a graphics layer accepting
    one geometry type (like all polygons, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'As the ArcGIS API has matured, it has added a number of different renderers
    to its library. We''ll take a look at three common ones: the `SimpleRenderer`,
    the `UniqueValueRenderer`, and the `ClassBreakRenderer`. Each has its appropriate
    use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: SimpleRenderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SimpleRenderer` is the simplest of the renderers because it only assigns
    one symbol. It accepts a default symbol, and assumes that you''ll only insert
    graphics of the same type as the symbol. Like other renderers, if you assign a
    `SimpleRenderer` to a `GraphicsLayer`, you can add Graphic objects to the `GraphicsLayer`
    without them having a symbol assigned. Let''s look at a code snippet that shows
    how to create and apply a `SimpleRenderer` to the map''s graphics layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `SimpleRenderer` has been expanded since version 3.7 of the API. Symbols
    can be modified in different ways, based on a range of expected values in a field.
    For instance, you can vary the symbol's color between two colors by setting the
    `colorInfo` property of the SimpleRenderer. You can also change the size of a
    point according to a field value by setting its `proportionSymbolInfo` property.
    Finally, you can rotate a symbol by its field value by setting its `rotationInfo`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Unique Value Renderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want to display different symbols for your graphics based on one
    of their attributes. You can do that with a Unique Value Renderer. Specific unique
    values can be highlighted, while values not in the list can be assigned a default
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of the Unique Value Renderer accepts a default symbol, and
    up to three different fields to compare values against. If more than one field
    is used, a field delimiter string is required. Unique values and the associated
    symbols can then be loaded as objects within the renderer''s info parameter. The
    info object requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A unique value (`value`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A symbol associated with that value (`symbol`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A symbol label (`label`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A description of the unique value (`description`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class Break Renderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want to classify your graphics by where they fit in certain ranges
    of values, like population or **Gross Domestic Product** (**GDP**). The Class
    Break Renderer helps you to organize the graphics in a visual manner. This renderer
    looks at a particular field value in a graphic, and finds which class break range
    graphic's field value fits between. It then assigns the corresponding symbol to
    that graphic.
  prefs: []
  type: TYPE_NORMAL
- en: 'When constructing a Class Break Renderer, you assign a default symbol, and
    the field that will be evaluated to modify the symbol. Class breaks are assigned
    through an info property of the renderer. The info array accepts a JavaScript
    object containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum value of the class break (`minValue`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum value of the class break (`maxValue`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The symbol (`symbol`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A label describing the break (`label`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A description of the class break (`description`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InfoTemplates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`InfoTemplates`, as we mentioned in [Chapter 1](ch01.html "Chapter 1. Your
    First Mapping Application"), *Your First Mapping Application*, describe how you
    want to display data in a popup. The `InfoTemplate` can be constructed using two
    strings, the title and the content. The title and content strings represent HTML
    templates, and you can substitute graphic attributes in the template. For a graphic''s
    `infoTemplate`, if you wanted to display the graphic''s total attribute, you would
    insert the value in the template with a `${total}`, which shows the field name
    inserted inside the brackets of the substitution string `${}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to display a popup containing all the name/value pairs in the graphic''s
    attributes, you can use a wildcard `${*}` in the content value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For the content, you can add HTML content to the string, including tables,
    lists, images, and links. For example, you might use something like the following
    to describe a marine habitat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we added the name attribute of the graphic to the
    title, and created a two-column table that displays the type of the graphic, the
    zone where the graphic resides, and a two-column wide image connected to the map
    graphic.
  prefs: []
  type: TYPE_NORMAL
- en: Toolbars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ArcGIS API for JavaScript uses toolbars to handle controls that transform
    the cursor. The API has three different toolbars: one for map navigation, one
    for drawing graphics, and one for editing those graphics. These tools are turned
    on using the `activate()` method, which includes parameters describing what tool
    you want to use. The tools can be turned off using the `deactivate()` method;
    let''s take a closer look at these tools.'
  prefs: []
  type: TYPE_NORMAL
- en: The navigation toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The navigation toolbar handles advanced map navigation. By default, the map
    offers zoom sliders, and the ability to pan around the map. By activating the
    zoom in/zoom out features of the navigation toolbar, the user can draw a boxed
    extent where the map will either zoom in on, or zoom out at the same ratio as
    the zoom box to the map's current extent. This zoom in/out box is always on once
    you activate it, so you'll have to either develop something that turns it off,
    or let the user activate the pan tool, which disables the zoom in/out.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation controls have three more actions that can be activated. The `zoomToFullExtent()`
    function, when called from the navigation toolbar, triggers the map to zoom to
    its original map extent. The toolbar also keeps track of how many zoom-ins, zoom-outs,
    and pans the user has done. By activating the `zoomToPreviousExtent()` function,
    the map extent goes back to previous extents. And if the map goes back to previous
    extents, the map can also zoom to future locations. With the `zoomToNextExtent()`
    function, the user can undo the zoom extent changes they made when they viewed
    the previous extent.
  prefs: []
  type: TYPE_NORMAL
- en: The draw toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The draw toolbar allows the user to draw on the map to provide input. Depending
    on which draw tool was activated, the user can draw a shape on the map, and any
    event listener attached to the `draw-end` event is called, running a function
    that receives the shape the user drew. Multiple `draw-end` events can be attached
    to the event listener if needed. Common draw-end events might include adding a
    drawing to the map, measuring the shape drawn by the toolbar, or using the shape
    drawn in a query. The tools also modify the tooltip of the map, giving directions
    about how to draw with them.
  prefs: []
  type: TYPE_NORMAL
- en: The ArcGIS API provides numerous shapes to use when drawing on the map. The
    toolbar can be activated using simple drawing tool constants like point, polyline,
    and polygon, which are activated by clicking each point on the map and double-clicking
    to complete. There are freehand versions of the polyline and polygon, which allow
    you to click and drag the mouse to draw a continuous line or shape, and release
    the mouse to stop drawing. Also included in the API are drawing tools for common
    shapes such as triangles, rectangles, circles, ovals, and arrows, just to name
    a few.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The different toolbars are not aware of each other. If you are not careful,
    you could activate both drawing and navigation tools at the same time, and their
    actions will occur simultaneously. You could draw a shape for a tool, and be zoomed
    into that area because the navigation tool wasn't told to deactivate. Plan ahead
    how you will disable one event when another is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: The edit toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens when you draw something on the map and you have made a mistake?
    How do you correct a graphic on the map? The edit toolbar allows you to change
    map graphics' shape, size, and orientation. It also works on text symbols, letting
    you change the text of a text graphic on the map.
  prefs: []
  type: TYPE_NORMAL
- en: When the edit toolbar is activated on a feature, it allows you to move, rotate,
    scale, or change the vertices of the feature. Moving lets you grab the feature
    and position it where you want. Rotating provides a point to click and drag around
    to re-orient the graphic. Scaling lets the user make the graphic larger or smaller.
    For editing vertices, the user can drag points around on the map, right-click
    to "delete" the point, and click between the graphic versions on "ghost points"
    to add new vertices to the map.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that while the Edit Toolbar allows users to change graphics on the
    map, it doesn't have any features built in that let the user save their changes.
    When using the edit toolbar on graphics in an editable feature layer, you still
    will need a way to tell the feature layer to save changes. Graphics can be edited
    in the current session without saving the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the previous chapter, some application items require resource-intense
    processes that are best left for the server. The ArcGIS API calls these actions
    tasks. There are a large variety of tasks. Some require the server to compute
    and/or return data, which is the case for the geometry service and the `QueryTask`.
    Others use the server to generate custom documents, like the Print Task. Still,
    others also do all this, and also require custom extensions not initially a part
    of ArcGIS Server. Let's take a look at what makes a good task.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks, parameters, and results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed in the previous chapter, a task is made up of three parts,
    the task constructor, the task parameters, and the task results. Typically, only
    the task constructor and the task parameters need to be loaded using AMD. The
    task results are automatically produced when the results return from the server.
    The format of the results is shown in the API documentation to show you how to
    access what you need when you successfully receive results. The common order of
    events with tasks is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The task and task parameters are constructed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task parameters are filled in with the required information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task executes a server call using the task parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the browser receives the results from the server, something is done with
    the results either through a `callback` function or a deferred value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is worth noting that when tasks are executed, they return one of Dojo's **Deferred**
    objects. These deferred results can be passed to another function to be run asynchronously
    when the browser receives the results.
  prefs: []
  type: TYPE_NORMAL
- en: Common tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many tasks commonly available on any installation of ArcGIS Server.
    Many rely on a published map service or geoprocessing service to act on. Some,
    like the `GeometryService`, are built into ArcGIS Server. Let's take a look at
    some of the common tasks available through the API.
  prefs: []
  type: TYPE_NORMAL
- en: GeometryService
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`GeometryService` provides multiple functions for manipulating geometry data.
    Typically, it is published as part of ArcGIS Server. Let''s take a look at the
    Geometry Service functions available.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AreasAndLengths`: Finds areas and perimeters of polygon geometries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AutoComplete`: Helps create polygons adjacent to other polygons by filling
    in gaps between them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Buffer`: Creates a polygon whose edges are a set distance or distances from
    the source geometry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConvexHull`: Creates the smallest polygon shape necessary to contain all the
    input geometries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cut`: Splits a polyline or a polygon along a secondary polyline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Difference`: Takes a list of geometries, and a secondary geometry (probably
    a polygon), and returns the first list any overlap against the secondary geometry
    is cut out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Distance`: Finds the distance between geometries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Generalize`: Draws a similar looking shape with much fewer points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Intersect`: Given a list of geometries and another geometry, returns the geometries
    defined by where the first list intersected with the second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label Points`: Finds a point within a polygon which would be the best position
    to place a label'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lengths`: For lines and polylines, finds the planar or geodesic distance from
    beginning to end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Offset`: Given a geometry and a distance, will create a geometry the defined
    distance to the right of the original geometry if the distance is positive, or
    to the left of the geometry if negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Project`: Based on a geometry and a new spatial reference, it returns the
    original geometry in the new spatial reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Relation`: Based on two sets of geometries and a specified relationship parameter,
    returns a list of pairings showing how items in the two lists are related (for
    example: how many from list2 are inside list1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reshape`: Given a line or a polygon, and a secondary line, it changes the
    shape of the first geometry based on the second one, adding to the original figure,
    or tossing some of it away'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Simplify`: Given a complicated polygon or line whose edges crosses itself,
    it returns simpler polygons where the crossed parts are undone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TrimExtend`: Given a list of polylines, and a polyline to trim or extend to,
    it cuts lines in the list where they cross over the second polyline, and extend
    other polylines where they don''t quite reach the secondary polyline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Union`: Given a list of polygons, creates a unified geometry where all the
    polygons are dissolved along edges that overlap, creating one solid polygon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QueryTask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `QueryTask` provides a way to collect both shape and attribute data from
    features in a map service. You can request data on individual layers in a map
    service, defining your search area by geometry and/or limiting your results to
    attribute queries. The `QueryTask` is constructed with a URL parameter pointing
    to a single layer in a map service. The number of results returned from a successful
    query is limited by ArcGIS Server, typically to either 1,000 or 2,000 results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because results for a `QueryTask` can be limited by ArcGIS Server, the `QueryTask`
    object has been extended with multiple methods to collect data on its search results.
    Here are some of the methods available through the `QueryTask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execute()`: Accepts the `QueryTask` parameters, and requests features based
    on those parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executeForCount()`: Accepts the same parameters, and returns the number of
    results in the map service layer that match the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executeForExtent()`: It is based on the parameters passed, returns the geographic
    extent that contains all the search results. Note that this is only valid on hosted
    feature services on [www.arcgis.com](http://www.arcgis.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executeForIds()`: With the parameters passed, the results return a list of
    `ObjectIds` for the features that match the search. Unlike the execute command,
    where the number of results are limited by ArcGIS Server, the `executeForIds()`
    method returns all the `ObjectIds` that match the search. That means, if there
    are 30,000 results that match the search, this method will return 30,000 `ObjectIds`,
    instead of the server limit of 1,000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `QueryTask` parameters can be created using the `Query` module (`esri/tasks/query`).
    If you have experience with SQL, you''ll see similarities between the `Query`
    parameters and SQL `Select` statements, while there are some `Query` parameters
    that are more specific to ArcGIS Server. A few of the common ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`where` (string): A legal where clause for a query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`geometry` (esri/geometry): A shape to spatial select against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returnGeometry` (Boolean): Whether you want the geometry of the search result
    features. Setting this to false returns just attribute data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outFields` (array of strings): A list of fields to retrieve the search results.
    Assigning ["`*`"] to the `outFields` parameter returns all fields, which is equivalent
    to the SQL statement `SELECT * from`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outSpatialReference` (`esri/SpatialReference`): The spatial reference you
    want the geometry to be drawn in. Typically, the map''s spatial reference is assigned
    to this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orderByFields` (array of strings): A list of field values to sort the results
    by. Add `DESC` to the string if you want values returned in descending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Results are returned from `QueryTask` in a form called `FeatureSet` (`esri/tasks/FeatureSet`).
    `FeatureSet` contains data about the results returned, including the geometry
    type of the results, the spatial reference, field aliases for the results, and
    a list of feature graphics that match the search results. The `featureSet` even
    returns whether or not the number of results that match the query exceeded the
    number that could be delivered by ArcGIS Server. The array of features within
    the features property of the `featureSet` can symbolized and added straight to
    a map's graphics layer to be seen and clicked.
  prefs: []
  type: TYPE_NORMAL
- en: IdentifyTask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `IdentifyTask` provides a shortcut way to retrieve data from a map service
    for a popup. Unlike the `QueryTask`, which queries only one layer in the map service,
    the `IdentifyTask` can search through all layers in the map service. While the
    `QueryTask` has numerous methods to retrieve data on a search, the `IdentifyTask`
    is more simplified, with a single `execute()` command to retrieve server results.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters passed to an `IdentifyTask` are referred to as `IdentifyParameters`.
    Because `IdentifyTasks` can search multiple layers, the `IdentifyParameters` focus
    on searching by geometry. To search by a `where` clause, a `layerDefinition` parameter
    must also be added to the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The results of an `IdentifyTask`, known as the `IdentifyResults`, differ somewhat
    from the `FeatureSet`. First, `IdentifyResults` are returned as an array of objects
    that contain a feature parameter that contains the result graphic, while the `FeatureSet`
    is a single object with an array of graphics in its features parameter. Secondly,
    `IdentifyResults` do not contain a list of field names and aliases like the `FeatureSet`,
    because the feature attributes of the `IdentifyResult` are name/value pairs where
    the name key is the alias. Finally, the `IdentifyResults` return the layer id
    and name of the layer they were retrieved from. These attributes makes the `IdentifyTask`
    favourable to quickly populate a map's popup on a click.
  prefs: []
  type: TYPE_NORMAL
- en: FindTask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ArcGIS API offers another tool for finding features on a map called a `FindTask`.
    The `FindTask` accepts a text string, and searches for features in the map service
    that contain that value. On the database side, the `FindTask` queries through
    each layer in the map service, searching permitted fields for a text string with
    wildcards before and after it. If searching for the string "Doe", the `FindTask`
    would return a feature with the name value of "John *Doe*", "*Doe* Trail", or
    "`Fiddledee` *doe* Studios", but would not return a feature containing "Do exit"
    because of the space.
  prefs: []
  type: TYPE_NORMAL
- en: Locator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Locator provides either an approximate location for an address based on street
    addressing data, known as **geocoding**. The locator can also perform **reverse
    geocoding**, which provides an approximate address for a point on the map based
    on that same street data. ESRI provides geocoding services on a national and world
    level, but if you have more up-to-date street information, you can publish your
    own geocoding service on ArcGIS Server.
  prefs: []
  type: TYPE_NORMAL
- en: For address location, the locator accepts a parameter object containing either
    a single line input, or an object containing a Street, City, State, and Zone (zip
    code) parameter. The `callback` function that accepts the `Locator.execute()`
    results should accept a list of objects called `AddressCandidates`. These `AddressCandidates`
    include the possibly matching street address, the point location of the address,
    and a score from 0 to 100, where 100 is a perfect match. If no results return
    there were no matches for the address provided.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks requiring server extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While ArcGIS Server packs a lot of functionality, ESRI also provides server
    extensions, or optional software that performs specific tasks through ArcGIS Server.
    This software can do a number of unique tasks, from providing driving directions
    to sifting through tweets in your area. You will need to know if your server has
    one or more of these extensions before trying to use them. We'll take a look at
    one of them, the Routing Task.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Routing Tasks can provide driving directions, calculate the most effective routes,
    and redirect users around known roadblocks. The Routing Tasks require the Network
    Analyst extension for ArcGIS Server. For Routing Parameters, you can add a `FeatureSet`
    into the stop parameter, and fill it with graphics defining the various stops
    our vehicle has to make. You can also supply barriers in the same way, which block
    certain roadways. When the Routing Task is executed, it returns a best route based
    on the street data provided to the service.
  prefs: []
  type: TYPE_NORMAL
- en: Dijits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ArcGIS API for JavaScript also provides Dojo widgets, commonly referred
    to as **dijits**. Many of these dijits offer a **user interface** (**UI**) with
    existing API modules working in the background. Using these dijits can cut development
    time by providing well-used and tested UI components. Dijit documentation also
    shows the CSS classes used to style the dijits, so that developers and designers
    can restyle them to fit the theme of the page. Let's take a look at the more commonly
    used dijits.
  prefs: []
  type: TYPE_NORMAL
- en: Measurement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Measurement dijit provides a tool that can be used to measure distances,
    areas, and perimeters of locations on the map. It can also get the latitude and
    longitude of points on the map. The dijit uses the drawing toolbar to draw shapes
    on the map. From there, it sends a request to a `GeometryService`. Once the dijit
    has retrieved its results, it either displays the latitude and longitude of a
    point, shows the length of the line drawn on the map, or displays the area and
    perimeter of the polygon area drawn on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Print
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Print dijit provides a dropdown control that lets the user select from a
    predefined list of print templates and parameters. The developer configures the
    dijit with a link to an ArcGIS Server print service, and a list of predefined
    print parameters. When the user selects from one of the dropdown choices, the
    `printTask` incorporated in the Print dijit fires off an `execute()` method with
    the corresponding print parameters. When the `printTask` receives a success response
    from the server, the dijit provides a link to click on to download the printout.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more granularity in your print control, this dijit is not for you.
    This tool is not meant to handle every combination of print parameters. If you're
    required to support everything from Tabloid ANSI B Landscape `.pdf` documents
    to Letter ANSI A Portrait `.gif` images, and everything else in between, you should
    consider developing your own tool.
  prefs: []
  type: TYPE_NORMAL
- en: Bookmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Bookmarks dijit allows the user to save custom areas on the map. You can
    pre-assign bookmarked areas in the configuration file that the user can click
    and zoom to. They can also add areas to a list, edit the names, and delete the
    custom areas they want to zoom to. The Bookmarks dijit does not save the map state,
    meaning that the layers that were turned on previously won't be automatically
    switched, and the selected graphics on the map may not be there.
  prefs: []
  type: TYPE_NORMAL
- en: Basemaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ArcGIS API provides a couple dijits for changing your basemaps. This can
    be useful when the data blends in or doesn't look right against the current background.
    The first tool the API provides is a `BasemapToggle`, which lets you switch between
    two basemaps. The second is the `BasemapGallery`, which offers more choices. Both
    provide thumbnail photos and captions describing the basemaps.
  prefs: []
  type: TYPE_NORMAL
- en: The `BasemapGallery` can be customized to show your custom basemaps, or show
    basemaps from ArcGIS Online. When constructing the `BasemapGallery`, the choice
    of incorporating ArcGIS Online basemaps can be modified by setting the `showArcGISBasemaps`
    option to true. Remember the rule about tiled map services, however. The ArcGIS
    Online basemaps are in Web Mercator Auxiliary Sphere (WKID 102100), which is the
    same projection as Google and Bing Maps. If your data is not in the same projection,
    you could have issues with accuracy and/or missing tiled layers.
  prefs: []
  type: TYPE_NORMAL
- en: Popups and InfoWindows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Popups and `InfoWindows` provide a small window to view data about features
    on a map. There are four varieties of the `infoWindows` available: The legacy
    version that was replaced in version 3.4, a smaller version of the legacy `infoWindow`
    called `InfoWindowLite`, the current default popup control, and a lighter mobile
    version of the current popup.'
  prefs: []
  type: TYPE_NORMAL
- en: The current popup exposes a number of elements that you can tap into to customize
    the user experience. The popup can select multiple features, and holds the graphics
    content of the selected items in a features array. It also has a paging control
    that lets the user click to see what other features have been selected. It also
    keeps track of which feature is selected through a `selectedIndex` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Editing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The editing dijits provide UI components and tools that you can use to edit
    features on the map. These tools work with editable `FeatureLayers`, allowing
    the user to edit shapes, add features on the map, change attributes, and save
    all those changes to the server. Let's look at some of the components that make
    up the editing tools.
  prefs: []
  type: TYPE_NORMAL
- en: AttributeInspector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AttributeInspector` allows the user to edit graphic attribute data from
    an HTML form. The inspector connects to the `FeatureLayer` and displays data on
    one of the features that is selected. The inspector also provides a previous and
    next button to search through the selected Features. The `AttributeInspector`
    also supplies a delete button to delete selected features.
  prefs: []
  type: TYPE_NORMAL
- en: The inspector then builds a form based on the requirements of the features.
    Dates will be given calendars, and domain-bound fields will show an HTML Select
    element with a dropdown list of domain choices. The user can type in and edit
    data, and the data can be saved server-side.
  prefs: []
  type: TYPE_NORMAL
- en: TemplatePicker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TemplatePicker` provides a selector to select what feature types and subtypes
    you'll be editing. When a `featureLayer` is published as editable, it has to expose
    the symbology and preset styles through the REST service. The `TemplatePicker`
    then reads the exposed symbology and feature setup data to create a grid of valid
    editable choices. The user clicks on the templates like a button, and the symbology
    is passed to a drawing tool of some kind.
  prefs: []
  type: TYPE_NORMAL
- en: An all-in-one Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ArcGIS API provides an all-in-one **Editor** dijit to provide some basic
    editing needs. The dijit incorporates the `TemplatePicker` to select features
    types and subtypes to draw from. It also has a toolbar with various tools, pertaining
    to the editable features on the map. So, when you select a green line, the tool
    will show line-related drawing tools.
  prefs: []
  type: TYPE_NORMAL
- en: The Editor also generates an `AttributeInspector` in the `map.infoWindow`. You
    can edit field values from the popup. It is up to you how you implement saving
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: The editor also provides undo and redo buttons in the toolbar. If you accidently
    delete a feature you wanted to save, you can use the undo button. If you realize
    that you really wanted to delete that feature, you can click the redo button.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have been exposed to most of the major features of the ArcGIS API
    for JavaScript, you are better prepared to write some more code using the API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've taken a whirlwind tour of the ArcGIS API for JavaScript.
    We've gained familiarity with how the website and API is organized. We've studied
    the Map object in detail, looking at all its parts. We've looked over the other
    parts of the API, including layers, graphics, toolbars, tasks, and dijits. We've
    discussed how each of these are implemented, and some use cases for them. Now
    that we know more about the parts of the API, we can use these components to create
    custom applications and widgets in the next chapter.
  prefs: []
  type: TYPE_NORMAL
