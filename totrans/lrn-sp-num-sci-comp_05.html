<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;SciPy for Signal Processing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. SciPy for Signal Processing</h1></div></div></div><p>We define a signal as data that measures either time-varying or spatially varying phenomena. Sound or electrocardiograms are excellent examples of time-varying quantities, while images embody the quintessential spatially varying cases. Moving images (movies or videos) are treated with the techniques of both types of signals, obviously.</p><p>The field of signal processing treats four aspects of this kind of data – its acquisition, quality improvement, compression, and feature extraction. SciPy has many routines to treat tasks effectively in any of the four fields. All these are included in two low-level modules (<code class="literal">scipy.signal</code> being the main one, with an emphasis in time-varying data, and <code class="literal">scipy.ndimage</code>, for images). Many of the routines in these two modules are based on Discrete Fourier Transform of the data.</p><p>In this chapter, we will cover the following things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Definition of background algorithms, <code class="literal">scipy.fftpack</code></li><li class="listitem" style="list-style-type: disc">Built-in functions for signal construction</li><li class="listitem" style="list-style-type: disc">Presentation of functions to filter spatial or time series signals</li></ul></div><p>Additional details on the subject can be found in <span class="emphasis"><em>Python for Signal Processing</em></span>, <span class="emphasis"><em>Unpingco José</em></span>, <span class="emphasis"><em>Springer Publishing</em></span>.</p><div class="section" title="Discrete Fourier Transforms"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Discrete Fourier Transforms</h1></div></div></div><p>Discrete Fourier Transform (DFT) transforms any signal from its time/space domain into a related signal in frequency domain. This allows <a id="id240" class="indexterm"/>us not only to analyze the different frequencies of the data, but also enables faster filtering operations, when used properly. It is possible to turn a signal in frequency domain back to its time/spatial domain, thanks to the Inverse Fourier Transform (IFT). We will not go into details of the mathematics behind these operators, since we assume familiarity at some level with this theory. We will focus on syntax and applications instead.</p><p>The basic routines in the <code class="literal">scipy.fftpack</code> module compute the DFT and its inverse, for discrete signals in any dimension – <code class="literal">fft</code>, <code class="literal">ifft</code> (one dimension); <code class="literal">fft2</code>, <code class="literal">ifft2</code> (two dimensions); <code class="literal">fftn</code>, <code class="literal">ifftn</code> (any number of dimensions). All of these routines assume that the data is complex valued. If we know beforehand that a particular dataset is actually real valued, and should offer real-valued frequencies, we use <code class="literal">rfft</code> and <code class="literal">irfft</code> instead, for a faster algorithm. All these routines are designed so that composition with their inverses always yields the identity. The syntax is the same in all cases, as follows:</p><div class="informalexample"><pre class="programlisting">fft(x[, n, axis, overwrite_x])</pre></div><p>The first <a id="id241" class="indexterm"/>parameter, <code class="literal">x</code>, is always the signal in any array-like form. Note that <code class="literal">fft</code> performs one-dimensional transforms. This means that if <code class="literal">x</code> happens to be two-dimensional, for example, <code class="literal">fft</code> will output another two-dimensional array where each row is the transform of each row of the original. We can use columns instead, with the optional parameter, <code class="literal">axis</code>. The rest of the parameters are also optional; <code class="literal">n</code> indicates the length of the transform and <code class="literal">overwrite_x</code> gets rid of the original data to save memory and resources. We usually play with the integer <code class="literal">n</code> when we need to pad the signal with zeros, or truncate it. For a higher dimension, <code class="literal">n</code> is substituted by <code class="literal">shape</code> (a tuple), and <code class="literal">axis</code> by <code class="literal">axes</code> (another tuple).</p><p>To better understand the output, it is often useful to shift the zero frequencies to the center of the output arrays with <code class="literal">fftshift</code>. The inverse of this operation, <code class="literal">ifftshift</code>, is also included in the module. The following code shows some of these routines in action when applied to a checkerboard image:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.fftpack import fft,fft2, fftshift</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; B=numpy.ones((4,4)); W=numpy.zeros((4,4))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; signal = numpy.bmat("B,W;W,B")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; onedimfft = fft(signal,n=16)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; twodimfft = fft2(signal,shape=(16,16))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.figure()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.gray()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(121,aspect='equal')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.pcolormesh(onedimfft.real)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.colorbar(orientation='horizontal')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(122,aspect='equal')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.pcolormesh(fftshift(twodimfft.real))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.colorbar(orientation='horizontal')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>Note how the first four rows of the one-dimensional transform are equal (and so are the last four), while the two-dimensional transform (once shifted) presents a peak at the origin and nice symmetries in the frequency domain.</p><p>In the following screenshot, which has been obtained from the previous code, the image on the left is <code class="literal">fft</code> and the one on the right is <code class="literal">fft2</code> of a 2 x 2 checkerboard signal:</p><div class="mediaobject"><img src="graphics/7702OS_05_01.jpg" alt="Discrete Fourier Transforms"/></div><p>The <code class="literal">scipy.fftpack</code> module also offers the Discrete Cosine Transform with its inverse (<code class="literal">dct</code>, <code class="literal">idct</code>) as <a id="id242" class="indexterm"/>well as many differential and pseudo-differential operators defined in terms of all these transforms – <code class="literal">diff</code> (for derivative/integral); <code class="literal">hilbert</code>, <code class="literal">ihilbert</code> (for the Hilbert transform); <code class="literal">tilbert</code>, <code class="literal">itilbert</code> (for the h-Tilbert transform of periodic sequences); and so on. </p></div></div>
<div class="section" title="Signal construction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Signal construction</h1></div></div></div><p>To aid<a id="id243" class="indexterm"/> the construction of signals with predetermined properties, the <code class="literal">scipy.signal</code> module has a nice collection of the most frequent one-dimensional waveforms in the literature – <code class="literal">chirp</code> and <code class="literal">sweep_poly</code> (for the frequency-swept cosine generator), <code class="literal">gausspulse</code> (a Gaussian modulated sinusoid), <code class="literal">sawtooth</code> and <code class="literal">square</code> (for the waveforms with those names). They all take as their main parameter a one-dimensional <code class="literal">ndarray</code> representing the times at which the signal is to be evaluated. Other parameters control the design of the signal according to frequency or time constraints. Let's take a look into the following code snippet which illustrates the use of these one dimensional waveforms that we just discussed:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.signal import chirp, sawtooth, square, gausspulse</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; t=numpy.linspace(-1,1,1000)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(221); plt.ylim([-2,2])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(t,chirp(t,f0=100,t1=0.5,f1=200))   # plot a chirp</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.title("Chirp signal")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(222); plt.ylim([-2,2])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(t,gausspulse(t,fc=10,bw=0.5))      # Gauss pulse</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.title("Gauss pulse")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(223); plt.ylim([-2,2])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; t*=3*numpy.pi</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(t,sawtooth(t))                     # sawtooth</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.xlabel("Sawtooth signal")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(224); plt.ylim([-2,2])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(t,square(t))                       # Square wave</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.xlabel("Square signal")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>Generated<a id="id244" class="indexterm"/> by this code, the following diagram shows waveforms for <code class="literal">chirp</code>, <code class="literal">gausspulse</code>, <code class="literal">sawtooth</code>, and <code class="literal">square</code>:</p><div class="mediaobject"><img src="graphics/7702OS_05_02.jpg" alt="Signal construction"/></div><p>The usual method of creating signals is to import them from a file. This is possible by using purely NumPy routines; for example, <code class="literal">fromfile</code>:</p><div class="informalexample"><pre class="programlisting">fromfile(file, dtype=float, count=-1, sep='')</pre></div><p>The <code class="literal">file</code> argument may point to either a file or a string, the <code class="literal">count</code> argument is used to determine the number of items to read, and <code class="literal">sep</code> indicates what constitutes a separator in the original file/string. For images, we have the versatile routine, <code class="literal">imread</code> in in either the <code class="literal">scipy.ndimage</code> or <code class="literal">scipy.misc</code> module:</p><div class="informalexample"><pre class="programlisting">imread(fname, flatten=False)</pre></div><p>The <code class="literal">fname</code> argument is a string containing the location of an image. The routine infers the type<a id="id245" class="indexterm"/> of file, and reads the data into array accordingly. In case if the <code class="literal">flatten</code> argument is turned to <code class="literal">True</code>, the image is converted to gray scale. Note that, in order for <code class="literal">fromfile</code> and <code class="literal">imread</code> to work, the <span class="strong"><strong>Python Imaging Library</strong></span> (<span class="strong"><strong>PIL</strong></span>) needs<a id="id246" class="indexterm"/> to be installed.</p><p>It is also possible to load <code class="literal">.wav</code> files for analysis, with the <code class="literal">read</code> and <code class="literal">write</code> routines from the <code class="literal">wavfile</code> submodule in the <code class="literal">scipy.io</code> module. For instance, the following line of code reads an audio file, say <code class="literal">audio.wav</code>, using the <code class="literal">read</code> routine:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; rate,data = scipy.io.wavfile.read("audio.wav")</strong></span>
</pre></div><p>The command assigns an integer value to the <code class="literal">rate</code> variable, indicating the sample rate of the file (in samples per second), and a NumPy <code class="literal">ndarray</code> to the <code class="literal">data</code> variable, containing the numerical values assigned to the different notes. If we wish to write some one-dimensional <code class="literal">ndarray data</code> into an audio file of this kind, with the sample rate given by the <code class="literal">rate</code> variable, we may do so by issuing the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; scipy.io.wavfile.write("filename.wav",rate,data)</strong></span>
</pre></div></div>
<div class="section" title="Filters"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Filters</h1></div></div></div><p>A filter<a id="id247" class="indexterm"/> is an operation on signals that either removes features or extracts some component. SciPy has a complete set of known filters as well as the tools to allow construction of new ones. The complete list of filters in SciPy is long, and we encourage the reader to explore the help documents of the <code class="literal">scipy.signal</code> and <code class="literal">scipy.ndimage</code> modules for the complete picture. We will introduce in these pages, as an exposition, some of the most used filters in the treatment of audio or image processing.</p><p>We start by creating a signal worth filtering:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from numpy import sin, cos, pi, linspace</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; f=lambda t: cos(pi*t) + 0.2*sin(5*pi*t+0.1) + 0.2*sin(30*pi*t) + 0.1*sin(32*pi*t+0.1) + 0.1*sin(47* pi*t+0.8)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; t=linspace(0,4,400); signal=f(t)</strong></span>
</pre></div><p>First, we test the classical smoothing filter of <span class="strong"><strong>Wiener</strong></span> and <span class="strong"><strong>Kolmogorov</strong></span>, <code class="literal">wiener</code>. We present in a <code class="literal">plot</code> the original signal (in black) and the corresponding filtered data, with a choice of Wiener <a id="id248" class="indexterm"/>window of size 55 samples (in blue). Next we compare<a id="id249" class="indexterm"/> the<a id="id250" class="indexterm"/> result of applying the median filter, <code class="literal">medfilt</code>, with a kernel of the same size as before (in red):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from scipy.signal import wiener, medfilt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pylab as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(t,signal,'k', label='The signal')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(t,wiener(signal,mysize=55),'r',linewidth=3, label='Wiener filtered')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(t,medfilt(signal,kernel_size=55),'b',linewidth=3, label='Medfilt filtered')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.legend()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>This gives us the following graph showing the comparison of smoothing filters (<span class="strong"><strong>Wiener</strong></span>, in red, is the one that has its starting point just above <span class="strong"><strong>0.5</strong></span> and <span class="strong"><strong>Medfilt</strong></span>, in blue, has its starting point just below <span class="strong"><strong>0.5</strong></span>):</p><div class="mediaobject"><img src="graphics/7702OS_05_03.jpg" alt="Filters"/></div><p>Most of the filters in the <code class="literal">scipy.signal</code> module can be adapted to work with arrays of any dimension. But in the particular case of images, we prefer to use the implementations in the <code class="literal">scipy.ndimage</code> module, since they are coded with these objects in mind. For instance, to <a id="id251" class="indexterm"/>perform a median filter on an image for smoothing, we use <code class="literal">scipy.ndimage.median_filter</code>. Let us show an example. We will start by loading Lena to array, and corrupting the image with Gaussian noise (zero mean and standard deviation of 16):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from scipy.stats import norm     # Gaussian distribution</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import scipy.misc</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import scipy.ndimage</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.gray()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; lena=scipy.misc.lena().astype(float)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(221);</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(lena)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; lena+=norm(loc=0,scale=16).rvs(lena.shape)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(222);</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(lena)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; denoised_lena = scipy.ndimage.median_filter(lena,3)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(224); </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(denoised_lena)</strong></span>
</pre></div><p>The set of filters for images come in two flavors – statistical and morphological. For example, among the filters of statistical nature, we have the <span class="strong"><strong>Sobel</strong></span> algorithm oriented to detection<a id="id252" class="indexterm"/> of edges (singularities along curves). Its syntax is as follows:</p><div class="informalexample"><pre class="programlisting">sobel(image, axis=-1, output=None, mode='reflect', cval=0.0)</pre></div><p>The optional parameter, <code class="literal">axis</code>, indicates the dimension in which the computations are performed. By default, this is always the last axis (-1). The <code class="literal">mode</code> parameter, which is one of the strings <code class="literal">'reflect'</code>, <code class="literal">'constant'</code>, <code class="literal">'nearest'</code>, <code class="literal">'mirror'</code>, or <code class="literal">'wrap'</code>, indicates how to handle the border of the image in case there is insufficient data to perform the computations there. In case <code class="literal">mode</code> is <code class="literal">'constant'</code>, we may indicate the value to use in the border with the <code class="literal">cval</code> parameter. Let's look into the following code snippet which illustrates the use of <code class="literal">sobel</code> filter: </p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from scipy.ndimage.filters import sobel</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; lena=scipy.misc.lena()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sblX=sobel(lena,axis=0); sblY=sobel(lena,axis=1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sbl=numpy.hypot(sblX,sblY)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(223); </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(sbl) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>The following screenshot illustrates the previous two filters in action—Lena (upper-left), noisy <a id="id253" class="indexterm"/>Lena (upper-right), edge map with sobel (lower-left), and median filter (lower-right):</p><div class="mediaobject"><img src="graphics/7702OS_05_04.jpg" alt="Filters"/></div><div class="section" title="The LTI system theory"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>The LTI system theory</h2></div></div></div><p>To <a id="id254" class="indexterm"/>investigate the response of a time-invariant linear system<a id="id255" class="indexterm"/> to input signals, we have many resources in the <code class="literal">scipy.signal</code> module. As a matter of fact, to simplify representation of objects, we have an <code class="literal">lti</code> class (linear-time invariant class) with associated methods such as <code class="literal">bode</code> (to calculate bode magnitude and phase data), <code class="literal">impulse</code>, <code class="literal">output</code>, and <code class="literal">step</code>.</p><p>Whether we are working with continuous or discrete-time linear systems, we have routines to simulate such systems (<code class="literal">lsim</code> and <code class="literal">lsim2</code> for continuous, <code class="literal">dsim</code> for discrete), as well as compute impulses (<code class="literal">impulse</code> and <code class="literal">impulse2</code> for continuous, <code class="literal">dimpulse</code> for discrete) and steps (<code class="literal">step</code> and <code class="literal">step2</code> for continuous, <code class="literal">dstep</code> for discrete).</p><p>Transforming a system from continuous to discrete is possible with <code class="literal">cont2discrete</code>, but in either case we are able to provide for any system with any of its representations, as well as to convert from one to another. For instance, if we have the zeros <code class="literal">z</code>, poles <code class="literal">p</code>, and system gain <code class="literal">k</code> of the transfer function, we may obtain the polynomial representation (numerator first, then denominator) with <code class="literal">zpk2tf(z,p,k)</code>. If we have numerator (<code class="literal">num</code>) and denominator (<code class="literal">dem</code>) of the transfer function, we obtain the state-space with <code class="literal">tf2ss(num,dem)</code>. This operation is reversible with the <code class="literal">ss2tf</code> routine. The change of representation<a id="id256" class="indexterm"/> from zero-pole-gain to/from state-space is also<a id="id257" class="indexterm"/> contemplated in the (<code class="literal">zpk2ss</code>, <code class="literal">ss2zpk</code>) module.</p></div><div class="section" title="Filter design"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Filter design</h2></div></div></div><p>There are <a id="id258" class="indexterm"/>routines in the <code class="literal">scipy.signal</code> module that allow the creation of different kinds of filters with diverse methods. For instance, the <code class="literal">bilinear</code> function<a id="id259" class="indexterm"/> returns a digital filter from an analog using a bilinear transform. <span class="strong"><strong>Finite impulse response</strong></span> (<span class="strong"><strong>FIR</strong></span>) filters can be designed by the window method with the <code class="literal">firwin</code> and <code class="literal">firwin2</code> routines. <span class="strong"><strong>Infinite impulse response</strong></span> (<span class="strong"><strong>IIR</strong></span>) filters<a id="id260" class="indexterm"/> can be designed in two different ways, via <code class="literal">iirdesign</code> or <code class="literal">iirfilter</code>. <span class="strong"><strong>Butterworth</strong></span> filters can be designed with the <code class="literal">butter</code> routine. There <a id="id261" class="indexterm"/>are also routines to design filters of <span class="strong"><strong>Chebyshev</strong></span> (<code class="literal">cheby1</code>, <code class="literal">cheby2</code>), <span class="strong"><strong>Cauer</strong></span> (<code class="literal">ellip</code>), and Bessel (<code class="literal">bessel</code>).</p></div><div class="section" title="Window functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Window functions</h2></div></div></div><p>No signal processing computational system would be complete without an extensive list of windows—mathematical functions that are zero valued outside specific domains. In this section, we will use a few of the coded windows implemented in the <code class="literal">scipy.signal</code> module to design very simple smoothing filters by using convolution. </p><p>We will be testing them on the same one-dimensional signal we employed before, for comparison.</p><p>We start by showing the plot of four well-known window functions – Boxcar, Hamming, Blackman-Harris (Nuttall version), and triangular. We will use a size of 31 samples:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from scipy.signal import boxcar, hamming, nuttall, triang</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pylab as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; windows=['boxcar', 'hamming', 'nuttall', 'triang']</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(121)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; for w in windows:</strong></span>
<span class="strong"><strong>        eval( 'plt.plot(' + w + '(31))' )</strong></span>
<span class="strong"><strong>        plt.ylim([-0.5,2]); plt.xlim([-1,32])</strong></span>
<span class="strong"><strong>        plt.legend(windows)</strong></span>
</pre></div><p>We need to extend the original signal by fifteen samples for plotting purposes:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.subplot(122)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from numpy import sin, cos, pi, linspace</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; f=lambda t: cos(pi*t) + 0.2*sin(5*pi*t+0.1) + 0.2*sin(30*pi*t) + 0.1*sin(32*pi*t+0.1) + 0.1*sin(47* pi*t+0.8)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; t=linspace(0,4,400); signal=f(t)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; extended_signal=numpy.r_[signal[15:0:-1],signal,signal[-1:-15:- 1]]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(extended_signal,'k')</strong></span>
</pre></div><p>The final <a id="id262" class="indexterm"/>step is the filter itself, which we perform by a simple convolution:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; for w in windows:</strong></span>
<span class="strong"><strong>        window = eval( w+'(31)')</strong></span>
<span class="strong"><strong>        output=numpy.convolve(window/window.sum(),signal)</strong></span>
<span class="strong"><strong>        plt.plot(output,linewidth=2)</strong></span>
<span class="strong"><strong>        plt.ylim([-2,3]); plt.legend(['original']+windows)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>This produces the following output, showing convolution of a signal with different windows:</p><div class="mediaobject"><img src="graphics/7702OS_05_05.jpg" alt="Window functions"/></div></div><div class="section" title="Image interpolation"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Image interpolation</h2></div></div></div><p>The set <a id="id263" class="indexterm"/>of filters on images that performs some geometric<a id="id264" class="indexterm"/> manipulation of the input is classically termed image interpolation, since this numerical technique is the root of all the algorithms. As a matter of fact, SciPy collects all these under the submodule, <code class="literal">scipy.ndimage.interpolation</code>, for ease of access. This section is best explained through examples, going over the most meaningful routines for geometric transformation. The starting point is the image, Lena. We now assume that all functions from the submodule have been imported into the session.</p><p>We need to apply an affine transformation on the domain of the image, given in matrix form as follows:</p><div class="mediaobject"><img src="graphics/7702OS_05_06.jpg" alt="Image interpolation"/></div><p>To apply<a id="id265" class="indexterm"/> the transformation on the domain of the image we<a id="id266" class="indexterm"/> issue the <code class="literal">affine_transform</code> command (note that the syntax is self-explanatory):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import scipy.misc</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import numpy </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pylab as plt </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.ndimage.interpolation import affine_transform</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; lena=scipy.misc.lena() </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; A=numpy.mat("0,1;-1,1.25"); b=[-400,0]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Ab_Lena=affine_transform(lena,A,b,output_shape=(512*2.2,512*2.2))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.gray() </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(121) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(Ab_Lena)</strong></span>
</pre></div><p>For a general transformation, we use the <code class="literal">geometric_transform</code> routine with the following syntax:</p><div class="informalexample"><pre class="programlisting">geometric_transform(input, mapping, output_shape=None, 
                    output=None, order=3, mode='constant',
cval=0.0, prefilter=True, extra_arguments=(),
extra_keywords={})</pre></div><p>We need to provide a rank-2 map from tuples to tuples as the parameter mapping. For instance, we desired to apply the <span class="strong"><strong>Möbius</strong></span> transform for complex-valued number <code class="literal">z</code> (where we assume the values of <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, and <code class="literal">d</code> are already defined and they are complex-valued numbers) in the following formula:</p><div class="mediaobject"><img src="graphics/7702OS_05_07.jpg" alt="Image interpolation"/></div><p>We would have to code it in the following way:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; def f(z):</strong></span>
<span class="strong"><strong>        temp = a*(z[0]+1j*z[1]) + b</strong></span>
<span class="strong"><strong>        temp /= c*(z[0]+1j*z[1])+d</strong></span>
<span class="strong"><strong>        return (temp.real, temp.imag)</strong></span>
</pre></div><p>In both <a id="id267" class="indexterm"/>functions, the values of the grid that cannot be computed<a id="id268" class="indexterm"/> directly with the formula are inferred with spline interpolation. We may specify the order of this interpolation with the <code class="literal">order</code> parameter. The points outside the domain of definition are not interpolated, but filled according to some predetermined rule. We may impose this rule by passing a string to the <code class="literal">mode</code> option. The choices are – <code class="literal">'constant'</code>, to use a constant value that we may impose with the <code class="literal">cval</code> option; <code class="literal">'nearest'</code>, that continues the last value of the interpolation on each level line; and <code class="literal">'reflect'</code> or <code class="literal">'wrap'</code>, which are self-explanatory.</p><p>For example, for the values <code class="literal">a = 2**15*(1+1j)</code>, <code class="literal">b = 0</code>, <code class="literal">c = -2**8*(1-1j*2)</code>, and <code class="literal">d = 2**18-1j*2**14</code>, we obtain (after imposing the <code class="literal">reflect</code> mode) the result, as shown just after this line of code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from scipy.ndimage.interpolation import geometric_transform </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; a = 2**15*(1+1j); b = 0; c = -2**8*(1-1j*2); d = 2**18-1j*2**14</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Moebius_Lena = geometric_transform(lena,f,mode='reflect')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(122); </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(Moebius_Lena) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>The following screenshot shows affine transformation (left) and geometric transformation (right):</p><div class="mediaobject"><img src="graphics/7702OS_05_08.jpg" alt="Image interpolation"/></div><p>For special<a id="id269" class="indexterm"/> cases of rotations, shifts, or dilations, we have the syntactic sugar routines, <code class="literal">rotate(input,angle)</code>, <code class="literal">shift(input, offset)</code>, and <code class="literal">zoom(input,dilation_factor)</code>.</p><p>Given any <a id="id270" class="indexterm"/>image, we know the value of the array at pixel values (with integer coordinates) in the domain. But what would the corresponding value of a location be without integer coordinates? We may obtain that information with the valuable routine, map_coordinates. Note that the syntax may be confusing, especially with the <code class="literal">coordinates</code> parameter:</p><div class="informalexample"><pre class="programlisting">map_coordinates(input, coordinates, output=None, order=3, 
                mode='constant', cval=0.0, prefilter=True)</pre></div><p>For instance, if we wish to evaluate Lena at the locations (10.5, 11.7) and (12.3, 1.4), we collect the coordinates as a sequence of sequences; the first internal sequence contains the <code class="literal">x</code> values, and the second, the <code class="literal">y</code> values. We may specify the order of splines used with <code class="literal">order</code>, and the interpolation scheme outside of the domain, if needed, as in the previous examples. Let's evaluate Lena at the locations (which we just discussed in our example) using following code snippet:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import scipy.misc </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.ndimage.interpolation import map_coordinates</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; lena=scipy.misc.lena().astype(float)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; coordinates=[[10.5, 12.3], [11.7, 1.4]]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; map_coordinates(lena, coordinates, order=1)</strong></span>
</pre></div><p>The output is shown as:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 157.2 ,  157.42])</strong></span>
</pre></div><p>Further, we <a id="id271" class="indexterm"/>evaluate Lena with <code class="literal">order=2</code> as shown in following line of code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; map_coordinates(lena, coordinates, order=2)</strong></span>
</pre></div><p>The<a id="id272" class="indexterm"/> output is shown as:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>array([ 157.80641507,  157.6741489 ])</strong></span>
</pre></div></div><div class="section" title="Morphology"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Morphology</h2></div></div></div><p>We also<a id="id273" class="indexterm"/> have the possibility of creating and applying filters to images <a id="id274" class="indexterm"/>based on mathematical morphology, both to binary and gray-scale images. The four basic morphological operations are opening (<code class="literal">binary_opening</code>), closing (<code class="literal">binary_closing</code>), dilation (<code class="literal">binary_dilation</code>), and erosion (<code class="literal">binary_erosion</code>). Note that the syntax of each of these filters is very simple, since we only need two ingredients – the signal to filter and the structuring element to perform the morphological operation. Let's take a look into the general syntax for these morphological operations:</p><div class="informalexample"><pre class="programlisting">binary_operation(signal, structuring_element)</pre></div><p>We have illustrated the use some of these operations towards an application to obtain the structural model of an oxide, but we will postpone this example until we cover the notions of triangulations and Voronoi diagrams in <a class="link" href="ch07.html" title="Chapter 7. SciPy for Computational Geometry">Chapter 7</a>, <span class="emphasis"><em>SciPy for Computational Geometry</em></span>.</p><p>We may use combinations of these four basic morphological operations to create more complex filters for the removal of holes, hit-or-miss transforms (to find the location of specific patterns in binary images), denoising, edge detection, and many more. The module even provides us with some of the most common filters constructed this way. For instance, for the location of the letter e in a text (which we covered in <a class="link" href="ch02.html" title="Chapter 2. Working with the NumPy Array As a First Step to SciPy">Chapter 2</a>, <span class="emphasis"><em>Working with the NumPy Array As a First Step to SciPy</em></span>, as an application of correlation), we could use the following command instead:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; binary_hit_or_miss(text, letterE)</strong></span>
</pre></div><p>For comparative purposes, let's apply this command to the example from <a class="link" href="ch02.html" title="Chapter 2. Working with the NumPy Array As a First Step to SciPy">Chapter 2</a>, <span class="emphasis"><em>Working with the NumPy Array As a First Step to SciPy</em></span>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import scipy.ndimage</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pylab as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.ndimage.morphology import binary_hit_or_miss</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; text = scipy.ndimage.imread('CHAP_05_input_textImage.png')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; letterE = text[37:53,275:291]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; HitorMiss = binary_hit_or_miss(text, structure1=letterE, origin1=1) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; eLocation = numpy.where(HitorMiss==True)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; x=eLocation[1]; y=eLocation[0]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(text, cmap=plt.cm.gray, interpolation='nearest')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.autoscale(False)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(x,y,'wo',markersize=10)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.axis('off')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>This<a id="id275" class="indexterm"/> generates the following output, which the reader should compare with <a id="id276" class="indexterm"/>the corresponding one on <a class="link" href="ch02.html" title="Chapter 2. Working with the NumPy Array As a First Step to SciPy">Chapter 2</a>, <span class="emphasis"><em>Working with the NumPy Array As a First Step to SciPy</em></span>:</p><div class="mediaobject"><img src="graphics/7702OS_05_09.jpg" alt="Morphology"/></div><p>For gray-scale images, we may use a structuring element (<code class="literal">structuring_element</code>) or a footprint. The syntax is, therefore, a little different:</p><div class="informalexample"><pre class="programlisting">grey_operation(signal, [structuring_element, footprint, size, ...])
</pre></div><p>If we desire to use a completely flat and rectangular structuring element (all <span class="emphasis"><em>ones</em></span>), then it is enough to indicate the size as a tuple. For instance, to perform gray-scale dilation of a flat element of <code class="literal">size (15,15)</code> on our classical image of Lena, we issue the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; grey_dilation(lena, size=(15,15))</strong></span>
</pre></div><p>The last kind of morphological operations coded in the scipy.ndimage module perform distance and feature transforms. Distance transforms create a map that assigns to each pixel the distance to the nearest object. Feature transforms provide the index of the closest background element instead. These operations are used to decompose images into different labels. We may even choose different metrics such as Euclidean distance, chessboard distance, and <span class="strong"><strong>taxicab</strong></span> distance. The syntax for the distance transform (<code class="literal">distance_transform</code>) using a brute force algorithm is as follows:</p><div class="informalexample"><pre class="programlisting">distance_transform_bf(signal, metric='euclidean', sampling=None,
return_distances=True, return_indices=False,
                      distances=None, indices=None)</pre></div><p>We indicate the metric with the strings such as <code class="literal">'euclidean'</code>, <code class="literal">'taxicab'</code>, or <code class="literal">'chessboard'</code>. If we desire to provide the feature transform instead, we switch <code class="literal">return_distances</code> to <code class="literal">False</code> and <code class="literal">return_indices</code> to <code class="literal">True</code>.</p><p>Similar <a id="id277" class="indexterm"/>routines are available with more sophisticated algorithms – <code class="literal">distance_transform_cdt</code> (using chamfering for taxicab and chessboard distances). For<a id="id278" class="indexterm"/> Euclidean distance, we also have <code class="literal">distance_transform_edt</code>. All these use the same syntax.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, we explored signal processing (any dimensional), including the treatment of signals in frequency space, by means of their Discrete Fourier Transforms. These correspond to the <code class="literal">fftpack</code>, <code class="literal">signal</code>, and <code class="literal">ndimage</code> modules.</p><p>The <a class="link" href="ch06.html" title="Chapter 6. SciPy for Data Mining">Chapter 6</a>, <span class="emphasis"><em>SciPy for Data Mining</em></span>, will explore the tools included in SciPy to approach Statistical and Data Mining problems. In addition to standard statistical quantities, special topics like kernel estimation, statistical distances, and the clustering of big data sets will be presented.</p></div></body></html>