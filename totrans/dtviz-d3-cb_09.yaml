- en: Chapter 9. Lay Them Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 布局它们
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Building a pie chart
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建饼图
- en: Building a stacked area chart
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建堆叠面积图
- en: Building a treemap
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建树状图
- en: Building a tree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建树
- en: Building an enclosure diagram
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建围栏图
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'The D3 **layout** is the focus of this chapter—a concept we have not encountered
    before. As expected, D3 layouts are algorithms that calculate and generate placement
    information for a group of elements. However there are a few critical properties
    worth mentioning before we dive deeper into the specifics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是D3的**布局**——这是一个我们之前未曾遇到的概念。正如预期的那样，D3布局是一组算法，用于计算和生成一组元素的放置信息。然而，在我们深入具体细节之前，有一些关键属性值得提及：
- en: '**Layouts are data**: Layouts are purely data centric and data driven, they
    do not generate any graphical or display related output directly. This allows
    them to be used and reused with SVG or canvas or even when there is no graphical
    output'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局是数据**：布局完全是数据驱动的，它们不会直接生成任何图形或显示相关的输出。这使得它们可以与SVG或canvas一起使用，甚至在没有图形输出的情况下也可以重复使用'
- en: '**Abstract and reusable**: Layouts are abstract, allowing a high degree of
    flexibility and reusability. You can combine and reuse layouts in various different
    interesting ways.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象和可重用**：布局是抽象的，允许高度灵活性和可重用性。您可以通过各种不同的有趣方式组合和重用布局。'
- en: '**Layouts are different**: Each layout is different. Every layout provided
    by D3 focuses on a very special graphical requirement and data structure.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局是不同的**：每个布局都是不同的。D3提供的每个布局都专注于一个非常特殊的图形需求和数据结构。'
- en: '**Stateless**: Layouts are mostly stateless by design to simplify their usage.
    What statelessness means here is that generally layouts are like functions, they
    can be called multiple times with different input data and generate different
    layout output.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：布局主要是无状态的，以简化其使用。这里的无状态意味着布局通常像函数一样，可以用不同的输入数据多次调用，并生成不同的布局输出。'
- en: Layouts are interesting and powerful concepts in D3\. In this chapter we will
    explore some of the most commonly used layouts in D3 by creating fully functional
    visualization leveraging these layouts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是D3中有趣且强大的概念。在本章中，我们将通过创建利用这些布局的完整功能可视化来探索D3中最常用的布局。
- en: Building a pie chart
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建饼图
- en: 'A pie chart or a circle graph is a circular graph containing multiple sectors
    used to illustrate numerical proportion. We will explore techniques, involving
    D3 **pie layout**, to build a fully functional pie chart in this recipe. In [Chapter
    7](ch07.html "Chapter 7. Getting into Shape"), *Getting into Shape*, it becomes
    clear that using the D3 arc generator directly is a very tedious job. Each arc
    generator expects the following data format:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图或圆形图是一个包含多个扇区的圆形图，用于说明数值比例。在本配方中，我们将探索涉及D3 **饼图布局**的技术，以构建一个功能齐全的饼图。在[第7章](ch07.html
    "第7章. 进入形状")“进入形状”中，很明显，直接使用D3弧生成器是一个非常繁琐的工作。每个弧生成器都期望以下数据格式：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This essentially requires the calculation of the angle partition for each slice
    out of an entire circle of `2 * Math.PI`. Obviously this process can be automated
    by an algorithm which is exactly what `d3.layout.pie` is designed for. In this
    recipe, we will see how pie layout can be used to implement a fully functional
    pie chart.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上需要计算整个圆周`2 * Math.PI`中每个切片的角度分区。显然，这个过程可以通过一个算法自动完成，这正是`d3.layout.pie`设计的目的。在本配方中，我们将看到如何使用饼图布局来实现一个功能齐全的饼图。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pie-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pie-chart.html).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pie-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pie-chart.html).'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: A pie chart or a circle graph is a circular diagram divided into sectors (slices).
    Pie charts are popular in many fields and widely used to demonstrate relationships
    between different entities though not without criticism. Let's take a look at
    how a pie chart is implemented using `d3.pie.layout` first.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图或圆形图是一个分为扇区（切片）的圆形图。饼图在许多领域都很受欢迎，广泛用于展示不同实体之间的关系，尽管并非没有批评。让我们首先看看如何使用`d3.pie.layout`实现饼图。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This recipe generates the following pie chart:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方生成了以下饼图：
- en: '![How to do it...](img/2162OS_09_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2162OS_09_01.jpg)'
- en: Donut chart
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 圆环图
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe is built over what we have learned in the [Chapter 7](ch07.html
    "Chapter 7. Getting into Shape"), *Getting into Shape*. One major difference is
    that we rely on `d3.layout.pie` to transform the raw data into arcs data for us.
    The pie layout was created on line A with both sort and value accessors specified.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是在我们学到的[第7章](ch07.html "第7章。进入形状")，*进入形状*的基础上构建的。一个主要的不同之处在于，我们依赖于`d3.layout.pie`来为我们转换原始数据为弧数据。饼图布局在行A上创建，同时指定了排序和值访问器。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `sort` function tells the pie layout to sort slices by its ID field, so
    that we can maintain stable order amongst slices. Without the sorting, by default
    the pie layout will order the slices by value resulting in the swapping of slices
    whenever we update the pie chart. The `value` function is used to provide value
    accessor which in our case returns the `value` field. When rendering slices, now
    with the pie layout, we directly set the pie layout as data (remember layouts
    are data) to generate the arc `svg:path` elements (line B).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数告诉饼图布局按其ID字段对切片进行排序，这样我们就可以在切片之间保持稳定的顺序。如果没有排序，默认情况下，饼图布局将按值对切片进行排序，导致每次我们更新饼图时切片都会交换。`value`函数用于提供值访问器，在我们的例子中返回`value`字段。现在，在饼图布局中渲染切片时，我们直接将饼图布局作为数据（记住布局是数据）来生成弧`svg:path`元素（行B）。'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The rest of the rendering logic is pretty much the same as what we have learned
    in [Chapter 7](ch07.html "Chapter 7. Getting into Shape"), *Getting into Shape*,
    with one exception on line C. On line C we retrieve the current arc value from
    the element so the transition can start from the current angle instead of zero.
    Then on line D we reset the current arc value to the latest one so the next time
    when we update the pie chart data we can repeat the stateful transition.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的渲染逻辑基本上与我们学到的[第7章](ch07.html "第7章。进入形状")，*进入形状*中相同，只有一个例外是在行C。在行C中，我们从元素中检索当前弧值，以便过渡可以从当前角度开始而不是从零开始。然后在行D中，我们将当前弧值重置为最新值，这样下次我们更新饼图数据时，我们可以重复状态性过渡。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Technique – stateful visualization**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术 – 状态性可视化**'
- en: Technique of value injection on a DOM element is a common approach to introduce
    statefulness to your visualization. In other words, if you need your visualizations
    to remember what their previous states are, you can save them in DOM elements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DOM 元素上注入值的技术是将状态性引入你的可视化的常见方法。换句话说，如果你需要你的可视化记住它们之前的状态，你可以在 DOM 元素中保存它们。
- en: Finally we also need to render labels on each slice so our user can understand
    what each slice is representing. This is done by the `renderLabels` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要在每个切片上渲染标签，以便我们的用户可以理解每个切片代表什么。这是通过`renderLabels`函数完成的。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once again we use the pie layout as data to generate the `svg:text` elements.
    The placement of the labels is calculated using `arc.centroid` (line F). Additionally,
    the label placement is animated through the transition so they can be moved with
    arcs in unison.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用饼图布局作为数据来生成`svg:text`元素。标签的位置是通过`arc.centroid`（行F）计算的。此外，标签位置通过过渡进行动画处理，这样它们就可以与弧一起移动。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Pie charts are very widely used in many different domains. However, they have
    also been widely criticized due to the fact that they are difficult for human
    eyes to compare different sections of a given pie chart as well as their low information
    density. Therefore, it is highly recommended to limit the number of sections to
    less than 3, with 2 to be ideal. Otherwise, you can always use a bar chart or
    a small table to replace a pie chart in places with better precision and communicative
    power.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图在许多不同的领域中被广泛使用。然而，由于它们对于人类眼睛来说难以比较给定饼图的各个部分，以及它们的信息密度低，因此它们也受到了广泛的批评。因此，强烈建议将部分数量限制在3个以下，其中2个是理想的。否则，你总是可以使用条形图或小型表格在精度和传达能力更好的地方替换饼图。
- en: See also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using arc generators* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。进入形状")的*使用弧生成器*配方中，*进入形状*
- en: The *Implementing arc transition* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。进入形状")的*实现弧过渡*配方中，*进入形状*
- en: Building a stacked area chart
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建堆叠面积图
- en: In the *Creating an area chart* recipe in [Chapter 8](ch08.html "Chapter 8. Chart
    Them Up"), *Chart Them Up*, we have explored how a basic layered area chart can
    be implemented using D3\. In this recipe, we will build over what we have learned
    in the area chart recipe to implement a stacked area chart. Stacked area chart
    is a variation of the standard area chart in which different areas are stacked
    on top of each other giving your audience not only the ability to compare different
    data series individually but also their relationship to the total in proportion.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。绘制图表")的`Creating an area chart`食谱中，我们探讨了如何使用D3实现基本分层面积图。在本食谱中，我们将基于我们在面积图食谱中学到的知识来实现堆叠面积图。堆叠面积图是标准面积图的一种变体，其中不同的区域堆叠在一起，不仅使观众能够单独比较不同的数据系列，而且还能比较它们与总量的比例关系。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/stacked-area-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/stacked-area-chart.html).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/stacked-area-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/stacked-area-chart.html).'
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'This recipe is built over what we have implemented in [Chapter 8](ch08.html
    "Chapter 8. Chart Them Up"), *Chart Them Up*, therefore in the following code
    example only the parts that are particularly relevant to the stacked area chart
    are included:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱是在我们在[第8章](ch08.html "第8章。绘制图表")中实现的`Chart Them Up`的基础上构建的，因此，在以下代码示例中，仅包含与堆叠面积图特别相关的部分：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This recipe generates the following visualization:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱生成了以下可视化效果：
- en: '![How to do it...](img/2162OS_09_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2162OS_09_02.jpg)'
- en: Stacked area chart
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠面积图
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main difference between this recipe and standard area chart as well as the
    focus on this recipe is the stacking. The stacking effect as illustrated in this
    recipe was achieved through `d3.layout.stack` created on line A.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准面积图相比，本食谱的主要区别在于堆叠。本食谱中展示的堆叠效果是通过在行A上创建的`d3.layout.stack`实现的。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only customization we have done on stack layout is setting its `offset`
    to `zero`. D3 stack layout supports a few different offset modes which determine
    what stacking algorithm to use; this is something that we will explore in this
    and the next recipe. In this case we use the `zero` offset stacking which generates
    a zero base-lined stacking algorithm, which is exactly what we want in this recipe.
    Next, on line B, we invoked the stack layout on the given data array which generates
    the following layout data:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆叠布局上，我们唯一进行的自定义是将其`offset`设置为`zero`。D3堆叠布局支持几种不同的偏移模式，这些模式决定了使用哪种堆叠算法；这是我们将在本食谱和下一食谱中探讨的内容。在这种情况下，我们使用`zero`偏移堆叠，它生成一个零基线的堆叠算法，这正是本食谱所想要的。接下来，在行B上，我们对给定的数据数组调用了堆叠布局，生成了以下布局数据：
- en: '![How it works...](img/2162OS_09_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/2162OS_09_03.jpg)'
- en: Stacked data
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠数据
- en: As shown, the stack layout automatically calculates a baseline `y0` for each
    datum in our three different data series. Now with this stacked dataset in hand,
    we can easily generate stacked lines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，堆叠布局自动为我们的三个不同数据系列中的每个数据项计算一个基线`y0`。现在，我们有了这个堆叠数据集，我们可以轻松地生成堆叠线。
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A D3 line generator function was created with its x value directly mapped to
    the `x` (line C) and its y value mapped to `y + y0` (line D). This is all you
    need to do for line stacking. The rest of the `renderLines` function is essentially
    the same as in the basic area chart implementation. The area stacking logic is
    slightly different:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个D3线生成函数，其x值直接映射到`x`（行C），其y值映射到`y + y0`（行D）。这就是进行线堆叠所需做的全部工作。`renderLines`函数的其余部分基本上与基本面积图实现相同。面积堆叠逻辑略有不同：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similar to the line rendering logic when rendering area, the only place we need
    to change is in the `d3.svg.area` generator setting. For areas the `x` value is
    still directly mapped to `x` (line E) with its `y0` directly mapped with `y0`
    and finally again `y1` is the sum of `y` and `y0` (line G).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染面积时，与线渲染逻辑类似，我们唯一需要更改的地方是在`d3.svg.area`生成器设置中。对于面积，`x`值仍然直接映射到`x`（行E），其`y0`直接映射到`y0`，最后`y1`是`y`和`y0`的和（行G）。
- en: As we have seen so far, D3 stack layout is nicely designed to be compatible
    with different D3 SVG generator functions. Hence, using it to generate the stacking
    effect is quite straightforward and convenient.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，D3堆叠布局设计得非常好，可以与不同的D3 SVG生成函数兼容。因此，使用它来生成堆叠效果非常直接和方便。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Let's take a look at a couple of variations of the stacked area chart.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看堆叠面积图的几个变体。
- en: Expanded area chart
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展面积图
- en: We have mentioned that `d3.layout.stack` supports different offset modes. In
    addition to the `zero` offset we have seen so far, another very useful offset
    mode for area chart is called `expand`. With the `expand` mode, stack layout will
    normalize different layers to fill the range of [0, 1]. If we change the offset
    mode in this recipe and the y axis domain to [0, 1], we will get the expanded
    (normalized) area chart shown below.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到`d3.layout.stack`支持不同的偏移模式。除了我们之前看到的`zero`偏移之外，还有一种对面积图非常有用的偏移模式，称为`expand`。在`expand`模式下，堆叠布局将不同层标准化以填充[0,
    1]的范围。如果我们更改此食谱中的偏移模式和y轴域为[0, 1]，我们将得到下面显示的扩展（标准化）面积图。
- en: '![Expanded area chart](img/2162OS_09_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![扩展面积图](img/2162OS_09_04.jpg)'
- en: Expanded area chart
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展面积图
- en: 'For the complete companion code example please visit: [https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/expanded-area-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/expanded-area-chart.html).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的配套代码示例，请访问：[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/expanded-area-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/expanded-area-chart.html)。
- en: Streamgraph
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流图
- en: Another interesting variation of stacked area chart is called streamgraph. Streamgraph
    is a stacked area chart displayed around a central axis creating a flowing and
    organic shape. Streamgraph was initially developed by Lee Byron and popularized
    by its use in a New York Times article on movie box office revenues in 2008\.
    The D3 stack layout has built-in support for this kind of stacking algorithm therefore
    changing a zero based stacked area chart to streamgraph is trivial. The key difference
    is that streamgraph uses `wiggle` as its layout offset mode.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有趣的堆叠面积图变体被称为流图。流图是一种围绕中心轴显示的堆叠面积图，它创造出一个流动和有机的形状。流图最初由李·拜伦开发，并于2008年在《纽约时报》一篇关于电影票房收入的文章中普及。D3堆叠布局内置了对这种堆叠算法的支持，因此将基于零的堆叠面积图转换为流图是微不足道的。关键区别在于流图使用`wiggle`作为其布局偏移模式。
- en: '![Streamgraph](img/2162OS_09_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![流图](img/2162OS_09_05.jpg)'
- en: Streamgraph
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 流图
- en: 'For the complete companion code example please visit: [https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/streamgraph.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/streamgraph.html).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的配套代码示例，请访问：[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/streamgraph.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/streamgraph.html)。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料也
- en: '`d3.layout.stack` offers several additional functions to customize its behavior;
    for more information on stack layout visit [https://github.com/mbostock/d3/wiki/Stack-Layout](https://github.com/mbostock/d3/wiki/Stack-Layout)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.layout.stack`提供了一些额外的函数来定制其行为；有关堆叠布局的更多信息，请访问[https://github.com/mbostock/d3/wiki/Stack-Layout](https://github.com/mbostock/d3/wiki/Stack-Layout)。'
- en: The *Creating an area chart* recipe in [Chapter 8](ch08.html "Chapter 8. Chart
    Them Up"), *Chart Them Up*
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第8章“Chart Them Up”的*创建面积图*食谱中，[第8章](ch08.html "第8章。绘制图表")。
- en: Building a treemap
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建树状图
- en: Treemaps were introduced by Ben Shneiderman in 1991\. A treemap displays hierarchical
    tree-structured data as a set of recursively subdivided rectangles. In other words,
    it displays each branch of the tree as a large rectangle which is then tiled with
    smaller rectangles representing sub-branches. This process continuously repeats
    itself till it reaches the leaves of the tree.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 树状图是由本·施奈德曼在1991年提出的。树状图将层次树状数据显示为一系列递归划分的矩形。换句话说，它将树的每一分支显示为一个大的矩形，然后使用代表子分支的小矩形进行平铺。这个过程会一直重复，直到达到树的叶子。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on treemaps, see this paper by Ben Shneiderman at [http://www.cs.umd.edu/hcil/treemap-history/](http://www.cs.umd.edu/hcil/treemap-history/)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于树状图的更多信息，请参阅本·施奈德曼在[http://www.cs.umd.edu/hcil/treemap-history/](http://www.cs.umd.edu/hcil/treemap-history/)上的这篇论文。
- en: Before we dive into the code example, let's first define what we mean by **hierarchical
    data** .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码示例之前，让我们首先定义一下我们所说的**层次数据**。
- en: 'So far we have learned many types of visualizations capable of representing
    flat data structure usually stored in one or two dimensional arrays. In the rest
    of this chapter, we will switch our focus onto another common type of data structure
    in data visualization—the hierarchical data structure. Instead of using arrays,
    as in the case of flat data structures, hierarchical data are usually structured
    as a rooted tree. The following JSON file shows a typical hierarchical data you
    would expect in a data visualization project:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了多种能够表示通常存储在一维或二维数组中的平面数据结构的可视化类型。在本章的剩余部分，我们将把我们的重点转向数据可视化中另一种常见的类型——层次数据结构。与平面数据结构中使用数组不同，层次数据通常以根树的形式组织。以下JSON文件展示了在数据可视化项目中可能会遇到的典型层次数据：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a shortened version of a popular hierarchical dataset used in the D3
    community for demonstration purposes. This data is extracted from a popular flash
    based data visualization library—Flare, created by the UC Berkeley Visualization
    Lab. It shows the size and hierarchical relationship amongst different packages
    within the library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从D3社区中用于演示目的的流行层次数据集的一个简略版本。这些数据是从一个流行的基于Flash的数据可视化库Flare中提取的，该库由加州大学伯克利分校可视化实验室创建。它显示了库中不同包之间的大小和层次关系。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'See the official Flare site for more information on the project: [http://flare.prefuse.org/](http://flare.prefuse.org/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 查看官方Flare网站以获取有关项目的更多信息：[http://flare.prefuse.org/](http://flare.prefuse.org/)。
- en: As we can see quite easily this particular JSON feed is structured as a typical
    singly-linked rooted tree with each node having a single parent and multiple child
    nodes stored in the `children` array. This is the most natural way to organize
    your hierarchical data in order to be consumed by the D3 hierarchical layouts.
    For the rest of this chapter, we will use this particular dataset for exploring
    different hierarchical data visualization techniques D3 has to offer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们很容易看到的，这个特定的JSON数据流的结构是一个典型的单链根树，每个节点有一个父节点和存储在`children`数组中的多个子节点。这是组织您的层次数据以便由D3层次布局消费的最自然方式。在本章的其余部分，我们将使用这个特定的数据集来探索D3提供的不同层次数据可视化技术。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/treemap.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/treemap.html).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/treemap.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/treemap.html)。'
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Now let's see how we can use the D3 treemap layout to visually represent this
    kind of hierarchical data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用D3树状图布局来直观地表示这类层次数据。
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This recipe generates the following treemap visualization:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方生成了以下树状图可视化：
- en: '![How to do it...](img/2162OS_09_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2162OS_09_06.jpg)'
- en: Treemap
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 树状图
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At this point you might be surprised how little code is needed to implement
    a complex data visualization like this. This is because most of the heavy lifting
    is done by `d3.layout.treemap`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能对实现如此复杂的数据可视化所需的代码如此之少感到惊讶。这是因为大部分繁重的工作都是由`d3.layout.treemap`完成的。
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The treemap layout is defined on line A with some basic custom settings:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 树状图布局在行A上定义，并包含一些基本的自定义设置：
- en: '`round(false)`: If rounding is on, the treemap layout will round to exact pixel
    boundaries. This is great when you want to avoid antialiasing artifacts in SVG.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`round(false)`: 如果开启舍入，树状图布局将舍入到精确的像素边界。当你想要避免SVG中的抗锯齿伪影时，这非常有用。'
- en: '`size([_width, _height])`: It sets the layout boundary to the size of this
    SVG.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size([_width, _height])`: 它将布局边界设置为SVG的大小。'
- en: '`sticky(true)`: In sticky mode, the treemap layout will try to preserve the
    relative arrangement of nodes (rectangles in our case) across the transition.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sticky(true)`: 在粘性模式下，树状图布局将尝试在过渡过程中保持节点（在我们的例子中是矩形）的相对排列。'
- en: '`value(_valueAccessor)`: One feature this recipe offers is the ability to switch
    the treemap value accessor on the fly. Value accessor is used by a treemap to
    access value field on each node. In our case, it can be either one of the following
    functions:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value(_valueAccessor)`: 此配方提供的一项功能是能够在运行时切换树状图值访问器。值访问器用于树状图访问每个节点的值字段。在我们的例子中，它可以是以下函数之一：'
- en: '[PRE12]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To apply a treemap layout on Flare JSON datafeed, we simply set the `nodes`
    on the treemap layout to the root node in our JSON tree (line C). Treemap nodes
    are then further filtered to remove parent nodes (nodes that have children) on
    line D since we only want to visualize the leaf nodes while using coloring to
    highlight the package grouping in this treemap implementation. The layout data
    generated by treemap layout contains the following structure:![How it works...](img/2162OS_09_07.jpg)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在Flare JSON数据源上应用树状图布局，我们只需将树状图布局中的`nodes`设置为我们的JSON树中的根节点（行C）。然后，在行D中进一步过滤树状图节点以删除父节点（有子节点的节点），因为我们只想可视化叶子节点，同时使用着色来突出显示此树状图实现中的包分组。树状图布局生成的布局数据包含以下结构：![工作原理...](img/2162OS_09_07.jpg)
- en: Treemap node object
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 树状图节点对象
- en: 'As shown, the treemap layout has annotated and calculated quite a few attributes
    for each node using its algorithm. Many of these attributes can be useful when
    visualizing and in this recipe we mostly care about the following attributes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，树状图布局已使用其算法为每个节点标注和计算了许多属性。其中许多属性在可视化时非常有用，在本教程中，我们主要关注以下属性：
- en: '`x`: Cell x coordinate'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`: 单元x坐标'
- en: '`y`: Cell y coordinate'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`: 单元y坐标'
- en: '`dx`: Cell width'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dx`: 单元宽度'
- en: '`dy`: Cell height'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dy`: 单元高度'
- en: 'On line E, a set of `svg:g` elements were created for the given nodes. The
    function `renderCells` is then responsible for creating rectangles and its labels:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在行E中，为给定的节点创建了一组`svg:g`元素。然后，`renderCells`函数负责创建矩形及其标签：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each rectangle is placed at its location `(x, y)` determined by the layout on
    line F, and then its width and height are set to `dx` and `dy`. On line G, we
    colored every cell using its parent's names therefore making sure all children
    belonging to the same parent are colored the same way. From line H onward we created
    the label (`svg:text`) element for each rectangle and setting its text to the
    node name. One aspect worth mentioning here is that in order to avoid displaying
    label for the cells that are smaller than the label itself, the opacity of label
    is set to 0 if the label is larger than the cell width (line I).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矩形放置在其位置`(x, y)`上，该位置由行F上的布局确定，然后其宽度和高度设置为`dx`和`dy`。在行G中，我们使用每个单元的父节点名称着色每个单元，从而确保属于同一父节点的所有子节点都以相同的方式着色。从行H开始，我们为每个矩形创建标签（`svg:text`）元素，并将其文本设置为节点名称。这里值得提到的一个方面是，为了避免显示比单元格宽度更大的标签，如果标签比单元格宽度大，则将标签的不透明度设置为0（行I）。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Technique – auto-hiding label**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术 - 自动隐藏标签**'
- en: 'What we have seen here on line I is a useful technique in visualization to
    implement auto-hiding labels. This technique can be considered generally in the
    following form:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在行I中，我们看到的是可视化中实现自动隐藏标签的有用技术。这项技术可以一般地考虑以下形式：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: This recipe is inspired by Mike Bostock's treemap layout example, which you
    can find at [http://mbostock.github.io/d3/talk/20111018/treemap.html](http://mbostock.github.io/d3/talk/20111018/treemap.html)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本教程灵感来源于Mike Bostock的树状图布局示例，您可以在[http://mbostock.github.io/d3/talk/20111018/treemap.html](http://mbostock.github.io/d3/talk/20111018/treemap.html)找到。
- en: Building a tree
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建树
- en: When working with hierarchical data structures, a tree (tree graph) is probably
    one of the most natural and common visualizations typically leveraged to demonstrate
    structural dependencies between different data elements. Tree is an undirected
    graph in which any two nodes (vertices) are connected by one and only one simple
    path. In this recipe, we will learn how to implement a tree visualization using
    tree layout.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理分层数据结构时，树（树图）可能是最自然和常见的可视化方式之一，通常用于展示不同数据元素之间的结构依赖关系。树是一个无向图，其中任意两个节点（顶点）通过一条且仅有一条简单路径连接。在本教程中，我们将学习如何使用树布局实现树可视化。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/tree.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/tree.html).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/tree.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/tree.html)。'
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now let''s see `d3.layout.tree` in action:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`d3.layout.tree`的实际应用：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This recipe generates the following tree visualization:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程生成的以下树状图可视化：
- en: '![How to do it...](img/2162OS_09_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2162OS_09_08.jpg)'
- en: Tree
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 树
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As we have mentioned before, this recipe is built over the D3 tree layout.
    `d3.layout.tree` is specifically designed to convert a hierarchical data structure
    into a visual layout data suitable for generating tree graph. Our tree layout
    instance is defined as the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这个食谱是在D3树布局之上构建的。`d3.layout.tree`是专门设计用来将层次数据结构转换为适合生成树图的视觉布局数据的。我们的树布局实例定义如下：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only setting we provided here is the size of our visualization, which is
    the size of our SVG image minus the margins. `d3.layout.tree` will then take care
    of the rest and calculate every node's position accordingly. To use the tree layout,
    you simply invoke its `nodes` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提供的唯一设置是我们可视化的尺寸，即我们的SVG图像尺寸减去边距。然后`d3.layout.tree`将处理其余部分，并相应地计算每个节点的位置。要使用树布局，你只需调用其`nodes`函数。
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you peek into the `nodes` layout data, it contains node data looking like
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`nodes`布局数据，它包含看起来像这样的节点数据：
- en: '![How it works...](img/2162OS_09_09.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/2162OS_09_09.jpg)'
- en: Tree layout data
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 树布局数据
- en: One new D3 SVG shape generator we need for this recipe that is worth mentioning
    is `d3.svg.diagonal`. The diagonal generator is designed to create `svg:path`
    that connects two points. In this recipe, we use diagonal generator with tree
    layout `links` function to generate a path connecting every node in the tree.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们需要提到的一个新的D3 SVG形状生成器是`d3.svg.diagonal`。对角线生成器旨在创建连接两个点的`svg:path`。在这个食谱中，我们使用对角线生成器与树布局的`links`函数一起生成连接树中每个节点的路径。
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case we configure our diagonal generator to project using Cartesian
    orientation and simply reply on the x and y coordinates calculated by the tree
    layout for positioning. The actual rendering was performed by the following functions.
    First let''s take a look at the `renderNodes` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们配置对角线生成器使用笛卡尔方向投影，并简单地依赖于树布局计算出的x和y坐标进行定位。实际的渲染由以下函数执行。首先让我们看看`renderNodes`函数：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we loop through all the nodes and artificially assign a 180-pixel spacing
    between them. You probably are wondering why we are using the y coordinate instead
    of x. The reason is that in this recipe we want to render a horizontal tree instead
    of a vertical one; therefore we have to reverse the x and y coordinates here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历所有节点，并人为地在它们之间分配180像素的间距。你可能想知道为什么我们使用y坐标而不是x坐标。原因是，在这个食谱中，我们想要渲染一个水平树而不是垂直树；因此，我们必须在这里反转x和y坐标。
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we bind the nodes that were generated by the tree layout as data to generate
    the tree node element. At this point, we also assign an ID to each node using
    an index to obtain object constancy.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将树布局生成的节点绑定到数据，以生成树节点元素。在这个时候，我们还使用索引为每个节点分配一个ID，以获得对象一致性。
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this point, we create the nodes and move them to the same point of origin
    as set in the `renderBody` function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们创建节点并将它们移动到在`renderBody`函数中设置的相同原点。
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we start a transition in the update section to move the nodes to their proper
    position.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始在更新部分开始一个转换，将节点移动到它们正确的位置。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At last, we handle the exit case and remove the nodes after a brief animation
    of the collapsing effect. The `renderLabels` function is quite simple so we will
    not cover it in detail here. Please see the complete online code companion for
    details.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们处理退出情况，并在简短的折叠效果动画后移除节点。`renderLabels`函数相当简单，所以我们不会在这里详细说明。请参阅完整的在线代码伴侣以获取详细信息。
- en: Now let's take a look at the more interesting `renderLinks` function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看更有趣的`renderLinks`函数。
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, we generate the data binding using the `links` function on `d3.layout.tree`.
    The `links` function, which returns an array of link objects containing the `{source,
    target}` fields that point to the appropriate tree nodes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`d3.layout.tree`上的`links`函数生成数据绑定。`links`函数返回一个包含指向适当树节点的`{source, target}`字段的链接对象数组。
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `enter` section, the `svg:path` elements were created to visually represent
    the links between source and target nodes. To generate the `d` attribute for the
    path element we rely on the `d3.svg.diagonal` generator we defined earlier. During
    creation we temporarily set the links to zero length paths by setting both source
    and target to the same point of origin. So when later we transition the link to
    its proper length, it will generate the expanding effect.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `enter` 部分中，创建了 `svg:path` 元素来直观地表示源节点和目标节点之间的链接。为了生成路径元素的 `d` 属性，我们依赖于我们之前定义的
    `d3.svg.diagonal` 生成器。在创建过程中，我们暂时将链接设置为长度为零的路径，通过将源和目标都设置为同一点来设置。因此，当我们后来将链接过渡到其适当长度时，它将生成扩展效果。
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we transition the links to its proper length and position using the links
    data generated by the tree layout.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用树布局生成的链接数据，将链接过渡到其适当的长度和位置。
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we remove the nodes again,we rely on the same trick of setting the link
    to its parent's position with zero length in order to simulate the collapsing
    effect.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次移除节点时，我们依靠同样的技巧，将链接设置为长度为零的父节点位置，以模拟折叠效果。
- en: See also
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: '`d3.layout.tree` offers several functions allowing customization. For more
    details, please check out its API documentation at [https://github.com/mbostock/d3/wiki/Tree-Layout](https://github.com/mbostock/d3/wiki/Tree-Layout).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.layout.tree` 提供了几个函数，允许自定义。更多详情，请参阅其API文档，链接为 [https://github.com/mbostock/d3/wiki/Tree-Layout](https://github.com/mbostock/d3/wiki/Tree-Layout)。'
- en: The `d3.svg.diagonal` generator is capable of projection using Cartesian orientation,
    radial and other orientations. For more details, please see its API documentation
    at [https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-diagonal](https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-diagonal).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.svg.diagonal` 生成器能够使用笛卡尔方向、径向和其他方向进行投影。更多详情，请参阅其API文档，链接为 [https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-diagonal](https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-diagonal)。'
- en: The *Animating multiple elements* recipe in [Chapter 6](ch06.html "Chapter 6. Transition
    with Style"), *Transition with Style*, for explanations on object constancy.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第6章“Transition with Style”的*动画多个元素*菜谱中，有关于对象恒常性的解释。
- en: This recipe is inspired by Mike Bostock's tree layout example, which you can
    find at [http://mbostock.github.io/d3/talk/20111018/tree.html](http://mbostock.github.io/d3/talk/20111018/tree.html).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱受到了Mike Bostock的树布局示例的启发，您可以在 [http://mbostock.github.io/d3/talk/20111018/tree.html](http://mbostock.github.io/d3/talk/20111018/tree.html)
    找到它。
- en: Building an enclosure diagram
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建封装图
- en: An enclosure diagram is an interesting visualization of hierarchical data structures
    that uses the recursive circle packing algorithm. It uses containment (nesting)
    to represent hierarchy. Circles are created for each leaf node in a data tree
    while its size is proportional to a particular quantitative dimension of each
    data element. In this recipe, we will learn how to implement this kind of visualization
    using D3 pack layout.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 封装图是一种有趣的层次数据结构的可视化，它使用递归圆形封装算法。它使用包含（嵌套）来表示层次结构。对于数据树中的每个叶节点，都会创建一个圆，其大小与每个数据元素的一个特定定量维度成比例。在这个菜谱中，我们将学习如何使用D3封装布局实现这种可视化。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pack.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pack.html)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pack.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pack.html)'
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, let's see how we can implement an enclosure diagram using `d3.layout.pack`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，让我们看看如何使用 `d3.layout.pack` 实现一个封装图。
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This recipe generates the following visualization:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱生成了以下可视化：
- en: '![How to do it...](img/2162OS_09_10.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2162OS_09_10.jpg)'
- en: Enclosure diagram
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 封装图
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First thing we need to take care of in this recipe is to define our layout;
    in this case we need to use the `d3.layout.pack` layout.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先需要关注的是定义我们的布局；在这种情况下，我们需要使用 `d3.layout.pack` 布局。
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we set the size of the layout using the outer circle''s radius and set
    the value to use the Flare package size, which in turn will determine each circle''s
    size; hence, effectively making each circle''s size proportional to the package
    size in our data feed. Once layout is created, we feed our data elements through
    its `nodes` function generating the layout data with the following structure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用外圆的半径设置布局的大小，并将值设置为使用Flare包的大小，这反过来将决定每个圆的大小；因此，有效地使每个圆的大小与我们的数据源中的包大小成比例。一旦布局创建完成，我们就通过其`nodes`函数将我们的数据元素传递进去，生成具有以下结构的布局数据：
- en: '![How it works...](img/2162OS_09_11.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/2162OS_09_11.jpg)'
- en: Pack layout data
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 打包布局数据
- en: 'Circle rendering is done in the `renderCircle` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形渲染是在`renderCircle`函数中完成的：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then we simply bind the layout data and create the `svg:circle` elements for
    each node.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简单地绑定布局数据，并为每个节点创建`svg:circle`元素。
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For update, we set `cx`, `cy`, and `radius` to the value that the pack layout
    has calculated for us for each circle.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新，我们将`cx`、`cy`和`radius`设置为打包布局为我们每个圆计算出的值。
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally when removing the circle, we reduce the size of the circle down to zero
    first, before removing them to generate a more smooth transition. Label rendering
    in this recipe is pretty straight forward with some help from the auto-hiding
    technique we introduced in this chapter, so we will not cover the function in
    detail here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在移除圆之前，我们首先将圆的大小减小到零，然后再移除它们以生成更平滑的过渡。在这个配方中，标签渲染相当直接，得益于我们在本章中引入的自动隐藏技术，因此我们不会在这里详细说明该函数。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`d3.layout.pack` offers several functions allowing customization. For more
    details, please check out its API documentation at [https://github.com/mbostock/d3/wiki/Pack-Layout](https://github.com/mbostock/d3/wiki/Pack-Layout)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.layout.pack`提供了几个函数，允许自定义。有关更多详细信息，请查看其API文档，链接为[https://github.com/mbostock/d3/wiki/Pack-Layout](https://github.com/mbostock/d3/wiki/Pack-Layout)'
- en: The *Building a treemap* recipe for auto label hiding technique.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于自动隐藏标签技术的*构建树状图*配方。
- en: This recipe is inspired by Mike Bostock's pack layout example, which you can
    find at [http://mbostock.github.io/d3/talk/20111018/pack.html](http://mbostock.github.io/d3/talk/20111018/pack.html).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个配方灵感来源于Mike Bostock的打包布局示例，您可以在[http://mbostock.github.io/d3/talk/20111018/pack.html](http://mbostock.github.io/d3/talk/20111018/pack.html)找到。
