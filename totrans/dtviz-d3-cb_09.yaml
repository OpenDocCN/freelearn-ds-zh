- en: Chapter 9. Lay Them Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a stacked area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a treemap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an enclosure diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The D3 **layout** is the focus of this chapter—a concept we have not encountered
    before. As expected, D3 layouts are algorithms that calculate and generate placement
    information for a group of elements. However there are a few critical properties
    worth mentioning before we dive deeper into the specifics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layouts are data**: Layouts are purely data centric and data driven, they
    do not generate any graphical or display related output directly. This allows
    them to be used and reused with SVG or canvas or even when there is no graphical
    output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract and reusable**: Layouts are abstract, allowing a high degree of
    flexibility and reusability. You can combine and reuse layouts in various different
    interesting ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layouts are different**: Each layout is different. Every layout provided
    by D3 focuses on a very special graphical requirement and data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: Layouts are mostly stateless by design to simplify their usage.
    What statelessness means here is that generally layouts are like functions, they
    can be called multiple times with different input data and generate different
    layout output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layouts are interesting and powerful concepts in D3\. In this chapter we will
    explore some of the most commonly used layouts in D3 by creating fully functional
    visualization leveraging these layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Building a pie chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pie chart or a circle graph is a circular graph containing multiple sectors
    used to illustrate numerical proportion. We will explore techniques, involving
    D3 **pie layout**, to build a fully functional pie chart in this recipe. In [Chapter
    7](ch07.html "Chapter 7. Getting into Shape"), *Getting into Shape*, it becomes
    clear that using the D3 arc generator directly is a very tedious job. Each arc
    generator expects the following data format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This essentially requires the calculation of the angle partition for each slice
    out of an entire circle of `2 * Math.PI`. Obviously this process can be automated
    by an algorithm which is exactly what `d3.layout.pie` is designed for. In this
    recipe, we will see how pie layout can be used to implement a fully functional
    pie chart.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pie-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pie-chart.html).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pie chart or a circle graph is a circular diagram divided into sectors (slices).
    Pie charts are popular in many fields and widely used to demonstrate relationships
    between different entities though not without criticism. Let's take a look at
    how a pie chart is implemented using `d3.pie.layout` first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following pie chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Donut chart
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is built over what we have learned in the [Chapter 7](ch07.html
    "Chapter 7. Getting into Shape"), *Getting into Shape*. One major difference is
    that we rely on `d3.layout.pie` to transform the raw data into arcs data for us.
    The pie layout was created on line A with both sort and value accessors specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `sort` function tells the pie layout to sort slices by its ID field, so
    that we can maintain stable order amongst slices. Without the sorting, by default
    the pie layout will order the slices by value resulting in the swapping of slices
    whenever we update the pie chart. The `value` function is used to provide value
    accessor which in our case returns the `value` field. When rendering slices, now
    with the pie layout, we directly set the pie layout as data (remember layouts
    are data) to generate the arc `svg:path` elements (line B).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the rendering logic is pretty much the same as what we have learned
    in [Chapter 7](ch07.html "Chapter 7. Getting into Shape"), *Getting into Shape*,
    with one exception on line C. On line C we retrieve the current arc value from
    the element so the transition can start from the current angle instead of zero.
    Then on line D we reset the current arc value to the latest one so the next time
    when we update the pie chart data we can repeat the stateful transition.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Technique – stateful visualization**'
  prefs: []
  type: TYPE_NORMAL
- en: Technique of value injection on a DOM element is a common approach to introduce
    statefulness to your visualization. In other words, if you need your visualizations
    to remember what their previous states are, you can save them in DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we also need to render labels on each slice so our user can understand
    what each slice is representing. This is done by the `renderLabels` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once again we use the pie layout as data to generate the `svg:text` elements.
    The placement of the labels is calculated using `arc.centroid` (line F). Additionally,
    the label placement is animated through the transition so they can be moved with
    arcs in unison.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pie charts are very widely used in many different domains. However, they have
    also been widely criticized due to the fact that they are difficult for human
    eyes to compare different sections of a given pie chart as well as their low information
    density. Therefore, it is highly recommended to limit the number of sections to
    less than 3, with 2 to be ideal. Otherwise, you can always use a bar chart or
    a small table to replace a pie chart in places with better precision and communicative
    power.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using arc generators* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing arc transition* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a stacked area chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Creating an area chart* recipe in [Chapter 8](ch08.html "Chapter 8. Chart
    Them Up"), *Chart Them Up*, we have explored how a basic layered area chart can
    be implemented using D3\. In this recipe, we will build over what we have learned
    in the area chart recipe to implement a stacked area chart. Stacked area chart
    is a variation of the standard area chart in which different areas are stacked
    on top of each other giving your audience not only the ability to compare different
    data series individually but also their relationship to the total in proportion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/stacked-area-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/stacked-area-chart.html).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is built over what we have implemented in [Chapter 8](ch08.html
    "Chapter 8. Chart Them Up"), *Chart Them Up*, therefore in the following code
    example only the parts that are particularly relevant to the stacked area chart
    are included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stacked area chart
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main difference between this recipe and standard area chart as well as the
    focus on this recipe is the stacking. The stacking effect as illustrated in this
    recipe was achieved through `d3.layout.stack` created on line A.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The only customization we have done on stack layout is setting its `offset`
    to `zero`. D3 stack layout supports a few different offset modes which determine
    what stacking algorithm to use; this is something that we will explore in this
    and the next recipe. In this case we use the `zero` offset stacking which generates
    a zero base-lined stacking algorithm, which is exactly what we want in this recipe.
    Next, on line B, we invoked the stack layout on the given data array which generates
    the following layout data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2162OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stacked data
  prefs: []
  type: TYPE_NORMAL
- en: As shown, the stack layout automatically calculates a baseline `y0` for each
    datum in our three different data series. Now with this stacked dataset in hand,
    we can easily generate stacked lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A D3 line generator function was created with its x value directly mapped to
    the `x` (line C) and its y value mapped to `y + y0` (line D). This is all you
    need to do for line stacking. The rest of the `renderLines` function is essentially
    the same as in the basic area chart implementation. The area stacking logic is
    slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the line rendering logic when rendering area, the only place we need
    to change is in the `d3.svg.area` generator setting. For areas the `x` value is
    still directly mapped to `x` (line E) with its `y0` directly mapped with `y0`
    and finally again `y1` is the sum of `y` and `y0` (line G).
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen so far, D3 stack layout is nicely designed to be compatible
    with different D3 SVG generator functions. Hence, using it to generate the stacking
    effect is quite straightforward and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at a couple of variations of the stacked area chart.
  prefs: []
  type: TYPE_NORMAL
- en: Expanded area chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have mentioned that `d3.layout.stack` supports different offset modes. In
    addition to the `zero` offset we have seen so far, another very useful offset
    mode for area chart is called `expand`. With the `expand` mode, stack layout will
    normalize different layers to fill the range of [0, 1]. If we change the offset
    mode in this recipe and the y axis domain to [0, 1], we will get the expanded
    (normalized) area chart shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanded area chart](img/2162OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanded area chart
  prefs: []
  type: TYPE_NORMAL
- en: 'For the complete companion code example please visit: [https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/expanded-area-chart.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/expanded-area-chart.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Streamgraph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another interesting variation of stacked area chart is called streamgraph. Streamgraph
    is a stacked area chart displayed around a central axis creating a flowing and
    organic shape. Streamgraph was initially developed by Lee Byron and popularized
    by its use in a New York Times article on movie box office revenues in 2008\.
    The D3 stack layout has built-in support for this kind of stacking algorithm therefore
    changing a zero based stacked area chart to streamgraph is trivial. The key difference
    is that streamgraph uses `wiggle` as its layout offset mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Streamgraph](img/2162OS_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Streamgraph
  prefs: []
  type: TYPE_NORMAL
- en: 'For the complete companion code example please visit: [https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/streamgraph.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/streamgraph.html).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`d3.layout.stack` offers several additional functions to customize its behavior;
    for more information on stack layout visit [https://github.com/mbostock/d3/wiki/Stack-Layout](https://github.com/mbostock/d3/wiki/Stack-Layout)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating an area chart* recipe in [Chapter 8](ch08.html "Chapter 8. Chart
    Them Up"), *Chart Them Up*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a treemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Treemaps were introduced by Ben Shneiderman in 1991\. A treemap displays hierarchical
    tree-structured data as a set of recursively subdivided rectangles. In other words,
    it displays each branch of the tree as a large rectangle which is then tiled with
    smaller rectangles representing sub-branches. This process continuously repeats
    itself till it reaches the leaves of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on treemaps, see this paper by Ben Shneiderman at [http://www.cs.umd.edu/hcil/treemap-history/](http://www.cs.umd.edu/hcil/treemap-history/)
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the code example, let's first define what we mean by **hierarchical
    data** .
  prefs: []
  type: TYPE_NORMAL
- en: 'So far we have learned many types of visualizations capable of representing
    flat data structure usually stored in one or two dimensional arrays. In the rest
    of this chapter, we will switch our focus onto another common type of data structure
    in data visualization—the hierarchical data structure. Instead of using arrays,
    as in the case of flat data structures, hierarchical data are usually structured
    as a rooted tree. The following JSON file shows a typical hierarchical data you
    would expect in a data visualization project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a shortened version of a popular hierarchical dataset used in the D3
    community for demonstration purposes. This data is extracted from a popular flash
    based data visualization library—Flare, created by the UC Berkeley Visualization
    Lab. It shows the size and hierarchical relationship amongst different packages
    within the library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'See the official Flare site for more information on the project: [http://flare.prefuse.org/](http://flare.prefuse.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see quite easily this particular JSON feed is structured as a typical
    singly-linked rooted tree with each node having a single parent and multiple child
    nodes stored in the `children` array. This is the most natural way to organize
    your hierarchical data in order to be consumed by the D3 hierarchical layouts.
    For the rest of this chapter, we will use this particular dataset for exploring
    different hierarchical data visualization techniques D3 has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/treemap.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/treemap.html).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's see how we can use the D3 treemap layout to visually represent this
    kind of hierarchical data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following treemap visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Treemap
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point you might be surprised how little code is needed to implement
    a complex data visualization like this. This is because most of the heavy lifting
    is done by `d3.layout.treemap`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The treemap layout is defined on line A with some basic custom settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`round(false)`: If rounding is on, the treemap layout will round to exact pixel
    boundaries. This is great when you want to avoid antialiasing artifacts in SVG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size([_width, _height])`: It sets the layout boundary to the size of this
    SVG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sticky(true)`: In sticky mode, the treemap layout will try to preserve the
    relative arrangement of nodes (rectangles in our case) across the transition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value(_valueAccessor)`: One feature this recipe offers is the ability to switch
    the treemap value accessor on the fly. Value accessor is used by a treemap to
    access value field on each node. In our case, it can be either one of the following
    functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To apply a treemap layout on Flare JSON datafeed, we simply set the `nodes`
    on the treemap layout to the root node in our JSON tree (line C). Treemap nodes
    are then further filtered to remove parent nodes (nodes that have children) on
    line D since we only want to visualize the leaf nodes while using coloring to
    highlight the package grouping in this treemap implementation. The layout data
    generated by treemap layout contains the following structure:![How it works...](img/2162OS_09_07.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treemap node object
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As shown, the treemap layout has annotated and calculated quite a few attributes
    for each node using its algorithm. Many of these attributes can be useful when
    visualizing and in this recipe we mostly care about the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x`: Cell x coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: Cell y coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dx`: Cell width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dy`: Cell height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On line E, a set of `svg:g` elements were created for the given nodes. The
    function `renderCells` is then responsible for creating rectangles and its labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Each rectangle is placed at its location `(x, y)` determined by the layout on
    line F, and then its width and height are set to `dx` and `dy`. On line G, we
    colored every cell using its parent's names therefore making sure all children
    belonging to the same parent are colored the same way. From line H onward we created
    the label (`svg:text`) element for each rectangle and setting its text to the
    node name. One aspect worth mentioning here is that in order to avoid displaying
    label for the cells that are smaller than the label itself, the opacity of label
    is set to 0 if the label is larger than the cell width (line I).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Technique – auto-hiding label**'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have seen here on line I is a useful technique in visualization to
    implement auto-hiding labels. This technique can be considered generally in the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is inspired by Mike Bostock's treemap layout example, which you
    can find at [http://mbostock.github.io/d3/talk/20111018/treemap.html](http://mbostock.github.io/d3/talk/20111018/treemap.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with hierarchical data structures, a tree (tree graph) is probably
    one of the most natural and common visualizations typically leveraged to demonstrate
    structural dependencies between different data elements. Tree is an undirected
    graph in which any two nodes (vertices) are connected by one and only one simple
    path. In this recipe, we will learn how to implement a tree visualization using
    tree layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/tree.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/tree.html).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s see `d3.layout.tree` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following tree visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tree
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have mentioned before, this recipe is built over the D3 tree layout.
    `d3.layout.tree` is specifically designed to convert a hierarchical data structure
    into a visual layout data suitable for generating tree graph. Our tree layout
    instance is defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only setting we provided here is the size of our visualization, which is
    the size of our SVG image minus the margins. `d3.layout.tree` will then take care
    of the rest and calculate every node's position accordingly. To use the tree layout,
    you simply invoke its `nodes` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you peek into the `nodes` layout data, it contains node data looking like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2162OS_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tree layout data
  prefs: []
  type: TYPE_NORMAL
- en: One new D3 SVG shape generator we need for this recipe that is worth mentioning
    is `d3.svg.diagonal`. The diagonal generator is designed to create `svg:path`
    that connects two points. In this recipe, we use diagonal generator with tree
    layout `links` function to generate a path connecting every node in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case we configure our diagonal generator to project using Cartesian
    orientation and simply reply on the x and y coordinates calculated by the tree
    layout for positioning. The actual rendering was performed by the following functions.
    First let''s take a look at the `renderNodes` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we loop through all the nodes and artificially assign a 180-pixel spacing
    between them. You probably are wondering why we are using the y coordinate instead
    of x. The reason is that in this recipe we want to render a horizontal tree instead
    of a vertical one; therefore we have to reverse the x and y coordinates here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we bind the nodes that were generated by the tree layout as data to generate
    the tree node element. At this point, we also assign an ID to each node using
    an index to obtain object constancy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we create the nodes and move them to the same point of origin
    as set in the `renderBody` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we start a transition in the update section to move the nodes to their proper
    position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At last, we handle the exit case and remove the nodes after a brief animation
    of the collapsing effect. The `renderLabels` function is quite simple so we will
    not cover it in detail here. Please see the complete online code companion for
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at the more interesting `renderLinks` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First, we generate the data binding using the `links` function on `d3.layout.tree`.
    The `links` function, which returns an array of link objects containing the `{source,
    target}` fields that point to the appropriate tree nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the `enter` section, the `svg:path` elements were created to visually represent
    the links between source and target nodes. To generate the `d` attribute for the
    path element we rely on the `d3.svg.diagonal` generator we defined earlier. During
    creation we temporarily set the links to zero length paths by setting both source
    and target to the same point of origin. So when later we transition the link to
    its proper length, it will generate the expanding effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we transition the links to its proper length and position using the links
    data generated by the tree layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we remove the nodes again,we rely on the same trick of setting the link
    to its parent's position with zero length in order to simulate the collapsing
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`d3.layout.tree` offers several functions allowing customization. For more
    details, please check out its API documentation at [https://github.com/mbostock/d3/wiki/Tree-Layout](https://github.com/mbostock/d3/wiki/Tree-Layout).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `d3.svg.diagonal` generator is capable of projection using Cartesian orientation,
    radial and other orientations. For more details, please see its API documentation
    at [https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-diagonal](https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-diagonal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Animating multiple elements* recipe in [Chapter 6](ch06.html "Chapter 6. Transition
    with Style"), *Transition with Style*, for explanations on object constancy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe is inspired by Mike Bostock's tree layout example, which you can
    find at [http://mbostock.github.io/d3/talk/20111018/tree.html](http://mbostock.github.io/d3/talk/20111018/tree.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an enclosure diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enclosure diagram is an interesting visualization of hierarchical data structures
    that uses the recursive circle packing algorithm. It uses containment (nesting)
    to represent hierarchy. Circles are created for each leaf node in a data tree
    while its size is proportional to a particular quantitative dimension of each
    data element. In this recipe, we will learn how to implement this kind of visualization
    using D3 pack layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pack.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pack.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, let's see how we can implement an enclosure diagram using `d3.layout.pack`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enclosure diagram
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First thing we need to take care of in this recipe is to define our layout;
    in this case we need to use the `d3.layout.pack` layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set the size of the layout using the outer circle''s radius and set
    the value to use the Flare package size, which in turn will determine each circle''s
    size; hence, effectively making each circle''s size proportional to the package
    size in our data feed. Once layout is created, we feed our data elements through
    its `nodes` function generating the layout data with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2162OS_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pack layout data
  prefs: []
  type: TYPE_NORMAL
- en: 'Circle rendering is done in the `renderCircle` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then we simply bind the layout data and create the `svg:circle` elements for
    each node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For update, we set `cx`, `cy`, and `radius` to the value that the pack layout
    has calculated for us for each circle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Finally when removing the circle, we reduce the size of the circle down to zero
    first, before removing them to generate a more smooth transition. Label rendering
    in this recipe is pretty straight forward with some help from the auto-hiding
    technique we introduced in this chapter, so we will not cover the function in
    detail here.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`d3.layout.pack` offers several functions allowing customization. For more
    details, please check out its API documentation at [https://github.com/mbostock/d3/wiki/Pack-Layout](https://github.com/mbostock/d3/wiki/Pack-Layout)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building a treemap* recipe for auto label hiding technique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe is inspired by Mike Bostock's pack layout example, which you can
    find at [http://mbostock.github.io/d3/talk/20111018/pack.html](http://mbostock.github.io/d3/talk/20111018/pack.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
