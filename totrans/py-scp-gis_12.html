<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">GeoDjango</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Django Python web framework was made available in 2005 and has been steadily supported and improved throughout the years. One major improvement was additional support for spatial data types and queries. This effort produced GeoDjango, allowing Django to support geospatial database models and web views that utilize geospatial queries.</p>
<p class="mce-root">GeoDjango is now a standard Django component, which can be activated using a specific configuration. In December 2017, Django 2 was released as the new long-term support version. It currently supports Python 3.4, 3.5, and 3.6.</p>
<p>In this chapter, we will learn about the following:</p>
<ul>
<li>Installation and configuration of Django and GeoDjango</li>
<li>Django admin panel functionality, including map editing</li>
<li>How to load shapefiles into database tables using LayerMapping</li>
<li>GeoDjango queries</li>
<li>Django URL patterns</li>
<li>Django views</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and configuring Django and GeoDjango</h1>
                </header>
            
            <article>
                
<p><span>Django, compared to Flask, is a batteries-included framework. It includes modules that allow for database backend support, without requiring a separate database code package (unlike Flask, which relies on SQLAlchemy). Django also includes an admin panel that allows for easy data editing and management through a web interface. This means fewer modules are installed and more code is included to handle database interactions and web processing.</span></p>
<p><span>There are some major differences between Flask and Django. Django separates URLs from views and models in a more structured manner than Flask. Django also uses Python classes for databases tables, but it has built-in database support. For geospatial databases, no extra module is required. Django also supports geometry columns in a wider range of databases, though PostgreSQL and PostGIS are used the most often. </span></p>
<p>Like many Python 3 modules, Django development is geared towards Linux development environments. While it supports Windows installation, it requires a few modifications of the environment variables within Windows, requiring administrative control of the machine. <span>Administrative-level permissions are required for configurations, allowing Django to access <strong>Geospatial Data Abstraction Library</strong> (<strong>GDAL</strong>) and <strong>OGR Simple Features </strong>libraries.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Steps from Django to GeoDjango</h1>
                </header>
            
            <article>
                
<p><span>Within this section,</span> <span>we'll install Django add GeoDjango configurations, and add the required libraries (including the GDAL and</span><span> OGR) that bring spatial functionality to Django</span><span>. </span>Installing the Django 2 module for Python 3, and configuring the GeoDjango components, depends on a number of steps. These include:</p>
<ol>
<li>Using <kbd>pip</kbd> to install Django 2</li>
<li>Installing and enabling a spatial database (if not already installed)</li>
<li>Installing GDAL/ OGR/PROJ4/GEOS</li>
<li>Configuring the Windows environment variables</li>
<li>Generating a project</li>
<li>Opening <kbd>settings.py</kbd></li>
<li>Adding <kbd>django.contrib.gis</kbd> to <kbd>INSTALLED_APPS</kbd></li>
<li>Configuring database settings to point to the spatial database</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Django</h1>
                </header>
            
            <article>
                
<p>Django 2 is hosted in <strong>Python Package Index</strong> (<strong>PyPI</strong>), so use <kbd>pip</kbd> to install it. It can also be downloaded and installed manually. Using <kbd>pip</kbd> to install Django will also install the required dependency, <kbd>pytz</kbd>. Django will be downloaded from PyPI as a wheel and installed. </p>
<p>Because Django 2 is a major update which has been recently released, we have to ensure that <kbd>pip</kbd> installs the correct version. With this command, we will install Django 2.0:</p>
<pre><strong>C:\Python36\Scripts&gt;pip install Django==2.0</strong></pre>
<p>The module will be installed, along with the supporting modules:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50a55e05-b2b3-4100-bbdb-a0a8feeeb59a.png"/></div>
<p><span>Django 2.0 is used in this chapter. Use the latest version of Django 2 available to start a project. Check out Django 2.0 documentation (as well as other Django versions) here: <br/>
<a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a>.</span></p>
<div class="packt_tip"><span>If you are using virtual environments, you can specify a specific version of Django for each environment. If not, and you have multiple versions of Python installed, be sure to use the correct</span> <kbd>pip</kbd> <span>version to install Django within the <kbd>Python 3</kbd> folder structure. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing PostGIS and psycopg2</h1>
                </header>
            
            <article>
                
<p>This chapter will use PostGIS. Refer to <a href="4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml">Chapter 7</a>, <em>Geoprocessing with Geodatabases</em>, if you do not have PostGIS installed on your machine as it explains how to install the spatial extension add-on to PostgreSQL. Also, ensure that the <kbd>psycopg2</kbd> module is installed by using the following code:</p>
<pre><strong>C:\Python36\Scripts&gt;pip install psycopg2</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the database</h1>
                </header>
            
            <article>
                
<p>Generating the database table is made possible by the <kbd>Chapter12_0.py</kbd> script, which creates a PostgreSQL database called <kbd>chapter12</kbd> and adds spatial functionality to the new database. Adjust the credentials, host, and port (as needed) in the connection configuration below.</p>
<p>Connect to the database server using <kbd>psycopg2</kbd> and its <kbd>connect</kbd> function, which creates a <kbd>connection</kbd> class. The class has a <kbd>cursor</kbd> function that creates a <kbd>cursor</kbd> object, which is able to execute SQL statements. This section creates the database for the chapter:</p>
<pre>import psycopg2<br/>connection = psycopg2.connect(host='localhost', user='{user}',password='{password}', port="5432")<br/>connection.autocommit = True<br/>cursor = connection.cursor()<br/>cursor.execute('CREATE DATABASE chapter12')</pre>
<p>To make the database geospatial, ensure that the PostGIS spatial add-on has been installed. Connect to the new database and pass the following SQL statement, which adds the spatial functionality tables to the database:</p>
<pre>import psycopg2<br/>connection = psycopg2.connect(dbname='chapter12', host='localhost', user='{user}', password='{password}', port="5432")<br/>cursor = connection.cursor()<br/>connection.autocommit = True<br/>cursor.execute('CREATE EXTENSION postgis')<br/>connection.close() </pre>
<p>The PostGIS database for this chapter is now created and spatially enabled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GDAL/OGR</h1>
                </header>
            
            <article>
                
<p>Django's built-in geospatial support requires the use of code libraries available from the <strong>Open Source Geospatial Foundation</strong> (<span><strong>OSGeo</strong>)</span>. The GDAL library, which includes OGR, handles vector and raster datasets. It must be installed (see <a href="0b3a2208-3881-479a-83a8-78be85b9c1d6.xhtml">Chapter 5</a>, <em><span>Vector Data Analysis</span></em>, and <a href="a5c9354e-8ea4-45f6-9e69-191375e171c3.xhtml">Chapter 6</a>, <em>Raster Data Processing</em>, for more details on using it for analysis). </p>
<p>If it is not already installed, use the OSGeo4W installer available at: <a href="https://trac.osgeo.org/osgeo4w/">https://trac.osgeo.org/osgeo4w/</a>. Select the correct installer for your machine. The installer will also install QGIS and GRASS and other open source geospatial programs. Download and run the installer and place the output files on your local drive. This file path (for example: <kbd>C:\OSGeo4w</kbd>) will be important when modifying the Windows environment variables. </p>
<div class="packt_infobox">Find installation instructions for configuring GeoDjango for Linux and macOS from the Django project documentation here: <br/>
<a href="https://docs.djangoproject.com/en/2.0/ref/contrib/gis/install/">https://docs.djangoproject.com/en/2.0/ref/contrib/gis/install/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying Windows environment variables</h1>
                </header>
            
            <article>
                
<p>Editing the system path and other environment variables within Windows requires administrative permissions. Here are the steps to edit them for our purposes:</p>
<ol>
<li>Log into an account with administrative permissions.</li>
<li>Open Windows Explorer and right-click on the PC icon in the left pane.</li>
<li>Select <span class="packt_screen">Properties</span> from the context menu.</li>
<li>Click on <span class="packt_screen">Advanced system settings</span>.</li>
<li>In the next menu, click on <span class="packt_screen">Environment Variables</span>.</li>
<li>Select <span class="packt_screen">Path</span> from the system variables and click <span class="packt_screen">Edit</span> (or double-click on the path value).</li>
<li>Add the file path of the <kbd>bin</kbd> folder in the <kbd>OSGeo4W</kbd> folder <span>(for example, <kbd>C:\OSGeo4W\bin</kbd>) </span><span>to the path:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;width:47.75em;height:39.75em;" src="assets/a278951a-3204-4cf5-bd15-c794188c225d.png"/></div>
<div class="packt_infobox">The <kbd>Python 3.6</kbd> folder has also been added to the path in this example, as well as <kbd>Python 2.7</kbd>, which is ordered behind <kbd>Python 3.6</kbd> because of its position in the path environment variable value. This means that when Python is passed to a command line, the <kbd>Python 3.6</kbd> executable will be run.</div>
<p><span>Two other variables that may be required are the <span class="packt_screen">GDAL_DATA</span> variable and the <span class="packt_screen">PROJ_LIB</span> variable. </span>If PostGIS has been installed, it will have created a <span class="packt_screen">GDAL_DATA</span> variable already, but if it is not present, click the <span class="packt_screen">New</span> button underneath the system variables box. Add the name of the variable (<span class="packt_screen">GDAL_DATA</span>) and the variable value (for example, <kbd>C:\OSGeo4W64\share\gdal</kbd>).</p>
<p>Add the <span class="packt_screen">PROJ_LIB</span> variable the same way:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3fc8d73c-8589-4663-bf5e-c480a87e6559.png"/></div>
<p>Click <span class="packt_screen">OK</span> to save the new variables, and <span class="packt_screen">OK</span> again to get out of the first settings dialog. Close the <span class="packt_screen">System Properties</span> menu.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a project and application</h1>
                </header>
            
            <article>
                
<p>Now that Django is installed, let's create a project. Django has two levels that are managed by scripts accepting command-line arguments. These two levels are projects and applications. A project can have many applications, and sometimes an application has multiple projects as well. This organization allows you to reuse of code between related applications, governed by project-level code.</p>
<p>Django uses an administration file, <kbd>django-admin.py</kbd>, to control the creation of projects. It is installed in the <kbd>Scripts</kbd> folder of the <kbd>Python 3</kbd> folder. I usually copy the <kbd>django-admin.py</kbd> file into a new project folder, and pass the required command-line arguments while working in the project folder, but it can also be called from the command line if the <kbd>Scripts</kbd> folder is included in the path environment variable.</p>
<p>Create a folder for your project; something like <kbd>C:\Projects</kbd>. Copy <kbd>django-admin.py</kbd> into <kbd>C:\Projects</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command-line argument – startproject</h1>
                </header>
            
            <article>
                
<p>A command-line argument is used with <kbd>django-admin.py</kbd> to create the project—<kbd>startproject</kbd>. To create a project, open the command prompt and change directories to the folder created earlier. We will create projects in this folder by passing <kbd>startproject</kbd> and the name of our new project (<kbd>chapter12</kbd>) to <kbd>django-admin.py</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/17c20ecb-1bc4-49bf-b62e-c01e9dff7c98.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is created by startproject?</h1>
                </header>
            
            <article>
                
<p>By passing the two arguments to <kbd>django-admin.py</kbd>, <kbd>startproject</kbd>, and <kbd>chapter12</kbd> (the name of the project), a folder is created with a number of scripts and subfolders. The outer (<kbd>root</kbd>) folder is called <kbd>chapter12</kbd>, and it contains an important script called <kbd>manage.py</kbd>, and a folder also called <kbd>chapter12</kbd><em>,</em> which is the project folder:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2e667b98-8611-4bef-9690-f6a8f6f0bb7e.png" style="width:25.42em;height:10.75em;"/></div>
<p>Inside the project folder are some important scripts, including <kbd>settings.py</kbd> and <kbd>urls.py</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0239fb6b-828e-4f0f-ab98-ab98d320a3cd.png" style="width:28.00em;height:12.00em;"/></div>
<p>These files are default placeholders, waiting for us to configure our project and applications. We will edit <kbd>setting.py</kbd> and <kbd>urls.py</kbd> too, with the specifics of our project as we go along. The third file, <kbd>wsgi.py</kbd>, is used for production deployment of the web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an application using manage.py</h1>
                </header>
            
            <article>
                
<p>Now, the <kbd>root</kbd> folder, <kbd>Projects</kbd> folder, and associated scripts have been created. Within the <kbd>root</kbd> folder is the <kbd>manage.py</kbd> file, which is used for configuration and management of the applications and project. In this section, we'll create an application using <kbd>manage.py</kbd> and the command-line argument <kbd>startapp</kbd>. </p>
<p><span>With the command prompt, change directories into the <kbd>root</kbd> folder. Unlike</span> <kbd>django-admin.py</kbd><span>, we have to run</span> <kbd>manage.py</kbd> <span>by passing it as an argument to the Python executable. In turn, to </span><kbd>manage.py</kbd> <span>we pass the argument</span> <kbd>startapp</kbd> <span>and the name of the application,</span> <kbd>arenas</kbd><span>. It should look like this:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/117d45fd-a4e0-4e8d-b81e-a9ce0ae91b85.png" style="width:33.33em;height:12.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is created by manage.py</h1>
                </header>
            
            <article>
                
<p>Passing the <kbd>startapp arenas</kbd> command to <kbd>manage.py</kbd> created a folder called <kbd>arenas</kbd>. All applications are created within the <kbd>root</kbd> folder, next to the project folder:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/76d4ed13-91b6-4f08-ac26-912e704f2822.png" style="width:23.42em;height:10.83em;"/></div>
<p>Inside the folder are auto-generated scripts that we will configure and add to later. There is also a folder called <kbd>migrations</kbd>, which is used by Django to store scripts describing edits to the database. The scripts <kbd>admin.py</kbd>, <kbd>models.py</kbd>, and <kbd>views.py</kbd> will be used in this chapter:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/114bdd5b-898b-416e-8793-812ed7422a98.png" style="width:25.67em;height:16.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring settings.py</h1>
                </header>
            
            <article>
                
<p>With the project created and a new application, the next step towards using GeoDjango is to configure the <kbd>settings.py</kbd> script contained in the project folder. We'll add the specifics about the database connection (user, password, database name, and so on), and adjust the <kbd>INSTALLED_APPS</kbd> setting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a new database connection</h1>
                </header>
            
            <article>
                
<p> Using IDLE or another IDE, open <kbd>settings.py</kbd> from the <kbd>chapter12</kbd> project folder. Scroll down to the variable called <kbd>DATABASES</kbd>. This variable, which is set to a local SQLite database, will be adjusted to the PostgreSQL database with the PostGIS extension.</p>
<p>This is the default:</p>
<pre>DATABASES = {<br/>     'default': {<br/>         'ENGINE': 'django.db.backends.sqlite3',<br/>         'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),<br/>     }<br/>}</pre>
<p>Change it to the following, substituting the <kbd>username</kbd> and <kbd>password</kbd> for your PostGIS installation (see <a href="42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml">Chapter 3</a>, <em>Introduction to Geospatial Databases</em>):</p>
<pre>DATABASES = {<br/>    'default': {<br/>         'ENGINE': 'django.contrib.gis.db.backends.postgis',<br/>         'NAME': 'chapter12',<br/>         'USER': '{username}',<br/>         'PASSWORD': '{password}',<br/>         'HOST': '127.0.0.1',<br/>         'PORT':'5432'<br/>    },<br/>}</pre>
<p>An empty string can also be used for the <kbd>HOST</kbd> option to indicate <kbd>localhost</kbd>. If the PostgreSQL installation is on a different machine, adjust the <kbd>HOST</kbd> option to the IP address of the database server. If it is on a different port, adjust the <kbd>PORT</kbd> option.</p>
<p>Save the script, but don't close it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding new installed apps</h1>
                </header>
            
            <article>
                
<p>Within <kbd>settings.py</kbd>, scroll to the variable <kbd>INSTALLED_APPS</kbd>. This lists the built-in, core applications used to support our application. To it, we'll add <kbd>django.contrib.gis</kbd>, the built-in Django GIS application, and our own new application, Arenas.</p>
<p><span><kbd>INSTALLED_APPS</kbd> is a list and can be edited. </span>Initially, <kbd>INSTALLED_APPS</kbd> looks like this:</p>
<pre>INSTALLED_APPS = [<br/>    'django.contrib.admin',<br/>    'django.contrib.auth',<br/>    'django.contrib.contenttypes',<br/>    'django.contrib.sessions',<br/>    'django.contrib.messages',<br/>    'django.contrib.staticfiles',<br/>]</pre>
<p>Edit it to look like this:</p>
<pre>INSTALLED_APPS = [<br/>    'django.contrib.admin',<br/>    'django.contrib.auth',<br/>    'django.contrib.contenttypes',<br/>    'django.contrib.sessions',<br/>    'django.contrib.messages',<br/>    'django.contrib.staticfiles',<br/><strong>    'django.contrib.gis',</strong><br/><strong>    'arenas',</strong><br/>]</pre>
<p>Save <kbd>settings.py</kbd> and close the script. Now w<span>e've added our custom arenas app and Django's GIS library to the installed app package manager, so</span> GeoDjango is now configured. Next, we'll use <kbd>manage.py</kbd> and OGR to read shapefiles and automatically generate data models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the application</h1>
                </header>
            
            <article>
                
<p>This application will perform geospatial analysis using the geometry fields of database tables. To make this possible, we have to create and populate the database tables using shapefiles and a built-in method called <kbd>LayerMapping</kbd>.</p>
<p>The completed application will need URL pattern matching to link URLs with the views that will process the requests and return the response. Templates will be used to pass processed data to the browser. Views will be written to be able to handle both <kbd>POST</kbd> and <kbd>GET</kbd> requests and to redirect to other views.</p>
<p>Now that GeoDjango is configured, the NBA Arenas application can be created using the Django project management script called <kbd>manage.py</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">manage.py</h1>
                </header>
            
            <article>
                
<p>The script <kbd>manage.py</kbd> performs a number of jobs to help set up and manage the project. For testing purposes, it can create a local web server (using <kbd>runserver</kbd> as the argument); it manages database schema migrations, generating tables from data models (using <kbd>makemigration</kbd> and <kbd>migrate</kbd>); it even has a built-in Python 3 shell (using <kbd>shell</kbd>) for testing and more:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0e08c8f9-ae5d-484b-b60f-81a06f8a823a.png"/></div>
<p>In this section, we'll use <kbd>manage.py</kbd> to create<span> and populate</span> database tables, using shapefiles as the data and schema source.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating data models</h1>
                </header>
            
            <article>
                
<p>After configuring GeoDjango, a new available function in <kbd>manage.py</kbd> is available, <kbd>ogrinspect</kbd>, which automatically <span>generates </span>data table models with geometry columns that can be placed in <kbd>models.py</kbd>. By inspecting or reading the shapefile data using OGR, Django's built-in functionality creates a <span>Python class </span>data model and a field mapping dictionary that maps between the names of shapefile fields and database columns. </p>
<p>For this section, we will use the shapefiles downloaded in <a href="e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml">Chapter 11</a>, <em>Flask and GeoAlchemy2</em>. They are also available in the code package. Copy the four shapefiles (and all of the associated files) into a folder called <kbd>data</kbd> within the arenas application folder:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0c239832-ff10-469c-af8c-fb7754492ac7.png"/></div>
<p>Open a command prompt, and change the directory to the project folder. The <kbd>data</kbd> folder with the four shapefiles (<kbd>Arenas_NBA.shp</kbd>, <kbd>US_States.shp</kbd>, <kbd>US_County_Boundaries.shp</kbd>, and <kbd>Congressional_Districts.shp</kbd>) will be inspected to generate data models using <kbd>manage.py</kbd>. The results are copied to <kbd>models.py</kbd>. From these models, the database tables will be generated, and then the tables will be populated using the field mapping dictionaries:</p>
<pre><strong>C:\Projects\chapter12&gt;python manage.py ogrinspect arenas\data\Arenas_NBA.shp Arenas --srid=4326 --mapping</strong></pre>
<p>This command will produce a data model with a geometry column and a <kbd>4326</kbd> SRID. The <span>field mapping dictionary</span>, generated by the <kbd>--mapping</kbd> option, is a Python dictionary that maps between the keys (data model column names) and the values (shapefile field names). This is a part of the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d9dc5556-ddbb-494d-bbb2-a8cd113c170c.png"/></div>
<p>Copy the output, including the <kbd>import</kbd> line, data model, and the <span>field mapping dictionary</span> into <kbd>arenas</kbd>\<kbd>models.py</kbd>. Copy the <kbd>import</kbd> line over the data model class definition over the auto-generated <kbd>import</kbd> line in <kbd>models.py</kbd>.</p>
<div class="packt_tip">Copying from the command line is easy when the <span class="packt_screen">Quick Edit</span> option is turned on in the command prompt defaults. Once it is on, select text by dragging the mouse. Push <em>Enter</em> when the text block has been selected.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multipolygons </h1>
                </header>
            
            <article>
                
<p>For the three other shapefiles with multipolygon geometry types, we'll pass the argument—<kbd>multi</kbd> to <kbd>manage.py</kbd> and <kbd>ogrinspect</kbd>. Using this option generates a <kbd>MultiPolygon</kbd> geometry column in the data model.</p>
<p>This command generates a data model from the US States shapefile:</p>
<pre><strong>C:\Projects\chapter12&gt;python manage.py ogrinspect arenas\data\US_States.shp US_States \</strong><br/><strong>     --srid=4326 --mapping --multi</strong></pre>
<p>The output will look like this:</p>
<pre>#<strong> This is an auto-generated Django model module created by ogrinspect.</strong><br/><strong>from django.contrib.gis.db import models</strong><br/><strong>class US_States(models.Model):</strong><br/><strong>    stfips = models.CharField(max_length=2)</strong><br/><strong>    state = models.CharField(max_length=66)</strong><br/><strong>    stpostal = models.CharField(max_length=2)</strong><br/><strong>    version = models.CharField(max_length=2)</strong><br/><strong>    dotregion = models.IntegerField()</strong><br/><strong>    shape_leng = models.FloatField()</strong><br/><strong>    shape_area = models.FloatField()</strong><br/><strong>    geom = models.MultiPolygonField(srid=4326)</strong><br/><strong># Auto-generated `LayerMapping` dictionary for US_States model</strong><br/><strong>    us_states_mapping = {</strong><br/><strong>    'stfips': 'STFIPS',</strong><br/><strong>    'state': 'STATE',</strong><br/><strong>    'stpostal': 'STPOSTAL',</strong><br/><strong>    'version': 'VERSION',</strong><br/><strong>    'dotregion': 'DotRegion',</strong><br/><strong>    'shape_leng': 'Shape_Leng',</strong><br/><strong>    'shape_area': 'Shape_Area',</strong><br/><strong>    'geom': 'MULTIPOLYGON',</strong><br/><strong>}</strong></pre>
<p>Copy the output to <kbd>models.py</kbd>, including both the data model and the field mapping dictionary. Repeat the process for the counties and districts shapefiles by adjusting the arguments to <kbd>manage.py</kbd><em> </em>(that is, the shapefile name and the table name), and save <kbd>models.py</kbd> once the models have been added.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database migrations</h1>
                </header>
            
            <article>
                
<p>Django uses a concept of database migrations to record and execute changes to the database. These changes include table creation and schema alterations. Now that we have generated the data models, we need to migrate the database, which involves inspecting <kbd>models.py</kbd> for changes, calculating the SQL syntax to generate the database alterations, and then running the required migrations to make the database table columns match their <kbd>models.py</kbd> code definitions. These migrations can also be reverted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">makemigrations </h1>
                </header>
            
            <article>
                
<p>To start the migration, pass <kbd>makemigrations</kbd> to <kbd>manage.py</kbd>. This argument will start the migration process by inspecting the contents of <kbd>models.py</kbd>. All of the Python class data models will be read, and the corresponding SQL is generated:</p>
<pre><strong>C:\Projects\chapter12&gt;python manage.py makemigrations</strong><br/><strong>Migrations for 'arenas':</strong><br/><strong>  arenas\migrations\0001_initial.py</strong><br/><strong>    - Create model Arenas</strong><br/><strong>    - Create model Counties</strong><br/><strong>    - Create model Districts</strong><br/><strong>    - Create model US_States</strong></pre>
<p>A new script has been generated and added to the <kbd>migrations</kbd> folder. This initial database migration script creates a <kbd>Migration</kbd> class and includes a number of migration operations using the <kbd>CreateModel</kbd> method. Each of these migrations creates operations will generate a new (empty) table in the <kbd>chapter12</kbd> database. <kbd>Migration</kbd> classes also have methods for performing table alterations, when you need to add or remove fields.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">sqlmigrate</h1>
                </header>
            
            <article>
                
<p>Use the command <kbd>sqlmigrate</kbd> to see the SQL statements generated from the <kbd>makemigration</kbd> operation. Pass <kbd>sqlmigrate</kbd>, the application label (<kbd>arenas</kbd>), and the migration name (<kbd>0001</kbd>) to <kbd>manage.py</kbd> to generate the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2f0aeaa8-cb7a-41b8-8370-f596c379e116.png"/></div>
<p>All of the data models have been translated to SQL, with definitions for primary keys and field lengths added automatically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">migrate</h1>
                </header>
            
            <article>
                
<p>With the migration script generated, we can finally perform the database migration. This operation will generate the tables within the database specified in <kbd>settings.py</kbd>.</p>
<p>Pass the argument <kbd>migrate</kbd> to <kbd>manage.py</kbd>:</p>
<pre><strong>C:\Projects\chapter12&gt;python manage.py migrate</strong></pre>
<p>The result of the operation should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c116e214-f585-4673-8308-7287af23b699.png"/></div>
<p>The database tables have been created in the database. Open pgAdmin4 (or another database GUI tool) to check on the tables within the database, or open psql and use the command line interface.</p>
<div class="packt_infobox"><span>Explore the Django documentation to explore all of the available arguments for <kbd>django-admin.py</kbd> and <kbd>manage.py</kbd>:<br/></span><a href="https://docs.djangoproject.com/en/2.0/ref/django-admin/"><span>https://docs.djangoproject.com/en/2.0/ref/django-admin/</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">LayerMapping</h1>
                </header>
            
            <article>
                
<p>To populate the database tables created from the shapefiles, Django has a built-in concept called <kbd>LayerMapping</kbd>. By using the field mapping dictionary generated by <kbd>manage.py</kbd>, along with the <kbd>LayerMapping</kbd> class from <kbd>django.contrib.gis.utils</kbd>, the data contained in the shapefiles can be extracted and loaded into the database tables. To instantiate a <kbd>LayerMapping</kbd> instance, we will pass the data model, the associated field mapping, and the location of the shapefile to the class.</p>
<p>Create a new file called <kbd>load.py</kbd> and save it inside the Arenas application. Add this line to the file:</p>
<pre>import os<br/>from django.contrib.gis.utils import LayerMapping<br/>from .models import US_States, Counties, Arenas, Districts</pre>
<p>Open <kbd>models.py</kbd> and copy all of the field mapping dictionaries into <kbd>load.py</kbd>. Then, use the <kbd>os</kbd> module to assign the shapefile path to a variable. Here is the dictionary and path variable for <kbd>US_County_Boundary.shp</kbd>:</p>
<pre>us_counties_mapping = {<br/>'stfips' : 'STFIPS', 'ctfips' : 'CTFIPS', 'state' : 'STATE', 'county' : 'COUNTY',<br/>'version' : 'VERSION', 'shape_leng' : 'Shape_Leng', 'shape_area' : 'Shape_Area', 'geom' : 'MULTIPOLYGON'<br/>}<br/>counties_shp = os.path.abspath(os.path.join(os.path.dirname(__file__), 'data','US_County_Boundaries.shp'),<br/>)</pre>
<p>Repeat this step for all of the shapefiles, as demonstrated in the <kbd>load.py</kbd> provided in the code package. These path variables and mapping dictionaries are required to perform the layer mapping. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the layer mapping </h1>
                </header>
            
            <article>
                
<p>At the bottom of <kbd>load.py</kbd>, create a function called <kbd>run</kbd> that contains the following code. Note that the names of the mappings (for example, <kbd>us_states_mapping</kbd>) will have to match the names of the dictionaries:</p>
<pre>def run(verbose=True):<br/>    lm = LayerMapping(<br/>        US_States, states_shp, us_states_mapping,<br/>        transform=False, encoding='iso-8859-1',<br/>    )<br/>    lm.save(strict=True, verbose=verbose)<br/>    lm = LayerMapping(<br/>        Counties, counties_shp, us_counties_mapping,<br/>        transform=False, encoding='iso-8859-1',<br/>    )<br/>    lm.save(strict=True, verbose=verbose)<br/>    lm = LayerMapping(<br/>        Districts, districts_shp, districts_mapping,<br/>        transform=False, encoding='iso-8859-1',<br/>    )<br/>    lm.save(strict=True, verbose=verbose)<br/>    lm = LayerMapping(<br/>        Arenas, arenas_shp, arenas_mapping,<br/>        transform=False, encoding='iso-8859-1',<br/>    )<br/>    lm.save(strict=True, verbose=verbose)</pre>
<p>To run the script, we will use the <kbd>manage.py shell</kbd> argument to invoke a Python shell, and then import the <kbd>load.py</kbd> file and execute the <kbd>run</kbd> function inside this local shell: </p>
<pre><strong>&gt;&gt;&gt;</strong> <strong>from arenas import load</strong><br/><strong>&gt;&gt;&gt;</strong> <strong>load.run()</strong></pre>
<p>Once the <kbd>run</kbd> function is called and executed, the rows of data in the shapefiles are imported into the database tables:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4b22e3c5-ba3c-43d8-acbd-15607672236b.png"/></div>
<p>Once the function completes successfully, the database tables will be populated. We can now explore a very useful feature of Django—the built-in admin panel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Administrative panel</h1>
                </header>
            
            <article>
                
<p>The Django framework was developed in a busy newsroom environment, and from the beginning, it required a built-in administrative panel that would allow reporters and editors to access their stories. This concept has continued to be supported, as most websites require an interface for administrative tasks. It's a very useful and convenient interface that requires no technical knowledge about the site to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GeoDjango administrative panel</h1>
                </header>
            
            <article>
                
<p>Websites built with the GeoDjango configuration are no different, and the administrative panel for GeoDjango websites even supports the display<span> and editing</span> of geometry data. The <kbd>OpenLayers</kbd> JavaScript library is included in the panel template to allow for the data visualizations. It also allows for the normal administrative tasks such as editing groups or users and their permissions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">admin.py</h1>
                </header>
            
            <article>
                
<p>To access the data models stored in <kbd>models.py</kbd> through the administrative panel, the autogenerated script called <kbd>admin.py</kbd> inside the Arenas application must be updated. Open the file in an IDE and add the following lines, copying the original code:</p>
<pre>from django.contrib.gis import admin<br/>from .models import US_States, Counties, Arenas, Districts<br/>admin.site.register(US_States, admin.GeoModelAdmin)<br/>admin.site.register(Counties, admin.GeoModelAdmin)<br/>admin.site.register(Arenas, admin.GeoModelAdmin)<br/>admin.site.register(Districts, admin.GeoModelAdmin)</pre>
<p>Save the script and close it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">createsuperuser</h1>
                </header>
            
            <article>
                
<p>The first step is to create a superuser. This user will be able to access the administrative panel. To do this, we will pass the <kbd>createsuperuser</kbd> argument to <kbd>manage.py</kbd> and follow the instructions as they appear one by one:</p>
<pre><strong>C:\Projects\chapter12&gt;python manage.py createsuperuser</strong><br/><strong>Username: loki</strong><br/><strong>Email address: email@server.com</strong><br/><strong>Password:</strong><br/><strong>Password (again):</strong><br/><strong>Superuser created successfully.</strong></pre>
<p>The superuser is now available for logging into the administrative panel, using the password and username supplied.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">runserver</h1>
                </header>
            
            <article>
                
<p>Once the superuser has been created, pass the <kbd>runserver</kbd> argument to <kbd>manage.py</kbd> to start the local development web server:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50708041-295e-426d-b330-bec34b8afe33.png" style="width:39.25em;height:12.25em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">This will make the <kbd>localhost</kbd> open at port <kbd>8000</kbd> by default (<kbd>http://127.0.0.1:8000</kbd>). The administrative panel is available at: <kbd>http://127.0.0.1:8000/admin</kbd>. Open a web browser and navigate to the administrative panel URL. Enter the superuser credentials:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/316a4389-9f0b-45c9-a2ae-29affc4fa067.png" style="width:30.58em;height:21.67em;"/></div>
<p>Once they are entered, the administrative panel will list the available models, as well as the authentication and authorization section. These models are initially shown with an <span class="packt_screen">s</span> at the end of their name (pluralizing them by default). This behavior can (and should) be overridden, though we won't focus on that task here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/236269fb-0033-4657-ace3-6bb5732ad665.png" style="width:39.08em;height:29.00em;"/></div>
<p>Click on the <span class="packt_screen">U_s_statess</span> model under <span class="packt_screen">ARENAS</span>, and then click on the first object in the list of states objects. It should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/031b3c08-fca8-46a6-8980-b3ab1548b3b1.png" style="width:41.00em;height:30.00em;"/></div>
<p>These fields can be edited through this administrative panel, and even the geometry of the state (or, in this case, Puerto Rico) can be edited using the <kbd>OpenLayers</kbd> editing plugin included. Click <span class="packt_screen">Save</span> after any edits. The data row can also be deleted from this interface.</p>
<div class="packt_infobox">Explore the complete administrative panel documentation here:<br/>
<a href="https://docs.djangoproject.com/en/2.0/ref/contrib/admin/">https://docs.djangoproject.com/en/2.0/ref/contrib/admin/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URLs</h1>
                </header>
            
            <article>
                
<p>Finally, within the HTML form section, we designate where the description and a drop-down list will go and include a hidden token (CSRF), which is required for authentication.</p>
<p>With the models generated and data added to the associated tables, it's time to generate some views, which will process our web requests and return the data required to complete our request. </p>
<p>To correctly route our requests, we have to first create some URLs that will be paired with a view. This will require both project-level and application-level configuration. Unlike Flask, URLs are not attached to views using Python decorators. Instead, they are contained in separate scripts that will either map to an application or a view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URL patterns</h1>
                </header>
            
            <article>
                
<p>Django URL patterns are very clean and simple and make for nice websites where the URLs are short and memorable. To make this possible, there is matching of the requested URL with a view (or application-level URL that matches with a view). The URLs and their destination are matched inside a list called <kbd>urlpatterns</kbd>. </p>
<p>Within the project folder (<kbd>C:\Projects\chapter12\chapter12</kbd>), there is a script called <kbd>urls.py</kbd> just underneath <kbd>settings.py</kbd>. This script controls project-level URL routing. For this application, we'll also add application-level URLs inside the <kbd>arenas</kbd> folder and will point the project-level URL routing to the application URLs.</p>
<p>Open up the project-level <kbd>urls.py</kbd>, and copy the following code over any existing code:</p>
<pre>from django.urls import include, path<br/>from django.contrib.gis import admin<br/>urlpatterns = [<br/>  path('', include('arenas.urls')),<br/>  path('arena/', include('arenas.urls')),<br/>  path('admin/', admin.site.urls),<br/>]</pre>
<p>This code will redirect the requests to two different URLs in the application-level <kbd>urls.py</kbd> file, where they can be further sorted. Any requests sent to the admin URL are handled by the administrative code. The <kbd>path</kbd> function accepts two required parameters: the URL path (for example, <kbd>'arenas/'</kbd>, which goes to <kbd>http://127.0.0.1:8000/arenas</kbd>), and the view or application-level code that will accept the request. The <kbd>include</kbd> function is used to add the available URLs from the Arenas application into the project level URLs.</p>
<p>To create the application-level URLs, create a script called <kbd>urls.py</kbd> inside the Arenas application folder. Copy the following code:</p>
<pre>from django.urls import path<br/>from . import views<br/>urlpatterns = [<br/>    path('', views.index, name='index'),<br/>    path('arena', views.arena, name='arena'),<br/>]</pre>
<p>This time, the function <kbd>path</kbd> directs requests to views (that will be) inside the <kbd>views.py</kbd> script. Both the base URL and the arena URL are redirected to a view. The optional parameter <kbd>name</kbd> is also included.</p>
<div class="packt_tip">Note that a major change in Django URL patterns was introduced in Django 2.0. Earlier Django versions do not use the <kbd>path</kbd> function but use a similar function called <kbd>url</kbd>. Ensure that you are using the newest version of Django to match the code here.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Views</h1>
                </header>
            
            <article>
                
<p><span>Views are at the heart of the application, and in Django take the form of Python functions. They accept both <kbd>GET</kbd> and <kbd>POST</kbd> web requests, allowing for multiple actions, with various responses, to occur inside the same function. Within</span> view <span>functions, we design how the request is parsed, how database tables are queried, how the query results (<strong>QuerySets</strong> in Django) are processed, and which forms and templates are sent to the browser along with the processed data.</span></p>
<p><span>N</span>ow that the URL patterns are in place, we need to write some views that will accept and process the web requests sent to the URLs. These views will query the database table model classes in <kbd>models.py</kbd><em> </em>to find the location data associated with each NBA arena included in the <kbd>Arenas</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Required folders and files</h1>
                </header>
            
            <article>
                
<p>The first step is to create the necessary folders with files of forms and templates, as web responses from the views require a pre-generated template that can display the requested data (in this case, the location of the NBA <kbd>arena</kbd> requested).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">forms.py</h1>
                </header>
            
            <article>
                
<p>A web form is used in Django to capture user input and submit it to a view. To make it possible to select an NBA <kbd>arena</kbd> name from a drop-down list and have the web map zoom to that location, a new script, <kbd>forms.py</kbd>, must be created. Open an IDE and copy the following code into a new file:</p>
<pre>from django import forms<br/>from .models import Arenas<br/>class ArenaForm(forms.Form):<br/>    name = ""<br/>    description = "Use the dropdown to select an arena."<br/>    selections = <br/>    forms.ChoiceField(choices=Arenas.objects.values_list('id','name1'),<br/>                                  widget=forms.Select(),required=True)</pre>
<p>This section creates a form class by subclassing from <kbd>forms.Form</kbd>. It has a <kbd>name</kbd> field, a <kbd>description</kbd> field, and a <kbd>ChoiceField</kbd>. The <kbd>ChoiceField</kbd> will create a drop-down list, populated by the IDs and names of the <kbd>arenas</kbd>. Other fields will be added to the <kbd>ArenaForm</kbd> class within the view and are not defined here. This form and its fields will be inserted into the template created in the next section. Save this file as <kbd>forms.py</kbd> into the Arenas application folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">templates folder</h1>
                </header>
            
            <article>
                
<p>Copy the <kbd>templates</kbd> folder from the completed code package into the Arenas application folder. Inside the <kbd>templates</kbd> folder is a folder called <kbd>arenas</kbd>, with a template HTML file called <kbd>index.html</kbd>. This file contains a JavaScript portion that generates a web map. On that map, the location of an NBA <kbd>arena</kbd> is displayed.</p>
<p>Django templates use placeholders <span>(demarcated with a </span><kbd>{{form.field }}</kbd><span> format) that </span>allow for data to be passed at runtime into the template, providing the specifics of the request. These placeholders are located throughout <kbd>index.html</kbd>. Django has its own built-in template language, which we will use here, and also includes Jinja2, which Flask also uses (see <a href="e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml">Chapter 11</a>, <em>Flask and GeoAlchemy2</em>).</p>
<p>The first portion <span>of <kbd>index.html</kbd> is </span>to highlight is where the <kbd>longitude</kbd> and <kbd>latitude</kbd> of the current NBA <kbd>arena</kbd> have been added to the Leaflet JavaScript, which centers the map window on that location at zoom level <kbd>13</kbd>:</p>
<pre><span> </span>var themap = L.map('map').setView([ <strong>{{form.latitude}}</strong>, <strong>{{form.longitude}}</strong>], <strong>13</strong>);</pre>
<p><span>The next portion</span><span> </span><span>to highlight is where the <kbd>longitude</kbd>, <kbd>latitude</kbd>, and custom <kbd>popup</kbd> about the current NBA <kbd>arena</kbd> are added to a marker:</span></p>
<pre>  L.marker([ <strong>{{form.latitude}}</strong>,<strong>{{form.longitude}}</strong>]).addTo(themap)<br/>  .bindPopup("<strong>{{form.popup}}</strong>").openPopup();</pre>
<p>Finally, within the HTML <kbd>form</kbd> section, we designate where the <kbd>description</kbd> and a drop-down list will go and include a hidden token (CSRF), which is required for authentication of the <kbd>POST</kbd> request. The button is generated by the input HTML:</p>
<pre>  &lt;form method="post" class="form"&gt;<br/>     &lt;h3&gt;{{form.name}}&lt;/h3&gt;<br/>     &lt;h4&gt;{{form.description}}&lt;/h4&gt;<br/>    <strong>{{form.selections}}</strong><br/>    &lt;br&gt;<br/>    &lt;input type="submit" value="Find Data"&gt;<br/>    <strong>{% csrf_token %}</strong><br/>  &lt;/form&gt;</pre>
<p>All of these placeholders will be populated when the view is processed and data is returned to the requesting browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing views</h1>
                </header>
            
            <article>
                
<p>Everything is finally set to write our views. Open up <kbd>views.py</kbd> from the Arenas application folder within an IDE. Import the required libraries, models, forms, and modules:</p>
<pre>from django.shortcuts import render, redirect<br/>from django.http import HttpResponse, HttpResponseNotFound<br/>from .models import US_States, Counties, Districts, Arenas<br/>from .forms import ArenaForm<br/>from django.views.decorators.http import require_http_methods<br/>import random</pre>
<p>Next, we will create two views—<kbd>index</kbd> and <kbd>arena</kbd><em>, </em>and one non-view function called <kbd>queryarena</kbd>. These match with the URLs we added to <kbd>urls.py</kbd>. The return from the <kbd>index</kbd> function is very simple—it will redirect to the function <kbd>arena</kbd>. For the views, a decorator is used to determine the HTTP request methods allowed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">index view</h1>
                </header>
            
            <article>
                
<p>The <kbd>index</kbd> view is a Python function that accepts the request data and redirects it to the <kbd>arena</kbd> view, with a decorator (<kbd>require_http_methods</kbd>) prior to restricting the HTTP requests allowed:</p>
<pre>@<strong>require_http_methods</strong>(["GET", "POST"])<br/>def index(request):<br/>    return <strong>redirect</strong>(arena)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">queryarena function</h1>
                </header>
            
            <article>
                
<p>The <kbd>arena</kbd> function below selects a random <kbd>arena</kbd> for the initial <kbd>GET</kbd> request, getting data from the database model about the selected NBA <kbd>arena</kbd>. The queries themselves are handled by the <kbd>queryarena</kbd> function.</p>
<p><span>In this function, the name of the selected <kbd>arena</kbd> is accepted as a parameter. It is used to query (or</span> <kbd>filter</kbd><span>) all of the <kbd>Arenas</kbd> model objects. This <strong>object-relational mapping</strong> (<strong>ORM</strong>) </span><kbd>filter</kbd><span> method requires a field as a parameter; in this case, the field is called </span><kbd>name1</kbd><span>. As an example of what the <kbd>filter</kbd> is doing,  if the name of the <kbd>arena</kbd> is <em>Oracle Arena</em>, the <kbd>filter</kbd> translated to English would be <em>find all NBA arenas with the name Oracle Arena</em>. The results of the <kbd>filter</kbd> method are returned as a list, so the first result is retrieved from the list using zero-indexing. A result is an object representing the data row from the <kbd>Arenas</kbd> class that met the <kbd>filter</kbd> parameters:</span></p>
<pre>def queryarena(name):<br/>    arena = Arenas.objects.filter(<strong>name1=name</strong>)[0]<br/>    state = US_States.objects.filter(<strong>geom__intersects</strong>=<strong>arena.geom</strong>)<br/>    if state:<br/>        state = state[0]<br/>        county = Counties.objects.filter(<strong>geom__contains</strong>=arena.geom)[0]<br/>        district = Districts.objects.filter(<strong>geom__contains</strong>=arena.geom)[0]<br/>        popup = "This arena is called " + arena.name1 + " and it's <br/>        located at " <br/>        popup += str(round(arena.geom.x,5))+ "," + <br/>        str(round(arena.geom.y,5) )<br/>        popup += "It is located in " +state.state + " and in the county <br/>        of " + county.county<br/>        popup += " and in Congressional District " + district.district<br/>        return arena.name1, arena.geom.y, arena.geom.x, popup<br/>    else:<br/>        return arena.name1, arena.geom.y, arena.geom.x, arena.name1 + " <br/>        is not in the United States"</pre>
<p>Once the <kbd>arena</kbd> object is instantiated, its geometry field is used in a <kbd>filter</kbd> operation. Instead of using a field to <kbd>filter</kbd>, however, this <kbd>filter</kbd> uses geospatial analysis. <span>Passing </span><kbd>arena.geom</kbd><span> to the </span><kbd>geom__intersects</kbd> method (provided by GeoDjango) performs an intersect operation to find the state in which the <kbd>arena</kbd> resides. An <kbd>if</kbd>/<kbd>else</kbd> conditional checks to ensure that the <kbd>arena</kbd> is located in the United States (for instance, not Toronto's <kbd>arena</kbd>) to determine the correct value to return.</p>
<p>If the <kbd>arena</kbd> is located inside the United States, the <kbd>arena</kbd> geometry is again used to determine the <kbd>county</kbd> and congressional <kbd>district</kbd> that contain the <kbd>arena</kbd>. This time, the geospatial operation is <kbd>geom_contains</kbd>. The <kbd>filters</kbd> return a <kbd>county</kbd> object and a <kbd>district</kbd> object. They are used to generate the custom <kbd>popup</kbd> that will be added to the map marker on the leaflet map. This <kbd>popup</kbd> contains the <kbd>longitude</kbd> and <kbd>latitude</kbd> of the <kbd>arena</kbd>, the name of the <kbd>arena</kbd>, and the name of its <kbd>county</kbd>, <kbd>state</kbd>, and the number of the congressional <kbd>district</kbd> within its <kbd>state</kbd>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">arena view</h1>
                </header>
            
            <article>
                
<p>The <kbd>arena</kbd> view accepts the <kbd>request</kbd> object and then instantiates an <kbd>ArenaForm</kbd> object to gather the data needed to respond to the <kbd>request</kbd>. <span>A query of </span><span>the <kbd>Arenas</kbd> model objects and its</span> <kbd>values_list</kbd> <span>method creates a Python list that contains tuples with the ID and name of every <kbd>arena</kbd>. </span>The <kbd>request</kbd> method (either <kbd>GET</kbd> or <kbd>POST</kbd>) is used in a conditional to determine the appropriate response.</p>
<p>If a <kbd>GET</kbd> request is received (that is, the web page is first opened), a random <kbd>arena</kbd> object is generated and passed to the template, which shows the <kbd>arena</kbd> on the included map. To get a random <kbd>arena</kbd>, we use the list of <kbd>arena</kbd> names and IDs (values). Once the list is generated, a list comprehension is used to generate a new list containing <kbd>arena</kbd> names. </p>
<p>Using the <kbd>random</kbd> module and the <kbd>#</kbd> of names in the list (<kbd>length</kbd>) generates a random <kbd>index</kbd> that is used to select an <kbd>arena</kbd> name from the list. This <kbd>name</kbd> is then passed to the <kbd>queryarena</kbd> function, which populates the <kbd>form</kbd> with the <kbd>arena</kbd> <kbd>name</kbd>, location, and the <kbd>popup</kbd>. </p>
<p>These values are returned to the browser using the <kbd>render</kbd> function. This function is used to pass <kbd>forms</kbd> to templates along with the <kbd>request</kbd>, and knows where the <kbd>templates</kbd> folder is located inside the Arenas application:</p>
<pre class="mce-root">@require_http_methods(["GET", "POST"])<br/>def arena(request):<br/>  values = Arenas.objects.values_list('id','name1')<br/>  if <strong>request.method=="GET"</strong>:<br/>    form= ArenaForm(request.GET)<br/>    names = [name for id, name in values]<br/>    length = len(names)<br/>    selectname = names[random.randint(0, length-1)]<br/>    form.name, form.latitude, form.longitude, form.popup =     <strong>queryarena</strong>(selectname)<br/>    return render(request, "arena/index.html", {"form":form})<br/>  else:<br/>    form= ArenaForm(request.POST)<br/>    if form.is_valid():<br/>      selectid = int(request.POST['selections'])<br/>      selectname = [name for ids, name in values if ids == selectid][0]<br/>      form.name, form.latitude, form.longitude, form.popup =         <br/>      queryarena(selectname)<br/>      return render(request, "arena/index.html", {"form":form})</pre>
<p>If a <kbd>POST</kbd> request is received (that is, an <kbd>arena</kbd> was selected), an <kbd>ArenaForm</kbd> class is called by passing the <kbd>POST</kbd> data to the class, and the <kbd>form</kbd> is validated. The ID of the selected <kbd>arena</kbd> is used as a conditional in a list comprehension, allowing us to retrieve the <kbd>name</kbd> of the <kbd>arena</kbd>. The <kbd>name</kbd> is then passed to <kbd>queryarena</kbd>, and the details of its location are queried and added to the <kbd>form</kbd> before it is returned using <kbd>render</kbd>.</p>
<p>The views are complete and the script can be saved. The next step is to run the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Open, the command prompt and change directories to the <kbd>root</kbd> folder (<kbd>C:\Projects\chapter12</kbd>). Start the local development server with the following command:</p>
<pre><strong>C:\Projects\chapter12&gt;python manage.py runserver</strong></pre>
<p>The result should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/257c5316-7c47-469e-a9a9-d4858dc1d43a.png" style="width:32.42em;height:17.17em;"/></div>
<p>Open a browser and go to: <kbd>http://127.0.0.1:8000</kbd>. The initial <kbd>GET</kbd> request will be redirected to the <kbd>arenas</kbd> view and processed, returning a random <kbd>arena</kbd>. Selecting another <kbd>arena</kbd> from the list and pushing the <span class="packt_screen">Find Data</span> button will perform a <kbd>POST</kbd> request and will locate the selected <kbd>arena</kbd>. Each time an <kbd>arena</kbd> is selected, the text of the <kbd>arena</kbd> name will change, along with the map location and popup displayed. </p>
<p>Here is an example of the results of a <kbd>POST</kbd> request:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/42da4615-1886-44c4-8ac2-9b91e1573145.png" style="width:41.83em;height:41.00em;"/></div>
<p>Test the application by selecting different NBA arenas, and for extra credit, change the popup message. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>Django, with its batteries-included philosophy, creates complete applications with very few outside libraries required. </span>This application performs data management and data analysis using only the Django built-in tools and the GDAL/OGR library. Enabling the GeoDjango functionality is a relatively seamless experience because it is an integral part of the Django project.</p>
<p>Creating web applications with Django allows for a lot of instant functionality, including the administrative panel. The <kbd>LayerMapping</kbd> makes it easy to import data from shapefiles. The ORM model makes it easy to perform geospatial filters or queries. The templating system makes it easy to add web maps as well as location intelligence to a website.</p>
<p>In the next chapter, we will use a Python web framework to create a geospatial REST API. This API will accept requests and return JSON encoded data representing geospatial features. </p>
<p> </p>
<p> </p>


            </article>

            
        </section>
    </body></html>