<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 4. Example Topology – Twitter"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Example Topology – Twitter</h1></div></div></div><p>This chapter builds on the material from <a class="link" href="ch03.html" title="Chapter 3. Introducing Petrel">Chapter 3</a>, <span class="emphasis"><em>Introducing Petrel</em></span>. In this chapter, we'll build a topology that demonstrates a number of new features and techniques. In particular, we'll see how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implement a spout that reads from Twitter</li><li class="listitem" style="list-style-type: disc">Build topology components based on third-party Python libraries</li><li class="listitem" style="list-style-type: disc">Compute statistics and rankings over rolling time periods</li><li class="listitem" style="list-style-type: disc">Read custom configuration settings from <code class="literal">topology.yaml</code></li><li class="listitem" style="list-style-type: disc">Use "tick tuples" to execute logic on a schedule</li></ul></div><div class="section" title="Twitter analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Twitter analysis</h1></div></div></div><p>Most of you <a id="id126" class="indexterm"/>have heard of Twitter, but if you have not, check out how Wikipedia describes Twitter:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"an online social networking service that enables users to send and read short 140-character messages called "tweets"."</em></span></p></blockquote></div><p>In 2013, users posted 400 million messages per day on Twitter. Twitter offers an API that gives developers real-time access to streams of tweets. On it, messages are public by default. The volume of messages, the availability of an API, and the public nature of tweets combine to make Twitter a valuable source of insights on current events, topics of interest, public sentiment, and so on.</p><p>Storm was originally <a id="id127" class="indexterm"/>developed at BackType to process tweets, and Twitter analysis is still a popular use case of Storm. You can see several examples on the Storm website at <a class="ulink" href="https://storm.apache.org/documentation/Powered-By.html">https://storm.apache.org/documentation/Powered-By.html</a>.</p><p>The topology in this chapter demonstrates how to read from Twitter's real-time streaming API, computing a ranking of the most popular words. It's a Python version of the "rolling top words" sample<a id="id128" class="indexterm"/> on the Storm website (<a class="ulink" href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/storm/starter/RollingTopWords.java">https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/storm/starter/RollingTopWords.java</a>), and consists of the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Twitter stream spout (<code class="literal">twitterstream.py</code>): This <a id="id129" class="indexterm"/>reads tweets from the Twitter sample stream.</li><li class="listitem" style="list-style-type: disc">Splitter bolt (<code class="literal">splitsentence.py</code>): This receives tweets and splits them into words. It is an improved version of the <a id="id130" class="indexterm"/>splitter bolt from <a class="link" href="ch03.html" title="Chapter 3. Introducing Petrel">Chapter 3</a>, <span class="emphasis"><em>Introducing Petrel</em></span>.</li><li class="listitem" style="list-style-type: disc">Rolling word count bolt (<code class="literal">rollingcount.py</code>): This <a id="id131" class="indexterm"/>receives words and counts the occurrences. It is similar to the word count bolt from <a class="link" href="ch03.html" title="Chapter 3. Introducing Petrel">Chapter 3</a>, <span class="emphasis"><em>Introducing Petrel</em></span>, but implements a rolling count (this means that the bolt periodically discards old data, so<a id="id132" class="indexterm"/> the word counts only consider recent messages).</li><li class="listitem" style="list-style-type: disc">Intermediate rankings bolt (<code class="literal">intermediaterankings.py</code>): This consumes word counts and <a id="id133" class="indexterm"/>periodically emits the <span class="emphasis"><em>n</em></span> most frequently seen words.</li><li class="listitem" style="list-style-type: disc">Total rankings bolt (<code class="literal">totalrankings.py</code>): This is similar to the intermediate rankings bolt. It <a id="id134" class="indexterm"/>combines the intermediate rankings to produce an overall set of rankings.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Twitter's Streaming API"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Twitter's Streaming API</h1></div></div></div><p>Twitter's public API is <a id="id135" class="indexterm"/>both powerful and flexible. It has many features for both posting and consuming tweets. Our application needs to receive and process tweets in real time. Twitter's streaming API was designed to solve this problem. In computer science, a <span class="emphasis"><em>stream</em></span> is a sequence of data elements (in this case, tweets) made available over time.</p><p>The streaming<a id="id136" class="indexterm"/> API is explained in detail at <a class="ulink" href="https://dev.twitter.com/streaming/overview">https://dev.twitter.com/streaming/overview</a>. To use it, an application first creates a connection to Twitter. The <a id="id137" class="indexterm"/>connection remains open indefinitely to receive tweets.</p><p>The Streaming API offers several ways to choose which tweets your application receives. Our topology uses the so-called sample stream, which provides a small subset of all tweets arbitrarily chosen by Twitter. The sample stream is intended for demos and testing. Production <a id="id138" class="indexterm"/>applications generally use one of the other stream types. For more information about the available streams, refer to <a class="ulink" href="https://dev.twitter.com/streaming/public">https://dev.twitter.com/streaming/public</a>.</p><div class="section" title="Creating a Twitter app to use the Streaming API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Creating a Twitter app to use the Streaming API</h2></div></div></div><p>Before<a id="id139" class="indexterm"/> we can use Twitter's Streaming API, Twitter requires us to create an app. This sounds complicated, but it's quite easy to set up; basically, we just fill in a form on the website:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If you don't have a<a id="id140" class="indexterm"/> Twitter account, create one at <a class="ulink" href="https://twitter.com/">https://twitter.com/</a>.</li><li class="listitem">Once you have an account, log in <a id="id141" class="indexterm"/>and go to <a class="ulink" href="https://apps.twitter.com/">https://apps.twitter.com/</a>. Click on <span class="strong"><strong>Create New App</strong></span>. Fill in the form for creating an application. Leave the <span class="strong"><strong>Callback URL</strong></span> field blank. The default access level is read-only, which means that this application can only read tweets; it can't post or make other changes. Read-only access is fine for this example. Finally, click on <span class="strong"><strong>Create your Twitter application</strong></span>. You will be redirected to your app's page.</li><li class="listitem">Click on the <span class="strong"><strong>Keys and Access Tokens</strong></span> tab, then click on <span class="strong"><strong>Create my access token</strong></span>. Twitter will generate an access token consisting of two parts: <span class="strong"><strong>Access Token</strong></span> and <span class="strong"><strong>Access Token Secret</strong></span>. While connecting to Twitter, your application will use this token along with <span class="strong"><strong>Consumer Key</strong></span> and <span class="strong"><strong>Consumer Secret</strong></span>. <p>The following screenshot shows the <span class="strong"><strong>Keys and Access Tokens</strong></span> tab after generating the access token:</p><div class="mediaobject"><img src="images/B03471_04_01.jpg" alt="Creating a Twitter app to use the Streaming API"/></div></li></ol></div></div><div class="section" title="The topology configuration file"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>The topology configuration file</h2></div></div></div><p>Now that we've <a id="id142" class="indexterm"/>set up a Twitter account with API access, we're ready to create the topology. First, create <code class="literal">topology.yaml</code>. We first saw a basic <code class="literal">topology.yaml</code> file in <a class="link" href="ch03.html" title="Chapter 3. Introducing Petrel">Chapter 3</a>, <span class="emphasis"><em>Introducing Petrel</em></span>. Here, <code class="literal">topology.yaml</code> will also hold the connection parameters for Twitter. Enter the following text, replacing the four<a id="id143" class="indexterm"/> <code class="literal">oauth</code> values with your own Twitter credentials from <a class="ulink" href="https://apps.twitter.com/">https://apps.twitter.com/</a>:</p><div class="informalexample"><pre class="programlisting">nimbus.host: "localhost"
topology.workers: 1

oauth.consumer_key: "blahblahblah"
oauth.consumer_secret: "blahblahblah"
oauth.access_token: "blahblahblah"
oauth.access_token_secret: "blahblahblah"</pre></div></div><div class="section" title="The Twitter stream spout"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>The Twitter stream spout</h2></div></div></div><p>Now, let's look at<a id="id144" class="indexterm"/> the Twitter spout. Enter this code in<a id="id145" class="indexterm"/> <code class="literal">twitterstream.py</code>:</p><div class="informalexample"><pre class="programlisting">import json
import Queue
import threading

from petrel import storm
from petrel.emitter import Spout

from tweepy.streaming import StreamListener
from tweepy import OAuthHandler, Stream

class QueueListener(StreamListener):
    def __init__(self, queue):
        self.queue = queue
    
    def on_data(self, data):
        tweet = json.loads(data)
        if 'text' in tweet:
            self.queue.put(tweet['text'])
        return True


class TwitterStreamSpout(Spout):
    def __init__(self):
        super(TwitterStreamSpout, self).__init__(script=__file__)
        self.queue = Queue.Queue(1000)

    def initialize(self, conf, context):
        self.conf = conf
        thread = threading.Thread(target=self._get_tweets)
        thread.daemon = True
        thread.start()

    @classmethod
    def declareOutputFields(cls):
        return ['sentence']

    def _get_tweets(self):
        auth = OAuthHandler(
            self.conf['oauth.consumer_key'],
            self.conf['oauth.consumer_secret'])
        auth.set_access_token(
            self.conf['oauth.access_token'],
            self.conf['oauth.access_token_secret'])
        stream = Stream(auth, QueueListener(self.queue))
        stream.sample(languages=['en'])

    def nextTuple(self):
        tweet = self.queue.get()
        storm.emit([tweet])
        self.queue.task_done()

def run():
    TwitterStreamSpout().run()</pre></div><p>How does the spout <a id="id146" class="indexterm"/>communicate with Twitter? The Twitter API imposes <a id="id147" class="indexterm"/>a number of requirements on API clients:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connections must be encrypted using the Secure Sockets Layer (SSL)</li><li class="listitem" style="list-style-type: disc">API clients must be authenticated using OAuth, a popular authentication protocol used to interact with secure web services</li><li class="listitem" style="list-style-type: disc">Because it involves a long-lived connection, the streaming API involves more than a simple HTTP request</li></ul></div><p>Fortunately, there is a library called <a id="id148" class="indexterm"/>
<span class="strong"><strong>Tweepy</strong></span> (<a class="ulink" href="http://www.tweepy.org/">http://www.tweepy.org/</a>) that implements these requirements in a simple and easy-to-use Python API. Tweepy provides a <code class="literal">Stream</code> class to connect to the Streaming API. It is used in <code class="literal">_get_tweets()</code>.</p><p>Creating a Tweepy stream requires the four Twitter connection parameters listed earlier. We could hardcode these directly in our spout, but then we'd have to change the code if the connection parameters change. Instead, we put this information in the <code class="literal">topology.yaml</code> configuration file. Our spout reads these settings in the <code class="literal">initialize()</code> function. Storm calls this function when a task for this component starts up, passing it information about the environment and configuration. Here, the <code class="literal">initialize()</code> function captures the topology configuration in <code class="literal">self.conf</code>. This dictionary includes the <code class="literal">oauth</code> values.</p><p>The following sequence diagram shows how the spout communicates with Twitter, receives tweets, and emits them. You may have noticed that the spout creates a background thread. This thread receives the tweets from Tweepy and passes them to the main spout thread using a Python queue.</p><div class="mediaobject"><img src="images/B03471_04_02.jpg" alt="The Twitter stream spout"/></div><p>Why does the spout use a thread? Often, threads are used to support concurrent processing. That's not the case<a id="id149" class="indexterm"/> here. Rather, there is simply a mismatch between the behavior of Tweepy and the Petrel spout API.</p><p>When reading from<a id="id150" class="indexterm"/> a Twitter stream, Tweepy blocks execution, calling an application-supplied event handler function for each tweet received.</p><p>In Petrel, the <code class="literal">nextTuple()</code> function on <a id="id151" class="indexterm"/>a spout must return from the function after each tuple.</p><p>Running Tweepy in a background thread that writes to a queue provides a simple and elegant solution to these conflicting requirements.</p></div><div class="section" title="Splitter bolt"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Splitter bolt</h2></div></div></div><p>The splitter bolt here is similar in <a id="id152" class="indexterm"/>structure to the one in <a class="link" href="ch03.html" title="Chapter 3. Introducing Petrel">Chapter 3</a>, <span class="emphasis"><em>Introducing Petrel</em></span>. This version has two improvements that make it more useful and realistic.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>Ignore words that are so common that they are not interesting or useful in a "top words" list. This includes English words such as "the," as well as word-like terms that appear frequently in Tweets, such as "http," "https," and "rt."</p><p>Omit punctuation when splitting a Tweet into words.</p></div></div><p>A Python library called<a id="id153" class="indexterm"/> <span class="strong"><strong>Natural Language Toolkit</strong></span> (<span class="strong"><strong>NLTK</strong></span>) makes it easy to implement both. NLTK has many other fascinating, powerful language processing features, but those are beyond the scope <a id="id154" class="indexterm"/>of this book.</p><p>Enter this code in <code class="literal">splitsentence.py</code>:</p><div class="informalexample"><pre class="programlisting">import nltk.corpus

from petrel import storm
from petrel.emitter import BasicBolt

class SplitSentenceBolt(BasicBolt):
    def __init__(self):
        super(SplitSentenceBolt, self).__init__(script=__file__)
        self.stop = set(nltk.corpus.stopwords.words('english'))
        self.stop.update(['http', 'https', 'rt'])

    def declareOutputFields(self):
        return ['word']

    def process(self, tup):
        for word in self._get_words(tup.values[0]):
            storm.emit([word])

    def _get_words(self, sentence):
        for w in nltk.word_tokenize(sentence):
            w = w.lower()
            if w.isalpha() and w not in self.stop:
                yield w

def run():
    SplitSentenceBolt().run()</pre></div></div><div class="section" title="Rolling word count bolt"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Rolling word count bolt</h2></div></div></div><p>The rolling word <a id="id155" class="indexterm"/>count bolt is similar to the word count bolt in <a class="link" href="ch03.html" title="Chapter 3. Introducing Petrel">Chapter 3</a>, <span class="emphasis"><em>Introducing Petrel</em></span>. The bolt in the earlier chapter simply accumulated the word counts indefinitely. This is not good for analyzing top words on Twitter, where popular topics can change from one moment to the next. Rather, we want counts that reflect the latest information. To do this, the rolling word count bolt stores data in time-based buckets. Then, it periodically discards buckets that exceed 5 minutes in age. Thus, the word counts from this bolt only consider the last 5 minutes of data.</p><p>Enter the<a id="id156" class="indexterm"/> following code in <code class="literal">rollingcount.py</code>:</p><div class="informalexample"><pre class="programlisting">from collections import defaultdict

from petrel import storm
from petrel.emitter import BasicBolt

class SlotBasedCounter(object):
    def __init__(self, numSlots):
        self.numSlots = numSlots
        self.objToCounts = defaultdict(lambda: [0] * numSlots)

    def incrementCount(self, obj, slot):
        self.objToCounts[obj][slot] += 1

    def getCount(self, obj, slot):
        return self.objToCounts[obj][slot]

    def getCounts(self):
        return dict((k, sum(v)) for k, v in self.objToCounts.iteritems())

    def wipeSlot(self, slot):
        for obj in self.objToCounts.iterkeys():
            self.objToCounts[obj][slot] = 0

    def shouldBeRemovedFromCounter(self, obj):
        return sum(self.objToCounts[obj]) == 0

    def wipeZeros(self):
        objToBeRemoved = set()
        for obj in self.objToCounts.iterkeys():
            if sum(self.objToCounts[obj]) == 0:
                objToBeRemoved.add(obj)
        for obj in objToBeRemoved:
            del self.objToCounts[obj]


class SlidingWindowCounter(object):
    def __init__(self, windowLengthInSlots):
        self.windowLengthInSlots = windowLengthInSlots
        self.objCounter = /
            SlotBasedCounter(
                self.windowLengthInSlots)
        self.headSlot = 0
        self.tailSlot = self.slotAfter(self.headSlot)

    def incrementCount(self, obj):
        self.objCounter.incrementCount(obj, self.headSlot)

    def getCountsThenAdvanceWindow(self):
        counts = self.objCounter.getCounts()
        self.objCounter.wipeZeros()
        self.objCounter.wipeSlot(self.tailSlot)
        self.headSlot = self.tailSlot
        self.tailSlot = self.slotAfter(self.tailSlot)
        return counts

    def slotAfter(self, slot):
        return (slot + 1) % self.windowLengthInSlots


class RollingCountBolt(BasicBolt):
    numWindowChunks = 5
    emitFrequencyInSeconds = 60
    windowLengthInSeconds = numWindowChunks * \
        emitFrequencyInSeconds

    def __init__(self):
        super(RollingCountBolt, self).__init__(script=__file__)
        self.counter = SlidingWindowCounter(
            self.windowLengthInSeconds /
                self.emitFrequencyInSeconds

    @classmethod
    def declareOutputFields(cls):
        return ['word', 'count']

    def process(self, tup):
        if tup.is_tick_tuple():
            self.emitCurrentWindowCounts()
        else:
            self.counter.incrementCount(tup.values[0])

    def emitCurrentWindowCounts(self):
        counts = self.counter.getCountsThenAdvanceWindow()
        for k, v in counts.iteritems():
            storm.emit([k, v])

    def getComponentConfiguration(self):
        return {"topology.tick.tuple.freq.secs":
            self.emitFrequencyInSeconds}


def run():
    RollingCountBolt().run()</pre></div><p>The <code class="literal">SlotBasedCounter</code> stores a list of <code class="literal">numSlots</code> (five) count values for each word. Each slot stores <code class="literal">emitFrequencyInSeconds</code> (60) seconds of data. Count values more than 5 minutes old are discarded.</p><p>How does the bolt<a id="id157" class="indexterm"/> know when 60 seconds have elapsed? Storm makes this easy by providing a feature called <span class="strong"><strong>tick tuples</strong></span>. This feature is useful<a id="id158" class="indexterm"/> when you need to execute some logic within your bolts as per a schedule. To use this feature, perform the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In <code class="literal">getComponentConfiguration()</code>, return a dictionary containing a <code class="literal">topology.tick.tuple.freq.secs</code> key. The value is the desired number of seconds between ticks.</li><li class="listitem" style="list-style-type: disc">In <code class="literal">process()</code>, check whether the tuple is a normal tuple or a tick tuple. When a tick tuple is received, the bolt should run its scheduled processing.</li></ul></div></div><div class="section" title="The intermediate rankings bolt"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>The intermediate rankings bolt</h2></div></div></div><p>The intermediate rankings bolt maintains a dictionary of the top <code class="literal">maxSize</code> (10) items ranked by occurrence<a id="id159" class="indexterm"/> count, and emits those items every <code class="literal">emitFrequencyInSeconds</code> (15) seconds. In production, the topology will run many instances of this bolt, with each of them maintaining the top words for a <span class="emphasis"><em>subset</em></span> of the overall words seen. Having many instances of the same component allows the topology to process large numbers of tweets and easily keep all the counts in the memory, even if the number of distinct words is quite large.</p><p>Enter this code in <code class="literal">intermediaterankings.py</code>:</p><div class="informalexample"><pre class="programlisting">from petrel import storm
from petrel.emitter import BasicBolt

def tup_sort_key(tup):
    return tup.values[1]


class IntermediateRankingsBolt(BasicBolt):
    emitFrequencyInSeconds = 15
    maxSize = 10

    def __init__(self):
        super(IntermediateRankingsBolt, self).__init__(script=__file__)
        self.rankedItems = {}

    def declareOutputFields(self):
        return ['word', 'count']

    def process(self, tup):
        if tup.is_tick_tuple():
            for t in self.rankedItems.itervalues():
                storm.emit(t.values)
        else:
            self.rankedItems[tup.values[0]] = tup
            if len(self.rankedItems) &gt; self.maxSize:
                for t in sorted(
                        self.rankedItems.itervalues(), key=tup_sort_key):
                    del self.rankedItems[t.values[0]]
                    break

    def getComponentConfiguration(self):
        return {"topology.tick.tuple.freq.secs":
            self.emitFrequencyInSeconds}

def run():
    IntermediateRankingsBolt().run()</pre></div></div><div class="section" title="The total rankings bolt"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>The total rankings bolt</h2></div></div></div><p>The total rankings bolt is very similar to the intermediate rankings bolt. There is only one instance of this bolt in the<a id="id160" class="indexterm"/> topology. It receives the top words from each instance of that bolt, choosing the top <code class="literal">maxSize</code> (10) items overall.</p><p>Enter the following code in <code class="literal">totalrankings.py</code>:</p><div class="informalexample"><pre class="programlisting">import logging

from petrel import storm
from petrel.emitter import BasicBolt

log = logging.getLogger('totalrankings')

def tup_sort_key(tup):
    return tup.values[1]


class TotalRankingsBolt(BasicBolt):
    emitFrequencyInSeconds = 15
    maxSize = 10

    def __init__(self):
        super(TotalRankingsBolt, self).__init__(script=__file__)
        self.rankedItems = {}

    def declareOutputFields(self):
        return ['word', 'count']

    def process(self, tup):
        if tup.is_tick_tuple():
            for t in sorted(
                    self.rankedItems.itervalues(),
                    key=tup_sort_key,
                    reverse=True):
                log.info('Emitting: %s', repr(t.values))
                storm.emit(t.values)
        else:
            self.rankedItems[tup.values[0]] = tup
            if len(self.rankedItems) &gt; self.maxSize:
                for t in sorted(
                        self.rankedItems.itervalues(),
                        key=tup_sort_key):
                    del self.rankedItems[t.values[0]]
                    break
            zero_keys = set(
                k for k, v in self.rankedItems.iteritems()
                if v.values[1] == 0)
            for k in zero_keys:
                del self.rankedItems[k]

    def getComponentConfiguration(self):
        return {"topology.tick.tuple.freq.secs": self.emitFrequencyInSeconds}

def run():
    TotalRankingsBolt().run()</pre></div></div><div class="section" title="Defining the topology"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Defining the topology</h2></div></div></div><p>Here is the <a id="id161" class="indexterm"/>
<code class="literal">create.py</code> script that defines the structure of the topology:</p><div class="informalexample"><pre class="programlisting">from twitterstream import TwitterStreamSpout
from splitsentence import SplitSentenceBolt
from rollingcount import RollingCountBolt
from intermediaterankings import IntermediateRankingsBolt
from totalrankings import TotalRankingsBolt

def create(builder):
    spoutId = "spout"
    splitterId = "splitter"
    counterId = "counter"
    intermediateRankerId = "intermediateRanker"
    totalRankerId = "finalRanker"
    builder.setSpout(spoutId, TwitterStreamSpout(), 1)
    builder.setBolt(
        splitterId, SplitSentenceBolt(), 1).shuffleGrouping("spout")
    builder.setBolt(
        counterId, RollingCountBolt(), 4).fieldsGrouping(
            splitterId, ["word"])
    builder.setBolt(
        intermediateRankerId,
        IntermediateRankingsBolt(), 4).fieldsGrouping(
            counterId, ["word"])
    builder.setBolt(
        totalRankerId, TotalRankingsBolt()).globalGrouping(
            intermediateRankerId)</pre></div><p>The structure of this topology is similar to the word count topology from <a class="link" href="ch03.html" title="Chapter 3. Introducing Petrel">Chapter 3</a>, <span class="emphasis"><em>Introducing Petrel</em></span>. <code class="literal">TotalRankingsBolt</code> has a new wrinkle. As described earlier, there is just one instance of this bolt, and it uses <code class="literal">globalGrouping()</code>, so all tuples from <code class="literal">IntermediateRankingsBolt</code> are sent to it.</p><p>You may be wondering why the topology needs both an intermediate ranking and a total ranking bolt. In order for us to know the top words overall, there needs to be a single bolt instance (total rankings) that sees across the entire tweet stream. But at high data rates, a single bolt can't possibly keep up with the traffic. The intermediate rankings bolt instances "shield" the total rankings bolt from this traffic, computing the top words for their slice of the tweet stream. This allows the final rankings bolt to compute the most common words overall, while consuming only a handful of the overall word counts. Elegant!</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Running the topology"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Running the topology</h1></div></div></div><p>We have a few more <a id="id162" class="indexterm"/>small items to address before we run the topology:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy the <code class="literal">logconfig.ini</code> file from the second example in <a class="link" href="ch03.html" title="Chapter 3. Introducing Petrel">Chapter 3</a>, <span class="emphasis"><em>Introducing Petrel</em></span>, to this topology's directory.</li><li class="listitem">Create a file called <code class="literal">setup.sh</code>. Petrel will package this script with the topology and run it at startup. This script installs the third-party Python libraries used by the topology. The file looks like this:<div class="informalexample"><pre class="programlisting">pip install -U pip
pip install nltk==3.0.1 oauthlib==0.7.2 tweepy==3.2.0</pre></div></li><li class="listitem">Create a file called <code class="literal">manifest.txt</code> with these two lines:<div class="informalexample"><pre class="programlisting">logconfig.ini
setup.sh</pre></div></li><li class="listitem">Before running the topology, let's review the list of files that we've created. Make sure you have created these files correctly:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">topology.yaml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">twitterstream.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">splitsentence.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">rollingcount.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">intermediaterankings.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">totalrankings.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">manifest.txt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setup.sh</code></li></ul></div></li><li class="listitem">Run the topology with this command:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>petrel submit --config topology.yaml --logdir `pwd`</strong></span></pre></div></li></ol></div><p>Once the topology starts running, open another terminal in the <code class="literal">topology</code> directory. Enter the following command to see the <code class="literal">log</code> file for the total rankings bolt, sorted from oldest to newest:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>ls -ltr petrel*totalrankings.log</strong></span></pre></div><p>If this is the first time you've run the topology, there will be only one log file listed. A new file is created for each run. If there are several files listed, choose the most recent one. Enter this command to monitor the contents of the log file (the exact filename will be different on your system):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>tail -f petrel24748_totalrankings.log</strong></span></pre></div><p>About every 15 seconds, you <a id="id163" class="indexterm"/>will see log messages with the top 10 words in descending order of popularity, like this:</p><div class="mediaobject"><img src="images/B03471_04_03.jpg" alt="Running the topology"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we developed a complex topology using a number of new techniques and libraries. After reading this example, you should be ready to begin applying Petrel and Storm to solve real problems.</p><p>In the upcoming chapter, we'll take a closer look at some of Storm's built-in features that are useful while operating a cluster, such as logging and monitoring.</p></div></div>
</body></html>