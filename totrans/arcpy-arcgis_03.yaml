- en: Chapter 3. Creating the First Python Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have Python configured to fit our needs, we can create Python scripts.
    This chapter will explore how to use ArcGIS **ModelBuilder** to model a simple
    analysis as the basis for our script. ModelBuilder is very useful on its own and
    for creating Python scripts as it has an operational and a visual component, and
    all models can be outputted as Python scripts. This will allow us to compare how
    the more familiar ModelBuilder utilizes tools in the ArcToolbox to how Python
    handles the same tools. We will also discuss iteration and when it is best to
    use Python over ModelBuilder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling a simple analysis using ModelBuilder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting the model out to a Python script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Along with ArcGIS ModelBuilder, a data set and scripts are required."'
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, the accompanying data and scripts should be downloaded from
    Packt Publishing's website. The completed scripts are available for comparison
    purposes and the data will be used for this chapter's analysis.
  prefs: []
  type: TYPE_NORMAL
- en: ModelBuilder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ArcGIS has been in development since the 1970s. During that time, it included
    a variety of programming languages and tools to help GIS analysts automate analyses
    and map production. These include the Avenue scripting language in the ArcGIS
    3x series and the **ARC Macro Language** (**AML**) in the ARC/Info workstation
    days, as well as VBScript up until ArcGIS 10x when Python was introduced. Another
    useful tool introduced in ArcGIS 9x was ModelBuilder, a visual programming environment
    used for both modeling analysis and creating tools that can be used repeatedly
    with different input feature classes.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of ModelBuilder is an export function that allows modelers
    to create Python scripts directly from a model. This will make it easier to compare
    how inputs in a ModelBuilder tool are accepted versus how a Python script calls
    the same tool and supplies the inputs to it, or how the feature classes that are
    created are named and placed within the file structure. ModelBuilder is a fantastic
    tool that will make it easy for a GIS analyst to bridge the gap from normal GIS
    workflows to automated Python-based workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model and exporting to Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will depend on the downloadable `SanFrancisco.gdb` file geodatabase,
    available from the Packt Publishing website. The San Francisco GDB contains data
    downloaded from [data.sfgov.org](http://data.sfgov.org) and the US Census' American
    Factfinder website available at [factfinder2.census.gov](http://factfinder2.census.gov).
    All census and geographic data included in the geodatabase is from the 2010 census.
    The data is contained within a feature dataset called **SanFrancisco**. The data
    in this feature dataset is in NAD 83 California State Plane Zone 3 and the linear
    unit of measure is the US Foot (this corresponds to SRID 2227 in the European
    Petroleum Survey Group, or EPSG, format).
  prefs: []
  type: TYPE_NORMAL
- en: The analysis we will create with the model, and eventually export to Python
    for further refinement, will use bus stops along a specific line in San Francisco.
    These bus stops will be buffered to create a representative region around each
    bus stop. The buffered areas will then be intersected with census blocks to find
    out how many people are within each representative region around the bus stops.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the Select and Buffer tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using ModelBuilder, we will first model the basis of the bus stop analysis.
    Once it has been modeled, it will be exported as an automatically generated Python
    script. Follow these steps to begin the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up **ArcCatalog** and create a folder connection to the folder containing
    `SanFrancisco.gdb`. Right-click on geodatabase and add a new toolbox called **Chapter3Tools**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open **ModelBuilder** and create a Model, saving it in the **Chapter3Tools**
    toolbox as **Chapter3Model1.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Bus_Stops** feature class and the **Select** tool from the **Analysis/Extract**
    toolset in **ArcToolbox**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Select** tool and name the output feature class `Inbound71`. Make
    sure that the feature class is written to the **Chapter3Results** feature dataset
    into the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Expression** SQL Query Builder and create the following SQL expression:
    **NAME = ''71 IB'' AND BUS_SIGNAG = ''Ferry Plaza''**.![Modeling the Select and
    Buffer tools](img/8662OS_03_01.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to add a **Buffer** tool from the **Analysis/Proximity** toolset.
    The **Buffer** tool will be used to create buffers around each bus stop. The buffered
    bus stops allow us to intersect with census data in the form of census blocks,
    creating the representative regions around each bus stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output of the **Select** tool (**Inbound71**) to the **Buffer**
    tool. Open up the **Buffer** tool and add 400 to the **Distance** field, and make
    the units **Feet**. Leave the rest of the options blank. Click on **OK** and return
    to the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Modeling the Select and Buffer tools](img/8662OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the Intersect tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have selected the bus line of interest, and buffered the stops
    to create representative regions, we will need to intersect the regions with the
    census blocks to find the population of each representative region:'
  prefs: []
  type: TYPE_NORMAL
- en: First, add the **CensusBlocks2010** feature class from the **SanFrancisco**
    feature dataset to the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the **Intersect** tool, located in the **Analysis/Overlay** toolset
    in **ArcToolbox**. While we could use **Spatial Join** to achieve a similar result,
    I am using the **Intersect** tool to capture the area of intersect for use later
    in the model and script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, our model should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Intersect tool](img/8662OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tallying the analysis results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we created this simple analysis, the next step is to determine the results
    for each bus stop. Finding the number of people that live in census blocks touched
    by the 400 feet buffer of each bus stop involves examining each row of data in
    the final feature class and selecting rows that correspond to the bus stop. Once
    these are selected, a sum of the selected rows would be calculated either using
    the **Field Calculator** or the **Summarize** tool. All of these methods will
    work, and yet none are perfect. They take too long, and worse, are not repeatable
    automatically if an assumption in the model is adjusted (if the buffer is adjusted
    from 400 feet to 500 feet, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: This is where the traditional uses of ModelBuilder begin to fail analysts. It
    should be easy to instruct the model to select all rows associated with each bus
    stop, and then generate a summed population figure for each bus stop's representative
    region. It would be even better to have the model create a spreadsheet to contain
    the final results of the analysis. It's time to use Python to take this analysis
    to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the model and adjusting the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While modeling analysis in ModelBuilder has its drawbacks, there is one fantastic
    option built into ModelBuilder; the ability to create a model and then export
    the model to Python. Along with the ArcGIS help documentation, it is the best
    way to discover the correct Python syntax to use when writing ArcPy scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder that can hold the exported scripts next to the **SanFrancisco**
    geodatabase (for example, `C:\Projects\Scripts`). This will hold both the exported
    scripts that ArcGIS automatically generates, and the versions that we will build
    from those generated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Open the model called **Chapter3Model1** and click on the **Model** menu in
    the upper left. Select **Export** from the menu, and then select **To Python Script**.
    Save the script in the script folder as `Chapter3Model1.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there is also the option to export the model as a graphic. Creating
    a graphic of the model is a good way to share what the model is doing with other
    analysts without the need to share the model and the data, and can also be useful
    when sharing Python scripts as well.
  prefs: []
  type: TYPE_NORMAL
- en: The automatically generated script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the automatically generated script in an IDE. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine this script line by line. The first line is preceded by a pound
    sign (#), which again means that this line is a comment; however, it is not ignored
    by the Python interpreter when the script is executed as usual but is used to
    help Python interpret the encoding of the script as described here: [http://legacy.python.org/dev/peps/pep-0263](http://legacy.python.org/dev/peps/pep-0263).'
  prefs: []
  type: TYPE_NORMAL
- en: The second commented line and the third line are included for decorative purposes.
    The next four lines, all commented, are used to provide readers with information
    about the script, what it is called and when it was created, along with a description
    that is pulled from the model's properties. Another decorative line is included
    to separate out the informative header from the body of the script visually. While
    the commented information section is nice to include in a script for other users
    of the script, it is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the script, or the executable portion of the script, starts with
    the `import arcpy` line. Import statements are, by convention, included at the
    top of the body of the script. In this instance, the only module that is being
    imported is ArcPy.
  prefs: []
  type: TYPE_NORMAL
- en: ModelBuilder's export function creates not only an executable script, but also
    comments each section to help mark the different sections of the script. The comments
    let the user know where the variables are located and where the ArcToolbox tools
    are being executed. The comments will grow to be superfluous as the reader grows
    to understand the code, but it was nice of ESRI to include the comments.
  prefs: []
  type: TYPE_NORMAL
- en: Below the import statements are the variables. In this case, the variables represent
    the file paths to the input and output feature classes. The variable names are
    derived from the names of the feature classes (the base names of the file paths).
    The file paths are assigned to the variables using the assignment operator (=),
    and the parts of the file paths are separated by two backslashes.
  prefs: []
  type: TYPE_NORMAL
- en: File paths in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be good to review how file paths are used in Python compared to how
    they are represented in Windows. In Python, file paths are strings, and strings
    in Python have special characters used to represent tabs (\t), newlines (\n),
    or carriage returns (\r), among many others. These special characters all incorporate
    single backslashes, making it very hard to create a file path that uses single
    backslashes. This would not be a big deal, except that file paths in Windows Explorer
    all use single backslashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of methods used to avoid this issue. Python was developed
    within the Linux environment, where file paths have forward slashes. This more
    Pythonic representation is also available when using Python in a Windows environment,
    demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Within a Python script, the file path with the forward slashes will work, while
    the Windows Explorer version might cause the script to throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method used to avoid the issue with special characters is the one employed
    by ModelBuilder when it automatically creates the Python scripts from a model.
    In this case, the backslashes are escaped using a second backslash. The preceding
    script uses this second method to produce the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The third method, which I prefer, is to create what is known as a raw string.
    This is the same as a regular string, but it includes an **r** before the script
    begins. This r alerts the Python Interpreter that the following script does not
    contain any special characters or escape characters. Here is an example of how
    it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using raw strings will make it easier to grab a file path from Windows Explorer
    and add it to a string inside a script. It will also make it easier to avoid accidentally
    forgetting to include a set of double backslashes in a file path, which happens
    all the time and is the cause of many script bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the script analysis: the ArcPy tools'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next, and most important, section of the script is where the analysis is
    executed. The same tools that we created in the model, the **Select**, the **Buffer**,
    and the **Intersect** tools, are included in this section. The same parameters
    that we supplied in the model are also included here: the inputs and outputs,
    plus the SQL statement in the Select tool, and the buffer distance in the **Buffer**
    tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool parameters are supplied to the tools in the script in the same order
    as they appear in the tool interfaces in the model. Here is the **Select** tool
    in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It works like this. The arcPy module has a method, or a special property, called
    `Select_analysis`. This method, when called, requires three parameters: the input
    feature class (or shapefile), the output feature class, and the SQL statement.
    In this example, the input is represented by the variable `Bus_Stops` and the
    output feature class is represented by the variable `Inbound71`, both of which
    are defined in the variable section. The SQL statement is included as the third
    parameter. Note that it could also be represented by a variable, if the variable
    was defined above this line; the SQL statement, as a string, could be assigned
    to a variable and the variable could replace the SQL statement as the third parameter.
    Here is an example of parameter replacement using a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While ModelBuilder is good about assigning input and output feature classes
    to variables, it does not assign variables to every portion of the parameter.
    This will be an important thing to correct when we adjust and build our own scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The **Buffer** tool accepts a similar set of parameters as the **Select** tool.
    There is an input feature class represented by a variable, an output feature class
    variable, and the distance that we provided (400 feet in this case), along with
    a series of parameters that are supplied by default. Note that the parameters
    rely on keywords, and these key words can be adjusted within the text of the script
    to adjust the resulting buffer output. For instance, Feet could be adjusted to
    Meters and the buffer would much larger. Check the help section of the tool to
    better understand how the other parameters will affect the buffer and to find
    the key words arguments that will be accepted by the **Buffer** tool in ArcPy.
    Also, as noted earlier, all of the parameters could be assigned to variables,
    which can save time if the same parameters are used repeatedly throughout a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes the supplied parameter is merely an empty string, as is the case
    here with the last parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The empty string, which in this case signifies that there is not a dissolve
    field for this buffer, is found quite frequently within ArcPy. It could also be
    represented by two single quotes, but ModelBuilder has been built to use double
    quotes to encase strings.
  prefs: []
  type: TYPE_NORMAL
- en: The Intersect tool and string manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last tool, the Intersect tool, uses a different method to represent the
    files that need to be intersected together when the tool is executed. Because
    the tool accepts multiple files in the input section (meaning there is no limit
    to the number of files that can be intersected together in one operation), it
    stores all of the file paths within one string. The string uses the hash or pound
    sign (#) to separate the file paths within the input string. This slight deviation
    must be dealt with if we are to use the Intersect tool in a Script tool. If we
    are building a tool from this script, we will not know the files that will be
    intersected before they are run, so we need to know the methods to deal with inserting
    variables into strings.
  prefs: []
  type: TYPE_NORMAL
- en: There are three methods to insert variables into strings. Each method has different
    advantages and disadvantages of a technical nature. It's good to know about all
    three of them as they have uses beyond our needs here, so let's review them.
  prefs: []
  type: TYPE_NORMAL
- en: The string manipulation method 1–string addition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'String addition is an odd concept at first as it would not seem possible to
    add strings together, unlike integers or floats, which are numbers. However, within
    Python and other programming languages, this is a normal step. Using the plus
    sign (+), strings are added together to make longer strings or allow variables
    to be added to the middle of existing strings. Here are some examples of this
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Two or more strings can be added together, and can even be assigned to a third
    variable. This process can be useful for situations such as the input string for
    the Intersect tool. The string can be broken up and variables representing the
    file paths can be inserted into the middle of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a powerful and useful way to insert the file paths into the input string.
    As long as the separators are still included in the string, the string will still
    be valid and the Intersect tool will run as expected. Here is what the string
    will look like when the string addition is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Another similar offshoot of string addition is string multiplication, where
    strings are multiplied by an integer to produce repeated versions of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The string manipulation method 2–string formatting #1'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second method of string manipulation, known as string formatting, involves
    adding placeholders into the string that will accept specific kinds of data. This
    means that these special strings can accept other strings as well as integers
    and float values. These placeholders use the modulo (%) and a key letter to indicate
    the type of data to expect. Strings are represented using **%s**, floats are represented
    using **%f**, and integers are represented using **%d**. The floats can also be
    adjusted to limit the digits included by adding a modifying number after the modulo.
    If there is more than one placeholder in a string, the values are passed to the
    string in a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method has become less popular since the third method discussed in the
    following section was introduced in Python 2.6, but it is still valuable to know
    as many older scripts use it. Here is an example of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example when using a float placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example using an integer placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For the **Intersect** tool, the %s symbol can be used to accept the file path
    string variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The string manipulation method 3–string formatting #2'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final method, the most recently introduced, is also known as string formatting.
    It is similar to the string formatting discussed earlier, with the added benefit
    of not requiring a specific type of placeholder. The placeholders, or tokens as
    they are also known, are only required to be in order to be accepted. The format
    function is built into strings; by adding `.format` to the string, and passing
    in parameters, the string accepts the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The tokens don't have to be in order within the string, and can even be repeated.
    The order is derived from the parameters supplied to the `.format` function that
    passes the values to the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the **Intersect** tool, the string formatting would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The third method has become my go-to method for string manipulation because
    of the ability to add the values repeatedly and make it possible to avoid supplying
    the wrong type of data to a specific placeholder, unlike the second method.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now is the time to take the automatically generated script and adjust it to
    fit our needs. We want the script to both produce the output data, and to have
    it analyze the data and tally the results into a spreadsheet. This spreadsheet
    will hold an averaged population value for each bus stop. The average will be
    derived from each census block that the buffered representative region surrounding
    the stops intersected. Save the original script as `Chapter3Model1Modified`.`py`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CSV module to the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this script, we will use the **CSV** module, a useful module to create Comma
    Separated Value spreadsheets. Its simple syntax will make it a useful tool to
    create script outputs. It should be noted that ArcGIS for Desktop also installs
    the **xlrd** and **xlwt** modules, used to read or generate Excel spreadsheets
    respectively, when it is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just below the import arcPy line, add `import csv`. This will allow us to use
    the csv module to create the spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next adjustment is made to the **Intersect** tool. Notice that the two
    paths included in the input string are also defined as variables in the variable
    section. Remove the file paths from the input strings and replace them with numbered
    placeholder tokens, and then add the format function and supply the variables
    as placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the data: Using a cursor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the script is in place to generate the raw data we need, we need a
    way to access the data held in the output feature class from the **Intersect**
    tool. This access will allow us to aggregate the rows of data representing each
    bus stop. We also need something to hold the aggregate data in the memory, to
    be written to the spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish the second part, we will use a Python dictionary. To accomplish
    the first part, we will use a method built into the ArcPy module: the Data Access
    Search Cursor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python dictionary will be added below the **Intersect** tool. A dictionary
    in Python is created using curly brackets. Add the following line to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: dataDictionary = {}
  prefs: []
  type: TYPE_NORMAL
- en: 'This script will use the Bus Stop IDs as keys for the dictionary. The values
    will be lists, which will hold all of the population values associated with each
    Bus Stop ID. Add the following lines to generate a Data Cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This iteration combines a few ideas in Python and ArcPy. The with … as statement
    is used to create a variable (cursor) that represents the `arcpy.da.SearchCursor`
    object. It could also be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of the with ... as structure is that the cursor object is erased
    from memory when the iteration is completed, which eliminates locks on the feature
    classes being evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: The `arcpy.da.SearchCursor()` function requires an input feature class, and
    a list of fields to be returned. Optionally, a SQL statement can limit the number
    of rows returned.
  prefs: []
  type: TYPE_NORMAL
- en: The next line, `for row in cursor`, is the iteration through the data. It is
    not a normal Pythonic iteration, a distinction that will have ramifications in
    certain instances. For instance, however, it does allow for row-by-row access
    to data contained within the supplied feature class. Note that when using a Search
    Cursor, each row of data is returned as a tuple, which cannot be modified. The
    data can be accessed using indexes, as shown in the preceding code, where the
    two members of the tuple are assigned to variables.
  prefs: []
  type: TYPE_NORMAL
- en: The if/else conditional allows the data to be sorted. As noted earlier, the
    Bus Stop IDs, which are the first member of the data included in the tuple, will
    be used as a key. The conditional evaluates whether the Bus Stop ID is included
    in the dictionary's existing keys (which are contained in a list and accessed
    using the `dictionary.keys()` method). If it is not, it is added to the keys,
    and assigned a value that is a list containing (at first) one piece of data, the
    population value contained in that row. If it does exist in the keys, the list
    is appended with the next population value associated with that Bus Stop ID. With
    this code, we have now sorted each census block population according to the Bus
    Stop with which it is associated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add code to create the spreadsheet. This code will use the
    same with ... as structure, and will generate an average population value by using
    two built-in Python functions, `sum`, which creates a sum from a list of numbers,
    and `len`, which will get the length of a list, tuple, or string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The average population value is retrieved from the dictionary using the Bus
    Stop ID key, and then assigned to the variable `averagePop`. The two data pieces,
    the `BusStopID` and the `averatePop` variable are then added to a list, which
    is supplied to a `CSVwriter` object, which knows how to accept the data and write
    it to a file located at the file path supplied to the built-in Python `the open()`
    function, used to create simple files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is complete, although it is nice to add one more line at the end
    to give us visual confirmation that the script has run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will create an output indicating that the script has run. Once it is done,
    go to the location of the output csv file and open it, using Excel or Notepad,
    and see the results of the analysis. Our first script is complete!
  prefs: []
  type: TYPE_NORMAL
- en: The final script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is how the script should look in the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to craft a model of an analysis and export it
    to a script. After discussing the script, we adjusted the script to include a
    results analysis and summation, which was outputted to a CSV file. In particular,
    we discussed how to use ModelBuilder to create an analysis and export it as a
    script, and how to adjust the script to be more Pythonic. We also briefly touched
    on the use of Search Cursors, which will be covered in greater detail in [Chapter
    5](ch05.html "Chapter 5. ArcPy Cursors – Search, Insert, and Update"), *ArcPy
    Cursors – Search, Insert, and Update.* Also, we saw how built-in modules such
    as the CSV module can be used along with ArcPy to capture analysis output in formatted
    spreadsheets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to create more complex scripts and
    build functions to avoid repeating code. These functions will make it possible
    to write code once and use it forever. This reuse of code will demonstrate how
    Python goes beyond automation of analysis to become a new productivity toolset.
  prefs: []
  type: TYPE_NORMAL
