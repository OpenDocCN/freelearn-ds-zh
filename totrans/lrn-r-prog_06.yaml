- en: Chapter 6. Working with Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned many built-in functions in several categories
    to work with basic objects. You learned how to access object classes, types, and
    dimensions; how to do logical, math, and basic statistical calculations; and how
    to perform simple analytic tasks such as root solving. These functions are the
    building blocks of our solution to specific problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'String-related functions are a very important category of functions. They will
    be introduced in this chapter. In R, texts are stored in character vectors, and
    a good number of functions and techniques are useful to manipulate and analyze
    texts. In this chapter, you will learn the basics and useful techniques of working
    with strings, including the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic manipulation of character vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between date/time objects and their string representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expressions to extract information from texts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Character vectors in R are used to store text data. You previously learned that
    in contrast with many other programming languages, a character vector is not a
    vector of single characters, letters, or alphabet symbols such as a, b, c. Rather,
    it is a vector of strings.
  prefs: []
  type: TYPE_NORMAL
- en: R also provides a variety of built-in functions to deal with character vectors.
    Many of them also perform vectorized operations so they can process numerous string
    values in one step.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn more about printing, combining, and transforming
    texts stored in character vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Printing texts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most basic thing we can do with texts is to view them. R provides
    several ways to view texts in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way is to directly type the string in quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Like a numeric vector of floating numbers, a character vector is a vector of
    character values, or strings. `Hello` is in the first position and is the only
    element of the character vector we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also print a string value stored in a variable by simply evaluating
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, simply writing a character value in a loop does not print it iteratively.
    It does not print anything at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s because R only automatically prints the *value* of an expression as
    it is being typed in the console. A for loop does not explicitly return a value.
    This behavior also explains the difference between the printing behaviors when
    the following two functions are called, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, `test1` does not print `Hello`, but it prints `World`
    because `test1("World")` returns the value of the last expression `x`, which is
    given as `World`, the value of the function call and R automatically prints this
    value. Let''s assume we remove `x` from the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, `test2` always returns `Hello`, no matter what value `x` takes. As a result,
    R automatically prints the value of expression `test2("World")`, that is, `Hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to explicitly print an object, we should use `print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the character vector is printed with a position `[1]`. This works in
    a loop too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It also works in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, we want the texts to appear as a message rather than a character
    vector with indices. In such cases, we can call `cat()` or `message()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can construct the message in a more flexible way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We change the input to print a more formal sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like the concatenated string appears to use unnecessary spaces between
    different arguments. It is because the space character is used by default as the
    separator between the input strings. We can change it by specifying the `sep=`
    argument. In the following example, we will avoid the default space separator
    and manually write spaces in the input strings to create a correct version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative function is `message()`, which is often used in serious situations
    such as an important event. The output text has a more conspicuous appearance.
    It is distinct from `cat()`, in that, it does not automatically use space separators
    to concatenate input strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using `message()`, we need to write the separators manually in order to show
    the same text as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference in the behavior between `cat()` and `message()` is that `message()`
    automatically ends the text with a new line while `cat()` does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two examples demonstrate the difference. We want to print the
    same contents but get different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is obvious that each time `cat()` is called, it prints the input string
    without a new line appended. The effect is that the three letters show in the
    same line. By contrast, each time `message()` is called, it appends a new line
    to the input string. As a result, the three letters show in three lines. To print
    each letter in a new line using `cat()`, we need to explicitly add a new line
    character in the input. The following code prints exactly the same contents as `message()`
    did in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Concatenating strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In practice, we often need to concatenate several strings to build a new one.
    The `paste()` function is used to concatenate several character vectors together.
    This function also uses space as the default separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t want the separator, we can set `sep=""` or alternatively call `paste0()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe you are confused by `paste()` and `cat()` because they both are capable
    of concatenating strings. But what''s the difference? Although both functions
    concatenate strings, the difference is that `cat()` only prints the string to
    the console, but `paste()` returns the string for further uses. The following
    code demonstrates that `cat()` prints the concatenated string but returns `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In other words, `cat()` only prints strings, but `paste()` creates a new character
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous examples show the behavior of `paste()` working with single-element
    character vectors. What about working with multi-element ones? Let''s see how
    this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `paste()` works element-wise, that is, `paste("A", "C")` first,
    then `paste("B", "D")`, and finally, the results are collected to build a character
    vector of two elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want the results to be put together in one string, we can specify how
    these two elements are again concatenated by setting `collapse=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to put them in two lines, we can set `collapse` to be `\n` (new
    line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The new character vector `result` is a two-lined string, but the text representation
    of it is still written in one line. The new line is represented by `\n` as we
    specified. To view the text we created, we need to call `cat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, the two-lined string is printed to the console in its intended format.
    The same thing also works with `paste0()`.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming texts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Turning texts into another form is useful in many cases. It is easy to perform
    a number of basic types of transformation on texts.
  prefs: []
  type: TYPE_NORMAL
- en: Changing cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we process data with texts, the input may not comply with our standard
    as supposed. For example, we expect all products to be graded in capital letters,
    from A to F, but the actual input may consist of these letters in both cases.
    Changing cases is useful to ensure that the input strings are consistent in cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tolower()` function changes the texts to lowercase letters, while `toupper()`
    does the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is particularly useful when a function accepts character input. For example,
    we can define a function that returns `x + y` when type is `add` in all possible
    cases. It returns `x * y` when type is `times` in all possible cases. The best
    way to do it is to always convert `type` to lowercase or uppercase, no matter
    what the input value is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This gives more tolerance to similar inputs only in different cases so that
    `type` is case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the two functions are vectorized, that is, it changes the cases
    of each string element of the given character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Counting characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another useful function is `nchar()`, which simply counts the number of characters
    of each element of a character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `toupper()` and `tolower()`, `nchar()` is also vectorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is often used to check whether an argument is supplied a valid
    string. For example, the following function takes some personal information of
    a student and stores it in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Before storing the information in the database, the function uses `stopifnot()`
    to check whether `name` and `age` are provided valid values. If the user does
    not provide a meaningful name (for example, no less than two letters), the function
    would stop with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that `nchar(x) == 0` is equivalent to `x == ""`. To check against an empty
    string, both methods work.
  prefs: []
  type: TYPE_NORMAL
- en: Trimming leading and trailing whitespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, we used `nchar()` to check whether `name` is valid.
    However, sometimes, the input data comes with useless whitespaces. This adds more
    noise to the data and requires a careful checking of string arguments. For example, `store_student()`
    in the previous section makes pass of a name such as `" P"`, which is as invalid
    as a straight `"P"` argument, but `nchar(" P")` returns `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To take the possibility into account, we need to refine `store_student`. In
    R 3.2.0, `trimws()` is introduced to trim leading and/or trailing whitespaces
    of given strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the function is more robust to noisy data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The function, by default, trims both the leading and trailing whitespaces,
    which can be spaces and tabs. You can specify whether "left" or "right" to only
    trim one side of the strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Substring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In previous chapters, you learned how to subset vectors and lists. We can also
    subset the texts in a character vector by calling `substr()`. Suppose we have
    several dates in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'All the months are represented by three-letter abbreviations. We can use `substr()`
    to extract the months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the day, we need to use `substr()` and `nchar()` together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can extract both months and days in the input strings, it is useful
    to write a function to transform the strings in such format to numeric values
    to represent the same date. The following function uses many functions and ideas
    you learned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `substr()` function also has a counterpart function to replace the substrings
    with a given character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Splitting texts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many cases, the lengths of string parts to extract are not fixed. For example,
    person names such as "Mary Johnson" or "Jack Smiths" have no fixed lengths for
    the first names and last names. It is more difficult to use `substr()`, as you
    learned in the previous section, to separate and extract both parts. Texts in
    such format have a regular separator such as space or a comma. To extract the
    useful parts, we need to split the texts and make each part accessible. The `strsplit()`
    function is used to split texts by specific separators given as a character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returns a list. Each element in the list is a character vector
    produced from splitting that element in the original character vector. It is because
    `strsplit()`, like all previous string functions we have introduced, is also vectorized,
    that is, it returns a list of character vectors as a result of the splitting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strsplit()` function returns a list of character vectors containing split
    parts by working element-wise. In practice, splitting is only the first step to
    extract or reorganize data. To continue, we can use `rbind` to put the data into
    a matrix and give appropriate names to the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will convert the matrix to a data frame so that we can transform each
    column to more proper types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, raw string input students are transformed into a more organized and more
    useful data frame `students_df`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One small trick to split the whole string into single characters is to use
    an empty `split` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `strsplit()` is more powerful than is shown. It also supports *regular
    expressions*, a very powerful framework to process text data. We will cover this
    topic in the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting texts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concatenating texts with `paste()` is sometimes not a good idea because the
    text has to be broken into pieces and it becomes harder to read as the format
    gets longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s assume we need to print each record in `students_df` in
    the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, using `paste()` will be a pain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The code looks messy, and it is hard to get the general template at first glance.
    By contrast, `sprintf()` supports a formatting template and solves the problem
    in a nice way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `#%d, name: %s, age: %d, major: %s` is the formatting
    template in which `%d` and `%s` are placeholders to represent the input arguments
    to appear in the string. The `sprintf()` function is especially easy to use because
    it prevents the template string from tearing apart, and each part to replace is
    specified as a function argument. In fact, this function uses C style formatting
    rules as described in detail at [https://en.wikipedia.org/wiki/Printf_format_string](https://en.wikipedia.org/wiki/Printf_format_string).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, `%s` stands for string and `%d` for digits (integers).
    Moreover, `sprintf()` is also very flexible in formatting numeric values using `%f`.
    For example, `%.1f` means to round the number to 0.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, there is a formatting syntax of different types of values. The following
    table shows the most commonly used syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%s", "A")` | `A` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%d", 10)` | `10` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%04d", 10)` | `0010` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%f", pi)` | `3.141593` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%.2f", pi)` | `3.14` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%1.0f", pi)` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%8.2f", pi)` | `3.14` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%08.2f", pi)` | `00003.14` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%+f", pi)` | `+3.141593` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%e", pi)` | `3.141593e+00` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf("%E", pi)` | `3.141593E+00` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The official documentation ([https://stat.ethz.ch/R-manual/R-devel/library/base/html/sprintf.html](https://stat.ethz.ch/R-manual/R-devel/library/base/html/sprintf.html))
    gives a full description of the supported formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `%` in the format text is a special character and will be interpreted
    as the initial character of a place holder. What if we really mean `%` in the
    string? To avoid formatting interpretation, we need to use `%%` to represent a
    literal `%`. The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using Python string functions in R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sprintf()` function is powerful but not perfect for all use cases. For
    example, if some parts have to appear multiple times in the template, you will
    need to write the same arguments multiple times. This often makes the code more
    redundant and a bit hard to modify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other ways to represent the placeholders. The `pystr` package provides
    the `pystr_format()` function to format strings in Python formatting style using
    either numeric or named placeholders. The preceding example can be rewritten with
    this function in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One is using numeric placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The other is using named placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, no argument has to repeat, and the position the input appears
    at can be easily moved to other places in the template string.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting date/time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In data analysis, it is common to encounter date and time data types. Perhaps,
    the simplest functions related with date are `Sys.Date()`, which returns the current
    date, and `Sys.time()`, which returns the current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the book is being rendered, the date is printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And the time is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, the date and time look like character vectors, but actually
    they are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: They are, in essence, numeric values relative to an origin and have special
    methods to do date/time calculations. For a date, its numeric value means the
    number of days passed after 1970-01-01\. For a time, its numeric value means the
    number of seconds passed after 1970-01-01 00:00.00 UTC.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing text as date/time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a date relative to a customized origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in more cases, we create date and time from a standard text representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we can represent time in string such as 2016-02-10, then why do we need
    to create a `Date` object like we did earlier? It is because a date has more features:
    we can do date math with them. Suppose we have a date object, we can add or minus
    a number of days and get a new date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can directly subtract a date from another to get the difference in number
    of days between two dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `date2 - date1` looks like a message, but it is actually a numeric
    value. We can make it explicit using `as.numeric()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Time is similar, but there is no function called `as.Time()`. To create a date
    time from a text representation, we can use either `as.POSIXct()` or `as.POSIXlt()`.
    These two functions are different implementations of a date/time object under
    the POSIX standard. In the following example, we use `as.POSIXlt` to create a
    date/time object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of object also defines `+` and `-` for simple time calculations.
    Unlike the date object, it works at the unit of seconds rather than days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Given a string representation of date or time in data, we have to convert it
    to date or date/time objects, which enable us to do calculations. Often, however,
    what we get in raw data is not always the format that can be directly recognized
    by `as.Date()` or `as.POSIXlt()`. In this case, we need to use a set of special
    letters as placeholders to represent certain parts of a date or time, just like
    we did with `sprintf()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for the input `2015.07.25`, `as.Date()` will produce an error
    if no format string is supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a format string as a template to tell `as.Date()` how to parse the
    string to a date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for a non-standard date/time string, we also need to specify a template
    string to tell `as.POSIXlt()` how to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative (and more direct) function to convert a string to a date/time
    is `strptime()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In fact, `as.POSIXlt()` is only a wrapper of `strptime()` for character input,
    but `strptime()` always requires that you supply the format string, while `as.POSIXlt()`
    works for standard formats without a supplied template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like numeric vectors, date and date/time are vectors too. You can supply
    a character vector to `as.Date()` and get a vector of dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The math is also vectorized. In the following code, we will add some consecutive
    integers to the date, and we get consecutive dates as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The same feature also applies to date/time objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, the data uses integer representations of date and time. It makes
    parsing the date and time trickier. For example, to parse `20150610`, we will
    run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse `20150610093215`, we can specify the template to describe such a format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'A trickier example is to parse the date/time in the following data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use `paste0()`on the columns of `datetimes` and directly call `strptime()`
    with the template used in the previous example, we will get a missing value that
    indicates that the first element is not consistent with the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem lies in `92325`, which should be `092325`. We need to use `sprintf()`
    to make sure a leading zero is present when necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the conversion works as supposed.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting date/time to strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how to convert strings to date and date/time
    objects. In this section, you will learn the opposite: converting date and date/time
    objects back to strings according to a specific template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a date object is created, every time we print it, it is always represented
    in the standard format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert the date to a string in a standard representation with `as.character()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, `my_date` looks the same, but the string is now merely a plain
    text and no longer supports date calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we need to format the date in a non-standard way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, `as.character()` calls `format()` directly behind the scenes. We will
    get exactly the same result using `format()`, and this is recommended in most
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing also applies to a date/time object. We can further customize
    the template to include more texts other than the placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The format placeholders are much more than we mentioned. Read the documentation
    by typing in `?strptime` for detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of packages to make dealing with date and time much easier.
    I recommend the `lubridate` package ([https://cran.r-project.org/web/packages/lubridate](https://cran.r-project.org/web/packages/lubridate))
    because it provides almost all the functions you need to work with date and time
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, you learned a number of basic functions to deal with
    strings and date/time objects. These functions are useful but much less flexible
    than regular expressions. You will learn this very powerful technique in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For research, you may need to download data from open-access websites or authentication-required
    databases. These data sources provide data in various formats, and most of the
    data supplied are very likely well-organized. For example, many economic and financial
    databases provide data in the CSV format, which is a widely supported text format
    to represent tabular data. A typical CSV format looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In R, it is convenient to call `read.csv()` to import a CSV file as a data frame
    with the right header and data types because the format is a natural representation
    of a data frame.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all data files are well organized, and dealing with poorly organized
    data is painstaking. Built-in functions such as `read.table()` and `read.csv()`
    work in many situations, but they may not help at all for such format-less data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you need to analyze raw data (`messages.txt`) organized in
    a CSV-like format as shown here, you had better be careful when you call `read.csv()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want to import this file as a data frame in the following format
    which is nicely organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you blindly call `read.csv()`, then you will see that it does not
    work out correctly. This dataset is somehow special in the message column. There
    are extra commas that will be mistakenly interpreted as separators in a CSV file.
    Here is the data frame translated from the raw text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'There are various methods to tackle this problem. You may consider using `strsplit()`
    for each line and manually take out the first several elements and paste others
    for each line split into multiple parts. But one of the simplest and most robust
    ways is to use the so-called Regular Expression ([https://en.wikipedia.org/wiki/Regular_expression](https://en.wikipedia.org/wiki/Regular_expression)).
    Don''t worry if you feel strange about the terminology. Its usage is very simple:
    describe the pattern that matches the text and extract the desired part from that
    text.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we apply the technique, we need some basic knowledge. The best way to
    motivate yourself is look at a simpler problem and consider what is needed to
    solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are dealing with the following text (`fruits.txt`) that describes
    the number or status of some fruits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now, we want to pick out all fruits with a number rather than with status information.
    Although we can easily finish the task visually, it is not that easy for a computer.
    If the number of lines exceeds two thousand, it can be easy for a computer with
    the appropriate technique applied and, by contrast, be hard, time-consuming, and
    error prone for a human.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that should come to our mind is that we need to distinguish
    fruits with numbers and fruits with no numbers. In general, we need to distinguish
    texts that match a particular pattern from the ones that do not. Here, regular
    expression is definitely the right technique to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions solve problems using two steps: the first is to find a
    pattern to match the text and the second is to group the patterns to extract the
    information in need.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding a string pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve the problem, our computer does not have to understand what fruits actually
    are. We only need to find out a pattern that describes what we want. Literally,
    we want to get all lines that start with a word followed by a semicolon and a
    space, and end with an integer rather than words or other symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expression provides a set of symbols to represent patterns. The preceding
    pattern can be described with `^\w+:\s\d+$` where meta-symbols are used to represent
    a class of symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: This symbol is used at the beginning of the line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w`: This symbol represents a word character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s`: This symbol is a space character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d`: This symbol is a digit character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: This symbol is used at the end of the line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, `\w+` means one or more word characters, `:` is exactly the symbol
    we expect to see after the word, and `\d+` means one or more digit characters.
    See, this pattern is so magical that it represents all the cases we want and excludes
    all the cases we don't want.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, this pattern matches lines such as `abc: 123` but excludes
    lines otherwise. To pick out the desired cases in R, we use `grep()` to get which
    strings match the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `\` in R should be written as `\\` to avoid escaping. Then, we can
    filter `fruits` by `matches`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now, we successfully distinguish desirable lines from undesirable ones. The
    lines that match the pattern are chosen, and those that do not match the pattern
    are omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we specify a pattern that starts with `^` and ends with `$` because
    we don''t want a partial matching. In fact, regular expressions perform partial
    matching by default, that is, if any part of the string matches the pattern, the
    whole string is considered to match the pattern. For example, the following code
    attempts to find out which strings match the two patterns respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The first pattern matches strings that include any digit (partial matching),
    while the second pattern with `^` and `$` matches strings that have only one digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the pattern works correctly, we go to the next step: using groups to extract
    the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Using groups to extract the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the pattern string, we can make marks to identify the parts we want to extract
    from the texts using parenthesis. In this problem, we can modify the pattern to
    `(\w+):\s(\d+)`, where two groups are marked: one is the fruit name matched by `\w+`
    and the other is the number of the fruit matched by `\d+`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use this modified version of the pattern to extract the information
    we want. Although it is perfectly possible to use built-in functions in R to do
    the job, I strongly recommend using functions in the `stringr` package. This package
    makes it substantially easier to use regular expressions. We call `str_match()`
    with the modified pattern with groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This time the matches are a matrix with more than one column. The groups in
    parenthesis are extracted from the text and are put to columns 2 and 3\. Now,
    we can easily transform this character matrix to a data frame with the right header
    and data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `fruits_df` is a data frame with the right header and data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: If you are not sure about the intermediate results in the preceding code, you
    can run the code line by line and see what happens in each step. Finally, this
    problem is perfectly solved with regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous example, we see that the magic of regular expressions is
    but a group of identifiers used to represent different kinds of characters and
    symbols. In addition to the meta-symbols we have mentioned, the following are
    also useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[0-9]`: This symbol represents a single integer from 0 to 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[a-z]`: This symbol represents a single lower capital letter from a to z'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[A-Z]`: This symbol represents a single upper capital letter from A to Z'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.`: This symbol represents any single symbol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: This symbol represents a pattern, which may appear zero, one, or more
    times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: This is a pattern, which appears one or more than one time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{n}`: This is a pattern that appears `n` times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{m,n}`: This is a pattern that appears at least `m` times and at most `n`
    times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these meta-symbols, we can easily check or filter string data. For example,
    suppose we have some telephone numbers from two countries that are mixed together.
    If the pattern of telephone numbers in one country is different from that of the
    other, regular expressions can be helpful to split them into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is an exception in the data. The number has no `-` in the middle.
    For unexceptional cases, it should be easy to figure out the pattern of the two
    types of telephone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out the exceptional cases, `grepl()` is more useful because it returns
    a logical vector to indicate whether each element matches the pattern. Therefore,
    we can use this function to choose all records that do not match the given patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code basically says that all records that do not match the two
    patterns are considered exceptional. Imagine we have millions of records to check.
    Exceptional cases may be in any format, so it is more robust to use this method:
    excluding all valid records to find out invalid records.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading data in customizable ways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the problem we faced at the very beginning of this section.
    The procedure is exactly the same with the fruits example: finding the pattern
    and making groups.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at a typical line of the raw data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: It is obvious that all lines are based on the same format, that is, date, time,
    sender, receiver, and message are separated by commas. The only special thing
    is that commas may appear in the message, but we don't want our code to interpret
    it as separators.
  prefs: []
  type: TYPE_NORMAL
- en: Note that regular expressions perfectly works with this purpose as it did in
    the previous example. To represent one or more symbols that follow the same pattern,
    just place a plus sign (`+`) after the symbolic identifier. For example, `\d+`
    represents a string consisting of one or more digital characters between "0" and
    "9". For example,"1","23", and"456" all match this pattern, while"word" does not.
    There are also situations where a pattern may or may not appear at all. Then,
    we need to place a `*` after the symbolic identifier to mark that this particular
    pattern may appear once or more, or may not appear, in order to match a wide range
    of texts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to our problem. We need to recognize a sufficiently general
    pattern of a typical line. The following is the pattern with grouping we should
    figure out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to import the raw texts in exactly the same way as we did in the
    fruits example using `readLines()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to work out the pattern that represents the text and the information
    we want to extract from the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The pattern here looks like some secret code. Don't worry. That's exactly how
    regular expression works, and it should make some sense now if you go through
    the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular expression works perfectly. The `messages_df` file looks like the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The pattern we use is comparable to a key. The hard part of any regular expression
    application is to find the key. Once we get it, we are able to open the door and
    extract as much information as we want from the messy texts. Generally speaking,
    how difficult it is to find that key largely relies on the difference between
    the positive cases and negative cases. If the difference is quite obvious, a few
    symbols will solve the problem. If the difference is subtle and many special cases
    are involved, just like most real-world problems, you need more experience, harder
    thinking, and many trials and errors to work out the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Through the motivating examples mentioned earlier, you should now grasp the
    idea of regular expressions. You don't have to understand how it works internally,
    but it is very useful to become familiar with the related functions, whether they
    are built in or provided by certain packages.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more, RegexOne ([http://regexone.com/](http://regexone.com/))
    is a very good place to learn the basics in an interactive manner. To learn more
    specific examples and the full set of identifiers, this website ([http://www.regular-expressions.info/](http://www.regular-expressions.info/))
    is a good reference. To find out good patterns to solve your problem, you can
    visit RegExr ([http://www.regexr.com/](http://www.regexr.com/)) to test your patterns
    interactively online.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about a number of built-in functions for manipulating
    character vectors and converting between date/time objects and their string representations.
    You also learned about the basic idea of regular expressions, a very powerful
    tool to check and filter string data and extract information from raw texts.
  prefs: []
  type: TYPE_NORMAL
- en: With the vocabulary we built in this and previous chapters, we are now able
    to work with basic data structures. In the next chapter, you will learn about
    some tools and techniques to work with data. We will get started with reading
    and writing simple data files, producing graphics of various types, applying basic
    statistical analysis and data-mining models on simple datasets, and using numeric
    methods to solve root-solving and optimization problems.
  prefs: []
  type: TYPE_NORMAL
