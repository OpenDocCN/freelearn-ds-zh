<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Inside R"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Inside R</h1></div></div></div><p>In the previous chapters, you learned the basics of R programming language, and understood the usage of vectors, matrices, lists, and data frames to represent data in different shapes. You also saw how we can use the built-in functions to solve simple problems. However, simply knowing these features does not help you solve every problem. Real-world data analysis usually involves careful and detailed transformation and aggregation of data, which can be done with a good variety of functions, whether they are built-in or provided by extension packages.</p><p>To best use these functions rather than let them confuse you with unexpected results, you need a basic but concrete understanding of how R functions work. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Lazy evaluation</li><li class="listitem" style="list-style-type: disc">Copy-on-modify mechanism</li><li class="listitem" style="list-style-type: disc">Lexical scoping</li><li class="listitem" style="list-style-type: disc">Environments</li></ul></div><p>If you understand these concepts and their roles in the code, most R code should appear highly predictable to you, which means higher productivity in both finding bugs and writing properly functional code.</p><div class="section" title="Understanding lazy evaluation"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Understanding lazy evaluation</h1></div></div></div><p>A big part of understanding how R works can be done by figuring out how R functions work. After going through the previous chapters, you should know the most commonly used basic functions. However, you may still be confused about their exact behavior. Suppose we create the following function:</p><pre class="programlisting">test0 &lt;- function(x, y) {&#13;
  if (x &gt; 0) x else y&#13;
} &#13;
</pre><p>The function is somewhat special because <code class="literal">y</code> seems to be needed only when <code class="literal">x</code> is greater than zero. What if we only supply a positive number to <code class="literal">x</code> and ignore <code class="literal">y</code>? Will the function fail because we don't supply every argument in its definition? Let's find out by calling the following function:</p><pre class="programlisting">test0(1)&#13;
## [1] 1 &#13;
</pre><p>The function works without <code class="literal">y</code> being supplied. It looks like we are not required to supply the values to all arguments when we call a function but only to those that are needed. If we call <code class="literal">test0</code> with a negative number, <code class="literal">y</code> is needed:</p><pre class="programlisting">test0(-1)&#13;
## Error in test0(-1): argument "y" is missing, with no default &#13;
</pre><p>Since we did not specify the value of <code class="literal">y</code>, the function stopped, reporting that <code class="literal">y</code> is missing.</p><p>From the preceding examples, you learn that a function does not require all arguments to be specified if they are not needed to return a value. What if we insist on specifying those arguments that are not used in the function? Will they be evaluated before we call the function or not evaluated at all? Let's find out by putting a <code class="literal">stop()</code> function in the position of argument <code class="literal">y</code>. If the expression is evaluated by any means somewhere, it should stop immediately before <code class="literal">x</code> is returned:</p><pre class="programlisting">test0(1, stop("Stop now"))&#13;
## [1] 1 &#13;
</pre><p>The output indicates that <code class="literal">stop()</code> does not happen, which indicates that it is not evaluated at all. If we change the value of <code class="literal">x</code> to a negative number, the function should stop instead:</p><pre class="programlisting">test0(-1, stop("Stop now"))&#13;
## Error in test0(-1, stop("Stop now")): Stop now &#13;
</pre><p>Now, it is very clear that <code class="literal">stop()</code> is evaluated in this case. The mechanism becomes quite transparent. In a function call, the expression of an argument is evaluated only when the value of the argument is needed. This mechanism is called <span class="strong"><strong>lazy evaluation</strong></span>, and therefore, we can also say that the arguments of a function call are lazily evaluated, that is, evaluated only when needed.</p><p>If you are not aware of the lazy evaluation mechanism, you may think that the following function call must be extremely time consuming and may exhaust all your computer memory. However, lazy evaluation prevents it from happening because <code class="literal">rnorm(1000000)</code> is never evaluated. This is because it is never needed when evaluating <code class="literal">if (x &gt; 0) x else y</code>, which can be verified by timing the function calls in turn using <code class="literal">system.time()</code>:</p><pre class="programlisting">system.time(rnorm(10000000))&#13;
## user system elapsed&#13;
## 0.91  0.01   0.92 &#13;
</pre><p>Generating 10 million random numbers is not an easy job. It takes more than a second. By contrast, evaluating a number should be the easiest thing R can do, and it is so fast that the timer itself can't tell:</p><pre class="programlisting">system.time(1)&#13;
## user system elapsed&#13;
##  0     0      0 &#13;
</pre><p>If we time the following expression, given the logic of <code class="literal">test0</code> and the knowledge of lazy evaluation, at an educated guess it should be zero:</p><pre class="programlisting">system.time(test0(1, rnorm(10000000)))&#13;
## user system elapsed&#13;
##  0     0      0 &#13;
</pre><p>Another lazy evaluation scenario that could happen is the default values of arguments. More precisely, the default values of function arguments should really be default expressions because the value is not available until the expression is actually evaluated. Consider the following function:</p><pre class="programlisting">test1 &lt;- function(x, y = stop("Stop now")) {&#13;
  if (x &gt; 0) x else y&#13;
} &#13;
</pre><p>We give <code class="literal">y</code> a default value that calls <code class="literal">stop()</code>. If lazy evaluation does not apply here, that is, if <code class="literal">y</code> is evaluated irrespective of whether it is needed, we should receive an error as long as we call <code class="literal">test1()</code> without supplying <code class="literal">y</code>. However, if lazy evaluation applies, calling <code class="literal">test1()</code> with a positive <code class="literal">x</code> argument should not cause an error since the <code class="literal">stop()</code> expression of <code class="literal">y</code> is never evaluated.</p><p>Let's do an experiment to find out which is true. First, we will call <code class="literal">test1()</code> with a positive <code class="literal">x argument</code>:</p><pre class="programlisting">test1(1)&#13;
## [1] 1 &#13;
</pre><p>The output implies that lazy evaluation also works here. The function only uses <code class="literal">x</code>, and the default expression of <code class="literal">y</code> is not evaluated at all. If we supply a negative <code class="literal">x</code> argument instead, the function should stop as supposed:</p><pre class="programlisting">test1(-1)&#13;
## Error in test1(-1): Stop now &#13;
</pre><p>The preceding examples demonstrate an advantage of lazy evaluation: it makes it possible to save time and avoid unnecessary evaluation of expressions. Besides, it also allows more flexible specification of default values of function arguments. For example, you can use other arguments in the expression of a function argument:</p><pre class="programlisting">test2 &lt;- function(x, n = floor(length(x) / 2)) {&#13;
  x[1:n]&#13;
} &#13;
</pre><p>This allows you to set up the default behavior of a function in a more reasonable or desirable way, while the function arguments are still as customizable as they were without those default values.</p><p>If we call <code class="literal">test2</code> without specifying <code class="literal">n</code>, the default behavior takes out the first half elements of <code class="literal">x</code>:</p><pre class="programlisting">test2(1:10)&#13;
## [1] 1 2 3 4 5 &#13;
</pre><p>The function remains flexible because you can always override its default behavior by specifying another value of <code class="literal">n</code>:</p><pre class="programlisting">test2(1:10, 3)&#13;
## [1] 1 2 3 &#13;
</pre><p>Like all other features, lazy evaluation also has its pros and cons. Since the arguments of a function are only parsed but not evaluated when the function is called, we can only make sure that the expressions supplied to the arguments are syntactically correct. It is hard to ensure that the arguments are going to work.</p><p>For example, if an undefined variable appears in the default value of an argument, there will be no warning or error the moment we create the function. In the following example, we create a <code class="literal">test3</code> function, which is exactly the same as <code class="literal">test2</code>, except that <code class="literal">x</code> in <code class="literal">n</code> is mistakenly written as an undefined variable <code class="literal">m</code>.</p><pre class="programlisting">test3 &lt;- function(x, n = floor(length(m) / 2)) {&#13;
  x[1:n]&#13;
} &#13;
</pre><p>When we create <code class="literal">test3</code>, there's no warning or error because <code class="literal">floor(length(m) / 2)</code> is never evaluated before <code class="literal">test3</code> is called, and the value of <code class="literal">n</code> is demanded by <code class="literal">1:n</code>. The function will stop only when we actually call it:</p><pre class="programlisting">test3(1:10)&#13;
## Error in test3(1:10): object 'm' not found &#13;
</pre><p>If we have <code class="literal">m</code> defined before <code class="literal">test3</code> is called, the function works, but in an unexpected way:</p><pre class="programlisting">m &lt;- c(1, 2, 3)&#13;
test3(1:10)&#13;
## [1] 1 &#13;
</pre><p>Another example that makes how lazy evaluation works more explicit is as follows:</p><pre class="programlisting">test4 &lt;- function(x, y = p) {&#13;
  p &lt;- x + 1&#13;
  c(x, y)&#13;
} &#13;
</pre><p>Note that the default value of <code class="literal">y</code> is <code class="literal">p</code>, which is not defined before the function is called, just like the previous example. A notable difference between these two examples is when the missing symbol in the default value of the second argument is supplied. In the previous example, <code class="literal">p</code> is defined before the function is called. However, in this example, <code class="literal">p</code> is defined inside the function before <code class="literal">y</code> is used.</p><p>Let's see what happens when we call the function:</p><pre class="programlisting">test4(1)&#13;
## [1] 1 2 &#13;
</pre><p>It looks like the function works rather than ending up in an error. It will become easier to understand if we go through the detailed process of how <code class="literal">test4(1)</code> is executed:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find a function named <code class="literal">test4</code>.</li><li class="listitem">Match the given arguments, but both <code class="literal">x</code> and <code class="literal">y</code> are unevaluated.</li><li class="listitem"><code class="literal">p &lt;- x + 1</code> evaluates <code class="literal">x + 1</code> and assigns the value to a new variable <code class="literal">p</code>.</li><li class="listitem"><code class="literal">c(x, y)</code> evaluates both <code class="literal">x</code> and <code class="literal">y</code>, where <code class="literal">x</code> takes <code class="literal">1</code> and <code class="literal">y</code> takes <code class="literal">p</code>, which just happens to get the value of <code class="literal">x + 1</code>, which is <code class="literal">2</code>.</li><li class="listitem">The function returns a numeric vector <code class="literal">c(1, 2)</code>.</li></ol></div><p>Therefore, in the whole evaluation process of <code class="literal">test4(1)</code>, no warning or error occurs because no rules are violated. The most important trick here is that <code class="literal">p</code> is just defined before <code class="literal">y</code> is used.</p><p>The preceding example helps exaplain how lazy evaluation works, but it is indeed a bad practice. I won't recommend writing a function in this way because such a trick only makes the behavior of the function less transparent. A good practice is to simplify the arguments and avoid using undefined symbols outside the function. Otherwise, it can be hard to predict its behavior or debug the function due to its dependency on the outer environment.</p><p>Despite this, there is some wise use of lazy evaluation too. For example, <code class="literal">stop()</code> can be used along with <code class="literal">switch()</code> in the last argument to make the function stop when no cases are matched. The following function <code class="literal">check_input()</code> uses <code class="literal">switch()</code> to regulate the input of <code class="literal">x</code> so that it only accepts <code class="literal">y</code> or <code class="literal">n</code> and stops when other strings are supplied:</p><pre class="programlisting">check_input &lt;- function(x) {&#13;
  switch(x,&#13;
    y = message("yes"),&#13;
    n = message("no"),&#13;
    stop("Invalid input"))&#13;
} &#13;
</pre><p>When <code class="literal">x</code> takes <code class="literal">y</code>, a message saying <code class="literal">yes</code> shows:</p><pre class="programlisting">check_input("y")&#13;
## yes &#13;
</pre><p>When <code class="literal">x</code> takes <code class="literal">n</code>, a message saying <code class="literal">no</code> shows:</p><pre class="programlisting">check_input("n")&#13;
## no &#13;
</pre><p>Otherwise, the function stops:</p><pre class="programlisting">check_input("what")&#13;
## Error in check_input("what"): Invalid input &#13;
</pre><p>The example works because <code class="literal">stop()</code> is lazily evaluated as an argument of <code class="literal">switch()</code>.</p><p>As a summary of the examples, the reminder here is that you cannot rely too much on the parser to check the code. It only checks the code in its syntax, and it does not tell you whether the code is written with good practice. To avoid the potential pitfalls caused by lazy evaluation, do necessary checking in the function to make sure that the input can be handled correctly.</p></div></div>
<div class="section" title="Understanding the copy-on-modify mechanism"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Understanding the copy-on-modify mechanism</h1></div></div></div><p>In the previous section, we showed how lazy evaluation works and how it may help save computing time and working memory by avoiding unnecessary evaluation of function arguments. In this section, I will show you an important feature of R that makes it safer to work with data. Suppose we create a simple numeric vector <code class="literal">x1</code>:</p><pre class="programlisting">x1 &lt;- c(1, 2, 3) &#13;
</pre><p>Then, we assign the value of <code class="literal">x1</code> to <code class="literal">x2</code>:</p><pre class="programlisting">x2 &lt;- x1 &#13;
</pre><p>Now, <code class="literal">x1</code> and <code class="literal">x2</code> have exactly the same value. What if we modify an element in one of the two vectors? Will both vectors change?</p><pre class="programlisting">x1[1] &lt;- 0&#13;
x1&#13;
## [1] 0 2 3&#13;
x2&#13;
## [1] 1 2 3 &#13;
</pre><p>The output shows that when <code class="literal">x1</code> is changed, <code class="literal">x2</code> will remain unchanged. You may guess that the assignment automatically copies the value and makes the new variable point to the copy of the data instead of the original data. Let's use <code class="literal">tracemem()</code> to track the footprint of the data in memory.</p><p>Let's reset the vectors and conduct an experiment by tracing the memory addresses of <code class="literal">x1</code> and <code class="literal">x2</code>:</p><pre class="programlisting">x1 &lt;- c(1, 2, 3)&#13;
x2 &lt;- x1 &#13;
</pre><p>As we call <code class="literal">tracemem()</code> on the two vectors, it shows the current memory address of the data. If the memory address being traced changes, a text will show up with the original address and the new address, indicating that the data is copied:</p><pre class="programlisting">tracemem(x1)&#13;
## [1] "&lt;0000000013597028&gt;"&#13;
tracemem(x2)&#13;
## [1] "&lt;0000000013597028&gt;" &#13;
</pre><p>Now, both vectors have the same value, and <code class="literal">x1</code> and <code class="literal">x2</code> share the same address, which implies that they point to exactly the same piece of data in memory and that the assignment operation does not copy the data automatically. But when is the data copied?</p><p>Now, we will modify the first element of <code class="literal">x1</code> to <code class="literal">0</code>:</p><pre class="programlisting">x1[1] &lt;- 0&#13;
## tracemem[0x0000000013597028 -&gt; 0x00000000170c7968] &#13;
</pre><p>The memory tracing says that the address of <code class="literal">x1</code> has changed to a new one. More specifically, the piece of memory, that is, the original vector both <code class="literal">x1</code> and <code class="literal">x2</code> point to is copied to a new location. Now we have two copies of the same data in two different locations. Then, the first element of the copy is modified, and finally, <code class="literal">x1</code> is made to point to the modified copy.</p><p>Now, <code class="literal">x1</code> and <code class="literal">x2</code> have different values: <code class="literal">x1</code> points to the modified vector and <code class="literal">x2</code> remains pointing to the original vector.</p><p>In other words, if multiple variables refer to the same object, modifying one variable will make a copy of the object. This mechanism is called <span class="strong"><strong>copy-on-modify</strong></span>.</p><p>Another scenario where copy-on-modify happens is when we modify a function argument. Suppose we create the following function:</p><pre class="programlisting">modify_first &lt;- function(x) {&#13;
  x[1] &lt;- 0&#13;
  x&#13;
} &#13;
</pre><p>When the function is executed, it attempts to modify the first element of argument <code class="literal">x</code>. Let's do some experiments with vectors and lists and see whether <code class="literal">modify_first()</code> can modify them.</p><p>For a number vector <code class="literal">v1</code>:</p><pre class="programlisting">v1 &lt;- c(1, 2, 3)&#13;
modify_first(v1)&#13;
## [1] 0 2 3&#13;
v1&#13;
## [1] 1 2 3 &#13;
</pre><p>For a list <code class="literal">v2</code>:</p><pre class="programlisting">v2 &lt;- list(x = 1, y = 2)&#13;
modify_first(v2)&#13;
## $x&#13;
## [1] 0&#13;
##&#13;
## $y&#13;
## [1] 2&#13;
v2&#13;
## $x&#13;
## [1] 1&#13;
##&#13;
## $y&#13;
## [1] 2 &#13;
</pre><p>In both experiments, the function only returned a modified version of the original object, but it did not modify the original object. However, directly modifying the vectors outside the function works:</p><pre class="programlisting">v1[1] &lt;- 0&#13;
v1&#13;
## [1] 0 2 3&#13;
v2[1] &lt;- 0&#13;
v2&#13;
## $x&#13;
## [1] 0&#13;
##&#13;
## $y&#13;
## [1] 2 &#13;
</pre><p>To use the modified version, we need to assign it to the original variable:</p><pre class="programlisting">v3 &lt;- 1:5&#13;
v3 &lt;- modify_first(v3)&#13;
v3&#13;
## [1] 0 2 3 4 5 &#13;
</pre><p>The preceding examples demonstrate that modifying a function argument also causes a copy to make sure that the modification does not affect things outside the function.</p><p>The copy-on-modify mechanism also happens when the attributes are modified. The following function removes the row names of a data frame and replaces its column names with capital letters:</p><pre class="programlisting">change_names &lt;- function(x) {&#13;
  if (is.data.frame(x)) {&#13;
    rownames(x) &lt;- NULL&#13;
    if (ncol(x) &lt;= length(LETTERS)) {&#13;
      colnames(x) &lt;- LETTERS[1:ncol(x)]&#13;
    } else {&#13;
      stop("Too many columns to rename")&#13;
    }&#13;
  } else {&#13;
    stop("x must be a data frame")&#13;
  }&#13;
  x&#13;
} &#13;
</pre><p>To test the function, we will create a simple data frame with randomly generated data:</p><pre class="programlisting">small_df &lt;- data.frame(&#13;
  id = 1:3,&#13;
  width = runif(3, 5, 10),&#13;
  height = runif(3, 5, 10))&#13;
small_df&#13;
##   id    width   height&#13;
## 1  1  7.605076 9.991836&#13;
## 2  2  8.763025 7.360011&#13;
## 3  3  9.689882 8.550459 &#13;
</pre><p>Now, we will call the function with the data frame and see the modified version:</p><pre class="programlisting">change_names(small_df)&#13;
##   A     B        C&#13;
## 1 1 7.605076 9.991836&#13;
## 2 2 8.763025 7.360011&#13;
## 3 3 9.689882 8.550459 &#13;
</pre><p>According to the copy-on-modify mechanism, <code class="literal">small_df</code> is copied the first time when its row names are removed, and then, all subsequent changes are made to the copied version instead of the original version. We can verify this by viewing <code class="literal">small_df</code>:</p><pre class="programlisting">small_df&#13;
##   id   width   height&#13;
## 1  1 7.605076 9.991836&#13;
## 2  2 8.763025 7.360011&#13;
## 3  3 9.689882 8.550459 &#13;
</pre><p>The original version has not changed at all.</p><div class="section" title="Modifying objects outside a function"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Modifying objects outside a function</h2></div></div></div><p>Despite the copy-on-modify mechanism, it is still possible to modify a vector outside a function. The <code class="literal">&lt;&lt;-</code> operator is designed to do the job. Suppose we have a variable <code class="literal">x</code> and create a function <code class="literal">modify_x()</code> that simply assigns a new value to <code class="literal">x</code>:</p><pre class="programlisting">x &lt;- 0&#13;
modify_x &lt;- function(value) {&#13;
  x &lt;&lt;- value&#13;
} &#13;
</pre><p>When we call the function, the value of <code class="literal">x</code> will be replaced:</p><pre class="programlisting">modify_x(3)&#13;
x&#13;
## [1] 3 &#13;
</pre><p>This can be useful when you try to map a vector to a new list and do some counting at the same time. The following code creates a list of vectors with an increasing number of elements. In each iteration of <code class="literal">lapply()</code>, <code class="literal">count</code> is used to sum up the total number of elements in the vector generated:</p><pre class="programlisting">count &lt;- 0&#13;
lapply(1:3, function(x) {&#13;
  result &lt;- 1:x&#13;
  count &lt;&lt;- count + length(result)&#13;
  result&#13;
})&#13;
## [[1]]&#13;
## [1] 1&#13;
##&#13;
## [[2]]&#13;
## [1] 1 2&#13;
##&#13;
## [[3]]&#13;
## [1] 1 2 3&#13;
count&#13;
## [1] 6 &#13;
</pre><p>Another example in which <code class="literal">&lt;&lt;-</code> is useful is to flatten a nested list. Suppose we have a nested list like the one shown here:</p><pre class="programlisting">nested_list &lt;- list(&#13;
  a = c(1, 2, 3),&#13;
  b = list(&#13;
    x = c("a", "b", "c"),&#13;
    y = list(&#13;
      z = c(TRUE, FALSE),&#13;
      w = c(2, 3, 4))&#13;
  )&#13;
)&#13;
str(nested_list)&#13;
## List of 2&#13;
## $ a: num [1:3] 1 2 3&#13;
## $ b:List of 2&#13;
## ..$ x: chr [1:3] "a" "b" "c"&#13;
## ..$ y:List of 2&#13;
## .. ..$ z: logi [1:2] TRUE FALSE&#13;
##   .. ..$ w: num [1:3] 2 3 4 &#13;
</pre><p>We want to flatten the list so that the nested levels are all brought to the first level. The following code solves the problem using <code class="literal">rapply()</code> and <code class="literal">&lt;&lt;-</code>.</p><p>First, we need to know that <code class="literal">rapply()</code> is a recursive version of <code class="literal">lapply()</code>. In each iteration, the supplied function is called with an atomic vector at a particular level in the list until all atomic vectors at all levels are exhausted. Calling <code class="literal">rapply(nested_list, f)</code> basically runs in the following manner:</p><pre class="programlisting">f(c(1, 2, 3))&#13;
f(c("a", "b", "c"))&#13;
f(c(TRUE, FALSE))&#13;
f(c(2, 3, 4)) &#13;
</pre><p>Keep in mind, that we should work out a solution to flatten <code class="literal">nested_list</code>. The solution that we will discuss is inspired by a Stackoverflow answer (<a class="ulink" href="http://stackoverflow.com/a/8139959/2906900">http://stackoverflow.com/a/8139959/2906900</a>), which smartly uses <code class="literal">rapply()</code>. First, we will create an empty list to receive individual vectors in the nested list and a counter:</p><pre class="programlisting">flat_list &lt;- list()&#13;
i &lt;- 1 &#13;
</pre><p>Then, we will use <code class="literal">rapply()</code> to recursively apply a function to <code class="literal">nested_list</code>. In each iteration, the function receives an atomic vector in <code class="literal">nested_list</code> through <code class="literal">x</code>. The function sets the<code class="literal">i</code>
<sup>th</sup> element of <code class="literal">flat_list</code> to <code class="literal">x</code> and increments the counter <code class="literal">i</code>:</p><pre class="programlisting">res &lt;- rapply(nested_list, function(x) {&#13;
flat_list[[i]] &lt;&lt;- x&#13;
i &lt;&lt;- i + 1&#13;
}) &#13;
</pre><p>With the iterations done, all atomic vectors are stored in <code class="literal">flat_list</code> at the first level. The value returned by <code class="literal">rapply()</code> is as follows:</p><pre class="programlisting">res&#13;
## a  b.x b.y.z b.y.w&#13;
## 2   3   4     5 &#13;
</pre><p>As a result of <code class="literal">i &lt;&lt;- i + 1</code>, the values in <code class="literal">res</code> are of no much importance. However, the names of <code class="literal">res</code> are useful to indicate the original levels and names of each element in <code class="literal">flat_list</code>. So we let <code class="literal">flat_list</code> also have the names of <code class="literal">res</code> to indicate the origin of each element:</p><pre class="programlisting">names(flat_list) &lt;- names(res)&#13;
str(flat_list)&#13;
## List of 4&#13;
## $ a : num [1:3] 1 2 3&#13;
## $ b.x : chr [1:3] "a" "b" "c"&#13;
## $ b.y.z: logi [1:2] TRUE FALSE&#13;
## $ b.y.w: num [1:3] 2 3 4 &#13;
</pre><p>Finally, all elements in <code class="literal">nested_list</code> are stored in a flat way in <code class="literal">flat_list</code>.</p></div></div>
<div class="section" title="Understanding lexical scoping"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Understanding lexical scoping</h1></div></div></div><p>In the previous section, we introduced the copy-on-modify mechanism. The examples demonstrated two cases in which this mechanism happens. When an object has multiple names or is passed as an argument to a function, modifying it will cause the object to be copied, and it is the copied version that is actually modified.</p><p>To modify an object outside a function, we introduced the use of <code class="literal">&lt;&lt;-</code>, which finds the variable outside the function first and modifies that object instead of copying one locally. This leads to an important idea that a function has inside and outside. Inside a function, we can somehow refer to variables and functions outside.</p><p>For example, the following function uses two outside variables:</p><pre class="programlisting">start_num &lt;- 1&#13;
end_num &lt;- 10&#13;
fun1 &lt;- function(x) {&#13;
  c(start_num, x, end_num)&#13;
} &#13;
</pre><p>We first create two variables and define a function called <code class="literal">fun1</code>. The function simply puts together <code class="literal">start_num</code>, argument <code class="literal">x</code>, and <code class="literal">end_num</code> into a new vector. It is clear that <code class="literal">start_num</code> and <code class="literal">end_num</code> are not defined in the function but outside it while <code class="literal">x</code> is the argument of the function. Let's see if it works:</p><pre class="programlisting">fun1(c(4, 5, 6))&#13;
## [1]  1  4  5  6 10 &#13;
</pre><p>The function works by successfully getting the value of the two variables outside the function. You may guess that when we define the function, the values are captured so that <code class="literal">start_num</code> and <code class="literal">end_num</code> in <code class="literal">fun1</code> just take the values from outside. In fact, two experiments can be performed to prove it wrong.</p><p>The first experiment is simple. Let's remove the two variables:</p><pre class="programlisting">rm(start_num, end_num)&#13;
fun1(c(4, 5, 6))&#13;
## Error in fun1(c(4, 5, 6)): object 'start_num' not found &#13;
</pre><p>Then, the function does not work anymore. If the values of the two variables are captured when the function is defined, the removal of them should not paralyze the function.</p><p>The second experiment is the other way around. Let's remove the function as well as the two variables. We will first define the function:</p><pre class="programlisting">rm(fun1, start_num, end_num)&#13;
## Warning in rm(fun1, start_num, end_num): object 'start_num'&#13;
## not found&#13;
## Warning in rm(fun1, start_num, end_num): object 'end_num'&#13;
## not found&#13;
fun1 &lt;- function(x) {&#13;
c(start_num, x, end_num)&#13;
} &#13;
</pre><p>If the creation of the function has to capture the two variables that are not present in it, the preceding code should result in an error saying <code class="literal">start_num</code> and <code class="literal">end_num</code> are missing. Clearly, there's no error, and the function is successfully created. Let's call it now:</p><pre class="programlisting">fun1(c(4, 5, 6))&#13;
## Error in fun1(c(4, 5, 6)): object 'start_num' not found &#13;
</pre><p>The function does not work because the two variables are not found. We will then define the two variables and again call the function with the same argument:</p><pre class="programlisting">start_num &lt;- 1&#13;
end_num &lt;- 10&#13;
fun1(c(4, 5, 6))&#13;
## [1]  1  4  5  6 10 &#13;
</pre><p>The function works again. This leads to the conclusion that the function actually tries to look for the variables when it is called. Actually, during the execution of the function, when a symbol is encountered, it will first look for it inside the function. More specifically, if the symbol is passed in as an argument or created inside the function, the symbol will be resolved and its value is used.</p><p>Suppose we create a variable <code class="literal">p</code> first and then define a function <code class="literal">fun2</code> in which another <code class="literal">p</code> variable is created and used in the value to return:</p><pre class="programlisting">p &lt;- 0&#13;
fun2 &lt;- function(x) {&#13;
  p &lt;- 1&#13;
  x + p&#13;
} &#13;
</pre><p>When we call the function, which <code class="literal">p</code> will <code class="literal">fun2</code> use in <code class="literal">x + p</code>? Let's find out;</p><pre class="programlisting">fun2(1)&#13;
## [1] 2 &#13;
</pre><p>The output makes it clear that <code class="literal">x + p</code> uses <code class="literal">p</code> defined inside the function. The flow is simple. First, <code class="literal">p &lt;- 1</code> creates a new variable <code class="literal">p</code> with value <code class="literal">1</code> instead of changing <code class="literal">p</code> outside the function. Then, <code class="literal">x + p</code> is evaluated, with <code class="literal">x</code> being resolved as the passed-in argument and <code class="literal">p</code> as the local variable just defined. The rule is that only if a variable is not present inside the function will it be searched for outside.</p><p>However, what exactly does "outside" mean? The question is subtler than it appears to be. Suppose we create the following two functions:</p><pre class="programlisting">f1 &lt;- function(x) {&#13;
  x + p&#13;
}&#13;
g1 &lt;- function(x) {&#13;
  p &lt;- 1&#13;
  f1(x)&#13;
} &#13;
</pre><p>The first function <code class="literal">f1</code> simply adds two variables: <code class="literal">x</code> is an argument and <code class="literal">p</code> is a variable yet to be found outside. The second function <code class="literal">g1</code> defines a <code class="literal">p</code> variable inside and calls <code class="literal">f1</code>. The question is, "Will <code class="literal">f1</code> find <code class="literal">p</code> inside <code class="literal">g1</code> when <code class="literal">g1</code> is called?"</p><pre class="programlisting">g1(0)&#13;
## [1] 0 &#13;
</pre><p>Unfortunately, <code class="literal">f1</code> cannot find <code class="literal">p</code> inside <code class="literal">g1</code> even though <code class="literal">f1</code> is called in <code class="literal">g1</code>. If we define <code class="literal">p</code> and then call <code class="literal">g1</code> again, the function works:</p><pre class="programlisting">p &lt;- 1&#13;
g1(0)&#13;
## [1] 1 &#13;
</pre><p>What made <code class="literal">g1</code> work is that when <code class="literal">f1</code> is called and <code class="literal">p</code> cannot be found inside <code class="literal">f1</code>, it will search where <code class="literal">f1</code> is defined instead of where it is called. This mechanism is called <span class="strong"><strong>lexical scoping</strong></span>. In the preceding code, we defined <code class="literal">p</code> in the same scope where <code class="literal">f1</code> is defined. Then, <code class="literal">f1</code> can find <code class="literal">p</code> when it is called inside <code class="literal">g1</code>.</p><p>The same scoping rule also applies to how <code class="literal">&lt;&lt;-</code> finds variables. For example, the following code defines a variable <code class="literal">m</code> and two functions, <code class="literal">f2</code> and <code class="literal">g2</code>, in the same scope. In <code class="literal">f2</code>, <code class="literal">m</code> is set to <code class="literal">2</code>. However, in <code class="literal">g2</code>, a local <code class="literal">m</code> variable is defined and then <code class="literal">f2</code> is called:</p><pre class="programlisting">m &lt;- 1&#13;
f2 &lt;- function(x) {&#13;
  m &lt;&lt;- 2&#13;
  x&#13;
}&#13;
g2 &lt;- function(x) {&#13;
  m &lt;- 1&#13;
  f2(x)&#13;
  cat(sprintf("[g2] m: %d\n", m))&#13;
} &#13;
</pre><p>As soon as <code class="literal">f2</code> is called, the value of <code class="literal">m</code> in <code class="literal">g2</code> is printed. Let's call <code class="literal">g2</code> and see what happens:</p><pre class="programlisting">g2(1)&#13;
## [g2] m: 1 &#13;
</pre><p>The printed text shows that the value of <code class="literal">m</code> in <code class="literal">g2</code> remains unchanged, but the value of <code class="literal">m</code> outside <code class="literal">f2</code> and <code class="literal">g2</code> is changed as can be verified:</p><pre class="programlisting">m&#13;
## [1] 2 &#13;
</pre><p>The preceding experiment confirms that <code class="literal">m &lt;&lt;- 2</code> follows the rule of lexical scoping.</p><p>The following two examples look even more complex. The functions are nested. In <code class="literal">f</code>, we not only create local variables such as <code class="literal">p</code> and <code class="literal">q</code> but also a local function <code class="literal">f2</code>, in which another local <code class="literal">p</code> variable is defined:</p><pre class="programlisting">f &lt;- function(x) {&#13;
  p &lt;- 1&#13;
  q &lt;- 2&#13;
  cat(sprintf("1. [f1] p: %d, q: %d\n", p, q))&#13;
  f2 &lt;- function(x) {&#13;
    p &lt;- 3&#13;
    cat(sprintf("2. [f2] p: %d, q: %d\n", p, q))&#13;
    c(x = x, p = p, q = q)&#13;
  }&#13;
  cat(sprintf("3. [f1] p: %d, q: %d\n", p, q))&#13;
  f2(x)&#13;
} &#13;
</pre><p>If you understand lexical scoping, you should be able to predict the result given an arbitrary input <code class="literal">x</code>. We add some <code class="literal">cat()</code> functions to make it easier to track the values of variables in each scope level. The <code class="literal">cat()</code> message includes an order, the function scope, and the values of <code class="literal">p</code> and <code class="literal">q</code>. Now, we will run <code class="literal">f(0)</code> and you may predict the result:</p><pre class="programlisting">f(0)&#13;
## 1. [f1] p: 1, q: 2&#13;
## 3. [f1] p: 1, q: 2&#13;
## 2. [f2] p: 3, q: 2&#13;
## x p q&#13;
## 0 3 2 &#13;
</pre><p>The executing order of the three <code class="literal">cat()</code> functions are <code class="literal">1</code>, <code class="literal">3</code>, and <code class="literal">2</code>, and the values of <code class="literal">p</code> and <code class="literal">q</code> in each scope are consistent with lexical scoping rules. In the following example, we will also use <code class="literal">&lt;&lt;-</code>:</p><pre class="programlisting">g &lt;- function(x) {&#13;
  p &lt;- 1&#13;
  q &lt;- 2&#13;
  cat(sprintf("1. [f1] p: %d, q: %d\n", p, q))&#13;
  g2 &lt;- function(x) {&#13;
    p &lt;&lt;- 3&#13;
    p &lt;- 2&#13;
    cat(sprintf("2. [f2] p: %d, q: %d\n", p, q))&#13;
    c(x = x, p = p, q = q)&#13;
  }&#13;
  cat(sprintf("3. [f1] p: %d, q: %d\n", p, q))&#13;
  result &lt;- g2(x)&#13;
  cat(sprintf("4. [f1] p: %d, q: %d\n", p, q))&#13;
  result&#13;
} &#13;
</pre><p>You may analyze the flow of the function by predicting the order of execution and the values of the printed variables:</p><pre class="programlisting">g(0)&#13;
## 1. [f1] p: 1, q: 2&#13;
## 3. [f1] p: 1, q: 2&#13;
## 2. [f2] p: 2, q: 2&#13;
## 4. [f1] p: 3, q: 2&#13;
## x p q&#13;
## 0 2 2 &#13;
</pre><p>If you do not succeed in predicting the behavior of the preceding function, go through the examples in this section more carefully.</p></div>
<div class="section" title="Understanding how an environment works"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Understanding how an environment works</h1></div></div></div><p>In the previous sections, you learned about lazy evaluation, copy-on-modify, and lexical scoping. These mechanisms are highly related to a type of object called <span class="strong"><strong>environment</strong></span>. In fact, lexical scoping is enabled exactly by the environment. Although environments look quite similar to lists, they are indeed fundamentally different in several aspects. In the following sections, we will get to know the behavior of environment objects by creating and manipulating them, and see the way its structure determines how R functions work.</p><div class="section" title="Knowing the environment object"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Knowing the environment object</h2></div></div></div><p>An environment is an object consisting of a set of names and has a parent environment. Each name (also known as a symbol or variable) points to an object. When we look up a symbol in an environment, it will search the set of symbols and return the object the symbol points to if it exists in the environment. Otherwise, it will continue to look up its parent environment. The following diagram illustrates the structure of an environment and the relationship between environments:</p><div class="mediaobject"><img src="graphics/image_08_001.jpg" alt="Knowing the environment object"/></div><p>In the preceding diagram, <span class="strong"><strong>Environment 1</strong></span> consists of two names (<span class="strong"><strong>id</strong></span> and <span class="strong"><strong>grades</strong></span>), and its parent environment is <span class="strong"><strong>Environment 0</strong></span>, which consists of one name (<span class="strong"><strong>scores</strong></span>). Each name in these environments points to an object stored somewhere in the memory. If we look up <span class="strong"><strong>id</strong></span> in <span class="strong"><strong>Environment 1</strong></span>, we'll get the numeric vector it points to directly. If we look up <span class="strong"><strong>scores</strong></span> instead, <span class="strong"><strong>Environment 1</strong></span> does not consist of <span class="strong"><strong>scores</strong></span>, so it will look it up in its parent environment, <span class="strong"><strong>Environment 1</strong></span>, and get its value successfully. For other names, it will look along the chain of parent environments until it is found or it will end up with an error of symbol not found.</p><p>In the following sections, we will go through these concepts in detail.</p></div><div class="section" title="Creating and chaining environments"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Creating and chaining environments</h2></div></div></div><p>We can create a new environment using the <code class="literal">new.env()</code> function:</p><pre class="programlisting">e1 &lt;- new.env() &#13;
</pre><p>The environment is usually represented by hexadecimal digits, which is a memory address:</p><pre class="programlisting">e1&#13;
## &lt;environment: 0x0000000014a45748&gt; &#13;
</pre><p>Extraction operators (<code class="literal">$</code> and<code class="literal">[[</code>) can be used to create variables in the environment, just like modifying a list:</p><pre class="programlisting">e1$x &lt;- 1&#13;
e1[["x"]]&#13;
## [1] 1 &#13;
</pre><p>However, there are three major differences between an environment and a list:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An environment has no index</li><li class="listitem" style="list-style-type: disc">An environment has a parent environment</li><li class="listitem" style="list-style-type: disc">Environments have reference semantics</li></ul></div><p>In the following sections, we will explain them in detail.</p><div class="section" title="Accessing an environment"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec44"/>Accessing an environment</h3></div></div></div><p>An environment has no index. This means that we cannot subset an environment nor can we extract an element from it by index. If we try to subset the environment using a range of positions, we will get an error:</p><pre class="programlisting">e1[1:3]&#13;
## Error in e1[1:3]: object of type 'environment' is not subsettable &#13;
</pre><p>We will get a different error when we try to extract a variable from an environment using index:</p><pre class="programlisting">e1[[1]]&#13;
## Error in e1[[1]]: wrong arguments for subsetting an environment &#13;
</pre><p>The correct way to work with an environment is using names and environment-access functions. For example, we can detect whether a variable exists in an environment using <code class="literal">exists()</code>:</p><pre class="programlisting">exists("x", e1)&#13;
## [1] TRUE &#13;
</pre><p>For an existing variable, we can call <code class="literal">get()</code> to retrieve its value:</p><pre class="programlisting">get("x", e1)&#13;
## [1] 1 &#13;
</pre><p>We can call <code class="literal">ls()</code> to see all variable names in a given environment, as we mentioned in <a class="link" href="ch03.html" title="Chapter 3. Managing Your Workspace">Chapter 3</a>, <span class="emphasis"><em>Managing Your Workspace</em></span>:</p><pre class="programlisting">ls(e1)&#13;
## [1] "x" &#13;
</pre><p>If we use <code class="literal">$</code> or <code class="literal">[[</code> to access variables that don't exist in the environment, we will get <code class="literal">NULL</code>, just like what we get when we extract an element from a list using a non-existing name:</p><pre class="programlisting">e1$y&#13;
## NULL&#13;
e1[["y"]]&#13;
## NULL &#13;
</pre><p>However, if we use the <code class="literal">get()</code> function in a non-existing variable out of an environment, we will certainly receive an error, just like what happens when we refer to a non-existing variable without caution:</p><pre class="programlisting">get("y", e1)&#13;
## Error in get("y", e1): object 'y' not found &#13;
</pre><p>To better handle the situation before an error occurs, we may use <code class="literal">exists()</code> to perform a detection before we use the <code class="literal">get()</code> function to the variable:</p><pre class="programlisting">exists("y", e1)&#13;
## [1] FALSE &#13;
</pre></div></div><div class="section" title="Chaining environments"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec113"/>Chaining environments</h2></div></div></div><p>An environment has a parent environment, which is the next place to look up a symbol if the symbol does not exist in the original environment. Suppose we are trying to use the <code class="literal">get()</code> function to a variable in an environment. If the variable is directly found in it, we get the value. Otherwise, <code class="literal">get()</code> will look for the variable in its parent environment.</p><p>In the following example, we will create a new environment <code class="literal">e2</code>, whose parent (or enclosing) environment is <code class="literal">e1</code>, just like we created in the previous section:</p><pre class="programlisting">e2 &lt;- new.env(parent = e1) &#13;
</pre><p>Different environments have different memory addresses:</p><pre class="programlisting">e2&#13;
## &lt;environment: 0x000000001772ef70&gt;&#13;
e1&#13;
## &lt;environment: 0x0000000014a45748&gt; &#13;
</pre><p>However, the parent environment of <code class="literal">e2</code> is, by definition, exactly the same environment <code class="literal">e1</code> refers to, which can be verified by <code class="literal">parent.env()</code>:</p><pre class="programlisting">parent.env(e2)&#13;
## &lt;environment: 0x0000000014a45748&gt; &#13;
</pre><p>Now, we create a variable <code class="literal">y</code> in <code class="literal">e2</code>:</p><pre class="programlisting">e2$y &lt;- 2 &#13;
</pre><p>We can use <code class="literal">ls()</code> to inspect all variable names in <code class="literal">e2</code>:</p><pre class="programlisting">ls(e2)&#13;
## [1] "y" &#13;
</pre><p>We can also access the value of the variable using <code class="literal">$</code>, <code class="literal">[[, exists()</code> or <code class="literal">get()</code>:</p><pre class="programlisting">e2$y&#13;
## [1] 2&#13;
e2[["y"]]&#13;
## [1] 2&#13;
exists("y", e2)&#13;
## [1] TRUE&#13;
get("y", e2)&#13;
## [1] 2 &#13;
</pre><p>However, the extraction operators (<code class="literal">$</code> and <code class="literal">[[</code>) and the environment-access functions have a notable difference. The operators only work in the scope of a single environment, but the functions work along a chain of environments.</p><p>Note that we don't define any variable called <code class="literal">x</code> in <code class="literal">e2</code>. With no surprise, both operators extracting <code class="literal">x</code> result in <code class="literal">NULL</code>:</p><pre class="programlisting">e2$x&#13;
## NULL&#13;
e2[["x"]]&#13;
## NULL &#13;
</pre><p>However, the parent environment plays a role when we use <code class="literal">exists()</code> and <code class="literal">get()</code>. Since <code class="literal">x</code> is not found in <code class="literal">e2</code>, the functions will continue the search in its parent environment <code class="literal">e1</code>:</p><pre class="programlisting">exists("x", e2)&#13;
## [1] TRUE&#13;
get("x", e1)&#13;
## [1] 1 &#13;
</pre><p>That's why we get positive results from both the preceding function calls. If we don't want the functions to search the parent environment, we can set <code class="literal">inherits = FALSE</code>. In this case, if the variable is not immediately available in the given environment, the search will not continue. Instead, <code class="literal">exists()</code> will return <code class="literal">FALSE</code>:</p><pre class="programlisting">exists("x", e2, inherits = FALSE)&#13;
## [1] FALSE &#13;
</pre><p>Also, the <code class="literal">get()</code> function will result in an error:</p><pre class="programlisting">get("x", e2, inherits = FALSE)&#13;
## Error in get("x", e2, inherits = FALSE): object 'x' not found &#13;
</pre><p>The chaining of environments work at many levels. For example, you may create an environment, <code class="literal">e3</code>, whose parent is <code class="literal">e2</code>. When you use the <code class="literal">get()</code> function to a variable from <code class="literal">e3</code>, the search will go along the chain of environments.</p><div class="section" title="Using environments for reference semantics"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec45"/>Using environments for reference semantics</h3></div></div></div><p>Environments have reference semantics. This means that unlike data types such as atomic vectors and lists, an environment will not be copied when it is modified, whether it has multiple names or is passed as an argument to a function.</p><p>For example, we assign the value of <code class="literal">e1</code> to another variable <code class="literal">e3</code>:</p><pre class="programlisting">ls(e1)&#13;
## [1] "x"&#13;
e3 &lt;- e1 &#13;
</pre><p>If we have two variables pointing to the same list, modifying one would make a copy first and then modify the copied version, which does not influence the other list. Reference semantics behave otherwise. No copy is made when we modify the environment through either variable. So, we can see the changes through both <code class="literal">e1</code> and <code class="literal">e3</code> since they point to exactly the same environment.</p><p>The following code demonstrates how reference semantics work:</p><pre class="programlisting">e3$y&#13;
## NULL&#13;
e1$y &lt;- 2&#13;
e3$y&#13;
## [1] 2 &#13;
</pre><p>First, there is no <code class="literal">y</code> defined in <code class="literal">e3</code>. Then, we created a new variable <code class="literal">y</code> in <code class="literal">e1</code>. Since <code class="literal">e1</code> and <code class="literal">e3</code> point to exactly the same environment, we can also access <code class="literal">y</code> through <code class="literal">e3</code>.</p><p>The same thing happens when we pass an environment as an argument to a function. Suppose we define the following function that tries to set <code class="literal">z</code> of <code class="literal">e</code> to <code class="literal">10</code>:</p><pre class="programlisting">modify &lt;- function(e) {&#13;
  e$z &lt;- 10&#13;
} &#13;
</pre><p>If we pass a list to this function, the modification will not work. Instead a local version is created and modified, but it is dropped after the function call ends:</p><pre class="programlisting">list1 &lt;- list(x = 1, y = 2)&#13;
list1$z&#13;
## NULL&#13;
modify(list1)&#13;
list1$z&#13;
## NULL &#13;
</pre><p>However, if we pass an environment to the function, modifying the environment does not produce a local copy but directly creates a new variable <code class="literal">z</code> in the environment:</p><pre class="programlisting">e1$z&#13;
## NULL&#13;
modify(e1)&#13;
e1$z&#13;
## [1] 10 &#13;
</pre></div><div class="section" title="Knowing the built-in environments"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec46"/>Knowing the built-in environments</h3></div></div></div><p>Environment is quite a special type of object in R, but it is used everywhere from the implementation of a function call to the mechanism of lexical scoping. In fact, when you run a chunk of R code, you run it in a certain environment. To know which environment we are running the code in, we can call <code class="literal">environment()</code>:</p><pre class="programlisting">environment()&#13;
## &lt;environment: R_GlobalEnv&gt; &#13;
</pre><p>The output says that the current environment is the global environment. In fact, when a fresh R session gets ready for user input, the working environment is always the global environment. It is in this environment that we usually create variables and functions in data analysis.</p><p>As the previous examples demonstrated, an environment is also an object we can create and work with. For example, we can assign the current environment to a variable and create new symbols in this environment:</p><pre class="programlisting">global &lt;- environment()&#13;
global$some_obj &lt;- 1 &#13;
</pre><p>The preceding assignment is equivalent to directly calling <code class="literal">some_obj &lt;- 1</code>, because this is already in the global environment. As long as you run the preceding code, the global environment is modified and <code class="literal">some_obj</code> gets a value:</p><pre class="programlisting">some_obj&#13;
## [1] 1 &#13;
</pre><p>There are other ways to access the global environment. For example, both <code class="literal">globalenv()</code> and <code class="literal">.GlobalEnv</code> refer to the global environment:</p><pre class="programlisting">globalenv()&#13;
## &lt;environment: R_GlobalEnv&gt;&#13;
.GlobalEnv&#13;
## &lt;environment: R_GlobalEnv&gt; &#13;
</pre><p>The global environment (<code class="literal">globalenv()</code>) is the user workspace, while the base environment (<code class="literal">baseenv()</code>) provides basic functions and operators:</p><pre class="programlisting">baseenv()&#13;
## &lt;environment: base&gt; &#13;
</pre><p>If you type <code class="literal">base::</code> in the RStudio editor, a long list of functions should appear. Most of the functions we introduced in the previous chapters are defined in the base environment, including, for example, functions to create basic data structures (for example, <code class="literal">list()</code> and <code class="literal">data.frame()</code>) and operators to work with them (for example, <code class="literal">[</code>, <code class="literal">:</code> and even <code class="literal">+</code>).</p><p>The global environment and the base environment are the most important built-in environments. Now, you may ask "What is the parent environment of the global environment? And what about the base environment? What about their grandparents?"</p><p>The following function can be used to find out the chain of a given environment:</p><pre class="programlisting">parents &lt;- function(env) {&#13;
  while (TRUE) {&#13;
    name &lt;- environmentName(env)&#13;
    txt &lt;- if (nzchar(name)) name else format(env)&#13;
    cat(txt, "\n")&#13;
    env &lt;- parent.env(env)&#13;
  }&#13;
} &#13;
</pre><p>The preceding function recursively prints the names of the environment, the parent environment of each being the next one. Now, we can find out all levels of parent environments of the global environment:</p><pre class="programlisting">parents(globalenv())&#13;
## R_GlobalEnv&#13;
## package:stats&#13;
## package:graphics&#13;
## package:grDevices&#13;
## package:utils&#13;
## package:datasets&#13;
## package:methods&#13;
## Autoloads&#13;
## base&#13;
## R_EmptyEnv&#13;
## Error in parent.env(env): the empty environment has no parent &#13;
</pre><p>Note that the chain terminates at an environment called the <span class="strong"><strong>empty environment</strong></span>, which is the only environment that has nothing in it and has no parent environment. There is also a <code class="literal">emptyenv()</code>function that refers to the empty environment, but <code class="literal">parent.env(emptyenv())</code> will cause an error. This explains why <code class="literal">parents()</code> will always end up with an error.</p><p>The chain of environments is a combination of built-in environments and package environments. We can call <code class="literal">search()</code> to get the search path of symbol lookup in the perspective of the global environment:</p><pre class="programlisting">search()&#13;
## [1] ".GlobalEnv" "package:stats"&#13;
## [3] "package:graphics" "package:grDevices"&#13;
## [5] "package:utils" "package:datasets"&#13;
## [7] "package:methods" "Autoloads"&#13;
## [9] "package:base" &#13;
</pre><p>Given the knowledge of symbol lookup along a chain of environments, we can figure out the process in detail of how the following code is evaluated in the global environment:</p><pre class="programlisting">median(c(1, 2, 1 + 3)) &#13;
</pre><p>The expression looks simple, but its evaluation process is more complex than it appears. First, look for <code class="literal">median</code> along the chain. It is found in the <code class="literal">stats</code> package environment. Then, look for <code class="literal">c</code>. It is found in the base environment. Finally, you may be surprised when you look for <code class="literal">+</code> (this is also a function!), as it is found in the base environment.</p><p>In fact, each time you attach a package, the package environment will be inserted before the global environment in the search path. If two packages export functions with conflict names, the functions defined in the package attached later will mask formerly defined ones since it becomes a closer parent to the global environment.</p></div></div><div class="section" title="Understanding environments associated with a function"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec114"/>Understanding environments associated with a function</h2></div></div></div><p>Environments govern the symbol lookup at not only the global level but also the function level. There are three important environments associated with function and its execution process: the executing environment, the enclosing environment, and the calling environment.</p><p>Each time a function is called, a new environment called is created to host the execution process. This is the executing environment of the function call. The arguments of the function and the variables we create in the function are actually the variables in the executing environment.</p><p>Like all other environments, the executing environment of a function is created with a parent environment. That parent environment, also called the enclosing environment of the function, is the environment where the function is defined. This means that during the execution of the function, any variable that is not defined in the executing environment will be looked for in the enclosing environment. This is exactly what makes lexical scoping possible.</p><p>Sometimes it is also useful to know the calling environment, that is, the environment in which the function is called. We can use <code class="literal">parent.frame()</code> to get the calling environment of the currently executing function.</p><p>To demonstrate these concepts, suppose we define the following function:</p><pre class="programlisting">simple_fun &lt;- function() {&#13;
  cat("Executing environment: ")&#13;
  print(environment())&#13;
  cat("Enclosing environment: ")&#13;
  print(parent.env(environment()))&#13;
} &#13;
</pre><p>The function does nothing but prints the executing and enclosing environments when it is called:</p><pre class="programlisting">simple_fun()&#13;
## Executing environment: &lt;environment: 0x0000000014955db0&gt;&#13;
## Enclosing environment: &lt;environment: R_GlobalEnv&gt;&#13;
simple_fun()&#13;
## Executing environment: &lt;environment: 0x000000001488f430&gt;&#13;
## Enclosing environment: &lt;environment: R_GlobalEnv&gt;&#13;
simple_fun()&#13;
## Executing environment: &lt;environment: 0x00000000146a23c8&gt;&#13;
## Enclosing environment: &lt;environment: R_GlobalEnv&gt; &#13;
</pre><p>Note that each time the function is called, the executing environment is different, but the enclosing environment remains the same. In fact, when the function is defined, its enclosing environment is determined. We can call <code class="literal">environment()</code> over a function to get its enclosing environment:</p><pre class="programlisting">environment(simple_fun)&#13;
## &lt;environment: R_GlobalEnv&gt; &#13;
</pre><p>The following example involves the three environments of three nested functions. In each function, the executing environment, enclosing environment, and calling environment are printed. If you firmly understand these concepts, I suggest that you make a prediction of which are the same and which are different:</p><pre class="programlisting">f1 &lt;- function() {&#13;
  cat("[f1] Executing in ")&#13;
  print(environment())&#13;
  cat("[f1] Enclosed by ")&#13;
  print(parent.env(environment()))&#13;
  cat("[f1] Calling from ")&#13;
  print(parent.frame())&#13;
  f2 &lt;- function() {&#13;
    cat("[f2] Executing in ")&#13;
    print(environment())&#13;
    cat("[f2] Enclosed by ")&#13;
    print(parent.env(environment()))&#13;
    cat("[f2] Calling from ")&#13;
    print(parent.frame())&#13;
  }&#13;
  f3 &lt;- function() {&#13;
    cat("[f3] Executing in ")&#13;
    print(environment())&#13;
    cat("[f3] Enclosed by ")&#13;
    print(parent.env(environment()))&#13;
    cat("[f3] Calling from ")&#13;
    print(parent.frame())&#13;
    f2()&#13;
  }&#13;
  f3()&#13;
} &#13;
</pre><p>Let's call <code class="literal">f1</code> and find out when each message is printed. The output requires some effort to read in its original form. We split the output into chunks for easier reading while preserving the order of output for consistency.</p><p>Note that temporarily created environments only have memory addresses (for example, <code class="literal">0x0000000016a39fe8</code>) instead of a common name like the global environment (<code class="literal">R_GlobalEnv</code>). To make it easier to identify identical environments, we give the same memory addresses the same tags (for example, <code class="literal">*A</code>) at the end of each line of text output for the environments:</p><pre class="programlisting">f1()&#13;
## [f1] Executing in &lt;environment: 0x0000000016a39fe8&gt; *A&#13;
## [f1] Enclosed by &lt;environment: R_GlobalEnv&gt;&#13;
## [f1] Calling from &lt;environment: R_GlobalEnv&gt; &#13;
</pre><p>When we call <code class="literal">f1</code>, its associated environments are printed as supposed, and then <code class="literal">f2</code> and <code class="literal">f3</code> are defined, and finally <code class="literal">f3</code> is called, which continues producing the following text output:</p><pre class="programlisting">## [f3] Executing in &lt;environment: 0x0000000016a3def8&gt; *B&#13;
## [f3] Enclosed by &lt;environment: 0x0000000016a39fe8&gt; *A&#13;
## [f3] Calling from &lt;environment: 0x0000000016a39fe8&gt; *A &#13;
</pre><p>Then, <code class="literal">f2</code> is called in <code class="literal">f3</code>, which further produces the following text output:</p><pre class="programlisting">## [f2] Executing in &lt;environment: 0x0000000016a41f90&gt; *C&#13;
## [f2] Enclosed by &lt;environment: 0x0000000016a39fe8&gt; *A&#13;
## [f2] Calling from &lt;environment: 0x0000000016a3def8&gt; *B &#13;
</pre><p>The printed messages show the following facts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Both the enclosing environment and calling environment of <code class="literal">f1</code> are the global environment</li><li class="listitem" style="list-style-type: disc">The enclosing environment and the calling environment of <code class="literal">f3</code>, as well as the enclosing environment of <code class="literal">f2</code>, are the executing environments of <code class="literal">f1</code></li><li class="listitem" style="list-style-type: disc">The calling environment of <code class="literal">f2</code> is the executing environment of <code class="literal">f3</code></li></ul></div><p>The preceding facts are consistent with the following facts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">f1</code> is both defined and called in the global environment</li><li class="listitem" style="list-style-type: disc"><code class="literal">f3</code> is both defined and called in <code class="literal">f1</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">f2</code> is defined in <code class="literal">f1</code> but called in <code class="literal">f3</code></li></ul></div><p>If you managed to make the right predictions, you have a good understanding of how an environment and a function basically work. To go even deeper, I strongly recommend Hadley Wickham's Advanced R (<a class="ulink" href="http://amzn.com/1466586966?tag=devtools-20">http://amzn.com/1466586966?tag=devtools-20</a>).</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we went inside R and learned how R functions basically work. More specifically, you learned lazy evaluation, copy-on-modify, lexical scoping, and how environments work to allow these mechanisms. Having a concrete understanding of how R code is run not only helps you write the correct code but also makes it easier to find bugs from unexpected results.</p><p>In the next chapter, we will build on top of the foundation laid in this chapter. You will learn the basics of metaprogramming, which enables powerful features of interactive analysis.</p></div></body></html>