<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. QGIS Workflows</h1></div></div></div><p class="calibre9">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Creating an NDVI</li><li class="listitem">Geocoding addresses</li><li class="listitem">Creating raster footprints</li><li class="listitem">Performing network analysis</li><li class="listitem">Routing along streets</li><li class="listitem">Tracking a GPS</li><li class="listitem">Creating a mapbook</li><li class="listitem">Finding the least cost path</li><li class="listitem">Performing nearest neighbor analysis</li><li class="listitem">Creating a heat map</li><li class="listitem">Creating a dot density map</li><li class="listitem">Collecting field data</li><li class="listitem">Computing road slope using elevation data</li><li class="listitem">Geolocating photos on the map</li><li class="listitem">Image change detection</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec134" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre9">In this chapter, we'll use Python to perform a variety of common geospatial tasks in QGIS, which may be complete workflows in themselves or key pieces of larger workflows.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec135" class="calibre1"/>Creating an NDVI</h1></div></div></div><p class="calibre9">A <strong class="calibre2">Normalized Difference Vegetation Index</strong> (<strong class="calibre2">NDVI</strong>) is <a id="id615" class="calibre1"/>one of the oldest remote sensing algorithms used to detect green vegetation in an area of interest, using the red and near-infrared bands of an image. The chlorophyll in plants absorbs visible light, including the red band, while the cell structures of plants reflect near-infrared light. The NDVI formula provides a ratio of near-infrared light to the total incoming radiation, which serves as an indicator of vegetation density. This recipe will use Python to control the QGIS raster calculator<a id="id616" class="calibre1"/> in order to create an NDVI using a multispectral image of a farm field.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec390" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the image from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/farm-field.tif">https://geospatialpython.googlecode.com/svn/farm-field.tif</a> and place it in your <code class="literal">qgis_data</code> to a directory named <code class="literal">rasters</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec391" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the raster as a QGIS raster layer, perform the NDVI algorithm, and finally apply a color ramp to the raster so that we can easily visualize the green vegetation in the image. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the QGIS <strong class="calibre2">Python Console</strong>, import the following libraries:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from qgis.analysis import *</strong>
</pre></div></li><li class="listitem" value="2">Now, load the raster image as a layer using the following code:<div><pre class="programlisting"><strong class="calibre2">rasterName = "farm"</strong>
<strong class="calibre2">raster = QgsRasterLayer("/Users/joellawhead/qgis_data/\</strong>
<strong class="calibre2">rasters/farm-field.tif", rasterName)</strong>
</pre></div></li><li class="listitem" value="3">Then, create entries in the QGIS raster calculator for the two bands using the following code:<div><pre class="programlisting"><strong class="calibre2">ir = QgsRasterCalculatorEntry()</strong>
<strong class="calibre2">r = QgsRasterCalculatorEntry()</strong>
</pre></div></li><li class="listitem" value="4">Now, using the following lines of code, assign the raster layer as the raster component of each calculator entry:<div><pre class="programlisting"><strong class="calibre2">ir.raster = raster</strong>
<strong class="calibre2">r.raster = raster</strong>
</pre></div></li><li class="listitem" value="5">Select the appropriate band for each entry, so the calculator will use the data we need for the NDVI. The red and infrared band numbers are typically listed in the raster's metadata:<div><pre class="programlisting"><strong class="calibre2">ir.bandNumber = 2</strong>
<strong class="calibre2">r.bandNumber = 1</strong>
</pre></div></li><li class="listitem" value="6">Next, assign<a id="id617" class="calibre1"/> a reference ID to each entry using the special QGIS naming convention, as shown here, with the name of the layer as a prefix followed by an <code class="literal">@</code> symbol and the band number as a suffix:<div><pre class="programlisting"><strong class="calibre2">ir.ref = rasterName + "@2"</strong>
<strong class="calibre2">r.ref = rasterName + "@1"</strong>
</pre></div></li><li class="listitem" value="7">Build the raster calculator expression with the following code:<div><pre class="programlisting"><strong class="calibre2">references = (ir.ref, r.ref, ir.ref, r.ref)</strong>
<strong class="calibre2">exp = "1.0 * (%s - %s) / 1.0 + (%s + %s)" % references</strong>
</pre></div></li><li class="listitem" value="8">Then, specify the output name of the NDVI image:<div><pre class="programlisting"><strong class="calibre2">output = "/Users/joellawhead/qgis_data/rasters/ndvi.tif"</strong>
</pre></div></li><li class="listitem" value="9">Set up the variables for the rest of the raster calculator call by defining the raster's extent, its width and height in columns and rows, and the raster entries we defined in the previous steps:<div><pre class="programlisting"><strong class="calibre2">e = raster.extent()</strong>
<strong class="calibre2">w = raster.width()</strong>
<strong class="calibre2">h = raster.height()</strong>
<strong class="calibre2">entries = [ir,r]</strong>
</pre></div></li><li class="listitem" value="10">Now, create the NDVI using our expression:<div><pre class="programlisting"><strong class="calibre2">ndvi =  QgsRasterCalculator(exp, output, "GTiff", e, w, h, entries)</strong>
<strong class="calibre2">ndvi.processCalculation()</strong>
</pre></div></li><li class="listitem" value="11">Next, load the NDVI output as a raster layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsRasterLayer(output, "NDVI")</strong>
</pre></div></li><li class="listitem" value="12">We must perform a histogram stretch on the image, otherwise the differences in values will be difficult to see. A stretch is performed using a QGIS contrast enhancement algorithm:<div><pre class="programlisting"><strong class="calibre2">algorithm = QgsContrastEnhancement.StretchToMinimumMaximum</strong>
<strong class="calibre2">limits = QgsRaster.ContrastEnhancementMinMax</strong>
<strong class="calibre2">lyr.setContrastEnhancement(algorithm, limits)</strong>
</pre></div></li><li class="listitem" value="13">Next, build a color ramp shader to colorize the NDVI, as follows:<div><pre class="programlisting"><strong class="calibre2">s = QgsRasterShader()</strong>
<strong class="calibre2">c = QgsColorRampShader()</strong>
<strong class="calibre2">c.setColorRampType(QgsColorRampShader.INTERPOLATED)</strong>
</pre></div></li><li class="listitem" value="14">Then, add <a id="id618" class="calibre1"/>entries for each color in the image. Each entry consists of a lower value range, a color, and a label. The color in an entry will continue from the lower value until it encounters a higher value or the maximum value. Note that we will use a variable alias for the extremely long name of the QGIS <code class="literal">ColorRampItem</code> object:<div><pre class="programlisting"><strong class="calibre2">i = []</strong>
<strong class="calibre2">qri = QgsColorRampShader.ColorRampItem</strong>
<strong class="calibre2">i.append(qri(0, QColor(0,0,0,0), 'NODATA')) </strong>
<strong class="calibre2">i.append(qri(214, QColor(120,69,25,255), 'Lowest Biomass'))</strong>
<strong class="calibre2">i.append(qri(236, QColor(255,178,74,255), 'Lower Biomass'))</strong>
<strong class="calibre2">i.append(qri(258, QColor(255,237,166,255), 'Low Biomass'))</strong>
<strong class="calibre2">i.append(qri(280, QColor(173,232,94,255), 'Moderate Biomass'))</strong>
<strong class="calibre2">i.append(qri(303, QColor(135,181,64,255), 'High Biomass'))</strong>
<strong class="calibre2">i.append(qri(325, QColor(3,156,0,255), 'Higher Biomass'))</strong>
<strong class="calibre2">i.append(qri(400, QColor(1,100,0,255), 'Highest Biomass'))</strong>
</pre></div></li><li class="listitem" value="15">Now, we can add the entries to the shader and apply it to the image:<div><pre class="programlisting"><strong class="calibre2">c.setColorRampItemList(i)</strong>
<strong class="calibre2">s.setRasterShaderFunction(c)</strong>
<strong class="calibre2">ps = QgsSingleBandPseudoColorRenderer(lyr.dataProvider(), 1, s)</strong>
<strong class="calibre2">lyr.setRenderer(ps)</strong>
</pre></div></li><li class="listitem" value="16">Finally, add the classified NDVI image to the map in order to visualize it:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec392" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The QGIS raster calculator<a id="id619" class="calibre1"/> is exactly what its name implies. It allows you to perform array math on images. Both the QGIS raster menu and the Processing Toolbox have several raster processing tools, but the raster calculator can perform custom analysis that can be defined in a single mathematical equation. The NDVI algorithm is the infrared band minus the red band divided by the infrared band plus the red band, or <em class="calibre10">(IR-R)/(IR+R)</em>. In our calculator expression, we multiply each side of the equation by <code class="literal">1.0</code> to avoid division-by-zero errors. Your output should look similar to the following image if you load the result into QGIS. In this screenshot, <code class="literal">NODATA</code> values are represented as black; however, your QGIS installation may default to using white:</p><div><img src="img/00054.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec136" class="calibre1"/>Geocoding addresses</h1></div></div></div><p class="calibre9">Geocoding is the<a id="id620" class="calibre1"/> process of turning an address into earth coordinates. Geocoding requires a comprehensive dataset that ties zip codes, cities, streets, and street numbers (or street number ranges) to the coordinates. In order to have a geocoder that works for any address in the world with reasonable accuracy, you need to use a cloud service because geocoding datasets are very dense and can be quite large. Creating a geocoding dataset for any area beyond a few square miles requires a significant amount of resources. There are several services available, including Google and MapQuest. In QGIS, the easiest way to access these services is through the QGIS Python GeoCoding plugin. In this recipe, we'll use this plugin to programmatically geocode an address.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec393" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need <a id="id621" class="calibre1"/>to install <a id="id622" class="calibre1"/>the QGIS Python GeoCoding plugin by Alessandro Pasotti for this exercise, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">From the QGIS <strong class="calibre2">Plugins</strong> menu, select <strong class="calibre2">Manage and Install Plugins….</strong></li><li class="listitem" value="2">In the <strong class="calibre2">Plugins</strong> dialog search box, search for <code class="literal">Geocoding</code>.</li><li class="listitem" value="3">Select <strong class="calibre2">GeoCoding</strong> plugin and click on the <strong class="calibre2">Install plugin</strong> button.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec394" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">In this recipe, we will <a id="id623" class="calibre1"/>access the GeoCoding plugin methods using Python, feed the<a id="id624" class="calibre1"/> plugin an address, and print the resulting coordinates. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the QGIS <strong class="calibre2">Python Console</strong>, import the OpenStreetMap <code class="literal">geoCoding</code> object using the following code:<div><pre class="programlisting"><strong class="calibre2">from GeoCoding.geopy.geocoders import Nominatim</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll create our geocoder:<div><pre class="programlisting"><strong class="calibre2">geocoder = Nominatim()</strong>
</pre></div></li><li class="listitem" value="3">Then, using the following code, we'll geocode an address:<div><pre class="programlisting"><strong class="calibre2">location = geocoder.geocode("The Ugly Pirate, Bay Saint Louis, MS 39520")</strong>
</pre></div></li><li class="listitem" value="4">Finally, we'll print the results to see the coordinates:<div><pre class="programlisting"><strong class="calibre2">print location</strong>
</pre></div></li><li class="listitem" value="5">Check whether you have received the following output printed to the console:<div><pre class="programlisting"><strong class="calibre2">(u'The Ugly Pirate, 144, Demontluzin Street, Bay St. Louis, Hancock County, Mississippi, 39520, United States of America', (30.3124059, -89.3281418))</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec395" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <strong class="calibre2">GeoCoding</strong> plugin is <a id="id625" class="calibre1"/>designed to be used with the QGIS GUI interface. However, like most QGIS plugins, it is written in Python and we can access it through the Python console.</p><div><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre9">This trick doesn't work with every plugin. Sometimes, the user interface is too intertwined with the plugin's GUI that you can't programmatically use the plugin's methods without triggering the GUI.</p></div><p class="calibre9">However, in most cases, you can use the plugins to not only extend QGIS but also for its powerful Python API. If you write a plugin yourself, consider making it accessible to the QGIS Python console in order to make it even more useful.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec396" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">The GeoCoding plugin also provides the Google geocoding engine as a service. Note that the Google mapping API, including geocoding, comes with some limitations that can be found at <a class="calibre1" href="https://developers.google.com/maps-engine/documentation/limits">https://developers.google.com/maps-engine/documentation/limits</a>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec137" class="calibre1"/>Creating raster footprints</h1></div></div></div><p class="calibre9">A <a id="id626" class="calibre1"/>common way to catalog raster datasets that consist of a large number of files is by creating a vector dataset with polygon footprints of the extent of each raster file. The vector footprint files can be easily loaded in QGIS or served over the Web. This recipe demonstrates a method to create a footprint vector from a directory full of raster files. We will build this program as a Processing Toolbox script, which is easier to build than a QGIS plugin and provides both a GUI and a clean programming API.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec397" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the sample raster image scenes from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/scenes.zip">https://geospatialpython.googlecode.com/svn/scenes.zip</a>. Unzip the <code class="literal">scenes</code> directory into a directory named <code class="literal">rasters</code> in your <code class="literal">qgis_data</code> directory.</p><p class="calibre9">For this recipe, we will create a new Processing Toolbox script using the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the QGIS Processing Toolbox, expand the <strong class="calibre2">Scripts</strong> tree menu.</li><li class="listitem" value="2">Next, expand the <strong class="calibre2">Tools</strong> tree menu.</li><li class="listitem" value="3">Finally, double-click on the <strong class="calibre2">Create new script</strong> item to bring up the processing script editor.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec398" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">First, we will use the Processing Toolbox<a id="id627" class="calibre1"/> header naming conventions ,which will simultaneously define our GUI and the input and output variables. Then, we'll create the logic, which processes a raster directory and calculates the image extents, and finally we'll create the vector file. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we define our input variables using comments to tell the Processing Toolbox to add these to the GUI when the script is invoked by a user. The first item defines the script's group menu to place our script in the toolbox, the second item defines the directory containing the rasters, and the third item is the output name of our shapefile. The script must start with these comments. Each item also declares a type allowed by the Processing Toolbox API. The names of the variables in these comments become available to the script:<div><pre class="programlisting"><strong class="calibre2">##Vector=group</strong>
<strong class="calibre2">##Input_Raster_Directory=folder</strong>
<strong class="calibre2">##Output_Footprints_Vector=output vector</strong>
</pre></div></li><li class="listitem" value="2">Next, we import the Python libraries we will need, using the following commands:<div><pre class="programlisting"><strong class="calibre2">import os</strong>
<strong class="calibre2">from qgis.core import *</strong>
</pre></div></li><li class="listitem" value="3">Now, we <a id="id628" class="calibre1"/>get a list of files in the raster directory. The following script makes no attempt to filter the files by type. If there are other types of data in the directory that are not raster files, they will be included as well:<div><pre class="programlisting"><strong class="calibre2">files = os.listdir(Input_Raster_Directory)</strong>
</pre></div></li><li class="listitem" value="4">Then, we declare a couple of variables, which will hold our raster extents and the coordinate reference string, as shown here:<div><pre class="programlisting"><strong class="calibre2">footprints = []</strong>
<strong class="calibre2">crs = ""</strong>
</pre></div></li><li class="listitem" value="5">Now, we loop through the rasters, load them as a raster layer to grab their extents, store them as point data in Python dictionaries, and add them to our list of footprints for temporary storage. If the raster can't be processed, a warning is issued using the Processing Toolbox progress object:<div><pre class="programlisting"><strong class="calibre2">for f in files:</strong>
<strong class="calibre2">    try:</strong>
<strong class="calibre2">        fn = os.path.join(Input_Raster_Directory, f)</strong>
<strong class="calibre2">        lyr = QgsRasterLayer(fn, "Input Raster")</strong>
<strong class="calibre2">        crs = lyr.crs()</strong>
<strong class="calibre2">        e = lyr.extent()</strong>
<strong class="calibre2">        ulx = e.xMinimum()</strong>
<strong class="calibre2">        uly = e.yMaximum()</strong>
<strong class="calibre2">        lrx = e.xMaximum()</strong>
<strong class="calibre2">        lry = e.yMinimum()</strong>
<strong class="calibre2">        ul = (ulx, uly)</strong>
<strong class="calibre2">        ur = (lrx, uly)</strong>
<strong class="calibre2">        lr = (lrx, lry)</strong>
<strong class="calibre2">        ll = (ulx, lry)</strong>
<strong class="calibre2">        fp = {}</strong>
<strong class="calibre2">        points = []</strong>
<strong class="calibre2">        points.append(QgsPoint(*ul))</strong>
<strong class="calibre2">        points.append(QgsPoint(*ur))</strong>
<strong class="calibre2">        points.append(QgsPoint(*lr)) </strong>
<strong class="calibre2">        points.append(QgsPoint(*ll))   </strong>
<strong class="calibre2">        points.append(QgsPoint(*ul))</strong>
<strong class="calibre2">        fp["points"] = points</strong>
<strong class="calibre2">        fp["raster"] = fn</strong>
<strong class="calibre2">        footprints.append(fp)</strong>
<strong class="calibre2">    except:</strong>
<strong class="calibre2">        progress.setInfo("Warning: The file %s does not appear to be a \</strong>
<strong class="calibre2">valid raster file." % f)</strong>
</pre></div></li><li class="listitem" value="6">Using the <a id="id629" class="calibre1"/>following code, we will create a memory vector layer to build the footprint vector before writing it to a shapefile:<div><pre class="programlisting"><strong class="calibre2">vectorLyr =  QgsVectorLayer("Polygon?crs=%s&amp;field=raster:string(100)" \</strong>
<strong class="calibre2">% crs, "Footprints" , "memory")</strong>
<strong class="calibre2">vpr = vectorLyr.dataProvider()</strong>
</pre></div></li><li class="listitem" value="7">Now, we'll turn our list of extents into features:<div><pre class="programlisting"><strong class="calibre2">features = []</strong>
<strong class="calibre2">for fp in footprints:</strong>
<strong class="calibre2">    poly = QgsGeometry.fromPolygon([fp["points"]])</strong>
<strong class="calibre2">    f = QgsFeature()</strong>
<strong class="calibre2">    f.setGeometry(poly)</strong>
<strong class="calibre2">    f.setAttributes([fp["raster"]])</strong>
<strong class="calibre2">    features.append(f)</strong>
<strong class="calibre2">vpr.addFeatures(features)</strong>
<strong class="calibre2">vectorLyr.updateExtents()</strong>
</pre></div></li><li class="listitem" value="8">We'll then set up the file driver and the CRS for the shapefile:<div><pre class="programlisting"><strong class="calibre2">driver = "Esri Shapefile"</strong>
<strong class="calibre2">epsg = crs.postgisSrid()</strong>
<strong class="calibre2">srs = "EPSG:%s" % epsg</strong>
</pre></div></li><li class="listitem" value="9">Finally, we'll write the selected output file, specifying the layer we are saving to disk; the name of the output file; the file encoding, which might change depending on the input; the coordinate reference system; and the driver for the output file type, which in this case is a shapefile:<div><pre class="programlisting"><strong class="calibre2">error = QgsVectorFileWriter.writeAsVectorFormat\ (vectorLyr, Output_Footprints_Vector, \"utf-8", srs, driver)</strong>
<strong class="calibre2">if error == QgsVectorFileWriter.NoError:</strong>
<strong class="calibre2">    pass</strong>
<strong class="calibre2">else:</strong>
<strong class="calibre2">    progress.setInfo("Unable to output footprints.")</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec399" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">It is important <a id="id630" class="calibre1"/>to remember that a Processing Toolbox script can be run in several different contexts: as a GUI process such as a plugin, as a programmatic script from the Python console, a Python plugin, or the Graphical Modeler framework. Therefore, it is important to follow the documented Processing Toolbox API so that it can work as expected in all of these contexts. This includes defining clear inputs and outputs and using the progress object. The progress object is the proper way to provide feedback to the user for both progress bars and messages. Although the API allows you to define outputs that let the user select different OGR and GDAL outputs, only shapefiles and GeoTiffs seem to be supported currently.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec400" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">The Graphical Modeler tool<a id="id631" class="calibre1"/> within the Processing Toolbox lets you visually chain different processing algorithms together to create complex workflows. Another interesting plugin is the Processing Workflows plugin, which not only allows you to chain algorithms together but also provides a nice tabbed interface with instructions for the end user to help beginners through complicated geospatial workflows.</p><p class="calibre9">The following screenshot shows the raster footprints over an OpenStreetMap basemap:</p><div><img src="img/00055.jpeg" alt="There's more..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec138" class="calibre1"/>Performing network analysis</h1></div></div></div><p class="calibre9">Network analysis <a id="id632" class="calibre1"/>allows you to find the most efficient route <a id="id633" class="calibre1"/>between two points along a defined network of connected lines. These lines might represent streets, pipes in a water system, the Internet, or any number of connected systems. Network analysis abstracts this common problem so that the same techniques and algorithms can be applied across a wide variety of applications. In this recipe, we'll use a generic line network to perform analysis using the Dijkstra algorithm, which is one of the oldest algorithms used to find the shortest path. QGIS has all of this functionality built in.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec401" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">First, download the vector dataset from the following link, which includes two shapefiles, and unzip it to a directory named <code class="literal">shapes</code> in your <code class="literal">qgis_data</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/network.zip">https://geospatialpython.googlecode.com/svn/network.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec402" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will create a network graph by defining the beginning and end of our network of lines, and then use<a id="id634" class="calibre1"/> this graph to determine the shortest route along the line network between our two points. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the QGIS <strong class="calibre2">Python Console</strong>, we'll first import the libraries we'll need, including the QGIS Network Analyzer:<div><pre class="programlisting"><strong class="calibre2">from qgis.core import *</strong>
<strong class="calibre2">from qgis.gui import *</strong>
<strong class="calibre2">from qgis.networkanalysis import *</strong>
<strong class="calibre2">from PyQt4.QtCore import *</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll load our line network shapefile and the shapefile containing the points along the network we want the Network Analyzer to consider when selecting a route:<div><pre class="programlisting"><strong class="calibre2">network = QgsVectorLayer("/Users/joellawhead/qgis_data/shapes/\Network.shp", "Network Layer", "ogr")</strong>
<strong class="calibre2">waypoints = QgsVectorLayer("/Users/joellawhead/qgis_data/shapes/\ NetworkPoints.shp", "Waypoints", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Now, we will create a graph director to define the properties of the graph. The <code class="literal">director</code> object accepts our line shapfile, a field ID for direction information, and some other documented integer codes involving direction properties in the network. In our example, we're going to tell the director to ignore directions. The <code class="literal">properter</code> object is a basic algorithm for a routing strategy that gets added to the network graph and considers line length:<div><pre class="programlisting"><strong class="calibre2">director = QgsLineVectorLayerDirector(network, -1, '', '', '', 3)</strong>
<strong class="calibre2">properter = QgsDistanceArcProperter()</strong>
<strong class="calibre2">director.addProperter(properter)</strong>
<strong class="calibre2">crs = network.crs()</strong>
</pre></div></li><li class="listitem" value="4">Now, we create the <code class="literal">GraphBuilder</code> object to actually convert the line network into a graph:<div><pre class="programlisting"><strong class="calibre2">builder = QgsGraphBuilder(crs)</strong>
</pre></div></li><li class="listitem" value="5">We define the two points that are the start and end of our route:<div><pre class="programlisting"><strong class="calibre2">ptStart = QgsPoint(-0.8095638694, -0.1578175511)</strong>
<strong class="calibre2">ptStop = QgsPoint(0.8907435677, 0.4430834924)</strong>
</pre></div></li><li class="listitem" value="6">Then, we tell the director to turn our point layer into tie points in our network, which define the waypoints along our network and can also optionally provide resistance values:<div><pre class="programlisting"><strong class="calibre2">tiePoints = director.makeGraph(builder, [ptStart, ptStop])</strong>
</pre></div></li><li class="listitem" value="7">Now, we <a id="id635" class="calibre1"/>can use the following code to build the graph:<div><pre class="programlisting"><strong class="calibre2">graph = builder.graph()</strong>
</pre></div></li><li class="listitem" value="8">We now locate our start and end points as tie points in the graph:<div><pre class="programlisting"><strong class="calibre2">tStart = tiePoints[0]</strong>
<strong class="calibre2">tStop = tiePoints[1]</strong>
<strong class="calibre2">idStart = graph.findVertex(tStart)</strong>
<strong class="calibre2">idStop = graph.findVertex(tStop)</strong>
</pre></div></li><li class="listitem" value="9">Then, we can tell the Analyzer to use our start point in order to find the shortest route through the network:<div><pre class="programlisting"><strong class="calibre2">(tree, cost) = QgsGraphAnalyzer.dijkstra(graph, idStart, 0)</strong>
</pre></div></li><li class="listitem" value="10">Next, we loop through the resulting tree and grab the points along the output route:<div><pre class="programlisting"><strong class="calibre2">p = []</strong>
<strong class="calibre2">curPos = idStop</strong>
<strong class="calibre2">while curPos != idStart:</strong>
<strong class="calibre2">p.append(graph.vertex(graph.arc(tree[curPos]).inVertex()).point())</strong>
<strong class="calibre2">curPos = graph.arc(tree[curPos]).outVertex()</strong>
<strong class="calibre2">p.append(tStart)</strong>
</pre></div></li><li class="listitem" value="11">Now, we'll load our two input shapefiles onto the map and create a rubber band in order to visualize the route:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([network,waypoints])</strong>
<strong class="calibre2">rb = QgsRubberBand(iface.mapCanvas())</strong>
<strong class="calibre2">rb.setColor(Qt.red)</strong>
</pre></div></li><li class="listitem" value="12">Finally, we'll add the route points to the rubber band in order to see the output of the Network Analyzer:<div><pre class="programlisting"><strong class="calibre2">for pnt in p:</strong>
<strong class="calibre2">  rb.addPoint(pnt)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec403" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This recipe is an extremely simple example to be used as a starting point for the investigation of a <a id="id636" class="calibre1"/>very complex and powerful tool. The line network shapefiles can have a field defining each line as one-way in a certain direction or bi-directional. The point shapefile provides waypoints along the network, as well as resistance values, which might represent elevation, traffic density, or other factors that will make a route less desirable. The output will look similar to the following image:</p><div><img src="img/00056.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">More information and examples of the<a id="id637" class="calibre1"/> network analysis tool are available in the QGIS documentation at <a class="calibre1" href="http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html">http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html</a>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec139" class="calibre1"/>Routing along streets</h1></div></div></div><p class="calibre9">Sometimes, you <a id="id638" class="calibre1"/>may want to find the best driving route between two addresses. Street routing has now become so commonplace that we take it for granted. However, if you explore the recipes on geocoding and network analysis in this book, you will begin to see what a complex challenge street routing truly is. To perform routing operations in QGIS, we'll use the QGIS GeoSearch plugin, which is written in Python, so that we can access it from the console.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec404" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to<a id="id639" class="calibre1"/> install the QGIS Python GeoSearch plugin for this exercise in order to do the routing, as well as the QGIS OpenLayers Plugin to overlay the result on a Google map, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">From the QGIS <strong class="calibre2">Plugins</strong> menu, select <strong class="calibre2">Manage and Install Plugins….</strong></li><li class="listitem" value="2">If you have the QGIS GeoCoding Plugin installed, then you must uninstall it, as sometimes it conflicts with the GeoSearch plugin. So, select this in the plugin list and click on the <strong class="calibre2">Uninstall plugin</strong> button.</li><li class="listitem" value="3">In the <strong class="calibre2">Plugins</strong> dialog search box, search for <code class="literal">GeoSearch</code>.</li><li class="listitem" value="4">Select the <strong class="calibre2">GeoSearch plugin</strong> and click on the <strong class="calibre2">Install plugin</strong> button.</li><li class="listitem" value="5">Next, in the <strong class="calibre2">Plugins</strong> search dialog, search for <code class="literal">OpenLayers</code>.</li><li class="listitem" value="6">Select the <strong class="calibre2">OpenLayers plugin</strong> and click on the <strong class="calibre2">Install plugin</strong> button.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec405" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will invoke the <a id="id640" class="calibre1"/>GeoSearch plugin's routing function, which uses Google's routing engine, and display the result over a Google map from the OpenLayers plugin. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the <strong class="calibre2">QGIS Python Console</strong>, we first import the <strong class="calibre2">QGIS utils library</strong> as well as the required portions of the <strong class="calibre2">GeoSearch</strong> plugin:<div><pre class="programlisting"><strong class="calibre2">import qgis.utils</strong>
<strong class="calibre2">from GeoSearch import geosearchdialog, GoogleMapsApi</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll use the QGIS utils library to access the <strong class="calibre2">OpenLayers plugin</strong>:<div><pre class="programlisting"><strong class="calibre2">openLyrs = qgis.utils.plugins['openlayers_plugin']</strong>
</pre></div></li><li class="listitem" value="3">The GeoSearch plugin isn't really designed for programmatic use, so in order to invoke this plugin, we must invoke it through the GUI interface, but then we need to pass blank values so that it doesn't trigger the GUI plugin interface:<div><pre class="programlisting"><strong class="calibre2">g = geosearchdialog.GeoSearchDialog(iface)</strong>
<strong class="calibre2">g.SearchRoute([])</strong>
</pre></div></li><li class="listitem" value="4">Now, using the following code, we can safely create our routing engine object:<div><pre class="programlisting"><strong class="calibre2">d = GoogleMapsApi.directions.Directions()</strong>
</pre></div></li><li class="listitem" value="5">Next, we create our origin and destination addresses:<div><pre class="programlisting"><strong class="calibre2">origin = "Boston, MA"</strong>
<strong class="calibre2">dest = "2517 Main Rd, Dedham, ME 04429"</strong>
</pre></div></li><li class="listitem" value="6">Then, we can calculate the route using the simplest possible options, as shown here:<div><pre class="programlisting"><strong class="calibre2">route = d.GetDirections(origin, dest, mode = "driving", \ waypoints=None, avoid=None, units="imperial")</strong>
</pre></div></li><li class="listitem" value="7">Now, we use the <strong class="calibre2">OpenLayers</strong> plugin to add the Google Maps base map to the QGIS map:<div><pre class="programlisting"><strong class="calibre2">layerType = openLyrs._olLayerTypeRegistry.getById(4)</strong>
<strong class="calibre2">openLyrs.addLayer(layerType)</strong>
</pre></div></li><li class="listitem" value="8">Finally, we <a id="id641" class="calibre1"/>use the <strong class="calibre2">GeoSearch plugin</strong> to create a QGIS layer on top of the base map for our route:<div><pre class="programlisting"><strong class="calibre2">g.CreateVectorLayerGeoSearch_Route(route)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec406" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Even though they are built in Python, neither the GeoSearch nor OpenLayers plugins are designed to be used with Python by a programmer. However, we are still able to use the tools in a script without much trouble. To take advantage of some of the routing options available with the GeoSearch plugin, you can use its GUI to see what is available and then add those options to your script. Beware that most plugins don't have a true API, so a slight change to the plugin in a future version can break your script.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec140" class="calibre1"/>Tracking a GPS</h1></div></div></div><p class="calibre9">QGIS has the <a id="id642" class="calibre1"/>ability to connect to a GPS that uses the NMEA standard. QGIS can use a serial connection to the GPS or communicate with it through the open source software called gpsd using the QGIS GPS information panel. The location information from the GPS can be displayed on the QGIS map, and QGIS can even automatically pan the map to follow the GPS point. In this recipe, we'll use the QGIS API to process NMEA sentences and update a point on a global map. The information needed to connect to different GPS units can vary widely, so we'll use an online NMEA sentence generator to get some simulated GPS information.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec407" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">This recipe doesn't require any preparation.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec408" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll grab a batch of NMEA GPS sentences from a free online generator, create a worldwide basemap using online geojson data, create a vector point layer to represent the GPS, and finally loop through the sentences and make our track point move around the map.</p><p class="calibre9">To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import some standard Python libraries using the QGIS <strong class="calibre2">Python Console</strong>:<div><pre class="programlisting"><strong class="calibre2">import urllib</strong>
<strong class="calibre2">import urllib2</strong>
<strong class="calibre2">import time</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll connect to the online NMEA generator, download a batch of sentences, and turn them into a list, as follows:<div><pre class="programlisting"><strong class="calibre2">url = 'http://freenmea.net/api/emitnmea'</strong>
<strong class="calibre2">values = {'types' : 'default'}</strong>
<strong class="calibre2">data = urllib.urlencode(values)</strong>
<strong class="calibre2">req = urllib2.Request(url, data)</strong>
<strong class="calibre2">response = urllib2.urlopen(req)</strong>
<strong class="calibre2">results = response.read().split("\n")</strong>
</pre></div></li><li class="listitem" value="3">Next, we<a id="id643" class="calibre1"/> can add our world countries basemap using a geojson service:<div><pre class="programlisting"><strong class="calibre2">wb = "https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json"</strong>
<strong class="calibre2">basemap = QgsVectorLayer(wb, "Countries", "ogr")</strong>
<strong class="calibre2">qmr = QgsMapLayerRegistry.instance()</strong>
<strong class="calibre2">qmr.addMapLayer(basemap)</strong>
</pre></div></li><li class="listitem" value="4">Now, we can create our GPS point layer and access its data provider:<div><pre class="programlisting"><strong class="calibre2">vectorLyr = QgsVectorLayer('Point?crs=epsg:4326', \'GPS Point' , "memory")</strong>
<strong class="calibre2">vpr = vectorLyr.dataProvider()</strong>
</pre></div></li><li class="listitem" value="5">Then, we need some variables to hold the current coordinates as we loop through the locations, and we'll also access the <code class="literal">mapCanvas</code> object:<div><pre class="programlisting"><strong class="calibre2">cLat = None</strong>
<strong class="calibre2">cLon = None</strong>
<strong class="calibre2">canvas = iface.mapCanvas()</strong>
</pre></div></li><li class="listitem" value="6">Next, we'll create a GPS connection object for data processing. If we are using a live GPS object, we will use this line to enter the device's information:<div><pre class="programlisting"><strong class="calibre2">c = QgsNMEAConnection(None)</strong>
</pre></div></li><li class="listitem" value="7">Now, we set up a flag to determine whether we are processing the first point or not:<div><pre class="programlisting"><strong class="calibre2">firstPt = True</strong>
</pre></div></li><li class="listitem" value="8">We can loop through the NMEA sentences now, but we must check the sentence type to <a id="id644" class="calibre1"/>see which type of information we are using. In a live GPS connection, QGIS handles this part automatically and this part of the code will be unnecessary:<div><pre class="programlisting"><strong class="calibre2">for r in results:</strong>
<strong class="calibre2">    l = len(r)</strong>
<strong class="calibre2">    if "GGA" in r:</strong>
<strong class="calibre2">        c.processGGASentence(r,l)</strong>
<strong class="calibre2">    elif "RMC" in r:</strong>
<strong class="calibre2">        c.processRMCSentence(r,l)</strong>
<strong class="calibre2">    elif "GSV" in r:</strong>
<strong class="calibre2">        c.processGSVSentence(r,l)</strong>
<strong class="calibre2">    elif "VTG" in r:</strong>
<strong class="calibre2">        c.processVTGSentence(r,l)</strong>
<strong class="calibre2">    elif "GSA" in r:</strong>
<strong class="calibre2">        c.processGSASentence(r,l)</strong>
</pre></div></li><li class="listitem" value="9">Then, we can get the current GPS information:<div><pre class="programlisting"><strong class="calibre2">    i=c.currentGPSInformation()</strong>
</pre></div></li><li class="listitem" value="10">Now, we will check this information to make sure that the GPS location has actually changed since the previous loop before we try to update the map:<div><pre class="programlisting"><strong class="calibre2">  if i.latitude and i.longitude:</strong>
<strong class="calibre2">        lat = i.latitude</strong>
<strong class="calibre2">        lon = i.longitude</strong>
<strong class="calibre2">        if lat==cLat and lon==cLon:</strong>
<strong class="calibre2">            continue</strong>
<strong class="calibre2">        cLat = lat</strong>
<strong class="calibre2">        cLon = lon</strong>
<strong class="calibre2">        pnt = QgsGeometry.fromPoint(QgsPoint(lon,lat))</strong>
</pre></div></li><li class="listitem" value="11">Now that we have a new point, we check whether this is the first point and add the whole layer to the map if it is. Otherwise, we edit the layer and add a new feature, as follows:<div><pre class="programlisting"><strong class="calibre2">        if firstPt:</strong>
<strong class="calibre2">            firstPt = False</strong>
<strong class="calibre2">            f = QgsFeature()</strong>
<strong class="calibre2">            f.setGeometry(pnt)</strong>
<strong class="calibre2">            vpr.addFeatures([f])</strong>
<strong class="calibre2">            qmr.addMapLayer(vectorLyr)</strong>
<strong class="calibre2">        else:</strong>
<strong class="calibre2">            print lon, lat</strong>
<strong class="calibre2">            vectorLyr.startEditing()</strong>
<strong class="calibre2">            vectorLyr.changeGeometry(1,pnt)</strong>
<strong class="calibre2">            vectorLyr.commitChanges()</strong>
</pre></div></li><li class="listitem" value="12">Finally, we <a id="id645" class="calibre1"/>refresh the map and watch the tracking point jump to a new location:<div><pre class="programlisting"><strong class="calibre2">        vectorLyr.setCacheImage(None)</strong>
<strong class="calibre2">        vectorLyr.updateExtents()</strong>
<strong class="calibre2">        vectorLyr.triggerRepaint()</strong>
<strong class="calibre2">        time.sleep(1)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec409" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">A live GPS will move in a linear, incremental path across the map. In this recipe, we used randomly-generated points that leap around the world, but the concept is the same. To connect a live GPS, you will need to use QGIS's GPS information GUI first to establish a connection, or at least get the correct connection information, and then use Python to automate things from there. Once you have the location information, you can easily manipulate the QGIS map using Python.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec410" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">The NMEA standard is old and widely used, but it is a poorly-designed protocol by modern standards. Nearly every smartphone has a GPS now, but they do not use the NMEA protocol. There are, however, several apps available for nearly every smartphone platform that will output the phone's GPS as NMEA sentences, which can be used by QGIS. Later in this chapter, in the <em class="calibre10">Collecting field data</em> recipe, we'll demonstrate another method for tracking a cell phone, GPS, or even estimated locations for digital devices, which is much simpler and much more modern.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec141" class="calibre1"/>Creating a mapbook</h1></div></div></div><p class="calibre9">A mapbook <a id="id646" class="calibre1"/>is an automatically-generated document, which can also be called an<a id="id647" class="calibre1"/> <strong class="calibre2">atlas</strong>. A mapbook takes a dataset and breaks it down into smaller, detailed maps based on a coverage layer that zooms the larger map to each feature in the coverage in order to make a page of the mapbook. The coverage layer may or may not be the same as the map layer featured on each page of the mapbook. In this recipe, we'll create a mapbook that <a id="id648" class="calibre1"/>features all the countries in the world.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec411" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, you need to download the world countries dataset from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/countries.zip">https://geospatialpython.googlecode.com/svn/countries.zip</a> and put it in a directory named <code class="literal">shapes</code> within your <code class="literal">qgis_data</code> directory.</p><p class="calibre9">Next, you'll need to install the <code class="literal">PyPDF2</code> library. On Linux or OS X, just open a console and run the following command:</p><div><pre class="programlisting"><strong class="calibre2">sudo easy_install PyPDF2</strong>
</pre></div><p class="calibre9">On Windows, open the OSGEO4W console from your start menu and run this:</p><div><pre class="programlisting"><strong class="calibre2">easy_install PyPDF2</strong>
</pre></div><p class="calibre9">Finally, in your <code class="literal">qgis_data</code> directory, create a folder called <code class="literal">atlas</code> to store the mapbook's output.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec412" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will build a QGIS composition and set it to atlas mode. Then, we'll add a composer map, where each country will be featured, and an overview map. Next, we'll run the atlas process to produce each page of the mapbook as separate PDF files. Finally, we'll combine the individual PDFs into a single PDF file. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, import all the libraries that are needed:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">from qgis.core import *</strong>
<strong class="calibre2">import PyPDF2</strong>
<strong class="calibre2">import os</strong>
</pre></div></li><li class="listitem" value="2">Next, create variables related to the output files, including the mapbook's name, the coverage layer, and the naming pattern for the individual PDF files:<div><pre class="programlisting"><strong class="calibre2">filenames = []</strong>
<strong class="calibre2">mapbook = "/Users/joellawhead/qgis_data/atlas/mapbook.pdf"</strong>
<strong class="calibre2">coverage = "/Users/joellawhead/qgis_data/shapes/countries.shp"</strong>
<strong class="calibre2">atlasPattern = "/Users/joellawhead/qgis_data/atlas/output_"</strong>
</pre></div></li><li class="listitem" value="3">Now, add the coverage layer to the map using the following code:<div><pre class="programlisting"><strong class="calibre2">vlyr = QgsVectorLayer(coverage, "Countries", "ogr")</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(vlyr)</strong>
</pre></div></li><li class="listitem" value="4">Next, establish the map renderer:<div><pre class="programlisting"><strong class="calibre2">mr = QgsMapRenderer()</strong>
<strong class="calibre2">mr.setLayerSet([vlyr.id()])</strong>
<strong class="calibre2">mr.setProjectionsEnabled(True)</strong>
<strong class="calibre2">mr.setMapUnits(QGis.DecimalDegrees)</strong>
<strong class="calibre2">crs = QgsCoordinateReferenceSystem()</strong>
<strong class="calibre2">crs.createFromSrid(4326)</strong>
<strong class="calibre2">mr.setDestinationCrs(crs)</strong>
</pre></div></li><li class="listitem" value="5">Then, set <a id="id649" class="calibre1"/>up the composition:<div><pre class="programlisting"><strong class="calibre2">c = QgsComposition(mr)</strong>
<strong class="calibre2">c.setPaperSize(297, 210)</strong>
</pre></div></li><li class="listitem" value="6">Create a symbol for the coverage layer:<div><pre class="programlisting"><strong class="calibre2">gray = {"color": "155,155,155"}</strong>
<strong class="calibre2">mapSym = QgsFillSymbolV2.createSimple(gray)</strong>
<strong class="calibre2">renderer = QgsSingleSymbolRendererV2(mapSym)</strong>
<strong class="calibre2">vlyr.setRendererV2(renderer)</strong>
</pre></div></li><li class="listitem" value="7">Now, add the first composer map to the composition, as shown here:<div><pre class="programlisting"><strong class="calibre2">atlasMap = QgsComposerMap(c, 20, 20, 130, 130)</strong>
<strong class="calibre2">atlasMap.setFrameEnabled(True)</strong>
<strong class="calibre2">c.addComposerMap(atlasMap)</strong>
</pre></div></li><li class="listitem" value="8">Then, create the atlas framework:<div><pre class="programlisting"><strong class="calibre2">atlas = c.atlasComposition()</strong>
<strong class="calibre2">atlas.setCoverageLayer(vlyr)</strong>
<strong class="calibre2">atlas.setHideCoverage(False)</strong>
<strong class="calibre2">atlas.setEnabled(True)</strong>
<strong class="calibre2">c.setAtlasMode(QgsComposition.ExportAtlas)</strong>
</pre></div></li><li class="listitem" value="9">Next, establish the overview map:<div><pre class="programlisting"><strong class="calibre2">ov = QgsComposerMap(c, 180, 20, 50, 50)</strong>
<strong class="calibre2">ov.setFrameEnabled(True)</strong>
<strong class="calibre2">ov.setOverviewFrameMap(atlasMap.id())</strong>
<strong class="calibre2">c.addComposerMap(ov)</strong>
<strong class="calibre2">rect = QgsRectangle(vlyr.extent())</strong>
<strong class="calibre2">ov.setNewExtent(rect)</strong>
</pre></div></li><li class="listitem" value="10">Then, create the overview map symbol:<div><pre class="programlisting"><strong class="calibre2">yellow = {"color": "255,255,0,255"}</strong>
<strong class="calibre2">ovSym = QgsFillSymbolV2.createSimple(yellow)</strong>
<strong class="calibre2">ov.setOverviewFrameMapSymbol(ovSym)</strong>
</pre></div></li><li class="listitem" value="11">Next, you<a id="id650" class="calibre1"/> need to label each page with the name of the country, which is stored in the <code class="literal">CNTRY_NAME</code> field of the shapefile:<div><pre class="programlisting"><strong class="calibre2">lbl = QgsComposerLabel(c)</strong>
<strong class="calibre2">c.addComposerLabel(lbl)</strong>
<strong class="calibre2">lbl.setText('[% "CNTRY_NAME" %]')</strong>
<strong class="calibre2">lbl.setFont(QgsFontUtils.getStandardTestFont())</strong>
<strong class="calibre2">lbl.adjustSizeToText()</strong>
<strong class="calibre2">lbl.setSceneRect(QRectF(150, 5, 60, 15))</strong>
</pre></div></li><li class="listitem" value="12">Now, we'll tell the atlas to use automatic scaling for each country in order to best fit each map in the window:<div><pre class="programlisting"><strong class="calibre2">atlasMap.setAtlasDriven(True)</strong>
<strong class="calibre2">atlasMap.setAtlasScalingMode(QgsComposerMap.Auto)</strong>
<strong class="calibre2">atlasMap.setAtlasMargin(0.10)</strong>
</pre></div></li><li class="listitem" value="13">Now we tell the atlas to loop through all the features and create PDF maps, as follows:<div><pre class="programlisting"><strong class="calibre2">atlas.setFilenamePattern("'%s' || $feature" % atlasPattern)</strong>
<strong class="calibre2">atlas.beginRender()</strong>
<strong class="calibre2">for i in range(0, atlas.numFeatures()):</strong>
<strong class="calibre2">    atlas.prepareForFeature(i)</strong>
<strong class="calibre2">    filename = atlas.currentFilename() + ".pdf"</strong>
<strong class="calibre2">    print "Writing file %s" % filename</strong>
<strong class="calibre2">    filenames.append(filename)</strong>
<strong class="calibre2">    c.exportAsPDF(filename)</strong>
<strong class="calibre2">atlas.endRender()</strong>
</pre></div></li><li class="listitem" value="14">Finally, we will use the PyPDF2 library to combine the individual PDF files into a single PDF file, as shown here:<div><pre class="programlisting"><strong class="calibre2">output = PyPDF2.PdfFileWriter()</strong>
<strong class="calibre2">for f in filenames:</strong>
<strong class="calibre2">    pdf = open(f, "rb")</strong>
<strong class="calibre2">    page = PyPDF2.PdfFileReader(pdf)</strong>
<strong class="calibre2">    output.addPage(page.getPage(0))</strong>
<strong class="calibre2">    os.remove(f)</strong>
<strong class="calibre2">print "Writing final mapbook..."</strong>
<strong class="calibre2">book = open(mapbook, "wb")</strong>
<strong class="calibre2">output.write(book)</strong>
<strong class="calibre2">with open(mapbook, 'wb') as book:</strong>
<strong class="calibre2">    output.write(book)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec413" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">You can customize<a id="id651" class="calibre1"/> the template that creates the individual pages as much as you want. The GUI atlas tool can export the atlas to a single file, but this functionality is not available in PyQIS, so we use the pure Python PyPDF2 library. You can also create a template in the GUI, save it, and load it with Python, but it is often easier to make changes if you have the layout available in the code. You should also know that the PDF pages are just images. The maps are exported as rasters, so the mapbook will not be searchable and the file size can be large.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec142" class="calibre1"/>Finding the least cost path</h1></div></div></div><p class="calibre9">
<strong class="calibre2">Least cost path</strong> (<strong class="calibre2">LCP</strong>) analysis<a id="id652" class="calibre1"/> is the raster equivalent of network analysis, which is used to find the optimal path between two points in a raster. In this recipe, we'll perform LCP analysis on a digital elevation model (DEM).</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec414" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You need to download the following DEM and extract the ZIP file to your <code class="literal">qgis_data/rasters</code> directory: <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/lcp.zip">https://geospatialpython.googlecode.com/svn/lcp.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec415" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load our DEM <a id="id653" class="calibre1"/>and two shapefiles consisting of start and end points. Then, we'll use GRASS through the Processing Toolbox to create a cumulative cost layer that assigns a cost to each cell in a raster based on its elevation, the value of the other cells around it, and its distance to and from the end points.</p><p class="calibre9">Then, we'll use a SAGA processing algorithm to find the least cost path between two points. Finally, we'll load the <a id="id654" class="calibre1"/>output onto the map. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll import the QGIS processing Python library:<div><pre class="programlisting"><strong class="calibre2">import processing</strong>
</pre></div></li><li class="listitem" value="2">Now, we'll set the paths to the layers, as follows:<div><pre class="programlisting"><strong class="calibre2">path = "/Users/joellawhead/qgis_data/rasters"/"</strong>
<strong class="calibre2">dem = path + "dem.asc"</strong>
<strong class="calibre2">start = path + "start-point.shp"</strong>
<strong class="calibre2">finish = path + "end-point.shp"</strong>
</pre></div></li><li class="listitem" value="3">We need the DEM's extent as a string for the algorithms:<div><pre class="programlisting"><strong class="calibre2">demLyr = QgsRasterLayer(dem, "DEM")</strong>
<strong class="calibre2">ext = demLyr.extent()</strong>
<strong class="calibre2">xmin = ext.xMinimum()</strong>
<strong class="calibre2">ymin = ext.yMinimum()</strong>
<strong class="calibre2">xmax = ext.xMaximum()</strong>
<strong class="calibre2">ymax = ext.xMaximum()</strong>
<strong class="calibre2">box = "%s,%s,%s,%s" % (xmin,xmax,ymin,ymax)</strong>
</pre></div></li><li class="listitem" value="4">Using the following code, we will establish the end points as layers:<div><pre class="programlisting"><strong class="calibre2">a = QgsVectorLayer(start, "Start", "ogr")</strong>
<strong class="calibre2">b = QgsVectorLayer(finish, "End", "ogr")</strong>
</pre></div></li><li class="listitem" value="5">Then, we'll create the cumulative cost raster, specifying the algorithm name, cost layer (DEM), start point layer, end point layer, speed or accuracy option, keep null values option, extent of interest, cell size (0 for default), and some additional defaults:<div><pre class="programlisting"><strong class="calibre2">tmpCost = processing.runalg("grass:r.cost",dem,a,b,\</strong>
<strong class="calibre2">False,False,box,0,-1,0.0001,None)</strong>
<strong class="calibre2">cost = tmpCost["output"]</strong>
</pre></div></li><li class="listitem" value="6">We also need to combine the points into a single layer for the SAGA algorithm:<div><pre class="programlisting"><strong class="calibre2">tmpMerge = processing.runalg("saga:mergeshapeslayers",\start,finish,None)</strong>
<strong class="calibre2">merge = tmpMerge["OUT"]</strong>
</pre></div></li><li class="listitem" value="7">Next, we set up the inputs and outputs for the LCP algorithm:<div><pre class="programlisting"><strong class="calibre2">vLyr = QgsVectorLayer(merge, "Destination Points", "ogr")</strong>
<strong class="calibre2">rLyr = QgsRasterLayer(cost, "Accumulated Cost")</strong>
<strong class="calibre2">line = path + "path.shp"</strong>
</pre></div></li><li class="listitem" value="8">Then, we run the LCP analysis using the following code:<div><pre class="programlisting"><strong class="calibre2">results = processing.runalg("saga:leastcostpaths",\lyr,rLyr,demLyr,None,line)</strong>
</pre></div></li><li class="listitem" value="9">Finally, we can load the path to view it:<div><pre class="programlisting"><strong class="calibre2">path = QgsVectorLayer(line, "Least Cost Path", "ogr")</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([demLyr, \ vLyr, path])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec416" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">GRASS has an <a id="id655" class="calibre1"/>LCP algorithm too, but the SAGA algorithm is easier to use. GRASS does a great job of creating the cost grid. Processing Toolbox algorithms allow you to create temporary files that are deleted when QGIS closes. So, we use temporary files for the intermediate products, including the cost grid and the merged shapefile.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec143" class="calibre1"/>Performing nearest neighbor analysis</h1></div></div></div><p class="calibre9">Nearest neighbor analysis <a id="id656" class="calibre1"/>relates one point to the nearest point in one or more datasets. In this recipe, we'll relate one set of points to the closest point from another dataset. In this case, we'll find the closest major city for each entry in a catalog of unidentified flying object (UFO) sightings from the National UFO reporting center. This analysis will tell you which major cities have the most UFO activity. The UFO catalog data just contains latitude and longitude points, so we'll use <a id="id657" class="calibre1"/>nearest neighbor analysis to assign names to places.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec417" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the following ZIP file and extract it to a directory named <code class="literal">ufo</code> in your <code class="literal">qgis_data</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/ufo.zip">https://geospatialpython.googlecode.com/svn/ufo.zip</a>
</p><p class="calibre9">You will also need the MMQGIS plugin:</p><div><ol class="orderedlist"><li class="listitem" value="1">From the QGIS <strong class="calibre2">Plugins</strong> menu, select <strong class="calibre2">Manage and Install Plugins….</strong></li><li class="listitem" value="2">In the <strong class="calibre2">Plugins</strong> dialog search box, search for <code class="literal">mmqgis</code>.</li><li class="listitem" value="3">Select the <strong class="calibre2">MMQGIS plugin</strong> and click on the <strong class="calibre2">Install plugin</strong> button.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec418" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">This recipe is simple. Here, we <a id="id658" class="calibre1"/>will load the layers and run the nearest neighbor algorithm within the MMQGIS plugin, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll import the MMQGIS plugin:<div><pre class="programlisting"><strong class="calibre2">from mmqgis import mmqgis_library as mmqgis</strong>
</pre></div></li><li class="listitem" value="2">Next, as shown here, we'll load all our datasets:<div><pre class="programlisting"><strong class="calibre2">srcPath = "/qgis_data/ufo/ufo-sightings.shp"</strong>
<strong class="calibre2">dstPath = "/qgis_data/ufo/major-cities.shp"</strong>
<strong class="calibre2">usPth = "/qgis_data/ufo/continental-us.shp"</strong>
<strong class="calibre2">output = "/qgis_data/ufo/alien_invasion.shp"</strong>
<strong class="calibre2">srcName = "UFO Sightings"</strong>
<strong class="calibre2">dstName = "Major Cities"</strong>
<strong class="calibre2">usName = "Continental US"</strong>
<strong class="calibre2">source = QgsVector(srcPath, srcName, "ogr")</strong>
<strong class="calibre2">dest = QgsVector(dstPath, dstName, "ogr")</strong>
<strong class="calibre2">us = QgsVector(usPath, usName, "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Finally, we'll run and load the algorithm, which will draw lines from each UFO sighting point to the nearest city:<div><pre class="programlisting"><strong class="calibre2">mmqgis.mmqgis_hub_distance(iface, srcName, dstName, \"NAME", "Miles", True, output, True)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec419" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">There are a couple of different nearest neighbor algorithms in QGIS, but the MMQGIS version is an excellent implementation and has the best visualization. Like the other recipes in this chapter, the plugin doesn't have an intentional Python API, so a good way to explore its functionality is to use the GUI interface before taking a look at the Python code. The following image shows the output, with UFO sightings represented by smaller points and hub lines leading to the cities, which are represented by larger, darker points.</p><div><img src="img/00057.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec144" class="calibre1"/>Creating a heat map</h1></div></div></div><p class="calibre9">A <strong class="calibre2">heat map</strong> is <a id="id659" class="calibre1"/>used to show the geographic clustering of data using a raster image that shows density. The clustering can also be weighed using a field in the data to not only show geographic density but also an intensity factor. In this recipe, we'll use earthquake point data to create a heat map of the impact of an earthquake and weigh the clustering by the earthquake's magnitude.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec420" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">This recipe requires no preparation.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec421" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will build a map <a id="id660" class="calibre1"/>with a worldwide base layer of countries and earthquake locations, both in GeoJSON. Next, we'll run the SAGA kernel density estimation algorithm to produce the heat map image. We'll create a layer from the output, add a color shader to it, and add it to the map.</p><p class="calibre9">To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll import the Python libraries that we'll need in the Python console:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">import processing</strong>
</pre></div></li><li class="listitem" value="2">Next, using the following code, we'll define our map layers and the output raster name:<div><pre class="programlisting"><strong class="calibre2">countries = "https://raw.githubusercontent.com/johan/\world.geo.json/master/countries.geo.json"</strong>
<strong class="calibre2">quakes = "https://geospatialpython.googlecode.com/\svn/quakes2014.geojson"</strong>
<strong class="calibre2">output = "/Users/joellawhead/qgis_data/rasters/heat.tif"</strong>
</pre></div></li><li class="listitem" value="3">Now <a id="id661" class="calibre1"/>we'll add the layers to the map:<div><pre class="programlisting"><strong class="calibre2">basemap = QgsVectorLayer(countries, "World", "ogr")</strong>
<strong class="calibre2">quakeLyr = QgsVectorLayer(quakes, "Earthquakes", "ogr")</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([quakeLyr, basemap])</strong>
</pre></div></li><li class="listitem" value="4">We need to get the extent of the earthquake layer for the Processing Toolbox algorithm to use:<div><pre class="programlisting"><strong class="calibre2">ext = quakeLyr.extent()</strong>
<strong class="calibre2">xmin = ext.xMinimum()</strong>
<strong class="calibre2">ymin = ext.yMinimum()</strong>
<strong class="calibre2">xmax = ext.xMaximum()</strong>
<strong class="calibre2">ymax = ext.xMaximum()</strong>
<strong class="calibre2">box = "%s,%s,%s,%s" % (xmin,xmax,ymin,ymax)</strong>
</pre></div></li><li class="listitem" value="5">Now, we can run the kernel density estimation algorithm by specifying the <code class="literal">mag</code> or magnitude field as our weighting factor:<div><pre class="programlisting"><strong class="calibre2">processing.runalg("saga:kerneldensityestimation",quakeLyr,"mag",10,0,0,box,1,output)</strong>
</pre></div></li><li class="listitem" value="6">Next, we load the output as a layer:<div><pre class="programlisting"><strong class="calibre2">heat = QgsRasterLayer(output, "Earthquake Heatmap")</strong>
</pre></div></li><li class="listitem" value="7">Then, we create the color ramp shader and apply it to the layer:<div><pre class="programlisting"><strong class="calibre2">algorithm = QgsContrastEnhancement.StretchToMinimumMaximum</strong>
<strong class="calibre2">limits = QgsRaster.ContrastEnhancementMinMax</strong>
<strong class="calibre2">heat.setContrastEnhancement(algorithm, limits)</strong>
<strong class="calibre2">s = QgsRasterShader() </strong>
<strong class="calibre2">c = QgsColorRampShader() </strong>
<strong class="calibre2">c.setColorRampType(QgsColorRampShader.INTERPOLATED) </strong>
<strong class="calibre2">i = [] </strong>
<strong class="calibre2">qri = QgsColorRampShader.ColorRampItem</strong>
<strong class="calibre2">i.append(qri(0, QColor(255,255,178,255), \</strong>
<strong class="calibre2">'Lowest Earthquake Impact')) </strong>
<strong class="calibre2">i.append(qri(0.106023, QColor(254,204,92,255), \</strong>
<strong class="calibre2">'Lower Earthquake Impact')) </strong>
<strong class="calibre2">i.append(qri(0.212045, QColor(253,141,60,255), \</strong>
<strong class="calibre2">'Moderate Earthquake Impact')) </strong>
<strong class="calibre2">i.append(qri(0.318068, QColor(240,59,32,255), \</strong>
<strong class="calibre2">'Higher Earthquake Impact'))</strong>
<strong class="calibre2">i.append(qri(0.42409, QColor(189,0,38,255), \</strong>
<strong class="calibre2">'Highest Earthquake Impact')) </strong>
<strong class="calibre2">c.setColorRampItemList(i) </strong>
<strong class="calibre2">s.setRasterShaderFunction(c) </strong>
<strong class="calibre2">ps = QgsSingleBandPseudoColorRenderer(heat.dataProvider(),\ 1,  s) </strong>
<strong class="calibre2">heat.setRenderer(ps) </strong>
</pre></div></li><li class="listitem" value="8">Finally, we<a id="id662" class="calibre1"/> add the <code class="literal">Heatmap</code> to our map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([heat])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec422" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The kernel density estimation algorithm<a id="id663" class="calibre1"/> looks at the point dataset and forms clusters. The higher the value, the denser is the cluster. The algorithm then increases values based on the weighting factor, which is the earthquake's magnitude. The output image is, of course, a grayscale geotiff, but we use the color ramp shader to make the visualization easier to understand. The following screenshot shows the expected output:</p><div><img src="img/00058.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec423" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">QGIS has a fantastic plugin available, called heat map, that works well on a wide variety of data automatically. However, it is written in C++ and does not have a Python API.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec145" class="calibre1"/>Creating a dot density map</h1></div></div></div><p class="calibre9">A dot density map<a id="id664" class="calibre1"/> uses point density to illustrate a field value within a polygon. We'll use this technique to illustrate population density in some US census bureau tracts.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec424" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the census tract layer and extract it to a directory named <code class="literal">census</code> in your <code class="literal">qgis_data</code> directory from <a class="calibre1" href="https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip">https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec425" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the<a id="id665" class="calibre1"/> census layer, create a memory layer, loop through the features in the census layer, calculate a random point within the feature for every 100 people, and finally add the point to the memory layer. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the QGIS <strong class="calibre2">Python Console</strong>, we'll import the <code class="literal">random</code> module:<div><pre class="programlisting"><strong class="calibre2">import random</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll load the census layer:<div><pre class="programlisting"><strong class="calibre2">src = "/Users/joellawhead/qgis_data/census/\</strong>
<strong class="calibre2">GIS_CensusTract_poly.shp"</strong>
<strong class="calibre2">tractLyr = QgsVectorLayer(src, "Census Tracts", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Then, we'll create our memory layer:<div><pre class="programlisting"><strong class="calibre2">popLyr =  QgsVectorLayer('Point?crs=epsg:4326', "Population" , "memory")</strong>
</pre></div></li><li class="listitem" value="4">We need the index for the population value:<div><pre class="programlisting"><strong class="calibre2">i = tractLyr.fieldNameIndex('POPULAT11')</strong>
</pre></div></li><li class="listitem" value="5">Now, we get our census layer's features as an iterator:<div><pre class="programlisting"><strong class="calibre2">features = tractLyr.getFeatures()</strong>
</pre></div></li><li class="listitem" value="6">We need a data provider for the memory layer so that we can edit it:<div><pre class="programlisting"><strong class="calibre2">vpr = popLyr.dataProvider()</strong>
</pre></div></li><li class="listitem" value="7">We'll create a list to store our random points:<div><pre class="programlisting"><strong class="calibre2">dotFeatures = []</strong>
</pre></div></li><li class="listitem" value="8">Then, we<a id="id666" class="calibre1"/> can loop through the features and calculate the density points:<div><pre class="programlisting"><strong class="calibre2">for feature in features:</strong>
<strong class="calibre2">  pop = feature.attributes()[i]</strong>
<strong class="calibre2">  density = pop / 100</strong>
<strong class="calibre2">  found = 0</strong>
<strong class="calibre2">  dots = []</strong>
<strong class="calibre2">  g = feature.geometry()</strong>
<strong class="calibre2">  minx =  g.boundingBox().xMinimum()</strong>
<strong class="calibre2">  miny =  g.boundingBox().yMinimum()</strong>
<strong class="calibre2">  maxx =  g.boundingBox().xMaximum()</strong>
<strong class="calibre2">  maxy =  g.boundingBox().yMaximum()</strong>
<strong class="calibre2">  while found &lt; density:</strong>
<strong class="calibre2">    x = random.uniform(minx,maxx)</strong>
<strong class="calibre2">    y = random.uniform(miny,maxy)</strong>
<strong class="calibre2">    pnt = QgsPoint(x,y)</strong>
<strong class="calibre2">    if g.contains(pnt):</strong>
<strong class="calibre2">      dots.append(pnt)</strong>
<strong class="calibre2">      found += 1</strong>
<strong class="calibre2">  geom = QgsGeometry.fromMultiPoint(dots)</strong>
<strong class="calibre2">  f = QgsFeature()</strong>
<strong class="calibre2">  f.setGeometry(geom)</strong>
<strong class="calibre2">  dotFeatures.append(f)</strong>
</pre></div></li><li class="listitem" value="9">Now, we can add our features to the memory layer using the following code and add them to the map in order to see the result:<div><pre class="programlisting"><strong class="calibre2">vpr.addFeatures(dotFeatures)</strong>
<strong class="calibre2">popLyr.updateExtents()</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers(\ [popLyr,tractLyr])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec426" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This approach <a id="id667" class="calibre1"/>is slightly inefficient; it uses a brute-force approach that can place randomly generated points outside irregular polygons. We use the feature's extents to contain the random points as close as possible and then use the geometry contains method to verify that the point is inside the polygon. The following screenshot shows a sample of the output:</p><div><img src="img/00059.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec146" class="calibre1"/>Collecting field data</h1></div></div></div><p class="calibre9">For decades, collecting<a id="id668" class="calibre1"/> field observation data from the field into a GIS required hours of manual data entry or, at best, loading data after the trip. Smartphones and laptops with cellular connections have revolutionzed this process. In this recipe, we'll use a simple but interesting geojson-based framework to enter information and a map location from any Internet-connected device with a web browser and update a map in QGIS.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec427" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">There is no preparation required for this recipe.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec428" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load a world boundaries layer and the field data layer onto a QGIS map, go to the field data mobile website and create an entry, and then refresh the QGIS map to see the update. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the QGIS <strong class="calibre2">Python Console</strong>, add the following geojson layers:<div><pre class="programlisting"><strong class="calibre2">wb = "https://raw.githubusercontent.com/johan/\ world.geo.json/master/countries.geo.json"</strong>
<strong class="calibre2">basemap = QgsVectorLayer(wb, "Countries", "ogr")</strong>
<strong class="calibre2">observations = \</strong>
<strong class="calibre2">QgsVectorLayer("http://bit.ly/QGISFieldApp", \</strong>
<strong class="calibre2">"Field Observations", "ogr")</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers(\ [basemap, observations])</strong>
</pre></div></li><li class="listitem" value="2">Now, in a <a id="id669" class="calibre1"/>browser on your computer, or preferably on a mobile device with a data connection, go to <a class="calibre1" href="http://geospatialpython.github.io/qgis/fieldwork.html">http://geospatialpython.github.io/qgis/fieldwork.html</a>. The application will ask you for permission to use your location, which you should temporarily allow for the program to work.</li><li class="listitem" value="3">Enter information in the form and click on the <strong class="calibre2">Send</strong> button.</li><li class="listitem" value="4">Verify that you can see the geojson data, including your submission, at <a class="calibre1" href="https://api.myjson.com/bins/3ztvz">https://api.myjson.com/bins/3ztvz</a>.</li><li class="listitem" value="5">Finally, update the map in QGIS by zooming or panning and locate your record.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec429" class="calibre1"/>How it works...</h2></div></div></div><pre> code for the mobile page on GitHub.com (<a class="calibre1" href="https://github.com/GeospatialPython/qgis">https://github.com/GeospatialPython/qgis</a>).</pre><p class="calibre9">The following image shows the mobile field application on an iPhone:</p><div><img src="img/00060.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p><p class="calibre9">This image shows<a id="id671" class="calibre1"/> how the corresponding data looks in QGIS:</p><div><img src="img/00061.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec147" class="calibre1"/>Computing road slope using elevation data</h1></div></div></div><p class="calibre9">A common <a id="id672" class="calibre1"/>geospatial workflow is to assign raster values to a coincident vector layer so that you can style or perform further analysis on the vector layer. This<a id="id673" class="calibre1"/> recipe will use this concept to illustrate the steepness of a road using color by mapping values to the road vector from a slope raster.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec430" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download a zipped directory from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/road.zip">https://geospatialpython.googlecode.com/svn/road.zip</a> and place the directory, named <code class="literal">road</code>, in your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec431" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll start with a DEM and compute its slope. Then, we'll load a road vector layer and break it into interval lengths of 500 meters. Next, we'll load the layer and style it using green, yellow, and red values for each segment to show the range of steepness. We'll overlay this layer on a hillshade of the DEM for a nice visualization. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the QGIS processing module, the QGIS constants module, the Qt GUI module, and the os module in the QGIS <strong class="calibre2">Python Console</strong>:<div><pre class="programlisting"><strong class="calibre2">from qgis.core import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">import processing</strong>
</pre></div></li><li class="listitem" value="2">Now, we need to set the coordinate reference system (CRS) of our project to that of our digital elevation model (DEM), which is EPSG code 26910, so we can work with the data in meters instead of decimal degrees:<div><pre class="programlisting"><strong class="calibre2">myCrs = QgsCoordinateReferenceSystem(26910, QgsCoordinateReferenceSystem.EpsgCrsId)</strong>
<strong class="calibre2">iface.mapCanvas().mapRenderer().setDestinationCrs(myCrs)</strong>
<strong class="calibre2">iface.mapCanvas().setMapUnits(QGis.Meters)</strong>
<strong class="calibre2">iface.mapCanvas().refresh()</strong>
</pre></div></li><li class="listitem" value="3">Now, we'll set the paths of all the layers. For this, we'll use intermediate layers that we create so that we can change them in one place, if needed:<div><pre class="programlisting"><strong class="calibre2">src_dir = "/Users/joellawhead/qgis_data/road/" </strong>
<strong class="calibre2">dem = os.path.join(src_dir, "dem.asc")</strong>
<strong class="calibre2">road = os.path.join(src_dir, "road.shp")</strong>
<strong class="calibre2">slope = os.path.join(src_dir, "slope.tif")</strong>
<strong class="calibre2">segRoad = os.path.join(src_dir, "segRoad.shp")</strong>
<strong class="calibre2">steepness = os.path.join(src_dir, "steepness.shp")</strong>
<strong class="calibre2">hillshade = os.path.join(src_dir, "hillshade.tif") </strong>
</pre></div></li><li class="listitem" value="4">We will <a id="id674" class="calibre1"/>load the DEM and road layer so that we can get the extents for the processing algorithms:<div><pre class="programlisting"><strong class="calibre2">demLyr = QgsRasterLayer(dem, "DEM")</strong>
<strong class="calibre2">roadLyr = QgsVectorLayer(road, "Road", "ogr")</strong>
</pre></div></li><li class="listitem" value="5">Now, build<a id="id675" class="calibre1"/> a string with the DEM extent using the following code:<div><pre class="programlisting"><strong class="calibre2">ext = demLyr.extent()</strong>
<strong class="calibre2">xmin = ext.xMinimum()</strong>
<strong class="calibre2">ymin = ext.yMinimum()</strong>
<strong class="calibre2">xmax = ext.xMaximum()</strong>
<strong class="calibre2">ymax = ext.yMaximum()</strong>
<strong class="calibre2">demBox = "%s,%s,%s,%s" % (xmin,xmax,ymin,ymax)</strong>
</pre></div></li><li class="listitem" value="6">Next, compute the slope grid:<div><pre class="programlisting"><strong class="calibre2">processing.runalg("grass:r.slope",dem,0,0,1,0,True,\ demBox,0,slope)</strong>
</pre></div></li><li class="listitem" value="7">Then, we can get the extent of the road layer as a string:<div><pre class="programlisting"><strong class="calibre2">ext = roadLyr.extent()</strong>
<strong class="calibre2">xmin = ext.xMinimum()</strong>
<strong class="calibre2">ymin = ext.yMinimum()</strong>
<strong class="calibre2">xmax = ext.xMaximum()</strong>
<strong class="calibre2">ymax = ext.yMaximum()</strong>
<strong class="calibre2">roadBox = "%s,%s,%s,%s" % (xmin,xmax,ymin,ymax)</strong>
</pre></div></li><li class="listitem" value="8">Now, we'll break the road layer into segments of 500 meters to have a meaningful length for the slope valuation:<div><pre class="programlisting"><strong class="calibre2">processing.runalg("grass:v.split.length",road,500,\</strong>
<strong class="calibre2">roadBox,-1,0.0001,0,segRoad)</strong>
</pre></div></li><li class="listitem" value="9">Next, we'll add the slope and segmented layer to the map interface for the next algorithm, but we'll keep them hidden from view using the boolean <code class="literal">False</code> option in the <code class="literal">addMapLayers</code> method:<div><pre class="programlisting"><strong class="calibre2">slopeLyr = QgsRasterLayer(slope, "Slope")</strong>
<strong class="calibre2">segRoadLyr = QgsVectorLayer(segRoad, \</strong>
<strong class="calibre2">"Segmented Road", "ogr")</strong>
<strong class="calibre2">QgsMapLayerRegistry</strong>
<strong class="calibre2">.instance().addMapLayers([\ segRoadLyr,slopeLyr], False)</strong>
</pre></div></li><li class="listitem" value="10">Now, we can transfer the slope values to the segmented road layer in order to create the steepness layer:<div><pre class="programlisting"><strong class="calibre2">processing.runalg("saga:addgridvaluestoshapes",\ segRoad,slope,0,steepness)</strong>
</pre></div></li><li class="listitem" value="11">Now, we <a id="id676" class="calibre1"/>can load the steepness layer:<div><pre class="programlisting"><strong class="calibre2">steepLyr = QgsVectorLayer(steepness, \ "Road Gradient", "ogr")</strong>
</pre></div></li><li class="listitem" value="12">We'll style<a id="id677" class="calibre1"/> the steepness layer to use the stoplight red, yellow, and green values, with red being the steepest:<div><pre class="programlisting"><strong class="calibre2">roadGrade = ( ("Rolling Hill", 0.0, 20.0, "green"), </strong>
<strong class="calibre2">("Steep", 20.0, 40.0, "yellow"),</strong>
<strong class="calibre2">("Very Steep", 40.0, 90.0, "red"))</strong>
<strong class="calibre2">ranges = []</strong>
<strong class="calibre2">for label, lower, upper, color in roadGrade:</strong>
<strong class="calibre2">    sym = QgsSymbolV2.defaultSymbol(steepLyr.geometryType())</strong>
<strong class="calibre2">    sym.setColor(QColor(color))</strong>
<strong class="calibre2">    sym.setWidth(3.0)</strong>
<strong class="calibre2">    rng = QgsRendererRangeV2(lower, upper, sym, label)</strong>
<strong class="calibre2">    ranges.append(rng)</strong>
<strong class="calibre2">    </strong>
<strong class="calibre2">field = "slope"</strong>
<strong class="calibre2">renderer = QgsGraduatedSymbolRendererV2(field, ranges)</strong>
<strong class="calibre2">steepLyr.setRendererV2(renderer)</strong>
</pre></div></li><li class="listitem" value="13">Next, we'll create a hillshade from the DEM for visualization and load everything onto the map:<div><pre class="programlisting"><strong class="calibre2">processing.runalg("saga:analyticalhillshading",dem,\</strong>
<strong class="calibre2">0,315,45,4,hillshade)</strong>
<strong class="calibre2">hs = QgsRasterLayer(hillshade, "Terrain")</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([steepLyr, hs])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec432" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">For each of our 500-meter line segments, the algorithm averages the underlying slope values. This workflow<a id="id678" class="calibre1"/> is fairly simple and also provides all the building blocks you need for a more complex version. While performing calculations that <a id="id679" class="calibre1"/>involve measurements over a relatively small area, using projected data is the best option. The following image shows how the output looks:</p><div><img src="img/00062.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec148" class="calibre1"/>Geolocating photos on the map</h1></div></div></div><p class="calibre9">Photos <a id="id680" class="calibre1"/>taken with GPS-enabled cameras, including smartphones, store location information in the header of the file, in a format called EXIF tags. These tags are largely based on the same <a id="id681" class="calibre1"/>header tags used by the TIFF image standard. In this recipe, we'll use these tags to create locations on a map for some photos and provide links to open them.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec433" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download some sample geotagged photos from <a class="calibre1" href="https://github.com/GeospatialPython/qgis/blob/gh-pages/photos.zip?raw=true">https://github.com/GeospatialPython/qgis/blob/gh-pages/photos.zip?raw=true</a> and place them in a directory named <code class="literal">photos</code> in your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec434" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">QGIS requires the <a id="id682" class="calibre1"/>
<strong class="calibre2">Python Imaging Library</strong> (<strong class="calibre2">PIL</strong>), which should already be included with your installation. PIL can parse EXIF tags. We will gather the filenames of<a id="id683" class="calibre1"/> the photos, parse the location information, convert it to decimal degrees, create the point vector layer, add the<a id="id684" class="calibre1"/> photo locations, and add an action link to the attributes. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">In the QGIS <strong class="calibre2">Python Console</strong>, import the libraries that we'll need, including k for parsing image data and the <code class="literal">glob</code> module for doing wildcard file searches:<div><pre class="programlisting"><strong class="calibre2">import glob</strong>
<strong class="calibre2">import Image</strong>
<strong class="calibre2">from ExifTags import TAGS</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll create a function that can parse the header data:<div><pre class="programlisting"><strong class="calibre2">def exif(img):</strong>
<strong class="calibre2">    exif_data = {}</strong>
<strong class="calibre2">    try:    </strong>
<strong class="calibre2">        i = Image.open(img)</strong>
<strong class="calibre2">        tags = i._getexif()</strong>
<strong class="calibre2">        for tag, value in tags.items():</strong>
<strong class="calibre2">            decoded = TAGS.get(tag, tag)</strong>
<strong class="calibre2">            exif_data[decoded] = value</strong>
<strong class="calibre2">    except:</strong>
<strong class="calibre2">        pass</strong>
<strong class="calibre2">    return exif_data</strong>
</pre></div></li><li class="listitem" value="3">Now, we'll create a function that can convert degrees-minute-seconds to decimal degrees, which is how coordinates are stored in JPEG images:<div><pre class="programlisting"><strong class="calibre2">def dms2dd(d, m, s, i):</strong>
<strong class="calibre2">    sec = float((m * 60) + s)</strong>
<strong class="calibre2">    dec = float(sec / 3600)</strong>
<strong class="calibre2">    deg = float(d + dec)</strong>
<strong class="calibre2">    if i.upper() == 'W':</strong>
<strong class="calibre2">        deg = deg * -1</strong>
<strong class="calibre2">    elif i.upper() == 'S':</strong>
<strong class="calibre2">        deg = deg * -1</strong>
<strong class="calibre2">    return float(deg)</strong>
</pre></div></li><li class="listitem" value="4">Next, we'll define a<a id="id685" class="calibre1"/> function to parse the location data from the header data:<div><pre class="programlisting"><strong class="calibre2">def gps(exif):</strong>
<strong class="calibre2">    lat = None</strong>
<strong class="calibre2">    lon = None</strong>
<strong class="calibre2">    if exif['GPSInfo']:        </strong>
<strong class="calibre2">        # Lat</strong>
<strong class="calibre2">        coords = exif['GPSInfo']</strong>
<strong class="calibre2">        i = coords[1]</strong>
<strong class="calibre2">        d = coords[2][0][0]</strong>
<strong class="calibre2">        m = coords[2][1][0]</strong>
<strong class="calibre2">        s = coords[2][2][0]</strong>
<strong class="calibre2">        lat = dms2dd(d, m ,s, i)</strong>
<strong class="calibre2">        # Lon</strong>
<strong class="calibre2">        i = coords[3]</strong>
<strong class="calibre2">        d = coords[4][0][0]</strong>
<strong class="calibre2">        m = coords[4][1][0]</strong>
<strong class="calibre2">        s = coords[4][2][0]</strong>
<strong class="calibre2">        lon = dms2dd(d, m ,s, i)</strong>
<strong class="calibre2">    return lat, lon</strong>
</pre></div></li><li class="listitem" value="5">Next, we'll <a id="id686" class="calibre1"/>loop through the <code class="literal">photos</code> directory, get the filenames, parse the location information, and build a simple dictionary to store the information, as follows:<div><pre class="programlisting"><strong class="calibre2">photos = {}</strong>
<strong class="calibre2">photo_dir = "/Users/joellawhead/qgis_data/photos/"</strong>
<strong class="calibre2">files = glob.glob(photo_dir + "*.jpg")</strong>
<strong class="calibre2">for f in files:</strong>
<strong class="calibre2">    e = exif(f)</strong>
<strong class="calibre2">    lat, lon = gps(e)</strong>
<strong class="calibre2">    photos[f] = [lon, lat]</strong>
</pre></div></li><li class="listitem" value="6">Now, we'll set up the vector layer for editing:<div><pre class="programlisting"><strong class="calibre2">lyr_info = "Point?crs=epsg:4326&amp;field=photo:string(75)"  </strong>
<strong class="calibre2">vectorLyr =  QgsVectorLayer(lyr_info, \"Geotagged Photos" , "memory")</strong>
<strong class="calibre2">vpr = vectorLyr.dataProvider()</strong>
</pre></div></li><li class="listitem" value="7">We'll add the photo details to the vector layer:<div><pre class="programlisting"><strong class="calibre2">features = []</strong>
<strong class="calibre2">for pth, p in photos.items():</strong>
<strong class="calibre2">    lon, lat = p</strong>
<strong class="calibre2">    pnt = QgsGeometry.fromPoint(QgsPoint(lon,lat))</strong>
<strong class="calibre2">    f = QgsFeature()</strong>
<strong class="calibre2">    f.setGeometry(pnt)</strong>
<strong class="calibre2">    f.setAttributes([pth])</strong>
<strong class="calibre2">    features.append(f)</strong>
<strong class="calibre2">vpr.addFeatures(features)</strong>
<strong class="calibre2">vectorLyr.updateExtents()</strong>
</pre></div></li><li class="listitem" value="8">Now, we <a id="id687" class="calibre1"/>can add the layer to the map and<a id="id688" class="calibre1"/> make the active layer:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(vectorLyr)</strong>
<strong class="calibre2">iface.setActiveLayer(vectorLyr)</strong>
<strong class="calibre2">activeLyr = iface.activeLayer()</strong>
</pre></div></li><li class="listitem" value="9">Finally, we'll add an action that allows you to click on it and open the photo:<div><pre class="programlisting"><strong class="calibre2">actions = activeLyr.actions() </strong>
<strong class="calibre2">actions.addAction(QgsAction.OpenUrl, "Photos", \'[% "photo" %]')</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec435" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Using the included PIL EXIF parser, getting location information and adding it to a vector layer is relatively straightforward. The interesting part of this recipe is the QGIS action to open the photo. This action is a default option for opening a URL. However, you can also use Python expressions as actions to perform a variety of tasks. The following screenshot shows an example of the data visualization and photo popup:</p><div><img src="img/00063.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec436" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">Another plugin called <a id="id689" class="calibre1"/>Photo2Shape<a id="id690" class="calibre1"/> is available, but it requires you to install an external EXIF tag parser.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec149" class="calibre1"/>Image change detection</h1></div></div></div><p class="calibre9">Change detection<a id="id691" class="calibre1"/> allows you to automatically highlight the differences between two images in the same area if they are properly orthorectified. In this recipe, we'll do a simple difference change detection on two images, which are several<a id="id692" class="calibre1"/> years apart, to see the differences in urban development and the natural environment.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec437" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You can download the two images for this recipe from <a class="calibre1" href="https://github.com/GeospatialPython/qgis/blob/gh-pages/change-detection.zip?raw=true">https://github.com/GeospatialPython/qgis/blob/gh-pages/change-detection.zip?raw=true</a> and put them in a directory named <code class="literal">change-detection</code> in the <code class="literal">rasters</code> directory of your <code class="literal">qgis_data</code> directory. Note that the file is 55 megabytes, so it may take several minutes to download.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec438" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll use the QGIS raster calculator to subtract the images in order to get the difference, which will highlight significant changes. We'll also add a color ramp shader to the output in order to visualize the changes. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the libraries that we need in to the QGIS console:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from qgis.analysis import *</strong>
</pre></div></li><li class="listitem" value="2">Now, we'll set up the path names and raster names for our images:<div><pre class="programlisting"><strong class="calibre2">before = "/Users/joellawhead/qgis_data/rasters/change-detection/before.tif"</strong>
<strong class="calibre2">after = "/Users/joellawhead/qgis_data/rasters/change-detection/after.tif"</strong>
<strong class="calibre2">beforeName = "Before"</strong>
<strong class="calibre2">afterName = "After"</strong>
</pre></div></li><li class="listitem" value="3">Next, we'll <a id="id693" class="calibre1"/>establish our images as raster layers:<div><pre class="programlisting"><strong class="calibre2">beforeRaster = QgsRasterLayer(before, beforeName)</strong>
<strong class="calibre2">afterRaster = QgsRasterLayer(after, afterName)</strong>
</pre></div></li><li class="listitem" value="4">Then, we can build the calculator entries:<div><pre class="programlisting"><strong class="calibre2">beforeEntry = QgsRasterCalculatorEntry()</strong>
<strong class="calibre2">afterEntry = QgsRasterCalculatorEntry()</strong>
<strong class="calibre2">beforeEntry.raster = beforeRaster</strong>
<strong class="calibre2">afterEntry.raster = afterRaster</strong>
<strong class="calibre2">beforeEntry.bandNumber = 1</strong>
<strong class="calibre2">afterEntry.bandNumber = 2</strong>
<strong class="calibre2">beforeEntry.ref = beforeName + "@1"</strong>
<strong class="calibre2">afterEntry.ref = afterName + "@2"</strong>
<strong class="calibre2">entries = [afterEntry, beforeEntry]</strong>
</pre></div></li><li class="listitem" value="5">Now, we'll set up the simple expression that does the math for remote sensing:<div><pre class="programlisting"><strong class="calibre2">exp = "%s - %s" % (afterEntry.ref, beforeEntry.ref)</strong>
</pre></div></li><li class="listitem" value="6">Then, we can set up the output file path, the raster extent, and pixel width and height:<div><pre class="programlisting"><strong class="calibre2">output = "/Users/joellawhead/qgis_data/rasters/change-detection/change.tif"</strong>
<strong class="calibre2">e = beforeRaster.extent()</strong>
<strong class="calibre2">w = beforeRaster.width()</strong>
<strong class="calibre2">h = beforeRaster.height()</strong>
</pre></div></li><li class="listitem" value="7">Now, we perform the calculation:<div><pre class="programlisting"><strong class="calibre2">change = QgsRasterCalculator(exp, output, "GTiff", e, w, h, entries)</strong>
<strong class="calibre2">change.processCalculation()</strong>
</pre></div></li><li class="listitem" value="8">Finally, we'll <a id="id694" class="calibre1"/>load the output as a layer, create the color ramp shader, apply it to the layer, and add it to the map, as shown here:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsRasterLayer(output, "Change")</strong>
<strong class="calibre2">algorithm = QgsContrastEnhancement.StretchToMinimumMaximum</strong>
<strong class="calibre2">limits = QgsRaster.ContrastEnhancementMinMax</strong>
<strong class="calibre2">lyr.setContrastEnhancement(algorithm, limits)</strong>
<strong class="calibre2">s = QgsRasterShader() </strong>
<strong class="calibre2">c = QgsColorRampShader() </strong>
<strong class="calibre2">c.setColorRampType(QgsColorRampShader.INTERPOLATED) </strong>
<strong class="calibre2">i = [] </strong>
<strong class="calibre2">qri = QgsColorRampShader.ColorRampItem</strong>
<strong class="calibre2">i.append(qri(0, QColor(0,0,0,0), 'NODATA')) </strong>
<strong class="calibre2">i.append(qri(-101, QColor(123,50,148,255), 'Significant Itensity Decrease')) </strong>
<strong class="calibre2">i.append(qri(-42.2395, QColor(194,165,207,255), 'Minor Itensity Decrease')) </strong>
<strong class="calibre2">i.append(qri(16.649, QColor(247,247,247,0), 'No Change'))</strong>
<strong class="calibre2">i.append(qri(75.5375, QColor(166,219,160,255), 'Minor Itensity Increase')) </strong>
<strong class="calibre2">i.append(qri(135, QColor(0,136,55,255), 'Significant Itensity Increase'))</strong>
<strong class="calibre2">c.setColorRampItemList(i) </strong>
<strong class="calibre2">s.setRasterShaderFunction(c) </strong>
<strong class="calibre2">ps = QgsSingleBandPseudoColorRenderer(lyr.dataProvider(), 1,  s) </strong>
<strong class="calibre2">lyr.setRenderer(ps) </strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec439" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The concept is simple. We subtract the older image data from the new image data. Concentrating on urban areas tends to be highly reflective and results in higher image pixel values. If a building <a id="id695" class="calibre1"/>is added in the new image, it will be brighter than its surroundings. If a building is removed, the new image will be darker in that area. The same holds true for vegetation, to some extent.</p></div></div></body></html>