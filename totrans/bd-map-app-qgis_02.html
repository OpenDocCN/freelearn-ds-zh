<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;The QGIS Python Console"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. The QGIS Python Console</h1></div></div></div><p class="calibre8">In this chapter, we will look at the ways in which you can use the QGIS Python Console as a geospatial development tool. We will also use the console as a looking-glass to examine the world of QGIS programming. In particular, we will learn the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Explore the ways in which the console can be used to develop and execute Python code</li><li class="listitem">Learn how to write Python scripts using the console's built-in source code editor</li><li class="listitem">Discover various tips and techniques to work with the QGIS Console</li><li class="listitem">Figure out how to manipulate the current project within QGIS using Python commands</li><li class="listitem">Access geospatial data and perform geospatial calculations using the console</li><li class="listitem">Use various QGIS user-interface elements within our Python programs</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;The QGIS Python Console">
<div class="book" title="Using the console"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec11" class="calibre1"/>Using the console</h1></div></div></div><p class="calibre8">While you briefly used the QGIS Console in the previous chapter, it is worth examining the QGIS Console<a id="id66" class="calibre1"/> window in more detail, so that you are aware of the various features that are available.</p><p class="calibre8">If you don't already have it open, choose the <span class="strong"><strong class="calibre9">Python Console</strong></span> item from the <span class="strong"><strong class="calibre9">Plugins</strong></span> menu to open the console. The following screenshot shows the various parts of the console window:</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Using the console" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Let's take a closer look <a id="id67" class="calibre1"/>at these various parts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <span class="strong"><strong class="calibre9">Clear console</strong></span> button wipes out the contents of the interpreter log</li><li class="listitem">The <span class="strong"><strong class="calibre9">Import Class</strong></span> pop up contains shortcuts to import some commonly-used PyQGIS classes<div class="mediaobject"><img src="../images/00011.jpeg" alt="Using the console" class="calibre11"/></div><p class="calibre25"> </p><p class="calibre26">These are equivalent to typing <code class="email">import Processing</code>, <code class="email">from PyQt4.QtCore import *</code>, and <code class="email">from PyQt4.QtGui import *</code>.</p></li><li class="listitem">The <span class="strong"><strong class="calibre9">Run command</strong></span> button simply executes the command you have typed in the Python shell field<div class="note" title="Note"><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre8">Of course, you can also run the entered command by pressing the <span class="strong"><em class="calibre10">Return</em></span> key, so this command is only useful if you really want to run a command using the mouse.</p></div></li><li class="listitem">The <span class="strong"><strong class="calibre9">Show editor</strong></span> button shows or hides the built-in source code editor. We'll look at this shortly</li><li class="listitem">The <span class="strong"><strong class="calibre9">Settings</strong></span> button displays the console's Settings window, allowing you to customize the way the console looks and behaves</li><li class="listitem">The <span class="strong"><strong class="calibre9">Help</strong></span> button brings up the built-in help viewer page, which contains useful information about how to use the console</li><li class="listitem">The <span class="strong"><strong class="calibre9">Python Shell</strong></span> field is where you type your Python commands and other input</li><li class="listitem">The <span class="strong"><strong class="calibre9">Interpreter Log</strong></span> shows a complete history of the commands you have typed and the Python interpreter's output</li></ul></div><p class="calibre8">As we've already <a id="id68" class="calibre1"/>seen, you can type Python commands in the shell and press the <span class="strong"><em class="calibre10">Return</em></span> key to execute them. The commands you type, along with the Python interpreter's output, appear in the Interpreter Log.</p><p class="calibre8">The Python Shell has been designed to make it easier to work with Python interactively. The following features are currently supported:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Pressing the up and down arrow keys will move through the command history, making it easy to re-enter the Python commands you typed earlier.</li><li class="listitem">You can display a list of previously-entered commands by pressing <span class="strong"><em class="calibre10">Ctrl</em></span> + <span class="strong"><em class="calibre10">Shift</em></span> + <span class="strong"><em class="calibre10">Space</em></span> (<span class="strong"><em class="calibre10">command</em></span> + <span class="strong"><em class="calibre10">Shift</em></span> + <span class="strong"><em class="calibre10">Space</em></span> on Mac).</li><li class="listitem">If you select some text in the Interpreter Log, you can use the <span class="strong"><strong class="calibre9">Enter Selected</strong></span> command to move that text to the shell and execute it. This command is available in the console's pop-up menu, or it can be accessed by pressing <span class="strong"><em class="calibre10">Ctrl</em></span> + <span class="strong"><em class="calibre10">E</em></span> (<span class="strong"><em class="calibre10">command</em></span> + <span class="strong"><em class="calibre10">E</em></span> if you are running Mac OS X).</li><li class="listitem">The Python Shell supports <a id="id69" class="calibre1"/><span class="strong"><strong class="calibre9">auto-completion</strong></span>. As you type, a pop-up menu appears, showing you the matching class, function, and method names within the PyQGIS and PyQt APIs. You can then press the up and down arrow keys to select the exact name you want, and press the <span class="strong"><em class="calibre10">Tab</em></span> key to select it.</li><li class="listitem">When you type an opening parenthesis, the console automatically enters the closing parenthesis for you. You can turn this off by using the <span class="strong"><strong class="calibre9">Settings</strong></span> window if you wish.</li><li class="listitem">When you type <code class="email">from XXX</code>, the console enters the word <code class="email">import</code> for you automatically. Once again, you can turn this off in the <span class="strong"><strong class="calibre9">Settings</strong></span> window if you don't like this behavior.</li><li class="listitem">When you type the opening parenthesis for a function or method, the C++ signature for that function or method will be displayed. Despite being in C++ format, this tells you which parameters are expected and the type of value being returned.</li><li class="listitem">You can type <code class="email">_api</code> into the shell; your web browser will open the PyQGIS API reference documentation. Similarly, if you type <code class="email">_pyqgis</code>, your web browser will display the PyQGIS Developer Cookbook.</li></ul></div><p class="calibre8">While typing commands into the Python Shell is a useful way of exploring the QGIS Python libraries, and is good for one-off commands, it quickly gets tedious if you have to type multiple lines <a id="id70" class="calibre1"/>of Python text or repeat the same set of commands over and over. After all, this is why we store Python code in <code class="email">.py</code> files and execute them, rather than just typing everything into the Python command-line interface.</p><p class="calibre8">The QGIS Console comes with its own editor, allowing you to write Python scripts and execute them directly within the console. Let's take a quick look at how this works.</p><p class="calibre8">With the QGIS Console open, click on the <span class="strong"><strong class="calibre9">Show Editor</strong></span> icon (<span class="strong"><img src="../images/00012.jpeg" alt="Using the console" class="calibre27"/></span>). The console window will be split in half, with the Python source code editor now taking up the right-hand side of the window:</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Using the console" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The various toolbar icons provide standard editing behavior such as loading and saving files, copying and pasting text, checking syntax, and executing your script:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Using the console" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">You'll probably want to memorize the top three icons as there are currently no keyboard shortcuts to open <a id="id71" class="calibre1"/>and save Python scripts.</p><p class="calibre8">Let's use the console editor to create a simple Python program and run it. With a QGIS project loaded, type the following into the editor:</p><div class="informalexample"><pre class="programlisting">for layer in iface.legendInterface().layers():
    print layer.name() </pre></div><p class="calibre8">As you can probably guess, this program prints out the names of the various layers within the current project. To run this program, save it by clicking on the <span class="strong"><strong class="calibre9">Save As...</strong></span> toolbar icon; then, either click on the <span class="strong"><strong class="calibre9">Run script</strong></span> toolbar icon (<span class="strong"><img src="../images/00015.jpeg" alt="Using the console" class="calibre27"/></span>), or type the keyboard shortcut, <span class="strong"><em class="calibre10">Ctrl</em></span> + <span class="strong"><em class="calibre10">Shift</em></span> + <span class="strong"><em class="calibre10">E</em></span> (that's <span class="strong"><em class="calibre10">command</em></span> + <span class="strong"><em class="calibre10">Shift</em></span> + <span class="strong"><em class="calibre10">E</em></span> on Mac). You should see something like the following appear in the Interpreter Log:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt;&gt;&gt; execfile(u'/.../tmp1NR24f.py'.encode('utf-8'))</strong></span>
<span class="strong"><strong class="calibre9">water</strong></span>
<span class="strong"><strong class="calibre9">urban</strong></span>
<span class="strong"><strong class="calibre9">basemap</strong></span>
</pre></div><p class="calibre8">Note that QGIS uses the <a id="id72" class="calibre1"/>
<code class="email">execfile()</code> function (which is part of the Python standard library) to execute your script.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre8">If your program didn't display the names of any layers, make sure you have a project loaded with at least one layer. In this example, we've used the example project we created in the previous chapter, which had three layers in it.</p></div><p class="calibre8">Of course, there is a lot more that we can do with the QGIS Console and its built-in Python editor, and we'll be using it to do useful work shortly. Before we do, though, there are two final things you should know about the QGIS Console.</p><p class="calibre8">Firstly, the console<a id="id73" class="calibre1"/> itself is written in Python using PyQt and the <code class="email">PyQScintilla2</code> editor. You can learn a lot about how QGIS has been implemented by looking through the source code to the console, which is available at <a class="calibre1" href="https://github.com/qgis/QGIS/tree/master/python/console">https://github.com/qgis/QGIS/tree/master/python/console</a>.</p><p class="calibre8">The second thing you should know is that the console is implemented as a Qt "Dockable" window; that is, it can be dragged into a pane within the main QGIS window. If you click and hold the console's title bar, you can drag it inside the main window, as shown in the following illustration:</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Using the console" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The console can be moved into any of the existing panes within the QGIS window, and it will stay there until you move it out.</p><p class="calibre8">To turn the<a id="id74" class="calibre1"/> console into a window again, click on the title bar and drag it out of the QGIS window. Alternatively, you can double-click on the console's title bar to switch between having it as a standalone window or a docked pane.</p><p class="calibre8">This docking behavior can be annoying if you're working on a small screen, where you can accidentally dock the console window while moving it out of the way so you can see what is beneath it. Fortunately, since the QGIS Console is implemented in PyQt, you can disable this quite easily by running the following Python code:</p><div class="informalexample"><pre class="programlisting">from console import console
from PyQt4.QtCore import Qt
console._console.setAllowedAreas(Qt.DockWidgetAreas(Qt.NoDockWidgetArea))</pre></div><p class="calibre8">If you want, you can create a startup script that automatically shows the console and makes it nondockable whenever QGIS starts up. The startup script is stored in a hidden directory in your user or home folder. Using your file manager, look for a hidden directory named <code class="email">.qgis2</code> (or <code class="email">.qgis</code>, depending on which version of QGIS you are running) in your user or home directory (for Mac OS X, you can use the <span class="strong"><strong class="calibre9">Go to Folder...</strong></span> item in the Finder's <span class="strong"><strong class="calibre9">Go</strong></span> menu). Inside this directory, there will be a subdirectory named <code class="email">python</code>. Inside<a id="id75" class="calibre1"/> the <code class="email">python</code> directory, create a file named <code class="email">startup.py</code> and place the following into this file:</p><div class="informalexample"><pre class="programlisting">from console import console
from PyQt4.QtCore import Qt
console.show_console()
console._console.setAllowedAreas(Qt.DockWidgetAreas(Qt.NoDockWidgetArea))</pre></div><p class="calibre8">As you can see, the only thing we changed was to add a call to <code class="email">console.show_console()</code> to open the console window when QGIS starts.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">If the console is currently docked, this script won't undock it, although it will prevent you from accidentally docking the console again.</p></div></div></div>
<div class="book" title="Working with geospatial data in the console"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec12" class="calibre1"/>Working with geospatial data in the console</h1></div></div></div><p class="calibre8">So far, we have used the QGIS Console as a glorified Python interpreter, running standard Python programs and manipulating the QGIS user interface. But QGIS is a Geographical Information System (GIS), and one of the main uses of a GIS is to manipulate and <a id="id76" class="calibre1"/>query geospatial data. So, let's write some Python code to work with geospatial data directly within the QGIS<a id="id77" class="calibre1"/> Console.</p><p class="calibre8">In the previous chapter, we loaded three shapefiles into a QGIS project using Python. Here is a typical instruction we used to load a shapefile into a QGIS map layer:</p><div class="informalexample"><pre class="programlisting">layer = iface.addVectorLayer("/path/to/shapefile.shp", "layer_name", "ogr")</pre></div><p class="calibre8">While this is useful if you want to create a QGIS project programmatically, you may just want to load a shapefile so you can analyze its contents, without putting the data into a map layer. To do this, we have to get an appropriate<a id="id78" class="calibre1"/> <span class="strong"><strong class="calibre9">data provider</strong></span> and ask it to open the shapefile, like this:</p><div class="informalexample"><pre class="programlisting">registry = QgsProviderRegistry.instance()
provider = registry.provider("ogr","/path/to/shapefile.shp")
if not provider.isValid():
    print "Invalid shapefile."
    return</pre></div><p class="calibre8">The <code class="email">isValid()</code> method will return <code class="email">False</code> if the shapefile cannot be loaded; this allows us to fail gracefully if there is an error.</p><p class="calibre8">Once we have the data provider, we can ask it for the list of fields used to hold the attribute values for each of the shapefile's features:</p><div class="informalexample"><pre class="programlisting">for field in provider.fields():
      print field.name(), field.typeName()</pre></div><p class="calibre8">We can also scan through the features within the shapefile using a <code class="email">QgsFeatureRequest</code> object. For example:</p><div class="informalexample"><pre class="programlisting">for feature in provider.getFeatures(QgsFeatureRequest()):
    print feature.attribute("name")</pre></div><p class="calibre8">Of course, this is just a taste of what can be done using the QGIS libraries to query and manipulate <a id="id79" class="calibre1"/>geospatial data. However, let's use what we've learned to build a simple program that calculates and displays information about the contents of a shapefile. Shapefiles hold geospatial features such as polygons, lines and points, and each feature can have any number of attributes associated with it. We'll write a program that opens and scans through a shapefile, identifying the features and calculating the length of each line feature and the area of each polygon feature. We'll <a id="id80" class="calibre1"/>also calculate the total length and area across all the features.</p><p class="calibre8">One of the challenges we'll have to deal with is the fact that the shapefile can be in any map projection. This means that our calculation of the area and length has to take the map projection into account; if, for example, we simply calculated the linear length of a feature in a shapefile that uses the EPSG 4326 projection (that is, lat/long coordinates), then the calculated length will be in degrees of latitude and longitude—which is a completely meaningless figure. We'll want to calculate the feature lengths in kilometers, and the areas in square kilometers. This is possible but requires us to do a bit more work.</p><p class="calibre8">Let's get started with our program. Start by creating a new Python script and enter the following:</p><div class="informalexample"><pre class="programlisting">from PyQt4.QtGui import *</pre></div><p class="calibre8">To make the program easier to use, we're going to define a function and place all our program logic inside this function, like this:</p><div class="informalexample"><pre class="programlisting">def analyze_shapefile():
    ...

analyze_shapefile()</pre></div><p class="calibre8">Now, let's start writing the contents of the <code class="email">analyze_shapefile()</code> function. So far, we've been hardwiring the name of the shapefile, but this time, let's use QGIS's graphical interface to prompt the user to select a shapefile:</p><div class="informalexample"><pre class="programlisting">def analyze_shapefile():
    filename = QFileDialog.getOpenFileName(iface.mainWindow(),
                                           "Select Shapefile",
                                           "~", '*.shp')
    if not filename:
        print "Cancelled."
        return</pre></div><p class="calibre8">We can then open the selected shapefile:</p><div class="informalexample"><pre class="programlisting">    registry = QgsProviderRegistry.instance()
    provider = registry.provider("ogr",filename)
    if not provider.isValid():
        print "Invalid shapefile."
        return</pre></div><p class="calibre8">In order to identify a feature, we need to display a meaningful label for the feature. To do this, we'll look <a id="id81" class="calibre1"/>for an attribute with a likely-looking name. If there is no suitable attribute, we'll have to use the feature's ID instead.</p><p class="calibre8">Let's start by building a<a id="id82" class="calibre1"/> list of the various attributes stored in this shapefile:</p><div class="informalexample"><pre class="programlisting">    attr_names = []
    for field in provider.fields():
        attr_names.append(field.name())</pre></div><p class="calibre8">We're now ready to start scanning through the shapefile's features. Before we do this, though, let's initialize a couple of variables to hold the totals we need to calculate:</p><div class="informalexample"><pre class="programlisting">    tot_length = 0
    tot_area = 0</pre></div><p class="calibre8">We also need to set up a <code class="email">QgsDistanceArea</code> object to do the distance and area calculations for us.</p><div class="informalexample"><pre class="programlisting">    crs = provider.crs()
    calculator = QgsDistanceArea()
    calculator.setSourceCrs(crs)
    calculator.setEllipsoid(crs.ellipsoidAcronym())
    calculator.setEllipsoidalMode(crs.geographicFlag())</pre></div><p class="calibre8">We'll use this object to calculate the true length and area of the shapefile's features in meters and square meters respectively.</p><p class="calibre8">We're now ready<a id="id83" class="calibre1"/> to scan through the contents of the shapefile, processing each feature in turn:</p><div class="informalexample"><pre class="programlisting">    for feature in provider.getFeatures(QgsFeatureRequest()):
        ...</pre></div><p class="calibre8">For each feature, we want to calculate a label that identifies that feature. We'll do this by looking for an attribute called <code class="email">"name"</code>, <code class="email">"NAME"</code>, or <code class="email">"Name"</code>, and using that attribute's value as the feature<a id="id84" class="calibre1"/> label. If there is no attribute with one of these field names, we'll fall back to using the feature's ID instead. Here is the relevant code:</p><div class="informalexample"><pre class="programlisting">        if "name" in attr_names:
            feature_label = feature.attribute("name")
        elif "Name" in attr_names:
            feature_label = feature.attribute("Name")
        elif "NAME" in attr_names:
            feature_label = feature.attribute("NAME")
        else:
            feature_label = str(feature.id())</pre></div><p class="calibre8">Next, we need to obtain the geometry object associated with the feature. The geometry object represents a polygon, line, or point. Getting a reference to the feature's underlying geometry object is simple:</p><div class="informalexample"><pre class="programlisting">        geometry = feature.geometry()</pre></div><p class="calibre8">We can now use the <code class="email">QgsDistanceArea</code> calculator we initialized earlier to calculate the length of a line feature and the area of a polygon feature. To do this, we'll first have to identify the type of feature we are dealing with:</p><div class="informalexample"><pre class="programlisting">        if geometry.type() == QGis.Line:
            ...
        elif geometry.type() == QGis.Polygon:
            ...
        else:
            ...</pre></div><p class="calibre8">For line geometries, we'll calculate the length of the line and update the total length:</p><div class="informalexample"><pre class="programlisting">        if geometry.type() == QGis.Line:
            length = int(calculator.measure (geometry) / 1000)
            tot_length = tot_length + length
            feature_info = "line of length %d kilometers" % length</pre></div><p class="calibre8">For polygon geometries, we'll calculate the area of the polygon and update the total area:</p><div class="informalexample"><pre class="programlisting">        elif geometry.type() == QGis.Polygon:
            area = int(calculator.measure (geometry) / 1000000)
            tot_area = tot_area + area
            feature_info = "polygon of area %d square kilometers" % area</pre></div><p class="calibre8">Finally, for the other types of geometries, we'll simply display the geometry's type:</p><div class="informalexample"><pre class="programlisting">        else:
            geom_type = qgis.vectorGeometryType(geometry.type())
            feature_info = "geometry of type %s" % geom_type</pre></div><p class="calibre8">Now that we've done these calculations, we can display the feature's label together with the information we calculated about this feature:</p><div class="informalexample"><pre class="programlisting">        print "%s: %s" % (feature_label, feature_info)</pre></div><p class="calibre8">Finally, when<a id="id85" class="calibre1"/> we've finished iterating over the features, we can display the total line length and polygon area for all the features in the shapefile:</p><div class="informalexample"><pre class="programlisting">    print "Total length of all line features: %d" % tot_length
    print "Total area of all polygon features: %d" % tot_area</pre></div><p class="calibre8">This completes<a id="id86" class="calibre1"/> our program for analyzing the contents of a shapefile. The full source for this program is available in the code samples provided with this book. To test our program, type or copy and paste it into the console's script editor, save the file, and click on the <span class="strong"><strong class="calibre9">Run Script</strong></span> button (or press <span class="strong"><em class="calibre10">Ctrl</em></span> + <span class="strong"><em class="calibre10">Shift</em></span> + <span class="strong"><em class="calibre10">E</em></span>). Here's an example of what the program's output looks like:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">Antigua and Barbuda: polygon of area 549 square kilometers</strong></span>
<span class="strong"><strong class="calibre9">Algeria: polygon of area 2334789 square kilometers</strong></span>
<span class="strong"><strong class="calibre9">Azerbaijan: polygon of area 86109 square kilometers</strong></span>
<span class="strong"><strong class="calibre9">Albania: polygon of area 28728 square kilometers</strong></span>
<span class="strong"><strong class="calibre9">Armenia: polygon of area 29732 square kilometers</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">Jersey: polygon of area 124 square kilometers</strong></span>
<span class="strong"><strong class="calibre9">South Georgia South Sandwich Islands: polygon of area 3876 square kilometers</strong></span>
<span class="strong"><strong class="calibre9">Taiwan: polygon of area 36697 square kilometers</strong></span>
<span class="strong"><strong class="calibre9">Total length of all line features: 0</strong></span>
<span class="strong"><strong class="calibre9">Total area of all polygon features: 147363163</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre8">This output was produced using the World Borders dataset, available at <a class="calibre1" href="http://thematicmapping.org/downloads/world_borders.php">http://thematicmapping.org/downloads/world_borders.php</a>. This is a useful set of <a id="id87" class="calibre1"/>geospatial data, which provides simple world maps and associated metadata. If you haven't already done so, you should grab yourself a copy of this dataset, as we'll be using this shapefile throughout this book.</p></div><p class="calibre8">As you can see, it is<a id="id88" class="calibre1"/> quite possible to create Python programs that read and analyze geospatial data, and you can run these programs directly from within the QGIS Console. It is also possible to create and manipulate geospatial data sources using the PyQGIS libraries.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Scripting the QGIS user interface"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec13" class="calibre1"/>Scripting the QGIS user interface</h1></div></div></div><p class="calibre8">While the example program we created earlier has very limited user interaction, it is quite possible to build your program to directly use the QGIS user interface elements such as the status bar, the message bar, progress indicators, and the QGIS logging window. You can also create <a id="id89" class="calibre1"/>custom forms and windows so that the output of your program looks just like any other feature of QGIS itself. Let's take a closer look at how some of these QGIS user-interface elements can be used from within your Python programs.</p></div>

<div class="book" title="Scripting the QGIS user interface">
<div class="book" title="The status bar"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec13" class="calibre1"/>The status bar</h2></div></div></div><p class="calibre8">The QGIS <a id="id90" class="calibre1"/>window has a status bar. You can use it to <a id="id91" class="calibre1"/>display the current status of your Python program, for example:</p><div class="informalexample"><pre class="programlisting">iface.mainWindow().statusBar().showMessage("Please wait...")</pre></div><p class="calibre8">The status message will appear at the bottom of the window, like this:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="The status bar" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">As you can<a id="id92" class="calibre1"/> see, there isn't much room on the status bar, so you'll need to keep your status message short. To hide the message again, do<a id="id93" class="calibre1"/> the following:</p><div class="informalexample"><pre class="programlisting">iface.mainWindow().statusBar().clearMessage()</pre></div></div></div>

<div class="book" title="Scripting the QGIS user interface">
<div class="book" title="The message bar"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec14" class="calibre1"/>The message bar</h2></div></div></div><p class="calibre8">A message<a id="id94" class="calibre1"/> bar appears within a window to display<a id="id95" class="calibre1"/> messages to the user, for example:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="The message bar" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Message bars have several useful features:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Messages can be stacked so that if multiple messages appear at once, the user won't miss<a id="id96" class="calibre1"/> the earlier messages</li><li class="listitem">Messages have a level, which indicates the importance of the message, and affects how the message is displayed</li><li class="listitem">Messages have an optional title as well as the text to be displayed</li><li class="listitem">Messages can stay on the screen until the user closes them, or they can time out, disappearing automatically after a given number of seconds</li><li class="listitem">You can <a id="id97" class="calibre1"/>add various Qt widgets to the message bar to customize its behavior and appearance</li></ul></div><p class="calibre8">Any window in QGIS can have its own message bar. The <code class="email">iface</code> variable has a <code class="email">messageBar()</code> method, which returns the message bar for the main QGIS window, but you can also add a message bar to your own custom windows if you wish.</p><p class="calibre8">To add a message to a <a id="id98" class="calibre1"/>message bar, you call the message bar's <code class="email">pushMessage()</code> method. To create a message without a title, you use the following method signature:</p><div class="informalexample"><pre class="programlisting">messageBar.pushMessage(text, level=QsgMessageBar.INFO, duration=None)</pre></div><p class="calibre8">For example:</p><div class="informalexample"><pre class="programlisting">from qgis.gui import *
iface.messageBar().pushMessage("Hello World",
         level=QgsMessageBar.INFO)</pre></div><p class="calibre8">To include a title, use the following method signature:</p><div class="informalexample"><pre class="programlisting">messageBar.pushMessage(title, text, level=QgsMessageBar.INFO, duration=None)</pre></div><p class="calibre8">In both cases, the <code class="email">level</code> parameter can be set to <code class="email">QgsMessageBar.INFO</code>, <code class="email">QgsMessageBar.WARNING</code>, or <code class="email">QgsMessageBar.CRITICAL</code>, and if the <code class="email">duration</code> parameter is specified, it will be<a id="id99" class="calibre1"/> the number of seconds before the message is hidden.</p><p class="calibre8">To remove all<a id="id100" class="calibre1"/> the messages currently being shown, you can call the <code class="email">messageBar.clearWidgets()</code> method.</p></div></div>

<div class="book" title="Scripting the QGIS user interface">
<div class="book" title="Progress indicators"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec15" class="calibre1"/>Progress indicators</h2></div></div></div><p class="calibre8">You can also make<a id="id101" class="calibre1"/> use of the message bar to display a Qt progress indicator. To do this, use the <code class="email">messageBar.createMessage()</code> method to create a widget to display your message, then modify the widget to<a id="id102" class="calibre1"/> include additional Qt controls, and finally call the <code class="email">messageBar.pushWidget()</code> method to display the message and the controls you added. For example:</p><div class="informalexample"><pre class="programlisting">progressMessage = iface.messageBar().createMessage("Please wait")
progressBar = QProgressBar()
progressBar.setMaximum(100)
progressBar.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
progressMessage.layout().addWidget(progressBar)
iface.messageBar().pushWidget(progressMessage)
...
progressBar.setValue(n)
...
iface.messageBar().clearWidgets()</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre8">There is a bug in the Mac version of QGIS 2.2, which prevents the user interface from updating while your Python code is running. A workaround for this is to use threads, as described in the following article: <a class="calibre1" href="http://snorf.net/blog/2013/12/07/multithreading-in-qgis-python-plugins">http://snorf.net/blog/2013/12/07/multithreading-in-qgis-python-plugins</a>
</p></div></div></div>

<div class="book" title="Scripting the QGIS user interface">
<div class="book" title="QGIS logging"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec16" class="calibre1"/>QGIS logging</h2></div></div></div><p class="calibre8">You can use<a id="id103" class="calibre1"/> the built-in logging facilities of<a id="id104" class="calibre1"/> QGIS to display the output in a separate window. For example:</p><div class="informalexample"><pre class="programlisting">for i in range(100):
    QgsMessageLog.logMessage("Message %d" % i)</pre></div><p class="calibre8">The log messages will be shown in the log view, which you can show by navigating to <span class="strong"><strong class="calibre9">View</strong></span> | <span class="strong"><strong class="calibre9">Panels</strong></span> | <span class="strong"><strong class="calibre9">Log Messages</strong></span>.</p><p class="calibre8">If you wish, you can change the importance of your message by adding a message level to the <code class="email">logMessage()</code> call, for example:</p><div class="informalexample"><pre class="programlisting">QgsMessageLog.logMessage("Something is wrong",
                         level=QgsMessageLog.CRITICAL)</pre></div><p class="calibre8">Rather than being mixed in with other QGIS messages, you can also choose to have all your log messages appear in a pane by themselves, by adding a tag to the <code class="email">logMessage()</code> call as follows:</p><div class="informalexample"><pre class="programlisting">QgsMessageLog.logMessage("Test Message", tag="my panel")</pre></div><p class="calibre8">Your log messages will then appear in a panel by themselves, like this:</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="QGIS logging" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="Scripting the QGIS user interface">
<div class="book" title="Custom dialogs and windows"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec17" class="calibre1"/>Custom dialogs and windows</h2></div></div></div><p class="calibre8">As QGIS is built <a id="id105" class="calibre1"/>on top of Qt, you can use the PyQt classes to create your own windows and dialog boxes, and display them directly from within your Python code. For example, here's a script<a id="id106" class="calibre1"/> that displays a custom dialog box that<a id="id107" class="calibre1"/> prompts<a id="id108" class="calibre1"/> the user to enter a latitude and longitude value:</p><div class="informalexample"><pre class="programlisting">from PyQt4.QtGui import *

class MyDialog(QDialog):
    def __init__(self):
        QDialog.__init__(self)
        self.setWindowTitle("Enter Coordinate")

        layout = QFormLayout(self)

        self.lat_label = QLabel("Latitude", self)
        self.lat_field = QLineEdit(self)

        self.long_label = QLabel("Longitude", self)
        self.long_field = QLineEdit(self)

        self.ok_btn = QPushButton("OK", self)
        self.ok_btn.clicked.connect(self.accept)

        self.cancel_btn = QPushButton("Cancel", self)
        self.cancel_btn.clicked.connect(self.reject)

        btn_layout = QHBoxLayout(self)
        btn_layout.addWidget(self.ok_btn)
        btn_layout.addWidget(self.cancel_btn)

        layout.addRow(self.lat_label, self.lat_field)
        layout.addRow(self.long_label, self.long_field)
        layout.addRow(btn_layout)

        self.setLayout(layout)

dialog = MyDialog()
if dialog.exec_() == QDialog.Accepted:
    lat = dialog.lat_field.text()
    long = dialog.long_field.text()
    print lat,long</pre></div><p class="calibre8">Running this script will cause the following dialog box to be displayed:</p><div class="mediaobject"><img src="../images/00020.jpeg" alt="Custom dialogs and windows" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If the user<a id="id109" class="calibre1"/> clicks on the <span class="strong"><strong class="calibre9">OK</strong></span> button, the entered latitude and longitude values will be printed to the console. Of course, this is just a simple example—there's no error <a id="id110" class="calibre1"/>checking or conversion of the entered<a id="id111" class="calibre1"/> values from text back to numbers. However, this is just a simple example. There's a lot more that can be done using the PyQt libraries, and people have written entire <a id="id112" class="calibre1"/>books on the subject. However, the main thing to realize now is that, because QGIS is built on top of Qt, you can use all of the<a id="id113" class="calibre1"/> features of PyQt to build sophisticated user interfaces. You're <a id="id114" class="calibre1"/>certainly not limited to using the Python console to interact with the user.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we explored the QGIS Python Console, and how to use it for a variety of programming tasks. We also used the console to delve more deeply into the QGIS Python programming environment.</p><p class="calibre8">As we worked through this chapter, we learned what the various toolbar buttons and controls do within the QGIS Console, and how to enter commands using the Python Shell. We looked at how we can use the Python Interpreter Log to view the previous output and re-enter commands you executed earlier. We saw the ways in which you can use autocompletion to enter your Python code more quickly, and also learned about the parameters that the various PyQGIS functions and methods accept.</p><p class="calibre8">We then looked at how to enter and execute Python scripts using the built-in source code editor. We discovered that the Python Console is itself written in Python, allowing you to explore the source code and manipulate the console itself using the Python code.</p><p class="calibre8">We learned how to create a startup script that is run automatically whenever QGIS starts up, and how you can use this to set up the console to open automatically and prevent it from acting as a dockable window.</p><p class="calibre8">Next, we examined the process of loading geospatial data directly using your Python scripts, without first having to load it into a QGIS map layer. We saw how to identify the attributes defined by a shapefile, how to scan through the features within a shapefile, and the ways in which the PyQGIS libraries allow you to perform common geospatial calculations.</p><p class="calibre8">We then looked at the various ways in which you can make use of QGIS user interface elements within your Python scripts, including the status bar, message bars, progress indicators, and the QGIS message log.</p><p class="calibre8">Finally, we saw how you can use standard PyQt classes to create your own windows and dialog boxes to provide a sophisticated user interface for your Python scripts.</p><p class="calibre8">In the following chapter, we will work more directly with the QGIS Python libraries, learning how these libraries are structured and how you can use them to perform various sorts of geospatial data manipulation and display the results on a map.</p></div></body></html>