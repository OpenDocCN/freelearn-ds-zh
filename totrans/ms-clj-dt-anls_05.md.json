["```py\n(defproject benford \"0.1.0-SNAPSHOT\"\n  :dependencies [[org.clojure/clojure \"1.5.1\"]\n                 [org.clojure/data.csv \"0.1.2\"]\n                 [incanter \"1.5.2\"]])\n```", "```py\n(ns benford.core\n  (:require [clojure.string :as str]\n            [clojure.java.io :as io]\n            [clojure.pprint :as pp]\n            [clojure.data.csv :as csv]\n            [incanter.stats :as s]))\n```", "```py\n(defn first-digit [n]\n  (Integer/parseInt (re-find #\"\\d\" (str n))))\n```", "```py\n(defn first-digit-freq [coll]\n  (frequencies (map first-digit coll)))\n```", "```py\n(defn benford [d]\n  (Math/log10 (+ 1.0 (/ 1.0 (float d)))))\n```", "```py\nuser=> (map benford (range 1 10))\n(0.3010299956639812 0.17609125905568124 0.12493873660829993 0.09691001300805642 0.07918124604762482 0.06694678963061322 0.05799194697768673 0.05115252244738129 0.04575749056067514)\n```", "```py\n(defn x-sqr [expected-ratios observed]\n  (let [total (sum observed)\n        f (fn [e o]\n            (let [n (- o e)]\n              (/ (* n n) e)))]\n    (sum (map f (map #(* % total) expected-ratios) observed))))\n```", "```py\n(defn benford-test [coll]\n  (let [freqs (first-digit-freq coll)\n        digits (range 1 10)]\n    (x-sqr (map benford digits) (map freqs digits))))\n```", "```py\nuser=> (benford-test data)\n1.7653767101950812\n```", "```py\nuser=> (s/cdf-chisq 1.7653 :df 8 :lower-tail? false)\n0.9873810658453659\n```", "```py\nCountry Name,Country Code,Indicator Name,Indicator Code,1960 [YR1960],1961 [YR1961],1962 [YR1962],1963 [YR1963],1964 [YR1964],1965 [YR1965],1966 [YR1966],1967 [YR1967],1968 [YR1968],1969 [YR1969],1970 [YR1970],1971 [YR1971],1972 [YR1972],1973 [YR1973],1974 [YR1974],1975 [YR1975],1976 [YR1976],1977 [YR1977],1978 [YR1978],1979 [YR1979],1980 [YR1980],1981 [YR1981],1982 [YR1982],1983 [YR1983],1984 [YR1984],1985 [YR1985],1986 [YR1986],1987 [YR1987],1988 [YR1988],1989 [YR1989],1990 [YR1990],1991 [YR1991],1992 [YR1992],1993 [YR1993],1994 [YR1994],1995 [YR1995],1996 [YR1996],1997 [YR1997],1998 [YR1998],1999 [YR1999],2000 [YR2000],2001 [YR2001],2002 [YR2002],2003 [YR2003],2004 [YR2004],2005 [YR2005],2006 [YR2006],2007 [YR2007],2008 [YR2008],2009 [YR2009],2010 [YR2010],2011 [YR2011],2012 [YR2012],2013 [YR2013]\n\nAfghanistan,AFG,Population (Total),SP.POP.TOTL,8774440,8953544,9141783,9339507,9547131,9765015,9990125,10221902,10465770,10729191,11015621,11323446,11644377,11966352,12273589,12551790,12806810,13034460,13199597,13257128,13180431,12963788,12634494,12241928,11854205,11528977,11262439,11063107,11013345,11215323,11731193,12612043,13811876,15175325,16485018,17586073,18415307,19021226,19496836,19987071,20595360,21347782,22202806,23116142,24018682,24860855,25631282,26349243,27032197,27708187,28397812,29105480,29824536,..\n```", "```py\n(defn read-csv [filename]\n  (with-open [f (io/reader filename)]\n    (let [[row & reader] (csv/read-csv f)\n          header (map keyword\n                      (map #(str/replace % \\space \\-) row))]\n      (doall\n        (map #(zipmap header %) reader)))))\n```", "```py\n(defn read-databank [filename]\n  (let [year-keys (map keyword (map str (range 1960 2013)))]\n    (->> filename\n      read-csv\n      (mapcat #(map (fn [f] (f %)) year-keys))\n      (remove empty?)\n      (map #(Double/parseDouble %))\n      (remove zero?))))\n```", "```py\n(defn sample [coll k]\n  (if (<= (count coll) k)\n    coll\n    (let [coll-size (count coll)]\n      (loop [seen #{}]\n        (if (>= (count seen) k)\n          (map #(nth coll %) (sort seen))\n          (recur (conj seen (rand-int coll-size))))))))\n```", "```py\nuser=> (def population (b/read-databank \"data/population.csv\"))\n#'user/population\nuser=> (def pop-test (s/benford-test (b/sample population 100)))\n#'user/pop-test\nuser=> (:X-sq pop-test)\n7.926272852944953\nuser=> (:p-value pop-test)\n0.4407050181730324\n```", "```py\n(defn make-fraudulent\n  ([data] (make-fraudulent data 1 0.05 1000))\n  ([data block sig-level k]\n   (let [get-rand (make-rand-range-fn data)]\n     (loop [v (vec (sample data k)), benford (s/benford-test v),\n            n 0, ps [], swapped #{}]\n       (println n \\. (:p-value benford))\n       (if (< (:p-value benford) sig-level)\n         {:n n, :benford benford, :data v, :p-history ps,\n          :swapped swapped}\n         (let [[new-v new-swapped]\n               (swap-random\n                 v swapped #(rand-int k) get-rand block)\n               benford (s/benford-test new-v)]\n           (recur new-v benford (inc n)\n                  (conj ps (:p-value benford))\n                  new-swapped)))))))\n```"]