["```py\ndef subtract(x1, x2):\n    return x1 - x2\n```", "```py\nr = subtract(5.0, 4.3)\n```", "```py\nz = 3 \ne = subtract(5,z)\n```", "```py\nz = 3 \ne = subtract(x2 = z, x1 = 5)\n```", "```py\nplot(xp, yp, linewidth = 2,label = 'y-values')\n```", "```py\ndef subtract(x1, x2):\n    z = x1 - x2\n    x2 = 50.\n    return z\na = 20.\nb = subtract(10, a)    # returns -10\na    # still has the value 20\n```", "```py\ndef subtract(x):\n    z = x[0] - x[1]\n    x[1] = 50.\n    return z\na = [10,20]\nb = subtract(a)    # returns -10\na    # is now [10, 50.0]\n```", "```py\nimport numpy as np # here the variable np is defined\ndef sqrt(x):\n    return np.sqrt(x) # we use np inside the function\n```", "```py\na = 3\ndef multiply(x):\n    return a * x # bad style: access to the variable a defined outside\n```", "```py\na=3\nmultiply(4)  # returns 12\na=4\nmultiply(4)  # returns 16\n```", "```py\ndef multiply(x, a):\n    return a * x\n```", "```py\nimport scipy.linalg as sl\nsl.norm(identity(3))\nsl.norm(identity(3), ord = 'fro')\nsl.norm(identity(3), 'fro')\n```", "```py\nTypeError: subtract() takes exactly 2 arguments (1 given)\n```", "```py\ndef subtract(x1, x2 = 0): \n    return x1 - x2\n```", "```py\ndef my_list(x1, x2 = []):\n    x2.append(x1)\n    return x2\nmy_list(1)  # returns [1]\nmy_list(2)  # returns [1,2]\n```", "```py\ndata = [[1,2],[3,4]]    \nstyle = dict({'linewidth':3,'marker':'o','color':'green'})\n```", "```py\nplot(*data,**style)\n```", "```py\ndef complex_to_polar(z):\n    r = sqrt(z.real ** 2 + z.imag ** 2)\n    phi = arctan2(z.imag, z.real)\n    return (r,phi)  # here the return object is formed\n```", "```py\nz = 3 + 5j  # here we define a complex number\na = complex_to_polar(z)\nr = a[0]\nphi = a[1]\n```", "```py\nr,phi = complex_to_polar(z)\n```", "```py\ndef append_to_list(L, x):\n    L.append(x)\n```", "```py\ndef function_with_dead_code(x):\n    return 2 * x\n    y = x ** 2 # these two lines ...\n    return y   # ... are never executed!\n```", "```py\ndef chebyshev(n, x):\n    if n == 0:\n        return 1.\n    elif n == 1:\n        return x\n    else:\n        return 2\\. * x * chebyshev(n - 1, x) \n                      - chebyshev(n - 2 ,x)\n\n```", "```py\nchebyshev(5, 0.52) # returns 0.39616645119999994\n```", "```py\nRuntimeError: maximum recursion depth exceeded\n```", "```py\ndef newton(f, x0):\n    \"\"\"\n    Newton's method for computing a zero of a function\n    on input:\n    f  (function) given function f(x)\n    x0 (float) initial guess \n    on return:\n    y  (float) the approximated zero of f\n    \"\"\"\n     ...\n```", "```py\nHelp on function newton in module __main__:\n\nnewton(f, x0)\n     Newton's method for computing a zero of a function\n     on input:\n     f  (function) given function f(x)\n     x0 (float) initial guess\n     on return:\n     y  (float) the approximated zero of f\n```", "```py\ndef square(x):\n    \"\"\"\n    Return the square of x\n    \"\"\"\n    return x ** 2\nsquare(4) # 16\nsq = square # now sq is the same as square\nsq(4) # 16\ndel square # square doesn't exist anymore\nprint(newton(sq, .2)) # passing as argument\n```", "```py\nfunc -- A Python function or method which takes at least one\n               (possibly vector) argument.\n```", "```py\nimport functools\ndef sin_omega(t, freq):\n    return sin(2 * pi * freq * t)\n\ndef make_sine(frequency):\n    return functools.partial(sin_omega, freq = frequency)\n```", "```py\ndef make_sine(freq):\n    \"Make a sine function with frequency freq\"\n    def mysine(t):\n        return sin_omega(t, freq)\n    return mysine\n```", "```py\nimport scipy.integrate as si\nsi.quad(lambda x: x ** 2 + 5, 0, 1)\n```", "```py\nlambda parameter_list: expression\n```", "```py\nparabola = lambda x: x ** 2 + 5\nparabola(3) # gives 14\n```", "```py\nparabola = lambda x: x**2+5 \n# the following code is equivalent\ndef parabola(x):\n    return x ** 2 + 5\n```", "```py\nimport scipy.integrate as si\nfor iteration in range(3):\n    print(si.quad(lambda x: sin_omega(x, iteration*pi), 0, pi/2.) )\n```", "```py\ndef how_sparse(A):\n    return len(A.reshape(-1).nonzero()[0])\n```", "```py\ndef cast2array(f):\n    def new_function(obj):\n        fA = f(array(obj))\n        return fA\n    return new_function\n```", "```py\n@cast2array\ndef how_sparse(A):\n    return len(A.reshape(-1).nonzero()[0])\n```", "```py\ndef partial(func, *args, **keywords):\n    def newfunc(*fargs, **fkeywords):\n        newkeywords = keywords.copy()\n        newkeywords.update(fkeywords)\n        return func(*(args + fargs), **newkeywords)\n    newfunc.func = func\n    newfunc.args = args\n    newfunc.keywords = keywords\n    return newfunc\n```"]