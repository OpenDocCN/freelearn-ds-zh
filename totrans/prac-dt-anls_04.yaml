- en: Getting Started with NumPy
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter teaches one of the most powerful Python libraries for data analysis:
    NumPy. You will learn key functions used for analysis and we''ll also discuss
    arrays and matrix data structures using NumPy. Finally, we''ll walk through some
    practical examples that serve as a foundation for future learning modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a Python NumPy array and its importance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences between single and multiple dimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your first NumPy array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical use cases of NumPy and arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the GitHub repository of this book: [https://github.com/PacktPublishing/Practical-Data-Analysis-using-Jupyter-Notebook/tree/master/Chapter03](https://github.com/PacktPublishing/Practical-Data-Analysis-using-Jupyter-Notebook/tree/master/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: You can download and install the required software from the following link: [https://www.anaconda.com/products/individual](https://www.anaconda.com/products/individual).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a Python NumPy array and its importance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several Python courses on NumPy focus on building programming or statistical
    examples intended to create a foundation for data science.
  prefs: []
  type: TYPE_NORMAL
- en: While this is important, I want to stay true to anyone who is just getting started
    working with data so the focus will be the practical usage of Python and NumPy
    for data analysis. This means not all of the features of NumPy will be covered,
    so I encourage you to learn more by looking at resources in the *Further reading*
    section. The history of the NumPy library has evolved from what was originally
    named **Numerical Python**. It was created as an open source project in 2001 by
    David Ascher, Paul Dubois, Konrad Hinsen, Jim Hugunin, and Travis Oliphant. According
    to the documentation, the purpose was to extend Python to allow the manipulation
    of large sets of objects organized in a grid-like fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Python does not support arrays out of the box but does have a similar feature
    called **lists**, which has limitations in performance and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Additional research on the subject of why NumPy was created points to a need
    for efficiency in memory and storage when processing large volumes of data. Today,
    NumPy can be found as a dependent library for millions of Python projects in a
    public search of GitHub, including thousands of examples that handle image manipulation
    used for facial recognition.
  prefs: []
  type: TYPE_NORMAL
- en: The NumPy library is all about arrays, so let's walk through what an array is
    and why it is important. Any computer science or programming class I have taken
    has always included arrays. I was first introduced to an array before I even understood
    the concept thirty-seven years ago when I was introduced to a computer, the Apple
    IIe, in Mrs. Sherman's 4th-grade classroom.
  prefs: []
  type: TYPE_NORMAL
- en: One of the educational software available to run on the Apple IIe was called
    <q>Logo*,* </q>which was a programming language that allowed you to write simple
    commands to control the movement of a cursor on the computer monitor. To make
    the process more appealing to a younger audience, the commands allowed you to
    create geometric shapes and print values represented by a turtle. In <q>*Logo*</q>,
    arrays used the `list` command, which groups together one or more words or numbers
    as a single object that can be referenced during the same session. You can still
    find emulators available that allow you to run the <q>Logo</q> programming language,
    which was a fun walk down memory lane for me that I hope you will enjoy as well.
  prefs: []
  type: TYPE_NORMAL
- en: A more formal definition of an array is it is a container used to store a list
    of values or collections of values called elements. The elements must be defined
    with a data type that applies to all of the values in an array, and that data
    type cannot be changed during the creation of the array. This sounds like a rigid
    rule but does create consistency between all of the data values. There is some
    flexibility using the data types of arrays found in the NumPy library, which are
    known as `dtype` (data types). The most common `dtype` are `Boolean` for true/false
    values, `char` for words/string values, `float` for decimal numbers, and `int`
    for integers. A full list of supported data types could be found in the documentation
    found in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of an array can be a list of numbers from 1 to 10 or a list of
    characters such as stock tickers, `APPL`, `IBM`, and `AMZN`. Even board games
    such as *Battleship* and chess are examples of arrays where pieces are placed
    on the board and identified with the interaction of letters and numbers. Arrays
    in NumPy support complex data types including sentences but remember, you must
    keep the data type defined and consistent to avoid errors. Arrays come in all
    shapes and sizes, so let's walk through a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between single and multiple dimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the array only has one dimension, it would represent that list of values
    in a single row or column (but not both). The following example shows a one-dimensional
    array assigned to variable named `1d_array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A two-dimensional array, also known as a matrix, would be any combination of
    multiple rows and columns. The following equation is an example of a two-dimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may have already realized from the examples that a structured data table
    that is made up of rows and columns is a two-dimensional array! Now you can see
    why understanding the array concept builds the foundation for data analysis against
    structured data.
  prefs: []
  type: TYPE_NORMAL
- en: Once an array is defined, it is available for use in calculations or manipulation
    by referencing it during the same session such as when changing the sequence of
    the values or even replacing values as needed. Arrays have a multitude of uses
    in programming so I want to stay focused on specific use cases related to data
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding arrays goes beyond just a simple table of rows and columns. The
    examples discussed have either one or two dimensions. If the array has more than
    one dimension, you can reference the values along the axis (*X*, *Y*, or *Z*).
  prefs: []
  type: TYPE_NORMAL
- en: With the `numpy` library package, the core feature is the `ndarray` object,
    which allows for any number of dimensions, which is called *n*-dimensional. This
    refers to the shape and size of the array across multiple axes. Hence, a 3D cube
    with an *X*, *Y*, and *Z* axis can also be created using NumPy arrays. A scatter
    plot visualization would be a useful way to analyze the type of data, which we
    will cover in [Chapter 9](e3570c4a-c8ad-483f-9f3f-3e113156e9c2.xhtml), *Plotting,
    Visualization, and Storytelling*, with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other key features of NumPy include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to perform mathematical calculations against big datasets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using operators to compare values such as greater than and less than
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining values in two or more arrays together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing individual elements in the sequence from how they are stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visual representations of the different types of arrays using blocks to represent
    the elements are shown in the following diagrams. The following diagram is a one-dimensional
    array with three elements, which is also known as a vector when dealing with ordinal
    numbers or a tuple when working with ordered pairs. The first element of any array
    is referenced with an index value of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c648e9d-282d-4ef4-9ca5-097305c4a193.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram is a two-dimensional array, which is also known as a
    matrix. This matrix builds from the first one-dimensional array but now has two
    rows with three columns for a total of six elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7688247-8c0a-42ba-af37-924a84dd775f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An *n*-dimensional array could be represented as a cube similar to the one
    in the following diagram. This *n*-dimensional array continues to build from the
    first two examples and now includes a third dimension or axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8790353-9a6e-45b5-93f9-d2df2e1db559.png)'
  prefs: []
  type: TYPE_IMG
- en: I find the best way to learn is to get hands-on and comfortable using the commands
    to work with the data, so let's launch a Jupyter notebook and walk through some
    simple examples.
  prefs: []
  type: TYPE_NORMAL
- en: Making your first NumPy array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest example to create a one-dimensional array would be a straightforward
    command. After renaming your Jupyter notebook from `Untitled` to `array_basics`,
    the first thing to do is to import the `numpy` library into your active session
    by typing in `import numpy as np` in the `In []` command and running the cell.
  prefs: []
  type: TYPE_NORMAL
- en: I like to run this line first to ensure the library is installed properly so
    if you receive an error, double-check and ensure that `conda` or `pip` was set
    up correctly. See [Chapter 2](e0fe6eb2-8f38-41f7-9dea-2b177578fd3c.xhtml), *Overview
    of Python and Installing Jupyter Notebook*, for help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you want to assign the array object a variable name so you can reference
    it in future commands. It is common to use single character values such as `a` or
    `x` as a shortcut for your array but for just getting started, let''s use something
    more descriptive, such as `my_first_array` for easier reference. To the right
    of the equals sign, we reference the `numpy` method using `np.array` followed
    by a parentheses and square brackets, which encapsulate the assigned values for
    each element. After running the command, to ensure the syntax is correct, the
    last command will be to print the array to ensure the output matches the input. Once
    completed, the results should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32905fa7-5953-43b0-9dc3-f9a3ed356a13.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have an array available, let's walk through how you can verify the
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: Useful array functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some useful commands to run against any array in NumPy to give you metadata
    (data about the data) are included here. The commands are being run specifically
    against the variable named `my_first_array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_first_array.shape`: It provides the array dimensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_first_array.size`: This shows the number of array elements (similar to
    the number of cells in a table).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len(my_first_array)`: This shows the length of the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_first_array.dtype.name`: This provides the data type of the array elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_first_array.astype(int)`: This converts an array into a different data
    type—in this example, an integer that will display as `int64`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you run the preceding commands in Jupyter, your notebook should look similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9158ed0-0705-492e-8a4a-990eb0003673.png)'
  prefs: []
  type: TYPE_IMG
- en: The shape, size, and length of a one-dimensional array will all output the same
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reference individual elements in the array, you use the square brackets
    along with an ordinal whole number, which is called the array index. If you are
    familiar with the Microsoft Excel function, `vlookup`, the behavior to reference
    the index of the data you want to retrieve has a similar concept. The first element
    in any array using NumPy would be `0` so if you wanted to just display the first
    value from the prior example, you would type in the `print(my_first_array[0])` command,
    which will output `1` on the screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/078060f5-580f-48c3-84e6-1630a5be89b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the array we are working with in this example has numeric values, we can
    also do some mathematical functions against the values.
  prefs: []
  type: TYPE_NORMAL
- en: Note the default `dtype` of the array in NumPy is `float` but if you don't define
    a data type when you first create it, Python will assign one based on the values
    assigned or provide an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some useful statistical functions you can run against numeric arrays that have `dtype` of
    `int` or `float` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_first_array.sum()`: Sums all of the element values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_first_array.min()`: Provides the minimum element value in the entire array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_first_array.max()`: Provides the maximum element value in the entire array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_first_array.mean()`: Provides the mean or average, which is the sum of
    the elements divided by the count of the elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you run these statistical commands against `my_first_array` in your notebook,
    the output will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cfd0a0f-6fec-4504-84cc-025bfe55ead8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from these few examples, there are plenty of useful functions
    built into the NumPy library that will help you with data validation and quality
    checks during the analysis process. In the *Further reading* section, I have placed
    a link to a printable one-page cheat sheet for easy reference.
  prefs: []
  type: TYPE_NORMAL
- en: Practical use cases of NumPy and arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's walk through a practical use case for working with a one-dimensional array
    in data analysis. Here's the scenario—you are a data analyst who wants to know
    what is the highest daily closing price for a stock ticker for the current **Year
    To Date** (**YTD**). To do this, you can use an array to store each value as an
    element, sort the price element from high to low, and then print the first element,
    which would display the highest price as the output value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before loading the file into Jupyter, it is best to inspect the file contents,
    which supports our **Know Your Data** (**KYD**) concept discussed in [Chapter
    1](0fa7e28f-7a30-4099-9bae-30dd3c86ee4f.xhtml), *Fundamentals of Data Analysis*. The
    following screenshot is a comma-delimited, structured dataset with two columns.
    The file includes a header row with a `Date` field in the format of `YYYY-MM-DD`
    and a field labeled `Close`, which represents the closing price of the stock by
    the end of the trading day for this stock ticker. This data was downloaded from
    Yahoo Business, manually changed to exclude some columns, and then stored as a
    file in the comma-delimited format. The file name represents the ticker of the
    stock, so `AAPL` represents the Apple Company, which is a publicly-traded company on
    the **National Association of Securities Dealers Automated Quotations** (**NASDAQ**)
    stock exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/599204ee-b4f3-4555-ae07-d00f6643cb1b.png)'
  prefs: []
  type: TYPE_IMG
- en: The first step would be to load the file that contains the data. I have placed
    this file in this book's GitHub repository for convenience, so go ahead and set
    up a new project folder using the best practices covered in [Chapter 2](e0fe6eb2-8f38-41f7-9dea-2b177578fd3c.xhtml), *Overview
    of Python and Installing Jupyter Notebook*, by launching a new Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the syntax of Python is explicit and case sensitive so don't be
    discouraged if the expected output is wrong or you receive an error message. In
    most cases, a simple change in the code will resolve the issue and you can re-run
    the command.
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario, there are a few options to load data in an array using NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to arrays manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first option would be to explicitly assign the values to an array manually,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43b98d94-0c19-4456-8c20-7e317dcb5250.png)'
  prefs: []
  type: TYPE_IMG
- en: This option is fine for small datasets, testing syntax, or other specific use
    cases but will be impractical when working with big data or multiple data files.
    We took a few shortcuts using this option by only typing in a sampling of ten
    values from the source file. Since all of the stock prices are numeric and have
    a consistent data type, we can use a one-dimensional array that has a default
    `dtype` of `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to reproduce this option are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Jupyter and create a new Python notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To stay consistent with best practices, be sure to rename the notebook `highest_daily_closing_stock_price_option_1`
    before moving forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following command to import the `numpy` library in the notebook,
    input `In []:`, and run the cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next input cell, add the following command to assign a NumPy array of
    values using the shortcut of `np` and assigning it to a variable named `input_stock_price_array`.
    Proceed by running the cell, which will *not* produce an output, `Out []`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next input `In []:` cell, add the following command to assign a NumPy
    array of values to a variable named `sorted_stock_price_array` and run the cell.
    Similar to before, the result will *not* produce an output, `Out []`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Type in the following commands, which use the `print()` function to display
    the results of each of the array variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Press the *Enter* key to create a new line so you can add the second line command
    before running the cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the output cell displays `Out []`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will be two rows of output with the first as the original array of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second output row is a sorted list of the values from the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type in the following command to use the `print()` function to display the
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the output cell displays `Out []`. The output should state `Highest
    closing stock price: 154.94`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key concepts to remember from these steps are that you load an initial array
    of stock price values and name it `input_stock_price_array`. This step was done
    after importing the NumPy library and assigning it to the `np` shortcut, which
    is a best practice. Next, you create a new array from the original, name it `sorted_stock_price_array`,
    and use the `sort()` function from NumPy. The benefit of the `sort()` function
    is that it will automatically order the elements of the original array from low
    to high. Since the goal of this scenario is to get the highest value, we add the
    `[::-1]` parameter to the function, which sorts the elements of values in descending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new array from the original array helps to make your analysis easier
    to repeat and reuse. The order of operation becomes critical in the process so
    you must walk through the steps in sequence to get the correct results.
  prefs: []
  type: TYPE_NORMAL
- en: To verify the results, we add an extra step to print both arrays together to
    visually compare the elements and confirm that the new array is sorted in descending
    order. Since the original task was to get the *highest* stock price, the final
    step is to print the first element in the sorted array, which has an index value
    of `0`. If the steps are performed without any errors, you'll see the highest
    closing stock price from the sampling of data, that is, `154.94`.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to arrays directly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more scalable option versus manually assigning values in the array is to use
    another NumPy command called the `genfromtxt()` function, which is available in
    the `numpy` library. Using this function, we can assign the array elements directly
    from reading in records from the file by row and column. The `genfromtxt()` function
    has a few parameters to support handling the structure of the data by isolating
    the specific column needed and its data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple required and optional parameters for the `genfromtxt()`
    function, which you can find in the *Further reading* section. For our example,
    let''s walk through the ones required to answer our business question:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the filename, which is assigned to the file we upload,
    named `AAPL_stock_price_example.csv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the delimiter, which is a comma since that is how the
    input file is structured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next parameter is to inform the function that our input data file has a
    header by assigning the `names=` parameter to `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last parameter is `usecols=`, which defines the specific column to read
    the data from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to the `genformtxt()` function help, when passing a value to the `usecols=`
    parameter, the first column is always assigned to `0` by default. Since we need
    the `Close` column in our file, we change the parameter value to `1` to match
    the order that is found in our input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `input_stock_price_array` is loaded using the `genfromtxt()` function,
    a quick *size* check will validate that the number of elements matches the number
    of rows in the source file. Note that the header row would be excluded from the
    size. In the following screenshot, you see a few modifications to the manual array
    option but once the array is populated with values, the remaining steps are very
    similar. I added `[:5]` to the `print()` function to displace the top five elements
    and make it easier to compare the source input array and the new sorted array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7d35b04-880e-48a1-b625-61466d125ba7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The steps to reproduce this option are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Jupyter and create a new Python notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To stay consistent with best practices, be sure to rename the notebook `highest_daily_closing_stock_price_option_2`
    before moving forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the `AAPL_stock_price_example.csv` file to the Jupyter notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `import numpy as np` in the `In []:` cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `input_stock_price_array = np.genfromtxt('AAPL_stock_price_example.csv',
    delimiter=',', names=True, usecols = (1))` in the next `In []:` cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `input_stock_price_array.size` in the next `In []:` cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the output cell displays `Out []:`. The number of rows is `229`
    when excluding the header row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `sorted_stock_price_array = np.sort(input_stock_price_array)[::-1]` in
    the next `In []:` cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in `print(''Closing stock price in order of day traded: '', input_stock_price_array[:5])
    print(''Closing stock price in order from high to low: '', sorted_stock_price_array[:5])` in
    the next `In []:` cell.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the output cell displays `Out []`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will be two rows of output with the first as the original array of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second output row is a sorted list of the values from the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type in `print(''Highest closing stock price: '', sorted_stock_price_array[0])` in
    the next `In []:` cell.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the output cell displays `Out []:`. The output should state `Highest
    closing stock price: 267.100006`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assigning values to an array using a loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another approach that may use more code but has more flexibility to control
    data quality during the process of populating the array would be to use a loop.
    There are a few concepts to walk through using this approach but I think it will
    be useful to understand this and applicable to further learning exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'A summary of the process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the file into memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through each individual record
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strip out a value from each record
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign each value to a temporary array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean up the array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the array in descending order
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the first element in the array to display the highest price
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last few steps in this process should look familiar since they are a repeat
    from the previous option where we clean the array, sort it, and then print the
    first element. The complete steps to reproduce this option are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Jupyter and create a new Python notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To stay consistent with best practices, be sure to rename the notebook `highest_daily_closing_stock_price_option_3` before
    moving forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the `AAPL_stock_price_example.csv` file to the Jupyter notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to upload the source CSV file in the correct file location so you can
    reference it in your Jupyter notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the following command to import the `numpy` library in the notebook
    input, `In []:`, and run the cell. There will be no output after running this
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the array by cleaning out all of the values before we can populate
    it. There will be no output after running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following block of code, we have to execute multiple consecutive commands
    in a loop. The sequence is important and Jupyter will auto-indent as you type
    in the `In []:` cell. I included comments to better understand the code. There
    will be no output after running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After `temp_array` is populated with elements, a quick `print()` function identifies
    another data cleanup step that is required to move forward. Type in the following
    command in the next `In []:` cell and run the cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the output cell displays `Out []`, which will look similar to the
    following screenshot. The array includes a header row value of `Close` and has
    single quotes around the price values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2bf6f084-5b78-4c6f-a5cd-69a67cb8a905.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The header row from the source file has been included in our array, which is
    easy to remove by assigning the array to itself and using the `delete()` function
    to delete the first element. There will be no output after running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `size()` function to confirm the size of the array matches the original
    source input file by adding the following commands running the cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the output cell displays `Out []`, which will look similar to the
    following screenshot. The number of rows is `229` when excluding the header row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/619353a1-21d2-4b2e-886a-6c6c4a0190f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The data type of the array has single quotes around each element. This can
    be remedied using a simple command from the `astype()` method by converting `dtype` of
    the array into `float` since the stock prices are decimal numeric values. There
    will be no output after running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the first few elements in the new array to verify the array has cleaned
    elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the array now has only numeric values in decimal format and the quotes
    have been removed, similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9b194839-679c-4678-84f1-4d814ed2dea5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last few steps are a repeat from the prior exercise. We start with sorting
    the array in descending order using the `sort()` function along with passing a
    parameter of `[::-1]` to sort from high to low. Type in the following command in
    the next `In []:` cell and run the cell. There will be no output after running
    this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the first few elements in the array to display the highest price by referencing
    the first sorted element in `sorted_stock_price_array` using the `print()` function
    by typing in the commands and running the cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the output cell displays `Out []`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will be two rows of output with the first as the original array of values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second output row is a sorted list of the values from the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad9202cd-f96c-42d8-894e-b3c24d9b5051.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To see the highest price, use the `print()` function and use the `[0]` command
    against the sorted array to display the first value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the output cell displays `Out []`, which will look similar to the
    following screenshot. The output should state `Highest closing stock price: 267.100006`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57e14172-405e-484b-97bb-99e5e29c7826.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, we have now learned how to use key features of the `numpy`
    library along with some practical real-world examples. We started by learning
    about arrays and why they are important by providing examples of how they have
    been rooted in computer science and programming languages for decades. We also
    learned about the foundation of structured data, which uses the concepts of arrays,
    by explaining the differences between single and multiple dimensional arrays and
    how we commonly identify them as tables with columns and rows.
  prefs: []
  type: TYPE_NORMAL
- en: Once the history and theories were explained, we learned how to make a NumPy
    array and walked through some useful functions available. We ended this chapter
    with a practical real-world example by loading stock prices into an array to show
    how it can answer specific questions by using a few NumPy commands available for
    data analysis. Data literacy skills were re-enforced throughout this chapter by
    understanding why data types impact data analysis and why the concept of KYD from [Chapter
    1](0fa7e28f-7a30-4099-9bae-30dd3c86ee4f.xhtml), *Fundamentals of Data Analysis*,
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will expand your data literacy skills with some hands-on
    lessons working with data structures called DataFrames using the `pandas` library.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some links that you can refer to, for more information on the relative
    topics of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Original NumPy user documentation: [http://people.csail.mit.edu/jrennie/python/numeric/numeric-manual.pdf](http://people.csail.mit.edu/jrennie/python/numeric/numeric-manual.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding Data Types in Python*: [https://jakevdp.github.io/PythonDataScienceHandbook/02.01-understanding-data-types.html](https://jakevdp.github.io/PythonDataScienceHandbook/02.01-understanding-data-types.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NumPy Cheat Sheet: Data Analysis in Python: [https://www.datacamp.com/community/blog/python-numpy-cheat-sheet](https://www.datacamp.com/community/blog/python-numpy-cheat-sheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The NumPy `genfromtxt()` function help guide: [https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image Processing with NumPy: [http://www.degeneratestate.org/posts/2016/Oct/23/image-processing-with-numpy/](http://www.degeneratestate.org/posts/2016/Oct/23/image-processing-with-numpy/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History of the Logo programming language: [http://www.sydlexia.com/logo.htm](http://www.sydlexia.com/logo.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logo emulator: [https://www.calormen.com/jslogo/#](https://www.calormen.com/jslogo/#)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difference between Python lists and NumPy arrays: [https://webcourses.ucf.edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference](https://webcourses.ucf.edu/courses/1249560/pages/python-lists-vs-numpy-arrays-what-is-the-difference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yahoo Finance Stock Ticker data: [https://finance.yahoo.com/quote/AAPL/history?period1=1546318800&period2=1574744400&interval=1d&filter=history&frequency=1d](https://finance.yahoo.com/quote/AAPL/history?period1=1546318800&period2=1574744400&interval=1d&filter=history&frequency=1d)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
