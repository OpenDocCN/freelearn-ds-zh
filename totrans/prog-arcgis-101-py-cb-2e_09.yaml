- en: Chapter 9. Using the ArcPy Data Access Module to Select, Insert, and Update
    Geographic Data and Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of cursor objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving features from a feature class with SearchCursor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering records with a where clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving cursor performance with Geometry tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting rows with InsertCursor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating rows with UpdateCursor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting rows with UpdateCursor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting and updating rows inside an edit session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading geometry from a feature class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start this chapter with a basic question. What are cursors? **Cursors**
    are in-memory objects containing one or more rows of data from a table or feature
    class. Each row contains the attributes from each field in the data source, along
    with the geometry for each feature. Cursors allow you to search, add, insert,
    update, and delete data from tables and feature classes.
  prefs: []
  type: TYPE_NORMAL
- en: The ArcPy Data Access module or `arcpy.da` is new to ArcGIS 10.1 and contains
    methods that allow you to iterate through each row in a cursor. Various types
    of cursors can be created. For example, search cursors can be created to read
    values from rows. Update cursors can be created to update values in rows or delete
    rows, and insert cursors can be created to insert new rows.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of cursor improvements that have been introduced with the
    ArcPy Data Access module. Prior to ArcGIS 10.1, cursor performance had been notoriously
    slow. Now, cursors are significantly faster. Esri has estimated that search cursors
    are up to 30 times faster while insert cursors are up to 12 times faster. In addition
    to these general performance improvements, the Data Access module also provides
    a number of new options that allow programmers to speed up processing. Rather
    than returning all the fields in a cursor, you can now specify that a subset of
    fields be returned. This increases the performance as less data needs to be returned.
    The same applies to geometry. Traditionally, when accessing the geometry of a
    feature, the entire geometric definition would be returned. You can now use geometry
    tokens to return a portion of the geometry rather than the full geometry for the
    feature. You can also use lists and tuples rather than using rows. Also new are
    edit sessions and the ability to work with versions, domains, and subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three cursor functions in `arcpy.da`. Each returns a cursor object
    having the same name as the function. `SearchCursor()` creates a read-only `SearchCursor`
    object containing rows from a table or feature class. `InsertCursor()` creates
    an `InsertCursor` object that can be used to insert new records into a table or
    feature class. `UpdateCursor()` returns a cursor object that can be used to edit
    or delete records from a table or feature class. Each of these cursor objects
    has methods for accessing rows in the cursor. You can see the relationship between
    the cursor functions, the objects they create, and how they are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Object Created | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SearchCursor()` | `SearchCursor` | Read-only view of data from a table or
    feature class |'
  prefs: []
  type: TYPE_TB
- en: '| `InsertCursor()` | `InsertCursor` | Adds rows to a table or feature class
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UpdateCursor()` | `UpdateCursor` | Edit or delete rows in a table or feature
    class |'
  prefs: []
  type: TYPE_TB
- en: The `SearchCursor()` function is used to return a `SearchCursor` object. This
    object can only be used to iterate through a set of rows returned for read-only
    purposes. No insertions, deletions, or updates can occur through this object.
    An optional `where` clause can be set to limit the rows returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve obtained a cursor instance, it is common to iterate through the
    records, particularly with a `SearchCursor` or `UpdateCursor`. There are some
    peculiarities that you need to understand about navigating the records in a cursor.
    Cursor navigation is forward moving only. When a cursor is created, the pointer
    for the cursor sits just above the first row in the cursor. The first call to
    `next()` will move the pointer to the first row. Rather than calling the `next()`
    method, you can also use a `for` loop to process each of the records without the
    need to call the `next()` method. After performing whatever processing you need
    to do with this row, a subsequent call to `next()` will move the pointer to row
    2\. This process continues as long as you need to access additional rows. However,
    after a row has been visited, you can''t go back a single record at a time. For
    instance, if the current row is row 3, you can''t programmatically back up to
    row 2\. You can only go forward. To revisit rows 1 and 2, you would need to either
    call the `reset()` method or recreate the cursor and move back through the object.
    As I mentioned, cursors are often navigated through the use of `for` loops as
    well. In fact, this is a more common way to iterate through a cursor and is a
    more efficient way to code your scripts. Cursor navigation is illustrated in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/4445OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `InsertCursor()` function is used to create an `InsertCursor` object that
    allows you to programmatically add new records to feature classes and tables.
    To insert rows, call the `insertRow()` method on this object. You can also retrieve
    a read-only tuple containing the field names in use by the cursor through the
    `fields` property. A lock is placed on the table or feature class being accessed
    through the cursor. It's important to always design your script in a way that
    releases the cursor when you are done.
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateCursor()` function can be used to create an `UpdateCursor` object
    that can update and delete rows in a table or feature class. As is the case with
    an `InsertCursor`, this function places a lock on the data while it's being edited
    or deleted. If the cursor is used inside a Python `with` statement, the lock will
    automatically be freed after the data has been processed. This hasn't always been
    the case. Prior to ArcGIS 10.1, cursors were required to be manually released
    using the Python `del` statement. Once an instance of `UpdateCursor` has been
    obtained, you can then call the `updateCursor()` method to update records in tables
    or feature classes and the `deleteRow()` method to delete a row.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of data locks requires a little more explanation. Insert and update
    cursors must obtain a lock on the data source they reference. This means that
    no other application can concurrently access this data source. Locks are a way
    of preventing multiple users from changing data at the same time and thus corrupting
    the data. When the `InsertCursor()` and `UpdateCursor()` methods are called in
    your code, Python attempts to acquire a lock on the data. This lock must be specifically
    released after the cursor has finished processing, so that other users running
    applications such as `ArcMap` or `ArcCatalog` can access the data sources. Otherwise,
    no other application will be able to access the data. Prior to ArcGIS 10.1 and
    the `with` statement, cursors had to be specifically unlocked through Python's
    `del` statement. Similarly, `ArcMap` and `ArcCatalog` also acquire data locks
    when updating or deleting data. If a data source has been locked by either of
    these applications, your Python code will not be able to access the data. Therefore,
    best practice is to close `ArcMap` and `ArcCatalog` before running any standalone
    Python scripts that use insert or update cursors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to cover the use of cursors for accessing and editing
    tables and feature classes. However, many of the cursor concepts that existed
    before ArcGIS 10.1 still apply.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving features from a feature class with a SearchCursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many occasions when you need to retrieve rows from a table or feature
    class for read-only purposes. For example, you might want to generate a list of
    all land parcels in a city with a value of greater than $100,000\. In this case,
    you don't have any need to edit the data. Your needs are met simply by generating
    a list of rows that meet some sort of criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SearchCursor()` function is used to return a `SearchCursor` object. This
    object can only be used to iterate through a set of rows returned for read-only
    purposes. No insertions, deletions, or updates can occur through this object.
    An optional `where` clause can be set to limit the rows returned. In this recipe,
    you will learn how to create a basic `SearchCursor` object on a feature class
    through the use of the `SearchCursor()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `SearchCursor` object contains a `fields` property along with `next()` and
    `reset()` methods. The `fields` property is a read-only structure in the form
    of a Python tuple, containing the fields requested from the feature class or table.
    You are going to hear the term tuple a lot in conjunction with cursors. If you
    haven't covered this topic before, tuples are a Python structure for storing a
    sequence of data similar to Python lists. But there are some important differences
    between Python tuples and lists. Tuples are defined as a sequence of values inside
    parentheses while lists are defined as a sequence of values inside brackets. Unlike
    lists, tuples can't grow and shrink, which can be a very good thing in some cases
    when you want data values to occupy a specific position each time. Such is the
    case with cursor objects that use tuples to store data from fields in tables and
    feature classes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to retrieve rows from a table or feature class
    inside a `SearchCursor` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a new script window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script as `c:\ArcpyBook\Ch9\SearchCursor.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy.da` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a Python `with` statement to create a cursor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through each row in the `SearchCursor` and print the name of the school.
    Make sure you indent the `for` loop inside the `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the script. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `with` statement, used with the `SearchCursor()` function, will create,
    open, and close the cursor. So you no longer have to be concerned with explicitly
    releasing the lock on the cursor as you did prior to ArcGIS 10.1\. The first parameter
    passed into the `SearchCursor()` function is a feature class, represented by the
    `Schools.shp` file. The second parameter is a Python tuple containing a list of
    fields that we want returned in the cursor. For performance reasons, it is a best
    practice to limit the fields returned in the cursor to only those that you need
    to complete the task. Here, we've specified that only the `Facility` and `Name`
    fields should be returned. The `SearchCursor` object is stored in a variable called
    `cursor`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `with` block, we are using a Python `for` loop to loop through each
    school returned. We're also using the Python `sorted()` function to sort the contents
    of the cursor. To access the values from a field on the row, simply use the index
    number of the field you want to return. In this case, we want to return the contents
    of the `Name` column, which will be index number `1`, since it is the second item
    in the tuple of field names that are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering records with a where clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, `SearchCursor` will contain all rows in a table or feature class.
    However, in many cases, you will want to restrict the number of rows returned
    by some sort of criteria. Applying a filter through the use of a `where` clause
    limits the records returned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, all rows from a table or feature class will be returned when you
    create a `SearchCursor` object. However, in many cases, you will want to restrict
    the records returned. You can do this by creating a query and passing it in as
    a `where` clause parameter when calling the `SearchCursor()` function. In this
    recipe, you'll build on the script you created in the previous recipe, by adding
    a `where` clause that restricts the records returned.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to apply a filter to a `SearchCursor` object that restricts
    the rows returned from a table or feature class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and load the `SearchCursor.py` script that you created in the previous
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `SearchCursor()` function by adding a `where` clause that queries
    the `facility` field for records that have the text `High School`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. The output will now be much smaller and restricted
    to only those schools that are high schools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We covered the creation of queries in [Chapter 8](ch08.html "Chapter 8. Querying
    and Selecting Data"), *Querying and Selecting Data*, so hopefully you now have
    a good grasp of how these are created along with all the rules you need to follow
    when coding these structures. The `where` clause parameter accepts any valid SQL
    query, and is used in this case to restrict the number of records that are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Improving cursor performance with geometry tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Geometry tokens** were introduced in ArcGIS 10.1 as a performance improvement
    for cursors. Rather than returning the entire geometry of a feature inside the
    cursor, only a portion of the geometry is returned. Returning the entire geometry
    of a feature can result in decreased cursor performance due to the amount of data
    that has to be returned. It''s significantly faster to return only the geometry
    that is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A token is provided as one of the fields in the `field` list passed into the
    constructor for a cursor and is in the format `SHAPE@<Part of Feature to be Returned>`.
    The only exception to this format is the `OID@` token, which returns the object
    ID of the feature. The following code example retrieves the x and y coordinates
    of a feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The following table lists the available geometry tokens. Not all cursors support
    the full list of tokens. Please check the ArcGIS help files for information on
    the tokens supported by each cursor type. The `SHAPE@` token returns the entire
    geometry of the feature. Use this carefully though, because it is an expensive
    operation to return the entire geometry of a feature and can dramatically affect
    performance. If you don't need the entire geometry, then do not include this token!
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4445OT_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, you will use a geometry token to increase the performance of
    a cursor. You'll retrieve the x and y coordinates of each land parcel from a `parcels`
    feature class, along with some attribute information about the parcel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a geometry token to a cursor, which should improve
    the performance of this object:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a new script window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script as `c:\ArcpyBook\Ch9\GeometryToken.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy.da` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re going to measure how long it takes to execute the code using a geometry
    token. Add a start time for the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a Python `with` statement to create a cursor that includes the centroid
    of each feature as well as the ownership information stored in the `PY_FULL_OW`
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through each row in `SearchCursor` and print the name of the school. Make
    sure you indent the `for` loop inside the `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Measure the elapsed time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the execution time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the script. You should see something similar to the following output. Note
    the execution time; your time will vary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''re going to measure the execution time if the entire geometry is returned
    instead of just the portion of the geometry that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: Save a new copy of the script as `c:\ArcpyBook\Ch9\GeometryTokenEntireGeometry.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `SearchCursor()` function to return the entire geometry using `SHAPE@`
    instead of `SHAPE@XY`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. You should see the following output. Your time will
    vary from mine, but notice that the execution time is slower. In this case, it''s
    only a little over a second slower but we''re only returning 2600 features. If
    the feature class were significantly large, as many are, this would be amplified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A geometry token can be supplied as one of the field names supplied in the constructor
    for the cursor. These tokens are used to increase the performance of a cursor
    by returning only a portion of the geometry instead of the entire geometry. This
    can dramatically increase the performance of a cursor, particularly when you are
    working with large polyline or polygon datasets. If you only need specific properties
    of the geometry in your cursor, you should use these tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting rows with InsertCursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can insert a row into a table or feature class using an `InsertCursor` object.
    If you want to insert attribute values along with the new row, you'll need to
    supply the values in the order found in the attribute table.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InsertCursor()` function is used to create an `InsertCursor` object that
    allows you to programmatically add new records to feature classes and tables.
    The `insertRow()` method on the `InsertCursor` object adds the row. A row, in
    the form of a list or tuple, is passed into the `insertRow()` method. The values
    in the list must correspond to the field values defined when the `InsertCursor`
    object was created. Just as with the other types of cursors, you can also limit
    the field names returned using the second parameter of the method. This function
    supports geometry tokens as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates how you can use `InsertCursor` to insert
    new rows into a feature class. Here, we are inserting two new wildfire points
    into the `California` feature class. The row values to be inserted are defined
    in a `list` variable. Then, an `InsertCursor` object is created, passing in the
    feature class and fields. Finally, the new rows are inserted into the feature
    class using the `insertRow()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, you will use `InsertCursor` to add wildfires retrieved from
    a `text` file into a point feature class. When inserting rows into a feature class,
    you will need to know how to add the geometric representation of a feature into
    the feature class. This can be accomplished using `InsertCursor` along with two
    miscellaneous objects: `Array` and `Point`. In this exercise, we will add point
    features in the form of wildfire incidents to an empty point feature class. In
    addition, you will use Python file manipulation techniques to read the coordinate
    data from a text file.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be importing North American wildland fire incident data from a single
    day in October, 2007\. This data is contained in a comma-delimited text file containing
    one line for each fire incident on that particular day. Each fire incident has
    a latitude/longitude coordinate pair separated by commas along with a confidence
    value. This data was derived by automated methods that use remote sensing data
    to derive the presence or absence of a wildfire. Confidence values can range from
    0 to 100\. Higher numbers represent a greater confidence that this is indeed a
    wildfire:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file at `c:\ArcpyBook\Ch9\Wildfire Data\NorthAmericaWildfire_2007275.txt`
    and examine the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that this is a simple comma-delimited text file containing longitude
    and latitude values for each fire along with a confidence value. We will use Python
    to read the contents of this file line-by-line and insert new point features into
    the `FireIncidents` feature class located in the `c:\ArcpyBook\Ch9 \WildfireData\WildlandFires.mdb`
    personal geodatabase.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `ArcCatalog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `c:\ArcpyBook\Ch9\WildfireData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see a personal geodatabase called `WildlandFires`. Open this geodatabase
    and you will see a point feature class called `FireIncidents`. Right now this
    is an empty feature class. We will add features by reading the text file you examined
    earlier and inserting points.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on `FireIncidents` and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Fields** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The latitude/longitude values found in the file we examined earlier will be
    imported into the `SHAPE` field and the confidence values will be written to the
    `CONFIDENCEVALUE` field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open IDLE and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `c:\ArcpyBook\Ch9\InsertWildfires.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` and `os` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the text file and read all the lines into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `InsertCursor` object using a `with` block. Make sure you indent
    inside the `try` statement. The cursor will be created on the `FireIncidents`
    feature class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a counter variable that will be used to print the progress of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through the text file line by line using a `for` loop. Since the text
    file is comma-delimited, we''ll use the Python `split()` function to separate
    each value into a list variable called `vals`. We''ll then pull out the individual
    latitude, longitude, and confidence value items and assign them to variables.
    Finally, we''ll place these values into a list variable called `rowValue`, which
    is then passed into the `insertRow()` function for the `InsertCursor` object,
    and then we''ll print a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `except` block to print any errors that may occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `finally` block to close the text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `ArcMap` and add the `FireIncidents` feature class to the table of contents.
    The points should be visible, as shown in the following screenshot:![How to do
    it…](img/4445_09_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some additional explanation may be needed here. The `lstFires` variable contains
    a list of all the wildfires that were contained in the comma-delimited text file.
    The `for` statement will loop through each of these records one by one, inserting
    each individual record into the `fire` variable. We also include an `if` statement
    that is used to skip the first record in the file, which serves as the header.
    As I explained earlier, we then pull out the individual latitude, longitude, and
    confidence value items from the `vals` variable, which is just a Python list object
    and assign them to variables called `latitude`, `longitude`, and `confid`. We
    then place these values into a new list variable called `rowValue` in the order
    that we defined when we created `InsertCursor`. That is, the latitude and longitude
    pair should be placed first, followed by the confidence value. Finally, we call
    the `insertRow()` function on the `InsertCursor` object assigned to the variable
    `cur`, passing in the new `rowValue` variable. We close by printing a message
    that indicates the progress of the script and also creating our `except` and `finally`
    blocks to handle errors and close the text file. Placing the `file.close()` method
    in the `finally` block ensures that it will execute, and close the file, even
    if there is an error in the previous try statement.
  prefs: []
  type: TYPE_NORMAL
- en: Updating rows with an UpdateCursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to edit or delete rows from a table or feature class, you can use
    `UpdateCursor`. As is the case with `InsertCursor`, the contents of `UpdateCursor`
    can be limited through the use of a `where` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UpdateCursor()` function can be used to either update or delete rows in
    a table or feature class. The returned cursor places a lock on the data, which
    will automatically be released if used inside a Python `with` statement. An `UpdateCursor`
    object is returned from a call to this method.
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateCursor` object places a lock on the data while it's being edited
    or deleted. If the cursor is used inside a Python `with` statement, the lock will
    automatically be freed after the data has been processed. This hasn't always been
    the case. Previous versions of cursors were required to be manually released using
    the Python `del` statement. Once an instance of `UpdateCursor` has been obtained,
    you can then call the `updateCursor()` method to update records in tables or feature
    classes and the `deleteRow()` method to delete a row.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you're going to write a script that updates each feature in
    the `FireIncidents` feature class by assigning a value of `poor`, `fair`, `good`,
    or `excellent` to a new field that is more descriptive of the confidence values
    using an `UpdateCursor`. Prior to updating the records, your script will add a
    new field to the `FireIncidents` feature class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an `UpdateCursor` object that will be used to
    edit rows in a feature class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `c:\ArcpyBook\Ch9\UpdateWildfires.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` and `os` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new field called `CONFID_RATING` to the `FireIncidents` feature class.
    Make sure to indent inside the `try` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `UpdateCursor` inside a `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a counter variable that will be used to print the progress of the script.
    Make sure you indent this line of code and all the lines of code to follow inside
    the `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through each of the rows in the `FireIncidents` fire class. Update the
    `CONFID_RATING` field according to the following guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confidence value 0 to 40 = `POOR`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidence value 41 to 60 = `FAIR`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidence value 61 to 85 = `GOOD`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidence value 86 to 100 = `EXCELLENT`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `except` block to print any errors that may occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `ArcMap` and add the `FireIncidents` feature class. Open the attribute
    table and you should see that a new `CONFID_RATING` field has been added and populated
    by `UpdateCursor`:![How to do it…](img/4445_09_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When you insert, update, or delete data in cursors, the changes are permanent
    and can't be undone if you're working outside an edit session. However, with the
    new edit session functionality provided by ArcGIS 10.1, you can now make these
    changes inside an edit session to avoid these problems. We'll cover edit sessions
    soon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, we've used `UpdateCursor` to update each of the features in a
    feature class. We first used the `Add Field` tool to add a new field called `CONFID_RATING`,
    which will hold new values that we assign based on values found in another field.
    The groups are poor, fair, good, and excellent, and are based on numeric values
    found in the `CONFIDENCEVALUE` field. We then created a new instance of `UpdateCursor`
    based on the `FireIncidents` feature class, and returned the two fields mentioned
    previously. The script then loops through each of the features and assigns a value
    of poor, fair, good, or excellent to the `CONFID_RATING` field (`row[1]`), based
    on the numeric value found in `CONFIDENCEVALUE`. A Python `if`/`elif`/`else` structure
    is used to control the flow of the script based on the numeric value. The value
    for `CONFID_RATING` is then committed to the feature class by passing in the row
    variable into the `updateRow()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting rows with an UpdateCursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to being used to edit rows in a table or feature class, an `UpdateCursor`
    can also be used to delete rows. Please keep in mind that when rows are deleted
    outside an edit session, the changes are permanent.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to updating records, `UpdateCursor` can also delete records from
    a table or feature class. The `UpdateCursor` object is created in the same way
    in either case, but instead of calling `updateRow()`, you call `deleteRow()` to
    delete a record. You can also apply a `where` clause to `UpdateCursor`, to limit
    the records returned. In this recipe, we'll use an `UpdateCursor` object that
    has been filtered using a `where` clause to delete records from our `FireIncidents`
    feature class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an `UpdateCursor` object that will be used delete
    rows from a feature class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `c:\ArcpyBook\Ch9\DeleteWildfires.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` and `os` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `UpdateCursor` inside a `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a counter variable that will be used to print the progress of the script.
    Make sure you indent this line of code and all the lines of code to follow inside
    the `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the returned rows by calling the `deleteRow()` method. This is done
    by looping through the returned cursor and deleting the rows one at a time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `except` block to print any errors that may occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs. 37 records should be deleted from the `FireIncidents`
    feature class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rows from feature classes and tables can be deleted using the `deleteRow()`
    method on `UpdateCursor`. In this recipe, we used a `where` clause in the constructor
    of `UpdateCursor` to limit the records returned to only those features with a
    `CONFID_RATING` of `POOR`. We then looped through the features returned in the
    cursor and called the `deleteRow()` method to delete the row from the feature
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting and updating rows inside an edit session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I've mentioned throughout the chapter, inserts, updates, or deletes to a
    table or feature class done outside an edit session are permanent. They can't
    be undone. Edit sessions give you much more flexibility for rolling back any unwanted
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we've used insert and update cursors to add, edit, and delete
    data from feature classes and tables. These changes have been permanent as soon
    as the script was executed and can't be undone. The new `Editor` class in the
    Data Access module supports the ability to create edit sessions and operations.
    With edit sessions, changes applied to feature classes or tables are temporary
    until permanently applied with a specific method call. This is the same functionality
    provided by the `Edit` toolbar in ArcGIS Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit sessions begin with a call to `Editor.startEditing()`, which initiates
    the session. Inside the session, you then start an operation with the `Editor.startOperation()`
    method. From within this operation, you then perform various operations that perform
    edits on your data. These edits can also be subject to undo, redo, and abort operations
    for rolling back, rolling forward, and aborting your editing operations. After
    the operations have been completed, you then call the `Editor.stopOperation()`
    method followed by `Editor.stopEditing()`. Sessions can be ended without saving
    changes. In this event, changes are not permanently applied. An overview of this
    process is provided in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4445OT_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Edit sessions can also be ended without saving changes. In this event, changes
    are not permanently applied. Edit sessions also allow for operations to be applied
    inside the session and then either applied permanently to the database or rolled
    back. In addition, the `Editor` class also supports undo and redo operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example shows the full edit session stack including the
    creation of the `Editor` object, the beginning of an edit session and an operation,
    edits to the data (an insert in this case), stopping the operation, and finally
    the end of the edit session by saving the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `Editor` class can be used with personal, file, and ArcSDE geodatabases.
    In addition, sessions can also be started and stopped on versioned databases.
    You are limited to editing only a single workspace at a time, and this workspace
    is specified in the constructor for the `Editor` object simply by passing in a
    string that references the workspace. Once created, this `Editor` object then
    has access to all the methods for starting, stopping, and aborting operations,
    and performing undo and redo operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to wrap `UpdateCursor` inside an edit session:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `c:\ArcpyBook\Ch9\UpdateWildfires.py` script and save it to a new script
    called `c:\ArcpyBook\Ch9\EditSessionUpdateWildfires.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to make several alterations to this existing script that updates
    values in the `CONFID_RATING` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an instance of the `Editor` class and start an edit session. These lines
    of code should be placed just inside the `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alter the `if` statement so that it appears as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'End the edit session and save edits. Place this line of code just below the
    counter increment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and run the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Edit operations should take place inside an edit session, which can be initiated
    with the `Editor.startEditing()` method. The `startEditing()` method takes two
    optional parameters including `with_undo` and `multiuser_mode`. The `with_undo`
    parameter accepts a Boolean value of `true` or `false`, with a default of `true`.
    This creates an undo/redo stack when set to `true`. The `multiuser_mode` parameter
    defaults to `true`. When `false`, you have full control of editing a non-versioned
    or versioned dataset. If your dataset is non-versioned and you use `stopEditing(False)`,
    your edits will not be committed. Otherwise, if set to `true`, your edits will
    be committed. The `Editor.stopEditing()` method takes a single Boolean value of
    `true` or `false`, indicating whether changes should be saved or not. This defaults
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Editor` class supports undo and redo operations. We''ll first look at
    undo operations. During an edit session, various edit operations can be applied.
    In the event that you need to undo a previous operation, a call to `Editor.undoOperation()`
    will remove the most previous edit operation in the stack. This is illustrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4445OT_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Redo operations, initiated by the `Editor.redoOperation()` method, will redo
    an operation that was previously undone. This is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4445OT_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reading geometry from a feature class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when you need to retrieve the geometric definition of features
    in a feature class. ArcPy provides the ability to read this information through
    various objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ArcPy, feature classes have associated geometry objects including `Polygon`,
    `Polyline`, `PointGeometry`, and `MultiPoint` that you can access from your cursors.
    These objects refer to the `shape` field in the attribute table for a feature
    class. You can read the geometries of each feature in a feature class through
    these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Polyline and polygon feature classes are composed of features containing multiple
    parts. You can use the `partCount` property to return the number of parts per
    feature and then use `getPart()` for each part in the feature to loop through
    each of the points and pull out the coordinate information. Point feature classes
    are composed of one `PointGeometry` object per feature that contains the coordinate
    information for each point.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will use a `SearchCursor` and `Polygon` object to read the
    geometry of a polygon feature class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to read the geometric information from each
    feature in a feature class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `c:\ArcpyBook\Ch9\ReadGeometry.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the input feature class to the `SchoolDistricts` polygon feature class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `SearchCursor` object with the input feature class, and return the
    `ObjectID` and `Shape` fields. The `Shape` field contains the geometry for each
    feature. The cursor will be created inside a `for` loop that we''ll use to iterate
    through all the features in the feature class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a `for` loop to loop through each part of the feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a `for` loop to loop through each vertex in each part and print the x and
    y coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. You should see the following output as the script
    writes the information for each feature, each part of the feature, and the x and
    y coordinates that define each part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We initially created a `SearchCursor` object to hold the contents of our feature
    class. After this, we looped through each row in the cursor using a `for` loop.
    For each row, we looped through all the parts of the geometry. Remember that polyline
    and polygon features are composed of two or more parts. For each part, we also
    returned the points associated with each part and we printed the `x` and `y` coordinates
    of each point.
  prefs: []
  type: TYPE_NORMAL
