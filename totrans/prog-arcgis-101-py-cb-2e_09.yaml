- en: Chapter 9. Using the ArcPy Data Access Module to Select, Insert, and Update
    Geographic Data and Tables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：使用 ArcPy 数据访问模块选择、插入和更新地理数据和表
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Overview of cursor objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游标对象概述
- en: Retrieving features from a feature class with SearchCursor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SearchCursor 从要素类中检索特征
- en: Filtering records with a where clause
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 where 子句过滤记录
- en: Improving cursor performance with Geometry tokens
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何标记提高游标性能
- en: Inserting rows with InsertCursor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 InsertCursor 插入行
- en: Updating rows with UpdateCursor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UpdateCursor 更新行
- en: Deleting rows with UpdateCursor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UpdateCursor 删除行
- en: Inserting and updating rows inside an edit session
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑会话中插入和更新行
- en: Reading geometry from a feature class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从要素类中读取几何形状
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: We'll start this chapter with a basic question. What are cursors? **Cursors**
    are in-memory objects containing one or more rows of data from a table or feature
    class. Each row contains the attributes from each field in the data source, along
    with the geometry for each feature. Cursors allow you to search, add, insert,
    update, and delete data from tables and feature classes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从本章的基本问题开始。什么是游标？**游标**是包含来自表或要素类中的一行或多行数据的内存对象。每一行包含数据源中每个字段的属性，以及每个要素的几何形状。游标允许您从表和要素类中搜索、添加、插入、更新和删除数据。
- en: The ArcPy Data Access module or `arcpy.da` is new to ArcGIS 10.1 and contains
    methods that allow you to iterate through each row in a cursor. Various types
    of cursors can be created. For example, search cursors can be created to read
    values from rows. Update cursors can be created to update values in rows or delete
    rows, and insert cursors can be created to insert new rows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ArcPy 数据访问模块或 `arcpy.da` 是 ArcGIS 10.1 中新增的，它包含允许您遍历游标中每一行的方法。可以创建各种类型的游标。例如，可以创建搜索游标来读取行中的值。可以创建更新游标来更新行中的值或删除行，也可以创建插入游标来插入新行。
- en: There are a number of cursor improvements that have been introduced with the
    ArcPy Data Access module. Prior to ArcGIS 10.1, cursor performance had been notoriously
    slow. Now, cursors are significantly faster. Esri has estimated that search cursors
    are up to 30 times faster while insert cursors are up to 12 times faster. In addition
    to these general performance improvements, the Data Access module also provides
    a number of new options that allow programmers to speed up processing. Rather
    than returning all the fields in a cursor, you can now specify that a subset of
    fields be returned. This increases the performance as less data needs to be returned.
    The same applies to geometry. Traditionally, when accessing the geometry of a
    feature, the entire geometric definition would be returned. You can now use geometry
    tokens to return a portion of the geometry rather than the full geometry for the
    feature. You can also use lists and tuples rather than using rows. Also new are
    edit sessions and the ability to work with versions, domains, and subtypes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ArcPy 数据访问模块引入了许多游标改进。在 ArcGIS 10.1 之前，游标性能一直很慢。现在，游标的速度显著提高。Esri 估计，搜索游标的速度提高了高达
    30 倍，而插入游标的速度提高了高达 12 倍。除了这些一般的性能改进之外，数据访问模块还提供了一些新的选项，允许程序员加快处理速度。现在，您可以选择返回游标中的部分字段，而不是所有字段，这提高了性能，因为需要返回的数据更少。同样适用于几何形状。传统上，在访问要素的几何形状时，会返回整个几何定义。现在，您可以使用几何标记来返回几何形状的一部分，而不是要素的完整几何形状。您还可以使用列表和元组而不是使用行。此外，还有编辑会话以及与版本、域和子类型一起工作的能力。
- en: 'There are three cursor functions in `arcpy.da`. Each returns a cursor object
    having the same name as the function. `SearchCursor()` creates a read-only `SearchCursor`
    object containing rows from a table or feature class. `InsertCursor()` creates
    an `InsertCursor` object that can be used to insert new records into a table or
    feature class. `UpdateCursor()` returns a cursor object that can be used to edit
    or delete records from a table or feature class. Each of these cursor objects
    has methods for accessing rows in the cursor. You can see the relationship between
    the cursor functions, the objects they create, and how they are used as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`arcpy.da` 中有三个游标函数。每个函数返回一个与函数同名的游标对象。`SearchCursor()` 创建一个只读的 `SearchCursor`
    对象，包含来自表或要素类的行。`InsertCursor()` 创建一个 `InsertCursor` 对象，可用于向表或要素类中插入新记录。`UpdateCursor()`
    返回一个游标对象，可用于编辑或删除表或要素类中的记录。每个游标对象都有访问游标中行的方法。您可以通过以下方式了解游标函数、它们创建的对象以及它们的使用方式：'
- en: '| Function | Object Created | Usage |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 创建的对象 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SearchCursor()` | `SearchCursor` | Read-only view of data from a table or
    feature class |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `SearchCursor()` | `SearchCursor` | 从表或要素类中读取数据的只读视图 |'
- en: '| `InsertCursor()` | `InsertCursor` | Adds rows to a table or feature class
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `InsertCursor()` | `InsertCursor` | 向表或要素类添加行 |'
- en: '| `UpdateCursor()` | `UpdateCursor` | Edit or delete rows in a table or feature
    class |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `UpdateCursor()` | `UpdateCursor` | 在表或要素类中编辑或删除行 |'
- en: The `SearchCursor()` function is used to return a `SearchCursor` object. This
    object can only be used to iterate through a set of rows returned for read-only
    purposes. No insertions, deletions, or updates can occur through this object.
    An optional `where` clause can be set to limit the rows returned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchCursor()` 函数用于返回一个 `SearchCursor` 对象。此对象只能用于迭代为只读目的返回的一组行。通过此对象不能进行插入、删除或更新操作。可以设置可选的
    `where` 子句以限制返回的行。'
- en: 'Once you''ve obtained a cursor instance, it is common to iterate through the
    records, particularly with a `SearchCursor` or `UpdateCursor`. There are some
    peculiarities that you need to understand about navigating the records in a cursor.
    Cursor navigation is forward moving only. When a cursor is created, the pointer
    for the cursor sits just above the first row in the cursor. The first call to
    `next()` will move the pointer to the first row. Rather than calling the `next()`
    method, you can also use a `for` loop to process each of the records without the
    need to call the `next()` method. After performing whatever processing you need
    to do with this row, a subsequent call to `next()` will move the pointer to row
    2\. This process continues as long as you need to access additional rows. However,
    after a row has been visited, you can''t go back a single record at a time. For
    instance, if the current row is row 3, you can''t programmatically back up to
    row 2\. You can only go forward. To revisit rows 1 and 2, you would need to either
    call the `reset()` method or recreate the cursor and move back through the object.
    As I mentioned, cursors are often navigated through the use of `for` loops as
    well. In fact, this is a more common way to iterate through a cursor and is a
    more efficient way to code your scripts. Cursor navigation is illustrated in the
    following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了游标实例，通常会对记录进行迭代，特别是使用 `SearchCursor` 或 `UpdateCursor`。你需要了解一些关于在游标中导航记录的特别之处。游标导航仅向前移动。当创建游标时，游标的指针位于游标中第一行之上。第一次调用
    `next()` 将指针移动到第一行。你不仅可以调用 `next()` 方法，还可以使用 `for` 循环来处理每个记录，而无需调用 `next()` 方法。在完成对当前行的任何所需处理之后，后续调用
    `next()` 将指针移动到第二行。只要你需要访问额外的行，这个过程就会继续。然而，一旦访问了行，就不能一次回退一个记录。例如，如果当前行是第三行，就不能以编程方式回退到第二行。你只能向前移动。要重新访问第一行和第二行，你需要调用
    `reset()` 方法或重新创建游标并遍历对象。正如我提到的，游标通常通过 `for` 循环进行导航。事实上，这是遍历游标的一种更常见的方式，也是编写脚本的一种更有效的方式。游标导航在以下图中说明：
- en: '![Introduction](img/4445OT_09_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/4445OT_09_02.jpg)'
- en: The `InsertCursor()` function is used to create an `InsertCursor` object that
    allows you to programmatically add new records to feature classes and tables.
    To insert rows, call the `insertRow()` method on this object. You can also retrieve
    a read-only tuple containing the field names in use by the cursor through the
    `fields` property. A lock is placed on the table or feature class being accessed
    through the cursor. It's important to always design your script in a way that
    releases the cursor when you are done.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertCursor()` 函数用于创建一个 `InsertCursor` 对象，允许你以编程方式向要素类和表中添加新记录。要插入行，请在此对象上调用
    `insertRow()` 方法。你也可以通过 `fields` 属性检索一个只读元组，其中包含游标正在使用的字段名称。对通过游标访问的表或要素类执行锁定。始终以设计脚本的方式释放游标是很重要的。'
- en: The `UpdateCursor()` function can be used to create an `UpdateCursor` object
    that can update and delete rows in a table or feature class. As is the case with
    an `InsertCursor`, this function places a lock on the data while it's being edited
    or deleted. If the cursor is used inside a Python `with` statement, the lock will
    automatically be freed after the data has been processed. This hasn't always been
    the case. Prior to ArcGIS 10.1, cursors were required to be manually released
    using the Python `del` statement. Once an instance of `UpdateCursor` has been
    obtained, you can then call the `updateCursor()` method to update records in tables
    or feature classes and the `deleteRow()` method to delete a row.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCursor()`函数可以用来创建一个`UpdateCursor`对象，该对象可以更新和删除表或要素类中的行。与`InsertCursor`一样，此函数在编辑或删除数据时会对数据进行锁定。如果游标在Python的`with`语句内部使用，锁将在数据处理完毕后自动释放。这并不总是如此。在ArcGIS
    10.1之前，游标需要使用Python的`del`语句手动释放。一旦获取了`UpdateCursor`的实例，您就可以调用`updateCursor()`方法来更新表或要素类中的记录，以及调用`deleteRow()`方法来删除一行。'
- en: The subject of data locks requires a little more explanation. Insert and update
    cursors must obtain a lock on the data source they reference. This means that
    no other application can concurrently access this data source. Locks are a way
    of preventing multiple users from changing data at the same time and thus corrupting
    the data. When the `InsertCursor()` and `UpdateCursor()` methods are called in
    your code, Python attempts to acquire a lock on the data. This lock must be specifically
    released after the cursor has finished processing, so that other users running
    applications such as `ArcMap` or `ArcCatalog` can access the data sources. Otherwise,
    no other application will be able to access the data. Prior to ArcGIS 10.1 and
    the `with` statement, cursors had to be specifically unlocked through Python's
    `del` statement. Similarly, `ArcMap` and `ArcCatalog` also acquire data locks
    when updating or deleting data. If a data source has been locked by either of
    these applications, your Python code will not be able to access the data. Therefore,
    best practice is to close `ArcMap` and `ArcCatalog` before running any standalone
    Python scripts that use insert or update cursors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据锁的主题需要稍作解释。插入和更新游标必须对其引用的数据源获取锁。这意味着没有其他应用程序可以同时访问此数据源。锁是防止多个用户同时更改数据并因此损坏数据的一种方式。当在您的代码中调用`InsertCursor()`和`UpdateCursor()`方法时，Python会尝试获取数据的锁。此锁必须在游标完成处理之后特别释放，以便其他运行`ArcMap`或`ArcCatalog`等应用程序的用户可以访问数据源。否则，其他应用程序将无法访问数据。在ArcGIS
    10.1和`with`语句之前，游标必须通过Python的`del`语句特别解锁。同样，`ArcMap`和`ArcCatalog`在更新或删除数据时也会获取数据锁。如果数据源被这些应用程序中的任何一个锁定，您的Python代码将无法访问数据。因此，最佳实践是在运行任何使用插入或更新游标的独立Python脚本之前关闭`ArcMap`和`ArcCatalog`。
- en: In this chapter, we're going to cover the use of cursors for accessing and editing
    tables and feature classes. However, many of the cursor concepts that existed
    before ArcGIS 10.1 still apply.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用游标访问和编辑表和要素类的方法。然而，在ArcGIS 10.1之前存在的许多游标概念仍然适用。
- en: Retrieving features from a feature class with a SearchCursor
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SearchCursor从要素类检索要素
- en: There are many occasions when you need to retrieve rows from a table or feature
    class for read-only purposes. For example, you might want to generate a list of
    all land parcels in a city with a value of greater than $100,000\. In this case,
    you don't have any need to edit the data. Your needs are met simply by generating
    a list of rows that meet some sort of criteria.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多场合需要从表或要素类中检索行以进行只读操作。例如，您可能想生成一个包含价值超过100,000美元的所有城市土地地块的列表。在这种情况下，您不需要编辑数据。您的需求仅通过生成满足某些条件的行列表即可满足。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `SearchCursor()` function is used to return a `SearchCursor` object. This
    object can only be used to iterate through a set of rows returned for read-only
    purposes. No insertions, deletions, or updates can occur through this object.
    An optional `where` clause can be set to limit the rows returned. In this recipe,
    you will learn how to create a basic `SearchCursor` object on a feature class
    through the use of the `SearchCursor()` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchCursor()`函数用于返回一个`SearchCursor`对象。此对象只能用于遍历为只读目的返回的行集。通过此对象不能进行插入、删除或更新操作。可以设置一个可选的`where`子句来限制返回的行。在本食谱中，您将学习如何通过使用`SearchCursor()`函数在要素类上创建一个基本的`SearchCursor`对象。'
- en: The `SearchCursor` object contains a `fields` property along with `next()` and
    `reset()` methods. The `fields` property is a read-only structure in the form
    of a Python tuple, containing the fields requested from the feature class or table.
    You are going to hear the term tuple a lot in conjunction with cursors. If you
    haven't covered this topic before, tuples are a Python structure for storing a
    sequence of data similar to Python lists. But there are some important differences
    between Python tuples and lists. Tuples are defined as a sequence of values inside
    parentheses while lists are defined as a sequence of values inside brackets. Unlike
    lists, tuples can't grow and shrink, which can be a very good thing in some cases
    when you want data values to occupy a specific position each time. Such is the
    case with cursor objects that use tuples to store data from fields in tables and
    feature classes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchCursor` 对象包含一个 `fields` 属性以及 `next()` 和 `reset()` 方法。`fields` 属性是一个只读结构，形式为
    Python 元组，包含从要素类或表中请求的字段。您将经常在游标相关的上下文中听到术语元组。如果您之前没有覆盖这个主题，元组是用于存储类似 Python 列的数据序列的
    Python 结构。但 Python 元组和列表之间有一些重要的区别。元组定义为括号内的值序列，而列表定义为方括号内的值序列。与列表不同，元组不能增长和缩小，这在某些情况下可能是一个非常好的事情，当您希望数据值每次都占据特定位置时。这种情况适用于使用元组存储来自表和要素类字段数据的游标对象。'
- en: How to do it…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to learn how to retrieve rows from a table or feature class
    inside a `SearchCursor` object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何在 `SearchCursor` 对象内部检索表或要素类的行：
- en: Open IDLE and create a new script window.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IDLE 并创建一个新的脚本窗口。
- en: Save the script as `c:\ArcpyBook\Ch9\SearchCursor.py`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为 `c:\ArcpyBook\Ch9\SearchCursor.py`。
- en: 'Import the `arcpy.da` module:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `arcpy.da` 模块：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Set the workspace:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use a Python `with` statement to create a cursor:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 的 `with` 语句创建游标：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Loop through each row in the `SearchCursor` and print the name of the school.
    Make sure you indent the `for` loop inside the `with` block:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `SearchCursor` 中的每一行并打印学校的名称。确保在 `with` 块内部缩进 `for` 循环：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the script.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'Run the script. You should see the following output:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。你应该会看到以下输出：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `with` statement, used with the `SearchCursor()` function, will create,
    open, and close the cursor. So you no longer have to be concerned with explicitly
    releasing the lock on the cursor as you did prior to ArcGIS 10.1\. The first parameter
    passed into the `SearchCursor()` function is a feature class, represented by the
    `Schools.shp` file. The second parameter is a Python tuple containing a list of
    fields that we want returned in the cursor. For performance reasons, it is a best
    practice to limit the fields returned in the cursor to only those that you need
    to complete the task. Here, we've specified that only the `Facility` and `Name`
    fields should be returned. The `SearchCursor` object is stored in a variable called
    `cursor`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `SearchCursor()` 函数一起使用的 `with` 语句将创建、打开和关闭游标。因此，您不再需要担心像在 ArcGIS 10.1 之前那样显式释放游标的锁。传递给
    `SearchCursor()` 函数的第一个参数是一个要素类，由 `Schools.shp` 文件表示。第二个参数是一个 Python 元组，包含我们希望在游标中返回的字段列表。出于性能考虑，将游标中返回的字段限制为仅您需要完成任务的字段是一种最佳实践。在这里，我们指定只返回
    `Facility` 和 `Name` 字段。`SearchCursor` 对象存储在一个名为 `cursor` 的变量中。
- en: Inside the `with` block, we are using a Python `for` loop to loop through each
    school returned. We're also using the Python `sorted()` function to sort the contents
    of the cursor. To access the values from a field on the row, simply use the index
    number of the field you want to return. In this case, we want to return the contents
    of the `Name` column, which will be index number `1`, since it is the second item
    in the tuple of field names that are returned.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `with` 块内部，我们使用 Python 的 `for` 循环遍历返回的每一所学校。我们还使用 Python 的 `sorted()` 函数对游标的内容进行排序。要从行中的字段访问值，只需使用您要返回的字段的索引号。在这种情况下，我们想返回
    `Name` 列的内容，这将是一个索引号为 `1` 的值，因为它是在返回的字段名元组中的第二个项目。
- en: Filtering records with a where clause
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `where` 子句过滤记录
- en: By default, `SearchCursor` will contain all rows in a table or feature class.
    However, in many cases, you will want to restrict the number of rows returned
    by some sort of criteria. Applying a filter through the use of a `where` clause
    limits the records returned.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`SearchCursor` 将包含表或要素类中的所有行。然而，在许多情况下，您可能希望根据某种标准限制返回的行数。通过使用 `where`
    子句应用过滤器可以限制返回的记录。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By default, all rows from a table or feature class will be returned when you
    create a `SearchCursor` object. However, in many cases, you will want to restrict
    the records returned. You can do this by creating a query and passing it in as
    a `where` clause parameter when calling the `SearchCursor()` function. In this
    recipe, you'll build on the script you created in the previous recipe, by adding
    a `where` clause that restricts the records returned.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你创建一个`SearchCursor`对象时，将返回表或要素类中的所有行。然而，在许多情况下，你可能想要限制返回的记录。你可以通过创建一个查询，并在调用`SearchCursor()`函数时将其作为`where`子句参数传递来实现这一点。在这个菜谱中，你将在上一个菜谱中创建的脚本的基础上进行扩展，通过添加一个限制返回记录的`where`子句。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to apply a filter to a `SearchCursor` object that restricts
    the rows returned from a table or feature class:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将过滤器应用到`SearchCursor`对象上，以限制从表或要素类返回的行：
- en: Open IDLE and load the `SearchCursor.py` script that you created in the previous
    recipe.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IDLE并加载你在上一个菜谱中创建的`SearchCursor.py`脚本。
- en: 'Update the `SearchCursor()` function by adding a `where` clause that queries
    the `facility` field for records that have the text `High School`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个查询`facility`字段的`where`子句来更新`SearchCursor()`函数，以查询具有文本`High School`的记录：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save and run the script. The output will now be much smaller and restricted
    to only those schools that are high schools:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。现在输出将大大减小，仅限于那些高中：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We covered the creation of queries in [Chapter 8](ch08.html "Chapter 8. Querying
    and Selecting Data"), *Querying and Selecting Data*, so hopefully you now have
    a good grasp of how these are created along with all the rules you need to follow
    when coding these structures. The `where` clause parameter accepts any valid SQL
    query, and is used in this case to restrict the number of records that are returned.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](ch08.html "第8章。查询和选择数据")中介绍了查询的创建，*查询和选择数据*，所以希望你现在对这些创建方法以及编写这些结构时需要遵循的所有规则有很好的掌握。`where`子句参数接受任何有效的SQL查询，并且在此情况下用于限制返回的记录数。
- en: Improving cursor performance with geometry tokens
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何令牌提高游标性能
- en: '**Geometry tokens** were introduced in ArcGIS 10.1 as a performance improvement
    for cursors. Rather than returning the entire geometry of a feature inside the
    cursor, only a portion of the geometry is returned. Returning the entire geometry
    of a feature can result in decreased cursor performance due to the amount of data
    that has to be returned. It''s significantly faster to return only the geometry
    that is needed.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**几何令牌**在ArcGIS 10.1中被引入，作为游标性能改进的一部分。而不是在游标内返回要素的整个几何形状，只返回几何形状的一部分。返回要素的整个几何形状可能会导致游标性能下降，因为需要返回的数据量很大。只返回所需的几何形状要快得多。'
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A token is provided as one of the fields in the `field` list passed into the
    constructor for a cursor and is in the format `SHAPE@<Part of Feature to be Returned>`.
    The only exception to this format is the `OID@` token, which returns the object
    ID of the feature. The following code example retrieves the x and y coordinates
    of a feature:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌作为传递给游标构造函数的`field`列表中的一个字段提供，其格式为`SHAPE@<要返回的要素部分>`。此格式的唯一例外是`OID@`令牌，它返回要素的对象ID。以下代码示例检索要素的x和y坐标：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The following table lists the available geometry tokens. Not all cursors support
    the full list of tokens. Please check the ArcGIS help files for information on
    the tokens supported by each cursor type. The `SHAPE@` token returns the entire
    geometry of the feature. Use this carefully though, because it is an expensive
    operation to return the entire geometry of a feature and can dramatically affect
    performance. If you don't need the entire geometry, then do not include this token!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了可用的几何令牌。并非所有游标都支持完整的令牌列表。请查阅ArcGIS帮助文件以获取有关每个游标类型支持的令牌的信息。`SHAPE@`令牌返回要素的整个几何形状。尽管如此，请谨慎使用，因为返回要素整个几何形状是一个昂贵的操作，可能会显著影响性能。如果你不需要整个几何形状，则不要包含此令牌！
- en: '![Getting ready](img/4445OT_09_08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4445OT_09_08.jpg)'
- en: In this recipe, you will use a geometry token to increase the performance of
    a cursor. You'll retrieve the x and y coordinates of each land parcel from a `parcels`
    feature class, along with some attribute information about the parcel.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将使用几何令牌来提高游标性能。你将从`parcels`要素类中检索每个地块的x和y坐标，以及一些关于地块的属性信息。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to add a geometry token to a cursor, which should improve
    the performance of this object:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将几何标记添加到光标中，这应该会提高该对象的表现：
- en: Open IDLE and create a new script window.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IDLE并创建一个新的脚本窗口。
- en: Save the script as `c:\ArcpyBook\Ch9\GeometryToken.py`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为`c:\ArcpyBook\Ch9\GeometryToken.py`。
- en: 'Import the `arcpy.da` module:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`arcpy.da`模块：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set the workspace:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re going to measure how long it takes to execute the code using a geometry
    token. Add a start time for the script:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将测量使用几何标记执行代码所需的时间。为脚本添加一个开始时间：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use a Python `with` statement to create a cursor that includes the centroid
    of each feature as well as the ownership information stored in the `PY_FULL_OW`
    field:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的`with`语句创建一个光标，该光标包括每个特征的质心以及存储在`PY_FULL_OW`字段中的所有权信息：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Loop through each row in `SearchCursor` and print the name of the school. Make
    sure you indent the `for` loop inside the `with` block:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`SearchCursor`中的每一行并打印学校的名称。确保在`with`块内缩进`for`循环：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Measure the elapsed time:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量经过的时间：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Print the execution time:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印执行时间：
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save the script.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'Run the script. You should see something similar to the following output. Note
    the execution time; your time will vary:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。你应该会看到以下类似的输出。注意执行时间；你的时间会有所不同：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we''re going to measure the execution time if the entire geometry is returned
    instead of just the portion of the geometry that we need:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测量如果返回整个几何形状而不是我们需要的几何形状的一部分，执行时间会如何：
- en: Save a new copy of the script as `c:\ArcpyBook\Ch9\GeometryTokenEntireGeometry.py`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本的新副本保存为`c:\ArcpyBook\Ch9\GeometryTokenEntireGeometry.py`。
- en: 'Change the `SearchCursor()` function to return the entire geometry using `SHAPE@`
    instead of `SHAPE@XY`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SearchCursor()`函数更改为使用`SHAPE@`而不是`SHAPE@XY`来返回整个几何形状：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Save and run the script. You should see the following output. Your time will
    vary from mine, but notice that the execution time is slower. In this case, it''s
    only a little over a second slower but we''re only returning 2600 features. If
    the feature class were significantly large, as many are, this would be amplified:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。你应该会看到以下输出。你的时间可能会和我的不同，但请注意执行时间较慢。在这种情况下，它只慢了一点点，但我们只返回了2600个特征。如果特征类非常大，像许多情况一样，这将放大：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A geometry token can be supplied as one of the field names supplied in the constructor
    for the cursor. These tokens are used to increase the performance of a cursor
    by returning only a portion of the geometry instead of the entire geometry. This
    can dramatically increase the performance of a cursor, particularly when you are
    working with large polyline or polygon datasets. If you only need specific properties
    of the geometry in your cursor, you should use these tokens.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 几何标记可以作为游标构造函数中提供的字段名之一提供。这些标记通过只返回部分几何形状而不是整个几何形状来提高游标性能。这可以显著提高游标的性能，尤其是在处理大型折线或多边形数据集时。如果你只需要游标中几何形状的特定属性，你应该使用这些标记。
- en: Inserting rows with InsertCursor
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用InsertCursor插入行
- en: You can insert a row into a table or feature class using an `InsertCursor` object.
    If you want to insert attribute values along with the new row, you'll need to
    supply the values in the order found in the attribute table.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`InsertCursor`对象将行插入到表或要素类中。如果你想将属性值与新行一起插入，你需要按属性表中的顺序提供这些值。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `InsertCursor()` function is used to create an `InsertCursor` object that
    allows you to programmatically add new records to feature classes and tables.
    The `insertRow()` method on the `InsertCursor` object adds the row. A row, in
    the form of a list or tuple, is passed into the `insertRow()` method. The values
    in the list must correspond to the field values defined when the `InsertCursor`
    object was created. Just as with the other types of cursors, you can also limit
    the field names returned using the second parameter of the method. This function
    supports geometry tokens as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertCursor()`函数用于创建一个`InsertCursor`对象，该对象允许你以编程方式向要素类和表添加新记录。`InsertCursor`对象上的`insertRow()`方法添加行。行以列表或元组的形式传递到`insertRow()`方法中。列表中的值必须与创建`InsertCursor`对象时定义的字段值相对应。就像其他类型的游标一样，你也可以使用方法的第二个参数限制返回的字段名。此函数也支持几何标记。'
- en: 'The following code example illustrates how you can use `InsertCursor` to insert
    new rows into a feature class. Here, we are inserting two new wildfire points
    into the `California` feature class. The row values to be inserted are defined
    in a `list` variable. Then, an `InsertCursor` object is created, passing in the
    feature class and fields. Finally, the new rows are inserted into the feature
    class using the `insertRow()` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何使用 `InsertCursor` 向要素类中插入新行。在这里，我们正在向 `California` 要素类中插入两个新的野火点。要插入的行值定义在一个
    `list` 变量中。然后创建一个 `InsertCursor` 对象，传入要素类和字段。最后，使用 `insertRow()` 方法将新行插入到要素类中：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this recipe, you will use `InsertCursor` to add wildfires retrieved from
    a `text` file into a point feature class. When inserting rows into a feature class,
    you will need to know how to add the geometric representation of a feature into
    the feature class. This can be accomplished using `InsertCursor` along with two
    miscellaneous objects: `Array` and `Point`. In this exercise, we will add point
    features in the form of wildfire incidents to an empty point feature class. In
    addition, you will use Python file manipulation techniques to read the coordinate
    data from a text file.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将使用 `InsertCursor` 将从 `text` 文件中检索到的野火数据添加到点要素类中。当向要素类插入行时，您需要知道如何将要素的几何表示添加到要素类中。这可以通过使用
    `InsertCursor` 以及两个其他对象：`Array` 和 `Point` 来实现。在这个练习中，我们将以野火事件的形式将点要素添加到空点要素类中。此外，您还将使用
    Python 文件操作技术从文本文件中读取坐标数据。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will be importing North American wildland fire incident data from a single
    day in October, 2007\. This data is contained in a comma-delimited text file containing
    one line for each fire incident on that particular day. Each fire incident has
    a latitude/longitude coordinate pair separated by commas along with a confidence
    value. This data was derived by automated methods that use remote sensing data
    to derive the presence or absence of a wildfire. Confidence values can range from
    0 to 100\. Higher numbers represent a greater confidence that this is indeed a
    wildfire:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入来自 2007 年 10 月某一天的北美野火事件数据。这些数据包含在一个逗号分隔的文本文件中，该文件包含该特定日期上每个火灾事件的单独一行。每个火灾事件都有一个由逗号分隔的纬度/经度坐标对以及一个置信度值。这些数据是通过使用遥感数据来推断野火的存在或不存在而自动生成的。置信度值范围从
    0 到 100。数值越高表示这是一个真正的野火的置信度越大：
- en: Open the file at `c:\ArcpyBook\Ch9\Wildfire Data\NorthAmericaWildfire_2007275.txt`
    and examine the contents.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件 `c:\ArcpyBook\Ch9\Wildfire Data\NorthAmericaWildfire_2007275.txt` 并检查其内容。
- en: You will notice that this is a simple comma-delimited text file containing longitude
    and latitude values for each fire along with a confidence value. We will use Python
    to read the contents of this file line-by-line and insert new point features into
    the `FireIncidents` feature class located in the `c:\ArcpyBook\Ch9 \WildfireData\WildlandFires.mdb`
    personal geodatabase.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会注意到这是一个简单的逗号分隔的文本文件，包含每个火灾的经纬度值以及一个置信度值。我们将使用 Python 逐行读取此文件的内容，并将新的点要素插入到位于
    `c:\ArcpyBook\Ch9 \WildfireData\WildlandFires.mdb` 个人地理数据库中的 `FireIncidents` 要素类中。
- en: Close the file.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件。
- en: Open `ArcCatalog`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ArcCatalog`。
- en: Navigate to `c:\ArcpyBook\Ch9\WildfireData`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `c:\ArcpyBook\Ch9\WildfireData`。
- en: You should see a personal geodatabase called `WildlandFires`. Open this geodatabase
    and you will see a point feature class called `FireIncidents`. Right now this
    is an empty feature class. We will add features by reading the text file you examined
    earlier and inserting points.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到一个名为 `WildlandFires` 的个人地理数据库。打开此地理数据库，您将看到一个名为 `FireIncidents` 的点要素类。目前这是一个空要素类。我们将通过读取您之前检查的文本文件并插入点来添加要素。
- en: Right-click on `FireIncidents` and select **Properties**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `FireIncidents` 并选择 **属性**。
- en: Click on the **Fields** tab.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **字段** 选项卡。
- en: The latitude/longitude values found in the file we examined earlier will be
    imported into the `SHAPE` field and the confidence values will be written to the
    `CONFIDENCEVALUE` field.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们之前检查的文件中找到的纬度/经度值将被导入到 `SHAPE` 字段中，置信度值将被写入到 `CONFIDENCEVALUE` 字段中。
- en: Open IDLE and create a new script.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IDLE 并创建一个新的脚本。
- en: Save the script to `c:\ArcpyBook\Ch9\InsertWildfires.py`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到 `c:\ArcpyBook\Ch9\InsertWildfires.py`。
- en: 'Import the `arcpy` and `os` modules:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `arcpy` 和 `os` 模块：
- en: '[PRE19]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set the workspace:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE20]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open the text file and read all the lines into a list:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文本文件，将所有行读入一个列表：
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Start a `try` block:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个 `try` 块：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create an `InsertCursor` object using a `with` block. Make sure you indent
    inside the `try` statement. The cursor will be created on the `FireIncidents`
    feature class:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `with` 块创建一个 `InsertCursor` 对象。确保在 `try` 语句内部进行缩进。光标将在 `FireIncidents` 要素类上创建：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a counter variable that will be used to print the progress of the script:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计数器变量，用于打印脚本的进度：
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Loop through the text file line by line using a `for` loop. Since the text
    file is comma-delimited, we''ll use the Python `split()` function to separate
    each value into a list variable called `vals`. We''ll then pull out the individual
    latitude, longitude, and confidence value items and assign them to variables.
    Finally, we''ll place these values into a list variable called `rowValue`, which
    is then passed into the `insertRow()` function for the `InsertCursor` object,
    and then we''ll print a message:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环逐行遍历文本文件。由于文本文件是逗号分隔的，我们将使用 Python 的 `split()` 函数将每个值分离到一个名为 `vals`
    的列表变量中。然后，我们将提取单独的纬度、经度和置信度值项并将它们分配给变量。最后，我们将这些值放入一个名为 `rowValue` 的列表变量中，然后将其传递给
    `InsertCursor` 对象的 `insertRow()` 函数，然后我们打印一条消息：
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the `except` block to print any errors that may occur:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `except` 块以打印可能发生的任何错误：
- en: '[PRE26]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a `finally` block to close the text file:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `finally` 块来关闭文本文件：
- en: '[PRE27]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The entire script should appear as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE28]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。当脚本运行时，你应该会在输出窗口看到消息被写入：
- en: '[PRE29]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Open `ArcMap` and add the `FireIncidents` feature class to the table of contents.
    The points should be visible, as shown in the following screenshot:![How to do
    it…](img/4445_09_3.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ArcMap` 并将 `FireIncidents` 要素类添加到内容表中。点应该可见，如下面的截图所示：![如何操作…](img/4445_09_3.jpg)
- en: How it works…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Some additional explanation may be needed here. The `lstFires` variable contains
    a list of all the wildfires that were contained in the comma-delimited text file.
    The `for` statement will loop through each of these records one by one, inserting
    each individual record into the `fire` variable. We also include an `if` statement
    that is used to skip the first record in the file, which serves as the header.
    As I explained earlier, we then pull out the individual latitude, longitude, and
    confidence value items from the `vals` variable, which is just a Python list object
    and assign them to variables called `latitude`, `longitude`, and `confid`. We
    then place these values into a new list variable called `rowValue` in the order
    that we defined when we created `InsertCursor`. That is, the latitude and longitude
    pair should be placed first, followed by the confidence value. Finally, we call
    the `insertRow()` function on the `InsertCursor` object assigned to the variable
    `cur`, passing in the new `rowValue` variable. We close by printing a message
    that indicates the progress of the script and also creating our `except` and `finally`
    blocks to handle errors and close the text file. Placing the `file.close()` method
    in the `finally` block ensures that it will execute, and close the file, even
    if there is an error in the previous try statement.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能需要一些额外的解释。`lstFires` 变量包含一个列表，其中包含逗号分隔的文本文件中包含的所有野火。`for` 语句将逐个遍历这些记录，将每个单独的记录插入到
    `fire` 变量中。我们还包含了一个 `if` 语句，用于跳过文件中的第一个记录，该记录作为标题。正如我之前解释的，然后我们从 `vals` 变量中提取单独的纬度、经度和置信度值项，`vals`
    只是一个 Python 列表对象，并将它们分配给名为 `latitude`、`longitude` 和 `confid` 的变量。然后，我们将这些值按照我们在创建
    `InsertCursor` 时定义的顺序放入一个新的列表变量 `rowValue` 中。也就是说，纬度和经度对应该首先放置，然后是置信度值。最后，我们在变量
    `cur` 分配的 `InsertCursor` 对象上调用 `insertRow()` 函数，传入新的 `rowValue` 变量。我们通过打印一条消息来结束，该消息指示脚本的进度，并创建我们的
    `except` 和 `finally` 块来处理错误和关闭文本文件。将 `file.close()` 方法放在 `finally` 块中确保它将执行，并关闭文件，即使前面的
    `try` 语句中存在错误。
- en: Updating rows with an UpdateCursor
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UpdateCursor 更新行
- en: If you need to edit or delete rows from a table or feature class, you can use
    `UpdateCursor`. As is the case with `InsertCursor`, the contents of `UpdateCursor`
    can be limited through the use of a `where` clause.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编辑或从表或要素类中删除行，你可以使用 `UpdateCursor`。与 `InsertCursor` 一样，可以通过使用 `where` 子句来限制
    `UpdateCursor` 的内容。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UpdateCursor()` function can be used to either update or delete rows in
    a table or feature class. The returned cursor places a lock on the data, which
    will automatically be released if used inside a Python `with` statement. An `UpdateCursor`
    object is returned from a call to this method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCursor()` 函数可用于更新或删除表或要素类中的行。返回的游标会对数据进行锁定，如果在使用 Python `with` 语句时使用，则会自动释放。从对该方法的调用返回一个
    `UpdateCursor` 对象。'
- en: The `UpdateCursor` object places a lock on the data while it's being edited
    or deleted. If the cursor is used inside a Python `with` statement, the lock will
    automatically be freed after the data has been processed. This hasn't always been
    the case. Previous versions of cursors were required to be manually released using
    the Python `del` statement. Once an instance of `UpdateCursor` has been obtained,
    you can then call the `updateCursor()` method to update records in tables or feature
    classes and the `deleteRow()` method to delete a row.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCursor` 对象在编辑或删除数据时会对数据进行锁定。如果游标在 Python `with` 语句中使用，则在数据被处理后，锁定会自动释放。这并不总是这种情况。游标的先前版本需要使用
    Python `del` 语句手动释放。一旦获得 `UpdateCursor` 的实例，就可以调用 `updateCursor()` 方法来更新表或要素类中的记录，以及调用
    `deleteRow()` 方法来删除一行。'
- en: In this recipe, you're going to write a script that updates each feature in
    the `FireIncidents` feature class by assigning a value of `poor`, `fair`, `good`,
    or `excellent` to a new field that is more descriptive of the confidence values
    using an `UpdateCursor`. Prior to updating the records, your script will add a
    new field to the `FireIncidents` feature class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将编写一个脚本，通过将 `poor`、`fair`、`good` 或 `excellent` 的值分配给一个新字段，该字段更详细地描述了置信度值，并使用
    `UpdateCursor` 更新 `FireIncidents` 要素类中的每个要素。在更新记录之前，你的脚本将向 `FireIncidents` 要素类添加一个新字段。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to create an `UpdateCursor` object that will be used to
    edit rows in a feature class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个 `UpdateCursor` 对象，该对象将用于编辑要素类中的行：
- en: Open IDLE and create a new script.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IDLE 并创建一个新的脚本。
- en: Save the script to `c:\ArcpyBook\Ch9\UpdateWildfires.py`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到 `c:\ArcpyBook\Ch9\UpdateWildfires.py`。
- en: 'Import the `arcpy` and `os` modules:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `arcpy` 和 `os` 模块：
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Set the workspace:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Start a `try` block:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个 `try` 块：
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add a new field called `CONFID_RATING` to the `FireIncidents` feature class.
    Make sure to indent inside the `try` statement:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `FireIncidents` 要素类添加一个名为 `CONFID_RATING` 的新字段。确保在 `try` 语句内缩进：
- en: '[PRE33]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new instance of `UpdateCursor` inside a `with` block:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `with` 块内创建一个新的 `UpdateCursor` 实例：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a counter variable that will be used to print the progress of the script.
    Make sure you indent this line of code and all the lines of code to follow inside
    the `with` block:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计数变量，该变量将用于打印脚本的进度。确保缩进此行代码以及 `with` 块内随后的所有代码行：
- en: '[PRE35]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Loop through each of the rows in the `FireIncidents` fire class. Update the
    `CONFID_RATING` field according to the following guidelines:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `FireIncidents` 火灾类中的每一行。根据以下指南更新 `CONFID_RATING` 字段：
- en: Confidence value 0 to 40 = `POOR`
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信度值 0 至 40 = `差`
- en: Confidence value 41 to 60 = `FAIR`
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信度值 41 至 60 = `一般`
- en: Confidence value 61 to 85 = `GOOD`
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信度值 61 至 85 = `良好`
- en: Confidence value 86 to 100 = `EXCELLENT`
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信度值 86 至 100 = `优秀`
- en: '[PRE36]'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the `except` block to print any errors that may occur:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `except` 块以打印可能发生的任何错误：
- en: '[PRE37]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The entire script should appear as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE38]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。当脚本运行时，你应该会看到消息被写入输出窗口：
- en: '[PRE39]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Open `ArcMap` and add the `FireIncidents` feature class. Open the attribute
    table and you should see that a new `CONFID_RATING` field has been added and populated
    by `UpdateCursor`:![How to do it…](img/4445_09_4.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ArcMap` 并添加 `FireIncidents` 要素类。打开属性表，你应该能看到已添加并使用 `UpdateCursor` 填充的新 `CONFID_RATING`
    字段：![如何操作…](img/4445_09_4.jpg)
- en: Note
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you insert, update, or delete data in cursors, the changes are permanent
    and can't be undone if you're working outside an edit session. However, with the
    new edit session functionality provided by ArcGIS 10.1, you can now make these
    changes inside an edit session to avoid these problems. We'll cover edit sessions
    soon.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在游标中插入、更新或删除数据时，更改是永久的，如果你在编辑会话外工作，则无法撤销。然而，使用 ArcGIS 10.1 提供的新编辑会话功能，你现在可以在编辑会话内进行这些更改以避免这些问题。我们很快就会介绍编辑会话。
- en: How it works…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this case, we've used `UpdateCursor` to update each of the features in a
    feature class. We first used the `Add Field` tool to add a new field called `CONFID_RATING`,
    which will hold new values that we assign based on values found in another field.
    The groups are poor, fair, good, and excellent, and are based on numeric values
    found in the `CONFIDENCEVALUE` field. We then created a new instance of `UpdateCursor`
    based on the `FireIncidents` feature class, and returned the two fields mentioned
    previously. The script then loops through each of the features and assigns a value
    of poor, fair, good, or excellent to the `CONFID_RATING` field (`row[1]`), based
    on the numeric value found in `CONFIDENCEVALUE`. A Python `if`/`elif`/`else` structure
    is used to control the flow of the script based on the numeric value. The value
    for `CONFID_RATING` is then committed to the feature class by passing in the row
    variable into the `updateRow()` method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了`UpdateCursor`来更新要素类中的每个要素。我们首先使用`Add Field`工具添加一个名为`CONFID_RATING`的新字段，该字段将保存我们根据另一个字段中找到的值分配的新值。这些组是差、一般、好和优秀，基于`CONFIDENCEVALUE`字段中找到的数值。然后，我们根据`FireIncidents`要素类创建了一个新的`UpdateCursor`实例，并返回了之前提到的两个字段。然后脚本遍历每个要素，并根据`CONFIDENCEVALUE`中找到的数值将`CONFID_RATING`字段（`row[1]`）的值设置为差、一般、好或优秀。使用Python的`if`/`elif`/`else`结构根据数值控制脚本的流程。然后通过将行变量传递到`updateRow()`方法中，将`CONFID_RATING`的值提交到要素类。
- en: Deleting rows with an UpdateCursor
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`UpdateCursor`删除行
- en: In addition to being used to edit rows in a table or feature class, an `UpdateCursor`
    can also be used to delete rows. Please keep in mind that when rows are deleted
    outside an edit session, the changes are permanent.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于编辑表或要素类中的行之外，`UpdateCursor`还可以用于删除行。请记住，当在编辑会话之外删除行时，更改是永久的。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In addition to updating records, `UpdateCursor` can also delete records from
    a table or feature class. The `UpdateCursor` object is created in the same way
    in either case, but instead of calling `updateRow()`, you call `deleteRow()` to
    delete a record. You can also apply a `where` clause to `UpdateCursor`, to limit
    the records returned. In this recipe, we'll use an `UpdateCursor` object that
    has been filtered using a `where` clause to delete records from our `FireIncidents`
    feature class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更新记录外，`UpdateCursor`还可以从表或要素类中删除记录。在两种情况下创建`UpdateCursor`对象的方式相同，但不是调用`updateRow()`，而是调用`deleteRow()`来删除记录。您还可以将`where`子句应用于`UpdateCursor`，以限制返回的记录。在本例中，我们将使用带有`where`子句过滤的`UpdateCursor`对象来从我们的`FireIncidents`要素类中删除记录。
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to create an `UpdateCursor` object that will be used delete
    rows from a feature class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个`UpdateCursor`对象，该对象将用于从要素类中删除行：
- en: Open IDLE and create a new script.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IDLE并创建一个新的脚本。
- en: Save the script to `c:\ArcpyBook\Ch9\DeleteWildfires.py`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到`c:\ArcpyBook\Ch9\DeleteWildfires.py`。
- en: 'Import the `arcpy` and `os` modules:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`arcpy`和`os`模块：
- en: '[PRE40]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Set the workspace:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE41]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Start a `try` block:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个`try`块：
- en: '[PRE42]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a new instance of `UpdateCursor` inside a `with` block:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`with`块内创建`UpdateCursor`的新实例：
- en: '[PRE43]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a counter variable that will be used to print the progress of the script.
    Make sure you indent this line of code and all the lines of code to follow inside
    the `with` block:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计数器变量，该变量将用于打印脚本的进度。确保缩进此行代码以及`with`块内随后的所有代码行：
- en: '[PRE44]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Delete the returned rows by calling the `deleteRow()` method. This is done
    by looping through the returned cursor and deleting the rows one at a time:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`deleteRow()`方法删除返回的行。这是通过遍历返回的光标并逐行删除行来完成的：
- en: '[PRE45]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the `except` block to print any errors that may occur:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`except`块以打印可能发生的任何错误：
- en: '[PRE46]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The entire script should appear as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应该如下所示：
- en: '[PRE47]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs. 37 records should be deleted from the `FireIncidents`
    feature class:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。当脚本运行时，你应该会看到消息被写入输出窗口。`FireIncidents`要素类应该删除37条记录：
- en: '[PRE48]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Rows from feature classes and tables can be deleted using the `deleteRow()`
    method on `UpdateCursor`. In this recipe, we used a `where` clause in the constructor
    of `UpdateCursor` to limit the records returned to only those features with a
    `CONFID_RATING` of `POOR`. We then looped through the features returned in the
    cursor and called the `deleteRow()` method to delete the row from the feature
    class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `UpdateCursor` 上的 `deleteRow()` 方法从要素类和表中删除行。在这个菜谱中，我们在 `UpdateCursor`
    构造函数中使用了一个 `where` 子句来限制返回的记录仅限于那些具有 `CONFID_RATING` 为 `POOR` 的要素。然后我们遍历游标返回的要素，并调用
    `deleteRow()` 方法从要素类中删除该行。
- en: Inserting and updating rows inside an edit session
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编辑会话内插入和更新行
- en: As I've mentioned throughout the chapter, inserts, updates, or deletes to a
    table or feature class done outside an edit session are permanent. They can't
    be undone. Edit sessions give you much more flexibility for rolling back any unwanted
    changes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章中提到的，在编辑会话外对表或要素类进行的插入、更新或删除是永久的。它们无法撤销。编辑会话为您提供了更多的灵活性，可以回滚任何不希望的变化。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Up until now, we've used insert and update cursors to add, edit, and delete
    data from feature classes and tables. These changes have been permanent as soon
    as the script was executed and can't be undone. The new `Editor` class in the
    Data Access module supports the ability to create edit sessions and operations.
    With edit sessions, changes applied to feature classes or tables are temporary
    until permanently applied with a specific method call. This is the same functionality
    provided by the `Edit` toolbar in ArcGIS Desktop.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已使用插入和更新游标从要素类和表中添加、编辑和删除数据。这些更改在脚本执行后立即生效，并且无法撤销。数据访问模块中的新 `Editor`
    类支持创建编辑会话和操作的能力。使用编辑会话，对要素类或表应用的变化是临时的，直到通过特定的方法调用永久应用。这与 ArcGIS Desktop 中的 `Edit`
    工具栏提供的功能相同。
- en: 'Edit sessions begin with a call to `Editor.startEditing()`, which initiates
    the session. Inside the session, you then start an operation with the `Editor.startOperation()`
    method. From within this operation, you then perform various operations that perform
    edits on your data. These edits can also be subject to undo, redo, and abort operations
    for rolling back, rolling forward, and aborting your editing operations. After
    the operations have been completed, you then call the `Editor.stopOperation()`
    method followed by `Editor.stopEditing()`. Sessions can be ended without saving
    changes. In this event, changes are not permanently applied. An overview of this
    process is provided in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑会话从调用 `Editor.startEditing()` 开始，这会启动会话。在会话内部，您随后使用 `Editor.startOperation()`
    方法开始一个操作。在这个操作内部，您然后执行各种操作，这些操作会对您的数据进行编辑。这些编辑也可以受到撤销、重做和终止操作的影响，以回滚、前进和终止您的编辑操作。操作完成后，您随后调用
    `Editor.stopOperation()` 方法，然后调用 `Editor.stopEditing()`。会话可以在不保存更改的情况下结束。在这种情况下，更改不会被永久应用。以下截图提供了此过程的概述：
- en: '![Getting ready](img/4445OT_09_05.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/4445OT_09_05.jpg)'
- en: Edit sessions can also be ended without saving changes. In this event, changes
    are not permanently applied. Edit sessions also allow for operations to be applied
    inside the session and then either applied permanently to the database or rolled
    back. In addition, the `Editor` class also supports undo and redo operations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑会话也可以在不保存更改的情况下结束。在这种情况下，更改不会被永久应用。编辑会话还允许在会话内应用操作，然后要么将它们永久应用到数据库中，要么回滚。此外，`Editor`
    类还支持撤销和重做操作。
- en: 'The following code example shows the full edit session stack including the
    creation of the `Editor` object, the beginning of an edit session and an operation,
    edits to the data (an insert in this case), stopping the operation, and finally
    the end of the edit session by saving the data:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了完整的编辑会话堆栈，包括创建 `Editor` 对象、开始编辑会话和操作、对数据进行编辑（在这种情况下是插入）、停止操作，以及最后通过保存数据结束编辑会话：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Editor` class can be used with personal, file, and ArcSDE geodatabases.
    In addition, sessions can also be started and stopped on versioned databases.
    You are limited to editing only a single workspace at a time, and this workspace
    is specified in the constructor for the `Editor` object simply by passing in a
    string that references the workspace. Once created, this `Editor` object then
    has access to all the methods for starting, stopping, and aborting operations,
    and performing undo and redo operations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor`类可以与个人、文件和ArcSDE地理数据库一起使用。此外，还可以在版本化数据库上启动和停止会话。您一次只能编辑一个工作空间，并且可以通过传递一个引用工作空间的字符串来在`Editor`对象的构造函数中指定此工作空间。一旦创建，此`Editor`对象就可以访问所有用于启动、停止和取消操作以及执行撤销和重做操作的方法。'
- en: How to do it…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to wrap `UpdateCursor` inside an edit session:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将`UpdateCursor`包裹在编辑会话内：
- en: Open IDLE.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IDLE。
- en: Open the `c:\ArcpyBook\Ch9\UpdateWildfires.py` script and save it to a new script
    called `c:\ArcpyBook\Ch9\EditSessionUpdateWildfires.py`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`c:\ArcpyBook\Ch9\UpdateWildfires.py`脚本并将其保存为名为`c:\ArcpyBook\Ch9\EditSessionUpdateWildfires.py`的新脚本。
- en: We're going to make several alterations to this existing script that updates
    values in the `CONFID_RATING` field.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对现有脚本进行多次修改，该脚本用于更新`CONFID_RATING`字段中的值。
- en: 'Remove the following lines of code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下代码行：
- en: '[PRE50]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create an instance of the `Editor` class and start an edit session. These lines
    of code should be placed just inside the `try` block:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Editor`类的实例并启动编辑会话。以下代码行应放置在`try`块内：
- en: '[PRE51]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Alter the `if` statement so that it appears as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`if`语句，使其如下所示：
- en: '[PRE52]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'End the edit session and save edits. Place this line of code just below the
    counter increment:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束编辑会话并保存编辑。将此代码行放置在计数器增加之下：
- en: '[PRE53]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The entire script should appear as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE54]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Save and run the script.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。
- en: How it works…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: Edit operations should take place inside an edit session, which can be initiated
    with the `Editor.startEditing()` method. The `startEditing()` method takes two
    optional parameters including `with_undo` and `multiuser_mode`. The `with_undo`
    parameter accepts a Boolean value of `true` or `false`, with a default of `true`.
    This creates an undo/redo stack when set to `true`. The `multiuser_mode` parameter
    defaults to `true`. When `false`, you have full control of editing a non-versioned
    or versioned dataset. If your dataset is non-versioned and you use `stopEditing(False)`,
    your edits will not be committed. Otherwise, if set to `true`, your edits will
    be committed. The `Editor.stopEditing()` method takes a single Boolean value of
    `true` or `false`, indicating whether changes should be saved or not. This defaults
    to `true`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑操作应在编辑会话内进行，可以使用`Editor.startEditing()`方法启动编辑会话。`startEditing()`方法包含两个可选参数，包括`with_undo`和`multiuser_mode`。`with_undo`参数接受布尔值`true`或`false`，默认为`true`。当设置为`true`时，将创建一个撤销/重做堆栈。`multiuser_mode`参数默认为`true`。当设置为`false`时，您可以对非版本化或版本化数据集进行完全控制。如果您的数据集是非版本化的，并且您使用`stopEditing(False)`，则您的编辑将不会被提交。否则，如果设置为`true`，则您的编辑将被提交。`Editor.stopEditing()`方法接受单个布尔值`true`或`false`，表示是否应保存更改。默认为`true`。
- en: 'The `Editor` class supports undo and redo operations. We''ll first look at
    undo operations. During an edit session, various edit operations can be applied.
    In the event that you need to undo a previous operation, a call to `Editor.undoOperation()`
    will remove the most previous edit operation in the stack. This is illustrated
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor`类支持撤销和重做操作。我们首先来看撤销操作。在编辑会话期间，可以应用各种编辑操作。如果在需要撤销之前的操作时，调用`Editor.undoOperation()`将移除堆栈中最先前的编辑操作。这如下所示：'
- en: '![How it works…](img/4445OT_09_06.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/4445OT_09_06.jpg)'
- en: 'Redo operations, initiated by the `Editor.redoOperation()` method, will redo
    an operation that was previously undone. This is illustrated as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由`Editor.redoOperation()`方法启动的操作将重做之前已撤销的操作。这如下所示：
- en: '![How it works…](img/4445OT_09_07.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/4445OT_09_07.jpg)'
- en: Reading geometry from a feature class
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从要素类读取几何信息
- en: There may be times when you need to retrieve the geometric definition of features
    in a feature class. ArcPy provides the ability to read this information through
    various objects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您可能需要检索要素类中要素的几何定义。ArcPy通过各种对象提供了读取此信息的能力。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In ArcPy, feature classes have associated geometry objects including `Polygon`,
    `Polyline`, `PointGeometry`, and `MultiPoint` that you can access from your cursors.
    These objects refer to the `shape` field in the attribute table for a feature
    class. You can read the geometries of each feature in a feature class through
    these objects.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ArcPy 中，要素类有相关的几何对象，包括 `Polygon`、`Polyline`、`PointGeometry` 和 `MultiPoint`，你可以从你的游标中访问这些对象。这些对象引用要素类的属性表中的
    `shape` 字段。你可以通过这些对象读取要素类中每个要素的几何形状。
- en: Polyline and polygon feature classes are composed of features containing multiple
    parts. You can use the `partCount` property to return the number of parts per
    feature and then use `getPart()` for each part in the feature to loop through
    each of the points and pull out the coordinate information. Point feature classes
    are composed of one `PointGeometry` object per feature that contains the coordinate
    information for each point.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 折线和多边形要素类由包含多个部分的要素组成。你可以使用 `partCount` 属性来返回每个要素的部分数量，然后对要素中的每个部分使用 `getPart()`
    来遍历每个点并提取坐标信息。点要素类由每个要素的一个 `PointGeometry` 对象组成，该对象包含每个点的坐标信息。
- en: In this recipe, you will use a `SearchCursor` and `Polygon` object to read the
    geometry of a polygon feature class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将使用 `SearchCursor` 和 `Polygon` 对象来读取多边形要素类的几何形状。
- en: How to do it…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to learn how to read the geometric information from each
    feature in a feature class:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何从要素类中的每个要素读取几何信息：
- en: Open IDLE and create a new script.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IDLE 并创建一个新的脚本。
- en: Save the script to `c:\ArcpyBook\Ch9\ReadGeometry.py`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到 `c:\ArcpyBook\Ch9\ReadGeometry.py`。
- en: 'Import the `arcpy` module:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `arcpy` 模块：
- en: '[PRE55]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Set the input feature class to the `SchoolDistricts` polygon feature class:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入要素类设置为 `SchoolDistricts` 多边形要素类：
- en: '[PRE56]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a `SearchCursor` object with the input feature class, and return the
    `ObjectID` and `Shape` fields. The `Shape` field contains the geometry for each
    feature. The cursor will be created inside a `for` loop that we''ll use to iterate
    through all the features in the feature class:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入要素类创建一个 `SearchCursor` 对象，并返回 `ObjectID` 和 `Shape` 字段。`Shape` 字段包含每个要素的几何形状。游标将在一个
    `for` 循环内创建，我们将使用它遍历要素类中的所有要素：
- en: '[PRE57]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use a `for` loop to loop through each part of the feature:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环遍历要素的每个部分：
- en: '[PRE58]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use a `for` loop to loop through each vertex in each part and print the x and
    y coordinates:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环遍历每个部分中的每个顶点并打印 x 和 y 坐标：
- en: '[PRE59]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Save and run the script. You should see the following output as the script
    writes the information for each feature, each part of the feature, and the x and
    y coordinates that define each part:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。当脚本为每个要素、每个要素的部分以及定义每个部分的 x 和 y 坐标写入信息时，你应该看到以下输出：
- en: '[PRE60]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We initially created a `SearchCursor` object to hold the contents of our feature
    class. After this, we looped through each row in the cursor using a `for` loop.
    For each row, we looped through all the parts of the geometry. Remember that polyline
    and polygon features are composed of two or more parts. For each part, we also
    returned the points associated with each part and we printed the `x` and `y` coordinates
    of each point.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初创建了一个 `SearchCursor` 对象来保存我们要素类的所有内容。之后，我们使用 `for` 循环遍历游标中的每一行。对于每一行，我们遍历几何形状的所有部分。记住，折线和多边形要素由两个或多个部分组成。对于每个部分，我们还返回与每个部分相关的点，并打印每个点的
    `x` 和 `y` 坐标。
