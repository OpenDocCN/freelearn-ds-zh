<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Namespaces, Scopes, and Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Namespaces, Scopes, and Modules</h1></div></div></div><p>In this chapter, we will cover Python modules. Modules are files containing functions and class definitions. The concept of a namespace and the scope of variables across functions and modules is also explained in this chapter.</p><div class="section" title="Namespace"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec88"/>Namespace</h1></div></div></div><p>Names of Python objects, such as names of variables, classes, functions, and modules, are collected in namespaces. Modules and classes have their own named namespaces with the same name as these objects. These namespaces are created when a module is imported or a class is instantiated. The lifetime of a namespace of a module is as long as the current Python session. The lifetime of a namespace of a class instance is until the instance is deleted.</p><p>Functions create a local namespace when they are executed (invoked). It is deleted when the function stops the execution by a regular return or an exception. Local namespaces are unnamed.</p><p>The concept of namespaces puts a variable name in its context. For example, there are several functions with the name <code class="literal">sin</code> and they are distinguished by the namespace they belong to, as shown in the following code:</p><pre class="programlisting">import math&#13;
import scipy&#13;
math.sin&#13;
scipy.sin</pre><p>They are indeed different, as <code class="literal">scipy.sin</code> is a universal function accepting lists or arrays as input, where <code class="literal">math.sin</code> takes only floats. A list with all the names in a particular namespace can be obtained by the command <code class="literal">dir(&lt;name of the namespace&gt;)</code>. It contains two special names <code class="literal">__name__</code> and <code class="literal">__doc__</code>. The former refers to the name of the module and the latter to its docstring:</p><pre class="programlisting">math.__name__ # returns math&#13;
math.__doc__ # returns 'This module is always ...'</pre><p>There is a special namespace, <code class="literal">__builtin__</code>, which contains names that are available in Python without any <code class="literal">import</code>. It is a named namespace but its name need not be given when referring to a built-in object:</p><pre class="programlisting">'float' in dir(__builtin__) # returns True&#13;
float is __builtin__.float # returns True</pre></div></div>
<div class="section" title="Scope of a variable"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec89"/>Scope of a variable</h1></div></div></div><p>A variable defined in one part of a program needs not to be known in other parts. All program units to which it a certain variable is known are called the scope of that variable. We first give an example; let's consider the two nested functions:</p><pre class="programlisting">e = 3&#13;
def my_function(in1):&#13;
    a = 2 * e&#13;
    b = 3&#13;
    in1 = 5&#13;
    def other_function():&#13;
       c = a&#13;
       d = e&#13;
       return dir()&#13;
    print("""&#13;
          my_function's namespace: {} &#13;
          other_function's namespace: {}&#13;
          """.format(dir(),other_function()))&#13;
    return a</pre><p>Execution of <code class="literal">my_function(3)</code> results in:</p><pre class="programlisting">my_function's namespace: ['a', 'b', 'in1', 'other_function'] &#13;
other_function's namespace: ['a', 'c', 'd']</pre><p>The variable <code class="literal">e</code>  is in the namespace of the program unit that encloses the function <code class="literal">my_function </code>. The variable <code class="literal">a</code>  is in the namespace of this function, which itself encloses the innermost function <code class="literal">other_function</code>. For the two functions, <code class="literal">e</code> is a global variable.</p><p>It is a good practice to pass information to a function only by its parameter list and not use the construction from the preceding example. An exception can be found in section <span class="emphasis"><em>Anonymous functions</em></span>  in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>, where global variables are used for closures. By assigning it a value, a variable automatically becomes a local variable:</p><pre class="programlisting">e = 3&#13;
def my_function():&#13;
    e = 4&#13;
    a = 2&#13;
    print("my_function's namespace: {}".format(dir()))</pre><p>Execution of</p><pre class="programlisting">e = 3&#13;
my_function()&#13;
e # has the value 3</pre><p>gives:</p><pre class="programlisting">my_function's namespace: ['a', 'e']</pre><p>Where <code class="literal">e</code> became a local variable. In fact, this piece of code now has two variables <code class="literal">e</code> belonging to different namespaces.</p><p>By using the <code class="literal">global</code> declaration statement, a variable defined in a function can be made global, that is, its value will be accessible even outside this function. The use of a <code class="literal">global</code> declaration is demonstrated as follows:</p><pre class="programlisting">def fun():&#13;
    def fun1():&#13;
        global a&#13;
        a = 3&#13;
    def fun2():&#13;
        global b&#13;
        b = 2&#13;
        print(a)&#13;
    fun1()&#13;
    fun2() # prints a&#13;
    print(b)</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p><span class="strong"><strong>Avoid using global</strong></span></p><p>It would be advisable to avoid using this construct and the use of <code class="literal">global</code>. These kinds of code are hard to debug and maintain. The use of classes (refer to <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes</em></span>, for more information) makes <code class="literal">global</code> mainly obsolete.</p></div></div></div>
<div class="section" title="Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec90"/>Modules</h1></div></div></div><p>In Python, a module is simply a file containing classes and functions. By importing the file in your session or script, the functions and classes become usable.</p><div class="section" title="Introduction"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec114"/>Introduction</h2></div></div></div><p>Python comes with many different libraries by default. You may also want to install more of those for specific purposes, such as optimization, plotting, reading/writing file formats, image handling, and so on. NumPy and SciPy are two important examples of such libraries, matplotlib for plotting is another one. At the end of this chapter, we will list some useful libraries.</p><p>To use a library, you may either:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Load only certain objects from a library, for example from NumPy:
<pre class="programlisting">        from numpy import array, vander</pre></li><li class="listitem" style="list-style-type: disc">Or load the entire library:
<pre class="programlisting">        from numpy import *</pre></li><li class="listitem" style="list-style-type: disc">Or give access to an entire library by creating a namespace with the library name:<pre class="programlisting">        import numpy&#13;
        ...&#13;
        numpy.array(...)</pre><p>Prefixing a function from the library with the namespace gives access to this function and distinguishes this function from other objects with the same name.</p></li></ul></div><p>Furthermore, the name of a namespace can be specified together with the <code class="literal">import</code> command:</p><pre class="programlisting">import numpy as np&#13;
...&#13;
np.array(...)</pre><p>Which option you use affects the readability of your code as well as the possibilities for mistakes. A common mistake is shadowing:</p><pre class="programlisting">from scipy.linalg import eig&#13;
A = array([[1,2],[3,4]])&#13;
(eig, eigvec) = eig(A)&#13;
...&#13;
(c, d) = eig(B) # raises an error</pre><p>A way to avoid this unintended effect is to use <code class="literal">import</code>:</p><pre class="programlisting">import scipy.linalg as sl&#13;
A = array([[1,2],[3,4]])&#13;
(eig, eigvec) = sl.eig(A) # eig and sl.eig are different objects&#13;
...&#13;
(c, d) = sl.eig(B)</pre><p>Throughout this book, we have used many commands, objects, and functions. These were imported into the local namespace by statements such as:</p><pre class="programlisting">from scipy import *</pre><p>Importing objects in this manner does not make the module from which they are imported evident. Some examples are given in the following table (<span class="emphasis"><em>Table 11.1</em></span>):</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>Libraries</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Methods</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">numpy</code>
</p>
</td><td>
<p>
<code class="literal">array</code>, <code class="literal">arange</code>, <code class="literal">linspace</code>, <code class="literal">vstack</code>, <code class="literal">hstack</code>, <code class="literal">dot</code>, <code class="literal">eye</code>, <code class="literal">identity</code>, and <code class="literal">zeros</code>.</p>
</td></tr><tr><td>
<p>
<code class="literal">numpy.linalg</code>
</p>
</td><td>
<p>
<code class="literal">solve</code>, <code class="literal">lstsq</code>, <code class="literal">eig</code>, and <code class="literal">det</code>.</p>
</td></tr><tr><td>
<p>
<code class="literal">matplotlib.pyplot</code>
</p>
</td><td>
<p>
<code class="literal">plot</code>, <code class="literal">legend</code>, and <code class="literal">cla</code>.</p>
</td></tr><tr><td>
<p>
<code class="literal">scipy.integrate</code>
</p>
</td><td>
<p>
<code class="literal">quad</code>.</p>
</td></tr><tr><td>
<p>
<code class="literal">copy</code>
</p>
</td><td>
<p>
<code class="literal">copy</code> and <code class="literal">deepcopy</code>.</p>
</td></tr></tbody></table></div><p>Table 11.1: Examples of importing objects</p></div><div class="section" title="Modules in IPython"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec115"/>Modules in IPython</h2></div></div></div><p>IPython is used under code development. A typical scenario is that you work on a file with some function or class definitions which you change within a development cycle. For loading the contents of such a file into the shell, you may use <code class="literal">import</code> but the file is loaded only once. Changing the file has no effect on later imports. That's where IPyhthon's magic command <code class="literal">run</code> enters the stage.</p><div class="section" title="The IPython magic command"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec30"/>The IPython magic command</h3></div></div></div><p>IPython has a special magic command named <code class="literal">run</code> that executes a file as if you ran it directly in Python. This means that the file is executed independently of what is already defined in IPython. This is the recommended method to execute files from within IPython when you want to test a script intended as a standalone program. You must import all you need in the executed file in the same way as if you were executing it from the command line. A typical example of running code in <code class="literal">myfile.py</code> is:</p><pre class="programlisting">from numpy import array&#13;
...&#13;
a = array(...)</pre><p>This script file is executed in Python by <code class="literal">exec(open('myfile.py').read())</code>. Alternatively, in IPython the magic command <code class="literal">run myfile</code> can be used if you want to make sure that the script runs independent of the previous imports. Everything that is defined in the file is imported into the IPython workspace.</p></div></div><div class="section" title="The variable __name__"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec116"/>The variable __name__</h2></div></div></div><p>In any module, the special variable <code class="literal">__name__</code> is defined as the name of the current module. In the command line (in IPython), this variable is set to <code class="literal">__main__</code>, which allows the following trick:</p><pre class="programlisting"># module&#13;
import ...&#13;
&#13;
class ...&#13;
&#13;
if __name__ == "__main__":&#13;
   # perform some tests here</pre><p>The tests will be run only when the file is directly run, not when it is imported.</p></div><div class="section" title="Some useful modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec117"/>Some useful modules</h2></div></div></div><p>The list of useful Python modules is vast. In the following table, we have given a very short segment of such a list, focused on modules related to mathematical and engineering applications (<span class="emphasis"><em>Table 11.2)</em></span>:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>Module</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">scipy</code>
</p>
</td><td>
<p>Functions used in scientific computing</p>
</td></tr><tr><td>
<p>
<code class="literal">numpy</code>
</p>
</td><td>
<p>Support arrays and related methods</p>
</td></tr><tr><td>
<p>
<code class="literal">matplotlib</code>
</p>
</td><td>
<p>Plotting and visualization with the import submodule pyplot
</p>
</td></tr><tr><td>
<p>
<code class="literal">functools</code>
</p>
</td><td>
<p>Partial application  of functions
</p>
</td></tr><tr><td>
<p>
<code class="literal">itertools</code>
</p>
</td><td>
<p>Iterator tools to provide special capabilities, like slicing to generators
</p>
</td></tr><tr><td>
<p>
<code class="literal">re</code>
</p>
</td><td>
<p>Regular expressions for advanced string handling
</p>
</td></tr><tr><td>
<p>
<code class="literal">sys</code>
</p>
</td><td>
<p>System specific functions</p>
</td></tr><tr><td>
<p>
<code class="literal">os</code>
</p>
</td><td>
<p>Operating system interfaces like directory listing and file handling</p>
</td></tr><tr><td>
<p>
<code class="literal">datetime</code>
</p>
</td><td>
<p>Representing dates and date increments</p>
</td></tr><tr><td>
<p>
<code class="literal">time</code>
</p>
</td><td>
<p>Returning wall clock time</p>
</td></tr><tr><td>
<p>
<code class="literal">timeit</code>
</p>
</td><td>
<p>Measures execution time</p>
</td></tr><tr><td>
<p>
<code class="literal">sympy</code>
</p>
</td><td>
<p>Computer arithmetic package (symbolic computations)</p>
</td></tr><tr><td>
<p>
<code class="literal">pickle</code>
</p>
</td><td>
<p> Pickling, special file in- and output format
</p>
</td></tr><tr><td>
<p>
<code class="literal">shelves</code>
</p>
</td><td>
<p> Shelves, special file in- and output format
</p>
</td></tr><tr><td>
<p>
<code class="literal">contextlib</code>
</p>
</td><td>
<p>Tools for context managers</p>
</td></tr></tbody></table></div><p>Table 11.2: A non-exhaustive list of useful Python packages for engineering applications</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec91"/>Summary</h1></div></div></div><p>We started the book by telling you that you had to import SciPy and other useful modules. Now you fully understand what importing means. We introduced namespaces and discussed the difference between <code class="literal">import</code> and <code class="literal">from ... import *</code>. The scope of a variable was already introduced in an earlier <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>, but now you have a more complete picture of the importance of that concept.</p></div></body></html>