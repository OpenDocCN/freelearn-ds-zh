<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Real-Time Data</h1>
                </header>
            
            <article>
                
<p>A common saying among geospatial analysts is: <em>A map is outdated as soon as it's created</em>. This saying reflects the fact that the Earth and everything on it are constantly changing. For most of the history of geospatial analysis and through most of this book, geospatial products are relatively static. Raw datasets are typically updated anywhere from a few months to a few years. The age of geospatial data in a map is referred to as <strong>data currency</strong>.</p>
<p>Data currency has traditionally not been the primary focus because of the time and expense needed to collect data. Web mapping, wireless cellular modems, and low-cost GPS antennas have changed that focus. It is now logistically feasible and even quite affordable to monitor a rapidly changing object or system and broadcast those changes to millions of people online. This change is revolutionizing geospatial technology and taking it in new directions. The most direct evidence of this revolution is web mapping mashups using systems such as Google Maps or OpenLayers and web-accessible data formats. Every day, more and more electronic devices are being brought online to broadcast their location and data for automation or remote control. Examples include thermostats, cameras, cars, and more. You can also use cheap, embedded computers such as the popular Raspberry Pi to turn almost anything into a connected <strong>smart</strong> device. This concept of connecting devices into a web of data and information is called <strong>The Internet of Things</strong> (<strong>IoT</strong>).</p>
<p><span>In this chapter, we'll be checking out the following topics:</span></p>
<ul>
<li><span>Limitations of real-time data</span></li>
<li><span>Using real-time data</span></li>
<li><span>Tracking vehicles</span></li>
<li><span>Storm chasing</span></li>
<li><span>Reports from the field</span></li>
</ul>
<p><span>By the end, you'll have learned to work with real-time geospatial data, and will be able to build a field reporting tool that can serve as a data transmission source for any type of data.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter requires the following things:</p>
<ul>
<li>Python 3.6 or higher</li>
<li>RAM: Minimum 6 GB (Windows), 8 GB (macOS), recommended 8 GB</li>
<li>Storage: Minimum 7200 RPM SATA with 20 GB of available space, and recommended SSD with 40 GB of available space</li>
<li class="mce-root">Processor: Minimum Intel Core i3 2.5 GHz, and recommended Intel Core i5</li>
<li>The MapQuest Developer API key, available here: <a href="https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register">https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Limitations of real-time data</h1>
                </header>
            
            <article>
                
<p>The term <strong>real-time data</strong> typically means near-real-time. Some tracking devices capture real-time data and may update as often as several times a second. But the limitations of the infrastructure that broadcasts that data may constrain the output to every 10 seconds or longer. Weather radar is a perfect example. A <strong>Doppler Weather Radar</strong> (<strong>DWR</strong>) sweeps continuously but data is typically available online every five minutes. But given the contrast with traditional geospatial data updates, a refresh of a few minutes is real-time enough. Limitations can be summarized as follows:</p>
<ul>
<li>Network bandwidth limitations restricting data size</li>
<li>Network latency limiting the data update frequency</li>
<li>Availability of the data source due to restrictions such as battery life</li>
<li>Lack of quality control due to data being instantly available to consumers</li>
<li>Security vulnerabilities due to rapid ingestion of unverified data</li>
</ul>
<p>Real-time data opens up additional opportunities for geospatial applications so we'll look at using it next.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using real-time data</h1>
                </header>
            
            <article>
                
<p>Web mashups often use real-time data. Web mashups are amazing and have changed the way many different industries operate. But they are typically limited in that they usually just display pre-processed data on a map and give developers access to a JavaScript API. But what if you want to process the data in some way? What if you want to filter, change, and then send it to another system? To use real-time data for geospatial analysis, you need to be able to access it as point data or a georeferenced raster.</p>
<div class="packt_infobox"><span>You can find out more about web map mashups here: </span><a href="https://www.esri.com/arcgis-blog/products/product/uncategorized/digital-map-mashups/">https://www.esri.com/arcgis-blog/products/product/uncategorized/digital-map-mashups/</a>.</div>
<p>As with examples in the previous chapters, the scripts are as simple as possible and designed to be read from start to finish without much mental looping. When functions are used they are listed first, followed by script variable declarations, and finally the main program execution.</p>
<p><span>Now let's see how to access a real-time and point-location data source using vehicles from the NextBus API.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tracking vehicles</h1>
                </header>
            
            <article>
                
<p>For our first real-time data source, we'll use the excellent <strong>NextBus API</strong>. NextBus (<a href="http://www.nextbus.com/">http://www.nextbus.com/</a>) is a commercial service that tracks public transportation for municipalities including buses, trolleys, and trains. People riding these transit lines can then track the arrival time of the <em>next bus</em>.</p>
<p>What's even better is that, with the customer's permission, NextBus publishes tracking data through a <strong>REpresentational State Transfer</strong> (<strong>REST</strong>) <strong>API.</strong> Using URL API calls, developers can request information about a vehicle and receive an XML document about its location. This API is a straightforward way to begin using real-time data.</p>
<p class="mce-root"/>
<p>If you go to NextBus, you'll see a web interface as shown in the following screenshot, showing data for the city of Los Angeles, California metro system:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9af21cb9-55b2-4dc1-8b1d-878b4e3622ed.png" width="968" height="674"/></p>
<p>The system lets you select several parameters to learn the current location and time prediction for the next stop. On the right side of the screen, there is a link to a Google Maps mashup, showing transit tracking data for the particular route as shown in the following screenshot:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="Images/624abf09-c442-4370-88ed-9a586eb84972.png" width="587" height="341"/></p>
<p>This is a very useful website but it does not give us control over how the data is displayed and used. Let's access the raw data directly using Python and the NextBus REST API to start working with real-time data. </p>
<p>For the examples in this chapter, we'll use the documented NextBus API found here: <a href="http://www.nextbus.com/xmlFeedDocs/NextBusXMLFeed.pdf">http://www.nextbus.com/xmlFeedDocs/NextBusXMLFeed.pdf</a>.</p>
<p>To start with this example, we will need a list of buses required.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NextBus agency list</h1>
                </header>
            
            <article>
                
<p>NextBus customers are called <strong>agencies</strong>. In our examples, we are going to track bu<span>ses on a route for Los</span><span> </span><span>Angeles, California. First, we need to get some information about the agency. The NextBus API consists of a web service named <kbd>publicXMLFeed</kbd>, in which you set a parameter named</span> <kbd>command</kbd><span>. We'll call the <kbd>agencyList</kbd> command in a browser to get an XML document containing agency information using the following REST URL: </span><a href="http://webservices.nextbus.com/service/publicXMLFeed?command=agencyList">http://webservices.nextbus.com/service/publicXMLFeed?command=agencyList</a>.</p>
<p class="mce-root"/>
<p>When we go to that link in a browser, it returns an XML document containing the <kbd>&lt;agency/&gt;</kbd> tag. The tag for Los Angeles looks like the following:</p>
<pre>&lt;agency tag="lametro" title="Los Angeles Metro" regionTitle="California-Southern"/&gt; </pre>
<p><span><span>Now that we have a list of buses, we need to get the routes they can travel.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The NextBus route list</h1>
                </header>
            
            <article>
                
<p>The <kbd>tag</kbd> attribute is the ID for Thunder Bay, which we need for other NextBus API commands. The other attributes are human-readable metadata. The next piece of information we need is the details about the <strong>route 2</strong> bus route. To get this information, we'll use the agency ID and the <kbd>routeList</kbd> <span>REST command </span>to get another XML document by pasting the URL into our web browser.</p>
<div class="packt_tip">Note that the agency ID is set to the parameter in the REST URL: <a href="http://webservices.nextbus.com/service/publicXMLFeed?command=routeList&amp;a=lametro">http://webservices.nextbus.com/service/publicXMLFeed?command=routeList&amp;a=lametro</a>.</div>
<p>When we call this URL in a browser, we get the following XML document:</p>
<pre class="CodePACKT">&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>&lt;body copyright="All data copyright Los Angeles Metro 2015."&gt;&lt;route tag="2" title="2 Downtown LA - Pacific Palisades Via"/&gt;&lt;route tag="4" title="4 Downtown LA - Santa Monica Via Santa"/&gt;<br/>&lt;route tag="10" title="10 W Hollywood-Dtwn LA -Avalon Sta Via"/&gt;<br/>...<br/>&lt;route tag="901" title="901 Metro Orange Line"/&gt;<br/>&lt;route tag="910" title="910 Metro Silver Line"/&gt;<br/>&lt;/body&gt;</pre>
<p>We have buses and routes. We're ready to start tracking their locations! </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">NextBus vehicle locations</h1>
                </header>
            
            <article>
                
<p>So the mainline route ID stored in the <kbd>tag</kbd> attribute is simply <kbd>1</kbd>, according to  these results. Thus, now, we have all of the information we need to track buses along the <strong>LA Metro route 2</strong>. </p>
<p class="mce-root"/>
<p>There is only one more required parameter (called <kbd>t</kbd>) that represents milliseconds since the <strong>1970 epoch date</strong> (<strong>January 1, 1970, at midnight UTC</strong>). The epoch date is simply a computer standard used by machines to track time. The easiest thing to do within the NextBus API is to specify <kbd>0</kbd> for this value, which returns data for the last 15 minutes.</p>
<p>There is an optional <kbd>direction</kbd> tag that allows you to specify a terminating bus stop in the event a route has multiple buses running on the route in opposite directions. But, if we don't specify that, the API will return the first one, which suits our needs. The REST URL to get the mainline route for LA Metro looks like the following: <a href="http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&amp;a=lametro&amp;r=2&amp;t=0">http://webservices.nextbus.com/service/publicXMLFeed?command=vehicleLocations&amp;a=lametro&amp;r=2&amp;t=0</a>.</p>
<p>Calling this REST URL in a browser returns the following XML document:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br/>&lt;body copyright="All data copyright Los Angeles Metro 2015."&gt;<br/>&lt;vehicle id="7582" routeTag="2" dirTag="2_758_0" lat="34.097992" lon="-118.350365" secsSinceReport="44" predictable="true" heading="90" speedKmHr="0"/&gt;<br/>&lt;vehicle id="7583" routeTag="2" dirTag="2_779_0" lat="34.098076" lon="-118.301399" secsSinceReport="104" predictable="true" heading="90" speedKmHr="37"/&gt;<br/>. . .<br/>&lt;/body &gt;  </pre>
<p>E<span>ach <kbd>vehicle</kbd> tag represents a location within the last 15 minutes. The <kbd>last</kbd> tag is the most recent location (even though XML is technically unordered).</span></p>
<div class="packt_infobox">
<p>These public transportation systems do not run all of the time. Many close down at 10:00 p.m. (22:00) local time. If you encounter an error in the script, use the NextBus website to locate a system that is running and change the agency and route variables to that system.</p>
</div>
<p>We can now write a Python script that returns the locations for a bus on a given route. If we don't specify the <kbd>direction</kbd> tag, NextBus returns the first one. In this example, we are going to poll the NextBus tracking API by calling the REST URL using the built-in Python <kbd>urllib</kbd> library demonstrated in previous chapters.</p>
<p class="mce-root"/>
<p>We'll parse the returned XML document using the simple built-in <kbd>minidom</kbd> module, also shown in <em>The minidom module</em> section, in <a href="ff05aa7d-3aac-40b6-b857-e6bf08498141.xhtml">Chapter 4</a><em>, Geospatial Python Toolbox</em>. This script simply outputs the latest latitude and longitude of the route 2 bus. You will see the agency and route variables near the top. To do this, we need to follow the following steps:</p>
<ol>
<li>First, we import the libraries we need:</li>
</ol>
<pre style="padding-left: 60px">import urllib.request<br/>import urllib.parse<br/>import urllib.error<br/>from xml.dom import minidom</pre>
<ol start="2">
<li>Now we set up our variables for API mode and the customer and route we want to query:</li>
</ol>
<pre style="padding-left: 60px"># Nextbus API command mode<br/>command = "vehicleLocations"<br/><br/># Nextbus customer to query<br/>agency = "lametro"<br/><br/># Bus we want to query<br/>route = "2"</pre>
<ol start="3">
<li>We're going to set the time value to <kbd>0</kbd>, which will grab the last <kbd>15</kbd> minutes of data:</li>
</ol>
<pre style="padding-left: 60px"># Time in milliseconds since the<br/># 1970 epoch time. All tracks<br/># after this time will be returned.<br/># 0 only returns data for the last<br/># 15 minutes<br/>epoch = "0"</pre>
<ol start="4">
<li>Now we need to build the query URL that we'll use to access the API:</li>
</ol>
<pre style="padding-left: 60px"># Build our query url<br/># webservices base url<br/>url = "http://webservices.nextbus.com"<br/><br/># web service path<br/>url += "/service/publicXMLFeed?"<br/><br/># service command/mode<br/>url += "command=" + command<br/><br/># agency<br/>url += "&amp;a=" + agency<br/>url += "&amp;r=" + route<br/>url += "&amp;t=" + epoch</pre>
<ol start="5">
<li>Next, we can call the API using <kbd>urllib</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># Access the REST URL<br/>feed = urllib.request.urlopen(url)<br/>if feed:<br/> # Parse the xml feed<br/> xml = minidom.parse(feed)<br/> # Get the vehicle tags<br/> vehicles = xml.getElementsByTagName("vehicle")<br/> # Get the most recent one. Normally there will<br/> # be only one.</pre>
<ol start="6">
<li>Finally, we can access the results and print out the location of each bus:</li>
</ol>
<pre style="padding-left: 60px"> if vehicles:<br/>   bus = vehicles.pop()<br/>   # Print the bus latitude and longitude<br/>   att = bus.attributes<br/>   print(att["lon"].value, ",", att["lat"].value)<br/> else:<br/>   print("No vehicles found.")</pre>
<p>The output of this script is simply a latitude and longitude value that implies that we now have control of the API and understand it. The output should be a coordinate value for the latitude and longitude.</p>
<p><span>Now we are ready to use these location values to create our own map.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mapping NextBus locations </h1>
                </header>
            
            <article>
                
<p>The best source of freely available street mapping data is the <strong>OpenStreetMap</strong> (<strong>OSM</strong>) project: <a href="http://www.openstreetmap.org">http://www.openstreetmap.org</a>. OSM also has a publicly available REST API for creating static map images called <strong>StaticMapLite</strong>: <a href="http://staticmap.openstreetmap.de">http://staticmap.openstreetmap.de</a>.</p>
<p>The <strong>OSM StaticMapLite API</strong> provides a <kbd>GET</kbd> API based on Google's static map API to create simple map images with a limited number of point markers and lines. A <kbd>GET</kbd> API, as opposed to a REST, API allows you to append name/value parameter pairs after a question mark on the URL. A REST API makes the parameters part of the URL path. We'll use the API to create our own NextBus API map on-demand with a red pushpin icon for the bus location.</p>
<p>In the next example, we have condensed the previous script down to a compact function named <kbd>nextbus()</kbd>. The <kbd>nextbus()</kbd> function accepts an agency, route, command, and epoch as arguments. The command defaults to <kbd>vehicleLocations</kbd> and the epoch defaults to <kbd>0</kbd> to get the last 15 minutes of data. In this script, we'll pass in the LA route-2 route information and use the default command that returns the most recent latitude/longitude of the bus.</p>
<p>We have a second function named <kbd>nextmap()</kbd> that creates a map with a purple marker on the current location of the bus each time it is called. The map is created by building a <kbd>GET</kbd> URL for the OSM <kbd>StaticMapLite</kbd> API, which centers on the location of the bus and uses a zoom level between <em>1-18</em> and the map size to determine the map extent.</p>
<div class="packt_tip">You can access the API directly in a browser to see an example of what the <kbd>nextmap()</kbd> function does. You will need a free MapQuest Developer API key available by registering here: <a href="https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register">https://developer.mapquest.com/plan_purchase/steps/business_edition/business_edition_free/register</a>. Once you have the key, insert it in the <kbd>key</kbd> parameter where it says <kbd>YOUR_API_KEY_HERE</kbd>. Then, you can test the following example URL: <kbd>https://www.mapquestapi.com/staticmap/v4/getmap?size=865,512&amp;type=map&amp;pois=mcenter,40.702147,-74.015794|&amp;zoom=14&amp;center=40.714728,-73.998672&amp;imagetype=JPEG&amp;key=YOUR_API_KEY_HERE</kbd>.</div>
<p class="CDPAlignLeft CDPAlign"><span>Static maps look similar to the following:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/71778fe8-ec15-4e7a-96f6-767d10ebeb4c.png" width="881" height="524"/></p>
<p>The <kbd>nextmap()</kbd> function accepts a NextBus agency ID, route ID, and string for the base image name for the map. The function calls the <kbd>nextbus()</kbd> function to get the latitude/longitude pair. The execution of this program loops through at timed intervals, creates a map on the first pass, and then overwrites the map on subsequent passes. The program also outputs a timestamp each time a map is saved. The <kbd>requests</kbd> variable specifies the number of passes and the <kbd>freq</kbd> variable represents the time in seconds between each loop. Let's check the following code to see how of this example works: </p>
<ol>
<li>First, we import the libraries we need:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">import urllib.request<br/>import urllib.parse<br/>import urllib.error<br/>from xml.dom import minidom<br/>import time</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Next, we create a function that can get the latest location of a bus on a given route:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">def nextbus(a, r, c="vehicleLocations", e=0):<br/> """Returns the most recent latitude and<br/> longitude of the selected bus line using<br/> the NextBus API (nbapi)<br/> Arguments: a=agency, r=route, c=command,<br/> e=epoch timestamp for start date of track,<br/> 0 = the last 15 minutes"""<br/> nbapi = "http://webservices.nextbus.com"<br/> nbapi += "/service/publicXMLFeed?"<br/> nbapi += "command={}&amp;a={}&amp;r={}&amp;t={}".format(c, a, r, e)<br/> xml = minidom.parse(urllib.request.urlopen(nbapi))<br/> # If more than one vehicle, just get the first <br/> bus = xml.getElementsByTagName("vehicle")[0]<br/> if bus: <br/> at = bus.attributes<br/> return(at["lat"].value, at["lon"].value)<br/> else:<br/> return (False, False)</pre>
<ol start="3">
<li>Now we have a function to plot a bus location on a map image:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">def nextmap(a, r, mapimg):<br/> """Plots a nextbus location on a map image<br/> and saves it to disk using the MapQuest OpenStreetMap Static Map <br/> API (osmapi)"""<br/> # Fetch the latest bus location<br/> lat, lon = nextbus(a, r)<br/> if not lat:<br/>   return False<br/> # Base url + service path</pre>
<ol start="4">
<li>Within that function, we set up the API parameters in the URL:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"> osmapi = "https://www.mapquestapi.com/staticmap/v4/getmap?<br/> type=map&amp;"<br/># Use a red, pushpin marker to pin point the bus<br/> osmapi += "mcenter={},{}|&amp;".format(lat, lon)<br/># Set the zoom level (between 1-18, higher=lower scale)<br/> osmapi += "zoom=18&amp;"<br/># Center the map around the bus location<br/> osmapi += "center={},{}&amp;".format(lat, lon)<br/># Set the map image size<br/> osmapi += "&amp;size=1500,1000"<br/># Add our API Key<br/> osmapi += "&amp;key=YOUR_API_KEY_HERE"</pre>
<ol start="5">
<li>Now we can create the image by calling the URL and save it:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"> # Create a PNG image<br/> osmapi += "imagetype=png&amp;"<br/> img = urllib.request.urlopen(osmapi)<br/><br/># Save the map image<br/> with open("{}.png".format(mapimg), "wb") as f:<br/>   f.write(img.read())<br/>return True</pre>
<ol start="6">
<li>Now in our main program, we can set up variables about the buses we want to track:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Nextbus API agency and bus line variables<br/>agency = "lametro"<br/>route = "2"<br/># Name of map image to save as PNG<br/>nextimg = "nextmap"</pre>
<ol start="7">
<li>Then, we can specify the <span>number </span>and frequency of tracking points we want:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Number of updates we want to make<br/>requests = 1<br/># How often we want to update (seconds)<br/>freq = 5</pre>
<ol start="8">
<li>Finally, we can begin tracking and updating our map image:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"># Map the bus location every few seconds<br/>for i in range(requests):<br/> success = nextmap(agency, route, nextimg)<br/> if not success:<br/>   print("No data available.")<br/>   continue<br/> print("Saved map {} at {}".format(i, time.asctime()))<br/> time.sleep(freq)</pre>
<ol start="9">
<li>While the script runs, you'll see an output similar to the following, showing at what time the script saved each map:</li>
</ol>
<pre style="padding-left: 60px"><strong>Saved map 0 at Sun Nov 1 22:35:17 2015</strong><br/><strong>Saved map 1 at Sun Nov 1 22:35:24 2015</strong><br/><strong>Saved map 2 at Sun Nov 1 22:35:32 2015</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This script saves a map image similar to the following, depending on where the bus was when you ran it: </p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c70b792f-51a9-45ae-a35d-bb152171205e.png" width="635" height="598"/></p>
<p class="mce-root"/>
<p>This map is an excellent example of using an API to create a custom mapping product. But it is a very basic tracking application. To begin to develop it into a more interesting geospatial product, we need to combine it with some other real-time data source that gives us more situational awareness.</p>
<p>Now that we can track buses, let's add some additional information to the map that would be useful to know for passengers taking a bus. Let's add some weather data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Storm chasing</h1>
                </header>
            
            <article>
                
<p>So far, we have created a simpler version of what the NextBus website already does. But we have done it in a way that ultimately gives us complete control over the output. Now we want to use this control to go beyond what the NextBus Google Maps mashup does. We'll add another real-time data source that is very important to both travelers and bus-line operators: the weather.</p>
<p><strong>Iowa State University's Mesonet</strong> program provides free and polished weather data for applications. We use this data to create a real-time weather map for our bus location map. We can use the <strong>Open Geospatial Consortium</strong> (<strong>OGC</strong>) <strong>Web Map Service</strong> (<strong>WMS</strong>) standard to request a single image over our area of interest. A WMS is an OGC standard for serving georeferenced map images through the web; they are generated by a map server through an HTTP request.</p>
<p>The Mesonet system provides an excellent web mapping service that returns a subsetted image from a global precipitation mosaic based on a properly-formatted WMS request. An example of such a request is the following query: <a href="http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi?service=wms&amp;version=1.1.1&amp;request=getmap&amp;layers=nexrad-n0r&amp;styles=&amp;srs=epsg:900913&amp;bbox=-15269659.42,2002143.61,-6103682.81,7618920.15&amp;width=600&amp;height=600&amp;format=image/png">http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetMap&amp;LAYERS=nexrad-n0r&amp;STYLES=&amp;SRS=EPSG:900913&amp;BBOX=-15269659.42,2002143.61,-6103682.81,7618920.15&amp;WIDTH=600&amp;HEIGHT=600&amp;FORMAT=image/png</a>.</p>
<p>Because the examples in this chapter rely on real-time data, the specific requests listed may produce blank weather images if there is no activity in the area of interest. You can visit this link (<a href="http://radar.weather.gov/ridge/Conus/index.php">http://radar.weather.gov/ridge/Conus/index.php</a>) to find an area where a storm is occurring. This page contains a KML link for Google Earth or QGIS. These WMS images are transparent PNG images similar to the following sample:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a39f31c3-a584-430b-89ba-8af09ac5ed71.png" width="1095" height="671"/></p>
<p>The OSM site, on the other hand, no longer provides its street maps via WMS—only as tiles. They do, however, allow other organizations to download tiles or raw data to extend the free service. The US <strong>National Oceanic and Atmospheric Administration</strong> (<strong>NOAA</strong>) has done just that and provided a WMS interface to their OSM data, allowing requests to retrieve the single basemap image we need for our bus route:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c228131d-66db-41f5-8c00-5c42b22efbb2.png" width="610" height="609"/></p>
<p>We now have data sources from which to get the basemap and weather data. We want to combine these images and plot the current location of the bus. Instead of a simple dot, we'll get a little more sophisticated and add the following bus icon this time:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c064e817-54d8-4b76-91db-aad622f3b828.png" style="width:14.58em;height:14.58em;" width="256" height="256"/></p>
<p>You will need to download this icon, <kbd>busicon.png</kbd>, to your working directory  from here: <a href="https://github.com/GeospatialPython/Learn/blob/master/busicon.png?raw=true">https://github.com/GeospatialPython/Learn/blob/master/busicon.png?raw=true</a>.</p>
<p>Now we'll combine our previous scripts and our new data sources to create a real-time weather bus map. Because we are going to blend the street map and weather map, we'll need the <strong>Python Imaging Library</strong> (<strong>PIL</strong>) used in previous chapters. We'll replace our <kbd>nextmap()</kbd> function from the previous example with a simple <kbd>wms()</kbd> function that can grab a map image by a bounding box from any WMS service.  We'll also add a function that converts decimal degrees into meters, named <kbd>ll2m()</kbd>. </p>
<p>The script gets the bus location, converts the location to meters, creates a 2 mile (3.2 km) rectangle around the location, and then downloads a street and weather map. The map images are then blended together using PIL. PIL then shrinks the   bus icon image to 30 x 30 pixels and pastes it in the center of the map, which is the bus location. Let's look at how the following code works:</p>
<ol>
<li>First, we'll import the libraries we need:</li>
</ol>
<pre style="padding-left: 60px">import sys<br/>import urllib.request<br/>import urllib.parse<br/>import urllib.error<br/>from xml.dom import minidom<br/>import math<br/>try:<br/> import Image<br/>except:<br/> from PIL import Image</pre>
<ol start="2">
<li>Now we'll reuse our <kbd>nextbus</kbd> function from the previous example to get the bus tracking data:</li>
</ol>
<pre style="padding-left: 60px">def nextbus(a, r, c="vehicleLocations", e=0):<br/> """Returns the most recent latitude and<br/> longitude of the selected bus line using<br/> the NextBus API (nbapi)"""<br/> nbapi = "http://webservices.nextbus.com"<br/> nbapi += "/service/publicXMLFeed?"<br/> nbapi += "command=%s&amp;a=%s&amp;r=%s&amp;t=%s" % (c, a, r, e)<br/> xml = minidom.parse(urllib.request.urlopen(nbapi))<br/> # If more than one vehicle, just get the first<br/> bus = xml.getElementsByTagName("vehicle")[0]<br/> if bus:<br/> at = bus.attributes<br/> return(at["lat"].value, at["lon"].value)<br/> else:<br/> return (False, False)</pre>
<ol start="3">
<li>We also need a function to convert latitude and longitude into meters:</li>
</ol>
<pre style="padding-left: 60px">def ll2m(lon, lat):<br/> """Lat/lon to meters"""<br/> x = lon * 20037508.34 / 180.0<br/> y = math.log(math.tan((90.0 + lat) *<br/> math.pi / 360.0)) / (math.pi / 180.0)<br/> y = y * 20037508.34 / 180<br/> return (x, y)</pre>
<ol start="4">
<li>Now we need a function to retrieve WMS map images, which we'll use for our weather image:</li>
</ol>
<pre style="padding-left: 60px">def wms(minx, miny, maxx, maxy, service, lyr, epsg, style, img, w, <br/>        h):<br/>    """Retrieve a wms map image from<br/>    the specified service and saves it as a JPEG."""<br/>    wms = service<br/>    wms += "?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetMap&amp;"<br/>    wms += "LAYERS={}".format(lyr)<br/>    wms += "&amp;STYLES={}&amp;".format(style)<br/>    wms += "SRS=EPSG:{}&amp;".format(epsg)<br/>    wms += "BBOX={},{},{},{}&amp;".format(minx, miny, maxx, maxy)<br/>    wms += "WIDTH={}&amp;".format(w)<br/>    wms += "HEIGHT={}&amp;".format(h)<br/>    wms += "FORMAT=image/jpeg"<br/>    wmsmap = urllib.request.urlopen(wms)<br/>    with open(img + ".jpg", "wb") as f:<br/>        f.write(wmsmap.read())</pre>
<ol start="5">
<li>Now we can set up all of the variables in our main program to use our functions:</li>
</ol>
<pre style="padding-left: 60px"># Nextbus agency and route ids<br/>agency = "roosevelt"<br/>route = "shuttle"<br/># OpenStreetMap WMS service<br/>basemap = "http://ows.mundialis.de/services/service"<br/># Name of the WMS street layer<br/>streets = "TOPO-OSM-WMS"<br/># Name of the basemap image to save<br/>mapimg = "basemap"<br/># OpenWeatherMap.org WMS Service<br/>weather = "https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q.cgi?"<br/># If the sky is clear over New York,<br/># use the following url which contains<br/># a notional precipitation sample:<br/># weather = "http://git.io/vl4r1"<br/># WMS weather layer<br/>weather_layer = "<span>nexrad-n0q-900913</span>"<br/># Name of the weather image to save<br/>skyimg = "weather"<br/># Name of the finished map to save<br/>final = "next-weather"<br/># Transparency level for weather layer<br/># when we blend it with the basemap.<br/># 0 = invisible, 1 = no transparency<br/>opacity = .5<br/># Pixel width and height of the<br/># output map images<br/>w = 600<br/>h = 600<br/># Pixel width/height of the the<br/># bus marker icon<br/>icon = 30</pre>
<ol start="6">
<li>Now we're ready to get our bus location:</li>
</ol>
<pre style="padding-left: 60px"># Get the bus location<br/>lat, lon = nextbus(agency, route)<br/>if not lat:<br/> print("No bus data available.")<br/> print("Please try again later")<br/> sys.exit()<br/># Convert strings to floats<br/>lat = float(lat)<br/>lon = float(lon)<br/># Convert the degrees to Web Mercator<br/># to match the NOAA OSM WMS map<br/>x, y = ll2m(lon, lat)<br/># Create a bounding box 1600 meters<br/># in each direction around the bus<br/>minx = x - 1600<br/>maxx = x + 1600<br/>miny = y - 1600<br/>maxy = y + 1600</pre>
<ol start="7">
<li>Then, we can download our street map:</li>
</ol>
<pre style="padding-left: 60px"># Download the street map<br/>wms(minx, miny, maxx, maxy, basemap, streets, mapimg, w, h)</pre>
<ol start="8">
<li>Then, we can download the weather map:</li>
</ol>
<pre style="padding-left: 60px"># Download the weather map<br/>wms(minx, miny, maxx, maxy, weather, weather_layer, skyimg, w, h)</pre>
<ol start="9">
<li>Now we can overlay the weather data on the bus map:</li>
</ol>
<pre style="padding-left: 60px"># Open the basemap image in PIL<br/>im1 = Image.open("basemap.png").convert('RGBA')<br/># Open the weather image in PIL<br/>im2 = Image.open("weather.png").convert('RGBA')<br/># Convert the weather image mode<br/># to "RGB" from an indexed PNG<br/># so it matches the basemap image<br/>im2 = im2.convert(im1.mode)<br/># Create a blended image combining<br/># the basemap with the weather map<br/>im3 = Image.blend(im1, im2, opacity)</pre>
<ol start="10">
<li>Next, we need to add the bus icon to our combined map to show the bus's location:</li>
</ol>
<pre style="padding-left: 60px"># Open up the bus icon image to<br/># use as a location marker.<br/># http://git.io/vlgHl <br/>im4 = Image.open("busicon.png")<br/># Shrink the icon to the desired<br/># size<br/>im4.thumbnail((icon, icon))<br/># Use the blended map image<br/># and icon sizes to place<br/># the icon in the center of<br/># the image since the map<br/># is centered on the bus<br/># location.<br/>w, h = im3.size<br/>w2, h2 = im4.size<br/># Paste the icon in the center of the image<br/>center_width = int((w/2)-(w2/2))<br/>center_height = int((h/2)-(h2/2))<br/>im3.paste(im4, (center_width, center_height), im4)</pre>
<ol start="11">
<li>Finally, we can save the finished map:</li>
</ol>
<pre style="padding-left: 60px"># Save the finished map<br/>im3.save(final + ".png")</pre>
<p>This script will produce a map similar to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5cda48cd-bba9-4174-bade-c1577c918866.png" width="611" height="611"/></p>
<p>The map shows us that the bus is experiencing moderate precipitation at its current location. The color ramp, as shown in the Mesonet website screenshot earlier, ranges from light blue for light precipitation, then green, yellow, orange, to red as the rain gets heavier (or light gray to darker gray in black and white). So, at the time this map was created, the bus-line operator could use this image to tell their drivers to go a little slower, and passengers will know they may want to get an umbrella before heading to the bus stop. </p>
<div class="packt_tip">
<p>Because we wanted to learn the NextBus API at a low level, we used the API directly using built-in Python modules. But several third-party Python modules exist for the API including one on PyPI, simply called <kbd>nextbus</kbd>, which allows you to work with higher-level objects for all of the NextBus commands and provides more robust error handling not included in the simple examples in this chapter.</p>
</div>
<p>Now that we've learned how to check the weather, let's combine discrete real-time data sources into more meaningful products using Python, HTML, and JavaScript.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reports from the field</h1>
                </header>
            
            <article>
                
<p>In our final example in this chapter, we'll get off of the bus and out into the field. Modern smartphones, tablets, and laptops allow us to update a GIS and view those updates from everywhere. We'll use HTML, GeoJSON, the Leaflet JavaScript library, and a pure-Python library named Folium to create a client-server application that allows us to post geospatial information to a server and then create an interactive web map to view those data updates.</p>
<p>First, we need a web form that shows your current location and updates the server when you submit the form with comments about your location. You can find the form here: <a href="http://geospatialpython.github.io/Learn/fieldwork.html">http://geospatialpython.github.io/Learn/fieldwork.html</a>.</p>
<p><a href="http://geospatialpython.github.io/learn/fieldwork.html"/></p>
<p>The following screenshot shows the form:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c4cf73ba-0a9f-45f8-be5b-25e5cd783c08.png" width="786" height="733"/></p>
<p>You can view the source of that form to see how it works. The mapping is done using the Leaflet library and posts GeoJSON to a unique URL on <a href="http://myjson.com/">myjson.com</a>. You can use this page on mobile devices, move it to any web server, or even use it on your local hard drive.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The form posts to the following URL publicly on <a href="http://myjson.com/">myjson.com</a>: <a href="https://api.myjson.com/bins/467pm">https://api.myjson.com/bins/467pm</a>. You can visit that URL in a browser to see the raw GeoJSON.</p>
<p>Next, you need to install the Folium library from PyPI. Folium provides a simple Python API for creating Leaflet web maps. You can find more information about Folium here: <a href="https://github.com/python-visualization/folium">https://github.com/python-visualization/folium</a>.</p>
<p>Folium makes producing a Leaflet map extremely simple. This script is just a few lines and will output a web page named <kbd>map.html</kbd>. We pass the GeoJSON URL to the <kbd>map</kbd> object, which will plot the locations on the map:</p>
<pre>import folium<br/>m = folium.Map()<br/>m.geo_json(geo_path="https://api.myjson.com/bins/467pm")<br/>m.create_map(path="map.html")</pre>
<p>The resulting interactive map will display points as markers. When you click on a marker, the information from the form is displayed. You can just open the HTML file in any browser.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Real-time data is an exciting way to do new types of geospatial analysis, only recently made possible by advances in several different technologies, including web mapping, GPS, and wireless communications. In this chapter, you learned how to access raw feeds for real-time location data, how to acquire a subset of real-time raster data, how to combine different types of real-time data into a custom map analysis product using only Python, and how to build client-server geospatial applications to update a GIS in real-time. </p>
<p>As with previous chapters, these examples contain building blocks that will let you build new types of application using Python that go far beyond the typical popular and ubiquitous JavaScript-based mashups.</p>
<p>In the next chapter, we will combine everything we've learned so far into a complete geospatial application that applies algorithms and concepts in a realistic scenario.</p>


            </article>

            
        </section>
    </div>



  </body></html>