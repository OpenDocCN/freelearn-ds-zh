- en: Flask and GeoAlchemy2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has always had strong internet capabilities. The standard library includes
    models for HTTP processing, STMP messages, and URL requests. Thousands of third-party
    modules have been written to extend or improve the built-in web functionality.
    Over time, a few modules coalesced into Python web frameworks—code libraries written
    to manage the creation and maintenance of complex and dynamic websites.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how to use a Python web framework and how to add geospatial
    capabilities, we'll implement the Flask **Model View Controller** (**MVC**) framework.
    A pure Python web framework, Flask can be combined with SQLAlchemy, GeoAlchemy2,
    and the Jinja2 HTML template system to create geospatially-enabled web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: The Flask web framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAlchemy database management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoAlchemy2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to PostGIS using object-relational mapping (ORM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Jinja2 web page template system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask and its component modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask, as opposed to Django and GeoDjango (covered in [Chapter 12](a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml),
    *GeoDjango*), does not include batteries. Instead, it allows a number of supporting
    modules to be installed as needed. This gives more freedom to you as the programmer,
    but it also makes it necessary to install the required components separately.
  prefs: []
  type: TYPE_NORMAL
- en: I've chosen some modules for this chapter that will allow us to create a Flask
    application with a geospatial component. The following sections will detail how
    to set up, install, and utilize these modules to generate a website, using a demonstration
    site with a PostGIS database backend (as covered in [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml),
    *Geoprocessing with Geodatabases*) and the ability to perform spatial queries
    through a web-based interface.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of important Python modules must be in place to ensure that the Flask
    application and its connection to the PostgreSQL and PostGIS database components,
    will run as required. These modules will be downloaded and installed using `pip`,
    which connects to the **Python Package Index** (**PyPI**), an online repository
    of registered modules located at [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
  prefs: []
  type: TYPE_NORMAL
- en: 'These modules include:'
  prefs: []
  type: TYPE_NORMAL
- en: Flask, a pure Python MVC web framework ([http://flask.pocoo.org/](http://flask.pocoo.org/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-SQLAlchemy, a database ORM module that can connect to a multitude of database
    backends ([http://flask-sqlalchemy.pocoo.org/2.3/](http://flask-sqlalchemy.pocoo.org/2.3/)).
    This module installs SQLAlchemy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoAlchemy2, a Python module that builds on the SQLAlchemy module and the Postgres/PostGIS
    backend (covered in [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml), *Geoprocessing
    with Geodatabases*), is used to allow for geospatial data columns and ORM spatial
    queries ([https://geoalchemy-2.readthedocs.io/en/latest/](https://geoalchemy-2.readthedocs.io/en/latest/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-WTForms, a web form module built on the WTForms ([https://wtforms.readthedocs.io/en/latest/](https://wtforms.readthedocs.io/en/latest/))
    that allows for Flask to carry the logic of each web page and to process the inputs
    ([https://flask-wtf.readthedocs.io/en/stable/](https://flask-wtf.readthedocs.io/en/stable/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAlchemy-Utils, used to manage database creation and deletion ([https://github.com/kvesteri/sqlalchemy-utils/](https://github.com/kvesteri/sqlalchemy-utils/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`psycopg2`, used to create connections to the PostgreSQL database and is used
    by the SQLAlchemy module ([http://initd.org/psycopg/](http://initd.org/psycopg/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyshapefile` (or `pyshp`), used to read the shapefiles used in this example
    and add it to the database tables ([https://pypi.python.org/pypi/pyshp](https://pypi.python.org/pypi/pyshp)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `pygeoif` ([https://pypi.python.org/pypi/pygeoif](https://pypi.python.org/pypi/pygeoif))
    is used to allow for the conversion of data from a shapefile binary encoding to
    a **well-known text** (**WKT**) encoding, for insertion of geometry data into
    the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other important supporting modules are automatically installed along with Flask
    and the preceding modules, including the Jinja2 templating system ([http://jinja.pocoo.org/](http://jinja.pocoo.org/))
    and the Werkzeug **Web Server Gateway Interface** (**WSGI**) module ([http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Installing modules using pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have multiple versions of Python installed on your machine and you''re
    not using a virtual environment with the `virtualenv` module, ensure that the
    `pip` version being called with the command line is the Python 3 version using
    the `pip -V` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once it is clear that the correct `pip` is being called from the command line,
    the modules can be installed. Let's walk through the required `pip` commands and
    some examples of the expected output that each command will generate.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Flask using pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, install the Flask module itself. Use the `pip` command `pip install
    flask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pip` will find Flask and its required dependencies on PyPI and will then
    run the included `setup.py` instructions (or the equivalent) to install the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22176846-a3f1-4e2d-a648-f807ca651a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing Flask-SQLAlchemy via pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the command `pip install flask-sqlalchemy` to install the `flask-sqlalchemy`
    wheel and its required dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The install command will find the `flask-sqlalchemy` wheel file (a pre-built
    file type used by `pip` to install modules) on PyPI and run the installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcee7274-f35b-44f2-952c-4305f5475864.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing GeoAlchemy2 using pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the command `pip install GeoAlchemy2` to call the module from PyPI, download
    the wheel file, and install it into the `Lib`/`site-packages` folder of the Python
    installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Installing Flask-WTForms and WTForms using pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the WTForms module and the Flask-WTF interface, we can create the web
    forms that will make the webpage interactive. Install it using the `pip install
    flask-wtf` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Installing psycopg2 using pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pscycopg2` is a Python module used to connect to PostgreSQL databases.
    If it is not installed yet (see [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml),
    *Geoprocessing with Geodatabases*), install it using the `pip install psycopg2`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Installing SQLAlchemy-Utils using pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These utilities allow for quick database creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Installing pyshapefile (or pyshp) using pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pyshapefile` module can read and write shapefiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Installing pygeoif using pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pygeoif` module allows for geospatial data format conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Writing a Flask application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore the basics of Flask and GeoAlchemy2, we'll build a Flask web application
    and test and deploy it locally using the included web server. This web application
    allows the user to find the county, state, and congressional district associated
    with different arena's located throughout the country. This application will involve
    downloading shapefiles from a **United States Geological Survey** (**USGS**) data
    catalog and will have views (Python functions that process web requests) performing
    geospatial queries using the GeoAlchemy2 ORM and table relationship searches using
    the SQLAlchemy ORM.
  prefs: []
  type: TYPE_NORMAL
- en: This application requires the use of two scripts that create the database and
    database tables. These scripts are detailed as we proceed further and are in the
    `Chapter11` folder of the book's code package. The final product will be a web
    application that uses a `Leaflet` JavaScript map to display the results of ORM-based
    spatial queries and a relationship query.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the data from a data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start this project, let's download data from the USGS data catalog. This
    project will use four US-based shapefiles—an NBA arena shapefile, a states shapefile,
    a congressional districts shapefile, and a counties shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: The USGS has a lot of USA shapefiles for download available here: [https://www.sciencebase.gov/catalog/item/503553b3e4b0d5ec45b0db20](https://www.sciencebase.gov/catalog/item/503553b3e4b0d5ec45b0db20).
  prefs: []
  type: TYPE_NORMAL
- en: County, district, state, and arena shapefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `US_County_Boundaries` data is a polygon shapefile available from the USGS
    data catalog at this address: [https://www.sciencebase.gov/catalog/item/4f4e4a2ee4b07f02db615738](https://www.sciencebase.gov/catalog/item/4f4e4a2ee4b07f02db615738).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the download zip link, as shown in the image. Unzip the file into
    a project folder (for example, `C:\GeospatialPy3\Chapter11`) so it can be accessed
    throughout the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b1862b4-a369-41a9-80dd-7d08f08e80a3.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Arenas_NBA` shapefile is available here: [https://www.sciencebase.gov/catalog/item/4f4e4a0ae4b07f02db5fb54d](https://www.sciencebase.gov/catalog/item/4f4e4a0ae4b07f02db5fb54d).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Congressional_Districts` shapefile is available here: [https://www.sciencebase.gov/catalog/item/4f4e4a06e4b07f02db5f8b58](https://www.sciencebase.gov/catalog/item/4f4e4a06e4b07f02db5f8b58).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `US_States` shapefile is available here: [https://www.sciencebase.gov/catalog/item/4f4e4783e4b07f02db4837ce](https://www.sciencebase.gov/catalog/item/4f4e4783e4b07f02db4837ce).'
  prefs: []
  type: TYPE_NORMAL
- en: These shapefiles are not current (for example, the Nets arena is still listed
    as being in New Jersey and not in Brooklyn), but it's the application techniques
    that we're exploring here (and how they deal with geometry data types) and not
    the data itself, so ignore the temporal quality of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database and data tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our database and the tables that will hold the application data,
    we will use the SQLAlchemy and GeoAlchemy2 classes and methods. The following
    code is in the script called `Chapter11_0.py`. This code will allow us to connect
    to a PostgreSQL data server to create a database and data tables that will form
    the backend of the web application. Import these libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Connecting the database server to both generate and query the data tables is
    achieved using the `create_engine` function and the connection string format,
    demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Connection strings are used throughout all Python database modules. They usually
    include a specification of the **relational database management system** (**RDBMS**)
    type, the username, the password, the instance host (that is the IP address or
    `localhost` for a database server installed on the local machine), an optional
    port number, and a database name. For example, a connection string might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `postgresql` is the RDBMS type, `postgres` is the user, `bond007`
    is the password, `localhost` is the instance host, `5432` is the port (and the
    default port for PostgreSQL installations; if the port wasn't changed on installation,
    it can be left out of the connection string), and `chapter11` is the name of the
    database. The `echo=True` statement is used to generate logs of the database interactions
    to the standard output window. To turn these messages off, change the echo value
    to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: A more thorough explanation of this pattern can be found here: [http://docs.sqlalchemy.org/en/latest/core/engines.html](http://docs.sqlalchemy.org/en/latest/core/engines.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our database, we can use the following format. Replace `{user}` and `{pword}`
    (including the brackets) with your PostgreSQL server username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the connection string is valid, the `create_engine` function will return
    an object to the `engine` variable, which will be used to perform database interactions
    throughout the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the comment (`#drop_database(engine.url)`) is commented out but
    can be uncommented if the database needs to be dropped and then recreated using
    the script. It calls the SQLAlchemy create_engine''s `url` property, which is
    a reference to the connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The database and the data tables it will contain is created within an `if not`
    conditional that relies on the `database_exists` function. If the conditional
    returns `True` (indicating that the database does not exist), the `engine` variable
    is passed to the `create_database` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Adding the PostGIS extension tables to the new database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just underneath the `create_database` function, we will need to connect to
    the database using the `engine.connect` function to pass an SQL statement directly
    to the database. This SQL statement, `("CREATE EXTENSION postgis*"*)` enables
    spatial columns and queries within the new database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A `try`/`except` block is used here in case the database has already been spatially
    enabled. Check the output from the `print` statements to ensure that no other
    exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the database tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the world of Python MVC web frameworks, the database tables are the **models**.
    Used by the website to store data, they are generated with and modeled by Python
    classes. These classes subclass or inherit pre-written functionality from a superclass
    that contains a majority of the database management code, leaving us to simply
    define the columns of the table using basic data types such as strings and integers,
    as well as advanced classes such as geometries.
  prefs: []
  type: TYPE_NORMAL
- en: These class-defined tables can be generated in multiple RDBMS without the need
    to revamp how the model code is written. While GeoAlchemy2 only works on top of
    PostgreSQL/PostGIS, SQLAlchemy models can be used to generate tables in a variety
    of databases, including SQL Server, Oracle, Postgres, MySQL and more.
  prefs: []
  type: TYPE_NORMAL
- en: The declarative base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For SQLAlchemy database classes, a base class called the `declarative_base`
    allows for inheritance of database methods and properties (this is where the superclass
    magic of SQLAlchemy exists, handling database SQL statements in multiple SQL versions,
    which simplifies the code required to write to any RDBMS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Database table model classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the base has been called or instantiated, it can be passed to the model
    classes. These classes, like all Python classes, could include functions, properties,
    and methods which are useful for processing data internally to the class. In this
    chapter, the models do not include any internal functions, but instead only define
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore SQLAlchemy models and their internal functions here: [http://docs.sqlalchemy.org/en/latest/orm/tutorial.html](http://docs.sqlalchemy.org/en/latest/orm/tutorial.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Table properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of the data table generated in the RDBMS database will correspond to
    the `__tablename__` property of a model class. The primary key for each table
    is used for relationships and queries and must be defined using the keyword `primary_key`.
    The `Column` class and the `String`, `Float` and `Integer` type classes are called
    from SQLAlchemy and are used to define table columns to be generated within the
    underlying RDBMS (thus allowing the programmer to avoid crafting `CREATE TABLE`
    statements for each variety of SQL used by the major RDBMS).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `Arena` class will be used to manage a table that has four
    columns—a `String` `name` field, two `Float` fields (`longitude` and `latitude`),
    and a `POINT` geometry type with an SRID or EPSG spatial reference system ID of
    `4326`, corresponding to the WGS 1984 coordinate system ([http://spatialreference.org/ref/epsg/wgs-84/](http://spatialreference.org/ref/epsg/wgs-84/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Like the `Arena` class, the following classes use a `String` `name` column.
    For the geometry type, they also use SRID `4326`, but they use the `MULTIPOLYGON`
    geometry type to store the complex multipolygon geometries used to model these
    geographies. For tables with relationships, as in the case of the `County`, `District`,
    and `State` classes, there are also special classes used to manage table relationships
    and queries between tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'These special classes include the `ForeignKey` class and the `relationship`
    function. The `ForeignKey` class is passed an `id` parameter and passed to a `Column`
    class, associating the child row''s with the parent. The `relationship` function
    allows two-way queries. The `backref` keyword generates a function that instantiates
    an instance of the joined table''s model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `County` class and the `District` class will have a `relationship` with
    the `State` class, allowing session queries that call the `State` class. This
    `relationship` makes it easy to find which US state a county or congressional
    district is located in. The `state_id` column builds the `relationship`, and the `state_ref` field
    references the parent `State` class. For the `State` class, the counties and districts
    have their own `backref` references, allowing the parent `State` class to access
    the associated counties/districts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating the tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To actually generate the tables, there are two methods that can be used. Table
    model classes have an internal `__table__` method that has a `create` function,
    which can be used to create each table separately. There is also a `drop` function
    that can be called to drop a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script, we use `try`*/*`except` blocks to generate the tables. If an
    exception is incurred (that is, if the table already exists), the table is dropped
    and then created. Here is the `State` table creation statement as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, all database tables can be generated from the defined classes
    using the `Base` method `metadata` and its `create_all` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Inserting data into the new data tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the database has been created and the database tables have been defined
    and created within the database, the data can be added. A second script, `Chapter11_1.py`,
    will be used to find and read the data contained within the downloaded shapefiles
    and `for` loops will be used to read through the data and write it to the respective
    database table. An SQLAlchemy session manager will be used to query and commit
    data to the tables.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the required modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the data to be processed and imported, a few new modules will be used. The
    `pyshapefile` module (or `pyshp`, imported as shapefile) is used to connect to
    the shapefiles and to read both the geometries and attribute data that they contain.
    The `pygeoif` module is a pure Python module that implements a protocol known
    as the `geo_interface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This protocol allows Python object-level introspection of geospatial data,
    for example, it converts geospatial data formats into Python objects. It will
    be used to convert between shapefile geometries stored in binary into WKT geometries
    that can be inserted into the database using the GeoAlchemy2 ORM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: More discussion of the `geo_interface` protocol is available here: [https://gist.github.com/sgillies/2217756](https://gist.github.com/sgillies/2217756).
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the database and the tables, import the SQLAlchemy ORM and other
    SQLAlchemy functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To add data to the geometry columns of the database tables, the GeoAlchemy2
    `Geometry` data type will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the script to find the downloaded shapefiles, use the `Tkinter` module
    and its `filedialog` method, as it is built into Python and is OS-agnostic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Connections to the database will again be created using the `create_engine`
    function from SQLAlchemy. This section also generates a `session` using the session
    manager, binding it to the `engine` variable that connects to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `session` will allow for queries and commits (that is, writing to the database) to
    them being managed. We will need to query against database tables inside the `for`
    loop, to create the database relationships between the counties, districts, and
    states.
  prefs: []
  type: TYPE_NORMAL
- en: The database table models are again defined within the script, subclassing from
    the `declarative_base` class. These class definitions will match those within
    the last script.
  prefs: []
  type: TYPE_NORMAL
- en: Locating and reading the shapefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create file dialogs that allow the user to search for and locate shapefiles,
    Tkinter''s `Tk` class is instantiated and assigned to the variable `root`. The
    `Tk` class creates a small console window that is not necessary, so it is withdrawn
    using the `root.withdraw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The file dialogs are generated using the `filedialog.askopenfilename` method.
    The method accepts a number of arguments, including the `title` of the file dialog
    window, the initial directory, and the file extensions that should be visible
    while using the file dialog. Here is the `Select Arena Shapefile` dialog code
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Within the script, this is repeated for each of the downloaded shapefiles. After
    using the file dialogs, each of the shapefiles located will pass a string type
    file path to the `root` variable and the file path will be held in a property.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing shapefile data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access the data within the shapefiles, the `pyshp` `Reader` class is invoked
    by passing the respective file path property to the `Reader` class. The instantiated
    class will have both `records` and a `shapes` method, to allow access to the shapefile''s
    attribute data and geometry data respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once the data has been read and assigned to iteratable variables, they can be
    iterated using `for` loops. Because the data accessed using the `pyshp` `Reader`
    `records` method corresponds to the data accessed using the `shapes` method, a
    loop counter generated using the `enumerate` function is used to match indexes
    between the current record and the corresponding geometry data in the list of
    geometries generated by the `shapes` method.
  prefs: []
  type: TYPE_NORMAL
- en: For the `Arena` shapefile geometry, the `Reader` `shapes` method returns the
    data as a list with coordinate pairs. As the `Arena` class geometry column is
    a `POINT` data type, the data can be written to the database table using a `POINT(X
    Y)` WKT template. The SRID (`4326`) is included at the beginning of the string,
    as per GeoAlchemy2 Extended WKT (EWKT) requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Read more on the GeoAlcheym2 ORM here: [http://geoalchemy-2.readthedocs.io/en/0.4/orm_tutorial.html](http://geoalchemy-2.readthedocs.io/en/0.4/orm_tutorial.html).
  prefs: []
  type: TYPE_NORMAL
- en: With each loop, a new `Arena` class is instantiated and assigned to the variable
    `arena`. The `name` field is extracted from the `Reader` `record` data item located
    at index `6` and assigned to the `arena` variable, while the geometry data is
    extracted from the `arena_shapes` data item at `count` (that is, the current loop
    number) and assigned to the `Arena` columns called `arena.longitude` and `arena.latitude`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These coordinates are then passed to the string `format` method to format the
    EWKT template and assigned to the `arena.geom` property. Once the data for the
    `arena` row has been assigned, it''s added to the session using `session.add`.
    Finally, the data is written to the database using the session''s `commit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `State` class (and the `County` and `District` classes), the name, **Federal
    Information Processing Standards** (**FIPS**) code, and postal code abbreviation
    are extracted from the attribute data using indexing. The `pygeoif` is used to
    convert the geometry first into a `pygeoif` `MultiPolygon` format and then into
    WKT, which is passed to a string template and written to the `geom` field as EWKT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Because of the large size of the geometry data for states, they are committed
    to the database every `10` loops. The final `commit` catches any remainder.
  prefs: []
  type: TYPE_NORMAL
- en: Using queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the `District` and `County` data tables, a final wrinkle is added, querying
    against the newly added `state` data to find the associated state by FIPS code.
    By querying the `State` class using `session.query` and filtering the state''s
    data using the `filter_by` method (passing the FIPS code from the district records
    as the `filter` argument), and then specifying that the `first` result should
    be used, the correct `state` can be called. The variable state''s `id` field is
    used to populate the district''s `state_id` column to create the `relationship`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `County` table is similarly looped and also includes a `State` query. Check
    the script to see the completed code. Once all of the data has been written to
    the data tables, `close` the session and `dispose` of the connection engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Components of the Flask application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the backend database and tables have been created and loaded with data
    and the relationships between the tables have been modeled and generated, it's
    time to write the scripts that will create the Flask application. These scripts
    will contain views, models, and forms that process web requests, query the database,
    and return an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: The web application is called the Arena application, as it lists all of the
    NBA `arenas` stored in the `arena` table in a drop-down list, and allows the user
    to display the location on a map along with a `popup` that contains information
    about the `arena` from spatial queries and table relationships.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC method of web development allows for separation between the necessary
    components of a web application. These components include database models (the
    SQLAlchemy models described earlier), web forms for accepting application input,
    and a controller object that routes requests. The separation of components is
    reflected in the separate scripts. Making each component independent makes it
    easier to adjust without affecting other components of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The database model will be contained in a script called `models.py`, along with
    the required module imports. The web forms (Python classes that create web page
    components such as drop-down lists and entry fields) will be contained in a script
    called `forms.py`. All of the views, which include the URL endpoints and the processing
    of the web requests to those URLs, will be contained within a script called `views.py`.
  prefs: []
  type: TYPE_NORMAL
- en: A controller is an object generated from the `Flask` class and assigned to the
    variable called `app`. Each URL endpoint of the web application is defined using
    `app.route` and has an associated Python function (the view) that contains the
    logic to process the web request and return an HTTP response. The controller is
    used to route web requests to the correct URL endpoint and can distinguish between `GET` and `POST HTTP`
    requests. It is created in the `views.py` script.
  prefs: []
  type: TYPE_NORMAL
- en: HTML templates are used to present the processed results of a web request. Using
    the Jinja2 templating system, the data contained within the web forms will be
    passed to HTML templates and sent back to the requesting web browser as a complete
    web page. The template for this application contains links to JavaScript libraries,
    including `Leaflet`, which allows the web page to present a map within the web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Folder structure and the controller object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To contain the separate components of the application, a specific folder structure
    is recommended. It will allow for the components to reference each other as needed,
    while still maintaining independence. Adjustments made to one portion of a component
    shouldn't require the overhaul of a separated component (at least as much as possible).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Arena application is contained within a folder called `arenaapp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c34b72a-3640-46e3-a156-2c8f1d69668b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the `arenaapp` folder is a script called `app.py` and a folder called
    `application`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c947cb29-fc9f-4f4d-afaf-5bc9298ebf38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `app.py` script imports the `app` controller object from the `application`
    and calls the `app.run` method to start the web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Making the folder `application` importable and allowing `app` access to code
    inside the component scripts is made possible by adding a Python `__init__.py` script.
    This special script indicates to the Python executable that the folder is a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f34e301a-ca18-4df3-b8ea-b28e672ab8b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside `__init__.py`, the `app` object is defined and configured. The `app`
    object contains a configuration dictionary that allows the web application to
    connect to the backend (`''SQLALCHEMY_DATABASE_URI''`) and to perform session
    management and encryption. While we have included the configuration settings within
    this script, note that larger applications will separate out the configuration
    settings into a separate `config.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To make it easier to debug the application, the `DEBUG` configuration has been
    set to `True`. Set it to `False` in production. Replace `'SECRET KEY'` with your
    own secret key.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about configuring a Flask web application here: [http://flask.pocoo.org/docs/latest/config/](http://flask.pocoo.org/docs/latest/config/).
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the Arena application, a script called `models.py` contains the models that
    will be used for the application. As described earlier, these models are Python
    classes that contain database column definitions and can have internal functions
    for processing data. Our simplified models contain only data column definitions
    using SQLAlchemy and GeoAlchemy2 classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the database, the `app` object is imported. This makes the application
    configuration variables, including `app.config[''SQLALCHEMY_DATABASE_URI'']` which
    stores the database connection string, available to the SQLAlchemy `create_engine`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of brevity, I've skipped detailing the model class definitions
    here as they were explained previously. Look for them inside the `arenaapp`/`application`
    folder's `models.py` script.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web forms are used in web applications to accept data from a user and send it
    to the server for validation and processing. To generate the required forms (for
    example drop-downs, entry fields, and even password fields that hide their contents
    from the user), the Flask-WTF module and the WTForms module are used. These modules
    contain classes that make it possible to create the form components and to ensure
    that the data entered into them is valid for that field.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our simple application, only one form is created. The `ArenaForm` form
    inherits from the `FlaskFor` class and contains a `description` attribute and
    field called `selections`. This field is a `SelectField`, which will create a
    drop-down list on the web page. It requires a description string and uses the
    keyword `choices` to generate the list of the choices available in the drop-down
    list. As the members of the drop-down list will be generated dynamically within
    the view (explained as follows), an empty list is passed to the `choices` keyword
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Other field classes, such as `TextField`, `BooleanField`, `StringField`, `FloatField`,
    `PasswordField`, and many others, are available from WTForms for implementation
    of complex web applications. Also, because they are Python objects, forms can
    be updated to include other data attributes on the fly, as we will see as we proceed
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask views are Python functions that, when paired with the `app` controller
    object and its `app.route` URL definitions, allows us to write Python code to
    accept a web request, process it, and return a response. They are the heart of
    the web application, making it possible to connect web pages and their forms to
    the database and its tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create views, we will import all of the application components along with
    a number of Flask functions. The forms and models are imported from their respective
    scripts, as is the `app` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For the Arena application, we have two views defined that create two application
    URL endpoints. The first view, `home`, is in place only to redirect requests to
    the IP address root. Using the Flask functions `redirect` and `url_for`, any web
    requests sent to the `root` address will be redirected to the `arenas` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The second view, `arenas`, is more complex. It accepts both `GET` and `POST`
    request methods. Depending on the `request` method, the data processed and returned
    will be different, though they both rely on the template `index.html` which is
    stored in the `application`/`templates` folder (where all Flask HTML templates
    are stored). Here is the complete view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Dissecting the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The views''s URL is `http://{localhost}/arenas`***.*** Using a special Python
    object called a **decorator** (such as `@app.route`*)* allows us to connect the
    URL that we want to use with the function that will accept and handle the request
    processing. The function and the URL do not need to have the same name, though
    it is common for them to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Underneath the decorator and the function declaration, the `ArenaForm` from
    `forms.py` is called and the function `request.form` is passed as a parameter.
    This adds functionality to the `ArenaForm` and allows it to access the request's
    own parameters as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `ArenaForm` object is passed to the variable `form`, it can be populated
    with data. This data will come from an SQLAlchemy session `query` on the `Arena`
    model. This query requests all rows of data from the `Arena` table and passes
    it to the variable `arenas` using `all` method (as opposed to the `filter_by`
    method which would limit the rows returned).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the ArenaForm''s `selections` field is currently blank, we''ll use
    a list comprehension to loop through the `arena` objects contained within the
    list called `arenas`, adding their `id` and `name` fields to tuples inside the
    list. This populates the drop-down list and makes it so each selection in the
    list has a value (the `id`) and a label (the `name`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After populating the selections choices, three new attributes are added to the
    form—`popup`, `latitude`, and `longitude`. Initially, these are just placeholders
    and are not derived from the `arena` data. However, once the web application is
    running and users are selecting `arenas` from the drop-down list, these placeholder
    values will be replaced with data derived from the `arenas` tables and from queries
    against the other tables.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the request method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next line is an `if` conditional that uses the `request.method` property
    to see if the HTTP request method is `POST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the initial request to the URL `arenas` is a `GET` request, the code
    initially evaluates the `if` conditional as `False`, skipping the indented code
    section to the bottom of the view to return the template `index.html` and the
    now populated `form`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This function returns uses the `render_template` function to return the template
    called `index.html` and passes the populated `ArenaForm` variable called `form` into
    the template, making it possible for the Jinja2 templating system to generate
    the completed web page and send it to the requesting web browser. All of the template's
    double-bracketed variables are filled in with the corresponding data from `form`
    (for example, the selections are added to the drop-down list).
  prefs: []
  type: TYPE_NORMAL
- en: POST requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a user selects an `arena` from the list and pushes the Find Data button,
    the HTML form issues a `POST` request to the view. With the `if` conditional resolving
    to `True`, the view handles the request by generating an `arena` location coordinate
    pair and a custom `popup`, instead of using a default coordinate pair and `popup`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The property `form.selections.data` is used to retrieve the `id` of the `arena`
    chosen from the list and is passed to a variable called `arena_id`. This `id`
    is then used to query the database through the SQLAlchemy ORM's `get` method.
    The `form.longitude` and `form.latitude` fields can be populated from data fields
    of the `arena` object returned by the query.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find the county and the congressional district, two PostGIS spatial analysis
    techniques are used—`ST_Contains` and `ST_Intersects`. The first query determines
    if the `arena` is contained within a `county`; if not, the result is null (or
    `None` in Python):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: While `ST_Contains` could be used for both queries, I wanted to demonstrate
    that the GeoAlchemy2 ORM allows for access to all PostGIS functions when using
    `Geometry` columns. These searches combine the SQLAlchemy `filter` method with
    the GeoAlchemy2 ORM to make it possible to return query results based on a spatial
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Relationship query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the `county` query was successful, the `district` query is performed, and
    then a relationship attribute (`state_ref`) is used to find the `state` within
    which the `county` is placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The two-way relationship established in the `County`, `District`, and `State`
    model definitions make this possible. This `state` object is a member of the `State`
    model class and can be used to retrieve the `name` of the `state`.
  prefs: []
  type: TYPE_NORMAL
- en: To create the custom `popup`, string template formatting is used to populate
    the `popup` with the specifics describing the `arena` requested. The result is
    assigned to the variable `form.popup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the populated `form` is then passed once again to the `index.html`
    template, but this time it contains data about the selected `arena`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of the application query results for The Oracle Arena:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54a1006e-af1e-4437-98ca-3af63d58a38c.png)'
  prefs: []
  type: TYPE_IMG
- en: The web map template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the `index.html` template, the `form` data is accessed inside double-bracketed
    variables. These variables can be located inside the JavaScript or within the
    HTML. In this example, the `form.latitude` and `form.longitude` variables are
    located inside the map JavaScript that defines the initial center point of the
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the `marker` at the location of the `arena` requested, with a custom
    `popup`, the location coordinates and the `popup` fields are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the `POST` requests possible, an HTML form with a `POST` method houses
    the `form.description` and `form.selection` (the drop-down list) attributes. The
    HTML form''s button generates the `POST` request when it is pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Running the web application locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the application locally, we can call the `app.py` script, located in
    the `arenaapp` folder, using the Python executable. Open up a command line and
    pass a script argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: To run this application on a web server is beyond the scope of the chapter,
    but it involves configuring a web server with a WSGI handler to allow for web
    requests to be processed by the Python executable and `app.py`. For Apache web
    servers, the `mod_wsgi` module is popular. For Windows servers using **Internet
    Information Services** (**IIS**), the `wfastcgi` module is very useful and is
    available from the Microsoft Web Platform Installer.
  prefs: []
  type: TYPE_NORMAL
- en: Explore more about Apache and the `mod_wsgi` module here: [http://flask.pocoo.org/docs/latest/deploying/mod_wsgi/](http://flask.pocoo.org/docs/latest/deploying/mod_wsgi/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For IIS, these installation instructions are very useful: [http://netdot.co/2015/03/09/flask-on-iis/](http://netdot.co/2015/03/09/flask-on-iis/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use the Flask MVC web framework and some
    of the available component modules that add extra functionality. These modules
    include the SQLAlchemy ORM, the GeoAlchemy2 ORM for geospatial queries, WTForms
    for processing of web data, and the Jinja2 templating system for creating web
    page templates. We created database tables, added data tables and tables relationships,
    and created a web application that utilized geospatial and relationship queries
    to generate dynamic web pages.
  prefs: []
  type: TYPE_NORMAL
- en: A fun challenge, building on the code reviewed here, would be to explore adding
    editing capabilities to the Arena application, allowing the user to move the `arenas`
    into their correct location if the data is out of date. Explore the GeoAlchemy2
    ORM documentation for more advanced capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review a similar MVC web framework, Django, and
    its GeoDjango spatial component. With more batteries included philosophy, Django
    solves the same problems inherent to web applications in different ways, but with
    less freedom of module choice, when compared to Flask.
  prefs: []
  type: TYPE_NORMAL
