- en: Flask and GeoAlchemy2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask和GeoAlchemy2
- en: Python has always had strong internet capabilities. The standard library includes
    models for HTTP processing, STMP messages, and URL requests. Thousands of third-party
    modules have been written to extend or improve the built-in web functionality.
    Over time, a few modules coalesced into Python web frameworks—code libraries written
    to manage the creation and maintenance of complex and dynamic websites.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python一直拥有强大的互联网功能。标准库包括HTTP处理、STMP消息和URL请求的模型。已经编写了数千个第三方模块来扩展或改进内置的Web功能。随着时间的推移，一些模块聚集成了Python网络框架——编写来管理复杂和动态网站创建和维护的代码库。
- en: To better understand how to use a Python web framework and how to add geospatial
    capabilities, we'll implement the Flask **Model View Controller** (**MVC**) framework.
    A pure Python web framework, Flask can be combined with SQLAlchemy, GeoAlchemy2,
    and the Jinja2 HTML template system to create geospatially-enabled web pages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何使用Python网络框架以及如何添加地理空间功能，我们将实现Flask **模型-视图-控制器**（**MVC**）框架。一个纯Python网络框架，Flask可以与SQLAlchemy、GeoAlchemy2和Jinja2
    HTML模板系统结合使用，以创建具有地理空间功能的网页。
- en: 'In this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解：
- en: The Flask web framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask网络框架
- en: SQLAlchemy database management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy数据库管理
- en: GeoAlchemy2
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeoAlchemy2
- en: Connecting to PostGIS using object-relational mapping (ORM)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象关系映射（ORM）连接到PostGIS
- en: The Jinja2 web page template system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2网页模板系统
- en: Flask and its component modules
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask及其组件模块
- en: Flask, as opposed to Django and GeoDjango (covered in [Chapter 12](a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml),
    *GeoDjango*), does not include batteries. Instead, it allows a number of supporting
    modules to be installed as needed. This gives more freedom to you as the programmer,
    but it also makes it necessary to install the required components separately.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与Django和GeoDjango（在第12章中介绍，*GeoDjango*）不同，Flask不包含电池。相反，它允许根据需要安装多个支持模块。这给了程序员更多的自由，但也使得必须单独安装所需的组件。
- en: I've chosen some modules for this chapter that will allow us to create a Flask
    application with a geospatial component. The following sections will detail how
    to set up, install, and utilize these modules to generate a website, using a demonstration
    site with a PostGIS database backend (as covered in [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml),
    *Geoprocessing with Geodatabases*) and the ability to perform spatial queries
    through a web-based interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这一章选择了一些模块，这些模块将使我们能够创建一个具有地理空间组件的Flask应用程序。以下章节将详细介绍如何设置、安装和利用这些模块来生成网站，使用具有PostGIS数据库后端的演示网站（在第7章中介绍，*使用地理数据库进行地理处理*）以及通过基于Web的界面执行空间查询的能力。
- en: Setup
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: A number of important Python modules must be in place to ensure that the Flask
    application and its connection to the PostgreSQL and PostGIS database components,
    will run as required. These modules will be downloaded and installed using `pip`,
    which connects to the **Python Package Index** (**PyPI**), an online repository
    of registered modules located at [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 必须安装一些重要的Python模块，以确保Flask应用程序及其与PostgreSQL和PostGIS数据库组件的连接能够按预期运行。这些模块将通过`pip`下载和安装，`pip`连接到**Python包索引**（**PyPI**），一个位于[https://pypi.python.org/pypi](https://pypi.python.org/pypi)的在线注册模块仓库。
- en: 'These modules include:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块包括：
- en: Flask, a pure Python MVC web framework ([http://flask.pocoo.org/](http://flask.pocoo.org/)).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask，一个纯Python MVC网络框架（[http://flask.pocoo.org/](http://flask.pocoo.org/)）。
- en: Flask-SQLAlchemy, a database ORM module that can connect to a multitude of database
    backends ([http://flask-sqlalchemy.pocoo.org/2.3/](http://flask-sqlalchemy.pocoo.org/2.3/)).
    This module installs SQLAlchemy.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy，一个可以连接到多种数据库后端的数据库ORM模块（[http://flask-sqlalchemy.pocoo.org/2.3/](http://flask-sqlalchemy.pocoo.org/2.3/)）。此模块安装SQLAlchemy。
- en: GeoAlchemy2, a Python module that builds on the SQLAlchemy module and the Postgres/PostGIS
    backend (covered in [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml), *Geoprocessing
    with Geodatabases*), is used to allow for geospatial data columns and ORM spatial
    queries ([https://geoalchemy-2.readthedocs.io/en/latest/](https://geoalchemy-2.readthedocs.io/en/latest/)).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeoAlchemy2，一个基于SQLAlchemy模块和Postgres/PostGIS后端（在第7章中介绍，*使用地理数据库进行地理处理*）的Python模块，用于允许地理空间数据列和ORM空间查询（[https://geoalchemy-2.readthedocs.io/en/latest/](https://geoalchemy-2.readthedocs.io/en/latest/)）。
- en: Flask-WTForms, a web form module built on the WTForms ([https://wtforms.readthedocs.io/en/latest/](https://wtforms.readthedocs.io/en/latest/))
    that allows for Flask to carry the logic of each web page and to process the inputs
    ([https://flask-wtf.readthedocs.io/en/stable/](https://flask-wtf.readthedocs.io/en/stable/)).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-WTForms，一个基于 WTForms ([https://wtforms.readthedocs.io/en/latest/](https://wtforms.readthedocs.io/en/latest/))
    的 Web 表单模块，允许 Flask 承载每个网页的逻辑并处理输入 ([https://flask-wtf.readthedocs.io/en/stable/](https://flask-wtf.readthedocs.io/en/stable/))。
- en: SQLAlchemy-Utils, used to manage database creation and deletion ([https://github.com/kvesteri/sqlalchemy-utils/](https://github.com/kvesteri/sqlalchemy-utils/)).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy-Utils，用于管理数据库的创建和删除 ([https://github.com/kvesteri/sqlalchemy-utils/](https://github.com/kvesteri/sqlalchemy-utils/))。
- en: '`psycopg2`, used to create connections to the PostgreSQL database and is used
    by the SQLAlchemy module ([http://initd.org/psycopg/](http://initd.org/psycopg/)).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psycopg2`，用于创建与 PostgreSQL 数据库的连接，并由 SQLAlchemy 模块使用 ([http://initd.org/psycopg/](http://initd.org/psycopg/))。'
- en: '`pyshapefile` (or `pyshp`), used to read the shapefiles used in this example
    and add it to the database tables ([https://pypi.python.org/pypi/pyshp](https://pypi.python.org/pypi/pyshp)).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyshapefile`（或 `pyshp`），用于读取本例中使用的 shapefiles 并将其添加到数据库表中 ([https://pypi.python.org/pypi/pyshp](https://pypi.python.org/pypi/pyshp))。'
- en: Finally, `pygeoif` ([https://pypi.python.org/pypi/pygeoif](https://pypi.python.org/pypi/pygeoif))
    is used to allow for the conversion of data from a shapefile binary encoding to
    a **well-known text** (**WKT**) encoding, for insertion of geometry data into
    the database.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`pygeoif` ([https://pypi.python.org/pypi/pygeoif](https://pypi.python.org/pypi/pygeoif))
    用于允许将 shapefile 二进制编码的数据转换为 **已知文本**（**WKT**）编码，以便将几何数据插入到数据库中。
- en: Other important supporting modules are automatically installed along with Flask
    and the preceding modules, including the Jinja2 templating system ([http://jinja.pocoo.org/](http://jinja.pocoo.org/))
    and the Werkzeug **Web Server Gateway Interface** (**WSGI**) module ([http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其他重要的支持模块会自动与 Flask 及前面的模块一起安装，包括 Jinja2 模板系统 ([http://jinja.pocoo.org/](http://jinja.pocoo.org/))
    和 Werkzeug **Web 服务器网关接口**（**WSGI**）模块 ([http://werkzeug.pocoo.org/](http://werkzeug.pocoo.org/))。
- en: Installing modules using pip
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装模块
- en: 'If you have multiple versions of Python installed on your machine and you''re
    not using a virtual environment with the `virtualenv` module, ensure that the
    `pip` version being called with the command line is the Python 3 version using
    the `pip -V` option:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你机器上安装了多个版本的 Python，并且没有使用带有 `virtualenv` 模块的虚拟环境，确保使用命令行调用的是 Python 3 版本的
    `pip`，可以使用 `pip -V` 选项来检查：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once it is clear that the correct `pip` is being called from the command line,
    the modules can be installed. Let's walk through the required `pip` commands and
    some examples of the expected output that each command will generate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认命令行中调用的是正确的 `pip`，就可以安装模块。让我们逐一查看所需的 `pip` 命令和一些每个命令预期生成的输出示例。
- en: Installing Flask using pip
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装 Flask
- en: 'First, install the Flask module itself. Use the `pip` command `pip install
    flask`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装 Flask 模块本身。使用 `pip` 命令 `pip install flask`：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `pip` will find Flask and its required dependencies on PyPI and will then
    run the included `setup.py` instructions (or the equivalent) to install the modules:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 将在 PyPI 上找到 Flask 及其所需的依赖项，然后运行包含的 `setup.py` 指令（或等效指令）来安装模块：'
- en: '![](img/22176846-a3f1-4e2d-a648-f807ca651a8d.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22176846-a3f1-4e2d-a648-f807ca651a8d.png)'
- en: Installing Flask-SQLAlchemy via pip
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 pip 安装 Flask-SQLAlchemy
- en: 'Use the command `pip install flask-sqlalchemy` to install the `flask-sqlalchemy`
    wheel and its required dependencies:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令 `pip install flask-sqlalchemy` 安装 `flask-sqlalchemy` 轮子及其所需的依赖项：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The install command will find the `flask-sqlalchemy` wheel file (a pre-built
    file type used by `pip` to install modules) on PyPI and run the installation process:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装命令将在 PyPI 上找到 `flask-sqlalchemy` 轮子文件（`pip` 安装模块时使用的预构建文件类型），并运行安装过程：
- en: '![](img/dcee7274-f35b-44f2-952c-4305f5475864.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcee7274-f35b-44f2-952c-4305f5475864.png)'
- en: Installing GeoAlchemy2 using pip
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装 GeoAlchemy2
- en: 'Use the command `pip install GeoAlchemy2` to call the module from PyPI, download
    the wheel file, and install it into the `Lib`/`site-packages` folder of the Python
    installation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令 `pip install GeoAlchemy2` 从 PyPI 调用模块，下载轮子文件，并将其安装到 Python 安装的 `Lib`/`site-packages`
    文件夹中：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing Flask-WTForms and WTForms using pip
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装 Flask-WTForms 和 WTForms
- en: 'With the WTForms module and the Flask-WTF interface, we can create the web
    forms that will make the webpage interactive. Install it using the `pip install
    flask-wtf` command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WTForms 模块和 Flask-WTF 接口，我们可以创建使网页交互的 Web 表单。使用 `pip install flask-wtf` 命令安装它：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Installing psycopg2 using pip
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装 psycopg2
- en: 'The `pscycopg2` is a Python module used to connect to PostgreSQL databases.
    If it is not installed yet (see [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml),
    *Geoprocessing with Geodatabases*), install it using the `pip install psycopg2`
    command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`pscycopg2` 是一个用于连接 PostgreSQL 数据库的 Python 模块。如果尚未安装（见 [第 7 章](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml)，*使用地理数据库进行地理处理*），请使用
    `pip install psycopg2` 命令安装它：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Installing SQLAlchemy-Utils using pip
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装 SQLAlchemy-Utils
- en: 'These utilities allow for quick database creation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实用工具允许快速创建数据库：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Installing pyshapefile (or pyshp) using pip
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装 pyshapefile（或 pyshp）
- en: 'The `pyshapefile` module can read and write shapefiles:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyshapefile` 模块可以读取和写入形状文件：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing pygeoif using pip
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装 pygeoif
- en: 'The `pygeoif` module allows for geospatial data format conversion:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygeoif` 模块允许进行地理空间数据格式转换：'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Writing a Flask application
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Flask 应用程序
- en: To explore the basics of Flask and GeoAlchemy2, we'll build a Flask web application
    and test and deploy it locally using the included web server. This web application
    allows the user to find the county, state, and congressional district associated
    with different arena's located throughout the country. This application will involve
    downloading shapefiles from a **United States Geological Survey** (**USGS**) data
    catalog and will have views (Python functions that process web requests) performing
    geospatial queries using the GeoAlchemy2 ORM and table relationship searches using
    the SQLAlchemy ORM.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索 Flask 和 GeoAlchemy2 的基础知识，我们将构建一个 Flask 网络应用程序，并在本地使用包含的 Web 服务器进行测试和部署。此
    Web 应用程序允许用户查找位于全国各地的不同场馆所属的县、州和国会选区。此应用程序将涉及从美国地质调查局（**USGS**）数据目录下载形状文件，并将包含执行地理空间查询的视图（处理
    Web 请求的 Python 函数）使用 GeoAlchemy2 ORM 和使用 SQLAlchemy ORM 进行表关系搜索。
- en: This application requires the use of two scripts that create the database and
    database tables. These scripts are detailed as we proceed further and are in the
    `Chapter11` folder of the book's code package. The final product will be a web
    application that uses a `Leaflet` JavaScript map to display the results of ORM-based
    spatial queries and a relationship query.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序需要使用两个脚本创建数据库和数据库表。随着我们进一步进行，这些脚本将详细介绍，并位于书籍代码包的 `Chapter11` 文件夹中。最终产品将是一个使用基于
    ORM 的空间查询和关系查询的 `Leaflet` JavaScript 地图显示结果的 Web 应用程序。
- en: Downloading the data from a data source
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据源下载数据
- en: To start this project, let's download data from the USGS data catalog. This
    project will use four US-based shapefiles—an NBA arena shapefile, a states shapefile,
    a congressional districts shapefile, and a counties shapefile.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始此项目，让我们从美国地质调查局数据目录下载数据。此项目将使用四个基于美国的形状文件——NBA 场馆形状文件、州形状文件、国会选区形状文件和县形状文件。
- en: The USGS has a lot of USA shapefiles for download available here: [https://www.sciencebase.gov/catalog/item/503553b3e4b0d5ec45b0db20](https://www.sciencebase.gov/catalog/item/503553b3e4b0d5ec45b0db20).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 美国地质调查局（USGS）在此处提供了大量可供下载的 USA 形状文件：[https://www.sciencebase.gov/catalog/item/503553b3e4b0d5ec45b0db20](https://www.sciencebase.gov/catalog/item/503553b3e4b0d5ec45b0db20).
- en: County, district, state, and arena shapefiles
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 县、区、州和场馆形状文件
- en: The `US_County_Boundaries` data is a polygon shapefile available from the USGS
    data catalog at this address: [https://www.sciencebase.gov/catalog/item/4f4e4a2ee4b07f02db615738](https://www.sciencebase.gov/catalog/item/4f4e4a2ee4b07f02db615738).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`US_County_Boundaries` 数据是一个多边形形状文件，可以从美国地质调查局（USGS）数据目录的此地址获取：[https://www.sciencebase.gov/catalog/item/4f4e4a2ee4b07f02db615738](https://www.sciencebase.gov/catalog/item/4f4e4a2ee4b07f02db615738).'
- en: 'Click on the download zip link, as shown in the image. Unzip the file into
    a project folder (for example, `C:\GeospatialPy3\Chapter11`) so it can be accessed
    throughout the chapter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下载 zip 文件链接，如图所示。将文件解压到项目文件夹中（例如，`C:\GeospatialPy3\Chapter11`），以便在整个章节中访问：
- en: '![](img/4b1862b4-a369-41a9-80dd-7d08f08e80a3.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b1862b4-a369-41a9-80dd-7d08f08e80a3.png)'
- en: The `Arenas_NBA` shapefile is available here: [https://www.sciencebase.gov/catalog/item/4f4e4a0ae4b07f02db5fb54d](https://www.sciencebase.gov/catalog/item/4f4e4a0ae4b07f02db5fb54d).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arenas_NBA` 形状文件在此处可用：[https://www.sciencebase.gov/catalog/item/4f4e4a0ae4b07f02db5fb54d](https://www.sciencebase.gov/catalog/item/4f4e4a0ae4b07f02db5fb54d).'
- en: 'The `Congressional_Districts` shapefile is available here: [https://www.sciencebase.gov/catalog/item/4f4e4a06e4b07f02db5f8b58](https://www.sciencebase.gov/catalog/item/4f4e4a06e4b07f02db5f8b58).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Congressional_Districts` 形状文件可在以下位置获取：[https://www.sciencebase.gov/catalog/item/4f4e4a06e4b07f02db5f8b58](https://www.sciencebase.gov/catalog/item/4f4e4a06e4b07f02db5f8b58)。'
- en: 'The `US_States` shapefile is available here: [https://www.sciencebase.gov/catalog/item/4f4e4783e4b07f02db4837ce](https://www.sciencebase.gov/catalog/item/4f4e4783e4b07f02db4837ce).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`US_States` 形状文件可在以下位置获取：[https://www.sciencebase.gov/catalog/item/4f4e4783e4b07f02db4837ce](https://www.sciencebase.gov/catalog/item/4f4e4783e4b07f02db4837ce)。'
- en: These shapefiles are not current (for example, the Nets arena is still listed
    as being in New Jersey and not in Brooklyn), but it's the application techniques
    that we're exploring here (and how they deal with geometry data types) and not
    the data itself, so ignore the temporal quality of the data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形状文件不是最新的（例如，Nets 场地仍然列在新泽西州，而不是布鲁克林），但我们在这里探索的是应用程序技术（以及它们如何处理几何数据类型），而不是数据本身，因此忽略数据的时效性。
- en: Creating the database and data tables
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库和数据表
- en: 'To create our database and the tables that will hold the application data,
    we will use the SQLAlchemy and GeoAlchemy2 classes and methods. The following
    code is in the script called `Chapter11_0.py`. This code will allow us to connect
    to a PostgreSQL data server to create a database and data tables that will form
    the backend of the web application. Import these libraries:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的数据库以及将存储应用程序数据的表，我们将使用 SQLAlchemy 和 GeoAlchemy2 类和方法。以下代码位于名为 `Chapter11_0.py`
    的脚本中。此代码将使我们能够连接到 PostgreSQL 数据服务器以创建数据库和数据表，这些表将构成网络应用程序的后端。导入以下库：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Connecting the database server to both generate and query the data tables is
    achieved using the `create_engine` function and the connection string format,
    demonstrated as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `create_engine` 函数和连接字符串格式连接数据库服务器以生成和查询数据表，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Connection strings are used throughout all Python database modules. They usually
    include a specification of the **relational database management system** (**RDBMS**)
    type, the username, the password, the instance host (that is the IP address or
    `localhost` for a database server installed on the local machine), an optional
    port number, and a database name. For example, a connection string might look
    like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串在所有 Python 数据库模块中都会使用。它们通常包括对关系数据库管理系统（**RDBMS**）类型的指定、用户名、密码、实例主机（即数据库服务器安装的
    IP 地址或本地机器上的 `localhost`）、可选的端口号和数据库名称。例如，连接字符串可能看起来像这样：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, `postgresql` is the RDBMS type, `postgres` is the user, `bond007`
    is the password, `localhost` is the instance host, `5432` is the port (and the
    default port for PostgreSQL installations; if the port wasn't changed on installation,
    it can be left out of the connection string), and `chapter11` is the name of the
    database. The `echo=True` statement is used to generate logs of the database interactions
    to the standard output window. To turn these messages off, change the echo value
    to `False`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`postgresql` 是 RDBMS 类型，`postgres` 是用户名，`bond007` 是密码，`localhost` 是实例主机，`5432`
    是端口（这是 PostgreSQL 安装的默认端口；如果安装时没有更改端口，则可以将其从连接字符串中省略），`chapter11` 是数据库名称。`echo=True`
    语句用于将数据库交互的日志生成到标准输出窗口。要关闭这些消息，将 echo 值更改为 `False`。
- en: A more thorough explanation of this pattern can be found here: [http://docs.sqlalchemy.org/en/latest/core/engines.html](http://docs.sqlalchemy.org/en/latest/core/engines.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的解释可以在以下位置找到：[http://docs.sqlalchemy.org/en/latest/core/engines.html](http://docs.sqlalchemy.org/en/latest/core/engines.html)。
- en: 'For our database, we can use the following format. Replace `{user}` and `{pword}`
    (including the brackets) with your PostgreSQL server username and password:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数据库，我们可以使用以下格式。将 `{user}` 和 `{pword}`（包括括号）替换为您的 PostgreSQL 服务器用户名和密码：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the connection string is valid, the `create_engine` function will return
    an object to the `engine` variable, which will be used to perform database interactions
    throughout the script.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接字符串有效，`create_engine` 函数将返回一个对象到 `engine` 变量，该变量将用于在整个脚本中执行数据库交互。
- en: 'The code in the comment (`#drop_database(engine.url)`) is commented out but
    can be uncommented if the database needs to be dropped and then recreated using
    the script. It calls the SQLAlchemy create_engine''s `url` property, which is
    a reference to the connection string:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注释中的代码（`#drop_database(engine.url)`）被注释掉了，但如果需要使用脚本删除并重新创建数据库，可以取消注释。它调用 SQLAlchemy
    create_engine 的 `url` 属性，该属性是连接字符串的引用：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The database and the data tables it will contain is created within an `if not`
    conditional that relies on the `database_exists` function. If the conditional
    returns `True` (indicating that the database does not exist), the `engine` variable
    is passed to the `create_database` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库及其包含的数据表是在一个依赖于`database_exists`函数的`if not`条件语句中创建的。如果条件返回`True`（表示数据库不存在），则将`engine`变量传递给`create_database`函数：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding the PostGIS extension tables to the new database
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将PostGIS扩展表添加到新数据库中
- en: 'Just underneath the `create_database` function, we will need to connect to
    the database using the `engine.connect` function to pass an SQL statement directly
    to the database. This SQL statement, `("CREATE EXTENSION postgis*"*)` enables
    spatial columns and queries within the new database:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create_database`函数下方，我们需要使用`engine.connect`函数连接到数据库，以便直接向数据库传递SQL语句。这个SQL语句`("CREATE
    EXTENSION postgis*"*)`在新数据库中启用空间列和查询：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A `try`/`except` block is used here in case the database has already been spatially
    enabled. Check the output from the `print` statements to ensure that no other
    exception occurs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`try`/`except`块是为了防止数据库已经被空间启用。检查`print`语句的输出以确保没有其他异常发生。
- en: Defining the database tables
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据库表
- en: Within the world of Python MVC web frameworks, the database tables are the **models**.
    Used by the website to store data, they are generated with and modeled by Python
    classes. These classes subclass or inherit pre-written functionality from a superclass
    that contains a majority of the database management code, leaving us to simply
    define the columns of the table using basic data types such as strings and integers,
    as well as advanced classes such as geometries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python MVC Web框架的世界中，数据库表是**模型**。网站使用这些模型来存储数据，它们由Python类生成和建模。这些类从包含大部分数据库管理代码的超类中继承或继承预写的功能，让我们只需使用基本数据类型（如字符串和整数）以及高级类（如几何形状）来定义表的列。
- en: These class-defined tables can be generated in multiple RDBMS without the need
    to revamp how the model code is written. While GeoAlchemy2 only works on top of
    PostgreSQL/PostGIS, SQLAlchemy models can be used to generate tables in a variety
    of databases, including SQL Server, Oracle, Postgres, MySQL and more.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些由类定义的表可以在多个关系数据库管理系统（RDBMS）中生成，而无需重新编写模型代码。虽然GeoAlchemy2仅适用于PostgreSQL/PostGIS之上，但SQLAlchemy模型可以用于在包括SQL
    Server、Oracle、Postgres、MySQL等多种数据库中生成表。
- en: The declarative base
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式基类
- en: 'For SQLAlchemy database classes, a base class called the `declarative_base`
    allows for inheritance of database methods and properties (this is where the superclass
    magic of SQLAlchemy exists, handling database SQL statements in multiple SQL versions,
    which simplifies the code required to write to any RDBMS):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLAlchemy数据库类，一个名为`declarative_base`的基类允许继承数据库方法和属性（这就是SQLAlchemy的超类魔法所在，处理多个SQL版本的数据库SQL语句，从而简化了写入任何关系数据库管理系统所需的代码）：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Database table model classes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库表模型类
- en: Once the base has been called or instantiated, it can be passed to the model
    classes. These classes, like all Python classes, could include functions, properties,
    and methods which are useful for processing data internally to the class. In this
    chapter, the models do not include any internal functions, but instead only define
    columns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用或实例化了基类，就可以将其传递给模型类。这些类，就像所有Python类一样，可以包括函数、属性和方法，这些对于在类内部处理数据非常有用。在本章中，模型类不包含任何内部函数，而是只定义列。
- en: 'Explore SQLAlchemy models and their internal functions here: [http://docs.sqlalchemy.org/en/latest/orm/tutorial.html](http://docs.sqlalchemy.org/en/latest/orm/tutorial.html).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里探索SQLAlchemy模型及其内部函数：[http://docs.sqlalchemy.org/en/latest/orm/tutorial.html](http://docs.sqlalchemy.org/en/latest/orm/tutorial.html)。
- en: Table properties
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表属性
- en: The name of the data table generated in the RDBMS database will correspond to
    the `__tablename__` property of a model class. The primary key for each table
    is used for relationships and queries and must be defined using the keyword `primary_key`.
    The `Column` class and the `String`, `Float` and `Integer` type classes are called
    from SQLAlchemy and are used to define table columns to be generated within the
    underlying RDBMS (thus allowing the programmer to avoid crafting `CREATE TABLE`
    statements for each variety of SQL used by the major RDBMS).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RDBMS 数据库中生成的数据表名称将对应于模型类的 `__tablename__` 属性。每个表的主键用于关系和查询，必须使用 `primary_key`
    关键字定义。`Column` 类和 `String`、`Float` 以及 `Integer` 类型类是从 SQLAlchemy 调用的，用于定义要在底层
    RDBMS 中生成的表列（从而允许程序员避免为每个主要 RDBMS 使用的各种 SQL 编写 `CREATE TABLE` 语句）。
- en: 'For example, the `Arena` class will be used to manage a table that has four
    columns—a `String` `name` field, two `Float` fields (`longitude` and `latitude`),
    and a `POINT` geometry type with an SRID or EPSG spatial reference system ID of
    `4326`, corresponding to the WGS 1984 coordinate system ([http://spatialreference.org/ref/epsg/wgs-84/](http://spatialreference.org/ref/epsg/wgs-84/)):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Arena` 类将用于管理一个具有四列的表——一个 `String` `name` 字段，两个 `Float` 字段（`longitude` 和
    `latitude`），以及一个具有 SRID 或 EPSG 空间参考系统 ID 为 `4326` 的 `POINT` 几何类型，对应于 WGS 1984
    坐标系统 ([http://spatialreference.org/ref/epsg/wgs-84/](http://spatialreference.org/ref/epsg/wgs-84/))）：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Like the `Arena` class, the following classes use a `String` `name` column.
    For the geometry type, they also use SRID `4326`, but they use the `MULTIPOLYGON`
    geometry type to store the complex multipolygon geometries used to model these
    geographies. For tables with relationships, as in the case of the `County`, `District`,
    and `State` classes, there are also special classes used to manage table relationships
    and queries between tables.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Arena` 类类似，以下类使用一个 `String` `name` 列。对于几何类型，它们也使用 SRID `4326`，但它们使用 `MULTIPOLYGON`
    几何类型来存储用于建模这些地理的复杂多边形几何。对于具有关系的表，例如 `County`、`District` 和 `State` 类，还有用于管理表关系和表之间查询的特殊类。
- en: 'These special classes include the `ForeignKey` class and the `relationship`
    function. The `ForeignKey` class is passed an `id` parameter and passed to a `Column`
    class, associating the child row''s with the parent. The `relationship` function
    allows two-way queries. The `backref` keyword generates a function that instantiates
    an instance of the joined table''s model:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊类包括 `ForeignKey` 类和 `relationship` 函数。`ForeignKey` 类接受一个 `id` 参数，并将其传递给
    `Column` 类，以关联子行与父行。`relationship` 函数允许双向查询。`backref` 关键字生成一个函数，该函数实例化连接表的模型实例：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `County` class and the `District` class will have a `relationship` with
    the `State` class, allowing session queries that call the `State` class. This
    `relationship` makes it easy to find which US state a county or congressional
    district is located in. The `state_id` column builds the `relationship`, and the `state_ref` field
    references the parent `State` class. For the `State` class, the counties and districts
    have their own `backref` references, allowing the parent `State` class to access
    the associated counties/districts:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`County` 类和 `District` 类将与 `State` 类建立 `relationship` 关系，允许会话查询调用 `State` 类。这种
    `relationship` 使得查找县或国会选区所在的美国州变得容易。`state_id` 列建立 `relationship`，而 `state_ref`
    字段引用父 `State` 类。对于 `State` 类，县和区有自己的 `backref` 引用，允许父 `State` 类访问相关的县/区：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating the tables
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表
- en: To actually generate the tables, there are two methods that can be used. Table
    model classes have an internal `__table__` method that has a `create` function,
    which can be used to create each table separately. There is also a `drop` function
    that can be called to drop a table.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际生成表时，可以使用两种方法。表模型类有一个内部的 `__table__` 方法，该方法有一个 `create` 函数，可以用来单独创建每个表。还有一个
    `drop` 函数可以用来删除表。
- en: 'In the script, we use `try`*/*`except` blocks to generate the tables. If an
    exception is incurred (that is, if the table already exists), the table is dropped
    and then created. Here is the `State` table creation statement as an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们使用 `try`*/*`except` 块来生成表。如果发生异常（即，如果表已存在），则删除表并重新创建。以下是一个示例的 `State`
    表创建语句：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, all database tables can be generated from the defined classes
    using the `Base` method `metadata` and its `create_all` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用定义的类通过 `Base` 方法的 `metadata` 和其 `create_all` 函数生成所有数据库表：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inserting data into the new data tables
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据插入新的数据表中
- en: Once the database has been created and the database tables have been defined
    and created within the database, the data can be added. A second script, `Chapter11_1.py`,
    will be used to find and read the data contained within the downloaded shapefiles
    and `for` loops will be used to read through the data and write it to the respective
    database table. An SQLAlchemy session manager will be used to query and commit
    data to the tables.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了数据库并在数据库中定义和创建了数据库表，就可以添加数据。第二个脚本`Chapter11_1.py`将用于查找和读取下载的shapefile中的数据，并使用`for`循环读取数据并将其写入相应的数据库表。将使用SQLAlchemy会话管理器来查询和提交数据到表中。
- en: Importing the required modules
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入所需的模块
- en: For the data to be processed and imported, a few new modules will be used. The
    `pyshapefile` module (or `pyshp`, imported as shapefile) is used to connect to
    the shapefiles and to read both the geometries and attribute data that they contain.
    The `pygeoif` module is a pure Python module that implements a protocol known
    as the `geo_interface`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要处理和导入的数据，将使用几个新的模块。`pyshapefile`模块（或`pyshp`，作为shapefile导入）用于连接到shapefile并读取它们包含的几何和属性数据。`pygeoif`模块是一个纯Python模块，实现了名为`geo_interface`的协议。
- en: 'This protocol allows Python object-level introspection of geospatial data,
    for example, it converts geospatial data formats into Python objects. It will
    be used to convert between shapefile geometries stored in binary into WKT geometries
    that can be inserted into the database using the GeoAlchemy2 ORM:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议允许对地理空间数据进行Python对象级别的自省，例如，它将地理空间数据格式转换为Python对象。它将被用来将存储在二进制中的shapefile几何形状转换为可以插入数据库的WKT几何形状，使用GeoAlchemy2
    ORM：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: More discussion of the `geo_interface` protocol is available here: [https://gist.github.com/sgillies/2217756](https://gist.github.com/sgillies/2217756).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`geo_interface`协议的更多讨论，请参阅以下链接：[https://gist.github.com/sgillies/2217756](https://gist.github.com/sgillies/2217756)。
- en: 'To connect to the database and the tables, import the SQLAlchemy ORM and other
    SQLAlchemy functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到数据库和表，导入SQLAlchemy ORM和其他SQLAlchemy函数：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To add data to the geometry columns of the database tables, the GeoAlchemy2
    `Geometry` data type will be used:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据添加到数据库表的几何列中，将使用GeoAlchemy2的`Geometry`数据类型：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To enable the script to find the downloaded shapefiles, use the `Tkinter` module
    and its `filedialog` method, as it is built into Python and is OS-agnostic:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要使脚本能够找到下载的shapefile，使用`Tkinter`模块及其`filedialog`方法，因为它内置在Python中，且与操作系统无关：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Connections to the database will again be created using the `create_engine`
    function from SQLAlchemy. This section also generates a `session` using the session
    manager, binding it to the `engine` variable that connects to the database:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将再次使用SQLAlchemy的`create_engine`函数创建数据库连接。本节还使用会话管理器生成一个`session`，并将其绑定到连接数据库的`engine`变量：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `session` will allow for queries and commits (that is, writing to the database) to
    them being managed. We will need to query against database tables inside the `for`
    loop, to create the database relationships between the counties, districts, and
    states.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`session`将允许对这些表进行查询和提交（即写入数据库）进行管理。我们将在`for`循环内部查询数据库表，以创建县、区和州之间的数据库关系。'
- en: The database table models are again defined within the script, subclassing from
    the `declarative_base` class. These class definitions will match those within
    the last script.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表模型再次在脚本中定义，从`declarative_base`类派生。这些类定义将与上一个脚本中的定义相匹配。
- en: Locating and reading the shapefiles
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位和读取shapefile
- en: 'To create file dialogs that allow the user to search for and locate shapefiles,
    Tkinter''s `Tk` class is instantiated and assigned to the variable `root`. The
    `Tk` class creates a small console window that is not necessary, so it is withdrawn
    using the `root.withdraw` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建允许用户搜索和定位shapefile的文件对话框，Tkinter的`Tk`类被实例化并分配给变量`root`。`Tk`类创建了一个不必要的迷你控制台窗口，因此使用`root.withdraw`方法将其隐藏：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The file dialogs are generated using the `filedialog.askopenfilename` method.
    The method accepts a number of arguments, including the `title` of the file dialog
    window, the initial directory, and the file extensions that should be visible
    while using the file dialog. Here is the `Select Arena Shapefile` dialog code
    as an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对话框是通过`filedialog.askopenfilename`方法生成的。该方法接受多个参数，包括文件对话框窗口的`title`、初始目录以及在使用文件对话框时应可见的文件扩展名。以下是一个示例代码，用于`选择竞技场Shapefile`对话框：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Within the script, this is repeated for each of the downloaded shapefiles. After
    using the file dialogs, each of the shapefiles located will pass a string type
    file path to the `root` variable and the file path will be held in a property.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，这会为每个下载的shapefile重复进行。在文件对话框使用后，每个找到的shapefile都将传递一个字符串类型的文件路径给`root`变量，并且文件路径将保存在一个属性中。
- en: Accessing shapefile data
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问shapefile数据
- en: 'To access the data within the shapefiles, the `pyshp` `Reader` class is invoked
    by passing the respective file path property to the `Reader` class. The instantiated
    class will have both `records` and a `shapes` method, to allow access to the shapefile''s
    attribute data and geometry data respectively:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问shapefile中的数据，通过将相应的文件路径属性传递给`Reader`类来调用`pyshp`的`Reader`类。实例化的类将具有`records`和`shapes`方法，分别允许访问shapefile的属性数据和几何数据：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once the data has been read and assigned to iteratable variables, they can be
    iterated using `for` loops. Because the data accessed using the `pyshp` `Reader`
    `records` method corresponds to the data accessed using the `shapes` method, a
    loop counter generated using the `enumerate` function is used to match indexes
    between the current record and the corresponding geometry data in the list of
    geometries generated by the `shapes` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被读取并分配给可迭代变量，它们可以使用`for`循环进行迭代。因为使用`pyshp`的`Reader` `records`方法访问的数据与使用`shapes`方法访问的数据相对应，所以使用`enumerate`函数生成的循环计数器用于匹配当前记录和由`shapes`方法生成的几何数据列表中相应的几何数据索引。
- en: For the `Arena` shapefile geometry, the `Reader` `shapes` method returns the
    data as a list with coordinate pairs. As the `Arena` class geometry column is
    a `POINT` data type, the data can be written to the database table using a `POINT(X
    Y)` WKT template. The SRID (`4326`) is included at the beginning of the string,
    as per GeoAlchemy2 Extended WKT (EWKT) requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Arena`形状文件的几何形状，`Reader`的`shapes`方法返回一个包含坐标对的列表。由于`Arena`类的几何列是`POINT`数据类型，可以使用`POINT(X
    Y)` WKT模板将数据写入数据库表。根据GeoAlchemy2扩展WKT（EWKT）的要求，SRID（`4326`）包含在字符串的开头。
- en: Read more on the GeoAlcheym2 ORM here: [http://geoalchemy-2.readthedocs.io/en/0.4/orm_tutorial.html](http://geoalchemy-2.readthedocs.io/en/0.4/orm_tutorial.html).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于GeoAlcheym2 ORM的信息：[http://geoalchemy-2.readthedocs.io/en/0.4/orm_tutorial.html](http://geoalchemy-2.readthedocs.io/en/0.4/orm_tutorial.html).
- en: With each loop, a new `Arena` class is instantiated and assigned to the variable
    `arena`. The `name` field is extracted from the `Reader` `record` data item located
    at index `6` and assigned to the `arena` variable, while the geometry data is
    extracted from the `arena_shapes` data item at `count` (that is, the current loop
    number) and assigned to the `Arena` columns called `arena.longitude` and `arena.latitude`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环中，都会实例化一个新的`Arena`类并将其分配给变量`arena`。`name`字段从位于索引`6`的`Reader` `record`数据项中提取出来，并分配给`arena`变量，同时几何数据从`arena_shapes`数据项的`count`（即当前循环号）中提取出来，并分配给`Arena`列的`arena.longitude`和`arena.latitude`。
- en: 'These coordinates are then passed to the string `format` method to format the
    EWKT template and assigned to the `arena.geom` property. Once the data for the
    `arena` row has been assigned, it''s added to the session using `session.add`.
    Finally, the data is written to the database using the session''s `commit` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标随后传递给字符串`format`方法以格式化EWKT模板，并分配给`arena.geom`属性。一旦为`arena`行分配了数据，它就使用`session.add`添加到会话中。最后，使用会话的`commit`方法将数据写入数据库：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the `State` class (and the `County` and `District` classes), the name, **Federal
    Information Processing Standards** (**FIPS**) code, and postal code abbreviation
    are extracted from the attribute data using indexing. The `pygeoif` is used to
    convert the geometry first into a `pygeoif` `MultiPolygon` format and then into
    WKT, which is passed to a string template and written to the `geom` field as EWKT:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`State`类（以及`County`和`District`类），使用索引从属性数据中提取名称、**联邦信息处理标准**（**FIPS**）代码和邮政编码缩写。`pygeoif`用于首先将几何数据转换为`pygeoif`
    `MultiPolygon`格式，然后转换为WKT，并将其传递给字符串模板，写入`geom`字段作为EWKT：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Because of the large size of the geometry data for states, they are committed
    to the database every `10` loops. The final `commit` catches any remainder.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于州几何数据量较大，它们每`10`次循环提交到数据库。最后的`commit`捕获任何剩余的数据。
- en: Using queries
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用查询
- en: 'For the `District` and `County` data tables, a final wrinkle is added, querying
    against the newly added `state` data to find the associated state by FIPS code.
    By querying the `State` class using `session.query` and filtering the state''s
    data using the `filter_by` method (passing the FIPS code from the district records
    as the `filter` argument), and then specifying that the `first` result should
    be used, the correct `state` can be called. The variable state''s `id` field is
    used to populate the district''s `state_id` column to create the `relationship`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“地区”和“县”数据表，增加了一个最后的细节，即通过FIPS代码查询新添加的“州”数据以找到相关的州。通过使用`session.query`查询“州”类，并使用`filter_by`方法（将地区记录中的FIPS代码作为“过滤”参数传递）过滤州的数据，然后指定使用“第一个”结果，可以调用正确的“州”。使用变量的`id`字段来填充地区的`state_id`列以创建“关系”：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `County` table is similarly looped and also includes a `State` query. Check
    the script to see the completed code. Once all of the data has been written to
    the data tables, `close` the session and `dispose` of the connection engine:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “县”表同样被循环遍历，并包括一个“州”查询。查看脚本以查看完整的代码。一旦所有数据都已写入数据表，就“关闭”会话并“处理”连接引擎：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Components of the Flask application
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask应用程序的组件
- en: Now that the backend database and tables have been created and loaded with data
    and the relationships between the tables have been modeled and generated, it's
    time to write the scripts that will create the Flask application. These scripts
    will contain views, models, and forms that process web requests, query the database,
    and return an HTTP response.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在后台数据库和表已经创建并加载数据，表之间的关系也已经建模和生成，是时候编写创建Flask应用程序的脚本了。这些脚本将包含处理Web请求、查询数据库并返回HTTP响应的视图、模型和表单。
- en: The web application is called the Arena application, as it lists all of the
    NBA `arenas` stored in the `arena` table in a drop-down list, and allows the user
    to display the location on a map along with a `popup` that contains information
    about the `arena` from spatial queries and table relationships.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该网络应用程序被称为“竞技场应用程序”，因为它在下拉列表中列出存储在“竞技场”表中的所有NBA“竞技场”，并允许用户在地图上显示位置，同时显示包含关于“竞技场”信息的“弹出窗口”，这些信息来自空间查询和表关系。
- en: The MVC method of web development allows for separation between the necessary
    components of a web application. These components include database models (the
    SQLAlchemy models described earlier), web forms for accepting application input,
    and a controller object that routes requests. The separation of components is
    reflected in the separate scripts. Making each component independent makes it
    easier to adjust without affecting other components of the application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发的MVC方法允许将网络应用程序的必要组件分开。这些组件包括数据库模型（前面描述的SQLAlchemy模型）、接受应用程序输入的网络表单以及一个路由请求的控制对象。组件的分离反映在单独的脚本中。使每个组件独立，可以更容易地调整而不会影响应用程序的其他组件。
- en: The database model will be contained in a script called `models.py`, along with
    the required module imports. The web forms (Python classes that create web page
    components such as drop-down lists and entry fields) will be contained in a script
    called `forms.py`. All of the views, which include the URL endpoints and the processing
    of the web requests to those URLs, will be contained within a script called `views.py`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模型将包含在一个名为“models.py”的脚本中，以及所需的模块导入。网络表单（创建网页组件如下拉列表和输入字段的Python类）将包含在一个名为“forms.py”的脚本中。所有视图，包括URL端点和处理这些URL的Web请求，都将包含在一个名为“views.py”的脚本中。
- en: A controller is an object generated from the `Flask` class and assigned to the
    variable called `app`. Each URL endpoint of the web application is defined using
    `app.route` and has an associated Python function (the view) that contains the
    logic to process the web request and return an HTTP response. The controller is
    used to route web requests to the correct URL endpoint and can distinguish between `GET` and `POST HTTP`
    requests. It is created in the `views.py` script.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是从`Flask`类生成的对象，并分配给名为`app`的变量。每个Web应用程序的URL端点都使用`app.route`定义，并有一个相关的Python函数（视图），其中包含处理Web请求并返回HTTP响应的逻辑。控制器用于将Web请求路由到正确的URL端点，并且可以区分`GET`和`POST
    HTTP`请求。它在`views.py`脚本中创建。
- en: HTML templates are used to present the processed results of a web request. Using
    the Jinja2 templating system, the data contained within the web forms will be
    passed to HTML templates and sent back to the requesting web browser as a complete
    web page. The template for this application contains links to JavaScript libraries,
    including `Leaflet`, which allows the web page to present a map within the web
    page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML模板来展示Web请求的处理结果。通过使用Jinja2模板系统，网页表单中的数据将被传递到HTML模板中，并以完整的网页形式发送回请求的Web浏览器。该应用的模板包含指向JavaScript库的链接，包括`Leaflet`，这使得网页能够在网页内展示地图。
- en: Folder structure and the controller object
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹结构和控制器对象
- en: To contain the separate components of the application, a specific folder structure
    is recommended. It will allow for the components to reference each other as needed,
    while still maintaining independence. Adjustments made to one portion of a component
    shouldn't require the overhaul of a separated component (at least as much as possible).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了包含应用程序的独立组件，建议使用特定的文件夹结构。这将允许组件在需要时相互引用，同时仍然保持独立性。对组件某一部分的调整不应需要分离组件的重构（至少尽可能少）。
- en: 'The Arena application is contained within a folder called `arenaapp`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Arena应用程序包含在一个名为`arenaapp`的文件夹中：
- en: '![](img/5c34b72a-3640-46e3-a156-2c8f1d69668b.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c34b72a-3640-46e3-a156-2c8f1d69668b.png)'
- en: 'Inside the `arenaapp` folder is a script called `app.py` and a folder called
    `application`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`arenaapp`文件夹中有一个名为`app.py`的脚本和一个名为`application`的文件夹：
- en: '![](img/c947cb29-fc9f-4f4d-afaf-5bc9298ebf38.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c947cb29-fc9f-4f4d-afaf-5bc9298ebf38.png)'
- en: 'The `app.py` script imports the `app` controller object from the `application`
    and calls the `app.run` method to start the web application:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py`脚本从`application`导入`app`控制器对象，并调用`app.run`方法来启动Web应用程序：'
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Making the folder `application` importable and allowing `app` access to code
    inside the component scripts is made possible by adding a Python `__init__.py` script.
    This special script indicates to the Python executable that the folder is a module:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加Python的`__init__.py`脚本，使得`application`文件夹可导入，并允许`app`访问组件脚本中的代码成为可能。这个特殊的脚本会告诉Python可执行文件该文件夹是一个模块：
- en: '![](img/f34e301a-ca18-4df3-b8ea-b28e672ab8b1.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f34e301a-ca18-4df3-b8ea-b28e672ab8b1.png)'
- en: 'Inside `__init__.py`, the `app` object is defined and configured. The `app`
    object contains a configuration dictionary that allows the web application to
    connect to the backend (`''SQLALCHEMY_DATABASE_URI''`) and to perform session
    management and encryption. While we have included the configuration settings within
    this script, note that larger applications will separate out the configuration
    settings into a separate `config.py` script:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__.py`文件中，定义并配置了`app`对象。`app`对象包含一个配置字典，允许Web应用程序连接到后端（`'SQLALCHEMY_DATABASE_URI'`）并执行会话管理和加密。虽然我们在脚本中包含了配置设置，但请注意，较大的应用程序会将配置设置分离到单独的`config.py`脚本中：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To make it easier to debug the application, the `DEBUG` configuration has been
    set to `True`. Set it to `False` in production. Replace `'SECRET KEY'` with your
    own secret key.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于调试应用程序，已将`DEBUG`配置设置为`True`。在生产环境中将其设置为`False`。将`'SECRET KEY'`替换为您的自己的密钥。
- en: Read more about configuring a Flask web application here: [http://flask.pocoo.org/docs/latest/config/](http://flask.pocoo.org/docs/latest/config/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于配置Flask Web应用程序的信息：[http://flask.pocoo.org/docs/latest/config/](http://flask.pocoo.org/docs/latest/config/)。
- en: Models
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: For the Arena application, a script called `models.py` contains the models that
    will be used for the application. As described earlier, these models are Python
    classes that contain database column definitions and can have internal functions
    for processing data. Our simplified models contain only data column definitions
    using SQLAlchemy and GeoAlchemy2 classes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Arena应用程序，一个名为`models.py`的脚本包含了将用于应用程序的模型。如前所述，这些模型是包含数据库列定义的Python类，并且可以包含内部函数以处理数据。我们的简化模型仅使用SQLAlchemy和GeoAlchemy2类定义数据列。
- en: 'To connect to the database, the `app` object is imported. This makes the application
    configuration variables, including `app.config[''SQLALCHEMY_DATABASE_URI'']` which
    stores the database connection string, available to the SQLAlchemy `create_engine`
    function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到数据库，导入`app`对象。这使得应用程序配置变量，包括`app.config['SQLALCHEMY_DATABASE_URI']`（存储数据库连接字符串），对SQLAlchemy的`create_engine`函数可用：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For the sake of brevity, I've skipped detailing the model class definitions
    here as they were explained previously. Look for them inside the `arenaapp`/`application`
    folder's `models.py` script.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我在这里省略了模型类定义的详细说明，因为它们之前已经解释过了。请查找它们在 `arenaapp`/`application` 文件夹的 `models.py`
    脚本中。
- en: Forms
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: Web forms are used in web applications to accept data from a user and send it
    to the server for validation and processing. To generate the required forms (for
    example drop-downs, entry fields, and even password fields that hide their contents
    from the user), the Flask-WTF module and the WTForms module are used. These modules
    contain classes that make it possible to create the form components and to ensure
    that the data entered into them is valid for that field.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 网络表单用于在 Web 应用中接受用户数据并将其发送到服务器进行验证和处理。为了生成所需的表单（例如下拉列表、输入字段，甚至隐藏其内容的密码字段），我们使用了
    Flask-WTF 模块和 WTForms 模块。这些模块包含创建表单组件并确保输入到其中的数据对该字段有效的类。
- en: 'For our simple application, only one form is created. The `ArenaForm` form
    inherits from the `FlaskFor` class and contains a `description` attribute and
    field called `selections`. This field is a `SelectField`, which will create a
    drop-down list on the web page. It requires a description string and uses the
    keyword `choices` to generate the list of the choices available in the drop-down
    list. As the members of the drop-down list will be generated dynamically within
    the view (explained as follows), an empty list is passed to the `choices` keyword
    here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单应用，只创建了一个表单。`ArenaForm` 表单继承自 `FlaskFor` 类，并包含一个名为 `description` 的属性和字段
    `selections`。这个字段是一个 `SelectField`，它将在网页上创建一个下拉列表。它需要一个描述字符串，并使用关键字 `choices`
    生成下拉列表中可用的选项列表。由于下拉列表的成员将在视图中动态生成（如下所述），因此在这里传递给 `choices` 关键字的是一个空列表：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Other field classes, such as `TextField`, `BooleanField`, `StringField`, `FloatField`,
    `PasswordField`, and many others, are available from WTForms for implementation
    of complex web applications. Also, because they are Python objects, forms can
    be updated to include other data attributes on the fly, as we will see as we proceed
    further.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字段类，如 `TextField`、`BooleanField`、`StringField`、`FloatField`、`PasswordField`
    以及许多其他类，都可用于 WTForms 以实现复杂 Web 应用。此外，由于它们是 Python 对象，因此可以在运行时更新表单以包含其他数据属性，正如我们将在进一步操作中看到的那样。
- en: Views
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Flask views are Python functions that, when paired with the `app` controller
    object and its `app.route` URL definitions, allows us to write Python code to
    accept a web request, process it, and return a response. They are the heart of
    the web application, making it possible to connect web pages and their forms to
    the database and its tables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 视图是 Python 函数，当与 `app` 控制器对象及其 `app.route` URL 定义配对时，允许我们编写 Python 代码来接受网络请求、处理它并返回响应。它们是
    Web 应用的核心，使得将网页及其表单连接到数据库及其表成为可能。
- en: 'To create views, we will import all of the application components along with
    a number of Flask functions. The forms and models are imported from their respective
    scripts, as is the `app` object:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建视图，我们将导入所有应用程序组件以及许多 Flask 函数。表单和模型从各自的脚本中导入，就像 `app` 对象一样：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the Arena application, we have two views defined that create two application
    URL endpoints. The first view, `home`, is in place only to redirect requests to
    the IP address root. Using the Flask functions `redirect` and `url_for`, any web
    requests sent to the `root` address will be redirected to the `arenas` view:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Arena 应用，我们定义了两个视图，创建了两个应用程序 URL 端点。第一个视图 `home` 仅用于将请求重定向到 IP 地址根。使用 Flask
    函数 `redirect` 和 `url_for`，发送到 `root` 地址的任何网络请求都将重定向到 `arenas` 视图：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second view, `arenas`, is more complex. It accepts both `GET` and `POST`
    request methods. Depending on the `request` method, the data processed and returned
    will be different, though they both rely on the template `index.html` which is
    stored in the `application`/`templates` folder (where all Flask HTML templates
    are stored). Here is the complete view:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个视图 `arenas` 更复杂。它接受 `GET` 和 `POST` 请求方法。根据 `request` 方法，处理和返回的数据将不同，尽管它们都依赖于存储在
    `application`/`templates` 文件夹（所有 Flask HTML 模板都存储在这里）中的模板 `index.html`。以下是完整的视图：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Dissecting the view
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图剖析
- en: 'The views''s URL is `http://{localhost}/arenas`***.*** Using a special Python
    object called a **decorator** (such as `@app.route`*)* allows us to connect the
    URL that we want to use with the function that will accept and handle the request
    processing. The function and the URL do not need to have the same name, though
    it is common for them to do so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的 URL 是 `http://{localhost}/arenas`***。*** 使用一个特殊的 Python 对象，称为 **装饰器**（例如
    `@app.route`*），我们可以将我们想要使用的 URL 与将接受和处理请求处理的函数连接起来。函数和 URL 不需要具有相同的名称，尽管它们通常是这样的：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using forms
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单
- en: Underneath the decorator and the function declaration, the `ArenaForm` from
    `forms.py` is called and the function `request.form` is passed as a parameter.
    This adds functionality to the `ArenaForm` and allows it to access the request's
    own parameters as needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在装饰器和函数声明之下，调用了来自 `forms.py` 的 `ArenaForm`，并将 `request.form` 函数作为参数传递。这为 `ArenaForm`
    添加了功能，并允许它根据需要访问请求的自身参数。
- en: Once the `ArenaForm` object is passed to the variable `form`, it can be populated
    with data. This data will come from an SQLAlchemy session `query` on the `Arena`
    model. This query requests all rows of data from the `Arena` table and passes
    it to the variable `arenas` using `all` method (as opposed to the `filter_by`
    method which would limit the rows returned).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 `ArenaForm` 对象传递给变量 `form`，就可以用数据填充它。这些数据将来自对 `Arena` 模型的 SQLAlchemy 会话
    `query`。此查询请求 `Arena` 表的所有数据行，并使用 `all` 方法（而不是 `filter_by` 方法，后者会限制返回的行数）将其传递给变量
    `arenas`。
- en: 'Because the ArenaForm''s `selections` field is currently blank, we''ll use
    a list comprehension to loop through the `arena` objects contained within the
    list called `arenas`, adding their `id` and `name` fields to tuples inside the
    list. This populates the drop-down list and makes it so each selection in the
    list has a value (the `id`) and a label (the `name`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ArenaForm` 的 `selections` 字段目前为空，我们将使用列表推导来遍历名为 `arenas` 的列表中包含的 `arena`
    对象，将它们的 `id` 和 `name` 字段添加到列表内部的元组中。这填充了下拉列表，并确保列表中的每个选择项都有一个值（`id`）和一个标签（`name`）：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After populating the selections choices, three new attributes are added to the
    form—`popup`, `latitude`, and `longitude`. Initially, these are just placeholders
    and are not derived from the `arena` data. However, once the web application is
    running and users are selecting `arenas` from the drop-down list, these placeholder
    values will be replaced with data derived from the `arenas` tables and from queries
    against the other tables.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充选择项选项后，表单中添加了三个新属性——`popup`、`latitude` 和 `longitude`。最初，这些只是占位符，并不来自 `arena`
    数据。然而，一旦网络应用程序运行，并且用户从下拉列表中选择 `arenas`，这些占位符值将被来自 `arenas` 表和其他表的查询得到的数据所替换。
- en: Evaluating the request method
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估请求方法
- en: 'The next line is an `if` conditional that uses the `request.method` property
    to see if the HTTP request method is `POST`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条是使用 `request.method` 属性的 `if` 条件语句，以查看 HTTP 请求方法是否为 `POST`：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Because the initial request to the URL `arenas` is a `GET` request, the code
    initially evaluates the `if` conditional as `False`, skipping the indented code
    section to the bottom of the view to return the template `index.html` and the
    now populated `form`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对 `arenas` URL 的初始请求是一个 `GET` 请求，代码最初评估 `if` 条件为 `False`，跳过视图底部缩进的代码部分，以返回模板
    `index.html` 和现在已填充的 `form`：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This function returns uses the `render_template` function to return the template
    called `index.html` and passes the populated `ArenaForm` variable called `form` into
    the template, making it possible for the Jinja2 templating system to generate
    the completed web page and send it to the requesting web browser. All of the template's
    double-bracketed variables are filled in with the corresponding data from `form`
    (for example, the selections are added to the drop-down list).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `render_template` 函数返回名为 `index.html` 的模板，并将填充的 `ArenaForm` 变量 `form`
    传递到模板中，使得 Jinja2 模板系统能够生成完整的网页并发送到请求的网页浏览器。模板中所有双括号变量都填充了来自 `form` 的对应数据（例如，选择项被添加到下拉列表中）。
- en: POST requests
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST 请求
- en: 'If a user selects an `arena` from the list and pushes the Find Data button,
    the HTML form issues a `POST` request to the view. With the `if` conditional resolving
    to `True`, the view handles the request by generating an `arena` location coordinate
    pair and a custom `popup`, instead of using a default coordinate pair and `popup`
    value:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户从列表中选择一个 `arena` 并点击查找数据按钮，HTML 表单会向视图发出 `POST` 请求。当 `if` 条件解析为 `True` 时，视图通过生成
    `arena` 位置坐标对和自定义 `popup` 来处理请求，而不是使用默认的坐标对和 `popup` 值：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The property `form.selections.data` is used to retrieve the `id` of the `arena`
    chosen from the list and is passed to a variable called `arena_id`. This `id`
    is then used to query the database through the SQLAlchemy ORM's `get` method.
    The `form.longitude` and `form.latitude` fields can be populated from data fields
    of the `arena` object returned by the query.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `form.selections.data` 用于检索从列表中选择的 `arena` 的 `id`，并将其传递给一个名为 `arena_id` 的变量。然后，使用
    SQLAlchemy ORM 的 `get` 方法通过此 `id` 查询数据库。查询返回的 `arena` 对象的数据字段可以填充 `form.longitude`
    和 `form.latitude` 字段。
- en: Spatial queries
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间查询
- en: 'To find the county and the congressional district, two PostGIS spatial analysis
    techniques are used—`ST_Contains` and `ST_Intersects`. The first query determines
    if the `arena` is contained within a `county`; if not, the result is null (or
    `None` in Python):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到县和国会选区，使用了两种 PostGIS 空间分析技术——`ST_Contains` 和 `ST_Intersects`。第一个查询确定 `arena`
    是否包含在县内；如果不是，结果为空（或 Python 中的 `None`）：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: While `ST_Contains` could be used for both queries, I wanted to demonstrate
    that the GeoAlchemy2 ORM allows for access to all PostGIS functions when using
    `Geometry` columns. These searches combine the SQLAlchemy `filter` method with
    the GeoAlchemy2 ORM to make it possible to return query results based on a spatial
    analysis.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `ST_Contains` 可以用于两个查询，但我想要展示 GeoAlchemy2 ORM 允许在 `Geometry` 列中使用所有 PostGIS
    函数。这些搜索结合了 SQLAlchemy 的 `filter` 方法与 GeoAlchemy2 ORM，使其能够根据空间分析返回查询结果。
- en: Relationship query
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系查询
- en: 'If the `county` query was successful, the `district` query is performed, and
    then a relationship attribute (`state_ref`) is used to find the `state` within
    which the `county` is placed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `county` 查询成功，则执行 `district` 查询，然后使用关系属性 (`state_ref`) 来找到 `county` 所在的 `state`：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The two-way relationship established in the `County`, `District`, and `State`
    model definitions make this possible. This `state` object is a member of the `State`
    model class and can be used to retrieve the `name` of the `state`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `County`、`District` 和 `State` 模型定义中建立的双向关系使得这一点成为可能。这个 `state` 对象是 `State`
    模型类的一个成员，可以用来检索 `state` 的 `name`。
- en: To create the custom `popup`, string template formatting is used to populate
    the `popup` with the specifics describing the `arena` requested. The result is
    assigned to the variable `form.popup`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义 `popup`，使用字符串模板格式化来填充 `popup`，以包含描述请求的 `arena` 的具体信息。结果被分配给变量 `form.popup`。
- en: 'Finally, the populated `form` is then passed once again to the `index.html`
    template, but this time it contains data about the selected `arena`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，填充的 `form` 再次传递给 `index.html` 模板，但这次它包含有关所选 `arena` 的数据：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is a screenshot of the application query results for The Oracle Arena:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是应用程序查询结果截图，针对的是 The Oracle Arena：
- en: '![](img/54a1006e-af1e-4437-98ca-3af63d58a38c.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54a1006e-af1e-4437-98ca-3af63d58a38c.png)'
- en: The web map template
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络地图模板
- en: 'Within the `index.html` template, the `form` data is accessed inside double-bracketed
    variables. These variables can be located inside the JavaScript or within the
    HTML. In this example, the `form.latitude` and `form.longitude` variables are
    located inside the map JavaScript that defines the initial center point of the
    map:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.html` 模板中，通过双括号变量访问 `form` 数据。这些变量可以位于 JavaScript 中或 HTML 中。在这个例子中，`form.latitude`
    和 `form.longitude` 变量位于定义地图初始中心点的地图 JavaScript 中：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To create the `marker` at the location of the `arena` requested, with a custom
    `popup`, the location coordinates and the `popup` fields are added:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要在请求的 `arena` 位置创建具有自定义 `popup` 的 `marker`，需要添加位置坐标和 `popup` 字段：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To make the `POST` requests possible, an HTML form with a `POST` method houses
    the `form.description` and `form.selection` (the drop-down list) attributes. The
    HTML form''s button generates the `POST` request when it is pushed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `POST` 请求成为可能，一个具有 `POST` 方法的 HTML 表单包含了 `form.description` 和 `form.selection`（下拉列表）属性。当按钮被按下时，HTML
    表单的按钮生成 `POST` 请求：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Running the web application locally
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行网络应用程序
- en: 'To run the application locally, we can call the `app.py` script, located in
    the `arenaapp` folder, using the Python executable. Open up a command line and
    pass a script argument:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地运行应用程序，我们可以使用 Python 可执行文件调用位于 `arenaapp` 文件夹中的 `app.py` 脚本。打开命令行并传递脚本参数：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To run this application on a web server is beyond the scope of the chapter,
    but it involves configuring a web server with a WSGI handler to allow for web
    requests to be processed by the Python executable and `app.py`. For Apache web
    servers, the `mod_wsgi` module is popular. For Windows servers using **Internet
    Information Services** (**IIS**), the `wfastcgi` module is very useful and is
    available from the Microsoft Web Platform Installer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，运行此应用程序在 Web 服务器上超出了范围，但这涉及到配置一个带有 WSGI 处理器的 Web 服务器，以便允许通过 Python 可执行文件和
    `app.py` 处理 Web 请求。对于 Apache Web 服务器，`mod_wsgi` 模块很受欢迎。对于使用 **Internet Information
    Services**（**IIS**）的 Windows 服务器，`wfastcgi` 模块非常有用，并且可以从 Microsoft Web 平台安装程序中获取。
- en: Explore more about Apache and the `mod_wsgi` module here: [http://flask.pocoo.org/docs/latest/deploying/mod_wsgi/](http://flask.pocoo.org/docs/latest/deploying/mod_wsgi/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处了解更多关于 Apache 和 `mod_wsgi` 模块的信息：[http://flask.pocoo.org/docs/latest/deploying/mod_wsgi/](http://flask.pocoo.org/docs/latest/deploying/mod_wsgi/).
- en: 'For IIS, these installation instructions are very useful: [http://netdot.co/2015/03/09/flask-on-iis/](http://netdot.co/2015/03/09/flask-on-iis/).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 IIS，以下安装说明非常有用：[http://netdot.co/2015/03/09/flask-on-iis/](http://netdot.co/2015/03/09/flask-on-iis/).
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the Flask MVC web framework and some
    of the available component modules that add extra functionality. These modules
    include the SQLAlchemy ORM, the GeoAlchemy2 ORM for geospatial queries, WTForms
    for processing of web data, and the Jinja2 templating system for creating web
    page templates. We created database tables, added data tables and tables relationships,
    and created a web application that utilized geospatial and relationship queries
    to generate dynamic web pages.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Flask MVC Web 框架以及一些可用的组件模块，这些模块增加了额外的功能。这些模块包括 SQLAlchemy ORM、用于地理空间查询的
    GeoAlchemy2 ORM、用于处理 Web 数据的 WTForms 以及用于创建网页模板的 Jinja2 模板系统。我们创建了数据库表，添加了数据表和表关系，并创建了一个利用地理空间和关系查询生成动态网页的
    Web 应用程序。
- en: A fun challenge, building on the code reviewed here, would be to explore adding
    editing capabilities to the Arena application, allowing the user to move the `arenas`
    into their correct location if the data is out of date. Explore the GeoAlchemy2
    ORM documentation for more advanced capabilities.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的挑战，基于此处审查的代码，将是探索向 Arena 应用程序添加编辑功能，允许用户在数据过时的情况下将 `arenas` 移动到正确的位置。探索
    GeoAlchemy2 ORM 文档以获取更多高级功能。
- en: In the next chapter, we will review a similar MVC web framework, Django, and
    its GeoDjango spatial component. With more batteries included philosophy, Django
    solves the same problems inherent to web applications in different ways, but with
    less freedom of module choice, when compared to Flask.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾一个类似的 MVC Web 框架 Django 及其 GeoDjango 空间组件。Django 以更多内置功能（batteries
    included）的哲学，以不同的方式解决了与 Web 应用程序固有的相同问题，但与 Flask 相比，模块选择自由度较低。
