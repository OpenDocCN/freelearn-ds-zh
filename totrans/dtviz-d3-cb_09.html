<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Lay Them Out</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a pie chart</li><li class="listitem" style="list-style-type: disc">Building a stacked area chart</li><li class="listitem" style="list-style-type: disc">Building a treemap</li><li class="listitem" style="list-style-type: disc">Building a tree</li><li class="listitem" style="list-style-type: disc">Building an enclosure diagram</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Introduction</h1></div></div></div><p>The D3 <strong>layout</strong>
<a id="id483" class="indexterm"/> is the focus of this chapter—a concept we have not encountered before. As expected, D3 layouts are algorithms that calculate and generate placement information for a group of elements. However there are a few critical properties worth mentioning before<a id="id484" class="indexterm"/> we dive deeper into the specifics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Layouts are data</strong>: Layouts are purely data centric and data driven, they do not generate any graphical or display related output directly. This allows them to be used and reused with SVG or canvas or even when there is no graphical output</li><li class="listitem" style="list-style-type: disc"><strong>Abstract and reusable</strong>: Layouts are abstract, allowing a high degree of flexibility and reusability. You can combine and reuse layouts in various different interesting ways.</li><li class="listitem" style="list-style-type: disc"><strong>Layouts are different</strong>: Each layout is different. Every layout provided by D3 focuses on a very special graphical requirement and data structure.</li><li class="listitem" style="list-style-type: disc"><strong>Stateless</strong>: Layouts are mostly stateless by design to simplify their usage. What statelessness means here is that generally layouts are like functions, they can be called multiple times with different input data and generate different layout output.</li></ul></div><p>Layouts are interesting and powerful concepts in D3. In this chapter we will explore some of the most commonly used layouts in D3 by creating fully functional visualization leveraging these layouts.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Building a pie chart</h1></div></div></div><p>A pie chart<a id="id485" class="indexterm"/> or a circle graph is a circular graph containing multiple sectors used to illustrate numerical proportion. We will explore techniques, involving D3 <a id="id486" class="indexterm"/>
<strong>pie layout</strong>, to build a fully functional pie chart in this recipe. In <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>, it becomes clear that using the D3 arc generator directly is a very tedious job. Each arc generator expects the following data format:</p><div><pre class="programlisting">var data = [
  {startAngle: 0, endAngle: 0.6283185307179586}, 
  {startAngle: 0.6283185307179586, endAngle: 1.2566370614359172},
  ...
  {startAngle: 5.654866776461628, endAngle: 6.283185307179586}
];</pre></div><p>This essentially requires the calculation of the angle partition for each slice out of an entire circle of <code class="literal">2 * Math.PI</code>. Obviously this process can be automated by an algorithm which is exactly what <code class="literal">d3.layout.pie</code> is designed for. In this recipe, we will see how pie layout can be used to implement a fully functional pie chart.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec179"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pie-chart.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pie-chart.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec180"/>How to do it...</h2></div></div></div><p>A pie chart or a <a id="id487" class="indexterm"/>circle graph is a circular diagram divided into sectors (slices). Pie charts are popular in many fields and widely used to demonstrate relationships between different entities though not without criticism. Let's take a look at how a pie chart is implemented using <code class="literal">d3.pie.layout</code> first.</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
  function pieChart() {
    var _chart = {};

    var _width = 500, _height = 500,
      _data = [],
      _colors = d3.scale.category20(),
      _svg,
      _bodyG,
      _pieG,
      _radius = 200,
      _innerRadius = 100;

      _chart.render = function () {
        if (!_svg) {
          _svg = d3.select("body").append("svg")
            .attr("height", _height)
            .attr("width", _width);
        }

      renderBody(_svg);
  };

  function renderBody(svg) {
    if (!_bodyG)
      _bodyG = svg.append("g")
        .attr("class", "body");

    renderPie();
  }

  function renderPie() {
    var pie = d3.layout.pie()
      .sort(function (d) {
        return d.id;
      })
      .value(function (d) {
        return d.value;
      });

    var arc = d3.svg.arc()
      .outerRadius(_radius)
      .innerRadius(_innerRadius);

    if (!_pieG)
      _pieG = _bodyG.append("g")
        .attr("class", "pie")
        .attr("transform", "translate(" + _radius + "," + _radius + ")");

    renderSlices(pie, arc);

    renderLabels(pie, arc);
  }

  function renderSlices(pie, arc) {
  // explained in detail in the'how it works...' section
  ...
  }

  function renderLabels(pie, arc) {
  // explained in detail in the 'how it works...' section
  ...
  }
  ...
  return _chart;
}
...
&lt;/script&gt;</pre></div><p>This recipe <a id="id488" class="indexterm"/>generates the following pie chart:</p><div><img src="img/2162OS_09_01.jpg" alt="How to do it..."/><div><p>Donut chart</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec181"/>How it works...</h2></div></div></div><p>This recipe is<a id="id489" class="indexterm"/> built over what we have learned in the <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>. One major difference is that we rely on <code class="literal">d3.layout.pie</code> to transform the raw data into arcs data for us. The pie layout was created on line A with both sort and value accessors specified.</p><div><pre class="programlisting">var pie = d3.layout.pie() // &lt;-A
  .sort(function (d) {
    return d.id;
  })
  .value(function (d) {
    return d.value;
  });</pre></div><p>The <code class="literal">sort</code> function<a id="id490" class="indexterm"/> tells the pie layout to sort slices by its ID field, so that we can maintain stable order amongst slices. Without the sorting, by default the pie layout will order the slices by value resulting in the swapping of slices whenever we update the pie chart. The <code class="literal">value</code> function is used to provide value accessor which in our case returns the <code class="literal">value</code> field. When rendering slices, now with the pie layout, we directly set the pie layout as <a id="id491" class="indexterm"/>data (remember layouts are data) to generate the arc <code class="literal">svg:path</code> elements (line B).</p><div><pre class="programlisting">function renderSlices(pie, arc) {
  var slices = _pieG.selectAll("path.arc")
    .data(pie(_data)); // &lt;-B

  slices.enter()
    .append("path")
    .attr("class", "arc")
    .attr("fill", function (d, i) {
      return _colors(i);
    });

  slices.transition()
    .attrTween("d", function (d) {
      var currentArc = this.__current__;//&lt;-C

      if (!currentArc)
        currentArc = {startAngle: 0, 
          endAngle: 0};

      var interpolate = d3.interpolate(
        currentArc, d);
      this.__current__ = interpolate(1);//&lt;-D
        return function (t) {
          return arc(interpolate(t));
        };
    });
}</pre></div><p>The rest of the rendering logic is pretty much the same as what we have learned in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>, with one exception on line C. On line C we retrieve the current arc value from the element so the transition can start from the current angle instead of zero. Then on line D we reset the current arc value to the latest one so the next time when we update the pie chart data we can repeat the stateful transition.</p><div><div><h3 class="title"><a id="tip42"/>Tip</h3><p>
<strong>Technique – stateful visualization</strong>
</p><p>Technique of value injection on a DOM element is a common approach to introduce statefulness to<a id="id492" class="indexterm"/> your visualization. In other words, if you need your visualizations to remember what their previous states are, you can save them in DOM elements.</p></div></div><p>Finally we also need to render labels on each slice so our user can understand what each slice is representing. This is done by the <code class="literal">renderLabels</code> function.</p><div><pre class="programlisting">function renderLabels(pie, arc) {
  var labels = _pieG.selectAll("text.label")
    .data(pie(_data)); // &lt;-E

  labels.enter()
    .append("text")
    .attr("class", "label");

  labels.transition()
    .attr("transform", function (d) {
      return "translate(" 
        + arc.centroid(d) + ")"; //&lt;-F
      })
    .attr("dy", ".35em")
    .attr("text-anchor", "middle")
    .text(function (d) {
      return d.data.id;
    });
}</pre></div><p>Once <a id="id493" class="indexterm"/>again we use the pie layout as data to generate the <code class="literal">svg:text</code> elements. The placement of the labels is calculated using <code class="literal">arc.centroid</code> (line F). Additionally, the label placement is animated through the transition so they can be moved with arcs in unison.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec182"/>There's more...</h2></div></div></div><p>Pie charts are very widely used in many different domains. However, they have also been widely criticized due to the fact that they are difficult for human eyes to compare different sections of a given pie chart as well as their low information density. Therefore, it is highly recommended to limit the number of sections to less than 3, with 2 to be ideal. Otherwise, you can always use a bar chart or a small table to replace a pie chart in places with better precision and communicative power.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec183"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using arc generators</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em></li><li class="listitem" style="list-style-type: disc">The <em>Implementing arc transition</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Building a stacked area chart</h1></div></div></div><p>In the <em>Creating an area chart</em> recipe in <a class="link" href="ch08.html" title="Chapter 8. Chart Them Up">Chapter 8</a>, <em>Chart Them Up</em>, we have explored how a basic layered area chart can be<a id="id494" class="indexterm"/> implemented using D3. In this recipe, we will build over what we have learned in the area chart recipe to implement a stacked area chart. Stacked area chart is a variation of the standard area chart in which different areas are stacked on top of each other giving your audience not only the ability to compare different data series individually but also their relationship to the total in proportion.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec184"/>Getting ready</h2></div></div></div><p>Open your local<a id="id495" class="indexterm"/> copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/stacked-area-chart.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/stacked-area-chart.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec185"/>How to do it...</h2></div></div></div><p>This recipe is built over what we have implemented in <a class="link" href="ch08.html" title="Chapter 8. Chart Them Up">Chapter 8</a>, <em>Chart Them Up</em>, therefore in the following code example only the parts that are particularly relevant to the stacked area chart are included:</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
function stackedAreaChart() {
  var _chart = {};

  var _width = 900, _height = 450,
    _margins = {top: 30, left: 30, right: 30, bottom: 30},
    _x, _y,
    _data = [],
    _colors = d3.scale.category10(),
    _svg,
    _bodyG,
    _line;

  _chart.render = function () {
    if (!_svg) {
      _svg = d3.select("body").append("svg")
      .attr("height", _height)
      .attr("width", _width);

    renderAxes(_svg);

    defineBodyClip(_svg);
  }

  renderBody(_svg);
};
...
function renderBody(svg) {
  if (!_bodyG)
    _bodyG = svg.append("g")
      .attr("class", "body")
      .attr("transform", "translate("
        + xStart() + ","
        + yEnd() + ")")
      .attr("clip-path", "url(#body-clip)");

  var stack = d3.layout.stack() //&lt;-A
    .offset('zero');
  stack(_data); //&lt;-B

  renderLines(_data);

  renderAreas(_data);
}

function renderLines(stackedData) {
  // explained in details in the'how it works...' section
...
}

function renderAreas(stackedData) {
  // explained in details in the 'how it works...' section
...
}
...</pre></div><p>This recipe <a id="id496" class="indexterm"/>generates the following visualization:</p><div><img src="img/2162OS_09_02.jpg" alt="How to do it..."/><div><p>Stacked area chart</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec186"/>How it works...</h2></div></div></div><p>The main <a id="id497" class="indexterm"/>difference between this recipe and standard area chart as well as the focus on this recipe is the stacking. The stacking effect as illustrated in this recipe was achieved through <code class="literal">d3.layout.stack</code> created on line A.</p><div><pre class="programlisting">var stack = d3.layout.stack() //&lt;-A
  .offset('zero');
stack(_data); //&lt;-B</pre></div><p>The only customization we have done on stack layout is setting its <code class="literal">offset</code> to <code class="literal">zero</code>. D3 stack layout supports a few different offset modes which determine what stacking algorithm to use; this is something that we will explore in this and the next recipe. In this case we use the <code class="literal">zero</code> offset stacking which generates a zero base-lined stacking algorithm, which is exactly what we want in this recipe. Next, on line B, we invoked the stack layout on the given data array which generates the following layout data:</p><div><img src="img/2162OS_09_03.jpg" alt="How it works..."/><p>Stacked data
</p></div><p>As shown, the <a id="id498" class="indexterm"/>stack layout automatically calculates a baseline <code class="literal">y0</code> for each datum in our three different data series. Now with this stacked dataset in hand, we can easily generate stacked lines.</p><div><pre class="programlisting">function renderLines(stackedData) {
  _line = d3.svg.line()
    .x(function (d) {
      return _x(d.x); //&lt;-C
    })
    .y(function (d) {
      return _y(d.y + d.y0); //&lt;-D
    });
  _bodyG.selectAll("path.line")
    .data(stackedData)
    .enter()
    .append("path")
    .style("stroke", function (d, i) {
      return _colors(i);
    })
    .attr("class", "line");

  _bodyG.selectAll("path.line")
    .data(stackedData)
    .transition()
    .attr("d", function (d) {
      return _line(d);
    });
}</pre></div><p>A D3 line generator function was created with its x value directly mapped to the <code class="literal">x</code> (line C) and its y value mapped to <code class="literal">y + y0</code> (line D). This is all you need to do for line stacking. The rest of the <code class="literal">renderLines</code> function is essentially the same as in the basic area chart implementation. The area stacking logic is slightly different:</p><div><pre class="programlisting">function renderAreas(stackedData) {
  var area = d3.svg.area()
    .x(function (d) {
      return _x(d.x); //&lt;-E
    })
    .y0(function(d){return _y(d.y0);}) //&lt;-F
    .y1(function (d) {
      return _y(d.y + d.y0); //&lt;-G
    });
  _bodyG.selectAll("path.area")
    .data(stackedData)
    .enter()
    .append("path")
    .style("fill", function (d, i) {
      return _colors(i);
    })
    .attr("class", "area");

  _bodyG.selectAll("path.area")
    .data(_data)
    .transition()
    .attr("d", function (d) {
      return area(d);
    });
}</pre></div><p>Similar to the line rendering logic when rendering area, the only place we need to change is in the <code class="literal">d3.svg.area</code> generator setting. For areas the <code class="literal">x</code> value is still directly mapped to <code class="literal">x</code> (line E) with its <code class="literal">y0</code> directly mapped with <code class="literal">y0</code> and finally again <code class="literal">y1</code> is the sum of <code class="literal">y</code> and <code class="literal">y0</code> (line G).</p><p>As we have<a id="id499" class="indexterm"/> seen so far, D3 stack layout is nicely designed to be compatible with different D3 SVG generator functions. Hence, using it to generate the stacking effect is quite straightforward and convenient.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec187"/>There's more...</h2></div></div></div><p>Let's take a look at a couple of variations of the stacked area chart.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec12"/>Expanded area chart</h3></div></div></div><p>We have mentioned <a id="id500" class="indexterm"/>that <code class="literal">d3.layout.stack</code> supports different offset modes. In addition to the <code class="literal">zero</code> offset we have seen so far, another very useful offset mode for area chart is called <code class="literal">expand</code>. With the <code class="literal">expand</code> mode, stack layout will normalize different layers to fill the range of [0, 1]. If we change the offset mode in this recipe and the y axis domain to [0, 1], we will get the expanded (normalized) area chart shown below.</p><div><img src="img/2162OS_09_04.jpg" alt="Expanded area chart"/><p>Expanded area chart
</p></div><p>For the complete companion code example please visit: <a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/expanded-area-chart.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/expanded-area-chart.html</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec13"/>Streamgraph</h3></div></div></div><p>Another interesting variation of stacked area chart is called <a id="id501" class="indexterm"/>streamgraph. Streamgraph is a stacked area chart displayed around a central axis creating a flowing and organic shape. Streamgraph was initially developed by Lee Byron and popularized by its use in a New York Times article on movie box office revenues in 2008. The D3 stack layout has built-in support for this kind of stacking algorithm therefore changing a zero based stacked area chart to streamgraph is trivial. The key difference is that streamgraph uses <code class="literal">wiggle</code> as its layout offset mode.</p><div><img src="img/2162OS_09_05.jpg" alt="Streamgraph"/><p>Streamgraph
</p></div><p>For the complete companion code example please visit: <a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/streamgraph.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/streamgraph.html</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec188"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.layout.stack</code> offers several additional functions to customize its behavior; for more information on stack layout visit <a class="ulink" href="https://github.com/mbostock/d3/wiki/Stack-Layout">https://github.com/mbostock/d3/wiki/Stack-Layout</a></li><li class="listitem" style="list-style-type: disc">The <em>Creating an area chart</em> recipe in <a class="link" href="ch08.html" title="Chapter 8. Chart Them Up">Chapter 8</a>, <em>Chart Them Up</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Building a treemap</h1></div></div></div><p>Treemaps<a id="id502" class="indexterm"/> were introduced by Ben Shneiderman in 1991. A treemap displays hierarchical tree-structured data as a set of recursively subdivided rectangles. In other words, it displays each branch of the tree as a large rectangle which is then tiled with smaller rectangles representing sub-branches. This process continuously repeats itself till it reaches the leaves of the tree.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>For more information on <a id="id503" class="indexterm"/>treemaps, see this paper by Ben Shneiderman at <a class="ulink" href="http://www.cs.umd.edu/hcil/treemap-history/">http://www.cs.umd.edu/hcil/treemap-history/</a>
</p></div></div><p>Before we dive into the code example, let's first define what we mean by <strong>hierarchical data</strong>
<a id="id504" class="indexterm"/>.</p><p>So far we have <a id="id505" class="indexterm"/>learned many types of visualizations capable of representing flat data structure usually stored in one or two dimensional arrays. In the rest of this chapter, we will switch our focus onto another common type of data structure in data visualization—the hierarchical data structure. Instead of using arrays, as in the case of flat data structures, hierarchical data are usually structured as a rooted tree. The following JSON file shows a typical hierarchical data you would expect in a data visualization project:</p><div><pre class="programlisting">{
  "name": "flare",
  "children": [
  {
    "name": "analytics",
    "children": [
    {
      "name": "cluster",
      "children": [
        {"name": "AgglomerativeCluster", "size": 3938},
        {"name": "CommunityStructure", "size": 3812},
        {"name": "MergeEdge", "size": 743}
      ]
    },
    {
      "name": "graph",
      "children": [
        {"name": "BetweennessCentrality", "size": 3534},
        {"name": "LinkDistance", "size": 5731}
      ]
    },
    {
      "name": "optimization",
      "children": [
        {"name": "AspectRatioBanker", "size": 7074}
      ]
    }
  ]  
  ]
}</pre></div><p>This is a shortened version of a popular hierarchical dataset used in the D3 community for demonstration purposes. This data is extracted from a popular flash based data visualization library—Flare, created by the UC Berkeley Visualization Lab. It shows the size and hierarchical relationship amongst different packages within the library.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>See the official Flare site<a id="id506" class="indexterm"/> for more information on the project: <a class="ulink" href="http://flare.prefuse.org/">http://flare.prefuse.org/</a>.</p></div></div><p>As we can see <a id="id507" class="indexterm"/>quite easily this particular JSON feed is structured as a typical singly-linked rooted tree with each node having a single parent and multiple child nodes stored in the <code class="literal">children</code> array. This is the most natural way to organize your hierarchical data in order to be consumed by the D3 hierarchical layouts. For the rest of this chapter, we will use this particular dataset for exploring different hierarchical data visualization techniques D3 has to offer.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec189"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/treemap.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/treemap.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec190"/>How to do it...</h2></div></div></div><p>Now let's see how we can use the D3 treemap layout to visually represent this kind of hierarchical data.</p><div><pre class="programlisting">function treemapChart() {
  var _chart = {};

  var _width = 1600, _height = 800,
    _colors = d3.scale.category20c(),
   _svg,
   _nodes,
   _x = d3.scale.linear().range([0, _width]),
   _y = d3.scale.linear().range([0, _height]),
   _valueAccessor = function (d) {
      return 1;
    },
  _bodyG;

  _chart.render = function () {
    if (!_svg) {
      _svg = d3.select("body").append("svg")
        .attr("height", _height)
        .attr("width", _width);
    }

    renderBody(_svg);
  };

  function renderBody(svg) {
    // explained in details in the 'how it works...' section
    ... 

    renderCells(cells);
  }

  function renderCells(cells){
    // explained in details in the 'how it works...' section
    ...
  }

  // accessors omitted
  ...

  return _chart;
}

d3.json("flare.json", function (nodes) {
  var chart = treemapChart();
  chart.nodes(nodes).render();
});</pre></div><p>This recipe generates <a id="id508" class="indexterm"/>the following treemap visualization:</p><div><img src="img/2162OS_09_06.jpg" alt="How to do it..."/><div><p>Treemap</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec191"/>How it works...</h2></div></div></div><p>At this point you<a id="id509" class="indexterm"/> might be surprised how little code is needed to implement a complex data visualization like this. This is because most of the heavy lifting is done by <code class="literal">d3.layout.treemap</code>.</p><div><pre class="programlisting">function renderBody(svg) {
  if (!_bodyG) {
    _bodyG = svg.append("g")
      .attr("class", "body");

      _treemap = d3.layout.treemap() //&lt;-A
        .round(false)
        .size([_width, _height])
        .sticky(true);
      }

      _treemap.value(_valueAccessor); //&lt;-B

  var nodes = _treemap.nodes(_nodes) //&lt;-C
    .filter(function (d) {
      return !d.children; //&lt;-D
    });

  var cells = svg.selectAll("g") //&lt;-E
    .data(nodes);

  renderCells(cells);
    }</pre></div><p>The <a id="id510" class="indexterm"/>treemap layout is defined on line A with some basic custom settings:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">round(false)</code>: If rounding is on, the treemap layout will round to exact pixel boundaries. This is great when you want to avoid antialiasing artifacts in SVG.</li><li class="listitem" style="list-style-type: disc"><code class="literal">size([_width, _height])</code>: It sets the layout boundary to the size of this SVG.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sticky(true)</code>: In sticky mode, the treemap layout will try to preserve the relative arrangement of nodes (rectangles in our case) across the transition.</li><li class="listitem" style="list-style-type: disc"><code class="literal">value(_valueAccessor)</code>: One feature this recipe offers is the ability to switch the treemap value accessor on the fly. Value accessor is used by a treemap to access value field on each node. In our case, it can be either one of the following functions:<div><pre class="programlisting">function(d){ return d.size; } // visualize package size
function(d){ return 1; } // visualize package count</pre></div></li><li class="listitem" style="list-style-type: disc">To apply a treemap layout on Flare JSON datafeed, we simply set the <code class="literal">nodes</code> on the treemap layout to the root node in our JSON tree (line C). Treemap nodes are then further filtered to remove parent nodes (nodes that have children) on line D since we only want to visualize the leaf nodes while using coloring to highlight the package grouping in this treemap implementation. The layout data generated by treemap layout contains the following structure:<div><img src="img/2162OS_09_07.jpg" alt="How it works..."/><div><p>Treemap node object</p></div></div></li></ul></div><p>As shown, the <a id="id511" class="indexterm"/>treemap layout has annotated and calculated quite a few attributes for each node using its algorithm. Many of these attributes can be useful when visualizing and in this recipe we mostly care about the following attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>: Cell x coordinate</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code>: Cell y coordinate</li><li class="listitem" style="list-style-type: disc"><code class="literal">dx</code>: Cell width</li><li class="listitem" style="list-style-type: disc"><code class="literal">dy</code>: Cell height</li></ul></div><p>On line E, a set of <code class="literal">svg:g</code> elements were created for the given nodes. The function <code class="literal">renderCells</code> is then responsible for creating rectangles and its labels:</p><div><pre class="programlisting">function renderCells(cells){
  var cellEnter = cells.enter().append("g")
    .attr("class", "cell");

  cellEnter.append("rect")
  cellEnter.append("text");

  cells.transition().attr("transform", function (d) {
    return "translate("+d.x+","+d.y+")"; //&lt;-F
  })
  .select("rect")
    .attr("width", function (d) {return d.dx - 1;})
    .attr("height", function (d) {return d.dy - 1;})
    .style("fill", function (d) {
      return _colors(d.parent.name); //&lt;-G
    });

  cells.select("text") //&lt;-H
    .attr("x", function (d) {return d.dx / 2;})
    .attr("y", function (d) {return d.dy / 2;})
    .attr("dy", ".35em")
    .attr("text-anchor", "middle")
    .text(function (d) {return d.name;})
    .style("opacity", function (d) {
      d.w = this.getComputedTextLength();
      return d.dx &gt; d.w ? 1 : 0; //&lt;-I
    );

  cells.exit().remove();
}</pre></div><p>Each rectangle is <a id="id512" class="indexterm"/>placed at its location <code class="literal">(x, y)</code> determined by the layout on line F, and then its width and height are set to <code class="literal">dx</code> and <code class="literal">dy</code>. On line G, we colored every cell using its parent's names therefore making sure all children belonging to the same parent are colored the same way. From line H onward we created the label (<code class="literal">svg:text</code>) element for each rectangle and setting its text to the node name. One aspect worth mentioning here is that in order to avoid displaying label for the cells that are smaller than the label itself, the opacity of label is set to 0 if the label is larger than the cell width (line I).</p><div><div><h3 class="title"><a id="tip43"/>Tip</h3><p>
<strong>Technique – auto-hiding label</strong>
</p><p>What we have seen here on line I is a useful technique in visualization to implement auto-hiding labels. This technique can be considered generally in the following form:</p><div><pre class="programlisting">.style("opacity", function (d) {
    d.w = this.getComputedTextLength();
    return d.dx &gt; d.w ? 1 : 0;
)</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec192"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This recipe is inspired by Mike Bostock's treemap layout example, which you can find at <a class="ulink" href="http://mbostock.github.io/d3/talk/20111018/treemap.html">http://mbostock.github.io/d3/talk/20111018/treemap.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Building a tree</h1></div></div></div><p>When working with hierarchical <a id="id513" class="indexterm"/>data structures, a tree (tree graph) is probably one of the most natural and common visualizations typically leveraged to demonstrate structural dependencies between different data elements. Tree is an undirected graph in which any two nodes (vertices) are connected by one and only one simple path. In this recipe, we will learn how to implement a tree visualization using tree layout.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec193"/>Getting ready</h2></div></div></div><p>Open your local copy of <a id="id514" class="indexterm"/>the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/tree.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/tree.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec194"/>How to do it...</h2></div></div></div><p>Now let's see <code class="literal">d3.layout.tree</code> in action:</p><div><pre class="programlisting">function tree() {
  var _chart = {};

  var _width = 1600, _height = 800,
    _margins = {top:30, left:120, right:30, bottom:30},
    _svg,
    _nodes,
    _i = 0,
    _tree,
    _diagonal,
    _bodyG;

  _chart.render = function () {
    if (!_svg) {
      _svg = d3.select("body").append("svg")
        .attr("height", _height)
        .attr("width", _width);
    }

    renderBody(_svg);
  };

  function renderBody(svg) {
    if (!_bodyG) {
      _bodyG = svg.append("g")
        .attr("class", "body")
        .attr("transform", function (d) {
          return "translate(" + _margins.left 
            + "," + _margins.top + ")";
          });
    }

    _tree = d3.layout.tree()
      .size([
        (_height - _margins.top - _margins.bottom), 
        (_width - _margins.left - _margins.right)
      ]);

    _diagonal = d3.svg.diagonal()
      .projection(function (d) {
        return [d.y, d.x];
      });

    _nodes.x0 = (_height-_margins.top-_margins.bottom) / 2;
    _nodes.y0 = 0;

    render(_nodes);
  }

  function render(source) {
    var nodes = _tree.nodes(_nodes);

    renderNodes(nodes, source);

    renderLinks(nodes, source);
  }

  function renderNodes(nodes, source) {
    // will be explained in the 'how it works...' section
    ...
  }

  function renderLinks(nodes, source) {
    // will be explained in the 'how it works...' section
    ...
  }

  // accessors omitted
  ...

  return _chart;
}</pre></div><p>This recipe<a id="id515" class="indexterm"/> generates the following tree visualization:</p><div><img src="img/2162OS_09_08.jpg" alt="How to do it..."/><div><p>Tree</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec195"/>How it works...</h2></div></div></div><p>As we have mentioned before, this recipe is built over the D3 tree layout. <code class="literal">d3.layout.tree</code> is specifically designed to convert a hierarchical data structure into a visual layout data suitable for generating tree graph. Our tree layout instance is defined as the following:</p><div><pre class="programlisting">_tree = d3.layout.tree()
  .size([
    (_height - _margins.top - _margins.bottom), 
    (_width - _margins.left - _margins.right)
  ]);</pre></div><p>The only setting we <a id="id516" class="indexterm"/>provided here is the size of our visualization, which is the size of our SVG image minus the margins. <code class="literal">d3.layout.tree</code> will then take care of the rest and calculate every node's position accordingly. To use the tree layout, you simply invoke its <code class="literal">nodes</code> function.</p><div><pre class="programlisting">var nodes = _tree.nodes(_nodes);
</pre></div><p>If you peek into the <code class="literal">nodes</code> layout data, it contains node data looking like this:</p><div><img src="img/2162OS_09_09.jpg" alt="How it works..."/><div><p>Tree layout data</p></div></div><p>One new D3 SVG shape generator we need for this recipe that is worth mentioning is <code class="literal">d3.svg.diagonal</code>. The diagonal generator is designed to create <code class="literal">svg:path</code> that connects two points. In this recipe, we use diagonal generator with tree layout <code class="literal">links</code> function to generate a path connecting every node in the tree.</p><div><pre class="programlisting">
_diagonal = d3.svg.diagonal()
  .projection(function (d) {
    return [d.y, d.x];
  });</pre></div><p>In this case we configure our diagonal generator to project using Cartesian orientation and simply reply on the x and y coordinates calculated by the tree layout for positioning. The actual rendering was performed by the following functions. First let's take a look at the<a id="id517" class="indexterm"/> <code class="literal">renderNodes</code> function:</p><div><pre class="programlisting">function renderNodes(nodes, source) {
  nodes.forEach(function (d) {
    d.y = d.depth * 180; 
  });</pre></div><p>Here we loop<a id="id518" class="indexterm"/> through all the nodes and artificially assign a 180-pixel spacing between them. You probably are wondering why we are using the y coordinate instead of x. The reason is that in this recipe we want to render a horizontal tree instead of a vertical one; therefore we have to reverse the x and y coordinates here.</p><div><pre class="programlisting">  var node = _bodyG.selectAll("g.node")
    .data(nodes, function (d) {
      return d.id || (d.id = ++_i);
    });</pre></div><p>Now we bind the nodes that were generated by the tree layout as data to generate the tree node element. At this point, we also assign an ID to each node using an index to obtain object constancy.</p><div><pre class="programlisting">  var nodeEnter = node.enter().append("svg:g")
    .attr("class", "node")
    .attr("transform", function (d) {
      return "translate(" + source.y0 
        + "," + source.x0 + ")";
    });</pre></div><p>At this point, we create the<a id="id519" class="indexterm"/> nodes and move them to the same point of origin as set in the <code class="literal">renderBody</code> function.</p><div><pre class="programlisting">  nodeEnter.append("svg:circle")
    .attr("r", 1e-6);

  var nodeUpdate = node.transition()
    .attr("transform", function (d) {
      return "translate(" + d.y + "," + d.x + ")";
    });

  nodeUpdate.select("circle")
    .attr("r", 4.5);</pre></div><p>Now we start a transition in the update section to move the nodes to their proper position.</p><div><pre class="programlisting">  var nodeExit = node.exit().transition()
    .attr("transform", function (d) {
      return "translate(" + source.y 
        + "," + source.x + ")";
      })
    .remove();

  nodeExit.select("circle")
    .attr("r", 1e-6);

  renderLabels(nodeEnter, nodeUpdate, nodeExit);
}</pre></div><p>At last, we handle the exit case and remove the nodes after a brief animation of the collapsing effect. The <code class="literal">renderLabels</code> function<a id="id520" class="indexterm"/> is quite simple so we will not cover it in detail here. Please see the complete online code companion for details.</p><p>Now let's take a<a id="id521" class="indexterm"/> look at the more interesting<a id="id522" class="indexterm"/> <code class="literal">renderLinks</code> function.</p><div><pre class="programlisting">function renderLinks(nodes, source) {
  var link = _bodyG.selectAll("path.link")
    .data(_tree.links(nodes), function (d) {
      return d.target.id;
    });</pre></div><p>First, we generate the data binding using the <code class="literal">links</code> function on <code class="literal">d3.layout.tree</code>. The <code class="literal">links</code> function, which returns an array of link objects containing the <code class="literal">{source, target}</code> fields that point to the appropriate tree nodes.</p><div><pre class="programlisting">  link.enter().insert("svg:path", "g")
    .attr("class", "link")
    .attr("d", function (d) {
      var o = {x: source.x0, y: source.y0};
      return _diagonal({source: o, target: o});
    });</pre></div><p>In the <code class="literal">enter</code> section, the <code class="literal">svg:path</code> elements were created to visually represent the links between source and target nodes. To generate the <code class="literal">d</code> attribute for the path element we rely on the <code class="literal">d3.svg.diagonal</code> generator we defined earlier. During creation we temporarily set the links to zero length paths by setting both source and target to the same point of origin. So when later we transition the link to its proper length, it will generate the expanding effect.</p><div><pre class="programlisting">  link.transition()
    .attr("d", _diagonal);</pre></div><p>Now we transition the links to its proper length and position using the links data generated by the tree layout.</p><div><pre class="programlisting">  link.exit().transition()
    .attr("d", function (d) {
      var o = {x: source.x, y: source.y};
      return _diagonal({source: o, target: o});
    })
  .remove();</pre></div><p>When we<a id="id523" class="indexterm"/> remove the nodes again,we rely on the same trick of setting the link to its parent's position with zero length in order to simulate the collapsing effect.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec196"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.layout.tree</code> offers<a id="id524" class="indexterm"/> several functions allowing customization. For more details, please check out its API documentation at <a class="ulink" href="https://github.com/mbostock/d3/wiki/Tree-Layout">https://github.com/mbostock/d3/wiki/Tree-Layout</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">d3.svg.diagonal</code> generator<a id="id525" class="indexterm"/> is capable of projection using Cartesian orientation, radial and other orientations. For more details, please see its API documentation at <a class="ulink" href="https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-diagonal">https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-diagonal</a>.</li><li class="listitem" style="list-style-type: disc">The <em>Animating multiple elements</em> recipe in <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>, for explanations on object constancy.</li><li class="listitem" style="list-style-type: disc">This recipe is inspired by Mike Bostock's tree layout example, which you can find at <a class="ulink" href="http://mbostock.github.io/d3/talk/20111018/tree.html">http://mbostock.github.io/d3/talk/20111018/tree.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec70"/>Building an enclosure diagram</h1></div></div></div><p>An enclosure diagram <a id="id526" class="indexterm"/>is an interesting visualization of hierarchical data structures that uses the recursive circle packing algorithm. It uses containment (nesting) to represent hierarchy. Circles are created for each leaf node in a data tree while its size is proportional to a particular quantitative dimension of each data element. In this recipe, we will learn how to implement this kind of visualization using D3 pack layout.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec197"/>Getting ready</h2></div></div></div><p>Open your local<a id="id527" class="indexterm"/> copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pack.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter9/pack.html</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec198"/>How to do it...</h2></div></div></div><p>In this recipe, let's see how we can implement an enclosure diagram using <code class="literal">d3.layout.pack</code>.</p><div><pre class="programlisting">function pack() {
  var _chart = {};

  var _width = 1280, _height = 800,
    _svg,
    _r = 720,
    _x = d3.scale.linear().range([0, _r]),
    _y = d3.scale.linear().range([0, _r]),
    _nodes,
    _bodyG;

  _chart.render = function () {
    if (!_svg) {
      _svg = d3.select("body").append("svg")
        .attr("height", _height)
        .attr("width", _width);
    }

    renderBody(_svg);
  };

  function renderBody(svg) {
    if (!_bodyG) {
      _bodyG = svg.append("g")
        .attr("class", "body")
        .attr("transform", function (d) {
          return "translate(" 
            + (_width - _r) / 2 + "," 
            + (_height - _r) / 2 
            + ")";
        });
    }

    var pack = d3.layout.pack()
      .size([_r, _r])
      .value(function (d) {
        return d.size;
      });

    var nodes = pack.nodes(_nodes);

    renderCircles(nodes);

    renderLabels(nodes);
  }

  function renderCircles(nodes) {
    // will be explained in the 'how it works...' section
    ...
  }

  function renderLabels(nodes) {
    // omitted
    ...
  }

  // accessors omitted
  ...

  return _chart;
}</pre></div><p>This recipe <a id="id528" class="indexterm"/>generates the following visualization:</p><div><img src="img/2162OS_09_10.jpg" alt="How to do it..."/><div><p>Enclosure diagram</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec199"/>How it works...</h2></div></div></div><p>First thing we <a id="id529" class="indexterm"/>need to take care of in this recipe is to define our layout; in this case we need to use the <code class="literal">d3.layout.pack</code> layout.</p><div><pre class="programlisting">var pack = d3.layout.pack()
  .size([_r, _r])
  .value(function (d) {
    return d.size;
  });

var nodes = pack.nodes(_nodes);</pre></div><p>Now we set the size of the layout using the outer circle's radius and set the value to use the Flare package size, which in turn will determine each circle's size; hence, effectively making each circle's size proportional to the package size in our data feed. Once layout is created, we feed our data elements through its <code class="literal">nodes</code> function generating the layout data with the following structure:</p><div><img src="img/2162OS_09_11.jpg" alt="How it works..."/><div><p>Pack layout data</p></div></div><p>Circle rendering is done in <a id="id530" class="indexterm"/>the <code class="literal">renderCircle</code> function:</p><div><pre class="programlisting">function renderCircles(nodes) {
  var circles = _bodyG.selectAll("circle")
    .data(nodes);

  circles.enter().append("svg:circle");</pre></div><p>Then we simply <a id="id531" class="indexterm"/>bind the layout data and create the <code class="literal">svg:circle</code> elements for each node.</p><div><pre class="programlisting">  circles.transition()
    .attr("class", function (d) {
      return d.children ? "parent" : "child";
    })
    .attr("cx", function (d) {return d.x; })
    .attr("cy", function (d) {return d.y; })
    .attr("r", function (d) {return d.r; });</pre></div><p>For update, we set <code class="literal">cx</code>, <code class="literal">cy</code>, and <code class="literal">radius</code> to the value that the pack layout has calculated for us for each circle.</p><div><pre class="programlisting">  circles.exit().transition()
    .attr("r", 0)
    .remove();
}</pre></div><p>Finally when <a id="id532" class="indexterm"/>removing the circle, we reduce the size of the circle down to zero first, before removing them to generate a more smooth transition. Label rendering in this recipe is pretty straight forward with some help from the auto-hiding technique we introduced in this chapter, so we will not cover the function in detail here.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec200"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.layout.pack</code> offers several functions allowing customization. For more details, please check out its API documentation at <a class="ulink" href="https://github.com/mbostock/d3/wiki/Pack-Layout">https://github.com/mbostock/d3/wiki/Pack-Layout</a></li><li class="listitem" style="list-style-type: disc">The <em>Building a treemap</em> recipe for auto label hiding technique.</li><li class="listitem" style="list-style-type: disc">This recipe is inspired by Mike Bostock's pack layout example, which you can find at <a class="ulink" href="http://mbostock.github.io/d3/talk/20111018/pack.html">http://mbostock.github.io/d3/talk/20111018/pack.html</a>.</li></ul></div></div></div></body></html>