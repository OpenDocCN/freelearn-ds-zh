# 第二章：基本对象

学习 R 编程的第一步是熟悉基本 R 对象及其行为。在本章中，您将学习以下主题：

+   创建和子集原子向量（例如，数值向量、字符向量和逻辑向量）、矩阵、数组、列表和数据框。

+   定义和使用函数

> “存在的一切都是对象。发生的一切都是函数。” —— 约翰·查普曼*

例如，在统计分析中，我们经常将一组数据输入到线性回归模型中，并得到一组线性系数。

假设 R 中有不同类型的对象，当我们这样做时，在 R 中基本上发生的事情是，我们提供一个包含数据集的数据框对象，将其传递给线性模型函数，并得到一个包含回归结果属性的列表对象，最后从列表中提取一个数值向量，这是另一种类型的对象，用来表示线性系数。

每项任务都涉及各种不同类型的对象。每个对象都有不同的目标和行为。为了解决现实世界的问题，特别是用更优雅的代码和更少的步骤，理解基本对象的工作方式非常重要。更重要的是，对对象行为的更具体理解，让您有更多时间来解决您的问题，而不是在编写正确代码时被无数的小问题所困扰。

在以下章节中，我们将看到 R 中代表不同类型数据的基本对象，这些对象使得分析和可视化数据集变得容易。您将基本了解这些对象是如何工作的以及它们之间是如何相互作用的。

# 向量

向量是一组相同类型的原始值。它可以是一组数字、真/假值、文本或其他类型的值。它是所有 R 对象的基本构建块之一。

R 中有几种不同类型的向量。它们在存储的元素类型上彼此不同。在以下章节中，我们将看到最常用的向量类型，包括数值向量、逻辑向量和字符向量。

## 数值向量

数值向量是数值值的向量。一个标量数是最简单的数值向量。以下是一个示例：

```py
1.5
## [1] 1.5
```

数值向量是最常用的数据类型，是几乎所有数据分析的基础。在其他流行的编程语言中，有一些标量类型，如整数、双精度和字符串，这些标量类型是容器类型（如向量）的构建块。然而，在 R 中，没有正式的标量类型定义。标量数只是数值向量的一个特殊情况，它之所以特殊，仅仅是因为它的长度为 1。

当我们创建一个值时，自然会想到如何将其存储起来以供将来使用。为了存储值，我们可以使用 `<-` 将值赋给一个符号。换句话说，我们创建了一个名为 `x` 的值为 `1.5` 的变量：

```py
x <- 1.5
```

然后，值被赋给符号 `x`，从现在起我们可以使用 `x` 来表示这个值：

```py
x
## [1] 1.5
```

创建数值向量的方法有多种。我们可以调用 `numeric()` 来创建给定长度的零向量：

```py
numeric (10)
## [1] 0 0 0 0 0 0 0 0 0 0
```

我们也可以使用 `c()` 来组合几个向量，使其成为一个向量。最简单的情况是，例如，将几个单元素向量组合成一个多元素向量：

```py
c(1, 2, 3, 4, 5)
## [1] 1 2 3 4 5
```

我们还可以组合单元素向量和多元素向量，并得到一个与我们之前创建的具有相同元素的向量：

```py
c(1, 2, c(3, 4, 5))
## [1] 1 2 3 4 5
```

要创建一系列连续的整数，`:` 运算符可以轻松完成这个任务。

```py
1:5
## [1] 1 2 3 4 5
```

严格来说，前面的代码生成的是一个整数向量，而不是数值向量。在许多情况下，它们的区别并不重要。我们将在后面讨论这个话题。

生成数值序列的更通用方法是 `seq()`。例如，以下代码通过增量 2 生成从 1 到 10 的数值向量：

```py
seq(1, 10, 2)
## [1] 1 3 5 7 9
```

类似于 `seq()` 的函数有很多参数。我们可以通过提供所有参数来调用这样的函数，但在大多数情况下并不需要。大多数函数为某些参数提供了合理的默认值，这使得我们更容易调用它们。在这种情况下，我们只需要指定我们想要从其默认值修改的参数。

例如，我们可以通过指定 `length.out` 参数来创建一个从 `3` 开始长度为 `10` 的另一个数值向量：

```py
seq(3, length.out = 10)
## [1] 3 4 5 6 7 8 9 10 11 12
```

类似于上面的函数调用使用命名参数 `length.out`，这样其他参数保持默认值，只修改这个参数。

我们可以定义数值向量的方式有很多，但我们在使用 `:` 时应该始终小心，以下是一个示例：

```py
1 + 1:5
## [1] 2 3 4 5 6
```

如结果所示，`1 + 1:5` 并不表示从 `2` 到 `5` 的序列，而是从 `2` 到 `6`。这是因为 `:` 的优先级高于 `+`，导致首先计算 `1:5`，然后将 `1` 加到每个元素上，得到结果中看到的序列。我们将在后面讨论运算符的优先级。

## 逻辑向量

与数值向量不同，逻辑向量存储了一组 `TRUE` 或 `FALSE` 值。它们基本上是针对一组逻辑问题的“是”或“否”的回答。

最简单的逻辑向量就是 `TRUE` 和 `FALSE` 本身：

```py
TRUE
## [1] TRUE
```

获取逻辑向量的更常见方式是询问 R 对象的逻辑问题。例如，我们可以询问 R 是否 1 大于 2：

```py
1 > 2
## [1] FALSE
```

答案是肯定的，用 `TRUE` 表示。有时，写 `TRUE` 和 `FALSE` 有点啰嗦；因此，我们可以用 `T` 作为 `TRUE` 的缩写，用 `F` 作为 `FALSE` 的缩写。如果我们想同时进行多个比较，我们可以直接在问题中使用数值向量：

```py
c(1, 2) > 2
## [1] FALSE FALSE
```

R 将此表达式解释为 `c(1, 2)` 和 `2` 的逐元素比较。换句话说，它等同于 `c(1 > 2, 2 > 2)`。

只要较长向量的长度是较短向量长度的倍数，我们就可以比较两个多元素数值向量：

```py
c(1, 2) > c(2, 1)
## [1] FALSE TRUE
```

之前的代码等同于 `c(1 > 2, 2 > 1)`。为了演示不同长度的向量是如何比较的，请看以下示例：

```py
c(2, 3) > c(1, 2, -1, 3)
## [1] TRUE TRUE TRUE FALSE
```

这可能会让你有些困惑。计算机制会回收较短的向量，并像 `c(2 > 1, 3 > 2, 2 > -1, 3 > 3)` 一样工作。更具体地说，较短的向量将被回收以完成较长向量中每个元素的比较。

在 R 中，定义了几个逻辑二元运算符，例如 `==` 表示相等，`>` 表示大于，`>=` 表示大于等于，`<` 表示小于，以及 `<=` 表示小于等于。此外，R 还提供了一些其他附加的逻辑运算符，如 `%in%`，用于判断左侧向量中的每个元素是否包含在右侧向量中：

```py
1 %in% c(1, 2, 3)
## [1] TRUE
c(1, 4) %in% c(1, 2, 3)
## [1] TRUE FALSE
```

你可能会注意到，所有相等运算符都执行回收，但 `%in%` 不执行。相反，它总是通过迭代左边的向量来工作，就像前面的例子中的 `c(1 %in% c(1, 2, 3), 4 %in% c(1, 2, 3))`。

## 字符向量

字符向量是一组字符串。在这里，字符并不意味着在语言中字面上是一个单独的字母或符号，而是指像 `this is a string` 这样的字符串。双引号和单引号都可以用来创建字符向量，如下所示：

```py
"hello, world!"
## [1] "hello, world!"
'hello, world!'
## [1] "hello, world!"
```

我们还可以使用组合函数 `c()` 来构建一个多元素字符向量：

```py
c("Hello", "World")
## [1] "Hello" "World"
```

我们可以使用 `==` 来判断两个向量在对应位置上的值是否相等；这也适用于字符向量：

```py
c("Hello", "World") == c('Hello', 'World')
## [1] TRUE TRUE
```

字符向量相等，因为 `"` 和 `"` 都用于创建字符串，并且不影响其值：

```py
c("Hello", "World") == "Hello, World"
## [1] FALSE FALSE
```

之前的表达式返回 `FALSE`，因为 `Hello` 和 `World` 都不等于 `Hello, World`。两个引号之间的唯一区别在于创建包含引号的字符串时的行为。

如果你使用 `"` 创建一个包含 `"` 本身的字符串（一个单元素字符向量），你需要输入 `"` 来转义字符串中的 `"`，以防止解释器将字符串中的 `"` 视为字符串的结束引号。

以下示例演示了引号的转义。代码使用 `cat()` 打印给定的文本：

```py
cat("Is "You" a Chinese name?")
## Is "You" a Chinese name?
```

如果你觉得这不容易阅读，你可以很好地使用 `'` 来创建字符串，这可能更容易：

```py
cat('Is "You" a Chinese name?')
## Is "You" a Chinese name?
```

换句话说，`"` 允许在字符串中包含 `"` 而无需转义，而 `"` 允许在字符串中包含 `"` 而无需转义。

现在我们已经了解了创建数值向量、逻辑向量和字符向量的基本知识。实际上，在 R 中我们还有复数向量和原始向量。复数向量是复数值的向量，例如`c(1 + 2i, 2 + 3i)`。原始向量基本上存储原始二进制数据，以十六进制形式表示。这两种类型的向量使用得较少，但它们与我们已经覆盖的三种类型的向量共享许多行为。

在下一节中，你将学习几种访问向量一部分的方法。通过子集向量，你应该开始理解不同类型的向量如何相互关联。

## 子集向量

如果我们想要访问一些特定的条目或向量的一个子集，对向量进行子集操作意味着访问向量的一些特定条目或其子集。在本节中，我们将演示各种对向量进行子集操作的方法。

首先，我们创建一个简单的数值向量并将其赋值给`v1`：

```py
v1 <- c(1, 2, 3, 4)
```

每一行都获取`v1`的一个特定子集。

例如，我们可以获取第二个元素：

```py
v1[2]
## [1] 2
```

我们可以获取第二个到第四个元素：

```py
v1[2:4]
## [1] 2 3 4
```

我们可以获取除了第三个元素之外的所有元素：

```py
v1[-3]
## [1] 1 2 4
```

模式是清晰的——我们可以在向量后面的方括号中放入任何数值向量以提取相应的子集：

```py
a <- c(1, 3)v1[a]
## [1] 1 3
```

所有的前述示例都是通过位置进行子集操作，也就是说，我们通过指定元素的位置来获取向量的一个子集。使用负数将排除这些元素。需要注意的一点是，你不能同时使用正数和负数：

```py
v1[c(1, 2, -3)]
## Error in v1[c(1, 2, -3)]: only 0's may be mixed with negative subscripts
```

如果我们使用超出向量范围的索引来子集向量，会怎样呢？以下示例尝试从第三个元素到不存在的第六个元素获取`v1`的子集：

```py
v1[3:6]
## [1] 3 4 NA NA
```

如我们所见，不存在的位置最终以缺失值表示，用 NA 表示。在现实世界的数据中，缺失值很常见。好处是，所有与 NA 进行的算术计算也会得到 NA，以保证一致性。然而，另一方面，处理数据需要额外的努力，因为不能安全地假设数据中不包含缺失值。

另一种子集向量的方法是使用逻辑向量。我们可以提供一个等长的逻辑向量来决定每个条目是否应该被提取：

```py
v1[c(TRUE, FALSE, TRUE, FALSE)]
## [1] 1 3
```

除了子集之外，我们还可以像这样覆盖向量的一个特定子集：

```py
v1[2] <- 0
```

在这种情况下，`v1`变为以下形式：

```py
v1
## [1] 1 0 3 4
```

我们也可以同时覆盖不同位置上的多个元素：

```py
v1[2:4] <- c(0, 1, 3)
```

现在，`v1`变为以下形式：

```py
v1
## [1] 1 0 1 3
```

与子集类似，逻辑选择器也可以用于覆盖：

```py
v1[c(TRUE, FALSE, TRUE, FALSE)] <- c(3, 2)
```

如您所预期，`v1`变为以下形式：

```py
v1
## [1] 3 0 2 3
```

这个操作的用途之一是按照逻辑标准选择条目。例如，以下代码挑选出所有在`v1`中不大于`2`的元素：

```py
v1[v1 <= 2]
## [1] 0 2
```

更复杂的选择标准也适用。以下示例挑选出所有满足`x² - x + 1 > 0`的`v1`元素：

```py
v1[v1 ^ 2 - v1 + 1 >= 0]
## [1] 3 0 2 3
```

要将所有满足 `x <= 2` 的条目替换为 `0`，我们可以调用以下代码：

```py
v1[v1 <= 2] <- 0
```

如你所预期，`v1` 变成了以下内容：

```py
v1
## [1] 3 0 0 3
```

如果我们在一个不存在的条目上覆盖向量，向量将自动扩展，未分配的值作为缺失值 `NA`：

```py
v1[10] <- 8
v1
## [1] 3 0 0 3 NA NA NA NA NA 8
```

## 命名向量

命名向量不是与数值向量或逻辑向量平行的特定类型的向量。它是一个具有与元素对应的名称的向量。我们可以在创建向量时为其命名：

```py
x <- c(a = 1, b = 2, c = 3)
x
## a b c
## 1 2 3
```

然后，我们可以使用单值字符向量访问元素：

```py
x["a"]
## a
## 1
```

我们也可以使用字符向量获取多个元素：

```py
x[c("a", "c")]
## a c
## 1 3
```

如果字符向量有重复的元素，选择将导致选择重复的元素：

```py
x[c("a", "a", "c")]
## a a c
## 1 1 3
```

此外，对向量进行的所有其他操作也完全适用于命名向量。

我们可以使用 `names()` 函数获取向量的名称：

```py
names(x)
## [1] "a" "b" "c"
```

向量的名称不是固定的。我们可以通过将另一个字符向量赋给其名称来更改向量的名称。

```py
names(x) <- c("x", "y", "z")
x["z"]
## z
## 3
```

如果不再需要名称，我们可以简单地使用 NULL（一个表示未定义值的特殊对象）来移除向量的名称：

```py
names(x) <- NULL
x
## [1] 1 2 3
```

你可能会想知道当名称根本不存在时会发生什么。让我们用原始的 `x` 值进行实验：

```py
x <- c(a = 1, b = 2, c = 3)
x["d"]
## <NA>
## NA
```

根据直觉，访问一个不存在的元素应该会产生错误。然而，结果不是一个错误，而是一个包含单个缺失值的向量，并且具有缺失的名称：

```py
names(x["d"])
## [1] NA
```

如果你提供一个包含一些名称但其他名称不存在的字符向量，结果向量将保留选择向量的长度：

```py
x[c("a", "d")]
## a <NA>
## 1 NA
```

## 提取元素

虽然 `[]` 创建向量的子集，但 `[[]]` 从向量中提取一个元素。向量就像十盒糖果，`[]` 可以让你得到三盒糖果，但 `[[]]` 打开一盒并从中得到一颗糖果。

对于简单向量，使用 `[]` 和 `[[]]` 获取一个元素会产生相同的结果。然而，在某些情况下，它们有不同的行为。例如，使用单个条目对命名向量进行子集操作和从中提取元素将产生不同的结果：

```py
x <- c(a =  1, b = 2, c = 3)
x["a"]
## a
## 1
x[["a"]]
## [1] 1
```

糖果盒的比喻使理解更容易。`x["a"]` 参数给你标有 `"a"` 的糖果盒，而 `x[["a"]]` 给你标有 `"a"` 的盒子中的糖果。

由于 `[[]]` 只提取一个元素，因此它不适用于包含多个元素的向量：

```py
x[[c(1, 2)]]
## Error in x[[c(1, 2)]]: attempt to select more than one element
```

此外，它不适用于负整数，这意味着排除特定位置的元素：

```py
x[[-1]]
## Error in x[[-1]]: attempt to select more than one element
```

我们已经知道，使用不存在的位置或名称对向量进行子集操作会产生缺失值。然而，当我们使用超出范围的索引提取元素时，`[[]]` 简单地不起作用，与不存在的名称一起使用时也不起作用：

```py
x[["d"]]
## Error in x[["d"]]: subscript out of bounds
```

对于许多初学者来说，看到代码中同时使用 `[[]]` 和 `[]` 可能会感到困惑，并且很容易误用它们。只需记住糖果盒的比喻。

## 识别向量的类别

有时候在采取行动之前我们需要知道我们正在处理哪种类型的向量。`class()` 函数告诉我们任何 R 对象的类别：

```py
class(c(1, 2, 3))
## [1] "numeric"
class(c(TRUE, TRUE, FALSE))
## [1] "logical"
class(c("Hello", "World"))
## [1] "character"
```

如果我们需要确保一个对象确实是一个特定类别的向量，我们可以使用 `is.numeric`、`is.logical`、`is.character` 和一些具有类似名称的其他函数：

```py
is.numeric(c(1, 2, 3))
## [1] TRUE
is.numeric(c(TRUE, TRUE, FALSE))
## [1] FALSE
is.numeric(c("Hello", "World"))
## [1] FALSE
```

## 向量转换

不同类别的向量可以被强制转换为特定类别的向量。例如，一些数据是数字的字符串表示，如 `1` 和 `20`。如果我们保留这些字符串不变，我们就无法用它们进行数值计算。幸运的是，这两个字符串可以被转换为数值向量。这将使 R 将它们视为数字而不是字符串，这样我们就可以用它们进行数学运算。

为了演示一个典型的转换，我们首先创建一个字符向量：

```py
strings <- c("1", "2", "3")
class(strings)
## [1] "character"
```

正如我提到的，字符串不能直接用于数学运算：

```py
strings + 10
## Error in strings + 10: non-numeric argument to binary operator
```

我们可以使用 `as.numeric()` 将字符向量转换为数值向量：

```py
numbers <- as.numeric(strings)
numbers
## [1] 1 2 3
class(numbers)
## [1] "numeric"
```

现在，我们可以用数字进行数学运算：

```py
numbers + 10
## [1] 11 12 13
```

与检查给定对象类别的 `is.*` 函数（例如，`is.numeric`、`is.logical` 和 `is.character`）类似，我们可以使用 `as.*` 函数族将向量从其原始类别转换为另一个类别：

```py
as.numeric(c("1", "2", "3", "a"))
## Warning: NAs introduced by coercion
## [1] 1 2 3 NA
as.logical(c(-1, 0, 1, 2))
## [1] TRUE FALSE TRUE TRUE
as.character(c(1, 2, 3))
## [1] "1" "2" "3"
as.character(c(TRUE, FALSE))
## [1] "TRUE" "FALSE"
```

看起来每种类型的向量都可以以某种方式转换为所有其他类型。然而，转换遵循一套规则。

上述代码块中的第一行尝试将字符向量转换为数值向量，就像我们在上一个例子中所做的那样。显然，最后一个元素 `a` 无法转换为数字。转换除了最后一个元素之外都已完成，因此产生了缺失值。

对于将数值向量转换为逻辑向量，规则是只有 `0` 对应于 `FALSE`，所有非零数字都将产生 `TRUE`。

每种类型的向量都可以转换为字符向量，因为一切都有字符表示。然而，如果数值向量或逻辑向量被强制转换为字符向量，除非转换回，否则它不能直接参与与其他数值或逻辑向量的算术运算。这就是为什么以下代码不起作用，正如我刚才提到的：

```py
c(2, 3) + as.character(c(1, 2))
## Error in c(2, 3) + as.character(c(1, 2)): non-numeric argument to binary operator
```

从前面的例子中，我强调虽然 R 不强制类型规则，但这并不意味着 R 足够智能，可以自动执行你想要的精确操作。在大多数情况下，最好确保在计算中向量的类型是正确的；否则，可能会发生意外的错误。换句话说，只有当你得到正确的数据对象类型时，你才能进行正确的数学运算。

## 数值向量的算术运算符

数值向量的算术运算非常简单。它们基本上遵循两个规则：逐元素计算和回收较短的向量。以下示例演示了运算符与数值向量一起工作的行为：

```py
c(1, 2, 3, 4) + 2
## [1] 3 4 5 6
c(1, 2, 3) - c(2, 3, 4)
## [1] -1 -1 -1
c(1, 2, 3) * c(2, 3, 4)
## [1] 2 6 12
c(1, 2, 3) / c(2, 3, 4)
## [1] 0.5000000 0.6666667 0.7500000
c(1, 2, 3) ^ 2
## [1] 1 4 9
c(1, 2, 3) ^ c(2, 3, 4)
## [1] 1 8 81
c(1, 2, 3, 14) %% 2
## [1] 1 0 1 0
```

尽管向量可以有名称，但操作并不与相应的名称一起使用。只有左侧向量的名称将保留，而右侧向量的名称将被忽略：

```py
c(a = 1, b = 2, c = 3) + c(b = 2, c = 3, d = 4)
## a b c
## 3 5 7
c(a = 1, b = 2, 3) + c(b = 2, c = 3, d = 4)
## a b
## 3 5 7
```

我们看到了数值向量、逻辑向量和字符向量的基本行为。它们是最常用的数据结构，是各种其他有用对象的构建块之一。其中之一是矩阵，它在统计和计量经济学理论的制定中得到了广泛的应用，并且在表示二维数据和解决线性系统中非常有用。在下一章中，我们将看到如何在 R 中创建矩阵以及它与向量的深厚联系。

# 矩阵

矩阵是一个在二维中表示和可访问的向量。因此，适用于向量的东西很可能也适用于矩阵。例如，每种类型的向量（例如，数值向量或逻辑向量）都有其矩阵版本，即存在数值矩阵、逻辑矩阵等等。

## 创建矩阵

我们可以通过设置其两个维度之一来使用 `matrix()` 从向量创建矩阵：

```py
matrix(c(1, 2, 3, 2, 3, 4, 3, 4, 5), ncol = 3)
##      [,1] [,2] [,3]
## [1,]   1    2    3
## [2,]   2    3    4
## [3,]   3    4    5
```

通过指定`ncol = 3`，我们的意思是提供的向量应被视为一个有 3 列（和自动的 3 行）的矩阵。你可能觉得原始向量并不像它的表示那样直接。为了使代码更易于用户使用，我们可以将向量写成多行：

```py
matrix(c(1, 2, 3,  4, 5, 6,  7, 8, 9), nrow = 3, byrow = FALSE)
##     [,1] [,2] [,3]
## [1,]  1    4    7
## [2,]  2    5    8
## [3,]  3    6    9
matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = TRUE)
##      [,1] [,2] [,3]
## [1,]   1    2    3
## [2,]   4    5    6
## [3,]   7    8    9
```

通常，我们可能需要创建一个对角矩阵。在这里，`diag()` 是完成此操作最方便的方法：

```py
diag(1, nrow = 5)
##      [,1] [,2] [,3] [,4] [,5]
## [1,]   1    0    0    0    0
## [2,]   0    1    0    0    0
## [3,]   0    0    1    0    0
## [4,]   0    0    0    1    0
## [5,]   0    0    0    0    1
```

## 命名行和列

默认情况下，创建矩阵不会自动为其行和列命名。有时，当不同的行和列有不同的含义时，这样做是有用且直接的。在创建矩阵时，我们可以给出行名称和/或列名称：

```py
matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = TRUE, dimnames = list(c("r1", "r2", "r3"), c("c1", "c2", "c3")))
##    c1 c2 c3
## r1  1  2  3
## r2  4  5  6
## r3  7  8  9
```

或者，我们可以在矩阵创建后使用行名称和/或列名称：

```py
m1 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3)
rownames(m1) <- c("r1", "r2", "r3")
colnames(m1) <- c("c1", "c2", "c3")
```

这里，我们遇到了两个新事物：一个列表和一种函数类型，例如 `rownames(x) <-`。我们将在本章后面讨论它们。

## 矩阵子集

正如我们处理向量一样，我们不仅需要创建矩阵，还需要从矩阵中提取数据。这被称为**矩阵子集**。

注意，矩阵是一个在二维中表示和可访问的向量；我们不仅以二维的方式查看矩阵，还使用二维访问器 `[,]` 来访问它，这与用于子集向量的单维访问器 `[]` 非常相似。

要使用它，我们可以为每个维度提供两个向量以确定矩阵的子集。方括号中的第一个参数是行选择器，第二个是列选择器。正如我们在子集向量中所尝试的那样，我们可以在两个维度中使用数值向量、逻辑向量和字符向量。

以下代码演示了以下矩阵的多种子集方法：

```py
m1
##    c1 c2 c3
## r1  1  4  7
## r2  2  5  8
## r3  3  6  9
```

我们可以只提取第一行和第二列中的一个元素：

```py
m1[1, 2]
## [1] 4
```

我们可以使用一系列位置来对其进行子集操作：

```py
m1[1:2, 2:3]
##    c2 c3
## r1  4  7
## r2  5  8
```

如果一个维度留空，则将选择该维度中的所有值：

```py
m1[1,]
## c1 c2 c3 
## 1  4  7
m1[,2]
## r1 r2 r3 
## 4  5  6
m1[1:2,]
##    c1 c2 c3
## r1  1  4  7
## r2  2  5  8
m1[, 2:3]
##    c2 c3
## r1  4  7
## r2  5  8
## r3  6  9
```

负数在子集矩阵中排除位置，这与处理向量完全相同：

```py
m1[-1,]
##    c1 c2 c3
## r2 2  5  8
## r3 3  6  9
m1[,-2]
##    c1 c3
## r1  1  7
## r2  2  8
## r3  3  9
```

注意，矩阵有行名和列名，我们可以使用字符向量来对其进行子集操作：

```py
m1[c("r1", "r3"), c("c1", "c3")]
##    c1 c3
## r1  1  7
## r3  3  9
```

再次注意，矩阵是一个在二维中表示和可访问的向量；然而，本质上它仍然是一个向量。这允许我们使用一维访问器来对矩阵进行子集操作：

```py
m1[1]
## [1] 1
m1[9]
## [1] 9
m1[3:7]
## [1] 3 4 5 6 7
```

由于向量只包含相同类型的条目，矩阵也是如此。因此，它们的操作非常相似。如果你输入一个不等式，它将返回另一个大小相同的逻辑矩阵：

```py
m1 > 3
##       c1   c2   c3
## r1 FALSE TRUE TRUE
## r2 FALSE TRUE TRUE
## r3 FALSE TRUE TRUE
```

我们可以使用大小相等的逻辑矩阵进行子集操作，就像它是向量一样：

```py
m1[m1 > 3]
## [1] 4 5 6 7 8 9
```

## 使用矩阵运算符

向量的所有算术运算符也可以与矩阵一起使用，就像它们是向量一样。这些运算符逐元素执行计算，除了矩阵特有的运算符，如矩阵乘法 `%*%`：

```py
m1 + m1
##    c1 c2 c3
## r1  2  8 14
## r2  4 10 16
## r3  6 12 18
m1 - 2 * m1
##    c1 c2 c3
## r1 -1 -4 -7
## r2 -2 -5 -8
## r3 -3 -6 -9
m1 * m1
##   c1 c2 c3
## r1 1 16 49
## r2 4 25 64
## r3 9 36 81
m1 / m1
##    c1 c2 c3
## r1 1  1  1
## r2 1  1  1
## r3 1  1  1
m1 ^ 2
##    c1 c2 c3
## r1  1 16 49
## r2  4 25 64
## r3  9 36 81
m1 %*% m1
##     c1 c2 c3
## r1  30 66 102
## r2  36 81 126
## r3  42 96 150
```

我们还可以使用 `t()` 来转置矩阵：

```py
t(m1)
##    r1 r2 r3
## c1 1  2  3
## c2 4  5  6
## c3 7  8  9
```

向量和矩阵对于许多用例来说已经足够了。然而，一些特定的问题需要更高维度的数据结构。在下一节中，我们将简要介绍数组，并展示这些数据结构如何具有相似的行为。

# 数组

数组是矩阵在维度数量上的自然扩展。更具体地说，数组是一个在给定维度中表示和可访问的向量（通常是超过两个维度）。

如果你已经熟悉向量和矩阵，你不会对数组的行为感到惊讶。

## 创建一个数组

要创建一个数组，我们通过提供数据向量、数据在不同维度中的排列方式以及有时这些维度的行和列的名称来调用 `array()`：

假设我们有一些数据（从 0 到 9 的 10 个整数）并且我们需要在三维中排列它们：第一维为 1，第二维为 5，第三维为 2：

```py
a1 <- array(c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), dim = c(1, 5, 2))
a1
## , , 1
## 
##     [,1] [,2] [,3] [,4] [,5]
## [1,]  0    1    2    3    4
## 
## , , 2
## 
##     [,1] [,2] [,3] [,4] [,5]
## [1,]  5    6    7    8    9
```

通过观察它们周围的符号，我们可以清楚地看到如何访问这些条目。

此外，我们可以在创建数组时为这些维度添加名称：

```py
a1 <- array(c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), dim = c(1, 5, 2), dimnames = list(c("r1"), c("c1", "c2", "c3", "c4", "c5"), c("k1", "k2")))
a1
## , , k1
## 
##    c1 c2 c3 c4 c5
## r1  0  1  2  3  4
## 
## , , k2
## 
##    c1 c2 c3 c4 c5
## r1  5  6  7  8  9
```

或者，对于已经创建的数组，我们可以调用 `dimnames(x) <-` 来通过提供几个字符向量的列表来为每个维度设置名称：

```py
a0 <- array(c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), dim = c(1, 5, 2))
dimnames(a0) <- list(c("r1"), c("c1", "c2", "c3", "c4", "c5"), c("k1", "k2"))
a0
## , , k1
## 
##   c1 c2 c3 c4 c5
## r1 0  1  2  3  4
## 
## , , k2
## 
##   c1 c2 c3 c4 c5
## r1 5  6  7  8  9
```

## 数组的子集

数组的子集原则与矩阵的子集原则完全相同。在这里，我们可以为每个维度提供一个向量来提取数组的子集：

```py
a1[1,,]
##    k1 k2
## c1  0 5
## c2  1 6
## c3  2 7
## c4  3 8
## c5  4 9
a1[, 2,]
## k1 k2 
## 1 6
a1[,,1]
## c1 c2 c3 c4 c5 
## 0  1  2  3  4
a1[1, 1, 1]
## [1] 0
a1[1, 2:4, 1:2]
##    k1 k2
## c2 1  6
## c3 2  7
## c4 3  8
a1[c("r1"), c("c1", "c3"), "k1"]
## c1 c3 
## 0  2
```

正如你可能注意到的，原子向量、矩阵和数组几乎共享相同的行为集合。它们共享的一个基本共同特征是它们都是**同质数据类型**，即它们存储的元素类型必须相同。然而，R 中也有**异质数据类型**，即它们可以存储不同类型的元素，这使得它们更加灵活，但它们在内存效率和操作速度上较低。

# 列表

列表是一种通用的向量，允许包含不同类型的对象，甚至其他列表。

它的灵活性使其非常有用。例如，R 中线性模型拟合的结果基本上是一个包含线性回归丰富结果的列表对象，如线性系数（数值向量）、残差（数值向量）、QR 分解（包含矩阵和其他对象的列表）等等。

不需要每次调用不同的函数就能提取信息非常方便，因为这些结果都打包在一个列表中。

## 创建列表

根据函数名，我们可以使用 `list()` 创建列表。不同类型的对象可以放入一个列表中。例如，以下代码创建了一个包含单个元素数值向量、两个条目的逻辑向量和三个值的字符向量列表：

```py
l0 <- list(1, c(TRUE, FALSE), c("a", "b", "c"))
l0
## [[1]]
## [1] 1
## 
## [[2]]
## [1] TRUE FALSE
## 
## [[3]]
## [1] "a" "b" "c"
```

我们可以使用命名参数为每个列表条目分配名称：

```py
l1 <- list(x = 1, y = c(TRUE, FALSE), z = c("a", "b", "c"))
l1
## $x
## [1] 1
## 
## $y
## [1] TRUE FALSE
## 
## $z
## [1] "a" "b" "c"
```

## 从列表中提取元素

访问列表的元素有多种方式。最常见的方式是使用美元符号 `$` 通过名称提取列表元素的值：

```py
l1 <- list(x = 1, y = c(TRUE, FALSE), z = c("a", "b", "c"), m = NULL)
l1$x
## [1] 1
l1$y
## [1] TRUE FALSE
l1$z
## [1] "a" "b" "c"
l1$m
## NULL
```

注意，如果我们请求一个不存在的元素 `m`，将返回 `NULL`。

或者，我们可以使用双方括号中的数字来提取第 n 个列表成员的值。例如，我们可以提取列表 `l1` 的第二个成员的值，如下所示：

```py
l1[[2]]
## [1] TRUE FALSE
```

使用相同的符号，我们也可以提供一个名称来提取具有该名称的列表成员的值，就像使用美元符号一样：

```py
l1[["y"]]
## [1] TRUE FALSE
```

使用双方括号从列表中提取值可以更加灵活，因为有时在计算之前我们可能不知道需要提取哪个成员：

```py
member <- "z" # you can dynamically determine which member to extract
l1[[member]]
## [1] "a" "b" "c"
```

这里，我们将一个运行时评估的单元素字符向量提供给方括号。但为什么在这里要使用双括号？单括号在哪里？

## 列表的子集化

在许多情况下，我们需要从列表中提取多个元素。这些多个成员也作为原始列表的子集构建一个列表。

要对列表进行子集化，我们可以使用单方括号符号，就像我们用于向量和矩阵一样。我们可以从列表中提取一些元素并将它们放入一个新的列表中。

符号与向量操作的方式非常一致。我们可以通过字符向量使用名称提取列表元素，或通过数值向量使用位置提取，或通过逻辑向量使用标准提取：

```py
l1["x"]
## $x
## [1] 1
l1[c("x", "y")]
## $x
## [1] 1
## 
## $y
## [1] TRUE FALSE
l1[1]
## $x
## [1] 1
l1[c(1, 2)]
## $x
## [1] 1
## 
## $y
## [1] TRUE FALSE
l1[c(TRUE, FALSE, TRUE)]
## $x
## [1] 1
## 
## $z
## [1] "a" "b" "c"
```

总结来说，我们可以这样表述：`[[` 表示从向量或列表中提取一个元素，而 `[` 表示对向量或列表进行子集操作。对向量进行子集操作将得到一个新的向量。同样，对列表进行子集操作将得到一个新的列表。

## 命名列表

无论列表成员在创建列表时是否已经具有名称，我们都可以通过简单地命名一个向量来命名或重命名列表成员：

```py
names(l1) <- c("A","B","C")
l1
## $A
## [1] 1
## 
## $B
## [1] TRUE FALSE
## 
## $C
## [1] "a" "b" "c"
```

要移除它们的名称，我们将 `l1` 的名称替换为 `NULL`：

```py
names(l1) <- NULL
l1
## [[1]]
## [1] 1
## 
## [[2]]
## [1] TRUE FALSE
## 
## [[3]]
## [1] "a" "b" "c"
```

一旦移除了列表成员的名称，我们就不能再通过名称访问列表成员，而只能通过位置和逻辑条件访问。

## 设置值

设置列表中的值与处理向量一样简单：

```py
l1 <- list(x = 1, y = c(TRUE, FALSE), z = c("a", "b", "c"))
l1$x <- 0
```

如果我们给一个不存在的成员赋值，我们将添加一个新成员到列表中，其名称或位置由给定值决定：

```py
l1$m <- 4
l1
## $x
## [1] 0
## 
## $y
## [1] TRUE FALSE
## 
## $z
## [1] "a" "b" "c"
## 
## $m
## [1] 4
```

此外，我们还可以同时设置多个值：

```py
l1[c("y", "z")] <- list(y = "new value for y", z = c(1, 2))
l1
## $x
## [1] 0
## 
## $y
## [1] "new value for y"
## 
## $z
## [1] 1 2
## 
## $m
## [1] 4
```

如果我们需要从列表中删除一些成员，只需将它们的值赋为 `NULL`：

```py
l1$x <- NULL
l1
## $y
## [1] "new value for y"
## 
## $z
## [1] 1 2
## 
## $m
## [1] 4
```

我们可以从列表中一次性删除多个成员：

```py
l1[c("z", "m")] <- NULL
l1
## $y
## [1] "new value for y"
```

## 其他函数

R 中的许多函数都与列表相关。例如，如果我们不确定一个对象是否是列表，我们可以调用 `is.list()` 来查询：

```py
l2 <- list(a = c(1, 2, 3), b = c("x", "y", "z", "w"))
is.list(l2)
## [1] TRUE
is.list(l2$a)
## [1] FALSE
```

在这里，`l2` 是一个列表，而 `butl2$a` 是一个数值向量，而不是列表。

我们还可以使用 `as.list()` 将向量转换为列表：

```py
l3 <- as.list(c(a = 1, b =2, c = 3))
l3
## $a
## [1] 1
## 
## $b
## [1] 2
## 
## $c
## [1] 3
```

通过调用 `unlist` 将列表强制转换为向量也很容易，它基本上将所有列表成员转换为兼容类型的向量：

```py
l4 <- list(a = 1, b = 2, c = 3)
unlist(l4)
## a b c 
## 1 2 3
```

如果我们将混合数字和文本的列表进行反序列化，所有成员都将转换为它们各自可以转换到的最接近的类型：

```py
l4 <- list(a = 1, b = 2, c = "hello")
unlist(l4)
## a b c 
## "1" "2" "hello"
```

在这里，`l4$a` 和 `l4$b` 是数字，可以转换为字符；然而，`butl4$c` 是字符向量，不能转换为数值。因此，它们与所有元素兼容的最接近的类型是字符向量。

# 数据框

数据框表示具有行数和列数的数据集。它看起来像矩阵，但其列不一定具有相同的类型。这与数据集最常见的格式一致：每一行，或数据记录，由多个不同类型的列描述。

下表是一个可以完全由数据框表征的示例。

| **姓名** | **性别** | **年龄** | **专业** |
| --- | --- | --- | --- |
| Ken | 男性 | 24 | 金融 |
| Ashley | 女性 | 25 | 统计学 |
| Jennifer | 女性 | 23 | 计算机科学 |

## 创建数据框

要创建数据框，我们可以调用 `data.frame()` 并通过相应类型的向量提供每列的数据：

```py
persons <- data.frame(Name = c("Ken", "Ashley", "Jennifer"),
  Gender = c("Male", "Female", "Female"),
  Age = c(24, 25, 23),
  Major = c("Finance", "Statistics", "Computer Science"))
persons
##   Name     Gender  Age  Major
## 1 Ken      Male    24   Finance
## 2 Ashley   Female  25   Statistics
## 3 Jennifer Female  23   Computer Science
```

注意，创建数据框与创建列表的过程完全相同。这是因为，本质上，数据框是一个列表，其中每个元素都是一个向量，代表一个表格列，并且具有相同数量的元素。

除了从原始数据创建数据框外，我们还可以通过直接调用 `data.frame` 或 `as.data.frame` 来从列表创建数据框：

```py
l1 <- list(x = c(1, 2, 3), y = c("a", "b", "c"))
data.frame(l1)
##   x y
## 1 1 a
## 2 2 b
## 3 3 c
as.data.frame(l1)
##   x y
## 1 1 a
## 2 2 b
## 3 3 c
```

我们也可以使用相同的方法从一个矩阵创建数据框：

```py
m1 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = FALSE)
data.frame(m1)
##   X1 X2 X3
## 1 1  4  7
## 2 2  5  8
## 3 3  6  9
as.data.frame(m1)
##   V1 V2 V3
## 1  1  4  7
## 2  2  5  8
## 3  3  6  9
```

注意，转换还会自动将列名分配给新的数据框。实际上，正如你可能验证的那样，如果矩阵已经具有列名或行名，它们将在转换中保留。

## 命名行和列

由于数据框是一个列表，但看起来也像矩阵，因此访问这两种类型对象的两种方法都适用于数据框：

```py
df1 <- data.frame(id = 1:5, x = c(0, 2, 1, -1, -3), y = c(0.5, 0.2, 0.1, 0.5, 0.9))
df1
##   id  x   y
## 1  1  0  0.5
## 2  2  2  0.2
## 3  3  1  0.1
## 4  4 -1  0.5
## 5  5 -3  0.9
```

我们可以像处理矩阵一样重命名列和行：

```py
colnames(df1) <- c("id", "level", "score")
rownames(df1) <- letters[1:5]
df1
##    id level score
## a   1    0    0.5
## b   2    2    0.2
## c   3    1    0.1
## d   4   -1    0.5
## e   5   -3    0.9
```

## 数据框的子集操作

由于数据框是列向量类似矩阵的列表，我们可以使用这两组符号来访问数据框中的元素和子集。

### 将数据框作为列表进行子集操作

如果我们想将数据框视为向量的列表，我们可以使用列表符号来提取值或进行子集操作。

例如，我们可以使用 `$` 通过名称提取一列的值，或者使用 `[[` 通过位置进行操作：

```py
df1$id
## [1] 1 2 3 4 5
df1[[1]]
## [1] 1 2 3 4 5
```

列表子集完美适用于数据框，并产生一个新的数据框。子集操作符 (`[`) 允许我们使用数值向量通过位置提取列，使用字符向量通过名称提取列，或使用逻辑向量通过 `TRUE` 和 `FALSE` 选择提取列：

```py
df1[1]
##  id
## a 1
## b 2
## c 3
## d 4
## e 5
df1[1:2]
##  id level
## a 1  0
## b 2  2
## c 3  1
## d 4 -1
## e 5 -3
df1["level"]
##  level
## a  0
## b  2
## c  1
## d -1
## e -3
df1[c("id", "score")]
##  id score
## a 1  0.5
## b 2  0.2
## c 3  0.1
## d 4  0.5
## e 5  0.9
df1[c(TRUE, FALSE, TRUE)]
##   id score
## a 1  0.5
## b 2  0.2
## c 3  0.1
## d 4  0.5
## e 5  0.9
```

### 将数据框作为矩阵进行子集操作

然而，列表符号不支持行选择。相比之下，矩阵符号提供了更多的灵活性。如果我们将数据框视为矩阵，二维访问器使我们能够轻松访问子集的条目，这支持列选择和行选择。

换句话说，我们可以使用 `[row, column]` 符号通过指定行选择器和列选择器来子集数据框，这些选择器可以是数值向量、字符向量或逻辑向量。

例如，我们可以指定列选择器：

```py
df1[, "level"]
## [1] 0 2 1 -1 -3
df1[, c("id", "level")]
##  id level
## a 1  0
## b 2  2
## c 3  1
## d 4 -1
## e 5 -3
df1[, 1:2]
##  id level
## a 1  0
## b 2  2
## c 3  1
## d 4 -1
## e 5 -3
```

或者，我们可以指定行选择器：

```py
df1[1:4,]
##   id level score
## a  1   0    0.5
## b  2   2    0.2
## c  3   1    0.1
## d  4  -1    0.5
df1[c("c", "e"),]
##   id level score
## c  3   1    0.1
## e  5  -3    0.9
```

我们甚至可以同时指定两个选择器：

```py
df1[1:4, "id"]
## [1] 1 2 3 4
df1[1:3, c("id", "score")]
##   id score
## a  1  0.5
## b  2  0.2
## c  3  0.1
```

注意，矩阵符号会自动简化输出。也就是说，如果只选择一列，结果将不会是数据框，而是该列的值。为了始终将结果保持为数据框，即使它只有一列，我们也可以同时使用这两种符号：

```py
df1[1:4,]["id"]
##   id
## a 1
## b 2
## c 3
## d 4
```

在这里，第一组括号将数据框作为矩阵子集，选择前四行和所有列。第二组括号将结果数据框作为列表子集，只选择 `id` 列，从而得到一个数据框。

另一种方法是指定 `drop = FALSE` 以避免简化结果：

```py
df1[1:4, "id", drop = FALSE]
##   id
## a 1
## b 2
## c 3
## d 4
```

如果你期望数据框子集的输出始终是数据框，你应该始终设置 `drop = FALSE`；否则，如果假设你会得到数据框但实际上得到向量，一些边缘情况（如用户输入只选择一列）可能会导致意外的行为。

### 数据过滤

以下代码通过 `criterionscore >= 0.5` 过滤 `df1` 的行，并选择 `id` 和 `level` 列：

```py
df1$score >= 0.5
## [1] TRUE FALSE FALSE TRUE TRUE
df1[df1$score >= 0.5, c("id", "level")]
##   id level
## a  1   0
## d  4  -1
## e  5  -3
```

以下代码通过一个标准过滤`df1`的行，该标准是行名必须是`a`、`d`或`e`之一，并选择`id`和`score`列：

```py
rownames(df1) %in% c("a", "d", "e")
## [1] TRUE FALSE FALSE TRUE TRUE
df1[rownames(df1) %in% c("a", "d", "e"), c("id", "score")]
##   id score
## a  1  0.5
## d  4  0.5
## e  5  0.9
```

这两个例子基本上都使用矩阵表示法通过逻辑向量选择行，通过字符向量选择列。

## 设置值

设置数据框子集的值允许同时使用列表和矩阵的方法。

### 将值作为列表设置

我们可以使用`$`和`<-`一起给列表成员赋新值：

```py
df1$score <- c(0.6, 0.3, 0.2, 0.4, 0.8)
df1
##   id level score
## a 1    0    0.6
## b 2    2    0.3
## c 3    1    0.2
## d 4   -1    0.4
## e 5   -3    0.8
```

另外，`[`也可以使用，并且它还允许在一个表达式中进行多个更改，而`[[`只能一次修改一列：

```py
df1["score"] <- c(0.8, 0.5, 0.2, 0.4, 0.8)
df1
##   id level score
## a 1   0     0.8
## b 2   2     0.5
## c 3   1     0.2
## d 4  -1     0.4
## e 5  -3     0.8
df1[["score"]] <- c(0.4, 0.5, 0.2, 0.8, 0.4)
df1
##   id level score
## a 1   0     0.4
## b 2   2     0.5
## c 3   1     0.2
## d 4  -1     0.8
## e 5  -3     0.4
df1[c("level", "score")] <- list(level = c(1, 2, 1, 0, 0), score = c(0.1, 0.2, 0.3, 0.4, 0.5))
df1
##   id level score
## a 1    1    0.1
## b 2    2    0.2
## c 3    1    0.3
## d 4    0    0.4
## e 5    0    0.5
```

### 将值作为矩阵设置

使用列表表示法设置数据框的值与子集操作存在相同的问题——我们只能访问列。如果我们需要更灵活地设置值，我们可以使用矩阵表示法：

```py
df1[1:3, "level"] <- c(-1, 0, 1)
df1
##   id level score
## a 1   -1   0.1
## b 2   0    0.2
## c 3   1    0.3
## d 4   0    0.4
## e 5   0    0.5
df1[1:2, c("level", "score")] <- list(level = c(0, 0), score = c(0.9, 1.0))
df1
##   id level score
## a 1   0    0.9
## b 2   0    1.0
## c 3   1    0.3
## d 4   0    0.4
## e 5   0    0.5
```

## 因子

注意一点是，数据框的默认行为试图更有效地使用内存。有时，这种行为可能会默默地导致意外的问题。

例如，当我们通过提供一个字符向量作为列来创建数据框时，它将默认将该字符向量转换为因子，该因子只存储一次相同的值，这样重复就不会占用太多内存。实际上，因子本质上是一个整数向量，它有一个预先指定的可能值集合，称为级别，用于表示有限可能性的值。

我们可以通过在最初创建的`persons`数据框上调用`str()`来验证这一点：

```py
str(persons)
## 'data.frame': 3 obs. of 4 variables:
## $ Name : Factor w/ 3 levels "Ashley","Jennifer",..: 3 1 2
## $ Gender: Factor w/ 2 levels "Female","Male": 2 1 1
## $ Age : num 24 25 23
## $ Major : Factor w/ 3 levels "Computer Science",..: 2 3 1
```

我们可以清楚地发现`Name`、`Gender`和`Major`不是字符向量，而是因子对象。`Gender`用因子表示是合理的，因为它可能只能是`Female`或`Male`，所以使用两个整数来表示这两个值比使用字符向量存储所有值（无论是否重复）更有效率。

然而，这可能会对其他列（不仅限于具有几个可能值的列）引起问题。例如，如果我们想在`persons`中设置一个名字：

```py
persons[1, "Name"] <- "John"
## Warning in `[<-.factor`(`*tmp*`, iseq, value = "John"): invalid factor
## level, NA generated
persons
##    Name    Gender Age  Major
## 1 <NA>     Male   24   Finance
## 2 Ashley   Female 25   Statistics
## 3 Jennifer Female 23   Computer Science
```

出现了一个警告信息。这是因为在我们最初定义数据框时，`Name`字典中没有名为`John`的单词，因此我们无法将第一个人的名字设置为这样一个不存在的值。当我们设置任何`Gender`为`Unknown`时，也会发生同样的事情。原因完全相同：当我们从字符向量创建列时，该列默认将是一个因子，其值必须来自从该字符向量中唯一值创建的字典。

这种行为有时非常令人烦恼，实际上并没有多大帮助，尤其是在今天内存便宜的情况下。避免这种行为的简单方法是在使用`data.frame()`创建数据框时设置`stringsAsFactors = FALSE`：

```py
persons <- data.frame(Name = c("Ken", "Ashley", "Jennifer"),
  Gender = factor(c("Male", "Female", "Female")),
  Age = c(24, 25, 23),
  Major = c("Finance", "Statistics", "Computer Science"),
  stringsAsFactors = FALSE)
str(persons)
## 'data.frame': 3 obs. of 4 variables:
## $ Name : chr "Ken" "Ashley" "Jennifer"
## $ Gender: Factor w/ 2 levels "Female","Male": 2 1 1
## $ Age : num 24 25 23
## $ Major : chr "Finance" "Statistics" "Computer Science"
```

如果我们真的想让因子对象发挥作用，我们可以在特定的列中显式调用`factor()`，就像我们之前在`Gender`列上所做的那样。

## 适用于数据框的有用函数

对于数据框，有许多有用的函数。在这里，我们只介绍一些但最常用的函数。

`summary()`函数通过生成一个显示每列汇总统计信息的表格与数据框一起工作：

```py
summary(persons)
## Name Gender Age Major 
## Length:3 Female:2 Min. :23.0 Length:3 
## Class :character Male :1 1st Qu.:23.5 Class :character 
## Mode :character Median :24.0 Mode :character 
## Mean :24.0 
## 3rd Qu.:24.5 
## Max. :25.0
```

对于因子`Gender`，汇总计算每个值或级别的行数。对于数值向量，汇总显示数字的重要分位数。对于其他类型的列，它显示它们的长度、类别和模式。另一个常见的需求是通过行或列将多个数据框绑定在一起。为此，我们可以使用`rbind()`和`cbind()`，正如它们的名称所暗示的，分别执行行绑定和列绑定。

如果我们想向数据框中添加一些行，在这种情况下，添加一个人的新记录，我们可以使用`rbind()`：

```py
rbind(persons, data.frame(Name = "John", Gender = "Male", Age = 25, Major = "Statistics"))
##   Name     Gender Age Major
## 1 Ken      Male    24 Finance
## 2 Ashley   Female  25 Statistics
## 3 Jennifer Female  23 Computer Science
## 4 John     Male    25 Statistics
```

如果我们想向数据框中添加一些列，在这种情况下，添加两个新列以指示每个人是否注册以及手头项目的数量，我们可以使用`cbind()`：

```py
cbind(persons, Registered = c(TRUE, TRUE, FALSE), Projects = c(3, 2, 3))
##   Name    Gender  Age Major           Registered Projects
## 1 Ken      Male   24  Finance          TRUE         3
## 2 Ashley   Female 25  Statistics       TRUE         2
## 3 Jennifer Female 23  Computer Science FALSE        3
```

注意，`rbind()`和`cbind()`不会修改原始数据，而是创建一个新的数据框，其中附加了指定的行或列。

另一个有用的函数是`expand.grid()`。它生成一个包含列中所有值组合的数据框：

```py
expand.grid(type = c("A", "B"), class = c("M", "L", "XL"))
##   type class
## 1  A    M
## 2  B    M
## 3  A    L
## 4  B    L
## 5  A   XL
## 6  B   XL
```

有许多其他与数据框一起工作的有用函数。我们将在数据处理章节中讨论这些函数。

## 在磁盘上加载和写入数据

在实践中，数据通常存储在文件中。R 提供了一些函数来从文件中读取表格或将数据框写入文件。如果一个文件存储了一个表格，它通常是组织良好的，并遵循一些约定，该约定指定了行和列的排列方式。在大多数情况下，我们不需要逐字节读取文件，而是调用`read.table()`或`read.csv()`等函数。

最流行的软件无关数据格式是**CSV**（逗号分隔值）。该格式基本上是按这种方式组织的，即不同列中的值由逗号分隔，默认情况下，第一行被视为标题行。例如，人员可能以以下 CSV 格式表示：

```py
 Name,Gender,Age,MajorKen,Male,24,FinanceAshley,Female,25,StatisticsJennifer,Female,23,Computer Science
```

要将数据读入 R 环境，我们只需调用`read.csv(file)`，其中 file 是文件的路径。为确保数据文件可以被找到，请将`data`文件夹直接放置在您的当前工作目录中，调用`getwd()`以查找。我们将在下一章详细讨论这一点：

```py
read.csv("data/persons.csv")
##   Name     Gender Age Major
## 1 Ken      Male   24  Finance
## 2 Ashley   Female 25  Statistics
## 3 Jennifer Female 23  Computer Science
```

如果我们需要将数据框保存到 CSV 文件中，我们可以调用`write.csv(file)`并添加一些额外的参数：

```py
write.csv(persons, "data/persons.csv", row.names = FALSE, quote = FALSE)
```

参数`row.names = FALSE`避免了存储不必要的行名，而`argumentquote = FALSE`避免了在输出中引用文本，这两者在大多数情况下都是不必要的。

有许多内置函数和几个与不同格式数据读取和写入相关的包。我们将在后面的章节中介绍这个主题。

# 函数

函数是一个可以调用的对象。基本上，它是一个具有内部逻辑的机器，它接受一组输入（参数或参数）并返回一个值作为输出。

在前面的章节中，我们遇到了一些 R 的内置函数。例如，`is.numeric()`接受任何 R 对象作为参数，并返回一个逻辑值，指示该对象是否为数值向量。同样，`is.function()`可以判断给定的 R 对象是否为函数对象。

事实上，在 R 环境中，我们使用的每一件事都是对象，我们做的每一件事都是函数，也许会令你惊讶，所有函数仍然是对象。甚至`<-`和`+`都是接受两个参数的函数。尽管它们被称为二元运算符，但本质上它们是函数。

当我们进行随意的交互式数据分析时，有时我们不需要自己编写任何函数，因为内置函数以及成千上万的包提供的函数通常已经足够。

然而，如果您需要在数据处理或分析中重复逻辑或过程，这些函数可能无法完全满足您的需求，因为它们不是为满足特定任务或特定数据集的格式而设计的。那么，您需要创建自己的函数，针对特定的需求集。

## 创建函数

在 R 中创建函数很容易。假设我们定义一个名为`add`的函数，该函数简单地分别将两个数字`x`和`y`相加：

```py
add <- function(x, y) {  x + y}
```

函数语法`（x, y）`指定了函数的参数。换句话说，该函数接受两个名为`x`和`y`的参数。`{ x + y }`是函数体，它包含一系列以`x`、`y`和其他符号表示的表达式。函数返回的值是最后一个表达式的值，除非函数内部调用`return()`。最后，函数被赋值给`add`，这样我们就可以稍后使用`add`调用此函数。

创建这样一个简单的函数，或者任何更复杂的函数，都不会对评估向量产生任何影响。R 中的函数就像另一个对象。要查看`add`引用的对象，只需在控制台输入`add`：

```py
add
## function(x, y) {
## x + y
## }
```

## 调用函数

函数定义后，我们可以像在数学中一样调用函数。调用需要相同的语法：名称（arg1, arg2, ...）。看看下面的例子：

```py
add(2, 3)
## [1] 5
```

调用非常透明。当我们评估这样的调用时，R 会找出环境中是否有名为`add`的函数。然后，它会确定`add`指的是我们刚刚创建的函数，并创建一个局部环境，其中`x`取值为`2`，`y`取值为`3`。然后根据参数的值评估函数体内的表达式。最后，函数返回该表达式的值，即`5`。

## 动态类型

R 中的函数可以非常灵活，因为它不是强类型。换句话说，在调用之前，输入的类型不是固定的。即使函数最初是为标量数字设计的，只要`+`可以与它们一起工作，它也会自动推广到也可以与所有向量一起工作。例如，我们可以运行以下代码而不改变函数：

```py
add(c(2, 3), 4)
## [1] 6 7
```

前面的例子并没有真正展示动态类型的灵活性，因为标量在 R 中也是一个向量。一个更有资格的例子是：

```py
add(as.Date("2014-06-01"), 1)
## [1] "2014-06-02"
```

函数将两个参数放入表达式而不进行任何类型检查。`as.Date()`创建一个`Date`对象，它具有日期表示。在不改变`add`的任何代码的情况下，它与`Date`完美地工作。函数只有在`+`对于两个参数没有明确定义时才会失败：

```py
add(list(a = 1), list(a = 2))
## Error in x + y: non-numeric argument to binary operator
```

## 泛化一个函数

函数是对特定逻辑或过程的明确抽象，旨在解决某些特定问题。开发者通常希望函数足够通用，以适应广泛的用例，这样我们就可以轻松地使用它来解决类似的问题，而无需为每个问题编写太多的专用函数。

使函数更广泛适用的过程称为**泛化**。在像 R 这样的弱类型编程语言中泛化函数非常方便，但如果实现不正确，则可能会出错。

为了使`add()`更通用，以便它可以处理各种原始代数运算，我们可以定义另一个函数，称为`calc`。这个新函数接受三个参数，其中`x`和`y`是两个向量，而`type`接受一个字符向量，表示用户想要执行哪种代数运算。

以下代码使用**流程控制**实现这样一个函数，我们将在不久的将来介绍，但一开始看起来应该很容易理解。在这段代码中，要评估的表达式的选择取决于`type`的值：

```py
calc <- function(x, y, type) {
  if (type == "add") {
    x + y
  } else if (type == "minus") {
    x - y
  } else if (type == "multiply") {
    x * y
  } else if (type == "divide") {
    x / y
  } else {
    stop("Unknown type of operation")
  }
}
```

一旦函数被定义，我们就可以通过提供适当的参数来调用它：

```py
calc(2, 3, "minus")
## [1] -1
```

函数自动与数值向量一起工作：

```py
calc(c(2, 5), c(3, 6), "divide")
## [1] 0.6666667 0.8333333
```

函数也被推广到可以与非数值向量一起工作，其中`+`是明确定义的：

```py
calc(as.Date("2014-06-01"), 3, "add")
## [1] "2014-06-04"
```

考虑提供一些无效的参数：

```py
calc(1, 2, "what")
## Error in calc(1, 2, "what"): Unknown type of operation
```

在这种情况下，没有任何条件得到满足，因此最后 else 块中的表达式将被评估。`stop()`调用将产生一个错误信息并立即终止整个评估。

函数似乎工作得很好，并考虑了所有可能的无效参数的情况。然而，这并不正确：

```py
calc(1, 2, c("add", "minue"))
## Warning in if (type == "add") {: the condition has length > 1 and only the
## first element will be used
## [1] 3
```

在这里，我们没有考虑类型被给定为多元素向量的情况。问题是：当这样的向量与另一个向量比较时，它也会产生一个多元素逻辑向量，这将为`if`条件造成模糊。考虑`if(c(TRUE, FALSE))`的含义？

为了明确避免这种歧义，我们需要改进函数，以便错误信息更加详细和透明。为了进行下去，我们只需要检查向量是否有长度`1`：

```py
calc <- function(x, y, type) {

  if (length(type) > 1L) stop("Only a single type is accepted")
  if (type == "add") {
  x + y
  } else if (type == "minus") {
  x - y
  } else if (type == "multiply") {
  x * y
  } else if (type == "divide") {
  x / y
  } else {
  stop("Unknown type of operation")
  }
  }
```

然后，我们重新尝试那个麻烦的调用，看看异常是如何通过参数的预检查来处理的：

```py
calc(1, 2, c("add", "minue"))
## Error in calc(1, 2, c("add", "minue")): Only a single type is accepted
```

## 函数参数的默认值

一些函数非常灵活，因为它们接受广泛的输入并满足各种需求。在很多情况下，更多的灵活性意味着参数数量的增加。

如果我们必须在每次使用非常灵活的函数时指定数十个参数，那么查看代码肯定会很混乱。在这种情况下，为参数设置合理的默认值将极大地简化调用函数的代码。

要设置参数的默认值，使用`arg = value`。这将使参数成为可选的。以下示例创建了一个具有可选参数的函数：

```py
increase <- function(x, y = 1) {
x + y
}
```

新函数`increase()`允许我们仅使用`x`来调用它。在这种情况下，如果未明确指定，`y`将自动取值为`1`。

```py
increase(1)
## [1] 2
increase(c(1, 2, 3))
## [1] 2 3 4
```

许多 R 函数都有多个参数，其中一些参数有默认值。有时，确定参数的默认值可能很棘手，因为这很大程度上依赖于大多数用户的意图。

# 概述

在本章中，你学习了数值向量、逻辑向量和字符向量的基本行为。这些向量是同质数据类型，只能存储相同类型的元素。相比之下，列表和数据框更加灵活，因为它们可以存储不同类型的元素。你学习了如何对这些数据结构进行子集化并从中提取元素。最后，你学习了如何创建和调用函数。

现在你已经了解了游戏的规则，你需要熟悉游戏场地。在下一章中，我们将介绍一些关于管理工作空间的基本但重要的事项。我会向你展示一些管理工作目录、环境和包库的常见做法。
