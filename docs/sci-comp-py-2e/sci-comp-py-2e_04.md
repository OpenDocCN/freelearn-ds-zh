线性代数 - 数组

线性代数是计算数学中的一个基本组成部分。线性代数的对象是向量和矩阵。NumPy 包包含了处理这些对象所需的所有工具。

第一个任务是构建矩阵和向量，或通过切片修改现有的矩阵和向量。另一个主要任务是点积运算，它包含了大多数线性代数运算（标量积、矩阵-向量积和矩阵-矩阵积）。最后，提供了多种方法来解决线性问题。

本章节将涵盖以下主题：

+   数组类型概述

+   数学预备知识

+   数组类型

+   访问数组元素

+   构造数组的函数

+   访问和更改形状

+   堆叠

+   对数组进行操作的函数

+   SciPy 中的线性代数方法

# 第五章：4.1 数组类型概述

对于急于了解的读者，以下是如何使用数组的简要介绍。不过需要注意的是，数组的行为一开始可能会让人感到惊讶，因此我们建议在阅读完本介绍部分后继续阅读。

再次提醒，本章节的呈现方式假设你已经导入了 NumPy 模块，正如本书其他地方所假设的那样：

```py
from numpy import *
```

通过导入 NumPy，我们可以访问数据类型`ndarray`，将在接下来的章节中进行描述。

## 4.1.1 向量和矩阵

创建向量就像使用`array`函数将一个列表转换为数组一样简单：

```py
v = array([1.,2.,3.])
```

对象`v`现在是一个向量，表现得很像线性代数中的向量。我们已经在第 3.2 节中强调了它与 Python 中的列表对象的区别：*快速了解数组的概念*。

这里是一些对向量进行基本线性代数运算的示例：

```py
# two vectors with three components
v1 = array([1., 2., 3.])
v2 = array([2, 0, 1.])

# scalar multiplications/divisions
2*v1 # array([2., 4., 6.])
v1/2 # array([0.5, 1., 1.5])

# linear combinations
3*v1 # array([ 3., 6., 9.])
3*v1 + 2*v2 # array([ 7., 6., 11.])

# norm
from numpy.linalg import norm
norm(v1) # 3.7416573867739413
# scalar product
dot(v1, v2) # 5.0
v1 @ v2 # 5.0 ; alternative formulation
```

请注意，所有基本算术操作都是按元素进行的：

```py
# elementwise operations:
v1 * v2 # array([2., 0., 3.])
v2 / v1 # array([2.,0.,.333333])
v1 - v2 # array([-1., 2., 2.])/
v1 + v2 # array([ 3., 2., 4.])
```

还有一些函数也按元素对数组进行操作：

```py
cos(v1) # cosine, elementwise: array([ 0.5403, -0.4161, -0.9899])
```

本主题将在第 4.8 节中讲解：*对数组进行操作的函数*。

矩阵的创建与向量类似，只是它是从列表的列表中创建的：

```py
M = array([[1.,2],[0.,1]])
```

请注意，向量并不是列矩阵或行矩阵。一个![](img/dd804db6-ce44-4feb-b8b6-359bc63442df.png)向量、一个![](img/75c70cc7-6946-4e16-af4b-c6ba929f7142.png)，以及一个![](img/6f7b05e6-6f92-4cef-831d-790496c52a3b.png)矩阵是三种不同的对象，即使它们包含相同的数据。

要创建一个行矩阵，包含与向量`v = array([1., 2., 1.])`相同的数据，我们应用`reshape`方法：

```py
R = v.reshape((1,3))
shape(R)                # (1,3): this is a row matrix
```

对应的列矩阵通过`reshape`以相应的方式获得：

```py
C = v.reshape((3, 1))
shape(C) # (3,1): this is a column matrix
```

在学习了如何创建数组并看到基本的数组操作后，我们现在将学习如何通过索引和切片来访问数组元素和子数组。

## 4.1.2 索引和切片

索引和切片与列表中的对应操作类似。主要区别在于，当数组是矩阵时，可能会有多个索引或切片。该主题将在第 4.4.1 节：*基本数组切片*中深入讨论；在这里，我们仅提供一些索引和切片的示例：

```py
v = array([1., 2., 3])
M = array([[1., 2],[3., 4]])

v[0] # works as for lists
v[1:] # array([2., 3.])

M[0, 0] # 1.
M[1:] # returns the matrix array([[3., 4]])
M[1] # returns the vector array([3., 4.])

# access
v[0] # 1.
v[0] = 10

# slices
v[:2] # array([10., 2.])
v[:2] = [0, 1] # now v == array([0., 1., 3.])
v[:2] = [1, 2, 3] # error!
```

由于数组是所有计算线性代数任务的基本数据类型，本文本节将展示一些示例、点积及线性方程组的解法。

## 4.1.3 线性代数操作

执行大多数常见线性代数操作的关键运算符是 Python 函数`dot`。它用于矩阵-向量乘法（有关详细信息，请参阅第 4.2.4 节：*点积操作*）：

```py
dot(M, v) # matrix vector multiplication; returns a vector
M @ v # alternative formulation
```

它可以用来计算两个向量之间的标量积：

```py
dot(v, w) 
# scalar product; the result is a scalar
v @ w # alternative formulation
```

最后，它用于计算矩阵-矩阵乘积：

```py
dot(M, N) # results in a matrix
M @ N # alternative formulation
```

### 求解线性系统

如果![]是矩阵，![]是向量，你可以求解线性方程组

![](img/1378855e-0cd6-4a0c-b7e0-23e04a9d4809.png)

使用线性代数子模块`numpy.linalg`中的`solve`函数：

```py
from numpy.linalg import solve
x = solve(A, b)
```

例如，求解

![](img/b6d5dd31-f278-4cf2-8ab2-cd4287fa3b29.png)

执行以下 Python 语句：

```py
from numpy.linalg import solve
A = array([[1., 2.], [3., 4.]])
b = array([1., 4.])
x = solve(A, b)
allclose(dot(A, x), b) # True
allclose(A @ x, b) # alternative formulation
```

命令`allclose`用于比较两个向量。如果它们足够接近，该命令返回`True`。可以选择设置容差值。有关与线性方程组相关的更多方法，请参阅第 4.9 节：*SciPy 中的线性代数方法*。

现在，你已经看到了在 Python 中使用数组的第一种基本方式。在接下来的章节中，我们将向你展示更多细节及其基本原理。

# 4.2 数学基础

为了理解数组在 NumPy 中的工作原理，了解通过索引访问张量（矩阵和向量）元素与通过提供参数评估数学函数之间的数学关系非常有用。我们还将在本节中介绍点积作为归约算子的推广。

## 4.2.1 将数组视为函数

数组可以从多个不同的角度进行考虑。如果你希望从数学角度理解这一概念，可能会通过将数组类比为多个变量的函数来获益。这个视角将在后续讲解广播概念时再次提到，第 5.5 节：*广播*。

例如，选择给定向量中的一个分量，在![](img/0827edf6-8019-496b-87da-a611639c6ab4.png)中可能被视为从![](img/49fb25fc-995c-4a1c-b7db-fb0ca393e72e.png)到![](img/cab4aa7c-b61f-459e-afa8-71cd5baa66f1.png)的函数，其中我们定义集合：

![](img/f1785531-d885-4fce-80da-fc35bec04dbe.png)

在这里，集合 ![](img/9ff103aa-3603-4365-9d45-818b85a2c38d.png) 有 *n* 个元素。Python 函数 `range` 生成 *![*]。

另一方面，选择一个给定矩阵的元素是一个有两个参数的函数，其值域为 ![](img/2dd26863-2ac9-4c48-83ef-25700ef810e6.png)。从一个 *![](img/07d6e38b-b49b-4337-8925-160b771356ab.png)* 矩阵中选择特定元素，因此可以看作是一个从 ![](img/5398c6ee-de44-43c1-b7fb-7c30dbfe6117.png) 到 ![](img/f0d6533e-221c-4d66-8138-a00f24e830e0.png) 的函数。

## 4.2.2 操作是逐元素的

NumPy 数组本质上被当作数学函数来处理。特别是对于操作来说是这样。考虑两个定义在同一域并且取实值的函数，![](img/4cdad02e-e6f4-4c17-95c7-bfd5cf329282.png) 和 ![](img/6acb3ba5-69f9-4970-a5f4-90f7281ac936.png)。这两个函数的乘积 ![](img/8bd32329-08fb-4861-b05a-64b90be30405.png) 被定义为逐点乘积，即：

![](img/1e717cdf-b96e-492a-a775-81175e062d39.png)

请注意，这种构造对于两个函数之间的任何操作都是可能的。对于一个在两个标量之间定义的任意操作，我们这里用 ![](img/17a32615-8ff1-488f-b7df-8fc015e28be2.png) 表示，可以将 ![](img/4e03099d-ba8c-47a9-865e-a675a56e4e02.png) 定义如下：

![](img/9564f5b5-d0d8-45d1-9a6a-f8d3968aac02.png)

这一看似无害的言论让我们理解了 NumPy 对操作的立场；所有操作在数组中都是逐元素的。例如，两个矩阵之间的乘积，![](img/498ba54b-8eb4-40c7-9b03-4ff15b67a00d.png) 和 ![](img/2aa90bb5-7dbc-4b46-9e63-053f3c934bcf.png)，就像函数一样，其定义如下：

![](img/9fc20d80-879e-43b3-be9d-6d65c0bd6d78.png)

## 4.2.3 形状和维度数

这里有一个明确的区分：

+   *标量*：没有参数的函数

+   *向量*：一个具有一个参数的函数

+   *矩阵*：具有两个参数的函数

+   *高阶张量*：具有两个以上参数的函数

以下内容中，维度数是一个函数的参数个数。形状本质上对应于一个函数的定义域。

例如，一个大小为 *n* 的向量是一个从集合 ![](img/3e022549-3df7-4296-89f7-f07c4a254201.png) 到 ![](img/67c574fe-7309-413d-bc56-5dbfee30661e.png) 的函数。因此，它的定义域是 ![](img/914d84e0-9c6a-4895-9e11-c42f794a770a.png)。它的形状定义为单例 (*n*,)。类似地，大小为 ![](img/61fcaba3-7269-4d3d-b042-734057d63e0b.png) 的矩阵是一个定义在 ![](img/cbf9a605-eaf9-45d2-843e-ee7498361ef6.png) 上的函数。相应的形状就是一对 (*m*, *n*)。数组的形状由函数 `numpy.shape` 获取，维度数由函数 `numpy.ndim` 获取；请参见 第 4.6 节：*访问和更改形状*。

## 4.2.4 点积操作

将数组视为函数，虽然非常强大，但完全忽略了我们熟悉的线性代数结构，即矩阵-向量和矩阵-矩阵操作。幸运的是，这些线性代数操作可以都写成类似的统一形式：

向量-向量操作：

![](img/5d4531ef-e516-4ea5-907d-0de7b6edc077.png)

矩阵-向量操作：

![](img/6b07789a-b088-40b2-aa11-da31e046119c.png)

矩阵-矩阵操作：

![](img/d1e4e002-ee95-448c-91bd-4c9ecfa7120d.png)

向量-矩阵操作：

![](img/91a09614-743b-4b57-8b5c-2b98fd13232b.png)

本质的数学概念是“约简”（reduction）。对于矩阵-向量操作，约简由以下公式给出：

![](img/aec07b60-4dd3-4aa2-a52c-c21caae0c27d.png)

通常情况下，在两个张量之间定义的约简操作，分别是 ![](img/1f0c151e-39a4-4e33-b6cf-23789680aa6e.png) 和 ![](img/8016ef96-8baa-48ac-80e0-56016e765985.png)，它们的维度分别是 ![](img/58f0e0a7-a065-40a0-82b0-d8c685294696.png) 和 ![](img/cfd803fd-209a-4fa1-82cc-b2fa4237e1ac.png)，可以定义为：

![](img/6d735bf5-14bf-40c0-b43b-3347aab64854.png)

显然，张量的形状必须与该操作兼容才能产生

这要求对于矩阵-矩阵乘法也很熟悉。乘法 ![](img/e5b3c2c8-d223-4b63-9afe-67c3946130b2.png)

矩阵 ![](img/40c5c7dc-0cc9-4c09-b130-5ed416713e2c.png) 和 *![](img/2ed6b962-1034-42c4-bcd7-9f6df445ef53.png)* 之间的操作，只有当 ![](img/3f6cc52f-5279-45b4-ab25-c779292f6c32.png) 的列数等于 *![](img/4fc01d29-fe44-4681-8146-b4b1da231ed4.png)* 的行数时才有意义。

约简操作的另一个结果是它生成了一个具有 ![](img/907b8b22-fae5-42f9-bff7-b0381719d8fa.png) 维度的新张量。在*表 4.1*中，我们收集了涉及矩阵和向量的约简操作输出：

| **![](img/badb856c-cd63-4a10-a3c2-8d733fd6ecc6.png)** | **![](img/61296058-9a76-48b0-a429-4e031bf7f616.png)** | **![](img/a80b9a58-4dbc-4325-ba0b-20a3c0b6c80c.png)** |
| --- | --- | --- |
| ![](img/28959d31-3da1-4a37-b9ba-a658517250f8.png) | ![](img/669e969c-43c9-462d-8448-9d6663e312eb.png) | ![](img/72498382-abab-44ee-ba00-50bbbbfecc71e.png) |
| ![](img/9c3f79f5-ffa7-4480-8e0a-590a2a493fe5.png) | ![](img/f6d4ee8a-e85c-4952-a3d1-e6810b28d983.png) | ![](img/c6bd4cfd-a634-4531-90b9-69050d2a9ac0.png) |
| ![](img/9e9cd9c3-4a88-4eb3-b242-a59c8b0b2b13.png) | ![](img/742d6bd6-3c77-497f-8f05-ba91268a2709.png) | ![](img/ab0a2853-845f-403d-818a-9163956b0ba9.png) |
| ![](img/74866b6c-26bb-499a-bfc9-93c23837a315.png) | ![](img/f8606684-f88f-4c51-991c-29b266868d6e.png) | ![](img/7c5146dc-ee25-4f2b-867d-f726be6c87ab.png) |

​表 4.1：涉及矩阵和向量的约简操作输出

在 Python 中，所有的约简操作都可以通过 `dot` 函数或 `@` 操作符来执行：

```py
angle = pi/3
M = array([[cos(angle), -sin(angle)], 
           [sin(angle), cos(angle)]])
v = array([1., 0.])
y = dot(M, v)
```

在 Python 3.5 及更高版本中，点积可以用其运算符形式`dot(M, v)`表示，或者使用中缀符号表示`M @ v`。从现在起，我们将坚持使用更方便的中缀符号；如果需要其他形式，您可以修改示例。然而，我们需要注意的是，`dot`会在其参数类型为其他可以转换为数组的类型（如列表或浮点数）时执行类型转换。而中缀运算符`@`则不具有这个特性。

乘法运算符`*`始终是逐元素的。它与点积操作无关。即使*![](img/04ede9d1-0823-4b24-a5e7-fc247edcc0fa.png)*是矩阵，且![](img/8d8c60e1-cd74-45d6-9ec6-1798e72a0077.png)*是向量，`A*v`仍然是合法的操作。这将在第 5.5 节中解释：*广播*。

在本节中，我们介绍了在数学中使用数组与矩阵和向量的结合，并解释了相关的操作。特别地，我们解释了科学计算中最核心的操作——点积。接下来，我们将转向数组数据类型`ndarray`及其更一般的方法。

# 4.3 数组类型

用于操作向量、矩阵以及更一般张量的对象在 NumPy 中被称为 ndarray，简称数组。在本节中，我们将探讨它们的基本属性、如何创建它们以及如何访问其信息。

## 4.3.1 数组属性

数组本质上由三个属性来表征，这些属性在*表 4.2*中进行了描述。

| **名称** | **描述** |
| --- | --- |
| `shape` | 该属性描述数据应如何解释，例如作为向量、矩阵或更高阶张量，并给出相应的维度。可以通过`shape`属性访问该值。 |
| `dtype` | 该属性给出基础数据的类型（如浮点数、复数、整数等）。 |
| `strides` | 此属性指定数据应该如何读取。例如，一个矩阵可以按照列顺序（FORTRAN 约定）或行顺序（C 约定）连续存储在内存中。该属性是一个元组，包含到达下一行和下一列时需要跳过的字节数。它甚至允许对内存中的数据进行更灵活的解释，这也使得数组视图成为可能。 |

表 4.2：数组的三个特征属性

例如，考虑以下数组：

```py
A = array([[1, 2, 3], [3, 4, 6]])
A.shape   # (2, 3)
A.dtype   # dtype('int64')
A.strides # (24, 8)
```

它的元素类型为`'int64'`，即它们在内存中占用 64 位或 8 个字节。整个数组按行存储在内存中。从`A[0, 0]`到下一行第一个元素`A[1,0]`的内存距离是 24 个字节（即三个矩阵元素）。相应地，`A[0,0]`和`A[0,1]`之间的内存距离是 8 个字节（即一个矩阵元素）。这些值存储在`strides`属性中。

## 4.3.2 从列表创建数组

创建数组的一般方法是使用 `array` 函数。创建实值向量的语法如下：

```py
V = array([1., 2., 1.], dtype=float)
```

要创建一个具有相同数据的复数向量，可以使用：

```py
V = array([1., 2., 1.], dtype=complex)
```

如果未指定类型，则会猜测类型。`array` 函数会选择允许存储所有指定值的类型：

```py
V = array([1, 2]) # [1, 2] is a list of integers
V.dtype # int64
V = array([1., 2]) # [1., 2] mix float/integer
V.dtype # float64
V = array([1\. + 0j, 2.]) # mix float/complex
V.dtype # complex128
```

NumPy 会默默地将浮点数转换为整数，这可能会导致意外的结果：

```py
a = array([1, 2, 3])
a[0] = 0.5
a # now: array([0, 2, 3])
```

同样，常见的、通常是意外的数组类型转换发生在从 `complex` 到 `float` 之间。

### **数组和 Python 括号**

如我们在 第 1.2.2 节：*行连接* 中注意到，Python 允许在某些括号或圆括号没有关闭时换行。这为数组创建提供了方便的语法，使其更加符合人眼的审美：

```py
# the identity matrix in 2D
Id = array([[1., 0.], [0., 1.]])
# Python allows this:
Id = array([[1., 0.],
            [0., 1.]])
# which is more readable
```

到目前为止，你已经看到数组和列表在定义和使用上的许多区别。相比之下，访问数组元素似乎与访问列表元素非常相似。但尤其是多个索引的使用以及切片操作结果的对象，需要我们更加详细地研究这些问题。

# 4.4 访问数组条目

数组条目通过索引访问。与向量系数不同，访问矩阵系数需要两个索引。这些索引放在一对括号中。这使得数组语法与列表的列表有所区别。在后者中，需要两对括号来访问元素。

```py
M = array([[1., 2.],[3., 4.]])
M[0, 0] # first row, first column: 1.0
M[-1, 0] # last row, first column: 3.0
```

现在我们更详细地来看一下双重索引和切片的使用。

## 4.4.1 基本数组切片

切片与列表的切片类似（另见 第 3.1.1 节：*切片*），不过它们现在可能存在多个维度：

+   `M[i,:]` 是由行 ![](img/60a8e43a-37e5-406e-bad5-90981a04b955.png) 填充的向量，来自 ![](img/c0e17bfb-4fea-4289-9f4f-582181cc5699.png)*.*

+   `M[:,j]` 是由列填充的向量 ![](img/47def328-ef21-466c-8046-1574defb7ec6.png) 来自 ![](img/450c6166-8464-42a9-b6c1-acce375705c0.png)*.*

+   `M[2:4,:]` 是对行的 `2:4` 切片。

+   `M[2:4,1:4]` 是行和列的切片。

矩阵切片的结果见 *图 4.1*：

![](img/b07bb9d1-b49f-46b6-9d8d-9d8db197d47e.png)

图 4.1：矩阵切片的结果

如果省略索引或切片，NumPy 会假定你只是在取行。`M[3]` 是一个向量，它是对 M 的第三行的视图，而 `M[1:3]` 是一个矩阵，它是对 M 的第二行和第三行的视图：

修改切片的元素会影响整个数组（另见 第 5.1 节：*数组视图和副本*）：

```py
v = array([1., 2., 3.])
v1 = v[:2] # v1 is array([1., 2.])
v1[0] = 0\. # if v1 is changed ...
v # ... v is changed too: array([0., 2., 3.])
```

一般切片规则见 *表 4.3*：

| **访问** | **ndim** | **类型** |
| --- | --- | --- |
| 索引, 索引 | 0 | 标量 |
| 切片, 索引 | 1 | 向量 |
| 索引, 切片 | 1 | 向量 |
| 切片, 切片 | 2 | 矩阵 |

表 4.3：一般切片规则

数组 `M` 的切片操作结果（形状为 *(4, 4)*）见 *表 4.4*：

| **访问** | **形状** | **维度** | **类型** |
| --- | --- | --- | --- |
| `M[:2, 1:-1]` | (2,2) | 2 | 矩阵 |
| `M[1,:]` | (4,) | 1 | 向量 |
| `M[1,1]` | () | 0 | 标量 |
| `M[1:2,:]` | (1,4) | 2 | 矩阵 |
| `M[1:2, 1:2]` | (1,1) | 2 | 矩阵 |

表 4.4：形状为 (4,4) 的数组 M 的切片操作结果

## 4.4.2 使用切片更改数组

你可以使用切片或直接访问来更改数组。以下示例仅更改一个元素，位于 ![](img/b44e53a3-95ce-43a3-a6b4-3616878d891c.png) 矩阵 ![](img/c54c7a2c-59a0-4e88-bb60-28e29b2a1852.png) 中：

```py
M[1, 2] = 2.0 # scalar
```

同样，我们也可以更改矩阵中的一整行：

```py
M[2, :] = [1., 2., 3.] # vector
```

同样，我们也可以替换整个子矩阵：

```py
M[1:3, :] = array([[1., 2., 3.],[-1.,-2., -3.]])
```

列矩阵和向量之间是有区别的。以下使用列矩阵的赋值不会报错：

```py
M[1:4, 1:2] = array([[1.],[0.],[-1.0]]) 
```

而使用向量赋值时会返回 `ValueError`：

```py
M[1:4, 1:2] = array([1., 0., -1.0]) #  error
```

一般的切片规则如 *表 4.3* 所示。前面的矩阵和向量必须具有适当的大小，以适应矩阵 ![](img/b75a4632-4ef1-495c-891e-1184dfa2bc58.png)。你还可以使用广播规则（参见 第 5.5 节：*广播*）来确定替换数组的允许大小。如果替换数组的形状不正确，将引发 `ValueError` 异常。

我们已经看到如何通过切片从其他数组中构造数组。在下一节中，我们将考虑一些直接创建和初始化数组的特殊 NumPy 函数。

# 4.5 构造数组的函数

设置数组的常见方法是通过列表。但也有一些方便的方法用于生成特殊数组，这些方法在 *表 4.5* 中给出：

| **方法** | **形状** | **生成的结果** |
| --- | --- | --- |
| `zeros((n,m))` | *(n,m)* | 填充了 0 的矩阵 |
| `ones((n,m))` | *(n,m)* | 填充了 1 的矩阵 |
| `full((n,m),q)` | *(n,m)* | 填充了 ![](img/d4907979-e755-4827-ae0b-318783930a2d.png) 的矩阵 |
| `diag(v,k)` | *(n,n)* | 来自向量的（下、上）对角矩阵 ![](img/9cb240a7-8fe3-4f7a-862a-2057841ca009.png) |
| `random.rand(n,m)` | *(n,m)* | 填充了均匀分布的随机数（在 `(0,1)` 之间）的矩阵 |
| `arange(n)` | *(n,)* | 前 n 个整数 ![](img/cacd22ff-75a8-40a9-ad1d-b8e06d0c8dd9.png) |
| `linspace(a,b,n)` | *(n,)* | 向量，包含在 ![](img/76197639-ef19-4b09-89f0-b6702c4638f1.png) 和 ![](img/a68eb689-1673-4372-a195-a071d550b333.png) 之间均匀分布的 n 个点 |

表 4.5：创建数组的命令

这些命令可能会接受额外的参数。特别地，命令 `zeros`、`ones`、`full` 和 `arange` 接受 `dtype` 作为可选参数。默认类型是 `float`，但 `arange` 除外。也有一些方法，如 `zeros_like` 和 `ones_like`，它们是前述命令的轻微变体。例如，命令 `zeros_like(A)` 等价于 `zeros(shape(A))`。

函数 `identity` 用于构造给定大小的单位矩阵：

```py
I = identity(3)
```

该命令与以下命令相同：

```py
I = array([[ 1., 0., 0.],
           [ 0., 1., 0.],
           [ 0., 0., 1.]])
```

# 4.6 访问和改变形状

维度数是区分向量和矩阵的标志。*形状* 是区分不同大小的向量或矩阵的标志。在这一节中，我们将研究如何获取和改变数组的形状。

## 4.6.1 `shape` 函数

矩阵的形状是其维度的元组。一个 ![](img/116a1156-6428-4645-83b5-91a371d0ac37.png) 矩阵的形状是元组 `(n, m)`。可以通过 `shape` 函数获得：

```py
M = identity(3)
shape(M) # (3, 3)
```

或者，通过其属性来简单获取

```py
M.shape  # (3, 3)
```

然而，使用 `shape` 作为函数而不是属性的优点在于，函数也可以用于标量和列表。这在代码需要同时处理标量和数组时非常有用：

```py
shape(1.) # ()
shape([1,2]) # (2,)
shape([[1,2]]) # (1,2)
```

对于一个向量，形状是一个包含该向量长度的单一元素：

```py
v = array([1., 2., 1., 4.])
shape(v) # (4,) <- singleton (1-tuple)
```

## 4.6.2 维度数

数组的维度可以通过 `ndim` 函数或数组的 `ndim` 属性来获得：

```py
ndim(A) # 2
A.ndim # 2
```

注意，给定张量 `T`（向量、矩阵或更高阶张量）的维度数是由 `ndim` 函数给出的，并且总是等于其形状的长度：

```py
T = zeros((2,2,3)) # tensor of shape (2,2,3); three dimensions
ndim(T) # 3
len(shape(T)) # 3
```

## 4.6.3 重新塑形

方法 `reshape` 为数组提供了一个新的视图，具有新形状，而不复制数据：

```py
v = array([0,1,2,3,4,5])
M = v.reshape(2,3)
shape(M) # returns (2,3)
M[0,0] = 10 # now v[0] is 10
```

`reshape` 对由 `arange(6)` 定义的数组的各种影响如 *图 4.2* 所示：

![](img/c83ae739-a14a-4dac-b732-b5926366fe1d.png)

图 4.2：`reshape` 对数组的各种影响

`reshape` 不会创建一个新数组。它只是为现有数组提供一个新的视图。在前面的示例中，修改 `M` 的一个元素会自动导致 `v` 中相应元素的变化。当这种行为不可接受时，你需要复制数据，如在第 5.1 节中解释的那样：*数组视图与副本*。

如果你尝试重新塑形一个数组，而其形状不能与原始形状相乘，则会抛出错误：

```py
 ValueError: total size of new array must be unchanged.
```

有时候，指定一个 `shape` 参数并让 Python 自动计算出另一个参数，使得它们的乘积等于原始形状是很方便的。这可以通过将自由的 `shape` 参数设置为 `-1` 来实现：

```py
v = array([1, 2, 3, 4, 5, 6, 7, 8])
M = v.reshape(2, -1)
shape(M) # returns (2, 4)
M = v.reshape(-1, 2)
shape(M) # returns (4,2 )
M = v.reshape(3,- 1) # returns error
```

### 转置

重新塑形的一种特殊形式是 *转置*。它仅交换矩阵的两个形状元素。矩阵 ![](img/01c5013f-d771-4398-8b4a-09a7127faf37.png) 的转置是矩阵 ![](img/1e85d89b-68ed-4ce3-afcb-def575a94660.png)，使得

![](img/0d4d53d1-e828-4034-a089-d1a79219f880.png)

这将通过以下方式解决：

```py
A = ...
shape(A) # (3,4)

B = A.T  # A transpose
shape(B) # (4,3)
```

`transpose` 不会复制：转置与重新塑形非常相似，尤其是它也不复制数据，而是仅返回同一数组的视图：

```py
A= array([[ 1., 2.],[ 3., 4.]]) 
B=A.T 
A[1,1]=5\. 
B[1,1] # 5.0
```

转置一个向量没有意义，因为向量是一个一维的张量，也就是一个单变量的函数——索引。然而，NumPy 会执行转置并返回完全相同的对象：

```py
v = array([1., 2., 3.])
v.T # exactly the same vector!
```

当你想转置一个向量时，你可能是想创建一个行矩阵或列矩阵。这可以通过`reshape`来实现：

```py
v.reshape(-1, 1) # column matrix containing v
v.reshape(1, -1) # row matrix containing v
```

# 4.7 堆叠

从一对（匹配的）子矩阵构建矩阵的通用方法是`concatenate`。它的语法是：

```py
concatenate((a1, a2, ...), axis = 0)
```

当指定`axis=0`时，这个命令会将子矩阵垂直堆叠（一个在另一个之上）。使用`axis=1`参数时，它们会水平堆叠，这个操作会根据更高维度的数组进行泛化。这个函数通过多个方便的函数来调用，如下所示：

+   `hstack`：用于水平堆叠数组

+   `vstack`：用于垂直堆叠数组

+   `columnstack`：用于将向量堆叠成列

## 4.7.1 向量堆叠

你可以使用`vstack`和`column_stack`按行或按列堆叠向量，如*图 4.3*所示：

![](img/489416aa-cee4-4c78-bd61-6d55509b1907.png)

图 4.3：vstack 和 column_stack 的区别

注意，`hstack`将会产生`v1`和`v2`的拼接。

让我们以辛普森排列为向量堆叠的例子：我们有一个大小为![](img/95e7f926-6570-4979-aff3-cfd2456400df.png)的向量。我们想对具有偶数个分量的向量执行辛普森变换，即将向量的前半部分与后半部分交换，并且改变符号：

![](img/d1945fef-683a-48a7-8b84-69079e39b55f.png)

这个操作在 Python 中是这样解决的：

```py
# v is supposed to have an even length.
def symp(v):
    n = len(v) // 2 # use the integer division //
    return hstack([v[-n:], -v[:n]])
```

# 4.8 对数组的函数

数组上有不同类型的函数。有些是逐元素作用的，它们返回一个形状相同的数组，这些被称为*通用函数*。其他数组函数返回形状不同的数组。在本节中，我们将接触这两种类型的函数，并学习如何将标量函数转换为*通用函数*。

## 4.8.1 通用函数

通用函数是对数组逐元素作用的函数。因此，它们的输出数组与输入数组具有相同的形状。这些函数允许我们一次性计算标量函数在整个数组上的结果。

### 内建通用函数

一个典型的例子是`cos`函数（由 NumPy 提供）：

```py
cos(pi) # -1
cos(array([[0, pi/2, pi]])) # array([[1, 0, -1]])
```

注意，通用函数是逐分量作用于数组的。操作符，如乘法或指数，也遵循这个规则：

```py
2 * array([2, 4]) # array([4, 8])
array([1, 2]) * array([1, 8]) # array([1, 16])
array([1, 2])**2 # array([1, 4])
2**array([1, 2]) # array([2, 4])
array([1, 2])**array([1, 2]) # array([1, 4])
```

### 创建通用函数

如果你在函数中只使用通用函数，那么你的函数会自动变成通用函数。然而，如果你的函数使用了非通用函数，当你试图将它们应用于数组时，可能会得到标量结果，甚至出现错误：

```py
def const(x):
    return 1
const(array([0, 2])) # returns 1 instead of array([1, 1])
```

另一个例子如下：

```py
def heaviside(x):
    if x >= 0:
        return 1.
    else: 
        return 0.

heaviside(array([-1, 2])) # error
```

预期的行为是，将 `heaviside` 函数应用于一个向量 `[a, b]` 时，应该返回 `[heaviside(*a*), heaviside(*b*)]`。遗憾的是，这并不奏效，因为该函数总是返回一个标量，无论输入参数的大小如何。此外，使用数组输入时，`if` 语句会引发异常，具体细节可参见 第 5.2.1 节：*布尔数组*。

NumPy 函数 `vectorize` 使我们能够快速解决这个问题：

```py
vheaviside = vectorize(heaviside)
vheaviside(array([-1, 2])) # array([0, 1]) as expected
```

该方法的典型应用是用于绘制函数时：

```py
xvals = linspace(-1, 1, 100)
plot(xvals, vectorize(heaviside)(xvals))
axis([-1.5, 1.5, -0.5, 1.5])
```

*图 4.4* 显示了结果图：

![](img/87adeed7-835b-464a-bcc8-b0bb49a621e6.png)

图 4.4：Heaviside 函数

函数 `vectorize` 提供了一种方便的方式，可以快速地将一个函数转换，使其逐元素作用于列表和数组。

`vectorize` 也可以作为装饰器使用：

```py
@vectorize 
def heaviside(x): 
    if x >= 0: 
       return 1\. 
    else:  
       return 0\. 
# and a call of this results in:
heaviside(array([-1, 2])) # array([0, 1])
```

装饰器将在 第 7.8 节 中介绍：*作为装饰器的函数*。

## 4.8.2 数组函数

有一些作用于数组的函数，并不是逐元素作用的。这些函数的例子包括 `max`、`min` 和 `sum`。这些函数可以作用于整个矩阵、按行作用或按列作用。当没有提供参数时，它们会作用于整个矩阵。

假设：

![](img/b4b74487-2302-49d4-9832-3dfaa7c465be.png)

对该矩阵应用的 `sum` 函数返回一个标量：

```py
sum(A) # 36
```

该命令有一个可选参数 `axis`。它允许我们选择沿哪个轴执行操作。例如，如果轴是 ![](img/34738052-9fa9-47b9-82ff-83a13e4cff45.png)，意味着应该沿第一个轴计算和。沿轴 ![](img/b3c35afb-1602-49a5-af3a-b4f4a92bb398.png) 对形状为 ![](img/925c52a4-d0cd-400d-a844-1f5ff7e56e72.png) 的数组求和，将得到一个长度为 ![](img/0ae89473-603a-4d7f-a6e1-002309711489.png) 的向量。

假设我们计算 `A` 沿轴 ![](img/fb5a95be-3141-40c3-bb6c-4fa00dbd0586.png) 的和：

```py
sum(A, axis=0) # array([ 6, 8, 10, 12])
```

这相当于计算列上的和：

![](img/2aa3de70-06db-4cc0-882f-20d159526e22.png)

结果是一个向量：

![](img/d594fcb4-c367-4178-8eac-e9669d2c878f.png)

现在假设我们计算沿轴 *1* 的和：

```py
A.sum(axis=1) # array([10, 26])
```

这相当于计算行上的和：

![](img/b10b3aa4-6ef4-4079-bb86-d68282cd1f94.png)

结果是一个向量：

![](img/d8e2b4fb-ca07-4164-8283-bee562f7dd36.png)

在本节中，我们已经介绍了作用于数组的函数，接下来我们将转向解决基础科学计算任务的函数。我们通过考虑一些线性代数中的标准任务来举例说明。

# 4.9 SciPy 中的线性代数方法

SciPy 提供了一系列数值线性代数方法，这些方法在其模块 `scipy.linalg` 中。许多这些方法是 Python 包装的 `LAPACK` 程序，LAPACK 是一组广泛认可的 FORTRAN 子程序，用于解决线性方程组和特征值问题，详见 [[5]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。线性代数方法是科学计算中任何方法的核心，SciPy 使用包装器而非纯 Python 代码使得这些核心方法极其快速。我们在这里详细展示了如何通过 Scipy 解决两个线性代数问题，旨在让你对该模块有所了解。

你之前接触过一些来自 `numpy.linalg` 模块的线性代数函数。NumPy 和 SciPy 两个包是兼容的，但 Scipy 更侧重于科学计算方法，并且功能更加全面，而 NumPy 更侧重于数组数据类型，仅提供了一些便捷的线性代数方法。

## 4.9.1 使用 LU 解多个线性方程组

设 ![](img/4196e6f5-3ee7-4824-9a06-1e2a0023f791.png) 是一个 *![](img/6e3bf0cd-1219-43c9-8e6e-80888770ba90.png)* 矩阵，且 ![](img/919aa858-0c1e-4349-929f-6cab888543b5.png) 是一系列 ![](img/aec0a0b8-00cd-4635-9c1c-0686cbc24cc0.png) 向量。我们考虑求解问题，找到 ![](img/143b692e-7046-4f9d-b164-fe5cd9effa12.png) 向量 ![](img/67cb9bbc-afe6-4faa-849b-1d68041b2802.png)，使得：

![](img/0a0273f7-82f3-4066-88da-b79083ea9d5f.png)

我们假设向量 ![](img/85efadf5-99b6-44b4-a962-833b8b3d8355.png) 不是同时已知的。特别地，通常情况下，必须先解决 ![](img/871fa756-0080-460c-92c0-fd64f972467f.png)^(th) 问题，然后才能获得 ![](img/0282095b-b6ca-4e70-8a8a-dce30fc06d5f.png)，例如在简化的牛顿迭代法中，详见 [[24]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。

![](img/85bac675-3f92-4601-af52-ca94f39eef12.png) 因式分解是一种组织经典高斯消元法的方法，能够将计算分为两步进行：

+   矩阵的因式分解步骤 ![](img/00bdf963-c2e4-44f6-b55f-d79be2f3f4d9.png)，目的是将矩阵转换为三角形形式

+   一种相对廉价的向后和向前消元步骤，作用于 ![](img/efd18f9b-201c-4d88-a885-7fe6cc05eec3.png) 的实例，并且受益于更耗时的因式分解步骤

该方法还利用了这样一个事实：如果 ![](img/cecba16b-7cc5-4ca7-a597-a6c22ccac977.png) 是一个置换矩阵，使得 ![](img/99dfac8f-563a-4c50-98cd-e977f9ac85b5.png) 是原矩阵的行经过置换后的矩阵，那么两个系统 ![](img/b6467921-e799-4a7c-87d1-df158307b3d2.png) 和 ![](img/2d88dcdc-57aa-4e10-9cdb-494fbec51d25.png) 具有相同的解。

![](img/4578b253-5ead-4eef-9412-b4e3ea7439f6.png) 因式分解找到一个置换矩阵 ![](img/6c293ce8-4881-4f96-a225-cc7dfa04a769.png)，一个下三角矩阵 ![](img/44e8c59b-3b02-4ad4-9363-2b8a92b506fe.png)，以及一个上三角矩阵 ![](img/98ffc1b2-a1c7-45ba-9c92-71043ecb2d05.png)，使得：

![](img/caaf71e0-07ba-4fc0-80e0-cb79f1286d6c.png) 或等价地 ![](img/beaa3fdf-6087-4498-8883-f8d9797efc06.png)。

这种因式分解总是存在的。此外，![](img/3d8a0cf3-0fba-48ef-992d-4654fb86a225.png) 可以以 *![](img/6bc9dce9-f3fd-46c4-a547-553c7e51e6a7.png)* 的方式确定。因此，来自 ![](img/35f23021-e8c1-4326-b7e9-7909b1e2f02f.png) 的核心数据必须存储为 ![](img/9f65052f-5fc6-451c-acc0-509bb256677c.png)，同时 ![](img/9e90e974-9f89-492b-a3e8-3e8376d73586.png) 被保留。于是，*![](img/2b0e1170-2606-4e74-88b1-2c0681f6076c.png)* 和 ![](img/8d7fe4fb-c2fb-4d10-9f76-b4ffb42ae6c3.png) 可以存储在一个 ![](img/46e6348b-3f0b-442e-8b32-6c724c4ea4f5.png) 数组中，而关于置换矩阵 ![](img/0bdf51ae-0e08-4759-8a69-fe3479b39ccb.png) 的信息只需要一个 ![](img/d0f432d4-6869-4b90-9b12-31e8f12db89b.png) 整数向量——即主元向量。

在 SciPy 中，有两种方法可以计算 LU 因式分解。标准的方法是 `scipy.linalg.lu`，它返回三个矩阵 `L`、`U` 和 `P`。另一种方法是 `lu_factor`。我们在这里描述的是这种方法，因为它将方便地与 `lu_solve` 结合使用：

```py
import scipy.linalg as sl
[LU,piv] = sl.lu_factor(A)
```

在这里，矩阵 `A` 被分解，并返回一个包含 `L` 和 `U` 信息的数组，同时返回主元向量。有了这些信息，通过根据主元向量中的信息对向量 *![](img/153577e0-6458-4c62-92a0-8cf350510081.png)* 进行行交换，再通过使用 *![](img/96b762f1-848b-444d-a841-7d0d2766a23c.png)* 的回代替换，最后使用 ![](img/db5a6831-edd9-4a37-bb7e-8284f8a66aef.png) 的前代替换，即可求解系统。这在 Python 中被打包为 `lu_solve` 方法。下面的代码片段展示了如何在执行 LU 因式分解并将其结果存储在元组 (LU, piv) 中后，解决系统 ![](img/a8a9ac9f-b68e-45f0-a555-b8e489316cd5.png)：

```py
import scipy.linalg as sl
xi = sl.lu_solve((LU, piv), bi)
```

## 4.9.2 使用 SVD 求解最小二乘问题

一个线性方程组 ![](img/81eb24c9-baf8-4329-a16e-e721ec9262e1.png)，其中 ![](img/92a1bee6-65ee-4def-b0a6-8ed17278ef02.png) 为 *![](img/1d73bf3f-58a2-414e-9d7d-1afb6720205a.png)* 矩阵，*![](img/0fd80a0a-c81b-47b2-8e56-e2d1858c1e2a.png)*，称为过度确定的线性系统。通常，它没有经典解，你需要寻找一个向量 ![](img/6d0da559-17ca-4da7-bf6f-c8fc0c776aae.png)，满足以下性质：

![](img/d2456b56-3d9c-4b6d-b439-8a14d3933796.png)

这里，![](img/cbba8bf7-fee6-4d90-bdda-74de6bd48875.png) 表示欧几里得向量范数 ![](img/1b83e74f-85d8-4b81-9f8c-03be5257c74e.png)。

这个问题被称为最小二乘问题。解决此问题的稳定方法是基于对 ![](img/b6070459-10bf-46cd-8a81-79da90e4677d.png)*,* 进行分解，其中 ![](img/b2199c3b-3baf-4d99-b440-5a7f8128e122.png) 是一个 ![](img/9f894183-c602-4e45-acd2-1a5b1dfa8e57.png) 正交矩阵，![](img/321ee887-ee37-47ad-88e9-f433f47452eb.png) 是一个 ![](img/ec15b505-3dc6-454e-8ac0-432c1126e3c5.png) 正交矩阵，而 ![](img/9b49437c-733d-43d8-a853-e62eeeb21ea9.png) 是一个具有属性 ![](img/408d1afa-77dd-400a-9f84-938372b59921.png) 的矩阵，对于所有的 ![](img/a93a7e22-86c4-451e-b37c-70929ccdb519.png)。这种分解被称为 **奇异值分解**（**SVD**）。

我们写作：

![](img/d56a3d65-e4e2-4ec7-82c4-5c66a05cb0c9.png)

使用对角线 *![](img/482f5dde-34d4-431c-9b78-7922c29f02c6.png)* 矩阵 ![](img/214f9d14-1fe5-4917-bf5f-903e54fc58fe.png)。如果我们假设 ![](img/00bda032-6d12-4c96-bf4f-35e863ba8b90.png) 是满秩的，那么 *![*] 是可逆的，并且可以证明：

![](img/82c957bc-cd01-4ee7-9538-c30b62c29ffc.png)

成立。

如果我们将 ![](img/871828cc-22c0-46f1-837c-68393d365c37.png) 分割，其中 ![](img/5ef1ec2f-a76a-4523-bfcb-990bf31f162f.png) 是一个 ![](img/0a7fbf6f-dae4-4e00-8074-6c9453a683e9.png) 子矩阵，那么前面的方程可以简化为：

![](img/4a49ee33-bc31-403a-8fa2-723e1e78588d.png)

SciPy 提供了一个名为 `svd` 的函数，我们用它来解决这个任务：

```py
import scipy.linalg as sl 
[U1, Sigma_1, VT] = sl.svd(A, full_matrices = False,
                              compute_uv = True) 
xast = dot(VT.T, dot(U1.T, b) / Sigma_1)
r = dot(A, xast) - b # computes the residual
nr = sl.norm(r, 2) # computes the Euclidean norm of r
```

关键字 `full_matrices` 指示是计算完整矩阵 ![](img/9e72bfce-f08d-4f8a-a8b1-1ffef56ddffa.png) 还是仅计算其子矩阵 *![](img/51d29c20-bb37-4615-b3eb-5f131e0ed12b.png)*。由于你经常使用 `svd` 只计算奇异值，![](img/0ff12784-516f-4184-9447-e2016fa22484.png)，在我们的情况下，我们需要明确要求计算 ![](img/0be678a3-b8e0-4f25-88c3-38878a4d6a97.png) 和 ![](img/e209beca-7321-416e-a764-1645933a0536.png)，这可以通过使用关键字 `compute_uv` 来实现。

SciPy 函数 `scipy.linalg.lstsq` 通过内部使用 SVD 来直接求解最小二乘问题。

## 4.9.3 更多方法

到目前为止的例子中，你遇到了一些用于线性代数计算任务的方法，例如 `solve`。执行命令 `import scipy.linalg as sl` 后，可以使用更多的方法。最常用的方法列在 *表 4.6* 中：

| **方法** | **描述** |
| --- | --- |
| `sl.det` | 矩阵的行列式 |
| `sl.eig` | 矩阵的特征值和特征向量 |
| `sl.inv` | 矩阵的逆 |
| `sl.pinv` | 矩阵伪逆 |
| `sl.norm` | 矩阵或向量的范数 |
| `sl.svd` | 奇异值分解 |
| `sl.lu` | LU 分解 |
| `sl.qr` | QR 分解 |
| `sl.cholesky` | Cholesky 分解 |
| `sl.solve` | 一般或对称线性系统的解：*Ax = b* |
| `sl.solve.banded` | 带状矩阵的解法 |
| `sl.lstsq` | 最小二乘解 |

表 4.6：scipy.linalg 模块的线性代数函数

首先执行 `import scipy.linalg as sl`。

# 4.10 总结

在本章中，我们处理了线性代数中最重要的对象——向量和矩阵。为此，我们学习了如何定义数组，并掌握了重要的数组方法。一个较小的部分展示了如何使用 `scipy.linalg` 中的模块来解决线性代数中的核心任务。

在接下来的一章中，我们将考虑数组的更高级和特殊方面。

# 4.11 练习

**Ex. 1:** 考虑一个 ![](img/94b86ce2-e6b2-475b-9f14-76c5e36c9e19.png) 矩阵：

![](img/b9199d20-b134-4715-ae5c-f5f77974c909.png)

1.  使用函数 `array` 在 Python 中构造此矩阵。

1.  使用函数 `arange` 和适当的 `reshape` 构造相同的矩阵。

1.  表达式 `M[2,:]` 的结果是什么？类似表达式 `M[2:]` 的结果是什么？

**Ex. 2:** 给定一个向量 *x*，用 Python 构造如下矩阵：

![](img/fe063b6f-16f0-4f56-9598-adfd011526fe.png)

这里，![](img/6b2583e7-6896-4d67-964d-fd049538ba7f.png) 是向量 ![](img/18d85501-1ef0-49b3-8a5b-9e48a139c592.png) 的分量（从零开始编号）。给定向量 ![](img/219de5ca-b350-487d-aa10-0ad36e6b5f28.png)，用 Python 解决线性方程组 ![](img/ebed84dd-d1d0-4f9e-a484-605bfc06c9bb.png)。让 ![](img/03a227be-9acb-460e-9c61-af0cd3bd9232.png) 的分量用 *![](img/7e32640f-ea55-4d20-95c8-cb2b8f653841.png)* 表示。编写一个函数 `poly`，其输入为 ![](img/2b36f4f3-1189-45e2-bb5a-a0425f127e30.png) 和 ![](img/782f3b31-642b-4427-8c2a-4ed1be231cd2.png)，计算多项式：

![](img/11bad0bb-4452-4459-9007-88365688c530.png)

绘制该多项式，并在同一图中将点 ![](img/2f31ef49-1465-45fe-8d17-22e1a9ebb089.png) 表示为小星号。使用以下向量测试你的代码：

![](img/9f72d9a2-9a68-4ea6-a11e-3fb839a38d7b.png)

**Ex. 3:** 矩阵 ![](img/bcb237c4-8b52-4760-b9f7-a53906c9378f.png) 在 *Ex. 2* 中称为*范德蒙矩阵*。可以直接使用命令 `vander` 在 Python 中设置它。用 Python 命令 `polyval` 评估由系数向量定义的多项式。使用这些命令重复 *Ex. 2*。

**Ex. 4:** 设 ![](img/ee99a147-92c3-476d-a39a-a74ad9c0985c.png) 是一个一维数组。构造另一个数组 ![](img/290f6f75-cb1d-4a2f-8ff2-0a8e1a7921d0.png)，其值为 ![](img/6b23c9cd-6a6c-45c1-a2a7-fd6205634028.png)。在统计学中，这个数组被称为 *移动平均值*。在逼近理论中，它扮演了三次样条函数的 Greville 点的角色。尝试在你的脚本中避免使用`for`循环。

**Ex. 5:**

1.  从矩阵 ![](img/7178b185-4f57-411e-ab36-1878955e902b.png) （见*Ex. 2*）构造一个矩阵 ![](img/2df3ed42-0a6a-41a5-a792-3ea9d7c739c0.png)，删除其中 ![](img/0c7572b8-ae60-4056-bc23-b7755d8fd266.png) 的第一列。

1.  形成矩阵![](img/6eebcb7e-0a31-45fa-9f86-314c2724d5a4.png)。

1.  计算![](img/9f1f2ce4-d0bc-4b76-90e6-a007bf3de393.png)，并使用*Ex. 2*中的*y*。

1.  使用![](img/c3627f5c-ffb0-472c-adcd-349774cbc08b.png)和`polyval`绘制由![](img/6914b439-8e00-43a4-9d05-cf710057f952.png)定义的多项式。再次在同一图中绘制点![](img/fa578596-8b6d-4e5d-8d45-3444e2a19f77.png)。

**例 6：** *例 5* 描述了最小二乘法。重复该练习，但改用 SciPy 的`scipy.linalg.lstsq`方法。

**例 7：** 设![](img/9c8c6479-a5f2-468d-89ff-ebba2e920bf6.png)是一个向量，以其坐标形式写成![](img/dfb4ade8-dd92-4337-8bbb-69ad3e591092.png)矩阵![](img/d5202a4a-76e0-49b2-aa6a-a3700a41331e.png)。构造投影矩阵：

![](img/a37ac33c-9332-43af-88a3-44340ef9916e.png)和![](img/23ac98e4-77db-423f-8ce7-456009c627ba.png)

实验表明，![](img/83a4e7b1-68fc-49e9-b334-210006ce7cf4.png)是矩阵![](img/92b532e7-074a-4860-aa1c-7f8c7173159e.png)和![](img/0bc7f0fb-df10-4658-b18d-928f7a13cc76.png)的特征向量。相应的特征值是多少？

**例 8：** 在数值线性代数中，*![](img/44464ed2-4f61-4367-8619-39608a28d1e7.png)*矩阵![](img/5f13f90a-e7a8-4775-a9e7-b9d2228e5ca4.png)具有以下性质

![](img/9c02fdfc-2636-4564-b3ff-0995d87fa34d.png)

被用作极端增长因子的例子，在执行 LU 分解时，见[[36, p. 165]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。

在 Python 中设置这个矩阵，对于不同的![](img/a92b5fed-a950-43f8-ac67-7f39e1606d55.png)值，使用命令`scipy.linalg.lu`计算其 LU 分解，并通过实验得出关于增长因子的陈述。

![](img/92f0c83e-a714-49df-a074-f358f6ea7290.png)

关于![](img/eadd88ba-9e5c-48dc-95c9-f34ba0fe8f6b.png)。
