# 第十章：推荐引擎

*![](img/b4fc1c9d-6a64-4b2a-853a-d10b5a53826a.png)*推荐引擎是利用用户偏好和产品详情提供明智建议的一种方式。推荐引擎的目标是了解一组项目之间的相似性模式和/或制定用户和项目之间的互动。

本章首先介绍了推荐引擎的基础知识。然后，讨论了各种类型的推荐引擎。接下来，本章讨论了推荐引擎如何用于向不同用户建议项目和产品以及推荐引擎的各种限制。最后，我们将学习如何使用推荐引擎解决现实问题。

本章讨论了以下概念：

+   推荐系统的介绍

+   推荐引擎的类型

+   了解推荐系统的限制

+   实际应用领域

+   一个实际的例子——创建一个推荐引擎向订阅者推荐电影

在本章结束时，您应该能够理解如何使用推荐引擎根据一些偏好标准建议各种项目。

让我们从推荐引擎的背景概念开始。

# 推荐系统的介绍

推荐系统代表研究人员最初开发的方法，用于预测用户最有可能感兴趣的项目。推荐系统在给出关于项目的个性化建议方面的能力使其可能是在线购买世界中最重要的技术。

在电子商务应用中，推荐引擎使用复杂的算法来改善购物体验，允许服务提供商根据用户的偏好定制产品。

2009 年，Netflix 向任何能够通过超过 10%改进其现有推荐引擎（Cinematch）的算法提供 100 万美元的奖金。奖金被 BellKor 的 Pragmatic Chaos 团队赢得。

# 推荐引擎的类型

通常有三种不同类型的推荐引擎：

+   基于内容的推荐引擎

+   协同过滤引擎

+   混合推荐引擎

# 基于内容的推荐引擎

基于内容的推荐引擎的基本思想是建议与用户先前表现出兴趣的项目相似的项目。基于内容的推荐引擎的有效性取决于我们量化项目与其他项目的相似性的能力。

让我们看看下面的图表。如果**用户 1**已阅读**文档 1**，那么我们可以向用户推荐与**文档 1**相似的**文档 2**：

![](img/085cbec3-1d5a-4bc1-9b87-52474dfa09c4.png)

现在的问题是如何确定哪些项目彼此相似。让我们看看找到不同项目之间相似性的几种方法。

# 查找非结构化文档之间的相似性

确定不同文档之间相似性的一种方法是首先处理输入文档。处理非结构化文档后得到的数据结构称为**术语文档矩阵**（**TDM**），如下图所示：

![](img/e9f0d053-8d92-424c-8fec-1bea05859e38.png)

TDM 具有所有术语的词汇表作为行，所有文档作为列。它可以用于根据所选的距离度量确定哪些文档与其他文档相似。例如，Google 新闻根据与用户已经表现出兴趣的新闻相似性向用户推荐新闻。

一旦我们有了 TDM，有两种方法可以量化文档之间的相似性：

+   **使用频率计数**：这意味着我们假设一个词的重要性与每个词的频率成正比。这是计算重要性的最简单方法。

+   **使用 TFIDF**（**词频-逆文档频率**的缩写）：这是一个计算每个词在我们试图解决的问题的上下文中重要性的数字。它是两个术语的乘积：

+   **词频**（**TF**）：这是一个词或术语在文档中出现的次数。词频直接与一个词的重要性相关联。

+   **逆文档频率**（**IDF**）：首先，**文档频率**（**DF**）是包含我们搜索的术语的文档数量。作为 DF 的相反，IDF 给出了一个词所代表的独特性的度量，并将其与其重要性相关联。

+   由于 TF 和 IDF 都量化了我们试图解决的问题的上下文中一个词的重要性，它们的组合 TF-IDF 是每个词的重要性的一个很好的度量，是使用简单频率计数的更复杂的替代方法。

# 使用共现矩阵

这种方法基于这样的假设：如果两个物品大多数情况下一起购买，那么它们很可能是相似的，或者至少属于通常一起购买的物品类别。

例如，如果人们大多数情况下一起使用剃须膏和剃刀，那么如果有人买了剃刀，建议他也买剃须膏是有道理的。

让我们分析这四个用户的历史购买模式：

|  | **剃刀** | **苹果** | **剃须膏** | **自行车** | **鹰嘴豆泥** |
| --- | --- | --- | --- | --- | --- |
| 迈克 | 1 | 1 | 1 | 0 | 1 |
| 泰勒 | 1 | 0 | 1 | 1 | 1 |
| 埃琳娜 | 0 | 0 | 0 | 1 | 0 |
| 阿明 | 1 | 0 | 1 | 0 | 0 |

这将创建以下共现矩阵：

|  | **剃刀** | **苹果** | **剃须膏** | **自行车** | **鹰嘴豆泥** |
| --- | --- | --- | --- | --- | --- |
| 剃刀 | - | 1 | 3 | 1 | 1 |
| 苹果 | 1 | - | 1 | 0 | 1 |
| 剃须膏 | 3 | 1 | - | 1 | 2 |
| 自行车 | 1 | 0 | 1 | - | 1 |
| 鹰嘴豆泥 | 1 | 1 | 2 | 1 | - |

前述共现矩阵总结了一起购买两件物品的可能性。让我们看看如何使用它。

# 协同过滤推荐引擎

协同过滤的推荐是基于用户的历史购买模式的分析。基本假设是，如果两个用户对大多数相同的物品表现出兴趣，我们可以将两个用户都归类为相似。换句话说，我们可以假设以下内容：

+   如果两个用户的购买历史重叠超过阈值，我们可以将它们归类为相似用户。

+   查看相似用户的历史，购买历史中不重叠的物品将成为协同过滤推荐的基础。

例如，让我们看一个具体的例子。我们有两个用户，**迈克**和**埃琳娜**，如下图所示：

![](img/e1b17be1-78f8-46da-bcba-8a3912708c84.png)

请注意以下内容：

+   迈克和埃琳娜都对**文档 1**和**文档 2**表现出了完全相同的兴趣。

+   根据他们相似的历史模式，我们可以将他们两个都归类为相似用户。

+   如果埃琳娜现在阅读**文档 3**，那么我们也可以建议迈克阅读**文档 3**。

请注意，根据用户历史记录向用户推荐物品的策略并不总是有效的。

假设埃琳娜和迈克对**文档 1**都表现出了兴趣，这是关于摄影的（因为他们对摄影有共同的爱好）。此外，他们两个都对**文档 2**表现出了兴趣，这是关于云计算的，同样是因为他们对这个主题有兴趣。根据协同过滤，我们将他们归类为相似用户。现在埃琳娜开始阅读**文档 3**，这是一本关于女性时尚的杂志。如果我们遵循协同过滤算法，我们会建议迈克也阅读，而他可能对此并不感兴趣。

回到 2012 年，美国超市 Target 正在尝试使用协同过滤为购买者推荐产品。该算法根据他们的档案将一个父亲归类为他的十几岁的女儿。结果，Target 最终向父亲发送了一个关于尿布、婴儿奶粉和婴儿床的折扣券。他并不知道他女儿怀孕了。

请注意，协同过滤算法不依赖于任何其他信息，是一种独立的算法，基于用户的变化行为和协同推荐。

# 混合推荐引擎

到目前为止，我们已经讨论了基于内容和基于协同过滤的推荐引擎。这两种类型的推荐引擎可以结合起来创建混合推荐引擎。为此，我们按照以下步骤进行：

+   生成物品的相似矩阵。

+   生成用户的偏好矩阵。

+   生成推荐。

让我们逐步了解这些步骤。

# 生成物品的相似矩阵

在混合推荐中，我们首先通过使用基于内容的推荐创建物品的相似矩阵。这可以通过使用共现矩阵或使用任何距离度量来量化物品之间的相似性来实现。

假设我们目前有五种物品。使用基于内容的推荐，我们生成一个捕捉物品之间相似性的矩阵，看起来像这样：

![](img/506040b2-df72-412f-bad9-9061bc10a49c.png)

让我们看看如何将这个相似矩阵与偏好矩阵结合起来生成推荐。

# 生成用户的参考向量。

基于系统中每个用户的历史，我们将产生一个捕捉这些用户兴趣的偏好向量。

假设我们想为名为*KentStreetOnline*的在线商店生成推荐，该商店销售 100 种独特的物品。KentStreetOnline 很受欢迎，拥有 100 万活跃订阅者。重要的是要注意，我们只需要生成一个 100x100 维度的相似矩阵。我们还需要为每个用户生成一个偏好向量；这意味着我们需要为 100 万用户中的每一个生成 100 万个偏好向量。

性能向量的每个条目表示对项目的偏好。第一行的值表示**项目 1**的偏好权重为**4**。例如，第二行的值表示对**项目 2**没有偏好。

以下是图形显示：

![](img/c159ced5-502a-4f5e-9092-b364e75b7b15.png)

现在，让我们看看如何基于相似矩阵 S 和用户偏好矩阵 U 生成推荐。

# 生成推荐

为了进行推荐，我们可以将这些矩阵相乘。用户更有可能对经常与他们给出高评分的物品共现的物品感兴趣：

*Matrix[S] x Matrix[U] = Matrix[R]*

这个计算在以下图表中显示：

![](img/ce30323d-894b-4b7a-b4c9-65adb8a387bd.png)

为每个用户生成一个单独的结果矩阵。推荐矩阵*Matrix[R]*中的数字量化了用户对每个物品的预测兴趣。例如，在结果矩阵中，第四个物品的数字最高，为 58。因此，这个物品对这个特定用户来说是高度推荐的。

现在，让我们来看看不同推荐系统的局限性。

# 了解推荐系统的局限性

推荐引擎使用预测算法向一群用户建议推荐。这是一种强大的技术，但我们应该意识到它的局限性。让我们来看看推荐系统的各种局限性。

# 冷启动问题

显然，为了使协同过滤起作用，我们需要有关用户偏好的历史数据。对于新用户，我们可能没有任何数据，因此我们的用户相似性算法将基于可能不准确的假设。对于基于内容的推荐，我们可能不会立即获得有关新物品的详细信息。需要有关物品和用户的数据来生成高质量推荐的要求被称为**冷启动问题**。

# 元数据要求

基于内容的方法需要明确的物品描述来衡量相似性。这种明确的详细描述可能不可用，影响预测的质量。

# 数据稀疏问题

在大量物品中，用户只会对少数物品进行评分，导致非常稀疏的用户/物品评分矩阵。

亚马逊有大约十亿用户和十亿物品。据说亚马逊的推荐引擎是世界上数据最稀疏的推荐引擎。

# 由于社交影响而产生的偏见

社交影响在推荐系统中可以起到重要作用。社交关系可以被视为影响用户偏好的因素。朋友倾向于购买类似的物品并给出类似的评分。

# 有限的数据

有限数量的评论使得推荐系统难以准确衡量用户之间的相似性。

# 实际应用领域

让我们看看推荐系统在实际世界中的应用：

+   Netflix 上的电影有三分之二是推荐的。

+   亚马逊的三分之一的销售额来自推荐。

+   在 Google 新闻上，推荐引擎产生的点击率增加了 38%。

+   尝试预测用户对物品的偏好是基于其他物品的过去评分。

+   他们可以根据学生的需求和偏好为大学生推荐课程。

+   他们可以在在线求职门户网站上将简历与工作匹配。

现在，让我们尝试使用推荐引擎来解决一个现实世界的问题。

# 实际示例 - 创建推荐引擎

让我们构建一个可以向一群用户推荐电影的推荐引擎。我们将使用明尼苏达大学 GroupLens 研究小组收集的数据。

按照以下步骤：

1.  首先，我们将导入相关的包：

```py
import pandas as pd 
import numpy as np
```

1.  现在，让我们导入`user_id`和`item_id`数据集：

```py
df_reviews = pd.read_csv('reviews.csv')
df_movie_titles = pd.read_csv('movies.csv',index_col=False)
```

1.  我们通过电影 ID 合并了这两个 DataFrame：

```py
df = pd.merge(df_users, df_movie_titles, on='movieId')
```

在运行上述代码后，df DataFrame 的标题如下：

![](img/25808f2a-8fef-49e7-8e0e-e7f6ec14b479.png)

列的详细信息如下：

+   +   **userid**：每个用户的唯一 ID

+   **电影 id**：每部电影的唯一 ID

+   **rating**：每部电影的评分从 1 到 5

+   **timestamp**：电影被评分的时间戳

+   **title**：电影的标题

+   **genres**：电影的流派

1.  为了了解输入数据的摘要趋势，让我们使用`groupby`按`title`和`rating`列计算每部电影的平均评分和评分次数：

![](img/9561fa50-6ff3-4136-bf48-4c1b7c56b208.png)。

1.  现在让我们为推荐引擎准备数据。为此，我们将把数据集转换为一个具有以下特征的矩阵：

+   +   电影标题将成为列。

+   `User_id`将成为索引。

+   评分将是值。

我们将使用 DataFrame 的`pivot_table`函数来完成它：

```py
movie_matrix = df.pivot_table(index='userId', columns='title', values='rating')
```

请注意，上述代码将生成一个非常稀疏的矩阵。

1.  现在，让我们使用我们创建的推荐矩阵来推荐电影。为此，让我们考虑一个特定的用户，他观看了电影*Avatar (2009)*。首先，我们将找到所有对*Avatar (2009)*表现出兴趣的用户：

```py
Avatar_user_rating = movie_matrix['Avatar (2009)']
Avatar_user_rating = Avatar_user_rating.dropna()
Avatar_user_rating.head()
```

1.  现在，让我们尝试推荐与*Avatar (2009)*相关的电影。为此，我们将计算`Avatar_user_rating` DataFrame 与`movie_matrix`的相关性，如下所示：

```py
similar_to_Avatar=movie_matrix.corrwith(Avatar_user_rating)
corr_Avatar = pd.DataFrame(similar_to_Avatar, columns=['correlation'])
corr_Avatar.dropna(inplace=True)
corr_Avatar = corr_Avatar.join(df_ratings['number_of_ratings'])
corr_Avatar.head()
```

这会产生以下输出：

![](img/f0a29140-c9eb-4a17-96ad-f586ea608d86.png)

这意味着我们可以将这些电影作为用户的推荐。

# 总结

在本章中，我们学习了推荐引擎。我们研究了根据我们试图解决的问题选择合适的推荐引擎。我们还研究了如何准备数据以创建相似性矩阵，以供推荐引擎使用。我们还学习了推荐引擎如何用于解决实际问题，比如根据用户过去的模式推荐电影。

在下一章中，我们将专注于用于理解和处理数据的算法。
