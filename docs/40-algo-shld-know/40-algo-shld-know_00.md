# 前言

算法在计算机科学和实践中一直扮演着重要角色。本书侧重于利用这些算法来解决现实世界的问题。要充分利用这些算法，对它们的逻辑和数学有更深入的理解是必不可少的。您将从算法介绍开始，探索各种算法设计技术。接着，您将了解线性规划、页面排名和图表，甚至使用机器学习算法，理解它们背后的数学和逻辑。本书还包含案例研究，如天气预测、推文聚类和电影推荐引擎，将向您展示如何最优地应用这些算法。完成本书后，您将自信地使用算法解决现实世界的计算问题。

# 本书适合对象

本书适合严肃的程序员！无论您是经验丰富的程序员，希望更深入地了解算法背后的数学，还是对编程或数据科学知识有限，想了解如何利用经过实战检验的算法来改进设计和编写代码的方式，您都会发现本书很有用。必须具备 Python 编程经验，尽管了解数据科学有所帮助，但并非必需。

# 本书涵盖内容

第一章《算法概述》总结了算法的基本原理。它从需要理解不同算法工作原理的基本概念开始。它总结了人们如何开始使用算法来数学地表达某些类别的问题。它还提到了不同算法的局限性。接下来的部分解释了指定算法逻辑的各种方法。由于本书使用 Python 编写算法，因此接下来解释了如何设置环境以运行示例。然后，讨论了衡量算法性能并与其他算法进行比较的各种方法。最后，本章讨论了验证算法特定实现的各种方法。

第二章《算法中使用的数据结构》着重于算法对必要的内存数据结构的需求，这些数据结构可以保存临时数据。算法可以是数据密集型、计算密集型或两者兼而有之。但对于所有不同类型的算法，选择正确的数据结构对于它们的最佳实现至关重要。许多算法具有递归和迭代逻辑，并且需要基本上是迭代性质的专门数据结构。由于本书使用 Python，本章重点介绍了可以用于实现本书讨论的算法的 Python 数据结构。

第三章《排序和搜索算法》介绍了用于排序和搜索的核心算法。这些算法以后可以成为更复杂算法的基础。本章首先介绍了不同类型的排序算法。它还比较了各种方法的性能。然后，介绍了各种搜索算法。它们进行了比较，并量化了它们的性能和复杂性。最后，本章介绍了这些算法的实际应用。

第四章《设计算法》介绍了各种算法的核心设计概念。它还解释了不同类型的算法，并讨论了它们的优缺点。在设计复杂算法时，理解这些概念是很重要的。该章首先讨论了不同类型的算法设计。然后，它提出了著名的旅行推销员问题的解决方案。接着讨论了线性规划及其局限性。最后，它提出了一个实际例子，展示了线性规划如何用于容量规划。

第五章《图算法》专注于计算机科学中常见的图问题的算法。有许多计算问题最好以图的术语表示。本章介绍了表示图和搜索图的方法。搜索图意味着系统地沿着图的边缘访问图的顶点。图搜索算法可以发现关于图结构的许多信息。许多算法首先通过搜索它们的输入图来获得这些结构信息。几种其他图算法详细介绍了基本的图搜索。搜索图的技术是图算法领域的核心。第一部分讨论了图的两种最常见的计算表示形式：邻接表和邻接矩阵。接下来介绍了一种简单的图搜索算法，称为广度优先搜索，并展示了如何创建广度优先树。接着介绍了深度优先搜索，并提供了一些关于深度优先搜索访问顶点顺序的标准结果。

第六章《无监督机器学习算法》介绍了无监督机器学习算法。这些算法被分类为无监督，因为模型或算法试图从给定数据中学习内在结构、模式和关系，而无需任何监督。首先讨论了聚类方法。这些是机器学习方法，试图在数据样本中找到相似性和关系的模式，然后将这些样本聚类成各种群组，使得每个数据样本的群组或簇都具有一定的相似性，基于内在属性或特征。接下来讨论了降维算法，当我们最终拥有大量特征时使用。接着介绍了一些处理异常检测的算法。最后，本章介绍了关联规则挖掘，这是一种数据挖掘方法，用于检查和分析大型交易数据集，以识别感兴趣的模式和规则。这些模式代表跨交易的各种项目之间的有趣关系和关联。

第七章《传统监督学习算法》描述了传统的监督机器学习算法，涉及一组机器学习问题，其中存在带有输入属性和相应输出标签或类别的标记数据集。然后利用这些输入和相应的输出来学习一个泛化系统，可以用来预测以前未见过的数据点的结果。首先，在机器学习的背景下介绍了分类的概念。然后介绍了最简单的机器学习算法之一，线性回归。接着介绍了最重要的算法之一，决策树。讨论了决策树算法的局限性和优势，然后介绍了两个重要的算法，SVM 和 XGBoost。

第八章《神经网络算法》首先介绍了典型神经网络的主要概念和组件，这种网络正成为最重要的机器学习技术。然后，它介绍了各种类型的神经网络，并解释了用于实现这些神经网络的各种激活函数。接着详细讨论了反向传播算法，这是最广泛使用的收敛神经网络问题的算法。接下来解释了迁移学习技术，可以大大简化和部分自动化模型的训练。最后，介绍了如何使用深度学习来检测多媒体数据中的对象作为实际例子。

第九章《自然语言处理算法》介绍了自然语言处理（NLP）的算法。本章以渐进的方式从理论到实践。首先介绍了基本原理，然后是基础数学知识。然后讨论了设计和实施几个重要的文本数据用例的最广泛使用的神经网络之一。还讨论了 NLP 的局限性。最后，介绍了一个案例研究，其中训练模型以根据写作风格检测论文的作者。

第十章《推荐引擎》专注于推荐引擎，这是一种对用户偏好相关信息进行建模，并利用这些信息提供有根据的推荐的方法。推荐引擎的基础始终是用户和产品之间记录的互动。本章首先介绍了推荐引擎背后的基本思想。然后讨论了各种类型的推荐引擎。最后，讨论了推荐引擎如何用于向不同用户推荐物品和产品。

第十一章《数据算法》关注与数据中心算法相关的问题。该章从简要概述与数据相关的问题开始。然后介绍了对数据进行分类的标准。接下来提供了如何将算法应用于流数据应用程序的描述，然后介绍了密码学的主题。最后，介绍了从 Twitter 数据中提取模式的实际例子。

第十二章《密码学》介绍了与密码学相关的算法。该章从背景开始。然后讨论了对称加密算法。解释了 MD5 和 SHA 哈希算法，并介绍了实施对称算法的局限性和弱点。接下来讨论了非对称加密算法以及它们如何用于创建数字证书。最后，讨论了一个总结所有这些技术的实际例子。

第十三章《大规模算法》解释了如何处理无法适应单个节点内存并涉及需要多个 CPU 进行处理的数据的大规模算法。本章首先讨论了最适合并行运行的算法类型。然后讨论了与并行化算法相关的问题。还介绍了 CUDA 架构，并讨论了如何使用单个 GPU 或一组 GPU 来加速算法以及需要对算法进行哪些更改才能有效利用 GPU 的性能。最后，本章讨论了集群计算，并讨论了 Apache Spark 如何创建弹性分布式数据集（RDD）以创建标准算法的极快并行实现。

第十四章，*实际考虑*，从解释性的重要主题开始，这在现在已经解释了自动决策背后的逻辑变得越来越重要。然后，本章介绍了使用算法的伦理和在实施它们时可能产生偏见的可能性。接下来，详细讨论了处理 NP-hard 问题的技术。最后，总结了实施算法的方法以及与此相关的现实挑战。

# 充分利用本书

| **章节编号** | **所需软件（带版本）** | **免费/专有** | **硬件规格** | **所需操作系统** |
| --- | --- | --- | --- | --- |
| 1-14 | Python 版本 3.7.2 或更高 | 免费 | 最低 4GB RAM，推荐 8GB+ | Windows/Linux/Mac |

**如果您使用本书的数字版本，我们建议您自己输入代码或通过 GitHub 存储库（链接在下一节中提供）访问代码。这样做将有助于避免与复制和粘贴代码相关的任何潜在错误。**

# 下载示例代码文件

您可以从您的账户在[www.packt.com](http://www.packt.com)下载本书的示例代码文件。如果您在其他地方购买了本书，您可以访问[www.packtpub.com/support](https://www.packtpub.com/support)并注册，文件将直接发送到您的邮箱。

您可以按照以下步骤下载代码文件：

1.  在[www.packt.com](http://www.packt.com)登录或注册。

1.  选择“支持”选项卡。

1.  点击“代码下载”。

1.  在搜索框中输入书名，然后按照屏幕上的说明进行操作。

文件下载后，请确保使用最新版本进行解压缩或提取文件夹：

+   Windows 的 WinRAR/7-Zip

+   Mac 的 Zipeg/iZip/UnRarX

+   Linux 的 7-Zip/PeaZip

该书的代码包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/40-Algorithms-Every-Programmer-Should-Know`](https://github.com/PacktPublishing/40-Algorithms-Every-Programmer-Should-Know)。如果代码有更新，将在现有的 GitHub 存储库上进行更新。

我们还有来自我们丰富书籍和视频目录的其他代码包，可在**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**上找到。去看看吧！

# 下载彩色图片

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图片。您可以在这里下载：[`static.packt-cdn.com/downloads/9781789801217_ColorImages.pdf`](https://static.packt-cdn.com/downloads/9781789801217_ColorImages.pdf)。

# 使用的约定

本书中使用了许多文本约定。

`CodeInText`：表示文本中的代码单词，数据库表名，文件夹名，文件名，文件扩展名，路径名，虚拟 URL，用户输入和 Twitter 句柄。这里有一个例子：“让我们看看如何通过使用`push`来向堆栈添加一个新元素，或者通过使用`pop`来从堆栈中移除一个元素。”

代码块设置如下：

```py
define swap(x, y)
    buffer = x
    x = y
    y = buffer
```

当我们希望引起您对代码块的特定部分的注意时，相关行或项目将以粗体显示：

```py
define swap(x, y)
    buffer = x
    x = y
 y = buffer
```

任何命令行输入或输出都以以下方式编写：

```py
pip install a_package
```

**粗体**：表示一个新术语，一个重要单词，或者屏幕上看到的单词。例如，菜单或对话框中的单词会以这种方式出现在文本中。这里有一个例子：“简化算法的一种方法是在准确性上做出妥协，从而产生一种称为**近似算法**的算法。”

警告或重要提示会以这种方式出现。提示和技巧会以这种方式出现。
