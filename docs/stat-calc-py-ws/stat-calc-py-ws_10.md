# 第十章：10\. 使用 Python 进行基础微积分

概述

在本章中，您将学习如何在给定的*x*值处计算函数的导数。您还将学习如何计算给定值之间函数的积分，并使用导数来解决优化问题，例如最大化利润或最小化成本。在本章结束时，您将能够使用微积分来解决各种数学问题。

# 介绍

微积分被称为变化的科学，因为它的工具是为了处理不断变化的值，如行星和抛射物的位置和速度而开发的。以前，没有办法表达这种变量的变化。

微积分中的第一个重要主题是**导数**。这是给定点的函数变化率。直线遵循一个简单的模式，称为斜率。这是*y*值（*上升*）在给定的*x*值范围内（*水平移动*）的变化：

![图 10.1：直线的斜率](img/B15968_10_01.jpg)

图 10.1：直线的斜率

在*图 10.1*中，线条中的*y*值每增加 1 个单位，*x*值就增加 2 个单位，因此我们将 2 除以 1 得到斜率为 2。

然而，曲线的斜率并不像直线那样在整条曲线上是恒定的。因此，正如您在*图 10.2*中所看到的，该函数在点**A**的变化率与点**B**的变化率是不同的：

![图 10.2：找到曲线的斜率](img/B15968_10_02.jpg)

图 10.2：找到曲线的斜率

然而，如果我们在点**A**上放大得足够近，我们会发现曲线被一条直线相当精确地近似。

![图 10.3：放大曲线](img/B15968_10_03.jpg)

图 10.3：放大曲线

这就是导数的工作原理：我们使*x*的变化，即*水平移动*，足够小，以至于曲线的这一小部分的斜率将近似等于该点的曲线变化率。让我们看看在 Python 中是什么样子。

# 编写导数函数

尽管在微积分课程中对导数进行了大量炒作，但用于数值计算导数的函数实际上非常简单。

在 Jupyter 笔记本中，我们将定义一个函数*f(x)*，即抛物线*y = x*2：

```py
def f(x):
    return x**2
```

现在我们可以编写一个函数，使用经典公式在任何点*(x, f(x))*计算导数：

![图 10.4：计算导数的公式](img/B15968_10_04.jpg)

图 10.4：计算导数的公式

分子是*上升*，分母是*水平移动*。*Δ x*表示*x*的变化，并且我们将通过将 1 除以一百万来使其成为一个非常小的小数：

```py
def f(x):
    return x**2
def derivative(f,x):
    """
    Returns the value of the derivative of
    the function at a given x-value.
    """
    delta_x = 1/1000000
    return (f(x+delta_x) - f(x))/delta_x
```

注意

下面代码片段中显示的三引号（`"""`）用于表示多行代码注释的起始和结束点。注释被添加到代码中，以帮助解释特定的逻辑部分。

现在我们可以计算任何*x*值处函数的导数，并且我们将得到一个非常精确的近似值：

```py
for i in range(-3,4):
    print(i,derivative(f,i))
```

如果您运行上述代码，您将得到以下输出：

```py
-3 -5.999999000749767
-2 -3.999998999582033
-1 -1.999999000079633
0 1e-06
1 2.0000009999243673
2 4.0000010006480125
3 6.000001000927568
```

这些值与它们的实际值只有一点偏差（-5.999999 而不是-6）。我们可以将打印输出四舍五入到最接近的十分位，这样我们将更清楚地看到这些值：

```py
for i in range(-3,4):
    print(i,round(derivative(f,i),1))
```

输出将是：

```py
-3 -6.0
-2 -4.0
-1 -2.0
0 0.0
1 2.0
2 4.0
3 6.0
```

我们已经计算了函数*y = x*2 在许多点的导数，我们可以看到模式：导数始终是*x*值的两倍。这是近似该点曲线的直线的斜率。这种方法的强大之处将在这个练习中变得清晰。 

## 练习 10.01：找到其他函数的导数

我们可以使用导数函数计算我们可以表达的任何函数的导数。当我们可以简单地使用计算斜率的*微小运行*方法时，就无需进行繁琐的代数运算。在这里，我们的函数将找到一些看起来复杂的函数的导数。我们重复使用了*f*，但您也可以调用其他函数。在这个练习中，您将找到给定*x*值处每个函数的导数：

![图 10.5：给定 x 值的函数定义](img/B15968_10_05.jpg)

图 10.5：给定 x 值的函数定义

执行以下步骤：

1.  首先，我们需要从`math`模块导入平方根函数：

```py
from math import sqrt
```

1.  以下是前述方程中的函数，转换为 Python 代码：

```py
def f(x):
    return 6*x**3
def g(x):
    return sqrt(2*x + 5)
def h(x):
    return 1/(x-3)**3
```

1.  如果您还没有定义导数函数，请定义它：

```py
def derivative(f,x):
    """Returns the value of the derivative of
    the function at a given x-value."""
    delta_x = 1/1000000
    return (f(x+delta_x) - f(x))/delta_x
```

1.  然后通过调用每个函数和所需的*x*值打印出导数：

```py
print(derivative(f,-2),derivative(g,3),derivative(h,5))
```

输出如下：

```py
71.99996399265274 0.30151133101341543 -0.18749981253729509
```

您刚刚学会了一个非常重要的技能：在特定*x*值处找到函数（任何函数）的导数。这就是微积分学生要做大量艰难代数的原因：要将导数作为一个函数得到，然后他们可以代入*x*值。然而，使用 Python，我们直接计算了函数的数值导数，而不需要进行任何代数运算。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2AnlJOC`](https://packt.live/2AnlJOC)。

您还可以在[`packt.live/3gi4I7S`](https://packt.live/3gi4I7S)上在线运行此示例。

## 找到切线的方程

微积分中一个常见的问题是找到曲线在给定点处的切线方程。还记得我们的点**A**和**B**吗？切线是在这些点附近紧密逼近曲线的线，正如您在*图 10.6*中所看到的：

![图 10.6：曲线的两条切线](img/B15968_10_06.jpg)

图 10.6：曲线的两条切线

让我们使用*图 10.6*中的信息。方程如下：

![图 10.7：f(x)的方程](img/B15968_10_07.jpg)

图 10.7：f(x)的方程

*图 10.6*中点**A**的*x*值为-0.48，**B**的*x*值为 0.67。使用 Python 的好处是，给定的值是整数、负数还是小数都无关紧要，计算机会轻松处理这些数字计算。

要找到直线的方程，我们只需要一个斜率和一个点。如果您记得您的代数，您可以使用这个公式：

![图 10.8：直线的方程](img/B15968_10_08.jpg)

图 10.8：直线的方程

我们已知函数和点(*x*0*, y*0)，因此我们可以从给定的*x*值处函数的导数中找到斜率*m*。切线的方程将以*y = mx + b*的形式表示，我们唯一不知道的是*b*，即线的*y*截距。但是，如果我们重新排列前面的方程，我们可以在方程的右侧看到它：

![图 10.9：点处的直线方程](img/B15968_10_09.jpg)

图 10.9：点处的直线方程

我们需要使用已有的导数函数找到斜率*m*，然后将其代入*y*0 *- m x*0。为此，请执行以下步骤：

1.  首先，我们将定义我们的`f(x)`函数：

```py
def f(x):
    return x**3 - 2*x**2 + 1
```

1.  然后，我们将编写一个函数，根据斜率和一个点返回直线的*y*截距。将其命名为`point_slope`：

```py
def point_slope(m,x,y):
    """Finds the y-intercept of a line
    given its slope m and a point (x,y)"""
    return y-m*x
```

1.  最后，我们将编写一个函数，该函数接受函数`f`和一个`x`值，并找到`f`在`x`处的导数，将其放入`point_slope`函数中，并以*y = mx + b*的形式打印出直线的方程。将其命名为`tangent_line`：

```py
def tangent_line(f,x):
    """Finds the equation of the line 
    tangent to f at x."""
```

1.  我们通过对`f`在`x`处进行导数运算来找到切线的斜率：

```py
    m = derivative(f,x)
```

1.  然后我们使用`point_slope`函数来找到*y*截距：

```py
    y0 = f(x)
    b = point_slope(m,x,y0)
    print("y = ",round(m,2),"x + ",round(b,2))
```

1.  现在，要得到在*x = -0.48*和*x = 0.67*处切线的方程，使用以下代码：

```py
for x in [-0.48,0.67]:
    tangent_line(f,x)
```

输出如下：

```py
y =  2.61 x +  1.68
y =  -1.33 x +  1.3
```

在本节中，我们学习了如何找出在特定 `x` 值处的切线方程。

# 计算积分

微积分的一个主要主题是微分微积分，这意味着取导数，就像我们在本章中一直在做的那样。另一个主要主题是积分微积分，它涉及使用许多小 *切片* 来累加面积或体积。

在手工计算积分时，我们被教导要逆转我们用来找到导数的代数。但是那个代数变得混乱，并且在某些情况下是不可能的。我们在学校学到的 *困难* 版本是黎曼和，它要求我们将曲线下的面积切成矩形 *切片* 并将它们相加以获得面积。但你永远无法在一个现实的时间内处理超过 10 个切片，当然也不可能在考试中。

然而，使用 Python，我们可以使用任意多的切片，并且它可以节省我们通过许多步骤获得代数方程的麻烦。找到代数方程的目的是获得准确的数值，如果使用程序可以得到最准确的数值，那么我们肯定应该选择这条路线。

*图 10.10* 显示了一个函数和其下的面积。通常面积由函数本身、一个较低的 *x* 值 **a**、一个较高的 *x* 值 **b** 和 *x* 轴界定。

![图 10.10：由函数 f(x) 定义的曲线下的面积 S](img/B15968_10_10.jpg)

图 10.10：由函数 f(x) 定义的曲线下的面积 S

我们要做的是将面积 **S** 切成等宽的矩形，由于我们知道高度（*f(x)*），所以使用 Python 将它们全部加起来会很容易。*图 10.11* 显示了 *f(x) = x*2 的情况：

![图 10.11：面积 S 被切成 10 个等宽的矩形](img/B15968_10_11.jpg)

图 10.11：面积 S 被切成 10 个等宽的矩形

首先，我们将定义函数并选择矩形的数量（以便两者的值都容易更改）。在这种情况下，我们将使用 20 个矩形，这将比 *图 10.11* 中显示的 10 个矩形给我们更高的准确度：

```py
def f(x):
    return x**2
number_of_rectangles = 20
```

然后我们定义我们的积分函数。首先，通过将范围 `(b – a)` 划分为 `num` 个矩形来获得等宽：

```py
def integral(f,a,b,num):
    """Returns the sum of num rectangles
    under f between a and b"""
    width = (b-a)/num
```

然后我们将循环遍历范围，随着我们的遍历，我们将矩形的面积相加。我们可以使用一行列表推导来实现这一点。对于每个 `n`，我们将矩形的底部（`width`）乘以高度（*f(x)*）来获得每个矩形的面积。最后，我们返回所有面积的总和：

```py
    area = sum([width*f(a+width*n) for n in range(num)])
    return area
```

这就是函数调用的样子：

```py
for i in range(1,21):
    print(i,integral(f,0,1,i))
```

输出显示，随着更多的矩形，我们越来越接近实际面积的值：

```py
1 0.0
2 0.125
3 0.18518518518518517
4 0.21875
5 0.24000000000000005
6 0.2546296296296296
7 0.26530612244897955
8 0.2734375
9 0.279835390946502
10 0.2850000000000001
11 0.2892561983471075
12 0.292824074074074
13 0.2958579881656805
14 0.29846938775510196
15 0.30074074074074075
16 0.302734375
17 0.3044982698961938
18 0.3060699588477366
19 0.3074792243767312
20 0.3087500000000001
```

看起来增长得很慢。如果我们直接跳到 100 个矩形呢？这将产生 *图 10.12* 中所示的情况：

![图 10.12：较小的矩形更好地逼近面积](img/B15968_10_12.jpg)

图 10.12：较小的矩形更好地逼近面积

下面是我们如何更改 `print` 语句以给出 100 个矩形的面积：

```py
print(100,integral(f,0,1,100))
```

输出将如下所示：

```py
100 0.32835000000000014
```

那么，使用 1,000 个矩形，这个积分将会非常困难和耗时地手工计算？使用 Python，我们只需将 `100` 改为 `1000`，就可以得到一个更准确的逼近：

```py
print(1000,integral(f,0,1,1000))
```

输出将如下所示：

```py
1000 0.33283350000000034
```

将 100,000 个矩形相加得到 0.3333283333\. 看起来它接近于 0.333，或者 1/3\. 但增加更多的零不会花费我们任何代价，所以随时增加矩形的数量以获得更准确的结果。

# 使用梯形

我们可以更快地获得更好的逼近，而不是使用矩形，而是使用梯形。这样，我们就不会错过太多的面积，就像在 *图 10.13* 中所示的那样：

![图 10.13：使用梯形更好地逼近曲线](img/B15968_10_13.jpg)

图 10.13：使用梯形更好地逼近曲线

以下是梯形规则的公式：

![图 10.14：梯形面积的公式](img/B15968_10_14.jpg)

图 10.14：梯形面积的公式

端点*x = a*和*x = b*处的段的高度计算一次，而所有其他高度计算两次。这是因为在梯形面积的公式中有两个*高度*。您能猜到如何调整您的积分函数以成为梯形吗？

```py
def trap_integral(f,a,b,num):
    """Returns the sum of num trapezoids
    under f between a and b"""
    width = (b-a)/num
    area = 0.5*width*(f(a) + f(b) + 2*sum([f(a+width*n) for n in range(1,num)]))
    return area
```

现在我们将使用`5`个梯形运行`trap_integral`函数：

```py
print(trap_integral(f,0,1,5))
```

输出将如下：

```py
0.3400000000000001
```

因此，仅使用 5 个梯形，我们将误差降低到 3%。（请记住，我们知道该函数的真实面积值为 0.333...）使用 10 个梯形，我们得到 0.335，误差为 0.6%。

## 练习 10.02：找到曲线下的面积

在这个练习中，我们将找到给定间隔内以下函数的面积：

![图 10.15：间隔的公式](img/B15968_10_15.jpg)

图 10.15：间隔的公式

执行以下步骤来找到面积。编写了`trap_integral`函数来使用梯形来近似曲线下的面积，很容易：只需定义函数（您可能需要导入`trig`函数和`pi`）并声明端点。让它使用 100 个梯形，因为那将非常准确和快速：

1.  首先，导入您需要的`math`函数并定义`f`，`g`和`h`：

```py
from math import cos,pi
def f(x):
    return x**3 + 3
def g(x):
    return 3*cos(x)
def h(x):
    return ((x**2 - 1)*(x**2+1))/x**2
```

1.  然后在指定的*x*值之间对每个函数调用`trap_integral`函数：

```py
print(trap_integral(f,3,4,100))
print(trap_integral(g,0,pi/4,100))
print(trap_integral(h,2,4,100))
```

输出如下：

```py
46.75017499999999
2.1213094390731206
18.416792708494786
```

到目前为止，您可能已经看到了这种数值方法的威力。如果您可以用 Python 表达一个函数，您可以使用用于在曲线下添加所有矩形的函数或更准确地说，用于在曲线下添加所有梯形的函数来获得其积分的非常准确的近似值。

注意

要访问此特定部分的源代码，请参考[`packt.live/3dTUVTG`](https://packt.live/3dTUVTG)。

您还可以在[`packt.live/2Zsfxxi`](https://packt.live/2Zsfxxi)上在线运行此示例。

# 使用积分解决应用问题

如果曲线围绕*x*轴或*y*轴或与其中一个轴平行的线旋转，以形成 3D 对象，我们可以使用积分工具来计算这个固体的体积。例如，假设抛物线*y = x*2 围绕其对称轴旋转形成一个抛物面，如*图 10.16*中所示：

![图 10.16：绕 z 轴旋转的抛物线](img/B15968_10_16.jpg)

图 10.16：绕 z 轴旋转的抛物线

我们可以通过将抛物面的所有*切片*相加来找到体积，就像在二维中使用矩形一样，现在我们在三维中使用圆柱体。在*图 10.16*中，切片是沿着图形向上而不是向右移动的，因此我们可以在脑海中翻转它，并重新定义曲线*y = x*2 为*y = sqrt(x)*。

现在每个圆柱体的半径是*y*值，假设我们从*x = 0*到*x = 1*：

![图 10.17：将抛物面侧翻](img/B15968_10_17.jpg)

图 10.17：将抛物面侧翻

端点仍然是*0*和*1*，但曲线的半径是*y*值，即*sqrt(x)*。因此，每个圆形切片的体积是圆柱体的体积（*pi * radius*2 ** height*），在这种情况下是*pi * r*2 ** thickness*，或*pi * sqrt(x)*2 ** width*。

首先，我们从`math`模块导入`sqrt`和`pi`并定义`f(x)`：

```py
from math import sqrt, pi
def f(x):
    return sqrt(x)
```

然后我们将定义一个函数，该函数将使用抛物面的函数和`x`的起始和结束值。它首先定义运行体积和我们将使用的切片数：

```py
def vol_solid(f,a,b):
    volume = 0
    num = 1000
```

然后，我们通过将*x*值的范围除以切片的数量来计算切片的厚度：

```py
    width = (b-a)/num
```

现在我们计算每个圆柱切片的体积，即*pi * r*2 ** 宽度*。我们将其添加到运行体积中，当循环完成时，我们返回最终体积：

```py
    for i in range(num):
    #     volume of cylindrical disk
        vol = pi*(f(a+i*width))**2*width
        volume += vol    
    return volume
```

让我们把`0`到`1`之间的所有体积加起来：

```py
print(vol_solid(f,0,1))
```

输出将如下所示：

```py
1.5692255304681022
```

这个值是有界抛物面积的近似值。同样，我们将函数分成的切片越多，近似值就越接近真实体积。

## 练习 10.03：找到旋转体的体积

这是另一个旋转体问题：找到以下函数在给定区间上绕*x*轴旋转时形成的固体的体积。

在下图中，绿色曲线是*f(x) = 4 – 4x*2*，红色曲线是*g(x) = 1-x*2*。找到当函数之间的区域围绕*x*轴旋转时形成的固体的体积。

![图 10.18：两个函数的二维外观](img/B15968_10_18.jpg)

图 10.18：两个函数的二维外观

固体的结果形状如下：

![图 10.19：结果形状像一个环](img/B15968_10_19.jpg)

图 10.19：结果形状像一个环

这就像一个找到环的面积的问题，就像前面的图所示。公式如下：

![图 10.20：环形面积公式](img/B15968_10_20.jpg)

图 10.20：环形面积公式

现在使用 Python 来找到固体的体积，执行以下步骤：

1.  像往常一样创建`f`和`g`，以及第三个函数（`h`）作为`f`和`g`的平方的差，来自环面积公式：

```py
def f(x):
    return 4 -4*x**2
def g(x):
    return 1-x**2
def h(x):
    return f(x)**2-g(x)**2
```

1.  现在，固体的体积将是在函数之间制成的给定数量（`num`）的圆柱体的总和。我们和我们的积分函数做同样的事情。圆柱的半径与我们积分时的矩形的高度相同：

```py
def vol_solid(f,a,b):
    volume = 0
    num = 10000
    width = (b-a)/num
    for i in range(num):
```

1.  圆柱的体积是*pi*r*2**h*，我们将其加到总体积中：

```py
        vol = pi*(f(a+i*width))*width
        volume += vol    
    return volume
```

1.  在这里，我们在`-1`和`1`之间的*x*上调用`vol_solid`函数：

```py
print(vol_solid(h,-1,1))
```

输出将如下所示：

```py
50.26548245743666
```

因此，得到的固体的体积为 50.3 立方单位。因此，我们已经使用我们的函数找到了固体的体积，并且已经调整它以找到两个曲线之间的固体的体积。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2NR9Svg`](https://packt.live/2NR9Svg)。

您还可以在[`packt.live/3eWJaxs`](https://packt.live/3eWJaxs)上在线运行此示例。

# 使用导数解决优化问题

在许多应用问题中，我们正在寻找一个最佳点，在这个点，误差最低，例如，或者利润最高。传统的方法是使用函数对情况进行建模，找到函数的导数，并解决使导数为零的输入。这是因为导数在局部最小值和最大值处为零，如下图所示：

![图 10.21：一个三次函数和我们想要找到的点](img/B15968_10_21.jpg)

图 10.21：一个三次函数和我们想要找到的点

我们在图中给出的函数是*f(x) = x*3 *- 2.8x*2 *+ 1.2x + 0.85*。我们有兴趣找到局部最大值，点**A**，和局部最小值，点**B**。我们需要对函数进行微分，并手动解决得到的方程。但是使用计算机，我们可以从网格左侧的一个*x*值开始，小步骤地检查*f(x)*，直到我们得到方向的改变。为此，我们可以使用我们的导数函数来检查导数何时改变符号。

首先，我们定义`f(x)`：

```py
def f(x):
    return x**3-2.8*x**2+1.2*x+0.85
```

然后，我们将定义一个名为`find_max_mins`的函数，从最小的*x*值开始，小步骤地检查导数是否等于零，或者是否改变符号，从正变为负，或者反之。最数学的方法是检查前一个导数乘以新的导数是否为负：

```py
def find_max_mins(f,start,stop,step=0.001):
    x = start
    deriv = derivative(f,x)
    while x < stop:
        x += step
        #take derivative at new x:
        newderiv = derivative(f,x)
        #if derivative changes sign
        if newderiv == 0 or deriv*newderiv < 0:
            print("Max/Min at x=",x,"y=",f(x))
            #change deriv to newderiv
            deriv = newderiv
```

最后，我们调用函数，这样它将打印出导数改变符号的所有值：

```py
find_max_mins(f,-100,100)
```

输出如下：

```py
Max/Min at x= 0.247000000113438 y= 0.9906440229999803
Max/Min at x= 1.6200000001133703 y= -0.3027919999998646
```

这些是*图 10.21*中`f`的局部最大值和局部最小值。

## 练习 10.04：寻找最快的路线

我们可以使用这种找到极值的方法来找到复杂函数的最小值。在传统的微积分课程中，学生们必须代数地求导，将其设为零，然后解决所得方程。我们可以在 Python 中对情况进行建模，并使用我们的导数和`find_max_min`函数轻松找到最小值。这就是情况：灯塔位于离岸 6 公里处，直线海岸上的小屋距离离灯塔最近的海岸点有 9 公里。如果你划船的速度是 3 公里/小时，步行的速度是 5 公里/小时，你应该在哪里着陆才能尽快地从灯塔到小屋？

![图 10.22：灯塔到小屋的距离](img/B15968_10_22.jpg)

图 10.22：灯塔到小屋的距离

执行以下步骤完成练习：

1.  我们的目标是最小化这次旅行所需的时间，所以让我们制定一个时间公式。记住，时间是距离除以速度：![图 10.23：计算时间的公式](img/B15968_10_23.jpg)

图 10.23：计算时间的公式

1.  这就是我们需要最小化的函数。最佳的*x*将在 0 到 9 公里之间，所以当我们调用我们的`find_max_mins`函数时，我们将把它们设置为我们的起始和结束值：

```py
from math import sqrt
def t(x):
    return sqrt(x**2+36)/3 + (9-x)/5

find_max_mins(t,0,9)
```

输出将如下所示：

```py
Max/Min at x= 4.4999999999998375 y= 3.4000000000000004
```

这非常接近沿着海滩的 4.5 公里。这是一个非常有用的计算：我们找到了两点之间的最短距离，当其他约束条件已经放置。

注

要访问此特定部分的源代码，请参阅[`packt.live/31DwYxu`](https://packt.live/31DwYxu)。

您还可以在[`packt.live/38wNRM5`](https://packt.live/38wNRM5)上在线运行此示例。

## 练习 10.05：箱子问题

对于所有微积分学生来说，有一个经典问题，即制造商有一块矩形材料，他们想通过从角落切割相同大小的正方形来制成一个箱子，就像下图所示：

![图 10.24：从矩形的角落切割正方形](img/B15968_10_24.jpg)

图 10.24：从矩形的角落切割正方形

在这种情况下，材料的尺寸是 10 英寸乘以 12 英寸。问题是：找出要切割的正方形的大小，以使得所得箱子的体积最大化：

1.  箱子体积的公式将是长度乘以宽度乘以高度。就*x*而言，从角落切下的正方形的长度，箱子的长度是*12-2x*，因为两个角落被切出了 12 英寸的边。同样，箱子的宽度将是*10-2x*。高度，一旦“盖子”向上弯曲，将是*x*。所以，体积是：![图 10.25：计算体积的公式](img/B15968_10_25.jpg)

图 10.25：计算体积的公式

1.  以下是如何在 Python 中定义这个函数的方法：

```py
def v(x):
    return x*(10-2*x)*(12-2*x)
```

1.  到目前为止，您知道如何将其放入您的`find_max_mins`函数中。我们只想插入 0 到 5 之间的值，因为超过 5 英寸将意味着我们将没有一边（宽度为 10 英寸）：

```py
find_max_mins(v,0,5)
```

输出将如下所示：

```py
Max/Min at x= 1.8109999999999113 y= 96.77057492400002
```

通过切割边长为 1.81 英寸的正方形来实现最大体积。这是体积的图表：

![图 10.26：实现最大值的图表](img/B15968_10_26.jpg)

图 10.26：实现最大值的图表

我们可以看到，当每边切割 1.81 英寸的正方形时，最大体积就会实现，因为这是图中最大点的位置。

注

要访问此特定部分的源代码，请参阅[`packt.live/3gc11AC`](https://packt.live/3gc11AC)。

您还可以在[`packt.live/2NNSNmb`](https://packt.live/2NNSNmb)上在线运行此示例。

## 练习 10.06：最佳罐头

一个圆柱体罐子可以容纳 355 立方厘米的苏打水。哪些尺寸（半径和高度）将使得构造罐子的金属成本最小？你可以忽略罐子的顶部：

1.  圆柱体的表面积是底部的面积（一个圆，所以πr2）加上它的侧面积，这是一个底部为*2πr*，高度为*h*的矩形。圆柱体的体积是πr2h，所以我们把它全部放在一起：![图 10.27：计算圆柱体体积的公式](img/B15968_10_27.jpg)

图 10.27：计算圆柱体体积的公式

1.  体积已经设定为 355。从那里，我们可以得到一个关于* r *的表达式，然后我们将表面积都转化为一个变量的表达式：![图 10.28：在公式中替换值](img/B15968_10_28.jpg)

图 10.28：在公式中替换值

1.  让我们用 Python 表达它，并把它放到我们的`find_max_mins`函数中：

```py
from math import pi
def surf_area(r):
    return pi*r**2 + 710/r
find_max_mins(surf_area,0.1,10)
```

运行代码时，输出将如下所示：

```py
Max/Min at x= 4.834999999999949 y= 220.28763352297025
```

因此，解决方案是半径约为 4.8 厘米，高度约为 355/(π(4.8)2) = 4.9 厘米。这意味着罐子的宽度大约是高度的两倍。这是一个`surf_area`函数的图，显示了 2 到 6 厘米之间的罐子。你可以看到最小化材料的点，在 4.5 和 5 厘米之间。我们计算得到确切的值是 4.9 厘米：

![图 10.29：找到制作罐子所需的最小材料](img/B15968_10_29.jpg)

图 10.29：找到制作罐子所需的最小材料

注意

要访问本节的源代码，请参阅[`packt.live/2Zu2bAK`](https://packt.live/2Zu2bAK)。

你也可以在[`packt.live/38lUNeE`](https://packt.live/38lUNeE)上在线运行这个例子。

## 练习 10.07：计算两艘移动船之间的距离

中午时，A 船在 B 船的北面 20 公里。如果 A 船以 6 公里/小时向南航行，B 船以 8 公里/小时向东航行，找到两艘船之间距离最小的时间。以下图显示了这种情况：

![图 10.30：A 和 B 船向南和东移动](img/B15968_10_30.jpg)

图 10.30：A 和 B 船向南和东移动

执行以下步骤找到时间：

1.  距离是速度乘以时间，因此两艘船之间的距离可以用这个方程来建模：![图 10.31：计算距离的公式](img/B15968_10_31.jpg)

图 10.31：计算距离的公式

1.  让我们用 Python 表达这个问题，并把它放到我们的`find_max_mins`函数中：

```py
from math import sqrt
def d(t):
    return sqrt((20-6*t)**2+(8*t)**2)
```

1.  我们假设时间将在`0`和`4`小时之间：

```py
find_max_mins(d,0,4)
```

输出将如下所示：

```py
Max/Min at x= 1.1999999999999786 y= 16.0
```

因此时间是 1.2 小时，由下图上的最小点表示。两小时的十分之一是 12 分钟，这意味着两艘船在下午 1:12 时最接近。这是距离与时间的图：

![图 10.32：距离与时间的图](img/B15968_10_32.jpg)

图 10.32：距离与时间的图

注意

要访问本节的源代码，请参阅[`packt.live/38k2kuF`](https://packt.live/38k2kuF)。

你也可以在[`packt.live/31FK3GG`](https://packt.live/31FK3GG)上在线运行这个例子。

## 活动 10.01：最大圆锥体积

这是一个经典的优化问题，如果你手工完成，将导致一些非常复杂的方程式来求导和解决。然而，使用 Python 将使微积分部分变得更容易。你从一个圆开始，切出一个θ度的扇形。然后你在下图中连接点**A**和**B**，制作一个圆锥：

![图 10.33：圆锥体积](img/B15968_10_33.jpg)

图 10.33：圆锥体积

问题，就像在盒子问题中一样，是找到切出的角度，使圆锥体的体积最大化。这将要求你想象切出角度，连接点制作圆锥体，并计算结果圆锥体的体积。

完成步骤：

1.  找到`AB`的弧长。

1.  找到* h *，结果圆锥体的高度。

1.  找到* r *，圆锥的底半径。

1.  找出圆锥的体积表达式作为角度切出的函数(*θ*)。

注意

此活动的解决方案可在第 694 页找到。

# 总结

微积分的工具使数学家和科学家能够处理不断变化的值，这些工具改变了科学研究的方式。突然之间，我们可以使用无限小的步骤来近似曲线在某一点的斜率，或者使用无限小的矩形来近似曲线下的面积。这些工具是在我们现代计算机和免费编程软件的世界出现数百年之前发展起来的，但是没有理由限制自己只使用牛顿、莱布尼兹和伯努利可用的工具。

在本章中，我们学会了通过简单地将函数从一个点到另一个点的*上升*除以这些点之间的无限小*运行*来对函数进行求导。我们只需告诉 Python 将 1 除以一百万，就可以得到这个小数。没有计算机的话，将这些小数插入函数将是一项艰巨的任务，但是 Python 可以像处理整数一样轻松地将小数插入函数。

我们利用导数的概念来找到函数的最高或最低输出，其中导数等于零。这使我们能够找到函数的最优值，例如产生最短距离或最大体积。

微积分中第二重要的主题是积分，这使我们能够使用矩形、梯形或圆柱体逐层构建复杂的面积或体积。使用 Python，我们可以轻松地组合数百或数千个切片，准确地近似一个面积或体积。

我们只是触及了微积分和 Python 赋予我们处理变化值、无限小值以及无限大值的能力的表面。

在下一章中，我们将扩展这些基本工具，以找到曲线的长度、表面的面积，以及对机器学习最有用的，表面上的最小点。

WFT54

GLS48
