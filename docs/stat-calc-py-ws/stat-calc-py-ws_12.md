# 第十二章：12.使用 Python 进行中级微积分

概述

在本章结束时，你将能够解决涉及变量变化的方程的问题。在本章中，你将使用数值方法来模拟人口和温度，并使用微分方程来计算它们的过去值或预测它们的未来值。当你知道数字在特定范围内时，你将学会使用二分搜索来*猜测和检查*，以获得非常准确的解决方案。你还将模拟物体移动的情况，并在给定它们的速度微分方程时解决它们的未来位置。

# 介绍

数学学生经常抱怨代数和几何中出现的问题没有现实世界的应用，比如因式分解多项式或者角的二等分，但对于微分方程却不能这样说。使用本章中将学到的工具，你将能够用微分方程模拟和解决物理、电子和工程中的真实问题。Python 是数学家和科学家的完美工具，他们想要进行数字计算和解决问题，但又不想为此再获得计算机科学学位。Python 是最受欢迎的编程语言之一，因为它易于使用且没有不必要的抽象。

到了 17 世纪，数学家们用数学方程模拟了物体的运动，并把目光投向了外层空间的行星。牛顿模拟了它们的运动，他提出的方程不仅涉及未知数，还涉及这些数字的变化。例如，他的方程不仅包含一个未知角度，还包含这个角度的变化（它的角速度），甚至是角度变化的变化（它的加速度）！当时没有工具来解决这些方程，所以他不得不自己发明这些工具。这些工具后来被称为微积分。

# 微分方程

在数学课上解方程通常涉及一个未知数*x*。方程隐藏了这个值，但给了你一些提示，告诉你如何找到这个值，比如![1](img/B15968_12_InlineEquation1.png)。但是要解微分方程，你只能得到关于函数的导数的信息，然后期望你找到这个函数。可能是像下面这样简单的东西：

![图 12.1：找到导数为 2 的函数](img/B15968_12_01.jpg)

图 12.1：找到导数为 2 的函数

这意味着*找到一个导数为 2 的函数*。这也可以写成如下形式：

![图 12.2：表示函数导数的另一种方式](img/B15968_12_02.jpg)

图 12.2：表示函数导数的另一种方式

通过简单的积分，我们可以找到适用于这个方程的函数，因为我们知道函数*y = 2x*的导数是 2。事实上，许多相关函数，比如*y = 2x + 1*，*y = 2x + 2*，*y = 2x + 3*等等，它们的导数都是 2。所以，我们写出一个一般形式，即*y = 2x + C*。

当我们没有太多线索时，事情就变得更加复杂，就像在这个方程中：

![图 12.3：函数值为函数本身的导数](img/B15968_12_03.jpg)

图 12.3：函数值为函数本身的导数

这是要求一个导数为函数本身的函数。

为了理解微分方程是如何使用的，让我们从简单的函数开始，以及涉及到现实世界中的东西，比如金钱。

# 利息计算

微分方程研究中有一个关键工具起源于中世纪的利息计算研究。让我们来看下面的练习。

## 练习 12.01：计算利息

一个储蓄账户每年支付 2%的利息。如果投资了 3500 美元，5 年后账户中有多少钱？

简单利息的公式如下：

![图 12.4：简单利息公式](img/B15968_12_04.jpg)

图 12.4：简单利息公式

在这里，*I*是利息，*P*是本金或原始投资金额，*r*是利率或增长率，*t*是投资金额已投资的时间。根据这个公式，金额的利息为*I = (3500)(0.02)(5) = 350 美元*。按照以下步骤完成此练习：

1.  这是一个很好的机会来开始一个程序，它将接受初始金额、利率和时间，并使用前面的公式输出利息收入：

```py
def amount(p0,rate,t):
    """Returns the amount after t
    years starting at p0 and growing
    at the given rate per year"""
    return p0*rate*t
```

1.  如您在`amount`函数的文档字符串中所看到的，它将接受一个起始金额和增长率，并返回给定年数后的投资金额。让我们看看 1-5 年内的利息收入：

```py
for i in range(1,6):
    print(i,amount(3500,0.02,i))
```

以下是输出：

```py
1 70.0
2 140.0
3 210.0
4 280.0
5 350.0
```

但这并不是利息的真正工作方式。每年几次，我们计算该年份的利息收入，将其加到本金中，新的本金更高。下一次的利息计算是在更高的数字上，因此称为*复利*。给定*每年 n 次复利*的*t*年后的金额的公式如下：

![图 12.5：计算 t 年后的金额公式](img/B15968_12_05.jpg)

图 12.5：计算 t 年后的金额公式

1.  让我们将`amount`函数更改为以下内容：

```py
def amount(p0,rate,t,comps):
    """Returns the amount after t
    years starting at p0 and growing
    at the given rate per year
    compounded comps times per year"""
    for i in range(int(t*comps)):
        p0 += p0*rate/comps
    return p0
```

在这个函数中，我们添加了按复利次数给出的年份的利息收入。如果我们每年只计算一次复利，看起来是这样的：

```py
for i in range(1,6):
    print(i,amount(3500,0.02,i,1))
```

这就是我们得到的：

```py
1 3570.0
2 3641.4
3 3714.228
4 3788.51256
5 3864.2828112
```

因此，在 5 年结束时，我们赚了 364 美元，而不仅仅是 350 美元。即使利率相同，复利更频繁也会使金额增长更快。如果我们将复利更改为每年 12 次（每月复利），我们将在 5 年后得到 3867 美元，比年复利多一点。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3dUWz7C`](https://packt.live/3dUWz7C)。

您也可以在[`packt.live/3iqUKCO`](https://packt.live/3iqUKCO)上在线运行此示例。

## 练习 12.02：计算复利-第 1 部分

在一个年利率为 5.5%的储蓄账户中投资了 2000 美元，按月复利。要将金额增长到 8000 美元需要多长时间？按照以下步骤来解决这个问题：

1.  我们将使用我们从上一个练习中的`amount`函数打印出投资的前 5 年：

```py
for i in range(1,6):
    print(i,amount(2000,0.055,i,12))
```

输出如下：

```py
1 2112.815720771071
2 2231.9951349686903
3 2357.8972049231984
4 2490.9011412619493
5 2631.4075450724245
```

1.  5 年后，金额只有 2631 美元。要达到 8000 美元，我们必须走 20 或 30 年：

```py
for i in [5,10,15,20,25,30]:
    print(i,amount(2000,0.055,i,12))
```

输出如下：

```py
5 2631.4075450724245
10 3462.1528341320413
15 4555.167544964467
20 5993.251123444263
25 7885.343112872511
30 10374.775681348801
```

在 25 到 30 年之间的某个时候，我们将达到 8000 美元。更精确的方法是更聪明地猜测。

1.  我们将范围减半，并根据我们得到的结果猜测更高或更低。例如，25 年和 30 年的平均值是 27.5，因此我们输入以下内容：

```py
print(amount(2000,0.055,27.5,12))
```

以下是输出：

```py
9044.814313545687
```

因此，我们将在 27.5 年内达到 9000 美元。达到 8000 美元的时间必须少于这个时间。

1.  我们将计算 25 和 27.5 的平均值并将其代入：

```py
def average(a,b):
    return (a+b)/2
print(amount(2000,0.055,average(25,27.5),12))
```

以下是输出：

```py
8445.203624219383
```

1.  让我们编写一个程序，直到找到答案为止。这称为**二分搜索**。让我们创建一个`bin_search`函数，它将使用我们正在使用的函数的名称，我们正在搜索的范围的下限和上限以及目标输出（在本例中为 8000）作为参数：

```py
def bin_search(f,lower,upper,target):
    for i in range(20):
        avg = average(lower,upper)
```

1.  这是关键的一行。它将平均值插入函数中，使用所有其他必需的参数，并将输出分配给`guess`变量。我们将检查该变量是否等于我们的目标，或者我们是否需要猜测更高或更低：

```py
        guess = f(2000,0.055,avg,12)
        if guess == target:
            return guess
        if guess > target:
            upper = avg
        else:
            lower = avg
    return avg
```

1.  我们将我们范围的下限和上限以及我们的目标数字代入我们的函数，以获得我们的近似值：

```py
bin_search(amount,25,30,8000)
```

输出如下：

```py
25.333333015441895
```

1.  看起来我们将在**25 年零 4 个月**内达到 8000 美元。让我们检查一下：

```py
amount(2000,0.055,25.334,12)
```

果然，复利后的余额超过了 8000 美元：

```py
8030.904658737448
```

我们将再次使用二分搜索，但现在，让我们使用我们的代码来找到一个在微分方程中经常出现的相当重要的数学常数。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3iq95PV`](https://packt.live/3iq95PV)

您还可以在[`packt.live/2BpdbHI`](https://packt.live/2BpdbHI)上在线运行此示例

## 练习 12.03：计算复利-第 2 部分

如果您以 100%的利率投资$1，连续复利 1 年，您会赚多少？

请记住，复利的频率越高，最终金额就越高。您认为会是多少？$1.50？$2？本金、利率和时间都是 1，但`comps`变量是什么？按照以下步骤完成这个练习：

1.  为了近似连续复利，我们将每秒复利一次（每年*365*24*60*60*次）：

```py
print(amount(1,1,1,365*24*60*60))
```

输出如下：

```py
2.7182817853606362
```

大约是$2.72。这个数字，2.71828…，是自然对数的底数*e*。它对于模拟自然界中的人口非常有用，因为动物、植物和微生物不会等到月底才繁殖-它们是持续不断地繁殖。因此，当利息连续复利或人口自然增长时，我们将使用这个公式：

![图 12.6：计算复利的公式](img/B15968_12_06.jpg)

图 12.6：计算复利的公式

1.  让我们创建一个函数来快速完成这个任务。首先，我们需要从`math`模块中导入*e*以进行连续复利：

```py
from math import e
```

1.  创建一个`pert`函数，它将插入初始金额或人口、增长率和时间，并返回最终金额：

```py
def pert(P,r,t):
    return P*e**(r*t)
```

我们将在本章中多次使用这个函数。现在，让我们回答更多的投资问题。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2D2Q1r0`](https://packt.live/2D2Q1r0)

您还可以在[`packt.live/31G5pDQ`](https://packt.live/31G5pDQ)上在线运行此示例

## 练习 12.04：计算复利-第 3 部分

一个人以每月复利的 18%年利率借了$5,000。1 年后这个人会欠多少钱？按照以下步骤完成这个练习：

1.  我们可以将其放入我们的函数调用中：

```py
amount(5000,0.18,1,12)
```

输出如下：

```py
5978.090857307678
```

为了比较，让我们看看如果利息是连续复利会发生什么。

1.  我们将使用我们的`pert`函数输入`P = 5000`，`r = 0.18`和`t = 1`作为值：

```py
print("Continuous:",pert(5000,0.18,1))
```

得到的金额如下：

```py
5986.096815609051
```

注意

要访问此特定部分的源代码，请参阅[`packt.live/31ES5Qi`](https://packt.live/31ES5Qi)

您还可以在[`packt.live/3f5j0s4`](https://packt.live/3f5j0s4)上在线运行此示例

## 练习 12.05：成为百万富翁

如果您以每日复利 8%的年利率投资$1,000，要成为百万富翁需要多长时间？如果初始金额是$10,000 呢？按照以下步骤完成这个练习：

1.  首先，让我们定义`bin_search`函数，如下所示：

```py
def bin_search(f,lower,upper,target):
    for i in range(20):
        avg = average(lower,upper)
        #Be sure to change this line
        #if the principal, rate or
        #compounding changes:
        guess = f(1000,0.08,avg,365)
        if guess == target:
            return guess
        if guess > target:
            upper = avg
        else:
            lower = avg
    return avg
```

1.  让我们猜一些野生的猜测，看看如果$1,000 投资这些年，我们会得到多少：

```py
for i in [10,20,30,40,50]:
    print(i,amount(1000,0.08,i,365))
```

这是输出：

```py
10 2225.34584963113
20 4952.164150470476
30 11020.277938941583
40 24523.929773205105
50 54574.22533744746
```

1.  50 年后，您仍然只有$54,000，而不是一百万。但是 100 年后，您将拥有近 300 万：

```py
amount(1000,0.08,100,365)
```

这是输出：

```py
2978346.0711824815
```

1.  答案必须在 50 和 100 之间。看起来是我们二分搜索的任务：

```py
print(bin_search(amount,50,100,1000000))
```

我们得到以下输出：

```py
86.3588809967041
```

1.  这表明在 86.36 年后，我们将拥有 100 万美元。如果初始投资是$10,000，那么在`bin_search`函数中更新`guess`变量：

```py
        guess = f(10000,0.08,avg,365)
```

这是我们将打印所需输出的方法：

```py
for i in [10,15,20,30,40,50,60]:
    print(i,amount(10000,0.08,i,365))
```

输出如下：

```py
10 22253.458496311334
15 33196.803971077774
20 49521.64150470513
30 110202.77938941623
40 245239.2977320514
50 545742.2533744735
60 1214465.2585152255
```

1.  因此，我们在 50 到 60 年之间就能达到 100 万美元。让我们在我们的二分搜索函数中将`1000`改为`10000`并检查一下：

```py
print(bin_search(amount,50,60,1000000))
```

我们得到以下输出：

```py
57.57260322570801
```

超过 57.57 年才能达到一百万美元。

因此，我们开始学习微分方程是通过研究复利来学习的。一定金额的钱每年、每月或每天都会有利息率。初始金额

注意

要访问此特定部分的源代码，请参阅[`packt.live/31ycoPg`](https://packt.live/31ycoPg)

您也可以在[`packt.live/2NMT9sX`](https://packt.live/2NMT9sX)上在线运行此示例

现在，我们将同样的推理扩展到人、动物、细菌和热量的数量，这些数量不断变化，或者说是*连续*的。

# 人口增长

微分方程对于找到特定时间的人口、动物和细菌的数量的公式非常有用；例如：

![图 12.7：计算时间 t 的微分方程](img/B15968_12_07.jpg)

图 12.7：计算时间 t 的微分方程

这个微分方程意味着*y*的变化速率与*y*成比例，或者说人口的增长与其数量成比例。这就是人口增长率的定义：人口的一部分或百分比。解决方案类似于涉及连续复利的利息问题：

![图 12.8：计算变化率的微分方程](img/B15968_12_08.jpg)

图 12.8：计算变化率的微分方程

## 练习 12.06：计算人口增长率-第 1 部分

在 1980 年代，肯尼亚的年人口增长率为 4%。以这个速度，人口翻倍需要多长时间？按照以下步骤完成这个练习：

1.  无论初始人口是多少，我们都在寻找使因子*e*rt 等于 2 的*t*。我们可以使用我们的`pert`函数和二项式搜索函数，稍作调整：

```py
def bin_search(f,lower,upper,target):
    for i in range(40):
        avg = average(lower,upper)
        guess = f(1,0.04,avg)
        if guess == target:
            return guess
        if guess > target:
            upper = avg
        else:
            lower = avg
    return avg
```

1.  我们正在寻找时间*t*，以 4%的增长率将我们的初始人口从 1 增加到 2。我们估计这个时间会在 1 到 100 年之间：

```py
print(bin_search(pert,1,100,2))
```

输出如下：

```py
17.32867951408025
```

我们可以用代数来验证这一点。我们取方程两边的对数并解出*t*：

![图 12.9：解决时间(t)的方程](img/B15968_12_09.jpg)

图 12.9：解决时间(t)的方程

1.  这意味着在 17 年多一点的时间内，肯尼亚的人口将翻倍。我们可以用我们的`amount`函数来验证这一点。1989 年，肯尼亚的人口为 2100 万：

```py
print(amount(21000000,0.04,17.3,1000000))
```

以下是输出：

```py
41951845.46179989
```

是的，每年使用一百万次复利，人口在 17.3 年内增长到了将近 4200 万。

作为对此的回应，肯尼亚政府大力推广*计划生育*。这有效果吗？

注意

要访问此特定部分的源代码，请参阅[`packt.live/2BxsfCT`](https://packt.live/2BxsfCT)

您也可以在[`packt.live/2Zuoy9c`](https://packt.live/2Zuoy9c)上在线运行此示例

## 练习 12.07：计算人口增长率-第 2 部分

2010 年，肯尼亚的人口为 4200 万。到 2019 年，人口为 5250 万。该范围的年人口增长率是多少？

我们可以再次使用二分搜索函数，返回给定初始人口（以百万计）、时间*t*和 9 年后的目标人口（以百万计）的增长因子*r*。

在`bin_search`函数中，将时间更改为`9`：

```py
        guess = f(1,avg,9)
```

然后，我们将找到这 9 年的年增长率。我们知道它在 0 到 2 之间：

```py
print(bin_search(pert,0,2,52.5/42))
```

打印出的值如下：

```py
0.024793727925498388
```

计划生育项目一定是有效的！肯尼亚将其人口增长率降低到了 2.5%。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3eWKzDW`](https://packt.live/3eWKzDW)

您也可以在[`packt.live/31EKPUq`](https://packt.live/31EKPUq)上在线运行此示例

# 放射性材料的半衰期

与人口问题类似，半衰期问题涉及一个群体，但其中一半是放射性材料的原子，其中一半的原子随着时间变成了不同物质的原子。例如，碳-14 衰变成氮-14，大约需要 5730 年才能使一半的碳衰变。这使得*放射性碳测年*成为从考古学到检测伪造艺术品的关键工具。

## 练习 12.08：测量放射性衰变

镭-226 的半衰期为 1600 年。在给定样本中，800 年内将消失多少镭？

意思是“物质的衰变速率与物质的数量成比例”的微分方程表达如下：

![图 12.10：用于计算物质衰变速率的微分方程](img/B15968_12_10.jpg)

图 12.10：用于计算物质衰变速率的微分方程

解决方案与我们的人口问题类似，只是衰减因子是负的，因为数量减少：

![图 12.11：使用负衰变因子计算变化率](img/B15968_12_11.jpg)

图 12.11：使用负衰变因子计算变化率

这意味着最终金额等于时间的初始金额，*e*，乘以衰减因子，*r*，和时间，*t*的乘积。我们可以像解决人口问题一样使用我们的二分搜索函数。我们正在寻找在 1,600 年内使我们的人口减半的增长率*r*。按照以下步骤完成这个练习：

1.  在`bin_search`函数中的`guess =`行中将`t`更改为`1600`：

```py
        guess = f(1,avg,1600)
```

1.  然后，搜索增长因子，我们认为它将在-2 和 0 之间。我们的目标金额是起始金额的一半：

```py
print(bin_search(pert,-2,0,0.5))
```

以下是输出：

```py
-0.0004332169864937896
```

1.  这就是镭-226 的衰变因子*r*。我们要做的就是将其插入我们的`pert`函数中，以找出 800 年后剩下的样本的百分比：

```py
pert(1,-0.0004332,800)
```

以下是输出：

```py
0.7071163910309745
```

因此，大约 71%的样本在 800 年后仍然存在。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2YSzQ84`](https://packt.live/2YSzQ84)

您还可以在[`packt.live/2ByUwJj`](https://packt.live/2ByUwJj)上在线运行此示例

## 练习 12.09：测量历史文物的年龄

对一块布进行了放射性碳测年。这意味着科学家们测量了有多少碳-14（半衰期 5730 年）衰变成了更稳定的同位素。他们发现剩下的碳-14 的数量是碳-13 的 10 倍。这块布有多大年龄？

如果碳-14 需要 5730 年使其数量减半，我们需要找到我们的 Pert 公式的速率*r*：

![图 12.12：Pert 公式](img/B15968_12_12.jpg)

图 12.12：Pert 公式

按照以下步骤完成这个练习：

1.  我们使用我们的二分搜索函数来解决*r*：

```py
def bin_search(f,lower,upper,target):
    for i in range(40):
        avg = average(lower,upper)
```

1.  这是更改的那一行。如果我们在`pert`函数中放入一个起始金额为`1`，*r*将是`avg`，`5730`将是目标时间：

```py
        guess = f(1,avg,5730)
        if guess == target:
            return guess
        if guess > target:
            upper = avg
        else:
            lower = avg
    return avg
print(bin_search(pert,-2,0,0.5))
```

以下是输出：

```py
-0.00012096809405193198
```

*r = -0.000120968*，因此我们的 Pert 公式变为如下：

![图 12.13：在 Pert 公式中替换 r 的新值](img/B15968_12_13.jpg)

图 12.13：在 Pert 公式中替换 r 的新值

这意味着*x*克的碳-14 衰变了，剩下的是 10x 克，是整个样本的 10 倍。因此，衰变量是整个样本的 1/11 或 0.091。结束金额是 1-0.091。这使我们的 Pert 方程如下：

![图 12.14：带有结束金额的 Pert 方程](img/B15968_12_14.jpg)

图 12.14：带有结束金额的 Pert 方程

1.  我们方程中唯一未知的是*t*，因此我们正在更改我们的`bin_search`函数，以便有策略地猜测和检查正确的*t*。返回到您的`bin_search`函数；开头应该是这样的：

```py
def bin_search(f,lower,upper,target):
    for i in range(40):
        avg = average(lower,upper)
```

1.  这是我们正在更改的行。我们将 1 代入原始量，长小数是我们的*r*，时间范围的平均值用于时间。目标是样本的 0.091，这将保持猜测和平均值，直到返回确切的年数以达到目标值：

```py
        guess = f(1,-0.000120968,avg)
        if guess == target:
            return guess
```

1.  由于它是一个递减函数，如果猜测小于目标值，我们将会超过目标值，`upper`数字将被替换为平均值：

```py
        if guess < target:
            upper = avg
        else:
            lower = avg
    return avg
print(bin_search(pert,1,100000,0.91))
print(pert(1,-0.000120968,5730))
```

1.  请注意，我们更改了`if guess < target:`行。我们正在寻找从 1 到 0.91 的衰减量所需的年数，以给定的速率。我们怀疑它在 1 到 100,000 年之间。第二个`print`行只是检查我们的`pert`函数确认在 5,730 年后，剩余量正好是原始量的一半。当我们运行代码时，这是输出：

```py
779.633287019019
0.5000002702800457
```

根据我们的计算，这块布大约有**780 年**的历史。

因此，我们最初编写此代码是为了测量投资中剩余的金额，该投资以给定的利率增长一段时间。在本节中，我们将此应用于物体中放射性物质的剩余量，该物质以已知速率衰变，时间未知。这就是科学家计算考古文物年龄的方法。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3eOJJJv`](https://packt.live/3eOJJJv)。

您也可以在[`packt.live/38mESgn`](https://packt.live/38mESgn)上在线运行此示例。

接下来，我们将使用相同的思路，但将其应用于物体的温度变化，比如一杯咖啡或人体的温度。

# 牛顿冷却定律

你是否曾经想过在警察节目中带着乳胶手套的**犯罪现场调查员**（**CSI**）如何判断受害者的死亡时间？艾萨克·牛顿被认为是发现物质冷却遵循微分方程的人：

![图 12.15：温度变化速率的微分方程](img/B15968_12_15.jpg)

图 12.15：温度变化速率的微分方程

看看这个微分方程与我们以前看到的微分方程略有不同？这不是物质温度变化速率与物质温度成比例，而是说“物质温度变化速率与物质温度与环境温度之间的差值成比例”。因此，如果一杯热咖啡放在热的房间里，它的温度变化速度会比放在非常冷的房间里慢。同样，我们知道警察节目中受害者的体温起始温度：98.6°F。

## 练习 12.10：计算死亡时间

一名调查员到达犯罪现场并测量环境和尸体的温度。如果环境温度为 65°，尸体温度为 80°，调查员记录时间并等待一小时。尸体温度与环境温度的差为 15 度。一个小时后，环境温度仍为 65°，尸体进一步冷却至 75°。温度差现在为 10 度。受害者是何时死亡的？

有了这些信息，她可以建立以下方程：

![图 12.16：计算死亡时间的方程](img/B15968_12_16.jpg)

图 12.16：计算死亡时间的方程

按照以下步骤完成这个练习：

1.  我们可以使用二分搜索来找出温度的衰减率。我们需要导入`e`并确保我们有`pert`和`average`函数：

```py
from math import e
def pert(P,r,t):
    return P*e**(r*t)
def average(a,b):
    return (a+b)/2
```

1.  我们的`bin_search`函数的第一部分与以前相同：

```py
def bin_search(f,lower,upper,target):
    for i in range(40):
        avg = average(lower,upper)
```

1.  这里的重要变化是：我们的原始量（温度差）为 15 度，我们想知道*r*，即我们 Pert 公式中的变化率：

```py
        guess = f(15,avg,1)
        if guess == target:
            return guess
        if guess > target:
            upper = avg
        else:
            lower = avg
    return avg
print(bin_search(pert,-2,0,10))
```

这是输出：

```py
-0.4054651081078191
```

这就是这种情况的衰减速率，所以我们知道了尸体温度与环境温度之间的初始差异（98.6-65），以及最终差异（10）和衰减速率。这是情况的图表：

![图 12.17：冷却体的图表](img/B15968_12_17.jpg)

图 12.17：冷却体的图表

我们只需要知道差异衰减到 10 所需的小时数。我们的方程如下：

![图 12.18：差异衰减到 10 所需的小时数](img/B15968_12_18.jpg)

图 12.18：差异衰减到 10 所需的小时数

1.  我们改变我们的二分搜索函数来获取时间：

```py
def bin_search(f,lower,upper,target):
    for i in range(40):
        avg = average(lower,upper)
        guess = f(33.6,-.4055,avg)
        if guess == target:
            return guess
        if guess > target:
            upper = avg
        else:
            lower = avg
    return avg
```

但是，如果时间太短，差异将太大。绕过这个最简单的方法是将更高的*t*作为函数调用的*较低*部分，将较低的*t*作为搜索范围的*上限*。

1.  调查员推断时间必须在 0 到 5 小时之间：

```py
print(bin_search(pert,5,0,10))
```

输出将如下：

```py
2.9887570258370033
```

几乎正好 3 小时。这看起来接近前图中曲线的*y*值为 10 的时间。

1.  让我们在我们的`pert`函数中检查一下。从*r = -0.4055*和*t = 3.0*开始，差异为 33.6 度。希望最终得到 10：

```py
pert(33.6,-0.4055,3)
```

以下是输出：

```py
9.954513505592326
```

所以，现在，当明星侦探在凌晨 2:30 到达现场时，调查员可以说，“死亡时间大约是晚上 11:30。”

注意

要访问此特定部分的源代码，请参阅[`packt.live/38jN68K.`](https://packt.live/38jN68K )

您还可以在[`packt.live/3gefegi.`](https://packt.live/3gefegi )上在线运行此示例

## 练习 12.11：计算温度变化的速率

一杯温度为 175°F 的咖啡放在一个 72°F 的房间里。我们等待 15 分钟，测量咖啡的温度，发现它已经变成了 140°F。按照这个速度，从开始算起 1 小时后它的温度会是多少？按照以下步骤完成这个练习：

1.  差异从 103°（175-72）开始。在 0.25 小时内，它变为 68°（140-72）。现在，我们可以建立一个方程：![图 12.19：计算咖啡温度差异的方程](img/B15968_12_19.jpg)

图 12.19：计算咖啡温度差异的方程

1.  我们可以改变我们的二分搜索函数以反映这种情况。将`guess=`行更改为`bin_search`函数中的以下内容：

```py
        guess = f(103,avg,0.25)
```

1.  运行它，找出在-2 和 0 之间的*r*将给我们带来 68°的差异：

```py
print(bin_search(pert,-2,0,68))
```

这是输出：

```py
-1.6608851322143892
```

1.  太快了！将其放入我们的 Pert 公式中，*P = 103*和*t=1*：

```py
pert(103,-1.6608851322143892,1)
```

以下是输出：

```py
19.566987911888482
```

这是 1 小时的差异。如果房间温度为 72°，那意味着咖啡将是*72 + 19.5 = 91.5°*。

注意

访问此特定部分的源代码，请参阅[`packt.live/3gl5p0i.`](https://packt.live/3gl5p0i )

您还可以在[`packt.live/2YTdCmw.`](https://packt.live/2YTdCmw )上在线运行此示例

# 混合问题

在代数中，有一些需要计算的文字问题，您必须计算出需要添加多少材料到混合物中才能获得特定的浓度或数量。在微积分中，自然，问题必须更难：例如，混合物正在改变；材料正在进入混合物，材料正在流出。您必须找出在特定时间后有多少混合物或溶剂。让我们看看以下练习，以更好地理解这个概念。

## 练习 12.12：解决混合问题-第 1 部分

一个罐子里含有 82 加仑的卤水，其中溶解了 18 磅的盐。每分钟以 5 加仑的速度流入罐子的卤水中含有每加仑 3 磅的溶解盐。这种混合物通过搅拌保持均匀，以每分钟 2 加仑的速度流出罐子。39 分钟后罐子里有多少盐？

正如你可以想象的，这种问题会导致一些复杂的微分方程，只有经过几页的代数运算，你才能得到一个方程（通常涉及到* e*的某个幂），然后你可以将时间代入并得到最终的数量。然而，使用编程，我们只需从给定的起始溶液开始，并添加和减去问题所需的任何材料。这只是一个跟踪溶液和溶质的问题。按照以下步骤完成这个练习：

1.  让我们创建一个函数，以找出在`t`分钟后的盐含量，给定我们的初始条件：

```py
def salt_content(t):
    salt = 18 #pounds
    brine = 82 #gallons
```

1.  然后，每分钟都会添加 5 加仑的卤水，其中含有 15 磅（每加仑 3 磅盐*每加仑*）的盐：

```py
    for i in range(t):
        brine += 5
        salt += 15
```

1.  现在，每分钟流出 2 加仑的卤水，但其中含有多少盐呢？这要求我们找出每加仑卤水的浓度：![图 12.20：计算每加仑卤水浓度的公式](img/B15968_12_20.jpg)

图 12.20：计算每加仑卤水浓度的公式

这可以很容易地转换为代码，如下所示：

```py
        concentration = salt/brine
```

1.  因此，每分钟离开罐子的盐将是流出的溶液加仑数乘以盐的浓度：

```py
        salt_out = 2*concentration
        salt -= salt_out
        brine -= 2
```

1.  循环结束后，我们可以打印出卤水和盐的最终数量：

```py
    print(i,brine,salt)
```

1.  为了解决我们的问题，我们只需运行我们的`salt_content`函数，*t=39*：

```py
salt_content(39)
```

输出如下：

```py
38 199 469.2592152141211
```

这意味着在 39 分钟后，我们最终得到 469 磅盐。这个数字非常接近解析解，但并不完全相同。我们该怎么做才能得到更准确的结果呢？记住，自然对数的底数*e*的背后思想是模拟值的恒定变化，而我们只是每分钟计算一次我们溶液的变化。

1.  让我们引入一个名为`frac`的变量，它将让我们计算分钟的变化：

```py
def salt_content(t,frac=0.001):
    salt = 18 #pounds
    brine = 82 #gallons
```

1.  参数中的`frac=0.001`值表示我们将每分钟计算一千次变化。这意味着我们将循环的次数乘以 1,000，或者 1/`frac`，我们将我们的数量变化乘以`frac`：

```py
    for i in range(int(t/frac)):
        brine += 5*frac
        salt += 15*frac
        concentration = salt/brine
        salt_out = 2*concentration*frac
        salt -= salt_out
        brine -= 2*frac
    print(i,brine,salt)
salt_content(39)
```

输出变成了以下内容：

```py
38999 198.99999999966812 470.74539697793307
```

470.7 磅盐甚至更接近解析解，使用更小的分钟分数并不会改变输出太多。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2BlX2Tn`](https://packt.live/2BlX2Tn)。

您也可以在[`packt.live/3dSrEcm`](https://packt.live/3dSrEcm)上在线运行此示例。

让我们在其他问题上使用这个函数。

## 练习 12.13：解决混合问题-第 2 部分

一个罐子里含有 10,000 升浓度为每 100 升 1 千克盐的卤水溶液。每秒以 20 升的速度流入罐中含有每 100 升 2 千克盐的卤水。混合物（均匀）以每秒 10 升的速度流出。找出在 5 分钟内罐中有多少盐。按照以下步骤完成这个练习：

1.  因此，我们需要进行一些简单的算术运算来找出我们的初始盐量，但是每 100 升 1 千克盐是 10,000 升中的 100 千克盐，而流入罐中的 20 升中是 0.4 千克盐。这是我们的新函数：

```py
def salt_content(t,frac=.001):
    salt = 100
    brine = 10000
    for i in range(int(t/frac)):
        brine += 20*frac
        salt += 0.4*frac
        concentration = salt/brine
        salt_out = 10*concentration*frac
        salt -= salt_out
        brine -= 10*frac
    return salt
```

现在，让我们调用`salt_content`函数：

```py
print(salt_content(5*60))
```

当我们调用函数时，输出如下：

```py
183.0769053279811
```

（记住，我们所有的数字都是以秒为单位的，我们想要 5 分钟，因此是`5*60`参数。）

输出告诉我们，在 5 分钟内溶液中有 183 千克盐。这非常接近解析解。

1.  我们可以通过将硬编码的数字更改为变量来简化我们的任务，因此当我们遇到不同初始卤水量的问题时，例如，我们只需在函数调用中输入不同的数字。我们需要变量来表示初始卤水量（或任何溶液）、溶质的初始量（到目前为止，我们一直在使用盐）、卤水的流入速度、盐的流入速度和卤水的流出速度。以下是如何更改函数的方法：

```py
def salt_content(t,salt_0,brine_0,salt_in,brine_in,v_out,frac=.001):
    salt = salt_0 #pounds
    brine = brine_0 #gallons
    for i in range(int(t/frac)):
        brine += brine_in * frac
        salt += salt_in* frac
        concentration = salt/brine
        salt_out = v_out*concentration* frac
        salt -= salt_out
        brine -= v_out* frac
    return salt
```

1.  现在，要解决最后一个问题，我们的函数调用将有更多的参数：

```py
salt_content(300,100,10000,0.4,20,10)
```

输出如下：

```py
183.0769053279811
```

如您所见，输出应与*步骤 1*中的相同。让我们将其应用到更多问题上。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3gkTWOd.`](https://packt.live/3gkTWOd )

您还可以在[`packt.live/3eSWF17.`](https://packt.live/3eSWF17 )上在线运行此示例

## 练习 12.14：解决混合问题-第 3 部分

一个大桶中含有 100 升糖水混合物，含有 900 克糖。每分钟以 5 克糖每升的速度进入大桶的糖水混合物为 2 升。另一个含有每升 10 克糖的混合物以每分钟 1 升的速度流入大桶。大桶保持混合，所得的混合物以每分钟 3 升的速度从大桶中排出。在 1 小时内找出大桶中的糖量。按照以下步骤完成此练习：

1.  这里唯一的诀窍是总溶液进入速度为每分钟 3 升，总溶质进入速度为每分钟 20 克。以下是函数调用：

```py
salt_content(60,900,100,20,3,3)
```

1.  输出将如下所示：

```py
705.2374486274181
```

溶质的量为 705 克。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2YRWNIl.`](https://packt.live/2YRWNIl )

您还可以在[`packt.live/2YRWKfD.`](https://packt.live/2YRWKfD )上在线运行此示例

## 练习 12.15：解决混合问题-第 4 部分

如果我们添加纯水会怎样？这会让它更难还是更容易？让我们试试这个。

一个罐子中含有 1200 升水和 18 克盐的卤水混合物。淡水以每分钟 15 升的速度进入罐子，并且罐子被搅拌以保持均匀。一根管子以每分钟 10 升的速度排出混合物。15 分钟后罐子中有多少盐？按照以下步骤完成此练习：

1.  我们可以使用我们的`salt_content`函数，但`盐`变量将设置为`0`。这使得以下函数调用：

```py
print(salt_content(15,18,1200,0,15,10))
```

1.  15 分钟后的盐含量输出如下：

```py
15.944648402124784
```

盐含量从 18 克减少到 15.9 克。

注意

访问此特定部分的源代码，请参阅[`packt.live/2ZsLTIs.`](https://packt.live/2ZsLTIs )

您还可以在[`packt.live/2AnLrT8.`](https://packt.live/2AnLrT8 )上在线运行此示例

因此，我们已经看到了通常需要大量代数操作才能找到情况的方程的微分方程的几个主题，以便（大概）我们可以插入一个变量并获得所寻找的温度、位置或数量。使用 Python 进行建模和运行模拟已经为我们节省了大量的代数，并且仍然为我们提供了非常准确的答案。

# 欧拉方法

在大学数学课程中，您学习了所有这些代数方法来求导数和积分以及解决微分方程。我们没有提到拉普拉斯变换，这是解决微分方程的更复杂的方法。现在，关于微分方程的肮脏秘密是，除非您主修工程学，否则学校不会告诉您的是，您在现实生活中遇到的大多数微分方程都没有*解析解*。

好消息是，数百年来一直有避免混乱代数的数值方法，随着计算机的发明，这些方法已经成为标准。即使存在解析解，数值方法对于实际目的几乎与解析方法一样准确，并且只需花费一小部分时间即可获得解决方案。

欧拉方法的思想非常简单：

1.  从已知点开始。

1.  使用微分方程在此点计算导数。这是曲线在此点处的方向。

1.  向计算出的方向迈出一小步。

1.  重复直到达到所需范围的末尾。

## 练习 12.16：使用欧拉方法解决微分方程

给定微分方程![2](img/B15968_12_InlineEquation4.png)。您想知道在特定值*x*处函数*y=f(x)*的输出。您在图上给出了一个点：*f(0) = 1*。这意味着，“在每个点上，这个函数的导数是该点的 y 值。”请记住，导数是图上的点朝向或方向。欧拉方法是从初始值开始，即在这种情况下，在(0,1)，并使用微分方程计算到下一个点的方向。**微分方程**（**DE**）规定斜率是*y*值，因此我们在正*x*方向上迈出一小步：

![图 12.21：朝着正确方向迈出小步（希望如此）](img/B15968_12_21.jpg)

图 12.21：朝着正确方向迈出小步（希望如此）

导数如下：

![图 12.22：函数的导数](img/B15968_12_22.jpg)

图 12.22：函数的导数

因此，*ΔY*变为以下内容：

![图 12.23：计算ΔY 的公式](img/B15968_12_23.jpg)

图 12.23：计算ΔY 的公式

这是导数和步长的乘积。要找到下一个*y*值，我们将*ΔY*添加到先前的*y*值。在新点上，我们重复这个过程：计算这一点的函数斜率，乘以步长，然后加到当前的*y*值上。按照以下步骤进行：

1.  让我们编写一个 Python 函数来做到这一点：

```py
def euler(x0,y0,target_x,stepsize):
    x,y = x0,y0
    while x<target_x:
        slope = y #from diff eq
        x += stepsize
        y += stepsize*slope
        print(x,y)
    return y
```

1.  因此，我们知道初始的`x`和`y`。我们想知道`x=2`时的`y`；步长可以是½：

```py
print(euler(0,1,2,0.5))
```

以下是输出：

```py
0.5 1.5
1.0 2.25
1.5 3.375
2.0 5.0625
5.0625
```

1.  我们不再需要`euler`函数内的`print`语句，因此将其注释掉：

```py
        #print(x,y)
```

1.  第一行是计算斜率的结果，即*y*值 1，乘以步长½，然后向上移动该距离。如果导数为负，我们将向下移动。在第二行，我们将*y*值 1.5 乘以步长 0.5，得到 0.75。我们从 0.75 上升到 2.25 等等。在 x 方向上采取小步骤，直到达到目标 x 值 2，我们最终得到*y*值 5.0625。我们不再需要打印出每一步，但让我们将步长减半 10 次：

```py
for n in [0.5**i for i in range(10)]:
    print(n,euler(0,1,2,n))
```

以下是输出：

```py
1.0 4.0
0.5 5.0625
0.25 5.9604644775390625
0.125 6.583250172027423
0.0625 6.958666757218805
0.03125 7.166276152788222
0.015625 7.275669793128417
0.0078125 7.3318505987410365
0.00390625 7.3603235532692795
0.001953125 7.374657160341845
```

因此，步长越小，我们似乎越接近 7.37。这是近似路径的图形：

![图 12.24：使用较小的步长获得更好的近似](img/B15968_12_24.jpg)

图 12.24：使用较小的步长获得更好的近似

第四条曲线（右侧的曲线）是我们近似路径的步长为 1 的路径。第三个图形的步长为½，第二条曲线为¼，第一条曲线为 1/8。我们选择![a](img/B15968_12_InlineEquation2.png)微分方程，因为我们知道代数解。

当*x*为 2 时，*e*2 *= 7.389*。添加*y=e*x*的实际曲线（左侧的第一条曲线），我们可以看到步长越小，近似值越接近实际曲线：

![图 12.25：实际曲线添加到第一条曲线的左侧](img/B15968_12_25.jpg)

图 12.25：实际曲线添加到第一条曲线的左侧

但是最后的近似值，步长为 0.001953125，需要在 0 和 2 之间进行 1,024 步。很容易理解为什么在计算机发明之前，欧拉方法不如代数方法受欢迎。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2VEQiaa`](https://packt.live/2VEQiaa)。

您还可以在[`packt.live/2ByZvtv`](https://packt.live/2ByZvtv)上在线运行此示例。

## 练习 12.17：使用欧拉方法评估函数

在**初始值问题**（**IVP**）上使用欧拉方法和步长 0.001：

![图 12.26：欧拉方法在初始 VP 上](img/B15968_12_26.jpg)

图 12.26：欧拉方法在初始 VP 上

在这里，*y(0) = 1*，以便计算近似解*y(x)*，当*x=0.3*时：

1.  在`euler`函数中，在`slope=`行中输入微分方程：

```py
def euler(x0,y0,target_x,stepsize):
    x,y = x0,y0
    while x<target_x:
        slope = x+y**2 #from diff eq
        x += stepsize
        y += stepsize*slope
    return y
```

1.  在函数调用中输入适当的参数：

```py
print(euler(0,1,0.3,0.001))
```

输出应该如下所示：

```py
1.48695561935322
```

这意味着通过从我们已知的点(0,1)开始，按微分方程指定的方向迈出微小步骤，我们能够预测 1.49 是对应于 x 值 0.3 的近似*y*值。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3inHj6S.`](https://packt.live/3inHj6S )

您也可以在[`packt.live/2VFLEbF.`](https://packt.live/2VFLEbF )上在线运行此示例

## Runge-Kutta 方法

由于 Euler 方法仅基于每个点的导数，它存在一个问题，即始终超出或低于真实曲线。毫不奇怪，在 Euler 方法被发明的几个世纪以来，已经对其进行了改进以抵消其缺点。其中一种改进是**Runge-Kutta**（**RK**）方法，它将四个近似值平均在一起，其中之一是 Euler 方法，使用区间的开始，另一个使用区间的结束，另外两个近似值使用区间的中点。当这些近似值平均在一起时，中点的近似值被赋予更高的权重。

以下是当 DE 给出时的方程，*f(x,y)*，起始*x*和*y*，*x*0 和*y*0，以及步长*h*：

![图 12.27：给出 f(x,y)时的方程](img/B15968_12_27.jpg)

图 12.27：给出 f(x,y)时的方程

对于下一个*y*，我们将前面四个近似值平均在一起，*k*2 和*k*3 的权重加倍：

![图 12.28：对前 4 个近似值进行平均的公式](img/B15968_12_28.jpg)

图 12.28：对前 4 个近似值进行平均的公式

然后，当然，*x*增加了*h*：

![图 12.29：将 x 增加 h](img/B15968_12_29.jpg)

图 12.29：将 x 增加 h

这是一大堆代码，但它的功能令人印象深刻。

## 练习 12.18：实现 Runge-Kutta 方法

在 IVP 上使用 Runge-Kutta 方法和步长 0.2：

![图 12.30：步长为 0.2 的 Runge-Kutta 方法](img/B15968_12_30.jpg)

图 12.30：步长为 0.2 的 Runge-Kutta 方法

1.  首先，我们定义微分方程。让我们称之为`deriv(x,y)`：

```py
def deriv(x,y):
    return x**2 + y**2
```

1.  现在，我们将定义 Runge-Kutta 方法，称之为`rk4`：

```py
def rk4(x0,y0,target_x,h):
    while x0 <= target_x:
        print(x0,y0)
        k1 = h*deriv(x0,y0)
        k2 = h*deriv(x0 + h/2, y0 + k1/2)
        k3 = h*deriv(x0 + h/2, y0 + k2/2)
        k4 = h*deriv(x0 + h, y0 + k3)
        #These are the values that are fed back into the function:
        y0 = y0 + (1/6)*(k1 + 2*k2 + 2*k3 + k4)
        x0 = x0 + h
```

1.  当我们从*y(0) = 0*开始，并且我们想要使用步长为 0.2 来计算*y(1)*时，这就是我们所说的：

```py
rk4(0,0,1,0.2)
```

我们的进展如下打印出来：

```py
0 0
0.2 0.0026668666933346665
0.4 0.021360090381533078
0.6 0.0724512003541295
0.8 0.17409018097333867
1.0 0.35025754914481283
```

1.  使用相同的步长解决相同的问题，但使用 Euler 方法的准确性较低。在`euler`函数中，将`slope=`行更改为匹配新微分方程：

```py
        slope = x**2 + y**2
```

1.  现在，我们使用 Euler 方法打印出解决方案：

```py
print(euler(0,0,1,0.2))
```

以下是输出：

```py
0.2428567456277198
```

这与 Runge-Kutta 解决方案并不十分接近。然而，在计算机出现之前，Runge-Kutta 改进可能更有用，因为我们可以简单地减小 Euler 方法中的步长并获得更好的近似值。这是步长为 0.001 的 Euler 方法的相同输出：

```py
print(euler(0,0,1,0.001))
```

以下是输出：

```py
0.34960542576393877
```

这只是对用于解方程的*数值方法*的简要介绍，不是通过代数来解决，而是通过将起始点输入计算机程序并按微分方程指示的方向迈出小步来解决。这是微积分的一个庞大领域，特别是现在免费软件和编程语言，再加上快速的计算机处理器，使以前费力的计算变得轻松。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3eWxF95.`](https://packt.live/3eWxF95 )

您也可以在[`packt.live/3dUlkkg.`](https://packt.live/3dUlkkg )上在线运行此示例

## 追踪曲线

微积分中的一个重要话题是追踪曲线，这是一个代理追逐移动目标所经过的路径。由于追逐者直接朝向目标移动，然后目标移动，这种情况导致了各种微分方程。代数可能会变得非常丑陋，这就是微积分教授喜欢这个话题的原因。然而，正如我们所知，微分方程通常是关于寻找一般代数解的，也就是一个函数，而不是一个数字。理论上，我们可以将值代入函数中，以找到特定时间的粒子位置或房间的温度。使用 Python，我们通过对情况进行建模并找到数值解来跳过代数步骤。我们在一般性上失去了一些东西，但在计算的便利性上获得了一些东西。

## 练习 12.19：找到捕食者捕捉猎物的位置

一只兔子从(0,0)开始，以每秒 1 单位的正*y*方向奔跑。一只狐狸从(20,0)开始追逐兔子，奔跑速度是兔子的 1.5 倍。狐狸在什么*y*值处追到兔子？

执行以下步骤：

1.  首先，我们需要从`math`模块中获取一些函数来测量距离和角度：

```py
from math import sqrt, atan2,sin,cos
```

1.  我们将编写一个函数，使用毕达哥拉斯定理来测量捕食者位置和猎物位置之间的距离：

```py
def dist(x1,y1,x2,y2):
    """Returns distance from (x1,y1) to (x2,y2)"""
    return sqrt((x1-x2)**2 + (y1-y2)**2)
```

1.  关键在于猎物和捕食者位置之间*y*的变化与*x*的变化代表我们想要的角度的正切。我们知道它们的位置，因此我们使用反正切函数`atan2`来计算角度，使得捕食者直接指向猎物。我们真正想知道的是如何改变捕食者的*x*和*y*坐标，使其朝着猎物移动 1 单位。为了使捕食者朝着猎物转向，我们需要找到两点之间的角度，如下图所示：![图 12.31：捕食者和猎物之间的角度](img/B15968_12_31.jpg)

图 12.31：捕食者和猎物之间的角度

1.  一旦我们知道变化，我们就可以将向量乘以我们想要的任何速度：

```py
def towards(x1,y1,x2,y2):
    """Returns unit vector in [x,y] format from point
    1 to point 2"""
    dx,dy = x2-x1,y2-y1
    angle = atan2(dy,dx)
    return [cos(angle),sin(angle)]
```

我们计算`x`和`y`的变化，使用`arctangent`函数计算角度，然后我们使用余弦和正弦来找到捕食者*x*和*y*坐标的相应变化，使其朝着猎物走一步。

1.  现在，追逐可以开始了。我们将捕食者和猎物放在它们所在的位置。然后，我们开始一个循环，其中我们将猎物移动一单位（或更准确的增量）：

```py
def chase():
    predator_x,predator_y = 20,0
    predator_v = 1.5 #prey is 1
    prey_x,prey_y = 0,0
    inc = 0.001
    while dist(predator_x,predator_y,prey_x,prey_y) > 0.001:
        prey_y += 1*inc
        p_vec = towards(predator_x,predator_y,\
                        prey_x,prey_y)
        predator_x += predator_v*p_vec[0]*inc
        predator_y += predator_v*p_vec[1]*inc
        #print(dist(predator_x,predator_y,prey_x,prey_y))
    return predator_y
```

1.  现在，我们运行追逐并打印出捕食者捕捉猎物的*y*值：

```py
y = chase()
print("Y:",y)
print("dist:",dist(1,1,4,5))
print("towards:",towards(1,1,2,2.732))
```

输出如下：

```py
Y: 23.997299988652507
dist: 5.0
towards: [0.5000110003630132, 0.8660190526287391]
```

这非常接近理论值 24。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3f6x44Z.`](https://packt.live/3f6x44Z )

您还可以在[`packt.live/2NO1A7v.`](https://packt.live/2NO1A7v )上在线运行此示例

## 练习 12.20：使用乌龟可视化追踪曲线

在这个练习中，我们将可视化捕食者和猎物的路径，这被称为*追踪曲线*。Python 中有一个内置模块，基于 Logo 编程语言的虚拟乌龟，可以根据我们编写的代码轻松创建可以在屏幕上四处走动的虚拟代理。按照以下步骤完成这个练习：

1.  首先，我们从`turtle`模块导入函数：

```py
from turtle import *
```

1.  我们根据所需的左下点设置屏幕的大小，我们将其设置为(-30，-30)，并设置右上点，我们将其设置为(40,40)：

```py
setworldcoordinates(-30,-30,40,40)
```

1.  设置捕食者和猎物意味着创建一个`Turtle`对象并设置其颜色、位置和速度。乌龟在行走时会留下路径，所以我们告诉它`penup`，以防止它在到达起始位置之前绘制。然后，我们告诉它`pendown`，这样它就会开始绘制：

```py
#set up predator
predator = Turtle()
predator.color("red")
predator.penup()
predator.setpos(20,0)
predator.pendown()
predator.speed(0)
```

1.  我们通过使乌龟变成绿色并赋予它乌龟的形状来设置猎物：

```py
#set up prey
prey = Turtle()
prey.color("green")
prey.shape("turtle")
prey.setheading(90)
prey.speed(0)
```

1.  `pursue`函数应该看起来很熟悉，但它有内置函数来计算距离，甚至指向另一个乌龟：

```py
def pursue():
    inc = 0.05
    while predator.distance(prey)>0.05:
        predator.setheading(predator.towards(prey))
        prey.forward(inc)
        predator.forward (1.5*inc)
    print("y:",predator.ycor())
```

1.  我们将执行`pursue`函数，然后一旦它打印输出，我们会告诉程序完成，这样图形窗口就不会冻结：

```py
pursue()
done()
```

1.  如果你运行这个，你可以观看追逐。这是最终输出应该看起来像的：![图 12.32：捕食者的路径是一个对数曲线](img/B15968_12_32.jpg)

图 12.32：捕食者的路径是一个对数曲线

1.  **扩展**：将猎物的路径改为圆形。在使猎物向前移动的行后，添加这行：

```py
prey.left(.3)
```

这将使猎物每一步左转一小部分度数。但是如果每次转弯都是一样的，最终会形成一个圆。结果路径看起来像这样：

![图 12.33：当猎物沿着圆形路径逃离时的追逐曲线](img/B15968_12_33.jpg)

图 12.33：当猎物沿着圆形路径逃离时的追逐曲线

注意

要访问此特定部分的源代码，请参阅[`packt.live/3dWHDG6。`](https://packt.live/3dWHDG6 )

这一部分目前没有在线交互式示例，需要在本地运行。

## 位置、速度和加速度

微分方程经常用于研究抛射体的路径，这可以说是微积分的起源。牛顿发明了微积分工具来解决由他对行星运动的研究得出的微分方程，并且表明地球上的自由落体物体受到与轨道行星相同的物理定律的约束。

## 练习 12.21：计算抛射体离地面的高度

一个球以初速度 29 米/秒向上抛出。它在击中地面之前要多久？按照以下步骤完成这个练习：

1.  在代数课上，我们被引导使用方程来计算抛射体的高度：![图 12.34：计算抛射体高度的公式](img/B15968_12_34.jpg)

图 12.34：计算抛射体高度的公式

这里，*h*0 是初始高度，*v*0 是初始向上速度，*t*是经过的秒数，*g*是重力加速度，大约 32 英尺或 9.8 米每秒。但是抛射体不使用方程来计算它们的位置；它们只是沿着它们的导数指示的方向运动。

1.  让我们模拟一下：

```py
v = 29
g = 9.8
h = 0
t = 0
```

因此，对于第一秒，球将以 29 米/秒的速度向上抛出，但会受到每秒 9.8 米的重力减速，这意味着一秒后，它只有*29 - 9.8 = 19.2*米/秒。因此，一秒后，球应该在空中 19.2 米高。我们每秒重复一次，直到它的高度为 0。

1.  `height`函数应该是这样的：

```py
def height(v0,h0,t):
    """Calculates the height a projectile given the
    initial height and velocity and the elapsed time."""
    v,h = v0,h0
    for i in range(1,t+1):
        v -= g
        h += v
    return h
```

1.  速度和高度被分配它们的起始值，*v*0 和*h*0，然后速度通过*g*和加速度（由于重力）进行更新，然后高度*h*通过速度进行更新。我们每秒重复计算并检查球的高度何时返回到零：

```py
for j in range(1,10):
    print(j,round(height(v,h,j),1))
```

以下是输出：

```py
 –
1 19.2
2 28.6
3 28.2
4 18.0
5 -2.0
6 -31.8
7 -71.4
8 -120.8
9 -180.0
```

看起来球在 4 到 5 秒之间击中地面。但是当我们将*t = 5*放入前面的公式中时，我们得到以下结果：

![图 12.35：替换计算抛射体高度公式中的值](img/B15968_12_35.jpg)

图 12.35：替换计算抛射体高度公式中的值

1.  5 秒后，球应该仍然在空中 22.5 米。我们的代码有什么问题？正如您现在应该知道的那样，球不仅每秒改变一次速度。它的速度不断变化。就像复利一样，我们需要每秒计算新的速度。对于 Python 来说很容易。我们只需引入一个`inc`变量来增加时间。请记住，这会增加我们循环计算的次数，因此`for i in range`行也会改变。然后，*g*和*v*乘以增量。我们将每半秒重新计算一次：

```py
def height(v0,h0,t):
    """Calculates the height a projectile given the
    initial height and velocity and the elapsed time."""
    inc = 0.5
    v,h = v0,h0
    for i in range(int(t/inc)):
        v -= g*inc
        h += v*inc
    return h
```

1.  使用相同的代码运行此代码：

```py
for j in range(1,7):
    print(j,round(height(v,h,j),1))
```

输出现在如下：

```py
1 21.7
2 33.5
3 35.6
4 27.8
5 10.3
6 -17.1
```

1.  球在空中停留的时间更长，在 5 秒时，它在空中的高度为 10.3 米。如果我们使增量非常小，它应该在 5 秒时更接近 22.5 米。将`inc`更改为 0.001，再次运行，您将获得以下输出：

```py
1 24.1
2 38.4
3 42.9
4 37.6
5 22.5
6 -2.4
```

1.  要回答球何时触地的问题，我们将不得不在 5 秒和 6 秒之间进行二分搜索。与以前的搜索一样，我们使用我们的`bin_search`函数，并更改`guess =`行以反映我们*猜测*的数字：

```py
def bin_search(f,lower,upper,target):
    def average(a,b):
        return (a+b)/2
    for i in range(40):
        avg = average(lower,upper)
        guess = f(29,0,avg)
        if guess == target:
            return avg
        if guess < target:
            upper = avg
        else:
            lower = avg
    return avg
```

1.  我们只需要更改`height`函数的参数的`guess =`行。最后一个参数*t*是我们正在搜索的内容，因此我们正在平均。二分搜索函数将在 5 和 6 之间插入值，并返回返回 0 的*t*值：

```py
print(bin_search(height,5,6,0))
```

以下是输出：

```py
5.918000000000575
```

现在，我们解决二次方程：

*29t – 4.9t*2 *= 0*

对于*t*，我们得到*t = 0*和*t = 5.9184*。当然，我们扔出球之前，球的高度为 0，第二个值非常接近我们得到的值。函数的图形如下所示。忽略空气阻力，粒子高度随时间的图形遵循抛物线路径：

![图 12.36：没有空气阻力的抛射物路径](img/B15968_12_36.jpg)

图 12.36：没有空气阻力的抛射物路径

这是对我们代码的测试，因为我们有一个很好的公式来检查我们的输出。现在，我们将继续进行更难的关于速度和加速度的微积分问题，其中没有公式可以帮助我们检查答案。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2VEAkN4`](https://packt.live/2VEAkN4)。

您还可以在[`packt.live/2Bzpz7Z`](https://packt.live/2Bzpz7Z)上在线运行此示例。

## 计算带空气阻力的抛射物高度的示例

数学学生被迫研究从代数到微积分的完美抛物线路径中行进的粒子。不幸的是，这不是真实粒子的行进方式。在现实生活中，物体穿过空气或水等介质，并根据介质的密度、其横截面积和其他因素而减速。这导致了一个复杂的施加在抛射物上的力的方程。简而言之，*抛射物上的力是由于重力加速度和与其速度的平方成比例的减速*。方程如下：

*F = mg - kv*2

有空气阻力，我们需要知道抛射物的质量*m*。由于重力加速度*g*为 9.8 m/s2。变量*k*是至少三个不同因素的组合，但值*k = 0.27*对于这种情况产生了现实结果。

与上一个练习一样，我们计算加速度并使用它来更新速度。然后，我们根据速度更新抛射物的位置。

抛射物上的力由两部分组成：由于重力的通常加速度和阻力分量。让我们编写一个 Python 函数来计算：

```py
def force(v,mass,g,k,inc):
    """Returns the downward force on a
    projectile"""
    gravity = mass*g*inc
    drag = k*(v**2)*inc
    if v > 0:
        return gravity + drag
    return gravity - drag
```

很多时候，我们的值都乘以`inc`，增量变量，这样我们可以采取更小的步骤来获得更好的近似值，就像我们以前做的那样。`gravity`和`drag`变量直接来自力的方程。请注意，如果速度大于 0，抛射物正在向上运动，因此向下的力是重力和阻力力的总和。否则，抛射物正在向下运动，因此重力的力仍然向下，但阻力正在减速，因此我们使用重力和阻力的差异。

现在，我们将调整我们在上一个练习中的`height`函数，以计算高度等于 0 所需的时间，并添加对我们的`force`函数的调用：

```py
def height(v0,h0):
    """Calculates the time it takes a projectile given the 
    initial height and velocity to hit the ground."""
    inc = 0.001
    v,h = v0,h0
    t = 0
    while h >= 0:
        v -= force(v,1,9.8,0,inc) #test with k=0
        h += v*inc
        t += inc
    return round(t,1),round(v,1)
```

在这个函数中，是`v -=`这一行在起重要作用。速度将受到向下的力的影响。当我们使用*k = 0*运行时，我们应该得到与上一个问题中相同的时间和结束速度，没有空气阻力：

```py
print(height(29,0))
```

输出如下：

```py
(5.9, -29.0)
```

是的；在上一个练习中，抛射物需要 5.9 秒才能到达地面。当没有空气阻力且结束高度与初始高度相同时，结束速度将与初始速度相同，只是方向相反，因此为-29 米/秒。

现在，让我们使用更现实的值*k*，`0.27`，看看粒子到达地面需要多长时间，以及它将以多快的速度运行。你有什么预测？

将`height`函数中的`v -=`行更改为以下内容：

```py
        v -= force(v,1,9.8,0.27,inc)
```

当您运行程序时，输出将如下所示：

```py
(2.2, -5.9)
```

因此，抛射物只用了 2.2 秒就上升并下降，最终速度为-5.9 米/秒。如果我们将具有和没有空气阻力的抛射物的高度图进行对比，我们会发现在有空气阻力的情况下高度要少得多：

![图 12.37：带空气阻力的抛射物的高度（内曲线）](img/B15968_12_37.jpg)

图 12.37：带空气阻力的抛射物的高度（内曲线）

这确实是很大的阻力。尝试使用不同的*k*值，即阻力常数，以获得不同的结束时间和结束速度。这引出了数学和科学中一个非常有趣的概念，即**终端速度**，当抛射物上下的力相等时，它不再加速。

## 练习 12.22：计算终端速度

如果您的抛射物从 3000 米的初始高度开始并从飞机上跳下（向下速度为 0），它会达到什么速度？它会简单地继续加速直到抛射物撞击地面吗？

将质量更改为 80 公斤，这是人类的平均体重，*k*更改为`0.27`。按照以下步骤完成此练习：

1.  确保您有来自上一个示例的`force`函数。

1.  修改您的`height`函数，使其看起来像这样：

```py
def height(v0,h0): 
    """Calculates the velocity of a projectile given the  
    initial height and velocity and the elapsed time.""" 
    inc = 0.001
    v,h = v0,h0 
    t = 0
    for i in range(500): 
```

1.  这是一个重要的行，我们在其中告诉`force`函数质量、*k*的值等等：

```py
        v -= force(v,80,9.8,0.27,inc)
        h += v*inc
        if i % 50 == 0:
            print("v:",round(v,1))
        t += inc
```

1.  我们进行了 500 次循环，但只在每 50 次循环时打印出速度。让我们用这行来运行它：

```py
height(0,3000)
```

这是我们收到的输出：

```py
v: -0.8
v: -34.1
v: -48.6
v: -52.6
v: -53.6
v: -53.8
v: -53.9
v: -53.9
v: -53.9
v: -53.9
```

速度从 0 开始，变得越来越负，直到停止减少。它在大约 54 米/秒左右稳定下来（为负，因为它向下），这大约是每小时 120 英里，人体在自由落体中的终端速度。这是随时间变化的速度图：

![图 12.38：带空气阻力的自由落体物体的速度](img/B15968_12_38.jpg)

图 12.38：带空气阻力的自由落体物体的速度

注意

要访问此特定部分的源代码，请参阅[`packt.live/2NNmWBM。`](https://packt.live/2NNmWBM )

您还可以在[`packt.live/2BUuXCp`](https://packt.live/2BUuXCp)上在线运行此示例。

现在，让我们完成一个活动，测试我们在本章学到的知识。

## 活动 12.01：找到粒子的速度和位置

在*x-y*平面上移动的粒子的速度矢量具有以下分量：

![图 12.39：粒子速度矢量的微分方程](img/B15968_12_39.jpg)

图 12.39：粒子速度矢量的微分方程

找到曲线的切线水平的所有时间（和坐标），然后找到*t=1*时粒子的速度。

执行以下步骤完成此活动：

1.  编写*dx/dt*和*dy/dt*的函数。

1.  循环遍历输出，找到导数为 0 的位置，找到导数从正变负或反之的值。然后，使用二分搜索找到更精确的近似值。

1.  创建一个`position`函数，并使用循环按照之前给出的导数（*位置的变化*）来改变粒子的位置，以便在所需的经过时间停止，并打印出*x-y*坐标。

1.  将您在*步骤 2*中找到的时间插入`position`函数中，以找到导数为 0 时粒子的*x-y*坐标。

1.  您被要求在时间*t=1*时粒子的速度。使用您得到的微分方程找到粒子速度的垂直和水平分量，并找到以这些分量作为腿的直角三角形的斜边。

注意

此活动的解决方案可在第 702 页找到。

# 总结

微积分是一套非常强大的工具，用于模拟真实情况，从热量传递到行星运动。它使我们能够计算函数在瞬间的变化率和复杂曲线下的面积（这些任务仅使用代数和几何的工具似乎是不可能的）。在本章中，我们能够处理值的变化率（导数）作为一个值本身，并使用 Python 循环和函数计算出一些非常精确的结果。模拟导致微分方程的情况，比如抛射物的路径，正是推动第一台电子计算机的发展。

数学课程可能仍然强调对方程的代数解，甚至微分方程，但正如我们在本章中所看到的，使用计算机是模拟现实生活情况的一种简单方法，比如捕食者追逐猎物。我们改变了变量，比如投资中的资金量，混合物中的盐量，以及捕食者的朝向，重复计算了数千次，每一步重新计算数量和距离，得到了非常精确的结果。Python 是设置一些起始条件并让程序运行直到抛射物击中地面或达到终端速度的完美工具。Python 还帮助我们避免了繁琐的代数运算，并让我们通过创建一个简单的模型来*蛮力*得到答案，比如一个下落的物体或一个捕食者追逐猎物。这是*简单*的，因为我们不必重复数千次计算——计算机会做。此外，这些数值方法已经用于没有简单代数解的微分方程，甚至适用于那些有解的方程。希望本章已经证明了使用计算机来模拟和分析复杂的现实情况的力量。

现在，您已经学会了如何利用 Python 的循环、变量、条件、函数和列表来解决统计学、概率论和微积分中的复杂问题。您还学会了如何计时执行代码并绘制输出。您使用了 Python 的最先进的数值包`numpy`来加速计算并操纵数组，适用于各种应用。您还看到 Python 编程被应用于太阳下的每一个数学主题，现在您将能够将其应用于未来遇到的任何现实生活情况。

JMK95

GEA39
