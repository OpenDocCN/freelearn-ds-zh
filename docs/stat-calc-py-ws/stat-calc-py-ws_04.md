# 第四章：函数和代数与 Python

概述

在前一章中，我们讨论了大量与统计相关的主题，包括变量、描述性统计和推断。在本章中，我们回到数学的一般主题，并研究其中两个最基本的组成部分：函数和代数。这些主题将与它们在 Python 中的实现并行介绍和理论讨论。掌握这些主题将使您能够解决一些可以使用数学和编程解决的最常见的现实生活问题，我们将在本章的最后一个活动中看到一个例子。

通过本章结束时，您将对数学函数的概念以及域、范围和绘图等相关概念有牢固的掌握。此外，您还将学习如何通过手工解决代数方程或方程组，以及通过 Python 编程解决。

# 介绍

虽然数学可以分为多个子领域，如微积分、数论和几何学，但有一些基本概念是每个数学学生都必须熟悉的。其中两个概念是函数和代数，这是本章的主要内容。

函数是描述从一个对象到另一个对象的某种映射的一般数学过程。函数可以接受一个数字并产生另一个数字。它还可以接受一组数字或向量并返回单个输出，甚至多个输出。函数如此重要，以至于它们也广泛应用于其他科学领域，包括物理学、经济学，正如我们在本书中所看到的，编程。

本章的目标是在数学背景下建立关于函数概念的具体基础讨论。这个讨论将与其他相关主题结合，如域、范围和函数的绘图。对这些主题的扎实理解将使您能够在以后的章节中探索更复杂的数学分析。

除了函数，我们还将考虑代数，这是数学中最重要的部分之一。虽然这个术语通常表示对数学对象的分析和操作，但我们将在代数方程和方程组的背景下考虑它。这将使我们能够研究它在数学中的重要作用，同时学习如何将这些知识应用于实际问题。

# 函数

如前所述，函数是数学对象，通常接受一些输入并产生所需的输出。因此，函数通常被认为是一个数学对象到另一个数学对象的映射。当函数接收输入并随后产生输出时，还可以使用*关系*的概念，这强调了函数本身建立的可能输入集和可能输出集之间的关系。

函数通常由小写字母*f*和括号表示，括号中包围着*f*接受的输入。这个符号，*f(x)*，也表示*f*在接受*x*作为输入时产生的输出。例如，假设函数*f*输出其输入的平方；*f*可以表示为*f(x) = x*2。

我们看到，在 Python 中声明函数的语法也遵循这种约定。例如，要在 Python 中声明相同的平方函数，代码将如下所示：

```py
def f(x):
    return x ** 2
```

当我们想要获得*f*作为其输入的值时，我们只需说我们在输入上调用*f*。例如：

```py
print(f(2))
print(f(-3))
```

这段代码将分别打印出`4`和`9`。正如我们所知，函数返回的值也可以通过赋值存储在变量中。

函数最重要的特征之一是没有输入可以映射到不同的输出。一旦一个输入*x*与相应的输出*f(x)*关联起来，那个输出是确定的，不能有多个可能的值。另一方面，完全可能多个输入映射到相同的输出。换句话说，多个*x*的值可以导致*f(x)*成为一个常见值。

也有可能一个函数不需要接受任何输入，也不一定需要产生任何输出。例如，在编程的情境中，一个函数的工作是读取并返回特定文件中包含的数据，不需要接受任何输入。另一个例子是更新全局变量的值的函数，在这种情况下不需要返回任何东西。也就是说，这些函数可以被认为属于一类特定的一般函数的子集，因此我们的讨论仍将围绕具有输入和输出的函数展开。

在接下来的小节中，让我们考虑数学和编程中一些常见类型的函数。

## 常见函数

虽然每个函数在自己的方式上都是独特的，但有一些特殊的分类或*家族*函数，我们需要了解。这些是常数、线性、多项式、对数和指数函数，它们总结在下表中：

![图 4.1：特殊函数家族表](img/B15968_04_01.jpg)

图 4.1：特殊函数家族表

花点时间考虑我们表格的第三列，其中包含每个函数家族的样本函数的图。我们将在本节后面更深入地讨论函数的图的理论细节，但现在我们看到每个函数家族都给我们一个独特的图形风格；事实上，从它们的图形中识别函数是我们即将进行的练习的主题。

请注意，常数和线性函数实际上是多项式函数家族的子集（当*x*的较大幂的系数都为零时）。你可能已经注意到的另一个有趣的事实是对数函数的输入必须是正数，这就是为什么它的图不会延伸到*y*轴的左侧。相反，指数函数的输出（假设常数是正的）总是正的；相应地，它的图始终在*x*轴上方。这些观点直接过渡到我们的下一个主题：函数的域和值域。

## 域和值域

域和值域是函数概念中的两个基本概念。函数的域表示函数接受的所有可能输入的集合，而值域指定了所有可能输出的集合。

大多数情况下，可以通过考虑函数的公式表达来确定给定函数的域和值域。例如，线性函数*f(x) = mx + c*接受任何实数值的*x*来产生一个实数值的*mx + c*，因此它的域和值域都是实数集合*R*。另一方面，二次函数*f(x) = x*2*只产生非负输出，因此它的值域是非负实数集合。

函数的域和值域也可以通过其图来检查。考虑一个具有单个输入和单个输出的函数的图的投影：其域对应于图在*x*轴上的投影；同样，当图在*y*轴上投影时得到值域。这就是为什么我们可以说对数函数*f(x) = ln(x)*的域是正数集合。相反，指数函数*f(x) = e*x*的值域也是正数集合。

总的来说，函数的定义域和值域取决于函数本身的形式，并且可以对函数的各种行为提供高度信息。其中一个经常感兴趣的行为是函数的根，我们将在下一小节中讨论。

## 函数的根和方程

函数的根是使输出等于零的属于其定义域的值。再次强调，函数的根取什么值高度依赖于函数本身。仍然使用前面表中包含的例子，*图 4.1*，我们看到*f(x) = mx + c*接受* x = - c / m*作为其唯一根，如果*m*不为零，而*f(x) = ln(x)*的唯一根是*x = 1*。一些函数可能有多个根：*f(x) = x*2 *- 3x + 2*有*x = 1*和*x = 2*作为其根，而*f(x) = 0*（其图对应于*x*轴）接受所有*x*的值作为其根。最后，如果一个函数的值域不包括 0，那么函数本身就没有任何根；这样的例子包括*f(x) = e*x*，*f(x) = x*2 *+ 1*和*f(x) = 3*。

找到函数*f(x)*的所有根的过程等同于解方程*f(x) = 0*。这里的*方程*一词表示我们有两个分开的量，*f(x)*和*0*，它们在数学表达式中相等。解方程可以说是数学中最核心的任务之一，有多种技术可应用于特定类型的方程。

我们在这里只是作为函数主题的一部分介绍了方程的概念，我们将在本章的后面再回到它。现在，我们将继续讨论函数的最后一个重要组成部分：图。

## 函数的图

在前面的例子中，函数的图是输出行为的视觉表示，关于函数输入的。具体地说，通过函数图，我们旨在检查在函数范围内，随着函数的输入在其定义域内的变化，输出如何变化。

在编程的背景下，函数的图可以通过连接散点对应于函数在*x*轴上一组细粒度均匀间隔值上的各个值来生成。例如，假设我们想要可视化函数*f(x) = x + 1*在`-10`和`10`之间的图，我们首先使用 NumPy 声明相应的均匀间隔的`x`值：

```py
x = np.linspace(-10, 10, 1000)
```

这个 NumPy 函数生成了一个在`-10`和`10`之间的 1,000 个均匀间隔的数字的数组，这由`x`的输出所说明：

![图 4.2：NumPy 生成的均匀间隔的数字](img/B15968_04_02.jpg)

图 4.2：NumPy 生成的均匀间隔的数字

然后可以使用 Matplotlib 的`plot()`函数生成图：

```py
plt.plot(x, x + 1)
plt.show()
```

请记住，由于矢量化，表达式`x + 1`将计算出一个与`x`大小相同的数组，其元素是`x`的元素加 1。这是 Python 语言的一个很好的特性，或者更具体地说，是 NumPy 库，它允许我们快速生成构成函数图的点。

这段代码应该产生以下可视化：

![图 4.3：Python 中 f(x) = x + 1 的图](img/B15968_04_03.jpg)

图 4.3：Python 中 f(x) = x + 1 的图

相同的逻辑可以应用于不同形式的函数。我们将在下一个练习中回到这个过程。现在，让我们回到我们的理论讨论。

函数的图是其公式表达的直观可视化，并包含了我们需要了解的有关该函数的所有信息。特别地，我们已经论证过函数图可以帮助我们确定函数的定义域和值域。此外，给定一个图，我们甚至可以确定该图是否是一个有效函数的图。这是通过垂直线测试来完成的，该测试规定如下。

给定二维平面上的图形，如果对于每条垂直线（与*y*轴平行的每条线），图形有多于一个交点，则它不是有效函数的绘图。这是我们之前所述的函数要求的一个直接推论：一个单一的输入不能映射到多于一个输出。如果一个图形确实与一条垂直线有至少两个交点，那么这意味着*x*轴上的一个点可以映射到*y*轴上至少两个点，这必然意味着这不是一个函数的绘图。

例如，考虑单位圆的以下图形（其中心为*O(0, 0)*，半径等于*1*），它未通过垂直线测试，由红线表示：

![图 4.4：单位圆的垂直线测试](img/B15968_04_04.jpg)

图 4.4：单位圆的垂直线测试

这意味着单位圆实际上不是我们考虑的二维平面上函数的绘图。

这个话题也标志着我们对函数定义的介绍结束。在我们进入下一节之前，让我们通过一个旨在巩固我们迄今学到的所有概念的练习。

## 练习 4.01：从图形中识别函数

在这个练习中，我们将练习分析给定图形的函数行为的技能。这个过程将使我们能够结合我们之前提到的各种主题，并理解函数行为与其图形之间的联系。

对于以下每个图形：

+   确定它是否对应于一个函数，如果是，继续下一步。

+   确定函数的定义域、值域和公式（提示：使用标记的刻度）。

+   确定函数是否至少有一个根。

+   使用 Python 重现绘图（轴及其箭头不是必需的）。

1.  **水平线**：![图 4.5：水平线](img/B15968_04_05.jpg)

图 4.5：水平线

该图对应于一个函数。函数是*f(x) = 2*，定义域是实数集，值域是*{2}*。函数没有任何根。

以下代码可用于重现绘图：

```py
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(-5, 5, 1000)
plt.plot(
    x,  # evenly spaced numbers in the x-axis
    np.ones(1000) * 2  # all 2s in the y-axis
)
plt.show()
```

1.  **旋转的二次曲线**：![图 4.6：旋转的二次曲线](img/B15968_04_06.jpg)

图 4.6：旋转的二次曲线

该图不对应于一个函数，因为它未通过垂直线测试。

1.  **直线**：![图 4.7：直线](img/B15968_04_07.jpg)

图 4.7：直线

图对应于函数*f(x) = x*的绘图。这个函数的定义域和值域都是一组实数。函数有一个根：*x = 0*。

以下代码可用于重现绘图（使用与*水平线*解决方案中相同的`x`变量）：

```py
plt.plot(x, x)
plt.show()
```

1.  **二次曲线**：![图 4.8：二次曲线](img/B15968_04_08.jpg)

图 4.8：二次曲线

该图对应于函数*f(x) = x*2 的绘图。函数的定义域是所有实数的集合，而值域是非负数的集合。函数也有一个根：*x = 0*。

以下代码可用于重现绘图（感谢 NumPy 数组的矢量化）：

```py
plt.plot(x, x ** 2)
plt.show()
```

通过这个快速练习，我们巩固了对函数和许多相关概念的理解，包括定义域、值域、垂直线测试以及使用 Python 绘制图形的过程。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2YRMZhL`](https://packt.live/2YRMZhL)。

您也可以在[`packt.live/2YSBgj2`](https://packt.live/2YSBgj2)上在线运行此示例。

在下一节中，我们将讨论函数的转换。

# 函数转换

变换是数学函数中最重要的概念之一。正如术语的名称所暗示的那样，函数的变换是在将函数的返回值通过特定的变换技术（如移动或缩放）后得到的输出。在最一般的意义上，我们可以将这个过程看作是*复合函数*：将一个函数的输出通过另一个函数。然而，由于它们的特定特性和有用性，有特定类型的函数通常被用作变换，我们将在接下来的小节中介绍它们，从移动开始。

由于变换最容易在应用到函数的图表上时理解，我们也将根据这一点来进行下面的讨论。

## 移动

函数的移动发生在函数的图表沿着*x*轴和/或*y*轴的特定距离上移动。例如，在下面的可视化中，蓝色曲线是函数*f(x) = x*2*的图表，而红色曲线是同一图表向上移动*1*后的图表：

![图 4.9：函数的垂直移动](img/B15968_04_09.jpg)

图 4.9：函数的垂直移动

我们看到属于*f(x) = x*2*图表的每个点*(x, y)*实际上被转换为*(x, y + 1)*。由于如果*(x, y)*属于*f(x)*的图表，那么*y = x*2*，移动的输出本质上是函数*f(x) = x*2 *+ 1*的图表。

这个例子让我们能够概括垂直移动的每种情况：任何给定函数*f(x)*的垂直移动的输出是新函数*f(x) + c*。在我们的例子中，这是*c = 1*，对应着向上水平移动*1*。然而，*c*也可以是负数，这种情况下函数向下移动，甚至可以是零，这种情况下变换是恒等变换，函数的图表不会改变。

我们看到当一个改变被加到（或者从中减去）函数的输出值时，或者换句话说，图表上的点的*y*坐标发生了垂直移动。同样，通过对函数的输入值进行改变（当一个数字被加到点的*x*坐标时），可以对函数进行水平移动。

一般来说，当函数*f(x)*的图表在二维平面上向左移动了一个量*c*时，结果图表是函数*f(x + c)*的图表。相反，函数*f(x - c)*的图表对应于函数*f(x)*向右移动*c*的水平移动。

仍然使用函数*f(x) = x*2*的例子，以下图表可视化了函数向右移动*2*，换句话说，函数*f(x) = (x - 2)*2*的图表：

![图 4.10：函数的水平移动](img/B15968_04_10.jpg)

图 4.10：函数的水平移动

也可以结合垂直移动和水平移动来变换函数，使整个图表朝任意方向移动。例如，假设我们想要将函数*f(x) = x*2*向东北方向（上和右）移动一个向量(*2, 1*)，那么变换后的函数将是*f(x) = (x - 2)*2 *+ 1*。

总的来说，变换作为一种*移动*函数图表的方式，垂直和/或水平地移动。因此，移动也是一种*仿射变换*，它被定义为将图表的所有点以相同方向和恒定距离移动。然而，移动不能改变图表的大小和比例。在下一节中，我们将讨论另一种可以改变大小和比例的变换方法：缩放。

## 缩放

缩放变换通过特定的比例因子拉伸或收缩函数的图形，具体取决于缩放因子。考虑以下可视化中对我们熟悉的函数*f(x) = x*2*应用缩放变换的输出：

![图 4.11：函数的缩放](img/B15968_04_11.jpg)

图 4.11：函数的缩放

通过前面的缩放变换，函数图上的每个点*(x, y)*都被转换为*(x, y / 2)*，有效地将图形水平缩放，使其更靠近*x*轴。变换后的图形对应于函数*f(x) = x*2 */ 2*，比原始图形更宽，因为曲线被缩放到更靠近*x*轴。除了原点(*0, 0*)之外，原始图形的任何点都被*拉下*，使其更靠近*x*轴。这也会使图形的整体斜率变得不那么陡峭。相反，将变换后的图形远离*x*轴的缩放变换可能是*f(x) = 2x*2，或*f(x) = 3x*2，从而使变换后的图形的斜率更陡。

在这些变换中，我们将函数图的*y*坐标乘以一个常数，这使我们能够控制相对于*x*轴的缩放。类似地，当通过将函数图的*x*坐标乘以一个常数来应用缩放时，图形将相对于*y*轴被拉伸或收缩。

总的来说，缩放变换的效果由*缩放因子*控制——图形的*x*或*y*坐标被乘以的常数。正的缩放因子不会改变图形相对于坐标轴的相对位置。

当进行垂直缩放（即缩放*y*坐标）时，小于 1 的正因子将*拉*图形靠近*x*轴，而大因子将*推*图形远离轴。水平缩放（即缩放*x*坐标）也是如此；小于 1 的正因子将图形*推*离*y*轴，而大因子将图形*拉*。

虽然这种*拉/推*效应对于负缩放因子也是一样的，但当函数被负常数缩放时，其图形将沿着相应的轴*翻转*：

![图 4.12：函数的负缩放](img/B15968_04_12.jpg)

图 4.12：函数的负缩放

就像我们在平移的情况下看到的那样，可以同时对函数应用多个缩放变换，以获得组合效果。

总的来说，平移和缩放构成了函数变换中最常见的两种方法。在下一个练习中，我们将练习识别这两种变换的技能，从它们对函数图的影响来识别。

## 练习 4.02：函数变换识别

在这里，我们的目标是分析特定变换对函数图的影响，并识别变换的类型和特征。这个练习将帮助我们熟悉变换如何操纵函数的行为。

以下图形包括三次函数*f(x) = x*3 *- x*的绘图，以及正弦函数*f(x) = sin(x)*的绘图，也因其周期性而常被称为正弦波：

![图 4.13：三次函数和正弦波的图形](img/B15968_04_13.jpg)

图 4.13：三次函数和正弦波的图形

每个图形包括这两个函数绘图中的一个作为蓝色曲线，以及从中得到的特定变换的结果作为红色曲线。对于每个图形：

1.  识别可能产生这种效果的变换。

1.  如果是平移，确定平移向量的值（即上/下移动多少，左/右移动多少）。

1.  如果是缩放，确定缩放因子是正数还是负数，并估计其值（使用刻度标记作为提示）。

1.  通过使用 Python 生成相同的图表来验证您的估计（不包括坐标轴和箭头）。

现在让我们来看一下图表：

1.  **三次曲线的第一次变换**：![图 4.14：三次曲线的第一次变换](img/B15968_04_14.jpg)

图 4.14：三次曲线的第一次变换

红色曲线是原始正弦波的移动结果。它是向左水平移动`2`，因此移动是`-2`。

以下代码可用于重现绘图：

```py
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(-5, 5, 1000)
plt.plot(x, x ** 3 - x, c='blue')  
plt.plot(x, (x + 2) ** 3 - (x + 2), c='red')  
plt.ylim(-5, 5)
plt.show()
```

1.  **三次曲线的第二次变换**：![图 4.15：三次曲线的第二次变换](img/B15968_04_15.jpg)

图 4.15：三次曲线的第二次变换

红色曲线是原始正弦波的复合移动的结果。它是向右水平移动`2`，再向上垂直移动`2`。

以下代码可用于重现绘图（使用相同的变量`x`）：

```py
plt.plot(x, x ** 3 - x, c='blue')  # original func
plt.plot(x, (x - 2) ** 3 - (x - 2) + 2, c='red')  # transformed func
plt.ylim(-5, 5)
plt.show()
```

1.  **正弦波的第一次变换**：![图 4.16：正弦波的第一次变换](img/B15968_04_16.jpg)

图 4.16：正弦波的第一次变换

红色曲线是通过缩放得到的。它是沿着*x*轴的垂直缩放，缩放因子为`2`。

以下代码可用于重现绘图（使用相同的变量`x`）：

```py
plt.plot(x, np.sin(x), c='blue')  # original func
plt.plot(x, np.sin(x) * 2, c='red')  # transformed func
plt.ylim(-5, 5)
plt.show()
```

1.  **正弦波的第二次变换**：![图 4.17：正弦波的第二次变换](img/B15968_04_17.jpg)

图 4.17：正弦波的第二次变换

红色曲线是通过缩放得到的。它是沿着*y*轴的水平缩放，将曲线拉近到`2`的因子，因此缩放因子是`2`。

以下代码可用于重现绘图（使用相同的变量`x`）：

```py
plt.plot(x, np.sin(x), c='blue')  # original func
plt.plot(x, np.sin(x * 2), c='red')  # transformed func
plt.ylim(-5, 5)
plt.show()
```

因此，我们已经学会了通过检查变换对函数图形的影响来识别变换类型及其变化程度。这个练习也结束了本章关于函数的主题。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2D2U7iR`](https://packt.live/2D2U7iR)。

您还可以在[`packt.live/2YPtHcJ`](https://packt.live/2YPtHcJ)上在线运行此示例。

在下一节中，我们将深入探讨一个之前简要提到的相关概念：方程。

# 方程

当一个函数被赋予值 0 时，就形成了一个方程，我们被要求找到满足方程的函数输入值，通常是*x*。这些值被称为原始函数的根。找到这些值的过程称为解方程，这是数学中一个丰富的主题，特别是代数。

在本节中，我们将讨论手工解方程的两种基本方法，并检查 Python 中可用的计算工具，以便自动解方程的过程。我们将从第一种方法开始，即代数操作。

## 代数操作

虽然我们将这个过程归类为一种方法，但代数学通常是一种将方程*转化*为更简单形式的技术，以便可以轻松找到解。一些典型的转化方程的方法包括在方程的两边加/减一个常数，将方程的两边乘/除以一个非零常数，或将方程的所有项移到一边。

一个简单的例子是*3x - 5 = 6*方程。

要解出*x*，我们首先将左边的数字*5*移到右边，即在方程的两边都加上*5*。这给我们*3x = 11*。

最后，我们将两边都乘以*1/3*，这样我们就得到了变量*x*的值，即*x = 11/3*。

这个简单的例子说明了代数操作整个过程的思想，以便我们可以隔离*x*的值。让我们通过另一个例子来强调这一点。假设我们有一个方程：*3x - 7 - 2(19x - 7) = (5x + 9) / 3 + 12*。

虽然这个方程似乎比第一个复杂得多，但过程实际上是相同的。我们首先展开括号内的项，并将涉及*x*的项收集到一组中，然后将剩余的项收集到另一组中。

这将给我们以下代数变换：

图 4.18：替换值以找到 x 的值

](image/B15968_04_18.jpg)

图 4.18：替换值以找到 x 的值

我们看到，总的来说，这个过程是相当简单的，特别是当我们只处理*x*的*线性*项时。术语*线性*表示的是变量*x*乘以一个常数的数量。总的来说，这两个方程的一般术语是**线性方程**，它只包含*x*的线性项。正如我们所见，解线性方程是一个直接的过程，即使我们手工进行解也是如此。

相比之下，多项式方程是具有大于*1*的次数的变量*x*的项的方程。多项式方程可以通过一种特定的技术有效地解决，这将在下一小节中讨论。现在，让我们考虑一个非线性方程的例子，*3e*x+2 *+ 3 = 2(e*x *+ 100)*，它可以简单地通过代数操作来解决。

请注意，*e*是自然对数函数的数学常数；它约为*2.71828*。

注意

您可以在[`mathworld.wolfram.com/e.html`](https://mathworld.wolfram.com/e.html)找到有关这个常数的更多信息。

要解决这个方程，我们首先展开这个方程中的项，如下所示：*3e*x*e*2 *+ 3 = 2e*x *+ 200*

左侧的变换是可能的，因为对于所有正数*a*和实数*x*和*y*，恒等式*a*x + y *= a*x *a*y*成立。现在，我们看到即使这个方程中没有*x*的线性项，我们仍然可以采用隔离涉及*x*的项并将它们分组的策略：

![图 4.19：替换方程中的值以找到 ex](img/B15968_04_19.jpg)

图 4.19：替换方程中的值以找到 ex

现在，有了*e*x 的值，我们想要提取出*x*项。为此，我们将自然对数函数*f(x) = ln(x)*应用到方程的两边。由于对于所有实数*x*，*ln( e*x *) = x*，这一步将把方程的左侧转换为简单的*x*：

![图 4.20：替换方程中的值以找到 x](img/B15968_04_20.jpg)

图 4.20：替换方程中的值以找到 x

总的来说，使用代数变换来解方程的一般思想是将涉及*x*的所有项分组并将它们操纵成一个单一项。同样，这种策略并不总是适用于任何方程，因为有时不可能将所有*x*项简化为一个单一项。这是多项式方程的情况，我们将在下一种解方程的方法——因式分解的背景下讨论它。

## 因式分解

虽然它在技术上属于代数的大类，**因式分解**特指将给定方程操纵成以下形式的过程：

![图 4.21：因式分解公式](img/B15968_04_21.jpg)

图 4.21：因式分解公式

如果这些项的乘积等于零，那么至少其中一个项必须等于零才能满足方程。换句话说，解原方程等价于解每个方程*f*1*(x) = 0*，*f*2*(x) = 0*，…，和*f*n*(x) = 0*。理想情况下，我们希望每个这些*f*i*(x) = 0*方程都比原方程更容易解决。

让我们考虑一个起始例子：x2 = 100

使用恒等式*x*2 *- y*2 *= (x - y) (x + y)*对于所有实数*x*和*y*值，方程等价于*(x - 10) (x + 10) = 0*。

由于它们的乘积为零，*x - 10*或*x + 10*也必须为零。解这两个方程给出了原方程的解：*x = 10*或*x = -10*。

虽然这是一个相当简单的例子，但它能够说明一些要点。首先，通过将方程分解为相乘等于 0 的不同项，问题被转化为一组更简单的子问题。此外，通过分解，我们可以实现简单的加法/乘法操作无法实现的事情：解多项式方程。

让我们考虑下一个例子：*x*3 *- 7x*2 *+ 15x = 9*

我们看到，即使所有涉及*x*的项已经被分组在一起，也不清楚我们应该如何进行简单的代数运算。

在这里，一个有洞察力的数学学生可能会注意到这个方程接受*x = 1*或*x = 3*作为解（因为将这些值代入使方程的左边评估为 0）。多项式方程接受*x = c*作为解不仅意味着通过在方程中用*c*替换*x*，它将评估为零，而且还意味着方程本身可以被分解成形式*(x - c) g(x) = 0*，其中*g(x)*是方程的另一个分解项。这个技巧还有另一个名字，鲁菲尼法则，关于这个你可以在[`mathworld.wolfram.com/RuffinisRule.html`](https://mathworld.wolfram.com/RuffinisRule.html)找到更多信息。考虑到这一点，我们尝试根据*(x - 1)*的项来分解给定的方程如下：

图 4.22：分解给定的方程

](image/B15968_04_22.jpg)

图 4.22：分解给定的方程

记住方程也接受*x = 3*作为解，我们继续将*(x*2 *- 6x + 9)*分解为*(x - 3)*乘以另一个项。如果你熟悉二次方程公式，你可能已经能够判断方程可以分解为*(x - 1) (x - 3)*2 *= 0*。

最后，我们证明了给定的方程接受两个解：*x = 1*和*x = 3*。

* n *的多项式方程是指*x*的最大次数为*n*的方程。总的来说，我们希望将这样的方程分解为*n*个不同的因子。这是因为可以数学证明，*n*次多项式方程最多只能有*n*个唯一解。

换句话说，如果我们成功地将一个方程转化为*n*个不同的因子，那么这些因子中的每一个都是*x*的线性项，可以很容易地使用我们上面讨论的第一种方法来解决。例如，方程*2x*3 *- 7x*2 *+ 7x - 2 = 0*可以分解为*(x - 1) (x - 2) (2x - 1) = 0*，这给出了三个解：*x = 1*，*x = 2*和*x = 1 / 2*。

当然，有些情况下，*n*次多项式方程不能被分解为*x*的*n*个不同线性项。考虑以下例子方程*x*3 *+ 4x - 5 = 0*。

这接受了*x = 1*的解，因此有一个因子为*(x - 1)*：

图 4.23：x = 1 的因子

](image/B15968_04_23.jpg)

图 4.23：x = 1 的因子

现在，考虑*x*2 *+ x + 5*这个项。如果我们尝试将各种*x*的值代入方程，我们会发现没有一个值能满足方程。这表明这个方程没有解，或者更具体地说，*x*2 *+ x + 5*对所有的*x*值都大于 0，我们将证明这个陈述。

当我们想要证明一个变量的二次函数始终大于 0 时，我们可以利用*(g(x))*2 对于所有实数值的*x*和所有函数*g*始终是非负的这一事实（这是因为任何实数的平方都是非负的）。如果我们能够将*x*2 *+ x + 5*重写为*(g(x))*2 *+ c*的形式，其中*c*是一个正常数，我们就可以证明这个项始终是正的。

在这里，我们使用**完成平方技术**将*x*项分组成一个平方。这种技术涉及使用恒等式*(a + b)*2 *= a*2 *+ 2ab + b*2*对所有的*a*和*b*值来构造*(g(x))*2。具体来说，项*x*可以重写为*2 x (1/2)*，因为我们需要它以 2 乘以*x*再乘以另一个数字的形式。所以，我们有*x*2 和*2 x (1/2)*；因此我们需要*(1/2)*2 *= 1/4*来将这三个数字的和完成为一个平方：*x*2 *+ x + 1/4 = x*2 *+ 2 x (1/2) + (1/2)*2 *= (x + 1/2)*2。

因此整个项可以转换为*x*2 *+ x + 5 = (x*2 *+ x + 1/4) + 19/4 = (x + 1/2)*2 *+ 19/4*。

*(x + 1/2)*2 对于任何实数值的*x*都是非负的，因此整个项*(x + 1/2)*2 *+ 19/4*大于或等于*19/4*。这就是说，没有任何实数值的*x*使得项*x*2 *+ x + 5*等于*0*；换句话说，方程*x*2 *+ x + 5 = 0*没有任何解。

这就是解决多项式方程的因式分解技术的概述。最后，关于方程的主题，我们将讨论使用 Python 自动化解方程的过程。

## 使用 Python

除了手动解方程的两种方法之外，我们还可以利用 Python 的计算能力自动解决任何方程。在本节中，我们将在`SymPy`库的背景下探讨这个过程。

广义上说，SymPy 是 Python 中用于符号数学的最佳库之一，这是一个涵盖符号（如*x*、*y*和*f(x)*）的代数计算的总称。虽然 SymPy 提供了广泛的 API，包括对不同数学子领域的支持，包括微积分、几何、逻辑和数论，但在本章中，我们只会探索它解方程和（在下一节中）解方程组的选项。

注意

您可以在其官方网站[`docs.sympy.org/latest/index.html`](https://docs.sympy.org/latest/index.html)上找到有关该库的更多信息。

首先，我们需要为我们的 Python 环境安装该库。这个过程，像往常一样，可以通过`pip`和`conda`来完成。运行以下命令中的任意一个：

```py
$ pip install sympy
$ conda install sympy
```

在成功安装了该库之后，让我们使用一个特定的示例来探索它提供的选项，即我们在上一节中考虑的方程：*x*3 *- 7x*2 *+ 15x = 9*。

作为符号数学工具，SymPy 提供了一个简单的 API 来声明变量和函数。为此，我们首先从 SymPy 库中导入`Symbol`类并声明一个名为`x`的变量：

```py
from sympy import Symbol
x = Symbol('x')
```

当在 Jupyter 笔记本中打印`x`时，我们会看到这个字母实际上被格式化为一个数学符号：

![图 4.24：Jupyter 笔记本中的 SymPy 符号](img/B15968_04_24.jpg)

图 4.24：Jupyter 笔记本中的 SymPy 符号

现在，为了解决给定的方程，我们从`sympy.solvers`包中导入`solve()`函数。这个`solve()`函数接受一个包含 SymPy 符号的表达式（在这种情况下，就是我们的变量`x`），并找到使表达式等于 0 的`x`的值。换句话说，要解*x*3 *- 7x*2 *+ 15x = 9*，我们输入以下代码：

```py
from sympy.solvers import solve
solve(x ** 3 - 7 * x ** 2 + 15 * x - 9, x)
```

此代码片段返回`x`的解列表，这种情况下是`[1, 3]`。我们看到这对应于我们之前通过因式分解找到的解。

让我们检查另一个我们之前解决过的例子：*3e*x + 2 *+ 3 = 2(e*x *+ 100.* 记住这个方程有一个根，*x = ln( 197 / (3e*2 *- 2) )*，约为 2.279。现在，我们将这个方程输入到`solve()`函数中（在导入内置的`math`库中的常数`e`之后）：

```py
from math import e
solve(3 * e ** (x + 2) + 3 - 2 * (e ** x + 100), x)
```

这将给我们以下输出：

```py
[2.27914777845756]
```

正如我们所看到的，这与我们代数分析得到的解决方案相同。总的来说，通过声明变量并将任何形式的函数作为`solve()`函数的输入，SymPy 为我们提供了一种灵活和方便的方式来在 Python 中计算解方程。

这个话题也结束了我们对方程和找到它们解决方法的讨论。在我们进入本章的下一个话题之前，让我们通过一个练习来练习我们在本节学到的知识。

## 练习 4.03：盈亏分析简介

盈亏分析是经济学和金融工程中的常见实践。盈亏分析的目标是找到企业收入平衡成本的特定时间点。因此，找到这些时间点对于对业务所有者和利益相关者非常重要，他们希望知道是否以及何时会获利。

这种情景可以很容易地使用数学变量和函数进行建模，这是我们将在本练习中进行的。具体来说，我们的目标是通过解决盈亏平衡点来对一个简单的业务进行建模和进行盈亏分析。最终，您将更加熟悉使用数学模型、函数和变量来表示现实生活情况的过程。

**情景**：一家汉堡餐厅每卖出一份汉堡的原料成本为 6.56 美元。它还每个月有固定成本 1312.13 美元，用于厨师工资、租金、水电费等。餐厅的老板想进行盈亏分析，以确定何时收入将覆盖成本。

1.  在第一个代码单元格中创建一个新的 Jupyter 笔记本，并导入 NumPy、Matplotlib 和 SymPy：

```py
import numpy as np
import matplotlib.pyplot as plt
from sympy.solvers import solve
from sympy import Symbol
```

1.  假设餐厅将每个卖出的汉堡的价格定为 8.99 美元，让*x*表示每个月需要卖出的汉堡的数量，以便收入等于成本。写出这种情况下*x*的方程。

当*x*是卖出的汉堡的数量时，*8.99x*是餐厅将获得的收入，而*6.56x + 1312.13*是餐厅将发生的成本。因此*x*的方程将是：

*8.99x = 6.56x + 1312.13*

1.  通过手工解出*x*并在 Jupyter 笔记本的下一个单元格中使用 Python 验证结果。为了测试目的，将 SymPy 返回的解决方案列表存储到名为`sols`的变量中。

通过简单的代数变换，我们可以解出*x*为*x = 1312.13 / (8.99 – 6.56) = 539.97*。因此，餐厅需要大约卖出 540 份汉堡才能实现盈亏平衡。

以下代码可以使用 SymPy 来解决*x*的问题：

```py
x = Symbol('x')
sols = solve(8.99 * x - 6.56 * x - 1312.13, x)
```

`sols`变量应该有值`[539.971193415638]`，这对应于我们的解决方案。

1.  不要解出*x*作为盈亏平衡点，构建一个关于*x*的函数，表示每个月餐厅的总利润（收入减去成本）。

该函数应为*f(x) = 8.99x - 6.56x - 1312.13 = 2.43x - 1312.13*。

1.  在 Jupyter 笔记本的下一个代码单元格中，使用 NumPy 和 Matplotlib 绘制这个函数，*x*的值在 0 到 1000 之间，并在 0 处绘制一条水平线，颜色应为黑色：

```py
xs = np.linspace(0, 1000, 1000)
plt.plot(xs, 2.43 * xs - 1312.13)
plt.axhline(0, c='k')
plt.show()
```

这应该产生以下图表：

![图 4.25：盈亏分析的可视化](img/B15968_04_25.jpg)

图 4.25：盈亏分析的可视化

我们的利润曲线与水平线的交点代表盈亏平衡点。在这种情况下，我们看到它大约在*x*坐标为`540`处，这对应于实际的盈亏平衡点。

1.  假设餐厅平均每月销售 400 个汉堡，现在让*x*成为餐厅可以设置的汉堡价格，以便他们可以实现盈亏平衡。写下这种情况下*x*的方程。

当*x*是汉堡的价格时，*400x*是餐厅将获得的利润，而*(400) 6.56 + 1312.13 = 3936.13*（每个汉堡*6.56*美元和固定金额*1312.13*美元）是餐厅将发生的成本。因此，*x*的方程将是*400x = 3936.13*。

1.  通过手工求解*x*，并在 Jupyter 笔记本中使用 SymPy 验证结果。将 SymPy 返回的解列表存储在名为`sols1`的变量中。

通过将两边都除以 400，可以简单地解出方程，得到*x = 9.84*。解决相同方程的 Python 代码如下，也得到相同的结果：

```py
sols1 = solve(400 * x - 3936.13, x)
sols1
```

1.  在下一个代码单元格中，绘制代表利润和成本之间差异的函数，*x*值在`0`和`10`之间，以及水平线在`0`处：

```py
xs = np.linspace(0, 10, 1000)
plt.plot(xs, 400 * xs - 3936.13)
plt.axhline(0, c='k')
plt.show()
```

这应该产生以下图表：

![图 4.26：盈亏分析的可视化](img/B15968_04_26.jpg)

图 4.26：盈亏分析的可视化

再次，两条线的交点（代表盈亏平衡点）与我们得出的实际解相符。

这就是我们练习的结束。在其中，我们通过建模一个样本现实生活中的业务，使用数学函数和变量，介绍了盈亏分析的概念。我们已经学会了如何找到要生产的产品数量，以及设置盈亏平衡的正确价格。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3gn3JU3`](https://packt.live/3gn3JU3)。

您也可以在[`packt.live/3gkeA0V`](https://packt.live/3gkeA0V)上在线运行此示例。

当然，现实生活中的业务场景更加复杂，涉及更多因素。我们将在本章末尾的活动中回到盈亏分析的任务，但在此之前，我们需要讨论本章的最后一节：方程组。

# 方程组

方程是我们需要通过解出特定变量的值来满足的相等式。在方程组中，我们有涉及多个变量的多个方程，目标仍然是相同的：解出这些变量的值，使系统中的每个方程都得到满足。

总的来说，系统可以有任意数量的方程。然而，可以严格证明，当系统的方程数量不等于其变量数量时，系统要么有无穷多个解，要么没有解。在本节中，我们只考虑这两个数字相等的情况。

此外，我们将考虑两种不同类型的方程组：线性方程组和非线性方程组。我们将考虑解决这两种类型的方程组的方法，无论是手工还是使用 Python。首先，让我们讨论线性方程组的概念。

## 线性方程组

与线性方程类似，线性方程组只包含常数和其变量的线性项，由线性方程组组成，这些方程也只包含其变量和常数的线性组合。

这种系统的一个简单示例如下：

![图 4.27：线性方程组的示例](img/B15968_04_27.jpg)

图 4.27：线性方程组的示例

正如我们所看到的，这个方程组有两个变量：*x* 和 *y*。这两个方程中包含这些变量与常数（线性项）相乘以及常数本身。

要解决这个方程组，您可能已经注意到，如果我们将两个方程的各自的两边相加，我们将得到一个额外的方程，*3y=8*，然后我们可以解出*y=8/3*，随后解出*x=5-8/3=7/3*。

总的来说，这种方法涉及将我们提供的方程分别乘以不同的常数并将它们相加，以依次消除变量。目标是获得一个只剩下单个变量的线性项（可能还有常数）的方程。然后我们可以解出这个变量。然后将这个变量的解值代入原方程，这个过程将继续进行下去，直到解出所有的变量。

尽管当我们拥有的变量/方程的数量相对较小时，这个过程是直接的，但随着这个数量的增加，它可能会变得非常混乱。在本小节中，我们将考虑一种称为*行简化*或*高斯消元*的方法，这将帮助我们规范化并自动化解方程组的过程。

假设我们被要求解下面的一般线性方程组，其中有*n*个变量和*n*个方程：

![图 4.28：具有 n 个变量和 n 个方程的线性方程组](img/B15968_04_28.jpg)

图 4.28：具有 n 个变量和 n 个方程的线性方程组

在这里，*c*ij 是第*i*个方程中变量*x*j 的常数系数。同样，这些*c*ij 值可以取任何常数值，这个方程组是任何线性方程组的最一般形式。 

为了应用行简化方法，我们构造了所谓的增广矩阵，即以下内容：

![图 4.29：一个增广矩阵](img/B15968_04_29.jpg)

图 4.29：一个增广矩阵

矩阵的左侧部分是一个*n*乘以*n*的子矩阵，其元素对应于原方程组中的常数系数；矩阵的右侧部分是一个包含*n*个值的列，这些值对应于原方程组中方程右侧的常数值。

现在，从这个增广矩阵中，我们可以进行三种类型的变换：

+   交换任意两行的位置。

+   将一行乘以非零常数。

+   将一行添加到任何其他行（可能也要乘以非零常数）。

该方法的目标是将增广矩阵转换成*简化行梯阵形式*，或者，因为我们有一个*n*个方程和*n*个变量的系统，转换成一个单位矩阵，其中第*i*行的第*i*个元素为 1，该行的其他元素为*0*。基本上，我们希望将增广矩阵转换成这个矩阵：

![图 4.30：矩阵变换](img/B15968_04_30.jpg)

图 4.30：矩阵变换

完成这一步之后，*c*i*'*值对应于构成原方程组解的值。换句话说，解将是*x*1*=c*1*，*x*2*=c*2*，依此类推。

尽管这种数学概括可能看起来令人生畏，但让我们通过考虑一个具体的例子来揭开这个过程的神秘面纱。假设我们要解下面的线性方程组：

![图 4.31：线性方程组](img/B15968_04_31.jpg)

图 4.31：线性方程组

我们首先构造相应的增广矩阵：

![图 4.32：相应的增广矩阵](img/B15968_04_32.jpg)

图 4.32：相应的增广矩阵

现在，我们的目标是通过使用三种提到的变换方法将这个矩阵转换成单位形式。我们首先将第二行减去三倍的第一行，然后除以 4 得到：

![图 4.33：将矩阵转换为单位矩阵的第一步](img/B15968_04_33.jpg)

图 4.33：将矩阵转换为单位矩阵的第 1 步

同样，目标是在左侧创建单位矩阵的结构，这可以通过强制非对角元素为零来实现。我们已经对第二行的第一个元素做到了这一点，所以现在让我们尝试对第三行做同样的事情，通过减去两倍的第一行：

![图 4.34：将矩阵转换为单位矩阵](img/B15968_04_34.jpg)

图 4.34：将矩阵转换为单位矩阵的第 2 步

第三行的第二个元素要转换为 0，可以通过减去两倍的第二行来实现：

![图 4.35：将矩阵转换为单位矩阵的第 3 步](img/B15968_04_35.jpg)

图 4.35：将矩阵转换为单位矩阵的第 3 步

一旦最后一行处于正确形式，转换其他行也相对容易。现在我们将第二行减去三倍的第三行，并乘以-1，得到：

![图 4.36：将矩阵转换为单位矩阵的第 4 步](img/B15968_04_36.jpg)

图 4.36：将矩阵转换为单位矩阵的第 4 步

至于第一行，我们首先加上三倍的第三行，以消除最后一个元素：

![图 4.37：将矩阵转换为单位矩阵的第 5 步](img/B15968_04_37.jpg)

图 4.37：将矩阵转换为单位矩阵的第 5 步

最后，我们减去三倍的第二行，这样就可以得到增广矩阵的行阶梯形式（左侧为单位矩阵）：

![图 4.38：单位矩阵](img/B15968_04_38.jpg)

图 4.38：单位矩阵

这对应于解*x = 1*，*y = 2*，和*z = 3*。我们可以通过将这些值代入原始方程组来确保我们的解确实是正确的，这显示它们确实满足该系统。

这就是使用行简化方法的过程。如前所述，解线性方程组的另一种方法是矩阵解法。这涉及将给定系统表示为矩阵方程。具体来说，从任何线性方程组的一般形式开始：

![图 4.39：线性方程组](img/B15968_04_39.jpg)

图 4.39：线性方程组

我们可以将其重写为矩阵表示形式*Ax = c*，其中*A*是包含常数系数的*n*乘*n*矩阵，*x*是包含我们要求解的变量的向量：*x*1，*x*2，…，*x*n，*c*同样是包含常数系数*c*1，*c*2，…，*c*n 的向量。由于矩阵和向量的乘积的定义，方程*Ax = c*确实等价于原始方程组。

在这个矩阵表示中，向量*x*可以很容易地求解为*x = A*-1 *c*，其中*A*-1 是*A*的*逆矩阵*。任何给定矩阵*M*的逆矩阵*M*-1 是满足方程*A A*-1 *= I*的矩阵，其中*I*是单位矩阵。

矩阵和向量之间的这种乘积称为**点积**，它输出另一个向量，其元素等于原始矩阵和向量中对应元素的乘积之和。在我们的情况下，*A*-1 和*c*之间的点积将给出构成系统解的向量。

有些矩阵没有对应的逆矩阵；这些矩阵称为奇异矩阵。我们可以用来判断矩阵是否奇异的标志之一是，如果矩阵的一行恰好是另一行乘以一个常数得到的。

从理论上讲，这类似于一个系统中的一个方程的系数是另一个方程的系数的精确乘法。如果是这种情况，我们要么有重复信息（当两个方程具有相同信息时，系统有无穷多个解），要么有冲突信息（当两个方程右侧的常数不匹配时，系统没有解）。

这背后的理论不在本书的范围之内。目前，我们只需要知道，如果线性方程组的对应系数矩阵没有逆矩阵，那么该系统就没有明确的解。

因此，并非每个矩阵都有其自己的逆矩阵，即使给定的矩阵有，计算逆矩阵的过程也可能非常复杂。幸运的是，在 Python 中可以相对容易地使用 NumPy 来完成这个过程，我们将在即将进行的练习中看到。具体来说，NumPy 中的`linalg`（代表线性代数）包提供了许多与线性代数相关的算法的高效实现。在这里，我们对`inv()`函数感兴趣，它接受表示矩阵的二维 NumPy 数组，并返回相应的逆矩阵。我们将在下一个练习中首次亲身体验这个函数的效果；有关该包的更多信息也可以在[`docs.scipy.org/doc/numpy/reference/routines.linalg.html`](https://docs.scipy.org/doc/numpy/reference/routines.linalg.html)找到。

## 练习 4.04：使用 NumPy 进行矩阵解法

在这个练习中，我们将编写一个程序，该程序接受一个线性方程组，并使用矩阵解法方法产生其解。同样，这将通过使用 NumPy 计算系数矩阵的逆矩阵来完成：

1.  创建一个 Jupyter 笔记本。在其第一个单元格中，导入 NumPy 及其`linalg`包中的`inv()`函数：

```py
import numpy as np
from numpy.linalg import inv
```

1.  在下一个代码单元格中，声明一个名为`solve_eq_sys()`的函数（用于测试目的），它接受两个参数：`coeff_matrix`，它存储线性方程组中常数系数的矩阵，以及`c`，它存储方程右侧的常数值向量：

```py
def solve_eq_sys(coeff_matrix, c):
```

这两个参数完全定义了线性方程组的一个实例，`solve_eq_sys()`函数的工作是计算其解。我们进一步假设这些参数都存储为 NumPy 数组。

1.  回想一下，系统的解为*x = A*-1 *c*，我们只需返回`coeff_matrix`的逆矩阵和`c`的乘积。

可以使用 NumPy 的`inv()`函数计算逆矩阵：

```py
inv_matrix = inv(coeff_matrix)
```

最后，可以使用`dot()`方法计算解决方案，该方法计算矩阵和向量的点积：

```py
return inv_matrix.dot(c)
```

我们的函数应该如下所示：

```py
def solve_eq_sys(coeff_matrix, c):
    inv_matrix = inv(coeff_matrix)
    return inv_matrix.dot(c)
```

1.  在下一个代码单元格中，为我们之前考虑的方程组声明相应的系数矩阵和`c`向量，并对它们调用`solve_eq_sys()`函数：![图 4.40：线性方程组](img/B15968_04_40.jpg)

图 4.40：线性方程组

这段代码应该是：

```py
coeff_matrix = np.array([[1, 3, -2],\
                         [3, 5, 6],\
                         [2, 4, 3]])
c = np.array([1, 31, 19])
solve_eq_sys(coeff_matrix, c)
```

这段代码应该产生以下输出：

```py
array([1., 2., 3.])
```

我们看到，这个输出恰好对应于使用行简化方法得出的方程组的实际解：*x = 1*，*y = 2*，*z = 3*。

1.  现在，我们想考虑系数矩阵是奇异的情况。我们通过在以下没有解的示例线性方程组上测试我们的代码来做到这一点：![图 4.41：线性方程组示例](img/B15968_04_41.jpg)

图 4.41：线性方程组示例

我们看到，如果我们将第一个方程乘以`2`，得到的方程与第三个方程矛盾。换句话说，没有一组变量*x*、*y*和*z*的值可以满足该系统。

在下一个代码单元格中，对此系数矩阵调用`inv()`函数：

```py
inv(np.array([[1, 3, -2],\
              [3, 5, 6],\
               [2, 6, -4]]))
```

我们将看到这段代码产生了一个`LinAlgError: Singular matrix`错误，我们将在下一步中修复这个错误。

为了测试目的，取消注释此单元格。

1.  回到我们的代码，并用一个`try...except`块修改我们当前的`solve_eq_sys()`函数来处理这个错误，这将需要从 NumPy 中导入：

```py
from numpy.linalg import inv, LinAlgError
```

现在，如果输入矩阵是奇异的，函数应该返回`False`。它应该如下所示：

```py
def solve_eq_sys(coeff_matrix, c):
    try:
        inv_matrix = inv(coeff_matrix)
        return inv_matrix.dot(c)
    except LinAlgError:
        return False
```

1.  在下一个代码单元格中，对我们在*步骤 5*中使用的示例方程组调用此函数：

```py
coeff_matrix = np.array([[1, 3, -2],\
                         [3, 5, 6],\
                         [2, 6, -4]])
c = np.array([1, 31, 19])
solve_eq_sys(coeff_matrix, c)
```

这次，函数返回值`False`，这是我们期望的行为。

通过这个练习，我们学会了如何使用 NumPy 实现矩阵解法来解决线性方程组。这也结束了线性方程组的主题。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2NPpQpK`](https://packt.live/2NPpQpK)。

您也可以在[`packt.live/2VBNg6w`](https://packt.live/2VBNg6w)上在线运行此示例。

在本章的下一节和最后一节中，我们将考虑不完全线性的方程组。

## 非线性方程组

当一个系统包含一个方程，其中包含一些变量的非线性项时，我们在上一节讨论的方法不适用。例如，考虑以下系统：

![图 4.42：非线性方程组示例](img/B15968_04_42.jpg)

图 4.42：非线性方程组示例

问题出在非线性项*x*2 上，这使我们想要对系统应用的任何转换变得复杂。

然而，我们仍然可以有一个系统化的方法来解决这些类型的系统。具体来说，注意到从任一方程中，我们都可以解出一个变量的另一个变量。为了做到这一点，我们对每个方程进行代数变换，使得一个变量可以纯粹地表示为另一个变量。特别地，*y*可以表示为*x*的函数，如下所示：

![图 4.43：替换方程以找到 y 的值](img/B15968_04_43.jpg)

图 4.43：替换方程以找到 y 的值

因此，为了使系统有一个有效的解，*y*的两个值需要匹配。换句话说，我们有以下只包含*x*的方程：

![图 4.44：在两边替换 y 的值](img/B15968_04_44.jpg)

图 4.44：在两边替换 y 的值

这只是一个关于*x*的多项式方程，正如我们所知，可以通过因式分解来解决。具体来说，该方程可以因式分解为*(x - 2) (x - 1) = 0*，显然接受*x = 1*和*x = 2*作为解。这些*x*的每个值对应于*y*的一个值，可以通过将 1 和 2 代入原始方程组来找到。最终，该系统有两个解：*(x = 1, y = 4)*和*(x = 2, y = 3)*。

总的来说，这种方法称为**替换**，表示我们能够通过转换方程来解出一个变量的另一个变量。然后将这个解代入另一个方程中，这样我们就得到了一个单变量的方程。

让我们看另一个例子，应用这种方法来解决以下方程组：

![图 4.45：方程组示例](img/B15968_04_45.jpg)

图 4.45：方程组示例

虽然有多种解决方法，但一种明显的方法是解出第二个方程中的*y*，得到*y = (x*2 *- 1) / 2*，然后将其代入第一个方程中，如*x*2 *- 2x - (x*2 *- 1)*2 */ 4 = -1*。

通过一些代数运算，我们可以将方程简化为*x*4 *-6x*2 *+ 8x -3 = 0*。

现在我们有一个只包含一个变量的方程，所以我们可以应用我们在上一节学到的技巧来解出*x*。一旦我们得到*x*的解，我们也可以使用之前的*y = (x*2 *- 1) / 2*代换来解出*y*。

在这里，可以应用因式分解来找到满足这个方程的*x*的值。让我们尝试代入一些*x*的值，比如*-1*、*0*、*1*或*2*，看哪个能使函数的值为 0。注意到*x = 1*是一个有效的解，我们首先将方程关于*(x - 1)*进行因式分解，得到*(x - 1) (x*3 *+ x*2 *- 5x + 3) = 0*。

我们再次注意到*x = 1*仍然满足方程*x*3 *+ x*2 *– 5x + 3 = 0*，因此我们再次进行因式分解得到*(x - 1)*2 *(x*2 *+ 2x - 3) = 0*。

二次函数*x*2 *+ 2x - 3*可以因式分解为*(x - 1) (x + 3)*。最终，我们得到以下方程*(x - 1)*3 *(x + 3) = 0*。

有两个*x*的值满足方程：*x = 1*和*x = -3*。通过将它们代入原方程组，我们可以解出*y*，得到方程组的两个解：*(x = 1, y = 0)*和*(x = -3, y = 4)*。

不幸的是，并非所有的非线性方程组都允许我们以如此简单的方式使用代换法。在许多情况下，需要使用微妙而巧妙的技巧来解决复杂的方程组。

那么，如果我们想要自动化地找到这些方程组的解，该怎么办呢？这就是`sympy`库提供的符号计算能力再次派上用场的地方。我们已经看到，使用 SymPy，我们可以解决任何一个一元方程。同样的想法也可以应用于非线性方程组，只是在这种情况下，我们将一系列符号函数传递给`solve()`函数。

在这一节中，我们想要使用 SymPy 来解决我们有的两个方程组；首先：

![图 4.46：第一个方程组](img/B15968_04_46.jpg)

图 4.46：第一个方程组

其次：

![图 4.47：第二个方程组](img/B15968_04_47.jpg)

图 4.47：第二个方程组

为此，我们首先将我们的变量声明为 SymPy 中`Symbol`类的实例：

```py
x = Symbol('x')
y = Symbol('y')
```

我们可以调用 SymPy 中的`solve()`函数来找到我们有的方程组的解。对于第一个方程组：

```py
solve([x + y - 5, x ** 2 - x + 2 * y - 8],\
       x, y)
```

这段代码将返回`[(1, 4), (2, 3)]`，这是我们之前得到的*x*和*y*的有效解的列表。至于第二个方程组：

```py
solve([x ** 2 - 2 * x - y ** 2 + 1, x ** 2 - 2 * y - 1],\
       x, y)
```

这段代码返回`[(-3, 4), (1, 0)]`，这也对应着我们得到的解。正如我们所看到的，SymPy 为我们提供了一个简单的语法，让我们轻松地解决方程和方程组。

这个例子也标志着这一节材料的结束。为了结束这一章，我们将考虑对我们之前进行的盈亏分析练习的扩展。

## 活动 4.01：多变量盈亏分析

正如我们在第一个盈亏分析练习的结尾提到的，随着我们模型中变量的数量增加，盈亏分析可能变得非常复杂。当模型中有多个变量时，需要使用方程组来找到盈亏平衡点，这就是我们将在这个活动中做的事情。

回想一下，在我们的例子中，汉堡餐厅的商业模型中，我们每生产一个汉堡的成本是 6.56 美元，每个月的固定成本是 1312.13 美元，用于水电费、房租和其他费用。在这个活动中，我们将探讨企业的总利润如何随着我们销售的汉堡数量和每个汉堡的价格而变化。

我们需要这个模型的一个额外信息是餐厅所在地区的人们对汉堡的需求。假设，平均而言，餐厅观察到他们的收入每个月大约是 4000 美元，所以对汉堡的需求大约是 4000 除以一个汉堡的价格。

要完成此活动，请执行以下步骤：

1.  将餐厅每月生产的汉堡数量和每个汉堡的价格视为我们模型的两个变量。用这两个变量表示餐厅的月收入、成本和总利润。

1.  构建一个与盈亏平衡点相对应的方程组：当餐厅生产的汉堡数量满足需求且收入等于成本时。

1.  通过手工解决这个方程组，并在 Jupyter 笔记本中使用 SymPy 验证结果。

1.  在同一个 Jupyter 笔记本中，编写一个 Python 函数，该函数接受生产的汉堡数量和每个汉堡的价格的任何组合。该函数应返回餐厅的总利润。

1.  在下一个代码单元格中，创建一个潜在值列表，表示每月生产的汉堡数量，范围从 300 到 500。使用每个汉堡 9.76 美元的固定价格生成相应利润列表，并将其存储在名为`profits_976`的变量中（用于测试）。将这个利润列表作为生产的汉堡数量的函数绘制出来。

1.  在下一个代码单元格中，生成相同的利润列表，这次使用每个汉堡 9.99 美元的固定价格，并将其存储在名为`profits_999`的变量中。创建相同的图表，并解释它与盈亏平衡点的关系。

1.  在下一个单元格中，创建一个潜在值列表，表示要生产的汉堡数量；它应该是 300 到 500 之间的每个偶数（例如，300、302、304，…，500）。另外，创建一个 NumPy 数组，其中包含 5 到 10 之间的 100 个均匀间隔的潜在汉堡价格。

1.  最后，生成一个二维列表，其中第一个列表中第*i*个数字表示将要生产的汉堡数量，第二个列表中第*j*个数字（NumPy 数组）表示每个汉堡的价格。将此列表存储在名为`profits`的变量中以进行测试。

1.  使用 Matplotlib 创建一个热力图，以可视化前一步生成的利润的二维列表，作为生产的汉堡数量（作为*y*轴）和每个汉堡的价格（作为*x*轴）的函数。

注意

此活动的解决方案可在第 665 页找到。

# 总结

本章正式介绍了数学上函数和变量的定义。还讨论了与函数相关的各种主题，如定义域、值域和函数的图。在本章的第二部分，我们讨论了方程和方程组的概念，以及寻找它们解的特殊方法。在这些讨论中，还检查了 SymPy 库和 NumPy 中计算矩阵的逆的函数。我们通过完成一个使用代数和函数构建多变量盈亏分析的任务来结束本章。

在下一章中，我们将继续讨论数学中的另一个重要主题：序列和级数。

FKV27

GCH43
