# 第十一章：11.使用 Python 进行更多微积分

概述

在本章中，您将学习如何根据其方程计算曲线的长度。您将学习如何在三维空间中使用偏导数来计算表面积。跟随中世纪的数学家的脚步，您将使用无限级数来计算诸如π之类的常数，并确定级数的收敛区间。像现代数学家和机器学习工程师一样，您将学习如何使用偏导数找到表面上的最小点。在本章结束时，您将能够使用微积分解决各种数学问题。

# 介绍

在上一章中，我们学习了如何计算导数和积分。现在，我们将使用这些工具来找到曲线和螺旋线的长度，并将这种推理扩展到三维空间，以找到复杂表面的面积。我们还将研究微积分中常用的工具，即无限级数，用于计算重要常数和近似复杂函数。最后，我们将研究机器学习中的一个重要概念：找到曲线上的最小点。当您使用神经网络时，您会创建一种“误差函数”，并努力找到曲面上使误差最小的点。我们将创建自己的梯度下降函数，不断向下移动，直到到达曲面的底部。

# 曲线的长度

导数和积分的一个主要用途是找到曲线的长度。有一个公式：

![图 11.1：计算曲线长度的公式](img/B15968_11_01.jpg)

图 11.1：计算曲线长度的公式

前面的公式包含积分和导数。要找到曲线的长度，我们需要我们的导数和积分函数。如果您还没有它们，请将它们复制并粘贴到您的代码中：

```py
from math import sqrt

def derivative(f,x):
    """Returns the value of the derivative of     the function at a given x-value."""
    delta_x = 1/1000000
    return (f(x+delta_x) - f(x))/delta_x

def trap_integral(f,a,b,num):
    """Returns the sum of num trapezoids     under f between a and b"""
    width = (b-a)/num
    area = 0.5*width*(f(a) + f(b) + 2*sum([f(a+width*n) \                                        for n in range(num)]))
    return area
```

以下是公式的 Python 版本：

```py
def curve_length(f,a,b,num):
    def g(x):
        return sqrt(1+(derivative(f,x)**2))
    return trap_integral(g,a,b,num)
```

请注意，我们只是将数学符号转换为 Python 代码。我们在`f`函数内定义了`g`函数。`g`函数是公式中平方根下的所有内容。然后，我们使用我们的`trap_integral`函数来找到`a`和`b`之间`g`函数的累积值。

让我们检查一下我们知道长度的曲线，比如线*y = 2x*。我们可以使用勾股定理计算曲线的长度，*x = (0,0)*和*x = (2,4)*之间的距离，结果为 2√5 或 4.47 个单位：

```py
def f(x):
    return 2*x
print(curve_length(f,0,2,1000))
```

前面的代码输出了 4.47...作为输出。

但是当我们尝试检查我们知道长度的实际曲线，比如半圆时，我们遇到了问题。我们知道以下方程的长度，因为它是半径为 1 的圆的一半周长。所以，我们应该得到π或 3.1415...作为输出：

![图 11.2：计算半圆长度的公式](img/B15968_11_02.jpg)

图 11.2：计算半圆长度的公式

让我们把`f(x)`改成前面半圆的方程：

```py
def f(x):
    return sqrt(1-x**2)
print(curve_length(f,-1,1,100))
```

当您执行前面的代码时，会出现错误。错误消息的最后一行（我读到的第一行）说：

```py
ValueError: math domain error
```

这是因为半圆在-1 和 1 处的导数是无穷大。这些点处的切线是垂直的，如下图所示：

![图 11.3：垂直切线，斜率无穷大](img/B15968_11_03.jpg)

图 11.3：垂直切线，斜率无穷大

所以，这种方法已经遇到了问题。让我们看看它是否能找到正常多项式的长度，比如下图所示的多项式：

![图 11.4：一个复杂的多项式](img/B15968_11_04.jpg)

图 11.4：一个复杂的多项式

这是一个 5 次多项式，意味着*x*的最高指数是*5*。曲线的方程如下：

![图 11.5：曲线的方程](img/B15968_11_05.jpg)

图 11.5：曲线方程

尽管看起来很复杂，但在曲线上没有地方导数是无穷大的，就像*图 11.3*中那样。这意味着我们可以在它上面使用我们的曲线长度函数。

以下是多项式的代码：

```py
def f(x):
    return 0.7*x**5 + 1.6*x**4-2.05*x**3 -3*x**2+2.95*x+2.9
print(curve_length(f,-2,1,1000))
```

曲线的长度如下：

```py
9.628984854276812
```

我们可以使用 Wolfram Alpha 来解决这个问题，方法是输入*length of curve y = ... from –2 to 1*，然后检查它是否是一个很好的近似值。但是使用 Python，有一种更直接的方法来计算曲线的长度，它不会遇到我们在导数中遇到的问题。事实上，它甚至不使用导数或积分。你可以简单地使用毕达哥拉斯定理找到曲线的微小部分的长度，并累加所有这些微小部分，如下图所示。我们知道宽度，我们对微小直角三角形的斜边感兴趣。我们可以计算高度，即*x*处的函数和*x*处的函数之间的差，再加上宽度：

![图 11.6：找到曲线的微小部分的长度](img/B15968_11_06.jpg)

图 11.6：找到曲线的微小部分的长度

在前面图表中显示的直角三角形的斜边如下：

![](img/B15968_11_07.jpg)

图 11.7：计算直角三角形斜边的公式

我们所要做的就是遍历从`a`到`b`的区间，计算所有这些长度。以下是如何在 Python 中实现的：

```py
def f(x):
    return 0.7*x**5 + 1.6*x**4-2.05*x**3 -3*x**2+2.95*x+2.9
def curve_length2(f,a,b,num=1000):
    """Returns the length of f between\
    a and b using num slices"""
    output = 0
    width = (b-a)/num
    for i in range(num):
        output += sqrt((f(a+(i+1)*width)-f(a+i*width))**2 + width**2)
    return output
```

这应该让你想起积分程序：创建一个运行总和，然后循环遍历曲线的每个*片段*，在此过程中添加面积（在本例中是弧长）。最后，返回运行总和的最终值。

这是我们感兴趣的区间的曲线长度：

```py
print(curve_length2(f,-2,1))
```

这给出了曲线的长度为`9.614118659973549`。这甚至比以前的版本更接近，而且麻烦要少得多。现在轮到你在以下练习中做同样的事情了。

## 练习 11.01：找到曲线的长度

在这个练习中，你将得到以下曲线方程。使用这个方程，确定两个给定*x*值之间的曲线长度：

![图 11.8：曲线方程](img/B15968_11_08.jpg)

图 11.8：曲线方程

这些值将从*x = -1*到*x = 1*。

执行以下步骤：

1.  首先，我们需要使用前述方程创建一个`circle`函数：

```py
def circle(x):
    return sqrt(1-x**2)
```

注意

这又是一个半圆。这次，我们的`curve_length2`函数将毫无问题地累加弧线的微小切片。

1.  现在，我们将在该曲线上运行`curve_length2`函数（我们已经编码过了），以累加所有微小段，就像以前一样：

```py
def curve_length2(f,a,b,num=1000):
    """Returns the length of f between\
       a and b using num slices"""
    output = 0
    width = (b-a)/num
    for i in range(num):
        output += sqrt((f(a+(i+1)*width)-f(a+i*width))**2 \
                        + width**2)
    return output
```

1.  现在，我们打印函数的输出，从*x = -1*到*x = 1*进行测量：

```py
print(curve_length2 (circle,-1,1))
```

输出如下：

```py
3.1415663562164773
```

这次没有错误消息。我们得到了一个很好的近似值，即半径为 1 的圆的半周长，我们知道是π。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3gkI5Qi`](https://packt.live/3gkI5Qi)。

你也可以在[`packt.live/3eVpSbz`](https://packt.live/3eVpSbz)上在线运行这个例子。

## 练习 11.02：找到正弦波的长度

数学和科学中一个非常重要和有用的函数是正弦波。它在 0 和 2π之间完成一个周期，如下图所示：

![图 11.9：正弦波的一个周期](img/B15968_11_09.jpg)

图 11.9：正弦波的一个周期

测量它的波长（2π）和振幅（它上下移动的距离，即 1 个单位）很容易，但实际曲线有多长呢？在这个练习中，我们将找到从 0 到 2π的正弦波的长度。

执行以下步骤：

1.  我们将再次使用我们的`curve_length2`函数，但现在我们必须从`math`模块导入我们的`sin`和`pi`函数：

```py
from math import sin, pi
```

1.  我们已经编写了`curve_length2`函数，它将累加曲线的所有部分。我们只需要告诉它要使用的函数，以及开始和结束的*x*值：

```py
print(curve_length2(sin,0,2*pi))
```

输出如下：

```py
7.640391636335927
```

如您所见，使用`curve_length2`函数，计算正弦波的长度变得非常容易。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3dUy3nk`](https://packt.live/3dUy3nk)。

您还可以在[`packt.live/2VFy2xd`](https://packt.live/2VFy2xd)上在线运行此示例。

# 螺旋的长度

那么，极坐标中的螺旋怎么样，其中*r*，即与原点的距离，是与与*x*轴成角度（θ）的函数？我们不能使用我们的*x*和*y*函数来测量以下图中显示的螺旋：

![图 11.10：阿基米德螺旋](img/B15968_11_10.jpg)

图 11.10：阿基米德螺旋

在前面的图中，我们有一个从（5,0）开始，绕中心旋转 7.5 圈，最终到达（11,π）的螺旋。该曲线的公式为*r(θ) = 5 + 0.12892θ*。旋转的弧度数是 7.5 乘以 2π，即 15π。我们将使用与前一节相同的思路：我们将找到从*r(θ)*到*r(θ+step)*的直线长度，step 是中心角的一个小步长，如下图所示：

![图 11.11：近似曲线的一小部分的长度](img/B15968_11_11.jpg)

图 11.11：近似曲线的一小部分的长度

三角形中央角的对边就像我们积分问题中的切片或前一个曲线长度程序中三角形的斜边一样。这次，它不是直角三角形，所以我们不能使用斜边。但是对于这个问题，有一个称为余弦定律的公式。在三角形 ABC 中，角 C 的对边长度如下：

![图 11.12：余弦定律](img/B15968_11_12.jpg)

图 11.12：余弦定律

我们所需要做的就是将其放入一个函数中，就像这样：

```py
def opposite(a,b,C):
    """Returns the side opposite the given angle in
       a triangle using the Law of Cosines
       Enter side, side, angle"""
    c = sqrt(a**2 + b**2 - 2*a*b*cos(C))
    return c
```

然后，我们只需要编写一个函数，从起始角度开始，沿着曲线采取微小步骤，测量每个微小角度的对边，直到达到结束角度：

```py
from math import sqrt,cos,pi
def spiral(r,a,b,step=0.0001):
    """Returns length of spiral r from
       a to b taking given step size"""
    length = 0
    theta = a
    while theta < b:
        length += opposite(r(theta),r(theta+step),step)
        theta += step
    return length
```

我们的函数如下：

```py
def r(theta):
    return 5 + 0.12892*theta
```

因此，我们所要做的就是在该螺旋上执行我们的螺旋函数，从 0 到 15π：

```py
spiral(r,0,2*pi*7.5)
```

输出如下：

```py
378.8146271783955
```

如您所见，螺旋的长度为`378.8146271783955`。在下一个练习中，我们将看看如何找到极坐标螺旋曲线的长度。

## 练习 11.03：找到极坐标螺旋曲线的长度

在这个练习中，您将找到极坐标螺旋曲线的长度，该曲线从（3,0）开始，围绕中心旋转 12 次，最终到达（16,0）。

执行以下步骤以找到所需的长度：

1.  我们不知道这个螺旋的公式，但我们知道半径在 12 个旋转中增加了 13 个单位（从 3 到 16）。这意味着对于角度θ的每个 2π增加，半径增加 13/12 个单位。因此，我们将 13/12 除以 2π。半径的增加可以表示如下：![图 11.13：计算半径增加的公式](img/B15968_11_13.jpg)

图 11.13：计算半径增加的公式

1.  我们可以用 Python 这样表示：

```py
def r(theta):
    return 3 + 0.1724*theta
```

1.  我们可以检查以确保*r(0) = 3*和*r(24π) = 16*：

```py
print(r(0),r(24*pi))
```

输出如下：

```py
3.0 15.998653763493127
```

1.  现在，我们只需将其放入我们的螺旋函数中：

```py
spiral(r,0,2*pi*12)
```

输出如下：

```py
716.3778471288748
```

在这个练习中，我们仅通过知道曲线的起始值和结束值以及它围绕中心旋转的次数，就轻松找到了这个螺旋曲线的长度，即`716.3778471288748`。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2YT70EH`](https://packt.live/2YT70EH)。

您还可以在[`packt.live/2YV4wFT`](https://packt.live/2YV4wFT)上在线运行此示例。

## 练习 11.04：找到卷中的绝缘长度

您被要求找到所示卷中绝缘的（近似）长度：

![图 11.14：使用微积分测量卷起的材料](img/B15968_11_14.jpg)

图 11.14：使用微积分测量卷起的材料

您测量卷起并发现中心是一个直径为 4 英寸的空圆（因此*r(0) = 2*）。卷的外径为 26 英寸。您从中心到外部计算层数，并估计螺旋需要 23 个半转，因此*r(2π*23.5)= 26/2 = 13*。

执行以下步骤计算长度：

1.  使用前面的数据计算方程：![图 11.15：计算半径的公式](img/B15968_11_15.jpg)

图 11.15：计算半径的公式

1.  这就是螺旋图的样子：![图 11.16：绝缘卷的图表](img/B15968_11_16.jpg)

图 11.16：绝缘卷的图表

1.  现在，将我们的`r`代码更改为这个螺旋并不难：

```py
def r(theta):
    return 2 + 0.0745*theta
```

1.  现在，我们可以在这个函数上运行我们的螺旋函数，从*0*到*2*π*23.5*：

```py
spiral(r,0,2*pi*23.5)
```

输出如下：

```py
1107.502879450013
```

1,107 英寸只是超过 92 英尺的绝缘。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2VE9YKZ`](https://packt.live/2VE9YKZ)。

您还可以在[`packt.live/31D43tG`](https://packt.live/31D43tG)上在线运行此示例。

## 练习 11.05：找到阿基米德螺旋的长度

对于这个练习，您已经得到了阿基米德螺旋的方程。找到从*θ=0*到*θ=2π*的螺旋长度：

![图 11.17：阿基米德螺旋的方程](img/B15968_11_17.jpg)

图 11.17：阿基米德螺旋的方程

注意

这适用于对数螺旋和阿基米德螺旋。

执行以下步骤找到长度：

1.  我们只需用指数函数重新定义`r`：

```py
from math import e
def r(theta):
    return 2*e**(0.315*theta)
```

1.  然后，我们从*0*到*2π*运行螺旋函数：

```py
spiral(r,0,2*pi)
```

输出如下：

```py
41.518256747758976
```

这个螺旋的长度是`41.518256747758976`。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2VEtjfo`](https://packt.live/2VEtjfo)。

您还可以在[`packt.live/2VHasQN`](https://packt.live/2VHasQN)上在线运行此示例。

# 表面积

让我们学习如何将这个从二维转换为三维，并计算 3D 表面的面积。在*第十章*，*使用 Python 进行基础微积分*中，我们学习了如何计算旋转表面的面积，但这是一个第三维度*z*是*x*和*y*的值的函数的表面。

## 公式

解决这个问题的传统代数方法是通过对表面进行双重积分：

![图 11.18：计算表面积的公式](img/B15968_11_18.jpg)

图 11.18：计算表面积的公式

这里，*z = f(x,y)*或*(x,y,f(x,y))*。那些花括号 d 是增量，意味着我们将处理偏导数。偏导数是导数，但只针对一个变量，即使函数依赖于多个变量。这是一个返回函数`f`在特定点(`v,w`)处相对于变量`u`的偏导数的函数。根据我们感兴趣的变量是*x*还是*y*，函数将朝着那个方向迈出微小的一步并计算导数，就像我们已经做过的那样：

```py
def partial_d(f,u,v,w,num=10000):
    """returns the partial derivative of f
    with respect to u at (v,w)"""
    delta_u = 1/num
    try:
        if u == 'x':
            return (f(v+delta_u,w) - f(v,w))/delta_u
        else:
            return (f(v,w+delta_u) - f(v,w))/delta_u
    except ValueError:
        pass
```

在代码中有一个`try...except`块，以防抛出`ValueError`。如果斜率太大，就像垂直线一样，就会发生这种情况。如果发生这种情况，它将忽略它并继续进行。

现在，我们需要一个 3D 向量和一个`cross`函数来计算面积公式中的叉积。叉积给出垂直于给定向量的向量的长度，但也给出由给定向量形成的平行四边形的面积。

![图 11.19：两个向量的叉积](img/B15968_11_19.jpg)

图 11.19：两个向量的叉积

如果您知道向量之间的角度，可以使用它来找到叉积：

![图 11.20：计算两个向量的叉积的公式](img/B15968_11_20.jpg)

图 11.20：计算两个向量的叉积的公式

如果不这样做，就像我们的情况一样，可以使用 3D 向量来表示向量在每个方向上的位移，*x*，*y*和*z*。例如，假设我们有两个向量，*u = 2i + 3j + 4k*和*v = 5i + 6j + 7k*。它们由它们在三个维度中的位移定义。*i*部分是*x*方向的位移，*j*部分是*y*方向的位移，*k*部分是*z*方向的位移。好消息是，会有一些零来简化事情。要交叉两个向量，我们可以将它们放入矩阵中，并对它们进行操作，如下矩阵的行列式：

![图 11.21：使用矩阵计算两个向量的叉积](img/B15968_11_21.jpg)

图 11.21：使用矩阵计算两个向量的叉积

我们将编写一个函数来执行两个 3D 向量的操作。我们需要放入的只是*i*，*j*和*k*的系数。因此，如果*u = ai + bj + ck*和*v = di + ej + fk*，我们将得到以下结果：

![图 11.22：对 3D 向量执行数学运算](img/B15968_11_22.jpg)

图 11.22：对 3D 向量执行数学运算

让我们使用列表来表示向量，所以*u = [a,b,c]*和*u[0] = a*，*u[1] = b*和*u[2] = c*为系数：

```py
def cross(u,v):
    """Returns the cross product of 2 3D vectors
    [[i,j,k],\
    [1,0,dz/dx],\
    [0,1,dz,dy]]
    cross([1,-1,2],[2,3,-5])
    >>> [-1, -9, 5]
    """
    return [u[1]*v[2]-v[1]*u[2],\
            -u[0]*v[2]+v[0]*u[2],\
            u[0]*v[1]-v[0]*u[1]]
```

我们编写了一个长的文档字符串，以清楚地说明函数的用途，如何放入值以及我们将得到什么输出。让我们检查一下，以确保我们得到正确的输出：

```py
print(cross([2,3,4],[5,6,7]))
```

输出如下：

```py
[-3, 6, -3]
```

可以了。现在，我们需要编写一个函数来找到 3D 向量的大小，因为这将给我们平行四边形的面积。这只是将勾股定理扩展到三维。因此，如果*u = ai + bj + ck*，则向量*u*的大小是![a](img/B15968_11_22a.png)：

```py
def mag(vec):
    """Returns the magnitude of a 3D vector"""
    return sqrt(vec[0]**2+vec[1]**2+vec[2]**2)
```

这是半圆的样子，其表面由平行四边形近似。更多的平行四边形应该意味着更准确的近似：

![图 11.23：使用更多的平行四边形](img/B15968_11_23.jpg)

图 11.23：使用更多的平行四边形

我们的面积函数将循环遍历网格中的所有*x*和*y*点，计算每个点的偏导数，并使用叉积来找到该点处平行四边形的面积：

```py
from math import sqrt
def sphere(x,y):
    """Sphere of radius 1"""
    return sqrt(1-x**2-y**2) 
def area(f,ax,bx,ay,by,num=1000):
    """Returns area of parallelogram formed by
    vectors with given partial derives"""
    running_sum = 0
    dx = (bx-ax)/num
    dy = (by-ay)/num
    for i in range(num):
        for j in range(num):
            x = ax+i*dx
            y = ay+j*dy
            dz_dx=partial_d(f,'x',x,y)
            dz_dy=partial_d(f,'y',x,y)
            try:
                running_sum += mag(cross([1,0,dz_dx],[0,1,dz_dy]))*dx*dy
            except:
                pass
    return running_sum
```

首先，我们将面积的运行总和设置为 0。然后，我们计算*dx*和*dy*，*x*和*y*的微小变化，因为我们将表面分成相等的切片。`try...except`块只是忽略(`pass`)当切线的斜率是垂直的时候，会出现无限的偏导数的错误，就像我们在*图 11.3*中看到的那样。如果没有错误，它将添加在该点由偏导数形成的平行四边形的面积。现在，我们使用 1,000 个点在每个方向上运行半球的面积函数，并得到一个相当准确的近似值。我们知道半径为 1 的球体的表面积的一半是 2π，或 6.28：

```py
print("Area of hemisphere:",area(sphere,-1,1,-1,1))
```

输出如下：

```py
Area of hemisphere: 6.210356913122
```

现在，让我们快速进行一个基于这个概念的练习。

## 练习 11.06：寻找 3D 表面的面积-第 1 部分

现在，让我们找到一个复杂表面的面积，这将很难使用代数方法找到。考虑以下方程的表面：

![图 11.24：表面的方程](img/B15968_11_24.jpg)

图 11.24：表面的方程

表面显示在以下图像中：

![图 11.25：复杂的 3D 表面](img/B15968_11_25.jpg)

图 11.25：复杂的 3D 表面

执行以下步骤以找到面积：

1.  让我们将函数放入我们的面积程序中，看看我们得到什么：

```py
from math import sin, cos, sqrt
def surface(x,y):
    return 10*sin(sqrt(x**2+y**2))
print("Area of wave surface:",area(surface,-5,5,-5,5))
```

1.  运行程序以查看输出：

```py
Area of wave surface: 608\. 2832236305994
```

从前面的代码中，我们可以清楚地看到，使用 Python 几行代码就可以轻松找到甚至复杂表面的面积有多容易。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3gwd6kr`](https://packt.live/3gwd6kr)。

您也可以在[`packt.live/2ZpgwOQ`](https://packt.live/2ZpgwOQ)上在线运行此示例。

## 练习 11.07：找到 3D 曲面的面积-第 2 部分

找到曲面的面积![a](img/B15968_11_25a.png)。

这就是曲面的样子：

![图 11.26：另一个 3D 曲面](img/B15968_11_26.jpg)

图 11.26：另一个 3D 曲面

执行以下步骤找到面积：

1.  定义我们的曲面函数以返回表达式：

```py
def surface(x,y):
    return 3*cos(x)+2*cos(x)*cos(y) 
```

1.  运行`surface`函数以获得值：

```py
print("Area of surface:",area(surface,0,6.28,0,6.28))
```

输出如下：

```py
Area of surface: 99.80676808568984
```

这个 3D 曲面的面积是`99.80676808568984`。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2VCaObq`](https://packt.live/2VCaObq)。

您也可以在[`packt.live/2NPXvQo`](https://packt.live/2NPXvQo)上在线运行此示例。

## 练习 11.08：找到曲面的面积-第 3 部分

找到曲面的面积![b](img/B15968_11_26a.png)。

这就是曲面的样子：

![图 11.27：曲面](img/B15968_11_27.jpg)

图 11.27：曲面![a](img/B15968_11_27a.png)

执行以下步骤找到面积：

1.  定义我们的曲面函数以返回新表达式：

```py
def surface(x,y):
    return sqrt(1+sin(x)*cos(y))
```

1.  运行`surface`函数：

```py
print("Area of surface:",area(surface,0,6.28,0,6.28))
```

输出如下：

```py
Area of surface: 42.80527549685105
```

这个曲面的面积是`42.80527549685105`。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3gwdLlV`](https://packt.live/3gwdLlV)。

您也可以在[`packt.live/3dUNWdt`](https://packt.live/3dUNWdt)上在线运行此示例。

# 无限级数

数学家经常遇到对他们来说太复杂以至于无法解决或处理的函数，近似一直是数学中的重要组成部分。对于试图代数地进行导数和积分的数学家来说，许多表达式没有漂亮的解、导数、积分等。一般来说，科学家在现实生活中遇到的微分方程没有代数解，因此他们必须使用其他方法。稍后会详细介绍微分方程，但有一类重要的近似使用*简单*函数来近似*难*函数。

## 多项式函数

解决多项式方程很容易，可以求导和积分，比如*y = x*2，甚至以下方程：

![图 11.28：多项式方程](img/B15968_11_28.jpg)

图 11.28：多项式方程

所有项都是一个接一个地添加（或相减），没有三角、对数或指数函数参与，使事情变得困难。以下是用*简单*多项式近似*难*函数的公式：

![图 11.29：泰勒级数](img/B15968_11_29.jpg)

图 11.29：泰勒级数

这个公式被称为泰勒级数：任何函数（可导）都可以使用一定精度在特定点用一定页数的多项式来近似。

## 级数

数学家有一种表示将一堆遵循某种模式的数字相加的符号：

![图 11.30：计算级数的公式](img/B15968_11_30.jpg)

图 11.30：计算级数的公式

看起来像一个*E*的大符号实际上是希腊字母 sigma，或者*S*，表示数字的总和。sigma 下面的方程是变量从哪里开始（在这种情况下是 1），sigma 上面是*i*的最后一个整数值（在这种情况下是 10）。在 sigma 右边是对变量的操作的表达式。在这种情况下，我们只是将*i*，变量，从 1 加到 10。这几乎就是您在 Python 中编写列表推导式的方式。如下：

```py
s = sum([i for i in range(1,11)])
```

列表推导式中的第一个项是在 sigma 级数表达式中看到的内容-在这种情况下是*i*。例如，直到*n*的整数平方和的级数如下：

![图 11.31：1 到 n 的整数平方和的级数](img/B15968_11_31.jpg)

图 11.31：1 到 n 的整数平方和的级数

在 Python 中，我们会这样写：

```py
s = sum([i**2 for i in range(1,n+1)])
```

一个古老但有用的级数是 arctangent 级数。它计算具有给定正切的角度（以弧度表示）；例如：

![图 11.32：arctangent 级数的方程](img/B15968_11_32.jpg)

图 11.32：arctangent 级数的方程

根据前述方程，arctan 的方程如下：

![图 11.33：arctan 的方程](img/B15968_11_33.jpg)

图 11.33：arctan 的方程

该系列按照以下模式计算：

![图 11.34：arctan 级数的方程](img/B15968_11_34.jpg)

图 11.34：arctan 级数的方程

这是 sigma 表达式：

![图 11.35：一个 sigma 表达式](img/B15968_11_35.jpg)

图 11.35：一个 sigma 表达式

通过插入*x*的正切，我们可以计算出角度的近似值：

![图 11.36：将 x 的值代入方程](img/B15968_11_36.jpg)

图 11.36：将 x 的值代入方程

对于几个世纪前的数学家来说，这是相当多的计算，但这是 Python 的等效代码。请注意，列表推导式的前半部分与前述 sigma 表达式非常接近：

```py
def arctan(x,n):
    """Returns the arctangent of x using a series of n terms."""
    return sum([((-1)**(i-1)*(x**(2*i-1)))/(2*i-1) \
                              for i in range(1,n+1)])
print(arctan(1/1.732,10))
```

因此，经过 10 个项，我们得到了以下结果：

```py
0.523611120446175
```

这非常接近![a](img/B15968_11_36a.png)。

## 收敛

数学家们希望简化 arctan 级数，以便使用以下事实轻松计算*π*：

![图 11.37：正切的三角函数](img/B15968_11_37.jpg)

图 11.37：正切的三角函数

根据前述方程，arctan 的方程如下：

![图 11.38：计算 arctan 的公式](img/B15968_11_38.jpg)

图 11.38：计算 arctan 的公式

他们认为将*x*替换为 arctan 级数中的*1*会使计算*π*变得轻而易举。以下是前几个项：

![图 11.39：将 x = 1 代入 arctan 级数](img/B15968_11_39.jpg)

图 11.39：将 x = 1 代入 arctan 级数

这个表达式给出了*π*的近似值：

![图 11.40：寻找π的近似值的方程](img/B15968_11_40.jpg)

图 11.40：寻找π的近似值的方程

我们只需编写 sigma 右侧的代码，添加*n*的范围代码，并将它们相加：

```py
for n in range(1,10):
    print(4*sum([((-1)**(i-1))/(2*i-1) for i in range(1,n+1)]))
```

我们可以在输出中显示逼近*π*的进展：

```py
4.0
2.666666666666667
3.466666666666667
2.8952380952380956
3.3396825396825403
2.9760461760461765
3.2837384837384844
3.017071817071818
3.2523659347188767
```

这与*π*不太接近。跳过更高数量的项呢？让我们改变循环的代码：

```py
for n in [100,1000,1000000]:
```

这是输出：

```py
3.1315929035585537
3.140592653839794
3.1415916535897743
```

经过 100 万项计算，我们只得到了五位正确的小数。这个级数*收敛*到（即非常接近或*趋向于*）π/4，但速度太慢，无法实际使用。因此，几个世纪以来，数学家一直在寻找更好的级数来近似π。

## 练习 11.09：计算π的 10 个正确数字

在 1706 年，英国数学家和天文学家约翰·马钦使用他改进的级数计算了*π*的 100 位小数。以下是该级数：

![图 11.41：一个 arctan 函数](img/B15968_11_41.jpg)

图 11.41：一个 arctan 函数

使用前述 arctan 函数来计算*π*的 10 个正确数字。按照以下步骤进行：

1.  只需调用我们的 arctan 函数。10 个项应该足够了：

```py
print(4*(4*arctan(1/5,10)-arctan(1/239,10)))
```

1.  运行上述代码以查看输出：

```py
3.1415926535897922
```

使用 10 个项可以得到一个相当不错的近似值。它甚至给出了超过 10 个正确的数字。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3dPjVvD`](https://packt.live/3dPjVvD)。

您也可以在[`packt.live/3dVlTKR`](https://packt.live/3dVlTKR)上在线运行此示例。

## 练习 11.10：使用欧拉的表达式计算π的值

伟大的德国数学家欧拉提出了以下表达式：

![图 11.42：欧拉的表达式](img/B15968_11_42.jpg)

图 11.42：欧拉的表达式

使用这个表达式来近似*π*。它是否比调整后的 arctan 公式更快地收敛？

执行以下步骤：

1.  以下是使用欧拉级数近似*π*的代码：

```py
from math import sqrt
for n in [100,1000,1000000]:
    print(sqrt(6*sum([1/(i**2) for i in range(1,n+1)])))
```

1.  它收敛得更快吗？运行前面的代码以查看输出：

```py
3.1320765318091053
3.1406380562059946
3.1415916986605086
```

看起来它似乎并没有更快地收敛。100 万项后，您仍然只有五位正确的小数。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2NRnnLD`](https://packt.live/2NRnnLD)。

您还可以在[`packt.live/38lHXgm`](https://packt.live/38lHXgm)上在线运行此示例。

## 20 世纪的公式

这是卓越的印度数学家拉马努金用来近似π的公式：

![图 11.43：拉马努金近似π的公式](img/B15968_11_43.jpg)

图 11.43：拉马努金近似π的公式

以下是如何在 Python 中编写该代码：

```py
from math import sqrt, factorial
one_over_pi = 2*sqrt(2)/9801*sum([(factorial(4*k)*(1103+26390*k))/ \
              (((factorial(k))**4)*(396**(4*k))) for k in range(10)])
print(1/one_over_pi)
```

10 个项后的输出如下：

```py
3.141592653589793
```

这非常准确！！

## 收敛区间

系列收敛（趋向于一个值）的值范围称为收敛区间。使用 Python，找到这个区间相当简单：您通过系列运行一些数字，如果它们变得无限大，它们就不在该区间内。如果它们产生一个数字，它们就在该区间内。例如，让我们看一个非常常见的教科书问题，并使用 Python 解决它。

## 练习 11.11：确定收敛区间-第 1 部分

确定以下幂级数的收敛区间：

![图 11.44：幂级数](img/B15968_11_44.jpg)

图 11.44：幂级数

执行以下步骤：

1.  将总和输入 Python：

```py
  def mystery_sum(x):
    return sum([(((-1)**n)*n)/(4*n)*(x+3)**n for n in \
                      range(1,1000000)])
```

由于我们不能使用数字“无穷大”，我们找到了从 n = 1 到 100 万的所有项的和。

1.  运行所有从-10 到 10 的整数，看看是否收敛到一个数字：

```py
for x in range(-10,11):
    print(x,mystery_sum(x))
```

1.  当您运行此代码时，将会出现`OverflowError`：

```py
OverflowError: int too large to convert to float
```

这意味着一些数字变得很大，这正是我们预期的。我们需要添加一个条件，以便如果出现错误，它将简单地返回`Infinity`。这是通过`try...except`块完成的。

1.  让我们告诉 Python 尝试一行代码。如果它抛出特定错误（在本例中是`OverflowError`），不要停止程序，而是执行以下操作：

```py
def mystery_sum(x):
    try:
        return sum([(((-1)**n)*n)/(4*n)*(x+3)**n \
                                  for n in range(1,1000000)])
    except OverflowError:
        return "Infinity"
```

1.  现在，输出给我们一些无穷大和一些实际值：

```py
-10 Infinity
-9 Infinity
-8 Infinity
-7 Infinity
-6 Infinity
-5 Infinity
-4 249999.75
-3 0.0
-2 -0.25
-1 Infinity
0 Infinity
1 Infinity
...
```

看起来我们的收敛区间是-5 < x < -1。这意味着如果*x*在该区间内，我们可以使用该级数获得有用的值。否则，我们无法使用它。

注意

要访问此特定部分的源代码，请参阅[`packt.live/38k30A2`](https://packt.live/38k30A2)。

您还可以在[`packt.live/31AtmMU`](https://packt.live/31AtmMU)上在线运行此示例。

## 练习 11.12：确定收敛区间-第 2 部分

确定以下幂级数的收敛区间：

![图 11.45：幂级数](img/B15968_11_45.jpg)

图 11.45：幂级数

执行以下步骤：

1.  在 Python 中定义总和：

```py
def mystery_sum(x):
    try:
        return sum([n*x**n/(5**(2*n)) for n in range(1,10000)])
    except OverflowError:
        return "Infinity"

for x in range(-30,30):
    print(x,mystery_sum(x))
```

1.  以下是一些输出：

```py
-30 Infinity 
-29 Infinity 
-28 Infinity 
-27 Infinity 
-26 -1.0561866634327267e+174 
-25 -5000.0 
-24 -0.24989587671803576 
-23 -0.24956597222222246 
-22 -0.24898143956541371 
-21 -0.24810964083175827 
-20 -0.24691358024691298
...
18 9.18367346938776 
19 13.19444444444444 
20 19.999999999999993 
21 32.812499999999964 
22 61.11111111111108 
23 143.74999999999983 
24 599.9999999999994 
25 49995000.0 
26 5.3728208568640556e+175 
27 Infinity 
28 Infinity
29 Infinity
```

在*x*在-25 和 25 之间的所有输出都保持很小（在 0 和 600 之间），无论我们使用多少项，因此我们将称之为收敛区间*-25 < x < 25*。

注意

要访问此特定部分的源代码，请参阅[`packt.live/38pwuwC`](https://packt.live/38pwuwC)。

您还可以在[`packt.live/2YS46jl`](https://packt.live/2YS46jl)上在线运行此示例。

## 练习 11.13：找到常数

在这个练习中，我们将在 Python 中表示一个无限级数并找到总和。我们将使用一个著名的常数，它被定义为该级数的和：

![图 11.46：级数的总和](img/B15968_11_46.jpg)

图 11.46：级数的总和

这个著名常数的值是多少？让我们按照以下步骤来确定这个值：

1.  导入阶乘模块并将前述方程转换为 Python，如下所示：

```py
from math import factorial
print(sum([1/factorial(n) for n in range(10000)]))
```

1.  运行前面的代码以查看输出：

```py
2.7182818284590455
```

著名的常数是*e*，自然对数的底数。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2AoyubH`](https://packt.live/2AoyubH)。

您还可以在[`packt.live/2BZ4aVw`](https://packt.live/2BZ4aVw)上在线运行此示例。

## 活动 11.01：寻找表面的最小值

机器学习中的一个重要任务是最小化函数。当您训练神经网络时，您正在改变矩阵或张量中的值，以查看哪些值提供了更好地逼近您的测试数据。在网络的每个值处，您都可以看到它对您的错误有多大贡献。这听起来像是表面上不同点的偏导数，不是吗？

这个例子是梯度下降的过程。让我们考虑一下，我们想要找到我们函数的最小值的位置。我们表面上的每个点都有一个偏导数，我们可以使用这些偏导数向更低的值移动一点。我们将从一个随机的地方开始，计算该点的偏导数，然后沿着降低*z*值的方向移动，也就是上下值。因此，如果*z*关于*x*的偏导数（我们称为*dz_dx*）是负的，这意味着*z*随着*x*的增加而减少，我们将希望向正*x*方向移动。如果*dz_dx*是正的，这意味着*z*随着*x*的增加而增加，所以我们将希望朝相反的方向移动，因此我们将向负*x*方向移动。我们将对*y*方向做同样的事情。这将如下所示：

![图 11.47：下降到最小值的路径](img/B15968_11_47.jpg)

图 11.47：下降到最小值的路径

这个活动的第一部分是创建一个找到表面最小点的函数。可以通过以下步骤编写此函数：

1.  编写一个函数，该函数将在表面上创建一个随机的(x, y)位置。您可以调用`random`模块的`uniform`函数来生成这些值。

1.  计算*z*关于*x*和*y*的偏导数。

1.  通过偏导数的负值乘以一个微小的*step*量来改变*x*和*y*，以防偏导数很大。

1.  计算这个新位置的偏导数，并保持循环，直到偏导数都非常小（小于 0.0001），或者位置偏离表面。

1.  在一堆随机位置上运行函数，将最小*z*值保存到*mins*列表中。

1.  最后，打印*mins*列表的最小值。

编写函数后，可以在已知值的函数上测试它，以验证它是否按预期工作。然后可以在不知道最小点的函数上运行它，以确定这个未知位置。具体步骤如下：

1.  在表面上测试您的函数![6](img/B15968_11_InlineEquation6.png)。您的函数应该发现最小值为 0，在点(0, 0)处。

1.  一旦您对您的函数有信心，就可以使用它来确定![7](img/B15968_11_InlineEquation8.png)的最小值，其中*-1 < x < 5*和*-1 < y < 5*。

您会发现，根据您的起始点，您的函数将收敛到不同的最小点 - 局部最小值和全局最小值。

注意

此活动的解决方案可在第 696 页找到。

# 总结

在上一章中，我们学习了导数和积分的力量，因此在本章中，我们基于这些工具来解决一些非常困难的问题，比如螺旋线的长度和三维表面的面积。我们甚至通过引入偏导数将导数和积分扩展到三维空间。在微积分课上，我们需要使用大量的代数来使用这些工具，但是通过使用 Python，我们对情况进行了建模并测试了我们的函数。我们创建了包含我们变化数值的变量，并在必要时循环计算数百万次。对于以前世纪的数学家来说，这似乎就像是某种魔法灯。

在下一章中，我们将处理更多的变化率和数量，并通过使用 Python 避免大量的代数。我们将找出一个不断变化的混合物中有多少盐，捕食者何时何地会捕捉到猎物，以及我们需要投资多长时间才能赚到 100 万美元。

FAB62

RUC47
