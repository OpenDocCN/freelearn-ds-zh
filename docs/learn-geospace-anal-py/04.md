# 四、地理空间 Python 工具箱

本书的前三章涵盖了地理空间分析的历史、分析师使用的地理空间数据类型以及地理空间行业中的主要软件和库。我们到处使用一些简单的 Python 示例来说明某些要点，但我们主要关注地理空间分析领域，与任何特定技术无关。从这里开始，我们将使用 Python 来征服地理空间分析，我们将在本书的剩余部分继续使用这种方法。本章解释了您在工具箱中需要的软件，以便在地理空间领域做任何您想做的事情。

我们将发现用于访问不同类型数据的 Python 库，这些数据位于[第 2 章](02.html)、*学习地理空间数据*的向量数据和栅格数据部分。其中一些库是纯 Python，以及我们在[第 3 章](03.html)、*地理空间技术领域*中看到的不同软件包的一些绑定。

在本章中，我们将涵盖以下主题:

*   安装第三方 Python 模块
*   Python 虚拟环境
*   伯爵夫人
*   码头工人
*   用于获取数据的 Python 网络库
*   基于 Python 标签的解析器
*   Python JSON 库
*   OGR
*   PyShp
*   DBFPY
*   形状美观的
*   断续器
*   菲奥纳
*   NumPy
*   地球 andas
*   Python 图像库(PIL)
*   PNGCanvas
*   ReportLab(报告实验室)
*   地球资源(geopdf)
*   Python NetCDF 库
*   Python HDF 库
*   OSMnx
*   空间索引库
*   Jupyter
*   伯爵夫人

我们将尽可能检查纯 Python 解决方案。Python 是一种非常有能力的编程语言，但是有些操作，尤其是遥感操作，计算量太大，因此在使用纯 Python 或其他解释语言时不切实际。幸运的是，地理空间分析的每个方面都可以通过 Python 以某种方式解决，即使它绑定到一个高效的 C/c++/其他编译语言库。

我们将避免使用涵盖地理空间分析以外的其他领域的广泛科学库，以使解决方案尽可能简单。使用 Python 进行地理空间分析的原因有很多，但最有力的论据之一是它的可移植性。

此外，Python 已经作为 Jython 发行版移植到了 Java，并移植到了。NET **公共语言运行时** ( **CLR** )作为 IronPython。Python 也有类似 Stackless Python 的版本，用于大规模并发程序。Python 的一些版本被设计为在集群计算机上运行，用于分布式处理。Python 也可以在许多不允许您安装自定义可执行文件的托管应用服务器上使用，例如谷歌应用引擎平台，它有一个 Python 应用编程接口。

# 技术要求

*   Python 3.6 或更高版本
*   内存:最小 6 GB (Windows)，8 GB (macOS)建议 8 GB
*   存储:最低 7200 转/分的 SATA，可用空间为 20gb；推荐的具有 40 GB 可用空间的固态硬盘
*   处理器:最低英特尔酷睿 i3 2.5 GHz 推荐的英特尔酷睿 i5

# 安装第三方 Python 模块

用纯 Python 编写的模块(使用标准库)将主要运行在 Python([https://www.python.org/](https://www.python.org/))网站提到的 20 个平台中的任何一个平台上。每次添加依赖于绑定到其他语言外部库的第三方模块时，都会降低 Python 固有的可移植性。您还增加了一层复杂性，通过向组合中添加另一种语言来从根本上改变代码。纯 Python 让事情变得简单。此外，Python 到外部库的绑定往往是自动或半自动生成的。

这些自动生成的绑定非常通用和深奥，它们只是使用 C/C++ API 中的方法名将 Python 连接到该 API，而不是遵循 Python 的最佳实践。当然，这种方法也有明显的例外，这是由项目需求驱动的，项目需求可能包括速度、独特的库特性或频繁更新的库，其中自动生成的接口更可取。

我们将区分作为 Python 标准库一部分的模块和必须安装的模块。在 Python 中，`words`模块和库可以互换使用。要安装库，您可以从 **Python 包索引** ( **PyPI** )中获取它们，或者在有大量地理空间模块的情况下，您可以下载专门的安装程序。

PyPI 充当库的官方软件存储库，并提供一些易于使用的安装程序来简化软件包的安装。你可以使用`easy_install`程序，它在 Windows 上特别好用，或者是在 Linux 和 Unix 系统上比较常见的`pip`程序。安装后，您可以通过运行以下代码来安装第三方软件包:

```py
easy_install <package name>
```

安装`pip`时，运行以下代码:

```py
pip install <package name>
```

这本书将提供 PyPI 上没有的开源软件包的链接和安装说明。您可以通过下载 Python 源代码并将其放在您当前的工作目录中来手动安装第三方 Python 模块，也可以将其放在您的 Python `site-packages`目录中。当您尝试导入模块时，这两个目录在 Python 的搜索路径中是可用的。如果您将一个模块放在当前的工作目录中，那么只有当您从该目录启动 Python 时，它才可用。

如果你把它放在你的`site-packages`目录中，它将在你每次启动 Python 时可用。`site-packages`目录是专门为第三方模块准备的。要为您的安装找到`site-packages`目录，您需要询问 Python 的`sys`模块。`sys`模块有一个`path`属性，该属性包含 Python 搜索路径中所有目录的列表。`site-packages`目录应该是最后一个。您可以通过指定索引`-1`来定位它，如以下代码所示:

```py
>>> import sys
>>> sys.path[-1]
'C:\\Python34\\lib\\site-packages'
```

如果该调用没有返回`site-packages`路径，只需查看整个列表来定位它，如以下代码所示:

```py
>> sys.path
['', 'C:\\WINDOWS\\system32\\python34.zip', 'C:\\Python34\\DLLs',
'C:\\Python34\\lib', 'C:\\Python34\\lib\\plat-win
', 'C:\\Python34\\lib\\lib-tk', 'C:\\Python34',
'C:\\Python34\\lib\\site-packages']
```

These installation methods will be used in the rest of this book. You can find the latest Python version, the source code for your platform installation, and compilation instructions at [http://python.org/download/](http://python.org/download/).

Python `virtualenv`模块允许您为特定项目轻松创建 Python 的独立副本，而不会影响您的主要 Python 安装或其他项目。使用此模块，您可以使用同一库的不同版本进行不同的项目。一旦你有了一个可以工作的代码库，你就可以将它与你使用的模块甚至 Python 本身的变化隔离开来。`virtualenv`模块使用简单，可以用于本书的任何示例；但是，不包括其使用的明确说明。

To get started with `virtualenv`, follow this simple guide: [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).

# Python virtualenv

Python 地理空间分析要求我们使用各种具有许多依赖性的模块。这些模块通常使用特定版本的 C 或 C++库相互构建。当您向系统中添加 Python 模块时，经常会遇到版本冲突。有时，当您升级一个特定的模块时，由于应用编程接口的变化，它可能会破坏您现有的 Python 程序，或者您可能同时运行 Python 2 和 Python 3 来利用为每个版本编写的库。您需要的是一种安全安装新模块而不损坏工作系统或代码的方法。这个问题的解决方案是通过`virtualenv`模块使用 Python 虚拟环境。

Python `virtualenv`模块为每个项目创建独立的 Python 环境，这样您就可以避免冲突模块污染您的主要 Python 安装。您可以通过激活或停用特定环境来打开或关闭它。`virtualenv`模块是高效的，因为它不会在您每次创建环境时复制您的整个系统 Python 安装。让我们开始吧:

1.  安装`virtualenv`就像运行以下代码一样简单:

```py
pip install virtualenv
```

2.  然后，为虚拟 Python 环境创建一个目录。想叫什么就叫什么:

```py
mkdir geospatial_projects
```

3.  现在，您可以使用以下命令创建第一个虚拟环境:

```py
virtualenv geospatial_projects/project1
```

4.  然后，输入以下命令后，您可以激活环境:

```py
source geospatial_projects/project1/bin/activate
```

5.  现在，当您在该目录中运行任何 Python 命令时，它将使用隔离的虚拟环境。完成后，您可以使用以下简单命令停用该环境:

```py
deactivate
```

这是您安装、激活使用和停用`virtualenv`模块的方法。然而，还有一个环境你应该知道。我们接下来会研究这个。

# 伯爵夫人

这里还值得一提的是 Conda，它是一个开源的、跨平台的包管理系统，也可以创建和管理类似`virtualenv`的环境。Conda 使安装复杂的包变得容易，包括地理空间包。除了 Python 之外，它还可以与其他语言一起工作，包括 R、Node.js 和 Java。

这里有 conda:[https://docs.conda.io/en/latest/](https://docs.conda.io/en/latest/)。

现在，让我们看看如何安装 GDAL，以便我们可以开始处理地理空间数据。

# 安装 GDAL

包括 OGR 在内的**地理空间数据抽象库** ( **GDAL** )对于本书中的许多示例至关重要，也是更复杂的 Python 设置之一。由于这些原因，我们将在这里单独讨论。PyPI 上有最新的 GDAL 绑定；但是，由于 GDAL 库需要额外的资源，安装需要更多的步骤。

有三种方法可以安装 GDAL，以便与 Python 一起使用。您可以使用其中任何一种:

*   从源代码编译它。
*   将其作为更大软件包的一部分安装。
*   安装二进制发行版，然后安装 Python 绑定。

如果你有编译 C 库以及所需编译软件的经验，那么第一个选项给你最大的控制权。但是，如果您只想尽快开始，就不建议这样做，因为即使是有经验的软件开发人员也会发现编译 GDAL 和相关的 Python 绑定具有挑战性。在领先平台上编译 GDAL 的说明可以在[http://trac.osgeo.org/gdal/wiki/BuildHints](http://trac.osgeo.org/gdal/wiki/BuildHints)找到。PyPI GDAL 页面上也有基本的构建说明；看看[https://pypi.python.org/pypi/GDAL](https://pypi.python.org/pypi/GDAL)。

第二种选择是迄今为止最快最简单的。**开源地理空间基金会** ( **OSGeo** )发布了一个名为 OSGeo4W 的安装程序，只需点击一个按钮，就可以在 Windows 上安装所有顶级开源地理空间包。OSGeo4W 可以在[http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/)找到。

虽然这些包最容易使用，但它们都有自己的 Python 版本。如果您已经安装了 Python，那么让另一个 Python 发行版只使用某些库可能会有问题。在这种情况下，第三种选择可能适合你。

第三种选择是安装一个针对您的 Python 版本的预编译二进制文件。这种方法是易于安装和定制之间的最佳折衷。问题是，您必须确保二进制发行版和相应的 Python 绑定彼此兼容，您的 Python 版本兼容，并且在许多情况下您的操作系统配置兼容。

# Windows 操作系统

在 Windows 上安装 Python 的 GDAL 一年比一年容易。要在 Windows 上安装 GDAL，您必须检查您运行的是 32 位还是 64 位版本的 Python:

1.  为此，只需在命令提示符下启动 Python 解释器，如以下代码所示:

```py
Python 3.4.2 (v3.4.2:ab2c023a9432, Oct 6 2014, 22:15:05) [MSC v.1600
32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more
information.
```

2.  基于这个实例，我们可以看到 Python 是针对`win32`的 3.4.2 版本，也就是说是 32 位版本。一旦你有了这些信息，请访问以下网址:[http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal](http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal)。
3.  这个网页包含几乎每个开源科学图书馆的 Python 窗口二进制文件和绑定。在该网页的 GDAL 部分，找到与您的 Python 版本相匹配的版本。发布名称使用 C Python 的缩写`cp`，后跟主要的 Python 版本号，32 位窗口使用`win32`，64 位窗口使用`win_amd64`。

In the previous example, we would download the file named `GDAL-1.11.3-cp34-none-win32.whl`.

4.  该下载包采用较新的 Python `pip`轮格式。要安装它，只需打开命令提示符并键入以下代码:

```py
pip install GDAL-1.11.3-cp34-none-win32.whl
```

5.  安装完软件包后，打开 Python 解释器并运行以下命令，通过检查版本来验证是否安装了 GDAL:

```py
Python 3.4.2 (v3.4.2:ab2c023a9432, Oct 6 2014, 22:15:05) [MSC v.1600 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> from osgeo import gdal
>>> gdal.__version__
1.11.3
```

现在，GDAL 应该会以`1.11.3`的形式返回它的版本。

If you have trouble installing modules using `easy_install` or `pip` and PyPI, try to download and install the wheel package from the same site as the GDAL example.

# Linux 操作系统

Linux 上的 GDAL 安装因发行版而异。下面的[https://gdal.org](https://gdal.org)二进制网页列出了几个发行版的安装说明:[http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries](http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries)。让我们开始吧:

1.  通常，您的包管理器会安装 GDAL 和 Python 绑定。例如，在 Ubuntu 上，要安装 GDAL，您需要运行以下代码:

```py
sudo apt-get install gdal-bin
```

2.  然后，要安装 Python 绑定，您可以运行以下命令:

```py
sudo apt-get install python3-gdal
```

3.  大多数 Linux 发行版已经被设置为编译软件，它们的指令比 Windows 上的指令简单得多。
4.  根据安装情况，您可能需要导入`gdal`和`ogr`作为`osgeo`包的一部分，如下命令所示:

```py
>>> from osgeo import gdal
>>> from osgeo import ogr
```

# mac os x

要在 macOS X 上安装 GDAL，还可以使用家酿软件包管理系统，该系统在[http://brew.sh/](http://brew.sh/)提供。

或者，您可以使用 MacPorts 软件包管理系统，该系统可在[https://www.macports.org/](https://www.macports.org/)获得。

这两个系统都有很好的文档记录，并且包含 Python 3 的 GDAL 包。只有那些需要用 C 语言编写的正确编译的二进制文件的库才真正需要它们，这些文件有很多依赖项，并且包括许多科学和地理空间库。

# 用于获取数据的 Python 网络库

绝大多数地理空间数据共享都是通过互联网完成的，Python 在几乎任何协议的网络库方面都有很好的装备。自动数据下载通常是地理空间过程自动化的重要一步。数据通常从网站的**统一资源定位符** ( **网址**)或**文件传输协议** ( **文件传输协议**)服务器中检索，由于地理空间数据集通常包含多个文件，数据通常以 ZIP 文件的形式分发。

Python 的一个很好的特性是它的类似文件的对象的概念。大多数读取和写入数据的 Python 库使用一组标准方法，允许您从不同类型的资源中访问数据，就像您在磁盘上写一个简单的文件一样。Python 标准库中的网络模块也使用这种约定。这种方法的好处是，它允许您将类似文件的对象传递给其他库和方法，这些库和方法可以识别约定，而无需对以不同方式分布的不同类型的数据进行大量设置。

# Python urllib 模块

Python `urllib`包是为简单访问任何带有网址的文件而设计的。Python 3 中的`urllib`包由几个模块组成，处理管理网络请求和响应的不同部分。这些模块实现了 Python 的一些类似文件的对象约定，从它的`open()`方法开始。当您调用`open()`时，它准备连接到资源，但不访问任何数据。有时，您只想抓取一个文件并将其保存到磁盘，而不是在内存中访问它。该功能可通过`urllib.request.retrieve()`方法获得。

以下示例使用`urllib.request.retrieve()`方法下载名为`hancock.zip`的压缩形状文件，该文件在其他示例中使用。我们将网址和本地文件名定义为变量。该网址作为一个参数以及我们想要使用的文件名传递，以将其保存到我们的本地机器上，在本例中，本地机器只是`hancock.zip`:

```py
>>> import urllib.request
>>> import urllib.parse
>>> import urllib.error
>>> url = "https://github.com/GeospatialPython/
Learn/raw/master/hancock.zip"
>>> fileName = "hancock.zip"
>>> urllib.request.urlretrieve(url, fileName)
('hancock.zip', <httplib.HTTPMessage instance at 0x00CAD378>)
```

来自底层`httplib`模块的消息确认文件已下载到当前目录。网址和文件名也可以作为字符串直接传递给`retrieve()`方法。如果只指定文件名，下载将保存到当前工作目录。您也可以指定一个完全限定的路径名，将其保存到其他地方。您还可以指定一个回调函数作为第三个参数，它将接收文件的下载状态信息，以便您可以创建一个简单的下载状态指示器或执行一些其他操作。

`urllib.request.urlopen()`方法允许您更精确和更可控地访问在线资源。正如我们前面提到的，它实现了除`seek()`方法之外的大多数类似 Python 文件的对象方法，该方法允许您跳转到文件中的任意位置。您可以一次一行地在线读取文件，以列表形式读取所有行，读取指定数量的字节，或者遍历文件的每一行。所有这些功能都在内存中执行，因此您不必将数据存储在磁盘上。此功能对于在线访问经常更新的数据非常有用，您可能希望在不保存到磁盘的情况下处理这些数据。

在下面的例子中，我们通过访问**美国地质调查局** ( **美国地质勘探局**)地震源来查看过去一小时内发生的所有地震，从而展示了这一概念。这些数据以**逗号分隔值** ( **CSV** )文件的形式分发，我们可以像文本文件一样逐行读取。CSV 文件类似于电子表格，可以在文本编辑器或电子表格程序中打开:

1.  首先，您需要打开网址并读取文件中带有列名的标题。

2.  然后，您需要读取第一行，其中包含最近地震的记录，如以下代码行所示:

```py
>>> url = "http://earthquake.usgs.gov/earthquakes/feed/v1.0/
summary/all_hour.csv"
>>> earthquakes = urllib.request.urlopen(url)
>>> earthquakes.readline()
'time,latitude,longitude,depth,mag,magType,nst,gap,dmin,rms,net,
id,updated,place
\n'
>>> earthquakes.readline()
'2013-06-14T14:37:57.000Z,64.8405,-147.6478,13.1,0.6,Ml,
6,180,0.09701805,0.2,ak,
ak10739050,2013-06-14T14:39:09.442Z,"3km E of Fairbanks,
Alaska"\n'
```

3.  我们还可以遍历这个文件，这是一种读取大文件的内存高效方式。
4.  如果在 Python 解释器中运行这个例子，需要按两次*回车*或*回车*键来执行循环。这个动作是必要的，因为它向解释器发出信号，表明您已经完成了循环的构建。在以下示例中，我们将输出缩写为:

```py
>>> for record in earthquakes: print(record)
2013-06-14T14:30:40.000Z,62.0828,-145.2995,22.5,1.6,
Ml,8,108,0.08174669,0.86,ak,
ak10739046,2013-06-14T14:37:02.318Z,"13km ESE of Glennallen,
Alaska"
...
2013-06-14T13:42:46.300Z,38.8162,-122.8148,3.5,0.6,
Md,,126,0.00898315,0.07,nc,nc
72008115,2013-06-14T13:53:11.592Z,"6km NW of The Geysers,
California"
```

# Python 请求模块

`urllib`模块已经存在很长时间了。开发了另一个第三方模块，使常见的 HTTP 请求变得更加容易。`requests`模块具有以下特点:

*   保活和连接池
*   国际域名和网址
*   具有 cookie 持久性的会话
*   浏览器风格的 SSL 验证
*   自动内容解码
*   基本/摘要身份验证
*   精美的钥匙/价值饼干
*   自动减压
*   Unicode 响应正文
*   超文本传输协议代理支持
*   多部分文件上传
*   流式下载
*   连接超时
*   分块请求
*   `.netrc`支持

在下面的例子中，我们将下载与使用`urllib`模块下载的相同的 ZIP 文件，除了这次使用`requests`模块。首先，我们需要安装`requests`模块:

```py
pip install requests
```

然后，我们可以导入它:

```py
import requests
```

然后，我们可以为网址和输出文件名设置变量:

```py
url = "https://github.com/GeospatialPython/Learning/raw/master/hancock.zip"
fileName = "hancock.zip"
```

检索 ZIP 文件就像使用`requests`模块的`get()`方法一样简单:

```py
r = requests.get(url)
```

现在，我们可以从`.zip`文件中获取内容，并将其写入我们的输出文件:

```py
with open(fileName, 'wb') as f:
 f.write(r.content)
```

`requests`模块有很多更高级的特性，和这个例子一样容易使用。现在我们知道了如何通过 HTTP 协议获取信息，让我们来研究一下 FTP 协议，它通常用于从在线档案中访问地理空间数据。

# 文件传送协议

FTP 允许您浏览在线目录，并使用 FTP 客户端软件下载数据。直到 2004 年左右，当地理空间网络服务变得非常普遍时，FTP 才是分发地理空间数据的最常见方式之一。FTP 现在不太常见了，但是在搜索数据时偶尔会遇到。同样，Python 的电池标准库有一个名为`ftplib`的合理的 FTP 模块，它有一个名为`FTP()`的主类。

在以下示例中，我们将执行以下操作:

1.  我们将访问由美国国家海洋和大气管理局托管的文件传输协议服务器，以访问一个文本文件，该文件包含来自“T4”深海海啸评估和报告网络的数据，该网络用于监视世界各地的海啸。这个特殊的浮标位于秘鲁海岸。
2.  我们将定义服务器和目录路径，然后访问服务器。所有 FTP 服务器都需要用户名和密码。大多数公共服务器都有一个名为 anonymous 的用户，其密码为 anonymous，就像这个服务器一样。
3.  使用 Python 的`ftplib`，只需调用`login()`方法，无需任何参数即可作为默认匿名用户登录。否则，您可以添加用户名和密码作为字符串参数。
4.  登录后，我们将转到包含 DART 数据文件的目录。
5.  为了下载文件，我们将打开一个被调用的本地文件，并将其`write()`方法作为回调函数传递给`ftplib.ftp.retrbinary()`方法，该方法同时下载文件并将其写入我们的本地文件。
6.  一旦文件被下载，我们可以关闭它来保存它。
7.  然后，我们将读取文件并查找包含浮标经纬度的行，以确保数据下载成功，如以下代码行所示:

```py
import ftplib

server = "ftp.ngdc.noaa.gov"
dir = "hazards/DART/20070815_peru"
fileName = "21415_from_20070727_08_55_15_tides.txt"
ftp = ftplib.FTP(server)
ftp.login()
ftp.cwd(dir)

with open(fileName, "wb") as out:
    ftp.retrbinary("RETR " + fileName, out.write)

with open(fileName) as dart:
 for line in dart:
     if "LAT, " in line:
     print(line)
     break
```

输出结果是:

```py
 LAT,   LON      50.1663    171.8360
```

在这个例子中，我们以二进制写模式打开了本地文件，我们使用了`retrbinary() ftplib`方法，而不是使用 ASCII 模式的`retrlines()`。二进制模式既适用于 ASCII 文件，也适用于二进制文件，所以它总是一个更安全的选择。事实上，在 Python 中，文件的二进制读写模式只在 Windows 上需要。

如果你只是从一个文件传输协议服务器下载一个简单的文件，许多文件传输协议服务器也有一个网络接口。在这种情况下，您可以使用`urllib`读取文件。FTP 网址使用以下格式访问数据:

```py
ftp://username:password@server/directory/file
```

这种格式对于受密码保护的目录是不安全的，因为您是通过互联网传输登录信息的。但是对于匿名 FTP 服务器来说，没有额外的安全风险。为了演示这一点，下面的示例访问了我们刚才看到的相同文件，但是使用了`urllib`而不是`ftplib`:

```py
>>> dart = urllib.request.urlopen("ftp://" + server + "/" + dir +
"/" + fileName)
>>> for line in dart:
... line = str(line, encoding="utf8")
... if "LAT," in line:
... print(line)
... break
...
LAT, LON 50.1663 171.8360
```

现在我们可以下载文件了，让我们学习如何解压缩它们。

# ZIP 和 TAR 文件

地理空间数据集通常由多个文件组成。因此，它们通常作为 ZIP 或 TAR 文件档案分发。这些格式也可以压缩数据，但是它们捆绑多个文件的能力是它们用于地理空间数据的主要原因。虽然 TAR 格式不包含压缩算法，但它结合了 gzip 压缩，并将其作为程序选项提供。Python 有读写 ZIP 和 TAR 档案的标准模块。这些模块分别称为`zipfile`和`tarfile`。

以下示例提取了包含在我们使用`urllib`下载的`hancock.zip`文件中的`hancock.shp`、`hancock.shx`和`hancock.dbf`文件，以便在前面的示例中使用。此示例假设 ZIP 文件位于当前目录中:

```py
>>> import zipfile
>>> zip = open("hancock.zip", "rb")
>>> zipShape = zipfile.ZipFile(zip)
>>> shpName, shxName, dbfName = zipShape.namelist()
>>> shpFile = open(shpName, "wb")
>>> shxFile = open(shxName, "wb")
>>> dbfFile = open(dbfName, "wb")
>>> shpFile.write(zipShape.read(shpName))
>>> shxFile.write(zipShape.read(shxName))
>>> dbfFile.write(zipShape.read(dbfName))
>>> shpFile.close()
>>> shxFile.close()
>>> dbfFile.close()
```

为了清楚起见，这个例子过于冗长。我们可以通过在`zipfile.namelist()`方法周围使用`for`循环来缩短这个示例，并使其更加健壮，而无需将不同的文件明确定义为变量。这种方法是一种更加灵活和 Pythonic 化的方法，可以用于内容未知的 ZIP 存档，如下面几行代码所示:

```py
>>> import zipfile
>>> zip = open("hancock.zip", "rb")
>>> zipShape = zipfile.ZipFile(zip)
>>> for fileName in zipShape.namelist():
... out = open(fileName, "wb")
... out.write(zipShape.read(fileName))
... out.close()
>>>
```

现在您已经了解了`zipfile`模块的基础知识，让我们将刚刚解压的文件解压缩，并使用它们创建一个 TAR 归档。在这个例子中，当我们打开 TAR 归档文件进行写入时，我们为 gzipped 压缩指定写入模式为`w:gz`。我们还将文件扩展名指定为`tar.gz`，以反映这种模式，如下面几行代码所示:

```py
>>> import tarfile
>>> tar = tarfile.open("hancock.tar.gz", "w:gz")
>>> tar.add("hancock.shp")
>>> tar.add("hancock.shx")
>>> tar.add("hancock.dbf")
>>> tar.close()
```

我们可以使用简单的`tarfile.extractall()`方法提取文件。首先，我们使用`tarfile.open()`方法打开文件，然后提取它，如下面几行代码所示:

```py
>>> tar = tarfile.open("hancock.tar.gz", "r:gz")
>>> tar.extractall()
>>> tar.close()
```

我们将通过结合本章中学习的元素以及[第 2 章](02.html)、*学习地理空间数据*的向量数据部分中的元素，来研究另一个示例。我们将从`hancock.zip`文件中读取边界框坐标，而不会将其保存到磁盘中。我们将使用 Python 的类似文件的对象约定来传递数据。然后，我们将使用 Python 的`struct`模块来读取边界框，就像我们在[第 2 章](02.html)、*学习地理空间数据*中所做的那样。

在这种情况下，我们将解压后的`.shp`文件读入一个变量，并通过指定以冒号(`:`)分隔的数据的开始和结束索引，使用 Python 数组切片来访问数据。我们能够使用列表切片，因为 Python 允许您将字符串视为列表。在本例中，我们还使用 Python 的`StringIO`模块将数据临时存储在内存中的一个类似文件的对象中，该对象实现了各种方法，包括大多数 Python 网络模块都没有的`seek()`方法，如下面几行代码所示:

```py
>>> import urllib.request
>>> import urllib.parse
>>> import urllib.error
>>> import zipfile
>>> import io
>>> import struct
>>> url =
"https://github.com/GeospatialPython/Learn/raw/master/hancock.zip"
>>> cloudshape = urllib.request.urlopen(url)
>>> memoryshape = io.BytesIO(cloudshape.read())
>>> zipshape = zipfile.ZipFile(memoryshape)
>>> cloudshp = zipshape.read("hancock.shp")
# Access Python string as an array
>>> struct.unpack("<dddd", cloudshp[36:68])
(-89.6904544701547, 30.173943486533133, -89.32227546981174,
30.6483914869749)
```

从到目前为止的例子中可以看出，Python 的标准库有很多优点。大多数情况下，您不必为了在线访问文件而下载第三方库。

# Python 标记和基于标记的解析器

基于标签的数据，尤其是不同的 XML 方言，已经成为一种非常流行的地理空间数据分发方式。机器可读和人类可读的格式通常很容易处理，尽管它们为了可用性而牺牲了存储效率。对于非常大的数据集，这些格式可能变得难以管理，但在大多数情况下非常有效。

虽然大多数格式都是某种形式的 XML(如 KML 或 GML)，但有一个明显的例外。**众所周知的文本** ( **WKT** )格式相当常见，但使用外部标记和方括号(`[]`)来包围数据，而不是像 XML 那样用尖括号中的标签包围数据。

Python 有对 XML 的标准库支持，以及一些优秀的第三方库。正确的 XML 格式都遵循相同的结构，因此您可以使用通用的 XML 库来读取它。因为 XML 是基于文本的，所以通常很容易将其写成字符串，而不是使用 XML 库。绝大多数输出 XML 的应用程序都是这样做的。

使用 XML 库来编写 XML 的主要优点是您的输出通常是经过验证的。创建自己的 XML 格式时，很容易产生错误。一个缺少的引号可能会使一个 XML 解析器脱轨，并为试图读取您的数据的人抛出一个错误。当这些错误发生时，它们实际上使您的数据集变得无用。你会发现这个问题在基于 XML 的地理空间数据中非常普遍。您会发现，一些解析器对不正确的 XML 比其他解析器更宽容。通常，可靠性比速度或内存效率更重要。

http://lxml.de/performance.html 提供的分析为不同 Python XML 解析器之间的内存和速度提供了基准。

# minidom 模块

Python `minidom`模块是一个非常古老且使用简单的 XML 解析器。它是 Python 在 XML 包中内置的一组 XML 工具的一部分。它可以解析 XML 文件或作为字符串输入的 XML。`minidom`模块最适合速度开始下降前小于 20 MB 左右的中小型 XML 文档。

为了演示`minidom`模块，我们将使用一个示例 KML 文件，它是谷歌 KML 文档的一部分，您可以下载。以下链接中的数据代表从全球定位系统设备传输的时间戳点位置:让我们开始吧:

1.  首先，我们将通过从文件中读入数据并创建一个`minidom`解析器对象来解析这些数据。该文件包含一系列`<Placemark>`标签，这些标签包含一个点和收集该点的时间戳。因此，我们将获得文件中所有`Placemarks`的列表，我们可以通过检查该列表的长度来计数它们，如以下代码行所示:

```py
>>> from xml.dom import minidom
>>> kml = minidom.parse("time-stamp-point.kml")
>>> Placemarks = kml.getElementsByTagName("Placemark")
>>> len(Placemarks)
361
```

2.  如你所见，我们取回了所有`Placemarks`，总计`361`。现在，让我们来看看列表中的第一个`Placemark`元素:

```py
>>> Placemarks[0]
<DOM Element: Placemark at 0x2045a30>
```

每个`<Placemark>`标签现在都是一个 DOM 元素数据类型。为了真正了解这个元素是什么，我们称之为`toxml()`方法，如下所示:

```py
>>> Placemarks[0].toxml()
u'<Placemark>\n <TimeStamp>\n \<when>2007-01-14T21:05:02Z</when>\n
</TimeStamp>\n <styleUrl>#paddle-a</styleUrl>\n <Point>\n
<coordinates>-122.536226,37.86047,0</coordinates>\n
</Point>\n </Placemark>'
```

3.  `toxml()`函数将包含在`Placemark`标签中的所有内容作为字符串对象输出。如果我们想将这些信息打印到一个文本文件中，我们可以调用`toprettyxml()`方法，该方法会添加额外的缩进，以使 XML 更具可读性。

4.  现在，如果我们想从这个地标中获取坐标呢？坐标被隐藏在`coordinates`标记中，该标记包含在`point`标记中，并嵌套在`Placemark`标记中。一个`minidom`对象的每个元素被称为一个**节点**。嵌套节点称为子节点或子节点。子节点不仅仅包括标签，它们还可以包括分隔标签的空白，以及标签内的数据。因此，我们可以使用标签名深入到`coordinates`标签，但是接下来我们需要访问`data`节点。所有的`minidom`元素都有`childNodeslist`，还有一个`firstChild()`方法来访问第一个节点。
5.  我们将结合这些方法来获得第一个坐标的`data`节点的`data`属性，我们使用坐标阶段列表中的索引`0`来引用该属性:

```py
>>> coordinates =
Placemarks[0].getElementsByTagName("coordinates")
>>> point = coordinates[0].firstChild.data
>>> point
u'-122.536226,37.86047,0'
```

If you're new to Python, you'll notice that the text output in these examples is tagged with the letter `u`. This markup is how Python denotes Unicode strings that support internationalization to multiple languages with different character sets. Python 3.4.3 changes this convention slightly and leaves Unicode strings unmarked while marking UTF-8 strings with a `b`.

6.  我们可以更进一步，通过拆分字符串并将结果字符串转换为 Python 浮点类型，将这个`point`字符串转换为可用数据，如下所示:

```py
>>> x,y,z = point.split(",")
>>> x
u'-122.536226'
>>> y
u'37.86047'
>>> z
u'0'
>>> x = float(x)
>>> y = float(y)
>>> z = float(z)
>>> x,y,z
(-122.536226, 37.86047, 0.0)
```

7.  使用 Python 列表理解，我们可以在一个步骤中执行这个操作，正如您在下面几行代码中看到的:

```py
>>> x,y,z = [float(c) for c in point.split(",")]
>>> x,y,z
(-122.536226, 37.86047, 0.0)
```

这个例子只是触及了`minidom`库所能做的事情的表面。关于这个库的一个很好的教程，请看下面的教程:[https://www.edureka.co/blog/python-xml-parser-tutorial/](https://www.edureka.co/blog/python-xml-parser-tutorial/)。

# elemonttree

`minidom`模块是纯 Python，容易上手，从 Python 2.0 开始就有了。然而，Python 2.5 在名为`ElementTree`的标准库中添加了一个更高效但更高级的 XML 解析器。`ElementTree`很有趣，因为它已经实现了多个版本。

有一个纯 Python 版本和一个用 C 写的更快的版本，叫做`cElementTree`。你应该尽可能使用`cElementTree`，但是有可能你所在的平台不包括基于 C 的版本。当您导入`cElementTree`时，您可以测试它是否可用，并在必要时返回到纯 Python 版本:

```py
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
```

`ElementTree`的一大特点是实现了 XPath 查询语言的一个子集。XPath 是 XML Path 的缩写，允许您使用路径样式的语法来搜索 XML 文档。如果您经常使用 XML，学习 XPath 是必不可少的。您可以通过以下链接了解更多关于 XPath 的信息:[https://www.w3schools.com/xml/xpath_intro.asp](https://www.w3schools.com/xml/xpath_intro.asp)。

这个特性的一个缺点是，如果文档像大多数 XML 文档一样指定了一个名称空间，那么您必须将该名称空间插入到查询中。`ElementTree`不会自动为你处理命名空间。您可以手动指定它，或者尝试使用字符串解析从根元素的标记名中提取它。

我们将使用`ElementTree`重复`minidomXML`解析示例:

1.  首先，我们将解析文档，然后手动定义 KML 命名空间；稍后，我们将使用 XPath 表达式和`find()`方法来查找第一个`Placemark`元素。
2.  最后，我们将找到坐标和子节点，然后抓取包含纬度和经度的文本。

在这两种情况下，我们都可以直接搜索`coordinates`标签。但是，通过抓取`Placemark`元素，它为我们提供了稍后抓取相应时间戳子元素的选项，如果我们选择这样做的话，如下面几行代码所示:

```py
>>> tree = ET.ElementTree(file="time-stamp-point.kml")
>>> ns = "{http://www.opengis.net/kml/2.2}"
>>> placemark = tree.find(".//%sPlacemark" % ns)
>>> coordinates =
placemark.find("./{}Point/{}coordinates".format(ns, ns))
>>> coordinates.text
'-122.536226,37.86047,0'
```

在本例中，请注意，我们使用了 Python 字符串格式语法，该语法基于 c 语言中的字符串格式概念。当我们为地标变量定义 XPath 表达式时，我们使用了`%`占位符来指定字符串的插入。然后，在字符串之后，我们使用`%`操作符后跟一个变量名来插入占位符所在的`ns`名称空间变量。在`coordinates`变量中，我们两次使用了`ns`变量，因此我们在字符串后两次指定了包含`ns`的元组。

String formatting is a simple yet extremely powerful and useful tool in Python that's worth learning. You can find more information in Python's documentation online at the following link: [https://docs.python.org/3.4/library/string.html](https://docs.python.org/3.4/library/string.html).

# 使用元素树和迷你 dom 构建 XML

大多数情况下，可以通过串联字符串来构建 XML，如您在以下命令中所见:

```py
xml = "<?xml version="1.0" encoding="utf-8"?>"
xml += "<kml >"
xml += " <Placemark>"
xml += " <name>Office</name>"
xml += " <description>Office Building</description>"
xml += " <Point>"
xml += " <coordinates>"
xml += " -122.087461,37.422069"
xml += " </coordinates>"
xml += " </Point>"
xml += " </Placemark>"
xml += "</kml>"
```

但是，这种方法很容易出现错别字，这会创建无效的 XML 文档。更安全的方法是使用 XML 库。让我们使用`ElementTree`来构建这个简单的 KML 文档:

1.  我们将定义`rootKML`元素，并为它分配一个名称空间。
2.  然后，我们将系统地向根追加子元素，将元素包装为`ElementTree`对象，声明 XML 编码，并将其写出到名为`placemark.xml`的文件中，如下面几行代码所示:

```py
>>> root = ET.Element("kml")
>>> root.attrib["xmlns"] = "http://www.opengis.net/kml/2.2"
>>> placemark = ET.SubElement(root, "Placemark")
>>> office = ET.SubElement(placemark, "name")
>>> office.text = "Office"
>>> point = ET.SubElement(placemark, "Point")
>>> coordinates = ET.SubElement(point, "coordinates")
>>> coordinates.text = "-122.087461,37.422069, 37.422069"
>>> tree = ET.ElementTree(root)
>>> tree.write("placemark.kml",
xml_declaration=True,encoding='utf-8',method="xml")
```

输出与前面的字符串构建示例相同，只是`ElementTree`没有缩进标记，而是将其作为一个长字符串写入。`minidom`模块有一个类似的界面，这在马克·皮尔格林所著的《潜入 Python》一书中有记载，在我们刚刚看到的`minidom`例子中也有引用。

像`minidom`和`ElementTree`这样的 XML 解析器在格式完美的 XML 文档上工作得非常好。不幸的是，绝大多数的 XML 文档不遵循这些规则，并且包含格式错误或无效字符。您会发现，您经常被迫处理这些数据，必须借助非凡的字符串解析技术来获取您实际需要的一小部分数据。但是多亏了 Python 和美丽的汤，您可以优雅地处理糟糕甚至糟糕的基于标签的数据。

美丽的汤是一个模块，专门设计来稳健地处理破碎的 XML。它面向 HTML，HTML 因格式不正确而臭名昭著，但也适用于其他 XML 方言。PyPI 上有美人汤，所以使用`easy_install`或`pip`安装，如下命令所示:

```py
easy_install beautifulsoup4
```

或者，您可以执行以下命令:

```py
pip install beautifulsoup4
```

然后，要使用它，您只需导入它:

```py
>>> from bs4 import BeautifulSoup
```

为了尝试一下，我们将使用智能手机应用程序中的**全球定位系统交换格式** ( **GPX** )跟踪文件，该文件有一个小故障，并导出略有损坏的数据。你可以从[下载这个样本文件。](https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx)

这个 2，347 行的数据文件处于原始状态，除了它缺少一个结束`</trkseg>`标记，该标记应该位于文件的最末端，就在结束`</trk>`标记之前。此错误是由源程序中的数据导出函数引起的。这个缺陷很可能是由于最初的开发人员在导出时手动生成了 GPX XML，而忘记了添加这个结束标记的代码行。看看如果我们试图用`minidom`解析这个文件会发生什么:

```py
>>> gpx = minidom.parse("broken_data.gpx")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "C:\Python34\lib\xml\dom\minidom.py", line 1914, in parse
return expatbuilder.parse(file)
File "C:\Python34\lib\xml\dom\expatbuilder.py", line 924, in
parse
result = builder.parseFile(fp)
File "C:\Python34\lib\xml\dom\expatbuilder.py", line 207, in
parseFile
parser.Parse(buffer, 0)
xml.parsers.expat.ExpatError: mismatched tag: line 2346, column 2
```

从错误消息的最后一行可以看出，`minidom`中的底层 XML 解析器确切地知道问题是什么——文件末尾的一个`mismatched`标记。然而，除了报告错误，它拒绝做任何事情。为了避免这种情况，您必须有完美的 XML 格式，或者根本没有。

现在，让我们用相同的数据来尝试更复杂、更高效的`ElementTree`模块:

```py
>>> ET.ElementTree(file="broken_data.gpx")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "C:\Python34\lib\xml\etree\ElementTree.py", line 611, in
__init__
self.parse(file)
File "C:\Python34\lib\xml\etree\ElementTree.py", line 653, in
parse
parser.feed(data)
File "C:\Python34\lib\xml\etree\ElementTree.py", line 1624, in
feed
self._raiseerror(v)
File "C:\Python34\lib\xml\etree\ElementTree.py", line 1488, in
_raiseerror
raise err
xml.etree.ElementTree.ParseError: mismatched tag: line 2346,
column 2
```

如您所见，不同的解析器面临着相同的问题。在地理空间分析中，格式不良的 XML 是一个非常普遍的现实，每个 XML 解析器都假设世界上所有的 XML 都是完美的，只有一个例外。进入美丽的汤。这个库毫不犹豫地将糟糕的 XML 分割成可用的数据，它可以处理比丢失标签更糟糕的缺陷。尽管缺少标点符号或其他语法，它仍能工作，并能给你最好的数据。它最初是为解析 HTML 而开发的，HTML 格式不佳是出了名的可怕，但它也能很好地处理 XML，如下所示:

```py
>>> from bs4 import BeautifulSoup
>>> gpx = open("broken_data.gpx")
>>> soup = BeautifulSoup(gpx.read(), features="xml")
>>>
```

没有美丽汤的抱怨！为了确保数据实际可用，让我们尝试访问一些数据。《美丽的汤》的一个奇妙的特性是它将标签变成了解析树的属性。如果有多个同名标签，它会抓取第一个标签。我们的样本数据文件有数百个`<trkpt>`标签。让我们访问第一个:

```py
>>> soup.trkpt
<trkpt lat="30.307267000" lon="-89.332444000">
<ele>10.7</ele><time>2013-05-16T04:39:46Z</time></trkpt>
```

我们现在确定数据已经被正确解析，并且我们可以访问它。如果我们想访问所有的`<trkpt>`标签，我们可以使用`findAll()`方法抓取它们，然后使用内置的 Python `len()`函数进行计数，如下图所示:

```py
>>> tracks = soup.findAll("trkpt")
>>> len(tracks)
2321
```

如果我们将解析后的数据写回到一个文件中，美丽的汤会输出正确的版本。我们将使用美丽的汤模块的`prettify()`方法将固定数据保存为一个新的 GPX 文件，用漂亮的缩进来格式化 XML，如下面几行代码所示:

```py
>>> fixed = open("fixed_data.gpx", "w")
>>> fixed.write(soup.prettify())
>>> fixed.close()
```

美丽的汤是一个非常丰富的图书馆，有更多的功能。如需进一步了解，请访问[在线美人汤文档。](http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html)

虽然`minidom`、`ElementTree`和`cElementTree`都有 Python 标准库，但是还有一个更强大、更流行的 Python XML 库叫做`lxml`。`lxml`模块使用`ElementTree`应用编程接口为`libxml2`和`libxslt` C 库提供了一个 Pythonic 接口。一个更好的事实是`lxml`也与美丽的汤一起解析基于标签的坏数据。在某些安装中，`beautifulsoup4`可能需要`lxml.``lxml`模块可通过 PyPI 获得，但需要一些额外的 C 库步骤。更多信息可在`lxml`主页以下链接获得:[http://lxml.de/](http://lxml.de/)。

# 知名文本(WKT)

WKT 格式已经存在多年，是一种简单的基于文本的格式，用于表示几何图形和空间参考系统。它主要被实现 OGC 简单功能的系统用作数据交换格式。看看下面多边形的 WKT 表示示例:

```py
POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))
```

目前，读写 WKT 最好的方法是使用 Shapely 库。Shapely 为我们在[第 3 章](03.html)、*地理空间技术景观*中描述的**几何引擎-开源** ( **GEOS** )库提供了非常面向 Python 或 Python 的接口。

您可以使用`easy_install`或`pip`安装 Shapely。您也可以使用我们在上一节中提到的站点上的轮子。Shapely 有一个 WKT 模块，可以加载和导出这些数据。让我们使用 Shapely 加载前一个多边形样本，然后通过计算其面积来验证它是否已被加载为多边形对象:

```py
>>> import shapely.wkt
>>> wktPoly = "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,
1 1))"
>>> poly = shapely.wkt.loads(wktPoly)
>>> poly.area
15.0
```

我们可以通过简单地调用其`wkt`属性将任何 Shapely 几何转换回 WKT，如下所示:

```py
>>> poly.wkt
'POLYGON ((0.0 0.0, 4.0 0.0, 4.0 4.0, 0.0 4.0, 0.0 0.0), (1.0 1.0,
2.0 1.0, 2.0 2.0, 1.0 2.0, 1.0 1.0))'
```

Shapely 还可以处理 WKT 的二进制对应物 W **众所周知的二进制** ( **WKB** )，它用于将 WKT 字符串作为二进制对象存储在数据库中。Shapely 使用其`wkb`模块加载 WKB 的方式与`wkt`模块相同，它可以通过调用该对象的`wkb`属性来转换几何图形。

Shapely 是处理 WKT 数据最常用的 Python 方式，但是您也可以使用 Python 绑定到 OGR 库，我们在本章前面已经安装了该库。

对于这个例子，我们将使用一个简单多边形的 shapefile，它可以作为 ZIP 文件下载。可通过以下链接获得:[https://github . com/GeospatialPython/Learn/raw/master/polygon . zip](https://github.com/GeospatialPython/Learn/raw/master/polygon.zip)。

在下面的例子中，我们将从 shapefile 数据集中打开`polygon.shp`文件，调用所需的`GetLayer()`方法，获取第一个(也是唯一的)特征，然后将其导出到 WKT:

```py
>>> from osgeo import ogr
>>> shape = ogr.Open("polygon.shp")
>>> layer = shape.GetLayer()
>>> feature = layer.GetNextFeature()
>>> geom = feature.GetGeometryRef()
>>> wkt = geom.ExportToWkt()
>>> wkt
' POLYGON ((-99.904679362176353 51.698147686745074,
-75.010398603076666 46.56036851832075,-75.010398603076666
46.56036851832075,-75.010398603076666 46.56036851832075,
-76.975736557742451 23.246272688996914,-76.975736557742451
23.246272688996914,-76.975736557742451 23.246272688996914,
-114.31715769639194 26.220870210283724,-114.31715769639194
26.220870210283724,-99.904679362176353 51.698147686745074))'
```

请注意，对于 OGR，您必须读取访问每个特征并单独导出，因为`ExporttoWkt()`方法是在特征级别。我们现在可以使用包含导出的`wkt`变量来读取 WKT 字符串。我们将把它导入回`ogr`并获得多边形的边界框，也称为包络，正如你在这里看到的:

```py
>>> poly = ogr.CreateGeometryFromWkt(wkt)
>>> poly.GetEnvelope()
(-114.31715769639194, -75.01039860307667, 23.246272688996914,
51.698147686745074)
```

Shapely 和 OGR 用于读取和写入有效的 WKT 字符串。当然，就像 XML(也是文本)一样，您可以在必要时将少量 WKT 作为字符串进行操作。接下来，我们将了解一种在地理空间世界中变得非常普遍的现代文本格式。

# Python JSON 库

**JavaScript 对象符号** ( **JSON** )正迅速成为许多领域的头号数据交换格式。轻量级的语法及其与现有数据结构的相似性，无论是 Python 借用的 JavaScript 数据结构，还是 JavaScript 本身，都使其成为 Python 的完美匹配。

以下 GeoJSON 示例文档包含一个点:

```py
{
    "type": "Feature",
    "id": "OpenLayers.Feature.Vector_314",
    "properties": {},
    "geometry": {
        "type": "Point",
        "coordinates": [
            97.03125,
            39.7265625
        ]
    },
    "crs": {
        "type": "name",
        "properties": {
            "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
        }
    }
}
```

此示例只是一个具有新属性的简单点，这些属性将存储在几何图形的属性数据结构中。在前面的示例中，标识、坐标和 CRS 信息将根据您的特定数据集而变化。

让我们使用 Python 修改这个示例 GeoJSON 文档。首先，我们将示例文档压缩成一个字符串，以便于处理:

```py
>>> jsdata = """{
    "type": "Feature",
   "id": "OpenLayers.Feature.Vector_314",
  "properties": {},
    "geometry": {
        "type": "Point",
        "coordinates": [
           97.03125,
           39.7265625
       ]
    },
    "crs": {
        "type": "name",
        "properties": {
            "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
        }
    }
}"""
```

现在，我们可以在下面的示例中使用我们在前面的代码中创建的 GeoJSON `jsdata`字符串变量。

# json 模块

GeoJSON 看起来非常类似于一组嵌套的 Python 字典和列表。只是为了好玩，让我们试着用 Python 的`eval()`函数将其解析为 Python 代码:

```py
>>> point = eval(jsdata)
>>> point["geometry"]
{'type': 'Point', 'coordinates': [97.03125, 39.7265625]}
```

哇哦！成功了。我们通过一个简单的步骤就把这个随机的 GeoJSON 字符串变成了本地 Python 数据。请记住，JSON 数据格式基于 JavaScript 语法，这恰好与 Python 相似。此外，随着您对 GeoJSON 数据的深入了解以及对更大数据的处理，您会发现 JSON 允许 Python 不允许的字符。使用 Python 的`eval()`函数也被认为是非常不安全的。但是就保持事情简单而言，请注意，没有比这更简单的了！

由于 Python 追求简单，更高级的方法不会变得更复杂。让我们使用 Python 的`json`模块，它是标准库的一部分，以正确的方式将相同的字符串转换成 Python:

```py
>>> import json
>>> json.loads(jsdata)
{u'geometry': {u'type': u'Point', u'coordinates': [97.03125,
39.7265625]}, u'crs': {u'type': u'name', u'properties': {u'name':
u'urn:ogc:def:crs:OGC:1.3:CRS84'}}, u'type': u'Feature', u'id': u'OpenLayers.Feature.Vector_314',
u'properties':
{}}
```

顺便说一下，在前面的示例中，CRS84 属性是公共 WGS84 坐标系的同义词。`json`模块增加了一些不错的特性，比如更安全的解析和字符串到 Unicode 的转换。我们可以用几乎相同的方式将 Python 数据结构导出到 JSON:

```py
>>> pydata = json.loads(jsdata)
>>> json.dumps(pydata)
'{"geometry": {"type": "Point", "coordinates": [97.03125,
39.7265625]}, "crs": {"type": "name", "properties": {"name":
"urn:ogc:def:crs:OGC:1.3:CRS84"}}, "type" : "Feature", "id": "OpenLayers.Feature.Vector_314", "properties":
{}}'
```

当您转储数据时，它会显示为一个难以读取的长字符串。有一种方法可以打印数据，这样更容易阅读:通过向`dumps()`方法传递缩进值:

```py
print(json.dumps(pydata, indent=4))

{
    "type": "Feature",
    "id":
    "OpenLayers.Feature.Vector_314",
    "properties": {},
    "geometry": {
        "type": "Point",
        "coordinates": [
            97.03125,
            39.7265625
        ]
    },
    "crs": {
        "type": "name",
        "properties": {           
                 "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
        }
   }
}
```

现在我们已经理解了`json`模块，让我们来看看名为`geojson`的地理空间版本。

# geojson 模块

我们可以永远使用`json`模块愉快地继续读写 GeoJSON 数据，但是还有更好的方法。PyPI 上提供的`geojson`模块有一些明显的优势。首先，它知道 GeoJSON 规范的要求，这可以节省大量的输入。让我们使用这个模块创建一个简单的点，并将其导出到 GeoJSON:

```py
>>> import geojson
>>> p = geojson.Point([-92, 37])
```

这一次，当我们转储 JSON 数据进行查看时，我们将添加一个值为`4`的缩进参数，这样我们就可以很好地缩进更容易读取的 JSON 数据:

```py
>>> geojs = geojson.dumps(p, indent=4)
>>> geojs
```

我们的输出如下:

```py
{
    "type": "Point",
    "coordinates": [
        -92,
        37
    ]
}
POINT (-92 37)
```

注意`geojson`模块有不同数据类型的接口，省去了我们手动设置类型和坐标属性。现在，想象一下，如果你有一个有数百个特征的地理物体。您可以通过编程来构建这个数据结构，而不是构建一个非常大的字符串。

`geojson`模块也是 Python `geo_interface`约定的参考实现。这个接口允许协作程序以 Pythonic 方式无缝地交换数据，而不需要程序员显式地导出和导入 GeoJSON 字符串。因此，如果我们想将我们用`geojson`模块创建的点馈送到 Shapely 模块，我们可以执行以下命令，该命令将`geojson`模块的点对象直接读入 Shapely，然后我们将它导出为 WKT:

```py
>>> from shapely.geometry import asShape
>>> point = asShape(p)
>>> point.wkt
'POINT (-92.0000000000000000 37.0000000000000000)'

```

越来越多的地理空间 Python 库同时实现了`geojson`和`geo_interface`功能，包括 PyShp、Fiona、Karta 和 ArcGIS。QGIS 存在第三方实现。

GeoJSON 是一种简单的文本格式，是人类和计算机可读的。现在，我们来看看一些二进制向量格式。

# OGR

我们将 OGR 作为处理 WKT 字符串的一种方式，但它的真正功能是作为一个通用向量库。这本书致力于纯 Python 解决方案，但是没有一个库能够接近 OGR 能够处理的各种格式。

让我们阅读一个使用 OGR Python 应用编程接口的样本点形状文件。示例 shapefile 可以在这里作为 ZIP 文件下载:[https://github . com/GeospatialPython/Learn/raw/master/point . ZIP](https://github.com/GeospatialPython/Learn/raw/master/point.zip)。

这个点形状文件有五个具有一位数正坐标的点。属性列出了创建点的顺序，这对测试很有用。这个简单的例子将读入点形状文件并遍历每个特征；然后，它将打印每个点的 *x* 和 *y* 值，加上第一个属性字段的值:

```py
>>> import ogr
>>> shp = ogr.Open("point.shp")
>>> layer = shp.GetLayer()
>>> for feature in layer:
... geometry = feature.GetGeometryRef()
... print(geometry.GetX(), geometry.GetY(),
feature.GetField("FIRST_FLD"))
...
1.0 1.0 First
3.0 1.0 Second
4.0 3.0 Third
2.0 2.0 Fourth
0.0 0.0 Appended
```

这个例子很简单，但是随着脚本变得越来越复杂，OGR 会变得相当冗长。接下来，我们将研究一种更简单的方法来处理 shapefiles。

# PyShp

PyShp 是一个简单、纯粹的 Python 库，可以读写 shapefiles。它不执行任何几何操作，只使用 Python 的标准库。它包含在一个文件中，易于移动、挤压到小型嵌入式平台上以及修改。它也与 Python 3 兼容。还实现了`__geo_interface__`。PyShp 模块在 PyPI 上提供。

让我们用 PyShp 重复前面的 OGR 例子:

```py
>>> import shapefile
>>> shp = shapefile.Reader("point.shp")
>>> for feature in shp.shapeRecords():
... point = feature.shape.points[0]
... rec = feature.record[0]
... print(point[0], point[1], rec)
...
1.0 1.0 First
3.0 1.0 Second
4.0 3.0 Third
2.0 2.0 Fourth
0.0 0.0 Appended //
```

# dbfpy

OGR 和 PyShp 都读写`.dbf`文件，因为它们是 shapefile 规范的一部分。`.dbf`文件包含形状文件的属性和字段。然而，这两个库都有非常基本的`.dbf`支持。偶尔，你需要做一些繁重的 DBF 工作。`dbfpy3`模块是一个纯 Python 模块，专门用于处理`.dbf`文件。它目前托管在 GitHub 上。您可以通过指定下载文件来强制`easy_install`查找下载:

```py
easy_install -f
 https://github.com/GeospatialPython/dbfpy3/archive/master.zip
```

如果使用`pip`安装软件包，请使用以下命令:

```py
pip install
 https://github.com/GeospatialPython/dbfpy3/archive/master.zip
```

下面的 shapefile 有 600 多条`.dbf`记录，代表美国人口普查局的大片，是试用`dbfpy` : [的好样本。](https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip)

让我们打开这个 shapefile 的`.dbf`文件，看看第一条记录:

```py
>>> from dbfpy3 import dbf
>>> db = dbf.Dbf("GIS_CensusTract_poly.dbf")
>>> db[0]
GEODB_OID: 4029 (<type 'int'>)
OBJECTID: 4029 (<type 'int'>)
PERMANE0: 61be9239-8f3b-4876-8c4c-0908078bc597 (<type 'str'>)
SOURCE_1: NA (<type 'str'>)
SOURCE_2: 20006 (<type 'str'>)
SOURCE_3: Census Tracts (<type 'str'>)
SOURCE_4: Census Bureau (<type 'str'>)
DATA_SE5: 5 (<type 'str'>)
DISTRIB6: E4 (<type 'str'>)
LOADDATE: 2007-03-13 (<type 'datetime.date'>)
QUALITY: 2 (<type 'str'>)
SCALE: 1 (<type 'str'>)
FCODE: 1734 (<type 'str'>)
STCO_FI7: 22071 (<type 'str'>)
STATE_NAME: 22 (<type 'str'>)
COUNTY_8: 71 (<type 'str'>)
CENSUST9: 22071001734 (<type 'str'>)
POPULAT10: 1760 (<type 'int'>)
AREASQKM: 264.52661934 (<type 'float'>)
GNIS_ID: NA (<type 'str'>)
POPULAT11: 1665 (<type 'int'>)
DB2GSE_12: 264526619.341 (<type 'float'>)
DB2GSE_13: 87406.406192 (<type 'float'>)
```

该模块可以快速方便地将列名和数据值一起提供给我们，而不是将它们作为单独的列表来处理，这样它们更容易管理。现在，让我们将`POPULAT10`中包含的人口字段增加`1`:

```py
>>> rec = db[0]
>>> field = rec["POPULAT10"]
>>> rec["POPULAT10"] = field + 1
>>> rec.store()
>>> del rec
>>> db[0]["POPULAT10"]
1761
```

请记住，OGR 和 PyShp 都可以执行相同的过程，但是`dbfp3y`如果您只是对进行了大量的更改，就会变得稍微容易一些。dbf 文件。

# 形状美观的

在**知名文字** ( **WKT** )一节中提到了匀称的进口和出口。然而，它的真正目的是作为一个通用几何图形库。Shapely 是 GEOS 库的高级 Pythonic 接口，用于几何操作。事实上，Shapely 有意避免读取或写入文件。它完全依赖于其他模块的数据导入和导出，并保持对几何操作的关注。

让我们做一个快速的 Shapley 演示，我们将定义一个单一的 WKT 多边形，然后将其导入 Shapley。然后，我们将测量面积。我们的计算几何将包括用五个任意单位的度量来缓冲该多边形，这将返回一个新的、更大的多边形，我们将为其测量面积:

```py
>>> from shapely import wkt, geometry
>>> wktPoly = "POLYGON((0 0,4 0,4 4,0 4,0 0))"
>>> poly = wkt.loads(wktPoly)
>>> poly.area
16.0
>>> buf = poly.buffer(5.0)
>>> buf.area
174.41371226364848
```

然后，我们可以在缓冲区区域和原始多边形区域中执行差异，如下所示:

```py
>>> buf.difference(poly).area
158.413712264
```

如果你不能拥有纯粹的 Python，那么一个像 Shapely 一样干净的 Pythonic API 来打这样的拳肯定是下一个最好的事情。

# 菲奥纳

Fiona 库提供了一个围绕 OGR 库的简单 Python API，用于数据访问等等。这种方法使用起来很容易，并且在使用 Python 时没有 OGR 那么冗长。默认情况下，Fiona 输出 GeoJSON。你可以在[http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona](http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona)找到菲奥娜的车轮档案。

作为一个例子，我们将使用我们在本章前面看到的`dbfpy`例子中的`GIS_CensusTract_poly.shp`文件。

首先，我们将导入`fiona`和 Python 的`pprint`模块来格式化输出。然后，我们将打开 shapefile 并检查其驱动程序类型:

```py
>>> import fiona
>>> from pprint import pprint
>>> f = fiona.open("GIS_CensusTract_poly.shp")
>>> f.driver
```

# ESRI shape file(ESRI shape file)

接下来，我们将检查其坐标参考系统，并获得数据边界框，如下所示:

```py
>>> f.crs
{'init': 'epsg:4269'}
>>> f.bounds
(-89.8744162216216, 30.161122135135138, -89.1383837783784,
30.661213864864862)
```

现在，我们将数据模式视为`geojson`并使用`pprint`模块对其进行格式化，如您在以下代码行中所见:

```py
>>> pprint(f.schema)
{'geometry': 'Polygon',
'properties': {'GEODB_OID': 'float:11',
'OBJECTID': 'float:11',
'PERMANE0': 'str:40',
'SOURCE_1': 'str:40',
'SOURCE_2': 'str:40',
'SOURCE_3': 'str:100',
'SOURCE_4': 'str:130',
'DATA_SE5': 'str:46',
'DISTRIB6': 'str:188',
'LOADDATE': 'date',
'QUALITY': 'str:35',
'SCALE': 'str:52',
'FCODE': 'str:38',
'STCO_FI7': 'str:5',
'STATE_NAME': 'str:140',
'COUNTY_8': 'str:60',
'CENSUST9': 'str:20',
'POPULAT10': 'float:11',
'AREASQKM': 'float:31.15',
'GNIS_ID': 'str:10',
'POPULAT11': 'float:11',
'DB2GSE_12': 'float:31.15',
'DB2GSE_13': 'float:31.15'}}
```

接下来，让我们统计一下功能的数量:

```py
>>> len(f)
45
```

最后，我们将打印一条格式化为 GeoJSON 的记录，如下所示:

```py
pprint(f[1])
{'geometry': {'coordinates': [[[(-89.86412366375093,
30.661213864864862), (-89.86418691770497, 30.660764012731285),
(-89.86443391770518, 30.659652012730202),
...
'type': 'MultiPolygon'},
'id': '1',
'properties': {'GEODB_OID': 4360.0,
'OBJECTID': 4360.0,
'PERMANE0': '9a914eef-9249-44cf-a05f-af4b48876c59',
'SOURCE_1': 'NA',
'SOURCE_2': '20006',
...
'DB2GSE_12': 351242560.967882,
'DB2GSE_13': 101775.283967268},
'type': 'Feature'}
```

# 断续器

GDAL 是栅格数据的主要地理空间库。它的栅格功能非常重要，几乎是任何语言的每个地理空间工具包的一部分，Python 也不例外。要了解 GDAL 如何在 Python 中工作的基本知识，请下载以下示例光栅卫星图像作为 ZIP 文件并解压缩:[https://github . com/GeospatialPython/Learn/raw/master/satimage . ZIP](https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip)。让我们打开这张图像，看看它有多少波段，每个轴上有多少像素:

```py
>>> from osgeo import gdal
>>> raster = gdal.Open("SatImage.tif")
>>> raster.RasterCount
3
>>> raster.RasterXSize
2592
>>> raster.RasterYSize
2693
```

通过在 OpenEV 中查看，我们可以看到下面的图像有三个波段，2，592 列像素和 2，693 行像素:

![](img/1831299e-4500-49f1-8ef2-f8ee35f21442.png)

GDAL 是 Python 中速度极快的地理空间栅格读取器和写入器。除了能做一些其他的技巧外，它还能很好地再现图像。然而，GDAL 的真正价值来自于它与下一个 Python 模块的交互，我们现在将对此进行研究。

# NumPy

NumPy 是一款速度极快的多维 Python 数组处理器，专为 Python 和科学计算而设计，但采用 c 语言编写。它可以通过 PyPI 获得，也可以作为轮子文件(可在[http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy)获得)获得，安装起来很方便。除了惊人的速度，NumPy 的魔力还包括它与其他库的交互。NumPy 可以与 GDAL、Shapely、 **Python 成像库** ( **PIL** )以及其他领域的许多其他科学计算 Python 库交换数据。

作为 NumPy 能力的一个快速例子，我们将把它与 GDAL 结合起来，读入我们的样本卫星图像，然后创建它的直方图。GDAL 和 NumPy 之间的接口是一个名为`gdal_array`的 GDAL 模块，它有 NumPy 作为依赖。NumPy 模块的旧名称是 NumPy。`gdal_array`模块导入 NumPy。

在以下示例中，我们将使用导入 NumPy 的`gdal_array`，以数组形式读取图像，抓取第一个波段，并将其保存为 JPEG 图像:

```py
>>> from osgeo import gdal_array
>>> srcArray = gdal_array.LoadFile("SatImage.tif")
>>> band1 = srcArray[0]
>>> gdal_array.SaveArray(band1, "band1.jpg", format="JPEG")
```

该操作在 OpenEV 中为我们提供了以下灰度图像:

![](img/9e69e56e-1fcd-4829-9bbd-e3f7e5e1e51e.png)

# PIL

PIL 最初是为遥感开发的，但已经发展成为 Python 的通用图像编辑库。像 NumPy 一样，它是用 C 语言编写的，以提高速度，但它是专门为 Python 设计的。除了图像创建和处理，它还有一个有用的光栅绘图模块。PIL 也可以通过 PyPI 获得；但是，在 Python 3 中，您可能希望使用枕头模块，这是 PIL 的升级版本。正如您将在下面的示例中看到的，我们可以使用 Python try 语句，根据您的安装方式，使用两种可能的变体来导入 PIL。

在这个例子中，我们将结合 PyShp 和 PIL 来光栅化前面例子中的`hancock`形状文件，并将其保存为图像。我们将使用类似于[第 1 章](01.html)、*中的简单地理信息系统的世界到像素坐标转换，学习使用 Python 进行地理空间分析。我们将在 PIL 创建一个用作画布的图像，然后我们将使用 PIL `ImageDraw`模块来渲染多边形。最后，我们将把它保存为一个 PNG 图像，正如您在下面几行代码中看到的:*

```py
>>> try:
>>> import Image
>>> import ImageDraw
>>> except:
>>> from PIL import Image
>>> from PIL import ImageDraw
>>> import shapefile
>>> r = shapefile.Reader("hancock.shp")
>>> xdist = r.bbox[2] - r.bbox[0]
>>> ydist = r.bbox[3] - r.bbox[1]
>>> iwidth = 400
>>> iheight = 600
>>> xratio = iwidth/xdist
>>> yratio = iheight/ydist
>>> pixels = []
>>> for x,y in r.shapes()[0].points:
... px = int(iwidth - ((r.bbox[2] - x) * xratio))
... py = int((r.bbox[3] - y) * yratio)
... pixels.append((px,py))
...
>>> img = Image.new("RGB", (iwidth, iheight), "white")
>>> draw = ImageDraw.Draw(img)
>>> draw.polygon(pixels, outline="rgb(203, 196, 190)",
fill="rgb(198, 204, 189)")
>>> img.save("hancock.png")
```

本示例创建以下图像:

![](img/fe5e5ae1-a9ff-4c7e-b9e1-fa1da206b56b.png)

# PNGCanvas

有时，您可能会发现 PIL 对您的目的来说有些过分，或者您不被允许安装 PIL，因为您没有管理权限来安装用 c 语言创建和编译的 Python 模块。在这种情况下，您通常可以使用轻量级纯 Python PNGCanvas 模块。可以使用`easy_install`或 pip 安装。

使用此模块，我们可以重复使用 PIL 但在纯 Python 中执行的光栅形状文件示例，如下所示:

```py
>>> import shapefile
>>> import pngcanvas
>>> r = shapefile.Reader("hancock.shp")
>>> xdist = r.bbox[2] - r.bbox[0]
>>> ydist = r.bbox[3] - r.bbox[1]
>>> iwidth = 400
>>> iheight = 600
>>> xratio = iwidth/xdist
>>> yratio = iheight/ydist
>>> pixels = []
>>> for x,y in r.shapes()[0].points:
... px = int(iwidth - ((r.bbox[2] - x) * xratio))
... py = int((r.bbox[3] - y) * yratio)
... pixels.append([px,py])
...
>>> c = pngcanvas.PNGCanvas(iwidth,iheight)
>>> c.polyline(pixels)
>>> f = open("hancock_pngcvs.png", "wb")
>>> f.write(c.dump())
>>> f.close()
```

这个例子给了我们一个简单的轮廓，因为 PNGCanvas 没有内置的填充方法:

![](img/a5135eda-4450-4838-8565-64ba2695193f.png)

# 地球 andas

Pandas 是一个高性能的 Python 数据分析库，可以处理大型数据集，包括表格(类似于数据库)、有序/无序、标记矩阵或未标记的统计数据。GeoPandas 只是 Pandas 的地理空间扩展，它建立在 Shapely、Fiona、PyProj、Matplotlib 和笛卡尔的基础上，所有这些都必须安装。它允许您用 Python 轻松地执行操作，否则需要空间数据库，如 PostGIS。你可以从[http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda](http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda)下载一个地球 andas 的轮子文件。

下面的脚本打开一个 shapefile，并将其转储到 GeoJSON 中。然后，它用`matplotlib`创建一个地图:

```py
>>> import geopandas
>>> import matplotlib.pyplot as plt
>>> gdf = geopandas.GeoDataFrame
>>> census = gdf.from_file("GIS_CensusTract_poly.shp")
>>> census.plot()
>>> plt.show()
```

下图是前面命令的结果地图图:

![](img/930444cb-0f37-407e-875f-dc4c5398b1ff.png)

# PyMySQL

流行的 MySQL(可在[http://dev.mysql.com/downloads](http://dev.mysql.com/downloads)获得)数据库正在逐步发展空间功能。它支持 OGC 几何和一些空间功能。它还有一个在 PyMySQL 库中可用的纯 Python 应用编程接口。有限的空间函数使用平面几何和边界矩形，而不是球形几何和形状。MySQL 的最新开发版本包含一些改进这一功能的附加功能。

在下面的例子中，我们将在 MySQL 中创建一个名为`spatial_db`的数据库。然后，我们将添加一个名为`PLACES`的带有几何列的表。接下来，我们将添加两个城市作为点位置。最后，我们将使用 MySQL 的`ST_Distance`函数计算距离，然后将结果从度数转换为英里。

首先，我们将导入我们的`mysql`库并建立数据库连接:

```py
# Import the python mysql library
import pymysql
# Establish a database connection on our local
# machine as the root database user.
conn = pymysql.connect(host='localhost', port=3306,
user='root', passwd='', db='mysql')
```

接下来，我们得到数据库游标:

```py
# Get the database cursor needed to change
# the database
cur = conn.cursor()
```

现在，我们检查数据库是否已经存在，如果存在，就将其删除:

```py
# If the database already exists, delete
# it and recreate it either way.
cur.execute("DROP DATABASE IF EXISTS spatial_db")
cur.execute("CREATE DATABASE spatial_db")
# Close the cursor and the connection
cur.close()
conn.close()
```

现在，我们建立一个新的连接并获得一个光标:

```py
# Set up a new connection and cursor
conn = pymysql.connect(host='localhost', port=3306,
user='root', passwd='', db='spatial_db')
cur = conn.cursor()
```

接下来，我们可以创建新表并添加字段:

```py
# Create our geospatial table
cur.execute("CREATE TABLE PLACES (id int NOT NULL
# Add name and location fields. The location
# field is spatially enabled to hold GIS data
AUTO_INCREMENT PRIMARY KEY, Name varchar(50) NOT NULL, location
Geometry NOT NULL)")
```

添加字段后，我们可以插入一些城市的位置记录:

```py
# Insert a name and location for the city of
# New Orleans
cur.execute("INSERT INTO PLACES (name, location) VALUES ('NEW
ORLEANS', GeomFromText('POINT(30.03 90.03)'))")
# Insert a name and location for the city of
# Memphis.
cur.execute("INSERT INTO PLACES (name, location) VALUES
('MEMPHIS', GeomFromText('POINT(35.05 90.00)'))")
```

然后，我们可以提交对数据库的更改:

```py
# Commit the changes to the database
conn.commit()
```

现在，我们可以查询数据库了！首先，我们将获得所有点位置的列表:

```py
# Now let's read the data. Select all of
# the point locations from the database.
cur.execute("SELECT AsText(location) FROM PLACES")
```

现在，我们将从查询结果中提取两点:

```py
# We know there's only two points, so we'll
# just parse them.
p1, p2 = [p[0] for p in cur.fetchall()]
```

在测量距离之前，我们需要将点列表转换为地理空间几何图形:

```py
# Now we'll convert the data
# to geometries to measure the distance
# between the two cities
cur.execute("SET @p1 = ST_GeomFromText('{}')".format(p1))
cur.execute("SET @p2 = ST_GeomFromText('{}')".format(p2))
```

最后，我们可以使用`Distance`存储过程来测量两个几何图形之间的距离:

```py
# Now we do the measurement function which
# is also a database query.
cur.execute("SELECT ST_Distance(@p1, @p2)")
d = float(cur.fetchone()[0])
# Print the distance as a formatted
# string object.
print("{:.2f} miles from New Orleans to Memphis".format(d *
70))
cur.close()
conn.close()
```

输出如下:

```py
351.41 miles from New Orleans to Memphis
```

还有其他可用的空间数据库选项，包括 PostGIS 和 SpatiaLite 然而，Python 3 对这些空间引擎的支持充其量只是发展性的。你可以通过 OGR 图书馆访问 PostGIS 和 MySQL 但是，MySQL 的支持是有限的。

# PyFPDF

纯 Python PyFPDF 库是创建 PDF(包括地图)的轻量级方法。因为 PDF 格式是一种广泛使用的标准，所以 PDF 通常用于分发地图。可以通过 PyPI 作为`fpdf`安装。该软件的官方名称是 PyFPDF，因为它是名为`fpdf`的 PHP 语言模块的一部分。本模块使用一个名为单元格的概念来布局页面上特定位置的项目。作为一个快速的例子，我们将把我们从 PIL 例子中创建的`hancock.png`图像导入到一个名为`map.pdf`的 PDF 中，以创建一个简单的 PDF 地图。地图顶部将有标题文本，上面写着汉考克县边界，后面是地图图像:

```py
>>> import fpdf
>>> # PDF constructor:
>>> # Portrait, millimeter units, A4 page size
>>> pdf=fpdf.FPDF("P", "mm", "A4")
>>> # create a new page
>>> pdf.add_page()
>>> # Set font: arial, bold, size 20
>>> pdf.set_font('Arial','B',20)
>>> # Layout cell: 160 x 25mm, title, no border, centered
>>> pdf.cell(160,25,'Hancock County Boundary', \
>>> border=0, align="C")
>>> # Write the image specifying the size
>>> pdf.image("hancock.png",25,50,110,160)
>>> # Save the file: filename, F = to file System
>>> pdf.output('map.pdf','F')
```

如果您在 Adobe Acrobat Reader 或其他 PDF 阅读器(如苏门答腊 PDF)中打开名为`map.pdf`的 PDF 文件，您会看到图像现在位于 A4 页面的中心。地理空间产品通常作为大型报告的一部分，PyFPDF 模块简化了自动生成 PDF 格式的报告。

# 地理空间 PDF

**便携式文档格式**或 **PDF** 是一种文件格式，用于以跨平台和独立于应用程序的方式存储和呈现数字格式的文本和图像。PDF 是一种广泛使用的文档格式，也已经扩展到存储地理空间信息。

从版本 1.7 开始的 PDF 规范包括地理空间 PDF 的扩展，它将文档的部分映射到物理空间，也称为地理配准。您可以创建点、线或多边形作为地理空间几何图形，这些几何图形也可以具有属性。

有两种方法可以对 PDF 中的地理空间信息进行编码。一家名为 TerraGo 的公司创建了一个规范，该规范已被开放地理空间联盟采纳为最佳实践，但不是标准。这种格式被称为**地球测向**。Adobe Systems 提出的扩展创建了名为 ISO 32000 的 PDF 规范，目前正在被纳入 2.0 版本的规范中。

TerraGo 的地理空间 PDF 产品符合 OGC 最佳实践文档和 Adobe PDF 扩展。但是 TerraGo 超越了这些特性，包括图层和其他地理信息系统功能。但是，您必须使用 TerraGo 的 Adobe Acrobat 插件或其他软件来访问该功能。至少，TerraGo 支持至少在任何 PDF 软件中显示所需的功能。

在 Python 中，有一个名为`geopdf`的库，它与 TerraGo 无关，但支持 OGC 最佳实践。这个库最初是由突出边缘的泰勒·加纳([https://prominentedge.com/](https://prominentedge.com/))为 Python 2 开发的。已经移植到 Python 3 了。

从 GitHub 安装`geopdf`就像运行以下程序一样简单:

```py
pip install https://github.com/GeospatialPython/geopdf-py3/archive/master.zip
```

以下示例将我们在[第 1 章](01.html)、*中使用 Python 学习地理空间分析*中创建的地图作为地理空间 PDF 重新创建在*简单地理信息系统*部分中。`geopdf`库依赖于 Python ReportLab PDF 库。我们需要执行的步骤如下:

1.  创建一个 PDF 绘图画布。
2.  为科罗拉多州画一个矩形。
3.  设置将地图坐标转换为屏幕坐标的功能。
4.  画出城市和人口并贴上标签。
5.  将州的角注册为地理空间 PDF 坐标，以地理参考整个地图。

Python 代码的注释解释了每一步发生的事情:

```py
# Import the geopdf library
from geopdf import GeoCanvas
# Import the necessary Reportlab modules
from reportlab.pdfbase.pdfdoc import PDFString, PDFArray
# Create a canvas with a name for our pdf.
canvas = GeoCanvas('SimpleGIS.pdf')
# Draw a rectangle to represent the State boundary
canvas.rect(100, 400, 400, 250, stroke=1)
# DATA MODEL
# All layers will have a name, 1+ points, and population count
NAME = 0
POINTS = 1
POP = 2
# Create the state layer
state = ["COLORADO", [[-109, 37], [-109, 41], [-102, 41], [-102, 37]], 5187582]
# Cities layer list
# city = [name, [point], population]
cities = []
# Add Denver
cities.append(["DENVER", [-104.98, 39.74], 634265])
# Add Boulder
cities.append(["BOULDER", [-105.27, 40.02], 98889])
# Add Durango
cities.append(["DURANGO", [-107.88, 37.28], 17069])
# MAP GRAPHICS RENDERING
map_width = 400
map_height = 250
# State Bounding Box
# Use Python min/max function to get state bounding box
minx = 180
maxx = -180
miny = 90
maxy = -90
for x, y in state[POINTS]:
    if x < minx:
        minx = x
    elif x > maxx:
        maxx = x
    if y < miny:
        miny = y
    elif y > maxy:
        maxy = y
# Get earth distance on each axis
dist_x = maxx - minx
dist_y = maxy - miny
# Scaling ratio each axis
# to map points from world to screen
x_ratio = map_width / dist_x
y_ratio = map_height / dist_y
def convert(point):
    """Convert lat/lon to screen coordinates"""
    lon = point[0]
    lat = point[1]
    x = map_width - ((maxx - lon) * x_ratio)
    y = map_height - ((maxy - lat) * y_ratio)
    # Python turtle graphics start in the middle of   
    # the screen so we must offset the points so they     
    # are centered
    x = x + 100
    y = y + 400
    return [x, y]

# Set up our map labels
canvas.setFont("Helvetica", 20)
canvas.drawString(250, 500, "COLORADO")

# Use smaller text for cities
canvas.setFont("Helvetica", 8)

# Draw points and label the cities
for city in cities:
pixel = convert(city[POINTS])
print(pixel)

# Place a point for the city
canvas.circle(pixel[0], pixel[1], 5, stroke=1, fill=1)  

# Label the city
canvas.drawString(pixel[0] + 10, pixel[1], city[NAME] + ", Population: " + str(city[POP]))

# A series of registration point pairs (pixel x, 
# pixel y, x, y) to spatially enable the PDF. We only 
# need to do the state boundary.
# The cities will be contained with in it.
registration = PDFArray([
PDFArray(map(PDFString, ['100', '400', '{}'.format(minx), '{}'.format(maxy)])),
PDFArray(map(PDFString, ['500', '400', '{}'.format(maxx), '{}'.format(maxy)])),
PDFArray(map(PDFString, ['100', '150', '{}'.format(minx), '{}'.format(miny)])),
PDFArray(map(PDFString, ['500', '150', '{}'.format(maxx), '{}'.format(miny)]))
])
# Add the map registration
canvas.addGeo(Registration=registration)
# Save our geopdf
canvas.save()
```

# Rasterio

我们在本章前面介绍的 GDAL 库非常强大，但它不是为 Python 设计的。`rasterio`库通过将 GDAL 封装在一个非常简单、干净的用于栅格数据操作的 Pythonic API 中来解决这个问题。

本示例使用本章中 GDAL 示例的卫星图像。我们将打开图像并获取一些元数据，如下所示

```py
>>> import rasterio
>>> ds = rasterio.open("SatImage.tif")
>>> ds.name
'SatImage.tif'
>>> ds.count
3
>>> ds.width
2592
>>> ds.height
2693
```

# OSMnx

`osmnx`库结合了**开放街道地图** ( **OSM** )和强大的 NetworkX 库来管理用于路由的街道网络。这个库有几十个依赖项，它汇总这些依赖项来完成下载、分析和可视化街道网络的所有复杂步骤。

可以尝试使用`pip`安装`osmnx`:

```py
pip install osmnx
```

但是，由于依赖关系，您可能会遇到一些安装问题。在这种情况下，使用 Conda 系统更容易，我们将在本章稍后介绍。

以下示例使用`osmnx`从 OSM 下载一个城市的街道数据，并从中创建一个街道网络，然后计算一些基本统计数据:

```py
>>> import osmnx as ox
>>> G = ox.graph_from_place('Bay Saint Louis, MS , USA', network_type='drive')
>>> stats = ox.basic_stats(G)
>>> stats["street_length_avg"]
172.1468804611654
```

# Jupyter

当使用地理空间或其他科学数据时，您应该注意 Jupyter 项目。Jupyter Notebook 应用程序在网络浏览器中创建并显示笔记本文档，这些文档是人类可读且机器可执行的代码和数据。它非常适合共享软件教程，并且在地理空间 Python 世界中变得非常普遍。

在这里可以找到很好的 Jupyter Notebooks 和 Python 的介绍:[https://Jupyter-notebook-初学者-guide . read the docs . io/en/latest/what _ is _ Jupyter . html](https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html)。

# 伯爵夫人

Conda 是一个开源的包管理系统，使得安装和更新复杂的库变得更加容易。它可以与几种语言一起工作，包括 Python。Conda 对于建立库并测试它们非常有用，这样我们就可以在开发环境中尝试新事物。定制配置生产环境通常更好，但是 Conda 是一个原型化新想法的好方法。

你可以在[https://conda.io/en/latest/](https://conda.io/en/latest/)开始康达。

# 摘要

在本章中，我们调查了用于地理空间分析的 Python 专用工具。这些工具中的许多都包括绑定到我们在[第 3 章](03.html)、*地理空间技术景观*中讨论的库，用于特定操作的最佳解决方案，例如 GDAL 的栅格访问功能。我们还尽可能地包含了纯 Python 库，并且在接下来的章节中，我们将继续包含纯 Python 算法。

在下一章中，我们将开始将所有这些工具应用于地理信息系统分析。

# 进一步阅读

以下链接将允许您进一步探讨本章中的主题。第一个链接是关于 XPath 查询语言，我们使用它来使用 Elementree 过滤 XML 元素。第二个链接是 Python 字符串库的文档，这在本书中对于操作数据至关重要。第三，我们有`lxml`库，一个更强大、更快速的 XML 库。最后，我们还有 Conda，它为 Python 中的科学操作提供了一个全面、易于使用的框架，包括地理空间技术:

*   有关 XPath 的更多信息，请查看以下链接:[http://www.w3schools.com/xsl/xpath_intro.asp](http://www.w3schools.com/xsl/xpath_intro.asp)
*   有关 Python `string`模块的更多详细信息，请查看以下链接:[https://docs.python.org/3.4/library/string.html](https://docs.python.org/3.4/library/string.html)
*   关于 LXML 的文档可以在以下链接找到:[http://lxml.de/](http://lxml.de/)
*   您可以通过以下链接了解更多关于康达的信息:[https://conda.io/en/latest/](https://conda.io/en/latest/)