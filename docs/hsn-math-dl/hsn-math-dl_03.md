# 第二章：向量微积分

你们大多数人可能在过去接触过一些微积分，无论是在高中、大学还是大学里，可能希望再也不碰它。然而，微积分不仅是数学上最深刻的发现之一，它还在深度学习中发挥着至关重要的作用。

在本章中，我们将从介绍单变量微积分的核心概念开始，然后我们将继续学习多变量微积分，并将我们在多变量微积分中学到的内容扩展到向量微积分，并理解它与深度学习的关系。

本章将涵盖以下主题：

+   单变量微积分

+   多变量微积分

+   向量微积分

# 单变量微积分

从本质上讲，微积分无非是研究关系和变化。对微积分有深刻的理解将帮助你更好地理解深度学习算法的工作原理，并在作为实践者时帮助你让它们更有效地为你服务。

让我们继续了解一下微积分为什么是一个如此强大的工具。我们从单变量微积分开始，它涉及到那些接受单一输入并产生单一输出的函数。

# 导数

首先，让我们想象一条直线，方程如下：

![](img/aa7984ce-3f61-4ad0-8d7c-43312df9eb75.png)

在这个方程中，以下几点适用：

+   *y* 是 *x* 的函数，通常简写为 *f(x)*（这是我们在本书剩余部分将主要使用的符号）。在前面的方程中，输出值 *y* 依赖于输入值 *x*。

+   *m* 值是梯度，告诉我们直线的陡峭程度，或者说它的变化率（即 *x* 值的变化对 *y* 值的影响有多大）。

+   该值 ![] 告诉我们直线是向上还是向下移动。

+   该值 ![] 告诉我们直线相对于原点的位置是向上还是向下。

+   直线中的 *m* 和 *b* 值在整个过程中是常量。

现在你已经知道了直线方程的样子，你可能会想知道如何找到任意直线的方程。

我们首先选择两点，(*x[1], y[1]*) 和 (*x[2], y[2]*), 它们位于直线上，然后将它们的值代入公式中 ![]。在找到了 *m* 的值后，我们通过使用直线方程并代入 *m* 的值和其中一个 (*x, y*) 点的值，来求解 *b*。

好吧，这非常简单直接。然而，外面还有许多复杂的方程并不像这样直接——比如那些与曲线（非线性函数）相关的方程，如下图所示：

![](img/9952e1b9-a429-42ed-a380-4535e0eb0596.png)

想象一下几座山丘或骆驼背的图片。如果你沿着它们的表面描绘，你将得到一条曲线，正如你可能已经注意到的那样，它会上升，然后下降，再上升，过程不断重复。

从前面曲线的图像中，你可以很容易看出，梯度不是常数，正如在前面的直线示例中看到的那样。我们可以沿着曲线画出直线并计算它们的斜率来理解曲线如何变化。然而，比这种繁琐方法更简单的方法是存在的。

微积分的核心有两个概念，如下所示：

+   **微分**帮助我们理解函数输出相对于输入变化的变化量。

+   **积分**帮助我们理解在某些点之间输入变化的影响。

我们将首先深入研究微分。求导数的基本方程如下所示：

![](img/f9062c7a-3330-4e38-91dd-65eb66be81d8.png)

我知道这里有一些新的符号，看起来很复杂，但其实非常简单。这个方程做的是求函数*f*对于分母中的变量*x*的导数。这与我们之前看到的方程（我们用来计算直线的梯度）并没有太大区别。我们减去两个值，*f(x+h)* 和 *f(x)*，然后除以它们的差值，*h*。但![]与这个有什么关系呢？这告诉我们，我们希望曲线上的两点尽可能靠近，以便当我们在曲线上绘制梯度时，它看起来像是在某一点上的一条直线。这样，我们就能更好地可视化并理解变化的效果，正如下面的截图所示：

![](img/af7f06c7-704a-4aea-947a-d511e68a65e9.png)

请看以下示例：

![](img/8edacc96-ce9a-4bda-8048-509329c9b4ad.png)

既然我们已经理解了导数是什么以及如何为任何函数找到导数，让我们继续了解一些重要的微分规则。

# 求和法则

求和法则表明，两个函数的和的导数等于这两个函数的导数之和，具体如下方程所示：

![](img/e1bd1f1b-f172-4bfc-9801-3e118806dcab.png)

假设我们有![] 和 ![]。

从这个，我们可以看到以下方程，![]，与这个方程是相同的：![]。

# 幂法则

幂法则有助于找到变量具有指数的函数的导数。简而言之，你将幂次与变量前的常数相乘，并将幂次减小 1。让我们来看一个使用幂法则的例子 ![]，如下所示：

![](img/6dd27b33-072d-449f-887d-14860524e576.png)

请注意，并非每个函数都有导数，至少在该函数的定义域内没有。

有些函数——例如 ![] 或 ![] ——不像我们之前看到的那些函数那样简单。函数 ![] 在 *x = 0* 处不可导，因为其值是未定义的。这被称为**不连续性**。

同样适用于 ![]；然而，*e*（即**欧拉常数**）具有一个非常有趣的特性，即该函数等于其导数——也就是说， ![]。

# 三角函数

在高中或大学，你可能学习过三角学，并遇到过正弦、余弦和正切函数。对我们来说，更重要的是正弦和余弦函数，你将经常遇到这两者，我们将在这里进行讨论。这些函数可以在以下图片中看到：

![](img/9180e689-9902-4707-8156-29175f938c29.png)

在这里，正弦是 ![]，余弦是 ![]。

正弦和余弦函数是相关的，导数将向我们展示这种关系。

如果 ![]，则 ![]。然而，如果 ![]，则 ![]。

导数形成一个循环，我们可以通过以下方式看到：

![](img/02d28816-e09e-49c6-b82e-180903528446.png)

# 一阶和二阶导数

既然我们知道如何找到函数的导数，那么接下来需要知道的是，我们可以对函数进行多次求导。

如我们所知，第一导数给出了函数在任意给定点 (*x*) 处的梯度（切线的斜率）——换句话说，就是该曲线的高度（即 *y* 或 *f(x)*) 是在增加还是在减少。正斜率告诉我们 *f(x)* 随着 *x* 增加而增加，负斜率告诉我们 *f(x)* 随着 *x* 增加而减少，斜率为 0 则告诉我们无法确定曲线的方向，只能推测它可能处于转折点（局部最小值或局部最大值）。这可以写成如下形式：

+   如果 ![]，则 *f(x)* 在 *x = t* 处是递增的。

+   如果 ![]，则 *f(x)* 在 *x = t* 处是递减的。

+   如果![]，那么 *x=t* 是 *f(x)* 的一个临界点。

例如，设![]。该函数的导数如下所示：

![](img/a7b22566-1a2e-4aff-82aa-6c6f099c85c4.png)

在 *x = 0* 时，导数为 9，这告诉我们函数在这一点是递增的。但在 *x = 1* 时，导数为-3，说明函数在这一点是递减的。

二阶导数是函数导数的导数。我们将其表示为![] 或 ![]。如同之前，第一导数告诉我们函数是增是减，二阶导数则告诉我们第一导数的增减情况。

如果二阶导数为正，那么随着 *x* 的增大，第一导数也在增大；如果二阶导数为负，则随着 *x* 的增大，第一导数在减小。

为了帮助我们可视化，当二阶导数为正时，曲线在某点是向上的凹曲线（抛物线朝上开口）；而当二阶导数为负时，曲线是向下的凹曲线（抛物线朝下开口）。正如之前所说，当二阶导数为零时，我们不会获得新的信息。这个点可能是局部最大值、局部最小值或拐点。可以写成如下形式：

+   如果![]，那么在 *x=t* 时，*f(x)* 是向上的凹曲线。

+   如果![]，那么 *f(x)* 在 *x=t* 处是向下凹的。

+   如果![]，那么在 *x=t* 处，我们无法获得关于 *f(x)* 的新信息。

例如，我们可以对之前使用的相同函数求二阶导数，结果如下：

![](img/58fa95b6-5228-49f2-8b75-5282c90782eb.png)

在 *x = 0* 时，二阶导数为-24，这告诉我们函数在这一点是向下凹的。但在 *x = 2* 时，二阶导数为 24，说明函数在这一点是向上凹的。

之前我们学到，当 *x* 是函数的临界点时，我们在该点无法得到关于函数的新信息，但我们可以用它来判断该点是局部最大值还是局部最小值。这些规则可以写成如下形式：

+   如果![] 和 ![]，那么 *f(x)* 在 *x=t* 处有一个局部最小值。

+   如果![] 和 ![]，那么 *f(x)* 在 *x=t* 处有一个局部最大值。

+   如果![] 和 ![]，那么在 *x=t* 处我们无法获得关于 *f(x)* 的新信息。

# 积分法则

积分法则为我们提供了一种直接的方法来求两个函数的乘积的导数。假设我们有两个任意函数，*f(x)* 和 *g(x)*，并将它们相乘。所以，![]。其导数为 ![]。

让我们更详细地探讨一下，看看它是如何工作的。请看下面的方程：

![](img/0cf58109-75ff-4cf3-9018-aff26a026420.png)

我们可以将导数重写为如下形式：

![](img/77772ea4-8854-4058-92b8-a4e79825b65b.png)

这可以进一步简化为 ![]，其结果与之前相同。

# 商法则

商法则使我们能够求出一个函数与另一个函数相除时的导数。这可以通过积分法则推导出来。和之前一样，我们取两个函数 *f(x)* 和 *g(x)*，但现在我们将它们相除。所以，![]。其导数为 ![]。

假设我们有 ![] 和 ![]。那么我们得到如下结果：

![](img/64cf49f5-d145-4b82-95ab-588e93df7968.png)

通过求出 *f(x)* 和 *g(x)* 的导数，并将它们代入前面的方程，我们得到以下结果：

![](img/68168e9d-53b4-44df-a5cf-bf27ba9af5f5.png)

如果我们扩展它，就能求出导数。

# 链式法则

链式法则适用于输入是另一个函数的函数。我们考虑 ![]，通常写作 ![]，表示 *f* 是 *g* 的 *x* 的函数。这意味着 *g(x)* 的输出将成为函数 *f* 的输入。

这个导数将写成如下形式：

![](img/d4b250a5-7a46-4a8a-8bb9-e97f84b43d46.png)

这与 ![] 相同。

例如，假设我们有 ![] 和 ![]。我们对这两个函数进行求导，得到 ![] 和 ![]。

将这个代入之前的公式，我们得到 ![]。

# 反导数

我们现在知道了什么是导数以及如何求导，但现在假设我们知道了人口 (*f*) 的变化率 (*F*)，并且我们想找出某一时刻的具体人口数量。我们需要做的是找到一个函数 *F*，使得它的导数是 *f*。这就是所谓的**反导数**，我们正式定义它为，如果在 ![] 上，*f* 的反导数 *F* 满足 ![] 对所有 ![](img/f213a601-0421-4be1-865d-053761e776a4.png) 成立。

假设我们有一个函数![]，然后是![]（其中*c*是某个常数），由此我们可以确认![]。

以下表格显示了我们将经常遇到的一些重要函数及其反导数：

| **函数** | **反导数** |
| --- | --- |
| ![](img/4a4df447-7c22-476e-bc54-a869bff13d1b.png) | ![](img/264a83db-2125-48f5-8e56-19423fee8167.png) |
| ![](img/d0ecb407-ec75-4cde-b9d5-7394b87bc069.png) | ![](img/6e2e7819-764f-4fe8-a372-4ae76a498ba3.png) |
| ![](img/b8e0a0d0-6ae2-4e2f-90d1-7a522cb1760b.png) | ![](img/f7c0b9fa-b845-4564-b1ff-48f15b6c940c.png) |
| ![](img/0d2197f2-cf35-4034-a2dc-41a80cf1390e.png) | ![](img/a500fee4-160c-411c-ada0-8c148a350a8a.png) |
| ![](img/df9ccc18-4b6d-4638-a5af-341e610765d5.png) | ![](img/28b6ebf4-c52f-4b04-aae8-b8f757731794.png) |
| ![](img/1e01b7fd-74b6-40fa-8017-e8f21c41527d.png) | ![](img/41a34e31-dd91-48a6-b360-9111145b56dd.png) |
| ![](img/a446e722-0db7-4983-bd67-dfd732784be7.png) | ![](img/c1534e87-0946-4590-92a4-c6045ce6ecad.png) |
| ![](img/557e24dd-070d-4a15-add4-c472d34ebe69.png) | ![](img/3a9b6fd3-1f92-420c-9cdd-dc6297982a86.png) |
| ![](img/c6369ea0-9427-4ef9-9c2c-78be0b132426.png) | ![](img/3a4c33ac-1018-406f-89f1-d9bd893a87d9.png) |

假设我们有以下函数：

![](img/b57b3099-0063-40f6-8785-6ba53e65d1a1.png)

我们想要找到它的反导数。我知道这看起来可能是一个复杂的方程，但通过使用前面的表格，我们可以让这一过程变得非常简单。让我们看看如何做。

首先，我们将函数重写为如下形式：

![](img/050a81e0-a8a5-46ee-8951-0c1228927d8e.png)

所以，反导数如下所示：

![](img/f5dd52fc-900f-4d4f-b519-4575004b1bde.png)

为了简化，我们将其重写如下：

![](img/2b074ce1-0d0f-4dc5-95aa-f799edb57054.png)。

就是这样。

现在你可能会想知道我们是否能找到*c*的值，如果能，应该怎么找。让我们通过另一个例子，看看如何操作。

假设我们有一个是二阶导数的函数，我们想找到反导数的反导数——也就是原始函数。我们有以下内容：

![](img/d0755649-4af0-4fbc-ba12-3d1878d463cf.png) 和 ![](img/8bff1025-e006-49fd-9e76-2d0776b1daec.png) 和 ![](img/e9232ae9-dd37-4c8a-9435-5f9068d5f7e3.png)

然后，第一个反导数如下所示：

![](img/5f4ed156-2651-484a-aabd-f5f2fc8d1c64.png)

所以，二阶反导数如下所示：

![](img/2ff2b47a-ff55-49cc-8417-3640de5e3ab6.png)

在这里，我们想要找出*c*和*d*的值。我们可以通过代入前面的值并解出未知数，简单地做到这一点，如下所示：

![](img/9b78cb2c-bf66-43f0-9081-8920db7503f7.png)；因此，![](img/0458a1e5-6874-4de9-9f04-541ba171cdd9.png)

我们还可以这样做：

![](img/7370788f-724f-4bb0-99d0-fbf3345dee0e.png)；因此， ![](img/2fc29d8e-c90d-439e-9ef2-2ce8eb6bfd1a.png)

因此，我们的函数看起来像这样：

![](img/80ea4eb4-1eed-4d16-a511-ec89e75d792c.png)

# 积分

到目前为止，我们已经学习了导数，这是一种提取函数变化率的信息的方法。但正如你可能已经意识到的，积分是之前问题的逆过程。

在积分中，我们找到曲线下方的面积。例如，如果我们有一辆车且我们的函数给出了它的速度，曲线下方的面积将告诉我们它在两个点之间行驶的距离。

假设我们有如下曲线 ![]，曲线下方在 *x = a*（下限）和 *x = b*（上限，亦可写作 [*a, b*]）之间的面积为 S。那么，我们得到以下公式：

![](img/15d05293-5a13-481b-9954-f5c81029bfde.png)

曲线的图示如下：

![](img/1e4dc6a3-a3cb-43d3-aa51-20234d07d01c.png)

这也可以写成如下形式：

![](img/ee572d5a-5e62-46f1-8022-9a8b29b23c20.png)

在前面的函数中，以下适用：![]，且 ![](img/17457674-cd90-4a0a-8e80-fa5b0ac06bea.png) 位于子区间 ![] 中。

该函数看起来像这样：

![](img/d68f33bd-9e7d-4ca3-beae-281243535f89.png)

积分给我们提供了一个关于曲线下方面积的近似值，以至于对于某些 ε > 0（ε 假定为一个很小的值），适用以下公式：

![](img/76c13e50-7190-4a54-910c-3c77e438e6ea.png)

现在，假设我们的函数既在 *x* 轴上方也在 *x* 轴下方，因此它既有正值也有负值，如下所示：

![](img/31767c94-5e84-48a4-9460-17f2cdde39ca.png)

如我们从前面的截图中看到的，*x* 轴上方的部分 (*A[1]*) 具有正面积，而* x* 轴下方的部分 (*A[2]*) 具有负面积。因此，以下公式适用：

![](img/6f180dcc-26b4-4780-9dd7-dc9668edd17a.png)

与和的运算是评估积分的重要部分，理解这一点需要一些新的和的规则。看下面的例子：

+   ![]

+   ![]

+   ![]

+   ![]

+   ![]

+   ![]

+   ![]

现在，让我们探讨积分的一些重要属性，这将帮助我们在深入本章时更好理解。看下面的例子：

+   ![]

+   ![](img/d5b3a394-1c0a-46d0-9b82-fac1f45547ce.png)，当 ![]

+   ![]，其中 *c* 是常数

+   ![]

+   ![]

+   ![]

现在，假设我们有一个函数 ![]，它看起来是这样的：

![](img/0fbf3c73-00a3-494b-bf14-dc09907579df.png)

然后，我们得到以下性质：

![](img/e734a2be-251f-4190-8a3d-775cc1d80941.png)

这个性质只适用于连续且具有相邻区间的函数。

# 微积分基本定理

微积分基本定理是微积分中最重要的定理，名字也非常恰当，因为它建立了微分学和积分学之间的关系。我们来看看是如何做到的。

假设 *f(x)* 在 [*a, b*] 上是连续的，并且在 (*a, b*) 内可导，且 *F(x)* 是 *f(x)* 的原函数。那么，我们得到以下结果：

![](img/a6711a17-581a-4a77-ada8-3f44f91423fc.png)

让我们稍微重写一下前面的方程，使它变成以下形式：

![](img/5e704612-aa00-44c4-84a9-17c644d2ed64.png)

我们所做的只是将 *x* 替换为 *t*，并将 *b* 替换为 *x*。而且我们知道 *F(x)-F(a)* 也是一个函数。由此，我们可以推导出以下性质：

![](img/d357ce0d-925c-4388-80c6-9ac8bbb38341.png)

我们可以推导出前面的性质，因为 *F(a)* 是常数，因此它的导数为零。

通过稍微改变我们的视角，我们得到以下函数：

![](img/469c5399-2588-4c5d-805e-5e480168fe10.png)

因此，我们得到 ![](img/d74d4c9a-2d0b-4c93-b890-b9e9bd4007cd.png)。

总结来说，如果我们对函数 *f* 进行积分，然后再对其求导，我们最终会得到原函数 *f*。

# 代换法则

显然，能够找到一个函数的原函数是非常重要的，但反积分公式并没有告诉我们如何计算每种类型的积分——例如，当我们遇到如下的函数时该如何处理：

![](img/482474f9-c0c3-4c3e-a415-e46d0fac49b2.png)

这并不像我们之前看到的例子那么简单。在这种情况下，我们需要引入一个新的变量来帮助我们，使问题变得更加可管理。

让我们设定一个新的变量 *u*，并且 ![](img/19f8ee20-b90e-4fd6-8f10-e8cb83d42de4.png)，那么 *u* 的微分就是 ![](img/e6006c36-cbdf-4c48-abd6-1774b725a865.png)。这将问题转化为以下形式：

![](img/388f09d4-e250-4305-93f8-23cc5c3e9ac5.png)

这显然要简单得多。它的原函数变为以下形式：

![](img/2a27ca99-9c6e-46a8-9f81-88c90fe53fcd.png)

然后，代入原始值 ![](img/88197e12-4ec6-4db2-8782-5942162d3233.png)，我们得到以下结果：

![](img/1157bd53-54d2-4bac-a00b-54575380879b.png)

就这样。

这个方法非常有用，当我们遇到以下形式的问题时，它是有效的：

![](img/76b23ba9-216c-4318-8699-4b812d91d773.png)

如果 ![]，那么以下公式适用：

![](img/91b4ed55-cb15-4367-8a72-e33acc5b266c.png)

那个方程可能看起来对你来说有些相似。它应该是的。这是微分法中的链式法则。

# 曲线之间的面积

我们知道，积分让我们能够找到两点之间曲线下方的面积。但现在，假设我们想找到两个图形之间的面积，如下图所示：

![](img/823a8488-5a2d-45ce-93ea-3c2341ae7f3f.png)

我们的区域*S*，如图所示，位于曲线*f(x)*和*g(x)*之间，夹在两条竖直线*x = a*和*x = b*之间。因此，我们可以将曲线之间的面积近似为以下公式：

![](img/faaa6614-1128-4790-ae3e-89e5f53ee617.png)

我们可以将其重写为如下积分形式：

![](img/29533d2e-fb17-493e-b8c1-c20174201a75.png)

为了更好地可视化并形成直觉，我们有以下图像：

![](img/dea92838-066b-4ec4-be9f-1ed245297494.png)

# 分部积分法

到目前为止，我们知道每一个微分法则都有对应的积分法则，因为它们之间存在反向关系。

在之前的微分部分，我们遇到了乘积法则。在积分中，对应的法则称为分部积分法。

回顾一下，乘积法则表明，如果*f*和*g*是可微的，则以下公式适用：

![](img/c88be3f5-0b11-41ea-b631-9ca184eb0761.png)

因此，在积分时，这变成了以下形式：

![](img/f981a162-de56-414f-b4d6-197d3cb77b84.png)

我们可以按如下方式重写这个公式：

![](img/81725a0d-9c73-4247-877d-7916f0731a05.png)

我们可以将这个公式与微积分基本定理结合，得到以下方程：

![](img/cd0eb6dd-8f53-4fea-b151-6ab66c34f745.png)

我们可以利用这一点来计算区间[*a, b*]之间的积分。

**注意**：术语 ![ ]仅表示我们将值*b*代入*x*并进行计算，然后从*a*的计算结果中减去它。

我们还可以使用之前的替代法来简化分部积分法中的积分计算。我们进行 ![] 和 ![]，然后，微分是 ![] 和 ![]。于是，公式变为：

![](img/3ceb179d-9272-41d8-807e-215833675629.png)

# 多变量微积分

现在，我们已经学习了单变量微积分并理解了微积分的基本概念，是时候深入一点，看看多变量微积分了。多变量微积分与单变量微积分有许多相似之处，唯一的区别是——正如其名字所示——在这里，我们将处理接受两个或更多变量作为输入的函数。

多元微积分在现实世界中被广泛应用，几乎所有领域和行业都有涉及，从医疗保健到经济学，再到金融、机器人学、航空航天等等。一个例子是，尝试模拟空气如何绕过飞机，以了解飞机的空气动力学性能以及飞机机身设计在哪些方面可以改进。这是我们在单变量微积分中无法做到的。

# 偏导数

偏导数是我们用来求解依赖于多个变量的函数的导数的方法，这个导数是关于其中一个变量的偏导数，同时保持其他变量不变。通过这种方法，我们可以了解一个函数是如何受单一变量影响的，而不是所有变量的影响。假设我们在建模某个商品的价格，并且该价格依赖于多个不同的因素。我们可以逐个改变每个变量，来确定这种变化会如何影响商品的价格。这与求总导数不同，总导数是所有变量都变化时的导数。

多元函数可以包含任意多个变量，但为了简化问题，我们将以一个包含两个变量的函数为例，如下所示：

![](img/49317bbb-48f4-47d2-89f3-c8d8be7d3591.png)

这个函数看起来比我们之前处理的要复杂得多。让我们分解一下。当我们对一个函数关于 *x* 求偏导数时，我们得到的是 *z* 随着 *x* 变化的变化率，同时保持 *y* 不变。对其他变量求导时也是如此。

让我们直观地想象 *xy* 平面（一个平面）作为可接受的输入点集。这些点可以作为我们函数的输入。输出 *z* 可以理解为我们距离 *xy* 平面的高度。

让我们首先对函数关于 ![](img/0b2dac96-00d5-4af1-87b9-d4a54051ecba.png) 求导，如下所示：

![](img/0f8712f5-2b14-4290-a5c8-baac7fcec4d7.png)

这给我们带来了以下结果：

![](img/04024c91-c5ae-4c9a-9fbf-02b9d01e66ad.png)

现在，我们将对 *y* 进行求导，如下所示：

![](img/fbd57942-7492-4165-8e3e-f3b179a10a45.png)

这给我们带来了以下结果：

![](img/3501ca6d-2b68-4800-a026-353cb16c51b7.png)

正如我们之前所见，在单变量微分中，我们可以对函数求二阶导数（当然是合理的情况下），但在多元微积分中，我们还可以进行混合偏导数的求解，如下所示：

![](img/655b50f4-ea62-490e-9788-c5dad3ab8f08.png)

你可能已经注意到，当我们进行混合偏导数时，变量的顺序并不重要，无论我们是先对 *x* 求导，再对 *y* 求导，还是反过来，结果都是相同的。

我们还可以以另一种形式来写这个表达式，这种形式通常更为方便，并且我们将在本书中继续使用这种方式。函数如下所示：

![](img/685ffa19-a0fd-4d99-ba56-8fbe912ad858.png)

# 链式法则

让我们取一个任意的函数 *f*，它以变量 *x* 和 *y* 为输入，并且某一个变量发生变化，从而得到![]。利用这一点，我们可以通过以下方式找到 *f* 的变化：

![](img/b77f4dbf-7a64-4ed0-b736-45daeeff4a34.png)

这将我们带入如下方程：

![](img/85c8797e-e2af-4dbf-9621-fd060d37d0c3.png)

然后，通过取函数的极限![]，我们可以推导出偏导数的链式法则。

我们将其表示如下：

![](img/b0459ebf-42e3-4555-ab42-fd7aae96b3ed.png)

我们现在通过一个额外的小量（*t*），其中 *x* 和 *y* 依赖于 *t*，来除以这个方程，以找到沿![]的梯度。前面的方程变为如下：

![](img/866e0098-a54a-4cef-bc69-bf8d0e0e19bf.png)

我们之前遇到的微分规则在这里仍然适用，并且可以扩展到多变量的情况。

# 积分

和单变量情况一样，对于依赖多个变量的函数，我们也有反导数和积分。之前我们学到，积分给出了曲线![]下的面积，位于区间[*a, b*]之间。现在，我们不再寻找区间上的面积，而是寻找图形![]下的体积，位于某个区域内。方程如下：

![](img/540405b4-b445-4ccf-9ac9-c04d3b348304.png)

在上面的方程中，*R* 是 *xy* 平面上的一个区域。可以将 *R* 看作被切割成多个小矩形区域，记为 Δ*A*。然后，我们可以按如下方式近似体积：

![](img/dc69db3c-edf2-47e2-885d-ec0b44dd7ecd.png)

此外，![;]因此，![]。

**注意**：双重积分并不等同于对积分进行两次计算。

现在，我们不再计算小矩形区域，而是将区域划分为宽度为 Δ*x* 的长且薄的切片。听起来熟悉吗？它应该很熟悉，因为这和我们在单变量积分中做的非常相似。

现在让我们分配![]，于是我们的积分变成了如下形式：

![](img/ad381372-6c96-4d98-ba5a-b0ec5d05a8d5.png)

然后，我们将结果乘以 Δ*x*。

现在我们可以将积分重写为如下形式：

![](img/c7688812-32f9-45d9-be9c-ad07a8d3507e.png)

这里，![] 和 ![]。

假设我们有一个函数![]，并且区域的边界定义在![]和![]上。那么，积分为：

![](img/9922169b-a119-4039-852d-4da4e59c96c7.png)

通过计算内积分，我们得到如下结果：

![](img/17115c30-bb32-4e01-85fb-d4485bc65613.png)

通过计算外部积分，我们得到如下结果：

![](img/60e815a1-85d4-4c46-962f-778e95704725.png)

就这样。这就是我们如何找到多变量函数的积分。

现在假设我们有一个函数 ![]，我们在区域内对其进行积分，其中 ![] 和 ![]。然后，我们得到如下结果：

![](img/1889bd7c-a91e-4118-b998-bf7b2c3bd4b5.png)

这是分配律的直接结果。

我们迄今为止所计算的区域是矩形的，但这不一定总是这样。如果区域是一个不规则的形状，那么每一片的积分限将会有所不同。

解决这个问题的最佳方法是将其写成我们没有进行积分的变量的函数。

假设我们有 ![]，且它存在的点集是 ![]，这告诉我们 ![] 和 ![]。现在我们可以写成以下形式：

![](img/031bf82e-ac78-4220-8c64-3fef3dfa3fad.png)

如我们所见，*x* 定义在区间[*a, b*]上，*y* 介于两条* x*的函数之间——**g(x)** 和**h(x)**。

我们知道从三角学，特别是毕达哥拉斯定理，*y*的最小值将是 ![]，最大值将是 ![]。

我们现在可以继续重写前面的一组点，如下所示：

![](img/f3109bfc-d343-4a60-9d9c-9856c8c2291f.png)

这样写和改变写法，将单位圆盘切成了间隔固定宽度的竖直线。

然后，我们的积分变成了这样：

![](img/35f179f9-865d-45eb-8d0d-af813394bdf8.png)

由于 ![]，我们可以像这样重写前面的积分：

![](img/e91a51cf-e4fe-4036-b05a-6088a9896e36.png)

然后，我们通过计算内积分，再计算外积分，像这样继续：

![](img/3ad754b2-0a8d-4517-9644-bf842e7a1999.png)

我们从圆的面积中知道这是正确的： ![]

双重积分的一些重要性质如下所示：

+   ![]

+   ![]，其中*c*是一个常数

+   ![] 如果*R*可以分成两个区域，*R[1]* 和 *R[2]*

+   ![] 当 ![] 对于所有 ![] 成立

现在，假设我们有一个带有球形顶部的圆柱体，如下图所示，我们想要求它的体积。球体下方的区域是![]，圆柱体内部是![]，并且在*z = 0*之上，如下所示：

![](img/e2000541-b7aa-4343-acc7-5c4276b28fad.png)

我们知道，求一个区域的体积的方法如下：

![](img/18738304-ab2a-4a7f-9668-f5cbeeeaa0f3.png)

为了计算这个积分，我们首先将球体的方程重写为![]，并且*x*和*y*被定义的点集是![]。

我们重写我们的点，并用极坐标系中的*θ*和半径*r*来定义区域的边界，使得方程看起来如下：

![](img/918eabda-a108-417e-bd45-5076e30c61d2.png)和![](img/8a539c2d-00c4-4a1e-855d-84060779733f.png)

现在，我们可以重写*z*，如下所示：

![](img/b159ca1b-4e61-4b5f-9c49-219ba148608f.png)

所以，体积如下所示：

![](img/684ef696-1257-424e-8218-3b95076d6d98.png)

通过计算内外积分，我们得到以下结果：

![](img/8f3b3e61-d4c0-42c4-8e4f-25a9bdac6c97.png)

我们现在知道如何在![](img/be1a346a-3930-4601-831f-2b50356df49d.png)中对区域进行积分并找到图形下的体积。但是当我们有![](img/d3408957-b006-4916-b42b-a1556c39659d.png)中的区域时怎么办呢？之前我们对二维区域使用了二重积分；所以，自然，对于三维区域，我们将使用三重积分。我们将其写成如下：

![](img/6643df1f-06f4-46f8-a9ee-6069c228ee26.png)

假设现在我们积分的区域由![]、![]和![]定义。三重积分变成如下：

![](img/d74823b3-0240-49f9-8da5-9615d786ab8c.png)

之前我们遇到了一种叫做替换的方法，我们将我们的函数设为一个变量，这样就更容易找到导数。我们在积分中也可以做同样的事情。

假设我们有以下积分：

![](img/85a603b4-17c1-4b2b-8a6a-2d88a366688f.png)

我们可以设![]，然后积分变成这样：

![](img/c181f01c-467b-4770-a84d-068f1cf34219.png)

现在，让我们继续研究二重积分，看看如何转化区域以便我们更容易处理。为此，我们需要请出我们熟悉的老朋友——雅可比矩阵来帮忙。

作为复习，假设我们有![]和![]。然后，雅可比矩阵如下所示：

![](img/bcfc4f85-904a-43c4-9e5f-36f41780011f.png)

此外，请记住，雅可比矩阵也可以被视为行列式。因此，我们可以将前面的方程重写为：

![](img/158f1b30-ba6b-42f6-af29-0b600946443e.png)

假设现在我们想对![]在 *R* 上进行积分。现在，让我们做出![]和![]，并将我们的区域重新命名为 *S*。积分现在看起来像这样：

![](img/5cfe91ee-3bab-4679-b065-2b49edc0ce38.png)

从中我们可以很容易地观察到![]。

现在让我们继续讲解三重积分。假设我们有一个函数![]，并且我们想对其在 *R* 上进行积分。我们首先做出![]，![]，和![]，并像之前一样将新区域重新命名为 *S*。雅可比矩阵随后是以下形式：

![](img/54edd27c-3db3-427f-b140-3321e8e42cc0.png)

三重积分现在看起来像这样：

![](img/c715df27-41f9-45ca-a206-0bca0ac3fa5e.png)

我们现在已经对多变量微积分有了足够的理解，准备深入探索向量微积分的精彩世界。

# 向量微积分

当我们对关于向量的函数求导时，我们需要更加细心。如我们在第二章《线性代数》中看到的那样，向量和矩阵是不可交换的，并且与标量的行为大不相同，因此我们需要找到一种不同的方式来对它们进行微分。

# 导数

之前，我们看到通过使用变量在商中的极限来对函数求导。但如我们所知，向量与标量不同，我们不能对向量进行除法运算，这就需要对向量值函数进行新的定义。

我们可以将向量函数定义为一个函数！[](img/baaa0c31-2440-4d95-af1c-0dc465738402.png)，也就是说，它接受一个标量值作为输入，并输出一个向量。因此，*F* 的导数定义如下：

![](img/73f17a07-fd96-41ff-84e2-9a01df882f69.png)

在前面的方程中，δ*x* 是对 *x* 的小扰动。此外，*F* 只有在以下条件下才可微分：

![](img/28debd64-9863-4c3d-8cdc-3f641b306439.png)

我们还可以将前面的微分写成如下形式：

![](img/2dd006ae-a223-4d7c-b707-10af669d9952.png)

通常，我们按分量对向量进行微分，因此，前面的微分变为：

![](img/b619f706-e26f-4434-8d29-12113e2a71e9.png)

这里的 *e[i]* 是一个正交归一基向量。

一些向量微分的规则如下所示：

+   ![]

+   ![]

+   ![]

+   ![]

+   ![]

+   ![]

我们之前知道，使用极限的概念来求解一个函数的导数。那么，接下来我们看看如何求解一个向量的极限。我们在这里使用范数的概念。我们说 ![]，因此，如果 ![]，那么当 ![](img/e4684acc-c400-4b7a-80b8-611c79274c47.png)， ![]。

通常情况下，导数是在所有可能的方向上计算的。但如果我们只想在一个特定的方向 *n*（单位向量）上找到导数呢？那么，假设 *δr = hn*，我们得到如下结果：

![](img/732b2bd0-bc2a-49e1-8caf-9fcbc4476d77.png)

从中我们可以推导出方向导数如下：

![](img/38e35a69-562b-4d7f-97f1-35dbaaca52ea.png)

这给出了 *f* 在这个方向上的变化率。

假设现在我们有 *n = e[i]*。那么，我们的方向导数变为以下：

![](img/851f69d9-e6e9-4e64-a869-2d51ffbbf41b.png)

因此，我们得到以下结果：

![](img/c6dda802-9d49-4dd7-b1ff-995d80d6b7da.png)

因此，差分性条件现在变为以下：

![](img/9302ca7d-1848-4c3f-a19f-72a21777a9c7.png)

我们可以用微分符号表示如下：

![](img/33b24343-477b-486d-9448-47805a69b0ce.png)

这看起来与我们之前遇到的情况非常相似。它是偏导数的链式法则。

现在让我们取一个函数 ![]，它接收一个向量输入 ![](img/f79cb4fb-e733-4673-9198-c8f53ede5072.png)，使得 ![]。该函数的偏导数表示如下：

![](img/32b5cfe8-6268-4037-b5da-edc66ab598de.png)

然后我们可以将其整体表示为一个 ![](img/8fcea3db-709d-4595-9e05-a3d9a731be73.png) 向量，我们写作如下：

![](img/9b85addc-9c3d-4ea8-9cd6-14a49fd41342.png)

让我们更进一步，设想一个由 *m* 个不同标量函数组成的向量函数，这些函数接受向量 *x* 作为输入。我们将其写为 *y = f(x)*。

展开 *y = f(x)*，我们得到以下：

![](img/ccc9f4ee-acbf-4f9f-a4d7-d0886d56c6f3.png)

让我们简要回顾一下雅可比矩阵。正如你所见，它仅仅是一个包含所有早期向量函数的偏导数的 (*m×n*) 矩阵。我们可以看到它长什么样：

![](img/0efbc5a3-52f8-4eee-a0dc-451ea275d204.png)

让我们进一步扩展这个定义到多个函数。这里，我们有 *y*，它是两个函数 *f* 和 *g* 的和，每个函数接受一个不同的向量输入，从而得到以下结果：

![](img/6152b8e1-6d89-403f-be4f-0fabe95214bb.png)

为了简化，*f*、*g*、*a* 和 *b* 都是 *n* 维的，这会导致一个 *n×n* 矩阵，如下所示：

![](img/c3f6b60b-97de-4559-8739-74af67f45ef5.png)

我们可以对这个矩阵分别关于 *a* 或 *b* 求导，并找出每个的雅可比矩阵。

通过对 *a* 求导，我们得到以下结果：

![](img/577451d4-d89d-4fb6-aeb6-4d734198545a.png)

通过对 *b* 求导，我们得到以下结果：

![](img/55ccdff4-7e3c-4f36-8d35-883c3d9eefc2.png)

我们可以对两个函数进行任何类型的逐元素操作。

如同单变量和多变量微积分中一样，我们也有向量微分的链式法则。

让我们考虑两个向量函数的组合，它们接受一个向量输入 ![]，因此其梯度将是 ![]，这看起来与我们之前遇到的相似。让我们进一步展开，如下所示：

![](img/cd154d02-0eb4-451c-8ff1-afe98b0df49e.png)

在大多数情况下，对于雅可比矩阵中的参数，其中 *i ≠ j*，参数往往为零，这导致我们得出以下定义：

![](img/86ebc192-bf82-472a-b81e-238560ec44e6.png)

因此，以下适用：

![](img/df26c76c-3949-4c97-848f-e78e0e9b4c0f.png)

如我们所见，这是一个对角矩阵。

# 向量场

我们将向量场定义为一个函数 ![](img/c9fd80cb-58a3-484e-9c45-059d1bba46c1.png)，只有在以下条件下，它才能被微分：

![](img/1672512e-0333-4a77-8850-d37aa0227177.png)

这里，![](img/1e791f2f-4bed-4985-86bc-786ed37144cf.png) 是 *F* 的导数。

我们可以将 *M* 看作是一个将一个向量映射到另一个向量的矩阵，现在我们可以将 *F* 表示为：

![](img/40ae9d86-ade8-4a53-86f3-bdb7cb4ba1a8.png)

这里， ![] 对所有 ![] 都成立，因此，*F* 的导数是：

![](img/fc8e832a-f37e-4158-bd5b-859428967f5b.png)

在单变量和多变量微积分的早期，我们学习了链式法则的重要性，因此我们在向量微积分中也有它，这不足为奇。其原理如下：

假设我们有 ![] 和 ![]，并且坐标是 ![]，![] 和 ![]。然后，链式法则给出了以下结果：

![](img/2ddd83c8-d02a-4cb0-9c8a-0a629c4c4afc.png)

我们可以将其改写为矩阵形式，如下所示：

![](img/dac75952-d318-486e-b1c1-e0b3e6683ce4.png)

# 逆函数

逆函数是一类非常有趣的函数，如果我们有两个函数，并将它们互相作用，我们会得到恒等式。在数学上，我们将其定义如下：

假设我们有![]。那么，只有当![]时，它们才是反函数。例如，我们可能有![]和![]。因此，![]，这告诉我们![]。

这是另一个很酷的属性：

![](img/106625a0-72e6-40d9-bf0f-df5310a346f0.png)

# 总结

通过这一部分，我们结束了微积分的章节。到目前为止，我们已经学习了单变量、多变量和向量微积分的基本概念，以及它们为何如此有用。

在下一章节中，我们将进入概率与统计，并探讨我们在线性代数和微积分中学到的知识如何在这些领域中应用。
