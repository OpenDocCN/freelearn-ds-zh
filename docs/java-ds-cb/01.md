

# 一、获取和清理数据

在本章中，我们将介绍以下配方:

*   使用 Java 从分层目录中检索所有文件名
*   使用 Apache Commons IO 从分层目录中检索所有文件名
*   使用 Java 8 从文本文件中一次性读取内容
*   使用 Apache Commons IO 一次从文本文件中读取所有内容
*   使用 Apache Tika 提取 PDF 文本
*   使用正则表达式清理 ASCII 文本文件
*   使用 Univocity 解析逗号分隔值文件
*   使用 Univocity 解析选项卡分隔值文件
*   使用 JDOM 解析 XML 文件
*   使用 JSON.simple 编写 JSON 文件
*   使用 JSON.simple 读取 JSON 文件
*   使用 JSoup 从 URL 中提取 web 数据
*   使用 Selenium 从网站提取网络数据`Webdriver`
*   从 MySQL 数据库读取表数据

# 简介

每个数据科学家都需要处理以多种格式存储在磁盘上的数据，比如 ASCII 文本、PDF、XML、JSON 等等。此外，数据可以存储在数据库表中。在进行任何分析之前，数据科学家的首要任务是从这些数据源和这些格式中获取数据，并应用数据清理技术去除其中存在的噪声。在这一章中，我们将看到完成这一重要任务的方法。

我们将不仅在本章，而且在整本书中使用外部 Java 库(Java 归档文件或简单的 JAR 文件)。这些库是由开发人员或组织创建的，目的是让每个人的生活更轻松。我们将使用 Eclipse IDE 进行代码开发，最好是在 Windows 平台上，并贯穿全书。这里是你如何包含任何外部 JAR 文件，在许多食谱中，我指导你将外部 JAR 文件包含到你的项目中，这是你需要做的。

在 Eclipse 中右键单击**项目** | **构建路径** | **配置构建路径**，可以在项目中添加一个 JAR 文件。在**库**选项卡下，点击**添加外部 jar...**，并选择您将用于特定项目的外部 JAR 文件:

![Introduction](img/image_01_001.jpg)

# 使用 Java 从分层目录中检索所有文件名

这个方法(以及下面的内容)是为想要从一个复杂的目录结构中检索文件路径和名称(用于将来的分析)的数据科学家准备的，这个复杂的目录结构包含根目录中的许多目录和文件。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  在目录中创建目录(尽可能多的层)。
2.  在其中的一些目录中创建文本文件，同时将一些目录留空以获得更多刺激。

## 怎么做...

1.  我们将创建一个接受一个`File`参数的`static`方法，这个参数最终是根目录或开始的目录。该方法将返回一组在这个根目录(以及所有其他后续目录)中找到的文件:

    ```java
            public static Set<File> listFiles(File rootDir) {  

    ```

2.  首先，创建一个包含文件信息的`HashSet`:

    ```java
            Set<File> fileSet = new HashSet<File>(); 

    ```

3.  一旦创建了`HashSet`，我们需要检查根目录或其中的目录是否是`null`。对于这种情况，我们不需要进一步处理:

    ```java
            if (rootDir == null || rootDir.listFiles() == null){ 
                         return fileSet; 
               } 

    ```

4.  我们一次从根目录中考虑一个目录(或文件),并检查我们是在处理一个文件还是一个目录。对于一个文件，我们将它添加到我们的`HashSet`中。在目录的情况下，我们通过发送目录的路径和名称再次递归调用这个方法:

    ```java
            for (File fileOrDir : rootDir.listFiles()) { 
                         if (fileOrDir.isFile()){ 
                           fileSet.add(fileOrDir); 
                         } 
                         else{ 
                           fileSet.addAll(listFiles(fileOrDir)); 
                         } 
                 } 

    ```

5.  Finally, we return the `HashSet` to the caller of this method:

    ```java
           return fileSet; 
              } 

    ```

    完整的方法，以及运行它的类和驱动程序方法如下:

    ```java
    import java.io.File; 
    import java.util.HashSet; 
    import java.util.Set; 

    public class TestRecursiveDirectoryTraversal { 
       public static void main(String[] args){ 
          System.out.println(listFiles(new File("Path for root 
              directory")).size()); 
       } 

       public static Set<File> listFiles(File rootDir) { 
           Set<File> fileSet = new HashSet<File>(); 
           if(rootDir == null || rootDir.listFiles()==null){ 
               return fileSet; 
           } 
           for (File fileOrDir : rootDir.listFiles()) { 
                 if (fileOrDir.isFile()){ 
                   fileSet.add(fileOrDir); 
                 } 
                 else{ 
                   fileSet.addAll(listFiles(fileOrDir)); 
                 } 
         } 

           return fileSet; 
       } 
    } 

    ```

### 注意

注意使用`HashSet`来存储文件的路径和名称。这意味着我们不会有任何重复，因为 Java 中的`Set`数据结构不包含重复条目。



# 使用 Apache Commons IO 从分层目录中检索所有文件名

分层目录中的文件名列表可以递归地完成，如前面的方法所示。然而，使用 Apache Commons IO 库，这可以用更简单、更方便的方式和更少的代码来完成。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  在这个菜谱中，我们将使用 Apache 的一个名为 Commons IO 的 Java 库。在整本书中，我们将使用 2.5 版本。从这里下载您选择的 JAR 文件:[https://commons . Apache . org/proper/commons-io/download _ io . CGI](https://commons.apache.org/proper/commons-io/download_io.cgi)
2.  将 JAR 文件包含在项目中，即 Eclipse 中的一个外部 JAR。

## 怎么做...

1.  创建一个方法，将目录层次结构中的根目录作为输入:

    ```java
            public void listFiles(String rootDir){ 

    ```

2.  创建一个根目录名为

    ```java
            File dir = new File(rootDir); 

    ```

    的文件对象
3.  Apache Commons 库的`FileUtils`类包含一个名为`listFiles()`的方法。用这个方法检索所有的文件名，并把这些名字放在一个带有`<File>`泛型的列表变量中。使用`TrueFileFilter.INSTANCE`匹配所有目录:

    ```java
            List<File> files = (List<File>) FileUtils.listFiles(dir,   
              TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE); 

    ```

4.  文件名可以显示在标准输出中，如下所示。现在我们有了列表中的名字，我们有了进一步处理这些文件中的数据的方法:

    ```java
            for (File file : files) { 
               System.out.println("file: " + file.getAbsolutePath()); 
            } 

    ```

5.  Close the method:

    ```java
           } 

    ```

    这个配方中的方法、它的类以及运行它的驱动程序方法如下:

    ```java
    import java.io.File; 
    import java.util.List; 
    import org.apache.commons.io.FileUtils; 
    import org.apache.commons.io.filefilter.TrueFileFilter; 

    public class FileListing{ 
       public static void main (String[] args){ 
          FileListing fileListing = new FileListing(); 
          fileListing.listFiles("Path for the root directory here"); 
       } 
       public void listFiles(String rootDir){ 
          File dir = new File(rootDir); 

          List<File> files = (List<File>) FileUtils.listFiles(dir,  
            TrueFileFilter.INSTANCE, TrueFileFilter.INSTANCE); 
          for (File file : files) { 
             System.out.println("file: " + file.getAbsolutePath()); 
          } 
       } 

    ```

### Tip

如果您想列出带有某些特定扩展名的文件，Apache Commons 库中也有一个名为`listFiles`的方法。但是，参数不同；该方法带三个参数，即文件目录、`String[]`扩展名、布尔递归。这个库中另一个有趣的方法是 listFilesAndDirs (File directory，IOFileFilter fileFilter，IOFileFilter dirFilter)，如果有人不仅对列出文件而且对列出目录感兴趣的话。详细信息可在 https://commons.apache.org/proper/commons-io/javadocs/的[找到。](https://commons.apache.org/proper/commons-io/javadocs/)



# 使用 Java 8 从文本文件中一次性读取内容

在许多情况下，数据科学家都有文本格式的数据。读取文本文件内容的方法有很多种，它们各有利弊:有些方法耗费时间和内存，有些方法速度很快，不需要太多的计算机内存；有些人一次读取所有文本内容，而有些人逐行读取文本文件。选择取决于手头的任务和数据科学家完成该任务的方法。

这个菜谱演示了如何使用 Java 8 一次读取所有文本文件内容。

## 怎么做...

1.  首先，创建一个`String`对象来保存将要读取的文本文件的路径和名称:

    ```java
            String file = "C:/dummy.txt";  

    ```

2.  使用`Paths`类的`get()`方法，我们得到我们试图读取的文件的路径。这个方法的参数是指向文件名的`String`对象。这个方法的输出被提供给另一个名为`lines()`的方法，它在`Files`类中。该方法从文件中读取所有行作为一个`Stream`，因此，该方法的输出指向一个`Stream`变量。因为我们的`dummy.txt`文件包含字符串数据，所以`Stream`变量的泛型被设置为`String`。

整个读取过程需要一个`try...catch`块来尝试读取一个不存在或损坏的文件等等。

下面的代码段显示了我们的`dummy.txt`文件的内容。`stream`变量包含文本文件的行，因此使用变量的`forEach()`方法显示每行内容:

```java
        try (Stream<String> stream = Files.lines(Paths.get(file))) { 
        stream.forEach(System.out::println); } catch (IOException e) { 
        System.out.println("Error reading " +  file.getAbsolutePath()); 
        } 

```



# 使用 Apache Commons IO 从文本文件中一次性读取内容

使用 Apache Commons IO API 可以实现上一个配方中描述的相同功能。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  在这个菜谱中，我们将使用 Apache 的一个名为 Commons IO 的 Java 库。从这里下载您选择的版本:[https://commons . Apache . org/proper/commons-io/download _ io . CGI](https://commons.apache.org/proper/commons-io/download_io.cgi)
2.  将 JAR 文件包含在项目中，即 Eclipse 中的一个外部 JAR。

## 怎么做...

1.  比方说，您正试图读取位于您的`C:/ drive`中名为`dummy.txt`的文件的内容。首先，你需要创建一个文件对象来访问这个文件，如下:

    ```java
            File file = new File("C:/dummy.txt");  

    ```

2.  接下来，创建一个 string 对象来保存文件的文本内容。我们将从 Apache Commons IO 库中使用的方法称为`readFileToString`，它是名为`FileUtils`的类的成员。有许多不同的方法可以调用这个方法。但是现在，只需要知道我们需要给这个方法发送两个参数。首先是`file`对象，这是我们将要读取的文件，然后是文件的编码，在这个例子中是`UTF-8` :

    ```java
            String text = FileUtils.readFileToString(file, "UTF-8"); 

    ```

3.  前面两行足以读取文本文件内容并将其放入变量中。然而，你不仅仅是一个数据科学家，你还是一个聪明的数据科学家。因此，您需要在代码前后添加几行代码，以便处理 Java 方法在试图读取一个不存在或已损坏的文件时抛出的异常。前面代码的完整性可以通过引入如下的`try...catch`块来实现:

    ```java
           File file = new File("C:/dummy.txt"); 
           try { 
           String text = FileUtils.readFileToString(file, "UTF-8"); 
           } catch (IOException e) { 
           System.out.println("Error reading " + file.getAbsolutePath()); 
           } 

    ```



# 使用 Apache Tika 提取 PDF 文本

解析和提取数据最困难的文件类型之一是 PDF。有些 pdf 甚至无法解析，因为它们受密码保护，而有些 pdf 包含扫描文本和图像。因此，这种动态文件类型有时会成为数据科学家的噩梦。这个菜谱演示了如何使用 Apache Tika 从 PDF 文件中提取文本，因为该文件没有加密或密码保护，并且包含没有扫描的文本。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  从[http://archive.apache.org/dist/tika/tika-app-1.10.jar](http://archive.apache.org/dist/tika/tika-app-1.10.jar)下载 Apache Tika 1.10 JAR 文件，并将其作为外部 Java 库包含在您的 Eclipse 项目中。
2.  在您的`C: drive`上将任何解锁的 PDF 文件另存为`testPDF.pdf`。

## 怎么做...

1.  创建一个名为`convertPdf(String)`的方法，该方法将待转换的 PDF 文件的名称作为参数:

    ```java
            public void convertPDF(String fileName){ 

    ```

2.  创建一个包含 PDF 数据的字节流输入流:

    ```java
            InputStream stream = null; 

    ```

3.  创建一个`try`块，如下所示:

    ```java
            try{ 

    ```

4.  将文件分配给刚刚创建的`stream`:

    ```java
            stream = new FileInputStream(fileName); 

    ```

5.  Apache Tika 包中提供了许多不同的解析器。如果您不知道要使用哪个解析器，或者说您不仅有 pdf，还有其他类型的文档要转换，您应该使用如下的【T0:】T1
6.  创建一个处理程序来处理文件的主体内容。注意`-1`是构造函数的参数。通常，Apache Tika 仅限于处理最多 100，000 个字符的文件。`-1`值确保这个限制被主体处理程序忽略:

    ```java
            BodyContentHandler handler = new BodyContentHandler(-1); 

    ```

7.  创建元数据对象:

    ```java
            Metadata metadata = new Metadata(); 

    ```

8.  用您刚刚创建的所有这些对象调用解析器对象的`parser()`方法:

    ```java
            parser.parse(stream, handler, metadata, new ParseContext()); 

    ```

9.  使用 handler 对象的`tostring()`方法获取从文件中提取的正文:

    ```java
            System.out.println(handler.toString()); 

    ```

10.  Close the `try` block and complement it with a `catch` block and `finally` block, and close the method as follows:

    ```java
            }catch (Exception e) { 
                          e.printStackTrace(); 
                     }finally { 
                         if (stream != null) 
                              try { 
                                   stream.close(); 
                              } catch (IOException e) { 
                                System.out.println("Error closing stream"); 
                              } 
                       } 
            } 

    ```

    一个类中带有驱动方法的完整方法如下。您刚刚创建的方法可以通过向它发送您需要转换的 PDF 文件的路径和名称来调用，该文件在您的`C: drive`中保存为`testPDF.pdf`:

    ```java
    import java.io.FileInputStream; 
    import java.io.IOException; 
    import java.io.InputStream; 
    import org.apache.tika.metadata.Metadata; 
    import org.apache.tika.parser.AutoDetectParser; 
    import org.apache.tika.parser.ParseContext; 
    import org.apache.tika.sax.BodyContentHandler; 

    public class TestTika { 
         public static void main(String args[]) throws Exception { 
              TestTika tika = new TestTika(); 
              tika.convertPdf("C:/testPDF.pdf"); 
         } 
         public void convertPdf(String fileName){ 
              InputStream stream = null; 
              try { 
                  stream = new FileInputStream(fileName); 
                  AutoDetectParser parser = new AutoDetectParser(); 
                  BodyContentHandler handler = new BodyContentHandler(-1); 
                  Metadata metadata = new Metadata(); 
                  parser.parse(stream, handler, metadata, new 
                      ParseContext()); 
                  System.out.println(handler.toString()); 
              }catch (Exception e) { 
                  e.printStackTrace(); 
              }finally { 
                  if (stream != null) 
                       try { 
                            stream.close(); 
                       } catch (IOException e) { 
                            System.out.println("Error closing stream"); 
                       } 
              } 
         } 
    } 

    ```



# 使用正则表达式清理 ASCII 文本文件

ASCII 文本文件可能包含最终在转换过程中引入的不必要的字符单元，如 PDF 到文本的转换或 HTML 到文本的转换。这些字符通常被视为噪音，因为它们是数据处理的主要障碍之一。这个方法使用正则表达式清除了 ASCII 文本数据中的一些干扰。

## 怎么做...

1.  创建一个名为`cleanText(String)`的方法，它采用`String`格式的文本:

    ```java
            public String cleanText(String text){ 

    ```

2.  Add the following lines in your method, return the cleaned text, and close the method. The first line strips off non-ASCII characters. The line next to it replaces continuous white spaces with a single white space. The third line erases all the `ASCII` control characters. The fourth line strips off the `ASCII` non-printable characters. The last line removes non-printable characters from Unicode:

    ```java
            text = text.replaceAll("[^p{ASCII}]",""); 
            text = text.replaceAll("s+", " "); 
            text = text.replaceAll("p{Cntrl}", ""); 
            text = text.replaceAll("[^p{Print}]", ""); 
            text = text.replaceAll("p{C}", ""); 

            return text; 
            } 

    ```

    类中包含驱动程序方法的完整方法如下所示:

    ```java
    public class CleaningData { 
       public static void main(String[] args) throws Exception { 
          CleaningData clean = new CleaningData(); 
          String text = "Your text here you have got from some file"; 
          String cleanedText = clean.cleanText(text); 
          //Process cleanedText 
       } 

       public String cleanText(String text){ 
          text = text.replaceAll("[^p{ASCII}]",""); 
            text = text.replaceAll("s+", " "); 
            text = text.replaceAll("p{Cntrl}", ""); 
            text = text.replaceAll("[^p{Print}]", ""); 
            text = text.replaceAll("p{C}", ""); 
            return text; 
       } 
    } 

    ```



# 使用 Univocity 解析逗号分隔值(CSV)文件

数据科学家处理的另一种非常常见的文件类型是**逗号分隔值** ( **CSV** )文件，其中数据由逗号分隔。CSV 文件非常受欢迎，因为它们可以被大多数电子表格应用程序读取，如 MS Excel。

在这个菜谱中，我们将看到如何解析 CSV 文件并处理从中检索到的数据点。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  从[http://OSS . sonatype . org/content/repositories/releases/com/univo city/univo city-parsers/2 . 2 . 1/univo city-parsers-2 . 2 . 1 . JAR](http://oss.sonatype.org/content/repositories/releases/com/univocity/univocity-parsers/2.2.1/univocity-parsers-2.2.1.jar)下载 Univocity JAR 文件。将 JAR 文件作为外部库包含在 Eclipse 的项目中。
2.  使用记事本从以下数据创建一个 CSV 文件。文件扩展名应该是`.csv`。你将文件保存为`C:/testCSV.csv` :

    ```java
            Year,Make,Model,Description,Price 
            1997,Ford,E350,"ac, abs, moon",3000.00 
            1999,Chevy,"Venture ""Extended Edition""","",4900.00 
            1996,Jeep,Grand Cherokee,"MUST SELL! 
            air, moon roof, loaded",4799.00 
            1999,Chevy,"Venture ""Extended Edition, Very Large""",,5000.00 
            ,,"Venture ""Extended Edition""","",4900.00 

    ```

## 怎么做...

1.  创建一个名为`parseCsv(String)`的方法，将文件名作为字符串参数:

    ```java
            public void parseCsv(String fileName){ 

    ```

2.  然后创建一个设置对象。该对象提供了许多配置设置选项:

    ```java
            CsvParserSettings parserSettings = new CsvParserSettings(); 

    ```

3.  您可以配置解析器来自动检测输入中的行分隔符序列:

    ```java
            parserSettings.setLineSeparatorDetectionEnabled(true); 

    ```

4.  创建一个`RowListProcessor`,将每个解析过的行存储在一个列表中:

    ```java
            RowListProcessor rowProcessor = new RowListProcessor(); 

    ```

5.  您可以配置解析器使用一个`RowProcessor`来处理每个解析行的值。你会在`com.univocity.parsers.common.processor`包中找到更多的`RowProcessors`，但是你也可以自己创建:

    ```java
            parserSettings.setRowProcessor(rowProcessor); 

    ```

6.  如果您将要解析的 CSV 文件包含标题，您可以将第一个解析的行视为文件中每一列的标题:

    ```java
            parserSettings.setHeaderExtractionEnabled(true); 

    ```

7.  现在，用给定的设置创建一个`parser`实例:

    ```java
            CsvParser parser = new CsvParser(parserSettings); 

    ```

8.  `parse()`方法将解析文件，并将每个解析的行委托给您定义的【T1:】T2
9.  如果您已经解析了头部，那么可以如下找到【T0:】T1
10.  然后，您可以轻松地处理这个字符串数组来获取头值。
11.  另一方面，行值可以在列表中找到。可以使用 for 循环打印列表，如下所示:

    ```java
            List<String[]> rows = rowProcessor.getRows(); 
            for (int i = 0; i < rows.size(); i++){ 
               System.out.println(Arrays.asList(rows.get(i))); 
            } 

    ```

12.  Finally, close the method:

    ```java
           } 

    ```

    整个方法可以写成如下形式:

    ```java
    import java.io.File; 
    import java.util.Arrays; 
    import java.util.List; 

    import com.univocity.parsers.common.processor.RowListProcessor; 
    import com.univocity.parsers.csv.CsvParser; 
    import com.univocity.parsers.csv.CsvParserSettings; 

    public class TestUnivocity { 
          public void parseCSV(String fileName){ 
              CsvParserSettings parserSettings = new CsvParserSettings(); 
              parserSettings.setLineSeparatorDetectionEnabled(true); 
              RowListProcessor rowProcessor = new RowListProcessor(); 
              parserSettings.setRowProcessor(rowProcessor); 
              parserSettings.setHeaderExtractionEnabled(true); 
              CsvParser parser = new CsvParser(parserSettings); 
              parser.parse(new File(fileName)); 

              String[] headers = rowProcessor.getHeaders(); 
              List<String[]> rows = rowProcessor.getRows(); 
              for (int i = 0; i < rows.size(); i++){ 
                System.out.println(Arrays.asList(rows.get(i))); 
              } 
          } 

          public static void main(String[] args){ 
             TestUnivocity test = new TestUnivocity(); 
             test.parseCSV("C:/testCSV.csv"); 
          } 
    } 

    ```

### 注意

有许多 CSV 解析器是用 Java 编写的。然而，相比之下，大学是最快的。详细对比结果见此:[https://github.com/uniVocity/csv-parsers-comparison](https://github.com/uniVocity/csv-parsers-comparison)



# 使用 Univocity 解析制表符分隔值(TSV)文件

与 CSV 文件不同，**制表符分隔值** ( **TSV** )文件包含由制表符分隔的数据。这个菜谱向您展示了如何从 TSV 文件中检索数据点。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  从[http://OSS . sonatype . org/content/repositories/releases/com/univo city/univo city-parsers/2 . 2 . 1/univo city-parsers-2 . 2 . 1 . JAR](http://oss.sonatype.org/content/repositories/releases/com/univocity/univocity-parsers/2.2.1/univocity-parsers-2.2.1.jar)下载 Univocity JAR 文件。将 JAR 文件包含在 Eclipse 外部库的项目中。
2.  使用记事本从以下数据创建 TSV 文件。文件扩展名应该是`.tsv`。您将文件保存为`C:/testTSV.tsv`:

```java
Year    Make    Model   Description Price 
1997    Ford    E350    ac, abs, moon   3000.00 
1999    Chevy   Venture "Extended Edition"      4900.00 
1996    Jeep    Grand Cherokee  MUST SELL!nair, moon roof, loaded  4799.00 
1999    Chevy   Venture "Extended Edition, Very Large"      5000.00 
        Venture "Extended Edition"      4900.00 

```

## 怎么做...

1.  创建一个名为`parseTsv(String)`的方法，将文件名作为字符串参数:

    ```java
            public void parseTsv(String fileName){ 

    ```

2.  在这个菜谱中，TSV 文件的行分隔符是一个换行符或`n`。要将该字符设置为行分隔符，请修改设置:

    ```java
            settings.getFormat().setLineSeparator("n"); 

    ```

3.  使用这些设置，创建一个 TSV 解析器:

    ```java
            TsvParser parser = new TsvParser(settings); 

    ```

4.  一次性解析 TSV 文件的所有行，如下所示:

    ```java
            List<String[]> allRows = parser.parseAll(new File(fileName)); 

    ```

5.  遍历列表对象，打印/处理这些行，如下所示:

    ```java
            for (int i = 0; i < allRows.size(); i++){ 
                     System.out.println(Arrays.asList(allRows.get(i))); 
                   } 

    ```

6.  最后，关闭方法:

```java
        } 

```

类中包含驱动程序方法的完整方法如下所示:

```java
import java.io.File; 
import java.util.Arrays; 
import java.util.List; 

import com.univocity.parsers.tsv.TsvParser; 
import com.univocity.parsers.tsv.TsvParserSettings; 

public class TestTsv { 
   public void parseTsv(String fileName){ 
       TsvParserSettings settings = new TsvParserSettings(); 
       settings.getFormat().setLineSeparator("n"); 
       TsvParser parser = new TsvParser(settings); 
       List<String[]> allRows = parser.parseAll(new File(fileName)); 
       for (int i = 0; i < allRows.size(); i++){ 
         System.out.println(Arrays.asList(allRows.get(i))); 
       } 
   } 
} 

```



# 使用 JDOM 解析 XML 文件

与通常是非结构化的文本数据不同，在 XML 文件中组织数据是一种以结构化方式准备、传递和利用数据的流行方法。有几种方法可以解析 XML 文件的内容。在本书中，我们将把我们的方法限制在一个名为 JDOM 的用于 XML 解析的外部 Java 库。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  从[http://www.jdom.org/downloads/index.html](http://www.jdom.org/downloads/index.html)下载 JDOM 的 2.06 版 JAR 文件。
2.  在 Eclipse 中，创建一个项目并将 JAR 文件包含在一个外部 JAR 中。
3.  打开记事本。创建一个名为`xmldummy`的新文件，扩展名为`.xml`。该文件的内容将简单如下:

```java
       <?xml version="1.0"?> 
       <book> 
          <author> 
             <firstname>Alice</firstname> 
             <lastname>Peterson</lastname> 
          </author> 
          <author> 
             <firstname>John</firstname> 
             <lastname>Doe</lastname> 
          </author> 
       </book> 

```

## 怎么做...

1.  创建一个名为`builder` :

    ```java
           SAXBuilder builder = new SAXBuilder(); 

    ```

    的`SAXBuilder`对象
2.  现在您需要创建一个`File`对象来指向您将要解析的 XML 文件。如果您已经将 XML 文件保存在了`C:/`驱动器中，那么输入下面的代码段:

    ```java
            File file = new File("c:/dummyxml.xml"); 

    ```

3.  在一个`try`块中，您将创建一个`Document`对象，这将是您的 XML 文件:

    ```java
            try { 
              Document document = (Document) builder.build(file); 

    ```

4.  当您解析 XML 时，由于它是树结构的，您需要知道文件的根元素来开始遍历树(换句话说，开始系统地解析)。因此，您创建了一个类型为`Element`的`rootNode`对象来保存根元素，在我们的例子中是`<book>`节点:

    ```java
            Element rootNode = document.getRootElement(); 

    ```

5.  然后，您将检索根节点中所有名为`author`的子节点。这些名字以列表的形式出现，因此，您将使用一个列表变量来保存它们:

    ```java
            List list = rootNode.getChildren("author"); 

    ```

6.  接下来，您将使用一个`for`循环来遍历这个列表，以获得这个列表中条目的元素。每个元素将保存在一个名为 node 的`Element`类型变量中。该变量有一个名为`getChildText()`的方法，该方法以其子变量的名字作为参数；该方法返回命名的子元素的文本内容，如果没有这样的子元素，则返回`null`。这个方法很方便，因为调用`getChild().getText()`可以抛出一个`NullPointerException` :

    ```java
            for (int i = 0; i < list.size(); i++) { 
               Element node = (Element) list.get(i); 
            System.out.println("First Name : " + 
              node.getChildText("firstname")); 
            System.out.println("Last Name : " +             
              node.getChildText("lastname")); 
            } 

    ```

7.  Finally, you will be closing the `try` block; put the following `catch` blocks to handle exceptions:

    ```java
            } catch (IOException io) { 
                  System.out.println(io.getMessage()); 
            } catch (JDOMException jdomex) { 
                  System.out.println(jdomex.getMessage()); 
            }  

    ```

    食谱的完整代码如下:

    ```java
    import java.io.File; 
    import java.io.IOException; 
    import java.util.List; 

    import org.jdom2.Document; 
    import org.jdom2.Element; 
    import org.jdom2.JDOMException; 
    import org.jdom2.input.SAXBuilder; 

    public class TestJdom { 

       public static void main(String[] args){ 
          TestJdom test = new TestJdom(); 
          test.parseXml("C:/dummyxml.com"); 

       } 
       public void parseXml(String fileName){ 
          SAXBuilder builder = new SAXBuilder(); 
          File file = new File(fileName); 
          try { 
             Document document = (Document) builder.build(file); 
             Element rootNode = document.getRootElement(); 
             List list = rootNode.getChildren("author"); 
             for (int i = 0; i < list.size(); i++) { 
                Element node = (Element) list.get(i); 
                System.out.println("First Name : " + 
                    node.getChildText("firstname")); 
                System.out.println("Last Name : " + 
                    node.getChildText("lastname")); 
             } 
          } catch (IOException io) { 
             System.out.println(io.getMessage()); 
          } catch (JDOMException jdomex) { 
             System.out.println(jdomex.getMessage()); 
          } 
       } 
    } 

    ```

### 注意

有许多不同类型的 XML 解析器，每种都有自己的好处 **Dom 解析器**:这些解析器将文档的完整内容加载到内存中，并在内存中创建其完整的层次树。 **SAX 解析器**:这些解析器不会将完整的文档加载到内存中，而是基于事件触发器来解析文档。 **JDOM 解析器** : JDOM 解析器以类似于 DOM 解析器的方式解析文档，但是更方便。 **StAX 解析器** : 这些解析器处理文档的方式与 SAX 解析器相似，但效率更高。 **XPath 解析器** : 这些解析器基于表达式解析文档，广泛用于 XSLT。 **DOM4J 解析器** : 这是一个 Java 库，使用 Java 集合框架解析 XML、XPath 和 XSLT，提供对 DOM、SAX 和 JAXP 的支持。



# 使用 JSON.simple 编写 JSON 文件

就像 XML 一样，JSON 也是一种轻量级的人类可读的数据交换格式。它代表 JavaScript 对象符号。这正成为现代 web 应用程序生成和解析的流行格式。在这个菜谱中，您将看到如何编写 JSON 文件。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  从[https://code.google.com/archive/p/json-simple/downloads](https://code.google.com/archive/p/json-simple/downloads)下载`json-simple-1.1.1.jar`，并将 JAR 文件作为外部库包含到您的 Eclipse 项目中。

## 怎么做...

1.  创建一个名为`writeJson(String outFileName)`的方法，该方法采用我们将生成的 JSON 文件的名称作为输出，并带有这个菜谱中的 JSON 信息。
2.  创建一个 JSON 对象，并使用该对象的`put()`方法填充一些字段。例如，假设你的领域是书籍和它们的作者。下面的代码将创建一个 JSON 对象，并填充哈利波特系列中的一本书的名称及其作者的姓名:

    ```java
            JSONObject obj = new JSONObject(); 
              obj.put("book", "Harry Potter and the Philosopher's Stone"); 
              obj.put("author", "J. K. Rowling");

    ```

3.  接下来，假设我们有三个书评人对这本书的评论。它们可以放在一个 JSON 数组中。该数组可以按如下方式填充。首先，我们使用数组对象的`add()`来添加评论。当所有的评论都被添加到数组中时，我们将把数组放到我们在上一步中创建的 JSON 对象中:

    ```java
    JSONArray list = new JSONArray(); 

    list.add("There are characters in this book that will remind us of all the people we have met. Everybody knows or knew a spoilt, overweight boy like Dudley or a bossy and interfering (yet kind-hearted) girl like Hermione"); 

    list.add("Hogwarts is a truly magical place, not only in the most obvious way but also in all the detail that the author has gone to describe it so vibrantly."); 

    list.add("Parents need to know that this thrill-a-minute story, the first in the Harry Potter series, respects kids' intelligence and motivates them to tackle its greater length and complexity, play imaginative games, and try to solve its logic puzzles. "); 

    obj.put("messages", list); 

    ```

4.  我们将把 JSON 对象中的信息写到一个输出文件中，因为这个文件将用于演示我们如何读取/解析 JSON 文件。下面的`try...catch`代码块将信息写到一个 JSON 文件中:

    ```java
            try { 

                     FileWriter file = new FileWriter("c:test.json"); 
                     file.write(obj.toJSONString()); 
                     file.flush(); 
                     file.close(); 

            } catch (IOException e) { 
                     //your message for exception goes here. 
            } 

    ```

5.  JSON 对象的内容也可以显示在标准输出上，如下所示:

    ```java
            System.out.print(obj); 

    ```

6.  最后，关闭方法:

```java
        } 

```

整个类、该配方中描述的方法以及调用带有输出 JSON 文件名的方法的驱动程序方法如下:

```java
import java.io.FileWriter; 
import java.io.IOException; 
import org.json.simple.JSONArray; 
import org.json.simple.JSONObject; 

public class JsonWriting { 

   public static void main(String[] args) { 
      JsonWriting jsonWriting = new JsonWriting(); 
      jsonWriting.writeJson("C:/testJSON.json"); 
   } 

   public void writeJson(String outFileName){ 
      JSONObject obj = new JSONObject(); 
      obj.put("book", "Harry Potter and the Philosopher's Stone"); 
      obj.put("author", "J. K. Rowling"); 

      JSONArray list = new JSONArray(); 
      list.add("There are characters in this book that will remind us  
        of all the people we have met. Everybody knows or knew a 
          spoilt, overweight boy like Dudley or a bossy and interfering   
            (yet kind-hearted) girl like Hermione"); 
      list.add("Hogwarts is a truly magical place, not only in the most 
        obvious way but also in all the detail that the author has gone     
          to describe it so vibrantly."); 
      list.add("Parents need to know that this thrill-a-minute story, 
        the first in the Harry Potter series, respects kids'  
          intelligence and motivates them to tackle its greater length 
            and complexity, play imaginative games, and try to solve 
              its logic puzzles. "); 

      obj.put("messages", list); 

      try { 

         FileWriter file = new FileWriter(outFileName); 
         file.write(obj.toJSONString()); 
         file.flush(); 
         file.close(); 

      } catch (IOException e) { 
         e.printStackTrace(); 
      } 

      System.out.print(obj); 
   } 
}

```

输出文件将包含如下数据。请注意，此处显示的输出已经过修改，以增加可读性，实际输出是一段大而平的文本:

```java
{ 
"author":"J. K. Rowling", 
"book":"Harry Potter and the Philosopher's Stone", 
"messages":[ 
         "There are characters in this book that will remind us of all the people we have met. Everybody knows or knew a spoilt, overweight boy like Dudley or a bossy and interfering (yet kind-hearted) girl like Hermione", 
         "Hogwarts is a truly magical place, not only in the most obvious way but also in all the detail that the author has gone to describe it so vibrantly.", 
         "Parents need to know that this thrill-a-minute story, the first in the Harry Potter series, respects kids' intelligence and motivates them to tackle its greater length and complexity, play imaginative games, and try to solve its logic puzzles." 
         ] 
} 

```



# 使用 JSON.simple 读取 JSON 文件

在这个菜谱中，我们将看到如何读取或解析 JSON 文件。作为我们的样本输入文件，我们将使用我们在前一个菜谱中创建的 JSON 文件。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  使用前面的方法创建一个 JSON 文件，其中包含图书、作者和评论者的评论信息。该文件将用作该配方解析/读取的输入。

## 怎么做...

1.  因为我们将读取或解析一个 JSON 文件，首先，我们将创建一个 JSON 解析器:

    ```java
            JSONParser parser = new JSONParser(); 

    ```

2.  然后，在`try`块中，我们将检索 book 和 author 字段中的值。然而，要做到这一点，我们首先使用解析器的`parse()`方法来读取输入的 JSON 文件。`parse()`方法将文件的内容作为对象返回。因此，我们将需要一个 `Object`变量来保存内容。然后，`object`将被分配给一个 JSON 对象进行进一步处理。注意在赋值期间`Object`变量的类型转换:

    ```java
           try { 

             Object obj = parser.parse(new FileReader("c:test.json")); 
             JSONObject jsonObject = (JSONObject) obj; 

             String name = (String) jsonObject.get("book"); 
             System.out.println(name); 

             String author = (String) jsonObject.get("author"); 
             System.out.println(author); 
           }

    ```

3.  从输入 JSON 文件中检索的下一个字段是 review 字段，这是一个数组。我们迭代这个字段如下:

    ```java

           JSONArray reviews = (JSONArray) jsonObject.get("messages"); 
             Iterator<String> iterator = reviews.iterator(); 
             while (iterator.hasNext()) { 
                System.out.println(iterator.next()); 
           } 

    ```

4.  最后，我们创建 catch 块来处理解析期间可能出现的三种类型的异常，然后关闭该方法:

```java

        } catch (FileNotFoundException e) { 
                 //Your exception handling here 
              } catch (IOException e) { 
                 //Your exception handling here 
              } catch (ParseException e) { 
                 //Your exception handling here 
              } 
        } 

```

整个类、该配方中描述的方法以及运行该方法的驱动程序方法如下:

```java
import java.io.FileNotFoundException; 
import java.io.FileReader; 
import java.io.IOException; 
import java.util.Iterator; 
import org.json.simple.JSONArray; 
import org.json.simple.JSONObject; 
import org.json.simple.parser.JSONParser; 
import org.json.simple.parser.ParseException; 

public class JsonReading { 
   public static void main(String[] args){ 
      JsonReading jsonReading = new JsonReading(); 
      jsonReading.readJson("C:/testJSON.json"); 
   } 
   public void readJson(String inFileName) { 
      JSONParser parser = new JSONParser(); 
      try { 
         Object obj = parser.parse(new FileReader(inFileName)); 
         JSONObject jsonObject = (JSONObject) obj; 

         String name = (String) jsonObject.get("book"); 
         System.out.println(name); 

         String author = (String) jsonObject.get("author"); 
         System.out.println(author); 

         JSONArray reviews = (JSONArray) jsonObject.get("messages"); 
         Iterator<String> iterator = reviews.iterator(); 
         while (iterator.hasNext()) { 
            System.out.println(iterator.next()); 
         } 
      } catch (FileNotFoundException e) { 
         //Your exception handling here 
      } catch (IOException e) { 
         //Your exception handling here 
      } catch (ParseException e) { 
         //Your exception handling here 
      } 
   } 
} 

```

成功执行代码后，您将能够在标准输出中看到输入文件的内容。



# 使用 JSoup 从 URL 中提取 web 数据

如今，大量的数据可以在网上找到。这些数据有时是结构化的、半结构化的，甚至是非结构化的。因此，提取它们需要非常不同的技术。有许多不同的方法来提取 web 数据。最简单方便的方法之一是使用名为 JSoup 的外部 Java 库。这个菜谱使用 JSoup 中提供的一些方法来提取 web 数据。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  去[https://jsoup.org/download](https://jsoup.org/download)，下载`jsoup-1.9.2.jar`文件。将 JAR 文件添加到 Eclipse 项目的外部库中。
2.  如果您是 Maven 爱好者，请按照下载页面上的说明将 JAR 文件包含到您的 Eclipse 项目中。

## 怎么做...

1.  创建一个名为`extractDataWithJsoup(String url)`的方法。该参数是调用该方法所需的任何网页的 URL。我们将从这个网址提取网页数据:

    ```java
            public void extractDataWithJsoup(String href){  

    ```

2.  使用`connect()`方法，将 URL 发送到我们想要连接的地方(并提取数据)。然后，我们会用它链接更多的方法。首先，我们将链接以毫秒为参数的`timeout()`方法。之后的方法定义连接期间的用户代理名称，以及是否尝试忽略连接错误。与前两个方法相联系的下一个方法是最终返回一个`Document`对象的`get()`方法。因此，我们将在`Document`类的`doc`中保存这个返回的对象:

    ```java
            doc = 
              Jsoup.connect(href).timeout(10*1000).userAgent
                ("Mozilla").ignoreHttpErrors(true).get();
    ```

3.  As this code throws `IOException`, we will be using a `try...catch` block as follows:

    ```java
            Document doc = null; 
            try { 
             doc = Jsoup.connect(href).timeout(10*1000).userAgent
               ("Mozilla").ignoreHttpErrors(true).get(); 
               } catch (IOException e) { 
                  //Your exception handling here 
            } 

    ```

    ### Tip

    We are not used to expressing time in milliseconds. Therefore, when milliseconds are the time unit in coding, it is a good practice to write 10*1000 to represent 10 seconds. This enhances the readability of the code.

4.  对于一个`Document`对象，可以找到大量的方法。如果要提取 URL 的标题，可以使用如下的标题方法:

    ```java
             if(doc != null){ 
              String title = doc.title(); 

    ```

5.  为了只提取 web 页面的文本部分，我们可以将`body()`方法与`Document`对象的`text()`方法链接起来，如下:

    ```java
            String text = doc.body().text();

    ```

6.  如果想提取一个 URL 中的所有超链接，可以使用带有`a[href]`参数的`Document`对象的`select()`方法。这一次给你所有的链接:

    ```java
            Elements links = doc.select("a[href]"); 

    ```

7.  也许你想单独处理网页中的链接？这也很简单——你需要遍历所有的链接来得到单个的链接:

    ```java
            for (Element link : links) { 
                String linkHref = link.attr("href"); 
                String linkText = link.text(); 
                String linkOuterHtml = link.outerHtml(); 
                String linkInnerHtml = link.html();  
            System.out.println(linkHref + "t" + linkText + "t"  +  
              linkOuterHtml + "t" + linkInnterHtml);       
            }  

    ```

8.  最后，用大括号结束 if 条件。用大括号结束该方法:

```java
        } 
        }  

```

完整的方法、其类和驱动程序方法如下:

```java
import java.io.IOException; 
import org.jsoup.Jsoup; 
import org.jsoup.nodes.Document; 
import org.jsoup.nodes.Element; 
import org.jsoup.select.Elements; 

public class JsoupTesting { 
   public static void main(String[] args){ 
      JsoupTesting test = new JsoupTesting(); 
      test.extractDataWithJsoup("Website address preceded by http://"); 
   } 

   public void extractDataWithJsoup(String href){ 
      Document doc = null; 
      try { 
         doc = Jsoup.connect(href).timeout(10*1000).userAgent
             ("Mozilla").ignoreHttpErrors(true).get(); 
      } catch (IOException e) { 
         //Your exception handling here 
      } 
      if(doc != null){ 
         String title = doc.title(); 
         String text = doc.body().text(); 
         Elements links = doc.select("a[href]"); 
         for (Element link : links) { 
            String linkHref = link.attr("href"); 
            String linkText = link.text(); 
            String linkOuterHtml = link.outerHtml(); 
            String linkInnerHtml = link.html(); 
            System.out.println(linkHref + "t" + linkText + "t"  + 
                linkOuterHtml + "t" + linkInnterHtml); 
         } 
      } 
   } 
} 

```



# 使用 Selenium Webdriver 从网站提取 web 数据

Selenium 是一个基于 Java 的工具，用于帮助自动化软件测试或质量保证。有趣的是，Selenium 可以用来自动检索和利用 web 数据。这个食谱告诉你如何做。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  从 http://selenium-release.storage.googleapis.com/index.html?[下载`selenium-server-standalone-2.53.1.jar`和`selenium-java-2.53.1.zip`路径=2.53/](http://selenium-release.storage.googleapis.com/index.html?path=2.53/) 。从后者中，提取出`selenium-java-2.53.1.jar`文件。将这两个 JAR 文件包含在您的 eclipse 项目外部 Java 库中。
2.  从[https://ftp.mozilla.org/pub/firefox/releases/47.0.1/](https://ftp.mozilla.org/pub/firefox/releases/47.0.1/)下载并安装火狐 47.0.1，选择适合你操作系统的版本。

### Tip

由于 Selenium 和 Firefox 之间的版本冲突问题，一旦您运行特定版本的代码，请关闭 Firefox 中的自动更新下载和安装选项。

## 怎么做...

1.  创建一个名为`extractDataWithSelenium(String)`的方法，该方法将一个`String`作为参数，它最终是我们要从中提取数据的 URL。我们可以从 URL 中提取许多不同类型的数据，比如标题、标题和下拉框中的值。这个菜谱只集中提取网页的文字部分:

    ```java
            public String extractDataWithSelenium(String url){ 

    ```

2.  接下来，使用下面的代码创建一个 Firefox web 驱动程序:

    ```java
            WebDriver driver = new FirefoxDriver(); 

    ```

3.  通过传递 URL:

    ```java
            driver.get("http://cogenglab.csd.uwo.ca/rushdi.htm"); 

    ```

    来使用`WebDriver`对象的`get()`方法
4.  The text of the webpage can be found using `xpath`, where the value of `id` is content:![How to do it...](img/image_01_002.jpg)![How to do it...](img/image_01_003.jpg)
5.  用`findElement()`方法找到这个特殊的元素。这个方法返回一个`WebElement`对象。创建一个名为`webElement`的`WebElement`对象来保存返回值:

    ```java
            WebElement webElement = driver.findElement(By.xpath("//* 
              [@id='content']")); 

    ```

6.  对象有一个名为`getText()`的方法。调用该方法检索网页文本，并将文本放入一个`String`变量中，如下:

    ```java
            String text = (webElement.getText()); 

    ```

7.  Finally, return the String variable and close the method:

    ```java
            }
    ```

    配方的 driver main()方法的完整代码段如下所示:

    ```java
    import org.openqa.selenium.By; 
    import org.openqa.selenium.WebDriver; 
    import org.openqa.selenium.WebElement; 
    import org.openqa.selenium.firefox.FirefoxDriver; 

    public class TestSelenium { 
       public String extractDataWithSelenium(String url) { 
          WebDriver driver = new FirefoxDriver(); 
          driver.get("http://cogenglab.csd.uwo.ca/rushdi.htm"); 
          WebElement webElement = driver.findElement(By.xpath("//*
            [@id='content']")); 
          System.out.println(webElement.getText()); 
          return url;    
       } 

       public static void main(String[] args){ 
          TestSelenium test = new TestSelenium(); 
          String webData = test.extractDataWithSelenium
            ("http://cogenglab.csd.uwo.ca/rushdi.htm"); 
          //process webData 
       } 
    } 

    ```

### 注意

Selenium 和 Firefox 有兼容性问题。一些 Selenium 版本不能与一些 Firefox 版本一起使用。此处提供的配方适用于配方中提到的版本。但它不能保证能与其他 Selenium 或 Firefox 版本兼容。

由于 Selenium 和 Firefox 之间的版本冲突问题，一旦您使用两者的特定版本运行代码，请关闭 Firefox 中的自动更新下载和安装选项。



# 从 MySQL 数据库读取表格数据

数据也可以存储在数据库表中。这个菜谱演示了我们如何从 MySQL 的一个表中读取数据。

## 准备就绪

为了执行此配方，我们需要以下内容:

1.  从 http://dev.mysql.com/downloads/mysql/下载并安装 MySQL 社区服务器。这个配方使用的版本是 5.7.15。
2.  Create a database named `data_science`. In this database, create a table named `books` that contains data as follows:![Getting ready](img/image_01_004.jpg)

    字段类型的选择对于这个配方来说并不重要，但是字段的名称需要与这里展示的名称完全匹配。

3.  从[http://dev.mysql.com/downloads/connector/j/](http://dev.mysql.com/downloads/connector/j/)下载平台无关的 MySql JAR 文件，并将其作为外部库添加到您的 Java 项目中。这个配方使用的版本是 5.1.39。

## 怎么做...

1.  创建一个 public void `readTable(String user, String password, String server)`方法，它将 MySQL 数据库的用户名、密码和服务器名作为参数:

    ```java
            public void readTable(String user, String password, String   
              server){ 

    ```

2.  创建一个 MySQL 数据源，并使用该数据源设置用户名、密码和服务器名:

    ```java
            MysqlDataSource dataSource = new MysqlDataSource(); 
              dataSource.setUser(user); 
              dataSource.setPassword(password); 
              dataSource.setServerName(server); 

    ```

3.  在`try`块中，为数据库创建一个连接。使用该连接，创建一个语句，该语句将用于执行一个`SELECT`查询来从表中获取信息。查询的结果将存储在一个结果集中:

    ```java
            try{ 
              Connection conn = dataSource.getConnection(); 
              Statement stmt = conn.createStatement(); 
              ResultSet rs = stmt.executeQuery("SELECT * FROM  
                data_science.books"); 

    ```

4.  现在，遍历结果集，通过提及列名来检索每一列数据。请注意方法的使用，它为我们提供了您在使用它们之前需要知道的字段类型。例如，我们知道 ID 字段是整数，我们可以使用`getInt()`方法:

    ```java
            while (rs.next()){ 
              int id = rs.getInt("id"); 
              String book = rs.getString("book_name"); 
              String author = rs.getString("author_name"); 
              Date dateCreated = rs.getDate("date_created"); 
              System.out.format("%s, %s, %s, %sn", id, book, author, 
                dateCreated); 
            }
    ```

5.  迭代后关闭结果集、语句和连接:

    ```java
            rs.close(); 
              stmt.close(); 
              conn.close(); 

    ```

6.  在从表中读取数据的过程中，尽可能捕捉一些异常，并关闭该方法:

```java
        }catch (Exception e){ 
           //Your exception handling mechanism goes here. 
          } 
        } 

```

执行该方法的完整方法、类和驱动程序方法如下:

```java
import java.sql.*; 
import com.mysql.jdbc.jdbc2.optional.MysqlDataSource; 
public class TestDB{ 
     public static void main(String[] args){ 
          TestDB test = new TestDB(); 
          test.readTable("your user name", "your password", "your MySQL 
              server name"); 
     } 
     public void readTable(String user, String password, String server) 
         { 
          MysqlDataSource dataSource = new MysqlDataSource(); 
          dataSource.setUser(user); 
          dataSource.setPassword(password); 
          dataSource.setServerName(server); 
          try{ 
               Connection conn = dataSource.getConnection(); 
               Statement stmt = conn.createStatement(); 
               ResultSet rs = stmt.executeQuery("SELECT * FROM 
                   data_science.books"); 
               while (rs.next()){ 
                    int id = rs.getInt("id"); 
                    String book = rs.getString("book_name"); 
                    String author = rs.getString("author_name"); 
                    Date dateCreated = rs.getDate("date_created"); 
                    System.out.format("%s, %s, %s, %sn", id, book, 
                        author, dateCreated); 
               } 
               rs.close(); 
               stmt.close(); 
               conn.close(); 
          }catch (Exception e){ 
               //Your exception handling mechanism goes here. 
          } 
     } 
} 

```

这段代码显示您创建的表中的数据。