# 附录 C. `NumPy` 数组

# 介绍

数组是`NumPy`引入的基本数据结构，它们是我们在本书中讨论的所有科学计算和数据分析库的基础。本附录将简要概述以下数组特性：

+   数组创建和成员访问

+   索引和切片

# 数组创建和成员访问

`NumPy`数组是`ndarray`类的对象，该类表示一个固定大小的多维同质数据集合。

在这里，我们假设已经通过以下命令行导入了`NumPy`库：

```py
import numpy as np

```

一旦完成这些步骤，我们可以从一个列表的列表创建`ndarray`（以后简称为**数组对象**或简单称为**数组**），如以下命令行所示：

```py
a = np.array([[-2,3,-4,0],[2,-7,0,0],[3,-4,2,1]],dtype=np.float64)
print a

```

与 Python 列表和元组不同，数组对象的所有元素必须是相同类型的。这些类型由`NumPy`对象表示，并称为数组的`dtype`（数据类型）。在前面的示例中，我们明确指定`dtype`为`float64`，它表示一个 64 位浮动小数值。

数组具有几个属性，用于提供关于数据布局的信息。最常用的属性如下：

+   数组的形状可以通过以下命令计算：

    ```py
    a.shape

    ```

    前面的命令返回元组`(3, 4)`，因为这是一个具有三行四列的二维数组。有些人可能会感到惊讶，`shape`属性并非只读，我们可以利用它来*重塑*数组：

    ```py
    a.shape = (6,2)
    print a

    ```

    运行前面的示例后，运行`a.shape(3,4)`可以返回原始维度。

+   数组的维度数量可以通过以下命令获取：

    ```py
    a.ndim

    ```

    当然，这将返回`2`。在`NumPy`中，一个重要的概念是数组的*轴*。二维数组有两个轴，编号为 0 和 1。如果我们把数组看作是一个数学矩阵，那么轴 0 是垂直的，指向下方，轴 1 是水平的，指向右侧。某些数组方法有一个可选的`axis`关键字参数，允许用户指定在哪个轴上执行操作。

+   要获取数组中元素的个数，可以使用以下命令：

    ```py
    a.size

    ```

    在前面的示例中，返回的输出是`12`，正如预期的那样。

+   数组的一个最终属性是计算数组的*转置*。这可以通过以下命令完成：

    ```py
    b = a.T
    print b

    ```

    这创建的一个重要内容是数组`a`的*视图*。`NumPy`包被设计成能高效处理非常大的数组，并且在大多数情况下，除非绝对必要，或明确指示，否则避免复制数据。

+   运行以下代码行：

    ```py
    print a
    b[1,2] = 11
    print a

    ```

    请注意，数组`a`的条目`2, 1`已被更改，这表明变量`a`和`b`都指向内存中的同一位置。

+   可以通过`empty()`函数如下创建一个包含未初始化数据的数组：

    ```py
    c = np.empty(shape=(3,2), dtype=np.float64)
    print c

    ```

+   使用未初始化的数据是不推荐的，因此最好使用 `zeros()` 或 `ones()` 函数，如下所示：

    +   要使用 `zeros()` 函数，执行以下命令：

        ```py
        d = np.zeros(shape=(3,2), dtype=np.float64)
        print d

        ```

    +   要使用 `ones()` 函数，执行以下命令：

        ```py
        e = np.ones(shape=(3,2), dtype=np.float64)
        print e

        ```

        ```py
        a_like = np.zeros_like(a)
        print a_like

        ```

    也有一些函数可以创建具有与现有数组相同形状和数据类型的新数组：

+   `ones_like()` 和 `empty_like()` 函数生成与给定数组相同形状的全 1 数组和未初始化的数据数组。

+   `NumPy` 还有一个 `eye()` 函数，可以返回给定维度和 `dtype` 的单位矩阵：

    ```py
    f = np.eye(5, dtype=np.float64)
    print f

    ```

    行和列的数量不必相同。在这种情况下，生成的矩阵将仅是左单位矩阵或右单位矩阵，具体取决于情况：

    ```py
    g = np.eye(5, 3, dtype=np.float64)
    print g

    ```

+   数组也可以从现有数据创建。`copy()` 函数可以如下面这样克隆数组：

    ```py
    aa = np.copy(a)
    print a
    print aa

    ```

+   `frombuffer()` 函数从暴露（单维）缓冲区接口的对象创建数组。以下是一个示例：

    ```py
    ar = np.arange(0.0, 1.0, 0.1, dtype=np.float64)
    v = np.frombuffer(ar)
    v.shape = (2, 5)
    print v

    ```

    `arange()` 函数是 `NumPy` 对 Python `range` 的扩展。它的语法类似，但允许浮动范围值。

+   `loadtxt()` 函数从文本文件中读取数组。假设文本文件 `matrix.txt` 包含以下数据：

    ```py
     1.3  4.6  7.8
    -3.6  0.4  3.54
     2.4  1.7  4.5

    ```

    然后，我们可以使用以下命令读取数据：

    ```py
    h = np.loadtxt('matrix.txt', dtype=np.float64)
    print h

    ```

+   数组也可以以 `.npy` 格式保存和加载：

    ```py
    np.save('matrix.npy',h)
    hh = np.load('matrix.npy')
    print hh

    ```

# 索引和切片

为了说明索引，我们先使用以下命令创建一个包含随机数据的数组：

```py
import numpy.random
a = np.random.rand(6,5)
print a

```

这会创建一个形状为 `(6,5)` 的数组，包含随机数据。数组的各个元素可以通过常规的索引表示法来访问，例如，`a[2,4]`。

操作 `NumPy` 数据的一个重要技巧是使用 **切片**。切片可以被认为是数组的一个子数组。例如，假设我们想要提取数组 `a` 中的中间两行和前两列的子数组。考虑以下命令：

```py
b = a[2:4,0:2]
print b

```

现在，让我们做一个非常重要的观察。*切片仅仅是数组的一种视图，并没有实际复制数据*。可以通过运行以下命令来验证：

```py
b[0,0]=0
print a

```

所以，`b` 的更改会影响数组 `a`！如果我们确实需要一个副本，我们需要明确表示我们想要一个副本。可以使用以下命令行来实现：

```py
c = np.copy(a[2:4,0:2])
c[0,0] = -1
print a

```

在切片表示法 `i:j` 中，我们可以省略 `i` 或 `j`，在这种情况下，切片将表示对应轴的开始或结束：

```py
print a[:4,3:]

```

省略 `i` 和 `j` 表示整个轴：

```py
print a[:,2:4]

```

最后，我们可以使用 `i:j:k` 的表示法来指定切片中的步幅 `k`。在以下示例中，我们首先创建一个更大的随机数组来说明这一点：

```py
a = np.random.rand(10,6)
print a
print
print a[1:7:2,5:0:-3]

```

现在，让我们考虑更高维度数组的切片。我们将通过创建一个非常大的三维数组来开始：

```py
d1, d2, d3 = 4, 5, 3
a = np.random.rand(d1, d2, d3)
print a

```

假设我们想提取最后一个轴中索引为 `1` 的所有元素。这可以通过使用省略号对象轻松实现，示例如下：

```py
print a[...,1]

```

上述命令行等同于以下命令：

```py
print a[:,:,1]

```

在切片时，也可以沿着某一轴扩展矩阵，如下所示：

```py
print a[0, :, np.newaxis, 0]

```

将前一个命令行的输出与以下输出进行比较：

```py
print a[0, :, 0]

```
