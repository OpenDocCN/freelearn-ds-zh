# 附录 B. Python 简要回顾

# 介绍

本附录将简要介绍 Python 语法。这并不是一个 Python 编程课程，而是供不熟悉该语言的读者作为快速入门使用。以下主题将在本附录中涵盖：

+   基本类型、表达式、变量及其赋值

+   序列类型

+   字典

+   控制结构

+   函数、对象和方法

# 基本类型、表达式、变量及其赋值

任何可以在 Python 代码中引用的数据都被视为**对象**。对象用于表示从*原子*数据（如数字）到非常复杂的数据结构（如多维数组、数据库连接和各种格式的文档）。

在对象层次结构的根部是数值数据类型。这些包括以下内容：

+   **整数**：Python 中有三种类型的整数。

    +   **普通整数**：它们在本地架构中表示，大多数系统中通常是 32 位或 64 位的有符号值。

    +   **长整型**：它们是具有无限范围的整数，取决于可用内存。大多数情况下，程序员不需要关心普通整数和长整型之间的区别。Python 会透明地处理这两种类型之间的转换。

    +   **布尔值**：它们表示`False`和`True`两个值。在大多数情况下，它们分别等价于`0`和`1`。

+   **浮点数**：它们表示本地的双精度浮点数。

+   **复数**：它们表示复数，表示为一对双精度浮点数。

下表展示了每种数据类型的**字面量**（即**常量**）示例：

| 数据类型 | 字面量 |
| --- | --- |
| **整数** | `0`, `2`, `4`, …, `43882838388``5L`, `5l`（长整型）`0xFE4`（十六进制）`03241`（八进制） |
| **实数（float）** | `5.34`, `1.2`, `3.`, `0``1.4e-32`（科学记数法） |
| **复数** | `1.0+3.4j`, `1+2j`, `1j`, `0j`, `complex(4.3, 2.5)` |

虚数单位由`j`表示，但只有在它跟随数字字面量时（否则它表示名为`j`的变量）。因此，要表示虚数单位，必须使用`1j`，复数零为`0j`。复数的实部和虚部总是以双精度浮点值存储。

### 注意

请注意，`NumPy`大大扩展了数值类型的集合，以便进行高效的数值计算。

赋值语句用于将值存储到变量中，如下所示：

```py
a = 3
b = 2.28
c = 12
d = 1+2j

```

Python 支持*多重同时赋值*，因此前四行代码可以等效地写成一行，如下所示：

```py
a, b, c, d = 3, 2.28, 12, 1+2j

```

在多重赋值中，右侧的所有表达式都会在赋值之前被求值。例如，交换两个变量的值的常见惯用法如下所示：

```py
v, w = w, v

```

作为练习，读者可以尝试预测以下语句的结果，前提是已知前面的变量赋值：

```py
a, b, c = a + b, c + d, a * b * c * d
print a, b, c, d

```

以下示例展示了如何计算二次方程的两个解：

```py
a, b, c = 2., -1., -4.
x1, x2 = .5 * (-b - (b ** 2 - 4 * a * c) ** 0.5), .5 * (-b + (b ** 2 - 4 * a * c) ** 0.5)
print x1, x2

```

请注意，我们通过使用小数点强制将变量 `a`、`b` 和 `c` 转换为浮点值。在进行数值计算时，这是一种良好的实践。下表包含了 Python 运算符的部分列表：

| 运算符 | Python 运算符 |
| --- | --- |
| **算术** | `+`（加法）`-`（减法，取负）`*`（乘法）`/`（除法，*见表格下方的注释*）`//`（整数除法）`%`（余数） |
| **比较** | `==`（等于）`>`（大于）`<`（小于）`>=`（大于或等于）`<=`（小于或等于）`!=`（不等于） |
| **布尔** | `and` `or` `not` |
| **位运算布尔** | `&`（与）`&#124;`（或）`^`（异或）`~`（非） |
| **位移** | `<<`（左移）`>>`（右移） |

### 注释

使用除法运算符（`/`）时需要小心。如果操作数是整数，则此操作的结果是整数商。例如，`34/12` 结果为 `2`。要获得浮点结果，我们必须输入浮点操作数，例如 `34./12.`，或者添加以下语句：

```py
from __future__ import division
```

`//` 运算符始终表示整数除法。

算术运算符遵循运算顺序规则，括号可以改变该顺序。比较运算符的优先级低于算术运算符，而 `or`、`and` 和 `not` 运算符的优先级更低。因此，像以下的表达式会得到预期的结果：

```py
2 + 3 < 5 ** 2 and 4 * 3 != 13

```

换句话说，前面的命令行被解析如下：

```py
(((2 + 3) < (5 ** 2)) and ((4 * 3) != 13))

```

逻辑运算符 `and` 和 `or` 采用短路求值，因此，例如，命令中的第二个比较不会被评估：

```py
2 < 3 or 4 > 5

```

位运算符和移位运算符的优先级规则可能不像直观那样清晰，因此建议始终使用括号来指定运算顺序，这也有助于代码的清晰度。

Python 还支持增强赋值。例如，以下命令行首先将值 `5` 赋给 `a`，然后将 `a` 的值加一：

```py
a = 5
a += 1

```

### 注释

Python 不支持递增/递减运算符，如 C 语言中的 a++ 和 ++a。

所有 Python 运算符都有对应的增强赋值语句。任何运算符 `$` 的一般语义如下所示：

```py
v $= <expression>

```

前面的语句等价于以下：

```py
v = v $ (<expression>)

```

### 注释

请注意，`$` 不是一个有效的 Python 运算符，它仅作为一个占位符表示通用运算符。

# 序列类型

Python 序列类型用于表示有序的对象集合。它们分为**可变**序列类型和**不可变**序列类型。在这里，我们只讨论`lists`（可变）和`tuples`与`strings`（均为不可变）。其他序列类型将在本节末尾提到。

## 列表

以下示例演示如何在 Python 中构造一个列表并将其赋值给变量：

```py
numbers = [0, 1.2, 234259399992, 4+3j]

```

列表中的个别条目可以通过索引表示法访问，如下所示：

```py
numbers[2]

```

请注意，索引总是从`0`开始。允许使用负索引，它们表示从列表末尾开始的位置。例如，`numbers[-1]`是最后一个元素，`numbers[-2]`是倒数第二个元素，以此类推。

由于列表是可变的序列类型，我们可以就地修改其中的条目：

```py
numbers[0] = -3
numbers[2] += numbers[0]
print numbers

```

另一种重要的引用 Python 序列类型元素的方法是切片，它允许从列表中提取子列表。由于这个话题对`NumPy`数组非常重要，我们将讨论延迟到附录 C，*NumPy 数组*。

Python 列表具有一组非常实用的功能，其中一些在以下代码示例中得到了体现：

+   要查找列表的长度，请使用以下命令：

    ```py
    len(numbers)

    ```

+   要就地反转列表，请使用以下命令：

    ```py
    numbers.reverse()
    print numbers

    ```

+   要添加一个新元素，请使用以下命令：

    ```py
    numbers.append(35)
    print numbers

    ```

+   要就地对列表进行排序，请使用以下命令：

    ```py
    values = [1.2, 0.5, -3.4, 12.6, 3.5]
    values.sort()
    print values
    values.sort(reverse=True)
    print values

    ```

+   要在指定位置插入一个值，请使用以下命令：

    ```py
    values.insert(3, 6.8)
    print values

    ```

+   要扩展列表，请使用以下命令：

    ```py
    values.extend([7,8,9])
    print values

    ```

Python 有一些便捷的方式来构造常用的列表。`range()`函数返回一个等间隔的整数列表。最简单的形式返回一个从`0`开始的连续整数列表：

```py
range(10)

```

上述命令返回以下列表：

```py
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

请注意，最后一个元素比函数调用中给出的参数少 1。通常规则是，`range(n)`返回一个包含`n`个元素的列表，从零开始，因此最后一个元素是`n-1`。要从非零值开始，请使用以下带有两个参数的版本：

```py
range(3, 17)

```

第三个参数指定一个*增量*。以下命令行会生成一个包含所有小于 100 的正 6 的倍数的列表：

```py
range(6,100,6)

```

也可以使用负增量：

```py
range(20, 2, -3)

```

列表支持连接，表示为`+`运算符：

```py
l1 = range(1, 10)
l2 = range(10, 0, -1)
l3 = l1 + l2
print l3

```

### 注意

请注意，对于`NumPy`数组，`+`运算符被重新定义为表示向量/矩阵加法。

乘法运算符（`*`）可用于通过重复给定列表的元素来构造一个新列表，如下所示：

```py
l4 = 3*[4,-1,5]
print l4

```

在 Python 中构造列表的最灵活方法是使用列表推导式。完整的讨论超出了本附录的范围，但以下示例说明了其中的一些可能性：

+   要显示从`0`到`10`（包括`10`）的整数的平方列表，请使用以下命令行：

    ```py
    [n ** 2 for n in range(11)]

    ```

+   要显示一个整数的所有除数列表，请使用以下命令行：

    ```py
    k = 60
    [d for d in range(1, k+1) if k % d == 0]

    ```

+   要显示小于 100 的所有素数列表，请使用以下命令行（效率较低）：

    ```py
    [k for k in range(2,101) if len([d for d in range(1, k+1) if k % d == 0])==2]

    ```

+   要显示具有整数坐标的点的元组列表及其与原点的距离，请使用以下命令行：

    ```py
    [(i,j,(i*i+j*j)**0.5) for i in range(5) for j in range(6)]

    ```

## 元组

元组与列表类似，但它们是不可变的——一旦创建，其元素就不能修改。

会发生变化。以下命令行将导致错误信息：

```py
t1 = (2,3,5,7)
t1[2] = -4

```

元组在 Python 中有一些特殊用途。它们可以作为字典中的索引（因为它们是不可变的）。它们还构成了 Python 用来从函数返回多个值的机制。例如，内建函数 `divmod()` 返回一个元组，其中包含整数商和余数：

```py
divmod(213, 43)

```

元组支持与列表相同的序列接口，除了会修改元组的那些方法。例如，没有名为 `sort()` 的方法可以就地对元组进行排序。

## 字符串

Python 字符串表示一个不可变的字符序列。有两种字符串类型：`str`，表示 ASCII 字符串，和 `unicode`，表示 Unicode 字符串。

字符串文字是由单引号或双引号括起来的字符序列，如下所示：

```py
s1 = 'I am a string'
s2 = "I am a string"
print s1
print s2

```

单引号和双引号之间没有语义上的区别，唯一的不同是单引号字符串可以包含双引号，而双引号字符串可以包含单引号。例如，以下命令行是正确的：

```py
s3 = "I'm a string"
print s3

```

字符串有两个主要用途：作为字典的索引和打印信息。当打印信息时，字符串有一个 `format()` 方法，可以轻松地显示信息。我们经常使用这个功能为图形添加注释。这里有一个例子：

```py
n = 3
message = 'The square root of {:d} is approximately {:8.5f}.'.format(n, n ** 0.5)
print message

```

在前面的例子中，有两个格式说明符：

+   `{:d}`：这指定了整数值的十进制格式

+   `{:8.5f}`：这指定了一个宽度为 `8`，小数点后有 `5` 位的浮点数格式

格式说明符会按顺序与参数匹配，在这个例子中是 `n` 和 `n ** 0.5`。

字符串有丰富的接口。如果你需要编写与字符串相关的代码，很可能有一个内建函数可以实现，且只需要很少的修改。所有可用字符串方法的列表以及格式化功能，可以参考 [`docs.python.org/2/library/stdtypes.html#string-methods`](https://docs.python.org/2/library/stdtypes.html#string-methods)。

# 字典

Python 字典是一种包含键值对的数据结构。键必须是不可变类型，通常是字符串或元组。以下是一个构建字典的示例：

```py
grades = {'Pete':87, 'Annie':92, 'Jodi':78}

```

要访问某个项，我们提供键作为索引，如下所示：

```py
print grades['Annie']

```

字典是可变的，所以我们可以使用它们来更改条目的值。如果 Jodi 做了额外的工作来提高她的成绩，我们可以这样更改：

```py
grades['Jodi'] += 10
print grades['Jodi']

```

要向字典添加条目，只需为新键赋值：

```py
grades['Ivan']=94

```

然而，尝试访问一个不存在的键会导致错误。

一个需要注意的重要点是，字典是无序的。以下代码是迭代字典的标准惯用法：

```py
for key, item in grades.iteritems():
 print "{:s}'s grade in the test is {:d}".format(key, item)

```

这里的关键点是，输出与字典中条目的添加顺序完全无关。

如需了解更多字典接口的细节，可以参考[`docs.python.org/2/library/stdtypes.html#mapping-types-dict`](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict)。

# 控制结构

控制结构允许改变代码执行的流程。我们关注的有两种结构：**分支**和**循环**。

分支结构根据测试结果执行不同的代码。以下示例展示了一个改进版的代码，用于求解二次方程。使用了`if-then-else`结构来处理实数解和虚数解的情况，如下所示：

```py
a, b, c = 2., -4., 5.
discr = b ** 2 - 4 * a * c
if discr >= 0:
 sqroot = discr ** 0.5
 x1 = 0.5 * (-b + sqroot)
 x2 = 0.5 * (-b - sqroot)
else:
 sqroot = (-discr) ** 0.5
 x1 = 0.5 * (-b + sqroot * 1j)
 x2 = 0.5 * (-b - sqroot * 1j)
print x1, x2

```

上面的代码首先计算二次方程的判别式。然后，使用`if-then-else`语句来判断根是实数还是虚数，这取决于判别式的符号。注意代码的缩进，Python 通过缩进来定义语句块的边界。`if-then-else`结构的一般形式如下：

```py
if <condition>:
 <statement block T>
else:
 <statement block F>

```

首先，条件`<condition>`被评估。如果为`True`，则执行语句`<statement block T>`；否则，执行语句`<statement block F>`。`else:`子句可以省略。

Python 中最常见的循环结构是`for`语句。下面是一个示例：

```py
numbers = [2, 4, 3, 6, 2, 1, 5, 10]
for n in numbers:
 r = n % 2
 if r == 0:
 print 'The integer {:d} is even'.format(n)
 else:
 print 'The integer {:d} is odd'.format(n)

```

我们首先定义一个整数列表。`for`语句使得变量`n`依次取列表中的每个值，并对每个值执行缩进块的代码。注意，`for`循环内部有一个`if-then-else`结构。此外，`print`语句是双重缩进的。

`for`循环常用于执行简单的搜索。一个常见的场景是，当满足某个条件时需要跳出循环。以下代码查找整数范围内的第一个完全平方数：

```py
for n in range(30, 90):
 if int(n ** 0.5) ** 2 == n:
 print n
 break

```

对于给定范围内的每个`n`值，我们先计算`n`的平方根，取其整数部分，再计算平方。如果结果等于`n`，则进入`if`块，打印`n`，然后跳出循环。

如果在范围内没有完全平方数怎么办？将前面的函数`range(30, 60)`改为`range(125, 140)`。运行命令行时不会输出任何内容，因为在`125`到`140`之间没有完全平方数。现在，将命令行改为如下：

```py
for n in range(125, 140):
 if int(n ** 0.5) ** 2 == n:
 print n
 break
else:
 print 'There are no perfect squares in the range'

```

`else`子句只有在执行没有跳出循环时才会被执行，此时会打印出相应的消息。

另一个常见的情况是某些值在迭代过程中需要跳过。以下示例中，我们打印一系列`-1`到`1`之间随机数的平方根，但只有当这些数为正时才打印：

```py
import random
numbers = [-1 + 2 * rand() for _ in range(20)]
for n in numbers:
 if n < 0:
 continue
 print 'The square root of {:8.6} is {:8.6}'.format(n, n ** 0.5)

```

当 Python 遇到`continue`语句时，它会跳过当前执行块的剩余部分，并继续执行控制变量的下一个值。

另一个经常使用的控制结构是`while`循环。该结构在条件为真时执行一组命令。例如，假设我们想计算一组随机生成的值的累加和，但仅当和超过某个值时才停止。可以使用以下代码来实现：

```py
import random
bound = 10.
acc = 0.
n = 0
while acc < bound:
 v = random.random()
 acc += v
 print 'v={:5.4}, acc={:6.4}'.format(v, acc)

```

另一种比预期更常见的情况需要一种叫做**永远循环**的模式。这种情况发生在循环开始时需要检查的条件不可用时。例如，下面的代码实现了著名的`3n+1`游戏：

```py
n = 7
while True:
 if n % 2 == 0:
 n /= 2
 else:
 n = 3 * n + 1
 print n
 if n == 1:
 break

```

游戏从一个任意整数开始，这里是`7`。然后，在每次迭代中，我们测试`n`是否为偶数。如果是，我们将其除以`2`；否则，将其乘以`3`并加上`1`。然后，我们检查是否达到了`1`。如果是，我们退出循环。由于我们不知道是否需要在循环结束前退出，因此我们使用一个永远循环，如下所示：

```py
while True:
 <statements>
 if <condition>:
 break
 <possibly more statements>

```

一些程序员避免使用这种结构，因为如果不小心，很容易导致无限循环。然而，它在某些情况下确实非常有用。顺便说一下，`3n+1`问题中的循环是否对所有初始值都会停止还是一个开放性问题！读者可以尝试使用初始值`n=27`来感受一下。

## 函数、对象和方法

现在我们来介绍使 Python 如此灵活和强大的构造，它的面向对象特性。我们在前面的章节中已经看到了一些面向对象的代码示例（面向对象的范式是 Python 的核心，很难写出不使用它的代码），但现在我们将对这些特性进行更具体的讨论。

### 函数

我们已经看到许多使用函数的例子。例如，`len()`函数用于计算列表的长度：

```py
lst = range(1000)
print len(lst)

```

调用函数的最基本语法如下：

```py
function_name(arg1, arg2, …, argn)

```

在这种情况下，`arg1`、`arg2`、…、`argn`被称为**位置参数**，因为它们是根据出现的位置进行匹配的。例如，我们考虑内置函数`pow()`。这个函数最多接受三个参数：

```py
pow(b, n, m)

```

在这种形式下，前面的函数使用优化算法来计算`b`的`n`次方模`m`。（如果你想知道，这是公共密钥密码学中的一个重要操作。）参数`b`、`n`和`m`是根据它们的位置来关联的。例如，要计算`12`的十次方模`15`，我们使用以下命令：

```py
pow(12, 10, 15)

```

Python 还支持任意大小的参数序列。例如，`max()`函数计算任意序列中的最大值：

```py
max(2,6,8,-3,3,4)

```

前面的命令返回值`8`。

传递参数给函数的第三种方式是使用**关键字参数**。这非常有用，因为通常很难记住位置参数的准确顺序。（例如，我不太愿意编写超过三个或四个位置参数的函数。）

例如，内置的`int()`函数可以用于将字符串转换为整数。可选的关键字参数`base`让我们可以指定转换的进制。例如，以下命令行将给定的`2`进制整数赋值给`n`：

```py
n = int('10111010100001', base=2)
print n

```

关键字参数总是有默认值。在我们的示例中，如果没有指定基数，默认假设为`10`。

我们经常需要编写自己的函数。这是通过关键字`def`来实现的。作为示例，假设我们要编写代码来实现著名的`bisection`方法以数值求解方程。一个可能的解决方案如下：

```py
def bisection(f, a, b, tol=1e-5, itermax=1000):
 fa = f(a)
 fb = f(b)
 if fa * fb > 0:
 raise ValueError('f(a) and f(b) must have opposite signs')
 niter = 0
 while abs(a-b) > tol and niter < itermax:
 m = 0.5 * (a + b)
 fm = f(m)
 if fm * fa < 0:
 b, fb = m, fm
 else:
 a, fa = m, fm
 return min(a, b), max(a, b)

```

上述函数需要三个重要且必要的参数：

+   `f`函数接受一个浮点值作为输入，并返回一个浮点值作为输出。

+   浮点值`a`和`b`，它们指定一个包含函数零点的区间。

另外两个参数是可选的。参数`tol`指定结果所需的容差，`itermax`指定最大迭代次数。要使用`bisection()`函数，必须先定义函数`f`。我们将借此机会展示另一种定义 Python 函数的方式，如下：

```py
from math import cos, pi
f = lambda x: cos(x) - x

```

我们现在准备通过以下命令来调用函数：

```py
bisection(f, 0, pi/2)

```

上述函数返回以下输出：

```py
(0.7390851262506977, 0.7390911183631504)

```

请注意，我们设计了该函数返回一个包含零的区间。该区间的长度小于`tol`，除非达到了最大迭代次数。如果我们希望更小的容差，可以使用以下函数：

```py
bisection(f, 0, pi/2, tol=1E-10)

```

现在，假设我们关注计算所花费的时间。我们可以通过以下方式限制最大次数：

```py
bisection(f, 0, pi/2, itermax=10, tol=1E-20)

```

请注意，关键字参数的顺序是无关紧要的，并且在前面的示例中没有达到所需的容差。

### 对象和方法

对象是 Python 中最通用的数据抽象。实际上，从程序员的角度来看，Python 中的一切都是对象。

对象不过是结构化数据的集合，并且有一个操作这些数据的接口。对象是通过`class`构造定义的，但我们这里的目标并不是展示如何定义类。尽管设计新类是一个高级话题，但使用现有类却相当简单。

作为示例，让我们探索内置类型`str`。首先，我们定义一个可以操作的`str`对象，如下所示：

```py
message = 'Mathematics is the queen of science'

```

首先，让我们将消息转换为大写，如下所示：

```py
message.upper()

```

我们说前述语句调用了`message`对象的`upper()`方法。方法仅仅是与对象关联的函数。以下是`str`对象的其他一些方法：

+   要查找子字符串的第一次出现（如果未找到该字符串，返回`-1`），请使用以下命令行：

    ```py
    message.find('queen')

    ```

+   要将字符串拆分为单词，请使用以下命令行：

    ```py
    words = message.split()
    print words

    ```

+   要计算`s`子字符串出现的次数，请使用以下命令行：

    ```py
    message.count('e')

    ```

+   要用其他内容替换子字符串，请使用以下命令行：

    ```py
    message.replace('Mathematics', 'Mme. Curie')

    ```

### 注意

请注意，前述方法不会改变原始字符串对象，而是返回新的修改过的字符串。字符串是不可变的。对于可变对象，方法可以自由地改变对象中的数据。

# 总结

在本附录中，我们概述了 Python 语法和特性，涵盖了基本类型、表达式、变量和赋值、基本数据结构、函数、对象和方法。
