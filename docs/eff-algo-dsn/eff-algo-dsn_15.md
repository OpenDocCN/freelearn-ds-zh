# 第十五章：<st c="0">11</st>

# <st c="3">数据结构的概貌</st>

<st c="32">算法与数据之间的关系是设计高效软件程序的基础。</st> <st c="135">数据结构的选择直接影响算法的性能，因为基础的数据结构可能需要资源密集型的操作，如搜索、插入和删除，从而可能导致软件执行效率低下。</st> <st c="384">相比之下，更高级的数据结构可以简化这些操作，降低复杂性，并显著提升整体算法性能。</st> <st c="537">理解这种关系是优化软件程序速度和资源使用的关键。</st> <st c="627">软件程序。</st>

<st c="645">在本章中，我们将探索数据结构的各个方面，包括它们作为线性和非线性类型的分类，以及静态和动态数据分配之间的区别。</st> <st c="852">我们还将讨论数据结构所支持的基本操作，例如搜索、插入和删除，并探讨不同数据结构下这些操作的效率差异。</st> <st c="1059">通过研究这些特性，本章旨在提供一个全面的理解，帮助选择和实现最符合特定算法需求的数据结构，从而实现更高效、更有效的</st> <st c="1301">软件设计。</st>

<st c="1317">我们将在</st> <st c="1359">本章中涵盖以下主要内容：</st>

+   <st c="1372">数据结构的分类</st> <st c="1385">数据结构</st>

+   <st c="1400">抽象</st> <st c="1410">数据类型</st>

+   <st c="1420">字典</st>

# <st c="1433">数据结构的分类</st>

<st c="1461">理解</st> <st c="1476">并设计算法而不考虑它们操作的数据是一个不完整的过程。</st> <st c="1573">在</st> *<st c="1576">第一章</st>*<st c="1585">中，我们探讨了计算硬件与算法之间的独特关系。</st> <st c="1666">同样，算法与数据之间也存在着重要的联系。</st> <st c="1740">一个高效的算法在很大程度上依赖于使用合适且高效的数据结构。</st> <st c="1837">因此，在本章及接下来的两章中，我们将从算法设计的角度，专注于数据结构。</st> <st c="1963">虽然数据结构是一个广泛且复杂的领域，值得详细研究，但我们在这里以及接下来的两章中的重点将是它们在</st> <st c="2123">算法效率中的关键作用。</st>

<st c="2144">首先，理解评估和衡量数据结构效率与特征的关键要素至关重要。</st> <st c="2166">了解这些要素很重要，因为选择合适的数据结构直接影响算法的性能和有效性。</st> <st c="2274">当设计一个算法时，选择合适的数据结构不仅仅是个人喜好问题，而是算法</st> <st c="2431">特定需求所决定的必要条件。</st>

<st c="2603">让我们首先定义一下，在算法的背景下什么是数据结构。</st> <st c="2687">数据结构是一种系统化的方式，用于组织、管理和存储计算机中的数据，以便高效地访问和修改。</st> <st c="2833">数据的组织并非随意的；它是专门设计来支持特定类型的操作，这些操作对算法和</st> <st c="3001">计算机程序的性能至关重要。</st>

<st c="3019">在算法领域，数据结构是算法运行的基础。</st> <st c="3122">它决定了数据如何存储、如何检索，以及如何在程序执行过程中进行操作。</st> <st c="3242">算法的效率通常取决于底层数据结构的有效性。</st> <st c="3341">无论任务涉及搜索、排序、插入还是删除数据，数据结构的选择都可能极大地影响算法的速度和资源消耗。</st>

<st c="3515">本质上，数据结构不仅仅是数据组织的一种方法；它是影响算法效率、可扩展性和整体性能的关键组成部分，尤其是在</st> <st c="3704">计算机科学中。</st>

<st c="3721">现在的关键问题是，哪种数据结构最适合特定的计算任务和算法？</st> <st c="3832">本节将致力于解答这个问题。</st> <st c="3887">在本节中，我们将介绍定义数据结构效率的标准。</st> <st c="3982">这些标准将指导我们探索各种数据结构及其对不同类型算法的适用性。</st> <st c="4108">接下来，讨论将转向全面考察数据结构如何分类。</st> <st c="4224">这种数据结构的分类法将帮助我们理解不同类型的数据结构及其适用场景，为选择最合适的数据结构提供结构化的思路。</st> <st c="4444">从而应对特定的算法挑战。</st>

## <st c="4466">物理数据结构与逻辑数据结构</st>

<st c="4506">在数据</st> <st c="4515">结构中，区分物理数据结构和逻辑数据结构非常重要。</st> <st c="4603">**<st c="4605">物理数据结构</st>** <st c="4628">指的是数据在计算机内存中的实际组织和排列。</st> <st c="4635">在这种情况下，数据项在内存中的物理位置决定了它们之间的物理关系。</st> <st c="4716">当算法执行时，它处理的数据以反映其</st> <st c="4821">物理结构的方式存储在计算机内存中。</st>

<st c="4956">物理数据结构直接关系到数据在内存中的布局方式，包括内存分配、指针以及硬件级别上数据的检索或修改方式。</st> <st c="5159">数据的物理组织方式可以显著影响算法的性能，特别是在速度和</st> <st c="5289">内存效率方面。</st>

<st c="5307">相反，**<st c="5322">逻辑数据结构</st>** <st c="5344">指的是算法或程序员所感知的数据的抽象组织。</st> <st c="5351">这是一个概念模型，定义了数据如何相关，而不考虑其物理存储方式。</st> <st c="5556">逻辑数据结构的例子包括数组、链表、树和图。</st> <st c="5641">这些结构由可以在其上执行的操作和数据项之间的关系来定义，而不是它们在内存中的物理位置。</st>

<st c="5806">当算法执行时，它操作这些逻辑数据结构。</st> <st c="5885">然而，为了使算法能够正常运行，必须在逻辑结构和存储数据的物理内存之间建立映射。</st> <st c="6036">这种映射由系统程序和内存管理子系统的组合管理，这些是操作系统的重要组成部分。</st> <st c="6188">这些系统确保算法使用的逻辑数据结构能够有效地转换为适当的物理数据结构</st> <st c="6337">在内存中。</st>

<st c="6347">随着计算机算法和模型抽象层次的提高，对数据物理表示的依赖逐渐减少。</st> <st c="6492">在这些高级层次上，关注点从数据如何在内存中物理存储转移到如何在逻辑上结构化和操作数据以达到</st> <st c="6645">期望的结果。</st>

<st c="6662">本质上，高级算法的设计是为了处理数据，而无需关心底层的物理数据表示。</st> <st c="6819">这种抽象使得算法设计具有更大的灵活性和通用性，因为相同的逻辑结构可以在不同的物理系统上实现，而无需改变</st> <st c="7001">算法本身。</st>

<st c="7018">在本书中，我们专注于在逻辑层面研究数据结构。</st> <st c="7098">这种方法使我们能够集中于数据的抽象组织和可以对其执行的操作，而不依赖于物理存储的具体细节。</st> <st c="7266">通过这种方式理解数据结构，我们可以开发出更具通用性和鲁棒性的算法，这些算法适用于不同的计算环境，无论底层硬件或</st> <st c="7466">内存架构如何。</st>

<st c="7486">总之，物理数据结构关注的是数据在内存中的实际存储，而逻辑数据结构则提供了一种抽象的方式来组织和操作数据。</st> <st c="7668">算法的效率往往取决于这两个方面的管理</st> <st c="7760">和协调。</st>

## <st c="7772">原始数据结构与复合数据结构</st>

<st c="7815">在</st> <st c="7820">讨论数据结构时，区分原始数据结构和复合数据结构至关重要。</st> *<st c="7931">原始数据结构</st>* <st c="7956">是</st> <st c="7960">最基本的数据表示形式。</st> <st c="8006">它们包括基本类型，如整数、浮点数、字符和指针。</st> <st c="8090">这些结构通常由计算机硬件或编程语言直接支持，并且它们是构建更复杂数据结构的基石。</st> <st c="8258">原始数据结构在实现和操作上都很简单，例如赋值、执行算术运算和基本的</st> <st c="8423">输入/输出操作。</st>

<st c="8447">相反，</st> *<st c="8460">复合数据结构</st>* <st c="8485">更为复杂，且由多个原始数据元素组成。</st> <st c="8557">它们被设计用来处理更复杂的数据组织和操作。</st> <st c="8638">复合数据结构的例子包括数组、链表、树和图。</st> <st c="8725">这些结构允许将多个原始数据类型组合成一个更强大的实体，从而实现更复杂的操作，如搜索、排序和</st> <st c="8893">层次化组织。</st>

<st c="8919">复合数据结构对于实现需要处理更复杂数据关系的算法至关重要。</st> <st c="9050">例如，树结构可以表示数据项之间的层次关系，而图结构可以表示更复杂的关系网络。</st> <st c="9220">与原始数据结构不同，复合数据结构需要精心设计和管理，以确保数据处理的高效性。</st> <st c="9355">在本书中（</st>*<st c="9369">第十二章</st>* <st c="9380">和</st> *<st c="9385">第十三章</st>*<st c="9395">），我们的重点是从</st> <st c="9476">逻辑角度理解和利用复合数据结构。</st>

## <st c="9496">线性数据结构与非线性数据结构</st>

<st c="9537">一种重要的</st> <st c="9552">逻辑数据结构分类方法是根据它们的线性性质进行区分。</st> <st c="9615">逻辑数据结构可以分为线性或非线性两种类型，每种类型都有不同的用途，并支持不同类型的</st> <st c="9760">操作。</st>

*<st c="9774">线性数据结构</st>* <st c="9797">是指数据元素按照顺序排列的结构，其中</st> <st c="9872">每个元素与其前后元素相连接，形成一条直线。</st> <st c="9959">线性数据结构的例子包括数组、链表、栈和队列。</st> <st c="10044">在一个线性数据结构中，诸如遍历、插入和删除等操作通常遵循简单的顺序模式。</st> <st c="10182">这种有序的特性使得线性数据结构非常适用于需要按特定顺序处理数据的任务，例如管理队列或执行</st> <st c="10342">简单搜索。</st>

<st c="10358">在内存方面，线性数据结构具有以下</st> <st c="10408">优势：</st>

+   **<st c="10430">连续内存分配</st>**<st c="10459">：线性数据结构，如数组，使用连续的内存块，使得由于引用局部性，内存访问更快、更可预测。</st> <st c="10618">这使得缓存内存的利用更加高效，减少了访问</st> <st c="10700">元素的开销。</st>

+   **<st c="10719">内存管理简便</st>**<st c="10748">：因为线性数据结构通常涉及固定大小（如数组）或顺序指针（如链表），所以内存管理较为简单。</st> <st c="10904">与更复杂的结构相比，内存分配和释放更容易实现。</st>

+   **<st c="10999">低内存开销</st>**<st c="11019">：对于如数组这样的结构，由于不需要额外的指针或链接来连接元素，因此内存开销很小，与非线性结构如树</st> <st c="11242">或图相比，内存使用较低。</st>

<st c="11252">相反，线性数据结构存在</st> <st c="11292">在内存方面的</st> <st c="11319">局限性：</st>

+   **<st c="11329">内存浪费（固定大小限制）</st>**<st c="11369">：在如数组等结构中，内存在创建时为固定数量的元素分配。</st> <st c="11478">如果元素数量少于分配的大小，就会有未使用的内存空间，从而导致</st> <st c="11584">效率低下。</st>

+   **<st c="11608">内存重新分配</st>**<st c="11628">：扩展如数组这样的线性数据结构需要重新分配内存并将元素复制到新的、更大的内存块中，这在时间和空间上都代价高昂。</st> <st c="11813">这种重新分配可能导致内存碎片化</st> <st c="11864">和低效。</st>

+   **<st c="11881">链表中的指针开销</st>**<st c="11914">：在链表中，每个元素存储一个额外的指针指向下一个元素，这增加了总体的内存使用，特别是在处理大量元素时。</st> <st c="12096">这种开销可能抵消通过</st> <st c="12161">动态大小调整获得的一些内存优势。</st>

+   **<st c="12176">顺序内存分配用于连续结构</st>**<st c="12231">：线性结构如数组需要连续的内存块。</st> <st c="12304">如果没有足够的连续空间可用，内存分配可能会失败或变得低效，从而导致潜在的</st> <st c="12424">性能瓶颈。</st>

<st c="12448">线性数据结构的</st> <st c="12453">简洁性通常导致实现上的简便性和性能的可预测性。</st> <st c="12563">然而，它们可能并不总是最有效的选择来表示数据元素之间更复杂的关系，因为它们的顺序性质在</st> <st c="12736">某些场景中可能限制灵活性。</st>

*<st c="12754">非线性数据结构</st>*<st c="12781">相反，</st> <st c="12797">它们并不以线性顺序组织数据。</st> <st c="12838">相反，数据元素以更复杂的方式连接，形成如树、图和堆等结构。</st> <st c="12955">在非线性数据结构中，每个元素可能与多个元素连接，从而能够表示数据点之间的层次或网络关系。</st> <st c="13121">。</st>

<st c="13133">非线性数据结构特别适合表示具有固有分层结构的数据，例如家谱或文件目录，或者建模网络，例如社交连接或交通路线。</st> <st c="13379">它们为需要管理和查询数据项之间复杂关系的任务提供了更大的灵活性和效率。</st> <st c="13512">然而，它们的复杂性也需要更复杂的</st> <st c="13570">遍历、搜索</st> <st c="13608">和操作算法。</st>

<st c="13625">在本书中，我们将从逻辑角度讨论线性（</st>*<st c="13669">第十二章</st>*<st c="13680">）和非线性数据结构（</st>*<st c="13715">第十三章</st>*<st c="13726">）的使用，重点是它们如何支持不同类型</st> <st c="13820">的算法。</st>

## <st c="13834">静态与动态内存分配</st>

<st c="13874">另一种</st> <st c="13883">重要的分类基于内存分配数据的方式。</st> <st c="13959">这种分类将数据结构分为静态数据分配和动态数据分配。</st>

*<st c="14081">静态数据结构</st>* <st c="14104">是</st> <st c="14109">在创建时大小固定的数据结构。</st> <st c="14190">这意味着为数据结构分配的内存量在其生命周期内保持不变。</st> <st c="14302">静态数据结构的一个例子是数组。</st> <st c="14353">当我们声明一个数组时，我们指定它可以容纳的元素数量，这个大小在运行时不能更改。</st> <st c="14474">静态数据结构通常更容易实现和访问，因为它们的内存布局是预先确定的，当数据大小已知时可以实现有效的内存使用</st> <st c="14658">。</st>

<st c="14669">然而，静态数据结构的主要缺点是其缺乏灵活性。</st> <st c="14747">如果实际数据大小超过预定义容量，没有办法在不重新分配内存且潜在移动数据的情况下扩展结构，这可能是低效</st> <st c="14926">和繁琐的。</st>

*<st c="14941">动态数据结构</st>*<st c="14965">则允许在运行时调整内存分配。</st> <st c="15030">这意味着数据结构的大小可以根据需要增长或缩小，具体取决于正在执行的操作。</st> <st c="15152">动态数据结构的例子包括链表、树和图。</st> <st c="15229">在动态数据结构中，随着元素的增加，内存会被分配，随着元素的删除，内存会被回收，从而在处理大小不确定或随时间变化的数据时，提供了更大的灵活性和内存使用的高效性。</st>

<st c="15461">动态数据结构在无法事先确定数据量或需要高效处理变动数据量的场景中尤其有用。</st> <st c="15664">然而，这种灵活性也意味着在内存分配和指针管理上需要额外的开销，这可能导致实现更加复杂，并且与静态数据结构相比，访问速度可能较慢。</st> <st c="15894">在</st> *<st c="15897">第十二章</st>* <st c="15908">和</st> *<st c="15913">第十三章</st>*<st c="15915">中，我们将探讨静态与动态数据结构，重点分析它们的特点、优势</st> <st c="16021">及其权衡。</st>

## <st c="16036">顺序访问与随机访问</st>

<st c="16068">数据结构的最终分类基于数据元素的访问和检索方式。</st> <st c="16072">这种分类将数据结构分为顺序访问和</st> <st c="16264">随机访问两类。</st>

*<st c="16278">顺序访问数据结构</st>* <st c="16312">是指那些数据元素按特定线性顺序访问的数据结构。</st> <st c="16317">要检索特定元素，必须首先遍历前面的元素。</st> <st c="16385">顺序访问数据结构的例子包括链表和队列。</st> <st c="16475">在这些结构中，访问特定元素通常需要迭代一系列节点或元素，这可能导致检索时间变长，特别是当所需元素位于结构较深的位置时</st> <st c="16758">。</st>

<st c="16770">顺序访问通常用于数据元素顺序重要或数据需要按线性方式处理的场景，例如在流应用程序中，或当数据需要逐个元素处理时。</st> <st c="17002">然而，主要的限制是无法直接访问特定元素，必须遍历整个序列，这对于</st> <st c="17156">大数据集来说可能效率低下。</st>

*<st c="17171">随机访问数据结构</st>*<st c="17201">则允许</st> <st c="17220">直接访问任何数据元素，而无需遍历其他元素。</st> <st c="17299">这意味着如果你知道元素的索引或键值，就可以立即检索或修改任何元素。</st> <st c="17394">随机访问数据结构的例子包括数组和哈希表。</st> <st c="17468">例如，在数组中，你可以通过索引直接访问任何元素，从而使得检索和更新等操作</st> <st c="17594">非常快速。</st>

<st c="17604">当需要快速访问单个元素时，随机访问特别有益，尤其是在速度至关重要的应用中，如数据库或实时系统。</st> <st c="17786">然而，这种便利性伴随着一些权衡，比如数组需要连续的内存分配，如果数据结构较为稀疏，可能导致内存使用效率低下。</st>

<st c="17995">在</st> *<st c="17999">第十二章</st>*<st c="18009">中，我们将探讨顺序访问和随机访问数据结构，重点关注它们的使用场景、优势和局限性。</st> <st c="18136">理解不同数据结构的访问模式对设计既高效又适合其处理数据类型的算法至关重要。</st> <st c="18318">在选择顺序访问和随机访问时，这一决定可能会显著影响算法的性能，特别是在速度和</st> <st c="18459">资源利用率方面。</st>

# <st c="18480">抽象数据类型</st>

<st c="18500">一个</st> **<st c="18504">抽象数据类型</st>** <st c="18522">(</st>**<st c="18524">ADT</st>**<st c="18527">)是</st> <st c="18533">一种数据类型的数学模型，数据类型由其行为（操作）定义，而非其实现方式。</st> <st c="18662">ADT 封装了数据和可以对该数据执行的操作，抽象化了实现细节。</st> <st c="18787">换句话说，ADT 指定了哪些操作是可能的，以及这些操作的行为，但并不说明这些操作是如何</st> <st c="18906">实现的。</st>

<st c="18922">抽象数据类型（ADT）是计算机科学中的基础概念，因为它们允许开发人员以更灵活和模块化的方式操作数据。</st> <st c="19048">通过定义操作而不具体说明实现细节，ADT 使得代码更易于维护，并能适应</st> <st c="19172">不同的应用场景。</st>

<st c="19191">ADT 可以根据它们支持的操作和所解决的使用场景分为几种类型。</st> <st c="19313">以下是一些</st> <st c="19327">常见的类型：</st>

+   **<st c="19340">列表</st>**<st c="19345">：列表是</st> <st c="19350">一种表示有序元素集合的抽象数据类型（ADT），其中每个元素在序列中都有一个特定的位置。</st> <st c="19480">列表的主要操作包括插入、删除、访问和遍历元素。</st> <st c="19577">常见的列表实现方式有数组和链表。</st> <st c="19646">数组是一种直接的实现方式，其中元素存储在连续的内存位置中，能够通过索引快速访问。</st> <st c="19784">与此不同，链表是一种更灵活的实现方式，每个元素（或节点）指向下一个元素，允许动态调整大小，并且更容易进行元素的插入或删除。</st> <st c="19966">列表常用于管理有序的项集合，例如学生名单、待办事项列表或歌曲播放列表。</st> <st c="20102">数组和链表将会在</st> *<st c="20152">第十二章</st>*<st c="20162">中讨论。</st>

+   **<st c="20163">栈</st>**<st c="20169">：栈是</st> <st c="20183">一种基于</st> **<st c="20211">后进先出</st>** <st c="20228">(</st>**<st c="20230">LIFO</st>**<st c="20234">)原则的抽象数据类型（ADT），其中</st> <st c="20254">最近添加的元素是第一个被移除的。</st> <st c="20314">栈的主要操作包括</st> **<st c="20365">压栈</st>** <st c="20369">(将元素添加到栈顶)和</st> **<st c="20418">弹栈</st>** <st c="20421">(移除栈顶元素)。</st> <st c="20450">栈的一个常见示例是调用栈，编程语言通过调用栈来跟踪函数的调用与返回。</st> <st c="20566">另一个常见的使用案例是文本编辑器中的撤销机制，其中栈用于回退到先前的状态。</st> <st c="20684">栈在编译器中用于解析表达式、实现回溯算法（例如解决迷宫或谜题），以及管理递归中的嵌套函数调用等方面也至关重要。</st> <st c="20867">栈将在</st> *<st c="20894">第十二章</st>*<st c="20904">中进行回顾。</st>

+   **<st c="20905">队列（Queue）</st>**<st c="20911">：一个</st> <st c="20916">队列是一个抽象数据类型（ADT），它遵循</st> <st c="20949">先进先出（</st> **<st c="20953">FIFO</st>** <st c="20971">）原则，意味着最先加入的元素是最先被移除的。</st> <st c="21055">队列的主要操作是</st> **<st c="21105">入队</st>** <st c="21112">（将元素添加到队列中）和</st> **<st c="21150">出队</st>** <st c="21157">（从队列中移除元素）。</st> <st c="21196">队列在软件编程和计算机系统中有广泛的应用，比如在打印队列中管理打印任务，文档按照接收的顺序进行处理，以及操作系统中的任务调度，进程按队列顺序执行。</st> <st c="21505">在</st> *<st c="21508">第十二章</st>*<st c="21518">中，我们将回顾队列的主要特性。</st>

+   **<st c="21571">双端队列（Deque）</st>**<st c="21597">：一个</st> <st c="21603">双端队列是一个抽象数据类型（ADT），允许元素从序列的两端插入和删除，实际上是对栈和队列的通用化。</st> <st c="21748">例如，</st> **<st c="21793">标准模板库（STL）</st>** <st c="21818">中 C++的双端队列实现提供了一个灵活的序列容器，可以在两端动态增长和缩小。</st> <st c="21829">另一个例子是循环缓冲区，它是一个常用于数据周期性添加和删除的双端队列实现。</st> <st c="21924">双端队列在实现诸如文本编辑器中的撤销/重做功能等软件应用中特别有用。</st> <st c="22058">它们在更复杂的应用中也发挥着重要作用，例如在算法中管理滑动窗口问题。</st> <st c="22179">双端队列将在</st> *<st c="22332">第十二章</st>*<st c="22342">中详细讨论。</st>

+   **<st c="22343">集合</st>**<st c="22347">：集合</st> <st c="22355">是一个抽象数据类型（ADT），表示一组唯一元素，其中元素的顺序不重要。</st> <st c="22461">集合的主要操作包括插入、删除、成员检查以及集合运算，如并集、交集和差集。</st> <st c="22613">集合实现的例子包括</st> **<st c="22653">HashSet</st>** <st c="22660">，它在 Java 中确保集合中没有重复元素，以及</st> **<st c="22738">集合</st>** <st c="22741">，它在 Python 中支持多种数学运算，如并集和交集。</st> <st c="22832">集合广泛应用于诸如管理唯一项目集合（例如，某课程注册学生名单）、实现要求唯一性的操作（例如，从列表中删除重复项）以及进行数学</st> <st c="23077">集合运算等场景。</st>

+   **<st c="23092">字典</st>**<st c="23103">：字典，也</st> <st c="23125">称为映射或关联数组，是一种将数据存储为键值对的抽象数据类型（ADT），其中每个键都是唯一的，并与特定的值相关联。</st> <st c="23280">主要操作包括插入新的键值对、删除键值对、根据键查找值，有时还包括遍历键或值。</st> <st c="23436">字典实现的例子包括</st> **<st c="23483">HashMap</st>** <st c="23490">，它在 Java 中使用唯一键快速检索值，以及</st> **<st c="23562">字典</st>** <st c="23572">，它在 Python 中提供了一种将键映射到值的多功能方式。</st> <st c="23636">字典广泛应用于各种场景，例如实现查找表、管理配置设置（每个设置通过唯一键标识）以及通过键存储和检索数据，例如通过用户 ID 索引的用户个人资料。</st> <st c="23886">关于字典的详细讨论请参见</st> <st c="23940">下一节。</st>

+   **<st c="23953">图</st>**<st c="23959">: 图是</st> <st c="23973">一种抽象数据类型（ADT），表示由节点（称为顶点）组成的集合，节点之间通过边连接。</st> <st c="24068">图可以是有向图，其中边具有特定方向，或者是无向图，其中边没有方向。</st> <st c="24184">图也可以包含环。</st> <st c="24214">图的常见操作包括添加顶点、添加边和遍历结构。</st> <st c="24311">图通常使用邻接表实现，其中每个节点都有一个邻居节点的列表，或者使用邻接矩阵，这是一种二维数组，表示节点之间是否存在边。</st> <st c="24520">图是</st> <st c="24531">广泛应用于各种科学和工程领域，包括建模社交网络、通信网络和交通系统等网络。</st> <st c="24694">图将在</st> *<st c="24726">第十三章</st>*<st c="24736">中进一步讨论。</st>

+   **<st c="24737">树</st>**<st c="24742">: 树</st> <st c="24751">是一种层次结构的抽象数据类型（ADT），其中元素以节点的形式排列，从一个根节点开始，根节点向外分支成子节点，形成子树。</st> <st c="24899">树可以有多种类型，例如二叉树，其中每个节点最多有两个子节点，或者更复杂的结构，如 B 树。</st> <st c="25038">示例包括</st> <st c="25054">**<st c="25059">二叉搜索树</st>**</st> <st c="25077">(</st>**<st c="25079">BST</st>**<st c="25082">) 和堆。</st> <st c="25099">在二叉搜索树中，每个节点最多有两个子节点，左子节点小于父节点，右子节点大于父节点。</st> <st c="25232">堆是一种专门的树结构，遵循</st> **<st c="25293">堆</st>** <st c="25297">属性，通常用于实现优先队列。</st> <st c="25352">我们将在</st> *<st c="25377">第十三章</st>*<st c="25387">中讨论树。</st>

<st c="25388">抽象数据类型（ADT）使程序员能够专注于可以对数据执行哪些操作，而不是如何实现这些操作。</st> <st c="25516">这种抽象化导致了更加灵活、可维护和可重用的代码。</st> <st c="25590">像列表、栈、队列、集合、映射、图和树等 ADT 是计算机科学的基础，每种 ADT 根据数据的性质和所需操作的不同，服务于特定的用例。</st> 

<st c="25783">现在我们已经了解了数据结构分类和抽象数据类型，下一部分将重点介绍可以对数据结构执行的主要操作。</st> <st c="25971">我们将从介绍一种抽象数据结构开始，称为</st> <st c="26036">*字典*</st> <st c="26048">。</st>

# <st c="26049">字典</st>

<st c="26062">字典</st> <st c="26076">是一种抽象数据结构，旨在以键值对的形式存储数据。</st> <st c="26151">在字典中，每个元素由一个唯一的键组成，该键用于访问关联的值。</st> <st c="26255">键值对使得查找变得快速，这是使用字典的主要</st><st c="26328">优势之一。</st> <st c="26366">字典也常被称为映射、关联数组或</st> <st c="26441">符号表。</st>

<st c="26455">尽管我们的重点</st> <st c="26471">主要放在逻辑数据结构上，但值得注意的是，字典也可以通过所谓的关联</st> <st c="26627">存储器，或者</st> **<st c="26638">内容寻址</st>** **<st c="26658">存储器</st>** <st c="26664">(</st>**<st c="26666">CAM</st>**<st c="26669">)直接在硬件中实现。</st>

<st c="26672">关联存储器用于超高速搜索操作。</st> <st c="26743">正如你所料，使用关联存储器时，任何搜索操作都可以在恒定时间内执行，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1790.png)<st c="26844"><st c="26845">。尽管使用关联存储器可能在通用算法应用中显得昂贵且不切实际，但在软件中更可行的做法是使用哈希。</st> <st c="27008">哈希，在</st> *<st c="27040">第七章</st>*<st c="27049">中有所讨论，提供了一种实现内容寻址数据结构的算法方法，允许高效的查找和</st> <st c="27168">其他操作。</st></st>

<st c="27185">字典的主要</st> <st c="27194">特性包括</st> <st c="27229">以下几点：</st>

+   <st c="27243">在大多数实现中，字典不会维护键值对的特定顺序。</st> <st c="27344">元素是根据内部使用的</st> **<st c="27403">哈希</st>** <st c="27407">函数以任意顺序存储的。</st>

+   <st c="27433">字典中的每个键都是唯一的。</st> <st c="27470">如果你试图插入一个新键值对，且其键在字典中已存在，现有的值通常会被</st> <st c="27619">新值覆盖。</st>

+   <st c="27629">字典的主要操作——如插入、删除和访问元素——通常在平均情况下以</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1791.png) <st c="27765"><st c="27766">时间完成，这得益于底层哈希表的实现。</st> <st c="27821">这使得字典在需要快速查找的大型数据集上非常高效。</st>

<st c="27916">问题是如何</st> <st c="27937">实现和维护字典。</st> <st c="27977">幸运的是，许多编程语言都提供了对字典的内置支持。</st> <st c="28060">这是一个简单的例子，展示了字典如何在 Python 中使用：</st>

```py
 # Creating a dictionary to store information about a student
student_info = {
    "name": "John Doe",
    "age": 21,
    "major": "Computer Science",
    "GPA": 3.8
}
# Accessing values using keys
print("Name:", student_info["name"])  # Output: Name: John Doe
print("Age:", student_info["age"])  # Output: Age: 21
# Adding a new key-value pair
student_info["graduation_year"] = 2024
print("Graduation Year:", student_info["graduation_year"])  # Output: Graduation Year: 2024
# Updating an existing value
student_info["GPA"] = 3.9
print("Updated GPA:", student_info["GPA"])  # Output: Updated GPA: 3.9
# Deleting a key-value pair
del student_info["major"]
print("After deletion:", student_info)  # Output: {'name': 'John Doe', 'age': 21, 'GPA': 3.9, 'graduation_year': 2024}
# Iterating over the dictionary
for key, value in student_info.items():
    print(f"{key}: {value}")
```

<st c="28976">这个例子</st> <st c="28990">展示了字典在 Python 中的基本操作，展示了如何轻松创建、操作和访问数据，充分发挥这种强大数据结构的优势。</st> <st c="29152">让我们简要解释一下</st> <st c="29174">代码：</st>

+   **<st c="29183">创建字典</st>**<st c="29205">：我们定义一个字典</st> **<st c="29232">student_info</st>**<st c="29244">，其中包含表示学生各种属性的键值对。</st>

+   **<st c="29312">访问值</st>**<st c="29329">：我们使用</st> **<st c="29373">name</st>** <st c="29377">和</st> **<st c="29382">age</st>** <st c="29385">键，通过方括号访问对应的值。</st>

+   **<st c="29413">添加键值对</st>**<st c="29437">：我们添加一个新的键</st> **<st c="29458">graduation_year</st>**<st c="29473">，并为其指定相应的值。</st>

+   **<st c="29504">更新值</st>**<st c="29521">：我们更新与</st> **<st c="29564">GPA</st>** <st c="29567">键相关联的值。</st>

+   **<st c="29572">删除键值对</st>**<st c="29598">：我们使用</st> **<st c="29615">del</st>** <st c="29620">语句删除</st> **<st c="29649">主要</st>** <st c="29652">键及其值。</st>

+   **<st c="29663">遍历字典</st>**<st c="29693">：我们使用</st> **<st c="29735">for</st>** <st c="29738">循环遍历字典，打印每个</st> <st c="29759">键值对。</st>

<st c="29774">正如我们在前面的例子中所展示的，字典不仅仅是键值对的集合；它们还支持一系列基本操作，允许高效的数据管理。</st> <st c="29976">这些基本操作包括插入、查找、更新（或编辑）和删除。</st> <st c="30058">让我们通过 Python 示例详细探索每个操作的实现。</st>

## <st c="30130">插入</st>

*<st c="30140">插入</st>* <st c="30150">涉及</st> <st c="30159">将一个新的键值对添加到字典中。</st> <st c="30207">如果键已经存在，则更新该键所关联的值；否则，创建一个新的条目。</st> <st c="30316">以下是一个简单字典的插入函数，</st> <st c="30379">用 Python 编写：</st>

```py
 # Creating an empty dictionary
student_grades = {}
# Inserting key-value pairs into the dictionary
student_grades["Alice"] = 85
student_grades["Bob"] = 90
print(student_grades)  # Output: {'Alice': 85, 'Bob': 90}
```

<st c="30601">在此示例中，我们创建一个空字典，名为</st> `<st c="30656">student_grades</st>` <st c="30670">并插入两个键值对 –</st> `<st c="30704">Alice: 85</st>` <st c="30713">和</st> `<st c="30718">Bob: 90</st>`<st c="30725">。字典现在包含这些值，新的</st> <st c="30773">条目可以通过类似方式</st> <st c="30789">添加。</st>

## <st c="30805">搜索</st>

*<st c="30812">搜索</st>* <st c="30819">是</st> <st c="30827">从字典中检索与特定键相关联的值的操作。</st> <st c="30891">这是字典中最常见且高效的操作之一，通常在常数时间内执行。</st> <st c="31002">让我们看一个简单的搜索函数，</st> <st c="31044">它用于字典中：</st>

```py
 # Searching for a value by its key
alice_grade = student_grades.get("Alice")
print("Alice's grade:", alice_grade)  # Output: Alice's grade: 85
# Searching for a non-existent key
charlie_grade = student_grades.get("Charlie", "Not Found")
print("Charlie's grade:", charlie_grade)  # Output: Charlie's grade: Not Found
```

<st c="31371">在这里，</st> `<st c="31382">get</st>` <st c="31385">方法被用来搜索与</st> `<st c="31445">Alice</st>` <st c="31450">键关联的值。</st> <st c="31456">如果键存在，则返回对应的值。</st> <st c="31512">如果未找到键，例如</st> `<st c="31555">Charlie</st>`<st c="31562">，可以返回一个默认值（</st>`<st c="31581">"未找到"</st>`<st c="31593">）。</st> <st c="31603">替代返回。</st>

## <st c="31620">更新</st>

*<st c="31627">更新</st>* <st c="31634">涉及</st> <st c="31644">更改字典中现有键所关联的值。</st> <st c="31714">如果键存在，则其值会被修改；如果键不存在，则会添加一个新的键值对。</st> <st c="31814">以下是一个更新的例子：</st> <st c="31843">例如：</st>

```py
 # Updating an existing key-value pair
student_grades["Alice"] = 88
print(student_grades)  # Output: {'Alice': 88, 'Bob': 90}
# Adding a new key-value pair through update
student_grades["Charlie"] = 92
print(student_grades)  # Output: {'Alice': 88, 'Bob': 90, 'Charlie': 92}
```

<st c="32127">在此示例中，</st> <st c="32148">与</st> `<st c="32175">Alice</st>` <st c="32181">键相关联的值从 85 更新为 88。</st> <st c="32211">此外，一个新的键值对，</st> `<st c="32247">Charlie: 92</st>`<st c="32258">，被添加到</st> <st c="32272">字典中。</st>

## <st c="32287">删除</st>

*<st c="32296">删除</st>* <st c="32305">移除</st> <st c="32314">字典中的一个键值对。</st> <st c="32352">一旦移除，键及其关联的值将不再存在于字典中。</st> <st c="32434">看看下面的</st> <st c="32453">例子：</st>

```py
 # Deleting a key-value pair by key
del student_grades["Bob"]
print(student_grades)  # Output: {'Alice': 88, 'Charlie': 92}
# Attempting to delete a non-existent key (optional approach)
removed_grade = student_grades.pop("David", "Key not found")
print(removed_grade)  # Output: Key not found
```

<st c="32761">在这个例子中，</st> `<st c="32783">del</st>` <st c="32786">语句用于从字典中删除</st> `<st c="32819">"Bob"</st>` <st c="32824">键及其相关的值。</st> <st c="32875">此外，</st> `<st c="32893">pop</st>` <st c="32896">方法用于尝试删除</st> `<st c="32937">David</st>` <st c="32942">键，而该键并不存在于字典中，返回默认消息：</st> `<st c="33017">键</st>` `<st c="33021">未找到</st>`<st c="33030">。</st>

<st c="33031">这些基本操作——插入、查找、更新和删除——对于在任何编程语言中使用字典至关重要。</st> <st c="33172">它们允许高效地管理数据，并使你能够创建动态且适应性强的程序。</st> <st c="33269">无论是添加新数据、检索已有信息、修改值，还是删除条目，这些功能都使字典成为算法设计和日常编程任务中一个多功能且强大的工具。</st> <st c="33470">程序任务。</st>

<st c="33488">在</st> *<st c="33492">第十二章</st>* <st c="33503">和</st> *<st c="33508">第十三章</st>*<st c="33510">中，我们将介绍各种数据结构，并评估它们在这些基本操作中的表现。</st> <st c="33636">此外，某些数据结构包括扩展功能和特定操作，如在二叉搜索树（BST）中查找后继和前驱。</st>

# <st c="33773">总结</st>

<st c="33781">本章探讨了数据结构的基础概念，重点讨论了它们的分类及可执行的基本操作。</st> <st c="33907">本章讨论了物理数据结构和逻辑数据结构之间的区别，以及原始数据结构和复合数据结构之间的区别。</st> <st c="33957">它还涵盖了线性数据结构与非线性数据结构之间的差异，以及静态与动态数据分配、顺序访问与随机访问的影响。</st> <st c="34283">通过这些讨论，强调了为特定算法任务选择合适数据结构的重要性。</st> <st c="34400">。</st>

<st c="34415">本章还提供了关于字典的工作原理的见解，重点介绍了它们的关键操作，如插入、查找、更新和删除，并通过示例演示它们的实际应用。</st> <st c="34622">讨论强调了字典作为一个多功能且高效的工具，在</st> <st c="34711">算法设计中的作用。</st>

<st c="34728">随着我们继续前进，下一章将深入探讨线性数据结构，包括数组和链表，并详细分析它们的属性和应用场景。</st>

# <st c="34910">参考资料与进一步阅读</st>

+   *<st c="34941">算法导论</st>* <st c="34968">作者：Thomas H.</st> <st c="34982">Cormen，Charles E.</st> <st c="35001">Leiserson，Ronald L.</st> <st c="35022">Rivest，和 Clifford Stein。</st> <st c="35050">第四版。</st> <st c="35066">MIT</st> <st c="35070">出版社。</st> <st c="35077">2022：</st>

    +   *<st c="35082">第十章</st>*<st c="35093">，</st> *<st c="35095">基础</st>* *<st c="35106">数据结构</st>*

+   *<st c="35121">算法</st>* <st c="35132">作者：R.</st> <st c="35139">Sedgewick，K.</st> <st c="35153">Wayne。</st> <st c="35160">第四版。</st> <st c="35176">Addison-Wesley。</st> <st c="35192">2011：</st>

    +   *<st c="35197">第一章</st>* *<st c="35206">，</st>* *<st c="35209">基础知识</st>*

+   *<st c="35221">C++中的数据结构与算法分析</st>* <st c="35267">作者：Mark A.</st> <st c="35279">Weiss。</st> <st c="35286">第四版。</st> <st c="35302">Pearson。</st> <st c="35311">2012：</st>

    +   *<st c="35316">第三章</st>*<st c="35326">，</st> *<st c="35328">列表、栈，</st>* *<st c="35343">队列</st>*
