# 前言

欢迎来到 *OpenCL 并行编程开发食谱集*！哇，这个名字确实有点长。这本书是由一位开发者（就是我）为开发者（希望也是你）编写的。这本书对一些人来说可能很熟悉，而对另一些人来说则很独特。它是我在 OpenCL 方面的经验的结果，但更重要的是在编程异构计算环境方面的经验。我想整理我所学到的知识，并与你，读者分享，并决定采用一种方法，即将每个问题分类到一个食谱中。这些食谱旨在简洁，但诚然有些比其他的长。这样做的原因是因为我选择的问题，它们以本书的章节形式出现，描述了你可以如何将这些技术应用到你的当前或未来工作中。希望它能成为你桌上众多参考资料的一部分。我确实希望理解这些问题的解决方案能像帮助我一样帮助你。

这本书是为那些希望不仅知道如何并行编程，而且希望学会并行思维的软件开发者而编写的。在我看来，后者比前者更重要，但单独任何一方都无法解决问题。本书通过代码强化每个概念，并在我们利用更多食谱时对其进行扩展。

本书结构旨在通过让你熟悉 OpenCL 的核心概念，让你轻松地进入 OpenCL，然后我们将通过将新获得的知识应用到你在工作中遇到的各个食谱和一般并行计算问题中进行深入研究。

为了最大限度地利用这本书，强烈建议你是软件开发者或嵌入式软件开发者，并对并行软件开发感兴趣，但不知道从哪里或如何开始。理想情况下，你应该了解一些 C 或 C++（你可以学习 C，因为它相对简单），并且熟悉使用跨平台构建系统，例如 Linux 环境中的 CMake。CMake 的好处是它允许你为那些习惯使用微软的 Visual Studio、苹果的 XCode 或其他集成开发环境的人生成构建环境。我必须承认，本书中的示例没有使用这些工具。

# 本书涵盖的内容

第一章，*使用 OpenCL*，通过建立 OpenCL 的目的和动机为读者设定了场景。核心概念通过涵盖设备和它们之间交互的内在特性以及实际工作代码的食谱来概述。读者将了解上下文和设备以及如何创建在这些设备上运行的代码。

第二章, *理解 OpenCL 数据传输和分区*，讨论了 OpenCL 中的缓冲区对象以及如何在它们之间分区数据的策略。随后，读者将了解工作项是什么以及如何通过利用 OpenCL 抽象来实现数据分区。

第三章, *理解 OpenCL 数据类型*，解释了 OpenCL 提供的两种通用数据类型，即标量和向量数据类型，它们如何用于解决不同的问题，以及 OpenCL 如何抽象处理器的原生向量架构。读者将了解他们如何通过 OpenCL 实现可编程向量化。

第四章, *理解 OpenCL 函数*，讨论了 OpenCL 在解决日常问题（例如几何、排列和三角学）时提供的各种功能。它还解释了如何通过使用它们的向量化对应物来加速这些功能。

第五章, *开发直方图 OpenCL 程序*，见证了典型 OpenCL 开发的生命周期。它还讨论了依赖于对所讨论算法的了解的数据分区策略。读者将无意中意识到并非所有算法或问题都需要相同的方法。

第六章, *开发 Sobel 边缘检测滤波器*，将指导您如何使用 Sobel 方法构建边缘检测滤波器。它将介绍一些数学形式，包括一维和二维的卷积理论及其相应的代码。最后，我们将介绍 OpenCL 中的性能分析是如何工作的以及它在本食谱中的应用。

第七章, *使用 OpenCL 开发矩阵乘法*，通过研究其并行形式并应用从顺序到并行的转换来讨论并行化矩阵乘法。接下来，它将讨论如何通过增加计算吞吐量和预热缓存来优化矩阵乘法。

第八章, *使用 OpenCL 开发稀疏矩阵-向量乘法*，讨论了这种计算的背景以及解决它的传统方法，即通过足够的数学运算使用共轭梯度。一旦这种直觉得到发展，读者将了解各种稀疏矩阵的存储格式如何影响并行计算，然后读者可以检查 ELLPACK、ELLPACK-R、COO 和 CSR。

第九章, *使用 OpenCL 开发 Bitonic 排序*，将向读者介绍排序算法的世界，并专注于并行排序网络，也称为 Bitonic 排序。本章通过展示理论及其顺序实现，从转换中提取并行性，然后开发最终的并行版本，来介绍这些配方，就像我们在所有其他章节中所做的那样。

第十章, *使用 OpenCL 开发基数排序*，将介绍一个非比较排序算法的经典示例，例如 QuickSort，它更适合 GPU 架构。读者还将被介绍到另一种称为归约的核心并行编程技术，我们开发了归约如何帮助基数排序表现更好的直觉。基数排序配方还展示了多个内核编程，并突出了其优点和缺点。

# 你需要这本书的以下内容

您需要在一个 Linux 环境中感到舒适，因为示例是在 Ubuntu 12.10 64 位操作系统上测试的。以下是一些要求：

+   GNU GCC C/C++ 编译器版本 4.6.1（至少）

+   AMD、Intel 和 NVIDIA 的 OpenCL 1.2 SDK

+   AMD APP SDK 版本 2.8 与 AMD Catalyst Linux 显示驱动程序版本 13.4

+   Intel OpenCL SDK 2012

+   CMake 版本 2.8（至少）

+   Clang 版本 3.1（至少）

+   如果你在 Windows 上工作，则需要 Microsoft Visual C++ 2010

+   Boost 库版本 1.53

+   VexCL（由 Denis Demidov 编写）

+   AMD 的 CodeXL Profiler（可选）

+   至少需要八小时的睡眠

+   一个开放和接受的心态

+   一杯新鲜煮的咖啡或任何能起作用的东西

# 这本书是为谁而写的

这本书是为那些经常想知道除了玩电脑游戏之外，如何使用他们新购买的 CPU 或 GPU 的软件开发者而编写的。话虽如此，这本书并不是关于那些只能在你的家用工作站上运行的玩具算法。这本书非常适合那些对 C/C++ 有一定了解并希望学习如何编写在 OpenCL 异构计算环境中执行的并行程序的开发者。

# 约定

在这本书中，你会发现许多不同风格的文本，用于区分不同类型的信息。以下是一些这些风格的示例及其含义的解释。

文本中的代码单词如下显示：“我们可以通过使用 `#include` 指令来包含其他上下文。”

代码块如下设置：

```py
[default]
cl_uint sortOrder = 0; // descending order else 1 for ascending order
        cl_uint stages = 0;
        for(unsigned int i = LENGTH; i > 1; i >>= 1)
            ++stages;
        clSetKernelArg(kernel, 0, sizeof(cl_mem),(void*)&device_A_in);
        clSetKernelArg(kernel, 3, sizeof(cl_uint),(void*)&sortOrder);
#ifdef USE_SHARED_MEM
        clSetKernelArg(kernel, 4, (GROUP_SIZE << 1) *sizeof(cl_uint),NULL);
#elif def USE_SHARED_MEM_2
```

当我们希望将您的注意力引到代码块的一个特定部分时，相关的行或项目将以粗体显示：

```py
[default]
cl_uint sortOrder = 0; // descending order else 1 for ascending order
        cl_uint stages = 0;
        for(unsigned int i = LENGTH; i > 1; i >>= 1)
            ++stages;
        clSetKernelArg(kernel, 0, sizeof(cl_mem),(void*)&device_A_in);
        clSetKernelArg(kernel, 3, sizeof(cl_uint),(void*)&sortOrder);
#ifdef USE_SHARED_MEM
        clSetKernelArg(kernel, 4, (GROUP_SIZE << 1) *sizeof(cl_uint),NULL);
#elif def USE_SHARED_MEM_2
```

任何命令行输入或输出都应如下编写：

```py
# gcc –Wall test.c –o test

```

新术语和重要词汇以粗体显示。你在屏幕上看到的单词，例如在菜单或对话框中，在文本中如下显示：“点击**下一个**按钮将您带到下一屏幕”。

### 注意

警告或重要注意事项以这种框的形式出现。

### 小贴士

技巧和窍门以这种方式出现。

# 读者反馈

我们始终欢迎读者的反馈。请告诉我们您对这本书的看法——您喜欢什么或可能不喜欢什么。读者反馈对我们开发您真正能从中获得最大收益的标题非常重要。

要向我们发送一般反馈，只需发送一封电子邮件到`<feedback@packtpub.com>`，并在邮件主题中提及书名。

如果您在某个主题上具有专业知识，并且您对撰写或为书籍做出贡献感兴趣，请参阅我们的作者指南[www.packtpub.com/authors](http://www.packtpub.com/authors)。

# 客户支持

现在您是 Packt 书籍的骄傲拥有者，我们有一些事情可以帮助您从您的购买中获得最大收益。

## 下载示例代码

您可以从[`www.packtpub.com`](http://www.packtpub.com)的账户下载您购买的所有 Packt 书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。

## 错误清单

尽管我们已经尽一切努力确保我们内容的准确性，但错误仍然会发生。如果您在我们的某本书中找到一个错误——可能是文本或代码中的错误——如果您能向我们报告这一点，我们将不胜感激。通过这样做，您可以节省其他读者的挫败感，并帮助我们改进此书的后续版本。如果您发现任何错误清单，请通过访问[`www.packtpub.com/submit-errata`](http://www.packtpub.com/submit-errata)，选择您的书籍，点击**错误清单****提交****表单**链接，并输入您的错误清单详情来报告它们。一旦您的错误清单得到验证，您的提交将被接受，错误清单将被上传到我们的网站，或添加到该标题的错误清单部分。任何现有的错误清单都可以通过从[`www.packtpub.com/support`](http://www.packtpub.com/support)中选择您的标题来查看。

## 盗版

互联网上版权材料的盗版是一个持续存在的问题，所有媒体都存在。在 Packt，我们非常重视我们版权和许可证的保护。如果您在互联网上发现我们作品的任何非法副本，无论形式如何，请立即提供位置地址或网站名称，以便我们可以追究补救措施。

请通过`<copyright@packtpub.com>`与我们联系，并提供涉嫌盗版材料的链接。

我们感谢您在保护我们作者方面的帮助，以及我们为您提供有价值内容的能力。

## 问题

如果您在本书的任何方面遇到问题，可以通过`<questions@packtpub.com>`与我们联系，我们将尽力解决。
