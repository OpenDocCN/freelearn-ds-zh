- en: Chapter 15. Symbolic Computations - SymPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章：符号计算 - SymPy
- en: In this chapter, we will give a brief introduction on using Python for symbolic
    computations. There is powerful software in the market for performing symbolic
    computations, for example, Maple^(TM) or Mathematica^(TM). But sometimes, it might
    be favorable to make symbolic calculations in the language or framework you are
    used to. At this stage of this book, we assume that this language is Python, so
    we seek for a tool in Python - the SymPy module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍使用 Python 进行符号计算。市场上存在用于执行符号计算的强大软件，例如 Maple^(TM) 或 Mathematica^(TM)。但有时，在您习惯的语言或框架中进行符号计算可能更有利。在本书的这个阶段，我们假设这种语言是
    Python，因此我们寻求在 Python 中找到一个工具——SymPy 模块。
- en: A complete description of SymPy - if possible, would fill an entire book, and
    that is not the purpose of this chapter. Instead, we will stake out a path into
    this tool by some guiding examples, giving a flavor of the potential of this tool
    as a complement to NumPy and SciPy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，对 SymPy 的完整描述将填满整本书，但这不是本章的目的。相反，我们将通过一些指导性示例来探索这个工具，展示这个工具作为 NumPy 和
    SciPy 的补充工具的潜力。
- en: What are symbolic computations?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是符号计算？
- en: All computations we did so far in this book were so-called numeric computations.
    These were a sequence of operations mainly on floating-point numbers. It is the
    nature of numeric computations that the result is an approximation of the exact
    solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中到目前为止所做的所有计算都是所谓的数值计算。这些计算主要是一系列对浮点数的操作。数值计算的本质是结果是对精确解的近似。
- en: Symbolic computations operate on formulas or symbols by transforming them as
    taught in algebra or calculus into other formulas. The last step of these transformations
    might then require that numbers are inserted and a numeric evaluation is performed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 符号计算通过对公式或符号进行变换来操作，这些变换遵循代数或微积分中的教学，然后转换成其他公式。这些变换的最后一步可能需要插入数字并执行数值评估。
- en: 'We illustrate the difference by computing this definite integral:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过计算这个定积分来说明这种差异：
- en: '![What are symbolic computations?](img/integral.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![什么是符号计算？](img/integral.jpg)'
- en: 'Symbolically this expression can be transformed by considering the primitive
    function of the integrand:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从符号上讲，这个表达式可以通过考虑被积函数的原函数来转换：
- en: '![What are symbolic computations?](img/primitive.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![什么是符号计算？](img/primitive.jpg)'
- en: 'We now obtain a formula for the definite integral by inserting the integral
    bounds:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过插入积分界限，我们现在得到了定积分的公式：
- en: '![What are symbolic computations?](img/integralsolution.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![什么是符号计算？](img/integralsolution.jpg)'
- en: This is called a closed-form expression for the integral. Very few mathematical
    problems have a solution that can be given in a closed-form expression. It is
    the exact value of the integral without any approximation. Also no error is introduced
    by representing real numbers as floating-point numbers, which would otherwise
    introduce round-off errors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为积分的闭式表达式。很少有数学问题的解可以用闭式表达式给出。这是积分的精确值，没有任何近似。而且，将实数表示为浮点数时不会引入任何误差，否则会引入舍入误差。
- en: 'Approximation and round-off come into play at the very last moment, when this
    expression needs to be evaluated. The square root and the *arctan* can only be
    evaluated approximately by numerical methods. Such an evaluation gives the final
    result up to a certain (often unknown) precision:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 近似和舍入误差在最后时刻发挥作用，当这个表达式需要被评估时。平方根和反正切函数只能通过数值方法近似计算。这样的评估给出最终结果，精确到一定的（通常是未知的）精度：
- en: '![What are symbolic computations?](img/numintegral.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![什么是符号计算？](img/numintegral.jpg)'
- en: 'On the other hand, numerical computation would directly approximate the definite
    integral by some approximation method, for example, Simpson''s rule, and deliver
    a numeric result, often with an estimate of error. In Python, this is done by
    these commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，数值计算会直接通过某种近似方法（例如辛普森法则）近似定积分，并给出一个数值结果，通常还会给出误差估计。在 Python 中，这是通过以下命令完成的：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: They return the value *0.9896614396122965* and an estimate for the error bound
    *1.1735663442283496 10^(-08).*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它们返回值 *0.9896614396122965* 和误差界限的估计值 *1.1735663442283496 10^(-08)*。
- en: 'The following diagram shows the comparison of numeric and symbolic approximation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了数值和符号近似的比较：
- en: '![What are symbolic computations?](img/symbolic-1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![什么是符号计算？](img/symbolic-1.jpg)'
- en: 'Figure 15.1: Symbolic and numeric quadrature'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1：符号和数值求积
- en: Elaborating an example in SymPy
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 SymPy 中详细说明一个例子
- en: To begin with, let's elaborate the previous example in SymPy which are explained
    the steps.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们详细说明在SymPy中之前提到的例子，并解释步骤。
- en: 'First, we have to import the module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须导入模块：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second command makes sure that formulas are presented in a graphical way,
    if possible. Then, we generate a symbol and define the integrand:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令确保如果可能的话，公式以图形方式呈现。然后，我们生成一个符号并定义被积函数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`x` is now a Python object of type `Symbol` and `f` is a SymPy `Lambda` function
    (note the command starting with a capital letter).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`现在是一个类型为`Symbol`的Python对象，而`f`是一个SymPy的`Lambda`函数（注意命令以大写字母开头）。'
- en: 'Now we start with the symbolic computation of the integral:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始进行积分的符号计算：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Depending on your working environment, the result is presented in different
    ways; refer to following screenshot (*Figure 15.2*) which represents two different
    result of SymPy formula in different environments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的工作环境，结果将以不同的方式呈现；请参考以下截图（*图15.2*），它表示在不同环境中SymPy公式的两个不同结果：
- en: '![Elaborating an example in SymPy](img/screendump.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![在SymPy中详细说明一个例子](img/screendump.jpg)'
- en: 'Figure 15.2: Two screenshots of a SymPy presentation of a formula in two different
    environments.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：SymPy在两个不同环境中展示公式的两个截图。
- en: 'We can check by differentiation whether the result is correct. To this end,
    we assign a name to the primitive function and differentiate with respect to *x*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过微分来检查结果是否正确。为此，我们给原函数赋予一个名称，并对*x*进行微分：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result obtained will be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的结果将如下所示：
- en: '![Elaborating an example in SymPy](img/unsimplifiedsolution.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![在SymPy中详细说明一个例子](img/unsimplifiedsolution.jpg)'
- en: 'which can be simplified by using the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令进行简化：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: to
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '![Elaborating an example in SymPy](img/integrand.jpg).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![在SymPy中详细说明一个例子](img/integrand.jpg)。'
- en: The result we expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预期的结果。
- en: 'The definite integral is obtained by using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令可以获得定积分：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It gives the following output after simplification with `simplify`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`simplify`简化后，得到以下输出：
- en: '![Elaborating an example in SymPy](img/solution2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![在SymPy中详细说明一个例子](img/solution2.jpg)'
- en: 'To obtain a numerical value, we finally evaluate this expression to a floating-point
    number:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个数值，我们最终将这个表达式评估为浮点数：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Basic elements of SymPy
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SymPy的基本元素
- en: Here we introduce the basic elements of SymPy. You will find it favorable to
    be already familiar with classes and data types in Python.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了SymPy的基本元素。你会发现熟悉Python中的类和数据类型会有所帮助。
- en: Symbols - the basis of all formulas
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号 - 所有公式的基石
- en: 'The basic construction element to build a formula in SymPy is the symbol. As
    we saw in the introductory example, a symbol is created by the command `symbols`.
    This SymPy command generates symbol objects from a given string:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在SymPy中构建公式的基元是符号。正如我们在介绍示例中看到的，符号是通过`symbols`命令创建的。这个SymPy命令从给定的字符串生成符号对象：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is actually a short form of following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是以下命令的简写形式：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'followed by a unpacking step to obtain variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行展开步骤以获得变量：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The arguments of the command define the string representation of the symbol.
    The variable name of the symbol is often chosen identical to its string representation,
    but this is not required by the language:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的参数定义了符号的字符串表示。符号的变量名通常选择与其字符串表示相同，但这不是语言的要求：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we also defined that the symbol is assumed to be an integer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还定义了符号被假定为整数。
- en: 'An entire set of symbols can be defined in a very compact way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以非常紧凑地定义一组符号：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, symbols for indexed variables can be defined by using the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以通过以下方式定义索引变量的符号：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This gives a tuple of symbols,
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个符号元组，
- en: '![Symbols - the basis of all formulas](img/tupleofsymbols.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![符号 - 所有公式的基石](img/tupleofsymbols.jpg)'
- en: The rules for the range of the indexes are those we saw earlier in this book
    when working with slices (refer [Chapter 3](ch03.html "Chapter 3. Container Types"),
    *Container Types* for more details).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 索引范围的规则是我们在这本书的早期章节中处理切片时看到的（有关更多详细信息，请参阅[第3章](ch03.html "第3章。容器类型")，*容器类型*）。
- en: Numbers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'Python evaluates operations on numbers directly and introduces unavoidably
    rounding errors. These would obstruct all symbolic calculations. This is avoided
    when we  `sympify` numbers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python直接评估数字上的操作，并不可避免地引入舍入误差。这些会阻碍所有符号计算。当我们`sympify`数字时，可以避免这种情况：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `sympify` command converts an integer to an object of type `sympy.core.numbers.Integer`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympify`命令将整数转换为`sympy.core.numbers.Integer`类型的对象。'
- en: Instead of writing 1/3 as an operation of two integers, it can also be represented
    directly as a rational number by `Rational(1,3)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将1/3写成两个整数的运算，也可以通过`Rational(1,3)`直接表示为一个有理数。
- en: Functions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: SymPy distinguishes between defined and undefined functions. The term undefined
    functions (might be a bit misleading) refers to well-defined Python objects for
    generic functions that have no special properties.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy区分已定义和未定义的函数。未定义函数（可能有些误导）指的是具有无特殊属性的通用函数的明确定义的Python对象。
- en: An example of a function with special properties is `atan` or the `Lambda` function
    used in the introductory example of this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特殊属性的函数示例是`atan`或本章介绍示例中使用的`Lambda`函数。
- en: 'Note the different names for the different implementations of the same mathematical
    function: `sympy.atan` and `scipy.arctan`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意同一数学函数的不同实现有不同的名称：`sympy.atan`和`scipy.arctan`。
- en: Undefined functions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未定义函数
- en: 'A symbol for an undefined function is created by giving the `symbols` command
    an extra class argument:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给`symbols`命令一个额外的类参数来创建一个未定义函数的符号：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The same can be achieved by using the `Function` constructor:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以通过使用`Function`构造函数实现：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: with undefined functions, we can evaluate general rules of calculus.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在未定义函数的情况下，我们可以评估微积分的一般规则。
- en: 'For example, let us evaluate the following expression:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们评估以下表达式：
- en: '![Undefined functions](img/chainrule1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![未定义函数](img/chainrule1.jpg)'
- en: 'This is symbolically computed in Python by using the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个在Python中通过以下命令进行符号计算：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When executed, the previous code returns the following as output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，前面的代码返回以下输出：
- en: '![Undefined functions](img/chainrule2.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![未定义函数](img/chainrule2.jpg)'
- en: This example shows how the product rule and the chain rule were applied.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何应用乘积规则和链式规则。
- en: 'We can even use undefined functions as a function in several variables, for
    example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将未定义函数用作多个变量的函数，例如：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'which returns the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回以下输出：
- en: '![Undefined functions](img/sev_variables.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![未定义函数](img/sev_variables.jpg)'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the use of the star operator to unpack a tuple to form *f* with arguments;
    refer to section *Anonymous functions*, [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用星号运算符将元组解包以形成带有参数的*f*；请参阅*匿名函数*部分，[第7章](ch07.html "第7章。函数")，*函数*。
- en: 'By using list comprehension, we can construct a list of all partial derivatives
    of *f* :'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用列表推导，我们可以构建包含所有偏导数的*f*的列表：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This returns a list with the elements of ![Undefined functions](img/nabla_f.jpg)
    (the gradient of *f*):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个包含![未定义函数](img/nabla_f.jpg)（*f*的梯度）元素的列表：
- en: '![Undefined functions](img/nabla_f_2.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![未定义函数](img/nabla_f_2.jpg)'
- en: 'The command can also be rewritten by using the `diff` method of the `Function`
    object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令也可以通过使用`Function`对象的`diff`方法重写：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another method is Taylor series expansion :'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是泰勒级数展开：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This returns Taylor''s formula, together with the rest term expressed by the
    Landau symbol:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回泰勒公式，以及由Landau符号表示的余项：
- en: '![Undefined functions](img/taylor1.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![未定义函数](img/taylor1.jpg)'
- en: Elementary Functions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本函数
- en: 'Examples for elementary functions in SymPy are trigonometric functions and
    their inverses. The following example shows how simplify acts on expression which
    include elementary function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy中的基本函数示例包括三角函数及其反函数。以下示例展示了`simplify`如何作用于包含基本函数的表达式：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is another example for the use of elementary functions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个使用基本函数的例子：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you use SciPy and SymPy together, we strongly recommend that you use them
    in different namespaces:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时使用SciPy和SymPy，我们强烈建议你在不同的命名空间中使用它们：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Lambda - functions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda - 函数
- en: In section *Anonymous functions* of [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*, we saw how to define so-called anonymous functions in Python. The
    counterpart in SymPy is done by the `Lambda` command. Note the difference; `lambda`
    is a keyword while `Lambda` is a constructor.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。函数")，*函数*的*匿名函数*部分中，我们看到了如何在Python中定义所谓的匿名函数。SymPy中的对应操作是通过`Lambda`命令完成的。注意区别；`lambda`是一个关键字，而`Lambda`是一个构造函数。
- en: The command `Lambda` takes two arguments, the symbol of the function's independent
    variable, and a SymPy expression to evaluate the function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lambda`命令接受两个参数，函数的独立变量符号和一个用于评估函数的SymPy表达式。'
- en: 'Here is an example that defines air resistance (also called drag) as a function
    of speed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，将空气阻力（也称为阻力）定义为速度的函数：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`f_drag` is displayed as an expression:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`f_drag` 显示为一个表达式：'
- en: '![Lambda - functions](img/f_drag.jpg).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![Lambda 函数](img/f_drag.jpg).'
- en: 'This function can be evaluated in the usual way by providing it with an argument:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以通过提供参数以通常的方式评估：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'which will results in given expression:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致给定的表达式：
- en: '![Lambda - functions](img/f_drag2.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Lambda 函数](img/f_drag2.jpg)'
- en: 'It is also possible to create functions in several variables by just providing
    it with several arguments as for example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能通过只提供几个参数来创建多个变量的函数，例如：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A call to this function can be done in two ways, either by directly providing
    several arguments:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数可以通过两种方式完成，要么直接提供几个参数：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'or by unpacking a tuple or list:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过解包元组或列表：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Matrix objects in SymPy make it even possible to define vector-valued functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 中的矩阵对象甚至可以定义向量值函数：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This enables us to compute Jacobians:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够计算雅可比矩阵：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Which gives the following expression as output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下表达式：
- en: '![Lambda - functions](img/jacobian.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Lambda 函数](img/jacobian.jpg)'
- en: 'In the case of more variables, it is convenient to use a more compact form
    to define the function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量的情况下，使用更紧凑的格式来定义函数是方便的：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Symbolic Linear Algebra
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号线性代数
- en: 'Symbolic linear algebra is supported by SymPy''s `matrix` data type which we
    will introduce first. Then we will present some linear algebra methods as examples
    for the broad spectrum of possibilities for symbolic computations in this field:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 符号线性代数由 SymPy 的 `matrix` 数据类型支持，我们首先介绍它。然后，我们将以一些线性代数方法为例，展示在这个领域中符号计算的广泛可能性：
- en: Symbolic matrices
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号矩阵
- en: 'We briefly met the `matrix` data type when we discussed vector valued functions.
    There, we saw it in its simplest form, which converts a list of lists into a matrix.
    To have an example, let''s construct a rotation matrix:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论向量值函数时，我们简要地遇到了 `matrix` 数据类型。在那里，我们看到了它的最简单形式，它将列表的列表转换为矩阵。为了举例，让我们构建一个旋转矩阵：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When working with SymPy matrices we have to note that the operator `*` performs
    matrix multiplications and is not acting as an elementwise multiplication which
    is the case for NumPy arrays.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 SymPy 矩阵时，我们必须注意运算符 `*` 执行矩阵乘法，而不是逐元素乘法，这是 NumPy 数组的情况。
- en: 'The above defined rotation matrix can be checked for orthogonality, by using
    this matrix multiplication and the transpose of a matrix:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义的旋转矩阵可以通过使用以下矩阵乘法和矩阵的转置来检查正交性：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The previous example shows how a matrix is transposed and how the identity
    matrix is created. Alternatively, we could have checked whether its inverse is
    its transpose, which can be done as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了如何转置矩阵以及如何创建单位矩阵。或者，我们也可以检查其逆矩阵是否等于其转置，这可以通过以下方式完成：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another way to set up a matrix is by providing a list of symbols and a shape:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种设置矩阵的方法是提供符号列表和形状：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This creates the following matrix:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下矩阵：
- en: '![Symbolic matrices](img/matrixM.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![符号矩阵](img/matrixM.jpg)'
- en: 'A third way to create a matrix is by generating its entries by a given function.
    The syntax is:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建矩阵的第三种方式是通过给定函数生成其元素。语法是：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We exemplify the above matrix by considering Toeplitz matrix is a matrix with
    constant diagonals. Given a *2n-1 * data vector *a*, its elements are defined
    as
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过考虑 Toeplitz 矩阵是一个具有常数对角线的矩阵来举例说明上述矩阵。给定一个 *2n-1* 数据向量 *a*，其元素定义为
- en: '![Symbolic matrices](img/Toeplitz.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![符号矩阵](img/Toeplitz.jpg)'
- en: 'In SymPy, the matrix can be defined by directly making use of this definition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中，矩阵可以通过直接使用此定义来定义：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Executing the previous code gives `toeplitz(5)`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '执行前面的代码会得到 `toeplitz(5)`:'
- en: '![Symbolic matrices](img/Toeplitz-new.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![符号矩阵](img/Toeplitz-new.jpg)'
- en: 'One clearly sees the desired structures; all elements along subdiagonals and
    superdiagonals are the same. We can access matrix elements by the indexes and
    slices according to the Python syntax introduced in the section *Lists* of [Chapter
    3](ch03.html "Chapter 3. Container Types"), *Container Type*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以清楚地看到所需的结构；所有子对角线和超对角线上的元素都是相同的。我们可以根据第 3 章[列表](ch03.html "第 3 章。容器类型")中介绍的
    Python 语法通过索引和切片来访问矩阵元素：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Examples for Linear Algebra Methods in SymPy
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SymPy 中线性代数方法的示例
- en: 'The basic task in linear algebra is to solve linear equation systems:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数的基本任务是解决线性方程组：
- en: '![Examples for Linear Algebra Methods in SymPy](img/linsys.jpg).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![线性代数方法在SymPy中的示例](img/linsys.jpg)。'
- en: 'Let us do this symbolically for a 3 *×* 3 matrix:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为3 *×* 3矩阵进行符号化处理：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of this relatively small problem is already merely readable which
    can be seen in the following expression:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相对较小的问题的输出已经相当易读，如下所示的表达式所示：
- en: '![Examples for Linear Algebra Methods in SymPy](img/huge_formula.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![线性代数方法在SymPy中的示例](img/huge_formula.jpg)'
- en: 'Again, the use of  `simplify` command helps us to detect canceling terms and
    to collect common factors:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用 `simplify` 命令可以帮助我们检测消去的项并收集公共因子：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'which will result in the following output which looks much better:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出，看起来要好得多：
- en: '![Examples for Linear Algebra Methods in SymPy](img/less_huge_formula.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![线性代数方法在SymPy中的示例](img/less_huge_formula.jpg)'
- en: Symbolic computations becomes very slow with increase in matrix dimensions.
    For dimensions bigger than 15, there might even occur memory problems.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 随着矩阵维度的增加，符号计算会变得非常慢。对于大于15的维度，甚至可能发生内存问题。
- en: 'The preceding figure (*Figure 15.3*) illustrates the differences in CPU time
    between symbolically and numerically solving a linear system:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图（*图15.3*）说明了符号和数值求解线性系统之间CPU时间的差异：
- en: '![Examples for Linear Algebra Methods in SymPy](img/linsys_CPU.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![线性代数方法在SymPy中的示例](img/linsys_CPU.jpg)'
- en: 'Figure 15.3: CPU time for numerically and symbolically solving a linear system.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：数值和符号求解线性系统所需的CPU时间。
- en: Substitutions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换
- en: 'Let us first consider a simple symbolic expression:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑一个简单的符号表达式：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What happens if we set `x = 0` ?  We observe that `b` did not change. What we
    did was that we changed the Python variable `x`. It now no longer refers to the
    symbol object but to the integer object *0*. The symbol represented by the string
    `'x'`  remains unaltered, and so does `b`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `x = 0` 会发生什么？我们观察到 `b` 没有改变。我们所做的是改变了Python变量 `x`。现在它不再指向符号对象，而是指向整数对象
    *0*。由字符串 `'x'` 表示的符号保持不变，`b` 也是如此。
- en: 'Instead, altering an expression by replacing symbols by numbers, other symbols,
    or expressions is done by a special substitution method which can be seen in following
    code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，通过用数字、其他符号或表达式替换符号来改变表达式，是通过一种特殊的替换方法完成的，这在以下代码中可以看到：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This method takes one or two arguments:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个或两个参数：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Dictionaries as arguments allow us to make several substitutions in one step:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将字典作为参数允许我们在一步中执行多个替换：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As items in dictionaries have no defined order - one never knows which would
    be the first - there is a need for assuring that permuting the items would not
    affect the substitution result. Therefore in SymPy, substitutions are first made
    within the dictionary and then on the expression. This is demonstrated by the
    following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典中的项目没有定义的顺序——永远不知道哪个会是第一个——因此需要确保交换项目不会影响替换结果。因此，在SymPy中，首先在字典中进行替换，然后对表达式进行替换。以下示例演示了这一点：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Both substitutions return the same result, that is,
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种替换都返回相同的结果，即
- en: '![Substitutions](img/subs_result.jpg) .'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![替换](img/subs_result.jpg)。'
- en: 'A third alternative to define multiple substitutions is by using a list of
    old-value/ new-value pairs instead:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 定义多个替换的第三种方法是使用旧值/新值对的列表：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is also possible to substitute entire expressions by others:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以用其他表达式替换整个表达式：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To illustrate substitutions of matrix elements, we take the *5 × 5* Toeplitz
    matrix again:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明矩阵元素的替换，我们再次取一个 *5 × 5* 的Toeplitz矩阵：
- en: '![Substitutions](img/Toeplitz.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![替换](img/Toeplitz.jpg)'
- en: Consider the substitution `M.subs(T[0,2],0)`. It changes the symbol object at
    position [0, 2], which is the symbol *a*[2]. It also occurs at two other places,
    which are automatically affected by this substitution.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑替换 `M.subs(T[0,2],0)`。它改变了位置 [0, 2] 的符号对象，即符号 *a*[2]。它还出现在其他两个地方，这些地方会自动受到影响。
- en: 'The given expression is the resulting matrix:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的表达式是得到的矩阵：
- en: '![Substitutions](img/mod_toeplitz.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![替换](img/mod_toeplitz.jpg)'
- en: 'Alternatively we can create a variable for this symbol and use it in the substitution:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以为这个符号创建一个变量并在替换中使用它：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As a more complex example for substitution we describe, how to turn the Toeplitz
    matrix into a tridiagonal Toeplitz matrix*.* This can be done in the following
    ways: First we generate a list of those symbols that we want to substitute; and
    then we use the `zip` command to generate a list of pairs. Finally we substitute
    by giving a list of old-value/new-value pairs as described above:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替换的一个更复杂的例子，我们描述了如何将托普利茨矩阵转换为三对角托普利茨矩阵*.* 这可以通过以下方式完成：首先我们生成一个我们想要替换的符号列表；然后我们使用
    `zip` 命令生成一个成对的列表。最后，我们通过提供上述描述的老值/新值对列表来进行替换：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This gives the following matrix as result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下矩阵作为结果：
- en: '![Substitutions](img/toeplitz_3diag.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![替换](img/toeplitz_3diag.jpg)'
- en: Evaluating symbolic expressions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估符号表达式
- en: In the context of scientific computing, there is often the need of first making
    symbolic manipulations and then converting the symbolic result into a floating-point
    number .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学计算的环境中，通常需要首先进行符号操作，然后将符号结果转换为浮点数。
- en: 'The central tool for evaluating a symbolic expression is `evalf`. It converts
    symbolic expressions to floating-point numbers by using the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 评估符号表达式的核心工具是 `evalf`。它通过以下方式将符号表达式转换为浮点数：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The data type of the resulting object is `Float` (note the capitalization),
    which is a SymPy data type that allows floating-point numbers with an arbitrary
    number of digits (arbitrary precision). The default precision corresponds to 15
    digits, but it can be changed by giving `evalf` an extra positive integer argument
    specifying the desired precision in terms the numbers of digits,
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对象的类型是 `Float`（注意大小写），这是一个 SymPy 数据类型，允许具有任意位数（任意精度）的浮点数。默认精度对应于15位，但可以通过给
    `evalf` 提供一个额外的正整数参数来改变，该参数指定了以数字位数表示的所需精度，
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A consequence of working with arbitrary precision is that numbers can be arbitrary
    small, that is, the limits of the classical floating-point representation are
    broken; refer *Floating Point Numbers* section in [Chapter 2](ch02.html "Chapter 2. Variables
    and Basic Types"), *Variables and Basic Types*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任意精度的一个后果是数字可以是任意小的，也就是说，打破了经典浮点表示的极限；参考[第2章](ch02.html "第2章。变量和基本类型")中的*浮点数*部分，*变量和基本类型*。
- en: Interestingly enough,  evaluating a SymPy function with an input of type `Float`
    returns a Float with the same precision as the input. We demonstrate the use of
    this fact in a more elaborated example from numerical analysis.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 趣味的是，使用 `Float` 类型的输入评估 SymPy 函数会返回与输入相同精度的 `Float`。我们通过一个更详细的数值分析示例来展示这一事实的使用。
- en: 'Example: A study on the convergence order of Newton''s Method'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：牛顿法收敛阶数的研究
- en: 'An iterative method with iterates *x[n]* is said to converge with order *q*
    with ![Example: A study on the convergence order of Newton''s Method](img/qinN.jpg),
    if there exists a positive constant *C* such that'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有迭代项 *x[n]* 的迭代方法，如果存在一个正常数 *C*，使得 ![示例：牛顿法收敛阶数的研究](img/qinN.jpg)，则称其以 *q*
    阶收敛，如果
- en: '![Example: A study on the convergence order of Newton''s Method](img/orderq.jpg).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![示例：牛顿法收敛阶数的研究](img/orderq.jpg)。'
- en: 'Newton''s method when started with a good initial has order *q* = 2, and for
    certain problems, even *q* = 3\. Newton''s method when applied to the problem
    arctan(*x*) = 0 gives the following iteration scheme:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当以良好的初始值开始时，牛顿法的阶数为 *q* = 2，对于某些问题，甚至 *q* = 3。将牛顿法应用于问题 arctan(*x*) = 0 给出以下迭代方案：
- en: '![Example: A study on the convergence order of Newton''s Method](img/atanNewton.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![示例：牛顿法收敛阶数的研究](img/atanNewton.jpg)'
- en: which converges cubically; that is *q* = 3.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这以立方收敛；也就是说 *q* = 3。
- en: This implies that the number of correct digits triples from iteration to iteration.
    To demonstrate cubic convergence and to numerically determine the constant *C*
    is hardly possible with the standard 16-digit float data type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着从迭代到迭代，正确的数字位数翻三倍。为了展示立方收敛并数值确定常数 *C*，使用标准的16位浮点数据类型几乎是不可能的。
- en: 'The following code, uses SymPy together with high-precision evaluation instead
    and puts a study on cubic convergence to the extreme:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 SymPy 和高精度评估代替，并将对立方收敛的研究推向极致：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The result is depicted in the next figure (*Figure 15.4*) which shows that the
    number of correct digits triples from iteration to iteration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图15.4所示，该图显示了从迭代到迭代正确的数字位数翻三倍。
- en: '![Example: A study on the convergence order of Newton''s Method](img/exterem_newton.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![示例：对牛顿法收敛阶数的研究](img/exterem_newton.jpg)'
- en: 'Figure 15.4: A study on the convergence of Newton''s method applied to arctan(x)=0'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：应用于 arctan(x)=0 的牛顿法收敛性研究
- en: 'This extreme precision requirement (3,000 digits!) enables us to evaluate seven
    terms of the preceding sequence to demonstrate cubic convergence in the following
    way:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种极端的精度要求（3,000位！）使我们能够评估前面序列的七个项，以展示以下方式的三次收敛：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is a list of seven terms which let us assume that *C =* 2/3:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含七个项的列表，让我们假设 *C =* 2/3：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Converting a symbolic expression into a numeric function
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将符号表达式转换为数值函数
- en: As we have seen the numerical evaluation of a symbolic expression is done in
    three steps, first we do some symbolic computations and then we substitute values
    by numbers and do an evaluation to a floating point number by `evalf`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，符号表达式的数值评估分为三个步骤，首先进行一些符号计算，然后通过 `evalf` 用数字替换值，并对浮点数进行评估。
- en: The reason for symbolic computations is often that one wants to make parameter
    studies. This requires that the parameter is modified within a given parameter
    range. This requires that an symbolic expression is eventually turned into a numeric
    function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 符号计算的原因通常是因为人们想要进行参数研究。这要求在给定的参数范围内修改参数。这要求最终将符号表达式转换为数值函数。
- en: A study on the parameter dependency of polynomial coefficients
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对多项式系数参数依赖性的研究
- en: 'We demonstrate a symbolic/ numeric parameter study by an interpolation example
    to introduce the SymPy command `lambdify`. Let us consider the task to interpolate
    the data *x* = [0, *t*, 1] and *y* = [0, 1,-1]. Here, *t* is a free parameter,
    which we will vary over the interval [-0.4, 1.4]. The quadratic interpolation
    polynomial has coefficients depending on this parameter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个插值示例来展示符号/数值参数研究，以介绍 SymPy 命令 `lambdify`。让我们考虑一个任务，即插值数据 *x* = [0, *t*,
    1] 和 *y* = [0, 1,-1]。在这里，*t* 是一个自由参数，我们将在区间 [-0.4, 1.4] 内变化它。二次插值多项式的系数依赖于这个参数：
- en: '![A study on the parameter dependency of polynomial coefficients](img/polynomial.jpg).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![对多项式系数参数依赖性的研究](img/polynomial.jpg)。'
- en: 'Using SymPy and the monomial approach described in gives us closed formulas
    for these coefficients:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SymPy 和文中描述的单项式方法，我们可以得到这些系数的封闭公式：
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We obtain a symbolic function for the leading coefficient *a*[2] of the interpolation
    polynomial:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了插值多项式的前导系数 *a*[2] 的符号函数：
- en: '![A study on the parameter dependency of polynomial coefficients](img/leading_coeff.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![对多项式系数参数依赖性的研究](img/leading_coeff.jpg)'
- en: Now it is time to turn the expression into a numeric function, for example,
    to make a plot. This is done by the function `lamdify`.  This function takes two
    arguments, the independent variable  and a SymPy function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将表达式转换为数值函数了，例如，绘制一个图。这是通过函数 `lamdify` 实现的。这个函数接受两个参数，自变量和一个 SymPy 函数。
- en: 'For our example in Python we can write:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Python 示例中，我们可以这样写：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This function can now be plotted, for example, by the following commands:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个函数可以通过以下命令进行绘图，例如：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding figure (*Figure 15.5*) is the result of this parameter study,
    one clearly sees the singularities due to multiple interpolation points, (here
    at *t* = 0 or *t* = 1):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图（*图15.5*）是此参数研究的结果，可以清楚地看到由于多个插值点而产生的奇点（在这里是 *t* = 0 或 *t* = 1）：
- en: '![A study on the parameter dependency of polynomial coefficients](img/leading_coeff-1.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![对多项式系数参数依赖性的研究](img/leading_coeff-1.jpg)'
- en: 'Figure 15.5: The dependency of a polynomial coefficient on the location of
    an interpolation point.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：多项式系数对插值点位置的影响。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter you were introduced in the world of symbolic computations and
    you got a glimpse of the power of SymPy. By guiding examples you learned how to
    set up symbolic expressions, how to work with symbolic matrices, and you saw how
    to make simplifications. Working with symbolic functions and transforming them
    into numerical evaluations built finally the link to scientific computing and
    floating point results. You experienced the strength of SymPy as you used its
    full integration into Python with its powerful constructs and legible syntax.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您被引入了符号计算的世界，并一瞥了SymPy的强大功能。通过引导示例，您学习了如何设置符号表达式，如何处理符号矩阵，以及如何进行简化。通过使用符号函数并将它们转换为数值评估，最终建立了与科学计算和浮点结果的联系。当您使用其与Python的强大构造和易读语法完全集成时，您体验到了SymPy的强大之处。
- en: Consider this last chapter as an appetizer rather than a complete menu. We hope
    you became hungry for future fascinating programming challenges in scientific
    computing and mathematics.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一章视为开胃菜而非完整菜单。我们希望您对科学计算和数学中未来令人着迷的编程挑战产生了渴望。
