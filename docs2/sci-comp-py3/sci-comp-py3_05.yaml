- en: Chapter 5. Advanced Array Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。高级数组概念
- en: In this chapter, we will explain some more advanced aspects of arrays. First,
    we will cover the notion of an array view, followed by Boolean arrays and how
    to compare arrays. We briefly describe indexing and vectorization, explain sparse
    arrays, and some special topics such as broadcasting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释数组的一些更高级的方面。首先，我们将介绍数组视图的概念，然后是布尔数组以及如何比较数组。我们将简要描述索引和向量化，解释稀疏数组，以及广播等一些特殊主题。
- en: Array views and copies
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组视图和副本
- en: In order to control precisely how memory is used, NumPy offers the concept of
    view of an array. Views are smaller arrays that share the same data as a larger
    array. This works just like a reference to one single object (refer to section
    *Basic Types* in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting
    Started*).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确控制内存的使用，NumPy提供了数组的视图概念。视图是较小的数组，与较大的数组共享相同的数据。这就像对一个单一对象的引用（参见[第1章](ch01.html
    "第1章。入门")中的*基本类型*部分，*入门*）。
- en: Array views
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组视图
- en: 'The simplest example of a view is given by a slice of an array:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的简单示例是数组的切片：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding slice is a view of `M`. It shares the same data as `M`. Modifying
    `v` will modify `M` as well:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的切片是`M`的视图。它与`M`共享相同的数据。修改`v`也会修改`M`：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is possible to access the object that owns the data using the array attribute
    `base`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用数组的`base`属性访问拥有数据的对象：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If an array owns its data, the attribute base is none :'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组拥有自己的数据，则基础属性为none：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Slices as views
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为视图的切片
- en: 'There are precise rules on which slices will return views and which ones will
    return copies. Only basic slices (mainly index expressions with `:`) return views,
    whereas any advanced selections (such as slicing with a Boolean) will return a
    copy of the data. For instance, it is possible to create new matrices by indexing
    with lists (or arrays):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '有关于哪些切片会返回视图以及哪些会返回副本的精确规则。只有基本切片（主要是带有`:`的索引表达式）会返回视图，而任何高级选择（例如使用布尔值的切片）都会返回数据的副本。例如，可以通过列表（或数组）索引创建新的矩阵： '
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the array `b` is not a view, whereas the array `c`,
    obtained with a simpler slice, is a view.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，数组`b`不是一个视图，而通过更简单的切片获得的数组`c`是一个视图。
- en: 'There is an especially simple slice of an array that returns a view of the
    whole array:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特别简单的数组切片可以返回整个数组的视图：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Transpose and reshape as views
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转置和重塑作为视图
- en: 'Some other important operations return views. For instance, transpose returns
    a view:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他重要操作会返回视图。例如，转置会返回一个视图：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same applies for all reshaping operations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有重塑操作也适用：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Array copy
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组复制
- en: 'Sometimes it is necessary to explicitly request that the data be copied. This
    is simply achieved with the NumPy function called `array`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要显式请求复制数据。这可以通过NumPy函数`array`简单地实现：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We may verify that the data has indeed been copied:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证数据确实已被复制：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Comparing arrays
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较数组
- en: 'Comparing two arrays is not as simple as it may seem. Consider the following
    code, which is intended to check whether two matrices are close to each other:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个数组并不像看起来那么简单。考虑以下代码，其目的是检查两个矩阵是否接近：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code raises the exception when the `if` statement is executed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`if`语句时，此代码会引发异常：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we explain why this is so and how to remedy this state of affairs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释为什么会这样，以及如何纠正这种情况。
- en: Boolean arrays
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔数组
- en: 'Boolean arrays are useful for advanced array indexing (refer to section *Indexing
    with Boolean arrays*). A Boolean array is simply an array for which the entries
    have the type `bool`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数组对于高级数组索引很有用（参见*使用布尔数组索引*部分）。布尔数组是一个条目类型为`bool`的数组：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Any comparison operator acting on arrays will create a Boolean array instead
    of a simple Boolean:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任何作用于数组的比较运算符都会创建一个布尔数组而不是简单的布尔值：
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that because array comparison creates Boolean arrays, one cannot use array
    comparison directly in conditional statements, for example, `if` statements. the
    solution is to use the methods `all` and `any`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于数组比较会创建布尔数组，因此不能直接在条件语句（例如`if`语句）中使用数组比较。解决方案是使用`all`和`any`方法：
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Checking for equality
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查相等性
- en: 'Checking for equality of two float arrays is not straight forward, because
    two floats may be very close without being equal. In NumPy, it is possible to
    check for equality with `allclose`. This function checks for equality of two arrays
    up to a given precision:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个浮点数组的相等性并不直接，因为两个浮点数可能非常接近但不相等。在NumPy中，可以使用`allclose`来检查相等性。此函数检查两个数组在给定精度下的相等性：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The tolerance is given in terms of a relative tolerance bound, `rtol`, and
    an absolute error bound, `atol`. The command `allclose` is a short form of: `(abs(A-B)
    < atol+rtol*abs(B)).all()`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 容忍度以相对容忍度界限`rtol`和绝对误差界限`atol`的形式给出。`allclose`命令是以下短语的缩写：`(abs(A-B) < atol+rtol*abs(B)).all()`。
- en: 'Note that `allclose` can be also applied to scalars:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`allclose`也可以应用于标量：
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Boolean operations on arrays
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组上的布尔运算
- en: 'You cannot use `and`, `or`, and `not` on Boolean arrays. Indeed, those operators
    force the casting from array to Boolean, which is not permitted. Instead, we can
    use the operators given in the following table (*Table 5.1*) for componentwise
    logical operations on Boolean arrays:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在布尔数组上使用 `and`、`or` 和 `not`。实际上，这些运算符强制将数组转换为布尔类型，这是不允许的。相反，我们可以使用下表中给出的运算符（*表5.1*）来进行布尔数组的逐元素逻辑运算：
- en: '| **Logic operator** | **Replacement for Boolean arrays** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** | **布尔数组的替代** |'
- en: '| `A and B` | `A & B` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `A and B` | `A & B` |'
- en: '| `A or B` | `A &#124; B` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `A or B` | `A &#124; B` |'
- en: '| `not A` | `~ A` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `not A` | `~ A` |'
- en: Table 5.1 Logical operators and, or and not do not work with arrays.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 逻辑运算符and、or和not不适用于数组。
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is an example usage of logical operators with Boolean arrays:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用布尔数组逻辑运算符的一个示例用法：
- en: 'Suppose that we have a sequence of data that is marred with some measurement
    error. Suppose further that we run a regression and it gives us a deviation for
    each value. We wish to obtain all the exceptional values and all the values with
    little deviation that are lower than a given threshold:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一系列带有测量错误的数据。进一步假设我们运行回归分析，并为每个值提供一个偏差。我们希望获得所有异常值以及低于给定阈值的偏差很小的值：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Array indexing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组索引
- en: We have already seen that one may index arrays by combinations of slices and
    integers, this is the basic slicing technique. There are, however, many more possibilities,
    which allow for a variety of ways to access and modify array elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到可以通过切片和整数的组合来索引数组，这是基本的切片技术。然而，还有许多其他可能性，这允许以多种方式访问和修改数组元素。
- en: Indexing with Boolean arrays
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔数组索引
- en: 'It is often useful to access and modify only parts of an array, depending on
    its value. For instance, one might want to access all the positive elements of
    an array. This turns out to be possible using Boolean arrays, which act like masks
    to select only some elements of an array. The result of such an indexing is *always*
    a vector. For instance, consider the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，根据数组的值，访问和修改数组的一部分是有用的。例如，可能想要访问数组中的所有正元素。这实际上可以通过布尔数组来实现，它们充当掩码以仅选择数组的某些元素。这种索引的结果*总是*是一个向量。例如，考虑以下示例：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In fact, the `M[B]` call is equivalent to `M.flatten()[B]`. One may then replace
    the resulting vector by another vector. For instance, one may replace all the
    elements by zero (refer to section *Broadcasting* for more information):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`M[B]`调用等同于`M.flatten()[B]`。然后可以用另一个向量替换结果向量。例如，可以将所有元素替换为零（有关更多信息，请参阅*广播*部分）：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or one may replace all the selected values by others:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以用其他值替换所有选定的值：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By combining the creation of Boolean arrays (`M > 2`), smart indexing (indexing
    with Boolean array), and broadcasting, one may use the following elegant syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合布尔数组的创建（`M > 2`）、智能索引（使用布尔数组索引）和广播，可以使用以下优雅的语法：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The expression broadcasting here refers to the tacit conversion of the scalar
    0 to a vector of an appropriate shape.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的表达式广播是指将标量0隐式转换为适当形状的向量。
- en: Using where
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用where
- en: The command `where` gives a useful construct that can take a Boolean array as
    a condition and either return the indexes of the array elements satisfying the
    condition or return different values depending on the values in the Boolean array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`命令提供了一个有用的结构，可以接受布尔数组作为条件，并返回满足条件的数组元素的索引，或者根据布尔数组中的值返回不同的值。'
- en: 'The basic structure is:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构是：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will return values from `a` when the condition is `True` and values from
    `b` when it is `False`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件为`True`时，这将返回`a`的值，当条件为`False`时，返回`b`的值。
- en: 'For instances consider, a *Heaviside* function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个*海维赛德*函数：
- en: '![Using where](img/B05511_05_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用where](img/B05511_05_01.jpg)'
- en: 'The following code implements a Heaviside function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了一个海维赛德函数：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second and third arguments can be either arrays of the same size as the
    condition (the Boolean array) or scalars. We give two more example to demonstrated
    how to manipulate elements from an array or a scalar depending on a condition:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个参数可以是与条件（布尔数组）大小相同的数组或标量。我们给出两个更多示例，以展示如何根据条件从数组或标量中操作元素：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the second and third arguments are omitted, then a tuple containing the indexes
    of the elements satisfying the condition is returned.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第二个和第三个参数，则返回满足条件的元素的索引组成的元组。
- en: 'For example consider the use of `where` with only one argument in the following
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码中`where`只使用一个参数的使用：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Performance and Vectorization
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和向量化
- en: When it comes to performance of your Python code, it often boils down to the
    difference between interpreted code and compiled code. Python is an interpreted
    programming language and basic Python code is executed directly without any intermediate
    compilation to machine code. With a compiled language, the code needs to be translated
    to machine instructions before execution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到Python代码的性能时，这通常归结为解释代码和编译代码之间的差异。Python是一种解释型编程语言，基本的Python代码是直接执行，而不需要任何中间编译成机器代码。对于编译型语言，代码在执行之前需要被翻译成机器指令。
- en: The benefits of an interpreted language are many but interpreted code cannot
    compete with compiled code for speed. To make your code faster, you can write
    some parts in a compiled language like FORTRAN, C, or C++. This is what NumPy
    and SciPy do.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言的优点很多，但解释型代码在速度上无法与编译型代码竞争。为了使你的代码更快，你可以用像FORTRAN、C或C++这样的编译型语言编写一些部分。这正是NumPy和SciPy所做的事情。
- en: 'For this reason, it is best to use functions in NumPy and SciPy over interpreted
    versions whenever possible. NumPy array operations such as matrix multiplication,
    matrix-vector multiplication, matrix factorization, scalar products, and so on
    are much faster than any pure Python equivalent. Consider the simple case of scalar
    products. The scalar product is much slower than the compiled NumPy function, `dot(a,b)`
    (more than 100 times slower for arrays with about 100 elements):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在可能的情况下，最好使用NumPy和SciPy中的函数，而不是解释型版本。NumPy数组操作，如矩阵乘法、矩阵-向量乘法、矩阵分解、标量积等，比任何纯Python等价物都要快得多。考虑标量积的简单情况。标量积比编译型NumPy函数`dot(a,b)`慢得多（对于大约有100个元素的数组，慢100多倍）：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Measuring the speed of your functions is an important aspect of scientific computing.
    Refer to section *Measuring execution time* in [Chapter 13](ch13.html "Chapter 13. Testing"),
    *Testing, * for details on measuring execution times.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 测量函数的速度是科学计算的一个重要方面。有关测量执行时间的详细信息，请参阅[第13章](ch13.html "第13章。测试")中的*测量执行时间*部分，*测试*。
- en: Vectorization
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量化
- en: 'To improve performance, one has to vectorize the code often. Replacing `for`
    loops and other slower parts of the code with NumPy slicing, operations, and functions
    can give significant improvements. For example, the simple addition of a scalar
    to a vector by iterating over the elements is very slow:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，必须经常向量化代码。用NumPy切片、操作和函数替换`for`循环和其他较慢的代码部分可以带来显著的改进。例如，通过遍历元素将标量加到向量上的简单操作非常慢：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'where using NumPy''s addition is much faster:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中使用NumPy的加法要快得多：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using NumPy slicing can also give significant speed improvements over iterating
    with `for` loops. To demonstrate this let us consider forming the average of neighbors
    in a two-dimensional array:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy切片也可以在迭代`for`循环时提供显著的性能提升。为了演示这一点，让我们考虑在一个二维数组中形成邻居的平均值：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These functions both assign each element the average of its four neighbors.
    The second version, using slicing, is much faster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都给每个元素分配了其四个邻居的平均值。第二种版本，使用切片，要快得多。
- en: Besides replacing `for` loops and other slower constructions with NumPy functions,
    there is a useful function called `vectorize`, refer to section *Functions acting
    on arrays* in [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"), *Linear
    Algebra - Arrays*. This will take a function and create a vectorized version that
    applies the function on all elements of an array using functions wherever possible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用 NumPy 函数替换 `for` 循环和其他较慢的结构之外，还有一个有用的函数叫做 `vectorize`，请参考[第 4 章](ch04.html
    "第 4 章。线性代数 – 数组")中的*作用在数组上的函数*部分，*线性代数 - 数组*。这将创建一个函数，并生成一个向量化版本，该版本尽可能使用函数在数组的所有元素上应用该函数。
- en: 'Consider the following example for vectorizing a function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下将函数向量化的例子：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Applying this by iterating over an array is very slow:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遍历数组应用这个方法非常慢：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead, use `vectorize` to create a new function, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用 `vectorize` 创建一个新的函数，如下所示：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This function can then be applied to the array directly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以直接应用于数组：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The vectorized option is much faster (around 10 times faster with arrays of
    length 100).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化选项要快得多（对于长度为 100 的数组，大约快 10 倍）。
- en: Broadcasting
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播
- en: Broadcasting in NumPy denotes the ability to guess a common, compatible shape
    between two arrays. For instance, when adding a vector (one-dimensional array)
    and a scalar (zero-dimensional array), the scalar is extended to a vector, in
    order to allow for the addition. The general mechanism is called broadcasting.
    We will first review that mechanism from a mathematical point of view, and then
    proceed to give the precise rules for broadcasting in NumPy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 中的广播表示猜测两个数组之间共同、兼容的形状的能力。例如，当将一个向量（一维数组）和一个标量（零维数组）相加时，标量被扩展为一个向量，以便进行加法。这种一般机制称为广播。我们首先将从数学角度回顾该机制，然后继续给出
    NumPy 中广播的精确规则。
- en: Mathematical view
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学视角
- en: Broadcasting is often performed in mathematics, mainly implicitly. Examples
    are expressions such as *f(x) + C* or *f(x) + g(y)*. We'll give an explicit description
    of that technique in this section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 广播在数学中经常进行，主要是隐式的。例如，有如 *f(x) + C* 或 *f(x) + g(y)* 这样的表达式。我们将在本节中给出该技术的明确描述。
- en: We have in mind the very close relationship between functions and NumPy arrays,
    as described in section *Mathematical preliminaries* of [Chapter 4](ch04.html
    "Chapter 4. Linear Algebra – Arrays"), *Linear Algebra - Arrays.*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想到了函数和 NumPy 数组之间非常紧密的关系，正如[第 4 章](ch04.html "第 4 章。线性代数 – 数组")中的*数学预备知识*部分所描述的，*线性代数
    - 数组*。
- en: Constant functions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常函数
- en: 'One of the most common examples of broadcasting is the addition of a function
    and a constant; if *C* is a scalar, one often writes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 广播最常见的一个例子是将函数和常数相加；如果 *C* 是一个标量，人们经常写成：
- en: '![Constant functions](img/sinplusC.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![常函数](img/sinplusC.jpg)'
- en: 'This is an abuse of notation since one should not be able to add functions
    and constants. Constants are however implicitly broadcast to functions. The broadcast
    version of the constant *C* is the function ![Constant functions](img/B05511_05_06_Cbar.jpg)
    defined by:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种符号滥用，因为不应该能够将函数和常数相加。然而，常数却隐式地广播到函数中。常数 *C* 的广播版本是以下定义的函数![常函数](img/B05511_05_06_Cbar.jpg)：
- en: '![Constant functions](img/cbar.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![常函数](img/cbar.jpg)'
- en: 'Now it makes sense to add two functions together:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将两个函数相加是有意义的：
- en: '![Constant functions](img/sinplusCbar.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![常函数](img/sinplusCbar.jpg)'
- en: 'We are not being pedantic for the sake of it, but because a similar situation
    may arise for arrays, as in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是为了吹毛求疵，而是因为类似的情况可能出现在数组中，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, everything happens as if the scalar `1.` had been converted
    to an array of the same length as `vector`, that is, `array([1.,1.,1.,1.])`, and
    then added to `vector`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有的事情都像是将标量 `1.` 转换为与 `vector` 相同长度的数组，即 `array([1.,1.,1.,1.])`，然后添加到
    `vector` 一样发生。
- en: This example is exceedingly simple, so we proceed to show less obvious situations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常简单，所以我们继续展示更不明显的情况。
- en: Functions of several variables
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多变量函数
- en: 'A more intricate example of broadcasting arises when building functions of
    several variables. Suppose, for instance, that we were given two functions of
    one variable, *f* and *g*, and that we want to construct a new function *F* according
    to the formula:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建多变量函数时，广播的一个更复杂的例子出现了。例如，假设我们被给出了两个一元函数，*f* 和 *g*，并且我们想要根据以下公式构建一个新的函数 *F*：
- en: '![Functions of several variables](img/fplusg.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![多变量函数](img/fplusg.jpg)'
- en: This is clearly a valid mathematical definition. We would like to express this
    definition as the sum of two functions in two variables defined as
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个有效的数学定义。我们希望将这个定义表达为两个变量的两个函数之和，这两个函数定义为
- en: '![Functions of several variables](img/fgoverline.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![多个变量的函数](img/fgoverline.jpg)'
- en: 'and now we may simply write:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简单地写成：
- en: '![Functions of several variables](img/fplugoverline.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![多个变量的函数](img/fplugoverline.jpg)'
- en: 'The situation is similar to that arising when adding a column matrix and a
    row matrix:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况与添加列矩阵和行矩阵时出现的情况相似：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is especially useful when sampling functions of two variables, as shown
    in section *Typical examples*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这在采样两个变量的函数时特别有用，如*典型示例*部分所示。
- en: General mechanism
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用机制
- en: 'We have seen how to add a function and a scalar and how to build a function
    of two variables from two functions of one variable. Let us now focus on the general
    mechanism that makes this possible. The general mechanism consists of two steps:
    reshaping and extending.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将一个函数和一个标量相加，以及如何从一个一变量的函数构建一个两个变量的函数。现在让我们关注使这成为可能的一般机制。一般机制由两个步骤组成：重塑和扩展。
- en: 'First, the function *g* is reshaped to a function ![General mechanism](img/gwidetilde.jpg) that
    takes two arguments. One of these arguments is a dummy argument, which we take
    to be zero, as a convention:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，函数*g*被重塑为一个接受两个参数的函数![通用机制](img/gwidetilde.jpg)。其中一个参数是一个虚拟参数，我们将其取为零，作为惯例：
- en: '![General mechanism](img/gtilde-1.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![通用机制](img/gtilde-1.jpg)'
- en: 'Mathematically, the domain of definition of ![General mechanism](img/gwidetilde.jpg)
    is now ![General mechanism](img/domain.jpg)Then the function *f* is reshaped in
    a way similar to:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，![通用机制](img/gwidetilde.jpg)的定义域现在是![通用机制](img/domain.jpg)。然后函数*f*以类似的方式重塑：
- en: '![General mechanism](img/ftilde.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![通用机制](img/ftilde.jpg)'
- en: Now both ![General mechanism](img/fwidetilde.jpg) and ![General mechanism](img/gwidetilde.jpg)
    take two arguments, although one of them is always zero. We proceed to the next
    step, extending. It is the same step that converted a constant into a constant
    function (refer to the constant function example).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，![通用机制](img/fwidetilde.jpg)和![通用机制](img/gwidetilde.jpg)都接受两个参数，尽管其中一个始终为零。我们继续进行下一步，扩展。这是将常数转换为常数函数的相同步骤（参考常数函数示例）。
- en: 'The function ![General mechanism](img/fwidetilde.jpg) is extended to:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数![通用机制](img/fwidetilde.jpg)被扩展为：
- en: '![General mechanism](img/foverlinewide.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![通用机制](img/foverlinewide.jpg)'
- en: 'The function ![General mechanism](img/gwidetilde.jpg) is extended to:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数![通用机制](img/gwidetilde.jpg)被扩展为：
- en: '![General mechanism](img/goverlinewide.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![通用机制](img/goverlinewide.jpg)'
- en: 'Now the function of two variables *F*, which was sloppily defined by *F(x,y)
    = f(x) + g(y)*, may be defined without reference to its arguments:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个变量的函数*F*，它被粗略地定义为*F(x,y) = f(x) + g(y)*，可以不参考其参数来定义：
- en: '![General mechanism](img/Fasfoverlinepluggoverline.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![通用机制](img/Fasfoverlinepluggoverline.jpg)'
- en: 'For example, let us describe the preceding mechanism for constants. A constant
    is a scalar, that is, a function of zero arguments. The reshaping step is thus
    to define the function of one (empty) variable:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们描述一下常数的前置机制。常数是一个标量，也就是说，一个零参数的函数。因此，重塑步骤就是定义一个只有一个（空）变量的函数：
- en: '![General mechanism](img/Cwidetilde.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![通用机制](img/Cwidetilde.jpg)'
- en: 'Now the extension step proceeds simply by:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在扩展步骤简单地通过以下方式继续进行：
- en: '![General mechanism](img/Cwideoverline.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![通用机制](img/Cwideoverline.jpg)'
- en: Conventions
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习惯用法
- en: The last ingredient is the convention on how to add the extra arguments to a
    function, that is, how the reshaping is automatically performed. By convention,
    a function is automatically reshaped by adding zeros on the left.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要素是关于如何向函数添加额外参数的惯例，即如何自动执行重塑。按照惯例，函数通过在左侧添加零自动重塑。
- en: 'For example, if a function *g* of two arguments has to be reshaped to three
    arguments, the new function would be defined by:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个两个参数的函数*g*需要被重塑为三个参数，新的函数将通过以下方式定义：
- en: '![Conventions](img/gthreearguments.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![习惯用法](img/gthreearguments.jpg)'
- en: Broadcasting arrays
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播数组
- en: We now repeat the observation that arrays are merely functions of several variables
    (refer to section *Mathematical preliminaries* in [Chapter 4](ch04.html "Chapter 4. Linear
    Algebra – Arrays"), *Linear Algebra - Arrays*). Array broadcasting thus follows
    exactly the same procedure as explained above for mathematical functions. Broadcasting
    is done automatically in NumPy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在重复观察，数组仅仅是几个变量的函数（请参阅[第4章](ch04.html "第4章。线性代数 – 数组")中的*数学预备知识*部分，*线性代数
    - 数组*）。因此，数组广播严格遵循上述数学函数中解释的相同程序。NumPy中自动执行广播。
- en: 'In the following figure (*Figure 5.1*), we show what happens when adding a
    matrix of shape (4, 3) to a matrix of size (1, 3). The second matrix is of the
    shape (4, 3):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图（*图5.1*）中，我们展示了将形状为 (4, 3) 的矩阵添加到形状为 (1, 3) 的矩阵时会发生什么。第二个矩阵的形状为 (4, 3)：
- en: '![Broadcasting arrays](img/broadcastingMV.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![广播数组](img/broadcastingMV.jpg)'
- en: 'Figure 5.1: Broadcasting between a matrix and a vector.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：矩阵和向量之间的广播。
- en: The broadcasting problem
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广播问题
- en: When NumPy is given two arrays with different shapes, and is asked to perform
    an operation that would require the two shapes to be the same, both arrays are
    broadcast to a common shape.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当NumPy被给出两个形状不同的数组，并被要求执行需要两个形状相同才能进行的操作时，两个数组都会广播到公共形状。
- en: 'Suppose the two arrays have shapes *s[1]* and *s[2]*. This broadcasting is
    performed in two steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设两个数组的形状为 *s[1]* 和 *s[2]*。此广播分为两个步骤进行：
- en: If the shape *s[1]* is shorter than the shape *s[2]* then ones are added on
    the left of the shape *s[1]*. This is a reshaping.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果形状 *s[1]* 比形状 *s[2]* 短，则会在形状 *s[1]* 的左侧添加一些ones。这是一个重塑操作。
- en: When the shapes have the same length, the array is extended to match the shape
    *s[2]* (if possible).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当形状长度相同时，数组会扩展以匹配形状 *s[2]*（如果可能的话）。
- en: Suppose we want to add a vector of shape (3, ) to a matrix of shape (4, 3).
    The vector needs be broadcast. The first operation is a reshaping; the shape of
    the vector is converted from (3, ) to (1, 3). The second operation is an extension;
    the shape is converted from (1, 3) to (4, 3).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将形状为 (3, ) 的向量添加到形状为 (4, 3) 的矩阵中。该向量需要被广播。第一个操作是重塑；向量的形状从 (3, ) 转换为 (1,
    3)。第二个操作是扩展；形状从 (1, 3) 转换为 (4, 3)。
- en: 'For instance, suppose a vector of size *n* is to be broadcast to the shape
    (*m, n*):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个大小为 *n* 的向量要广播到形状 (*m, n*)：
- en: '*v* is automatically reshaped to (1, *n*).'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*v* 将自动重塑为 (1, *n*)。'
- en: '*v* is extended to (*m*, *n*).'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*v* 被扩展到 (*m*, *n*)。'
- en: 'To demonstrate this we consider a matrix defined by:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们考虑一个由以下矩阵定义：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'and vector given by:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以及由以下向量给出：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we may add `M` and `v` directly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接添加 `M` 和 `v`：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result is this matrix:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这个矩阵：
- en: '![The broadcasting problem](img/B05511_05_02.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![广播问题](img/B05511_05_02.jpg)'
- en: Shape mismatch
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状不匹配
- en: 'It is not possible to automatically broadcast a vector `v` of length `n` to
    the shape `(n,m)`. This is illustrated in the following figure:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 无法自动将长度为 `n` 的向量 `v` 广播到形状 `(n,m)`。这在下图中进行了说明：
- en: '![Shape mismatch](img/broadcastingwrong.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![形状不匹配](img/broadcastingwrong.jpg)'
- en: 'The broadcasting will fail, because the shape `(n,)` may not be automatically
    broadcast to the shape `(m, n)`. The solution is to manually reshape `v` to the
    shape `(n,1)`. The broadcasting will now work as usual (by extension only):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 广播将失败，因为形状 `(n,)` 可能无法自动广播到形状 `(m, n)`。解决方案是手动将 `v` 重塑为形状 `(n,1)`。现在广播将像往常一样工作（仅通过扩展）：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is another example, define a matrix  by:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，定义一个矩阵 如下：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and a vector by:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 和一个向量：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now automatic broadcasting will fail, because automatic reshaping does not
    work:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在自动广播将失败，因为自动重塑不起作用：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The solution is thus to take care of the reshaping manually. What we want in
    that case is to add 1 on the right, that is, transform the vector into a column
    matrix. The broadcasting then works directly:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决方案是手动处理重塑。在这种情况下，我们想要在右侧添加1，即把向量转换成一个列矩阵。然后广播将直接工作：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the shape parameter -1, refer to section *Accessing and changing the shape*
    of [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"), *Linear Algebra
     - Arrays.* The result is this matrix:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于形状参数 -1，请参阅[第4章](ch04.html "第4章。线性代数 – 数组")中的*访问和更改形状*部分，*线性代数 - 数组*。结果是这个矩阵：
- en: '![Shape mismatch](img/B05511_05_03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![形状不匹配](img/B05511_05_03.jpg)'
- en: Typical examples
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型示例
- en: Let us examine some typical examples where broadcasting may come in handy.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一些典型的例子，在这些例子中广播可能很有用。
- en: Rescale rows
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重缩放行
- en: 'Suppose `M` is an *n* × *m* matrix, and we want to multiply each row by a coefficient.
    The coefficients are stored in a vector `coeff` with *n* components. In that case,
    automatic reshaping will not work, and we have to execute:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `M` 是一个 *n* × *m* 矩阵，并且我们想要将每一行乘以一个系数。这些系数存储在具有 *n* 个组件的向量 `coeff` 中。在这种情况下，自动重塑将不起作用，我们必须执行：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Rescale columns
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新缩放列
- en: 'The setup is the same here, but we would like to rescale each column with a
    coefficient stored in a vector `coeff` of length *m*. In this case, automatic
    reshaping will work:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里设置是相同的，但我们希望将每个列通过存储在长度为 *m* 的向量 `coeff` 中的系数进行缩放。在这种情况下，自动重塑将起作用：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Obviously, we may also do the reshaping manually and achieve the same result
    with:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们也可以手动重塑并达到相同的结果：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Functions of two variables
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二维函数的图像
- en: 'Suppose *u* and *v* are vectors and we want to form the matrix *W* with elements
    *w[ij] = u[i] + v[j]*. This would correspond to the function *F(x, y) = x + y*.
    The matrix *W* is merely defined by:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *u* 和 *v* 是向量，并且我们想要形成元素 *w[ij] = u[i] + v[j]* 的矩阵 *W*。这对应于函数 *F(x, y) =
    x + y*。矩阵 *W* 仅通过以下方式定义：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the vectors *u* and *v* are [0, 1] and [0, 1, 2] respectively, the result
    is:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向量 *u* 和 *v* 分别是 [0, 1] 和 [0, 1, 2]，则结果是：
- en: '![Functions of two variables](img/B05511_05_04.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![二维函数的图像](img/B05511_05_04.jpg)'
- en: 'More generally, suppose that we want to sample the function *w*(*x, y*) *:=*
    cos(*x*) *+* sin(2*y*). Supposing that the vectors *x* and *y* are defined, the
    matrix *w* of sampled values is obtained by:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，假设我们想要采样函数 *w*(*x, y*) *:=* cos(*x*) *+* sin(2*y*)。假设向量 *x* 和 *y* 已经定义，那么采样值矩阵
    *w* 通过以下方式获得：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that this is very frequently used in combination with `ogrid`. The vectors
    obtained from `ogrid` are already conveniently shaped for broadcasting. This allows
    for the following elegant sampling of the function cos(*x*) *+* sin(2*y*):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这通常与 `ogrid` 结合使用。从 `ogrid` 获得的向量已经方便地塑形，适用于广播。这允许以下优雅的函数 cos(*x*) *+* sin(2*y*)
    的采样：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The syntax of `ogrid` needs some explanation. First, `ogrid` is no function.
    It is an instance of a class with a `__getitem__` method (refer to section *Attributes*
    in [Chapter 8](ch08.html "Chapter 8. Classes"), *Classes*). That is why it is
    used with brackets instead of parentheses.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ogrid` 的语法需要一些解释。首先，`ogrid` 不是一个函数。它是一个具有 `__getitem__` 方法的类的一个实例（参考第8章中的
    *Attributes* 部分 [ch08.html "第8章。类"]，*Classes*）。这就是为什么它使用方括号而不是圆括号的原因。'
- en: 'The two commands are equivalent:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令是等效的：
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The stride parameter in the preceding example is a complex number. This is
    to indicate that it is the number of steps instead of the step size. The rules
    for the stride parameter might be confusing at first glance:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，步长参数是一个复数。这是为了表明它是步数而不是步长。步长参数的规则一开始可能看起来有些令人困惑：
- en: If the stride is a real number, then it defines the size of the steps between
    start and stop and stop is not included in the list.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果步长是一个实数，那么它定义了起始点和终点之间的步长大小，并且终点不包含在列表中。
- en: If the stride is a complex number `s`, then the integer part of `s.imag` defines
    the number of steps between start and stop and stop is included in the list.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果步长是一个复数 `s`，那么 `s.imag` 的整数部分定义了起始点和终点之间的步数，并且终点包含在列表中。
- en: 'Another example for the output of `ogrid` is a tuple with two arrays, which
    can be used for broadcasting:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ogrid` 的另一个输出示例是一个包含两个数组的元组，可以用于广播：'
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'gives:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 给出：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'which is equivalent to:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Sparse matrices
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: Matrices with a small number of nonzero entries are called **sparse matrices**.
    Sparse matrices occur, for example, in scientific computing when describing discrete
    differential operators in the context of numerically solving partial differential
    equations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 具有少量非零元素的矩阵称为**稀疏矩阵**。稀疏矩阵在科学计算中很常见，例如在数值求解偏微分方程时描述离散微分算子。
- en: Sparse matrices often have large dimensions, sometimes so large that the entire
    matrix (with zero entries) would not even fit in the available memory. This is
    one motivation for a special type for sparse matrices. Another motivation is better performance
    of operations where zero matrix entries can be avoided.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵通常具有很大的维度，有时甚至大到整个矩阵（包含零元素）都无法适应可用的内存。这是为稀疏矩阵创建特殊类型的一个动机。另一个动机是避免零矩阵元素的操作可以更好地提高性能。
- en: There are only a very limited number of algorithms for general, unstructured
    sparse matrices in linear algebra. Most of them are iterative in nature and based
    on efficient implementations of matrix-vector multiplication for sparse matrices.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数中，对于通用、无结构的稀疏矩阵，只有非常有限数量的算法。大多数都是迭代的，并且基于稀疏矩阵矩阵-向量乘法的有效实现。
- en: Examples for sparse matrices are diagonal or banded matrices. The simple pattern
    of these matrices allows straightforward storing strategies; the principal diagonal
    and the sub- and super-diagonals are stored in 1D arrays. Conversion from a sparse
    representation to the classical array type and vice-versa can be done by the command
    `diag`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵的例子包括对角矩阵或带状矩阵。这些矩阵的简单模式允许直接存储策略；主对角线和次对角线存储在 1D 数组中。通过 `diag` 命令可以将稀疏表示转换为经典数组类型，反之亦然。
- en: In general, there is not such a simple structure and the description of sparse
    matrices requires special techniques and standards. Here we present a row and
    a column oriented type for sparse matrices, both available through the module
    `scipy.sparse` .
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，没有如此简单的结构，稀疏矩阵的描述需要特殊的技术和标准。在这里，我们展示了稀疏矩阵的行和列导向类型，两者都可通过模块 `scipy.sparse`
    获取。
- en: '![Sparse matrices](img/sparse.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![稀疏矩阵](img/sparse.jpg)'
- en: 'Figure 5.2: A stiffness matrix from a finite element model of an elastic plate.
    The pixels denote nonzero entries in the 1250 × 1250 matrix'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：弹性板有限元模型的刚度矩阵。像素表示 1250 × 1250 矩阵中的非零项
- en: Sparse matrix formats
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稀疏矩阵格式
- en: 'The `scipy.sparse` module provides many different storing formats from sparse
    matrices. We describe here only the most important ones: CSR, CSC, and LIL. The
    LIL format should be used for generating and altering sparse matrices; CSR and
    CSC are efficient formats for matrix-matrix and matrix-vector operations.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.sparse` 模块提供了许多不同的稀疏矩阵存储格式。我们在这里只描述最重要的几种：CSR、CSC 和 LIL。LIL 格式应用于生成和修改稀疏矩阵；CSR
    和 CSC 是矩阵-矩阵和矩阵-向量操作的效率格式。'
- en: Compressed sparse row
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩稀疏行
- en: 'The compressed sparse row format (CSR) uses three arrays: `data`, `indptr`,
    and `indices`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩稀疏行格式（CSR）使用三个数组：`data`、`indptr` 和 `indices`：
- en: The 1D array `data` stores all the nonzero values in order. It has as many elements
    as there are nonzero elements, often denoted by the variable `nnz`.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1D 数组 `data` 按顺序存储所有非零值。它包含与非零元素数量相同的元素，通常用变量 `nnz` 表示。
- en: The 1D array `indptr` contains integers such that `indptr[i]` is the index of
    the element in `data`, which is the first nonzero element of row *i*. If the entire
    row *i* is zero, then `indptr[i]==indptr[i+1]`. If the original matrix has *m*
    rows, then `len(indptr)==m+1`.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1D 数组 `indptr` 包含整数，使得 `indptr[i]` 是 `data` 中元素的索引，它是行 *i* 的第一个非零元素。如果行 *i*
    的所有元素都是零，则 `indptr[i]==indptr[i+1]`。如果原始矩阵有 *m* 行，则 `len(indptr)==m+1`。
- en: The 1D array `indices` contains the column index information in such a way that
    `indices[indptr[i]:indptr[i+1]]` is an integer array with the column indexes of
    the nonzero elements in row *i*. Obviously, `len(indices)==len(data)==nnz`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1D 数组 `indices` 包含列索引信息，使得 `indices[indptr[i]:indptr[i+1]]` 是一个整数数组，包含行 *i*
    中非零元素的列索引。显然，`len(indices)==len(data)==nnz`。
- en: 'Let''s see an example: The CSR format of the matrix:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：矩阵的 CSR 格式：
- en: '![Compressed sparse row](img/B05511_05_05.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![压缩稀疏行](img/B05511_05_05.jpg)'
- en: 'is given by the three arrays:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由三个数组给出：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The module `scipy.sparse` provides a type, `csr_matrix`, with a constructor,
    which can be used in the following ways:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.sparse` 模块提供了一个类型 `csr_matrix`，它有一个构造函数，可以按以下方式使用：'
- en: With a 2D array as argument
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 2D 数组作为参数
- en: With a matrix in one of the other sparse formats in `scipy.sparse`
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `scipy.sparse` 中的其他稀疏格式之一中
- en: With a shape argument, `(m,n)`, to generate a zero matrix in CSR format
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形状参数 `(m,n)` 生成 CSR 格式的零矩阵
- en: By a 1D array for the `data` and an integer array `ij` with the shape `(2,len(data))`
    such that `ij[0,k]` is the row index and `ij[1,k]` is the column index of `data[k]`
    of the matrix
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个 1D 数组 `data` 和一个形状为 `(2,len(data))` 的整数数组 `ij`，其中 `ij[0,k]` 是矩阵中 `data[k]`
    的行索引，`ij[1,k]` 是列索引
- en: The three arguments, `data`, `indptr`, and `indices`, can be given to the constructor
    directly
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以直接将三个参数 `data`、`indptr` 和 `indices` 传递给构造函数
- en: The first two options are there for conversion purposes while the last two directly
    define the sparse matrix.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种选项用于转换目的，而最后两种直接定义稀疏矩阵。
- en: 'Consider the above example in python look like:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑上述示例在 Python 中的样子：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Among others, the following attributes are provided:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，以下属性被提供：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Compressed Sparse Column
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩稀疏列
- en: The CSR format has a column oriented twin - the compressed sparse column (CSC)
    format. The only difference in it compared to the CSR format is the definition
    of the `indptr` and `indices` arrays, which are now column-related. The type for
    the CSC format is `csc_matrix` and its use corresponds to `csr_matrix`, explained
    previously in this section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: CSR 格式有一个列向量的双胞胎 - 压缩稀疏列 (CSC) 格式。与 CSR 格式相比，唯一的区别是 `indptr` 和 `indices` 数组的定义，现在与列相关。CSC
    格式的类型是 `csc_matrix`，其使用与之前本节中解释的 `csr_matrix` 相对应。
- en: 'Continuing the same example in CSC format:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以 CSC 格式相同的示例：
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Row-based linked list format
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于行的链表格式
- en: The linked list sparse format stores the nonzero matrix entries rowwise in a
    list `data` such that `data[k]` is a list of the nonzero entries in row *k*. If
    all entries in that row are 0, it contains an empty list.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 链表稀疏格式将非零矩阵项按行存储在列表 `data` 中，使得 `data[k]` 是行 *k* 中非零项的列表。如果该行的所有项都是0，则包含一个空列表。
- en: 'A second list, `rows`, contains at position *k* a list of column indexes of
    the nonzero elements in row *k*.  Here is an example in **Row-Based linked List
    Format (LIL)** format:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个列表，`rows`，在位置 *k* 处包含行 *k* 中非零元素的列索引列表。以下是一个 **基于行的链表格式 (LIL)** 格式的示例：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Altering and slicing matrices in LIL format
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 LIL 格式中修改和切片矩阵
- en: 'The LIL format is the one best suited for slicing, that is, extracting submatrices
    in LIL format, and for changing the sparsity pattern by inserting nonzero elements.
    Slicing is demonstrated by the next example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: LIL 格式最适合切片，即以 LIL 格式提取子矩阵，以及通过插入非零元素来更改稀疏模式。以下示例演示了切片：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Insertion of a new nonzero element automatically updates the attributes:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 插入新的非零元素会自动更新属性：
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: These operations are discouraged in the other sparse matrix formats as they
    are extremely inefficient.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他稀疏矩阵格式中不鼓励这些操作，因为它们效率极低。
- en: Generating sparse matrices
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成稀疏矩阵
- en: The NumPy commands `eye`, `identity`, `diag`, and `rand` have their sparse counterparts.
    They take an additional argument; it specifies the sparse matrix format of the
    resulting matrix.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 命令 `eye`、`identity`、`diag` 和 `rand` 有它们的稀疏对应物。它们接受一个额外的参数；它指定了结果矩阵的稀疏矩阵格式。
- en: 'The following commands generate the identity matrix but in different sparse
    matrix formats:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令生成单位矩阵，但以不同的稀疏矩阵格式：
- en: '[PRE62]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `sp.rand` command takes an additional argument describing the density of
    the generated random matrix. A dense matrix has density 1 while a zero matrix
    has density 0:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`sp.rand` 命令接受一个额外的参数，用于描述生成的随机矩阵的密度。密集矩阵的密度为1，而零矩阵的密度为0：'
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There is no direct correspondence to the NumPy command `zeroes`. Matrices completely
    filled with zeros are generated by instantiating the corresponding type with the
    shape parameters as constructor parameters:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与 NumPy 命令 `zeroes` 没有直接对应关系。完全填充零的矩阵通过使用形状参数作为构造函数参数实例化相应的类型来生成：
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Sparse matrix methods
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稀疏矩阵方法
- en: 'There are methods to convert one sparse type into another or into an array:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以将一种稀疏类型转换为另一种类型或转换为数组：
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The type of a sparse matrix can be inspected by the methods `issparse` ,  `isspmatrix_lil`,
    `isspmatrix_csr`, and `isspmatrix_csc`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过方法 `issparse`、`isspmatrix_lil`、`isspmatrix_csr` 和 `isspmatrix_csc` 检查稀疏矩阵的类型。
- en: Elementwise operations `+`, `*`, `/`, and `**` on sparse matrices are defined
    as for NumPy arrays. Regardless of the sparse matrix format of the operands, the
    result is always a `csr_matrix`. Applying elementwise operating functions to sparse
    matrices requires first transforming them to either CSR or CSC format and applying
    the functions to their `data` attribute, as demonstrated by the next example.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵上的逐元素操作 `+`、`*`、`/` 和 `**` 定义与 NumPy 数组相同。无论操作数的稀疏矩阵格式如何，结果总是 `csr_matrix`。将逐元素操作函数应用于稀疏矩阵需要首先将它们转换为
    CSR 或 CSC 格式，并对其 `data` 属性应用函数，如下例所示。
- en: 'The elementwise sine of a sparse matrix can be defined by an operation on its
    `data` attribute:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵的逐元素正弦可以通过对其 `data` 属性的操作来定义：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For matrix-matrix or matrix-vector multiplications, there is a sparse matrix
    method, `dot`. It returns either a `csr_matrix` or a 1D NumPy `array`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵-矩阵或矩阵-向量乘法，有一个稀疏矩阵方法 `dot`。它返回 `csr_matrix` 或 1D NumPy `array`：
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Tip
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid using NumPy's command `dot` on sparse matrices, as this might lead to
    unexpected results. Use the command `dot` from `scipy.sparse` instead.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在稀疏矩阵上使用 NumPy 的 `dot` 命令，因为这可能会导致意外结果。请使用 `scipy.sparse` 中的 `dot` 命令。
- en: Other linear algebra operations such as system solving, least squares, eigenvalues,
    and singular values are provided by the `scipy.sparse.linalg` module.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 其他线性代数操作，如系统求解、最小二乘法、特征值和奇异值，由 `scipy.sparse.linalg` 模块提供。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The concept of views is one of the important topics you should have learned
    from this chapter. Missing this topic will give you a hard time when debugging
    your code. Boolean arrays occur at various places throughout this book. They are
    handy and compact tools for avoiding lengthy `if` constructions and loops when
    working with arrays. In nearly all large computational projects, sparse matrices
    become an issue. You saw how these are handled and which related methods are available.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的概念是您应该从本章中学到的重点之一。错过这个主题，在调试代码时可能会给您带来困难。布尔数组在本书的各个地方都有出现。它们是处理数组时避免冗长的 `if`
    语句和循环的便捷且紧凑的工具。在几乎所有的大型计算项目中，稀疏矩阵都会成为一个问题。您已经看到了如何处理这些问题以及哪些相关方法可用。
