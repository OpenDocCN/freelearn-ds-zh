- en: Chapter 3. Container Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。容器类型
- en: Container types are used to group objects together. The main difference between
    the different container types is the way individual elements are accessed and
    how operations are defined.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器类型用于将对象分组在一起。不同容器类型之间的主要区别在于访问单个元素的方式以及定义操作的方式。
- en: Lists
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'A list is, as the name hints, a list of objects of any kind:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，正如其名所示，是任何类型对象的列表：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The individual objects are enumerated by assigning each element an index. The
    first element in the list gets index 0\. This zero-based indexing is frequently
    used in mathematical notation. Consider the usual indexing of coefficients of
    a polynomial.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将每个元素分配一个索引来枚举单个对象。列表中的第一个元素得到索引 0。这种基于零的索引在数学符号中经常使用。考虑多项式系数的常规索引。
- en: 'The index allows us to access the following objects:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 索引使我们能够访问以下对象：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The bracket notation here corresponds to the use of subscripts in mathematical
    formulas. `L` is a simple list, while `M` itself contains a list so that one needs
    two indexes to access an element of the inner list.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的括号表示法对应于数学公式中下标的用法。`L` 是一个简单的列表，而 `M` 本身包含一个列表，因此需要两个索引来访问内部列表的元素。
- en: 'A list containing subsequent integers can easily be generated by the command
    `range`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过命令 `range` 轻松生成包含连续整数的列表：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A more general use is to provide this command with start, stop, and step parameters:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更通用的用法是向此命令提供起始、停止和步长参数：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The command `len` returns the length of the list:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `len` 返回列表的长度：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Slicing
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: Slicing a list between `i` and `j` creates a new list containing the elements
    starting at `index i` and ending just before `j`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `i` 和 `j` 之间切片列表会创建一个新列表，该列表包含从 `index i` 开始到 `j` 前结束的元素。
- en: 'For slicing, a range of indexes has to be given. `L[i:j]` means create a list
    by taking all elements from `L` starting at `L[i]` until `L[j-1]`. In other words,
    the new list is obtained by removing the first `i` elements from `L` and taking
    the next `j-i` elements (for *j* > *i* ≥ 0). See the following figure (*Figure
    3.1*) for more examples:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于切片，必须给出一个索引范围。`L[i:j]` 表示通过从 `L` 中取 `L[i]` 开始直到 `L[j-1]` 的所有元素来创建一个列表。换句话说，新列表是通过从
    `L` 中移除前 `i` 个元素并取下一个 `j-i` 个元素（对于 *j* > *i* ≥ 0）获得的。请参阅以下图（*图 3.1*）以获取更多示例：
- en: '![Slicing](img/slicing.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![切片](img/slicing.jpg)'
- en: 'Figure 3.1: Some typical slicing situations'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：一些典型的切片情况
- en: 'Here, `L[i:]` means remove the *i* first elements, `L[:i]` means take only
    the first *i* elements, and similarly, `L[:-i]` means remove the last *i* elements,
    and `L[-i:]` means take only the last *i* elements. This may be combined in `L[i:-j]` to
    remove the first *i* and the last *j* elements:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`L[i:]` 表示移除前 *i* 个元素，`L[:i]` 表示只取前 *i* 个元素，同样地，`L[:-i]` 表示移除最后 *i* 个元素，而
    `L[-i:]` 表示只取最后 *i* 个元素。这可以组合成 `L[i:-j]` 来移除前 *i* 个和最后 *j* 个元素：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One may omit the first or last bound of the slicing:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以省略范围中的第一个或最后一个边界：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Python allows the use of negative indexes for counting from the right. In particular,
    the element `L[-1]` is the last element in the list `L`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许使用负索引从右侧计数。特别是，元素 `L[-1]` 是列表 `L` 中的最后一个元素。
- en: 'Some list indexing descriptions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些列表索引描述：
- en: '`L[i:]` amounts to taking all elements except the *i* first ones'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L[i:]` 等同于取除了前 *i* 个元素之外的所有元素'
- en: '`L[:i]` amounts to taking the first *i* elements'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L[:i]` 等同于取前 *i* 个元素'
- en: '`L[-i:]` amounts to taking the last *i* elements'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L[-i:]` 等同于取最后 *i* 个元素'
- en: '`L[:-i]` amounts to taking all elements except the *i* last ones'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L[:-i]` 等同于取除了最后 *i* 个元素之外的所有元素'
- en: 'Here is an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Omitting one index in the range corresponds to half-open intervals in ℝ. The
    half-open interval (∞, *a*) means, take all numbers strictly lower than *a*; this
    is similar to the syntax `L[:j]`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围中省略一个索引对应于实数域中的半开区间。半开区间 (∞, *a*) 表示，取所有严格小于 *a* 的数；这与语法 `L[:j]` 类似。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Out of-bound slices**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**越界切片**'
- en: Notice that you never get index errors with out-of-bound slices. Possibly, you
    may obtain empty lists.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你永远不会在越界切片时得到索引错误。可能，你可能会获得空列表。
- en: 'Here is an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Be careful when using variables in indexing that may become negative, since
    it changes the slice completely. This might lead to unexpected results:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可能变为负数的变量进行索引时，请小心，因为这会完全改变切片。这可能会导致意外结果：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is `3`, `0`, `1`, `3` while one expects `0`, `0`, `1`, `3`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `3`，`0`，`1`，`3`，而预期的是 `0`，`0`，`1`，`3`。
- en: Strides
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步长
- en: 'When computing slices, one may also specify a stride, which is the length of
    the step from one index to the other. The default stride is one. Here is an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算切片时，也可以指定步长，即从一个索引到另一个索引的步长长度。默认步长为 1。以下是一个示例：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that the stride may also be negative:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意步长也可以是负数：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is also possible to create a new list that is reversed, using a negative
    stride (find about reverse method in section *In-place operations*):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用负步长创建一个新的反转列表，使用负步长（在 *原地操作* 部分查找关于反转方法的更多信息）：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Altering lists
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改列表
- en: 'Typical operations on lists are insertion and deletion of elements and list
    concatenation. With the slicing notation, list insertion and deletion become obvious;
    deletion is just replacing a part of a list by an empty list `[]`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的典型操作是元素的插入和删除以及列表连接。使用切片表示法，列表的插入和删除变得明显；删除就是用一个空列表 `[]` 替换列表的一部分：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Insertion means replacing an empty slice with the list to be inserted:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 插入意味着用一个要插入的列表替换一个空的切片：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Two lists are concatenated by the plus operator `+` :'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 两个列表可以通过加号运算符 `+` 连接：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Concatenating a list `n` times with itself motivates the use of the multiplication
    operator  `*`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表 `n` 次与自身连接，促使使用乘号运算符 `*`：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is no arithmetic operations on list, such as elementwise summation or
    division. For such operations we use arrays (refer to section *Array*).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表上没有算术运算，例如逐元素求和或除法。对于此类运算，我们使用数组（请参考 *数组* 部分）。
- en: Belonging to a list
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属于列表
- en: 'One may use the keywords `in` and `not in` to determine whether an element
    belongs to a list or not which is similar to ![Belonging to a list](img/in.jpg)
    and ![Belonging to a list](img/notin.jpg) in mathematics:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用关键字 `in` 和 `not in` 来确定一个元素是否属于列表，这与数学中的 ![属于列表](img/in.jpg) 和 ![不属于列表](img/notin.jpg)
    类似：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: List methods
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表方法
- en: 'Some useful methods of the `list` type are collected in the following T*able
    3.1*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格 3.1 收集了 `list` 类型的几个有用方法：
- en: '| **Command** | **Action** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| `list.append(x)` | Add `x` to the end of the list. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `list.append(x)` | 将元素 `x` 添加到列表的末尾。|'
- en: '| `list.expand(L)` | Expand the list by the elements of the list `L`. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `list.expand(L)` | 通过列表 `L` 的元素扩展列表。|'
- en: '| `list.insert(i,x)` | Insert `x` at position `i`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `list.insert(i,x)` | 在位置 `i` 插入元素 `x`。|'
- en: '| `list.remove(x)` | Remove the first item from the list whose value is `x`.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `list.remove(x)` | 移除列表中第一个值为 `x` 的元素。|'
- en: '| `list.count(x)` | The number of times `x` appears in the list. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `list.count(x)` | `x` 在列表中出现的次数。|'
- en: '| `list.sort()` | Sort the items of the list, in place. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `list.sort()` | 在原地对列表的元素进行排序。|'
- en: '| `list.reverse()` | Reverse the elements of the list, in place. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `list.reverse()` | 在原地反转列表的元素。|'
- en: '| `list.pop()` | Remove the last element of the list, in place. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `list.pop()` | 在原地移除列表的最后一个元素。|'
- en: 'Table 3.1: Methods of the datatype list'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：列表数据类型的方法
- en: 'There are two ways list methods can act:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表方法有两种行为方式：
- en: They can directly alter the list, that is, in-place operations.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以直接修改列表，即原地操作。
- en: They produce a new object.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会生成一个新对象。
- en: In–place operations
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原地操作
- en: 'All methods that result in a list are in-place operating methods, for example,
    `reverse`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有导致生成新列表的方法都是原地操作方法，例如 `reverse`：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Be aware of in-place operations. One might be tempted to write:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意原地操作。有人可能会想写：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is correct Python. But it results in a possibly unintended alternation
    of `L` in a variable `newL` having the value `None`. The reason is that `sort`
    operates in-place.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是正确的 Python 代码。但它可能导致变量 `newL` 中的 `L` 发生意外交替，其值为 `None`。原因是 `sort` 是原地操作。
- en: 'Here we demonstrate in-place operating methods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们演示原地操作方法：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`L` is altered. The `count` method is an example of a method that generates
    a new object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`L` 被修改。`count` 方法是一个生成新对象的示例：'
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Merging lists – zip
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表合并 – zip
- en: 'A particularly useful function for lists is `zip`. It can be used to merge
    two given lists into a new list by pairing the elements of the original lists.
    The result is a list of tuples (refer section *Tuples* for more information):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的一个特别有用的函数是 `zip`。它可以将两个给定的列表合并成一个新的列表，通过配对原始列表的元素。结果是元组列表（更多信息请参考 *元组* 部分）：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example also demonstrates what happens if the lists have different lengths.
    The length of the zipped list is the shorter of the two input lists. `zip` creates
    a special iterable object that can be turned into a list by applying the `list`
    function, as in the preceding example. Refer to section *Iterators* in [Chapter
    9](ch09.html "Chapter 9. Iterating"), *Iterating*, for more details on iterable
    objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还演示了如果列表长度不同会发生什么。合并后的列表长度是两个输入列表中较短的那个。`zip` 创建了一个特殊的可迭代对象，可以通过应用 `list`
    函数将其转换为列表，就像前面的例子一样。更多信息请参考第9章中 *迭代器* 部分 [Chapter 9](ch09.html "第9章。迭代")，*迭代*。
- en: List comprehension
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表推导式
- en: 'A convenient way to build up lists is by using the list comprehension construct,
    possibly with a condition inside. The syntax of a list comprehension is:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用列表推导式构造列表是一种方便的方法，可能包含一个条件。列表推导式的语法是：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'or more generally:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更普遍地：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is possible to have several `for` loops inside a list comprehension:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表推导式中可以包含多个 `for` 循环：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is of particular interest when dealing with arrays.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数组时，这一点尤其有趣。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Set notation**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合表示法**'
- en: List comprehension is closely related to the mathematical notation for sets.
    Compare:  ![List comprehension](img/set_notation.jpg)  and `L2 = [2*x for x in
    L]`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式与集合的数学表示法密切相关。比较：![列表推导式](img/set_notation.jpg) 和 `L2 = [2*x for x in L]`。
- en: One big difference though, is that lists are ordered while sets aren't (Refer,
    section *Sets* for more information).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一个很大的不同，那就是列表是有序的，而集合不是（更多信息请参考 *集合* 部分）。
- en: Arrays
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: The NumPy package offers arrays, which are container structures for manipulating
    vectors, matrices, or even higher order tensors in mathematics. In this section,
    we point out the similarities between arrays and lists. But arrays deserve a broader
    presentation, which will be given in [Chapter 4](ch04.html "Chapter 4. Linear
    Algebra – Arrays"), *Linear Algebra –  Arrays*, and [Chapter 5](ch05.html "Chapter 5. Advanced
    Array Concepts"), *Advanced Array Concepts*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 包提供了数组，它是用于在数学中操作向量、矩阵甚至更高阶张量的容器结构。在本节中，我们指出数组与列表之间的相似性。但数组需要更广泛的介绍，这将在第4章
    [Chapter 4](ch04.html "第4章。线性代数 – 数组")，*线性代数 – 数组* 和第5章 [Chapter 5](ch05.html
    "第5章。高级数组概念")，*高级数组概念* 中给出。
- en: 'Arrays are constructed from lists by the function `array` :'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是通过 `array` 函数从列表构建的：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To access an element of a vector, we need one index, while an element of a
    matrix is addressed by two indexes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问向量的一个元素，我们需要一个索引，而矩阵的元素通过两个索引来定位：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At first glance, arrays are similar to lists, but be aware that they are different
    in a fundamental way, which can be explained by the following points:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，数组与列表相似，但要注意它们在本质上有所不同，这可以通过以下几点来解释：
- en: 'Access to array data corresponds to that of lists, using square brackets and
    slices. They may also be used to alter the array:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数组数据与列表的访问方式相对应，使用方括号和切片。它们也可以用来修改数组：
- en: '[PRE29]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The number of elements in a vector, or the number of rows of a matrix, is obtained
    by the function `len` :'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量的元素数量或矩阵的行数可以通过 `len` 函数获得：
- en: '[PRE30]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Arrays store only elements of the same numeric type (usually `float` or `complex`
    but also `int`). Refer to section *Array properties* in [Chapter 4](ch04.html
    "Chapter 4. Linear Algebra – Arrays"), *Liner Algebra – Arrays*, for more information.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组只存储相同数值类型的元素（通常是 `float` 或 `complex`，但也包括 `int`）。更多信息请参考第4章中 *数组属性* 部分 [Chapter
    4](ch04.html "第4章。线性代数 – 数组")，*线性代数 – 数组*。
- en: The operations `+`, `*`, `/`, and `-` are all elementwise. The `dot` function
    and, in Python versions ≥ 3.5, the infix operator `@` are used for the scalar
    product and the corresponding matrix operations.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作 `+`、`*`、`/` 和 `-` 都是逐元素操作。`dot` 函数和 Python 3.5 及以上版本中的中缀运算符 `@` 用于标量积和相应的矩阵运算。
- en: Unlike lists, there is no `append` method for arrays. Nevertheless, there are
    special methods to construct arrays by stacking smaller size arrays (Refer to
    section *Stacking* in [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"),
    *Linear Algebra - Arrays*, for more information.). A related point is that arrays
    are not elastic as lists; one cannot use slices to change their length.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与列表不同，数组没有 `append` 方法。尽管如此，有一些特殊方法可以通过堆叠更小的数组来构建数组（更多信息请参考第4章中 *堆叠* 部分 [Chapter
    4](ch04.html "第4章。线性代数 – 数组")，*线性代数 - 数组*）。相关的一点是，数组不像列表那样具有弹性；不能使用切片来改变它们的长度。
- en: Vector slices are views; that is, they may be used to modify the original array.
    Refer to section *Array views and copies* in [Chapter 5](ch05.html "Chapter 5. Advanced
    Array Concepts"), *Advanced Array Concepts*, for more information.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量切片是视图；也就是说，它们可以用来修改原始数组。有关更多信息，请参阅第5章中的*数组视图和副本*部分 [第5章](ch05.html "第5章。高级数组概念")，*高级数组概念*。
- en: Tuples
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'A tuple is an immutable list. Immutable means that it cannot be modified. A
    tuple is just a comma-separated sequence of objects (a list without brackets).
    To increase readability, one often encloses a tuple in a pair of parentheses:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是不可变列表。不可变意味着它不能被修改。元组只是对象（没有括号的列表）的逗号分隔序列。为了提高可读性，人们经常将元组括在一对括号中：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The comma indicates that the object is a tuple:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号表示该对象是一个元组：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Tuples are useful when a group of values goes together; for example, they are
    used to return multiple values from functions (refer to section *Returns Values*
    in [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*. One may assign
    several variables at once by unpacking a list or tuple:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当一组值需要一起使用时，元组很有用；例如，它们用于从函数中返回多个值（请参阅第7章中的*返回值*部分 [第7章](ch07.html "第7章。函数")，*函数*。可以通过展开列表或元组一次分配多个变量）。
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**The swapping trick**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**交换技巧**'
- en: 'Use packing and unpacking to swap the contents of two variables: `a, b = b,
    a`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包和拆包来交换两个变量的内容：`a, b = b, a`
- en: 'To summarize:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总结如下：
- en: Tuples are nothing other than immutable lists with a notation without brackets.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组不过是不可变列表，没有括号的表示法。
- en: In most cases, lists may be used instead of tuples.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，可以使用列表代替元组。
- en: 'The notation without parentheses is convenient but dangerous. You should use
    parentheses when you are not sure:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无括号的表示法很方便，但也很危险。当你不确定时，应该使用括号：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Dictionaries
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: Lists, tuples, and arrays are ordered sets of objects. The individual objects
    are inserted, accessed, and processed according to their place in the list. On
    the other hand, dictionaries are unordered sets of pairs. One accesses dictionary
    data by keys.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、元组和数组是有序对象集合。根据它们在列表中的位置插入、访问和处理单个对象。另一方面，字典是无序的键值对集合。通过键访问字典数据。
- en: Creating and altering dictionaries
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和修改字典
- en: 'For example, we may create a dictionary containing the data of a rigid body
    in mechanics, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个包含力学中刚体数据的字典，如下所示：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A key/data pair is indicated by a colon, `:`. These pairs are comma separated
    and listed inside a pair of curly brackets, `{}`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 键/数据对由冒号 `:` 表示。这些对由逗号分隔，并放在一对花括号 `{}` 内。
- en: 'Individual elements are accessed by their keys:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键访问单个元素：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'New objects are added to the dictionary by creating a new key:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建新的键向字典中添加新对象：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Dictionaries are also used to provide parameters to a function (refer to section
    *Parameters and arguments* in [Chapter 7](ch07.html "Chapter 7. Functions"), *Functions*,
    for further information). Keys in a dictionary can be, among others, strings,
    functions, tuples with immutable elements, and classes. Keys cannot be lists or
    arrays. The command `dict`  generates a dictionary from a list with key/value
    pairs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也用于向函数提供参数（有关更多信息，请参阅第7章中的*参数和参数*部分 [第7章](ch07.html "第7章。函数")，*函数*）。字典中的键可以是字符串、函数、包含不可变元素的元组以及类。键不能是列表或数组。`dict`
    命令可以从键值对列表生成字典：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `zip` function may come in handy in this context (refer to section *Merging
    List*).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`zip` 函数可能很有用（请参阅*合并列表*部分）。
- en: Looping over dictionaries
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历字典
- en: 'There are mainly three ways to loop over dictionaries:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字典主要有三种方式：
- en: 'By keys:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'or equivalently:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等价地：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By value:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'By item, that is, key/value pairs:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过项，即键/值对：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Please, refer to section *Shelves* in [Chapter 12](ch12.html "Chapter 12. Input
    and Output"), *Input and Output*, for a special dictionary object for file access.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考第12章中的*书架*部分 [第12章](ch12.html "第12章。输入和输出")，*输入和输出*，以了解用于文件访问的特殊字典对象。
- en: Sets
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'Sets are containers that share properties and operations with sets in mathematics.
    A mathematical set is a collection of distinct objects. Here are some mathematical
    set expressions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是具有数学集合属性和操作的容器。数学集合是一组不同的对象。以下是一些数学集合表达式：
- en: '![Sets](img/set_operations.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![集合](img/set_operations.jpg)'
- en: 'And their Python counterparts:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它们的Python对应物：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Sets contain an element only once, corresponding to the aforementioned definition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 集合只包含一个元素，对应上述定义：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And a set is unordered; that is, the order of the elements in the set is not
    defined:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 并且集合是无序的；也就是说，集合中元素的顺序没有定义：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Sets in Python can contain all kinds of hashable objects, that is, numeric objects,
    strings, and Booleans.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的集合可以包含所有类型的可哈希对象，即数值对象、字符串和布尔值。
- en: 'There are `union` and `intersection` methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有`union`和`intersection`方法：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, sets can be compared using the methods `issubset` and `issuperset` :'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用`issubset`和`issuperset`方法进行比较：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Empty set**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**空集**'
- en: An empty set is defined in Python by `empty_set=set([])` and not by `{}`, which
    would define an empty dictionary!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，空集是通过`empty_set=set([])`定义的，而不是通过`{}`，后者会定义一个空字典！
- en: Container conversions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器转换
- en: We summarize in the following *Table 3.2* the most important properties of the
    container types presented so far. Arrays will be treated in [Chapter 4](ch04.html
    "Chapter 4. Linear Algebra – Arrays"), *Linear Algebra – Arrays*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下*表3.2*中总结了迄今为止所展示的容器类型的最重要属性。数组将在[第4章](ch04.html "第4章。线性代数 - 数组")，“线性代数
    - 数组”中处理。
- en: '![Container conversions](img/Table-3.2.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![容器转换](img/Table-3.2.jpg)'
- en: 'Table 3.2 : Container Types'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2：容器类型
- en: As you can see in the previous table, there is a difference in accessing container
    elements, and sets and dictionaries are not ordered.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，访问容器元素存在差异，集合和字典是无序的。
- en: 'Due to the different properties of the various container types, we frequently
    convert one type to another:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种容器类型的不同特性，我们经常将一种类型转换为另一种类型：
- en: '![Container conversions](img/Table-3.4.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![容器转换](img/Table-3.4.jpg)'
- en: Type checking
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查
- en: 'The direct way to see the type of a variable is to use the `type` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 查看变量类型的直接方法是使用`type`命令：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'However, if you want to test for a variable to be of a certain type, you should
    use `isinstance` (instead of comparing the types with `type`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想测试一个变量是否为特定类型，你应该使用`isinstance`（而不是使用`type`比较类型）：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The reason for using `isinstance` becomes apparent after having read [Chapter
    8](ch08.html "Chapter 8. Classes"), *Classes,* and in particular the concept of
    subclassing and inheritance in section *Subclassing and Inheritance* in [Chapter
    8](ch08.html "Chapter 8. Classes"), *Classes*. In short, often different types
    share some common properties with some basic type. The classical example is the
    type `bool`, which is derived by subclassing from the more general type `int`.
    In this situation, we see how the command `isinstance`  can be used in a more
    general way:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`isinstance`的原因在阅读了[第8章](ch08.html "第8章。类")、“类”以及第8章中“子类化和继承”部分（[第8章](ch08.html
    "第8章。类")，“类”）的概念后变得明显。简而言之，不同类型通常与一些基本类型共享一些共同属性。经典的例子是类型`bool`，它是通过从更通用的类型`int`中子类化得到的。在这种情况下，我们看到如何更通用地使用`isinstance`命令：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'So, in order to make sure that the variable `test` is as good as an integer
    (the particular type may be irrelevant), you should check that it is an instance
    of `integer`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了确保变量`test`尽可能像一个整数（特定的类型可能无关紧要），你应该检查它是否是`integer`的实例：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Type checking**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型检查**'
- en: Python is not a typed language. What that means is that objects are identified
    by what they can do rather than what they are. For instance, if you have a string
    manipulating function that acts on an object by using the `len` method, then your
    function will probably be useful for any objects implementing that method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Python不是一种类型语言。这意味着对象是通过它们能做什么来识别的，而不是它们是什么。例如，如果你有一个通过使用`len`方法对对象进行操作的字符串处理函数，那么你的函数可能对任何实现该方法的对象都很有用。
- en: So far, we have come across different types: `float`, `int`, `bool`, `complex`,
    `list`, `tuple`, `module`, `function`, `str`, `dict`, and `array`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经遇到了不同的类型：`float`、`int`、`bool`、`complex`、`list`、`tuple`、`module`、`function`、`str`、`dict`和`array`。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned to work with container types, mainly lists. It
    is important to know how to fill these containers and how to access their content.
    We saw that there is access by position or by keyword.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何处理容器类型，主要是列表。了解如何填充这些容器以及如何访问它们的内容是很重要的。我们看到可以通过位置或关键字进行访问。
- en: We will meet the important concept of slicing again in the next chapter on arrays.
    These are containers specially designed for mathematical operations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章关于数组的章节中，我们将再次遇到切片这个重要概念。这些容器是专门为数学运算设计的。
- en: Exercises
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Ex. 1 **→ Execute the following statements:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**例1**→ 执行以下语句：'
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What is the content of `L3`?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`L3`的内容是什么？'
- en: 'Try to predict the outcome of the following commands:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试预测以下命令的结果：
- en: '[PRE53]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What does the following command do?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令做什么？
- en: '[PRE54]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Concatenate `L3` and `L4` to a new list `L5`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `L3` 和 `L4` 连接到一个新的列表 `L5`。
- en: '**Ex. 2** → Use the `range` command and a list comprehension to generate a
    list with 100 equidistantly spaced values between 0 and 1.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2** → 使用 `range` 命令和列表推导生成一个包含 100 个等间距值（介于 0 和 1 之间）的列表。'
- en: '**Ex. 3** → Assume that the following signal is stored in a list:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3** → 假设以下信号存储在一个列表中：'
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'What is the outcome of:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令的结果是什么？
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Do this exercise by inspection only, that is, without using your Python Shell.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过检查来完成此练习，也就是说，不使用你的 Python Shell。
- en: '**Ex. 4** → Consider the Python statements:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 4** → 考虑以下 Python 语句：'
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: and assume that the variable `m` has been previously assigned an integer value.
    What is the value of `ans`? Answer this question without executing the statements
    in Python.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设变量 `m` 已经被分配了一个整数值。`ans` 的值是多少？在不执行 Python 中的语句的情况下回答这个问题。
- en: '**Ex. 5** → Consider the recursion formula:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5** → 考虑以下递归公式：'
- en: '![Exercises](img/main_F.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/main_F.jpg)'
- en: with *n* = 0,..., 1000, *h*= 1/1000, and *a* = -0.5.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *n* = 0,..., 1000，*h*= 1/1000，和 *a* = -0.5 时。
- en: Create a list `u`. Store in its first three elements *e⁰*, *e^(ha)*, and *e^(2ha)*.
    These represent the starting values *u*[0], *u*[1], and *u*[2] in the given formula.
    Build up the complete list from the recursion formula.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个列表 `u`。将其前三个元素存储为 *e⁰*，*e^(ha)*，和 *e^(2ha)*。这些代表给定公式中的起始值 *u*[0]，*u*[1]，和
    *u*[2]。从递归公式构建完整的列表。
- en: Construct a second list, `td`, in which you store the values *nh*, with *n*
    = 0, ..., 1000\. Plot `td` versus `u` (refer section *Basic plotting* in [Chapter
    6](ch06.html "Chapter 6. Plotting"), *Plotting*, for more information). Make a
    second plot in which you plot the difference, that is, *|e^(at[n]) - u[n]|*, where
    *t[n]* represents the values inside the vector `td` . Set axis labels and a title.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建第二个列表，`td`，在其中存储值 *nh*，其中 *n* = 0, ..., 1000。绘制 `td` 与 `u` 的关系图（参考第 6 章中的
    *基本绘图* 部分 [Chapter 6](ch06.html "第 6 章。绘图")，*绘图*，获取更多信息）。绘制第二个图，其中绘制差值，即 *|e^(at[n])
    - u[n]|*，其中 *t[n]* 表示向量 `td` 中的值。设置坐标轴标签和标题。
- en: The recursion is a multistep formula to solve the differential equation *u'
    = au* with the initial value *u(0) = u[0] = 1*. *u[n]* approximates *u(nh) = e^(anh)u*[0].
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一个多步公式，用于求解微分方程 *u' = au*，初始值为 *u(0) = u[0] = 1*。*u[n]* 近似于 *u(nh) = e^(anh)u*[0]。
- en: '**Ex. 6** → Let *A* and *B* be sets. The set (A \ B) ∪ (B \ A) is called the
    symmetric difference of the two sets. Write a function that performs this operation.
    Compare your results to the result of the command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 6** → 设 *A* 和 *B* 为集合。集合 (A \ B) ∪ (B \ A) 被称为两个集合的对称差。编写一个执行此操作的函数。将你的结果与以下命令的结果进行比较：'
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Ex. 7** → Verify in Python the statement that the empty set is a subset of
    any set.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 7** → 在 Python 中验证空集是任何集合的子集。'
- en: '**Ex. 8** → Study other operations on sets. You find a complete list of those
    by using the command completion feature of `IPython`. In particular, study the `update`
    and `intersection_update` methods. What is the difference between `intersection`
    and `intersection_update`?'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 8** → 研究集合的其他操作。您可以通过使用 `IPython` 的命令补全功能找到完整的列表。特别是，研究 `update` 和 `intersection_update`
    方法。`intersection` 和 `intersection_update` 之间有什么区别？'
