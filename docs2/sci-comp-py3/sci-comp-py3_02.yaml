- en: Chapter 2. Variables and Basic Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 变量和基本类型
- en: In this chapter, we will present the most important and basic types in Python.
    What is a type? It is a set consisting of data content, its representation, and
    all possible operations. Later in this book, we will make this definition much
    more precise, when we introduce the concepts of a class in [Chapter 8](ch08.html
    "Chapter 8. Classes"), *Classes*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Python 中最重要的基本类型。什么是类型？它是一个由数据内容、其表示和所有可能的操作组成的集合。在本书的后面部分，当我们介绍第
    8 章 [类](ch08.html "第 8 章。类") 中的类概念时，我们将对这个定义进行更精确的阐述。
- en: Variables
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Variables are references to Python objects. They are created by assignments,
    for example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是 Python 对象的引用。它们通过赋值创建，例如：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Variables take names that consist of any combination of capital and small letters,
    the underscore `_` , and digits. A variable name must not start with a digit.
    Note that variable names are case sensitive. A good naming of variables is an
    essential part of documenting your work, so we recommend that you use descriptive
    variable names.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以由大写和小写字母、下划线 `_` 和数字的任意组合命名。变量名不能以数字开头。请注意，变量名是区分大小写的。良好的变量命名是文档化您工作的一个基本部分，因此我们建议您使用描述性的变量名。
- en: Python has some *reserved keywords*, which cannot be used as variable names
    (refer to following table, *Table 2.1*). An attempt to use such a keyword as variable
    name would raise a syntax error.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一些 *保留关键字*，不能用作变量名（请参阅下表，*表 2.1*）。尝试将此类关键字用作变量名将引发语法错误。
- en: '![Variables](img/Table-2.11.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![变量](img/Table-2.11.jpg)'
- en: 'Table 2.1: Reserved Python keywords.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：保留的 Python 关键字。
- en: 'As opposed to other programming languages, variables require no type declaration.
    You can create several variables with a multiple assignment statement:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言不同，变量不需要类型声明。您可以使用多个赋值语句创建多个变量：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Variables can also be altered after their definition:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在其定义之后也可以被修改：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last two statements can be written by combining the two operations with
    an assignment directly by using increment operators:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个语句可以通过直接使用增量运算符将两个操作合并为一个赋值语句来编写：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Numeric types
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字类型
- en: At some point, you will have to work with numbers, so we start by considering
    different forms of numeric types in Python. In mathematics, we distinguish between
    natural numbers (ℕ), integers (ℤ), rational numbers (ℚ), real numbers (ℝ) and
    complex numbers (ℂ). These are infinite sets of numbers. Operations differ between
    these sets and may even not be defined. For example, the usual division of two
    numbers in ℤ might not result in an integer — it is not defined on ℤ.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您将不得不处理数字，因此我们首先考虑 Python 中不同形式的数字类型。在数学中，我们区分自然数（ℕ）、整数（ℤ）、有理数（ℚ）、实数（ℝ）和复数（ℂ）。这些都是无限数字集。这些集合之间的操作不同，甚至可能没有定义。例如，ℤ
    中两个数的通常除法可能不会得到一个整数——它不在 ℤ 上定义。
- en: 'In Python, like many other computer languages, we have numeric types:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，就像许多其他计算机语言一样，我们有数字类型：
- en: The numeric type `int`, which is at least theoretically the entire ℤ
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型 `int`，至少在理论上它是整个整数集 ℤ
- en: The numeric type `float`, which is a finite subset of ℝ and
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型 `float`，它是实数集 ℝ 的有限子集
- en: The numeric type `complex`, which is a finite subset of ℂ
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型 `complex`，它是复数集 ℂ 的有限子集
- en: Finite sets have a smallest and a largest number and there is a minimum spacing
    between two numbers; refer to the section on *Floating Point Representation* for
    further details.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有限集有最小和最大的数字，并且两个数字之间存在最小间隔；有关更多详细信息，请参阅 *浮点表示* 部分。
- en: Integers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: The simplest numerical type is the integer type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的数值类型是整数类型。
- en: Plain integers
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯整数
- en: The statement `k = 3` assigns the variable `k` to an integer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 `k = 3` 将变量 `k` 赋值为一个整数。
- en: Applying an operation of the type `+`, `-`, or `*` to integers returns an integer.
    The division operator, `//`, returns an integer, while `/` may return a `float:`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型为 `+`、`-` 或 `*` 的操作应用于整数返回一个整数。除法运算符 `//` 返回一个整数，而 `/` 可能返回一个 `float`：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The set of integers in Python is unbounded; there is no largest integer. The
    limitation here is the computer’s memory rather than any fixed value given by
    the language.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的整数集是无限的；没有最大的整数。这里的限制是计算机的内存，而不是语言给出的任何固定值。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the division operator (`/`) in the example returns 3, you might not have
    installed the correct Python version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果示例中的除法运算符 (`/`) 返回 3，您可能没有安装正确的 Python 版本。
- en: Floating point numbers
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: If you execute the statement `a = 3.0` in Python, you create a floating-point
    number (Python type: `float`). These numbers form a subset of rational numbers,
    ℚ.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行 Python 中的语句 `a = 3.0`，你将创建一个浮点数（Python 类型：`float`）。这些数字构成了有理数集 ℚ 的一个子集。
- en: Alternatively the constant could have been given in exponent notation as `a
    = 30.0e-1` or simply `a = 30.e-1`. The symbol `e` separates the exponent from
    the mantissa, and the expression reads in mathematical notation *a = 30.0 × 10^(−1)*.
    The name *floating-point number* refers to the internal representation of these
    numbers and reflects the floating position of the decimal point when considering
    numbers over a wide range.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，常数可以用指数表示法给出，例如 `a = 30.0e-1` 或简单地 `a = 30.e-1`。符号 `e` 将指数与尾数分开，数学表示法中表达式读作
    *a = 30.0 × 10^(−1)*。名称 *浮点数* 指的是这些数字的内部表示，并反映了在考虑广泛范围内的数字时小数点的浮动位置。
- en: 'Applying the elementary mathematical operations `+`, `-`, `*`, and `/` to two
    floating-point numbers or to an integer and a floating-point number returns a
    floating-point number. Operations between floating-point numbers rarely return
    the exact result expected from rational number operations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将基本数学运算 `+`、`-`、`*` 和 `/` 应用于两个浮点数或一个整数和一个浮点数，返回一个浮点数。浮点数之间的操作很少返回期望的精确结果：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This facts matters, when comparing floating point numbers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实在比较浮点数时很重要：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Floating point representation
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数表示
- en: 'Internally, floating-point numbers are represented by four quantities: the
    sign, the mantissa, the exponent sign, and the exponent:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，浮点数由四个量表示：符号、尾数、指数符号和指数：
- en: '![Floating point representation](img/float1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![浮点数表示](img/float1.jpg)'
- en: with *β* ϵ *ℕ* and *x[0]*≠ 0, 0 ≤ *x[i]≤ β*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: with *β* ϵ *ℕ* 和 *x[0]*≠ 0, 0 ≤ *x[i]≤ β*
- en: '*x*[0]...x[t-1] is called the mantissa, *β* the basis and *e* the exponent
    *|e| ≤ U* . *t* is called the mantissa length. The condition *x*[0] ≠ 0 makes
    the representation unique and saves, in the binary case (*β* = 2), one bit.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[0]...x[t-1] 被称为尾数，*β* 为基数，*e* 为指数 *|e| ≤ U* . *t* 被称为尾数长度。条件 *x*[0] ≠ 0
    使得表示唯一，并且在二进制情况下 (*β* = 2) 节省了一个比特。'
- en: There exist two-floating point zeros +0 and -0, both represented by the mantissa
    0.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两个浮点零 +0 和 -0，它们都由尾数 0 表示。
- en: On a typical Intel processor, *β* = 2 . To represent a number in the `float`
    type 64 bits are used, namely 2 bits for the signs, *t* = 52 bits for the mantissa
    and 10 bits for the exponent `|e|`. The upper bound *U* for the exponent is consequently
    2^(10)-1 *=* 102*3*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的英特尔处理器上，*β* = 2。为了表示 `float` 类型的数字，使用 64 位，即 2 位用于符号，*t* = 52 位用于尾数，10 位用于指数
    `|e|`。因此，指数的上限 *U* 为 2^(10)-1 *=* 102*3*。
- en: With this data the smallest positive representable number is
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些数据，可以表示的最小正数是
- en: fl[min] = 1.0 *×* 2^(-1023) ≈ 10^(-308) and the largest is  fl[max] = 1.111...1
    *×* 2^(1023) ≈ 10^(308)*.*
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: fl[min] = 1.0 *×* 2^(-1023) ≈ 10^(-308) 和最大的是  fl[max] = 1.111...1 *×* 2^(1023)
    ≈ 10^(308)*.*
- en: Note that floating-point numbers are not equally spaced in [0, fl[max]]. There
    is in particular a  gap at zero (refer to [[29]](apa.html "Appendix . References")).
    The distance between 0 and the first positive number is 2^(-1023), while the distance
    between the first and the second is smaller by a factor *2*^(-52)*≈ 2.2* *×* 10^(-16).
    This effect, caused by the normalization *x*[0] *≠ 0*, is visualized in *Figure
    2.1*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，浮点数在 [0, fl[max]] 区间内不是等间距的。特别是在零处有一个间隙（参见图 [[29]](apa.html "附录 . 参考文献")）。0
    和第一个正数之间的距离是 2^(-1023)，而第一个和第二个之间的距离小一个因子 *2*^(-52)*≈ 2.2* *×* 10^(-16)。这种由规范化
    *x*[0] *≠ 0* 引起的效果在 *图 2.1* 中得到了可视化。
- en: This gap is filled equidistantly with subnormal floating-point numbers to which
    such a result is rounded. Subnormal floating-point numbers have the smallest possible
    exponent and do not follow the convention that the leading digit *x[0]* has to
    differ from zero; refer to [[13]](apa.html "Appendix . References").
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个间隙被等距地填充了子正常浮点数，这些结果被四舍五入到这些数。子正常浮点数具有可能的最小指数，并且不遵循首位数字 *x[0]* 必须与零不同的惯例；参见图
    [[13]](apa.html "附录 . 参考文献")。
- en: Infinite and not a number
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无穷大和非数字
- en: There are in total![Infinite and not a number](img/float2.jpg) floating-point
    numbers. Sometimes a numerical algorithm computes floating-point numbers outside
    this range.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有![无穷大和非数字](img/float2.jpg) 个浮点数。有时数值算法会计算这个范围之外的浮点数。
- en: 'This generates number over- or underflow. In SciPy the special floating-point
    number `inf` is assigned to overflow results:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生数值溢出或下溢。在SciPy中，特殊浮点数`inf`被分配给溢出结果：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Working with `inf` may lead to mathematically undefined results. This is indicated
    in Python by assigning the result another special floating-point number, `nan`.
    This stands for not-a-number, that is, an undefined result of a mathematical operation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`inf`可能会导致数学上未定义的结果。在Python中，通过将结果分配给另一个特殊浮点数`nan`来表示这一点。这代表“非数字”，即数学运算的未定义结果：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are special rules for operations with `nan` and `inf`. For instance,
    `nan` compared to anything (even to itself) always returns `False`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`nan`和`inf`的操作有一些特殊规则。例如，`nan`与任何东西（甚至与自身）比较时总是返回`False`：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See *Exercise 4* for some surprising consequences of the fact that `nan` is
    never equal to itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*练习4*，了解`nan`永远不会等于它自己的事实的一些令人惊讶的后果。
- en: 'The float `inf` behaves much more as expected:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点`inf`的行为与预期更为一致：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One way to check for `nan` and `inf` is to use the  `isnan` and `isinf` functions.
    Often, one wants to react directly when a variable gets the value `nan` or `inf`.
    This can be achieved by using the NumPy command `seterr`. The following command
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`nan`和`inf`的一种方法是用`isnan`和`isinf`函数。通常，当变量变为`nan`或`inf`时，人们希望直接做出反应。这可以通过使用NumPy命令`seterr`来实现。以下命令
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: would raise an error if a calculation were to return one of those values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算返回这些值之一，将引发错误。
- en: Underflow - Machine Epsilon
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下溢 - 计算机epsilon
- en: Underflow occurs when an operation results in a rational number that falls into
    the gap at zero; refer to *Figure 2.1*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个操作的结果是一个落在零间隙中的有理数时，会发生下溢；参见图2.1。
- en: '![Underflow - Machine Epsilon](img/floatz.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![下溢 - 计算机epsilon](img/floatz.jpg)'
- en: 'Figure 2.1: The floating point gap at zero, here t = 3, U = 1'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：零处的浮点间隙，此处t = 3，U = 1
- en: The *machine epsilon* or rounding unit is the largest number *ε* such that float*(*1.0
    *+ ε) =* 1.0.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器epsilon*或舍入单位是最大的数*ε*，使得float(*1.0 *+ ε) =* 1.0。'
- en: 'Note that *ε* ≈ *β*^(1-t)/2 = 1.1102 × 10^(-16) on most of today’s computers.
    The value that is valid on the actual machine you are running your code on is
    accessible using the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*ε* ≈ *β*^(1-t)/2 = 1.1102 × 10^(-16)在大多数今天的计算机上。您在机器上运行的代码的有效值可以通过以下命令访问：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The variable `sys.float_info`  contains more information about the internal
    representation of the float type on your machine.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`sys.float_info`包含了关于您机器上浮点类型内部表示的更多信息。
- en: 'The function `float`  converts other types to a floating-point number—if possible.
    This function is especially useful when converting an appropriate string to a
    number:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`float`将其他类型转换为浮点数（如果可能）。当将适当的字符串转换为数字时，此函数特别有用：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Other float types in NumPy
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy中的其他浮点类型
- en: 'NumPy also provides other float types, known from other programming languages
    as double-precision and single-precision numbers, namely `float64` and `float32`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了其他浮点类型，在其他编程语言中称为双精度和单精度数字，即`float64`和`float32`：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The second last line demonstrates that `a` and `a1` do not differ in accuracy.
    In the first two lines, they only differ in the way they are displayed. The real
    difference in accuracy is between `a` and its single-precision counterpart, `a2`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行展示了`a`和`a1`在精度上没有差异。在前两行中，它们只是显示方式不同。精度上的真正差异在于`a`和它的单精度对应物`a2`之间。
- en: 'The NumPy function `finfo`  can be used to display information on these floating-point
    types:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy函数`finfo`可以用来显示这些浮点类型的信息：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Complex numbers
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数
- en: Complex numbers are an extension of the real numbers frequently used in many
    scientific and engineering fields.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 复数是实数的扩展，在许多科学和工程领域中经常使用。
- en: Complex Numbers in Mathematics
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学中的复数
- en: Complex numbers consist of two floating-point numbers, the real part *a* of
    the number and its imaginary part *b*. In mathematics, a complex number is written
    as *z=a+b*i, where i defined by i*² =* -1 is the imaginary unit. The conjugate
    complex counterpart of *z* is ![Complex Numbers in Mathematics](img/conjcomplex.jpg).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 复数由两个浮点数组成，即数的实部*a*和它的虚部*b*。在数学中，复数写作*z=a+b*i，其中i定义为i*² =* -1是虚数单位。*z*的共轭复数对应物为![数学中的复数](img/conjcomplex.jpg)。
- en: If the real part *a* is zero, the number is called an imaginary number.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实部*a*为零，则该数被称为虚数。
- en: The j notation
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: j表示法
- en: In Python, imaginary numbers are characterized by suffixing a floating-point
    number with the letter `j`, for example, `z = 5.2j`. A complex number is formed
    by the sum of a floating-point number and an imaginary number, for example, `z
    = 3.5 + 5.2j`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，虚数通过在浮点数后附加字母`j`来表示，例如，`z = 5.2j`。复数是通过浮点数和虚数的和形成的，例如，`z = 3.5 + 5.2j`。
- en: 'While in mathematics the imaginary part is expressed as a product of a real
    number *b* with the imaginary unit i, the Python way of expressing an imaginary
    number is not a product: `j` is just a suffix to indicate that the number is imaginary.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在数学中，虚部表示为实数*b*与虚数单位i的乘积，但Python表示虚数的方式不是乘积：`j`只是一个后缀，表示该数是虚数。
- en: 'This is demonstrated by the following small experiment:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下小型实验来演示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The method `conjugate` returns the conjugate of `z`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`conjugate`方法返回`z`的共轭：'
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Real and imaginary parts
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实部和虚部
- en: 'One may access the real and imaginary parts of a complex number *z* using the
    `real` and `imag` attributes. Those attributes are read-only:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`real`和`imag`属性访问复数*z*的实部和虚部。这些属性是只读的：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is not possible to convert a complex number to a real number:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无法将复数转换为实数：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Interestingly, the `real` and `imag` attributes as well as the conjugate method
    work just as well for complex arrays *([Chapter 4](ch04.html "Chapter 4. Linear
    Algebra – Arrays")*, *Linear Algebra – Arrays)*. We demonstrate this by computing
    the *N*^(th) roots of unity which are ![Real and imaginary parts](img/rootsofunity.jpg),
    that is, the *N* solutions of the equation ![Real and imaginary parts](img/rootsofunity1.jpg):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`real`和`imag`属性以及共轭方法对复数数组*([第4章](ch04.html "第4章。线性代数 - 数组")，*线性代数 - 数组)*同样有效。我们通过计算单位根的*N*次方来演示这一点，即方程![Real
    and imaginary parts](img/rootsofunity1.jpg)的*N*个解：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The resulting figure (*Figure 2.2*) shows the roots of unity together with the
    unit circle. (For more details on how to make plots, refer [Chapter 6](ch06.html
    "Chapter 6. Plotting"), *Plotting.*)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图（*图2.2*）显示了单位圆上的单位根。 (有关如何制作图表的更多详细信息，请参阅[第6章](ch06.html "第6章。绘图")，*绘图*）
- en: '![Real and imaginary parts](img/nrootsofunity.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Real and imaginary parts](img/nrootsofunity.jpg)'
- en: 'Figure 2.2: Roots of unity together with a unit circle'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：单位根与单位圆一起
- en: 'It is of course possible to mix the previous methods, as illustrated by the
    following examples:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以混合使用之前的方法，如下面的示例所示：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Booleans
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Boolean is a datatype named after *George Boole* (1815-1864). A Boolean variable
    can take only two values, `True` or `False`. The main use of this type is in logical
    expressions. Here are some examples:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值是一种以*乔治·布尔*（1815-1864）命名的数据类型。布尔变量只能取两个值，`True`或`False`。这种类型的主要用途是在逻辑表达式中。以下是一些示例：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Boolean expressions are often used in conjunction with the `if` statement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式通常与`if`语句一起使用：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Boolean operators
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: 'Boolean operations are performed using the `and`, `or`, and `not` keywords
    in Python:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，布尔运算使用`and`、`or`和`not`关键字执行：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The operators follow some precedence rules (refer to section *Executing scripts*
    in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting started*) which
    would make the parentheses in the third line and in the last obsolete (it is a
    good practice to use them anyway to increase the readability of your code). Note
    that the `and` operator is implicitly chained in the following Boolean expressions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符遵循一些优先级规则（请参阅[第1章](ch01.html "第1章。入门")中的*执行脚本*部分，*入门*），这将使第三行和最后一行的括号变得多余（尽管如此，使用它们来提高代码的可读性仍然是一个好习惯）。请注意，`and`运算符在以下布尔表达式中是隐式链式的：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Rules of Conversion to Booleans:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为布尔值的规则：
- en: '![Boolean operators](img/Capture.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![布尔运算符](img/Capture.jpg)'
- en: 'Table 2.2 : Rule of conversion to Boolean'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2：转换为布尔值的规则
- en: Boolean casting
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型转换
- en: Most objects Python may be converted to Booleans; this is called *Boolean casting*.
    The built-in function `bool` performs that conversion. Note that most objects
    are cast to `True`, except `0`, the empty tuple, the empty list, the empty string,
    or the empty array. These are all cast to `False`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的大多数对象都可以转换为布尔值；这被称为*布尔类型转换*。内置函数`bool`执行这种转换。请注意，大多数对象都转换为`True`，除了`0`、空元组、空列表、空字符串或空数组。这些都被转换为`False`。
- en: 'It is *not* possible to cast arrays into Booleans unless they contain no or
    only one element; this is explained further in [Chapter 5](ch05.html "Chapter 5. Advanced
    Array Concepts"), *Advanced Array Concepts*. The previous table contains summarized
    rules for Boolean casting. Some usage examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组转换为布尔值是不可能的，除非它们不包含任何元素或只包含一个元素；这将在[第5章](ch05.html "第5章。高级数组概念")中进一步解释，*高级数组概念*。前一个表格包含了布尔转换的总结性规则。一些用法示例：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Automatic Boolean casting
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动布尔转换
- en: 'Using an `if` statement with a non-Boolean type will cast it to a Boolean.
    In other words, the following two statements are always equivalent:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非布尔类型的`if`语句将将其转换为布尔值。换句话说，以下两个语句始终等价：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A typical example is testing whether a list is empty:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是测试列表是否为空：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An empty array, list, or tuple will return `False`. You can also use a variable
    in the `if` statement, for example, an integer:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 空数组、列表或元组将返回`False`。您也可以在`if`语句中使用变量，例如，一个整数：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we used `%` for the modulo operation, which returns the remainder
    of an integer division. In this case, it returns `0` or `1` as the remainder after
    modulo `2`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`%`进行取模运算，它返回整数除法的余数。在这种情况下，它返回`0`或`1`作为取模`2`后的余数。
- en: In this last example, the values `0` or `1` are cast to `bool`. Boolean operators
    `or`,`and` , and `not` will also implicitly convert some of their arguments to
    a Boolean.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，值`0`或`1`被转换为`bool`。布尔运算符`or`、`and`和`not`也会隐式地将它们的某些参数转换为布尔值。
- en: Return values of and and or
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`and`和`or`的返回值'
- en: 'Note that the operators `and` and `or` do not necessarily produce Boolean values.
    The expression `*x* and *y*` is equivalent to:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，运算符`and`和`or`不一定产生布尔值。表达式`*x* and *y*`等同于：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And the expression `x or y` is equivalent to:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并且表达式`x or y`等同于：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Interestingly, this means that when executing the statement `True or x`, the
    variable `x` need not even be defined! The same holds for `False and x`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这意味着在执行`True or x`语句时，变量`x`甚至不需要定义！对于`False and x`也是同样的情况。
- en: 'Note that, unlike their counterparts in mathematical logic, these operators
    are no longer commutative in Python. Indeed, the following expressions are not
    equivalent:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与数学逻辑中的对应运算符不同，这些运算符在Python中不再是交换的。确实，以下表达式并不等价：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Boolean and integer
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值和整数
- en: 'In fact, Booleans and integers are the same. The only difference is in the
    string representation of 0 and 1 which is in the case of Booleans `False` and
    `True` respectively. This allows constructions like this (for the format method
    refer section on *string formatting*):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，布尔值和整数是相同的。唯一的区别在于0和1的字符串表示，在布尔值中分别是`False`和`True`。这允许构建如下（有关格式化方法，请参阅*字符串格式化*部分）：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We note for readers already familiar with the concept of subclasses, that the
    type `bool` is a subclass of the type `int` (refer to [Chapter 8](ch08.html "Chapter 8. Classes"),
    *Classes*). Indeed, all four inquiries `isinstance(True, bool)`, `isinstance(False,
    bool)`, `isinstance(True, int)`, and `isinstance(False, int)` return the value
    `True` (refer to section *Type Checking* in [Chapter 3](ch03.html "Chapter 3. Container
    Types"), *Container Types*).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，对于已经熟悉子类概念的读者，类型`bool`是类型`int`的子类（请参阅[第8章](ch08.html "第8章。类")，*类*）。实际上，所有四个查询`isinstance(True,
    bool)`、`isinstance(False, bool)`、`isinstance(True, int)`和`isinstance(False, int)`都返回值`True`（请参阅[第3章](ch03.html
    "第3章。容器类型")，*容器类型*中的*类型检查*部分）。
- en: Even rarely used statements such as `True+13` are syntactically correct.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 即使很少使用的语句，如`True+13`，也是语法正确的。
- en: Strings
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'The type `string` is a type used for text:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类型是用于文本的类型：'
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A string is enclosed either by single or double quotes. If a string contains
    several lines, it has to be enclosed by three double quotes `"""` or three single
    quotes `'''`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串由单引号或双引号包围。如果字符串包含多行，它必须由三个双引号`"""`或三个单引号`'''`包围。
- en: 'Strings can be indexed with simple indexes or slices (refer to [Chapter 3](ch03.html
    "Chapter 3. Container Types"), *Container Types*, for a comprehensive explanation
    on slices):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以使用简单索引或切片进行索引（有关切片的全面解释，请参阅[第3章](ch03.html "第3章。容器类型")，*容器类型*）：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Strings are immutable; that is, items cannot be altered. They share this property
    with tuples. The command **`book[1] = ''a''`** returns:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的；也就是说，项目不能被更改。它们与元组共享这个属性。命令**`book[1] = 'a'`**返回：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The string `''\n''` is used to insert a line break  and `''t''` inserts a horizontal
    tabulator (TAB) into the string to align several lines:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `'\n'` 用于插入换行符，而 `'t'` 将水平制表符（TAB）插入字符串以对齐多行：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'These strings are examples of *escape sequences*. Escape sequences always start
    with a backslash, `\` . A multi line string automatically includes escape sequences:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串是转义序列的例子。转义序列始终以反斜杠 `\` 开头。多行字符串自动包含转义序列：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A special escape sequence is `""`, which represents the backslash symbol in
    text:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊转义序列是 `""`，它代表文本中的反斜杠符号：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The same can be achieved by using a raw string instead:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始字符串也可以达到相同的效果：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that in raw strings, the backslash remains in the string and is used to
    escape some special characters:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在原始字符串中，反斜杠仍然保留在字符串中，并用于转义一些特殊字符：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Operations on strings and string methods
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作和字符串方法
- en: 'Addition of strings means concatenation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的相加意味着连接：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Multiplication is just repeated addition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法只是重复加法：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When strings are compared, lexicographical order applies and the uppercase
    form precedes the lowercase form of the same letter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较字符串时，使用字典序，大写字母形式排在相同字母的小写字母形式之前：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Among the variety of string methods, we will mention here only the most important
    ones:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多字符串方法中，我们在此仅提及最重要的几个：
- en: '**Splitting a string**: This method generates a list from a string by using
    a single or multiple blanks as separators. Alternatively, an argument can be given
    by specifying a particular string as a separator:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分割字符串**：此方法通过使用单个或多个空格作为分隔符，从一个字符串生成一个列表。或者，可以通过指定一个特定的字符串作为分隔符来提供一个参数：'
- en: '[PRE45]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Joining a list to a string**: This is the reverse operation of splitting:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将列表连接到字符串**：这是分割操作的逆操作：'
- en: '[PRE46]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Searching in a string**: This method returns the first index in the string,
    where a given search substring starts:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在字符串中搜索**：此方法返回给定搜索子字符串在字符串中开始的第一个索引：'
- en: '[PRE47]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If the search string is not found, the return value of the method is -1 .
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果搜索字符串未找到，该方法返回的值是 -1 。
- en: String formatting
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'String formatting is done using the `format` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `format` 方法进行字符串格式化：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The function `format` is a string method; it scans the string for the occurrence
    of placeholders, which are enclosed by curly brackets. These placeholders are
    replaced in a way specified by the argument of the format method. How they are
    replaced depends on the format specification defined in each `{}` pair. Format
    specifications are indicated by a colon, `":"`, as their prefix.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 函数是一个字符串方法；它扫描字符串以查找占位符的出现，这些占位符由大括号包围。这些占位符会根据格式方法参数指定的方式被替换。它们是如何被替换的取决于每个
    `{}` 对中的格式规范。格式规范由冒号 `:` 作为其前缀指示。'
- en: 'The format method offers a range of possibilities to customize the formatting
    of objects depending on their types. Of particular use in scientific computing
    are the formatting specifiers for the `float` type. One may choose either the
    standard with `{:f}` or the exponential notation with `{:e}`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 格式方法提供了一系列可能性，可以根据对象的类型自定义其格式化。在科学计算中，特别有用的是 `float` 类型的格式规范。可以选择使用带有 `{:f}`
    的标准格式或带有 `{:e}` 的指数表示法：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The format specifiers allow to specify the rounding precision (digits following
    the decimal point in the representation). Also the total number of symbols including
    leading blanks to represent the number can be set.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 格式规范允许指定舍入精度（小数点后的数字表示）。还可以设置表示数字时包括前导空格在内的总符号数。
- en: 'In this example, the name of the object that gets its value inserted is given
    as an argument to the format method. The first `{}` pair is replaced by the first
    argument and the following pairs by the subsequent arguments. Alternatively, it
    may also be convenient to use the key-value syntax:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，获取其值插入的对象的名称作为格式方法的参数给出。第一个 `{}` 对被第一个参数替换，后续对由后续参数替换。或者，也可以方便地使用键值语法：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, two values are processed, a string `name` without a format specifier and
    a float `value` that is printed in fixed point notation with one digit after the
    decimal point. (We refer to the complete reference documentation for more details
    on *string formatting*, [[34]](apa.html "Appendix . References")).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，处理了两个值，一个没有格式说明符的字符串 `name` 和一个以小数点后一位固定点表示法打印的浮点数 `value`。（有关字符串格式化的详细信息，请参阅完整的参考文档
    [[34]](apa.html "附录。参考文献")）。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Braces in the string**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串中的大括号**'
- en: 'Sometimes, a string might contain a pair of curly braces, which should not
    be considered as placeholders for a `format` method. In that case, double braces
    are used:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个字符串可能包含一对大括号，不应将其视为 `format` 方法的占位符。在这种情况下，使用双大括号：
- en: '`r"we {} in LaTeX \begin{{equation}}".format(''like'')`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`r"我们 {} 在LaTeX \begin{{equation}}".format(''喜欢'')`'
- en: This returns the following string: `'we like in LaTeX \\begin{equation}'`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回以下字符串： `'我们喜欢在LaTeX \\begin{equation}'`。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you met the basic data types in Python and saw the corresponding
    syntax elements. We will work mostly with numeric types such as integers, floats
    and complex.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你遇到了Python中的基本数据类型，并看到了相应的语法元素。我们将主要使用数值类型，如整数、浮点数和复数。
- en: Booleans are needed for setting conditions, and by using strings, we often communicate
    results and messages.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值用于设置条件，并且通过使用字符串，我们通常传达结果和消息。
- en: Exercises
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Ex. 1 **→ Check whether *x =* 2.3 is a zero of the function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**例1 **→ 检查函数的零点 *x =* 2.3：'
- en: '![Exercises](img/polynomialCh2.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/polynomialCh2.jpg)'
- en: '**Ex. 2 →** According to de Moivre''s formula, the following holds:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**例2→** 根据棣莫弗公式，以下成立：'
- en: '![Exercises](img/deMoivre-1.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/deMoivre-1.jpg)'
- en: Choose numbers *n* and *x* and verify that formula in Python.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数字 *n* 和 *x* 并在Python中验证该公式。
- en: '**Ex. 3 →** Complex numbers. Verify Euler''s formula in the same way:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**例3→** 复数。以相同的方式验证欧拉公式：'
- en: '![Exercises](img/EulersFormula.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/EulersFormula.jpg)'
- en: '**Ex. 4 →** Suppose we are trying to check the convergence of a diverging sequence
    (here the sequence is defined by the recursive relation *u[n]*[+1]= 2*u[n]* and
    u[0] = 1.0):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**例4→** 假设我们正在尝试检查一个发散序列的收敛性（这里序列由递归关系 *u[n]*[+1]= 2*u[n]* 和 u[0] = 1.0 定义）：'
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since the sequence does not converge, the code should print the `No convergence`
    message. Execute it to see what happens.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于序列没有收敛，代码应该打印出 `没有收敛` 的消息。执行它以查看会发生什么。
- en: 'What happens if you replace the line:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将以下行替换掉会发生什么：
- en: '[PRE52]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'with:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用：
- en: '[PRE53]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It should give exactly the same result, shouldn't it? Run the code again to
    see what happens.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该给出完全相同的结果，不是吗？再次运行代码以查看会发生什么。
- en: What happens if you replace *u=1.0* by *u=1* (without decimal point). Run the
    code to check your predictions.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将 *u=1.0* 替换为 *u=1*（不带小数点）。运行代码以检查你的预测。
- en: Explain the unexpected behavior of this code. The key to understand what happens
    is that `inf`evaluates to `nan`, and the comparison of `nan` with anything else
    is returns always the value  `False` .
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释这个代码的意外行为。理解发生的关键是 `inf` 评估为 `nan`，并且 `nan` 与任何其他东西的比较总是返回值 `False` 。
- en: '**Ex. 5 →** An implication *C = (A ⇒ B)* is a Boolean expression that is defined
    as'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**例5→** 蕴含 *C = (A ⇒ B)* 是一个布尔表达式，定义为'
- en: '*C* is `True` if *A* is `False` or *A* and *B* are both `True`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C* 为 `True` 当 *A* 为 `False` 或 *A* 和 *B* 都为 `True`'
- en: '*C* is `False` otherwise'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C* 否则 `False`'
- en: Write a Python function `implication(A, B)`.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个Python函数 `implication(A, B)`。
- en: '**Ex. 6 →** This exercise is to train Boolean operations. Two binary digits
    (bits) are added by using a logical device called a **half adder**. It produces
    a carry bit (the digit of the next higher value) and the sum as defined by the
    following table, and half adder circuit.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**例6→** 这个练习是为了训练布尔运算。使用一个称为**半加器**的逻辑设备将两个二进制位（比特）相加。它产生一个进位位（下一个更高值的数字）和以下表格中定义的和，以及半加器电路。'
- en: '| **p** | **q** | **sum** | **carry** |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **p** | **q** | **和** | **进位** |'
- en: '| 1 | 1 | 0 | 1 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 0 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: Definition of the half adder operation
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 半加器操作的定义
- en: '![Exercises](img/half_adder.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/half_adder.jpg)'
- en: 'Figure 2.3: A half adder circuit'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：半加器电路
- en: 'A full adder consists of two half adders and sums up two bits and an additional
    carry bit on the input (refer to the following figure):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 全加器由两个半加器组成，它将两个位和一个额外的进位位相加（参见图以下）：
- en: '![Exercises](img/full_adder.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/full_adder.jpg)'
- en: 'Figure 2.4: A full adder circuit'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：全加器电路
- en: Write a function that implements a half adder and another that implements a
    full adder. Test these functions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个实现半加器的函数，另一个实现全加器的函数。测试这些函数。
