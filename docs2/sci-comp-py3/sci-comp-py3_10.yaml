- en: Chapter 10. Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. 错误处理
- en: In this chapter, we will cover errors, exceptions, and how to find and fix them.
    Handling exceptions is an important part of writing reliable and usable code.
    We will introduce the basic built-in exceptions and show how to use and treat
    exceptions. We'll introduce debugging and show you how to use the built-in Python
    debugger.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍错误、异常以及如何查找和修复它们。处理异常是编写可靠和可用代码的重要部分。我们将介绍基本的内置异常，并展示如何使用和处理异常。我们将介绍调试，并展示如何使用内置的
    Python 调试器。
- en: What are exceptions?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常是什么？
- en: One error programmers (even experienced ones) find is when code has incorrect
    syntax, meaning that the code instructions are not correctly formatted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员（即使是经验丰富的程序员）发现的一个错误是代码有错误的语法，这意味着代码指令格式不正确。
- en: 'Consider an example of Syntax error:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个语法错误的例子：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The error occurs because of a missing colon at the end of the `for` declaration.
    This is an example of an exception being raised. In the case of `SyntaxError`,
    it tells the programmer that the code has incorrect syntax and also prints the
    line where the error occurred, with an arrow pointing to where in that line the
    problem is.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为 `for` 声明末尾缺少冒号。这是一个异常被引发的例子。在 `SyntaxError` 的情况下，它告诉程序员代码有错误的语法，并打印出错误发生的行，其中有一个箭头指向该行中的问题所在。
- en: Exceptions in Python are derived (inherited) from a base class called `Exception`. Python
    comes with a number of built-in exceptions. Some common exception types are listed
    in *Table 10.1,* (for full list of built-in exceptions refer to *[[38]](apa.html
    "Appendix . References")*).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的异常是从一个称为 `Exception` 的基类派生（继承）的。Python 内置了许多异常。一些常见的异常类型列在 *表 10.1*
    中（有关内置异常的完整列表，请参阅 *[[38]](apa.html "附录 . 参考文献")*）。
- en: Here are two common examples of exceptions. As you might expect, `ZeroDivisionError`
    is raised when you try to divide by zero.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个常见的异常示例。正如你所预期的，当你尝试除以零时，会引发 `ZeroDivisionError`。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| **Exception** | **Description** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **异常** | **描述** |'
- en: '| `IndexError` | Index is out of bounds, for example, `v[10]` when v only has
    5 elements |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `IndexError` | 索引超出范围，例如，当 v 只有 5 个元素时 `v[10]` |'
- en: '| `KeyError` | A reference to an undefined dictionary key |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `KeyError` | 引用未定义的字典键 |'
- en: '| `NameError` | A name not found, for example, an undefined variable |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `NameError` | 未找到名称，例如，未定义的变量 |'
- en: '| `LinAlgError` | Errors in the `linalg` module, for example, when solving
    a system with a singular matrix |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `LinAlgError` | `linalg` 模块中的错误，例如，当使用奇异矩阵求解系统时 |'
- en: '| `ValueError` | Incompatible data value, for example, when using `dot` with
    incompatible arrays |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `ValueError` | 数据值不兼容，例如，使用 `dot` 与不兼容的数组 |'
- en: '| `IOError` | I/O operation fails, for example, "file not found" |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `IOError` | I/O 操作失败，例如，“文件未找到” |'
- en: '| `ImportError` | A module or name is not found on import |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `ImportError` | 导入模块或名称时未找到 |'
- en: 'Table10.1: Some frequently used built-in exceptions and their meaning'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1：一些常用内置异常及其含义
- en: A division with zero raises `ZeroDivisionError` and prints out the file, line,
    and function name where the error occurred.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除以零会引发 `ZeroDivisionError` 并打印出错误发生的文件、行和函数名称。
- en: 'As we have seen before, arrays can only contain elements of the same data type.
    If you try to assign a value of an incompatible type, a `ValueError` is raised.
    An example, of a value error:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，数组只能包含相同数据类型的元素。如果你尝试分配一个不兼容类型的值，则会引发 `ValueError`。一个值错误的例子：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `ValueError` is raised because the array contains floats and an element
    cannot be assigned a string value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`ValueError` 被引发，因为数组包含浮点数，而一个元素不能被分配一个字符串值。
- en: Basic principles
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本原则
- en: Let's look at the basic principles on how to use exceptions by raising them
    with `raise` and catching them with `try` statements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过使用 `raise` 语句引发异常和 `try` 语句捕获异常来使用异常的基本原则。
- en: Raising exceptions
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'Creating an error is referred to as raising an exception. You saw some examples
    of exceptions in the previous section. You can also define your own exceptions,
    of a predefined type or type-less. Raising an exception is done with the command
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建错误称为引发异常。你已经在上一节中看到了一些异常的示例。你也可以定义自己的异常，可以是预定义类型或无类型。引发异常使用如下命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It might be tempting to print out error messages when something goes wrong,
    for example, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当出错时，可能会诱使你打印出错误消息，例如，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is not recommended for a number of reasons. Firstly, printouts are easy
    to miss, especially if the message is buried in many other messages being printed
    to your console. Secondly, and more importantly, it renders your code unusable
    by other code. The calling code will have no way of knowing that an error occurred
    and therefore have no way of taking care of it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多种原因，这并不推荐。首先，打印输出很容易被忽略，尤其是如果消息被埋藏在许多其他打印到控制台的消息中。其次，更重要的是，它使得其他代码无法使用你的代码。调用代码将无法知道发生了错误，因此无法处理它。
- en: 'For these reasons, it is always better to raise an exception instead. Exceptions
    should always contain a descriptive message, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，总是抛出异常而不是捕获异常要好。异常应该总是包含一个描述性的消息，例如：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This message will stand out clearly for the user. It also gives the opportunity
    for the calling code to know that an error occurred, and to possibly find a remedy.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息将清楚地显示给用户。它还给了调用代码知道发生了错误的机会，并可能找到补救措施。
- en: 'Here is a typical example of checking the input inside a function to make sure
    it is usable before continuing. For an example, a simple check for negative values
    and the correct data type ensures the intended input of a function to compute
    factorials:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的例子，检查函数内部的输入以确保在继续之前它是可用的。例如，对负值和正确数据类型进行简单检查确保了计算阶乘函数的预期输入：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The user of the function will immediately know what the error is, if an incorrect
    input is given, and it is the user's responsibility to handle the exception. Note
    the use of the exception name when raising a predefined exception type, in this
    case `ValueError` followed by the message. By specifying the type of the exception,
    the calling code can decide to handle errors differently depending on what type
    of error is raised.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入不正确，函数的用户将立即知道错误是什么，并且处理异常是用户的责任。注意在抛出预定义的异常类型时使用异常名称，在这种情况下是 `ValueError`
    后跟消息。通过指定异常类型，调用代码可以决定根据抛出的错误类型以不同的方式处理错误。
- en: Summing up, it is always better to raise exceptions than to print error messages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，总是抛出异常比打印错误消息要好。
- en: Catching exceptions
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获异常
- en: Dealing with an exception is referred to as catching an exception. Checking
    for exceptions is done with the `try` and `except` commands.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常被称为捕获异常。检查异常使用 `try` 和 `except` 命令进行。
- en: An exception stops the program execution flow and looks for the closest `try`
    enclosing block. If the exception is not caught, the program unit is left and
    it continues searching for the next enclosing `try` block in a program unit higher
    up in the calling stack. If no block is found and the exception is not handled,
    execution stops entirely; the standard traceback information is displayed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 异常会停止程序执行流程，并寻找最近的包含 `try` 的包围块。如果异常没有被捕获，程序单元将被留下，并且它将继续在调用栈中更高层的程序单元中搜索下一个包围的
    `try` 块。如果在没有找到任何块且异常未被处理的情况下，执行将完全停止；将显示标准的回溯信息。
- en: 'Let''s look at an example for the `try` statement:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `try` 语句的一个例子：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, if the code inside the `try` block raises an error of type `ValueError`,
    the exception will be caught and the message in the `except` block printed. If
    no exception occurs inside the `try` block, the `except` block is skipped entirely
    and execution continues.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果 `try` 块内部抛出一个 `ValueError` 类型的错误，异常将被捕获，并在 `except` 块中打印出消息。如果 `try`
    块内部没有发生异常，则 `except` 块将被完全跳过，并且执行继续。
- en: 'The `except` statement can catch multiple exceptions. This is done by simply
    grouping them in a tuple, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`except` 语句可以捕获多个异常。这是通过简单地将它们分组在一个元组中实现的，如下所示：'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `try` block can also have multiple `except` statements. This makes it possible
    to handle exceptions differently depending on the type. Let''s see an example
    of multiple exception types:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 块也可以有多个 `except` 语句。这使得根据异常类型的不同来处理异常成为可能。让我们看看多个异常类型的例子：'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here an `OSError` will be caught if, for example, the file does not exist; and
    a `ValueError` will be caught if, for example, the data in the first line of the
    file is not compatible with the float data type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果文件不存在，将会捕获一个 `OSError`；如果文件的第一行中的数据与浮点数据类型不兼容，将会捕获一个 `ValueError`。
- en: 'In this example we assigned the `OSError` to a variable `oe` by the keyword
    `as`. This allows to access more details when handling this exception. Here we
    printed the error string `oe.strerror` and the name of the related file `oe.filename`.
    Each error type can have its own set of variables depending on the type. If the
    file does not exist, in the preceding example, the message will be:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们通过关键字`as`将`OSError`赋值给变量`oe`。这允许在处理此异常时访问更多详细信息。在这里，我们打印了错误字符串`oe.strerror`和相关的文件名`oe.filename`。每种错误类型都可以根据类型有自己的变量集。如果文件不存在，在先前的示例中，消息将是：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the other hand, if the file exists but you don’t have permission to open
    it, the message will be:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果文件存在但您没有权限打开它，消息将是：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a useful way to format the output when catching exceptions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在捕获异常时格式化输出的有用方式。
- en: 'The `try`  -  `except` combination can be extended with optional `else` and
    `finally` blocks. An example of using `else` can be seen in section *Testing the
    bisection algorithm* of [Chapter 13](ch13.html "Chapter 13. Testing"), *Testing*.
    Combining `try` with `finally` gives a useful construction when cleanup work needs
    to happen at the end:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` - `except`组合可以通过可选的`else`和`finally`块进行扩展。使用`else`的一个示例可以在第13章的*测试二分查找算法*部分中看到，*测试*。将`try`与`finally`结合使用，当需要在结束时执行清理工作时有用的构造：'
- en: 'An example for making sure a file is closed properly:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文件正确关闭的一个示例：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will make sure that the file is closed at the end no matter what exceptions
    are thrown while processing the file data. Exceptions that are not handled inside
    the `try` statement are saved and raised after the `finally` block. This combination
    is used in the `with` statement; see section *Context Managers - the with statement*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保无论在处理文件数据时抛出什么异常，文件最终都会被关闭。在`try`语句内部未处理的异常将被保存，并在`finally`块之后抛出。这种组合在`with`语句中使用；请参阅*上下文管理器
    - with语句*部分。
- en: User-defined exceptions
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户自定义异常
- en: Besides the built-in Python exceptions, it is also possible to define your own
    exceptions. Such user-defined exceptions should inherit from the `Exception` base
    class. This can be useful when you define your own classes like the polynomial
    class in section *Polynomials* of [Chapter 14](ch14.html "Chapter 14. Comprehensive
    Examples"), *Comprehensive Examples*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的Python异常之外，还可以定义自己的异常。这样的用户定义异常应该从`Exception`基类继承。当您定义自己的类，如第14章*综合示例*部分的*多项式*中的多项式类时，这可能很有用。
- en: 'Take a look at this small example of a simple user-defined exception:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个简单的用户定义异常的例子：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A random number is generated. If the number is below 0.5, an exception is thrown
    and a message that the value is too small is printed. If no exception is raised,
    the number is printed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个随机数。如果数字小于0.5，将抛出异常并打印出值过小的消息。如果没有抛出异常，则打印该数字。
- en: In this example, you also saw a case of using `else` in a `try` statement. The
    block under `else` will be executed if no exception occurs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您还看到了在`try`语句中使用`else`的一个案例。如果没有发生异常，则将执行`else`下的块。
- en: It is recommended that you define your exceptions with names that end in `Error`,
    like the naming of the standard built-in exceptions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用以`Error`结尾的名称定义您的异常，就像标准内置异常的命名一样。
- en: Context managers - the with statement
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器 - with语句
- en: 'There is a very useful construction in Python for simplifying exception handling
    when working with contexts, such as files or databases. The statement encapsulates
    the `try ... finally` structure in one simple command. Here is an example of using
    `with` to read a file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一个非常有用的构造，用于简化在处理上下文（如文件或数据库）时的异常处理。该语句将`try ... finally`结构封装在一个简单的命令中。以下是一个使用`with`读取文件的示例：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will try to open the file, run the specified operations on the file (for
    example, reading), and close the file. If anything goes wrong during the execution
    of `process_file_data`, the file is closed properly and then the exception is
    raised. This is equivalent to:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试打开文件，在文件上运行指定的操作（例如，读取），然后关闭文件。如果在执行`process_file_data`过程中出现任何错误，文件将正确关闭，然后抛出异常。这相当于：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will use this option in section *File handling* of [Chapter 12](ch12.html
    "Chapter 12. Input and Output"), *Input and Output*, when reading and writing
    files.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第12章*输入和输出*的*文件处理*部分中使用此选项来读取和写入文件。
- en: The preceding file reading example is an example of using context managers.
    Context managers are Python objects with two special methods, `_ _enter_ _` and
    `_ _exit_ _`. Any object of a class that implements these two methods can be used
    as a context manager. In this example, the file object `f`  is a context manager
    as there are `f._ _enter_ _` and `f._ _exit_ _` methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件读取示例是使用上下文管理器的示例。上下文管理器是具有两个特殊方法的 Python 对象，`_enter_` 和 `_exit_`。任何实现了这两个方法的类对象都可以用作上下文管理器。在这个例子中，文件对象
    `f` 是一个上下文管理器，因为它有 `f._enter_` 和 `f._exit_` 方法。
- en: The `_ _enter_ _` method should implement the initialization instructions, for
    example, opening a file or a database connection. If this method has a return
    statement, the returned object is accessed using the `as` construct. Otherwise,
    the `as` keyword is omitted. The `_ _exit_ _` method contains the cleanup instructions,
    for example, closing a file or committing transactions and closing a database
    connection. For more explanations and an example of a self-written context manager, see
    the section *Timing with a context manager* of [Chapter 13](ch13.html "Chapter 13. Testing"),
    *Testing*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`_enter_` 方法应该实现初始化指令，例如，打开文件或数据库连接。如果此方法有返回语句，则使用 `as` 构造来访问返回的对象。否则，省略 `as`
    关键字。`_exit_` 方法包含清理指令，例如，关闭文件或提交事务并关闭数据库连接。有关更多解释和自定义上下文管理器的示例，请参阅第13章 *使用上下文管理器计时*
    的 *测试* 部分，[第13章](ch13.html "Chapter 13. Testing")。'
- en: There are NumPy functions that can be used as context managers. For example,
    the `load` function supports context manager for some file formats. NumPy's function
    `errstate` can be used as a context manager to specify floating-point error handling
    behavior within a block of code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些 NumPy 函数可以用作上下文管理器。例如，`load` 函数支持某些文件格式的上下文管理器。NumPy 的函数 `errstate` 可以用作上下文管理器来指定代码块内的浮点错误处理行为。
- en: 'Here is an example of working with errstate and a context manager:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 errstate 和上下文管理器的示例：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Refer section *Infinite and Not a Number* of [Chapter 2](ch02.html "Chapter 2. Variables
    and Basic Types"), *Variables and Basic Types*, for more details on this example
    and section *Timing with a context manager* of [Chapter 13](ch13.html "Chapter 13. Testing"),
    *Testing *for another example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此示例的更多详细信息，请参阅[第2章](ch02.html "Chapter 2. Variables and Basic Types") *变量和基本类型*
    的 *无限和非数字* 部分，以及第13章 *使用上下文管理器计时* 的 *测试* 部分，[第13章](ch13.html "Chapter 13. Testing")。
- en: 'Finding Errors: Debugging'
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找错误：调试
- en: Errors in software code are sometimes referred to as *bugs*. Debugging is the
    process of finding and fixing bugs in code. This process can be performed at varying
    degrees of sophistication. The most efficient way is to use a tool called debugger.
    Having unittests in place is a good way to identify errors early, refer section
    *Using unittest* of [Chapter 13](ch13.html "Chapter 13. Testing"), *Testing*.
    When it is not obvious where or what the problem is, a debugger is very useful.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 软件代码中的错误有时被称为 *bug*。调试是查找和修复代码中错误的过程。这个过程可以在不同程度上进行。最有效的方法是使用一个名为调试器的工具。设置单元测试是一个很好的方法来早期识别错误，请参阅第13章
    *使用单元测试* 的 *测试* 部分，[第13章](ch13.html "Chapter 13. Testing")。当问题不明显时，调试器非常有用。
- en: Bugs
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误
- en: 'There are typically two kinds of bugs:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种类型的错误：
- en: An exception is raised and not caught.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生异常但没有被捕获。
- en: The code does not function properly.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码无法正常工作。
- en: The first case is usually easier to fix. The second can be more difficult as
    the problem can be a faulty idea or solution, a faulty implementation, or a combination
    of the two.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况通常更容易修复。第二种情况可能更困难，因为问题可能是一个错误的想法或解决方案，一个错误的实现，或者两者的组合。
- en: We are only concerned with the first case in what follows, but the same tools
    can be used to help find why the code does not do what it is supposed to.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们只关注第一种情况，但可以使用相同的工具来帮助找出代码为什么没有按预期执行。
- en: The stack
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈
- en: When an exception is raised, you see the call stack. The call stack contains
    the trace of all the functions that called the code where the exception was raised.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生异常时，你会看到调用栈。调用栈包含所有调用异常发生代码的函数的跟踪。
- en: 'A simple stack example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的栈示例：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The stack in this case is `f`, `g`, and `h`. The output generated by running
    this piece of code looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，栈是 `f`、`g` 和 `h`。运行此段代码生成的输出如下：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The error is printed. The sequence of functions leading up to the error is shown.
    The function  `f`  on line 11 was called, which in turn called `g` and then `h`.
    This caused the `ZeroDivisionError`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 错误被打印出来。显示导致错误的函数调用序列。第 11 行上的函数 `f` 被调用，它反过来调用 `g`，然后是 `h`。这导致了 `ZeroDivisionError`。
- en: A stack trace reports on the active stack certain point in the execution of
    a program. A stack trace lets you track the sequence of functions called up to
    a given point. Often this is after an uncaught exception has been raised. This
    is sometimes called post-mortem analysis, and the stack trace point is then the
    place where the exception occurred. Another option is to invoke a stack trace
    manually to analyze a piece of code where you suspect there is an error, perhaps
    before the exception occurs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 调试堆栈报告了程序执行中某个特定点的活动堆栈。调试堆栈让您能够追踪到给定点的函数调用序列。通常这发生在未捕获的异常被抛出之后。这有时被称为事后分析，此时调试堆栈点就是异常发生的地方。另一种选择是手动调用调试堆栈来分析您怀疑存在错误的代码片段，可能是在异常发生之前。
- en: The Python debugger
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 调试器
- en: Python comes with its own built-in debugger called pdb. Some development environments
    come with the debugger integrated. The following process still holds in most of
    these cases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python 自带一个名为 pdb 的内置调试器。一些开发环境将调试器集成其中。以下过程在大多数情况下仍然适用。
- en: 'The easiest way to use the debugger is to enable stack tracing at the point
    in your code that you want to investigate. Here is a simple example of triggering
    the debugger based on the example mentioned in section *Return values* of [Chapter
    7](ch07.html "Chapter 7. Functions"), *Functions*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器的最简单方法是启用您想要调查的代码点的堆栈跟踪。以下是基于第 7 章中 *返回值* 部分 *函数* 示例触发调试器的简单示例：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `pdb.set_trace()` command starts the debugger and enables tracing of subsequent
    commands. The preceding code will show this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb.set_trace()` 命令启动调试器并启用后续命令的跟踪。前面的代码将显示如下：'
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The debugger prompt is indicated with (Pdb). The debugger stops the program
    execution and gives you a prompt that lets you inspect variables, modify variables,
    step through commands, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器提示符用 (Pdb) 表示。调试器停止程序执行并提供一个提示，让您可以检查变量、修改变量、单步执行命令等。
- en: 'The current line is printed at each step, so you can follow where you are and
    what will happen next. Stepping through commands is done with the command `n`
    (next), like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步都会打印当前行，因此您可以跟踪您所在的位置以及接下来会发生什么。使用命令 `n` (next) 进行单步执行：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The command `n` (next)  will continue to the next line and print the line.
    If you need to see more than one line at the time, the list command `l` (list)
    shows the current line with surrounding code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `n` (next) 将继续到下一行并打印该行。如果您需要同时查看多行，列表命令 `l` (list) 将显示当前行及其周围的代码：
- en: 'Listing surrounding code in the debugger:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器中列出周围的代码：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inspection of variables can be done by printing their values to the console
    using the command `p` (print) followed by the variable name. An example of printing
    variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用命令 `p` (print) 后跟变量名称，可以将变量的值打印到控制台以进行检查。打印变量的示例：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `p` (print) command will print the variable; command `c` (continue) continues
    execution.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`p` (print) 命令将打印变量；命令 `c` (continue) 继续执行。'
- en: Changing a variable in mid-execution is useful. Simply assign the new value
    at the debugger prompt and step or continue the execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中更改变量是有用的。只需在调试器提示符下分配新值，然后单步执行或继续执行。
- en: 'An example of changing variables:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 变量更改的示例：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here the variable `z` is assigned a new value to be used throughout the remaining
    code. Note that the final printout has changed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量 `z` 被分配了一个新值，该值将在剩余的代码中使用。请注意，最终的打印输出已更改。
- en: Overview - debug commands
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述 - 调试命令
- en: In *Table 10.2*, the most common debug commands are shown. For a full listing
    and description of commands, (see the documentation [[25]](apa.html "Appendix . References")
    for more information). Note that any Python command also works, for example, assigning
    values to variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *表 10.2* 中，显示了最常见的调试命令。有关命令的完整列表和描述，(请参阅文档 [[25]](apa.html "附录 . 参考文献") 以获取更多信息)。请注意，任何
    Python 命令也都适用，例如，将值分配给变量。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Short variable names**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**短变量名**'
- en: If you want to inspect a variable with a name that coincides with any of the
    debugger's short commands, for example, `h`, you must use `!h` to display the
    variable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查与调试器的任何简短命令名称相同的变量，例如 `h`，您必须使用 `!h` 来显示该变量。
- en: '| **Command** | **Action** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **动作** |'
- en: '| `h` | Help (without arguments, it prints available commands) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 帮助（没有参数时，它打印可用的命令） |'
- en: '| `l` | List the code around the current line |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 列出当前行周围的代码 |'
- en: '| `q` | Quit (exits the debugger and the execution stops) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `q` | 退出（退出调试器并停止执行） |'
- en: '| `c` | Continue execution |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 继续执行 |'
- en: '| `r` | Continue execution until the current function returns |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 继续执行直到当前函数返回 |'
- en: '| `n` | Continue execution until the next line |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 继续执行直到下一行 |'
- en: '| `p <expression>` | Evaluate and print the expression in the current context
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `p <expression>` | 在当前上下文中评估并打印表达式 |'
- en: 'Table10.2: The most common debug commands for the debugger.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.2：调试器中最常见的调试命令。
- en: Debugging in IPython
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPython中的调试
- en: IPython comes with a version of the debugger called `ipdb`. At the time of writing
    this book, the differences are very minor but this may change.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: IPython自带一个名为`ipdb`的调试器版本。在撰写本书时，这些差异非常微小，但可能会发生变化。
- en: 'There is a command in IPython that automatically turns on the debugger in case
    of an exception. This is very useful when experimenting with new ideas or code.
    An example of how to automatically turn on the debugger in IPython:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: IPython中有一个命令，在发生异常时自动打开调试器。这在尝试新想法或代码时非常有用。以下是如何在IPython中自动打开调试器的示例：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The IPython magic command `%pdb` at the IPython prompt automatically enables
    the debugger when exceptions are raised. Here the debugger prompt shows `ipdb` instead
    to indicate that the debugger is running.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPython提示符下的IPython魔法命令`%pdb`在抛出异常时自动启用调试器。在这里，调试器提示符显示`ipdb`以指示调试器正在运行。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The key concepts in this chapter were exceptions and errors. We showed how an
    exception is raised to be later in another program unit caught. You can define
    your own exceptions and equip them with messages and current values of given variables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键概念是异常和错误。我们展示了如何抛出异常以便稍后在另一个程序单元中捕获。你可以定义自己的异常，并为其配备消息和给定变量的当前值。
- en: Code may return unexpected results without throwing an exception. The technique
    to localize the source of the erroneous result is called debugging. We introduced
    debugging methods and hopefully encouraged you to train them so that you have
    them readily available when needed. The need for serious debugging comes sooner
    than you might expect.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能会在没有抛出异常的情况下返回意外的结果。定位错误结果来源的技术称为调试。我们介绍了调试方法，并希望鼓励你训练这些方法，以便在需要时能够随时使用。严重调试的需求可能比你预期的要早。
