- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Establishing a Foundation with Snowpark
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Snowpark建立基础
- en: In the previous chapter, you learned the basics of Snowpark, its benefits, and
    how it allows developers to develop complex data applications using Python. This
    chapter will focus on establishing a solid foundation with Snowpark. Here, you
    will learn how to configure and operate Snowpark, select a coding style and structure,
    and explore Snowpark’s fundamentals in depth. This will help you acquire practical
    knowledge and skills to work efficiently with Snowpark, including setting up the
    environment, structuring the code, and utilizing it for different workloads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了Snowpark的基础知识、其优势以及它如何允许开发者使用Python开发复杂的数据应用程序。本章将专注于使用Snowpark建立坚实的基础。在这里，你将学习如何配置和操作Snowpark，选择编码风格和结构，并深入探索Snowpark的基本原理。这将帮助你获得实际的知识和技能，以高效地使用Snowpark，包括设置环境、结构化代码以及利用它处理不同的工作负载。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Configuring the Snowpark development environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Snowpark开发环境
- en: Operating with Snowpark
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Snowpark操作
- en: Establishing a project structure for Snowpark
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Snowpark建立项目结构
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you’ll require an active Snowflake account and Python installed
    with Anaconda configured locally. You can refer to the following documentation
    for installation instructions:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要一个活跃的Snowflake账户，并在本地安装了配置好的Anaconda Python。你可以参考以下文档以获取安装说明：
- en: You can sign up for a Snowflake Trial account at [https://signup.snowflake.com/](https://signup.snowflake.com/)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://signup.snowflake.com/](https://signup.snowflake.com/)注册Snowflake试用账户
- en: To configure Anaconda, follow the guide at [https://conda.io/projects/conda/en/latest/user-guide/getting-started.html](https://code.visualstudio.com/docs/python/python-tutorial).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要配置Anaconda，请遵循[https://conda.io/projects/conda/en/latest/user-guide/getting-started.html](https://code.visualstudio.com/docs/python/python-tutorial)中的指南
- en: In addition, to install and set up Python for VS Code, follow the guide at [https://code.visualstudio.com/docs/python/python-tutorial](https://code.visualstudio.com/docs/python/python-tutorial)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，要安装和设置VS Code中的Python，请遵循[https://code.visualstudio.com/docs/python/python-tutorial](https://code.visualstudio.com/docs/python/python-tutorial)中的指南
- en: To learn how to operate a Jupyter Notebook in VS Code, go to [https://code.visualstudio.com/docs/datascience/jupyter-notebooks](https://code.visualstudio.com/docs/datascience/jupyter-notebooks)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何在VS Code中操作Jupyter Notebook，请访问[https://code.visualstudio.com/docs/datascience/jupyter-notebooks](https://code.visualstudio.com/docs/datascience/jupyter-notebooks)
- en: The supporting materials for this chapter are available in this book’s GitHub
    repository at [https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark](https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的支持材料可在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark](https://github.com/PacktPublishing/The-Ultimate-Guide-To-Snowpark)。
- en: Configuring the Snowpark development environment
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Snowpark开发环境
- en: The first step in developing Snowpark is to set up the Snowpark development
    environment. Developers have much flexibility regarding which **integrated development
    environments** (**IDEs**) they can use to get started with Snowpark; the only
    thing they need to do is install the Snowpark client **application programmable
    interface** (**API**) and connect to their Snowflake account. The development
    environment can be a local Python environment that contains your favorite IDE
    or the new Snowflake Python worksheets in Snowsight. This section will cover setting
    up a Snowpark Python worksheet and the local development environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Snowpark的第一步是设置Snowpark开发环境。开发者有很大的灵活性，可以选择他们可以用来开始使用Snowpark的**集成开发环境**（**IDEs**）；他们唯一需要做的是安装Snowpark客户端**应用程序编程接口**（**API**）并连接到他们的Snowflake账户。开发环境可以是一个包含你喜欢的IDE的本地Python环境，或者Snowsight中的新Snowflake
    Python工作表。本节将涵盖设置Snowpark Python工作表和本地开发环境。
- en: Snowpark Python worksheet
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Snowpark Python工作表
- en: Snowflake released *Snowflake Worksheets for Python*, a new type of worksheet
    in Snowsight for developing a Python-based Snowpark environment from within Snowflake.
    This game-changing feature allows developers to easily leverage the power of Snowpark
    Python within Snowsight to perform data processing and create data pipelines,
    **machine learning** (**ML**) models, and applications by integrating Snowpark
    Python directly into the browser without setting up Python environments or installing
    open source libraries on the client. Instead, developers can easily use pre-existing
    packages from Anaconda or import their own Python files from stages into the Worksheet.
    In addition, they can quickly deploy the Python worksheets as a stored procedure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake 发布了 *Snowflake Worksheets for Python*，这是一种新的工作表类型，允许在 Snowflake 内部开发基于
    Python 的 Snowpark 环境。这一颠覆性功能允许开发者轻松利用 Snowpark Python 的力量在 Snowsight 中执行数据处理和创建数据管道、**机器学习**（**ML**）模型和应用，通过直接将
    Snowpark Python 集成到浏览器中，无需设置 Python 环境或在客户端安装开源库。相反，开发者可以轻松使用 Anaconda 中的预存软件包或从阶段导入自己的
    Python 文件到工作表中。此外，他们可以快速将 Python 工作表作为存储过程部署。
- en: Prerequisites for using Python worksheets
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 工作表的前提条件
- en: 'To enable and use Snowflake Python worksheets, you must first acknowledge the
    Anaconda terms of service in Snowsight. The following steps are to be performed
    by the organization’s administrator:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用和使用 Snowflake Python 工作表，您必须首先在 Snowsight 中确认 Anaconda 的服务条款。以下步骤应由组织管理员执行：
- en: 'First, you must sign into your Snowflake account. In the **Switch Role** section
    on the left panel, switch to the **ORGADMIN** role in the user context:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须登录到您的 Snowflake 账户。在左侧面板的 **切换角色** 部分中，切换到用户上下文中的 **ORGADMIN** 角色：
- en: '![Figure 2.1 – The ORGADMIN role in Snowflake](img/B19923_02_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Snowflake 中的 ORGADMIN 角色](img/B19923_02_1.jpg)'
- en: Figure 2.1 – The ORGADMIN role in Snowflake
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Snowflake 中的 ORGADMIN 角色
- en: 'Then, go to **Admin** | **Billing &** **Terms**:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到 **管理员** | **账单与** **条款**：
- en: '![Figure 2.2 – Admin | Billing & Terms](img/B19923_02_2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 管理员 | 账单与条款](img/B19923_02_2.jpg)'
- en: Figure 2.2 – Admin | Billing & Terms
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 管理员 | 账单与条款
- en: 'Click **Enable** next to **Anaconda** **Python packages**:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Anaconda** **Python 软件包** 旁边的 **启用**：
- en: '![Figure 2.3 – Enabling Anaconda Python packages](img/B19923_02_3.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 启用 Anaconda Python 软件包](img/B19923_02_3.jpg)'
- en: Figure 2.3 – Enabling Anaconda Python packages
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 启用 Anaconda Python 软件包
- en: 'You’ll get a popup, as shown in the following screenshot. Click **Acknowledge
    & Continue** to enable the packages:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个弹出窗口，如下面的截图所示。点击 **确认并继续** 以启用软件包：
- en: '![Figure 2.4 – Anaconda’s Terms and Services](img/B19923_02_4.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – Anaconda 的条款和服务](img/B19923_02_4.jpg)'
- en: Figure 2.4 – Anaconda’s Terms and Services
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – Anaconda 的条款和服务
- en: You’ll need to enable the Anaconda packages every time you create a new Snowflake
    environment. Now that we’ve enabled the packages, let’s see how we can work with
    Python worksheets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建新的 Snowflake 环境，您都需要启用 Anaconda 软件包。现在我们已经启用了这些软件包，让我们看看如何使用 Python 工作表。
- en: Database and schema creation in Snowflake Snowsight
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Snowflake Snowsight 中创建数据库和模式
- en: 'To create a database called `SNOWPARK_DEFINITIVE_GUIDE` and a schema called
    `MY_SCHEMA` using Snowflake’s Snowsight UI interface, perform the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Snowflake 的 Snowsight UI 界面创建名为 `SNOWPARK_DEFINITIVE_GUIDE` 的数据库和名为 `MY_SCHEMA`
    的模式，请执行以下步骤：
- en: 'Go to the Snowsight web interface, log in using your Snowflake credentials,
    and navigate to the **Data** | **Databases** section. This is typically located
    in the left-hand navigation menu:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Snowsight 网络界面，使用您的 Snowflake 凭据登录，并导航到 **数据** | **数据库** 部分。这通常位于左侧导航菜单中：
- en: '![Figure 2.5 – The Databases section](img/B19923_02_5.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 数据库部分](img/B19923_02_5.jpg)'
- en: Figure 2.5 – The Databases section
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 数据库部分
- en: 'Look for a button or link that says **+ Database** in the top-right corner
    and click it. In the dialogue box that appears, enter **SNOWPARK_DEFINITIVE_GUIDE**
    as the name for the new database. Optionally, you can specify other settings,
    such as **Comment**, if needed, and click **Create**:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角寻找一个按钮或链接，上面写着 **+ 数据库** 并点击它。在出现的对话框中，输入 **SNOWPARK_DEFINITIVE_GUIDE**
    作为新数据库的名称。如有需要，您可以指定其他设置，例如 **注释**，然后点击 **创建**：
- en: '![Figure 2.6 – The New Database dialogue](img/B19923_02_6.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 新数据库对话框](img/B19923_02_6.jpg)'
- en: Figure 2.6 – The New Database dialogue
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 新数据库对话框
- en: 'After creating the database, click on the **SNOWPARK_DEFINITIVE_GUIDE** database.
    This will take you to the following page:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库后，点击 **SNOWPARK_DEFINITIVE_GUIDE** 数据库。这将带您进入以下页面：
- en: '![Figure 2.7 – The SNOWPARK_DEFINTIVE_GUIDE page](img/B19923_02_7.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – SNOWPARK_DEFINTIVE_GUIDE 页面](img/B19923_02_7.jpg)'
- en: Figure 2.7 – The SNOWPARK_DEFINTIVE_GUIDE page
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – SNOWPARK_DEFINTIVE_GUIDE 页面
- en: 'On this page, look for a button or link that says **+ Schema** and click on
    it. In the dialogue box that appears, enter **MY_SCHEMA** as the name for the
    new schema. Optionally, you can specify other settings, such as **Comment** and
    **Managed access**. Click **Create** to create the schema:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此页面上，寻找一个写着**+ 模式**的按钮或链接并点击它。在出现的对话框中，将新模式的名字输入为**MY_SCHEMA**。可选地，你可以指定其他设置，例如**注释**和**管理访问**。点击**创建**来创建模式：
- en: '![Figure 2.8 – The New Schema dialogue](img/B19923_02_8.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 新模式对话框](img/B19923_02_8.jpg)'
- en: Figure 2.8 – The New Schema dialogue
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 新模式对话框
- en: We’ll consistently utilize the same database and schema throughout this book
    unless explicitly instructed otherwise in specific chapters.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，除非特定章节明确指示，否则我们将始终使用相同的数据库和模式。
- en: Working with Python worksheets in Snowflake
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Snowflake 中使用 Python 工作表
- en: 'Python worksheets come with a sample code template that can be used as a starter.
    The whole experience is embedded in Snowflake based on the Snowsight UI. Perform
    the following steps to create and work with Python worksheets in Snowflake:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python 工作表附带一个示例代码模板，可以作为起点使用。整个体验都基于 Snowflake 的 Snowsight UI。按照以下步骤创建和使用 Snowflake
    中的 Python 工作表：
- en: 'Navigate to the **Worksheets** section from the menu in the Snowsight UI:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Snowsight UI 的菜单导航到**工作表**部分：
- en: '![Figure 2.9 – The Worksheets menu option](img/B19923_02_9.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 工作表菜单选项](img/B19923_02_9.jpg)'
- en: Figure 2.9 – The Worksheets menu option
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 工作表菜单选项
- en: 'On the **Worksheets** pane, click the **+** icon on the right and select **Python
    Worksheet** to create a Python worksheet:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工作表**面板中，点击右侧的**+**图标并选择**Python 工作表**来创建 Python 工作表：
- en: '![Figure 2.10 – Creating a Python worksheet](img/B19923_02_10.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 创建 Python 工作表](img/B19923_02_10.jpg)'
- en: Figure 2.10 – Creating a Python worksheet
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 创建 Python 工作表
- en: 'Select a database and schema so that you can work in the worksheet context.
    The scope of the Python code will operate based on these details:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个数据库和模式，这样你就可以在工作表上下文中工作。Python 代码的作用域将基于这些细节：
- en: '![Figure 2.11 – Worksheet context](img/B19923_02_11.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 工作表上下文](img/B19923_02_11.jpg)'
- en: Figure 2.11 – Worksheet context
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 工作表上下文
- en: 'The worksheet has a handler function that’s invoked when the worksheet is executed.
    The **Settings** menu allows you to configure your worksheets. The default handler
    function is **main()**, and the return type can be specified as **Table()**, **Variant**,
    or **String**. The result will be shown in the format you choose:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作表有一个处理函数，当工作表执行时会被调用。**设置**菜单允许你配置你的工作表。默认的处理函数是**main()**，返回类型可以指定为**Table()**、**Variant**或**String**。结果将以你选择的格式显示：
- en: '![Figure 2.12 – Worksheet settings](img/B19923_02_12.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 工作表设置](img/B19923_02_12.jpg)'
- en: Figure 2.12 – Worksheet settings
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 工作表设置
- en: Worksheet preferences such as linting and line wrapping can also be customized
    here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 工作表首选项，如代码检查和换行，也可以在此处自定义。
- en: 'The Python code can be executed by clicking on the **RUN** button at the top
    right of the worksheet:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过点击工作表右上角的**运行**按钮来执行 Python 代码：
- en: '![Figure 2.13 – Executing the worksheet](img/B19923_02_13.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 执行工作表](img/B19923_02_13.jpg)'
- en: Figure 2.13 – Executing the worksheet
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 执行工作表
- en: You can start developing and executing the Python code within the worksheet
    to see the results.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在工作表中开始开发和执行 Python 代码以查看结果。
- en: Managing Anaconda packages in Python worksheets
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 工作表中管理 Anaconda 包
- en: 'Python worksheets come with an integrated Anaconda environment that supports
    importing the most common Anaconda libraries without having to worry about managing
    dependencies. It also supports importing custom packages from the internal stage.
    In this section, we will look at managing Anaconda packages in Python. To do this,
    perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python 工作表附带一个集成的 Anaconda 环境，支持导入最常见的 Anaconda 库，无需担心依赖管理。它还支持从内部阶段导入自定义包。在本节中，我们将探讨如何管理
    Python 中的 Anaconda 包。为此，请执行以下步骤：
- en: 'Navigate to the **Packages** tab from the menu and select **Anaconda Packages**.
    This will show a list of pre-installed packages and their versions:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单导航到**包**标签并选择**Anaconda 包**。这将显示预安装的包及其版本：
- en: '![Figure 2.14 – Anaconda Packages](img/B19923_02_14.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – Anaconda 包](img/B19923_02_14.jpg)'
- en: Figure 2.14 – Anaconda Packages
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – Anaconda 包
- en: 'You can search for and install the required packages by using the search bar:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用搜索栏搜索和安装所需的包：
- en: '![Figure 2.15 – Searching for packages](img/B19923_02_15.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 搜索包](img/B19923_02_15.jpg)'
- en: Figure 2.15 – Searching for packages
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 搜索包
- en: 'You can also modify the version of the packages by selecting the available
    versions from the respective dropdown:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过从相应的下拉列表中选择可用版本来修改包的版本：
- en: '![Figure 2.16 – Package versioning](img/B19923_02_16.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 包版本](img/B19923_02_16.jpg)'
- en: Figure 2.16 – Package versioning
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 包版本
- en: 'You can execute the following query to check the available Python packages
    in Snowflake using SQL:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下查询通过 SQL 检查 Snowflake 中可用的 Python 包：
- en: '[PRE0]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This query obtains the results from the packages view in the information schema:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此查询从信息模式中的包视图获取结果：
- en: '![Figure 2.17 – Anaconda packages query](img/B19923_02_17.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – Anaconda 包查询](img/B19923_02_17.jpg)'
- en: Figure 2.17 – Anaconda packages query
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – Anaconda 包查询
- en: 'If you need to check the version information of specific packages, you can
    filter the query by the package’s name:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要检查特定包的版本信息，可以通过包的名称过滤查询：
- en: '[PRE1]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![Figure 2.18 – Anaconda Python package query](img/B19923_02_18.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – Anaconda Python 包查询](img/B19923_02_18.jpg)'
- en: Figure 2.18 – Anaconda Python package query
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – Anaconda Python 包查询
- en: This query shows the list of Anaconda packages that are available in my account.
    In the next section, we’ll learn how to manage custom Python packages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询显示了我账户中可用的 Anaconda 包列表。在下一节中，我们将学习如何管理自定义 Python 包。
- en: Managing custom packages in Python worksheets
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 工作表中管理自定义包
- en: Python worksheets also support the ability to import custom Python packages
    that can be used in Python code. However, the package must be uploaded into the
    internal stage, which is the storage part of the Snowflake account, and imported
    from it. In Snowsight, you can load files into a named internal stage area, allowing
    you to conveniently view and utilize them within your Python worksheets or load
    the data into a table using SQL. However, it’s important to note that Snowsight
    does not support loading files into user or table stages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python 工作表也支持导入自定义 Python 包的功能，这些包可以在 Python 代码中使用。但是，必须将包上传到内部阶段，这是 Snowflake
    账户的存储部分，并从中导入。在 Snowsight 中，您可以将文件加载到命名的内部阶段区域，这样您就可以方便地在 Python 工作表中查看和使用它们，或者使用
    SQL 将数据加载到表中。但是，需要注意的是，Snowsight 不支持将文件加载到用户或表阶段。
- en: 'To create a named internal stage, ensure that the role you are using has the
    **USAGE** privilege on the relevant database and schema and the **CREATE STAGE**
    privilege on the schema. Let’s begin:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个命名的内部阶段，请确保您使用的角色在相关数据库和模式上具有**使用**权限，以及在模式上具有**创建阶段**权限。让我们开始吧：
- en: Sign in to Snowsight.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录 Snowsight。
- en: Access the **Data** section and navigate to **Databases**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问**数据**部分并导航到**数据库**。
- en: Choose the desired database and schema where you want to create the stage and
    load files.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要创建阶段并加载文件的数据库和模式。
- en: 'Click **Create**, select **Stage**, and click **Snowflake Managed**:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**，选择**阶段**，然后点击**Snowflake 管理的**：
- en: '![Figure 2.19 – Creating a stage](img/B19923_02_19.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 创建阶段](img/B19923_02_19.jpg)'
- en: Figure 2.19 – Creating a stage
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 创建阶段
- en: 'Provide a name for the stage and opt-in to enable a directory table for the
    stage, allowing you to visualize the files. Once you’re done, click **Create**:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为阶段提供一个名称，并选择启用目录表以使阶段可视化。完成后，点击**创建**：
- en: '![Figure 2.20 – Creating an internal stage](img/B19923_02_20.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 创建内部阶段](img/B19923_02_20.jpg)'
- en: Figure 2.20 – Creating an internal stage
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 创建内部阶段
- en: 'To load files into a Snowflake-managed named internal stage using Snowsight,
    follow these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Snowsight 将文件加载到 Snowflake 管理的命名内部阶段，请按照以下步骤操作：
- en: Access the **Data** section and select **Databases**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问**数据**部分并选择**数据库**。
- en: Choose the database schema where you created the stage and select the stage
    itself.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您创建阶段的数据库模式，并选择阶段本身。
- en: Click **+ Files** to load the desired files into the stage.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+ 文件**将所需的文件加载到阶段。
- en: 'In the **Upload Your Files** dialogue that appears, select the files you want
    to upload (multiple files can be selected simultaneously):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的**上传您的文件**对话框中，选择您想要上传的文件（可以同时选择多个文件）：
- en: '![Figure 2.21 – Uploading a custom package](img/B19923_02_21.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – 上传自定义包](img/B19923_02_21.jpg)'
- en: Figure 2.21 – Uploading a custom package
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – 上传自定义包
- en: Optionally, specify or create a path within the stage where you want to store
    the files.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在阶段内指定或创建一个路径，用于存储文件。
- en: Click **Upload**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **上传**。
- en: Once the files have been successfully loaded into the stage, you can perform
    various actions, depending on your requirements.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦文件成功加载到阶段，您就可以根据需求执行各种操作。
- en: With that, the package has been uploaded into the stage and is ready to be imported.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，包已经被上传到阶段，并准备好导入。
- en: Important note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The maximum permissible file size is 50 MB. You need a role with the **USAGE**
    privilege on the database and schema and the **WRITE** privilege on the stage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的最大文件大小为50 MB。您需要在数据库和模式上具有 **USAGE** 权限，以及在阶段上具有 **WRITE** 权限。
- en: 'Once the stage has been created and the package has been uploaded, you can
    import the module so that you can use it in the program. To import a package,
    follow these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建阶段并上传了包，您就可以导入模块，以便在程序中使用它。要导入包，请按照以下步骤操作：
- en: 'From the **Packages** menu, select **Stage Packages**:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **包** 菜单中选择 **阶段包**：
- en: '![Figure 2.22 – Stage Packages](img/B19923_02_22.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图2.22 – 阶段包](img/B19923_02_22.jpg)'
- en: Figure 2.22 – Stage Packages
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 – 阶段包
- en: 'Enter the path to the package. You can refer to the stage in the same database
    and schema using **@Stage/path/to/package.py**. If the stage is in a different
    database and schema, you can use **@Database.Schema.Stage/path/to/package.py**:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入包的路径。您可以使用 **@Stage/path/to/package.py** 在同一数据库和模式中引用阶段。如果阶段在不同的数据库和模式中，您可以使用
    **@Database.Schema.Stage/path/to/package.py**：
- en: '![Figure 2.23 – Importing a stage package](img/B19923_02_23.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图2.23 – 导入阶段包](img/B19923_02_23.jpg)'
- en: Figure 2.23 – Importing a stage package
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 – 导入阶段包
- en: 'Click **Import** to install the package. The module will now be visible under
    **Installed Packages**:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **导入** 以安装包。现在模块将在 **已安装包** 下可见：
- en: '![Figure 2.24 – Installing a stage package](img/B19923_02_24.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图2.24 – 安装阶段包](img/B19923_02_24.jpg)'
- en: Figure 2.24 – Installing a stage package
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 – 安装阶段包
- en: You can import the package into your code by using **import <****package name>**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过使用 **import <包名>** 将包导入到您的代码中。
- en: In the next section, we will cover how to deploy a Python stored procedure using
    the UI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何使用UI部署Python存储过程。
- en: Deploying a Python stored procedure
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署Python存储过程
- en: 'The Python script in our worksheet can be seamlessly deployed as a stored procedure.
    This can then be used in a regular SQL context or scheduled to execute as a task.
    To deploy a stored procedure, follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工作表中的Python脚本可以无缝地部署为存储过程。然后可以在常规SQL上下文中使用它，或安排为任务执行。要部署存储过程，请按照以下步骤操作：
- en: Click the **Deploy** button at the top right of the worksheet.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工作表右上角的 **部署** 按钮。
- en: 'Give the stored procedure a name; an optional comment can also be specified
    that provides information about it. If the stored procedure already exists, then
    check the **Replace if exists** box to replace the existing stored procedure:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给存储过程起一个名称；也可以指定一个可选的注释，提供有关它的信息。如果存储过程已存在，则勾选 **如果存在则替换** 复选框以替换现有存储过程：
- en: '![Figure 2.25 – Deploying a stored procedure](img/B19923_02_25.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图2.25 – 部署存储过程](img/B19923_02_25.jpg)'
- en: Figure 2.25 – Deploying a stored procedure
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25 – 部署存储过程
- en: Click **Deploy** to deploy the stored procedure. It will be deployed under the
    database and schema you provided in the worksheet context.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **部署** 以部署存储过程。它将在您在工作表上下文中提供的数据库和模式下部署。
- en: 'The stored procedure can now be executed in your worksheets using the following
    code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以使用以下代码在工作表中执行存储过程：
- en: '[PRE2]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the next section, we will cover the various features of Python worksheets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍Python工作表的各项功能。
- en: Features of Python worksheets
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python工作表的功能
- en: 'Python worksheets consist of some features that are developer-friendly and
    support productivity. Here are some of the distinct characteristics of Python
    worksheets:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python工作表包含一些对开发者友好的功能，并支持生产力。以下是Python工作表的某些独特特性：
- en: '**Interactive Python environment**: Worksheets support the Python language
    and support Snowpark **user-defined functions** (**UDFs**) and stored procedures.
    Features such as syntax highlighting, type-sensitive autocomplete for keywords,
    and handy diagnostics such as undeclared variables or invalid method usage help
    increase developers’ productivity:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式Python环境**：工作表支持Python语言，并支持Snowpark**用户自定义函数**（**UDFs**）和存储过程。诸如语法高亮、关键字类型敏感的自动完成以及诸如未声明的变量或无效方法使用等便捷的诊断功能有助于提高开发者的生产力：'
- en: '![Figure 2.26 – Interactive Python environment](img/B19923_02_26.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图2.26 – 交互式Python环境](img/B19923_02_26.jpg)'
- en: Figure 2.26 – Interactive Python environment
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26 – 交互式Python环境
- en: '**Python libraries support**: Python worksheets come with an integrated Anaconda
    environment that supports importing the most common Anaconda libraries without
    the need to worry about managing dependencies. It also supports importing custom
    packages from the internal stage.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python库支持**：Python工作表附带一个集成的Anaconda环境，支持导入最常见的Anaconda库，无需担心依赖管理。它还支持从内部阶段导入自定义包。'
- en: '**Snowpark debugging**: Python worksheets can display the results from a DataFrame
    inside Snowsight using the **show()** or **print()** function. The preview of
    the DataFrame can also be returned to display the output in tabular format, which
    is very useful when it comes to debugging Python programs:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Snowpark调试**：Python工作表可以使用**show()**或**print()**函数在Snowsight中显示DataFrame的结果。DataFrame的预览也可以返回以显示表格格式的输出，这在调试Python程序时非常有用：'
- en: '![Figure 2.27 –  Snowpark debugging](img/B19923_02_27.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图2.27 –  Snowpark调试](img/B19923_02_27.jpg)'
- en: Figure 2.27 – Snowpark debugging
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27 – Snowpark调试
- en: '**Collaboration**: Snowpark Python worksheets can be shared with developers.
    This makes collaboration much easier as multiple developers can access and work
    on the worksheet at the same time:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：Snowpark Python工作表可以与开发者共享。这使得协作变得更加容易，因为多个开发者可以同时访问并工作在工作表上：'
- en: '![Figure 2.28 – Worksheet collaboration](img/B19923_02_28.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图2.28 – 工作表协作](img/B19923_02_28.jpg)'
- en: Figure 2.28 – Worksheet collaboration
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28 – 工作表协作
- en: '**Charts and data exploration**: Python worksheets provide a convenient way
    to visualize data and DataFrames as charts, which helps with data exploration
    and provides an easy way to analyze the data quickly:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图表和数据探索**：Python工作表提供了一种方便的方式来可视化和探索数据以及DataFrame作为图表，这有助于数据探索并提供了一种快速分析数据的方法：'
- en: '![Figure 2.29 – Charts and data exploration](img/B19923_02_29.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图2.29 – 图表和数据探索](img/B19923_02_29.jpg)'
- en: Figure 2.29 – Charts and data exploration
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29 – 图表和数据探索
- en: In the next section, we will cover the limitations of Python worksheets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍Python工作表的局限性。
- en: Limitations of Python worksheets
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python工作表的局限性
- en: 'Python worksheets are relatively new in Snowsight and have some limitations
    in terms of functionality. Let’s take a closer look:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python工作表在Snowsight中相对较新，在功能方面存在一些局限性。让我们更仔细地看看：
- en: Logging levels lower than **WARN** do not appear in the **Results** area by
    default.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，低于**WARN**级别的日志级别不会出现在**结果**区域中。
- en: Python worksheets do not support breakpoints or selective execution of the portions
    of code. Instead, the entire code is run in the worksheet.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python工作表不支持断点或代码部分的选执行。相反，整个代码都在工作表中运行。
- en: The Python worksheet cannot display images or other artifacts of the Python
    code it generates. It can only show results that are returned through the DataFrame.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python工作表无法显示它生成的Python代码中的图像或其他元素。它只能显示通过DataFrame返回的结果。
- en: It only supports Python 3.8 and libraries that use Python 3.8.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅支持Python 3.8以及使用Python 3.8的库。
- en: Snowflake constantly updates features for Python worksheets, improving them
    for developers. As a result, Python worksheets make it easier and faster for developers
    to code in Python from within the Snowflake environment.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake不断更新Python工作表的功能，为开发者提供改进。因此，Python工作表使得开发者能够在Snowflake环境中更容易、更快地编写Python代码。
- en: Snowpark development in a local environment
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地环境中进行Snowpark开发
- en: Snowpark can also be developed conveniently from a local environment with your
    favorite IDE. The key benefit of Snowflake’s partnership with Anaconda is Anaconda’s
    Snowflake Snowpark for Python channel, which contains the necessary Python packages
    to run Snowpark. To use this channel, Anaconda or Miniconda should be installed
    and set up on the machine. In this section, we will walk you through how to set
    up Snowpark in your local development environment using Anaconda.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark 也可以方便地从本地环境使用您喜欢的 IDE 进行开发。Snowflake 与 Anaconda 的合作的关键优势在于 Anaconda
    的 Snowflake Snowpark for Python 通道，其中包含运行 Snowpark 所需的 Python 包。要使用此通道，Anaconda
    或 Miniconda 应该安装在机器上。在本节中，我们将向您介绍如何使用 Anaconda 在本地开发环境中设置 Snowpark。
- en: Important note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This book will utilize Anaconda for Snowpark development as it is the recommended
    approach and utilizes the benefits of Anaconda’s package manager to easily set
    up and manage the Snowpark development environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用 Anaconda 进行 Snowpark 开发，因为这是一种推荐的方法，并利用 Anaconda 的包管理器的优势，轻松设置和管理 Snowpark
    开发环境。
- en: 'The Snowpark API requires Python 3.8 to be installed. Snowflake recommends
    that you use Anaconda for easy package management. You can check out the Python
    version you have by running the following command in the **command-line** **interface**
    (**CLI**):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark API 需要安装 Python 3.8。Snowflake 建议您使用 Anaconda 以便于包管理。您可以通过在 **命令行界面**
    （**CLI**） 中运行以下命令来检查您拥有的 Python 版本：
- en: '[PRE3]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your output should look similar to the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出应类似于以下内容：
- en: '![Figure 2.30 – Python CLI version](img/B19923_02_30.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.30 – Python CLI 版本](img/B19923_02_30.jpg)'
- en: Figure 2.30 – Python CLI version
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30 – Python CLI 版本
- en: 'You can also check the Python version from within the Python code by running
    the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过运行以下命令在 Python 代码中检查 Python 版本：
- en: '[PRE4]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will print an output similar to the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出类似于以下内容：
- en: '![Figure 2.31 – Python version](img/B19923_02_31.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.31 – Python 版本](img/B19923_02_31.jpg)'
- en: Figure 2.31 – Python version
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31 – Python 版本
- en: Once Python has been installed, the virtual environment needs to be created.
    So, let’s create one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python 安装完成后，需要创建虚拟环境。因此，让我们创建一个。
- en: Creating a virtual environment
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: 'It’s recommended that you create a Python virtual environment to ensure a seamless
    developer experience when working with Snowpark; it isolates the Snowpark API
    and allows you to manage all dependencies that are required for development. To
    create a virtual environment using Anaconda, run the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您创建一个 Python 虚拟环境，以确保在处理 Snowpark 时拥有无缝的开发者体验；它隔离了 Snowpark API，并允许您管理所有开发所需的依赖项。要使用
    Anaconda 创建虚拟环境，请运行以下命令：
- en: '[PRE5]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command creates a new Python virtual environment named `def_gui_3.8_env`
    with Python 3.8 and installs the necessary packages, such as `numpy` and `pandas`,
    from Anaconda’s Snowflake channel.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了一个名为 `def_gui_3.8_env` 的新 Python 虚拟环境，并使用 Python 3.8 安装了必要的包，例如 `numpy`
    和 `pandas`，来自 Anaconda 的 Snowflake 通道。
- en: Installing the Snowpark Python package
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Snowpark Python 包
- en: 'Before installing the package, let''s activate our Python virtual environment
    using the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装包之前，让我们使用以下命令激活我们的 Python 虚拟环境：
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Snowpark package can be installed from Anaconda’s Snowflake channel using
    the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令从 Anaconda 的 Snowflake 通道安装 Snowpark 包：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, let’s install some additional packages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们安装一些额外的包。
- en: Installing additional Python packages
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装额外的 Python 包
- en: 'To install additional packages that are necessary for development, such as
    `pandas` and `numpy`, you can use the same Anaconda Snowflake channel:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装开发所需的额外包，例如 `pandas` 和 `numpy`，您可以使用相同的 Anaconda Snowflake 通道：
- en: '[PRE8]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The virtual environment is now ready for development and is connected to your
    favorite IDE, Jupyter Notebook, or VS Code development. Similarly, we can install
    an IPython notebook.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境现在已准备好用于开发，并连接到您喜欢的 IDE、Jupyter Notebook 或 VS Code 开发环境。同样，我们也可以安装 IPython
    Notebook。
- en: Configuring Jupyter Notebook
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Jupyter Notebook
- en: 'Jupyter Notebook is one of the most popular IDEs for developers. In this section,
    we will cover how to configure the Jupyter IDE for Snowpark since the examples
    in this book use Jupyter. Jupyter Notebook needs to be installed in your local
    environment. The Jupyter environment comes installed alongside Anaconda. So, let’s
    open Jupyter Notebook:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Notebook 是开发者中最受欢迎的 IDE 之一。在本节中，我们将介绍如何配置 Jupyter IDE 以支持 Snowpark，因为本书的示例使用
    Jupyter。Jupyter Notebook 需要安装在本地的环境中。Jupyter 环境与 Anaconda 一起安装。因此，让我们打开 Jupyter
    Notebook：
- en: 'The **def_gui_3.8_env** virtual environment must be activated for development
    if it is not activated in the previous section. To activate the virtual environment,
    run the following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在上一节中没有激活，则必须激活 **def_gui_3.8_env** 虚拟环境以进行开发。要激活虚拟环境，请运行以下命令：
- en: '[PRE9]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Launch Jupyter Notebook by running the following command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令启动 Jupyter Notebook：
- en: '[PRE10]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On the Jupyter Notebook web page, click the **New** button in the top-right
    corner. From the drop-down menu, select **Python 3** under the **Notebooks** section.
    This will open a new notebook with an empty cell that’s ready for code execution.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Jupyter Notebook 网页上，点击右上角的 **New** 按钮。从下拉菜单中，在 **Notebooks** 部分下选择 **Python
    3**。这将打开一个新的笔记本，其中包含一个空单元格，准备好执行代码。
- en: Important note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This book will utilize Jupyter Notebook for all the examples.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用 Jupyter Notebook 来展示所有示例。
- en: Importing Snowpark modules
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入 Snowpark 模块
- en: 'The Python classes for the Snowpark API are part of the `snowflake.snowpark`
    module. You can import particular classes from the module by specifying their
    names. For example, to import the `average` function, you can use the following
    code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark API 的 Python 类是 `snowflake.snowpark` 模块的一部分。您可以通过指定它们的名称从模块中导入特定的类。例如，要导入
    `average` 函数，您可以使用以下代码：
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that the development environment has been set up, let’s learn how to operate
    with Snowpark.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开发环境已经设置好了，让我们学习如何使用 Snowpark 进行操作。
- en: Operating with Snowpark
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Snowpark 操作
- en: 'Snowpark for Python consists of client APIs, UDFs, and stored procedures that
    execute directly on the Python engine. The following screenshot shows the various
    Snowpark objects that you can choose from:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark for Python 由直接在 Python 引擎上执行的客户端 API、UDF 和存储过程组成。以下截图显示了您可以选择的各种 Snowpark
    对象：
- en: '![Figure 2.32 – Snowpark Python objects](img/B19923_02_32.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.32 – Snowpark Python 对象](img/B19923_02_32.jpg)'
- en: Figure 2.32 – Snowpark Python objects
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32 – Snowpark Python 对象
- en: 'Snowpark uses DataFrame objects to query and process data. The guiding principle
    in operating with Snowpark is to keep the data in Snowflake and process it right
    within Snowflake using the various Snowflake objects. The following figure shows
    Snowpark’s architecture:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark 使用 DataFrame 对象来查询和处理数据。使用 Snowpark 操作的指导原则是将数据保持在 Snowflake 中，并使用各种
    Snowflake 对象在 Snowflake 内部进行处理。以下图显示了 Snowpark 的架构：
- en: '![Figure 2.33 – Snowpark Python architecture](img/B19923_02_33.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.33 – Snowpark Python 架构](img/B19923_02_33.jpg)'
- en: Figure 2.33 – Snowpark Python architecture
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.33 – Snowpark Python 架构
- en: In the next section, we will cover the Python Engine.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍 Python 引擎。
- en: The Python Engine
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 引擎
- en: The Python Engine is an Anaconda-powered secure sandboxed Python environment
    that’s executed on top of Snowflake’s virtual warehouse and hosted on Snowflake’s
    compute infrastructure. This lets you process data using Python without the need
    to extract the data outside the environment. The Python Engine consists of the
    UDF engine and the stored procedure engine. The UDF engine is a restricted engine
    that cannot read or write data outside of Snowflake, whereas the stored procedure
    engine is more permissive and consists of a session object for interacting with
    the Snowflake database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python 引擎是一个由 Anaconda 驱动的安全沙盒 Python 环境，它在 Snowflake 的虚拟仓库上执行，并托管在 Snowflake
    的计算基础设施上。这允许您使用 Python 处理数据，而无需将数据从环境中提取出来。Python 引擎由 UDF 引擎和存储过程引擎组成。UDF 引擎是一个受限的引擎，不能在
    Snowflake 外部读取或写入数据，而存储过程引擎则更为宽容，并包含一个用于与 Snowflake 数据库交互的会话对象。
- en: Client APIs
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端 API
- en: The client API is the `snowflake-snowpark-python` library and it can be installed
    in any Python environment. It provides a session and the DataFrame APIs as methods
    to support queries being pushed down in Snowflake’s Python Engine. The client
    APIs consist of notable objects, including sessions, DataFrames, and more. Let’s
    look at these in detail.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端API是`snowflake-snowpark-python`库，它可以在任何Python环境中安装。它提供会话和DataFrame API作为方法来支持在Snowflake的Python引擎中下推查询。客户端API包括会话、DataFrame等显著对象。让我们详细看看这些。
- en: Working with sessions
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与会话一起工作
- en: 'The Snowpark session is part of the Snowpark API and connects to Snowflake
    to interact with it and perform operations using Snowpark objects. The `Session`
    function in Snowpark API is responsible for operating with the session. To import
    the `Session` function for Snowpark, run the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark会话是Snowpark API的一部分，连接到Snowflake以与之交互并使用Snowpark对象执行操作。Snowpark API中的`Session`函数负责会话操作。要导入Snowpark的`Session`函数，请运行以下命令：
- en: '[PRE12]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Snowpark session consists of a Python dictionary containing the parameter
    values that are required to establish a connection to Snowflake:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark会话包含一个Python字典，其中包含建立Snowflake连接所需的参数值：
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The connection consists of the following mandatory parameters:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 连接包含以下必填参数：
- en: '**Account**: The Snowflake account identifier is **<orgname>-<account_name>**.
    There is no need to specify the **snowflakecomputing.com** suffix.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**账户**: Snowflake账户标识符为**<orgname>-<account_name>**。无需指定**snowflakecomputing.com**后缀。'
- en: '**User**: The username of the Snowflake user.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**: Snowflake用户的用户名。'
- en: '**Password**: The password to authenticate to Snowflake.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**: 用于验证Snowflake的密码。'
- en: 'The following are the optional parameters that can be passed to the connection:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以传递给连接的可选参数：
- en: '**role**: The role to be used in the Snowpark session. If left blank, the user’s
    default role will be used.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**: 在Snowpark会话中使用的角色。如果留空，将使用用户的默认角色。'
- en: '**warehouse**: The warehouse that’s used to execute the process. If left blank,
    the user’s default warehouse will be used.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**: 用于执行进程的仓库。如果留空，将使用用户的默认仓库。'
- en: '**database**: The database for the context of execution. If left blank, the
    user’s default database will be used.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**: 执行上下文中的数据库。如果留空，将使用用户的默认数据库。'
- en: '**schema**: The schema for the context of execution. If left blank, the user’s
    default schema will be used.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式**: 执行上下文中的模式。如果留空，将使用用户的默认模式。'
- en: 'You can create the `session` object by passing this dictionary to the session
    builder, which is then used to establish the session:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将此字典传递给会话构建器来创建`session`对象，然后使用它来建立会话：
- en: '[PRE14]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the session has been created, the `session` object acts as a handle to
    interact with Snowflake through various methods to perform operations such as
    reading and manipulating data. Some of the session methods that can be used are
    shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 会话创建后，`session`对象充当与Snowflake交互的句柄，通过各种方法执行读取和操作数据等操作。以下是一些可用的会话方法：
- en: '[PRE15]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, you can close the session by using the `close()` method. This terminates
    the session and the ongoing queries associated with it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`close()`方法关闭会话。这将终止会话及其关联的持续查询：
- en: '[PRE16]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Snowflake recommends that you close the session after the process has been completed.
    The `Session` method can be used to establish a session and interact with the
    `Session` objects.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake建议在进程完成后关闭会话。可以使用`Session`方法来建立会话并与`Session`对象交互。
- en: Advanced authentication
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高级认证
- en: 'Snowpark sessions also support advanced authentication, such as key pair authentication,
    if it’s been configured for the user connecting to Snowflake. The private key
    must be serialized and then passed to the connection object of the session builder.
    We will be using the hazmat crypto package to serialize the private key. This
    private key is provided as a variable:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark会话也支持高级认证，如密钥对认证，如果已为连接到Snowflake的用户配置，则可以使用。私钥必须序列化然后传递给会话构建器的连接对象。我们将使用hazmat加密包来序列化私钥。此私钥作为变量提供：
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We encode the private key using the passphrase and then serialize it to assign
    it to a variable that’s passed into the Snowflake connection object:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用口令对私钥进行编码，然后将其序列化以分配给传递给Snowflake连接对象的变量：
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The connection parameters will have the private key passed in serialized form,
    and the session can be established using the session builder:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 连接参数将以序列化的形式传递私钥，并且可以使用会话构建器建立会话：
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, let’s discuss Snowpark DataFrames.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论Snowpark DataFrames。
- en: Snowpark DataFrames
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Snowpark DataFrames
- en: 'Snowpark for Python consists of a client API that provides a DataFrame-based
    approach that queries and processes data with a DataFrame object. The following
    diagram explains the code blocks that are utilized:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark for Python由一个客户端API组成，它提供了一个基于DataFrame的方法，使用DataFrame对象查询和处理数据。以下图表解释了所使用的代码块：
- en: '![Figure 2.34 – Snowpark DataFrame API](img/B19923_02_34.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图2.34 – Snowpark DataFrame API](img/B19923_02_34.jpg)'
- en: Figure 2.34 – Snowpark DataFrame API
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.34 – Snowpark DataFrame API
- en: 'The Snowpark DataFrame API yields more efficiency with less effort required
    by the developer as it has a concise syntax that is easy to understand and debug.
    The following figure compares a DataFrame and a SQL query:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark DataFrame API提供了更高的效率，开发者所需的努力更少，因为它具有简洁且易于理解和调试的语法。以下图表比较了DataFrame和SQL查询：
- en: '![Figure 2.35 – Snowpark DataFrame versus a query](img/B19923_02_35.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图2.35 – Snowpark DataFrame与查询](img/B19923_02_35.jpg)'
- en: Figure 2.35 – Snowpark DataFrame versus a query
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.35 – Snowpark DataFrame与查询
- en: In addition, Snowpark DataFrames can directly read data from tables, views,
    and `SELECT` statements that support pushdown so that they can be executed in
    Snowflake. The Snowpark client APIs also support converting pandas DataFrames
    into Snowflake DataFrames so that data can be written back into Snowflake. Finally,
    Snowpark DataFrames support lazy evaluation as data computation is performed once
    an action is invoked.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Snowpark DataFrames可以直接从表、视图和`SELECT`语句中读取数据，这些语句支持下推，以便它们可以在Snowflake中执行。Snowpark客户端API还支持将pandas
    DataFrame转换为Snowflake DataFrame，以便数据可以写回Snowflake。最后，Snowpark DataFrames支持懒加载，因为数据计算是在动作调用时执行的。
- en: Note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Lazy evaluation in Snowpark means that data processing operations are not executed
    immediately when they are defined. Instead, Snowpark builds a sequence of transformations
    without executing them until you explicitly request the result. This approach
    optimizes performance and resource usage, allowing you to construct complex data
    workflows efficiently and interactively. Lazy evaluation is a key feature for
    handling large datasets and optimizing data processing tasks in Snowpark.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark中的懒加载意味着数据操作不会在定义时立即执行。相反，Snowpark会构建一系列转换，直到你明确请求结果时才执行。这种方法优化了性能和资源使用，允许你高效且交互式地构建复杂的数据工作流。懒加载是处理大型数据集和优化Snowpark中的数据处理任务的关键特性。
- en: Working with DataFrames
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用DataFrames
- en: DataFrames are the dataset objects in Snowpark in which data is queried and
    processed. They represent relational datasets that provide lazy evaluation. The
    DataFrame executes SQL in a push-down manner and can perform operations such as
    creating objects and reading, writing, and working with data from the Python code.
    Various methods in the `Session` object are used to work with DataFrames.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrames是Snowpark中的数据集对象，用于查询和处理数据。它们代表提供懒加载的关系数据集。DataFrame以下推方式执行SQL，并可以执行创建对象、从Python代码中读取、写入和操作数据等操作。`Session`对象中的各种方法用于处理DataFrames。
- en: 'Let’s create an employee data table called `SAMPLE_EMPLOYEE_DATA`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`SAMPLE_EMPLOYEE_DATA`的员工数据表：
- en: '[PRE20]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code will create a table with the required fields for employee
    data. Let’s insert some data into the table for operational purposes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将创建一个包含员工数据所需字段的表格。为了操作目的，让我们向表格中插入一些数据：
- en: '[PRE21]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code will populate the table with the data that we can query.
    To query the data, we can directly pass the SQL statement:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将填充表格，我们可以查询这些数据。要查询数据，我们可以直接传递SQL语句：
- en: '[PRE22]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code will return the results after it’s been executed in Snowflake.
    We can also store these results in a DataFrame so that we can operate on it in
    Python:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码在Snowflake中执行后会返回结果。我们还可以将这些结果存储在DataFrame中，以便在Python中操作：
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following code will save the results in a `df_subset_row` DataFrame that
    can be displayed using `show()`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将结果保存到`df_subset_row` DataFrame中，可以使用`show()`显示：
- en: '[PRE24]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![Figure 2.36 – DataFrame data](img/B19923_02_36.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图2.36 – DataFrame数据](img/B19923_02_36.jpg)'
- en: Figure 2.36 – DataFrame data
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.36 – DataFrame数据
- en: In the next section, we will look at Snowpark UDFs and stored procedures.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Snowpark UDFs和存储过程。
- en: A note on code snippets
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码片段的说明
- en: The examples presented in the following section have been simplified intentionally.
    Our main objective is to grasp and distinguish the concepts, rather than delving
    into complex scenarios. However, we’ll delve into more sophisticated examples
    in the upcoming chapters.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分中提供的示例已经有意简化。我们的主要目标是掌握和区分概念，而不是深入研究复杂场景。然而，在接下来的章节中，我们将深入研究更复杂的示例。
- en: UDFs
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDFs
- en: Snowpark for Python supports UDFs that allow developers to write reusable custom
    lambdas and functions to process the data through DataFrames. Like built-in functions,
    UDFs can be called from SQL, which enhances SQL with functionality that it doesn’t
    have or doesn’t do well. UDFs also provide a way to encapsulate functionality
    so that you can call it repeatedly from multiple places in your code. For example,
    you can write a UDF that returns a single value called a *scalar* function, also
    known as a UDF, or a group of values called a *tabular* function, also known as
    a **user data table function** (**UDTF**). These UDFs can be developed from within
    Python worksheets or by using Snowpark from your local development environment.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark for Python 支持UDF，允许开发者编写可重用的自定义lambda和函数，通过DataFrames处理数据。像内置函数一样，UDF可以从SQL中调用，这增强了SQL的功能，使其能够执行它原本不具备或执行不佳的操作。UDF还提供了一种封装功能的方法，以便您可以从代码的多个地方重复调用它。例如，您可以编写一个返回单个值（称为标量函数）的UDF，也称为UDF，或者返回一组值（称为表函数）的UDF，也称为**用户自定义表函数**（**UDTF**）。这些UDF可以从Python工作表内部开发，或者通过在本地开发环境中使用Snowpark来开发。
- en: Scalar UDFs
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标量UDF
- en: Scalar UDFs are invoked once per row and return one output row for each input
    row. These UDFs are called just like a standard SQL function, with columns or
    expressions as arguments. It produces a row consisting of a single column/value
    as output. The data gets processed in parallel across each node within a multi-node
    virtual warehouse.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 标量UDF对每一行调用一次，并为每个输入行返回一个输出行。这些UDF的调用方式与标准SQL函数相同，以列或表达式作为参数。它产生一个由单个列/值组成的行作为输出。数据在多节点虚拟仓库的每个节点内并行处理。
- en: Working with UDFs
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 UDF
- en: 'Once a Snowpark session has been created, the UDF can be turned into a standard
    function that can be registered in Snowflake:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个 Snowpark 会话，UDF 可以被转换成一个标准函数，该函数可以在 Snowflake 中注册：
- en: '[PRE25]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding template delineates the steps in creating a UDF in Snowflake using
    Python. It involves defining the primary Python function that will be used by
    the UDF and registering it in Snowflake. Next, the function and UDF names are
    specified, along with the Snowflake stage, where the UDF files will be uploaded.
    Finally, the required Snowpark `DataType` object for the UDF’s return value is
    imported, and its specific object is determined. This is not the only template
    we can follow – we can also leverage decorators to perform this. But for beginners,
    this can be very helpful to templatize and organize UDFS, UDTFs, and stored procedures.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模板定义了在 Snowflake 中使用 Python 创建 UDF 的步骤。它涉及定义UDF将使用的首选Python函数，并在 Snowflake
    中注册它。接下来，指定函数和UDF的名称，以及UDF文件将上传的 Snowflake 阶段。最后，导入UDF返回值的所需 Snowpark `DataType`
    对象，并确定其特定对象。这不是我们唯一可以遵循的模板——我们还可以利用装饰器来完成这项工作。但对于初学者来说，这可以非常有帮助，以便模板化和组织 UDFS、UDTFs
    和存储过程。
- en: 'Additionally, any necessary Snowpark `DataType` objects for the UDF’s input
    arguments are imported and determined. The template also allows you to include
    extra packages and imports in the UDF. We can also specify whether the UDF should
    be temporary and whether an existing UDF with the same name should be overwritten:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要导入和确定UDF输入参数所需的任何必要的 Snowpark `DataType` 对象。模板还允许您在UDF中包含额外的包和导入。我们还可以指定UDF是否应该是临时的，以及是否应该覆盖具有相同名称的现有UDF：
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This simple function gets the input name and splits it so that it returns the
    last name. The UDF is registered to the internal `My_Stage` stage and is deployed
    into Snowflake. The UDF can be invoked directly in SQL as a function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数获取输入名称并将其分割，以便返回最后一个名称。UDF 被注册到内部的 `My_Stage` 阶段，并部署到 Snowflake。UDF 可以直接在
    SQL 中作为函数调用：
- en: '[PRE27]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.37 – UDF Snowpark execution](img/B19923_02_37.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.37 – UDF Snowpark 执行](img/B19923_02_37.jpg)'
- en: Figure 2.37 – UDF Snowpark execution
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.37 – UDF Snowpark 执行
- en: 'In this example, we invoked the `LAST_NAME_FINDER` function with the `Name`
    column, which returned the last name by splitting it. The function can also be
    called within the `DataFrame` function, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用`Name`列调用了`LAST_NAME_FINDER`函数，该函数通过分割返回了姓氏。该函数也可以在`DataFrame`函数内部调用，如下所示：
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code generates the following output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下输出：
- en: '![Figure 2.38 – UDF DataFrame execution](img/B19923_02_38.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图2.38 – UDF DataFrame执行](img/B19923_02_38.jpg)'
- en: Figure 2.38 – UDF DataFrame execution
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.38 – UDF DataFrame执行
- en: Next, let’s look into UDTFs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看UDTF。
- en: UDTF
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UDTF
- en: Tabular UDFs, also known as UDTFs, require stateful operations to be performed
    on data batches and are invoked once per row, just like scalar UDFs, but they
    can return multiple rows as output for each input row. The UDTF handler method
    consists of an additional optional parameter that helps initialize the handler
    once for each partition and finalize processing for each section. A UDTF is a
    type of UDF that executes similarly to a UDF but with tabular output. Therefore,
    they can be developed in Python worksheets and Snowpark development environments.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 表格UDF，也称为UDTF，需要在数据批次上执行有状态的操作，并且对每行数据调用一次，就像标量UDF一样，但它们可以为每个输入行返回多行输出。UDTF处理方法包含一个额外的可选参数，该参数有助于为每个分区初始化处理程序并最终处理每个部分。UDTF是一种类似于UDF但具有表格输出的UDF。因此，它们可以在Python工作表和Snowpark开发环境中开发。
- en: Working with UDTFs
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用UDTF
- en: Creating a UDTF in Snowpark is similar to creating a UDF in that after a Snowpark
    session is created, the UDTF can be made directly in a standard command that can
    be registered in Snowflake.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Snowpark中创建UDTF与创建UDF类似，即在创建Snowpark会话之后，可以直接在标准命令中创建UDTF，该命令可以在Snowflake中注册。
- en: 'The following Snowpark UDTF template provides a basic outline for creating
    a UDTF in Snowpark using Python. The following code shows the key elements in
    this template:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Snowpark UDTF模板提供了使用Python在Snowpark中创建UDTF的基本轮廓。以下代码显示了此模板中的关键元素：
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This template creates a UDTF in Snowflake. First, a main Python handler class
    is defined for the UDTF, which can utilize other functions from the script or
    be imported from external sources. It is important to note that only one main
    Python handler class can be assigned to the UDTF.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板在Snowflake中创建UDTF。首先，为UDTF定义一个主要的Python处理程序类，该类可以利用脚本中的其他函数或从外部源导入。需要注意的是，只能将一个主要的Python处理程序类分配给UDTF。
- en: In this template, you are expected to replace `<name of main Python class>`
    with a meaningful name for your UDTF class. This is the main class where you will
    define the logic for processing data within your UDTF.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，您需要将`<主Python类名>`替换为对您的UDTF类有意义的名称。这是您将定义处理UDTF内部数据逻辑的主要类。
- en: The `__init__` method is marked as optional, meaning you may or may not include
    it in your UDTF implementation. If you choose to include it, this method will
    execute once per partition before breaking out into individual rows.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法被标记为可选，这意味着您可以选择是否将其包含在您的UDTF实现中。如果您选择包含它，此方法将在每个分区之前执行一次，然后才会进入单个行。'
- en: 'You can use the `__init__` method to perform any partition-level setup or initialization
    specific to your UDTF. For example, you might use it to initialize variables and
    open connections or set up data structures that will be used throughout the UDTF’s
    execution:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`__init__`方法执行任何针对您的UDTF的分区级设置或初始化。例如，您可能用它来初始化变量、打开连接或设置在整个UDTF执行过程中将使用的数据结构：
- en: '[PRE30]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method is responsible for processing each input row within a partition
    and generating tabular data as tuples. Inside the `process` method, you can write
    custom Python code that executes for every input row in the partition. The key
    part of this method is the usage of `yield` statements or a `return` statement
    to produce tuples as output.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法负责处理分区内的每个输入行并生成作为元组的表格数据。在`process`方法内部，您可以编写为分区中的每个输入行执行的定制Python代码。此方法的关键部分是使用`yield`语句或`return`语句生成元组作为输出。
- en: 'In terms of `yield` statements, you can output one or more tuples for each
    input row, allowing for flexibility in generating tabular results. Alternatively,
    you can use a `return` statement with a list of tuples to achieve the same result.
    In essence, the `process` method serves as the core logic for your UDTF, where
    you manipulate and transform data from each input row into tabular format, making
    it suitable for further processing or analysis:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `yield` 语句方面，您可以针对每个输入行输出一个或多个元组，从而在生成表格结果方面提供灵活性。或者，您可以使用带有元组列表的 `return`
    语句来实现相同的结果。本质上，`process` 方法是您 UDTF 的核心逻辑，其中您将每个输入行中的数据操作和转换成表格格式，使其适合进一步处理或分析：
- en: '[PRE31]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method is used to execute logic that’s specific to a partition after processing
    all the input rows in that partition. Inside the `end_partition` method, you can
    write custom Python code that performs calculations or generates results based
    on the data that’s processed within that partition. This method can also be used
    to yield or return tabular data as tuples, similar to the `process` method, but
    this data typically represents aggregated or summarized information for the entire
    partition.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于在处理完该分区的所有输入行后执行特定于分区的逻辑。在 `end_partition` 方法内部，您可以编写自定义的 Python 代码，根据在该分区中处理的数据执行计算或生成结果。此方法还可以用于像
    `process` 方法一样产生或返回作为元组的表格数据，但此数据通常代表整个分区的聚合或汇总信息。
- en: You have the option to use `yield` statements to output one or more tuples,
    or you can use a `return` statement with a list of tuples to provide the partition-level
    result. This allows you to perform partition-specific operations and return the
    results in a structured format.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择使用 `yield` 语句输出一个或多个元组，或者可以使用带有元组列表的 `return` 语句来提供分区级别的结果。这允许您执行特定于分区的操作并以结构化格式返回结果。
- en: The `end_partition` method in a Snowpark UDTF template is used for executing
    partition-level logic and returning tabular data or results specific to that partition
    after processing all input rows within it. It’s especially useful for tasks such
    as aggregations or calculations, which require data from the entire partition.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark UDTF 模板中的 `end_partition` 方法用于执行分区级别的逻辑，并在处理完该分区内的所有输入行后返回表格数据或特定于该分区的结果。这对于需要整个分区数据的聚合或计算等任务特别有用。
- en: 'The following code template provides details on how to register a UDTF in Snowflake
    and the corresponding options to define the UDTF:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码模板提供了如何在 Snowflake 中注册 UDTF 以及定义 UDTF 的相应选项的详细信息：
- en: '[PRE32]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `udtf()` method of the Snowflake Snowpark `Session` object is used to create
    the UDTF in Snowflake. The process involves several steps: determining the Python
    class that the UDTF will use, specifying the name of the UDTF within Snowflake
    (it can be a fully qualified name or created in the same namespace as the Snowpark
    `Session` object), and providing the name of the Snowflake stage where the UDTF
    files will be uploaded.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Snowflake Snowpark `Session` 对象的 `udtf()` 方法用于在 Snowflake 中创建 UDTF。这个过程涉及几个步骤：确定
    UDTF 将使用的 Python 类，指定 Snowflake 中 UDTF 的名称（可以是完全限定名称或与 Snowpark `Session` 对象在同一命名空间中创建），以及提供将上传
    UDTF 文件的 Snowflake 阶段名称。
- en: Specific Snowpark `DataType` objects are imported to define the structure of
    the UDTF. This includes importing objects for defining tabular structures, such
    as table schemas (using `StructType`) and fields within a table (using `StructField`).
    Furthermore, a specific Snowpark `DataType` object is imported for the values
    that are passed into and returned by the UDTF. The output schema of the UDTF is
    defined using the imported Snowpark `DataType` objects, embedding them into `StructField`
    and `StructType` objects. Additionally, a list of specific Snowpark `DataType`
    objects is defined for the input arguments of the UDTF. It is crucial to include
    all these `DataType` objects in the import and ensure they match the expected
    arguments that are passed to the `process` method within the `handler` class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的 Snowpark `DataType` 对象被导入以定义 UDTF 的结构。这包括导入用于定义表格结构的对象，如表模式（使用 `StructType`）和表内的字段（使用
    `StructField`）。此外，还导入了一个特定的 Snowpark `DataType` 对象，用于传递给 UDTF 并由 UDTF 返回的值。UDTF
    的输出模式使用导入的 Snowpark `DataType` 对象定义，将它们嵌入到 `StructField` 和 `StructType` 对象中。此外，还定义了一个特定
    Snowpark `DataType` 对象的列表，用于 UDTF 的输入参数。在导入时包括所有这些 `DataType` 对象并确保它们与在 `handler`
    类中传递给 `process` 方法的预期参数相匹配至关重要。
- en: The template allows a temporary UDTF to be created that only exists within the
    specific Snowflake Snowpark `Session` object. Additionally, an option exists to
    overwrite an existing UDTF with the same name; an error will be returned if it’s
    set to `False` and a UDTF already exists. Lastly, the template briefly mentions
    adding additional packages and imports to the UDTF, which is optional and can
    be done using the provided rows.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许创建一个临时的 UDTF，它仅在特定的 Snowflake Snowpark `Session` 对象中存在。此外，还有一个选项可以覆盖具有相同名称的现有
    UDTF；如果设置为 `False` 且已存在 UDTF，则将返回错误。最后，模板简要提到了向 UDTF 添加额外的包和导入，这是可选的，可以使用提供的行来完成。
- en: 'The following example illustrates how to use a Snowpark UDTF to calculate the
    averages of numeric data within Snowflake tables. This showcases the practical
    application of UDTFs in Snowpark for custom data processing tasks:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使用 Snowpark UDTF 来计算 Snowflake 表中数值数据的平均值。这展示了 UDTF 在 Snowpark 中用于自定义数据处理任务的实用应用：
- en: '[PRE33]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `CalculateAverage` Snowpark UDTF is designed to compute the average of a
    numeric column within a Snowflake table. It does this by accumulating the input
    values for each partition of the data and then calculating the average when the
    partition ends.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalculateAverage` Snowpark UDTF 的设计是为了计算 Snowflake 表中数值列的平均值。它是通过累积每个数据分区的输入值，然后在分区结束时计算平均值来实现的。'
- en: 'The `process` method collects input values one by one and stores them in a
    list. When the partition ends (in the `end_partition` method), it calculates the
    average by summing up all the collected values and dividing by the count of values.
    Finally, it yields the calculated average as the UDTF’s output. This UDTF simplifies
    the process of computing averages in Snowflake SQL queries, especially when dealing
    with large datasets:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`process` 方法逐个收集输入值并将它们存储在列表中。当分区结束时（在 `end_partition` 方法中），它通过将所有收集到的值相加并除以值的数量来计算平均值。最后，它将计算出的平均值作为
    UDTF 的输出产生。这个 UDTF 简化了在 Snowflake SQL 查询中计算平均值的流程，尤其是在处理大型数据集时：'
- en: '[PRE34]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we’re creating a UDTF function called `Average_Age` that calculates
    the average age by getting the age as input. The function is uploaded into `MY_STAGE`
    and registered in Snowflake.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `Average_Age` 的 UDTF 函数，该函数通过获取年龄作为输入来计算平均年龄。该函数被上传到 `MY_STAGE`
    并在 Snowflake 中注册。
- en: 'The function can be executed to get the average age per country from the sample
    employee data:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可以执行以从样本员工数据中获取每个国家的平均年龄：
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will display the following output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![Figure 2.39 – UDTF Snowpark execution](img/B19923_02_39.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.39 – UDTF Snowpark 执行](img/B19923_02_39.jpg)'
- en: Figure 2.39 – UDTF Snowpark execution
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.39 – UDTF Snowpark 执行
- en: The output shows the execution output of the UDTF. In the next section, we will
    cover vectorized UDFs.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了 UDTF 的执行输出。在下一节中，我们将介绍矢量化 UDF。
- en: Vectorized UDFs
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矢量化 UDF
- en: Vectorized UDFs operate similarly to scalar UDFs in that they let you define
    Python functions that receive batches of input rows as pandas DataFrames and return
    collections of results as pandas arrays or series.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量化 UDF 与标量 UDF 类似，允许您定义接收输入行批次的 Python 函数作为 pandas DataFrame，并返回结果集合作为 pandas
    数组或序列。
- en: Vectorized UDFs parallelize the operation on batches of data and provide significant
    performance advantages on sets of rows compared to serial row processing. In addition,
    they reduce the complexity of using libraries that operate on pandas DataFrames
    and arrays.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量化 UDF 将数据批次的操作并行化，并在与逐行序列处理相比的行集上提供显著的性能优势。此外，它们减少了使用在 pandas DataFrame 和数组上操作的库的复杂性。
- en: Working with vectorized UDFs
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与矢量化 UDF 一起工作
- en: 'The same example we looked at previously can be executed in the Snowpark environment
    after establishing the session by passing a vectorized DataFrame as the input
    to the standard UDF:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过将矢量化 DataFrame 作为输入传递给标准 UDF 建立会话后，之前查看的相同示例可以在 Snowpark 环境中执行：
- en: '[PRE36]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The example UDF returns the city and country in the `CITY_COUNTRY` column for
    each row in the `Sample` `Employee` table:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 UDF 返回 `Sample` `Employee` 表中每行的 `CITY_COUNTRY` 列中的城市和国家：
- en: '![Figure 2.40 – Vectorized UDF in Snowpark](img/B19923_02_40.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.40 – Snowpark 中的矢量化 UDF](img/B19923_02_40.jpg)'
- en: Figure 2.40 – Vectorized UDF in Snowpark
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.40 – Snowpark 中的矢量化 UDF
- en: The output shows the execution output of the vectorized UDF. In the next section,
    we will cover stored procedures.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了矢量化 UDF 的执行输出。在下一节中，我们将介绍存储过程。
- en: Stored procedures
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储过程
- en: A Python stored procedure is a series of code statements you can parameterize
    and execute on demand. They run in a less restricted environment than UDFs and
    support interacting with Snowflake objects, as well as performing DDL and DML
    operations on tables.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Python存储过程是一系列可以参数化和按需执行的代码语句。它们在比UDF更不受限制的环境中运行，支持与Snowflake对象交互，以及在对表执行DDL和DML操作。
- en: Stored procedures in Snowpark are utilized for executing tasks and streams within
    Snowflake’s data processing framework. These stored procedures encapsulate specific
    logic or functionality, allowing users to perform various operations on data seamlessly.
    Tasks, which are often associated with batch processing, involve executing predefined
    actions or workflows on datasets at scheduled intervals. Stored procedures enable
    users to automate these tasks, ensuring consistent and efficient data processing.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark中的存储过程用于在Snowflake数据处理框架中执行任务和流。这些存储过程封装了特定的逻辑或功能，使用户能够无缝地对数据进行各种操作。任务通常与批量处理相关联，涉及在预定时间间隔内对数据集执行预定义的操作或工作流。存储过程使用户能够自动化这些任务，确保数据处理的持续性和效率。
- en: On the other hand, streams are continuous data pipelines that capture changes
    in real-time from a data source. Stored procedures play a vital role in managing
    and processing streams by defining how incoming data should be processed and integrated
    into the target destination. With Snowpark, users can create stored procedures
    to handle these streaming data scenarios, including data transformation, filtering,
    and loading data into Snowflake tables.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，流是持续的数据管道，实时捕获数据源的变化。存储过程通过定义如何处理和集成到目标目的地来在管理和处理流中发挥关键作用。使用Snowpark，用户可以创建存储过程来处理这些流数据场景，包括数据转换、过滤以及将数据加载到Snowflake表中。
- en: Working with stored procedures
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用存储过程
- en: 'A stored procedure can be created in Snowpark with the following template:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下模板在Snowpark中创建存储过程：
- en: '[PRE37]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we define the main Python function that will be used in the stored procedure
    and an additional argument called `snowpark_session`, which allows us to interact
    with Snowflake objects. Next, we use the `sproc.register()` method to create the
    stored procedure, specifying the Python function, stored procedure’s name, and
    Snowflake stage for file uploads. Finally, we import specific Snowpark `DataType`
    objects for the stored procedure’s return value and input arguments.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了将在存储过程中使用的Python主函数以及一个名为`snowpark_session`的附加参数，它允许我们与Snowflake对象交互。接下来，我们使用`sproc.register()`方法创建存储过程，指定Python函数、存储过程名称和文件上传的Snowflake阶段。最后，我们导入存储过程的返回值和输入参数的特定Snowpark
    `DataType`对象。
- en: 'The `snowflake_session` argument is implicitly understood and not included
    in the input arguments. Optional rows allow for additional packages and imports.
    Here, we can determine whether the stored procedure will be temporary. We can
    also decide whether to overwrite an existing one with the same name and specify
    whether it will execute as the caller or the owner:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`snowflake_session`参数是隐含理解的，不包括在输入参数中。可选行允许额外的包和导入。在这里，我们可以确定存储过程是否为临时。我们还可以决定是否覆盖同名现有存储过程，并指定它将以调用者或所有者的身份执行：'
- en: '[PRE38]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The stored procedure returns the column name and the age from the `Employee
    Data` table. It’s registered as `SPROC_SUBSET_TABLE` and uploaded through `My_Stage`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 该存储过程从`Employee Data`表中返回列名和年龄。它注册为`SPROC_SUBSET_TABLE`并通过`My_Stage`上传：
- en: '[PRE39]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here’s the output:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '![Figure 2.41 – Stored procedure execution](img/B19923_02_41.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图2.41 – 存储过程执行](img/B19923_02_41.jpg)'
- en: Figure 2.41 – Stored procedure execution
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.41 – 存储过程执行
- en: The stored procedure can be executed by running the `CALL` command.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行`CALL`命令来执行存储过程。
- en: The difference between UDFs and stored procedures
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UDF与存储过程之间的区别
- en: 'UDFs and stored procedures have significant differences in terms of functionality
    and usage. The following figure shows the basic differences between UDFs and stored
    procedures and what they’re used for:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: UDF和存储过程在功能和用途方面有显著差异。以下图显示了UDF和存储过程的基本区别以及它们的使用目的：
- en: '![Figure 2.42 – UDFs versus stored procedures](img/B19923_02_42.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图2.42 – UDF与存储过程对比](img/B19923_02_42.jpg)'
- en: Figure 2.42 – UDFs versus stored procedures
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.42 – UDF与存储过程对比
- en: 'The following table shows the differences and similarities between UDFs and
    stored procedures based on their properties:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了UDF和存储过程基于其属性之间的差异和相似性：
- en: '|  | **UDF****s** | **Stored Procedure****s** |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|  | **UDF** | **存储过程** |'
- en: '| Purpose | Perform calculations and return the results. UDFs require a value
    to be returned. | Perform complex operations by executing SQL statements. They
    do not require an explicit value to be returned. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 执行计算并返回结果。UDF需要返回一个值。 | 通过执行SQL语句执行复杂操作。它们不需要显式返回一个值。 |'
- en: '| Usage | UDFs can be used when logic needs to be called as part of SQL statements
    that return a value. | When database operations or administrative tasks need to
    be performed. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 使用 | 当需要将逻辑作为返回值的SQL语句的一部分调用时，可以使用UDF。 | 当需要执行数据库操作或管理任务时。 |'
- en: '| Output | UDFs always need to return a result. | Stored procedures don’t need
    to return a result. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 输出 | UDF总是需要返回一个结果。 | 存储过程不需要返回结果。 |'
- en: '| Context | UDF return values are directly accessible in the SQL context. |
    Stored procedure return values are not accessible in the SQL context. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 上下文 | UDF的返回值可以直接在SQL上下文中访问。 | 存储过程的返回值在SQL上下文中不可访问。 |'
- en: '| Execution | UDFs can be called in the context of another SQL statement. In
    addition, multiple UDFs can be invoked in a single SQL statement. | Stored procedures
    are called independently. Therefore, only a single stored procedure is invoked
    in a SQL statement. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 执行 | UDF可以在另一个SQL语句的上下文中调用。此外，可以在单个SQL语句中调用多个UDF。 | 存储过程是独立调用的。因此，SQL语句中只调用一个存储过程。
    |'
- en: '| Security | UDFs cannot access the database or perform operations directly
    on it. | Stored procedures can access the database and perform data operations
    on it. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | UDF不能直接访问数据库或在其上执行操作。 | 存储过程可以访问数据库并在其上执行数据操作。 |'
- en: Table 2.1 – Comparison of UDFs and stored procedures
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – UDF和存储过程的比较
- en: Both stored procedures and UDFs can be used together to expand the capabilities
    of Python execution in Snowflake.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程和UDF都可以一起使用，以扩展Python在Snowflake中的执行功能。
- en: Establishing a project structure for Snowpark
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Snowpark建立项目结构
- en: To assist with the development of Snowpark in Python and to make it easy to
    create a Snowpark project, Snowflake has released Snowpark project templates for
    Python. These contain everything you’ll need for developing, testing, and deploying
    with Snowpark – they provide all the boilerplate required to develop UDFs and
    stored procedures, along with unit tests and even GitHub Actions workflow files
    for CI/CD.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助在Python中开发Snowpark并使其易于创建Snowpark项目，Snowflake已发布了Python Snowpark项目模板。这些模板包含您开发、测试和部署Snowpark所需的一切——它们提供了开发UDF和存储过程所需的所有样板代码，以及单元测试，甚至还有用于CI/CD的GitHub
    Actions工作流程文件。
- en: 'The project template has been released as open source on GitHub, making it
    easy for developers to clone and use the project. To clone the project, follow
    these steps:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目模板已作为开源发布在GitHub上，这使得开发者可以轻松克隆和使用项目。要克隆项目，请按照以下步骤操作：
- en: 'Download the files or clone the repository from [https://github.com/Snowflake-Labs/snowpark-python-template](https://github.com/Snowflake-Labs/snowpark-python-template).
    A new GitHub repository can be created from the template by using the GitHub CLI,
    like so:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/Snowflake-Labs/snowpark-python-template](https://github.com/Snowflake-Labs/snowpark-python-template)下载文件或克隆仓库。可以使用GitHub
    CLI从模板创建一个新的GitHub仓库，如下所示：
- en: '[PRE40]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The new repository’s name needs to be specified. The repository will be similar
    to the Snowpark project template.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要指定新仓库的名称。该仓库将与Snowpark项目模板类似。
- en: 'Set up the following environment variables so that you can configure the necessary
    Snowflake details:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置以下环境变量，以便您可以配置必要的Snowflake详细信息：
- en: '[PRE41]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These environment variables are required to connect to the Snowflake environment
    and for Snowpark to establish a session.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些环境变量是连接到Snowflake环境以及Snowpark建立会话所必需的。
- en: 'Create an Anaconda virtual environment and install the dependencies from the
    **environment.yml** file:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Anaconda虚拟环境，并从**environment.yml**文件安装依赖项：
- en: '[PRE42]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can test the connection and check if the environment has been set up by
    executing the **app.py** stored procedure. Navigate to the project folder and
    run the following command:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过执行**app.py**存储过程来测试连接并检查环境是否已设置。导航到项目文件夹并运行以下命令：
- en: '[PRE43]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This produces an output called **Hello World** that establishes a connection
    to Snowflake.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成一个名为**Hello World**的输出，用于建立与Snowflake的连接。
- en: The Snowpark project supports functions and stored procedures. The project structure
    consists of the `procs` directory for stored procedures, the `udf` directory for
    UDFs, and the `util` directory for the utilities methods and classes that are
    shared between UDFs and stored procedures.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark项目支持函数和存储过程。项目结构包括用于存储过程的`procs`目录，用于用户定义函数（UDFs）的`udf`目录，以及用于UDFs和存储过程之间共享的实用方法和类的`util`目录。
- en: The `test` folder consists of the test cases that can be tested via `pytest`.
    There’s also a GitHub workflow that can be deployed via GitHub Actions. We will
    cover this in detail in the following chapters.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`目录包含可以通过`pytest`测试的测试用例。还有一个可以通过GitHub Actions部署的GitHub工作流程。我们将在接下来的章节中详细介绍这一点。'
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Snowpark is very versatile and supports complex development patterns. In this
    chapter, we learned how to configure the Snowpark development environment and
    different Snowpark objects, such as sessions, UDFs, and stored procedures, and
    how to use them. We also learned how to set up a Snowpark development project
    locally and inside a Python worksheet before looking at some sample code that
    we could use to start developing.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Snowpark非常灵活，支持复杂的发展模式。在本章中，我们学习了如何配置Snowpark开发环境以及不同的Snowpark对象，例如会话、UDFs和存储过程，以及如何使用它们。我们还学习了在查看一些我们可以用来开始开发的示例代码之前，如何在本地和Python工作表中设置Snowpark开发项目。
- en: In the next chapter, we will cover how to perform data processing with Snowpark,
    as well as how to ingest, prepare, and analyze data.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何使用Snowpark进行数据处理，以及如何摄取、准备和分析数据。
