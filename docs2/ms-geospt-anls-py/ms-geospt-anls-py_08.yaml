- en: Automating QGIS Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化QGIS分析
- en: This book has introduced you to using Python from the command line, in a Jupyter
    Notebook, and in an IDE to perform geospatial tasks. While these three tools will
    allow you to accomplish your tasks, there are many times when work needs to be
    done using desktop GIS software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书已向你介绍了如何从命令行、Jupyter笔记本和IDE中使用Python执行地理空间任务。虽然这三个工具将允许你完成任务，但很多时候需要使用桌面GIS软件来完成工作。
- en: QGIS, a popular open source GIS application, provides desktop GIS functionality
    with the ability to work in a Python console and the ability to write toolboxes
    and plugins using Python. In this chapter, you will learn how to manipulate desktop
    GIS data using Python and how to automate these tasks using toolboxes and plugins.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS，一个流行的开源GIS应用，提供了桌面GIS功能，具有在Python控制台工作的能力，以及使用Python编写工具箱和插件的能力。在本章中，你将学习如何使用Python操作桌面GIS数据，以及如何使用工具箱和插件自动化这些任务。
- en: 'In this chapter, you will learn how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Load and save layers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和保存图层
- en: Create layers from API data sources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API数据源创建图层
- en: Add, edit, and delete features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加、编辑和删除要素
- en: Select specific features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择特定要素
- en: Call geoprocessing functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用地理处理函数
- en: Write geoprocessing toolboxes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写地理处理工具箱
- en: Write plugins
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写插件
- en: Working in the Python console
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python控制台工作
- en: The QGIS Python console is a Python console. You can perform all of your normal
    Python tasks with the added benefit of having the QGIS libraries added. From the
    console, you can manipulate GIS data and display it on the screen, or not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS Python控制台是一个Python控制台。你可以执行所有正常的Python任务，并且有QGIS库的附加优势。从控制台，你可以操作GIS数据并在屏幕上显示，或者不显示。
- en: 'The Python console is located under the Plugins menu on the QGIS toolbar. You
    can also access it by pressing *Ctrl *+ *Alt *+ *P* on the keyboard. The console
    will usually open in the bottom of the main window. You can undock it by clicking
    on the title bar (where it says Python Console), holding down the mouse button,
    and dragging the window to another location on the screen or by clicking the window
    button at the top-right of the console:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python控制台位于QGIS工具栏的“插件”菜单下。你也可以通过按*Ctrl*+*Alt*+*P*键在键盘上访问它。控制台通常会打开在主窗口的底部。你可以通过点击标题栏（显示为Python
    Console），按住鼠标按钮，并将窗口拖到屏幕上的另一个位置或点击控制台右上角的窗口按钮来取消停靠：
- en: '![](img/bfc549d0-4917-48e3-86e9-9186a7ddc648.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfc549d0-4917-48e3-86e9-9186a7ddc648.png)'
- en: A screenshot of the Python console
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python控制台的截图
- en: The console has buttons for clearing the window, importing GIS and QGIS specific
    libraries, running the current command (you can press *Enter* instead of clicking
    this button), showing the editor, modifying options, and viewing the Help files.
    The editor launches a simplified text editor you can use for writing your Python
    code. It has a few benefits over the command line. You can use the editor to open
    existing Python files and run or edit them. When you write code in the console,
    you can save it to a file. In the console, you would need to select all, then
    copy and paste it into another file, removing all of the output. The editor also
    allows you to search for text, cut text, add or remove comments, and inspect objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台有清除窗口、导入GIS和QGIS特定库、运行当前命令（你可以按*Enter*键而不是点击此按钮）、显示编辑器、修改选项和查看帮助文件按钮。编辑器启动一个简化的文本编辑器，你可以用它来编写Python代码。它有一些比命令行更多的优点。你可以使用编辑器打开现有的Python文件并运行或编辑它们。当你控制台编写代码时，你可以将其保存到文件。在控制台，你需要选择全部内容，然后复制并粘贴到另一个文件中，移除所有输出。编辑器还允许你搜索文本、剪切文本、添加或删除注释，以及检查对象。
- en: Now that you understand the basics of the console and the editor, we can start
    writing some Python code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了控制台和编辑器的基础知识，我们可以开始编写一些Python代码。
- en: Loading layers
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载图层
- en: 'One of the first things you will probably need to do is load some existing
    GIS data. You can open several different file formats. The method for doing this
    is the same. It is done by creating a `QgsVectorLayer` and passing a parameter
    for the data source, the layer name to be shown in the layers panel widget, and
    the provider name as shown in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要做的第一件事之一是加载一些现有的GIS数据。你可以打开几种不同的文件格式。完成此操作的方法是相同的。它是通过创建一个`QgsVectorLayer`并传递数据源参数、要在图层面板小部件中显示的图层名称以及提供者名称来完成的，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For most vector layers, you will use `"ogr"` as the provider. You can then
    add the layer to the map using the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数矢量图层，你将使用`"ogr"`作为提供者。然后你可以使用以下代码将图层添加到地图中：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous code adds the layer to the map registry. Alternatively, you can
    do the previously mentioned code in a single line of code using `iface` as shown
    in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将图层添加到地图注册表中。或者，您可以使用`iface`在单行代码中执行之前提到的代码，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The previous code loads a vector layer and adds it to the registry in a single
    step. The following screenshot shows the layers added in QGIS and the names added
    to the layers panel:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在单步中加载矢量图层并将其添加到注册表中。以下截图显示了在QGIS中添加的图层和添加到图层面板的名称：
- en: '![](img/252cacbf-972f-405f-8b3d-7ebda34ceed3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/252cacbf-972f-405f-8b3d-7ebda34ceed3.png)'
- en: A screenshot of the layers loaded in QGIS
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS中加载的图层截图
- en: 'The registry holds a list of all of the layers in the map document. You can
    get a list of loaded layers by using the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表包含地图文档中所有图层的列表。您可以使用以下代码获取加载的图层列表：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous code should show that two layers, `SeeClickFix` and `Streets`,
    are loaded:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码应显示加载了两个图层，`SeeClickFix`和`Streets`：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can remove a layer from the map by using `removeMapLayer()` and passing
    the `id` of the layer to remove. The `id` is the string from the result of calling
    `mapLayers()`. In this case, the `id` of the loaded layer is `''Steets20171129092415901''`.
    The following code will remove the layer:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`removeMapLayer()`并传递要移除的图层的`id`来从地图中移除图层。`id`是从调用`mapLayers()`的结果中得到的字符串。在这种情况下，加载的图层的`id`是`'Steets20171129092415901'`。以下代码将移除图层：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous code passes the layer `id` to `removeMapLayer()`. Since the data
    was loaded in the `streets` variable, you can also pass `streets.id()` instead
    of typing the layer `id`, as shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将图层`id`传递给`removeMapLayer()`。由于数据是在`streets`变量中加载的，因此您也可以传递`streets.id()`而不是键入图层`id`，如下所示：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both methods will result in the layer being removed from the map.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都会导致图层从地图中移除。
- en: Processing a layer
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图层
- en: Once the layer is loaded, you will want to examine the layer and the features
    in the layer. For the layer, you will probably want to know the projection, the
    coordinate reference system, and how many features it has.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图层加载，您将想要检查图层及其中的要素。对于图层，您可能想知道投影、坐标参考系统以及它有多少个要素。
- en: Layer properties
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图层属性
- en: 'To find the coordinate reference system, you can use `crs()` on the layer as
    shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到坐标参考系统，您可以在图层上使用`crs()`，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous code assigns the coordinate reference system to the variable `crs`.
    From here, you can inspect it by getting the descriptions shown in the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将坐标参考系统分配给变量`crs`。从这里，您可以通过获取以下代码中显示的描述来检查它：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The previous code will return the output as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将返回以下输出：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For a **well-known text** (**WKT**) representation of the coordinate reference
    system, you can use the `toWkt()` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于坐标参考系统的**已知文本**（**WKT**）表示，您可以使用`toWkt()`方法：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will return the results as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can get the bounding box of the layer by using the `extent()` method shown
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`extent()`方法获取图层的边界框，如下所示：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can then get a string of the extent using `toString()`, get the WKT using
    `asWktPolygon()`, or you can get each coordinate individually using `xMinimum()`,
    `xMaximum()`, `yMinimum()`, and `yMaximum()`. The methods and their output are
    shown as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`toString()`获取范围字符串，使用`asWktPolygon()`获取WKT，或者使用`xMinimum()`、`xMaximum()`、`yMinimum()`和`yMaximum()`分别获取每个坐标。方法和它们的输出如下所示：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To see the available methods on an object, use `dir(object)`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看对象上的可用方法，请使用`dir(object)`。
- en: To see the methods for the extent object, use `dir(extent)`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看范围对象的方 法，请使用`dir(extent)`。
- en: 'You can get the number of features in the layer by using `pendingFeatureCount()`.
    The following code returns the feature count for the `SeeClickFix` layer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`pendingFeatureCount()`获取图层中的要素数量。以下代码返回`SeeClickFix`图层的要素计数：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result is a long datatype and in this case, equals 126.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是长数据类型，在这种情况下等于126。
- en: Feature properties
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要素属性
- en: 'You can get the first feature using the code as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码获取第一个特征：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous code uses `getFeatures().next()` to get the first feature and assigns
    it to the `item` variable. If you remove the `.next()`, you get a `QgsFeatureIterator`,
    which allows you to iterate through all of the features. For the following examples
    we will use a single feature.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `getFeatures().next()` 来获取第一个特征并将其分配给 `item` 变量。如果你移除 `.next()`，你会得到一个
    `QgsFeatureIterator`，这允许你遍历所有特征。在接下来的示例中，我们将使用单个特征。
- en: 'To get the `geometry`, assign it to a variable as shown:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `geometry`，将其分配给一个变量，如下所示：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To get the `type`, you can use the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `type`，可以使用以下代码：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous code returns `0` for points. Knowing that the features are points,
    we can see the coordinates using `asPoint()` as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码对于点返回 `0`。知道特征是点后，我们可以使用 `asPoint()` 来查看坐标，如下所示：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we try the same code on the `streets` layer, we will get a type of `1` and
    the coordinates of the `Polyline` as shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `streets` 图层上尝试相同的代码，我们会得到类型 `1` 和 `Polyline` 的坐标，如下所示：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To get information about the fields in the features, use `fields()` as shown
    in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取特征字段的信息，请使用 `fields()` 如以下代码所示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can get a field name and type by using `.name()` and `.typeName()` for
    each of the four fields. Using field `2`, the following code will show you how to
    get the name and type:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `.name()` 和 `.typeName()` 为四个字段中的每一个来获取字段名和类型。使用字段 `2`，以下代码将向你展示如何获取名称和类型：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Knowing the name of the field, you can get the value of the field for the first
    record. Or, you could always use the numerical index as shown in the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 知道字段名后，你可以获取第一条记录的字段值。或者，你始终可以使用以下代码中的数值索引：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that you know how to access the geometry and attributes of a feature, you
    can iterate through the features using `getFeatures()`. The following code will
    iterate through the features and `print` the `ID` of all of the records with a
    `Status` of `''Closed''`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何访问特征的几何和属性，你可以使用 `getFeatures()` 遍历特征。以下代码将遍历特征并 `print` 所有具有 `'Closed'`
    状态的记录的 `ID`：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previous code uses the `getFeatures()` to return an iterator. It then checks
    if the `Status` attribute is equal to `''Closed''` and then prints the attribute
    `ID` if it is. The output is shown as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `getFeatures()` 返回一个迭代器。然后它检查 `Status` 属性是否等于 `'Closed'`，如果是，则打印属性 `ID`。输出如下所示：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Drawing a layer from PostGIS
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 PostGIS 绘制图层
- en: QGIS will allow you to load a PostgreSQL layer using the `QgsDataSourceURI`
    class and `QgsVectorLayer` (URI, name, provider (Postgres)). For this to work,
    QGIS needs to be compiled with Postgres support. In this section, you will use
    `psycopg2` as you learned in [Chapter 3](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml),
    *Introduction to Geospatial Databases*, and [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml),
    *Geoprocessing with Geodatabases*. The method of adding features to a layer and
    a layer to the map in this section will be used later in this chapter when you
    learn how to write toolboxes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 允许你使用 `QgsDataSourceURI` 类和 `QgsVectorLayer`（URI，名称，提供者（Postgres））来加载 PostgreSQL
    图层。为了使其工作，QGIS 需要编译带有 Postgres 支持的版本。在本节中，你将使用 `psycopg2`，正如你在第 3 章 [42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml]
    “地理空间数据库简介”和第 7 章 [4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml] “地理数据库处理”中学到的。本节中添加特征到图层以及图层到地图的方法将在本章后面学习如何编写工具箱时使用。
- en: Drawing points
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制点
- en: Before you learn how to load the data from PostGIS, we will first cover how
    to draw multiple points, convert them to a feature, add them to a layer, then
    load the layer to the map. The following code will walk you through the process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学习如何从 PostGIS 加载数据之前，我们首先介绍如何绘制多个点，将它们转换为特征，将它们添加到图层中，然后将图层加载到地图上。以下代码将引导你完成这个过程。
- en: 'Start by creating a `memory` layer as shown in the code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个 `memory` 图层，如下所示：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The previous code creates a vector layer and assigns it to the variable `theLayer`.
    The parameters are the type and coordinate reference system of the layer, the
    name for the layer panel, and we specified that it is a `memory` layer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个矢量图层并将其分配给变量 `theLayer`。参数是图层的类型和坐标参考系统，图层面板的名称，我们指定它是一个 `memory`
    图层。
- en: 'Next, you need to create the features:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建特征：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The previous code imports `qgis.PyQtCore`. You need the library for the `QVariant`.
    First, you call the data provider for the layer and pass it to the features. Next,
    you add the attributes and their types to the features. In the following code,
    you create a `point` and add it to the features:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码导入了 `qgis.PyQtCore`。您需要这个库来使用 `QVariant`。首先，您调用图层的数据提供者并将其传递给要素。接下来，您将属性及其类型添加到要素中。在以下代码中，您创建了一个
    `point` 并将其添加到要素中：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The previous code creates a `p` variable and makes it a `QgsFeature`. It then
    creates a point `p` and passes longitude and latitude coordinates. The feature
    is assigned geometry from the `point`. Next, you assign the attributes to the
    feature. Now you have a feature with geometry and attributes. In the next line,
    you pass the feature to the features array using `addFeature()`. Lastly, you update
    the layer extents and fields.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个 `p` 变量并将其设置为 `QgsFeature`。然后创建一个点 `p` 并传递经纬度坐标。要素从 `point` 被分配了几何形状。接下来，您将属性分配给要素。现在您有一个具有几何形状和属性的要素。在下一条语句中，您使用
    `addFeature()` 将要素传递到要素数组。最后，您更新图层范围和字段。
- en: 'Repeat the block of code a second time and assign the `point` different coordinates, `(-106.4540,34.9553)`,
    and then add the layer to the map as in the earlier section of this chapter, shown
    in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码块重复第二次，并将 `point` 的坐标设置为不同的值，`(-106.4540,34.9553)`，然后按照本章前面的部分，在以下代码中将图层添加到地图上：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will now have a map with two points as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将有一个包含两个点的地图，如下面的屏幕截图所示：
- en: '![](img/04cf83ce-3b71-47da-ac91-c0e61a26f86b.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04cf83ce-3b71-47da-ac91-c0e61a26f86b.png)'
- en: Two points with attributes loaded in QGIS from the Python console
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 控制台加载到 QGIS 中的具有属性的两个点
- en: You can see in the Layers Panel that the layer is named SomePoints. In the attribute
    table, you can see two fields, ID and Name for two features. Now that you know
    how to create features from geometry, add attributes, add the features to a layer,
    and display the layer on the map, we will add PostGIS to the mix and loop through
    the process mentioned earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图层面板中看到图层被命名为 SomePoints。在属性表中，您可以看到两个字段，ID 和 Name，对应两个要素。现在您知道了如何从几何形状创建要素，添加属性，将要素添加到图层，并在地图上显示图层，我们将添加
    PostGIS 并循环执行前面提到的过程。
- en: Drawing polygons from PostGIS
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 PostGIS 绘制多边形
- en: In this example, you will draw the Albuquerque Police Department Area Commands
    polygons from a PostGIS database. You will use the following code with an added
    PostGIS query, a loop to add all of the features, and a WKT function to draw the
    geometry instead of hard-coding the coordinates.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，您将从 PostGIS 数据库中绘制阿尔伯克基警察局区域命令的多边形。您将使用以下代码，并添加一个 PostGIS 查询，一个循环来添加所有要素，以及一个
    WKT 函数来绘制几何形状而不是硬编码坐标：
- en: 'The first step is to connect to the PostGIS database. The following code is
    the same as you used in [Chapter 3](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml), *Introduction
    to Geospatial Databases*, and [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml), *Geoprocessing
    With Geodatabases*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是连接到 PostGIS 数据库。以下代码与您在 [第 3 章](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml)，*地理空间数据库简介*
    和 [第 7 章](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml)，*使用地理数据库进行地理处理* 中使用的代码相同：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The previous code connects to PostGIS, grabs all of the Area Commands with
    their name and geometry, and assigns them to the `c` variable. Next, you will
    create the layer as in the earlier example. You will create a counter `x` and
    make it the `ID` field of the features:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码连接到 PostGIS，获取所有带有名称和几何形状的面积命令，并将它们分配给 `c` 变量。接下来，您将创建与早期示例中相同的图层。您将创建一个计数器
    `x` 并将其设置为要素的 `ID` 字段：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous code creates a polygon `memory` layer, creates the features, and
    adds attributes. Next, you will look through the `cursor`, creating geometry for
    each Area Command and adding attributes, then you update the layer''s extents
    and fields:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个 `polygon` 内存图层，创建了要素并添加了属性。接下来，您将遍历 `cursor`，为每个区域命令创建几何形状并添加属性，然后更新图层的范围和字段：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous code is the same as in the points example in the previous section.
    The one major difference is that you are creating the polygon using `QgsGeometry.fromWkt(wkt)`.
    The `acmd[1]` variable is the WKT `MultiPolygon` string from PostGIS.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与上一节中点示例中的代码相同。主要区别在于您正在使用 `QgsGeometry.fromWkt(wkt)` 创建多边形。`acmd[1]` 变量是从
    PostGIS 获取的 WKT `MultiPolygon` 字符串。
- en: 'Lastly, add the layer to the map as in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下代码将图层添加到地图上：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code will render the screenshot as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将渲染如下截图：
- en: '![](img/19a7113e-b217-41b2-b14b-055d6f0e7683.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19a7113e-b217-41b2-b14b-055d6f0e7683.png)'
- en: And there you have it, the Area Command polygons for the Albuquerque Police
    Department as a layer in QGIS. Next, you will learn how to add, edit, and delete
    features from a layer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你有了阿尔伯克基警察局的区域命令多边形，作为一个层在QGIS中。接下来，你将学习如何向层中添加、编辑和删除特征。
- en: Adding, editing, and deleting features
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加、编辑和删除特征
- en: In the previous examples, you created an empty layer and added fields, then
    added data and displayed it. There will be times when you will need to do that,
    more often than not, you will already have a layer and you will need to add data,
    edit data, or delete data from it. In this section, you will learn how to perform
    those tasks on existing data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，你创建了一个空层并添加了字段，然后添加了数据并显示了它。你将需要这样做的时候，大多数情况下，你已经有了一个层，你需要向其中添加数据、编辑数据或从其中删除数据。在本节中，你将学习如何对现有数据执行这些任务。
- en: Adding features to an existing layer
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向现有层添加特征
- en: 'To add data to a layer, you first need to load the layer. Start by loading
    a subset of some `SeeClickFix` data for Albuquerque as shown in the following
    code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要向层添加数据，你首先需要加载层。首先，加载一些`SeeClickFix`数据的一个子集，如以下代码所示：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The previous code loads and displays the layer on the map. It is the same code
    from the first section of this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码加载并在地图上显示层。这是本章第一节的相同代码。
- en: You do not need to display the layer on the map to work with it. You can load
    the layer using `scf = QgsVectorLayer("C:\Users\Paul\Desktop\PythonBook\CHP8\SCF.shp",
    "SeeClickFix","ogr")`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要在地图上显示层来与之工作。你可以使用`scf = QgsVectorLayer("C:\Users\Paul\Desktop\PythonBook\CHP8\SCF.shp",
    "SeeClickFix","ogr")`来加载层。
- en: 'Now that you have the layer loaded you can use `capabilitiesString()` to see
    what operations the provider allows on the data. The following code shows the
    results on the loaded layer:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经加载了层，你可以使用`capabilitiesString()`来查看提供者允许对数据执行哪些操作。以下代码显示了加载层的结果：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since `Add Features` is a capability, you can add a new feature as shown in
    the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`添加特征`是一个功能，你可以像以下代码所示添加一个新特征：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The previous code creates a feature and gets the fields from the loaded layer.
    It then sets each of the attributes. Next, it sets the geometry from a point.
    Lastly, the feature is added to the layer. When you call `addFeatures()` there
    are two return values you can assign to variables—the result and the feature.
    The result of `addFeature()` will be either true or false. The returned feature
    is a list of features. It may be convenient to hold the feature if you need to
    perform more operations with it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个特征并从加载的层中获取字段。然后它设置了每个属性。接下来，它从点设置几何形状。最后，特征被添加到层中。当你调用`addFeatures()`时，有两个返回值可以分配给变量——结果和特征。`addFeature()`的结果将是true或false。返回的特征是特征列表。如果你需要对该特征执行更多操作，保留特征可能很方便。
- en: When automating the process, you can perform a capabilities check before trying
    to edit the layer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化过程时，你可以在尝试编辑层之前执行功能检查。
- en: 'The results are a new point and record in the attributes table as shown in
    the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新的点和属性表中的记录，如以下截图所示：
- en: '![](img/5887ecb1-1029-4075-9d3a-4eeba4a17eec.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5887ecb1-1029-4075-9d3a-4eeba4a17eec.png)'
- en: A feature added to the layer
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到层的特征
- en: 'You can simplify the previous code by passing all the attributes in a single
    line using a list. The following code shows you how:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用列表在单行中传递所有属性来简化之前的代码。以下代码显示了如何做到这一点：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The previous code writes the attributes using a list and `setAttributes()` instead
    of the singular `setAttribute()`. If you want to remember the field names when
    reading your code later, the more verbose version is clearer. But if the efficiency
    of the code is your goal, the latter version is more appropriate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用列表和`setAttributes()`而不是单个`setAttribute()`来写入属性。如果你想记住在以后阅读代码时字段名称，更冗长的版本更清晰。但如果代码的效率是你的目标，后者版本更合适。
- en: What if we made a mistake, or have records we do not need? The next section
    will show you how to delete a feature.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们犯了错误，或者有我们不需要的记录怎么办？下一节将向你展示如何删除一个特征。
- en: Deleting features from an existing layer
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有层中删除特征
- en: 'Deleting features can be done in a single line of code following the format
    as shown:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 删除特征可以通过单行代码完成，格式如下所示：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the previous code, you use `deleteFeatures()` and the `id` of the layer.
    The `id` is the `feature.id()`. It is a number held internally and not in a user
    assigned attribute. To get the `id` of a specific feature you can iterate through
    them as you learned earlier in this chapter. The following code shows you how
    to delete the feature we created in the previous section:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，你使用`deleteFeatures()`函数和层的`id`。`id`是`feature.id()`，它是一个内部持有的数字，而不是用户分配的属性。要获取特定特征的`id`，你可以像在本章前面学到的那样遍历它们。以下代码显示了如何删除上一节中创建的特征：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The previous code iterates through the features in the layer looking for the
    one with the `ID` of `311`. When it finds it, it uses `deleteFeatures()` and passes
    the `id` using `x.id()`. In this case the `id` was `216`. If you know the `id`
    of the feature, you can delete it without the loop.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码遍历了层中的特征，寻找具有`ID`为`311`的那个。当找到它时，它使用`deleteFeatures()`函数并通过`x.id()`传递`id`。在这种情况下，`id`是`216`。如果你知道特征的`id`，你可以不通过循环就删除它。
- en: 'You can also pass a list of IDs as shown in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传递一个ID列表，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The previous code iterates through the features in the layer looking for all
    of the `'Closed'` cases. When it finds one, it puts the `id` in the list `key`.
    Lastly, it calls `deleteFeatures()` and passes the list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码遍历了层中的特征，寻找所有`'Closed'`情况。当找到其中一个时，它将`id`放入列表`key`中。最后，它调用`deleteFeatures()`函数并传递列表。
- en: Editing features from an existing layer
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有层编辑特征
- en: You can now add and delete features, but sometimes you only need to change an
    attribute value. For example, an open case status to a closed case status. In
    this section, you will learn how to modify attributes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以添加和删除特征，但有时你可能只需要更改属性值。例如，将开放案件状态更改为关闭案件状态。在本节中，你将学习如何修改属性。
- en: 'Attributes are modified by calling `changeAttributeValues()`. The following
    code changes a single feature:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`changeAttributeValues()`函数来修改属性。以下代码修改了一个单个特征：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The previous code calls `changeAttributeValues()` and passes a dictionary with
    the key being the feature `id` and the value being a dictionary of attributes—`{id:{0:value,
    1:value, n:value}}`. The keys for the attributes dictionary are the field indexes.
    There are four fields in the features so the dictionary of attributes will have
    keys `0` through `3`. The following screenshot shows the change in the attribute
    table:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码调用了`changeAttributeValues()`函数，并传递了一个字典，其中键是特征`id`，值是一个包含属性的字典—`{id:{0:value,
    1:value, n:value}}`。属性字典的键是字段索引。在特征中有四个字段，因此属性字典将有键`0`到`3`。以下截图显示了属性表的变化：
- en: '![](img/67704e0a-c110-4d57-b0e8-3ce4f7fdb4af.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67704e0a-c110-4d57-b0e8-3ce4f7fdb4af.png)'
- en: A single feature edited
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单个特征编辑
- en: 'The previous example assumes you already know the `id` of the feature you want
    to modify. It also assumes you want to modify all of the attribute values. The
    following code will modify several features but only a single attribute value
    in each—Status:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例假设你已经知道要修改的特征的`id`。它还假设你想要修改所有属性值。以下代码将修改多个特征，但每个特征只修改一个属性值—状态：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the previous code, a dictionary is declared with a key of `3` (the `''Status''`
    field) and a value of `"Closed"`. The code then iterates through the features
    in the layer looking for a match. When it finds a match, it changes the attribute
    value, but this time only the value of the Status field. The results are reflected
    in the attributes table shown in the screenshot as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，声明了一个字典，键为`3`（`'Status'`字段），值为`"Closed"`。然后代码遍历层中的特征以寻找匹配项。当找到匹配项时，它更改属性值，但这次只更改状态字段的值。结果反映在截图所示的属性表中如下：
- en: '![](img/2da7e828-dc2c-4132-baa8-23a3602ded04.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2da7e828-dc2c-4132-baa8-23a3602ded04.png)'
- en: All features of the Other type now have a status of Open
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他类型的特征现在状态为打开
- en: In the previous examples, you have been iterating through features and selecting
    them based on a condition. In the next section, you will learn how to highlight
    the selected features and how to use expressions to select instead of a condition.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，你已经遍历了特征并根据条件选择它们。在下一节中，你将学习如何突出显示选定的特征以及如何使用表达式而不是条件来选择。
- en: Selecting features using expressions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表达式选择特征
- en: 'Using expressions, you can iterate through features and evaluate the expression
    returning true(1) or false(0). Before we get into expressions, let''s select and
    highlight a feature. Selecting a feature is accomplished by calling `setSelectedFeatures()`
    and passing a list of IDs. The following code will select a single feature:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式，你可以遍历特征并评估返回真（1）或假（0）的表达式。在我们深入探讨表达式之前，让我们选择并突出显示一个特征。选择特征是通过调用`setSelectedFeatures()`并传递一个ID列表来完成的。以下代码将选择一个单一的特征：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The previous code, imports `QtGUI`, and `Qt.Widgets`. These are needed to set
    the color using `QColor`. The next line gets the map canvas and sets the section
    color to `red`. Lastly, the code selects the feature with an `id` of `100`. It
    will now display `red` on the map.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码导入了`QtGUI`和`Qt.Widgets`。这些是使用`QColor`设置颜色所需的。下一行获取地图画布并设置部分颜色为`红色`。最后，代码选择了一个`id`为`100`的特征。现在地图上会显示为`红色`。
- en: 'The previous example assumes you want to select a single feature and that you
    know the `id`. That is rarely the case. More often than not you will want to select
    by some condition—or using an expression. Using `QgsExpression()` you can pass
    an expression string and evaluate it against features. The following code shows
    you how:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子假设你想选择一个单一的特征，并且你知道其`id`。这种情况很少见。大多数情况下，你将想要根据某些条件或使用一个表达式来选择。使用`QgsExpression()`，你可以传递一个表达式字符串并对其特征进行评估。以下代码展示了如何操作：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, the previous code creates a list, `closed`, to store the IDs where the
    expression evaluates to true. Next the expression is declared. The expression
    checks for two conditions on the Type and Status. The expression is prepared and
    passed the fields in the layer. The next line iterates through the features. If
    the expression is true (`1`), the `id` is put in the list. Lastly, the selected
    features are set to the IDs in the closed list.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，之前的代码创建了一个列表，`closed`，用于存储表达式评估为真的ID。接下来声明了表达式。该表达式检查类型和状态上的两个条件。表达式被准备并传递了图层中的字段。下一行遍历特征。如果表达式为真（`1`），则`id`将被放入列表中。最后，选定的特征被设置为`closed`列表中的ID。
- en: 'The results of the previous code are shown in the screenshot as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的结果如下截图所示：
- en: '![](img/007b4975-1a00-4f08-8484-c9b29a913792.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/007b4975-1a00-4f08-8484-c9b29a913792.png)'
- en: Features selected based on an expression
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表达式选择的特征
- en: In the next section, you will learn how to use the toolboxes that come with
    QGIS to execute algorithms and perform geospatial tasks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何使用QGIS附带的工具箱来执行算法和执行地理空间任务。
- en: Using toolboxes in Python
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中使用工具箱
- en: 'QGIS has a processing library. If you go to the Processing menu in QGIS and
    select Toolbox, you will see a widget displayed with groups of toolboxes. The
    widget will look as shown:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS有一个处理库。如果你转到QGIS中的处理菜单并选择工具箱，你会看到一个显示工具箱分组的窗口小部件。窗口小部件看起来如下：
- en: '![](img/b2e75ae6-b8ea-4819-86b1-5a04a461f799.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2e75ae6-b8ea-4819-86b1-5a04a461f799.png)'
- en: The processing widget
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 处理窗口小部件
- en: 'You have access to the toolboxes in Python by importing `processing`. You can
    see the available algorithms by executing the code as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导入`processing`来访问Python中的工具箱。你可以通过以下方式执行代码来查看可用的算法：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The previous code imports `processing` and calls the `alglist()` method. The
    results are all of the available algorithms from the installed toolboxes. You
    should see something similar to the following output:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码导入了`processing`并调用了`alglist()`方法。结果是所有安装的工具箱中的可用算法。你应该看到以下类似的输出：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To search the algorithms by keyword, you can pass a string to `alglist()` as
    in the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过关键字搜索算法，你可以像以下代码那样将一个字符串传递给`alglist()`：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The previous code passes a string to narrow the results. The output will be
    several algorithms containing the word `buffer`. See the output as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码传递了一个字符串来缩小结果。输出将包含包含单词`buffer`的几个算法。如下所示：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this section, we will use the `Buffer vectors` algorithm. To see how the
    algorithm works, you can run the code as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`Buffer vectors`算法。要了解算法的工作原理，你可以运行以下代码：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The previous code calls `alghelp()` and passes the name of the algorithm found
    in the second column of the `alglist()`. The result will tell you the parameters
    and their type required for executing the algorithm. The output is shown as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码调用`alghelp()`并传递了在`alglist()`的第二列中找到的算法名称。结果将告诉你执行算法所需的参数及其类型。输出如下所示：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you run the algorithm from the GUI and then open `\.qgis2\processing\processing.log`,
    you will see the parameters used to execute the algorithm. Copy them and use them
    in your Python code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从GUI运行算法，然后打开`\.qgis2\processing\processing.log`，你将看到执行算法使用的参数。复制它们并在你的Python代码中使用。
- en: 'The previous output shows the parameters needed to run the algorithm. By using
    `runalg()` you can execute the algorithm. The buffer vector is executed in the
    code as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了运行算法所需的参数。通过使用`runalg()`，你可以执行算法。缓冲矢量在代码中的执行如下：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The previous code calls `runalg()` and passes the name of the algorithm we
    want to run, then the parameters required by the algorithm. In this case:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码调用`runalg()`并传递我们想要运行的算法的名称，然后是算法所需的参数。在这种情况下：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output layer is then added to the map. The result is shown in the following
    screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将输出层添加到地图上。结果如以下截图所示：
- en: '![](img/a63f65f2-9d2b-4b7f-b6eb-217bf808e480.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a63f65f2-9d2b-4b7f-b6eb-217bf808e480.png)'
- en: Results of the buffer algorithm
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区算法的结果
- en: Now that you know how to use the Python console and call an algorithm let's
    write our own algorithm. The next section will show you how to make a toolbox
    that you can call using `runalg()` or by using the GUI.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用Python控制台和调用算法，让我们编写我们自己的算法。下一节将向你展示如何创建一个可以使用`runalg()`或通过使用GUI调用的工具箱。
- en: Writing custom toolboxes
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义工具箱
- en: Writing toolboxes will allow you to automate several tasks and make that code
    available to users as a GUI, or to other developers as an algorithm that can be
    executed using processing. In this section, you will learn how to create a toolbox
    and call it from processing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 编写工具箱将允许你自动化几个任务，并将代码作为GUI提供给用户，或作为其他开发者可以执行的算法。在本节中，你将学习如何创建一个工具箱并从处理中调用它。
- en: In this chapter, you have learned how to load data from a file and from a PostGIS
    database. In this example, you will learn how to bring data in to QGIS from the
    `SeeClickFix`** Application Program Interface** (**API**).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了如何从文件和PostGIS数据库加载数据。在这个例子中，你将学习如何从`SeeClickFix`**应用程序程序接口**（**API**）将数据引入QGIS。
- en: '`SeeClickFix` is a 311 reporting system that is used by many cities in the
    United States. It contains geospatial data and has a very well documented, and
    user-friendly API.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeeClickFix`是一个311报告系统，被美国许多城市使用。它包含地理空间数据，并且有一个非常详细且用户友好的API。'
- en: To create a new script, open the processing toolbox in QGIS. This will open
    an editor window. You will write your code in this window and save it using the
    save icon. The file name will become a toolbox under Tools|User scripts|File name.
    Save the file and name it `SeeClickFix`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的脚本，请在QGIS中打开处理工具箱。这将打开一个编辑器窗口。你将在该窗口中编写你的代码，并使用保存图标保存它。文件名将成为工具箱，位于工具|用户脚本|文件名下。保存文件并命名为`SeeClickFix`。
- en: 'Now that you have an empty toolbox, we can start adding code. Before the code,
    you need to create the parameters you will want to pass to this algorithm. Each
    parameter will also become a GUI widget with the parameter name as the label.
    The `SeeClickFix` API allows you to specify a city or neighborhood and also filter
    strings. The following code will add these as parameters to our algorithm:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个空的工具箱，我们可以开始添加代码。在代码之前，你需要创建你想要传递给这个算法的参数。每个参数也将成为一个具有参数名称作为标签的GUI小部件。`SeeClickFix`
    API允许你指定一个城市或地区，并且还可以过滤字符串。以下代码将把这些作为参数添加到我们的算法中：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The previous code uses double comment symbols (`##`), then the parameter name
    followed by the parameter type and a default value. Default values are required
    for numbers and strings. The first parameter in the code is the city or neighborhood,
    it is a `string` and defaults to Albuquerque. Next, is the filter keyword, which
    is also a `string` and defaults to `Nothing`. Lastly, the code has an output,
    which is a type of `output vector`. The output will be what is added to the map
    or saved to disk.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用双注释符号（`##`），然后是参数名称，参数类型和一个默认值。对于数字和字符串，需要默认值。代码中的第一个参数是城市或地区，它是一个`string`，默认为阿尔伯克基。接下来是过滤关键字，它也是一个`string`，默认为`Nothing`。最后，代码有一个输出，它是一种`output
    vector`类型。输出将是要添加到地图上或保存到磁盘上的内容。
- en: 'At this point, you can run the toolbox in the GUI and you will see the window
    shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以在GUI中运行工具箱，你将看到以下截图所示的窗口：
- en: '![](img/d9185e7f-4e22-443e-99e8-369d9ec1a1fc.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d9185e7f-4e22-443e-99e8-369d9ec1a1fc.png)'
- en: The GUI for the toolbox. Notice each parameter is a label
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 工具箱的GUI。注意每个参数都是一个标签
- en: 'Next, you can import the libraries you need to perform the task. The following
    code will import what you need for the `SeeClickFix` toolbox:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以导入执行任务所需的库。以下代码将导入`SeeClickFix`工具箱所需的库：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The previous code imports the `qgis` libraries and also `requests` and `json`.
    The `requests` library will be used to make the API call and `json` will parse
    the response from the request to `json`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码导入了`qgis`库以及`requests`和`json`。`requests`库将用于进行API调用，而`json`将解析请求的响应为`json`。
- en: 'Now it is time to write some code. First, you will need to grab the parameters
    and set the variables needed to make the API call, and it would not hurt to give
    the user some information on what is happening. The following code will show you
    how:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写一些代码了。首先，您需要获取参数并设置进行API调用所需的变量，并且向用户提供一些关于正在发生的事情的信息也是有帮助的。以下代码将向您展示如何操作：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The previous code passes the parameters to variables. Then, I used a global
    variable, `progress`, which is provided to you by QGIS and calls the `setInfo()`
    and `setText()` methods to tell the user what is happening. `progress` is available
    as part of QGIS. The `setInfo()` method displays text in the text area of the
    GUI. The `setText()` method changes the text of the label on the `progress` bar
    and adds it to the text area in the GUI as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将参数传递给变量。然后，我使用了一个全局变量`progress`，这是QGIS提供的，并调用`setInfo()`和`setText()`方法来告诉用户正在发生什么。`progress`是QGIS的一部分。`setInfo()`方法在GUI的文本区域中显示文本。`setText()`方法更改进度条上标签的文本，并将其添加到GUI的文本区域中。
- en: Next, the code checks if the filter parameter is still `None`, and if it is,
    it assigns the **Uniform Resource Locator** (**URL**) to the API as a string with
    no filter parameter and uses the city or neighborhood parameter. If there is a
    filter, a different URL is assigned to make the API call.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码检查过滤器参数是否仍然是`None`，如果是，它将**统一资源定位符**（**URL**）作为没有过滤器参数的字符串分配给API，并使用城市或区域参数。如果有过滤器，将分配不同的URL以进行API调用。
- en: 'Now you are ready for some GIS specific setup. The following code will start
    you off:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好进行一些GIS特定的设置。以下代码将为您开始：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The previous code sets a coordinate reference system in WGS 84\. Then, it creates
    a `memory` layer, and assigns fields. Lastly, it creates a `writer` vector and
    passes the output parameter, encoding (`None`), the fields, the geometry type,
    and a coordinate reference system. Now you can make the API call as shown in the
    code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在WGS 84坐标系中设置坐标参考系统。然后，它创建一个`memory`层，并分配字段。最后，它创建一个向量`writer`并将输出参数、编码（`None`）、字段、几何类型和坐标参考系统传递给它。现在您可以根据代码进行API调用：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The previous code uses `requests` to make an API call. It assigns a variable
    for the number of `pages` and the number of `records` returned. Using the `setInfo()`
    method, the code tells the user how many `records` are being processed. It then
    loops through each page and loads the items from the `page`. It tells the user
    what `page` it is currently reading.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`requests`库进行API调用。它为页数和返回的记录数分配变量。使用`setInfo()`方法，代码告诉用户正在处理多少`records`。然后，它遍历每一页并从`page`中加载项目。它告诉用户当前正在读取哪一页。
- en: 'Now, the code will parse each `record` on the `page` as a feature and send
    it to the vector `writer`. You do not need to add the output to the map. Processing
    will handle this for you if you run it from the GUI. When you run it from Python,
    you get the file path to the layer and can load it yourself. The following code
    will show you how:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码将把页面上的每个`record`解析为一个特征并发送到向量`writer`。您不需要将输出添加到映射中。如果您从GUI运行它，处理将为您处理这一点。如果您从Python运行它，您将获得层的文件路径，可以自行加载。以下代码将向您展示如何操作：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The previous code creates a feature and passes the geometry from the API to
    a `point`. It then passes the attributes and sends the completed feature to the
    vector `writer`. The `progress` bar on the GUI is updated using `progress.setPercentage()`.
    The method takes a `float`. In this example, the percentage is the number of `records`
    processed divided by the total number of `records`. Lastly, you delete the `writer`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个特征，并将从API传递的几何形状传递到一个`point`。然后，它传递属性并将完成后的特征发送到向量`writer`。使用`progress.setPercentage()`更新GUI上的`progress`条。该方法接受一个`float`。在这个例子中，百分比是处理的`records`数除以总记录数。最后，您删除了`writer`。
- en: 'Your toolbox is complete, save it. Now a user can run it from the GUI or you
    can call it from Python. The following code will show you how to call it from
    Python and add the results to the map:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您的工具箱已经完整，请保存它。现在用户可以从GUI运行它，或者您可以从Python调用它。以下代码将展示如何从Python调用它并将结果添加到地图中：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The previous code calls the `alghelp()` method to show our new algorithm and
    the parameters. Next, it runs the algorithm using `runalg()` and assigns the results
    to the `out` variable. Printing the `out` variable shows a dictionary with a key
    of `Output` and a path to a temporary vector as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码调用`alghelp()`方法来显示我们新的算法和参数。接下来，它使用`runalg()`运行算法并将结果分配给`out`变量。打印`out`变量显示一个包含`Output`键和临时矢量路径的字典，如下所示：
- en: '[PRE59]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can assign the vector to a layer and add it to the map, or you can iterate
    through the features and do something else with it, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将矢量分配给图层并将其添加到地图中，或者您可以遍历要素并对其进行其他操作，如下所示：
- en: '[PRE60]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The results of adding the layer to the map will look like the following screenshot.
    All of the `SeeClickFix` incidents reported along the street, Juan Tabo:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将图层添加到地图的结果将类似于以下截图。沿Juan Tabo街道报告的所有`SeeClickFix`事件：
- en: '![](img/bac1fc04-bbcd-4809-8478-cde9ca8b00e8.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bac1fc04-bbcd-4809-8478-cde9ca8b00e8.png)'
- en: Results of the toolbox
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 工具箱的结果
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to use Python in QGIS. You started by
    learning the basics of loading a layer and displaying it on the map, and then
    progressed to adding, editing, and deleting features. You learned how to select
    features, highlight the selection, and how to use expressions. Then, we took advantage
    of pre-built geoprocessing tools and you learned how to call toolbox algorithms
    using processing. Lastly, you learned how to write your own toolbox.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在QGIS中使用Python。您从学习加载图层并在地图上显示它的基本知识开始，然后进步到添加、编辑和删除要素。您学习了如何选择要素、突出显示选择，以及如何使用表达式。然后，我们利用预构建的地理处理工具，您学习了如何使用处理调用工具箱算法。最后，您学习了如何编写自己的工具箱。
- en: In the next chapter, you will learn how to use Python with Esri tools. You will
    learn how to use Jupyter Notebooks in a browser to interact with cloud-based datasets
    and how to use the Esri API for Python to perform basic geospatial analysis and
    to create ArcGIS Online web maps.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用Python与Esri工具结合。您将学习如何在浏览器中使用Jupyter Notebooks与基于云的数据集交互，以及如何使用Python的Esri
    API进行基本的地理空间分析和创建ArcGIS Online网络地图。
