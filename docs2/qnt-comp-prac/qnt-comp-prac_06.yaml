- en: '*Chapter 6*: Understanding the Qiskit® Gate Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：理解 Qiskit® 量子门库'
- en: In this chapter, we will explore the quantum gates that are offered out of the
    Qiskit® box. By including a quantum gate library that features the most common
    gates, Qiskit® makes coding your circuits easy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 Qiskit® 提供的量子门。通过包含一个具有最常见门的量子门库，Qiskit® 使编写电路变得容易。
- en: Among the gates that we will look at are the Pauli X, Y, and Z gates used for
    basic qubit flips, the H (or Hadamard) gate used to create qubit superpositions,
    and the CX (controlled-NOT) gate used to create quantum entanglement. For a quick
    refresher, take a look at [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的门中包括用于基本量子比特翻转的泡利 X、Y 和 Z 门，用于创建量子比特叠加的 H（或哈达玛）门，以及用于创建量子纠缠的 CX（控制非）门。为了快速复习，请查看
    [*第 4 章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)，*从 Terra 的基础开始*。
- en: We will also look at the specialized S and T gates, spin our qubits with R gates,
    and then show how just a minimal set of U1, U2, U3, ID, and CX basis gates are
    used to translate the other gates for direct use with a quantum computer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨专门的 S 和 T 门，使用 R 门旋转我们的量子比特，然后展示如何仅使用最小的一组 U1、U2、U3、ID 和 CX 基础门来转换其他门，以便直接在量子计算机上使用。
- en: We will stop by the multi-qubit gates and finally end our tour with a short
    look beneath the covers to see how the simple gates that we string out in the
    Qiskit® programs get translated into much more complex sets of basis gates by
    the transpiler before we can run them on a real quantum computer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍多量子比特门，并最终以对 Qiskit® 程序中我们串出的简单门如何被编译器转换成更复杂的基门集的简要了解来结束我们的参观，这样我们才能在真实的量子计算机上运行它们。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Visualizing quantum gates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化量子门
- en: Flipping with the Pauli X, Y, and Z gates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泡利 X、Y 和 Z 门进行翻转
- en: Creating superpositions with the H gate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 H 门创建叠加态
- en: Fixed Z rotations with phase shift gates S, S†, T, and T†
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相位移位门 S、S†、T 和 T† 进行固定的 Z 旋转
- en: Free rotation around the axes with Rx, Ry, and Rz
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rx、Ry 和 Rz 在轴周围进行自由旋转
- en: Building our circuits with the basis gates – U1, U2, U3, and ID
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基础门 – U1、U2、U3 和 ID 构建我们的电路
- en: Using gates on 2 qubits
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 2 个量子比特上使用门
- en: Using gates on more than 2 qubits
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在超过 2 个量子比特上使用门
- en: What your quantum circuit really looks like
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的量子电路真正看起来是什么样子
- en: In these recipes, you will be exposed to quantum gate unitary matrixes and qubit
    state vectors, both of which we discussed mathematically in the *A quick introduction
    to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*. Feel free to jump back and test the
    math again if needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些菜谱中，你将接触到量子门单位矩阵和量子比特状态向量，这些我们在 [*第 2 章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)，*使用
    Python 进行量子计算和量子比特*中的“快速介绍量子门”菜谱中从数学上进行了讨论。如有需要，请随时返回并再次测试数学。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The quantum programs that we discuss in this chapter can be found here:  [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter06](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter06).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的量子程序可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter06](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter06)。
- en: Visualizing quantum gates
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化量子门
- en: To help us understand quantum gates, we can use the `ch6_r1_quantum_gate_ui.py`
    sample program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解量子门，我们可以使用 `ch6_r1_quantum_gate_ui.py` 示例程序。
- en: This recipe differs a bit from the ones that we have seen so far. Up until now,
    we have mainly just used Qiskit® commands inside a Python wrapper, with no actual
    coding beyond that. This time, we start out by building a rudimentary Python implementation
    to create a very basic *before-after gate exploration UI*. When you run the program,
    it prompts you to select an initial qubit state and a gate to apply to your qubit;
    then it creates a visualization to show you the gate action on the qubit.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱与我们所看到的略有不同。到目前为止，我们主要只是在 Python 包装器内使用 Qiskit® 命令，没有进行任何实际的编码。这次，我们首先构建了一个基本的
    Python 实现，以创建一个非常基本的 *门探索前后界面*。当你运行程序时，它会提示你选择一个初始量子比特状态和一个要应用于量子比特的门；然后它创建一个可视化来显示门对量子比特的作用。
- en: The script builds your circuit for you and then shows the basic minimum circuit
    that supports the gate, the state vector, and a Bloch sphere or Q-sphere visualization
    that corresponds to the gate action. The visualization highlights the qubit's
    state before the gate, and how the state changes after the gate.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本为您构建电路，然后显示支持门、状态向量和对应于门操作的布洛赫球或Q球可视化的基本最小电路。可视化突出显示了门之前量子比特的状态以及门之后状态的变化。
- en: Hybrid classical/quantum programs
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 混合经典/量子程序
- en: So, what we are doing here is building a hybrid classical/quantum program, where
    we use Python to drive user input control, general logic, and presentation, and
    the Qiskit® components to access the quantum-related features. This is what we
    will be doing going forward in the following chapters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里做的是构建一个混合经典/量子程序，其中我们使用Python来驱动用户输入控制、通用逻辑和展示，并使用Qiskit®组件来访问量子相关功能。这就是我们在接下来的章节中将要做的事情。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we step into the visualizer, let''s spend a second discussing a few
    basic qubit states that we can initialize our qubit in. You know two of them (![](img/Formula_06_001.png)
    and ![](img/Formula_06_002.png)) well, but for an understanding of where on the
    Bloch sphere our qubit state vector points, here''s a quick introduction of the
    rest with their Dirac ket description and a Bloch sphere reference:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入可视化器之前，让我们花一点时间讨论一些基本的量子比特状态，我们可以用这些状态初始化我们的量子比特。你们很熟悉其中两个（![](img/Formula_06_001.png)
    和 ![](img/Formula_06_002.png)），但为了理解我们的量子比特状态向量在布洛赫球上的指向，这里快速介绍一下其余的状态，包括它们的狄拉克矢量描述和布洛赫球参考：
- en: '![](img/Formula_06_003.png): Straight up along the *z* axis'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_06_003.png)：沿 *z* 轴直接向上'
- en: '![](img/Formula_06_004.png): Straight down along the *z* axis'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_06_004.png)：沿 *z* 轴直接向下'
- en: '![](img/Formula_06_005.png): Out along the + *x* axis'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_06_005.png)：沿 + *x* 轴向外延伸'
- en: '![](img/Formula_06_006.png): In along the - *x* axis'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_06_006.png)：沿 - *x* 轴向内延伸'
- en: '![](img/Formula_06_007.png): Right along the + *y* axis'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_06_007.png)：沿 + *y* 轴向右延伸'
- en: '![](img/Formula_06_008.png): Left along the - *y* axis'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_06_008.png)：沿 - *y* 轴向左延伸'
- en: '![Figure 6.1 – The initial qubit states mapped on the Bloch sphere](img/Figure_6.1_B14436.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 布洛赫球上映射的初始量子比特状态](img/Figure_6.1_B14436.jpg)'
- en: Figure 6.1 – The initial qubit states mapped on the Bloch sphere
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 布洛赫球上映射的初始量子比特状态
- en: 'In this recipe, we will explore several interesting Qiskit® features:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探索几个有趣的Qiskit®功能：
- en: '`qiskit.visualization` class includes various methods to visualize your qubits
    and your circuits. In this recipe, we will use the following:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qiskit.visualization` 类包含各种方法来可视化您的量子比特和电路。在本食谱中，我们将使用以下方法：'
- en: '**Bloch sphere**: Displays a single qubit as a Bloch sphere:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**布洛赫球**：显示单个量子比特作为布洛赫球：'
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Q-sphere**: Displays 1 or more qubits as a state probability vector on a
    sphere:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Q球**：在球面上显示1个或多个量子比特作为状态概率向量：'
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Initialize**: Used to initialize a qubit to specific initial states:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化**：用于将量子比特初始化到特定的初始状态：'
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Statevector simulator**: An **Aer** quantum simulator that is used to calculate
    the state vector of a qubit:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态向量模拟器**：一个 **Aer** 量子模拟器，用于计算量子比特的状态向量：'
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Unitary simulator**: An **Aer** quantum simulator that lets you calculate
    the unitary matrix of a quantum circuit. If you use this simulator on a circuit
    that contains only a single gate, you can in essence pull out the matrix representation
    of that quantum gate:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元模拟器**：一个 **Aer** 量子模拟器，允许您计算量子电路的单元矩阵。如果您在只包含单个门的电路上使用此模拟器，本质上可以提取该量子门的矩阵表示：'
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`QuantumCircuit.from_qasm_str(qasm_string)` method that we explored in the
    *Moving between worlds* recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *IBM Quantum® Experience – Drag and Drop Quantum Computing*.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuantumCircuit.from_qasm_str(qasm_string)` 方法，我们在[*第3章*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)的“在两个世界之间移动”食谱中进行了探索，*IBM
    Quantum® 经验 – 拖放量子计算*。'
- en: 'The code for the sample program is available here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例程序的代码在此处可用：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py)。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The sample program is a little convoluted but running it is straightforward.
    Each step is separated by an input step to select start states and gates, or by
    a simple *Hit Enter* before the next step rolls along:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例程序稍微有些复杂，但运行起来很简单。每个步骤都通过选择起始状态和门或简单的 *Hit Enter*（在下一步开始之前）之间的输入步骤来分隔：
- en: Run the `ch6_r1_quantum_gate_ui.py` sample file in your Python environment.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Python 环境中运行 `ch6_r1_quantum_gate_ui.py` 示例文件。
- en: 'At the first prompt, enter the starting state for your first qubit. If you
    pick a gate that uses more than 1 qubit, such as the CX gate, the qubit state
    that you select here is for the controlling qubit. Your options are the following:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一次提示时，输入您第一个量子比特的起始状态。如果您选择使用超过 1 个量子比特的门，例如 CX 门，则您在此处选择的量子比特状态是用于控制量子比特的。您的选项如下：
- en: '![Figure 6.2 – The first prompt: Select a start state](img/Figure_6.2_B14436.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 6.2 – 第一次提示：选择起始状态](img/Figure_6.2_B14436.jpg)'
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At the second prompt, enter the gate that you want to explore, for example
    `X`:![Figure 6.3 – The second prompt: Select a gate'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二次提示时，输入您想要探索的门，例如 `X`：![图 6.3 – 第二次提示：选择门](img/Figure_6.3_B14436.jpg)
- en: '](img/Figure_6.3_B14436.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.3_B14436.jpg)'
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program now uses the `get unitary()` function from the sample code on a
    blank circuit to retrieve and print the unitary matrix for the gate that you selected.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在程序使用从空白电路上的示例代码中获取的 `get unitary()` 函数来检索并打印您所选门的单位矩阵。
- en: 'For an X gate, the output will look something like this:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 X 门，输出将类似于以下内容：
- en: '![Figure 6.4 – First output: The unitary for the gate](img/Figure_6.4_B14436.jpg)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 6.4 – 第一次输出：门的单位矩阵](img/Figure_6.4_B14436.jpg)'
- en: 'Figure 6.4 – First output: The unitary for the gate'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.4 – 第一次输出：门的单位矩阵
- en: 'Compare this to the matrix version of the X gate that we calculated in [*Chapter
    2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing and Qubits
    with Python*:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此与我们在 [*第 2 章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045) 中计算的 X 门的矩阵版本进行比较，*使用
    Python 进行量子计算和量子比特*：
- en: '![](img/Formula_06_019.jpg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/Formula_06_019.jpg)'
- en: We are now ready for the meat of the program.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已准备好程序的精华部分。
- en: Press *Enter* to create the initial setup.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Enter* 键以创建初始设置。
- en: The program calls the `qgate(gate,start)` function to set up the circuit based
    on your input. It uses the gate input with `create_circuit(n_qubits,start)` to
    set up a 1-qubit or 2-qubit circuit, and then uses the `qgate_out(circuit,start)`
    function to display the empty circuit. At this point, the circuit will only include
    an `initialized` qubit set to the starting state you selected, and if the input
    state is ![](img/Formula_06_001.png), then we do not need to initialize the circuit
    at all.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序调用 `qgate(gate,start)` 函数根据您的输入设置电路。它使用 `create_circuit(n_qubits,start)` 与门输入一起设置
    1 个量子比特或 2 个量子比特的电路，然后使用 `qgate_out(circuit,start)` 函数显示空电路。在此阶段，电路将仅包括一个设置为所选起始状态的
    `initialized` 量子比特，如果输入状态是 ![图片](img/Formula_06_001.png)，则我们根本不需要初始化电路。
- en: 'The `initialize()` method takes a vector of complex amplitudes and a target
    qubit as input and adds a circuit instruction that looks much like a gate. The
    complex amplitudes must be normalized, and in the program, we use the following
    to create the vector: `[a * complex(1, 0), b * complex(1, 0)]`.'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`initialize()` 方法接受一个复数振幅向量和目标量子比特作为输入，并添加一个看起来很像门的电路指令。复数振幅必须是归一化的，在程序中，我们使用以下方式创建向量：`[a
    * complex(1, 0), b * complex(1, 0)]`。'
- en: 'The output should be something like the following:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '![Figure 6.5 – Second output: Initial circuit, state vector, and Bloch-sphere'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.5 – 第二次输出：初始电路、状态向量和 Bloch 球](img/Figure_6.5_B14436.jpg)'
- en: '](img/Figure_6.5_B14436.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.5_B14436.jpg)'
- en: 'Figure 6.5 – Second output: Initial circuit, state vector, and Bloch-sphere'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.5 – 第二次输出：初始电路、状态向量和 Bloch 球
- en: Press *Enter* again to add the gate you selected and display the end results
    after the gate.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按 *Enter* 键以添加您所选的门并显示门应用后的最终结果。
- en: The end result of the call to the `qgate(gate,start)` function was to return
    the complete circuit. We now use the `qgate_out(circuit,start)` function to display
    the final results, after the gate is applied.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用 `qgate(gate,start)` 函数的最终结果是返回完整的电路。我们现在使用 `qgate_out(circuit,start)` 函数来显示在应用门之后的最终结果。
- en: 'Here is the expected output for an X gate, acting on a qubit initialized to
    ![](img/Formula_06_021.png):'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 X 门作用于初始化为 ![图片](img/Formula_06_021.png) 的量子比特的预期输出：
- en: '![Figure 6.6 – Third output: Circuit, state vector, and Bloch sphere after
    the gate ](img/Figure_6.6_B14436.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 第三次输出：门应用后的电路、状态向量和 Bloch 球](img/Figure_6.6_B14436.jpg)'
- en: 'Figure 6.6 – Third output: Circuit, state vector, and Bloch sphere after the
    gate'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 第三个输出：门后的电路、状态矢量和布洛赫球体
- en: The result of the initial run is the qubit started out in the ![](img/Formula_06_022.png)
    state, pointing straight up, and was then flipped by the X gate to ![](img/Formula_06_002.png),
    pointing straight down.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 初始运行的结果是量子比特从 ![](img/Formula_06_022.png) 状态开始，指向正上方，然后通过X门翻转至 ![](img/Formula_06_002.png)，指向正下方。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the program, we defined several functions that run the Qiskit® specific
    functionality of the program:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我们定义了几个运行程序Qiskit®特定功能的函数：
- en: '`get_psi(circuit)`: This is the same function that we introduced in [*Chapter
    4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting at the Ground Level
    with Terra*, with a slight twist. Instead of using it to directly plot the Bloch
    vector, we set it up to return the state vector so that we can use it elsewhere.
    The function takes as input a quantum circuit and returns the state vector of
    that circuit by using the `statevector_simulator` backend that is provided by
    Qiskit Aer:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_psi(circuit)`: 这是我们之前在[*第4章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)中介绍的函数，*从Terra开始脚踏实地*，略有变化。我们不是用它直接绘制布洛赫矢量，而是设置它返回状态矢量，这样我们就可以在其他地方使用它。该函数接受一个量子电路作为输入，并使用Qiskit
    Aer提供的`statevector_simulator`后端返回该电路的状态矢量：'
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`get_unitary(circuit)`: This function takes as input a quantum circuit and
    returns the unitary matrix for that circuit by using the `unitary_simulator` Aer
    backend:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_unitary(circuit)`: 这个函数接受一个量子电路作为输入，并使用Aer后端中的`unitary_simulator`返回该电路的单位矩阵：'
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`create_circuit(n_qubits,start)`: This function creates a quantum circuit and
    initializes it to the start state that you selected.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_circuit(n_qubits,start)`: 这个函数创建一个量子电路并将其初始化为所选的起始状态。'
- en: 'We start by setting up the start vector based on the user input: `1`, `+`,
    `-`, `R`, `L`, `r`, or `d`:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先根据用户输入设置起始向量：`1`，`+`，`-`，`R`，`L`，`r`或`d`：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then create the circuit for the specified number of qubits and initialize
    the qubit if the start state is not ![](img/Formula_06_001.png):'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们为指定的量子比特数量创建电路，并在起始状态不是 ![](img/Formula_06_001.png) 的情况下初始化量子比特：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`qgate_out(circuit,start)`: In addition, we use the `print` functionality with
    some of the Qiskit® methods to create and save images of our circuits and the
    Bloch-sphere representations of the qubits:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qgate_out(circuit,start)`: 此外，我们还使用`print`功能与一些Qiskit®方法一起创建和保存我们电路和量子比特的布洛赫球表示的图像：'
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`qgate(gate,start)`: This function takes as input a gate and a start state,
    and then creates a quantum circuit from these. For single-qubit gates, the gate
    is added to the first qubit, and for 2-qubit gates, the second qubit is the controller
    qubit and the first qubit is the controlled qubit.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qgate(gate,start)`: 这个函数接受一个门和一个起始状态作为输入，然后从这些输入创建一个量子电路。对于单量子比特门，门被添加到第一个量子比特上，而对于双量子比特门，第二个量子比特是控制量子比特，第一个量子比特是被控制量子比特。'
- en: 'It then compares the input gate to the `oneq_gates` list, and promptly calls
    the `create_circuit()` function to create a 1-qubit or 2-qubit circuit. At this
    point, we also create the correct 1-qubit or 2-qubit QASM string that we use to
    append the selected gate to the circuit using the `from_qasm_str()` method that
    we started looking at in the *Moving between worlds* recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *IBM Quantum Experience® – Quantum Drag and Drop*. As luck would have it, the
    QASM code for our gates corresponds one-to-one with the names of the gates. To
    add an `x` gate, we use the following command:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后它将输入门与`oneq_gates`列表进行比较，并立即调用`create_circuit()`函数来创建一个1量子比特或2量子比特电路。在此阶段，我们还创建了正确的1量子比特或2量子比特QASM字符串，我们使用`from_qasm_str()`方法将其附加到电路中，该方法我们在[*第3章*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)的*在两个世界之间移动*食谱中开始探讨，*IBM
    Quantum Experience® – 量子拖放*。幸运的是，我们门的QASM代码与门名一一对应。要添加`x`门，我们使用以下命令：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Where the string addition is in the `from_qasm_string()` command:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字符串加法在`from_qasm_string()`命令中：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This translates into the following code and appends the `x` `gate` to the circuit:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这转化为以下代码，并将`x`门添加到电路中：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `qgate()` function then returns the circuit and we can move on:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`qgate()`函数然后返回电路，我们可以继续：'
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, now you are equipped with a little program that lets you set up very basic
    one-gate circuits and study the initial and final state vectors, see the unitary
    matrixes of the selected gates, and view how the gates make the Bloch vector move
    around, and visualize on a **Q-sphere** where the **Bloch sphere** is no longer
    enough.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在您拥有了一个小程序，可以设置非常基本的单门电路，研究初始和最终状态向量，查看所选门的单位矩阵，并查看门如何使Bloch向量移动，并在**Q-sphere**上可视化，其中**Bloch球**不再足够。
- en: Now take this program for a spin by working your way through the rest of the
    recipes in this chapter to explore the base set of quantum gates that Qiskit®
    provides.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过完成本章剩余的食谱来尝试这个程序，以探索Qiskit®提供的量子门的基本集合。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For a quick interactive look at a single-qubit Bloch sphere representation
    and what certain gate operations do to it, take a look at the **grok-bloch** application
    by Qiskit Advocate James Weaver: [https://github.com/JavaFXpert/grok-bloch](https://github.com/JavaFXpert/grok-bloch).
    You can install and run it from your own Python environment or run it online here:
    [https://javafxpert.github.io/grok-bloch/](https://javafxpert.github.io/grok-bloch/).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速直观地查看单量子比特的Bloch球表示以及某些门操作对其的影响，请查看Qiskit倡导者詹姆斯·韦弗的**grok-bloch**应用程序：[https://github.com/JavaFXpert/grok-bloch](https://github.com/JavaFXpert/grok-bloch)。您可以从自己的Python环境中安装并运行它，或者在此处在线运行：[https://javafxpert.github.io/grok-bloch/](https://javafxpert.github.io/grok-bloch/)。
- en: Flipping with the Pauli X, Y, and Z gates
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pauli X、Y和Z门翻转
- en: The Pauli X, Y, and Z gates all act on a single qubit, and perform an action
    similar to a classical NOT gate, which flips the value of a classical bit. For
    example, the X gate sends ![](img/Formula_06_027.png) to ![](img/Formula_06_028.png)
    and vice versa.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Pauli X、Y和Z门都作用于单个量子比特，并执行类似于经典NOT门的作用，翻转经典比特的值。例如，X门将![](img/Formula_06_027.png)发送到![](img/Formula_06_028.png)，反之亦然。
- en: As we shall see, the X gate is actually a rotation around the *x* axis of ![](img/Formula_06_029.png)
    radians. The same is true for the Pauli Y and Z gates, but along the *y* and *z*
    axes correspondingly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，X门实际上是在![](img/Formula_06_029.png)弧度下围绕*x*轴的旋转。对于Pauli Y和Z门也是如此，但沿着*y*和*z*轴相应地旋转。
- en: 'Mathematically, the X, Y, and Z gates can be expressed as the following unitary
    matrixes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，X、Y和Z门可以用以下单位矩阵表示：
- en: '![](img/Formula_06_030.png) ![](img/Formula_06_031.png) ![](img/Formula_06_032.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_030.png) ![](img/Formula_06_031.png) ![](img/Formula_06_032.png)'
- en: This recipe will serve as a sort of template for how to use the sample code
    that is provided in the chapter. The remaining recipes will largely gloss over
    the deeper details.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将作为如何使用章节中提供的示例代码的模板。其余的食谱将主要概述更深入的细节。
- en: Let's take a look at the Pauli X, Y, and Z gates by running the Quantum Gate
    UI sample program. It starts by setting up a plain quantum circuit with a single
    qubit initiated in a state that you select. The gate selected is then added to
    the circuit, and then the unitary simulator and state vector simulators are run
    to display the results in the form of a qubit state vector and the gate unitary
    matrix.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行量子门UI示例程序来查看Pauli X、Y和Z门。程序首先设置一个简单的量子电路，其中包含一个从您选择的态开始的单一量子比特。然后，将选定的门添加到电路中，然后运行单位模拟器和状态向量模拟器，以显示以量子比特状态向量和门单位矩阵形式的结果。
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例脚本可在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py)。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ch6_r1_quantum_gate_ui.py`示例程序。
- en: Select a start state for your qubit.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的量子比特的起始状态。
- en: The X and Y gates work well with ![](img/Formula_06_0221.png) and ![](img/Formula_06_023.png),
    essentially acting as a NOT gate.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X和Y门与![](img/Formula_06_0221.png)和![](img/Formula_06_023.png)配合良好，本质上充当NOT门。
- en: With ![](img/Formula_06_035.png)), the X gate will do nothing, but the Y and
    Z gate will create a phase shift of ![](img/Formula_06_036.png), creating ![](img/Formula_06_037.png).
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在![](img/Formula_06_035.png))的情况下，X门将不执行任何操作，但Y和Z门将创建一个![](img/Formula_06_036.png)的相移，创建![](img/Formula_06_037.png)。
- en: Also test ![](img/Formula_06_038.png) and ![](img/Formula_06_039.png) to see
    what they do. If you use the **r** (**random**) or **d** (**define**) inputs,
    then you can explore the gate rotations in more detail.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还要测试![公式6.3.8](img/Formula_06_038.png)和![公式6.3.9](img/Formula_06_039.png)以查看它们的作用。如果您使用**r**（**随机**）或**d**（**定义**）输入，那么您可以更详细地探索门旋转。
- en: When prompted, enter `x`, `y`, or `z` to select the gate to test.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入`x`、`y`或`z`以选择要测试的门。
- en: We tested the X gate in the *Visualizing the quantum gates* recipe. Now take
    a look at the others.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在*可视化量子门*菜谱中测试了X门。现在来看看其他的。
- en: 'The Z gate with a random start state might produce the following output:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随机起始状态的Z门可能会产生以下输出：
- en: '![Figure 6.7 – The Z gate with a random start state](img/Figure_6.7_B14436.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 随机起始状态的Z门](img/Figure_6.7_B14436.jpg)'
- en: Figure 6.7 – The Z gate with a random start state
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 随机起始状态的Z门
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The Pauli gates cannot run directly on a quantum backend, but are automatically
    transpiled to the following unitary basis gates before you run your program:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Pauli门不能直接在量子后端上运行，但在你运行程序之前会自动转换为以下单位基门：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For more information, see the *Building our circuits with the basis gates –
    U1,U2, U3, and ID* and *What your quantum circuit really looks like* recipes in
    this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅本章中的*使用基本门构建我们的电路 – U1、U2、U3和ID*和*你的量子电路真正看起来是什么样子*菜谱。
- en: Creating superpositions with the H gate
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用H门创建叠加
- en: Now, let's revisit our old friend from [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*, the **Hadamard** or **H** gate. This
    is a fairly specialized gate that we can use to make a generic qubit superposition.
    But there's more to it than that; we can also make use of the H gate to change
    the axis of measurement from the generic *z* (or computational) axis to the *x*
    axis to gain additional insights into the qubit behavior. More on that in the
    *There's more* section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们的老朋友[*第4章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)，*从Terra的起点开始*，**Hadamard**或**H**门。这是一个相当专业的门，我们可以用它来创建一个通用的量子比特叠加。但不仅如此；我们还可以利用H门来改变测量轴，从通用的*z*（或计算）轴变为*x*轴，以获得对量子比特行为的更深入了解。更多内容请参阅*更多内容*部分。
- en: 'The H gate can be expressed as the following unitary matrix:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: H门可以用以下单位矩阵表示：
- en: '![](img/Formula_06_040.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![公式6.4.0](img/Formula_06_040.jpg)'
- en: 'Unless you are really good at interpreting matrix operations, it might not
    be entirely clear just what this gate will do with your qubits. If we describe
    the behavior as a combination of 2 qubit rotations instead, things might become
    clearer. When you apply the Hadamard gate to your qubit, you run it through two
    rotations: first a ![](img/Formula_06_041.png) rotation around the *y* axis, and
    then a ![](img/Formula_06_042.png) rotation around the *x* axis.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你非常擅长解释矩阵运算，否则这个门会对你的量子比特做什么可能并不完全清楚。如果我们将其描述为两个量子比特旋转的组合，事情可能会变得清晰起来。当你对你的量子比特应用Hadamard门时，你让它经历两个旋转：首先是一个围绕*y*轴的![公式6.4.1](img/Formula_06_041.png)旋转，然后是一个围绕*x*轴的![公式6.4.2](img/Formula_06_042.png)旋转。
- en: For a qubit in state ![](img/Formula_06_043.png), this means that we start at
    the North Pole, and then travel down to the equator, ending up at the ![](img/Formula_06_044.png)
    location on the Bloch sphere, and finally just rotate around the *x* axis. Similarly,
    if you start at the South Pole at ![](img/Formula_06_045.png), you first move
    up to the equator but at the other extreme on the *x* axis, ending up at ![](img/Formula_06_046.png).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处于状态![公式6.4.3](img/Formula_06_043.png)的量子比特，这意味着我们从一个北极开始，然后下降到赤道，最终到达布洛赫球上的![公式6.4.4](img/Formula_06_044.png)位置，最后围绕*x*轴旋转。同样，如果您从南极![公式6.4.5](img/Formula_06_045.png)开始，您首先上升到赤道，但在*x*轴的另一端，最终到达![公式6.4.6](img/Formula_06_046.png)。
- en: 'If we do the matrix math for ![](img/Formula_06_047.png), we get the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对![公式6.4.7](img/Formula_06_047.png)进行矩阵运算，我们得到以下结果：
- en: '![](img/Formula_06_048.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![公式6.4.8](img/Formula_06_048.jpg)'
- en: 'Now we can use the following Dirac ket notation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下狄拉克矢量表示法：
- en: '![](img/Formula_06_049.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![公式6.4.9](img/Formula_06_049.jpg)'
- en: '![](img/Formula_06_050.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![公式6.5.0](img/Formula_06_050.png)'
- en: 'If we replace *a* and *b* with ![](img/Formula_06_051.png) from above, we get:
    ![](img/Formula_06_052.png) and ![](img/Formula_06_053.png), which corresponds
    to ![](img/Formula_06_044.png).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将*a*和*b*替换为上面的![公式6.5.1](img/Formula_06_051.png)，我们得到![公式6.5.2](img/Formula_06_052.png)和![公式6.5.3](img/Formula_06_053.png)，这对应于![公式6.4.4](img/Formula_06_044.png)。
- en: If we apply the Hadamard gate to qubits in states other than pure ![](img/Formula_06_055.png)
    and ![](img/Formula_06_056.png), we rotate the qubit to a new position.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将哈达玛门应用于处于纯 ![](img/Formula_06_055.png) 和 ![](img/Formula_06_056.png) 以外的量子比特状态，我们将量子比特旋转到新的位置。
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例脚本可在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py)。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To explore the Hadamard gate, we run the Quantum Gate program that is described
    in the *Visualizing quantum gates* recipe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索哈达玛门，我们运行了在 *可视化量子门* 食谱中描述的量子门程序：
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ch6_r1_quantum_gate_ui.py` 示例程序。
- en: Select a start state for your qubit.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的量子比特选择一个起始状态。
- en: The H gate works well with ![](img/Formula_06_057.png) and ![](img/Formula_06_058.png),
    placing you on the equator in an equal superposition. With ![](img/Formula_06_059.png)
    and ![](img/Formula_06_060.png), the H gate will return the equal superposition
    to the corresponding computational states, ![](img/Formula_06_0221.png) and ![](img/Formula_06_023.png).
    Try the ![](img/Formula_06_063.png), ![](img/Formula_06_0391.png), Random or Define
    inputs to explore the gate rotations in more detail.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: H 门与 ![](img/Formula_06_057.png) 和 ![](img/Formula_06_058.png) 配合良好，将你置于赤道上的等概率叠加状态。使用
    ![](img/Formula_06_059.png) 和 ![](img/Formula_06_060.png)，H 门将等概率叠加返回到相应的计算状态，![](img/Formula_06_0221.png)
    和 ![](img/Formula_06_023.png)。尝试使用 ![](img/Formula_06_063.png)、![](img/Formula_06_0391.png)、随机或定义输入来更详细地探索门旋转。
- en: 'When prompted, enter *h* to select the gate to test. The H gate applied to
    ![](img/Formula_06_0221.png) will produce the following output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入 *h* 选择要测试的门。将 H 门应用于 ![](img/Formula_06_0221.png) 将产生以下输出：
- en: '![Figure 6.8 – The H gate with |0> start state'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8 – 以 |0> 为起始状态的 H 门]'
- en: '](img/Figure_6.8_B14436.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.8_B14436.jpg)'
- en: Figure 6.8 – The H gate with |0> start state
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 以 |0> 为起始状态的 H 门
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Hadamard gate cannot run directly on a quantum backend, but is automatically
    transpiled to the following unitary basis gate before you run your program:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 哈达玛门不能直接在量子后端运行，但在你运行程序之前，会自动编译成以下单位算子基门：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For more information, see the *Building our circuits with the basis gates –
    U1,U2, U3, and ID* and *What your quantum circuit really looks like* recipes in
    this chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参阅本章中的 *使用基本门构建我们的电路 – U1、U2、U3 和 ID* 以及 *你的量子电路真正看起来是什么样子* 两个食谱。
- en: The Hadamard gate is also commonly used to change your measurement axis from
    the default (computational) *z* axis to the *x* axis. By measuring in the *x*
    axis, you can detect the qubit phase.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 哈达玛门通常也用于将你的测量轴从默认（计算）*z* 轴更改为 *x* 轴。通过沿 *x* 轴测量，你可以检测量子比特的相位。
- en: To figure out the value of the phase, you must add one more measurement, this
    time along the *y* axis. To achieve this, you use the Hadamard gate in combination
    with the S dagger gate to shift over to Y.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定相位的值，你必须进行一次额外的测量，这次是沿 *y* 轴。为此，你使用哈达玛门与 S dagger 门结合，以将量子比特移动到 Y 轴。
- en: The way you can visualize the changing of the measurement basis is to picture
    us rotating the qubit to match up with the axis we want to measure, and then do
    a standard Z measurement. When we measure along the *x* axis, we rotate the qubit
    to face in the ![](img/Formula_06_066.png) direction, and for the *y* axis to
    point, in the ![](img/Formula_06_156.png) direction.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过想象我们将量子比特旋转以匹配我们想要测量的轴，然后进行标准的 Z 轴测量来可视化测量基的变化。当我们沿 *x* 轴测量时，我们将量子比特旋转到面向
    ![](img/Formula_06_066.png) 方向，而对于 *y* 轴，则指向 ![](img/Formula_06_156.png) 方向。
- en: 'Here are the gate combinations that you need to apply to measure along the
    three Bloch sphere axes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是需要应用于测量三个玻尔球体轴的门的组合：
- en: '**Measure along z (computational basis):**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**沿 z 轴测量（计算基）：**'
- en: '![Figure 6.9 - Measure along z](img/Figure_6.9_B14436.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 - 沿 z 轴测量](img/Figure_6.9_B14436.jpg)'
- en: Figure 6.9 - Measure along z
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 - 沿 z 轴测量
- en: '**Measure along x:**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**沿 x 轴测量：**'
- en: '![Figure6.10 - Measure along x](img/Figure_6.10_B14436.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 - 沿 x 轴测量](img/Figure_6.10_B14436.jpg)'
- en: Figure6.10 - Measure along x
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 - 沿 x 轴测量
- en: '**Measure along y:**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**沿 y 轴测量：**'
- en: '![Figure 6.11 - Measure along y](img/Figure_6.11_B14436.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 - 沿 y 轴测量](img/Figure_6.11_B14436.jpg)'
- en: Figure 6.11 - Measure along y
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 - 沿 y 轴测量
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For an example of measuring along different axes to measure the phase of a qubit,
    see the *Exploring quantum phase kickback* recipe of [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关沿不同轴测量量子比特相位的示例，请参阅 *第 9 章* 的 *探索量子相位回冲* 菜谱 [[*第 9 章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)，*Grover
    的搜索算法*]。
- en: Fixed z rotations with phase shift gates S, ![](img/Formula_06_0681.png), T,
    and ![](img/Formula_06_0691.png)
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定 z 轴旋转与相位移位门 S、![img/Formula_06_0681.png]、T 和 ![img/Formula_06_0691.png]
- en: The S, ![](img/Formula_06_070.png), T, and ![](img/Formula_06_071.png) gates
    all perform rotations around the *z* axis of the qubit. This means that when you
    measure the qubit, there is no change in the probability of measuring the outcome
    as 1 or 0\. What does change is the phase of the qubit.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: S、![img/Formula_06_070.png]、T 和 ![img/Formula_06_071.png] 门都在量子比特的 *z* 轴周围进行旋转。这意味着当你测量量子比特时，测量结果为
    1 或 0 的概率不会发生变化。发生变化的是量子比特的相位。
- en: The S-gate and T-gate are not their own inverses
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: S 门和 T 门不是它们自己的逆
- en: As the S and T gates perform set rotations around the *z* axis, they are not
    reversible. Adding two of these gates in a row does not negate them. Instead,
    Qiskit includes the S† and T† gates which serve as the reverse S and T gates.
    For a quick reminder, see the *A quick introduction to quantum gates* recipe in
    [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing
    and Qubits with Python*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 S 门和 T 门在 *z* 轴周围进行固定旋转，它们是不可逆的。连续添加两个这样的门不会取消它们。相反，Qiskit 包含 S† 和 T† 门，它们作为逆
    S 和 T 门。为了快速回顾，请参阅 [*第 2 章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)，*使用
    Python 进行量子计算和量子比特* 中的 *快速介绍量子门* 菜谱。
- en: 'Mathematically, the S and T gates can be expressed as the following unitary
    matrixes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，S 门和 T 门可以表示为以下单位矩阵：
- en: '![](img/Formula_06_072.png) ![](img/Formula_06_073.png) ![](img/Formula_06_074.png)
    ![](img/Formula_06_075.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![img/Formula_06_072.png] ![img/Formula_06_073.png] ![img/Formula_06_074.png]
    ![img/Formula_06_075.png]'
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例脚本可在以下位置获取：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py)。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To explore the phase shift gates, we run the Quantum Gate UI program that is
    described in the *Visualizing quantum gates* recipe:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索相位移位门，我们运行了在 *可视化量子门* 菜谱中描述的量子门 UI 程序：
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ch6_r1_quantum_gate_ui.py` 示例程序。
- en: Select a start state for your qubit.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的量子比特选择一个起始状态。
- en: As these phase shift gates perform rotations around the *z* axis, there is very
    little point in using the default ![](img/Formula_06_0221.png) or ![](img/Formula_06_023.png)
    qubits, which are phaseless. Instead, pick a superposition state qubit such as
    **+**, **-**, **L**, **R**, **r**, or **d**.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这些相位移位门在 *z* 轴周围进行旋转，因此使用默认的 ![img/Formula_06_0221.png] 或 ![img/Formula_06_023.png]
    量子比特几乎没有意义，这些量子比特是无相的。相反，选择一个叠加态量子比特，例如 **+**、**-**、**L**、**R**、**r** 或 **d**。
- en: When prompted, enter `s`, `sdg`, `t`, or `tdg` to select the gate to test. The
    S gate on ![](img/Formula_06_078.png) should produce the following output:![Figure
    6.12 – The S gate with the  start state](img/Figure_6.12_B14436.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入 `s`、`sdg`、`t` 或 `tdg` 以选择要测试的门。![img/Formula_06_078.png] 上的 S 门应产生以下输出：![图
    6.12 – 具有起始状态的 S 门](img/Figure_6.12_B14436.jpg)
- en: Figure 6.12 – The S gate with the ![](img/Formula_06_079.png) start state
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 具有起始状态 ![img/Formula_06_079.png] 的 S 门
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The phase shift gates cannot run directly on a quantum backend, but are automatically
    transpiled to the following unitary basis gates before you run your program:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 相位移位门不能直接在量子后端上运行，但在你运行程序之前会自动编译成以下单位基门：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For more information, see the *Building our circuits with the basis gates –
    U1,U2, U3, and ID* and *What your quantum circuit really looks like* recipes in
    this chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅本章的 *使用基本门构建我们的电路 – U1、U2、U3 和 ID* 和 *你的量子电路真正看起来是什么样子* 菜谱。
- en: Free rotation around the axes with Rx, Ry, and Rz
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在轴周围进行自由旋转的 Rx、Ry 和 Rz
- en: While all the phase gates rotate around the *z* axis to change the phase of
    the qubit, the rotation gates perform rotations around the respective axes of
    the Bloch sphere. Rx and Ry rotate the qubit ![](img/Formula_06_015.png) angle
    at the phase angle (![](img/Formula_06_080.png)) 0 and ![](img/Formula_06_081.png)
    , and Rz rotates around Z, with the special case of ![](img/Formula_06_082.png)
    and ![](img/Formula_06_083.png), corresponding to the S and T gates.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有相移门都围绕 *z* 轴旋转以改变量子比特的相位，但旋转门在布洛赫球的相应轴周围进行旋转。Rx 和 Ry 在相位角 (![](img/Formula_06_080.png))
    0 和 ![](img/Formula_06_081.png) 处旋转量子比特 ![](img/Formula_06_015.png) 角度，而 Rz 围绕
    Z 旋转，特殊情况为 ![](img/Formula_06_082.png) 和 ![](img/Formula_06_083.png)，对应于 S 和 T
    门。
- en: The R-gates are not their own inverses
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: R 门不是它们自己的逆
- en: As the R-gates perform free rotations around the X, Y, or Z axes, they are not
    reversible. Adding two of these gates in a row does not negate them. For a quick
    reminder, see the *A quick introduction to quantum gates* recipe in [*Chapter
    2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing and Qubits
    with Python*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 R 门在 X、Y 或 Z 轴周围执行自由旋转，它们是不可逆的。连续添加两个这样的门不会抵消它们。为了快速回顾，请参阅[*第 2 章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)中的*快速介绍量子门*菜谱，*使用
    Python 进行量子计算和量子比特*。
- en: 'Mathematically, the R gates can be expressed as unitary matrixes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，R 门可以用单位矩阵表示：
- en: '![](img/Formula_06_084.jpg)![](img/Formula_06_085.jpg)![](img/Formula_06_086.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_084.jpg)![](img/Formula_06_085.jpg)![](img/Formula_06_086.jpg)'
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 样本脚本可在以下位置获取：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py)。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To explore the phase shift gates, we run the Quantum Gate program that is described
    in the *Visualizing the quantum gates* recipe:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索相移门，我们运行了在*可视化量子门*菜谱中描述的量子门程序：
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ch6_r1_quantum_gate_ui.py` 样本程序。
- en: Select a start state for your qubit.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的量子比特选择一个起始状态。
- en: The R gates perform arbitrary rotations around the corresponding axes.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R 门在相应的轴周围执行任意旋转。
- en: As all these gates perform rotations around the corresponding axes, play around
    with ![](img/Formula_06_087.png) to get a feel for what rotates where. Then test
    with Random or Define to explore more exotic rotations.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于所有这些门都在相应的轴周围进行旋转，请玩转 ![](img/Formula_06_087.png) 以获得对旋转位置的感觉。然后使用随机或定义来测试，以探索更多奇特的旋转。
- en: When prompted, enter `rx`, `ry`, or `rz` to select the gate to test.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入 `rx`、`ry` 或 `rz` 以选择要测试的门。
- en: Enter the angle (![](img/Formula_06_088.png)) with which to rotate. The Rx gate,
    set to ![](img/Formula_06_089.png) rotation on ![](img/Formula_06_090.png), should
    produce the following output:![Figure 6.13 – The Rx gate rotating  with the  start
    state](img/Figure_6.13_B14436.jpg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入旋转的角度 (![](img/Formula_06_088.png))。设置为 ![](img/Formula_06_089.png) 旋转的 Rx
    门在 ![](img/Formula_06_090.png) 上，应该产生以下输出：![图 6.13 – Rx 门以起始状态旋转](img/Figure_6.13_B14436.jpg)
- en: Figure 6.13 – The Rx gate rotating ![](img/Formula_06_091.png) with the ![](img/Formula_06_092.png)
    start state
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – Rx 门以 ![](img/Formula_06_091.png) 角度与 ![](img/Formula_06_092.png) 起始状态旋转
- en: 'Now, test again using various rotation angles to see the behavior by entering
    the following values for the ![](img/Formula_06_093.png) and/or ![](img/Formula_06_094.png)
    angles:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次使用不同的旋转角度进行测试，通过输入以下值来观察 ![](img/Formula_06_093.png) 和/或 ![](img/Formula_06_094.png)
    角度的行为：
- en: '![](img/Formula_06_095.jpg)![](img/Formula_06_096.jpg)![](img/Formula_06_097.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_095.jpg)![](img/Formula_06_096.jpg)![](img/Formula_06_097.jpg)'
- en: There's more...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The Pauli gates cannot run directly on a quantum backend, but are automatically
    transpiled to the following unitary basis gates before you run your program:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 保罗门不能直接在量子后端上运行，但在你运行程序之前会自动编译成以下单位基门：
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For more information, see the *Building our circuits with the basis gates –
    U1,U2, U3, and ID* and *What your quantum circuit really looks like* recipes in
    this chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅本章中的*使用基门构建我们的电路 – U1、U2、U3 和 ID*和*你的量子电路真正看起来是什么样子*菜谱。
- en: Building our circuits with the basis gates – U1, U2, U3, and ID
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基门构建我们的电路 – U1、U2、U3 和 ID
- en: Let's begin by exploring three of the gates that we recognize from [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit®*. You will not be using these three basis gates, U1, U2,
    and U3, in your quantum programs. However, they serve as building blocks for all
    other single-qubit gates when you run your circuits on a quantum computer. In
    fact, every other single-qubit gate can be written using just the U3 gate. There
    is nothing explicitly stopping you from using them, but the gate collection that
    we will go through in the rest of the recipes covers all the ground that we need.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索我们在 [*第 5 章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128) 中认识的三个门开始，*使用
    Qiskit® 探索 IBM Quantum® 硬件*。你不会在你的量子程序中使用这三个基础门，U1、U2 和 U3，但是当你在量子计算机上运行电路时，它们作为所有其他单量子比特门的构建块。实际上，每个其他单量子比特门都可以只用
    U3 门来表示。没有明确阻止你使用它们，但我们在后续食谱中将要介绍的门集合涵盖了我们需要的所有内容。
- en: The U gates are not their own inverses
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: U 门不是它们自己的逆
- en: As the U gates perform free rotations around the *x*, *y*, and *z* axes, they
    are generally not reversible. Adding two of these gates in a row does not negate
    them unless the rotations add up to complete rotations. For a quick reminder,
    see the *A quick introduction to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 U 门在 *x*、*y* 和 *z* 轴周围进行自由旋转，它们通常是不可逆的。连续添加两个这样的门不会取消它们，除非旋转的总和是完整的旋转。为了快速回顾，请参阅
    [*第 2 章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045) 中的 *A quick introduction
    to quantum gates* 食谱，*使用 Python 进行量子计算和量子比特*。
- en: 'If you remember back when we explored the IBM Quantum® backends in [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit®*, we took a look at the so-called **basis gates** available
    for the hardware backend using the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们在 [*第 5 章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128) 中探索 IBM
    Quantum® 后端时的情况，*使用 Qiskit® 探索 IBM Quantum® 硬件*，我们使用以下命令查看硬件后端可用的所谓 **基础门**：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It returned something like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的结果如下：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The CX and ID gates are ordinary gates that you use in your programs, UX (Controlled
    NOT) to create entanglements, and ID to run a gate that leaves the qubit untouched
    (more on these later). The U1, U2, and U3 gates are different though.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: CX 和 ID 门是你在程序中使用的普通门，UX（受控非）用于创建纠缠，ID 用于运行一个不改变量子比特状态的门（关于这些内容稍后会有更多介绍）。U1、U2
    和 U3 门则有所不同。
- en: Remember from [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, how we can see a quantum gate as a
    rotation around the ![](img/Formula_06_104.png) and ![](img/Formula_06_105.png)
    angles. This is exactly what the U gates do, with one, two, and three inputs respectively.
    In fact, single-qubit U-gate rotations and CNOT gates constitute a universal gate
    set for quantum computing. And here, the Id gate is a special case of rotation,
    with no rotation at all.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从 [*第 2 章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045) 中，*使用 Python 进行量子计算和量子比特*，我们如何将量子门视为在
    ![](img/Formula_06_104.png) 和 ![](img/Formula_06_105.png) 角度周围的旋转。这正是 U 门所做的事情，分别有一个、两个和三个输入。实际上，单量子比特
    U 门旋转和 CNOT 门构成了量子计算的通用门集。在这里，Id 门是旋转的特殊情况，完全没有旋转。
- en: The key thing with the basis gates is that you can program your qubits directly
    on the hardware using them. All other gates are translated into basis gates and
    then executed as you will see when we discuss the transpiler.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 基础门的关键在于，你可以直接在硬件上使用它们来编程你的量子比特。所有其他门都会被转换为基础门，然后按照你将在讨论编译器时看到的方式执行。
- en: The U3 gate
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U3 门
- en: 'The U3 gate is really the Swiss Army knife of quantum gates. It is the foundational
    unitary matrix for qubit manipulation. Every single-qubit manipulation that can
    be done can be done with the U3 gate, which can be expressed as the following
    unitary matrix:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: U3 门实际上是量子门的瑞士军刀。它是量子比特操作的基单位矩阵。可以完成的每个单量子比特操作都可以使用 U3 门来完成，它可以表示为以下单位矩阵：
- en: '![](img/Formula_06_106.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_106.jpg)'
- en: 'The three angles are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 三个角度如下：
- en: '![](img/Formula_06_093.png) = The polar angle between ![](img/Formula_06_0221.png)
    and the state vector'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/Formula_06_093.png) = 与状态向量之间的极角 ![](img/Formula_06_0221.png)'
- en: '![](img/Formula_06_109.png) = The longitudinal angle from the *x* axis (![](img/Formula_06_078.png))'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![](img/Formula_06_109.png) = 从 *x* 轴的纵向角度 (![](img/Formula_06_078.png))'
- en: '![](img/Formula_06_111.png) = The overall qubit phase angle (not visible on
    the Bloch sphere)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![](img/Formula_06_111.png) = 量子比特的总相位角（在Bloch球上不可见）'
- en: The U2 and U1 gates are basically specializations of U3, just like the other
    quantum gates are specializations of the U gates in general.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: U2门和U1门基本上是U3门的专业化，就像其他量子门是U门的一般专业化一样。
- en: The U2 gate
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U2门
- en: With the U2 gate, you can manipulate two angles at the same time. The U2 gate
    is the same as the U3 gate with ![](img/Formula_06_112.png).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用U2门，您可以同时操作两个角度。U2门与具有![](img/Formula_06_112.png)的U3门相同。
- en: 'The U2 gate can be expressed as the following unitary matrix:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: U2门可以用以下单位矩阵表示：
- en: '![](img/Formula_06_113.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_113.jpg)'
- en: The U1 gate
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U1门
- en: With the U1 gate, you can rotate the phase of the qubit around the *z* axis.
    A special case of the U1 is the Rz gate, which has the same input. The U1 gate
    is the same as the U3 gate with ![](img/Formula_06_114.png) and ![](img/Formula_06_115.png).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用U1门，您可以在*z*轴周围旋转量子比特的相位。U1的一个特殊情况是Rz门，它具有相同的输入。U1门与具有![](img/Formula_06_114.png)和![](img/Formula_06_115.png)的U3门相同。
- en: 'The U1 gate can be expressed as the following unitary matrix:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: U1门可以用以下单位矩阵表示：
- en: '![](img/Formula_06_116.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_116.jpg)'
- en: With these three gates, you can perform all possible single-qubit manipulations.
    They are not that user-friendly to read through and therefore Qiskit® includes
    translations of all relevant quantum gates for your programming ease. When you
    run your circuits, however, all the gates are translated into the collection of
    basis gates supported by the selected backend.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个门，您可以执行所有可能的单量子比特操作。它们在阅读上并不那么用户友好，因此Qiskit®包括所有相关量子门的翻译，以方便您的编程。然而，当您运行电路时，所有门都被翻译成所选后端支持的基门集合。
- en: 'The Pauli Id gate is a special gate that leaves the qubit in the same state
    as it was found. The gate can be expressed using the following matrix:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Pauli Id门是一种特殊的门，它使量子比特保持其原始状态。该门可以用以下矩阵表示：
- en: '![](img/Formula_06_117.png) = ![](img/Formula_06_118.png).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/Formula_06_117.png) = ![](img/Formula_06_118.png).'
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The code for the sample program is available here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r2_u_animation.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r2_u_animation.py).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 示例程序的代码在此处可用：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r2_u_animation.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r2_u_animation.py).
- en: In this recipe, we use the Pillow package to create, save, and merge images.
    For more information about Pillow, see [https://pypi.org/project/Pillow/](https://pypi.org/project/Pillow/).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用Pillow包来创建、保存和合并图像。有关Pillow的更多信息，请参阅[https://pypi.org/project/Pillow/](https://pypi.org/project/Pillow/).
- en: Installing Pillow
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Pillow
- en: 'If you need to install Pillow in your environment, you can use the following
    commands:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在环境中安装Pillow，可以使用以下命令：
- en: '`(environment_name) … $ pip install --upgrade pip`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`(环境名称) … $ pip install --upgrade pip`'
- en: '`(environment_name) … $ pip install --upgrade Pillow`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`(环境名称) … $ pip install --upgrade Pillow`'
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we will visualize the rotations of the U gates on a Bloch sphere.
    As you already know, we can use the `plot_bloch_multivector()` and `plot_state_qsphere()`
    methods to visualize how our state vectors behave and what the possible outcomes
    are. These both provide static views of the qubit at one moment and of the U gates
    for a specific set of angles.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将可视化U门在Bloch球上的旋转。如您所知，我们可以使用`plot_bloch_multivector()`和`plot_state_qsphere()`方法来可视化我们的状态矢量的行为以及可能的输出。这两个方法都提供了在某一时刻量子比特和特定角度集的U门的静态视图。
- en: In the sample program, you enter the angles input for your U gates, after which
    the program takes snapshots between 0 and the angle at a given resolution and
    produces an animated GIF that shows the movement of the qubit state vector on
    the Bloch sphere.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例程序中，您输入U门的角输入，然后程序在0和给定分辨率的角度之间进行快照，并生成一个动画GIF，显示量子比特状态矢量在Bloch球上的移动。
- en: 'Note that this animation doesn''t really show you how a qubit vector moves
    when you apply the gate, but rather gives a view of how you can use the U gates
    to position your qubit state vector wherever you want:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个动画并没有真正展示您应用门时量子比特矢量的移动方式，而是展示了如何使用U门将量子比特状态矢量定位到您想要的位置：
- en: Start by running the `ch6_r2_u_animation.py` script in your Python environment.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的 Python 环境中运行 `ch6_r2_u_animation.py` 脚本。
- en: 'At the prompts, enter the type of gate that you want to test, and then enter
    the required input angles for the gate. For the U3 gate, your input might look
    like this for ![](img/Formula_06_119.png):'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示下，输入你想要测试的门类型，然后输入该门所需的输入角度。对于 U3 门，你的输入可能如下所示，对于 ![](img/Formula_06_119.png)：
- en: '[PRE22]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the background, we are now calling the `create_images()` function, which
    takes the input you provided and then iteratively creates a set of circuits that
    iteratively apply the U gate you selected with the input angles divided into smaller
    angles as dictated by the *steps* parameter. Each circuit is then run through
    the statevector simulator in the `get_psi()` function that we created in the first
    recipe, *Visualizing the quantum gates*, and is finally saved as a Bloch sphere
    image and a Q-sphere image using `plot_bloch_multivector()` and `plot_state_qsphere()`.
    The images are continuously appended to two lists that will later be merged into
    an animation.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在后台，我们现在调用 `create_images()` 函数，该函数接收你提供的输入，然后迭代创建一系列电路，这些电路迭代应用你选择的 U 门，输入角度被分成更小的角度，这由
    *steps* 参数决定。然后，每个电路通过我们在第一个菜谱“可视化量子门”中创建的 `get_psi()` 函数中的状态向量模拟器运行，并最终使用 `plot_bloch_multivector()`
    和 `plot_state_qsphere()` 将其保存为 Bloch 球图像和 Q 球图像。这些图像持续追加到两个列表中，稍后将合并成动画。
- en: Here's how we build the function.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是我们构建函数的方法。
- en: 'Start by setting the input parameters and all internal function variables:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，设置输入参数和所有内部函数变量：
- en: '[PRE23]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then create the image and animation tools:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后创建图像和动画工具：
- en: '[PRE24]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, run the image creation loop based on the input parameters:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，根据输入参数运行图像创建循环：
- en: '[PRE25]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Create and save the animated GIFs.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并保存动画 GIF。
- en: 'The final step is to create the GIFs. Here we use the `save_gif(gate)` function
    to iterate through the image lists we created and let Pillow build the GIFs with
    our initial parameters. This is what we do:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步是创建 GIF。在这里，我们使用 `save_gif(gate)` 函数迭代我们创建的图像列表，让 Pillow 使用我们的初始参数构建 GIF。这是我们所做的：
- en: '[PRE26]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The final Python output might look like this:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的 Python 输出可能如下所示：
- en: '[PRE27]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The final result will be two animated GIFs saved in the same directory as where
    you run your script.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终结果将是两个保存在你运行脚本相同目录下的动画 GIF。
- en: 'You can now open the GIFs in an image viewer or web browser to take a look:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你可以在图像查看器或网页浏览器中打开 GIF，查看一下：
- en: '![Figure 6.14 – Still of animated GIFs of a Bloch sphere and a Q-sphere'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.14 – 动画 GIF 的静态图像，展示 Bloch 球和 Q 球'
- en: '](img/Figure_6.14_B14436.jpg)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_6.14_B14436.jpg)'
- en: Figure 6.14 – Still of animated GIFs of a Bloch sphere and a Q-sphere
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 动画 GIF 的静态图像，展示 Bloch 球和 Q 球
- en: If you view the animated GIFs side by side and synchronized, the Q-sphere representation
    shows the relative probabilities and phase angle of the qubit as the U gate is
    applied to it. Play around with different angles and different loop parameters
    to see how you can make the animations work for you.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你并排同步查看动画 GIF，Q 球表示法将显示在 U 门应用于其上的量子比特的相对概率和相位角。尝试不同的角度和不同的循环参数，看看你如何使动画为你所用。
- en: If you set the angles in the range of 0 to ![](img/Formula_06_123.png) and set
    your steps to a reasonably high number, you can create nice smooth looping effects.
    There is nothing stopping you from setting the angles really high though, which
    will result in fairly chaotic behavior in the animations. Have fun!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将角度设置在 0 到 ![](img/Formula_06_123.png) 的范围内，并将你的步骤设置为合理的较高数值，你可以创建出漂亮的平滑循环效果。尽管如此，你完全可以设置非常高的角度，这将导致动画中出现相当混乱的行为。祝您玩得开心！
- en: 'When you test the U gates with the script, remember the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用脚本测试 U 门时，请记住以下几点：
- en: U3 lets you point the qubit vector anywhere on the Bloch sphere using two angles,
    ![](img/Formula_06_124.png) and ![](img/Formula_06_125.png). The third angle,
    ![](img/Formula_06_111.png), has no effect on the Bloch sphere representation.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U3 允许你使用两个角度，![](img/Formula_06_124.png) 和 ![](img/Formula_06_125.png)，将量子比特向量指向
    Bloch 球上的任何位置。第三个角度，![](img/Formula_06_111.png)，对 Bloch 球表示没有影响。
- en: U2 is the same as U3 but with ![](img/Formula_06_015.png) set to ![](img/Formula_06_128.png)
    , which places the qubit vector on the equator.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U2 与 U3 相同，但将 ![](img/Formula_06_015.png) 设置为 ![](img/Formula_06_128.png) ，这会将量子比特向量放置在赤道上。
- en: U1 is the same as U3 but with both ![](img/Formula_06_124.png) and ![](img/Formula_06_130.png)
    set to 0\. A special case of U1 is Rz.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U1 与 U3 相同，但将 ![](img/Formula_06_124.png) 和 ![](img/Formula_06_130.png) 都设置为
    0。U1 的一个特殊情况是 Rz。
- en: There's more...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Well, in this case, there's less not more. The sample script in this recipe
    will work in your local environment, but not very well in your IBM Quantum Experience®
    notebook environment as you do not have access to the underlying filesystem.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在这种情况下，是少而不是多。本菜谱中的示例脚本将在你的本地环境中工作，但在你的 IBM Quantum Experience® 笔记本环境中效果不佳，因为你无法访问底层文件系统。
- en: Using gates on 2 qubits
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 2 个量子位上使用门
- en: Two-qubit gates such as controlled gates are slightly different from ordinary
    1-qubit gates; they let you create interaction between your qubits. In general,
    this translates into using 1 qubit as the control qubit, and the other as the
    acted-on qubit. Mathematically, this is not super complex, but intuitively you
    might have to think once or twice about what is going on.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 双量子位门，如控制门，与普通单量子位门略有不同；它们允许你在量子位之间创建交互。一般来说，这相当于使用一个量子位作为控制量子位，另一个作为作用量子位。从数学上来说，这并不特别复杂，但直观上你可能需要思考一两次才能理解正在发生的事情。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The first 2-qubit gate that we'll touch on is the Controlled-NOT gate that we
    saw in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting
    at the Ground Level with Terra*. The CX gate is generally used to create entanglement
    between qubits if the control qubit is in a superposition.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要接触的第一个双量子位门是我们在 [*第 4 章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)
    中看到的控制非门，*从 Terra 的基态开始*。CX 门通常用于在控制量子位处于叠加态时在量子位之间创建纠缠。
- en: 'A CX gate where the controlling qubit is the second qubit and the controlled
    qubit the first can be expressed as the following matrix:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制量子位是第二个量子位，受控量子位是第一个量子位时，CX 门可以表示为以下矩阵：
- en: '![](img/Formula_06_131.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![img/Formula_06_131.jpg](img/Formula_06_131.jpg)'
- en: 'This corresponds to the following circuit:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于以下电路：
- en: '![Figure 6.15 – CX gate from q_1 to q_0'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.15 – CX 门从 q_1 到 q_0]'
- en: '](img/Figure_6.15_B14436.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.15 – 从 q_1 到 q_0 的 CX 门](img/Figure_6.15_B14436.jpg)'
- en: Figure 6.15 – CX gate from q_1 to q_0
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 从 q_1 到 q_0 的 CX 门
- en: The way you interpret this is to run the first or controlling qubit through
    an Id gate, leaving it untouched. The second, or controlled, qubit applies an
    X gate if the first qubit is 1.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这个方法的方式是运行第一个或控制量子位通过一个 Id 门，使其保持不变。第二个，或受控，量子位如果第一个量子位是 1，则应用一个 X 门。
- en: 'Here are two matrix calculations to demonstrate:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个矩阵计算来演示：
- en: '![](img/Formula_06_132.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![img/Formula_06_132.jpg](img/Formula_06_132.jpg)'
- en: 'Here, the first qubit is 1 and the second 0\. The result is both qubits in
    1:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个量子位是 1，第二个是 0。结果是两个量子位都是 1：
- en: '![](img/Formula_06_133.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![img/Formula_06_133.jpg](img/Formula_06_133.jpg)'
- en: Here, both qubits are 1\. The result is the first qubit is 1 and the second
    is 0.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个量子位都是 1。结果是第一个量子位是 1，第二个是 0。
- en: The CX gate is one of the basis gates of the IBM Quantum® backends.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: CX 门是 IBM Quantum® 后端的基本门之一。
- en: Other CX matrices
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 CX 矩阵
- en: 'If the CX gate points the other way, with the first qubit as the controlling
    qubit, the matrix will look like this instead:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CX 门的方向相反，第一个量子位作为控制量子位，矩阵将看起来像这样：
- en: '![](img/Formula_06_134.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![img/Formula_06_134.png](img/Formula_06_134.png)'
- en: To convince yourself, do the calculation. For a quick refresher, see the *A
    quick introduction to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你确信，请进行计算。为了快速复习，请参阅 [*第 2 章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)
    中的 *快速量子门简介* 菜谱，*使用 Python 进行量子计算和量子位*。
- en: 'The sample script is available at: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 样本脚本可在以下网址获取：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py).
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Earlier, for the single-qubit gates, the Quantum Gate program set up a plain
    quantum circuit with one qubit initiated in the ground state ![](img/Formula_06_0221.png).
    When we start playing with multi-qubit gates, the program will initialize with
    both qubits in ![](img/Formula_06_0221.png). The gate selected is then run on
    the circuit, and results in the form of a qubit state vector and the gate unitary
    matrix are displayed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，对于单量子位门，量子门程序设置了一个只有一个量子位处于基态的简单量子电路 ![img/Formula_06_0221.png](img/Formula_06_0221.png)。当我们开始使用多量子位门时，程序将以两个量子位都处于
    ![img/Formula_06_0221.png](img/Formula_06_0221.png) 的状态初始化。然后，选定的门将在电路中运行，并以量子位状态向量和门单位矩阵的形式显示结果。
- en: 'To explore the control gates, we run the Quantum Gate program that is described
    in the *Visualizing quantum gates* recipe:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索控制门，我们运行了*可视化量子门*配方中描述的量子门程序：
- en: Run the `ch6_r1_quantum_gate_ui.py` sample program.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ch6_r1_quantum_gate_ui.py`示例程序。
- en: Select a start state for your controlling qubit.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的控制量子比特选择一个起始状态。
- en: The Cn gates use a single qubit as the controlling qubit and the other qubit
    as the controlled qubit. If the state of the controlling qubit is anything other
    than ![](img/Formula_06_0221.png), some action will be performed on the controlled
    qubit.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cn门使用单个量子比特作为控制量子比特，其他量子比特作为受控量子比特。如果控制量子比特的状态不是![公式_06_0221.png](img/Formula_06_0221.png)，则会在受控量子比特上执行一些操作。
- en: If you want to, then you can start by testing with ![](img/Formula_06_0221.png)—just
    to verify that no action is performed and that the 2-qubit state doesn't change.
    Then test with start state ![](img/Formula_06_139.png) to create a Bell state,
    as we did in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting
    at the Ground Level with Terra*. After you are done with this, play around with
    ![](img/Formula_06_140.png), Random or Define to explore other control states.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想的话，可以先使用![公式_06_0221.png](img/Formula_06_0221.png)进行测试——只是为了验证没有执行任何操作，并且2量子比特的状态没有改变。然后使用起始状态![公式_06_139.png](img/Formula_06_139.png)来创建贝尔态，就像我们在[*第4章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)中做的那样，*从Terra的起点开始*。完成这些后，尝试使用![公式_06_140.png](img/Formula_06_140.png)、随机或定义来探索其他控制状态。
- en: When prompted, enter `cx`, `cy`, `cz`, or `ch` to select the gate to test. For
    example, a CX gate with the controlling qubit state ![](img/Formula_06_078.png)
    will generate the following output:![Figure 6.16 – CX gate with the start state
    |+>
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入`cx`、`cy`、`cz`或`ch`以选择要测试的门。例如，控制量子比特状态![公式_06_078.png](img/Formula_06_078.png)的CX门将生成以下输出：![图6.16
    – CX门与起始状态|+>
- en: '](img/Figure_6.16_B14436.jpg)'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.16_B14436.jpg](img/Figure_6.16_B14436.jpg)'
- en: Figure 6.16 – CX gate with the start state |+>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – CX门与起始状态|+>
- en: Here, notice that the Bloch sphere representation makes no sense after the CX
    gate has been applied. The qubits are now entangled, and we can get no further
    individual information from them. In this case, we display the Q-sphere interpretation
    for clarification, where the initial Q-sphere indicates equal probabilities of
    getting states ![](img/Formula_06_142.png) and ![](img/Formula_06_143.png), and
    after the X gate, equal probabilities of getting ![](img/Formula_06_144.png),
    as expected for a Bell state.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请注意，在应用CX门之后，Bloch球表示没有意义。量子比特现在是纠缠的，我们无法从它们那里获取更多的单个信息。在这种情况下，我们显示Q球解释以供说明，其中初始Q球表示得到状态![公式_06_142.png](img/Formula_06_142.png)和![公式_06_143.png](img/Formula_06_143.png)的概率相等，在X门之后，得到![公式_06_144.png](img/Formula_06_144.png)的概率相等，这是贝尔态所预期的。
- en: How it works...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The CX gate is just one of many possible two-qubit control gates. Among the
    others built into Qiskit® are the CY and CZ gates:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: CX门只是许多可能的二量子比特控制门之一。在Qiskit®中内置的其他门还包括CY和CZ门：
- en: '![](img/Formula_06_145.jpg)![](img/Formula_06_146.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![公式_06_145.jpg](img/Formula_06_145.jpg)![公式_06_146.jpg](img/Formula_06_146.jpg)'
- en: Or why not a controlled Hadamard gate?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 或者为什么不试试受控Hadamard门？
- en: '![](img/Formula_06_147.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![公式_06_147.jpg](img/Formula_06_147.jpg)'
- en: 'Another handy 2-qubit gate is the SWAP gate that swaps the value of the first
    and second qubit. In this case, there is no entanglement and the individual qubits
    remain individuals:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实用的2量子比特门是SWAP门，它交换第一个和第二个量子比特的值。在这种情况下，没有纠缠，单个量子比特保持独立：
- en: '![](img/Formula_06_148.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![公式_06_148.jpg](img/Formula_06_148.jpg)'
- en: There's more...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The two-qubit gates can also be written as a combination of basis gates. For
    example, this is how you can code the CY gate:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 双量子比特门也可以写成基门组合的形式。例如，这是如何编码CY门的：
- en: '[PRE28]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For more information, and to test-transpile the other Cn gates, see the *What
    your quantum circuit really looks like* recipe.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息和测试转换其他Cn门，请参阅*你的量子电路真正看起来是什么样子*配方。
- en: See also
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Quantum Computation and Quantum Information*, 10th Anniversary Edition, Michael
    A. Nielsen & Isaac L. Chuang, *Chapter 4.3 Controlled operations*.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 《量子计算与量子信息》，第10周年纪念版，迈克尔·A·尼尔森与艾萨克·L·丘恩，*第4.3节受控操作*。
- en: Using gates on more than 2 qubits
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超过2个量子比特的门
- en: In addition to the single-qubit and two-qubit gates, Qiskit® also supports 3-
    and more qubit gates. We will use one of them, the Toffoli gate when we build
    the 3-qubit Grover search algorithm circuit in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*. We are including the Fredkin gate for completeness
    and will not be using it in any other examples; feel free to try it out.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单量子比特和双量子比特门之外，Qiskit® 还支持 3 个和更多量子比特的门。当我们构建第 9 章 [*“Grover 搜索算法”*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)
    中的 3 量子比特 Grover 搜索算法电路时，我们将使用其中之一，即 Toffoli 门。为了完整性，我们将包括 Fredkin 门，但不会在其他示例中使用它；请随意尝试。
- en: 'The multi-qubit gates in this recipe use 2, more, and 1 controlling qubit respectively:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的多量子比特门分别使用 2、更多和 1 个控制量子比特：
- en: '**Toffoli**: Controlled-controlled NOT (**CCX**), which takes 2 qubits as input
    and flips the third if both controlling qubits are set.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Toffoli**：受控受控非（**CCX**），它接受 2 个量子比特作为输入，如果两个控制量子比特都被设置，则翻转第三个量子比特。'
- en: '**MCX**: Multi-controlled NOT takes a number of qubits (controlling) as input
    and flips the controlled qubit if all are set.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MCX**：多控制非接受多个量子比特（控制）作为输入，如果所有量子比特都被设置，则翻转受控量子比特。'
- en: There is (in principle) no limit to the number of controlling qubits that you
    can use with your gates. In the 4- and more qubit Grover search algorithm circuit
    in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)*, Grover's Search
    Algorithm*, we build a 4-qubit **CCCX** **controlled-controlled-controlled** gate
    by using the **MCX** gate.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （原则上）你使用的控制量子比特的数量没有限制。在 4 个或更多量子比特的 Grover 搜索算法电路中 [*第 9 章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)，“Grover
    搜索算法”，我们通过使用 **MCX** 门构建了一个 4 量子比特的 **CCCX** **受控受控受控** 门。
- en: '**Fredkin**: Controlled SWAP, (**CSWAP**), which takes a single qubit as input
    and swaps the other two if the controlling qubit is set.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fredkin**：受控交换，(**CSWAP**)，它接受单个量子比特作为输入，如果控制量子比特被设置，则交换其他两个量子比特。'
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In your quantum programs, use the following sample code to implement these 3-qubit
    gates.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的量子程序中，使用以下示例代码来实现这些 3 量子比特门。
- en: Toffoli
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Toffoli
- en: 'The Toffoli or **CCX** gate is represented by the following unitary matrix
    with the second and third qubits controlling the first qubit:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Toffoli 或 **CCX** 门由以下单位矩阵表示，其中第二个和第三个量子比特控制第一个量子比特：
- en: '![](img/Formula_06_149.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_149.jpg)'
- en: 'The following code implements the CCX gate:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了 CCX 门：
- en: '[PRE29]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the circuit looks like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 电路看起来是这样的：
- en: '![Figure 6.17 – The Toffoli gate'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.17 – Toffoli 门](img/Figure_6.17_B14436.jpg)'
- en: '](img/Figure_6.17_B14436.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.17_B14436.jpg)'
- en: Figure 6.17 – The Toffoli gate
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – Toffoli 门
- en: Other CCX matrixes
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 CCX 矩阵
- en: 'Just like for the CX gate, the matrix will look different depending on which
    qubits you should use to control. For example, here is the matrix for a CCX gate
    where the first and second qubits control the third:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 CX 门一样，矩阵将根据你应该使用哪些量子比特来控制而有所不同。例如，这里是一个 CCX 门，其中第一个和第二个量子比特控制第三个量子比特的矩阵：
- en: '![](img/Formula_06_150.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_150.png)'
- en: To convince yourself, do the calculation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说服自己，做一下计算。
- en: MCX
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MCX
- en: The MCX gate is used to build general controlled-NOT gates with more than one
    controlling gate. The Toffoli (CCX) gate is a special example where this is an
    already coded gate. For controlled-NOT gates with more than 2 controlling qubits,
    you can use the MCX gate.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: MCX 门用于构建具有一个以上控制门的通用受控非门。Toffoli（CCX）门是一个特殊例子，其中这是一个已经编码的门。对于具有超过 2 个控制量子比特的受控非门，你可以使用
    MCX 门。
- en: 'The following code implements the MCX gate as a CCCX gate with second, third,
    and fourth qubits controlling the first qubit:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了 MCX 门作为 CCCX 门，其中第二个、第三个和第四个量子比特控制第一个量子比特：
- en: '[PRE30]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And the circuit looks like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 电路看起来是这样的：
- en: '![Figure 6.18 – The MCX gate for 3 controlling qubits (CCCX)](img/Figure_6.18_B14436.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.18 – 3 个控制量子比特的 MCX 门（CCCX）](img/Figure_6.18_B14436.jpg)'
- en: Figure 6.18 – The MCX gate for 3 controlling qubits (CCCX)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 3 个控制量子比特的 MCX 门（CCCX）
- en: Fredkin
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fredkin
- en: 'The Fredkin or **CSWAP** gate is represented by the following unitary matrix
    with the controlling third qubit swapping the first and second qubits:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Fredkin 或 **CSWAP** 门由以下单位矩阵表示，其中控制第三个量子比特交换第一个和第二个量子比特：
- en: '![](img/Formula_06_151.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_06_151.jpg)'
- en: 'The following code implements the CSWAP gate:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了 CSWAP 门：
- en: '[PRE31]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And the circuit looks like this:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 电路看起来是这样的：
- en: '![Figure 6.19 – The Fredkin gate'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19 – Fredkin 门](img/Figure_6.19_B14436.jpg)'
- en: '](img/Figure_6.19_B14436.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.19_B14436.jpg)'
- en: Figure 6.19 – The Fredkin gate
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – Fredkin 门
- en: There's more...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Just like the other gates that we have looked at in this chapter, the Toffoli
    and Fredkin gates are included with the basic set of Qiskit® gates. However, they
    are not basis gates, which means that they need to be rewritten using a set of
    basis gates, such as **u1**, **u2**, **u3**, **id**, and **cx**. This is called
    **transpiling** and is what we will be doing in the next recipe, *What your quantum
    circuit really looks like*. But we're jumping ahead just a little here and displaying
    the complexity of constructing these alluringly simple gates. Do try them out
    in the next recipe.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本章中查看的其他门一样，Toffoli 和 Fredkin 门包含在 Qiskit® 的基本门集中。然而，它们不是基本门，这意味着它们需要使用一组基本门（如
    **u1**、**u2**、**u3**、**id** 和 **cx**）重写。这被称为 **转换**，这是我们将在下一道菜谱“你的量子电路真正看起来是什么样子”中要做的。但在这里我们只是稍微提前了一点，展示了构建这些看似简单的门的复杂性。请尝试在下一道菜谱中尝试它们。
- en: Toffoli constructed from basis gates
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 由基本门构建的 Toffoli
- en: 'The Toffoli gate can be entered as a single gate in Qiskit®, which leads you
    to believe that the execution of the gate will correspond to *a single time step*
    just like the other gates:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Toffoli 门可以在 Qiskit® 中作为一个单独的门输入，这让你相信门的执行将对应于 *单个时间步*，就像其他门一样：
- en: '![Figure 6.20 – A single Toffoli gate built from 10+ basis gates'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.20 – 由 10+ 个基本门构建的单个 Toffoli 门'
- en: '](img/Figure_6.20_B14436.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.20_B14436.jpg)'
- en: Figure 6.20 – A single Toffoli gate built from 10+ basis gates
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 由 10+ 个基本门构建的单个 Toffoli 门
- en: When we unravel the CCX like this, we see that the truth is slightly worse than
    just one time step; the single gate is translated into a circuit depth of 11.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样解开 CCX 时，我们看到事实略逊于仅仅一个时间步；单个门被转换成电路深度为 11。
- en: Fredkin constructed from basis gates
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 由基本门构建的 Fredkin
- en: 'Much like the Toffoli gate, Fredkin might be transpiled into a large number
    of basis gates when executed on a hardware backend:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Toffoli 门类似，当在硬件后端执行时，Fredkin 可能会被转换成大量基本门：
- en: '![Figure 6.21 – A single Fredkin gate built from 20+ basis gates'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.21 – 由 20+ 个基本门构建的单个 Fredkin 门'
- en: '](img/Figure_6.21_B14436.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.21_B14436.jpg)'
- en: Figure 6.21 – A single Fredkin gate built from 20+ basis gates
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 由 20+ 个基本门构建的单个 Fredkin 门
- en: For a single Fredkin gate, the circuit depth goes from 1 to 22\. Not everything
    is easy to do on a quantum computer.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个 Fredkin 门，电路深度从 1 到 22。在量子计算机上并非所有事情都容易做到。
- en: What your quantum circuit really looks like
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的量子电路真正看起来是什么样子
- en: In [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063), *IBM Quantum
    Experience® – Quantum Drag and Drop*, and [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit®*, we touched on the concept of
    `u1`, `u2`, `u3`, `id`, and `cx`. We discussed these gates in the previous recipes
    of this chapter and even listed how the other gates can be written as implementations
    or combinations of these.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)，*IBM Quantum Experience®
    – Quantum Drag and Drop* 和 [*第 5 章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)，*使用
    Qiskit® 探索 IBM Quantum® 硬件*，我们提到了 `u1`、`u2`、`u3`、`id` 和 `cx` 的概念。我们在本章前面的菜谱中讨论了这些门，甚至列出了其他门如何作为这些门的实现或组合。
- en: 'In this recipe, we will take a look at some other aspects of the transpiling
    of circuits, such as the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这道菜谱中，我们将探讨电路转换的其他一些方面，例如以下内容：
- en: Simple transpiling of common gates to basis gates
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将常用门简单地转换为基本门
- en: Transpiling for a simulator
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为模拟器进行转换
- en: Transpiling your circuit if it doesn't match the physical layout of the backend
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的电路与后端物理布局不匹配，则进行电路转换
- en: One-qubit backend basis gates
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单量子比特后端基本门
- en: 'Most IBM Quantum® backends have the following basis gates: `u1`, `u2`, `u3`,
    `id`, and `cx`. One-qubit backends such as `ibmq_armonk` have no use for multi-qubit
    gates such as CX, which is not included. If you set your backend to `ibmq_armonk`
    and run the following command, you will get the corresponding output:`>>> backend.configuration().basis_gates
    Out: [''id'', ''u1'', ''u2'', ''u3'']`.'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '大多数 IBM Quantum® 后端都有以下基本门：`u1`、`u2`、`u3`、`id` 和 `cx`。单量子比特后端（如 `ibmq_armonk`）不需要多量子比特门（如
    CX），它不包括在内。如果你将后端设置为 `ibmq_armonk` 并运行以下命令，你将得到相应的输出：`>>> backend.configuration().basis_gates
    Out: [''id'', ''u1'', ''u2'', ''u3'']`。'
- en: When we execute a quantum program on an IBM quantum computer, our code is first
    transpiled down to the core basis gates (`u1`, `u2`, `u3`, `id`, and `cx`) that
    we can execute directly on the hardware.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 IBM 量子计算机上执行量子程序时，我们的代码首先被转换成我们可以在硬件上直接执行的核基本门（`u1`、`u2`、`u3`、`id` 和 `cx`）。
- en: Getting ready
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r3_transpiler.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r3_transpiler.py).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的食谱中所需的文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r3_transpiler.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r3_transpiler.py)。
- en: 'This is how we build our Python sample:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们构建Python示例的方法：
- en: 'First, we import the needed classes and methods, including `transpile`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类和方法，包括`transpile`：
- en: '[PRE32]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We also load our account, if needed, and set up a backend with `5` qubits:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还加载了我们的账户（如果需要），并使用`5`个量子比特设置了一个后端：
- en: '[PRE33]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s take a look at the basis gates and coupling map for the selected backend.
    The coupling map specifies the possible qubit connections for two-qubit circuits:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看所选后端的基本门和耦合图。耦合图指定了双量子比特电路可能的量子比特连接：
- en: '[PRE34]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code should result in an output similar to the following:'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码应该产生类似于以下输出的结果：
- en: '![Figure 6.22 – Basis gates and CX coupling map for a backend'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 6.22 – 后端的基本门和CX耦合图'
- en: '](img/Figure_6.22_B14436.jpg)'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_6.22_B14436.jpg](img/Figure_6.22_B14436.jpg)'
- en: Figure 6.22 – Basis gates and CX coupling map for a backend
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.22 – 后端的基本门和CX耦合图
- en: For a single qubit gates transpiling, the coupling map is not important. This
    changes when we write quantum programs that use two-qubit gates.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于单量子比特门的转换，耦合图并不重要。当我们编写使用双量子比特门的量子程序时，情况就不同了。
- en: 'We then set up the `build_circuit()` function to create a basic circuit, and
    selectively add gates to it depending on what circuit we want to explore:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置`build_circuit()`函数来创建一个基本电路，并根据我们想要探索的电路选择性地添加门：
- en: '[PRE35]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, we set up the `main()` function to run the circuit.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们设置了`main()`函数来运行电路。
- en: 'The main function prompts for a circuit to test, calls the `build_circuit()`
    function, transpiles the returned circuit using the `transpile()` class, and then
    displays the results:'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主函数提示输入要测试的电路，调用`build_circuit()`函数，使用`transpile()`类转换返回的电路，然后显示结果：
- en: '[PRE36]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it…
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s build and transpile a simple X circuit:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并转换一个简单的X电路：
- en: In your Python environment, run `ch6_r3_transpiler.py`.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Python环境中运行`ch6_r3_transpiler.py`。
- en: When prompted, enter `1` to pick the `Simple` `X` circuit:![Figure 6.23 – First,
    select the Simple X circuit
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入`1`以选择`Simple` `X`电路：![Figure 6.23 – 首先，选择Simple X电路
- en: '](img/Figure_6.23_B14436.jpg)'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_6.23_B14436.jpg](img/Figure_6.23_B14436.jpg)'
- en: Figure 6.23 – First, select the Simple X circuit
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.23 – 首先，选择Simple X电路
- en: The code should result in an output similar to this:![Figure 6.24 – The output
    of the simple, single X gate circuit](img/Figure_6.24_B14436.jpg)
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码应该产生类似于以下输出的结果：![Figure 6.24 – 简单的单X门电路的输出](img/Figure_6.24_B14436.jpg)
- en: Figure 6.24 – The output of the simple, single X gate circuit
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.24 – 简单的单X门电路的输出
- en: The resulting circuit looks pretty similar. The only real change is that the
    X gate is now a U3 gate, one of the basis gates.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果电路看起来相当相似。唯一真正的变化是X门现在是一个U3门，即基本门之一。
- en: We can get a numerical result as well, by pulling out the circuit depths and
    sizes for the circuit and the transpiled circuit.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过提取电路及其转换电路的深度和大小来获得数值结果。
- en: 'This code should result in the following circuit depths and sizes:'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码应该产生以下电路深度和大小：
- en: '![Figure 6.25 – Circuit depth and size](img/Figure_6.25_B14436.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 6.25 – 电路深度和大小](img/Figure_6.25_B14436.jpg)'
- en: Figure 6.25 – Circuit depth and size
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 – 电路深度和大小
- en: Here, depth means the number of end-to-end steps that the quantum computer has
    to execute. Each step might include one or more gates, depending on the layout
    of the circuit. The size is just the total number of gates that are executed.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，深度指的是量子计算机必须执行的端到端步骤的数量。每一步可能包括一个或多个门，具体取决于电路的布局。大小只是执行的总门数。
- en: For this very simple circuit transpiling, there isn't much of a change. The
    U3 gate performs the required rotation around the *x* axis, and the circuit depth
    and size are the same. Technically, you could use the U3 gate instead of the X
    gate in your code, but it would be much less transparent.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个非常简单的电路转换，变化不大。U3门执行围绕*x*轴所需的旋转，电路的深度和大小保持不变。技术上，你可以在代码中使用U3门而不是X门，但这样会不太透明。
- en: Transpiling for a simulator?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 为模拟器转换？
- en: 'So, what happens if you try transpiling your circuits for a simulator backend?
    As it turns out, the simulator includes many more basis gates than the hardware
    backends, so the transpiling will be different. To test this, simply uncomment
    the following line in the script to set the backend to a simulator and run the
    program again:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你尝试为模拟后端转换你的电路会发生什么？实际上，模拟器包含的基门比硬件后端要多得多，因此转换会有所不同。为了测试这一点，只需在脚本中取消以下行的注释，将后端设置为模拟器，然后再次运行程序：
- en: '`backend = provider.get_backend(''ibmq_qasm_simulator'')`'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`backend = provider.get_backend(''ibmq_qasm_simulator'')`'
- en: 'The `ibmq_qasm_simulator` supports the following basis gates:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`ibmq_qasm_simulator` 支持以下基门：'
- en: '`[''u1'', ''u2'', ''u3'', ''cx'', ''cz'', ''id'', ''x'', ''y'', ''z'', ''h'',
    ''s'', ''sdg'', ''t'', ''tdg'', ''ccx'', ''swap'', ''unitary'', ''initialize'',
    ''kraus'']`'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`[''u1'', ''u2'', ''u3'', ''cx'', ''cz'', ''id'', ''x'', ''y'', ''z'', ''h'',
    ''s'', ''sdg'', ''t'', ''tdg'', ''ccx'', ''swap'', ''unitary'', ''initialize'',
    ''kraus'']`'
- en: 'That said, you can provide additional parameters when running the transpiler,
    such as `basis_gates` and `coupling_map` to define the basis gates that you want
    to use and specify how the qubits are connected for use when transpiling for multi-qubit
    gates. We will not go into any details about that in this chapter, but take a
    look at the Qiskit® help for more info:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你可以在运行转换器时提供额外的参数，例如 `basis_gates` 和 `coupling_map`，以定义你想要使用的基门，并指定量子比特如何连接，以便在转换多量子比特门时使用。我们在这章中不会深入探讨这一点，但可以查看
    Qiskit® 帮助以获取更多信息：
- en: '`>>> from qiskit.compiler import transpile`'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> from qiskit.compiler import transpile`'
- en: '`>>> help(transpile)`'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> help(transpile)`'
- en: Now take a look at the *There's more* section for a short showcase of how things
    can get much more complicated, quickly.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看 *还有更多* 部分，看看事情如何迅速变得更加复杂。
- en: There's more...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This quick recipe gave a quick taste of what the transpiler does for a very
    simple quantum program, and illustrated how the transpiler translates your generic
    circuits into circuits that can be directly executed on the quantum chip.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快速配方快速展示了转换器为非常简单的量子程序做了什么，并说明了转换器如何将你的通用电路转换为可以直接在量子芯片上执行的电路。
- en: The following quick examples illustrate the complexities that might befall the
    poor transpiler if you ask it to build circuits that do not at all match the physical
    layout of the backend. You can test these circuits in the sample code to see if
    you get similar results.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 以下快速示例说明了如果要求转换器构建与后端物理布局完全不匹配的电路，可能会遇到哪些复杂性。你可以在示例代码中测试这些电路，看看你是否得到类似的结果。
- en: 'Test the following inputs when running the sample code:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例代码时，测试以下输入：
- en: Adding H and H + Barrier – Multiple gates and the barrier circuit element
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 H 和 H + 障碍 – 多个门和障碍电路元件
- en: The transpiling of one gate doesn't leave the transpiler with a lot to do, but
    as soon as you add more gates, things quickly get more complex. Remember that
    quantum gates generically are rotations around the three axes *x*, *y*, and *z*.
    If two gates are added in a row, the transpiler seeks to simplify the circuit
    (and thus make it shorter; less deep) by combining multiple gates into single
    basis gate.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 单个门的转换并不会给转换器留下太多工作要做，但一旦你添加了更多的门，事情会迅速变得更加复杂。记住，量子门通常是围绕三个轴 *x*、*y* 和 *z* 的旋转。如果连续添加两个门，转换器会试图通过将多个门组合成单个基门来简化电路（从而使其更短；更浅）。
- en: 'In the sample code, we extended the quantum circuit by adding a Hadamard gate
    after the X gate:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，我们在 X 门之后添加了一个 Hadamard 门来扩展量子电路：
- en: '[PRE37]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When you run the circuit now, you should see something like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行电路时，你应该能看到类似这样的东西：
- en: '![Figure 6.26 – Simplified transpiled circuit'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.26 – 简化的转换电路'
- en: '](img/Figure_6.26_B14436.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.26_B14436.jpg)'
- en: Figure 6.26 – Simplified transpiled circuit
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26 – 简化的转换电路
- en: As you can see, the transpiler combined the two gates into one, simplifying
    and shortening the circuit by looking ahead at what the gate combination would
    result in, and coding that as a U gate. However, it is not always that you want
    this simplification. For example, as we saw in the *A quick introduction to quantum
    gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, two identical quantum gates in a row
    might effectively cancel each other out. In some instances, a quantum circuit
    will end up being constructed out of repeating gates, and if those repeating gates
    are removed, the circuit will not work as expected.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编译器将两个门合并为一个，通过预览门组合的结果来简化并缩短电路，并将其编码为U门。然而，并不总是希望这种简化。例如，正如我们在[*第2章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)中“*快速介绍量子门*”配方中看到的，“*使用Python进行量子计算和量子比特*”，连续两个相同的量子门可能会有效地相互抵消。在某些情况下，量子电路最终可能由重复的门组成，如果移除这些重复的门，电路将无法按预期工作。
- en: 'The solution is the `barrier()` circuit component, which stops the transpiler
    from simplifying by combining gates. By using the *H + Barrier* option, we add
    a barrier between the X and H gates like this:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是`barrier()`电路组件，它阻止编译器通过合并门来简化。通过使用*H + Barrier*选项，我们在X门和H门之间添加一个障碍，如下所示：
- en: '[PRE38]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When you use the *H + Barrier* option, you should see something similar to
    this:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用*H + Barrier*选项时，您应该看到类似以下内容：
- en: '![Figure 6.27 – Transpiler does not transpile past the barriers'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.27 – 编译器不会越过障碍'
- en: '](img/Figure_6.27_B14436.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.27_B14436.jpg)'
- en: Figure 6.27 – Transpiler does not transpile past the barriers
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27 – 编译器不会越过障碍
- en: The gates are now transpiled one by one, and the circuit depth is retained.
    So, no problem there, right? Well, these were pretty simple gates. What happens
    when we complicate our circuit a bit? Take a look at the next section.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在门是逐个编译的，电路深度得到了保留。所以，没问题，对吧？嗯，这些门相当简单。当我们稍微复杂化我们的电路时会发生什么？请看下一节。
- en: Controlled Y
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制Y
- en: The **controlled X gate** (**CX**) is a basis gate for the IBM Quantum® backends,
    but the **controlled Y** (**CY**) is not. To create a CY gate that can run on
    the backend, the transpiler adds some additional basis gates.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制X门**（**CX**）是IBM Quantum®后端的基门，但**控制Y**（**CY**）不是。为了创建可以在后端运行的CY门，编译器添加了一些额外的基门。'
- en: 'By using the *Controlled-Y* option, we add a `cy()` gate like this:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用*Controlled-Y*选项，我们添加一个`cy()`门，如下所示：
- en: '[PRE39]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To create a CY gate that can run on the backend, the transpiler adds some additional
    basis gates:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建可以在后端运行的CY门，编译器添加了一些额外的基门：
- en: '![Figure 6.28 – Transpiling a CY gate'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.28 – 编译CY门'
- en: '](img/Figure_6.28_B14436.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.28_B14436.jpg)'
- en: Figure 6.28 – Transpiling a CY gate
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28 – 编译CY门
- en: Here we have the transpiler do a quick trick, adding Z rotations before and
    after the X in the CX gate. If the control qubit is 0, we will just get a rotation
    back and forth around the *z* axis. If the control qubit is 1, we get a negative
    quarter rotation around Z, a half-turn rotation around X, and then a quarter rotation
    back around Z, effectively landing us where we would have been with a half-turn
    Y rotation. Granted, a Y rotation would have been easily done with `Y(qubit)`
    `=` `U3(`![](img/Formula_06_154.png)`,` ![](img/Formula_06_154.png)`,` ![](img/Formula_06_154.png)`,`
    `qubit)`, but as the control functionality of the CX cannot be attached to the
    Y gate, we have to do this rework instead.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这里编译器做了一个小技巧，在CX门中的X前后添加Z旋转。如果控制量子比特为0，我们将在z轴周围来回旋转。如果控制量子比特为1，我们得到Z轴的负四分之一旋转，X轴的半转旋转，然后是Z轴的四分之一旋转，实际上相当于半转Y旋转。当然，Y旋转可以用`Y(qubit)`
    `=` `U3(`![](img/Formula_06_154.png)`,` ![](img/Formula_06_154.png)`,` ![](img/Formula_06_154.png)`,`
    `qubit)``轻松完成，但由于CX的控制功能不能附加到Y门上，我们不得不进行这种重做。
- en: Let's look at some other examples. These will illustrate how the transpiler
    works to convert your seemingly simple quantum circuits to circuits made out of
    basis gates that can be run on the actual IBM Quantum® hardware.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些其他示例。这些将说明编译器如何将看似简单的量子电路转换为可以在实际IBM Quantum®硬件上运行的基门电路。
- en: Non-conforming CX
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不符合规范的CX
- en: 'In this example, we set up a CX gate between two qubits that are not physically
    connected. As you have seen, CX is a base gate, so this should not require any
    transpiling, right? Well, in this case, we force the transpiler to attempt to
    build your circuit across two qubits that are not directly connected. In this
    case, the transpiler must map your CX gate across several intermediate qubits,
    which will add complexity to your circuit. In our sample code, we build this circuit:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在两个物理上未连接的量子比特之间设置了一个CX门。如您所见，CX是一个基本门，因此这不应该需要任何转换，对吧？但是，在这种情况下，我们迫使转换器尝试在两个未直接连接的量子比特之间构建您的电路。在这种情况下，转换器必须将您的CX门映射到几个中间量子比特上，这将增加电路的复杂性。在我们的示例代码中，我们构建了这个电路：
- en: '[PRE40]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running the sample code with the non-conforming CX input should result in something
    similar to the following:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不符合规定的CX输入运行示例代码应该产生类似于以下的结果：
- en: '![Figure 6.29 – Transpiling a CX gate across non-connected qubits'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.29 – 在非连接量子比特之间转换CX门'
- en: '](img/Figure_6.29_B14436.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.29_B14436.jpg)'
- en: Figure 6.29 – Transpiling a CX gate across non-connected qubits
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29 – 在非连接量子比特之间转换CX门
- en: 'Notice how this simple, one-CX circuit all of a sudden ballooned to a circuit
    with seven CX gates. This is not the most efficient coding example. The reason
    for this is clear if you look at the coupling map for the quantum computer that
    we are transpiling for, IBM Quantum® Ourense. Qubit 4 cannot directly communicate
    with qubit 0, but has to go through 3 and 1 first:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个简单的单CX电路突然膨胀到包含七个CX门。这不是最有效的编码示例。如果你查看我们正在进行转换的量子计算机的耦合图，即IBM Quantum® Ourense，原因就一目了然。量子比特4不能直接与量子比特0通信，而必须先通过3和1：
- en: '![Figure 6.30 – The physical layout of one of the IBM Quantum® 5-qubit backends'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.30 – IBM Quantum® 5量子比特后端之一的物理布局'
- en: '](img/Figure_6.30_B14436.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.30_B14436.jpg)'
- en: Figure 6.30 – The physical layout of one of the IBM Quantum® 5-qubit backends
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30 – IBM Quantum® 5量子比特后端之一的物理布局
- en: For simple circuits, there is no big difference between the original and transpiled
    circuits; try having the CX gate go from qubit 0 to qubit 1 and see what you get.
    But for more elaborate ones, the circuits quickly diverge.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的电路，原始电路和转换电路之间没有太大差异；尝试将CX门从量子比特0连接到量子比特1，看看你得到什么。但对于更复杂的电路，电路会迅速分化。
- en: But hang on!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！
- en: 'For those nitpickers of you that, like me, have looked over the circuit and
    walked through what happens if qubit 0 is set to 1 to trigger the CX, you will
    have noticed that the result of the original circuit ought to be `barrier` and
    `measure` lines in the code and run it again:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些像我自己一样仔细检查电路并思考如果量子比特0设置为1以触发CX会发生什么的挑剔者，您会注意到原始电路的结果应该是代码中的`barrier`和`measure`行，并再次运行：
- en: '[PRE41]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This ought to result in the following output:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下输出：
- en: '![Figure 6.31 – The transpiler also moves the measurement instructions around'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.31 – 转换器也会移动测量指令'
- en: '](img/Figure_6.31_B14436.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.31_B14436.jpg)'
- en: Figure 6.31 – The transpiler also moves the measurement instructions around
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31 – 转换器也会移动测量指令
- en: As you can see from the new mapping, qubits 1 and 3 are now measured to classical
    bits 0 and 4, just as we expected. The final measurement output will be correct.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从新的映射中看到的那样，量子比特1和3现在被测量为经典比特0和4，正如我们所期望的。最终的测量输出将是正确的。
- en: Multi-gate – Combined Bell and CSWAP circuit
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多门 – 结合贝尔和CSWAP电路
- en: 'This last example illustrates the complexity that occurs when you try to achieve
    something reasonably simple but run out of pathways to achieve it. We are creating
    a Bell state over qubits 0 and 4 and adding a controlled-SWAP gate from qubit
    3 to qubits 1 and 2 to have those qubits just swap values:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个例子说明了当你试图实现一个相对简单但路径有限的目标时，会出现的复杂性。我们正在创建量子比特0和4的贝尔态，并添加一个从量子比特3到量子比特1和2的控制-SWAP门，以便这些量子比特交换值：
- en: '[PRE42]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The multi-gate input should give the following result:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 多门输入应该给出以下结果：
- en: '![Figure 6.32 – A complex transpiling of a reasonably simple Bell + CSWAP circuit'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.32 – 一个相对简单的贝尔+CSWAP电路的复杂转换'
- en: '](img/Figure_6.32_B14436.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.32_B14436.jpg)'
- en: Figure 6.32 – A complex transpiling of a reasonably simple Bell + CSWAP circuit
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.32 – 一个相对简单的贝尔+CSWAP电路的复杂转换
- en: Well, trying this relatively simple circuit quickly took a turn for the worse.
    It ballooned from a depth of 2 to 32\. The circuit size also went up from the
    original 4 gates to an astounding 43\. Look at all those CX gates!
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，尝试这个相对简单的电路很快就变得糟糕起来。它的深度从 2 增加到 32。电路的大小也从最初的 4 个门增加到惊人的 43。看看所有那些 CX 门！
- en: '![Figure 6.33 – Depth and size of the multi-gate circuit'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.33 – 多门电路的深度和大小'
- en: '](img/Figure_6.33_B14436.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.33_B14436.jpg)'
- en: Figure 6.33 – Depth and size of the multi-gate circuit
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33 – 多门电路的深度和大小
- en: Again, if you take a look at *Figure 6.33*, you can see why this happens. The
    simple act on our part of connecting qubit 0 and 4 is physically impossible as
    the quantum chip is laid out. Instead, this connection requires a chain of intermediate
    qubit connections across qubits 1, 2, and 3\. These additional connections caused
    the number of individual gates to explode.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你看一下 *图 6.33*，你就可以看到为什么会发生这种情况。我们简单地连接量子位 0 和 4 在物理上是不可行的，因为量子芯片的布局。相反，这个连接需要通过量子位
    1、2 和 3 的中间量子位连接链。这些额外的连接导致了单个门的数量激增。
- en: 'Now try the following circuit instead and see how that changes the counts.
    You should expect both depth and size to shrink significantly as you are now coding
    for qubits that can directly communicate with each other. Apparently, coding for
    the backend that you want to run your program on is still important in this **Noisy
    Intermediate-Scale Quantum (NISQ)** era:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试以下电路，看看这如何改变计数。你应该预期深度和大小都会显著缩小，因为你现在正在为可以直接相互通信的量子位编写代码。显然，在这个**噪声中等规模量子（NISQ）**时代，为你要运行的程序编写后端代码仍然很重要：
- en: '![Figure 6.34 – A better conforming Bell + CSWAP circuit'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.34 – 更好的符合要求的 Bell + CSWAP 电路'
- en: '](img/Figure_6.34_B14436.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.34_B14436.jpg)'
- en: Figure 6.34 – A better conforming Bell + CSWAP circuit
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34 – 更好的符合要求的 Bell + CSWAP 电路
- en: As we have seen in this chapter, good quality programming is as important in
    quantum computing as it is in classical computing, if not more. The transpiler,
    left to its own devices, will do its best to translate your circuits to the backend
    where you plan to run them.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，高质量的编程在量子计算中与在经典计算中一样重要，如果不是更重要。编译器会尽其所能将你的电路翻译到你计划运行的底层。
- en: If it gets crowded, and you utilize all the qubits extensively, the rewriting
    of your circuit might extend the execution time beyond the T1 and T2 times, making
    your circuit produce junk results on today's **NISQ computer** even though it
    otherwise is very nicely constructed.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电路变得拥挤，并且你充分利用了所有的量子位，那么电路的重写可能会使执行时间超过 T1 和 T2 时间，即使电路本身构建得非常完美，在今天**NISQ
    计算机**上也可能产生垃圾结果。
- en: Quantum programming is definitely an art!
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 量子编程绝对是一门艺术！
