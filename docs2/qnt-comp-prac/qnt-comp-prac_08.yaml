- en: '*Chapter 8*: Cleaning Up Your Quantum Act with Ignis'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*: 使用Ignis清理你的量子行为'
- en: We have explored running our quantum programs on idealized Qiskit Aer simulators
    and gotten our hands dirty with the actual IBM Quantum machines. We understand
    that real qubits are noisy and that we cannot expect quantum computers to solve
    actual real-world problems of any significant magnitude (yet). On the path to
    this future application lies ﬁghting and mitigating noise and errors, and on that
    path lies Qiskit Ignis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了在理想化的Qiskit Aer模拟器上运行我们的量子程序，并且在实际的IBM Quantum机器上亲自动手。我们明白真实的量子位是有噪声的，我们无法期望量子计算机能够解决任何具有重大实际意义的现实世界问题（至少目前还不能）。通往这一未来应用的途径在于对抗和减轻噪声和错误，而Qiskit
    Ignis就在这条道路上。
- en: Qiskit® includes a lot of automation, such as the optimization of the assigned
    qubits according to connectivity and performance; but this automation is, to an
    extent, limited by the physical layout of a quantum chip, which controls how the
    qubits can communicate with each other. By studying the qubit performance and
    specifying which actual physical qubits you want to use with your quantum programs,
    you can optimize your circuits for optimal entanglement and decoherence, to name
    a few examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit® 包含了许多自动化功能，例如根据连接性和性能优化分配的量子位；但这种自动化在一定程度上受到量子芯片物理布局的限制，这决定了量子位如何相互通信。通过研究量子位性能并指定你想要与你的量子程序一起使用的实际物理量子位，你可以优化你的电路以实现最佳纠缠和去相干，仅举几个例子。
- en: In this chapter, we will explore how running your programs on different sets
    of qubits on the same backend might cause you to end up with different results.
    We will also use the Qiskit Ignis methods to do readout correction on our simpler
    algorithms on simulated and existing hardware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在相同后端的不同量子位集上运行你的程序可能会如何导致你得到不同的结果。我们还将使用Qiskit Ignis方法对我们的简单算法在模拟和现有硬件上进行读出校正。
- en: Finally, we will take a look at quantum error correction using the Shor code,
    seeing how you can create a single logical qubit by using several physical qubits
    for quantum error correction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨使用Shor码进行量子纠错，看看你如何可以通过使用多个物理量子位进行量子纠错来创建一个单独的逻辑量子位。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Exploring your qubits to understand T1, T2, errors, and gates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索你的量子位以了解T1、T2、错误和门
- en: Comparing the qubits on a chip
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较芯片上的量子位
- en: Estimating the number of gates you have time for
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算你有多少时间可以用于门操作
- en: Correcting the expected with readout correction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用读出校正来纠正预期结果
- en: Mitigating the unexpected with quantum error correction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用量子纠错来减轻意外情况
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The quantum programs that we''ll discuss in this chapter can be found here:
    [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将讨论的量子程序可以在这里找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08).
- en: Exploring your qubits to understand T1, T2, errors, and gates
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索你的量子位以了解T1、T2、错误和门
- en: 'Let''s start off with a quick overview of some things that can go wrong when
    you send your perfectly working and simulator-verified quantum program to an actual,
    physical quantum computer. As we have seen, as soon as we step away from our perfect
    simulated qubits and start using physical qubits that work quantum-mechanically,
    we also have to contend with another physical feature of reality: noise.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些快速概述开始，这些概述了当你将完美工作且经过模拟器验证的量子程序发送到实际的物理量子计算机时可能会出错的事情。正如我们所见，当我们离开完美的模拟量子位并开始使用在量子力学上工作的物理量子位时，我们也必须应对现实世界的另一个物理特性：噪声。
- en: In a quantum computer, the noise differs between backends, between qubits on
    a backend, between different types of gates, and between the readouts of each
    qubit. Building and programming quantum computers really is a complex task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子计算机中，噪声在各个后端之间、后端上的量子位之间、不同类型的门之间以及每个量子位的读出之间都存在差异。构建和编程量子计算机确实是一项复杂的任务。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required for this recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此配方的文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py)。
- en: This recipe builds on the work we did in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit® Tools*, but this time we are specifically
    looking at the qubit properties that hint at the many ways that things can go
    wrong.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基于我们在[*第5章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)，*使用Qiskit®工具游览IBM
    Quantum®硬件*中完成的工作，但这次我们特别关注那些暗示事物可能出错多种方式的量子比特属性。
- en: 'We will be using the `backend.properties()` Qiskit® method to pull out the
    following properties for qubits:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`backend.properties()` Qiskit®方法提取以下针对量子比特的属性：
- en: '`t1()`: The T1 or relaxation time for the given qubit'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t1()`: 给定量子比特的T1或弛豫时间'
- en: '`t2()`: The T2 or dephasing time for the given qubit'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t2()`: 给定量子比特的T2或去相位时间'
- en: '`readout_error()`: The risk of misreading the qubit during measurement'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readout_error()`: 测量过程中误读量子比特的风险'
- en: '`gate_length()`: The duration of the gate in units of seconds'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gate_length()`: 门的持续时间，以秒为单位'
- en: '`gate_error()`: The gate error estimate'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gate_error()`: 门的错误估计'
- en: The sample code
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'First, we import the class that we need and load our account:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类并加载我们的账户：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use `select_backend()` here to load and display the data for the available
    backends, and then prompt to select one:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里使用`select_backend()`来加载和显示可用的后端数据，然后提示选择一个：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `display_information(backend)` function retrieves the backend information
    such as the number of qubits and the qubit coupling map, and then uses that to
    cycle through the backend's qubits to retrieve the T1, T1, readout error, and
    gate information. The function comprises two parts.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`display_information(backend)`函数检索后端信息，如量子比特数量和量子比特耦合图，然后使用这些信息遍历后端量子比特以检索T1、T2、读出错误和门信息。该函数包含两部分。'
- en: 'First, we gather the qubit information:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们收集量子比特信息：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we print out the basic qubit information and the qubit-specific information
    for each gate:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们打印出基本量子比特信息和每个门的具体量子比特信息：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The main function calls the `select_backend()` and `display_information(backend)`
    functions to help you see all the qubit information for a selected backend:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主函数调用`select_backend()`和`display_information(backend)`函数，以帮助您查看所选后端的所有量子比特信息：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To explore the qubit properties of a specific backend, follow these steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索特定后端的量子比特属性，请按照以下步骤操作：
- en: In your Python environment, run `ch8_r1_gates_data.py`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Python环境中运行`ch8_r1_gates_data.py`。
- en: 'The script loads Qiskit® and grabs and displays a list of the available backends
    as shown here:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本加载Qiskit®并获取并显示可用的后端列表，如下所示：
- en: '![Figure 8.1 – Select a backend to investigate'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.1 – 选择一个后端进行调研'
- en: '](img/Figure_8.1_B14436.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.1_B14436.jpg](img/Figure_8.1_B14436.jpg)'
- en: Figure 8.1 – Select a backend to investigate
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.1 – 选择一个后端进行调研
- en: 'When prompted, enter the name of the IBM Quantum® backend that you want to
    take a look at:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入您想要查看的IBM Quantum®后端的名称：
- en: 'We now pull in `backend.properties()` for the selected backend, and from these,
    sift through and display the following parameters: qubit readout error, T1 and
    T2 decoherence times, gate length, and error for all the basis gates for the backend.'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在为所选后端提取`backend.properties()`，并从这些属性中筛选并显示以下参数：量子比特读出错误、T1和T2去相位时间、门长度以及后端所有基门的错误。
- en: '![Figure 8.2 – Qubit data for the ibmq_vigo 5-qubit backend'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.2 – ibmq_vigo 5量子比特后端的数据'
- en: '](img/Figure_8.2_B14436.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.2_B14436.jpg](img/Figure_8.2_B14436.jpg)'
- en: Figure 8.2 – Qubit data for the ibmq_vigo 5-qubit backend
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – ibmq_vigo 5量子比特后端的数据
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: That is a fair bit of data, but it only represents a small piece of the data
    that can be collected for a specific backend. For a refresher, see the *Exploring
    a selected backend using Qiskit®* recipe in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit® Tools*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大批数据，但它只代表可以收集的特定后端数据中的一小部分。为了复习，请参阅[*第5章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)，*使用Qiskit®工具游览IBM
    Quantum®硬件*中的*使用Qiskit®探索所选后端*配方。
- en: 'The first pieces of data that we will touch on are the **T1** and **T2** times
    and the **readout error**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一部分数据是 **T1** 和 **T2** 时间以及 **读取错误**：
- en: '![Figure 8.3 – Data for qubit 0'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – qubit 0 的数据'
- en: '](img/Figure_8.3_B14436.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B14436.jpg)'
- en: Figure 8.3 – Data for qubit 0
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – qubit 0 的数据
- en: 'This first set of data represents the physical reasons that you might not get
    the results that you expect when you run your quantum code on the backend:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这组数据首先代表了当你在后端运行量子代码时，可能得不到预期结果的一些物理原因：
- en: '**T1**, **or relaxation** **time**: The T1 value, displayed as ![](img/Formula_008_100.png)
    in *Figure 8.3,* is a statistical value of how long it takes for the qubit to
    spontaneously relax from the "excited" state ![](img/Formula_008_001.png) to the
    ground state ![](img/Formula_008_002.png). In essence, T1 is an estimate of the
    time that you have at your disposal to perform high-quality actions on the qubit.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T1**，或**弛豫** **时间**：T1 值，如图 8.3 中所示，以 ![](img/Formula_008_100.png) 形式展示，是量子位从“激发”状态
    ![](img/Formula_008_001.png) 自发弛豫到基态 ![](img/Formula_008_002.png) 所需时间的统计值。本质上，T1
    是对你在量子位上执行高质量操作可利用时间的估计。'
- en: '**T2**, **or** **dephasing** **time:** Similar to T1, the T2 value, displayed
    as *ms* in *Figure 8.3,* is a measure of how phase information is lost for a qubit.
    An example of phase change is when the state ![](img/Formula_008_003.png) spontaneously
    changes to ![](img/Formula_008_004.png). Again, if the running time for your circuit
    starts to approach the T2 time, the quality of your readout data will suffer.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T2**，或**去相位** **时间**：与 T1 类似，T2 值，如图 8.3 中以 *ms* 形式展示，是量子位相位信息丢失的度量。相位变化的一个例子是当状态
    ![](img/Formula_008_003.png) 自发变为 ![](img/Formula_008_004.png)。同样，如果你的电路运行时间开始接近
    T2 时间，你的读取数据质量将受到影响。'
- en: 'Now for the rest of the data that we pulled in:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下我们收集到的其他数据：
- en: '![Figure 8.4 – Data for qubit 0'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – qubit 0 的数据'
- en: '](img/Figure_8.4_B14436.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B14436.jpg)'
- en: Figure 8.4 – Data for qubit 0
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – qubit 0 的数据
- en: '`readout_error`, `gate_length`, and `gate_error` represent the quality of the
    gates that you can run on each qubit.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`readout_error`、`gate_length` 和 `gate_error` 代表了你可以运行在每个量子位上的门的质量。'
- en: '`readout_error`: The readout error rate, displayed as a percentage in *Figure
    8.4*, is simply the probability that you will get the incorrect value when reading
    the qubit. For example, a qubit in state ![](img/Formula_06_0221.png) will be
    read as ![](img/Formula_06_023.png) and vice versa. This really has nothing to
    do with any other qubit manipulations but is simply the error rate for the final
    readout of the collapsed qubit. It is possible to get a statistical picture of
    each qubit and mitigate these readout errors. We will do that in the *Correct
    the expected with readout correction* recipe.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readout_error`：读取错误率，如图 8.4 中以百分比形式展示，是你在读取量子位时得到错误值的概率。例如，处于状态 ![](img/Formula_06_0221.png)
    的量子位将被读取为 ![](img/Formula_06_023.png)，反之亦然。这实际上与任何其他量子位操作无关，只是最终读取坍缩量子位的错误率。我们可以对每个量子位得到一个统计图像，并减轻这些读取错误。我们将在“使用读取校正修正预期”菜谱中这样做。'
- en: '`gate_length`: The gate length, displayed as *![](img/Formula_008_100.png)*
    in *Figure 8.4*, represents the time it takes to make the adjustment to the qubit
    that corresponds to the gate. If you look at the data returned, you see that the
    gate length for a U3 gate might be in the order of a twentieth of a microsecond
    or so, whereas the T1/T2 times might be much longer than that. This, however,
    doesn''t mean that you can just add hundreds or thousands of these gates within
    that time span and expect the results to be great. This is where gate errors come
    in.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gate_length`：门长度，如图 8.4 中以 *![](img/Formula_008_100.png)* 形式展示，代表调整与门相对应的量子位所需的时间。如果你查看返回的数据，你会看到
    U3 门的长度的量级可能是一个微秒的二十分之一左右，而 T1/T2 时间可能比这长得多。然而，这并不意味着你可以在那个时间段内添加数百或数千个这样的门并期望结果会很好。这就是门错误出现的地方。'
- en: '`gate_error`: The gate error, displayed as a percentage in *Figure 8.4*, is
    a statistical value for how accurate the gate is at executing the expected results.
    As you can see, the errors range from 0.05% to a few percent. For short circuits
    of just a few gates, we can run the circuit many times and statistically derive
    the correct values even with gate errors popping up. For longer circuits, of hundreds
    or thousands of gates, even these small gate errors start to make an impact. In
    [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover''s Search
    Algorithm*, you will build quantum circuits with hundreds of gates.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gate_error`：门错误，如图8.4中所示，以百分比形式显示，是门执行预期结果准确性的统计值。正如你所见，错误范围从0.05%到几个百分点。对于只有几个门的短路，我们可以多次运行电路并统计推导出正确的值，即使门错误出现。对于数百或数千个门的较长电路，即使是这些小的门错误也开始产生影响。在[*第9章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)的*Grover搜索算法*中，你将构建包含数百个门的量子电路。'
- en: 'Remember from the *What are the IBM Quantum® machines?* recipe in [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit®*, that the gates are not physical things like the bundles
    of transistors that make up the gates in classical computing. Instead, quantum
    gate logic constitutes a series of microwave pulses that are sent down to and
    interact with the cryogenically chilled qubits. The quality of gates thus hinges
    on quite a few things: the physical properties of the **Josephson junction** and
    resonator circuit that constitute the physical qubit, the accuracy of the carrier
    wave and gate-coded wave package, the microwave resonators, the cryostats, and
    much more.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从[*第5章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)的*什么是IBM Quantum®机器？*配方中，*使用Qiskit®游览IBM
    Quantum®硬件*，门不是像经典计算中构成门的晶体管束这样的物理事物。相反，量子门逻辑由一系列发送到并相互作用于低温冷却的量子位的微波脉冲组成。因此，门的质量取决于很多因素：构成物理量子位的**约瑟夫森结**和共振电路的物理特性，载波波和门编码波包的准确性，微波共振器，液氦冷却器，等等。
- en: There's more
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: You can also get to the backend qubit data from IBM Quantum Experience®.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从IBM量子体验®获取后端量子位数据。
- en: 'Let''s take a look:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一看：
- en: Log in to IBM Quantum Experience® at [https://quantum-computing.ibm.com](https://quantum-computing.ibm.com).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://quantum-computing.ibm.com](https://quantum-computing.ibm.com)登录IBM量子体验®。
- en: On the **Welcome** page, on the right side, you'll see a list of the available
    backends:![Figure 8.5 – The IBM Quantum Experience® home page
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**欢迎**页面上，右侧你会看到一个可用的后端列表：![图8.5 – IBM量子体验®首页
- en: '](img/Figure_3.1_B14436.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B14436.jpg)'
- en: Figure 8.5 – The IBM Quantum Experience® home page
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.5 – IBM量子体验®首页
- en: Click on the backend that you are interested in, for example, `ibmq_vigo`, to
    see the chip layout and additional information:![Figure 8.6 – Details of the ibmq_vigo
    backend
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你感兴趣的后端，例如，`ibmq_vigo`，以查看芯片布局和附加信息：![图8.6 – ibmq_vigo后端的详细信息
- en: '](img/Figure_8.6_B14436.jpg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B14436.jpg)'
- en: Figure 8.6 – Details of the ibmq_vigo backend
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.6 – ibmq_vigo后端的详细信息
- en: 'Click **Download Calibrations** for a CSV file with the qubit information.
    The downloaded calibration data looks as shown in the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下载校准**以获取包含量子位信息的CSV文件。下载的校准数据如下截图所示：
- en: '![Figure 8.7 – Downloaded calibration data from IBM Quantum Experience®'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 从IBM量子体验®下载的校准数据'
- en: '](img/Figure_8.7_B14436.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.7_B14436.jpg)'
- en: Figure 8.7 – Downloaded calibration data from IBM Quantum Experience®
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 从IBM量子体验®下载的校准数据
- en: You can now bring the data into your favorite spreadsheet software for further
    processing as needed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将数据带入你喜欢的电子表格软件进行进一步处理，如需。
- en: Comparing the qubits on a chip
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较芯片上的量子位
- en: In the previous recipe, we looked at some of the pieces of information that
    you can glean about the IBM Quantum® hardware, illustrating the nature of today's
    NISQ machines. In this recipe, we will show a real comparison between the different
    qubits of a selected IBM backend.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们查看了一些你可以从IBM Quantum®硬件中获取的信息片段，说明了今天NISQ机器的性质。在这个配方中，我们将展示一个所选IBM后端不同量子位的真实比较。
- en: 'We will run the same Bell state quantum program on three different setups:
    an ideal quantum computer (`qasm_simulator`), the best qubit pair, and the worst
    qubit pair on a 5-qubit, least busy IBM Quantum® machine.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个不同的设置上运行相同的贝尔态量子程序：理想量子计算机(`qasm_simulator`)，最佳量子比特对，以及5量子比特、最不繁忙的IBM
    Quantum®机器上最差的量子比特对。
- en: We will print and plot the end result to compare the ideal result (![](img/Formula_008_007.png)
    and ![](img/Formula_008_008.png) at 50%) with the real results (a probabilistic
    mix of ![](img/Formula_008_009.png)) to illustrate how today's quantum computers
    still have a little way to go.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打印并绘制最终结果，以比较理想结果（![](img/Formula_008_007.png) 和 ![](img/Formula_008_008.png)
    在 50%）与实际结果（![](img/Formula_008_009.png) 的概率混合）来展示今天的量子计算机仍有很长的路要走。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的食谱中所需文件可从以下链接下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py)
- en: The sample code
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'First, we import the classes and methods that we need and load our account.
    In this recipe, we combine a lot of important concepts from earlier in the book,
    such as simulators and noise models:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类和方法，并加载我们的账户。在这个食谱中，我们结合了书中早期的一些重要概念，例如模拟器和噪声模型：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `select_backend()` function lets you select an available backend. You can
    also have the system pick the least busy one:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`select_backend()` 函数允许您选择一个可用的后端。您还可以让系统选择最不繁忙的一个：'
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pull out the best and worst CX gate performance information, then cycle through
    the CX gate couplings to find the best and worst performing connection, before
    returning this information as a `cx_best_worst` list for later usage. We can now
    take a look at the best and worst performing CX gate information that we stored.
    To verify that we have collected the correct information, we can display the error
    map for the backend, and check that the CX connectors really do represent the
    best and worst:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取最佳和最差 CX 门性能信息，然后循环遍历 CX 门耦合，以找到最佳和最差性能的连接，然后将此信息作为 `cx_best_worst` 列表返回以供后续使用。现在我们可以查看我们存储的最佳和最差性能的
    CX 门信息。为了验证我们收集到的信息是否正确，我们可以显示后端的错误图，并检查 CX 连接器是否确实代表了最佳和最差：
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create two quantum circuits sized for the selected backend. With the qubit
    information gathered, we can create a quantum program that specifies CX gates
    for the best and worst qubit pairs. Here is where we use that qubits variable
    we pulled earlier. First, we build two circuits (`qc_best` and `qc_worst`) that
    have the correct number of qubits depending on the selected backend. That information
    is gathered using the `backend.configuration().n_qubits` method. We use the `cx_best_worst`
    list that we created earlier to place the H and CX gates on the correct qubits
    and then print the circuits:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个针对所选后端尺寸的量子电路。收集到量子位信息后，我们可以创建一个量子程序，该程序指定最佳和最差量子位对的 CX 门。这就是我们使用之前提取的量子位变量。首先，我们构建两个电路（`qc_best`
    和 `qc_worst`），它们具有根据所选后端正确的量子位数量。该信息是通过 `backend.configuration().n_qubits` 方法收集的。我们使用之前创建的
    `cx_best_worst` 列表将 H 和 CX 门放置在正确的量子位上，然后打印电路：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the best and worst circuits on the backend. With all pieces assembled, we
    can now run the best circuit, followed by the worst. Of course, we also want a
    benchmark job on the perfect `qasm_simulator` using the same number of qubits
    as when we ran on the actual backend. Create and run a benchmark circuit on a
    local simulator. Print the results for the best, worst, and baseline qubit pair
    and plot the results in a diagram. We can also use the Qiskit® histogram feature
    to display the results in diagram form for clarity.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后端运行最佳和最差电路。所有部件组装完毕后，我们现在可以运行最佳电路，然后是最差电路。当然，我们还想在完美的 `qasm_simulator` 上使用与实际后端运行时相同数量的量子位进行基准测试。在本地模拟器上创建并运行一个基准电路。打印最佳、最差和基线量子位对的成果，并在图表中绘制结果。我们还可以使用
    Qiskit® 直方图功能以图表形式清晰地显示结果。
- en: 'We start by displaying the best and worst CX-pair circuits, and running these
    on the selected backend:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先显示最佳和最差 CX 对电路，并在所选后端上运行这些电路：
- en: '[PRE9]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we build a generic CX circuit (Bell circuit), and run this one on the
    local `qasm_simulator` to get a baseline result:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们构建一个通用的 CX 电路（贝尔电路），并在本地的 `qasm_simulator` 上运行以获得基线结果：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we collect the best, worst, and baseline job results. We then print
    them and display them together in a diagram for comparison:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们收集最佳、最差和基线作业结果。然后我们打印它们，并在图表中一起显示以进行比较：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And finally, the `main` function pulls it all together:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`main`函数将所有这些整合在一起：
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何完成...
- en: The IBM Quantum® backends are actual physical semiconductor circuits, each with
    slightly different behavior. In addition, the qubits are physically connected
    to make it possible to directly entangle them the way that you specify in your
    quantum programs. This type of qubit communication can only take place directly
    as specified by the coupling map that we looked at in the *Visualizing the backends*
    recipe in [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring
    the IBM Quantum® Hardware with Qiskit®*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Quantum®后端是实际的物理半导体电路，每个后端的行为略有不同。此外，量子比特通过物理连接连接起来，以便能够以你在量子程序中指定的方式直接纠缠它们。这种类型的量子比特通信只能按照我们在[*第5章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)中查看的耦合图直接进行，该图在[*“使用Qiskit®游览IBM
    Quantum®硬件”*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)菜谱中进行了可视化。
- en: In this recipe, we extract the error rate for 2-qubit communication from our
    selected backend. We then pick the best and the worst qubit pairs and run the
    same quantum program on each pair to see how the outcome of the program differs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们从所选后端提取2量子比特通信的错误率。然后我们选择最佳和最差的量子比特对，并在每一对上运行相同的量子程序，以查看程序结果如何不同。
- en: 'Let''s see how it is done:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何完成的：
- en: In your Python environment, run `ch8_r3_time.py`. The script loads Qiskit® and
    grabs and displays a list of the available backends:![Figure 8.8 – First, we select
    a backend to test on, such as ibmq_santiago
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Python环境中运行`ch8_r3_time.py`。该脚本加载Qiskit®并获取并显示可用的后端列表：![Figure 8.8 – 首先，我们选择一个后端进行测试，例如ibmq_santiago
- en: '](img/Figure_8.8_B14436.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.8_B14436.jpg](img/Figure_8.8_B14436.jpg)'
- en: Figure 8.8 – First, we select a backend to test on, such as ibmq_santiago
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.8 – 首先，我们选择一个后端进行测试，例如ibmq_santiago
- en: Enter the name of a backend that you want to test on or enter `LB` to have the
    system pick the least busy system for you.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入你想要测试的后端名称，或者输入`LB`让系统为你选择最不繁忙的系统。
- en: The best and worst CX gate performance information is displayed as a list and
    as an error map:![Figure 8.9 – The various CX gate errors for the qubit combinations
    of ibmq_santiago
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳和最差CX门性能信息以列表和错误图的形式显示：![Figure 8.9 – ibmq_santiago量子比特组合的各种CX门错误
- en: '](img/Figure_8.9_B14436.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.9_B14436.jpg](img/Figure_8.9_B14436.jpg)'
- en: Figure 8.9 – The various CX gate errors for the qubit combinations of ibmq_santiago
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.9 – ibmq_santiago量子比特组合的各种CX门错误
- en: To verify that we have collected the correct information, we display the error
    map for the backend.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了验证我们收集到的信息是否正确，我们显示了后端错误图。
- en: 'Take a look at the CNOT error rate legend in *Figure 8.10* and verify that
    the CX connectors that we have selected really are the best [1,2] and worst [3,4]:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看图8.10中的CNOT错误率图例，并验证我们选择的CX连接器确实是最佳[1,2]和最差[3,4]：
- en: '![Figure 8.10 – Error map showing the best [1,2] and worst [3,4] CX connectors
    for ibmq_santiago](img/Figure_8.10_B14436.jpg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Figure 8.10 – 显示ibmq_santiago最佳[1,2]和最差[3,4] CX连接器的错误图](img/Figure_8.10_B14436.jpg)'
- en: Figure 8.10 – Error map showing the best [1,2] and worst [3,4] CX connectors
    for ibmq_santiago
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.10 – 显示ibmq_santiago最佳[1,2]和最差[3,4] CX连接器的错误图
- en: Two quantum circuits sized for the selected backend are created and displayed.
    These circuits represent the best and the worst CX connections for the backend.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所选后端创建了两个量子电路，并显示出来。这些电路代表了后端最佳和最差的CX连接。
- en: 'The best Bell circuit for the backend is shown in the next figure:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个图中显示了后端最佳Bell电路：
- en: '![Figure 8.11 – A Bell-state circuit for the best performing CX gate'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.11 – 最佳性能CX门的Bell态电路'
- en: '](img/Figure_8.11_B14436.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.11_B14436.jpg](img/Figure_8.11_B14436.jpg)'
- en: '[PRE13]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result of the preceding code will be something like this:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前述代码的结果可能如下所示：
- en: '![Figure 8.13 – A transpiled Bell-state circuit for the best performing CX
    gate'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.13 – 最佳性能CX门的重构Bell态电路'
- en: '](img/Figure_8.13_B14436.jpg)'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.13_B14436.jpg](img/Figure_8.13_B14436.jpg)'
- en: Figure 8.13 – A transpiled Bell-state circuit for the best performing CX gate
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.13 – 最佳性能CX门的重构Bell态电路
- en: As you can see, when we follow the qubit coupling map, our transpiled CX circuit
    looks exactly like the original circuit.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，当我们遵循量子比特耦合图时，我们的重构CX电路与原始电路完全一样。
- en: We now run the best and worst circuits on the backend together with a baseline
    execution of the same circuit on the Aer simulator:![Figure 8.14 – The results
    of the best, worst, and benchmark CX gate pairs
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在在后端上运行最佳和最差电路，同时在一个基准执行Aer模拟器上的相同电路：![Figure 8.14 – 最佳、最差和基准CX门对的结果
- en: '](img/Figure_8.14_B14436.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.14_B14436.jpg](img/Figure_8.14_B14436.jpg)'
- en: Figure 8.14 – The results of the best, worst, and benchmark CX gate pairs
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.14 – 最佳、最差和基准CX门对的结果
- en: 'And finally, we plot the results in a diagram for comparison:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将结果绘制成图表进行比较：
- en: '![Figure 8.15 – The benchmark, best, and worst results on the 5-qubit ibmq_santiago
    backend'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 – 5量子比特ibmq_santiago后端的基准、最佳和最差结果'
- en: '](img/Figure_8.15_B14436.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.15_B14436.jpg)'
- en: Figure 8.15 – The benchmark, best, and worst results on the 5-qubit ibmq_santiago
    backend
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 5量子比特ibmq_santiago后端的基准、最佳和最差结果
- en: You now have a visual view, as well as numerical evidence that the qubits and
    gates on a chip differ in performance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有了直观的视图，以及数值证据，表明芯片上的量子比特和门在性能上有所不同。
- en: Take a look at the results here. We expect the simulated baseline (blue bars)
    to return perfect results for ![](img/Formula_008_007.png) and ![](img/Formula_008_008.png)
    only at the expected 50/50 spread. Note how there are no blue ![](img/Formula_008_012.png)
    and ![](img/Formula_008_013.png) results for the simulator.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这里的结果。我们预计模拟的基线（蓝色条形）只在预期的50/50分布下返回完美的结果 ![](img/Formula_008_007.png) 和 ![](img/Formula_008_008.png)。注意模拟器没有蓝色
    ![](img/Formula_008_012.png) 和 ![](img/Formula_008_013.png) 结果。
- en: On a real machine, the results are affected by qubit errors, as can be seen
    in the red (worst) and green (best) bars, with the IBM backends to return noisy
    results for all combinations ![](img/Formula_008_014.png), with the best qubit
    pair slightly less noisy than the worst pair.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际机器上，结果会受到量子比特错误的影响，如红色（最差）和绿色（最佳）条形所示，IBM 后端对所有组合 ![](img/Formula_008_014.png)
    返回有噪声的结果，最佳量子比特对略低于最差对。
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Keep in mind that the results that you see are not just based on the CNOT coupling
    error, but also on qubit errors and read and write errors for your qubits. To
    completely understand the results of runs like these, you need to consider error
    mitigation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你看到的结果不仅基于CNOT耦合错误，还基于量子比特错误以及你的量子比特的读写错误。要完全理解这类运行的结果，你需要考虑错误缓解。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments:* [https://arxiv.org/pdf/1809.03452.pdf](https://arxiv.org/pdf/1809.03452.pdf).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Qiskit 后端规格说明，适用于 OpenQASM 和 OpenPulse 实验:* [https://arxiv.org/pdf/1809.03452.pdf](https://arxiv.org/pdf/1809.03452.pdf)。'
- en: Estimating the number of gates you have time for
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 估算你可以用的时间进行门操作的数量
- en: 'In addition to the gate errors that we have explored in the first two recipes,
    the end result of your recipes depends on another physical aspect of the qubits
    that we run on: the T1 and T2 times. We first discussed these in the *Explore
    your qubits to understand T1, T2, and errors* recipe:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在前两个菜谱中探讨的门错误之外，你的菜谱的最终结果还取决于我们在运行的量子比特的另一个物理方面：T1和T2时间。我们首先在 *探索你的量子比特以了解T1、T2和错误*
    菜谱中讨论了这些：
- en: '**T1**, or **relaxation time**: The T1 value is a statistical value of how
    long it takes for the qubit to spontaneously relax from the "excited" state ![](img/Formula_008_015.png)
    to the ground state ![](img/Formula_008_016.png). In essence, T1 is the upper
    limit, in microseconds, that you have at your disposal to perform high-quality
    actions on the qubit.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T1**，或**弛豫时间**：T1值是量子比特从“激发”状态 ![](img/Formula_008_015.png) 到基态 ![](img/Formula_008_016.png)
    自发弛豫所需时间的统计值。本质上，T1是你可用于对量子比特执行高质量操作的微秒级上限。'
- en: '**T2**, or **dephasing time**: Similar to T1, the T2 value is a statistical
    measure of how phase information is lost for a qubit. An example of phase change
    is when the state ![](img/Formula_008_003.png) spontaneously changes to ![](img/Formula_008_018.png).
    Again, if the running time for your circuit starts to approach the T2 time, the
    quality of your readout data will suffer.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T2**，或**去相位时间**：与T1类似，T2值是量子比特相位信息丢失的统计度量。相位变化的一个例子是当状态 ![](img/Formula_008_003.png)
    自发变为 ![](img/Formula_008_018.png)。再次强调，如果你的电路运行时间开始接近T2时间，你的读出数据质量将受到影响。'
- en: With this data, we can make a rough estimate of how the size of our programs
    might affect the end result. Not only do we have to take into account the error
    rates for the individual gates but we have to also understand how the T1/T2 times
    limit the number of gates that can actually be run. How many gates can we squeeze
    into our programs before they just return garbage? Let's take a look.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些数据，我们可以粗略估计我们的程序大小可能如何影响最终结果。我们不仅要考虑单个门的错误率，还要理解T1/T2时间如何限制可以实际运行的门数量。在我们程序返回垃圾之前，我们能塞入多少门？让我们看看。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的食谱中所需的文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py)。
- en: The sample code
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'First, we import the class that we need and load our account. In this recipe,
    we combine a lot of important concepts from earlier in the book, such as simulators
    and noise models:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类并加载我们的账户。在这个食谱中，我们结合了书中早期的一些重要概念，例如模拟器和噪声模型：
- en: '[PRE14]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `select_backend()` function lets you select an available backend:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`select_backend()` 函数允许您选择一个可用的后端：'
- en: '[PRE15]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When passed an IBM Quantum® backend name, the `display_information(backend,n_id,ttype)`
    function pulls the T1, T2, readout error, and length of an `id` gate for qubit
    0 of that backend:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当传递一个 IBM Quantum® 后端名称时，`display_information(backend,n_id,ttype)` 函数会提取该后端量子位
    0 的 T1、T2、读出错误和 `id` 门长度：
- en: '[PRE16]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `build_circuit(ttype,n_id)` function takes a number and builds a basic circuit
    that includes that amount of Id gates. It starts the circuit with an X gate to
    place the qubit in the ![](img/Formula_008_015.png), or excited state. The purpose
    of the circuit is to wait for a period of time and then measure the qubit, and
    the Id gate is perfect for the job; it doesn't perform any qubit manipulation,
    but still takes a certain amount of time to execute. If we have waited long enough,
    the qubit will spontaneously relax down to the ground state, or ![](img/Formula_008_016.png).
    This will require more or less gates depending on the T1 value for the qubit.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build_circuit(ttype,n_id)` 函数接受一个数字并构建一个包含该数量 Id 门的基电路。电路以一个 X 门开始，将量子位置于
    ![](img/Formula_008_015.png) 或激发态。电路的目的是等待一段时间然后测量量子位，而 Id 门非常适合这项工作；它不执行任何量子位操作，但仍然需要一定的时间来执行。如果我们等待足够长的时间，量子位将自发地松弛到基态，或
    ![](img/Formula_008_016.png)。这将根据量子位的 T1 值需要更多或更少的门。'
- en: 'Depending on the value of the `ttype` parameter, we will build one of the following:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据 `ttype` 参数的值，我们将构建以下之一：
- en: '`T1`: Set up a simple circuit that puts the qubit in state ![](img/Formula_008_021.png),
    then add a number of Id gates to make time pass, and finally perform the measurement
    of the outcome at different circuit lengths.'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`T1`：设置一个简单的电路，将量子位置于状态 ![](img/Formula_008_021.png)，然后添加多个 Id 门以使时间流逝，并最终在不同电路长度下测量结果。'
- en: '`T2`: Similarly, set up a simple circuit that puts the qubit in state ![](img/Formula_008_015.png),
    then in superposition ![](img/Formula_008_003.png) with phase ![](img/Formula_008_024.png).
    Then add a number of Id gates to make time pass, and finally apply another H gate
    and measure. If the qubit is still in ![](img/Formula_008_003.png), it will now
    measure as ![](img/Formula_008_015.png), but if it has spontaneously changed phase,
    approaching ![](img/Formula_008_018.png), it will read as ![](img/Formula_008_016.png)
    with a certain probability:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`T2`：同样，设置一个简单的电路，将量子位置于状态 ![](img/Formula_008_015.png)，然后处于叠加态 ![](img/Formula_008_003.png)
    并具有相 ![](img/Formula_008_024.png)。然后添加多个 Id 门以使时间流逝，最后应用另一个 H 门并测量。如果量子位仍然处于 ![](img/Formula_008_003.png)
    状态，它现在将测量为 ![](img/Formula_008_015.png)，但如果它自发地改变了相位，接近 ![](img/Formula_008_018.png)，它将以一定的概率读取为
    ![](img/Formula_008_016.png)：'
- en: '[PRE17]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we run the circuit on a simulator, we use the `build_noisemodel(backend)`
    function to build a noise model for the selected backend. We then use the noise
    model in `execute_circuit()` to simulate running the circuit on the actual backend:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在模拟器上运行电路，我们使用 `build_noisemodel(backend)` 函数为所选后端构建一个噪声模型。然后我们在 `execute_circuit()`
    中使用该噪声模型来模拟在真实后端上运行电路：
- en: '[PRE18]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the `execute_circuit(backend, circuit,noise_model, n_id)` function, we
    run the circuit on a simulated version of the selected backend by using the noise
    model we created in `build_noisemodel()`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `execute_circuit(backend, circuit,noise_model, n_id)` 函数，我们通过使用在 `build_noisemodel()`
    中创建的噪声模型，在所选后端的模拟版本上运行电路：
- en: '[PRE19]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `main` function can be broken up into a set of processes, starting with
    the input and information section:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 函数可以被分解成一系列过程，从输入和信息部分开始：'
- en: '[PRE20]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With all input, noise model, and initial circuit creation taken care of, we
    can now run the circuit on a pure simulator and then on the selected backend,
    either simulated or on IBM Quantum®. We store our results in an `entry` dictionary,
    and the lengths of the executed circuits in a `legend` array, then use them to
    present the results:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在处理完所有输入、噪声模型和初始电路创建后，我们现在可以在纯模拟器上运行电路，然后在所选后端上运行，无论是模拟的还是 IBM Quantum®。我们将我们的结果存储在
    `entry` 字典中，将执行电路的长度存储在 `legend` 数组中，然后使用它们来展示结果：
- en: '[PRE21]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we merge the results from the results dictionary into a `results_array`
    array, matching the lengths from the `legend` array, then display all the results
    in a combined diagram:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将结果字典中的结果合并到 `results_array` 数组中，与 `legend` 数组的长度匹配，然后在组合图表中显示所有结果：
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To explore how a qubit relaxes from the excited ![](img/Formula_06_023.png)
    state to the ground state ![](img/Formula_06_0221.png), follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索一个量子位如何从激发态 ![img/Formula_06_023.png] 衰减到基态 ![img/Formula_06_0221.png]，请按照以下步骤操作：
- en: In your Python environment, run `ch8_r3_time.py`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Python 环境中运行 `ch8_r3_time.py`。
- en: 'The script loads Qiskit® and grabs and displays a list of the available backends.
    Enter the name of a backend that you want to test on, then enter `S` to run on
    a noise-simulated version of the backend. Finally, enter the number of Id gates
    that you want to include in your circuit, for example, `1024`:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脚本加载 Qiskit® 并获取并显示可用的后端列表。输入你想要测试的后端名称，然后输入 `S` 以在噪声模拟的后端版本上运行。最后，输入你想要包含在你的电路中的
    Id 级数门数量，例如，`1024`：
- en: '![Figure 8.16 – Select a backend, whether to run on the actual backend, and
    enter a number of Id gates'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.16 – 选择后端，是否在真实后端运行，并输入 Id 级数门数量'
- en: '](img/Figure_8.16_B14436.jpg)'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.16_B14436.jpg)'
- en: Figure 8.16 – Select a backend, whether to run on the actual backend, and enter
    a number of Id gates
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.16 – 选择后端，是否在真实后端运行，并输入 Id 级数门
- en: Various pieces of data for the first qubit of the selected backend are displayed.
    We are particularly interested in the T1 value and the Id gate length. From these,
    we can estimate how long our circuit will take to run, and the percentage of the
    T1 time that will be consumed. We are not particularly concerned about gate errors;
    the Id gate does not do any qubit manipulation but is really only a delay gate:![Figure
    8.17 – The backend data
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示所选后端第一个量子位的各种数据。我们特别关注 T1 值和 Id 级数门长度。从这些数据中，我们可以估计电路运行所需的时间以及 T1 时间将消耗的百分比。我们并不特别关注门错误；Id
    级数门不进行任何量子位操作，实际上只是一个延迟门：![图 8.17 – 后端数据
- en: '](img/Figure_8.17_B14436.jpg)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.17_B14436.jpg)'
- en: Figure 8.17 – The backend data
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.17 – 后端数据
- en: We also display a representative sample circuit with five Id gates. Your actual
    circuit will be much, much bigger, but with the same architecture; a long string
    of barriers and Id gates:![Figure 8.18 – Sample Id-circuit
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还显示了一个包含五个 Id 级数门的有代表性电路。你的实际电路将大得多，但具有相同的架构；一长串屏障和 Id 级数门：![图 8.18 – 样例 Id
    电路
- en: '](img/Figure_8.18_B14436.jpg)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B14436.jpg)'
- en: Figure 8.18 – Sample Id-circuit
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.18 – 样例 Id 电路
- en: The circuit now runs, first on the build in the Qiskit Aer `qasm_simulator`
    for a clean result, then on the simulated or actual backend. It starts with a
    circuit with the selected number of Id gates, and then runs successively shorter
    circuits until it reaches a circuit with just one Id gate:![Figure 8.19 – Raw
    T1 results on the simulated ibmq_valencia backend
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电路现在运行，首先在 Qiskit Aer 内置的 `qasm_simulator` 上运行以获得干净的结果，然后是在模拟或真实后端上。它从一个具有所选
    Id 级数门数量的电路开始，然后依次运行更短的电路，直到达到只有一个 Id 级数门的电路：![图 8.19 – 模拟的 ibmq_valencia 后端上的原始
    T1 结果
- en: '](img/Figure_8.19_B14436.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.19_B14436.jpg)'
- en: Figure 8.19 – Raw T1 results on the simulated ibmq_valencia backend
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.19 – 模拟的 ibmq_valencia 后端上的原始 T1 结果
- en: Finally, it collects and displays the results of all the runs in one diagram:![Figure
    8.20 – T1 results on the simulated ibmq_valencia backend
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它收集并显示所有运行的图表结果：![图 8.20 – 在模拟的 ibmq_valencia 后端上的 T1 结果
- en: '](img/Figure_8.20_B14436.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.20_B14436.jpg)'
- en: Figure 8.20 – T1 results on the simulated ibmq_valencia backend
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 在模拟的 ibmq_valencia 后端上的 T1 结果
- en: Alright, so what do these results mean? Let's take a look…
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么这些结果意味着什么呢？让我们看看...
- en: As you can see, the probability of getting the result ![](img/Formula_06_023.png)
    gets lower and lower as the number of gates increases. At 1,024 gates, we are
    down to roughly 70%, which is pretty close to just noise. Try doubling the number
    of gates to 2,048 and see if the curve lands you somewhere close to 50% or so.
    So, where do you need to be to have a stab at actually getting good results from
    your circuits? Take a look at *Figure 8.20* again – this time, at the 1 Id gate
    circuit end. The probability of getting the result ![](img/Formula_06_139.png)
    hovers around 93-95%, and a bit of the uncertainty here comes from the readout
    error, which in our case was around 3.5%. This hints at a max circuit length of
    around 64 Id gates before things start to go wrong.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，随着门数的增加，得到结果 ![](img/Formula_06_023.png) 的概率越来越低。在1,024个门时，我们下降到大约70%，这几乎接近噪声。尝试将门数加倍到2,048，看看曲线是否接近50%左右。所以，你需要达到什么水平才能从你的电路中获得好的结果？再次查看
    *图8.20* – 这次，查看1个Id门电路的末端。得到结果 ![](img/Formula_06_139.png) 的概率在93-95%之间徘徊，这里的不确定性部分来自读出错误，在我们的案例中约为3.5%。这暗示了在事情开始出错之前，最大电路长度约为64个Id门。
- en: Also remember that this measurement only takes into account the T1 relaxation
    time, and only really measures the performance of the qubit at various circuit
    lengths, only using Id gates, which are not really useful for building actual
    quantum circuits.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，这个测量只考虑了T1弛豫时间，并且实际上只测量了在各个电路长度下量子比特的性能，只使用了Id门，这些门实际上对构建实际的量子电路并不真正有用。
- en: For actual, useful circuits, we also need to take into account other factors
    such as gate errors, transpiling architecture, and more. This means that you cannot
    just extrapolate the circuit count you deem OK quality-wise from this experiment
    and set that as your gate limit for a backend. Take a look back at the *Comparing
    the Qiskit Aer simulator with an IBM quantum computer* recipe in [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197),
    *Simulating Quantum Computers with Aer*, for a rudimentary example of what gate
    errors can do in long circuits.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际且有用的电路，我们还需要考虑其他因素，例如门错误、架构重编译等。这意味着你不能仅仅从这次实验中推断出你认为质量上可接受的电路数量，并将其设置为后端的门限制。回顾一下
    [*第7章*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197) 中的 *Comparing the Qiskit
    Aer simulator with an IBM quantum computer* 菜单，*使用Aer模拟量子计算机*，以了解门错误在长电路中可能产生的影响的初步示例。
- en: There's more
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: After this first run-through, you can test a couple of other scenarios, as discussed
    next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行之后，你可以测试一些其他场景，如接下来将要讨论的。
- en: Comparing backends
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较后端
- en: Try running identical circuits on different backends to see how the results
    differ. IBM Quantum® is hard at work—developing better and better qubits and control
    circuitry and you can see how progressively newer backends generally have longer
    T1/T2 times, and better performing qubits. You can estimate how old a backend
    is by looking at the **online since** dates in *Figure 8.21*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在不同的后端上运行相同的电路，以查看结果如何不同。IBM Quantum® 正在努力工作——开发更好的量子比特和控制电路，你可以看到较新的后端通常具有更长的T1/T2时间，并且量子比特的性能更好。你可以通过查看
    *图8.21* 中的 **online since** 日期来估计后端有多旧。
- en: 'Here, for example, are the results of the 1,024 Id gate circuit on the `ibmqx2`
    backend, which came online in January 2017\. Compare these to the `ibmq_valencia`
    results that we just obtained. That backend has been online since July 2019:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是 `ibmqx2` 后端上1,024个Id门电路的结果，该后端于2017年1月上线。将这些结果与我们刚刚获得的 `ibmq_valencia`
    结果进行比较。该后端自2019年7月上线：
- en: '![Figure 8.21 – Results on ibmqx2, an older backend with a shorter T1'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – 在较旧的、T1较短的ibmqx2后端上的结果'
- en: '](img/Figure_8.21_B14436.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.21_B14436.jpg)'
- en: Figure 8.21 – Results on ibmqx2, an older backend with a shorter T1
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 在较旧的、T1较短的ibmqx2后端上的结果
- en: By comparing the data in *Figure 8.20* (`ibmq_valencia`) with the data in *Figure
    8.21* (`ibmqx2`), you can see that the T1 time is more than twice as long for
    the newer `ibmq_valencia` backend and that the probability of getting the correct
    result after 1,024 Id gates is much higher (70% versus 46%).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较 *图8.20* (`ibmq_valencia`) 中的数据与 *图8.21* (`ibmqx2`) 中的数据，你可以看到对于较新的 `ibmq_valencia`
    后端，T1 时间是旧后端的两倍以上，并且在经过1,024个Id门之后得到正确结果的可能性要高得多（70% 对比 46%）。
- en: Running on an IBM Quantum® backend
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在IBM Quantum® 后端上运行
- en: Now, test running the same test on the actual backend by running the sample
    script `ch8_r3_time.py` again and entering `Q` when prompted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过再次运行示例脚本 `ch8_r3_time.py` 并在提示时输入 `Q`，来在实际后端上测试运行相同的测试。
- en: Pick a suitable backend
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的后端
- en: As we will be running about half a dozen individual jobs or so, the complete
    run might take some time depending on the number of users that are running jobs
    on the backend. Before you pick a backend to run on, check the **pending jobs**
    number for the backend.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将运行大约半打单独的任务，整个运行时间可能会根据在后台运行任务的用户数量而有所不同。在您选择要运行的后端之前，请检查后端的**待处理任务**数量。
- en: 'When running on the actual backend, the job monitor provides information about
    your place in the queue. For the backend `ibmq_valencia`, this might give the
    following result:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际后端运行时，作业监视器会提供有关您在队列中的位置的信息。对于`ibmq_valencia`后端，这可能会给出以下结果：
- en: '![Figure 8.22 – Raw T1 results on the ibmq_valencia backend'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – ibmq_valencia后端的原始T1结果](img/Figure_8.22_B14436.jpg)'
- en: '](img/Figure_8.22_B14436.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – ibmq_valencia后端的原始T1结果](img/Figure_8.22_B14436.jpg)'
- en: Figure 8.22 – Raw T1 results on the ibmq_valencia backend
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – ibmq_valencia后端的原始T1结果
- en: 'Plotted side by side, you get a visual comparison:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 并排绘制，您可以得到一个直观的比较：
- en: '![Figure 8.23 – T1 results on the ibmq_valencia backend'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 – ibmq_valencia后端的T1结果](img/Figure_8.23_B14436.jpg)'
- en: '](img/Figure_8.23_B14436.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 – ibmq_valencia后端的原始T1结果](img/Figure_8.23_B14436.jpg)'
- en: Figure 8.23 – T1 results on the ibmq_valencia backend
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – ibmq_valencia后端的T1结果
- en: See how the qubit relaxes from ![](img/Formula_008_033.png) as the number of
    Id gates increases, and thus the *wait* time gets longer. Note how the actual
    backend results match the simulated results pretty well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 看看量子比特如何随着Id门数量的增加从![](img/Formula_008_033.png)中放松，因此*等待*时间变长。注意实际的后端结果与模拟结果非常吻合。
- en: Testing T2 dephasing
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试T2退相
- en: 'You can also test the T2 value – how your qubit dephases – by changing the
    type parameter from `"T1"` to `"T2"` in the sample code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在示例代码中将类型参数从`"T1"`更改为`"T2"`来测试T2值——即您的量子比特退相的情况：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'How is the sample circuit different in this case? As the T2 time measures dephasing,
    we must first set up our qubit to actually have phase information. We start off
    our circuit with an X gate, putting our qubit in the ![](img/Formula_06_023.png)
    state. We then add an H gate, which brings the qubit to the ![](img/Formula_008_035.png)
    state, which is the same as the ![](img/Formula_008_036.png) state phase-shifted
    by ![](img/Formula_008_037.png) radians:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，样本电路有何不同？由于T2时间测量退相，我们必须首先设置我们的量子比特以实际具有相位信息。我们以X门开始我们的电路，将量子比特置于![](img/Formula_06_023.png)状态。然后我们添加一个H门，将量子比特带到![](img/Formula_008_035.png)状态，这与![](img/Formula_008_036.png)状态相同，只是相位移了![](img/Formula_008_037.png)弧度：
- en: '![Figure 8.24 – The T2 circuit includes H gates to place our qubit in the  state,
    with a  phase](img/Figure_8.24_B14436.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24 – T2电路包括H门，将我们的量子比特置于![](img/Formula_008_040.png)状态，并带有![](img/Formula_008_039.png)相位的图中](img/Figure_8.24_B14436.jpg)'
- en: Figure 8.24 – The T2 circuit includes H gates to place our qubit in the ![](img/Formula_008_035.png)
    state, with a ![](img/Formula_008_039.png) phase
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – T2电路包括H门，将我们的量子比特置于![](img/Formula_008_035.png)状态，并带有![](img/Formula_008_039.png)相位的图中
- en: 'We then let time pass, giving the qubit the opportunity to dephase a bit from
    the initial ![](img/Formula_008_040.png) phase, before adding another H gate to
    bring us back to the computational basis so that we can measure the qubit:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们让时间流逝，给量子比特一点时间从初始![](img/Formula_008_040.png)相位中退相，然后再添加另一个H门，将我们带回到计算基，以便我们可以测量量子比特：
- en: '![Figure 8.25 – T2 results on the ibmqx2 backend'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 – ibmqx2后端的T2结果](img/Figure_8.25_B14436.jpg)'
- en: '](img/Figure_8.25_B14436.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 – ibmqx2后端的T2结果](img/Figure_8.25_B14436.jpg)'
- en: Figure 8.25 – T2 results on the ibmqx2 backend
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – ibmqx2后端的T2结果
- en: By looking at *Figure 8.25* and *Figure 8.21*, you can now get a complete picture
    of the T1 and T2 impact on your qubit. Try running with even more Id gates to
    see how the behavior changes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看*图8.25*和*图8.21*，你现在可以对你的量子比特的T1和T2影响有一个完整的了解。尝试运行带有更多Id门的任务，看看行为如何变化。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For a much more detailed description of T1 and T2 and how to measure it, take
    a look at *Learn Quantum Computing with Python and IBM Quantum Experience*, *Chapter
    11*, *Mitigating Quantum Errors Using Ignis*, by Robert Loredo, Packt, 2020.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解T1和T2以及如何测量它们，请参阅Robert Loredo所著的《用Python和IBM Quantum Experience学习量子计算》，第11章，*使用Ignis减轻量子错误*，Packt出版社，2020年。
- en: Correcting for the expected with readout correction
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用读出校正来校正预期的
- en: Now that we have some knowledge about what might go wrong when we use our qubits
    for quantum calculations, is there anything that we can do about it? There are
    essentially two approaches here, at least for the small quantum backends that
    we have at our disposal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些关于当我们使用我们的量子比特进行量子计算时可能会出现的问题，我们能做些什么来解决这个问题吗？这里本质上有两种方法，至少对于我们现在可用的那些小型的量子后端来说。
- en: First, we can make sure that the quantum programs that we run have a fighting
    chance of completing before the qubits get lost due to decoherence, the T1 and
    T2 times that we explored. This means that we make the programs short.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以确保我们运行的量子程序在量子比特因退相干而丢失之前有完成的机会，这就是我们之前探索的 T1 和 T2 时间。这意味着我们使程序变得简短。
- en: Second, we can take a good look at various readout errors and see if we can
    mitigate those. If you remember in [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197),
    *Simulating Quantum Computers with Aer*, we could pull in actual backend qubit
    data to `qasm_simulator` and have it behave like an NISQ backend. We can do the
    same in reverse, analyze the measurement errors for a backend, and use that data
    to create a mitigation map to counteract erroneous measurements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以仔细查看各种读出错误，看看我们是否可以减轻这些错误。如果你还记得在 [*第 7 章*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197)，*使用
    Aer 模拟量子计算机*，我们可以在 `qasm_simulator` 中引入实际的底层量子比特数据，并让它表现得像一个 NISQ 后端。我们可以反过来操作，分析后端的测量错误，并使用这些数据创建一个缓解图来对抗错误的测量。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py).
- en: The sample code
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'To handle the creation and running of the readout correction, we build a number
    of functions in the `ch8_r4_ignis.py` script:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理读出校正的创建和运行，我们在 `ch8_r4_ignis.py` 脚本中构建了多个函数：
- en: 'First, we import the classes and methods that we need. You can import Qiskit®
    and load the account by running the following code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类和方法。你可以通过运行以下代码来导入 Qiskit® 和加载账户：
- en: '[PRE24]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using `select_backend()`, we load and display the data for the available backends,
    and then prompt to select one:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `select_backend()`，我们加载并显示可用的后端数据，然后提示选择一个：
- en: '[PRE25]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using `create_circuit()`, we create a basic GHZ-state circuit for which we
    know the expected outcomes – ![](img/Formula_008_041.png):'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用 `create_circuit()`，我们创建了一个基本的 GHZ 状态电路，对于这个电路，我们知道预期的结果 – ![公式_008_041.png](img/Formula_008_041.png):'
- en: '[PRE26]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`simulator_results(circuit)` runs the provided circuit on the local Qiskit
    Aer simulator:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`simulator_results(circuit)` 在本地 Qiskit Aer 模拟器上运行提供的电路：'
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`noisy_results(circuit,backend)` runs the provided circuit on the provided
    backend:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`noisy_results(circuit,backend)` 在提供的后端上运行提供的电路：'
- en: '[PRE28]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This `mitigated_results(backend,circuit,results)` function is the main function
    we build to run error mitigation on the provided results, based on backend measurement
    error data:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `mitigated_results(backend,circuit,results)` 函数是我们构建的主要函数，用于根据后端测量错误数据在提供的结果上运行错误缓解：
- en: '[PRE29]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And finally, the `main()` function helps in wrapping up the function flow and
    final data presentation:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`main()` 函数有助于封装函数流程和最终数据展示：
- en: '[PRE30]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it…
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In your local Qiskit® environment, run the `ch8_r4_ignis.py` sample, then select
    one of the available backends to test on:![Figure 8.26 – Select an available backend
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的本地 Qiskit® 环境中，运行 `ch8_r4_ignis.py` 示例，然后选择一个可用的后端进行测试：![Figure 8.26 – 选择一个可用的后端
- en: '](img/Figure_8.26_B14436.jpg)'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.26_B14436.jpg](img/Figure_8.26_B14436.jpg)'
- en: Figure 8.26 – Select an available backend
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 8.26 – 选择一个可用的后端
- en: We'll now build the GHZ-state circuit that we will be testing with. We know
    that the expected outcomes are ![](img/Formula_008_043.png), and can use that
    information to validate how well our circuit runs on the selected backend, and
    how well we can error correct:![Figure 8.27 – The GHZ-state circuit that we will
    test with
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将构建我们将要测试的 GHZ 状态电路。我们知道预期的结果是 ![公式_008_043.png](img/Formula_008_043.png)，我们可以使用这些信息来验证我们的电路在所选后端上的运行情况，以及我们纠错的能力：![Figure
    8.27 – 我们将要测试的 GHZ 状态电路
- en: '](img/Figure_8.27_B14436.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.27_B14436.jpg](img/Figure_8.27_B14436.jpg)'
- en: Figure 8.27 – The GHZ-state circuit that we will test with
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 8.27 – 我们将要测试的 GHZ 状态电路
- en: The script now runs the circuit on a local simulator and on the selected backend:![Figure
    8.28 – Results on the local qasm_simulator and on the ibmqx2 backend
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在脚本将在本地模拟器和选定的后端上运行电路：![Figure 8.28 – 本地 qasm_simulator 和 ibmqx2 后端的结果
- en: '](img/Figure_8.28_B14436.jpg)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.28_B14436.jpg](img/Figure_8.28_B14436.jpg)'
- en: Figure 8.28 – Results on the local qasm_simulator and on the ibmqx2 backend
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 8.28 – 本地 qasm_simulator 和 ibmqx2 后端的结果
- en: Now that we have the results of the circuit when run on the backend, we can
    pull in the actual qubit and gate data from the backend and build a noise model.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了在后端运行电路的结果，我们可以从后端拉取实际的量子比特和门数据，并构建一个噪声模型。
- en: 'The model includes statistics on the measurement behavior for the backend''s
    qubits:'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该模型包括后端量子比特的测量行为统计：
- en: '![Figure 8.29 – Calibration matrix with the expected results and the statistical
    measurement errors'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.29 – 包含预期结果和统计测量误差的校准矩阵'
- en: '](img/Figure_8.29_B14436.jpg)'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.29_B14436.jpg](img/Figure_8.29_B14436.jpg)'
- en: Figure 8.29 – Calibration matrix with the expected results and the statistical
    measurement errors
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.29 – 包含预期结果和统计测量误差的校准矩阵
- en: In *Figure 8.29*, you can see the expected results in the diagonal, and the
    statistical measurement errors as gray shading away from the diagonal. The darker
    the shading, the higher the probability of getting that result.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在*图8.29*中，你可以看到对角线上的预期结果，以及从对角线远离的灰色阴影表示的统计测量误差。阴影越深，得到该结果的可能性越高。
- en: 'We can use this data to rerun the circuit on the local simulator, with the
    measurement calibration data as input. We can then run the original results through
    a measurement filter and get the mitigated results as follows:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用这些数据在本地模拟器上重新运行电路，将测量校准数据作为输入。然后，我们可以将原始结果通过测量滤波器运行，得到以下缓解结果：
- en: '![Figure 8.30 – The mitigated results for ibmq_16_melbourne'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 8.30 – ibmq_16_melbourne的缓解结果'
- en: '](img/Figure_8.30_B14436.jpg)'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.30_B14436.jpg](img/Figure_8.30_B14436.jpg)'
- en: Figure 8.30 – The mitigated results for ibmq_16_melbourne
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.30 – ibmq_16_melbourne的缓解结果
- en: 'Finally, we can plot the simulator results, the original backend results, and
    the mitigated results for comparison:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以绘制模拟器结果、原始后端结果和缓解结果以进行比较：
- en: '![Figure 8.31 – A comparison of results for simulator, backend, and mitigated
    backend'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.31 – 模拟器、后端和缓解后端的比较结果'
- en: '](img/Figure_8.31_B14436.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.31_B14436.jpg](img/Figure_8.31_B14436.jpg)'
- en: Figure 8.31 – A comparison of results for simulator, backend, and mitigated
    backend
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31 – 模拟器、后端和缓解后端的比较结果
- en: From the final chart, you can see that the expected results for a GHZ-state
    circuit, ![](img/Formula_008_042.png) with roughly a 50/50 chance, is not what
    we get on the backend. There are a large number of noisy bars between the expected
    results. With the error mitigation, we shrink these bars and bring the results
    closer to the expected.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终的图表中，你可以看到对于GHZ态电路的预期结果![img/Formula_008_042.png](img/Formula_008_042.png)，大约有50/50的机会，并不是我们在后端得到的结果。在预期结果之间有许多噪声条。通过错误缓解，我们缩小了这些条，并将结果更接近预期。
- en: Mitigating the unexpected with quantum error correction
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用量子错误纠正缓解意外情况
- en: As we saw in the previous recipe, it is good to understand how your measurements
    behave, to statistically be able to correct incorrect readouts. But in the end,
    a measurement is just a measurement, and a measurement of a qubit will result
    in either 0 or 1\. If the state of the qubit that you measure turns out to be
    ![](img/Formula_06_058.png) instead of the expected ![](img/Formula_008_045.png),
    it doesn't matter that you statistically corrected for measurement mistakes; your
    qubit is off by 100%.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例中所示，了解你的测量行为是很有好处的，以便在统计上能够纠正错误的读数。但最终，一个测量只是一个测量，对一个量子比特的测量将导致0或1。如果你测量的量子比特状态最终是![img/Formula_06_058.png](img/Formula_06_058.png)而不是预期的![img/Formula_008_045.png](img/Formula_008_045.png)，即使你统计上纠正了测量错误，你的量子比特也有100%的错误。
- en: There are a lot of things that can perturb our qubits, from gate errors to just
    plain physics that causes the qubit to decohere and dephase (remember the T1 and
    T2 times). In the classical computing world, we can periodically check in on our
    bits, and apply error correction coding to make sure that they behave. Digital
    error correction is one of the reasons that digital communication works and that
    you can play digital media, CDs, DVDs, and Blu-ray disks and actually hear or
    see what you expect.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多因素可能会干扰我们的量子比特，从门错误到简单的物理因素，这些因素会导致量子比特去相干和去相位（记住T1和T2时间）。在经典计算世界中，我们可以定期检查我们的比特，并应用错误纠正编码来确保它们的行为。数字错误纠正是数字通信能够工作以及你可以播放数字媒体（如CD、DVD和蓝光光盘）并真正听到或看到你所期望的原因之一。
- en: One way of performing classical error correction is to duplicate one bit that
    you want to transfer into three bits, and at the end compare the bit with its
    duplicated brethren. If they are different, then at least one of the bits has
    been *errored*. Very simply put, you can then take a majority vote and flip the
    offending bit, and thus get the original back.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 执行经典错误纠正的一种方法是将你想要传输的一个比特复制成三个比特，并在最后比较这个比特与其复制品。如果它们不同，那么至少有一个比特已经*出错*。简单来说，你可以然后进行多数投票并翻转有问题的比特，从而恢复原始状态。
- en: For qubits, it is not so simple. For one, you cannot make copies of qubits like
    you can for classical bits. Instead, we have to make use of **superposition**
    and **entanglement**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于量子比特来说，事情并不那么简单。首先，你不能像经典比特那样复制量子比特。相反，我们必须利用**叠加**和**纠缠**。
- en: We discussed superposition at length in the *Comparing a bit and a qubit* recipe
    of [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing
    and Qubits with Python*, and entanglement in the *Quantum-cheating in a coin toss?
    – Introducing the Bell State* recipe of [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*. Feel free to go back for a refresher.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)的“比较比特和量子比特”菜谱中详细讨论了叠加，在[*第四章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)的“抛硬币的量子作弊？——介绍贝尔态”菜谱中讨论了纠缠，这些菜谱都来自《使用Python的量子计算与量子比特入门》。请随时回顾以巩固知识。
- en: Let's use these tools to explore further... Read on!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些工具进一步探索... 继续阅读！
- en: Getting ready
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py)。
- en: The sample code
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'To handle the creation and running of the Shor code algorithm, we will build
    a number of functions in the `ch8_r5_shor.py` script:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理Shor编码算法的创建和运行，我们将在`ch8_r5_shor.py`脚本中构建一系列函数：
- en: 'First, we import the methods that we need and set the backend:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的函数并设置后端：
- en: '[PRE31]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `get_psi(qc)` function is an old friend that we are reusing to return the
    state vector of the circuit, to display Bloch spheres and Q-spheres:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_psi(qc)`函数是一个老朋友，我们正在重新使用它来返回电路的状态向量，以显示Bloch球和Q球：'
- en: '[PRE32]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead of expecting the first qubit errors to occur naturally, we use the
    `add_error(error, circuit,ry_error, rz_error)` function to create four different
    types of errors – **Bit flip**, **Bit flip + phase flip**, **Theta + phi shift**,
    and **Random**:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不是期待第一个量子比特的错误自然发生，而是使用`add_error(error, circuit, ry_error, rz_error)`函数来创建四种不同类型的错误——**比特翻转**、**比特翻转
    + 相位翻转**、**Theta + phi偏移**和**随机**：
- en: '[PRE33]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `not_corrected(error, ry_error, rz_error)` function creates a simple 1-qubit
    circuit and introduces the error that we select in the main process, then displays
    the results as a Bloch sphere and a Q-sphere. We also run the circuit on the Qiskit
    Aer `qasm_simulator` to see the results of our contaminated qubit:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`not_corrected(error, ry_error, rz_error)`函数创建一个简单的1量子比特电路，并引入我们在主过程中选择出的错误，然后以Bloch球和Q球的形式显示结果。我们还运行了Qiskit
    Aer的`qasm_simulator`电路，以查看我们受污染的量子比特的结果：'
- en: '[PRE34]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now it is time to add the quantum correction code that Peter Shor developed.
    We are building the same circuit as before, but with 8 `add_error()` function.
    This simulates real-world perturbance of the qubit:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候添加Peter Shor开发的量子纠正代码了。我们正在构建与之前相同的电路，但使用了8个`add_error()`函数。这模拟了量子比特在现实世界中的扰动：
- en: '[PRE35]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**The end of the bit-flip correction**: After the errors have been introduced,
    we now start collecting our qubits again, starting with wrapping up the bit-flip
    correction and adjusting each of the phase-shift qubits if needed:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**比特翻转纠正的结束**：在引入错误后，我们现在开始再次收集我们的量子比特，从完成比特翻转纠正并调整每个相位偏移量子比特（如果需要）开始：'
- en: '[PRE36]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**The end of the phase-flip correction**: And similar to the bit flip wrapping
    up, we now close the phase-flip correction, applying any necessary correction
    to the first qubit:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**相位翻转纠正的结束**：类似于比特翻转的结束，我们现在关闭相位翻转纠正，对第一个量子比特应用任何必要的纠正：'
- en: '[PRE37]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Measure and print**: We can now measure the qubit and print the result:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**测量并打印**：我们现在可以测量量子比特并打印结果：'
- en: '[PRE38]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The program prompts for a numeric input to select the error to introduce, and
    then runs the `not_corrected()` and `shor_corrected()` functions:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序提示输入数字选择要引入的错误，然后运行`not_corrected()`和`shor_corrected()`函数：
- en: '[PRE39]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code we have built here can now be run, simulating the quantum error correction
    of any phase and the bit perturbation of the qubit.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的代码现在可以运行，模拟任何相位的量子错误校正和量子比特的位扰动。
- en: How to do it…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s take the Shor code for a spin:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试Shor码：
- en: In your Python environment, run `ch8_r5_shor.py`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Python环境中运行`ch8_r5_shor.py`。
- en: 'When prompted, enter the error type for a bit flip: `1`.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入位翻转的错误类型：`1`。
- en: The error-free qubit is displayed:![Figure 8.32 – The qubit with no error, in
    state
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无错误的量子比特显示：![图8.32 – 无错误的量子比特，处于状态
- en: '](img/Figure_8.32_B14436.jpg)'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.32_B14436.jpg)'
- en: Figure 8.32 – The qubit with no error, in state ![](img/Formula_008_052.png)
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.32 – 无错误的量子比特，处于状态 ![公式](img/Formula_008_052.png)
- en: Then, the selected error is added, and the results are displayed. The qubit
    has now flipped from ![](img/Formula_008_053.png):![Figure 8.33 – The qubit with
    the selected bit-flip error, turning the qubit from
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加所选错误，并显示结果。量子比特现在翻转到了![公式](img/Formula_008_053.png)：![图8.33 – 选择位翻转错误的量子比特，将量子比特从
- en: '](img/Figure_8.33_B14436.jpg)'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.33_B14436.jpg)'
- en: Figure 8.33 – The qubit with the selected bit-flip error, turning the qubit
    from ![](img/Formula_008_054.png)
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.33 – 选择位翻转错误的量子比特，将量子比特从 ![](img/Formula_008_054.png)
- en: Now, press *Enter* to create a new circuit and display the undisturbed qubit
    with its 8 ancilla qubits. The Q-sphere displays the possible outcomes of this
    new unperturbed circuit, all 9 qubits in ![](img/Formula_06_057.png):![Figure
    8.34 – Undisturbed qubit with 8 ancilla qubits
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按 *Enter* 键创建一个新的电路并显示未受干扰的量子比特及其8个辅助量子比特。Q-sphere显示了此新未受干扰电路的可能结果，所有9个量子比特在![公式](img/Formula_06_057.png)：![图8.34
    – 未受干扰的量子比特与8个辅助量子比特
- en: '](img/Figure_8.34_B14436.jpg)'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.34_B14436.jpg)'
- en: Figure 8.34 – Undisturbed qubit with 8 ancilla qubits
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.34 – 未受干扰的量子比特与8个辅助量子比特
- en: We now start the Shor code creation and add the simulated error. The Q-sphere
    now shows a number of possible outcomes as qubits 0, 3, and 6 are now in a superposition,
    giving a probabilistic outcome for those qubits, and for their entangled counterparts.
    Notice that qubit 0 can now appear as both ![](img/Formula_008_056.png):![Figure
    8.35 – Qubit with added bit-flip error, turning the qubit from
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在开始创建Shor码并添加模拟错误。Q-sphere现在显示了一些可能的结果，因为量子比特0、3和6现在是叠加态，为这些量子比特及其纠缠对应物提供了一个概率结果。注意，量子比特0现在可以表现为![公式](img/Formula_008_056.png)：![图8.35
    – 添加了位翻转错误的量子比特，将量子比特从
- en: '](img/Figure_8.35_B14436.jpg)'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.35_B14436.jpg)'
- en: Figure 8.35 – Qubit with added bit-flip error, turning the qubit from ![](img/Formula_008_0541.png)
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.35 – 添加了位翻转错误的量子比特，将量子比特从 ![](img/Formula_008_0541.png)
- en: 'Finally, we complete the Shor code, display the expected outcomes for the circuit,
    and then run it on the Aer `qasm_simulator`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们完成Shor码，显示电路的预期结果，然后在Aer的`qasm_simulator`上运行它：
- en: '![Figure 8.36 – Result of the error-corrected qubit, back at  again](img/Figure_8.36_B14436.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图8.36 – 错误校正后的量子比特结果，回到 ![](img/Formula_008_052.png) 再次](img/Figure_8.36_B14436.jpg)'
- en: Figure 8.36 – Result of the error-corrected qubit, back at ![](img/Formula_008_052.png)
    again
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36 – 错误校正后的量子比特结果，回到 ![](img/Formula_008_052.png) 再次
- en: Take a look at the Q-sphere and the results count. The state vector has safely
    put our qubit back at ![](img/Formula_008_059.png) again; note how the least-significant
    bit that represents the first qubit is now ![](img/Formula_008_060.png). The result
    also points to our qubit being safely error-corrected, with a 100% chance of 0.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 看看Q-sphere和结果计数。状态向量已安全地将我们的量子比特放回![公式](img/Formula_008_059.png)再次；注意表示第一个量子比特的最不显著位现在是![公式](img/Formula_008_060.png)。结果还表明我们的量子比特被安全地错误校正，有100%的概率为0。
- en: How it works…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Here''s a short explanation of how qubit error correction works. We first create
    what is called a **syndrome** by entangling our qubit with two other ancilla qubits.
    The entangled qubits now walk through life as one entity, indistinguishable from
    each other with one exception: errors to the qubits are not entangled, but unique
    to each qubit.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对量子比特错误校正工作原理的简要说明。我们首先通过将我们的量子比特与两个其他辅助量子比特纠缠来创建所谓的**伴随子**。纠缠的量子比特现在作为一个整体生活，彼此之间无法区分，只有一个例外：对量子比特的错误不是纠缠的，而是每个量子比特独有的。
- en: Before using our qubit for anything, we first disentangle it from the other
    2 qubits; it is now a standalone qubit again. Now it is time to use the **syndrome**
    to correct any errors.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用我们的量子位进行任何操作之前，我们首先将其与其他2个量子位解开纠缠；现在它又是一个独立的量子位了。现在是我们使用**校验位**来纠正任何错误的时候了。
- en: To do this, we set up a Toffoli (**CCX**) gate from our two syndrome qubits
    to our qubit of interest. If the syndrome qubits differ from our original qubit,
    that is, our qubit has been disturbed, the CCX flips the qubit right again.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们设置了一个从我们的两个校验量子位到我们感兴趣的量子位的Toffoli（**CCX**）门。如果校验量子位与我们的原始量子位不同，也就是说，我们的量子位已经被干扰，CCX门会将量子位翻转回正确状态。
- en: That's it. Simple, eh? Well, let's take a closer look.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了。简单，对吧？好吧，让我们更仔细地看看。
- en: 'There are two methods we can use, for two different qubit errors:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种方法，针对两种不同的量子位错误：
- en: '**Bit-flip correction**: Correcting flipped qubits, from ![](img/Formula_008_061.png)
    and vice versa'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位翻转校正**：纠正翻转的量子位，从![公式_008_061](img/Formula_008_061.png)和相反方向'
- en: '**Phase-flip**: Correcting flipped phases, from ![](img/Formula_008_062.png)
    and vice versa'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相位翻转**：纠正翻转的相位，从![公式_008_062](img/Formula_008_062.png)和相反方向'
- en: Bit-flip correction
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位翻转校正
- en: 'In the bit correction method, we set up a GHZ-state entangled circuit, using
    the first qubit as the controller for a CXX gate (or two CX gates in this case),
    where two additional ancilla qubits are used as the error correction syndrome
    only and are not used in the final measurement:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在位校正方法中，我们设置了一个GHZ态纠缠电路，使用第一个量子位作为CXX门（或在这种情况下两个CX门）的控制位，其中两个额外的辅助量子位仅用作错误校正校验位，并在最终测量中不被使用：
- en: 'If the first qubit is ![](img/Formula_008_063.png), we now have the following
    state:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第一个量子位是![公式_008_063](img/Formula_008_063.png)，我们现在有以下状态：
- en: '![](img/Formula_008_064.png)'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![公式_008_064](img/Formula_008_064.png)'
- en: If it is ![](img/Formula_008_065.png), we now have ![](img/Formula_008_066.png)
    – nothing new there.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果它是![公式_008_065](img/Formula_008_065.png)，我们现在有![公式_008_066](img/Formula_008_066.png)
    – 没有什么新东西。
- en: After setting up the initial qubit and its ancillas, we let the world act on
    the first qubit, potentially introducing bit-flip errors, sending our ![](img/Formula_008_067.png),
    for example, to ![](img/Formula_008_068.png).
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置初始量子位及其辅助位之后，我们让世界作用于第一个量子位，可能会引入位翻转错误，例如，将![公式_008_067](img/Formula_008_067.png)发送到![公式_008_068](img/Formula_008_068.png)。
- en: In the diagram that follows, this is represented by the two barriers between
    the two sets of CX gates.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的图中，这通过两个CX门之间的两个障碍物来表示。
- en: 'Our 3 qubits might now be in the following two states:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们3个量子位现在可能处于以下两种状态：
- en: '![](img/Formula_008_069.png)'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![公式_008_069](img/Formula_008_069.png)'
- en: 'We then run a second GHZ-entanglement to disentangle the first qubit, and end
    up with the following states:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们运行第二个GHZ纠缠来解开第一个量子位，最终得到以下状态：
- en: '![](img/Formula_008_070.png), nothing changes as the first qubit is now ![](img/Formula_008_071.png),
    and ![](img/Formula_008_072.png) if the first qubit is ![](img/Formula_008_073.png).'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![公式_008_070](img/Formula_008_070.png)，由于第一个量子位现在是![公式_008_071](img/Formula_008_071.png)，并且![公式_008_072](img/Formula_008_072.png)如果第一个量子位是![公式_008_073](img/Formula_008_073.png)。'
- en: At this point, we add a supremely clever piece of coding by adding a Toffoli
    gate, with the two syndrome qubits as controllers, and the first qubit as the
    controlled qubit. What happens?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们通过添加一个Toffoli门，将两个校验量子位作为控制器，第一个量子位作为受控量子位，添加了一个极其巧妙的编码。会发生什么？
- en: '![](img/Formula_008_074.png) turns into ![](img/Formula_008_075.png), and ![](img/Formula_008_076.png)
    into ![](img/Formula_008_074.png), and like magic, our first qubit has returned
    to its original state of ![](img/Formula_008_078.png):'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![公式_008_074](img/Formula_008_074.png)变成![公式_008_075](img/Formula_008_075.png)，![公式_008_076](img/Formula_008_076.png)变成![公式_008_074](img/Formula_008_074.png)，就像魔法一样，我们的第一个量子位回到了其原始状态![公式_008_078](img/Formula_008_078.png)：'
- en: '![Figure 8.37 – The bit-flip quantum correction circuit](img/Figure_8.37_B14436.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图8.37 – 位翻转量子校正电路](img/Figure_8.37_B14436.jpg)'
- en: Figure 8.37 – The bit-flip quantum correction circuit
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37 – 位翻转量子校正电路
- en: Phase-flip correction
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相位翻转校正
- en: 'But a qubit also differs from a classical bit by one critical aspect: in addition
    to 0 and 1, a qubit can also have a phase value, and thus also phase errors. Can
    we error correct for that? Turns out that we can, with basically the same method,
    with yet another clever twist:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，量子位与经典位还有一个关键的区别：除了0和1之外，量子位还可以有一个相位值，因此也可以有相位错误。我们能否为这个错误进行纠错？事实证明，我们可以，基本上使用相同的方法，再加上另一个巧妙的转折：
- en: 'Like before, we start out with our 3 qubits, and our GHZ-state:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前一样，我们开始时有3个量子位和我们的GHZ态：
- en: '![](img/Formula_008_079.png)'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![公式_008_079](img/Formula_008_079.png)'
- en: 'The next step is to transform our measurement basis state into a state where
    we can work with phase information, by adding a Hadamard gate to each qubit. We
    now have the following two states instead:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将我们的测量基态转换为一个可以处理相位信息的状态，通过在每个量子比特上添加一个Hadamard门。我们现在有以下两种状态：
- en: '![](img/Formula_008_080.png)'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Formula 008_080.png](img/Formula_008_080.png)'
- en: 'Again, we let nature act on the first qubit, potentially ending up with a phase-shifted
    first qubit, like this:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们让自然作用于第一个量子比特，可能最终得到一个相位偏移的第一个量子比特，如下所示：
- en: '![](img/Formula_008_081.png)'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Formula_008_081.png](img/Formula_008_081.png)'
- en: In the diagram that follows, the error occurs between the two barriers between
    the H gates.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的图中，错误发生在H门之间的两个屏障之间。
- en: 'Like in the bit-flip example, we now apply the Hadamard gate and the GHZ-creating
    CXX gates again, and now end up with the following:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在位翻转示例中一样，我们现在再次应用Hadamard门和创建GHZ的CXX门，现在得到以下结果：
- en: '![](img/Formula_008_082.png)'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Formula_008_082.png](img/Formula_008_082.png)'
- en: '![](img/Formula_008_083.png)'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Formula_008_083.png](img/Formula_008_083.png)'
- en: 'And finally, the Toffoli (CCX) gate turns the qubit trio into the following:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，Toffoli（CCX）门将量子比特三重组转换为以下：
- en: '![](img/Formula_008_084.png)'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Formula 008_084.png](img/Formula_008_084.png)'
- en: 'Again, our first qubit has returned to its original state of ![](img/Formula_008_085.png)
    and ![](img/Formula_008_086.png):'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，我们的第一个量子比特回到了其原始状态![img/Formula_008_085.png](img/Formula_008_085.png)和![img/Formula_008_086.png]：
- en: '![Figure 8.38 – The phase-flip quantum correction circuit'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.38 – 相位翻转量子校正电路](img/Figure_8.38_B14436.jpg)'
- en: '](img/Figure_8.38_B14436.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.38 – B14436.jpg](img/Figure_8.38_B14436.jpg)'
- en: Figure 8.38 – The phase-flip quantum correction circuit
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 8.38 – 相位翻转量子校正电路
- en: Shor code
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shor码
- en: 'That is all great; we can tackle bit-flip errors as well as phase-flip errors.
    But what if both types of errors occur? After all, qubits are physical entities,
    and who really knows how they will behave? It turns out that we can do that as
    well. Peter Shor, of Shor''s algorithm fame (see [*Chapter 10*](B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271),
    *Getting to Know Algorithms with Aqua*) invented the Shor code, which is a combination
    of the phase-flip and bit-flip methods using 9 qubits in total. The first qubit
    is the one we want to do quantum error correction on, and the eight following
    are the ancillas, only used for working the correction magic:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 那都是很好的；我们可以处理位翻转错误以及相位翻转错误。但如果两种类型的错误都发生怎么办？毕竟，量子比特是物理实体，谁又能真正知道它们会如何表现呢？结果证明，我们也可以做到这一点。以Shor算法闻名（见[*第10章*](B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271)，*通过Aqua了解算法）的Peter
    Shor发明了Shor码，这是一种使用总共9个量子比特的相位翻转和位翻转方法的组合。第一个量子比特是我们想要进行量子纠错的目标量子比特，接下来的八个量子比特是辅助量子比特，仅用于执行纠错魔法：
- en: '![Figure 8.39 – The Shor code circuit'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.39 – Shor码电路](img/Figure_8.39_B14436.jpg)'
- en: '](img/Figure_8.39_B14436.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.39 – B14436.jpg](img/Figure_8.39_B14436.jpg)'
- en: Figure 8.39 – The Shor code circuit
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 8.39 – Shor码电路
- en: 'Here''s a quick description, but do take a look at *Figure 8.39*:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简要的描述，但请务必查看*Figure 8.39*：
- en: Set up the first half of the phase-flip circuit using qubits 0, 3, and 6.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用量子比特0、3和6设置相位翻转电路的前半部分。
- en: Set up the first half of three bit-flip circuits for qubits 0, 3, and 6.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为量子比特0、3和6设置三个位翻转电路的前半部分。
- en: Leave some room for nature and the error to happen to qubit 0\. The two barriers
    between the triplicate CX gate sets below.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为自然和错误发生给量子比特0留出一些空间。在下面三重CX门集之间的两个屏障之间。
- en: Set up the second half of three bit-flip circuits for qubits 0, 3, and 6, effectively
    correcting any bit flips on these 3 qubits.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为量子比特0、3和6设置三个位翻转电路的后半部分，有效地纠正这些3个量子比特上的任何位翻转。
- en: Set up the second half of the phase-flip circuit for qubits 0, 3, and 6, correcting
    any phase shifts for these three qubits.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为量子比特0、3和6设置相位翻转电路的后半部分，纠正这三个量子比特的任何相位偏移。
- en: Measure qubit 0.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量量子比特0。
- en: 'Now the math turns somewhat complicated, with Ket-representations for 9 qubits
    looking like this, for example: |011000101![](img/Formula_008_090.png). Not to
    mention what unitary matrices for 9-qubit circuits look like.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数学变得有些复杂，9个量子比特的Ket表示看起来像这样，例如：|011000101![img/Formula_008_090.png](img/Formula_008_090.png)。更不用说9量子比特电路的单位矩阵看起来像什么了。
- en: There's more
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: The first example that we ran, a simple bit-flip error, didn't really make use
    of the full power of the Shor code. Try some of the other options to simulate
    any type of conceivable error that might occur, from the simple to the very complex.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的第一个示例，一个简单的位翻转错误，并没有真正利用Shor码的全部功能。尝试其他选项来模拟可能发生的任何类型的错误，从简单到非常复杂。
- en: 'The following options are available:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选项可用：
- en: '**Bit flip**: This error flips the bit upside-down, from ![](img/Formula_008_087.png).'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bit flip**: 这种错误将比特翻转过来，从 ![](img/Formula_008_087.png)。'
- en: '**Bit flip plus phase flip**: A combined bit and phase flip.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bit flip plus phase flip**: 比特翻转和相位翻转的组合。'
- en: '**Theta plus phi shift**: Create your own error by entering the theta ![](img/Formula_008_088.png)
    and phi ![](img/Formula_008_089.png) angles to point your state vector at any
    point on the Bloch sphere. If you need a reminder about what these two angles
    represent, take a quick look at the *Visualizing a qubit in Python* recipe in
    [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045), *Quantum Computing
    and Qubits with Python*.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Theta plus phi shift**: 通过输入 theta ![](img/Formula_008_088.png) 和 phi ![](img/Formula_008_089.png)
    角度来创建自己的错误，使你的状态向量指向 Bloch 球上的任意一点。如果你需要提醒这两个角度代表什么，请快速查看 [*第二章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)
    中的 *Visualizing a qubit in Python* 菜谱，*Python 量子计算与量子比特*。'
- en: '**Random**: A random error.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Random**: 随机错误。'
- en: See also
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Quantum Error Correction for Beginners*, Simon J. Devitt, William J. Munro,
    and Kae Nemoto, June 24, 2013, [https://arxiv.org/pdf/0905.2794.pdf](https://arxiv.org/pdf/0905.2794.pdf
    )'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Quantum Error Correction for Beginners*，Simon J. Devitt, William J. Munro,
    和 Kae Nemoto，2013年6月24日，[https://arxiv.org/pdf/0905.2794.pdf](https://arxiv.org/pdf/0905.2794.pdf)'
- en: '*Quantum Computation and Quantum Information* by Isaac L. Chuang; Michael A.
    Nielsen, Cambridge University Press, 2010, Chapter 10.2 Shor code'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Quantum Computation and Quantum Information*，作者 Isaac L. Chuang 和 Michael
    A. Nielsen，剑桥大学出版社，2010年，第10.2节 Shor 代码'
