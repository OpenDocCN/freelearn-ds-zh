- en: '*Chapter 5*: Touring the IBM Quantum® Hardware with Qiskit®'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使用Qiskit®游览IBM Quantum®硬件'
- en: In the previous chapters, we have mainly used built-in and local quantum computer
    simulators of various forms, but we also connected and ran some of our quantum
    programs on actual IBM quantum computers. In this chapter, we will take a closer
    look at these backends, down to the level of actual physical qubits.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们主要使用了内置和本地各种形式的量子计算机模拟器，但我们也将一些量子程序连接到实际的IBM量子计算机上并运行。在本章中，我们将更深入地研究这些后端，直至实际的物理量子比特层面。
- en: We will take a quick tour of the IBM Quantum® lab by using both IBM Quantum
    Experience® and Qiskit® to access data about the available hardware. Among these
    things, we will look at the graphical view of the layout of the quantum chips,
    some physical aspects of quantum computers such as the T1 and T2 decoherence parameters,
    some basic and advanced error metrics, the way the available qubits can interact
    among themselves, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用IBM Quantum Experience®和Qiskit®访问有关可用硬件的数据，快速游览IBM Quantum®实验室。在这些事情中，我们将查看量子芯片布局的图形视图，量子计算机的一些物理方面，如T1和T2退相干参数，一些基本和高级错误度量，可用的量子比特之间如何相互交互，等等。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: What are the IBM Quantum® machines?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM Quantum®机器是什么？
- en: Locating the available backends
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位可用的后端
- en: Comparing backends
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较后端
- en: Finding the least busy backend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最不繁忙的后端
- en: Visualizing the backends
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化后端
- en: Exploring a selected backend using Qiskit®
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qiskit®探索选定的后端
- en: Throughout this chapter, we will generally use the Bell state program that we
    have used before, in [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081),
    *Starting at the Ground Level with Terra*, as its ideal results, ![](img/Formula_05_001.png)
    and ![](img/Formula_05_002.png), are known to us, and we can use them to make
    comparisons between runs on different machines and different sets of qubits.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一般使用我们在[*第4章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)中使用的贝尔态程序，*从Terra的起点开始*，作为其理想结果，![](img/Formula_05_001.png)和![](img/Formula_05_002.png)，这些结果对我们来说是已知的，我们可以使用它们来比较不同机器和不同量子比特集上的运行。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before you begin working on the quantum programs in this chapter, make sure
    that you have completed all the steps in [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*, especially the *Installing your API key and accessing
    your provider* recipe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始本章的量子程序之前，请确保您已完成了[*第1章*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021)中所有步骤，*准备您的环境*，特别是*安装您的API密钥并访问您的提供商*食谱。
- en: 'The quantum programs that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter05](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter05).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的量子程序可以在此找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter05](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter05)。
- en: What are the IBM Quantum® machines?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IBM Quantum®机器是什么？
- en: This section is less of a recipe and rather more of a basic overview of the
    quantum components and processes that you will be encountering. If you'd rather
    jump ahead and start coding right away, then go to the next recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节与其说是食谱，不如说是对您将遇到的量子组件和过程的基本概述。如果您想直接跳过并开始编码，请转到下一食谱。
- en: 'With Qiskit®, you can run your quantum programs on two types of quantum computers:
    `ibmq_qasm_simulator` – available online – lets you run fairly deep quantum programs
    on up to *32 qubits*. Your local simulator performance depends on your hardware;
    remember that simulating a quantum computer gets exponentially harder with each
    qubit added.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qiskit®，您可以在两种类型的量子计算机上运行您的量子程序：`ibmq_qasm_simulator` – 可在线使用 – 允许您在最多 *32
    个量子比特* 上运行相当深入的量子程序。您本地模拟器的性能取决于您的硬件；请记住，模拟量子计算机随着每个量子比特的增加而呈指数级变难。
- en: The actual IBM quantum computer hardware is located in an IBM lab and is accessed
    through the cloud. There are good reasons for this, so let's walk through this
    recipe on how to set up and run a quantum computer with the superconducting qubits
    that IBM Quantum® provides.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的IBM量子计算机硬件位于IBM实验室中，并通过云访问。这样做有很好的理由，所以让我们一步步了解如何设置和运行IBM Quantum®提供的超导量子比特量子计算机。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Superconducting quantum computers are extremely sensitive to noise such as electromagnetic
    radiation, sound waves, and heat. An isolated environment equipped with cryogenic
    cooling provides a location with as little disturbance as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 超导量子计算机对噪声非常敏感，如电磁辐射、声波和热量。配备低温冷却的隔离环境提供了一个尽可能少的干扰的位置。
- en: Quantum computers may use so-called **Josephson junctions** kept at cryogenic
    temperatures and manipulated by microwave pulses. Ordinary people do not possess
    this kind of hardware, so, in this book, we will use the freely available IBM
    quantum computers in the cloud for our quantum programming.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机可能使用所谓的**约瑟夫森结**，在低温下保持并受微波脉冲操控。普通人没有这种硬件，因此，在这本书中，我们将使用云中免费可用的IBM量子计算机进行量子编程。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps are a very high-level description of the process of running
    your quantum program on an actual IBM quantum computer:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是对在真实的IBM量子计算机上运行你的量子程序过程的非常高级的描述：
- en: Write a quantum program in your local Qiskit® environment or on IBM Quantum
    Experience®.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的本地Qiskit®环境中或在IBM Quantum Experience®上编写量子程序。
- en: Send your program through the cloud to be queued at IBM Quantum®.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的程序通过云发送到IBM Quantum®进行排队。
- en: The IBM cloud® model for quantum computing means that you will not have unrestricted
    access to the machines. This is a time-share system where everyone gets a some
    access sort of like a classical time-share system that used to be the norm in
    the early days of computing. The analogy is not too bad.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IBM云®量子计算模型意味着你将不会无限制地访问这些机器。这是一个时间共享系统，每个人都会得到一些访问权限，类似于计算机早期使用过的经典时间共享系统。这种类比并不太坏。
- en: Your program now gets `u1`, `u2`, `u3`, `id`, and `cx`. It turns out that all
    quantum programs that you write can be expressed using only these gates.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的程序现在获得了`u1`、`u2`、`u3`、`id`和`cx`。结果证明，你编写的所有量子程序都可以仅使用这些门来表示。
- en: As a part of the transpiling, your circuit might change size and depth somewhat,
    as single gates are converted into sets of gates depending on the backend that
    you run your program on. Simply speaking, the size of a circuit is the raw number
    of gates that are used, and the depth is the length of the circuit from left to
    right, which roughly translates into how many parallel operations the quantum
    computer has to do to run your program. Your original program structure might
    have to change to accommodate the physical layout of the chip that you are running
    on.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为转换的一部分，你的电路可能会在大小和深度上有所变化，因为单个门根据你运行程序的底层转换成一系列门。简单来说，电路的大小是使用的门的基本数量，深度是电路从左到右的长度，这大致相当于量子计算机运行你的程序时必须进行的并行操作的数量。你的原始程序结构可能需要改变以适应你运行的芯片的物理布局。
- en: The gates of your transpiled program are coded into wave packages.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的转换程序中的门被编码成波包。
- en: Now that your code has been converted into components that can be run on the
    chip, these components are translated into microwave packages that can be sent
    down to the quantum chip. Each gate can be seen as a rotation of the qubit Bloch
    vector around three axes, and each angle can be coded as a microwave pulse at
    different frequencies and durations.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在代码已经被转换成可以在芯片上运行的组件，这些组件被转换成微波包，可以发送到量子芯片。每个门可以看作是量子比特布洛赫矢量绕三个轴的旋转，每个角度都可以编码为不同频率和持续时间的微波脉冲。
- en: The quantum chip is reset.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 量子芯片被重置。
- en: Before we can do any quantum computing on the chip, its qubits need to be reset
    to their ground states. This is done by sending a specific microwave pulse to
    each qubit, much like when sending your gates to the qubits, which is described
    in the next step.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们能在芯片上执行任何量子计算之前，其量子比特需要重置到其基态。这是通过向每个量子比特发送特定的微波脉冲来完成的，就像在下一步中描述的将你的门发送到量子比特一样。
- en: Your coded gates are then sent to the qubits.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的编码门随后被发送到量子比特。
- en: Each gate is sent to its corresponding qubit as a *wave package* on top of a
    GHz carrier wave tuned exactly to the frequency of the receiving qubit. We now
    leave behind what is called the **room temperature electronics** and enter the
    cryogenic environment. The signal that encodes the gate travels down into the
    innards of the quantum computer through successively cooler layers, finally reaching
    the quantum chip at 15 millikelvin – much colder than outer space. By the end
    of the journey, the wave package finally ends up impinging the qubit through a
    microwave resonator to change the state of the qubit.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个门都作为*波包*发送到相应的量子比特，这个波包位于一个GHz载波波上，其频率正好调谐到接收量子比特的频率。我们现在离开了所谓的**室温电子设备**，进入了低温环境。编码门的信号通过依次冷却的层向下传输到量子计算机的内部，最终到达15毫开尔文温度的量子芯片——比外太空还要冷。在旅程结束时，波包最终通过微波谐振器撞击量子比特，以改变量子比特的状态。
- en: This is repeated for each gate that you apply to each qubit and is what constitutes
    running the quantum program on the backend.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这对每个量子比特上应用的每个门都重复进行，这就是在后端运行量子程序的过程。
- en: The qubit is now read.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在读取了量子比特。
- en: And by the end of the program, a certain type of wave package interferes with
    the resonator, and the resulting package interference is then sent back up the
    stack, through successively warmer layers and then out into the room-temperature
    electronics.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到程序结束时，一种特定的波包与谐振器发生干涉，然后产生的包干涉被发送回堆栈，通过依次变暖的层，然后进入室温电子设备。
- en: The interference is interpreted as a `0` or `1`, and thus the result of your
    program is registered. At this state, the delicate balance of your resonating
    qubit has been destroyed – the qubit no longer behaves quantum mechanically and
    needs to be reset to ground state before we can use it again.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 干涉被解释为`0`或`1`，因此你的程序结果被记录下来。在这个状态下，你共振量子比特的微妙平衡已经被破坏——量子比特不再表现出量子行为，在我们可以再次使用它之前需要将其重置到基态。
- en: This whole process is repeated by the number of shots that you have ordered,
    and all results are stored in the cloud. Finally, your complete run is packaged
    and sent back to you, if you had the patience to wait, as well as being stored
    for later retrieval.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程会根据你要求的射击次数重复进行，所有结果都存储在云端。最后，如果你的耐心足够，你的完整运行会被打包并返回给你，同时也会被存储以供以后检索。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most of the steps mentioned earlier are highly automated. You only have to write
    your quantum programs and send them off, then IBM Quantum® will do the rest and
    your qubit measurements are returned as ones or zeros.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的多数步骤都是高度自动化的。你只需编写你的量子程序并发送出去，然后IBM Quantum®会完成剩余的工作，并将你的量子比特测量结果以1或0的形式返回。
- en: As you can see, there are several steps where you can step in and dictate how
    things are done, for example, selecting the backend, picking the qubits to use
    based on qubit parameters, deciding the number of shots to run, and more. In this
    chapter, we will walk through how to dig out the hardware information and configuration
    parameters from the IBM Quantum® machines.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有几个步骤你可以介入并指定如何操作，例如，选择后端，根据量子比特参数选择要使用的量子比特，决定要运行的射击次数，等等。在本章中，我们将介绍如何从IBM
    Quantum®机器中挖掘硬件信息和配置参数。
- en: See also
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: For more information about the IBM Quantum® hardware, see [https://www.research.ibm.com/ibm-q/technology/devices/](https://www.research.ibm.com/ibm-q/technology/devices/)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想了解更多关于IBM Quantum®硬件的信息，请参阅[https://www.research.ibm.com/ibm-q/technology/devices/](https://www.research.ibm.com/ibm-q/technology/devices/)
- en: 'You can also read this article on *Superconducting Qubits and the Physics of
    Josephson Junctions* by John M. Martinis and Kevin Osborne at NIST: [https://web.physics.ucsb.edu/~martinisgroup/classnotes/finland/LesHouchesJunctionPhysics.pdf](https://web.physics.ucsb.edu/~martinisgroup/classnotes/finland/LesHouchesJunctionPhysics.pdf)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以阅读由John M. Martinis和Kevin Osborne在NIST撰写的关于*超导量子比特和约瑟夫森结物理学*的文章：[https://web.physics.ucsb.edu/~martinisgroup/classnotes/finland/LesHouchesJunctionPhysics.pdf](https://web.physics.ucsb.edu/~martinisgroup/classnotes/finland/LesHouchesJunctionPhysics.pdf)
- en: 'Also, here is a delightful Medium article on *QC – How to build a Quantum Computer
    with Superconducting Circuit?* by Jonathan Hui: [https://medium.com/@jonathan_hui/qc-how-to-build-a-quantum-computer-with-superconducting-circuit-4c30b1b296cd](https://medium.com/@jonathan_hui/qc-how-to-build-a-quantum-computer-with-superconducting-circuit-4c30b1b296cd)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，这里有一篇关于 *QC – 如何使用超导电路构建量子计算机？* 的令人愉快的Medium文章，作者是Jonathan Hui：[https://medium.com/@jonathan_hui/qc-how-to-build-a-quantum-computer-with-superconducting-circuit-4c30b1b296cd](https://medium.com/@jonathan_hui/qc-how-to-build-a-quantum-computer-with-superconducting-circuit-4c30b1b296cd)
- en: Locating the available backends
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位可用的后端
- en: In Qiskit®, a backend represents the system on which you run your quantum program.
    A **backend** can be a simulator, like the local Aer simulator that we have used
    earlier. If you want to run your quantum programs on real quantum computers instead
    of on your local simulator, you must identify an IBM Quantum® machine as a backend
    to use, and then configure your quantum program to use it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qiskit®中，后端代表您运行量子程序的系统。一个 **后端** 可以是一个模拟器，比如我们之前使用过的本地Aer模拟器。如果您想在本地模拟器而不是在您的本地模拟器上运行量子程序，您必须将一个IBM
    Quantum®机器识别为后端来使用，然后配置您的量子程序以使用它。
- en: 'Let''s see the steps of what we''ll be doing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将要进行的步骤：
- en: Start by importing the required classes and methods and load your account information.
    In this case, we use the IBMQ class, which contains the main hardware-related
    functions.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入所需的类和方法，并加载您的账户信息。在这种情况下，我们使用IBM Q类，它包含主要的硬件相关功能。
- en: Take a look at the machines that are available to your account.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看您账户可用的机器。
- en: Select a generally available backend.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个通常可用的后端。
- en: Create and run a Bell state quantum program on the selected backend.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选定的后端上创建并运行贝尔态量子程序。
- en: Select a simulator backend and run the Bell state quantum program again for
    comparison.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个模拟器后端，再次运行贝尔态量子程序以进行比较。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the IBMQ `provider.backends()` method to identify
    and filter available backends to run your programs and then use the `provider.get_backend()`
    method to select the backend. In the example that follows, we will use the `ibmqx2`
    and `ibmq_qasm_simulator` backends. We will then run a small quantum program on
    one of the hardware backends, and then on the simulator backend.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用IBM Q `provider.backends()` 方法来识别和过滤可用的后端以运行您的程序，然后使用 `provider.get_backend()`
    方法来选择后端。在下面的示例中，我们将使用 `ibmqx2` 和 `ibmq_qasm_simulator` 后端。然后我们将在一个硬件后端上运行一个小型量子程序，然后是在模拟器后端上。
- en: 'The Python file in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r1_identifying_backends.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r1_identifying_backends.py).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下菜谱中的Python文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r1_identifying_backends.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r1_identifying_backends.py)。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As always, we start by importing the Qiskit® classes and methods to use:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是先导入Qiskit®类和方法以使用：
- en: '[PRE0]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before you can start using the `IBMQ` class and the backend methods (if not
    already set), you must set the provider that is associated with your account:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您可以使用 `IBMQ` 类和后端方法（如果尚未设置）之前，您必须设置与您的账户关联的提供者：
- en: '[PRE1]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `provider.backends()` method is used to locate the IBM Quantum® backends
    that are available to your IBM Quantum® account. With that information, you can
    later set the backend that you want to run your quantum program on by using the
    `provider.get_backend()` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`provider.backends()` 方法用于定位对您的IBM Quantum®账户可用的IBM Quantum®后端。有了这些信息，您可以通过使用
    `provider.get_backend()` 方法来设置您想要在它上面运行量子程序的后端：'
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code might give an output similar to the following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的代码可能会产生类似于以下输出的结果：
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can use complex filtering such as lambda functions:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以使用复杂的过滤，如lambda函数：
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are also only interested in backends that are not down for maintenance.
    To do this, we filter by the `operational` parameter:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也只对那些没有因维护而关闭的后端感兴趣。为此，我们通过 `operational` 参数进行过滤：
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or else, you can use the following code:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下代码：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, with this in mind, when you want to run your quantum program on an IBM
    Quantum® machine, you need to specify the backend to run on, and for this, you
    can use the `get_backend()` method. Let''s manually select a backend from our
    previous list, for example, `ibmqx2`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，考虑到这一点，当你想在IBM Quantum®机器上运行你的量子程序时，你需要指定要运行的后端，为此，你可以使用`get_backend()`方法。让我们手动从我们之前的列表中选择一个后端，例如，`ibmqx2`：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code should give the following result:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码应该给出以下结果：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, with a backend selected, you can execute jobs on the backend with the
    command `job = execute(<your_quantum_circuit>, backend)`. In this case, we will
    use the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择了一个后端，你可以使用命令`job = execute(<your_quantum_circuit>, backend)`在该后端上执行作业。在这种情况下，我们将使用以下命令：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now create the circuit to test:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建电路进行测试：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The sample code should give a result similar to this:![Figure 5.1 – Output of
    the Bell quantum circuit on the selected backend](img/Figure_5.1_B14436.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例代码应该给出类似以下的结果：![图5.1 – 在所选后端上贝尔量子电路的输出](img/Figure_5.1_B14436.jpg)
- en: Figure 5.1 – Output of the Bell quantum circuit on the selected backend
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.1 – 在所选后端上贝尔量子电路的输出
- en: 'To select the IBM Quantum® simulator as the backend, and run the circuit on
    that one, you can do the following:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要选择IBM Quantum®模拟器作为后端，并在其上运行电路，你可以这样做：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code should give the following result:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码应该给出以下结果：
- en: '![Figure 5.2 – Output of the Bell quantum circuit on the ibmq_qasm_simulator
    backend](img/Figure_5.2_B14436.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 在ibmq_qasm_simulator后端上贝尔量子电路的输出](img/Figure_5.2_B14436.jpg)'
- en: Figure 5.2 – Output of the Bell quantum circuit on the ibmq_qasm_simulator backend
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 在ibmq_qasm_simulator后端上贝尔量子电路的输出
- en: So, we have now identified the IBM Quantum® backends that are available to us
    and run a quantum program on a backend that we selected, and on a simulator backend.
    In the next recipe, *Comparing backends*, we will do a simple performance comparison
    of the available backends.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经确定了可用的IBM Quantum®后端，并在我们选择的后端以及模拟后端上运行了一个量子程序。在下一道菜谱“比较后端”中，我们将对可用的后端进行简单的性能比较。
- en: There's more…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'You can also use the `backends()` method to look at the simulator backends
    that you have at your disposal on your locally installed Qiskit® environment.
    First, start by importing the `Aer` simulator class and then use the `backends()`
    method to take a look at the available backends:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`backends()`方法查看你本地安装的Qiskit®环境中可用的模拟后端。首先，导入`Aer`模拟器类，然后使用`backends()`方法查看可用的后端：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code should give the following result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该给出以下结果：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These are all simulators:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是模拟器：
- en: '`''qasm_simulator''`: This simulator lets you run your quantum programs and
    get results returned as if you were running on a perfect quantum computer with
    no errors and no noise.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''qasm_simulator''`：这个模拟器允许你运行你的量子程序，并得到的结果就像你在没有错误和噪声的完美量子计算机上运行一样。'
- en: '`''statevector_simulator''`: With this one, you can simulate what the statevector
    for your qubits looks like throughout your circuit.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''statevector_simulator''`：使用这个，你可以模拟你的量子比特在整个电路中的状态向量。'
- en: '`''unitary_simulator''`: This simulator lets you create the unitary matrix
    for your circuit.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''unitary_simulator''`：这个模拟器允许你为你的电路创建单位矩阵。'
- en: '`''pulse_simulator''`: This simulator lets you simulate sending discrete pulses
    to a qubit.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''pulse_simulator''`：这个模拟器允许你向量子比特发送离散脉冲。'
- en: We have already seen `'qasm_simulator'` and `'statevector_simulator'` used in
    [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting at the
    Ground Level with Terra*, and we will take a closer look at `'unitary_simulator'`
    as a part of [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding
    the Qiskit® Gate Library*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在[*第4章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)，“从Terra的起点开始”，中使用的`'qasm_simulator'`和`'statevector_simulator'`，我们将在[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)，“理解Qiskit®门库”中更详细地查看`'unitary_simulator'`。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information about the available IBM Quantum® systems: [https://www.ibm.com/quantum-computing/technology/systems/](https://www.ibm.com/quantum-computing/technology/systems/).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于可用的IBM Quantum®系统的更多信息：[https://www.ibm.com/quantum-computing/technology/systems/](https://www.ibm.com/quantum-computing/technology/systems/).
- en: You can also use Python help using `help(IBMQ)` and `help(provider.backends)`
    to find more information about these Qiskit® methods.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用Python帮助，使用`help(IBMQ)`和`help(provider.backends)`来查找有关这些Qiskit®方法的更多信息。
- en: Comparing backends
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较后端
- en: The IBM Quantum® backends are all slightly different, from the number of qubits
    to the individual behavior and interaction between these. Depending on how you
    write your quantum program, you might want to run the code on a machine with certain
    characteristics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Quantum®后端在数量、比特数以及这些比特之间的行为和交互上都有所不同。根据你编写的量子程序，你可能希望在具有特定特性的机器上运行代码。
- en: The backend information that is returned by IBMQ is just a plain Python list
    and you can juggle the returned data with any other list. For example, you can
    write a Python script that finds the available IBM Quantum® backends, then run
    a quantum program on each of the backends and compare the results in a diagram
    that shows a rough measure of the *quality* of the backends' qubits.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: IBMQ返回的后端信息只是一个普通的Python列表，你可以用任何其他列表来操作返回的数据。例如，你可以编写一个Python脚本来查找可用的IBM Quantum®后端，然后在每个后端上运行量子程序，并在显示后端比特质量大致测量的图表中比较结果。
- en: In this recipe, we will use a simple Python loop to run a succession of identical
    Bell-state quantum programs on the available IBM Quantum® backends to get a rough
    estimate of the performance of the backends.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用一个简单的Python循环，在可用的IBM Quantum®后端上运行一系列相同的贝尔态量子程序，以获得后端性能的大致估计。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required for this recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r2_comparing_backends.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r2_comparing_backends.py).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此菜谱所需的文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r2_comparing_backends.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r2_comparing_backends.py)。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s take a look at how to compare backends:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何比较后端：
- en: First, we import the required classes and methods.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类和方法。
- en: 'In this case, we use the IBMQ library, which contains the main hardware-related
    functions. We also import the classes to build quantum circuits, monitor jobs,
    and display results. And then load the stored account API key and get the provider:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用IBMQ库，它包含主要的硬件相关函数。我们还导入了构建量子电路、监控作业和显示结果的类。然后加载存储的账户API密钥并获取提供者：
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we will create the quantum program for which we know the expected results.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个已知预期结果的量子程序。
- en: 'For example, a Bell state program, which will give the results ![](img/Formula_05_003.png)
    and ![](img/Formula_05_004.png) only on a perfect quantum computer:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，一个贝尔态程序，在完美的量子计算机上只会给出 ![](img/Formula_05_003.png) 和 ![](img/Formula_05_004.png)
    的结果：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code should give the following result:![Figure 5.3 – A Bell state
    quantum circuit
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一段代码应该给出以下结果：![图5.3 – 一个贝尔态量子电路
- en: '](img/Figure_5.3_B14436.jpg)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图5.3 – 后端信息](img/Figure_5.3_B14436.jpg)'
- en: Figure 5.3 – A Bell state quantum circuit
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.3 – 一个贝尔态量子电路
- en: 'Now, we will get all available and operational backends, including the IBM
    Quantum® simulator to use as a benchmark:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将获取所有可用和可操作的后端，包括用于基准测试的IBM Quantum®模拟器：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Filtering out single-qubit backends
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 过滤掉单比特后端
- en: See how we are using a filter here, to only include backends with more than
    1 qubit. The reason for this is that our code requires two operational qubits
    and the code will fail if we run it on a backend with just one. One of the available
    IBM Quantum® machines—`ibmq_armonk`—is a quantum computer with just 1 qubit; we
    do not want to use that one and use the filter to remove it from our list of backends.
    The purpose of the `ibmq_armonk` backend is to experiment with qubit pulse programming,
    which is beyond the scope of this book.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看我们在这里是如何使用过滤器，只包括具有超过1个比特的后端。这样做的原因是我们的代码需要两个操作比特，如果我们在只有一个比特的后端上运行代码，代码将会失败。可用的IBM
    Quantum®机器之一—`ibmq_armonk`—是一个只有一个比特的量子计算机；我们不希望使用它，并使用过滤器将其从我们的后端列表中删除。`ibmq_armonk`后端的目的在于进行量子比特脉冲编程的实验，这超出了本书的范围。
- en: 'The preceding code might give the following result:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一段代码可能会得到以下结果：
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will run the simple quantum program on these backends in order. The
    resulting counts are stored in a dictionary that we call `counts`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将按顺序在这些后端上运行简单的量子程序。结果计数存储在一个我们称之为`counts`的字典中：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Get in line
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 排队
- en: Running four quantum programs on several different machines might take a while,
    depending on the number of other users actively using the backends, and the number
    of jobs that are queued up. For example, running this program on eight backends
    and one simulator might take about an hour on a typical Sunday evening.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在几台不同的机器上运行四个量子程序可能需要一段时间，具体取决于其他用户在积极使用后端的人数以及排队作业的数量。例如，在典型的周日晚上，在八个后端和一个模拟器上运行此程序可能需要大约一个小时。
- en: 'The preceding code might give the following result:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的代码可能会得到以下结果：
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that the jobs are running, we can print out and then plot the results using
    the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在作业正在运行，我们可以使用以下代码打印并绘制结果：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code might give the following result:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的代码可能会得到以下结果：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These raw results show how well each backend ran the program. The `ibmq-qasm-simulator`
    represents the ideal results on a simulated universal quantum computer; the other
    results show how the program ran on actual IBM Quantum® backends. A perfect quantum
    computer would get results similar to the simulator, resulting in values for ![](img/Formula_05_005.png)
    and ![](img/Formula_05_006.png) only:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原始结果显示了每个后端运行程序的效果。`ibmq-qasm-simulator` 代表在模拟的通用量子计算机上的理想结果；其他结果显示了程序在实际
    IBM Quantum® 后端上的运行情况。一个完美的量子计算机将得到与模拟器相似的结果，从而得到 ![](img/Formula_05_005.png)
    和 ![](img/Formula_05_006.png) 的值：
- en: '![Figure 5.4 – Graphical view of the Bell results'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – 贝尔结果的图形视图'
- en: '](img/Figure_5.4_B14436.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B14436.jpg)'
- en: Figure 5.4 – Graphical view of the Bell results
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 贝尔结果的图形视图
- en: What we have created here is a simple comparison of the available IBM Quantum®
    backends using a *basic 2-qubit Bell state quantum program*. On a perfect quantum
    computer, we only expect the results – ![](img/Formula_05_007.png) and ![](img/Formula_05_008.png)
    – which is indeed what we see for `ibmq_qasm_simulator`. Like we discussed in
    [*Chapter 4*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081), *Starting at the
    Ground Level* *with Terra*, for real **Noisy Intermediate-Scale Quantum** (**NISQ**)
    machines, we expect some noise and a mixed result, consisting of ![](img/Formula_05_009.png),
    ![](img/Formula_05_010.png), ![](img/Formula_05_011.png), and ![](img/Formula_05_012.png)
    for the IBM Quantum® hardware.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的是一个简单的比较，使用一个 *基本的 2 量子比特贝尔态量子程序*来比较可用的 IBM Quantum® 后端。在一个完美的量子计算机上，我们只期望得到结果
    – ![](img/Formula_05_007.png) 和 ![](img/Formula_05_008.png) – 这正是我们在 `ibmq_qasm_simulator`
    上看到的结果。正如我们在[*第 4 章*](B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081)，*从 Terra
    的基础开始*所讨论的，对于真实的 **有噪声的中尺度量子**（**NISQ**）机器，我们期望有一些噪声和混合结果，包括 ![](img/Formula_05_009.png)，![](img/Formula_05_010.png)，![](img/Formula_05_011.png)，和
    ![](img/Formula_05_012.png) 对于 IBM Quantum® 硬件。
- en: Generally speaking, the smaller the ![](img/Formula_05_013.png) and ![](img/Formula_05_014.png)
    bars are, the better the backends perform, but there are many factors at play.
    These will be explored later in this chapter and in [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Your Quantum Act with Ignis*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，![](img/Formula_05_013.png) 和 ![](img/Formula_05_014.png) 条形图越小，后端的表现越好，但有许多因素在起作用。这些将在本章的后面以及[*第
    8 章*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220)，*用 Ignis 清理你的量子行为*中探讨。
- en: Also, keep in mind that we are only comparing the default execution of your
    quantum programs here. Different qubit configurations, readout errors, qubit connection
    issues, and other errors that occur with real hardware play a part and make the
    results somewhat random.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们在这里只比较了你的量子程序默认执行情况。不同的量子比特配置、读出错误、量子比特连接问题和其他在真实硬件上发生的错误也会起作用，并使结果变得有些随机。
- en: There's more
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: 'In this recipe, we ran our quantum program on almost all available backends.
    As you saw in the *Locating the available backends* recipe, you can also filter
    the backends. This recipe required at least two qubits to run, so we added a filter
    to include backends with more than one qubit:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们在几乎所有可用的后端上运行了我们的量子程序。正如你在 *定位可用的后端* 配方中所看到的，你还可以过滤后端。这个配方至少需要两个量子比特来运行，因此我们添加了一个过滤器来包括具有一个以上量子比特的后端：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can use the filter capability for other reasons; for example, to run on
    only 5-qubit machines, filter by the number of qubits:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用过滤功能出于其他原因；例如，仅运行在 5 量子比特机器上，通过量子比特数量进行过滤：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can now see how the available backends behave, and how busy some of them
    might be. Time to figure out a way to speed up your quantum program executions
    by finding the backend with the shortest queue.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到可用的后端如何表现，以及其中一些可能有多忙碌。是时候找出一种方法，通过找到队列最短的后端来加速你的量子程序执行了。
- en: Finding the least busy backend
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最近忙的后端
- en: When you run your quantum program on an IBM Quantum® backend, you will quickly
    realize that you might not be the only one attempting to use that same backend
    at the same time. Depending on the time and day of the week, and the type and
    purpose of the quantum programs being run, not all IBM Quantum® machines are used
    to the same degree.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在IBM Quantum®后端上运行量子程序时，您会很快意识到，您可能不是唯一一个同时尝试使用相同后端的人。根据时间和星期几，以及正在运行的量子程序的类型和目的，并非所有IBM
    Quantum®机器的使用程度都相同。
- en: If you are not concerned with which machine you should run the code on, you
    can use the `least_busy` method to automatically find the best backend to run
    your programs on. The least busy status of a backend generally means that you
    have the least wait time, but this is not necessarily true. Some programs run
    longer than others, and queues (just like in the supermarket) might move at different
    speeds.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不关心应该在哪个机器上运行代码，您可以使用`least_busy`方法自动找到运行程序的最佳后端。后端的最不繁忙状态通常意味着您有最少的等待时间，但这并不一定正确。有些程序运行时间比其他程序长，队列（就像在超市里一样）可能以不同的速度移动。
- en: 'Let''s take a look at the following steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: Start by importing the required `IBMQ` and `least_busy` methods and load our
    account.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入所需的`IBMQ`和`least_busy`方法，并加载我们的账户。
- en: Use the `least_busy` method to automatically select the generally available
    least busy backend, and the least busy backend with 5 qubits.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`least_busy`方法自动选择通常可用的最不繁忙的后端，以及具有5量子比特的最不繁忙的后端。
- en: Finally, let's display the overview data for all backends to verify that the
    backends that we selected are indeed the least busy backends.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们显示所有后端的概述数据，以验证我们选择的后端确实是最近忙的后端。
- en: The `least_busy` method is convenient if we do not want to wait for our execution
    but might not be the best option. Qiskit® has given us the name of the least busy
    backend. We can now trust Qiskit® and run our quantum code on that backend, or,
    depending on our purposes, we might choose another backend to run on. It might
    turn out that the least busy backend is a machine with noisy qubits or short T1
    or T2 that doesn't suit our purposes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望等待执行但可能不是最佳选择，`least_busy`方法就非常方便。Qiskit®已经为我们提供了最不繁忙的后端名称。我们现在可以信任Qiskit®并在该后端上运行我们的量子代码，或者，根据我们的目的，我们可能选择另一个后端来运行。结果可能是，最不繁忙的后端是一个具有噪声量子比特或T1或T2时间短的机器，这并不适合我们的需求。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r3_least_busy.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r3_least_busy.py).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的食谱中所需文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r3_least_busy.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r3_least_busy.py)。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: What `least_busy` is looking for are backends that include a `pending_jobs`
    parameter. If you add additional filtering features that exclude the actual least
    busy backend, the method will return the backend with the least pending jobs that
    meet the filtering criteria.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`least_busy`正在寻找包含`pending_jobs`参数的后端。如果您添加了额外的筛选功能，排除了实际最不繁忙的后端，该方法将返回符合筛选标准的具有最少挂起作业的后端。'
- en: 'Let''s take a look:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看：
- en: 'Start by importing the required `IBMQ` and `least_busy` methods, and load our
    account:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入所需的`IBMQ`和`least_busy`方法，并加载我们的账户：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we can ask IBM Quantum® which backend is least busy, and set our `backend`
    parameter accordingly:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以询问IBM Quantum®哪个后端是最不繁忙的，并相应地设置我们的`backend`参数：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code might give the following result:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码可能会得到以下结果：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the least busy backend turned out to be `ibmq_armonk`, which
    is a 1-qubit machine designed for pulse testing. This is not the backend that
    you want to run your multi-qubit circuits on.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，最不繁忙的后端是`ibmq_armonk`，这是一台用于脉冲测试的1量子比特机器。这不是您想在上面运行多量子比特电路的后端。
- en: Filter the least busy results.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选最不繁忙的结果。
- en: 'You can feed the `least_busy` method a filtered list of backends, for example,
    to only include 5-qubit machines, or just call the method with the unfiltered
    `provider.backends()` function, like in the following example:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以将`least_busy`方法传入一个经过筛选的后端列表，例如，仅包括5量子比特的机器，或者直接使用未经筛选的`provider.backends()`函数调用该方法，如下面的示例所示：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code might give the following output:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码可能给出以下输出：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There we go – this is the least busy backend with five qubits.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样 – 这是拥有五个量子比特的最不繁忙的后端。
- en: 'To check that the method selected the best backend, we can use the `backend_overview()`
    method to take a look at the number of pending jobs for the available backends:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查所选方法是否选择了最佳后端，我们可以使用`backend_overview()`方法查看可用后端的挂起作业数量：
- en: '[PRE29]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code might give the following result:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码可能给出以下结果：
- en: '![Figure 5.5 – All available backends with no filtering](img/Figure_5.5_B14436.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 未过滤的所有可用后端](img/Figure_5.5_B14436.jpg)'
- en: Figure 5.5 – All available backends with no filtering
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 未过滤的所有可用后端
- en: Keep an eye on the **Least busy** parameter. As you can see, the number of pending
    jobs is the smallest for the least busy backend.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**最不繁忙**参数。如您所见，最不繁忙的后端挂起作业数量是最小的。
- en: So, the takeaway of this recipe is that you can automate which backend you run
    your quantum programs on, but that the returned backend might not be what you
    want if you need to run your program on a specific number of qubits. If this is
    the case, filter the search by the number of qubits to get the backend with the
    shortest queue.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本食谱的要点是您可以自动化您运行的量子程序的后端，但如果您需要在特定数量的量子比特上运行程序，返回的后端可能不是您想要的。如果是这种情况，通过量子比特数量过滤搜索以获取队列最短的后端。
- en: Visualizing the backends
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化后端
- en: Now that we have started poking at various parameters of the IBM Quantum® backends,
    it would be helpful to have a simple way of getting a visual overview of the quantum
    chips and various important parameters, such as how the qubits are interconnected,
    which connections are better than others, what the quality of each qubit is, and
    so on. Qiskit® comes with visualizations built in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始探索IBM Quantum®后端的各个参数，有一个简单的方法来获取量子芯片和各个重要参数的视觉概述将很有帮助，例如量子比特如何相互连接，哪些连接比其他连接更好，每个量子比特的质量如何，等等。Qiskit®内置了可视化功能。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r4_backend_vis.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r4_backend_vis.py).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的食谱中所需的文件可以从这里下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r4_backend_vis.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r4_backend_vis.py)。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will use three methods of the `qiskit.visualization` package to look over
    the backends: `plot_gate_map()`, `plot_error_map()`, and `plot_circuit_layout()`.
    For the last one, we also need to *transpile* a quantum circuit using the `transpile()`
    method to then display which qubits Qiskit® is mapping your gates to on the backend.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`qiskit.visualization`包的三个方法来查看后端：`plot_gate_map()`、`plot_error_map()`和`plot_circuit_layout()`。对于最后一个，我们还需要使用`transpile()`方法对量子电路进行*转换*，然后显示Qiskit®将您的门映射到后端上的哪些量子比特。
- en: 'Let''s look at the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Start by importing the required `qiskit` and `qiskit.visualization` methods,
    and load our account:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入所需的`qiskit`和`qiskit.visualization`方法，并加载我们的账户：
- en: '[PRE30]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Grab and get all available IBM Quantum® backends that have more than 1 qubit
    and that are not simulators:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取并获取所有具有超过1个量子比特且不是模拟器的可用IBM Quantum®后端：
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Select the backend that you want to take a look at:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要查看的后端：
- en: '[PRE32]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s display the gate map and the error map for the backend:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们显示后端的门映射图和错误映射图：
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This first visualization shows the logical layout of the backend, optionally
    with the permitted direction of communication between the qubits displayed (`plot_directed=True`).
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种首次可视化显示了后端的逻辑布局，可选地显示了量子比特之间允许的通信方向（`plot_directed=True`）。
- en: 'Consider this example: `display(plot_gate_map(backend, plot_directed=True))`.'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下示例：`display(plot_gate_map(backend, plot_directed=True))`。
- en: 'The preceding code might give the following output for `ibmq_burlington`:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码可能为`ibmq_burlington`提供以下输出：
- en: '![Figure 5.6 – The gate map for ibmq_burlington](img/Figure_5.6_B14436.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图5.6 – ibmq_burlington的门映射图](img/Figure_5.6_B14436.jpg)'
- en: Figure 5.6 – The gate map for ibmq_burlington
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.6 – ibmq_burlington的门映射图
- en: 'With the error map visualization, you get a view of the readout error and CX
    error rates for the backend. This map gives you an indication of the quality of
    the qubits for providing accurate readout results, and for correctly executing
    on the **controlled-NOT** **(CX)** gates between two qubits:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过错误映射可视化，你可以看到后端的读出错误和 CX 错误率。此图为你提供了关于量子比特质量的信息，这些量子比特可以提供准确的读出结果，并在两个量子比特之间的
    **受控-NOT** **(CX)** 门上正确执行：
- en: '![Figure 5.7 – The error map form ibmq_burlington](img/Figure_5.7_B14436.jpg)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Figure 5.7 – ibmq_burlington 的错误映射](img/Figure_5.7_B14436.jpg)'
- en: Figure 5.7 – The error map form ibmq_burlington
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.7 – ibmq_burlington 的错误映射
- en: 'And finally, create a Bell circuit, transpile it, and use it to display the
    circuit layout:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个贝尔电路，将其翻译，并使用它来显示电路布局：
- en: '[PRE34]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The circuit layout is a little bit more complex, as it not only takes a backend
    as input, but you must also feed it the transpiled quantum circuit that you want
    to run on it.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电路布局稍微复杂一些，因为它不仅需要后端作为输入，你还必须提供你想要在其上运行的编译后的量子电路。
- en: For example, still on `ibmq_burlington`, we might want to run a Bell circuit.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，仍然在 `ibmq_burlington` 上，我们可能想要运行一个贝尔电路。
- en: 'The preceding code might give the following result:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码可能会得到以下结果：
- en: '![Figure 5.8 – A Bell quantum circuit with two qubits](img/Figure_5.8_B14436.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 5.8 – 具有两个量子比特的贝尔量子电路](img/Figure_5.8_B14436.jpg)'
- en: Figure 5.8 – A Bell quantum circuit with two qubits
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 具有两个量子比特的贝尔量子电路
- en: 'The transpiled circuit tells us that we will run the circuit on qubits 0 and
    1\. As we started out with a 2-qubit circuit, we gave the transpiler the option
    to assign any two qubits to our circuit:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译后的电路告诉我们，我们将在量子比特 0 和 1 上运行电路。因为我们开始时是一个 2 量子比特电路，所以我们给了编译器将任意两个量子比特分配给我们的电路的选项：
- en: '![Figure 5.9 – The transpiled Bell circuit'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.9 – 翻译后的贝尔电路](img/Figure_5.9_B14436.jpg)'
- en: '](img/Figure_5.9_B14436.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.9_B14436.jpg](img/Figure_5.9_B14436.jpg)'
- en: Figure 5.9 – The transpiled Bell circuit
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 翻译后的贝尔电路
- en: 'The circuit layout shows us the expected qubit assignment:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 电路布局显示给我们预期的量子比特分配：
- en: '![Figure 5.10 – The CX gate in the Bell circuit is mapped from qubit 0 to qubit
    1'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.10 – 贝尔电路中的 CX 门从量子比特 0 映射到量子比特 1](img/Figure_5.10_B14436.jpg)'
- en: '](img/Figure_5.10_B14436.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.10_B14436.jpg](img/Figure_5.10_B14436.jpg)'
- en: Figure 5.10 – The CX gate in the Bell circuit is mapped from qubit 0 to qubit
    1
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 贝尔电路中的 CX 门从量子比特 0 映射到量子比特 1
- en: The view illustrates what the physical chip looks like, in a symbolic way with
    no technical details.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该视图以象征性的方式说明了物理芯片的外观，没有任何技术细节。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have seen the visualization steps in Qiskit®. You can also get the same information
    in IBM Quantum Experience®.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Qiskit® 中的可视化步骤。你也可以在 IBM Quantum Experience® 中获得相同的信息。
- en: 'Let''s take a look:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看：
- en: Log in to IBM Quantum Experience® at [https://quantum-computing.ibm.com](https://quantum-computing.ibm.com).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录 IBM Quantum Experience® [https://quantum-computing.ibm.com](https://quantum-computing.ibm.com)。
- en: On the **Welcome** page, on the right-hand side, you'll see a list of the available
    backends:![Figure 5.11 – The IBM Quantum Experience® home page](img/Figure_5.11_B14436.jpg)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **欢迎** 页面的右侧，你会看到一个可用后端的列表：![Figure 5.11 – IBM Quantum Experience® 主页](img/Figure_5.11_B14436.jpg)
- en: Figure 5.11 – The IBM Quantum Experience® home page
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.11 – IBM Quantum Experience® 主页
- en: Click on the backend that you are interested in, for example, `ibmq_burlington`,
    to see the chip layout and additional information:![Figure 5.12 – Details of the
    ibmq_burlington chip](img/Figure_5.12_B14436.jpg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你感兴趣的后端，例如 `ibmq_burlington`，以查看芯片布局和附加信息：![Figure 5.12 – ibmq_burlington
    芯片的细节](img/Figure_5.12_B14436.jpg)
- en: Figure 5.12 – Details of the ibmq_burlington chip
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – ibmq_burlington 芯片的细节
- en: 'Here''s a short list of the different pieces of data that you can see for the
    selected chip:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简短的数据列表，你可以看到所选芯片的不同部分：
- en: '**Online or offline**: Is the backend currently available?'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在线或离线**：后端目前可用吗？'
- en: '**The current queue**: How many people are using the backend at the moment?
    This number gives you a rough estimate of how busy the backend is, and how long
    it might take before your program will run.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前队列**：目前有多少人在使用后端？这个数字为你提供了一个粗略的估计，即后端有多忙，以及你的程序可能需要多长时间才能运行。'
- en: '**Providers**: This will be **open** for the freely available backends.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供商**：这将是对免费后端**开放**的。'
- en: '**A blueprint view of the actual quantum chip**: The view illustrates what
    the physical chip looks like, in a symbolic way with no technical details.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际量子芯片的蓝图视图**：该视图以象征性的方式说明了物理芯片的外观，没有任何技术细节。'
- en: '**A connectivity map**: The arrows between the qubits illustrate how they can
    be connected using 2-qubit gates such as the **CNOT** (also known as **controlled-NOT**,
    or **CX**) gate. The connection can be made from the qubit where the arrow starts
    to the qubit where it ends.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接图**：量子比特之间的箭头说明了它们如何使用2量子比特门（如**CNOT**门，也称为**受控非**或**CX**）进行连接。连接可以从箭头开始的量子比特到箭头结束的量子比特。'
- en: '**Single-qubit error rate**: This is a measure of the quality of the qubit.
    It is a summary of the error rate of the qubit itself and the readout error. Basically,
    this is the probability that a qubit in one state will be read as the other state.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单量子比特错误率**：这是量子比特质量的衡量标准。它是量子比特本身的错误率和读出错误的总结。基本上，这是量子比特处于一个状态时被读取为另一个状态的概率。'
- en: '**CNOT error rate**: This is the measure of the quality of the qubit connection.
    It is the probability that two entangled qubits will read the opposite of the
    entanglement.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CNOT错误率**：这是量子比特连接质量的衡量标准。它是两个纠缠量子比特读取相反纠缠的概率。'
- en: '**Number of qubits**: The number of available qubits.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**量子比特数量**：可用的量子比特数量。'
- en: '**Online since**: The date and time that the machine came online.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上线时间**：机器上线的时间和日期。'
- en: '**Maximum shots**: The maximum number of shots you can run on the backend.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大射击次数**：你可以在后端上运行的最大射击次数。'
- en: '**Quantum volume**: The measured quantum volume for the backend. The quantum
    volume is IBM''s suggested benchmark for measuring the performance of today''s
    quantum computers.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**量子体积**：后端的测量量子体积。量子体积是IBM为衡量今天量子计算机性能所提出的基准。'
- en: '`u1`, `u2`, `u3`, `cx`, and `id`. With these gates, you can build all other
    quantum gates that are supported by Qiskit®.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u1`、`u2`、`u3`、`cx`和`id`。有了这些门，你可以构建Qiskit®支持的所有其他量子门。'
- en: You can use the visualized IBM Quantum® information as guidance for writing
    and executing your quantum programs, and also include aspects such as the qubit
    properties and error map to fine-tune your programs for a specific backend. However,
    in a pure, non-user interface Qiskit® environment, you might want to access this
    data without having to resort to a user interface. This is all covered in the
    next recipe, where we dig out this data directly in Qiskit®.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用可视化的IBM Quantum®信息作为编写和执行你的量子程序的指导，并包括诸如量子比特属性和错误图等方面，以针对特定的后端微调你的程序。然而，在纯、非用户界面Qiskit®环境中，你可能希望在不使用用户界面的情况下访问这些数据。所有这些内容都在下一个菜谱中介绍，我们将直接在Qiskit®中挖掘这些数据。
- en: See also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For a good overview and explanation of the quantum volume concept, see the
    Medium article: *What Is Quantum Volume, Anyway?* by Ryan F. Mandelbaum, senior
    technical writer, IBM Quantum® and Qiskit®: [https://medium.com/qiskit/what-is-quantum-volume-anyway-a4dff801c36f](https://medium.com/qiskit/what-is-quantum-volume-anyway-a4dff801c36f)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 关于量子体积概念的概述和解释，请参阅Medium文章：*量子体积究竟是什么？*，作者Ryan F. Mandelbaum，IBM Quantum®和Qiskit®的高级技术作家：[https://medium.com/qiskit/what-is-quantum-volume-anyway-a4dff801c36f](https://medium.com/qiskit/what-is-quantum-volume-anyway-a4dff801c36f)
- en: Exploring a selected backend using Qiskit®
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qiskit®探索选定的后端
- en: Exploring backend data visually is a handy but strictly manual process. Sometimes
    you might want to include backend information in your program logic when running
    your programs, for example, to select the appropriate backend or dynamically apply
    your gates on the best qubits. To do this, we can pull this data directly from
    the available backend information by using Qiskit®.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化探索后端数据是一个方便但严格的手动过程。有时你可能想在运行程序时将后端信息包含在程序逻辑中，例如，选择合适的后端或动态地在最佳量子比特上应用你的门。为此，我们可以通过使用Qiskit®直接从可用的后端信息中提取这些数据。
- en: In this recipe, we will use the `backend.configuration()`, `backend.status()`,
    and `backend.properties()` methods to retrieve and list the available and operational
    backends, with some important configuration data such as the number of qubits,
    the maximum number of experiments you can run, and the number of pending jobs
    in the queue. We will also dig out some important qubit parameters such as T1,
    T2, frequency, and readout error for a selected backend.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`backend.configuration()`、`backend.status()`和`backend.properties()`方法来检索和列出可用的和正在运行的后端，以及一些重要的配置数据，例如量子比特数量、你可以运行的最大实验数量以及队列中挂起的作业数量。我们还将挖掘一些重要的量子比特参数，例如选定的后端的T1、T2、频率和读出错误。
- en: 'Okay, let''s take a look at how it is done:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看它是如何完成的：
- en: Start by importing the IBMQ class and load our account.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入IBMQ类并加载我们的账户。
- en: Get all available and operational backends.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有可用和运行中的后端。
- en: Fish out and print the backend criteria, such as the name, number of qubits,
    max number of experiments, and pending jobs to compare.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挖掘并打印出用于比较的后端标准，例如名称、量子比特数量、最大实验次数和挂起的作业数量。
- en: Select the least busy backend with five qubits.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择具有五个量子比特的最不繁忙的后端。
- en: Print out qubit properties for the selected backend.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出选定后端的量子比特属性。
- en: You can now take a closer look at the selected properties of the backend and,
    for example, use this information to decide which backend you want to run your
    programs on.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以更仔细地查看后端选定的属性，例如，使用这些信息来决定你想要在哪个后端上运行你的程序。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The file required in the following recipe can be downloaded from here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r5_explore.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r5_explore.py).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个菜谱中所需文件可从以下链接下载：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r5_explore.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r5_explore.py)。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Depending on the type of quantum program that you are writing, certain aspects
    of the backend might be important to you, and you might want to include these
    directly when you code your program. For example, you might be interested in the
    qubits with the smallest gate errors and readout errors, or if you are running
    deep circuits, you might be interested in long T1 and T2 times:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你编写的量子程序类型，后端的一些方面可能对你很重要，你可能希望在编写程序时直接包含这些方面。例如，你可能对具有最小门错误和读出错误的量子比特感兴趣，或者如果你正在运行深度电路，你可能对长的
    T1 和 T2 时间感兴趣：
- en: 'Like always, let''s start by importing the IBMQ class and load our account:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，让我们首先导入 IBMQ 类并加载我们的账户：
- en: '[PRE35]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Get all available backends.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有可用后端。
- en: 'We will use simple Python scripting to compare the available backends based
    on different criteria – the name, number of qubits, maximum allowed number of
    experiments per day, and number of pending jobs. First, we need a list of the
    available backends:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用简单的 Python 脚本来根据不同的标准（名称、量子比特数量、每天允许的最大实验次数和挂起的作业数量）比较可用的后端。首先，我们需要一个可用后端的列表：
- en: '[PRE36]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Fish out some backend parameters to compare.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挖掘一些后端参数进行比较。
- en: 'To find the parameters, we loop through the list and print out four selected
    parameters for each backend – `name`, `n_qubits`, `max_experiments`, and `pending_jobs`:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要找到参数，我们遍历列表并打印出每个后端的四个选定参数 – `name`、`n_qubits`、`max_experiments` 和 `pending_jobs`：
- en: '[PRE37]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding code might give the following result:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码可能给出以下结果：
- en: '![Figure 5.13 – The available backends with selected parameters displayed'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 5.13 – 显示选定参数的可用后端]'
- en: '](img/Figure_5.13_B14436.jpg)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_5.13_B14436.jpg)'
- en: Figure 5.13 – The available backends with selected parameters displayed
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.13 – 显示选定参数的可用后端
- en: Now, we can dig in and take a look at some of the available qubit data for the
    least busy backend with five qubits, such as the T1 and T2 decoherence values,
    the frequency, and the readout error for the qubits.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以深入了解并查看一些最不繁忙的后端（具有五个量子比特）的可用量子比特数据，例如 T1 和 T2 热退相干值、频率和量子比特的读出错误。
- en: For this exercise, we can write another simple Python `for` loop that prints
    the properties of the backend's qubits, such as name, value, and unit for the
    relevant data entry.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个练习，我们可以编写另一个简单的 Python `for` 循环来打印后端量子比特的属性，例如名称、值和相关的数据条目单位。
- en: 'We will loop through the number of qubits of the backend (`least_busy_backend.configuration().n_qubits`)
    and then the number of property parameters for each qubit (`len(least_busy_backend.properties().qubits[0])`):'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将遍历后端的量子比特数量（`least_busy_backend.configuration().n_qubits`）以及每个量子比特的属性参数数量（`len(least_busy_backend.properties().qubits[0])`）：
- en: '[PRE38]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code should give a result similar to the following:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码应给出类似于以下的结果：
- en: '![Figure 5.14 – Qubit details for a selected backend](img/Figure_5.14_B14436.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 选定后端的量子比特详细信息](img/Figure_5.14_B14436.jpg)'
- en: Figure 5.14 – Qubit details for a selected backend
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 选定后端的量子比特详细信息
- en: With that, we all of a sudden know much more about our qubits. They are not
    just logical entities anymore, but concrete physical objects, albeit physical
    objects behaving quantum mechanically. In the *Comparing qubits on a chip* recipe
    of [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220), *Cleaning Up
    Your Quantum Act with Ignis*, we will take a look at how you can use the `backend.properties().gates`
    information in your own programs.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们突然对量子比特有了更多的了解。它们不再是逻辑实体，而是具体的物理对象，尽管这些物理对象表现出量子行为。在[*第8章*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220)的“用Ignis清理您的量子行为”菜谱中，即[*比较芯片上的量子比特*]，我们将探讨如何在您的程序中使用`backend.properties().gates`信息。
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'In this recipe, we have looked at a selected subset of backend and qubit properties.
    With Qiskit®, you can dig out a lot more information by using the following methods:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们查看了一组选定的后端和量子比特属性。使用Qiskit®，您可以通过以下方法挖掘更多信息：
- en: '`backend.configuration()`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend.configuration()`'
- en: '`backend_name`'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`backend_name`'
- en: '`backend_version`'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`backend_version`'
- en: '`n_qubits`'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`n_qubits`'
- en: '`basis_gates`'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`basis_gates`'
- en: '`gates`'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gates`'
- en: '`local`'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`local`'
- en: '`simulator`'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`simulator`'
- en: '`conditional`'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`conditional`'
- en: '`open_pulse`'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`open_pulse`'
- en: '`memory`'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`memory`'
- en: '`max_shots`'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`max_shots`'
- en: '`backend.status()`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend.status()`'
- en: '`backend_name`'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`backend_name`'
- en: '`backend_version`'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`backend_version`'
- en: '`operational`'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`operational`'
- en: '`pending_jobs`'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pending_jobs`'
- en: '`status_msg`'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`status_msg`'
- en: '`backend.properties()`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend.properties()`'
- en: '`backend_name`'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`backend_name`'
- en: '`backend_version`'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`backend_version`'
- en: '`last_update_date`'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`last_update_date`'
- en: '`qubits`'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`qubits`'
- en: '`gates`'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gates`'
- en: '`general`'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`general`'
- en: Tip
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To print out the full list of value for each method, use the `to_dict()` parameter.
    For example: `backend.configuration().to_dict()`'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要打印出每个方法的所有值的完整列表，请使用`to_dict()`参数。例如：`backend.configuration().to_dict()`
- en: 'Try to modify the sample code to look up specific parameters such as the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改示例代码以查找特定的参数，如下所示：
- en: The backend name
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端名称
- en: The basis gates available for the backend
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端可用的基本门
- en: The qubit coupling map that specifies how the individual qubits can communicate
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定单个量子比特如何通信的量子比特耦合图
- en: A list of the gates and their properties for the backend
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端中门及其属性的列表
