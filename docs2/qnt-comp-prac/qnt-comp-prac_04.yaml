- en: '*Chapter 4*: Starting at the Ground Level with Terra'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：从Terra的起点开始'
- en: After our brief exploration of the IBM Quantum Experience® composer, and installation
    of IBM's Qiskit®, we are now ready to start writing quantum programs with Qiskit®.
    We will let go of the user interface, expanding our quantum computing journey
    into Python – one of the world's most popular and widespread scientific programming
    languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对IBM Quantum Experience®作曲家和IBM的Qiskit®进行简要探索，并安装IBM的Qiskit®之后，我们现在准备好开始使用Qiskit®编写量子程序。我们将放弃用户界面，将我们的量子计算之旅扩展到Python——这是世界上最受欢迎和广泛使用的科学编程语言之一。
- en: This chapter covers the basic requirements for building a quantum circuit with
    Qiskit®. We will walk through the making of a few minimalistic quantum programs
    that run on a local Qiskit Aer simulator and that display the results of the program
    in numeric as well as diagrammatic form. We will then take the leap and run the
    programs on actual IBM Quantum® hardware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了使用Qiskit®构建量子电路的基本要求。我们将逐步介绍几个最小化量子程序的制作，这些程序在本地Qiskit Aer模拟器上运行，并以数值和图表形式显示程序的结果。然后我们将迈出一步，在实际的IBM
    Quantum®硬件上运行这些程序。
- en: The theme of this chapter is *quantum coin tossing*, based on the rudimentary
    quantum program that we built in IBM Quantum Experience®. These are arguably the
    simplest meaningful quantum programs that you can write, as they start you off
    with a few basic foundational quantum gates, but also demonstrate the difference
    between probabilistic quantum computing and deterministic classical computing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是*量子抛硬币*，基于我们在IBM Quantum Experience®中构建的原始量子程序。这些可能是你可以编写的最简单且具有意义的量子程序，因为它们从一些基本的量子门开始，同时也展示了概率量子计算与确定性经典计算之间的差异。
- en: We will also expand on the minimal program by adding more gates, run the program
    many times to gather statistics about the outcomes, and more. The topics that
    we will be learning about in this chapter will be applied from the next chapter
    onwards.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过添加更多门来扩展最小化程序，多次运行程序以收集关于结果的数据，等等。本章我们将学习的内容将从下一章开始应用。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Building a Qiskit® quantum program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个Qiskit®量子程序
- en: Quantum coin toss revisited
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次探讨量子抛硬币
- en: Getting some statistics – tossing many coins in a row
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一些统计数据——连续抛掷许多硬币
- en: Implementing an upside-down coin toss
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现倒立抛硬币
- en: Tossing two coins simultaneously
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时抛掷两个硬币
- en: Quantum-cheating in a coin toss? – Introducing the Bell state
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛硬币时的量子作弊？——介绍贝尔态
- en: More ways to quantum-cheat – tweaking the odds
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多量子作弊的方法——调整概率
- en: Adding more coins – straight and cheating
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多硬币——直接和作弊
- en: Tossing some real coins
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛掷一些真实的硬币
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The quantum programs that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter04](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter04).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的量子程序可以在这里找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter04](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter04)。
- en: You can run the recipes in this chapter in your local Qiskit® environment that
    you set up as part of [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*, or you can run them in the notebook environment
    of the IBM Quantum Experience®.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在作为[*第1章*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021)，“准备你的环境”一部分设置的本地Qiskit®环境中运行本章的食谱，或者你可以在IBM
    Quantum Experience®的笔记本环境中运行它们。
- en: If you run them in your local environment, I'd recommend using the built-in
    Spyder iPython editor from your Anaconda installation. That is the editor used
    to build and run the samples in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本地环境中运行它们，我建议使用Anaconda安装中的内置Spyder iPython编辑器。这是本书中构建和运行示例所使用的编辑器。
- en: 'In the code examples in this book, you will sometimes see the following line
    of code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码示例中，你有时会看到以下这一行代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Depending on your environment, iPython might not display graphical output directly
    in the output. If this is the case, you can use the `display()` method to force
    the output, like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的环境，iPython可能不会直接在输出中显示图形输出。如果是这种情况，你可以使用`display()`方法强制输出，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example prints the quantum circuit `qc` to the iPython console.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将量子电路`qc`打印到iPython控制台。
- en: Building a Qiskit® quantum program
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Qiskit®量子程序
- en: Generally speaking, there are just a few required building blocks to create
    a quantum program using Qiskit®. First, you have to set up the required infrastructure
    and create the quantum circuit (what we call the **quantum score** in IBM Quantum
    Experience®). Then, you have to configure a backend to run your quantum program
    on, and finally execute and retrieve the results of your calculations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，使用Qiskit®创建量子程序只需要几个必要的构建块。首先，您必须设置所需的基础设施并创建量子电路（在IBM Quantum Experience®中我们称之为**量子评分**）。然后，您必须配置一个后端来运行您的量子程序，最后执行并检索计算结果。
- en: The following section is a summary of the Python building blocks that are required
    to make up a quantum program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分是构成量子程序的Python构建块的摘要。
- en: Listing the required classes, modules, and functions
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出所需的类、模块和函数
- en: 'Qiskit® includes a large number of Python classes, but for our initial foray,
    we just need the basic ones. These are used to configure each of the components
    that follow:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit®包含大量的Python类，但对我们最初的探索来说，我们只需要基本的一些。这些用于配置以下每个组件：
- en: '`QuantumCircuit`: This is used to create the circuit—the program—that you will
    execute. You will add gates and other components to the circuit.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuantumCircuit`: 这用于创建您将要执行的电路——程序。您将向电路添加门和其他组件。'
- en: '`QuantumRegister`: This represents the qubits that you can use to build your
    quantum program.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuantumRegister`: 这代表您可以用它来构建量子程序的可用的量子比特。'
- en: '`ClassicalRegister`: This represents the classical bits that are used to store
    the output of your quantum program.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassicalRegister`: 这代表用于存储您的量子程序输出的经典比特。'
- en: '`Aer`: This is the Qiskit® simulation layer, which we will discuss in greater
    detail in [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197), *Simulating
    Quantum Computers with Aer*.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aer`: 这是Qiskit®模拟层，我们将在[*第7章*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197)中更详细地讨论，*使用Aer模拟量子计算机*。'
- en: '`IBMQ`: This module is required to execute your quantum programs on actual
    IBMQ hardware. It includes the tools you need to interact with IBMQ.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IBMQ`: 此模块是执行您在IBM Q硬件上量子程序所必需的。它包括您与IBM Q交互所需的工具。'
- en: '`execute`: This component lets you run your program by providing the circuit,
    a backend, and a number of shots.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute`: 此组件允许您通过提供电路、后端和射击次数来运行您的程序。'
- en: Working with quantum registers and classical registers
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用量子寄存器和经典寄存器
- en: To be able to build your quantum program, you first need to decide how many
    qubits you want to work with, and how many classical bits you want to include
    to store your output. You can either set these up explicitly or use the `QuantumCircuit`
    class to automatically create the registers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建您的量子程序，您首先需要决定您想要使用多少量子比特，以及您想要包含多少经典比特来存储您的输出。您可以明确设置这些，或者使用`QuantumCircuit`类自动创建寄存器。
- en: 'The registers make up two sets of information-carrying bits of your quantum
    system:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器构成了您的量子系统中的两套信息携带比特：
- en: One set of quantum registers to hold your qubits
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组量子寄存器来存储您的量子比特
- en: One set of classical registers to hold your regular bits
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组经典寄存器来存储您的常规比特
- en: You will use measurement gates to read your qubits and then write the resulting
    classical bit to the classical registers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用测量门来读取您的量子比特，然后将结果经典比特写入经典寄存器。
- en: For most of the recipes in this book, the number of quantum and classical registers
    will be the same, but this is not required.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的大多数食谱，量子比特和经典寄存器的数量将是相同的，但这不是必需的。
- en: Understanding your quantum circuit
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解您的量子电路
- en: The quantum circuit instance that you create will hold the qubits and classical
    bits. You will manipulate each instance by adding gates.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的量子电路实例将包含量子比特和经典比特。您将通过添加门来操作每个实例。
- en: A quantum program can be assembled by combining more than one quantum circuit.
    You can, for example, create a circuit that holds the quantum gates and one circuit
    that holds the measurement gates. You can then add these circuits together to
    create a main quantum circuit that makes up your quantum program.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 量子程序可以通过组合多个量子电路来组装。例如，您可以创建一个包含量子门的电路和一个包含测量门的电路。然后，您可以添加这些电路以创建一个主量子电路，该电路构成了您的量子程序。
- en: Selecting a backend to run on
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择运行的后端
- en: To be able to execute your quantum program, you must define a backend. A backend
    can be a local simulator, an IBM Quantum® simulator in the cloud, or actual IBM
    Quantum® hardware accessed through the cloud.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够执行你的量子程序，你必须定义一个后端。后端可以是一个本地模拟器，云中的IBM Quantum®模拟器，或者通过云访问的实际IBM Quantum®硬件。
- en: Initially, we will use the `qasm_simulator` backend that is included with Qiskit
    Aer, but we will also run our quantum programs on some of the freely available
    IBM Quantum® backends.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将使用Qiskit Aer附带的自带的`qasm_simulator`后端，但我们也会在我们的量子程序上运行一些免费可用的IBM Quantum®后端。
- en: Running your circuit as a job
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将你的电路作为工作运行
- en: You run the quantum program as a job by providing the circuit, a backend, and
    a number of shots. If you run your quantum programs on IBM Quantum® hardware,
    you can also include a job monitor to keep track of your place in the queue.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供电路、后端和射击次数来作为一个工作运行量子程序。如果你在IBM Quantum®硬件上运行量子程序，你还可以包括一个工作监控器来跟踪你在队列中的位置。
- en: Receiving the results of your job
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收你的工作结果
- en: When your job has run, the results are returned. In these initial recipes, where
    we use the `qasm_simulator` backend or the IBM Quantum® hardware, the returned
    results will be Python dictionaries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的工作运行完成后，结果将被返回。在这些初始菜谱中，当我们使用`qasm_simulator`后端或IBM Quantum®硬件时，返回的结果将是Python字典。
- en: 'For a 1-qubit circuit, the result might look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于1比特电路，结果可能看起来像这样：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, the returned result of one shot was a qubit in the state ![](img/Formula_04_001.png)
    .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一次射击的返回结果是处于![img/Formula_04_001.png]状态的量子比特。
- en: 'The results could also look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 结果也可能看起来像这样：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the returned result was 1,000 shots, where 495 shots resulted in the qubit
    being ![](img/Formula_04_002.png) , and 505 shots that resulted in ![](img/Formula_04_001.png)
    .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，返回的结果是1,000次射击，其中495次射击导致量子比特处于![img/Formula_04_002.png]状态，505次射击导致![img/Formula_04_001.png]状态。
- en: 'The returned results can be more complex. The following example is a possible
    result of a 3-qubit quantum program that was run 1,000 times:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的结果可能更复杂。以下是一个可能的结果，这是一个运行了1,000次的3比特量子程序：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the result ![](img/Formula_04_004.png) came up 113 times, ![](img/Formula_04_005.png)
    came up 139 times, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，结果出现了113次![img/Formula_04_004.png]，出现了139次![img/Formula_04_005.png]，等等。
- en: But, enough talk, let's write some quantum programs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，话不多说，让我们编写一些量子程序。
- en: Quantum coin toss revisited
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子抛硬币再探
- en: In this recipe, we will take a closer look at the very first quantum program
    we created in IBM Quantum Experience® – the **quantum coin toss**. Again, this
    is arguably the simplest quantum program that still provides real quantum computing
    value. It demonstrates the probabilistic nature of quantum computing. For a refresher,
    see [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)*, IBM Quantum
    Experience® – Quantum Drag and Drop*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将更详细地研究我们在IBM Quantum Experience®中创建的第一个量子程序——**量子抛硬币**。再次强调，这可能是最简单的量子程序，但仍提供了真正的量子计算价值。它展示了量子计算的随机性质。为了复习，请参阅[*第3章*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)*，IBM
    Quantum Experience® – Quantum Drag and Drop*。
- en: 'In IBM Quantum Experience®, the coin toss program looked like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在IBM Quantum Experience®中，抛硬币程序看起来像这样：
- en: '![Figure 4.1 – Simple coin toss circuit in the IBM Quantum Experience® composer'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – IBM Quantum Experience® composer中的简单抛硬币电路'
- en: '](img/Figure_4.1_B14436.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.1_B14436.jpg]'
- en: Figure 4.1 – Simple coin toss circuit in the IBM Quantum Experience® composer
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – IBM Quantum Experience® composer中的简单抛硬币电路
- en: With the quantum coin toss, we will again use the *Hadamard gate* to create
    a quantum superposition, and a measurement gate to force the superposition to
    collapse into one of the two qubit states ![](img/Formula_04_002.png) or ![](img/Formula_04_001.png),
    representing *heads* or *tails*. This time, however, we will create the circuit
    in Python with Qiskit®, which means that we need to also create the framework
    for the gates and measurement by defining and creating quantum circuits and classical
    circuits using Python commands.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子抛硬币中，我们再次使用*Hadamard门*来创建量子叠加，并使用测量门迫使叠加坍缩为两个量子比特状态之一![img/Formula_04_002.png]或![img/Formula_04_001.png]，分别代表*正面*或*反面*。然而，这次我们将使用Qiskit®在Python中创建电路，这意味着我们还需要通过定义和创建量子电路和经典电路来定义和创建门和测量的框架。
- en: This is a quantum circuit that simulates the probabilistic nature of a single
    qubit in superposition. The 1-qubit circuit initializes the qubit in the ground
    state – ![](img/Formula_04_002.png) – and then uses a Hadamard gate to put the
    qubit in superposition.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模拟单个量子比特在叠加中概率性质的量子电路。1量子比特电路将量子比特初始化在基态 – ![](img/Formula_04_002.png) –
    然后使用Hadamard门将量子比特置于叠加状态。
- en: 'During our calculations, the statevector of the qubit looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计算中，量子比特的状态向量看起来是这样的：
- en: '![Figure 4.2 – Formula for the statevector of the qubit](img/Figure_4.2_B14436.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 量子比特状态向量的公式](img/Figure_4.2_B14436.jpg)'
- en: Figure 4.2 – Formula for the statevector of the qubit
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 量子比特状态向量的公式
- en: 'You can also write it in the vector form:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将其写成向量形式：
- en: '![Figure 4.3 – Statevector of the qubit in the vector form](img/Figure_4.3_B14436.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 向量形式下的量子比特状态向量](img/Figure_4.3_B14436.jpg)'
- en: Figure 4.3 – Statevector of the qubit in the vector form
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 向量形式下的量子比特状态向量
- en: 'Another vector form is the Qiskit® statevector form that you will see in these
    examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种向量形式是您将在这些示例中看到的Qiskit®状态向量形式：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Measuring the qubit causes it to collapse into one of the states ![](img/Formula_04_002.png)
    or ![](img/Formula_04_001.png) with a ~50% probability, that is, a coin toss.
    The result is displayed as a numeric readout, as a bar diagram, and as a Bloch
    sphere.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测量量子比特会导致它以大约50%的概率坍缩到状态 ![](img/Formula_04_002.png) 或 ![](img/Formula_04_001.png)
    ，即抛硬币。结果以数字读数、条形图和Bloch球的形式显示。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r1_coin_toss.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r1_coin_toss.py).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r1_coin_toss.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r1_coin_toss.py)。
- en: For a quick reminder of how to run the sample programs, see the *Downloading
    the code samples* recipe of [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速回顾如何运行示例程序，请参阅[*第1章*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021)的*下载代码示例*食谱，*准备您的环境*。
- en: You are ready to write your first quantum program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以编写您的第一个量子程序了。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: The following steps will—to a large extent—be repeated throughout the book,
    based on the basic required classes and steps for basic Qiskit® management. So,
    expect the *How to do it…* section's bullets to be somewhat briefer going forward.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤在很大程度上将在本书中重复，基于基本所需的类和步骤进行基本的Qiskit®管理。因此，请期待接下来的*如何做…*部分的要点将变得更加简短。
- en: 'There will, however, be differences depending on what program you are planning
    to run, and what Qiskit® components you will be using. Let''s start the program
    now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，具体差异将取决于您计划运行的程序以及您将使用的Qiskit®组件。现在让我们开始程序：
- en: Import the required Qiskit® classes.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的Qiskit®类。
- en: 'First, we import the Python classes that are required to create registers and
    circuits, set a backend, and so on. Please refer to the *Listing the required
    Qiskit® classes, modules, and functions* section of the *Building a Qiskit® quantum
    program* recipe:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们导入创建寄存器和电路、设置后端等所需的Python类。请参阅*列出所需的Qiskit®类、模块和函数*部分的*构建Qiskit®量子程序*食谱：
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In addition, we also import the `display` method from `IPython.core.display`.
    This is used to correctly display the graphics output in our Anaconda Spyder IPython
    environment, and might not be required in your environment.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还从`IPython.core.display`导入`display`方法。这用于在我们的Anaconda Spyder IPython环境中正确显示图形输出，并且可能不在您的环境中需要。
- en: Create the required registers and the quantum circuit.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的寄存器和量子电路。
- en: 'We create two registers, one for the quantum bit and one for the classic bit.
    We also create a quantum circuit that is made up of the quantum register and the
    classic register. The quantum register is initialized in the ground state, ![](img/Formula_04_002.png)
    , and the classical register is set to 0:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建两个寄存器，一个用于量子比特，一个用于经典比特。我们还创建了一个由量子寄存器和经典寄存器组成的量子电路。量子寄存器被初始化在基态，![](img/Formula_04_002.png)
    ，而经典寄存器被设置为0：
- en: '[PRE7]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add gates to the quantum circuit.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量子电路添加门。
- en: 'For our quantum program to actually do something, we now add a Hadamard gate
    that will put the qubit in a superposition, and also a measurement gate that we
    will use to read the value of the quantum bit at the end of our program. The Hadamard
    gate is one of the foundational gates. We will look much more closely at that
    gate, and others, in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让我们的量子程序真正做些事情，我们现在添加一个哈达玛门，将量子比特置于叠加态，并添加一个测量门，我们将在程序结束时使用它来读取量子比特的值。哈达玛门是基础门之一。我们将在[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)《理解Qiskit®门库》中更详细地研究该门以及其他门：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By visualizing the circuit with `qc.draw`(`''mpl''`), we see that just like
    in the IBM Quantum Experience® composer, we have a quantum circuit with 1 qubit
    and 1 classical bit, with a Hadamard gate on the qubit, and a measurement gate
    that will write the state of the qubit `q0_0` (![](img/Formula_04_002.png) or
    ![](img/Formula_04_001.png) ) to the classical bit `c0_0` as a 0 or 1:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用`qc.draw`(`'mpl'`)可视化电路，我们看到，就像在IBM Quantum Experience® composer中一样，我们有一个包含1个量子比特和1个经典比特的量子电路，量子比特上有一个哈达玛门，以及一个将量子比特`q0_0`(![](img/Formula_04_002.png)或![](img/Formula_04_001.png))的状态写入经典比特`c0_0`作为0或1的测量门：
- en: '![Figure 4.4 – A simple quantum coin toss circuit'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.4 – 简单量子抛硬币电路'
- en: '](img/Figure_4.4_B14436.jpg)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.4 – 简单量子抛硬币电路](img/Figure_4.4_B14436.jpg)'
- en: Figure 4.4 – A simple quantum coin toss circuit
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.4 – 一个简单的量子抛硬币电路
- en: 'In a strictly text-based Python environment, you can also print your circuit
    with the `print(qc)` command or use `qc.draw`(`''text''`), both of which produce
    ASCII text output:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在一个纯文本的Python环境中，你也可以使用`print(qc)`命令或使用`qc.draw`(`'text'`)来打印你的电路，这两个都会产生ASCII文本输出：
- en: '![Figure 4.5 – The circuit displayed as ASCII text](img/Figure_4.5_B14436.jpg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Figure 4.5 – 以ASCII文本显示的电路](img/Figure_4.5_B14436.jpg)'
- en: Figure 4.5 – The circuit displayed as ASCII text
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.5 – 以ASCII文本显示的电路
- en: Set the backend on which to run.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置运行的后端。
- en: 'For this initial recipe, we will use the built-in `qasm_simulator` backend.
    We create a backend variable and call on the Aer component to get us the required
    backend information:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个初始配方，我们将使用内置的`qasm_simulator`后端。我们创建一个后端变量并调用Aer组件来获取所需的后端信息：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the job.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行作业。
- en: 'Create a quantum job for the circuit and the selected backend that runs just
    one shot to simulate a coin toss. We then run the job and display the returned
    result; either ![](img/Formula_04_002.png) for heads or ![](img/Formula_04_001.png)
    for tails. The results are returned as a Python dictionary:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为电路和所选后端创建一个量子作业，只运行一次以模拟抛硬币。然后我们运行作业并显示返回的结果；要么是![](img/Formula_04_002.png)表示正面，要么是![](img/Formula_04_001.png)表示反面。结果以Python字典的形式返回：
- en: '[PRE10]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Print and visualize the results:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印并可视化结果：
- en: '[PRE11]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, we get a printout of the results:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们打印出结果：
- en: '[PRE12]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we get a printout of the result as a histogram:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们以直方图的形式打印出结果：
- en: '![Figure 4.6 – The result of a single quantum "coin toss" as a histogram](img/Figure_4.6_B14436.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.6 – 作为直方图的单个量子“抛硬币”结果](img/Figure_4.6_B14436.jpg)'
- en: Figure 4.6 – The result of a single quantum "coin toss" as a histogram
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 作为直方图的单个量子“抛硬币”结果
- en: Success! Your very first quantum coin toss program returned a tails, or ![](img/Formula_04_001.png)
    result.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！你第一个量子抛硬币程序返回了反面，或![](img/Formula_04_001.png)结果。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We tossed a quantum coin that started out with *heads* up ( ![](img/Formula_04_002.png)
    ), *spun* in quantum space as a superposition of ![](img/Formula_04_002.png) and
    ![](img/Formula_04_001.png), and finally landed in a *tails* position when we
    measured it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们抛了一个量子硬币，它最初是向上（![](img/Formula_04_002.png)），在量子空间中以![](img/Formula_04_002.png)和![](img/Formula_04_001.png)的叠加态旋转，当我们测量它时最终落在反面位置。
- en: So, what happened?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？
- en: 'Let''s reiterate:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重申：
- en: We created a qubit and initialized it in the ground state, ![](img/Formula_04_002.png).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个量子比特并将其初始化在基态，![](img/Formula_04_002.png)。
- en: We then applied a Hadamard gate to the qubit, which moved the statevector from
    the pole to the equator of the Bloch sphere.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们对量子比特应用了一个哈达玛门，将状态向量从布洛赫球的极点移动到赤道。
- en: Mathematically, when you apply the Hadamard gate to your qubit, you run it through
    two rotations, first a ![](img/Formula_04_021.png) rotation around the *y* axis,
    and then a ![](img/Formula_04_022.png) rotation around the *x* axis. The qubit
    is now in a superposition of ![](img/Formula_04_002.png) and ![](img/Formula_04_001.png),
    halfway between the poles.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从数学上讲，当你将Hadamard门应用于量子比特时，你让它经历两次旋转，首先是在*y*轴上的![](img/Formula_04_021.png)旋转，然后是在*x*轴上的![](img/Formula_04_022.png)旋转。量子比特现在处于![](img/Formula_04_002.png)和![](img/Formula_04_001.png)的叠加状态，位于两个极点之间。
- en: For more detailed information about the Hadamard gate, see the *Creating superpositions
    with the H gate* recipe in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想了解更多关于Hadamard门的信息，请参阅[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)中的*使用H门创建叠加*配方，*理解Qiskit®门库*。
- en: Finally, we measured the qubit.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们测量了量子比特。
- en: By measuring, we destroyed the superposition, literally forcing nature to make
    up its mind, and the qubit will be either ![](img/Formula_04_002.png) or ![](img/Formula_04_001.png).
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过测量，我们破坏了叠加，实际上迫使自然界做出决定，量子比特将处于![](img/Formula_04_002.png)或![](img/Formula_04_001.png)。
- en: Now, go ahead and run your program a couple of times, noting if you get heads
    ( ![](img/Formula_04_002.png) ) or tails ( ![](img/Formula_04_001.png) ). If we
    have done this right, you should be simulating a coin toss pretty closely.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，先运行你的程序几次，注意观察你是否得到正面（![](img/Formula_04_002.png)）或反面（![](img/Formula_04_001.png)）。如果我们做得正确，你应该能非常接近地模拟抛硬币。
- en: Getting some statistics – tossing many coins in a row
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取一些统计数据——连续抛很多次硬币
- en: Alright, so far, we have done a single coin toss at a time, much like you would
    do in real life.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止，我们一次只抛一个硬币，就像现实生活中一样。
- en: But the power of quantum computing comes from running your quantum programs
    many times with the same initial conditions, letting the qubit superpositions
    play out their quantum mechanical advantages, and summarizing a large number of
    runs statistically.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但量子计算的力量来自于多次运行相同的初始条件下的量子程序，让量子比特的叠加发挥其量子力学优势，并对大量运行进行统计分析。
- en: With this recipe, we will do 1,000 coin tosses in the blink of an eye and take
    a look at the results to see how good the coin is. Will this coin be a fair way
    to start, say, a game of baseball? Let's see how that works.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个配方，我们将在一瞬间进行1,000次抛硬币，并查看结果，看看硬币的好坏。这个硬币是否能够公平地开始一场棒球比赛？让我们看看它是如何工作的。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r2_coin_tosses.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r2_coin_tosses.py).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的示例代码可以在这里找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r2_coin_tosses.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r2_coin_tosses.py)。
- en: In this recipe, we will explore and expand on the `shots` job parameter. This
    parameter lets you control how many times you run the quantum job cycle – prepare,
    run, measure. So far, we have prepared our qubits in the ![](img/Formula_04_002.png)
    state, set the backend to a simulator, and then run one shot, which represents
    one full cycle.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探索和扩展`shots`作业参数。这个参数让你控制量子作业周期（准备、运行、测量）运行的次数。到目前为止，我们已经将量子比特准备在![](img/Formula_04_002.png)状态，将后端设置为模拟器，然后运行一次，这代表了一个完整的周期。
- en: In the IBM Quantum Experience® composer examples, we ran our scores 1,024 times,
    which is the default. We discovered that the output turned statistical. In this
    recipe, we will play with a different number of shots to see how the outcomes
    statistically change.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在IBM Quantum Experience®作曲家的示例中，我们运行了1,024次评分，这是默认值。我们发现输出变成了统计性的。在这个配方中，我们将尝试不同的射击次数，看看结果如何从统计上变化。
- en: Generally speaking, you want to increase the number of shots to improve statistical
    accuracy.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，你想要增加射击次数以提高统计精度。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Much like in the previous recipe, the following steps are all you need:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的配方类似，以下步骤都是你所需要的：
- en: Code reuse
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重用
- en: And for the lazy coder, in this case, as you might have realized, the only real
    change to the circuit appears in *step 6*, where we set the number of shots. Feel
    free to reuse the previous recipe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于懒惰的程序员来说，在这种情况下，正如你可能已经意识到的，电路中唯一真正的变化出现在*第 6 步*，在那里我们设置了射击次数。请随意重用之前的配方。
- en: 'Import the required Qiskit® classes and methods:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的 Qiskit® 类和方法：
- en: '[PRE13]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the required registers and the quantum circuit. Set up our quantum circuit
    with one qubit and one classical bit. Create the quantum circuit based on the
    registers:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的寄存器和量子电路。使用寄存器设置我们的量子电路，一个量子比特和一个经典比特。根据寄存器创建量子电路：
- en: '[PRE14]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add gates to the quantum circuit. Add the Hadamard and measurement gates:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量子电路添加门。添加 Hadamard 和测量门：
- en: '[PRE15]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Figure 4.7 – The same simple quantum coin toss circuit'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.7 – 相同的简单量子抛硬币电路'
- en: '](img/Figure_4.7_B14436.jpg)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.7_B14436.jpg)'
- en: Figure 4.7 – The same simple quantum coin toss circuit
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.7 – 相同的简单量子抛硬币电路
- en: 'Set the backend to our local simulator to run:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后端设置为我们的本地模拟器以运行：
- en: '[PRE16]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the job.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行作业。
- en: 'Note that this time, we run it with *1,000 shots*. This means that we run our
    quantum circuit 1,000 times, collect the results, and provide the average output
    as our results:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这次我们运行了*1,000 次射击*。这意味着我们运行了我们的量子电路 1,000 次，收集了结果，并提供了平均输出作为我们的结果：
- en: '[PRE17]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Print and visualize the results:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印并可视化结果：
- en: '[PRE18]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This time the output looks different:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次输出看起来不同：
- en: '[PRE19]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here is the output in the form of a histogram:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是输出的直方图形式：
- en: '![Figure 4.8 – The result of 1,000 shots, a roughly even distribution of 0
    and 1'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 1,000 次射击的结果，0 和 1 的分布大致均匀'
- en: '](img/Figure_4.8_B14436.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.8_B14436.jpg)'
- en: Figure 4.8 – The result of 1,000 shots, a roughly even distribution of 0 and
    1
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 1,000 次射击的结果，0 和 1 的分布大致均匀
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This time we used the underlying Qiskit® analytics to store and process the
    result of each individual shot and return it as a concatenated Python dictionary.
    The end result is a statistical view of all the actual outcomes of your quantum
    program. For the coin toss, you would expect to get heads and tails with roughly
    equal probability if you run it enough times.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了底层的 Qiskit® 分析来存储和处理每次射击的结果，并将其作为连接的 Python 字典返回。最终结果是所有实际输出的统计视图。对于抛硬币，如果你运行足够多次，你预计会以大致相等的概率得到正面和反面。
- en: Try adjusting the number of shots to 10,000 or 20,000, and see how your qubit
    behaves statistically.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将射击次数调整为 10,000 或 20,000，并查看你的量子比特在统计上的行为。
- en: In a more complex quantum program, the result will usually indicate a preference
    for a specific outcome, a specific combination of qubit statistics where certain
    solutions are amplified and show up much more often than others. This is one of
    the key tricks with writing good quantum algorithms, understanding how to get
    the circuits to point to the correct answer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更复杂的量子程序中，结果通常将表明对特定结果的偏好，即量子比特统计的特定组合，其中某些解决方案被放大并比其他解决方案出现得更频繁。这是编写良好的量子算法的关键技巧之一，理解如何让电路指向正确的答案。
- en: We will go into more detail on this later, starting with the *Exploring quantum
    phase kickback* recipe in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后对此进行更详细的介绍，从[*第 9 章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)中的*探索量子相位回弹*配方开始，*Grover
    搜索算法*。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Generally speaking, you are usually interested in getting the statistical result
    of your quantum program. In this case, we are looking at the probabilistic nature
    of a quantum coin toss – a random number generator. But sometimes, it might be
    interesting to see exactly what transpired, shot by shot.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，你通常对获取量子程序的统计结果感兴趣。在这种情况下，我们正在查看量子抛硬币的概率性质——一个随机数生成器。但有时，看到每一步的具体情况可能也很有趣。
- en: 'You can achieve this by setting the `memory=True` parameter when you run your
    quantum program:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在运行你的量子程序时设置`memory=True`参数来实现这一点：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This setting makes the quantum job save the individual results of each shot,
    and you can later retrieve these as a Python list by using the `result.get_memory()`
    command. For 10 shots on a 1-qubit circuit, the memory result might look like
    this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置使量子作业保存每次射击的个别结果，你可以稍后通过使用`result.get_memory()`命令检索这些结果。对于 1 量子比特电路的 10 次射击，内存结果可能看起来像这样：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And for 10 shots on a 2-qubit circuit (which we will do in a later recipe),
    the memory result might look like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个 2 量子比特电路的 10 次射击（我们将在后面的配方中这样做），内存结果可能看起来像这样：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can then dig out any data you want from this list and process it further
    with other Python tools as needed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这个列表中挖掘出任何您想要的数据，并根据需要使用其他Python工具进一步处理。
- en: Implementing an upside-down coin toss
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现倒立硬币抛掷
- en: In this recipe, we will tweak our very first quantum program a little bit but
    still keep it relatively simple. An actual coin can be tossed starting with either
    heads or tails facing upward. Let's do another quantum coin toss but with a different
    starting point, the coin facing tails up. In Dirac notation, we start with our
    qubit in ![](img/Formula_04_001.png) instead of in ![](img/Formula_04_002.png).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将对我们的第一个量子程序进行一点调整，但仍然保持相对简单。实际的硬币可以抛掷，开始时正面朝上或反面朝上。让我们再进行一次量子硬币抛掷，但起点不同，硬币朝反面。在狄拉克符号中，我们开始时将量子比特置于![img/Formula_04_001.png]，而不是![img/Formula_04_002.png]。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r3_coin_toss_tails.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r3_coin_toss_tails.py).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r3_coin_toss_tails.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r3_coin_toss_tails.py).
- en: Just like the previous recipe, this one is almost identical to the first coin
    toss recipe. Feel free to reuse what you have already created. The only real difference
    is that we add a new quantum gate, the **X** (or **NOT**) gate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的菜谱一样，这个菜谱几乎与第一个硬币抛掷菜谱相同。您可以自由地重用您已经创建的内容。唯一的真正区别是，我们添加了一个新的量子门，即**X**（或**NOT**）门。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The following steps are to a large extent identical to the steps from the *Quantum
    coin toss revisited* recipe. There are, however, differences depending on the
    program you are creating, and what Qiskit® components you are using. I will describe
    these in detail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤在很大程度上与*量子硬币抛掷重访*菜谱中的步骤相同。然而，根据您创建的程序以及您使用的Qiskit®组件，可能会有所不同。我将详细描述这些。
- en: 'Set up your code like the previous example and then add an X gate to flip the
    qubit:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的示例设置您的代码，然后添加一个X门来翻转量子比特：
- en: 'Import the required Qiskit® classes and methods:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的Qiskit®类和方法：
- en: '[PRE23]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how we are not importing the `QuantumRegister` and `ClassicalRegister`
    methods here like we did before. In this recipe, we will take a look at a different
    way of creating your quantum circuit.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在这里没有像之前那样导入`QuantumRegister`和`ClassicalRegister`方法。在这个菜谱中，我们将探讨创建量子电路的另一种不同方式。
- en: 'Create the quantum circuit with 1 qubit and 1 classical bit:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含1个量子比特和1个经典比特的量子电路：
- en: '[PRE24]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we are implicitly letting the `QuantumCircuit` method create the quantum
    and classical registers in the background; we do not have to explicitly create
    them. We will refer to these registers by numbers and lists going forward.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们隐式地让`QuantumCircuit`方法在后台创建量子比特和经典比特寄存器；我们不需要显式地创建它们。我们将使用数字和列表来引用这些寄存器。
- en: 'Add the Hadamard gate, the X gate, and the measurement gates to the circuit:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Hadamard门、X门和测量门添加到电路中：
- en: '[PRE25]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, here is the first example of using just numbers to refer to the qubits.
    We add the X gate to the first qubit, here referred to as 0 as Python starts numbering
    at 0, not 1:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，这里是我们使用仅数字来引用量子比特的第一个例子。我们将X门添加到第一个量子比特，这里称为0，因为Python从0开始编号，而不是从1开始：
- en: '![Figure 4.9 – The upside-down quantum coin toss circuit'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.9 – The upside-down quantum coin toss circuit'
- en: '](img/Figure_4.9_B14436.jpg)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_4.9_B14436.jpg]'
- en: Figure 4.9 – The upside-down quantum coin toss circuit
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.9 – 倒立量子硬币抛掷电路
- en: 'Set the backend to our local simulator:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后端设置为我们的本地模拟器：
- en: '[PRE26]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To run the job, this time, we go back to 1 shot to do just a single coin toss:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行作业，这次，我们回到1次抛掷，只进行一次硬币抛掷：
- en: '[PRE27]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice here how we have streamlined the code a bit and put all the execution
    in one row as we are only interested in the final counts.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这里我们稍微简化了代码，并将所有执行放在一行中，因为我们只对最终的计数感兴趣。
- en: 'Visualize the results:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化结果：
- en: '[PRE28]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output looks like the following:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出看起来如下：
- en: '![Figure 4.11 – Setting your qubit to  by using the initialize method](img/Figure_4.10_B14436.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.11 – 使用initialize方法将量子比特设置为](img/Figure_4.10_B14436.jpg)'
- en: Figure 4.10 – The results of a single upside-down quantum coin toss
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 单次倒立量子硬币抛掷的结果
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are introducing a new gate in this recipe, the Pauli-X gate. The X gate works
    just like a NOT gate in classical computing – it flips the value of a qubit.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们引入了一个新的门，即 Pauli-X 门。X 门在经典计算中就像 NOT 门一样工作——它翻转量子位的值。
- en: If the qubit is ![](img/Formula_04_002.png), then it is flipped to ![](img/Formula_04_001.png),
    and if it is in ![](img/Formula_04_001.png), then it is flipped to ![](img/Formula_04_002.png).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果量子位是 ![](img/Formula_04_002.png)，则它翻转成 ![](img/Formula_04_001.png)，如果它在 ![](img/Formula_04_001.png)，则它翻转成
    ![](img/Formula_04_002.png)。
- en: For simple situations like this, it is intuitively easy to understand exactly
    what the result will be, but for more complex qubit configurations, where the
    Bloch vector points at an arbitrary point on the Bloch sphere, it gets a little
    trickier. Essentially what happens is that the qubit is rotated around the *x*
    axis through an angle of ![](img/Formula_04_036.png) radians.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样简单的情况，直观上很容易理解结果会是什么，但对于更复杂的量子位配置，其中 Bloch 向量指向 Bloch 球上的任意点，事情就变得有点棘手。本质上发生的事情是量子位绕
    *x* 轴旋转了 ![](img/Formula_04_036.png) 弧度。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The X gate is handy for this, but there is another way to set your coin toss
    tails up. You can use the Qiskit Aer `initialize` method to set the initial state
    of a qubit to ![](img/Formula_04_001.png) before running your circuit.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: X 门在这里很有用，但还有另一种方法可以设置你的硬币投掷反面。你可以在运行电路之前使用 Qiskit Aer 的 `initialize` 方法将量子位的初始状态设置为
    ![](img/Formula_04_001.png)。
- en: 'The following is an example of how to do just that:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何做到这一点的示例：
- en: 'Create a Python vector that corresponds to an excited ![](img/Formula_04_001.png)
    state and initialize the quantum circuit:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与激发态对应的 Python 向量，并初始化量子电路：
- en: '[PRE29]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Find the following code in your circuit, and replace it with the preceding
    initialize code snippet:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电路中找到以下代码，并将其替换为前面的 initialize 代码片段：
- en: '[PRE30]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now run the program as normal. The results should be similar, but your circuit
    printout will look like this:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在正常运行程序。结果应该相似，但你的电路打印输出将如下所示：
- en: '![Figure 4.11 – Setting your qubit to  by using the initialize method'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11 – 使用 initialize 方法设置你的量子位为 ]'
- en: '](img/Figure_4.11_B14436.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B14436.jpg)'
- en: Figure 4.11 – Setting your qubit to ![](img/Formula_04_039.png) by using the
    initialize method
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 使用 initialize 方法设置你的量子位为 ![](img/Formula_04_039.png)
- en: 'This way, you can initialize any number of qubits to any state you choose.
    The initialization vector needs to fulfill two main criteria:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以将任意数量的量子位初始化为任何你选择的状态。初始化向量需要满足两个主要标准：
- en: It must include an entry for each of the 2n possible states. In the preceding
    example, with 1 qubit, all we needed was a vector with length 2\. For 2 qubits,
    the vector must have length 4, and so on.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须包括 2^n 可能状态中的每个状态的条目。在前面的例子中，对于 1 个量子位，我们只需要一个长度为 2 的向量。对于 2 个量子位，向量必须长度为
    4，依此类推。
- en: 'The sum of the squares of the absolute value of the vector components must
    be equal to 1\. Here''s the initial vector from the preceding example that initialized
    the qubit to ![](img/Formula_04_001.png):'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量分量绝对值的平方和必须等于 1。以下是初始化量子位为 ![](img/Formula_04_001.png) 的前一个示例中的初始向量：
- en: '[PRE31]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This translates into the following:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以转化为以下：
- en: '![Figure 4.12 – Initial vector](img/Figure_4.12_B14436.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 初始向量](img/Figure_4.12_B14436.jpg)'
- en: Figure 4.12 – Initial vector
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 初始向量
- en: 'This, in turn, gives the sum of probabilities:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来又给出了概率之和：
- en: '![Figure 4.13 – Sum of probabilities'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 概率之和'
- en: '](img/Figure_4.13_B14436.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B14436.jpg)'
- en: Figure 4.13 – Sum of probabilities
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 概率之和
- en: Tossing two coins simultaneously
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时掷两枚硬币
- en: So far, we have only played with one coin at a time, but there is nothing stopping
    us from adding more coins. In this recipe, we will add a coin to the simulation,
    and toss two coins simultaneously. We will do this by adding a second qubit, expanding
    the number of qubits – two of everything.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一次只玩一枚硬币，但没有任何阻止我们添加更多硬币。在这个菜谱中，我们将向模拟中添加一枚硬币，并同时掷两枚硬币。我们将通过添加第二个量子位来实现这一点，扩展量子位的数量——两倍于所有东西。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r4_two_coin_toss.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r4_two_coin_toss.py).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r4_two_coin_toss.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r4_two_coin_toss.py).
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Set up your code like the previous example, but with a 2-qubit quantum circuit:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的例子设置你的代码，但使用2量子比特量子电路：
- en: 'Import the classes and methods that we need:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的类和方法：
- en: '[PRE32]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Set up our quantum circuit with two qubits and two classical bits:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个量子比特和两个经典比特设置我们的量子电路：
- en: '[PRE33]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the Hadamard gates and the measurement gates to the circuit:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Hadamard门和测量门添加到电路中：
- en: '[PRE34]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note how we are now using lists to reference multiple qubits and multiple bits.
    For example, we apply the Hadamard gate to qubits 0 and 1 by using [0,1] as input:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们现在是如何使用列表来引用多个量子比特和多个比特的。例如，我们通过使用[0,1]作为输入来对量子比特0和1应用Hadamard门：
- en: '![Figure 4.14 – A 2-qubit quantum coin toss circuit ](img/Figure_4.14_B14436.jpg)'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图4.14 – 2量子比特量子硬币抛掷电路](img/Figure_4.14_B14436.jpg)'
- en: Figure 4.14 – A 2-qubit quantum coin toss circuit
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.14 – 2量子比特量子硬币抛掷电路
- en: 'Set the backend to our local simulator:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后端设置为我们的本地模拟器：
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the job with one shot:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一次射击的作业：
- en: '[PRE36]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, we are using streamlined code as we are only interested in the counts
    here.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，我们使用简化的代码，因为我们只对计数感兴趣。
- en: 'Visualize the results:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化结果：
- en: '[PRE37]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The histogram looks like this:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直方图看起来像这样：
- en: '![Figure 4.15 – The  result of a double quantum coin toss'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15 – 双量子硬币抛掷的结果'
- en: '](img/Figure_4.15_B14436.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B14436.jpg)'
- en: Figure 4.15 – The ![](img/Formula_04_041.png) result of a double quantum coin
    toss
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – 双量子硬币抛掷的![img/Formula_04_041.png]结果
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You set the number of qubits when you create the quantum circuit.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建量子电路时，你可以设置量子比特的数量。
- en: When you ran the program, both qubits were supplied with Hadamard gates, creating
    two parallel qubits both in superposition.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，两个量子比特都提供了Hadamard门，创建了两个处于叠加态的并行量子比特。
- en: 'In Qiskit®, qubit numbering starts with 0 for the first qubit and then counts
    upward. A 3-qubit circuit will contain the following qubits, referred to as the
    first, second, and third qubits:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qiskit®中，量子比特编号从0开始，第一个量子比特，然后向上计数。一个3量子比特电路将包含以下量子比特，分别称为第一个、第二个和第三个量子比特：
- en: 'If you are using `QuantumRegister` notation, like in the *Quantum coin toss
    revisited* recipe: `q[0]`, `q[1]`, and `q[2]`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用`QuantumRegister`表示法，就像在*量子硬币抛掷重访*食谱中一样：`q[0]`，`q[1]`，和`q[2]`
- en: 'If you are using the list notation: `[0,1,2]`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用列表表示法：`[0,1,2]`
- en: There's more...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Do a little experimentation here by adding more qubits to your circuit. You
    will realize that you can use this simple method to create random numbers of any
    kind. The output will be a binary number of the same length as the number of qubits
    in your circuit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里进行一些实验，通过向你的电路中添加更多量子比特。你会发现你可以使用这种方法来创建任何类型的随机数。输出将是一个与你的电路中量子比特数量相同的二进制数。
- en: 'For example, creating a circuit with 20 qubits and running it with one shot
    might result in the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建一个包含20个量子比特的电路，并运行一次，可能会得到以下输出：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This translates into the following decimal number:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以转换为以下十进制数字：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So, you can use quantum programs to create any type of random number. For example,
    you can also use this setup to create dice of different sizes following the 2n
    rule for a number of possible states (where n is the number of qubits). So, the
    calculation goes like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用量子程序来创建任何类型的随机数。例如，你也可以使用这个设置来创建不同大小的骰子，遵循2^n规则（其中n是量子比特的数量）。所以，计算是这样的：
- en: One qubit = two possible states = coin
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个量子比特 = 两种可能状态 = 硬币
- en: Two qubits = four possible states = four-sided dice
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个量子比特 = 四种可能状态 = 四面骰子
- en: Three qubits = eight possible states = eight-sided dice
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个量子比特 = 八种可能状态 = 八面骰子
- en: Quantum-cheating in a coin toss? Introducing the Bell state
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛硬币的量子作弊？介绍贝尔态
- en: So, now you have the ability to toss one or more quantum coins and get a probabilistic
    outcome. That is all well and good, and we could picture ourselves doing some
    gambling with this new tool of ours, betting money against the outcome of a coin
    toss. But with a 50/50 outcome, the possibility of earning any real money is limited,
    unless, of course, we tweak the odds (that is, we cheat).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有了抛一个或多个量子硬币并获得概率结果的能力。这很好，我们可以想象自己使用这个新工具进行赌博，对抛硬币的结果下注。但是，由于结果是50/50，除非我们调整赔率（也就是说，我们作弊），否则赚钱的可能性有限。
- en: So how do you cheat in coin tossing? Well, knowing the outcome beforehand would
    be a clever way. And it turns out this is possible using a quantum phenomenon
    called **entanglement**.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在抛硬币时如何作弊呢？嗯，事先知道结果将是一个聪明的办法。结果证明，这可以通过一种称为**纠缠**的量子现象来实现。
- en: By entangling two qubits, we connect them in a way so that they can no longer
    be described separately. In the most basic sense, if you have two entangled qubits
    and measure one of them as ![](img/Formula_04_002.png), the result of measuring
    the other one will be ![](img/Formula_04_002.png) as.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过纠缠两个量子比特，我们将它们以某种方式连接起来，使得它们不能再单独描述。在最基本的意义上，如果你有两个纠缠的量子比特，并测量其中一个为 ![](img/Formula_04_002.png)，那么测量另一个的结果将是
    ![](img/Formula_04_002.png)。
- en: So, how do we use this to cheat in coin tossing? Well, we create two qubits,
    entangle them, and then we separate them (turns out this is the tricky part to
    do physically, but we will ignore that for now). You bring one qubit into the
    gambling den, and your friend keeps the other qubit outside the room.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何利用这个来在抛硬币时作弊呢？嗯，我们创建两个量子比特，将它们纠缠在一起，然后分开它们（实际上，这在物理上做起来很棘手，但我们现在将忽略这一点）。你将一个量子比特带入赌场，而你的朋友将另一个量子比特留在房间外。
- en: When it is time to do a coin toss, you run your quantum circuit, entangle the
    qubits, and then your friend measures the qubit that they keep outside the room.
    They then sneakily, through some means (such as Bluetooth earphones, semaphoring,
    or telepathy), tell you what their measurement was, ![](img/Formula_04_002.png)
    or ![](img/Formula_04_001.png). You will then instantly know what your qubit is,
    before you measure it, and can bet money on that outcome. After measuring, you
    will find that you were indeed right, and cash in your winnings.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当是时候抛硬币时，你运行你的量子电路，纠缠量子比特，然后你的朋友测量他们留在房间外的量子比特。然后他们通过某种方式（例如蓝牙耳机、信号或心灵感应）偷偷告诉你他们的测量结果，![](img/Formula_04_002.png)或![](img/Formula_04_001.png)。你将立即知道你的量子比特是什么，在你测量它之前，并可以据此下注。测量后，你会发现你确实猜对了，并可以领取你的奖金。
- en: So, how is this done quantum programmatically? We will introduce a new gate,
    **controlled-NOT** (**CX**).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何进行量子编程呢？我们将介绍一个新的门，**受控非门**（**CX**）。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r5_two_coin_toss_bell.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r5_two_coin_toss_bell.py).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该菜谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r5_two_coin_toss_bell.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r5_two_coin_toss_bell.py)。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Set up your code like the previous example, with 2 qubits and classical bits:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的示例设置你的代码，使用2个量子比特和经典比特：
- en: 'Import the classes and methods that we need:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的类和方法：
- en: '[PRE40]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Set up our quantum circuit with two qubits and two classical bits:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个量子比特和两个经典比特设置我们的量子电路：
- en: '[PRE41]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Add the Hadamard gate, a controlled NOT gate, and the measurement gates to the
    circuit.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将哈达玛门、受控非门和测量门添加到电路中。
- en: 'For each circuit manipulation we do, such as adding a gate, we need to indicate
    which qubit to perform the manipulation on. For example, to add a Hadamard gate
    on the first qubit, you would use the code `qc.h(0)`:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们进行的每个电路操作，例如添加一个门，我们需要指明要对哪个量子比特进行操作。例如，要在第一个量子比特上添加一个哈达玛门，你会使用代码 `qc.h(0)`：
- en: '[PRE42]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code gives the following output:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码给出了以下输出：
- en: '![Figure 4.16 – 2-qubit quantum circuit with a controlled-NOT gate to entangle
    the qubits](img/Figure_4.16_B14436.jpg)'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图4.16 – 带有受控非门以纠缠量子比特的2量子比特量子电路](img/Figure_4.16_B14436.jpg)'
- en: Figure 4.16 – 2-qubit quantum circuit with a controlled-NOT gate to entangle
    the qubits
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.16 – 带有受控非门以纠缠量子比特的2量子比特量子电路
- en: 'Set the backend to our local simulator:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后端设置为我们的本地模拟器：
- en: '[PRE43]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the job with one shot:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一次射击的作业：
- en: '[PRE44]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Visualize the results:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化结果：
- en: '[PRE45]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output for the histogram looks like this:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直方图输出的结果如下：
- en: '![Figure 4.17 – The result of a 2-qubit entangled coin toss](img/Figure_4.17_B14436.jpg)'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Figure 4.17 – The result of a 2-qubit entangled coin toss](img/Figure_4.17_B14436.jpg)'
- en: Figure 4.17 – The result of a 2-qubit entangled coin toss
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.17 – 2量子比特纠缠抛硬币的结果
- en: 'Run the circuit a couple of times and you will realize that the only result
    on this double quantum coin toss is ![](img/Formula_04_046.png) or ![](img/Formula_04_047.png).
    Now run the circuit again, but with 1,000 shots, and get the results:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行电路几次，你就会意识到在这个双量子抛硬币的结果上，唯一的结果是 ![img/Formula_04_046.png](img/Formula_04_046.png)
    或 ![img/Formula_04_047.png](img/Formula_04_047.png)。现在再次运行电路，但使用1,000次射击，得到以下结果：
- en: '[PRE46]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You will see the following histogram as a result of your code:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下直方图作为你代码的结果：
- en: '![Figure 4.18 – Result of 1,000 shots. Only  and  appear!'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.18 – Result of 1,000 shots. Only  and  appear!](img/Figure_4.18_B14436.jpg)'
- en: '](img/Figure_4.18_B14436.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.18_B14436.jpg](img/Figure_4.18_B14436.jpg)'
- en: Figure 4.18 – Result of 1,000 shots. Only ![](img/Formula_04_048.png) and ![](img/Formula_04_049.png)
    appear!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 – 1,000次射击的结果。只有 ![img/Formula_04_048.png](img/Formula_04_048.png) 和 ![img/Formula_04_049.png](img/Formula_04_049.png)
    出现！
- en: How it works...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start with the new gate, CX. This gate takes as input the quantum state
    of the first qubit (as indicated by the dot on the first qubit score) and then
    executes a NOT gate (x) on the second qubit if the quantum state is ![](img/Formula_04_007.png).
    If the quantum state is ![](img/Formula_04_002.png), it does nothing to the second
    qubit.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从新的门，CX门开始。这个门将第一个量子比特的量子状态（如第一个量子比特得分的点所示）作为输入，然后如果量子状态是 ![img/Formula_04_007.png](img/Formula_04_007.png)，则在第二个量子比特上执行一个NOT门（x）。如果量子状态是
    ![img/Formula_04_002.png](img/Formula_04_002.png)，则对第二个量子比特不做任何操作。
- en: So here's a really exciting part of this story. At a point where we expect the
    `cx` gate to act, we do not know the state of the first qubit yet. The Hadamard
    gate has put it in a nice superposition, hovering exactly between ![](img/Formula_04_002.png)
    and ![](img/Formula_04_001.png). Not until we measure the first qubit will we
    know what state the qubit is in. Not even nature will know the state because the
    qubit isn't in a specific state; it is in a superposition of two states.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个故事中真正令人兴奋的部分是，在我们预期`cx`门起作用的地方，我们还没有知道第一个量子比特的状态。Hadamard门已经将它置于一个很好的叠加态，精确地悬浮在
    ![img/Formula_04_002.png](img/Formula_04_002.png) 和 ![img/Formula_04_001.png](img/Formula_04_001.png)
    之间。直到我们测量第一个量子比特，我们才会知道量子比特处于什么状态。甚至自然也不知道状态，因为量子比特不在特定的状态中；它处于两个状态的叠加中。
- en: So how would the CX gate know that it needed to flip the second qubit from ![](img/Formula_04_002.png)
    to ![](img/Formula_04_001.png) when we run the program? Well, that is the fascinating
    part of quantum computing, *it* *didn't*. Only when we measure the first qubit
    will the gate execution take place, and the entangled the second qubit will have
    flipped, or not. Einstein called this very real example of quantum mechanics *Spooky
    action at a distance* and wanted nothing to do with it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，CX门是如何知道在运行程序时需要将第二个量子比特从 ![img/Formula_04_002.png](img/Formula_04_002.png)
    翻转到 ![img/Formula_04_001.png](img/Formula_04_001.png) 呢？嗯，这正是量子计算中令人着迷的部分，*它*
    *没有*。只有当我们测量第一个量子比特时，门执行才会发生，纠缠的第二个量子比特才会翻转，或者不会翻转。爱因斯坦将量子力学的这个非常真实的事例称为“遥远地点的幽灵行动”并希望与之无关。
- en: So, the end result when running our little recipe is to get one of the two possible
    outcomes for these two qubits, ![](img/Formula_04_054.png) or ![](img/Formula_04_055.png)
    with roughly equal probability. If the first qubit reads ![](img/Formula_04_002.png),
    then so will the second qubit, giving you the ![](img/Formula_04_057.png) result.
    The same is true for the opposite reading of ![](img/Formula_04_001.png); both
    qubits will read the same, giving us ![](img/Formula_04_059.png). Once you have
    read 1 qubit, you immediately know what the second will be. This is how cheating
    is done in quantum coin tossing!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行我们的小食谱的最终结果是我们得到这两个量子比特的两个可能结果之一，![img/Formula_04_054.png](img/Formula_04_054.png)
    或 ![img/Formula_04_055.png](img/Formula_04_055.png)，概率大致相等。如果第一个量子比特读取 ![img/Formula_04_002.png](img/Formula_04_002.png)，则第二个量子比特也将读取相同，给出
    ![img/Formula_04_057.png](img/Formula_04_057.png) 的结果。对于 ![img/Formula_04_001.png](img/Formula_04_001.png)
    的相反读取也是一样；两个量子比特都将读取相同，给我们 ![img/Formula_04_059.png](img/Formula_04_059.png) 的结果。一旦你读取了一个量子比特，你立即就知道第二个量子比特会是什么。这就是量子抛硬币作弊的方法！
- en: There's more...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'But the Bell state is not locked into just the two results ![](img/Formula_04_060.png)
    and ![](img/Formula_04_061.png). By using other gates, you can set this entanglement
    up to be ![](img/Formula_04_062.png) and ![](img/Formula_04_063.png) as well:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但贝尔态不仅仅锁定在两个结果 ![img/Formula_04_060.png](img/Formula_04_060.png) 和 ![img/Formula_04_061.png](img/Formula_04_061.png)
    上。通过使用其他门，你可以设置这种纠缠状态为 ![img/Formula_04_062.png](img/Formula_04_062.png) 和 ![img/Formula_04_063.png](img/Formula_04_063.png)：
- en: '[PRE47]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Which gate would you use, on which qubit would it act, and where in your circuit
    would you add it? In this case, you might want to start the qubits in different
    states to see what happens. Take a look at the *Implementing an upside-down coin
    toss* recipe for inspiration.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用哪个门，它在哪个量子比特上起作用，你会在电路的哪个位置添加它？在这种情况下，你可能想要以不同的状态开始量子比特，看看会发生什么。参考“实现倒立抛硬币”菜谱以获取灵感。
- en: See also
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The results we got when running this Bell-state circuit on `qasm_simulator`
    (which simulates a perfect universal fault-tolerant quantum computer) gave us
    clear-cut results where both qubits were the same when measured all the time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`qasm_simulator`（模拟一个完美的通用容错量子计算机）上运行这个贝尔态电路得到的结果非常明确，两个量子比特在每次测量时都是相同的。
- en: In the real world, where the existing physical quantum computers are still quite
    far from universal fault-tolerant quantum computers, the result will be somewhat
    different. For a quick look, see the *Tossing some real coins* recipe.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，现有的物理量子计算机还远未达到通用容错量子计算机的水平，结果将会有所不同。为了快速了解，请参阅“抛一些真实的硬币”菜谱。
- en: More ways to quantum-cheat – tweaking the odds
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多量子作弊的方法 – 调整概率
- en: In the previous recipe, we used a quantum phenomenon called entanglement to
    cheat with our coin tossing. Admittedly, this might be complicated to set up,
    and people do tend to get suspicious of coin tossers with an earpiece who are
    obviously listening for information before catching and revealing the coin (measuring
    the qubit).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们使用了一种名为纠缠的量子现象来通过抛硬币作弊。诚然，这可能会很复杂，人们确实倾向于怀疑那些戴着耳机、显然在接住并揭示硬币（测量量子比特）之前就监听信息的抛硬币者。
- en: But there are more ways to skin a cat. Remember our discussion of qubits and
    quantum gates. By manipulating the qubit using gates, we could adjust the state
    of the qubit before we measure it. The closer the vector is to either ![](img/Formula_04_002.png)
    or ![](img/Formula_04_001.png), the higher the probability of that specific outcome
    when you measure.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但剥猫的方法不止一种。记得我们关于量子比特和量子门的讨论。通过使用门来操作量子比特，我们可以在测量之前调整量子比特的状态。向量越接近 ![img/Formula_04_002.png](img/Formula_04_002.png)
    或 ![img/Formula_04_001.png](img/Formula_04_001.png)，当你测量时，该特定结果出现的概率就越高。
- en: In this recipe, we will use a rotation gate, the **Ry** gate, to increase the
    probability of getting a tails outcome when we toss our coin.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用旋转门，即**Ry**门，来增加抛硬币时得到反面结果的概率。
- en: Getting ready
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r6_coin_toss_rot.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r6_coin_toss_rot.py).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r6_coin_toss_rot.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r6_coin_toss_rot.py)。
- en: How to do it...
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Set up your code like the previous example and then add a **Ry** gate to rotate
    the qubit:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的例子设置你的代码，然后添加一个**Ry**门来旋转量子比特：
- en: 'Import the classes and methods that we need:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的类和方法：
- en: '[PRE48]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Set up our quantum circuit with one qubit and one classical bit and create
    the quantum circuit based on the registers:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个量子比特和一个经典比特设置我们的量子电路，并基于寄存器创建量子电路：
- en: '[PRE49]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the Hadamard gate, the Ry gate, and the measurement gates to the circuit:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Hadamard门、Ry门和测量门添加到电路中：
- en: '[PRE50]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The preceding code should result in the following output:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码应该产生以下输出：
- en: '![Figure 4.19 – Our cheating coin toss circuit with a Ry gate'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.19 – 带有Ry门的我们的作弊抛硬币电路'
- en: '](img/Figure_4.19_B14436.jpg)'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_4.19_B14436.jpg](img/Figure_4.19_B14436.jpg)'
- en: Figure 4.19 – Our cheating coin toss circuit with a Ry gate
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.19 – 带有Ry门的我们的作弊抛硬币电路
- en: 'Set the backend to our local simulator:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后端设置为我们的本地模拟器：
- en: '[PRE51]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the job with a thousand shots:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一千次射击运行作业：
- en: '[PRE52]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Visualize the results:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化结果：
- en: '[PRE53]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The histogram for the preceding code looks like the following:'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面代码的直方图看起来如下：
- en: '![Figure 4.20 – A slightly skewed outcome for our cheating coin toss circuit'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.20 – 我们作弊抛硬币电路的略微倾斜的结果'
- en: '](img/Figure_4.20_B14436.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.20_B14436.jpg](img/Figure_4.20_B14436.jpg)'
- en: Figure 4.20 – A slightly skewed outcome for our cheating coin toss circuit
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 – 我们作弊抛硬币电路的略微倾斜的结果
- en: Alright, so the odds now seem to be much in your favor for tossing a ![](img/Formula_04_001.png)
    – almost 2 to 1.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以现在似乎有更多的机会让你投掷一个 ![](img/Formula_04_001.png) – 几乎是 2 比 1。
- en: How it works...
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: So, what is going on here? By adding the Ry gate, we managed to tweak the odds
    mightily in our favor. Let's take a closer look at what that gate does.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？通过添加 Ry 门，我们极大地提高了我们获胜的机会。让我们更仔细地看看这个门的作用。
- en: 'Let''s take a look at the Bloch vectors for the three different states that
    we are discussing here. In the sample code, there is this suspicious function
    that we have not touched upon yet. We will see more of it in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*. By calling the `get_psi()` function
    and using the quantum circuit that you are building, you can see the behavior
    of the qubit at each stage of building the circuit. The function uses another
    simulator, `statevector_simulator`, that calculates the behavior of the qubit
    at a given location in your circuit, and then we use the `plot_bloch_multivector()`
    method to display it as a Bloch sphere:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们正在讨论的三个不同状态下的 Bloch 矢量。在示例代码中，有一个可疑的函数我们还没有涉及。我们将在 [*第 6 章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)，*理解
    Qiskit® 量子门库*中看到更多。通过调用 `get_psi()` 函数并使用你正在构建的量子电路，你可以看到量子比特在构建电路的每个阶段的动态。该函数使用另一个模拟器，`statevector_simulator`，它计算你在电路中给定位置的量子比特行为，然后我们使用
    `plot_bloch_multivector()` 方法将其显示为 Bloch 球：
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When we call this function with a quantum circuit as an input, it will return
    the qubit statevector (psi or ![](img/Formula_04_067.png) ) at the end of the
    circuit. If more than one qubit is included in the circuit, the function will
    include the complete statevector for all of them.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用量子电路作为输入调用此函数时，它将在电路结束时返回量子比特状态矢量（psi 或 ![](img/Formula_04_067.png)）。如果电路中包含多个量子比特，该函数将包括所有量子比特的完整状态矢量。
- en: 'To run the circuit with the `get_psi()` function enabled, change the `show_bloch`
    variable from `False` to `True`, and run your circuit again. The output should
    now look something like the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `get_psi()` 函数运行电路，将 `show_bloch` 变量从 `False` 更改为 `True`，然后再次运行你的电路。现在的输出应该看起来像以下这样：
- en: First, we show the qubit in the ground state:![Figure 4.21 – In the initial
    ground state, the quantum vector is pointing straight
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们展示了处于基态的量子比特：![图 4.21 – 在初始基态，量子矢量直接指向
- en: up to  as we expect
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所预期的那样，高达
- en: '](img/Figure_4.21_B14436.jpg)'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.21_B14436.jpg)'
- en: Figure 4.21 – In the initial ground state, the quantum vector is pointing straight
    up to ![](img/Formula_04_068.png) as we expect
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.21 – 在初始基态，量子矢量如我们所预期的那样直接指向 ![](img/Formula_04_068.png)
- en: Then, we show the qubit after the Hadamard gate, now in a superposition of ![](img/Formula_04_002.png)
    and ![](img/Formula_04_001.png):![Figure 4.22 – After applying the Hadamard gate,
    the vector is now pointing along the x axis to the Bloch sphere equator](img/Figure_4.22_B14436.jpg)
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们展示了经过 Hadamard 门后的量子比特，现在处于 ![](img/Formula_04_002.png) 和 ![](img/Formula_04_001.png)
    的叠加态：![图 4.22 – 应用 Hadamard 门后，矢量现在指向 Bloch 球的赤道](img/Figure_4.22_B14436.jpg)
- en: Figure 4.22 – After applying the Hadamard gate, the vector is now pointing along
    the x axis to the Bloch sphere equator
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.22 – 应用 Hadamard 门后，矢量现在指向 Bloch 球赤道
- en: We have seen this before. If we were to measure it now, we would get ![](img/Formula_04_002.png)
    and ![](img/Formula_04_001.png) with roughly 50% probability:![Figure 4.23 – Finally,
    after applying the Ry gate, the vector is now pointing below
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前见过这个。如果我们现在测量它，我们会有大约 50% 的概率得到 ![](img/Formula_04_002.png) 和 ![](img/Formula_04_001.png)：![图
    4.23 – 最后，应用 Ry 门后，矢量现在指向 Bloch 球赤道以下
- en: the Bloch sphere equator](img/Figure_4.23_B14436.jpg)
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: the Bloch sphere equator](img/Figure_4.23_B14436.jpg)
- en: Figure 4.23 – Finally, after applying the Ry gate, the vector is now pointing
    below the Bloch sphere equator
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 最后，应用 Ry 门后，矢量现在指向 Bloch 球赤道以下
- en: Now, we apply the Ry gate, rotating the vector ![](img/Formula_04_073.png) radians
    (0.3927 in our preceding circuit diagram) around the *y* axis toward ![](img/Formula_04_001.png).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应用 Ry 门，将矢量 ![](img/Formula_04_073.png) 弧度（在我们先前的电路图中为 0.3927）绕 *y* 轴旋转到
    ![](img/Formula_04_001.png)。
- en: So, what happens here is that we have modified the angle ![](img/Formula_04_075.png)
    by using the Ry gate.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里发生的情况是，我们通过使用 Ry 门修改了角度 ![](img/Formula_04_075.png)。
- en: Remember the formula from [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 记得[*第二章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)中的公式，*使用Python进行量子计算和量子比特*？
- en: '![](img/Formula_04_076.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_076.jpg)'
- en: After applying the Hadamard gate, the angles were ![](img/Formula_04_077.png)
    and ![](img/Formula_04_078.png) (we haven't rotated around the *y* axis yet).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用Hadamard门之后，角度为![](img/Formula_04_077.png)和![](img/Formula_04_078.png)（我们还没有围绕*y*轴旋转）。
- en: 'The probability of measuring ![](img/Formula_04_001.png) was then:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 测量![](img/Formula_04_001.png)的概率是：
- en: '![](img/Formula_04_080.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_080.jpg)'
- en: 'Now, if we change ![](img/Formula_04_081.png) to ![](img/Formula_04_082.png)
    by adding ![](img/Formula_04_073.png) , we get this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们通过添加![](img/Formula_04_073.png)将![](img/Formula_04_081.png)改为![](img/Formula_04_082.png)，我们得到这个：
- en: '![](img/Formula_04_084.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_04_084.jpg)'
- en: This corresponds very well with what we measured and shows us that we have indeed
    tweaked the probability of our quantum coin to land tails up.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们测量的结果非常吻合，表明我们确实调整了量子硬币落地为尾的概率。
- en: There's more...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are three basic rotational gates—Rx, Ry, and Rz—that you can use to easily
    point the vector at any point on the Bloch sphere. These are described in more
    detail in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding
    the Qiskit® Gate Library*.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个基本的旋转门——Rx、Ry和Rz，你可以使用它们轻松地将向量指向Bloch球上的任何一点。这些在[*第六章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)中描述得更详细，*理解Qiskit®门库*。
- en: Try your hand at these variations
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试这些变体
- en: 'Have a go at creating a couple of quantum circuits using these:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这些创建几个量子电路：
- en: Create a 1-qubit superposition without using the Hadamard gate.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不使用Hadamard门创建一个1比特叠加态。
- en: Measure the circuit to make sure that the result is the same as with a Hadamard
    gate.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量电路以确保结果与使用Hadamard门的结果相同。
- en: Create a 1-qubit superposition using the Hadamard gate, then use an R-gate to
    point the vector along the *y* axis.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hadamard门创建一个1比特叠加态，然后使用R门将向量指向*y*轴。
- en: Which gate would that be, and what is the input? Can you get the same result
    by skipping the Hadamard gate and using only an R gate? Which one? Now, measure
    and see if that makes any difference to the expected outcome for a circuit in
    superposition.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那会是哪个门，输入是什么？你能通过跳过Hadamard门而只使用R门得到相同的结果吗？哪一个？现在，测量一下，看看这会不会对叠加态电路的预期结果产生影响。
- en: 'Look at the formula for calculating the probability of measuring ![](img/Formula_04_001.png)
    and see if you can use the Ry gate to set up a circuit that gives ![](img/Formula_04_001.png)
    as an outcome:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看计算测量![](img/Formula_04_001.png)概率的公式，看看你是否可以使用Ry门设置一个电路，使其结果为![](img/Formula_04_001.png)：
- en: 99% of the time
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 99%的时间
- en: 66% of the time
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 66%的时间
- en: 33% of the time
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 33%的时间
- en: Congratulations! Not only can you now cheat in quantum coin tossing, but you
    can also calculate your odds.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在不仅可以在量子硬币投掷中作弊，还可以计算你的概率。
- en: More on the get_psi() function
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于`get_psi()`函数的更多内容
- en: We started out with this very small, 1-qubit quantum circuit as an example of
    how to use our home-made `get_psi()` function to step your way through your circuit
    to understand how your qubits behave at each stage. Remember that even though
    people sometimes talk about qubits being 0 and 1 at the same time, what they really
    are referring to is the superposition math we have looked at. The important thing
    is that during our calculations, we place our qubits in very well-known states
    by manipulating their statevectors.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这个非常小的，1比特量子电路为例，展示了如何使用我们自制的`get_psi()`函数逐步遍历你的电路，以了解你的量子比特在每个阶段的运行情况。记住，尽管人们有时会谈论量子比特同时为0和1，但他们真正指的是我们之前看过的叠加数学。重要的是，在我们的计算中，通过操纵它们的态矢量，我们将量子比特置于非常知名的状态。
- en: For small circuits, it is fairly easy to envision what is going on at each step,
    but for larger circuits, you quickly run out of brainpower to mentally visualize
    how the little qubits behave.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小电路，想象每个步骤发生的事情相对容易，但对于大电路，你很快就会用尽脑力来心理上可视化小量子比特的行为。
- en: You can use the `get_psi()` function and the statevector simulator for just
    this. Call it from any point in your circuit design to see what your qubits are
    up to. If your quantum programs do not behave the way you expect, use the statevector
    simulator and Bloch sphere visualization to troubleshoot.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `get_psi()` 函数和状态向量模拟器来完成这个任务。您可以从电路设计的任何位置调用它，以查看您的量子比特正在做什么。如果您的量子程序没有按照您预期的行为运行，请使用状态向量模拟器和布洛赫球可视化来调试。
- en: As we move along through the book, we will tweak and modify the `get_psi()`
    function to suit our needs, and use it to display additional details about our
    circuits.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续阅读本书，我们将调整和修改 `get_psi()` 函数以满足我们的需求，并使用它来显示有关我们电路的更多详细信息。
- en: Adding more coins – straight and cheating
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多硬币 – 正直和作弊
- en: Up until now, our recipes have been mainly of the 1- or 2-qubit sort. With our
    simulator, there is nothing stopping us from adding more qubits to our circuits
    at will, with the caveat that each additional qubit will require more and more
    processing power from the system on which your simulator runs. For example, the
    IBM Quantum Experience® `qasm_simulator` runs on an IBM POWER9™ server and maxes
    out at around 32 qubits.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的菜谱主要是 1-或 2-量子比特的。有了我们的模拟器，我们可以在电路中随意添加更多量子比特，前提是每个额外的量子比特将需要更多和更多的处理能力，这是您的模拟器运行的系统所必需的。例如，IBM
    Quantum Experience® `qasm_simulator` 在 IBM POWER9™ 服务器上运行，最大可达到约 32 个量子比特。
- en: In this recipe, we will create two 3-qubit quantum programs, one multi-coin
    toss, and one new entangled state called **GHZ** (for **Greenberger–Horne–Zeilinger**
    state).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建两个 3-量子比特量子程序，一个是多硬币投掷，另一个是新纠缠态，称为 **GHZ**（代表 **Greenberger–Horne–Zeilinger**
    态）。
- en: Instead of doing this by creating two separate files, we will take a look at
    a new command, `reset()`. As the name implies, using the `reset()` command with
    a qubit sets it back to its original state of ![](img/Formula_04_002.png), ready
    to start a new quantum computing round. In this example, we use `reset()` to run
    two quantum programs in a row, writing to two sets of three classical registers,
    measuring twice per run.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是通过创建两个单独的文件来做这件事，我们将查看一个新的命令，`reset()`。正如其名所示，使用 `reset()` 命令与量子比特一起将其设置回其原始状态！[](img/Formula_04_002.png)，准备开始新一轮的量子计算。在这个例子中，我们使用
    `reset()` 来连续运行两个量子程序，写入两组三个经典寄存器，每次运行测量两次。
- en: Getting ready
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r7_three_coin_toss_ghz.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r7_three_coin_toss_ghz.py).'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r7_three_coin_toss_ghz.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r7_three_coin_toss_ghz.py).
- en: How to do it...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Set up your code like the previous examples, but with three qubits and classical
    bits:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的示例设置您的代码，但使用三个量子比特和经典比特：
- en: 'Import the classes and methods that we need:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的类和方法：
- en: '[PRE55]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Set up our quantum circuit with three qubits and six classical bits:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三个量子比特和六个经典比特设置我们的量子电路：
- en: '[PRE56]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the Hadamard gates and the measurement gates to the circuit:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将哈达玛门和测量门添加到电路中：
- en: '[PRE57]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output for the preceding code looks like this:'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面代码的输出如下所示：
- en: '![Figure 4.24 – A 3-qubit in superposition circuit, measuring to classical
    bits 0, 1, and 2'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.24 – 一个 3-量子比特叠加电路，测量到经典比特 0、1 和 2'
- en: '](img/Figure_4.24_B14436.jpg)'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.24_B14436.jpg)'
- en: Figure 4.24 – A 3-qubit in superposition circuit, measuring to classical bits
    0, 1, and 2
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.24 – 一个 3-量子比特叠加电路，测量到经典比特 0、1 和 2
- en: 'Set the backend to our local simulator:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后端设置为我们的本地模拟器：
- en: '[PRE58]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the job with a thousand shots:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一千次射击运行作业：
- en: '[PRE59]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Visualize the results:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化结果：
- en: '[PRE60]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The histogram for the preceding code looks like the following:'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面代码的直方图如下所示：
- en: '![Figure 4.25 – Three qubits in superposition give random results'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.25 – 三个叠加态的量子比特给出随机结果'
- en: '](img/Figure_4.25_B14436.jpg)'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.25_B14436.jpg)'
- en: Figure 4.25 – Three qubits in superposition give random results
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.25 – 三个叠加态的量子比特给出随机结果
- en: Notice here that we only see measurement results for the three first classical
    bits (0, 1, and 2). The three last classical bits are all 0\.
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到这里我们只看到了前三个经典比特（0、1 和 2）的测量结果。最后三个经典比特都是 0。
- en: Now modify the circuit by resetting the qubits, adding a Hadamard gate to qubit
    0, then adding two CX (Controlled NOT) gates, one from qubit 0 to qubit 1, and
    one from qubit 0 to qubit 2.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过重置量子比特，向量子比特0添加一个Hadamard门，然后添加两个CX（受控非）门，一个从量子比特0到量子比特1，另一个从量子比特0到量子比特2来修改电路。
- en: 'We will use a new circuit command to reset the qubits of our circuit back to
    ![](img/Formula_04_002.png) and start over using `reset()`:'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用一个新的电路命令来重置电路的量子比特回到初始状态，并使用`reset()`重新开始：
- en: '[PRE61]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Remember that when you modify just one qubit, you must specify which qubit
    to modify, like this `qc.h`(`0`), to add a Hadamard gate to the first qubit:'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，当你只修改一个量子比特时，你必须指定要修改的量子比特，就像这样`qc.h`(`0`)，向第一个量子比特添加Hadamard门：
- en: '![Figure 4.26 – Resetting the qubits of a quantum circuit back to   and starting
    over, writing to classical bits 3, 4, and 5 for the final measurement'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.26 – 将量子电路的量子比特重置为初始状态并重新开始，将最终测量写入经典比特3、4和5'
- en: '](img/Figure_4.26_B14436.jpg)'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.26_B14436.jpg)'
- en: Figure 4.26 – Resetting the qubits of a quantum circuit back to ![](img/Formula_04_002.png)
    and starting over, writing to classical bits 3, 4, and 5 for the final measurement
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.26 – 将量子电路的量子比特重置为初始状态并重新开始，将最终测量写入经典比特3、4和5
- en: 'Run the job with 1,000 shots:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用1,000次射击运行作业：
- en: '[PRE62]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Display the results:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示结果：
- en: '[PRE63]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The histogram presentation for the previous code looks like the following:'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前代码的直方图展示如下：
- en: '![Figure 4.27 – The combined results of three coin toss qubits and of three
    entangled qubits, the GHZ state, in the first three and second three classical
    bits, respectively'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27 – 三个抛掷硬币量子比特和三个纠缠量子比特（GHZ态）在第一三个和第二三个经典比特中的组合结果'
- en: '](img/Figure_4.27_B14436.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.27_B14436.jpg)'
- en: Figure 4.27 – The combined results of three coin toss qubits and of three entangled
    qubits, the GHZ state, in the first three and second three classical bits, respectively
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 – 三个抛掷硬币量子比特和三个纠缠量子比特（GHZ态）在第一三个和第二三个经典比特中的组合结果
- en: How it works...
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There is nothing inherently new to the two circuits that we created, just more
    qubits, and two rounds of measurements. In the first one, we added all gates in
    parallel, and in the second one, we diligently specified which ones to add where.
    The end result was two 3-qubit circuits, one that represented even more coins
    tossed, and one that expanded on the Bell state we explored earlier.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的两个电路并没有什么本质上的新东西，只是增加了更多的量子比特，以及两轮测量。在第一个中，我们并行添加了所有门，而在第二个中，我们仔细指定了添加门的位置。最终结果是两个3量子比特电路，一个代表了更多抛掷的硬币，另一个扩展了我们之前探索的贝尔态。
- en: That last one is interesting as it shows entanglement between several qubits;
    none of the qubits can now be treated separately. And this type of entanglement
    is key to more advanced quantum algorithms where a large number of qubits are
    set up, which are put in superposition and then entangled. They are finally acted
    on by other gates to produce specific outcomes.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个很有趣，因为它显示了几个量子比特之间的纠缠；现在没有一个量子比特可以单独处理。这种纠缠是更高级量子算法的关键，在这些算法中，大量量子比特被设置，处于叠加态，然后被纠缠。它们最终被其他门作用，以产生特定的结果。
- en: Finally, we tested a new way of writing the outcomes to classical bits. We wrote
    the coin toss results to the first three classical bits and the GHZ state results
    to the three last ones.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试了一种新的将结果写入经典比特的方法。我们将抛掷硬币的结果写入前三个经典比特，将GHZ状态的结果写入最后三个。
- en: There's more...
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Do a little experimentation to see how you can build larger circuits with more
    qubits, and how to add gates:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 进行一些实验，看看你如何构建具有更多量子比特的更大电路，以及如何添加门：
- en: Create a 5-qubit circuit, with Hadamard gates on all, but measurement gates
    on the first, third, and fifth qubits only. How many classical registers do you
    really need?
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个5量子比特电路，所有量子比特上都有Hadamard门，但只有第一个、第三个和第五个量子比特上有测量门。你实际上需要多少个经典寄存器？
- en: Create a 5-qubit circuit where you entangle the first, second, fourth, and fifth
    qubits with the third qubit. On which qubit do you need to add the Hadamard gate?
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个5量子比特电路，将第一个、第二个、第四个和第五个量子比特与第三个量子比特纠缠。你需要在哪个量子比特上添加Hadamard门？
- en: The GHZ circuit we built as a part of this recipe gives the entangled results
    ![](img/Formula_04_089.png)and ![](img/Formula_04_090.png) only. Build a circuit
    that gives you the result ![](img/Formula_04_091.png) or ![](img/Formula_04_092.png)
    instead. What gate other than H and CX do you use, and where do you put it, or
    them?
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在本菜谱中构建的GHZ电路只能给出纠缠结果![img/Formula_04_089.png]和![img/Formula_04_090.png]。构建一个给出结果![img/Formula_04_091.png]或![img/Formula_04_092.png]的电路。除了H和CX门之外，你使用什么门，以及你将它们放在哪里，或者它们在哪里？
- en: Tip
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: It might be easier to understand the workings of these circuits if you use one
    set of measurement commands only, and don't use the `reset()` command.
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你只使用一组测量命令，而不使用`reset()`命令，可能更容易理解这些电路的工作原理。
- en: Tossing some real coins
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投掷一些真实的硬币
- en: So, what do you say? Are you done simulating quantum coin tosses now, and want
    to do the real thing, running your Qiskit® quantum program on an actual IBM quantum
    computer? Let's finally get some use out of that IBM Quantum Experience® API key
    that you created.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你的想法是什么？你现在是否完成了量子硬币投掷的模拟，并想要进行真正的操作，即在真实的IBM量子计算机上运行你的Qiskit®量子程序？让我们最终利用你创建的IBM
    Quantum Experience® API密钥。
- en: In this recipe, you will run the cheating coin toss or Bell state on an actual
    IBM Quantum® machine by using Qiskit®. We know what the expected result is on
    a perfectly simulated quantum computer and will now take a look at what the results
    of a real so-called NISQ machine look like.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，你将通过使用Qiskit®在真实的IBM Quantum®机器上运行作弊硬币投掷或贝尔态。我们知道在完美模拟的量子计算机上预期的结果是什么，现在我们将看看所谓的NISQ机器的实际结果是什么样的。
- en: Finally, we will be getting some use out of that API key, introducing the IBMQ
    components, how to find the backends, how to select the best backend, and how
    to run the circuit against that backend.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将利用这个API密钥，介绍IBMQ组件，如何找到后端，如何选择最佳后端，以及如何在该后端运行电路。
- en: Getting ready
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r8_coin_toss_IBMQ.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r8_coin_toss_IBMQ.py).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r8_coin_toss_IBMQ.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r8_coin_toss_IBMQ.py).
- en: To be able to run your quantum program on real IBM hardware, you need to use
    the API key that you are assigned with in your IBM Quantum Experience® account.
    If you are running Qiskit® from the IBM Quantum Experience® notebook environment,
    then your API key is already available to you and no further action is needed.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要能在真实的IBM硬件上运行你的量子程序，你需要使用你在IBM Quantum Experience®账户中分配的API密钥。如果你在IBM Quantum
    Experience®笔记本环境中运行Qiskit®，那么你的API密钥已经可用，无需进一步操作。
- en: If, however, you are running Qiskit® on your own local machine, you must store
    the API key locally. You might have already carried out these required steps as
    part of the *Installing your API key and accessing your provider* recipe in [*Chapter
    1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021), *Preparing Your Environment*.
    If not, go ahead and complete the task now. We'll wait for you here.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的本地机器上运行Qiskit®，你必须将API密钥本地存储。你可能已经作为[*第1章*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021)中“安装你的API密钥和访问你的提供商”菜谱的一部分完成了这些必要的步骤，*准备你的环境*。如果没有，现在就完成这个任务。我们在这里等你。
- en: How to do it
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Set up your code as in the previous examples, with two qubits and classical
    bits:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的示例设置你的代码，使用两个量子比特和经典比特：
- en: 'Import the classes and methods that we need:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的类和方法：
- en: '[PRE64]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Retrieve the stored API key:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取存储的API密钥：
- en: '[PRE65]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Set up our quantum circuit with two qubits and two classical bits:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个量子比特和两个经典比特设置我们的量子电路：
- en: '[PRE66]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add the Hadamard gate and the CX gate to prepare for a Bell state:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Hadamard门和CX门以准备贝尔态：
- en: '[PRE67]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding code shows the following circuit:'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码显示了以下电路：
- en: '![Figure 4.28 – 2-qubit Bell-state circuit'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.28 – 2量子比特贝尔态电路'
- en: '](img/Figure_4.28_B14436.jpg)'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_4.28_B14436.jpg]'
- en: Figure 4.28 – 2-qubit Bell-state circuit
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.28 – 2量子比特贝尔态电路
- en: 'Set the backend to the least busy IBM Quantum® machine available:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将后端设置为最不繁忙的IBM Quantum®机器：
- en: '[PRE68]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We will revisit this way of picking an IBM Quantum® computer backend to run
    your circuit on in the *Finding the least busy backend* recipe of [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum Hardware® with Qiskit® Tools*. For now, just use the
    code as is.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在[*第五章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)的“寻找最不繁忙的后端”食谱中重新审视这种选择IBM
    Quantum®计算机后端来运行你的电路的方法，即*使用Qiskit®工具游览IBM Quantum Hardware®*。现在，只需按原样使用代码即可。
- en: 'Run the job with 1,000 shots. Wait for the job to complete:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用1,000次射击运行作业。等待作业完成：
- en: '[PRE69]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Get the results:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取结果：
- en: '[PRE70]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The histogram presentation for the preceding code looks like the following:'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码的直方图表示如下：
- en: '![Figure 4.29 – The result of running the Bell-state circuit on an actual IBM
    Quantum® backend'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.29 – 在实际的IBM Quantum®后端上运行贝尔态电路的结果'
- en: '](img/Figure_4.29_B14436.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.29_B14436.jpg](img/Figure_4.29_B14436.jpg)'
- en: Figure 4.29 – The result of running the Bell-state circuit on an actual IBM
    Quantum® backend
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.29 – 在实际的IBM Quantum®后端上运行贝尔态电路的结果
- en: Hold your horses! We were expecting results for only ![](img/Formula_04_093.png)
    and for ![](img/Formula_04_094.png) ... What is going on here?
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等一下！我们只期待得到![img/Formula_04_093.png](img/Formula_04_093.png)和![img/Formula_04_094.png](img/Formula_04_094.png)的结果……这里发生了什么？
- en: How it works...
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Wow, look at those noisy qubits!
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，看看那些有噪声的量子位！
- en: What you are seeing in the noisy results of your program is just that – noise.
    Even though the IBM Quantum® computers are running at temperatures colder than
    outer space (15 millikelvin), they still suffer from random noise both when executing
    gates on the qubits and when measuring them.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你在程序的有噪声结果中看到的就是噪声本身。尽管IBM Quantum®计算机在低于外太空温度（15毫开尔文）下运行，但它们在执行量子位上的门操作和测量时仍然会遭受随机噪声。
- en: The local `qasm_simulator` that we have run our quantum programs on up until
    this point behaves like a perfect **universal quantum computer**. The real hardware,
    on the other hand, is what is called a **Noisy Intermediate-Scale Quantum (NISQ)**
    computer, which behaves less than perfectly.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直运行量子程序的本地`qasm_simulator`表现得像一个完美的**通用量子计算机**。另一方面，真正的硬件被称为**有噪声的中规模量子（NISQ）计算机**，其表现并不完美。
- en: We will explore the existing IBM Quantum® backends in more detail in [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit® Tools*.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第五章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)的*使用Qiskit®工具游览IBM
    Quantum®硬件*中更详细地探讨现有的IBM Quantum®后端。
- en: There's more...
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When running your job on an actual IBM Quantum® machine, things will generally
    differ from the controlled experience you had with your local simulator.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在实际的IBM Quantum®机器上运行你的作业时，通常会有所不同，与你在本地模拟器上所经历的受控体验。
- en: Get in line
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排队
- en: 'As soon as you start running one or two quantum programs on the IBM Quantum®
    machines, you will most likely realize that you are not the only one. As it happens,
    there are a limited number of quantum computers available to the general public
    to use for free. As of this writing, a steadily growing number of physical backends
    and one simulator can be used. Use the `provider.backends()` command to list the
    ones that are currently available:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始在IBM Quantum®机器上运行一个或两个量子程序，你很可能会意识到你不是唯一一个。实际上，可供公众免费使用的量子计算机数量有限。截至本文撰写时，有稳定增长数量的物理后端和一个模拟器可以使用。使用`provider.backends()`命令列出目前可用的后端：
- en: '[PRE71]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The preceding code might give a result similar to the following:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可能得到以下类似的结果：
- en: '[PRE72]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Remember that you are in a timeshare here, with everyone else simultaneously
    running on the same machine as you. In the next chapter, we will take a closer
    look at these machines and explore how to figure out which one is best to use
    at any given moment.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你在这里是共享时间，与其他所有人同时使用与你相同的机器。在下一章中，我们将更仔细地查看这些机器，并探讨如何确定在任何给定时刻使用哪个机器最好。
- en: Hardware details in the results
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结果中的硬件细节
- en: 'After your job is complete and you have looked at the results, you can take
    a quick peek at the complete returned results as well by using the `job.result()`
    command. It will look something like this:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 作业完成后，你已经查看过结果后，可以通过使用`job.result()`命令快速查看完整的返回结果。它看起来可能像这样：
- en: '[PRE73]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this result set, you can see information about the quantum computer backend
    that was used, the results of the run, as well as the status and date and time
    for the run.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结果集中，你可以看到有关所使用的量子计算机后端的信息，运行的结果，以及运行的状态和日期和时间。
- en: What if the wait turns out to be long?
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果等待时间过长怎么办？
- en: Sometimes there is just a really long queue ahead of you, and you have to wait
    your turn. In a sense, the IBM Quantum® machines work as a time-share setup from
    the early days of computing; only one program can run at the same time.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你前面可能有一个非常长的队列，你必须等待你的轮次。从某种意义上说，IBM Quantum®机器就像计算机早期的时间共享设置一样工作；同一时间只能运行一个程序。
- en: But no need to despair. Your job has been submitted, and you can take a step
    back and let the machines do their work, picking up the thread when it suits you.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 但无需绝望。你的作业已经提交，你可以退后一步，让机器做它们的工作，在你方便的时候继续。
- en: This works the same as in the IBM Quantum Experience® Circuit Composer. Once
    submitted, your job will wait its turn, and then show up on the results page when
    returned. To do the same with your local Qiskit®, you first need your job ID.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这与IBM Quantum Experience®电路作曲家的工作方式相同。一旦提交，你的作业将等待它的轮次，然后在返回时显示在结果页面上。要在你的本地Qiskit®中做同样的事情，你首先需要你的作业ID。
- en: You can use the job ID to get your most recent job, or even retrieve earlier
    jobs that you have executed. The job ID is unique for each executed job.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用作业ID来获取你的最新作业，甚至检索你之前执行过的作业。每个执行过的作业都有一个唯一的作业ID。
- en: 'Use the `job.job_id()` command to get the job ID:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`job.job_id()`命令来获取作业ID：
- en: '[PRE74]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now that you have a job ID, you can get back the `job` object by using the
    `retrieve_job()` command:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了作业ID，你可以通过使用`retrieve_job()`命令来获取`job`对象：
- en: '[PRE75]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And now you can get the job results just like you are used to, from the `job`
    object, for example:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以像平时一样从`job`对象中获取作业结果，例如：
- en: '[PRE76]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding code might give the following output:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可能会产生以下输出：
- en: '[PRE77]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can also use the job ID to find the status of your job, and to see where
    in the queue it currently is:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用作业ID来查找作业的状态，并查看它在队列中的当前位置：
- en: '[PRE78]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here''s an example:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE79]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: There are more features built in with the jobs that you can pull back from IBM
    Quantum Experience®. For a closer look at the backends and what you can learn
    about them, continue with [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit® Tools*.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Quantum Experience®中内置了更多与作业相关的功能，你可以从中获取。要更详细地了解后端以及你可以了解的内容，请继续阅读[*第五章*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128)，*使用Qiskit®工具游览IBM
    Quantum®硬件*。
