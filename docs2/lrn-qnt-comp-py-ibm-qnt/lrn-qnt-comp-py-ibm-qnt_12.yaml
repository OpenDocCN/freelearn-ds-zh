- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Applying Quantum Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用量子算法
- en: In the last chapter, we considered the fundamentals that highlight the difference
    between classical and quantum systems, particularly the use of superposition and
    entanglement. In this chapter, we will focus on algorithms that have the potential
    to solve more applicable problems, such as periodicity and searching. These algorithms
    differ from the earlier algorithms as they are used in various domains and are
    included in many modern quantum algorithms. A few examples of these quantum algorithms
    are the **quantum amplitude estimation**, **variational quantum eigensolvers**,
    and **quantum support vector machine** algorithms. Having a good understanding
    of these algorithms will help you when learning about or creating your own algorithms
    as the techniques used can be applied in many industries. In this chapter, we
    will cover some of the fundamental principles and techniques that these more modern,
    and complex, algorithms leverage, to help you better understand them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们考虑了强调经典和量子系统之间差异的基本原理，特别是叠加和纠缠的使用。在本章中，我们将关注那些有可能解决更实用问题的算法，例如周期性和搜索。这些算法与早期算法的不同之处在于它们被用于各种领域，并包含在许多现代量子算法中。这些量子算法的几个例子包括**量子振幅估计**、**变分量子本征值求解器**和**量子支持向量机**算法。对这些算法有良好的理解将有助于您在学习或创建自己的算法时，因为所使用的技术可以应用于许多行业。在本章中，我们将介绍这些更现代、更复杂的算法所依赖的一些基本原理和技术，以帮助您更好地理解它们。
- en: '**Periodic algorithms** can be used to solve factorization or phase estimation
    problems. **Search algorithms** can also provide some speedup over classical algorithms
    in how they leverage amplitude amplification to find a specified entry.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**周期算法**可以用来解决因式分解或相位估计问题。**搜索算法**也可以通过利用振幅放大来找到指定条目，从而在速度上比经典算法有所提升。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding periodic quantum algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解周期量子算法
- en: Understanding the Quantum Fourier Transform algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解量子傅里叶变换算法
- en: Understanding Grover’s search algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Grover搜索算法
- en: After completing this chapter, you will be able to grasp the concepts of these
    algorithms and leverage the algorithms already provided in **Qiskit**, so you
    can use them without having to *reinvent the wheel*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够掌握这些算法的概念，并利用**Qiskit**中已提供的算法，这样您就可以使用它们而无需重新发明轮子。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you are familiar with some of the basic quantum algorithm
    components, such as superposition, oracles, phase kickback, and programming with
    Qiskit. You are also expected to understand basic linear algebra, such as multiplying
    matrices, the complex conjugation of a matrix, and inner products. Some advanced
    mathematics, such as an understanding of the **Fourier transform**, is also assumed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经熟悉一些基本的量子算法组件，例如叠加、预言机、相位回冲以及使用Qiskit进行编程。您还应该理解基本的线性代数，例如矩阵乘法、矩阵的复共轭和内积。还假设您了解一些高级数学，例如**傅里叶变换**。
- en: 'Here is the source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所使用的源代码如下：[https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition)。
- en: Understanding periodic quantum algorithms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解周期量子算法
- en: In *Chapter 11*, *Understanding Quantum Algorithms*, we covered algorithms that
    use phase kickback to solve various problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章“理解量子算法”中，我们介绍了使用相位回冲来解决各种问题的算法。
- en: In this section, we will start by understanding periodic quantum algorithms.
    Periodic functions are those where values are repeated over time. Your watch,
    for example, is periodic in that each minute has 60 seconds, each hour has 60
    minutes, and each day has 24 hours.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先理解周期量子算法。周期函数是指随时间重复其值的函数。例如，您的手表就是周期性的，因为每一分钟有60秒，每一小时有60分钟，每一天有24小时。
- en: If you have your watch set up with the hours from 1 to 12, then your watch has
    2 periods per day, in that your watch will cycle through the numbers 1 to 12 twice
    in one day. Of course, this is separate from the AM and PM indicators, whether
    it is before or after midday. Periodic functions occur all around us in many ways,
    so understanding how to relate them to a quantum circuit is key to understanding
    many of the quantum algorithms, including one of the most famous, **Grover’s algorithm**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将你的手表设置为从1到12小时，那么你的手表每天有2个周期，因为你的手表将在一天内两次循环通过数字1到12。当然，这独立于AM和PM指示器，无论是上午还是下午。周期函数以许多方式出现在我们周围，因此理解如何将它们与量子电路联系起来是理解许多量子算法的关键，包括最著名的**Grover算法**之一。
- en: But for now, we will begin by extending our understanding of periodic functions,
    particularly how we can understand and implement the **Quantum Fourier Transform**
    (**QFT**) algorithm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们将从扩展我们对周期函数的理解开始，特别是我们如何理解和实现**量子傅里叶变换**（**QFT**）算法。
- en: Learning about the QFT algorithm
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习QFT算法
- en: QFT is related to **Discrete Fourier Transform** (**DFT**) in that it too can
    transform from one domain to another.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: QFT与**离散傅里叶变换**（**DFT**）相关，因为它也能从一个域转换到另一个域。
- en: '**DFT** converts a finite sequence of samples into a complex-valued function
    of frequency that is used to analyze many applications, such as image processing
    and signal processing, and can also be used to help solve partial differential
    equations.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**DFT**将有限序列的样本转换成频率的复值函数，用于分析许多应用，如图像处理和信号处理，还可以用来帮助解决偏微分方程。'
- en: 'DFT is used to transfer signals from the time domain to the frequency domain,
    or in a more generalized description, mapping one domain, *x*, to another domain,
    ![](img/B18420_12_001.png), with the following formula:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: DFT用于将信号从时域转换到频域，或者用更广义的描述来说，将一个域*x*映射到另一个域，![](img/B18420_12_001.png)，以下公式：
- en: '![](img/B18420_12_002.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_12_002.png)'
- en: Similarly, we can define a quantum transformation as a transformation from one
    basis to another. For example, all the computations we have done in this book
    so far have been measured according to the *Z* basis. This means our basis states
    have been set on the *Z*-axis of the qubit with the states ![](img/B18420_05_004.png)
    and ![](img/B18420_05_005.png), referring to the positive and negative ends of
    the *Z*-axis on the Bloch sphere, respectively.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以定义量子变换为从一个基到另一个基的变换。例如，到目前为止，我们在这本书中所做的所有计算都是根据*Z*基进行的。这意味着我们的基态已经被设置在量子比特的*Z*-轴上，状态![](img/B18420_05_004.png)和![](img/B18420_05_005.png)分别对应于Bloch球上*Z*-轴的正负两端。
- en: There are, of course, other basis states that we can transition to if needed.
    One example is the *X*-axis of the qubit, where the basis states there are ![](img/B18420_04_008.png)
    and ![](img/B18420_04_012.png), which refer to the positive and negative ends
    of the *X*-axis on the Bloch sphere, respectively. QFT would transform between
    these two basis states. The QFT is used by many quantum algorithms, including
    Shor’s, as it has been shown to have improvements over the classical implementation
    of a discrete Fourier transform.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果需要，我们还可以转换到其他基态。一个例子是量子比特的*X*-轴，那里的基态是![](img/B18420_04_008.png)和![](img/B18420_04_012.png)，分别对应于Bloch球上*X*-轴的正负两端。QFT会在这两个基态之间转换。QFT被许多量子算法使用，包括Shor算法，因为它已被证明在经典离散傅里叶变换的实现上有所改进。
- en: In this section, we will work through a simple example of a QFT algorithm to
    extend our understanding of it when we see it used in many other quantum algorithms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个简单的QFT算法示例来加深我们对它的理解，当我们看到它在许多其他量子算法中使用时。
- en: We’ll begin by applying QFT to a simple three-qubit quantum state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将QFT应用于一个简单的三量子比特量子态。
- en: Understanding the QFT algorithm
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解QFT算法
- en: Before getting into the details, let’s first get an understanding of what each
    axis represents. As you recall from the Bloch sphere, one of the visual representations
    of a qubit, it is made up of three axes, *X*, *Y*, and *Z*. Rotations around the
    *X* and *Y* axes are what we use to adjust the amplitude of the qubit, that is,
    down along the longitude of the Bloch sphere (the North Pole to the South Pole).
    Rotation around the *Z*-axis is what we use to adjust the phase of the qubit,
    that is, around the latitude of the Bloch sphere.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们首先了解每个轴代表什么。如您从玻色球体回忆的那样，它是量子比特的一种视觉表示，由三个轴组成，即 *X*、*Y* 和 *Z* 轴。绕
    *X* 和 *Y* 轴的旋转是我们用来调整量子比特振幅的方法，即沿着玻色球体的经度（北极到南极）。绕 *Z*-轴的旋转是我们用来调整量子比特相位的，即沿着玻色球体的纬度。
- en: Each axis is a basis state, named by the axis, i.e. *X*-basis, *Y*-basis, and
    *Z*-basis. In quantum, the *Z*-axis is generally referred to as the computational
    basis and either the *X-* and *Y*-axis can be the Fourier basis. In this example,
    we will set the *X*-basis as the Fourier basis. The QFT transform is generally
    a transformation from one basis to another, in this case, from the computational
    (*Z*) basis to the Fourier (*X*) basis.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个轴都是一个基态，由轴命名，即 *X*-基态、*Y*-基态和 *Z*-基态。在量子计算中，*Z*-轴通常被称为计算基，而 *X* 和 *Y*-轴可以是傅里叶基。在这个例子中，我们将
    *X*-基设为傅里叶基。QFT 变换通常是从一个基到另一个基的变换，在这种情况下，是从计算基（*Z*）到傅里叶基（*X*）。
- en: 'To transform our quantum function from one basis state to another, we need
    to apply QFT, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的量子函数从一个基态转换到另一个基态，我们需要应用 QFT，如下所示：
- en: '![](img/B18420_12_007.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_12_007.png)'
- en: 'In the preceding equation, *Z – basis* refers to the basis states on the *Z*-axis,
    ![](img/B18420_05_004.png) and ![](img/B18420_05_005.png), and *X – basis* refers
    to the basis states (often referred to as the phase states because rotation around
    them refers to rotations around the *Z*-axis) on the *X*-axis, ![](img/B18420_09_050.png)
    and ![](img/B18420_09_052.png). The Qiskit documentation ([https://docs.quantum.ibm.com/](https://docs.quantum.ibm.com/))
    refers to the Fourier basis with a tilde (*~*), where *QFT* is the QFT Transform
    applied to the state ![](img/B18420_05_005.png), given as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，*Z – basis* 指的是 *Z*-轴上的基态，![图片](img/B18420_05_004.png) 和 ![图片](img/B18420_05_005.png)，而
    *X – basis* 指的是 *X*-轴上的基态（通常被称为相位态，因为绕它们的旋转指的是绕 *Z*-轴的旋转），![图片](img/B18420_09_050.png)
    和 ![图片](img/B18420_09_052.png)。Qiskit 文档（[https://docs.quantum.ibm.com/](https://docs.quantum.ibm.com/））使用波浪号（*~*）表示傅里叶基，其中
    *QFT* 是应用于状态 ![图片](img/B18420_05_005.png) 的 QFT 变换，如下所示：
- en: '![](img/B18420_12_013.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_12_013.png)'
- en: 'This can be equated, where the transformation is represented by the QFT between
    the amplitudes of *x*[j] and *y*[k], as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以等同于以下公式，其中变换由 QFT 在 *x*[j] 和 *y*[k] 的振幅之间表示：
- en: '![](img/B18420_12_014.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_12_014.png)'
- en: Now, let’s see how we can implement QFT in a quantum circuit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在量子电路中实现 QFT。
- en: Implementing the QFT algorithm
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现量子傅里叶变换（QFT）算法
- en: Let’s begin by deriving our implementation based on an input state ![](img/B18420_12_015.png),.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基于输入状态 ![图片](img/B18420_12_015.png) 的实现推导开始。
- en: 'An alternative is to apply it sequentially to the following formula as we move
    from qubit to qubit. For this example, we will operate as follows; given a state
    ![](img/B18420_12_016.png), we will apply a Hadamard gate where we add the phase
    based on the state ![](img/B18420_12_015.png), where each value, j[i], is appended
    to the phase, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是按顺序将其应用于以下公式，随着我们从量子比特到量子比特的移动。对于这个例子，我们将按以下方式操作；给定一个状态 ![图片](img/B18420_12_016.png)，我们将应用一个哈达玛门，其中我们根据状态
    ![图片](img/B18420_12_015.png) 添加相位，其中每个值，j[i]，都附加到相位上，如下所示：
- en: '![](img/B18420_12_018.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_12_018.png)'
- en: 'In the following exercise, we will implement the QFT of ![](img/B18420_12_019.png),
    where ![](img/B18420_12_020.png). It’s important to note that the fractional parts
    of the exponents are binary, not decimal:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将实现 ![图片](img/B18420_12_019.png) 的 QFT，其中 ![图片](img/B18420_12_020.png)。重要的是要注意，指数的分数部分是二进制，而不是十进制：
- en: 'We’ll begin by opening a new Jupyter notebook and import some common objects
    and run our helper file:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先打开一个新的 Jupyter 笔记本，导入一些常用对象并运行我们的辅助文件：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll create a quantum circuit where the width is equal to the length
    of our state value, `''110''`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个量子电路，其宽度等于我们的状态值长度，`'110'`：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have created our quantum circuit, let’s initialize the state, *s*,
    to ![](img/B18420_12_021.png). Since we write from the least significant position,
    we will reverse `s` accordingly as well:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们自己的量子电路，让我们将状态，*s*，初始化为 ![初始化状态，s，为](img/B18420_12_021.png)。由于我们从最不显著的位置开始写，我们将相应地反转`s`：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code will initialize and render our circuit as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将初始化并渲染我们的电路如下：
- en: '![Figure 14.5 – Initializing the state, s, to |110 ](img/B18420_12_01.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 初始化状态，s，为 |110 ](img/B18420_12_01.png)'
- en: 'Figure 12.1: Initializing the state, s, to ![](img/B18420_12_021.png)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：初始化状态，s，为 ![初始化状态，s，为](img/B18420_12_021.png)
- en: Now that we have prepared our state, we can begin transforming it using QFT.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的状态，我们可以开始使用QFT对其进行变换。
- en: 'Let’s review our transformation equation with our state ![](img/B18420_12_021.png):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的变换方程，使用我们的状态 ![初始化状态，s，为](img/B18420_12_021.png)：
- en: '![](img/B18420_12_024.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![初始化状态，s，为](img/B18420_12_024.png)'
- en: 'This states that for each qubit where we apply a Hadamard gate, we will need
    to include rotations while traversing from the qubit down to the least significant
    qubit—hence, ![](img/B18420_12_025.png). As we traverse down, the qubit states
    decrease by each degree. This means each of the controlled phase rotations, **Control
    Rotation** (**CROT**), is based on the following matrix representation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示对于每个我们应用Hadamard门的量子位，在遍历从量子位到最不显著的量子位的过程中，我们需要包括旋转——因此，![初始化状态，s，为](img/B18420_12_025.png)。当我们向下遍历，量子位的状态会逐度减少。这意味着每个受控相位旋转，**控制旋转**（**CROT**），基于以下矩阵表示：
- en: '![](img/B18420_12_026.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![初始化状态，s，为](img/B18420_12_026.png)'
- en: 'In the preceding equation, CROT(q)k is the CU[1] gate, and the parameter *q*
    is set as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，CROT(q)k是CU[1]门，参数*q*设置如下：
- en: '![](img/B18420_12_027.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![初始化并渲染我们的电路如下](img/B18420_12_027.png)'
- en: Therefore, we’ll start with the most significant qubit, *q*[2], from our state
    ![](img/B18420_05_035.png), as follows.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从我们的状态 ![初始化状态，s，为](img/B18420_05_035.png) 中的最显著的量子位，*q*[2]，开始，如下所示。
- en: 'Starting at the most significant qubit, we’ll add a Hadamard gate to the circuit:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从最显著的量子位开始，我们将向电路中添加一个Hadamard门：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have our first step, the next step is to add CROT(![](img/B18420_06_162.png))
    gates starting at *k=2*, which is the index of the most significant qubit position,
    q[2], and our parameter ![](img/B18420_06_162.png) starts at the following:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了第一步，下一步是添加CROT([![添加CROT门，从最显著的到最不显著的，从](img/B18420_06_162.png))）门，从*k=2*开始，这是最显著的量子位位置，q[2]的索引，我们的参数
    ![添加CROT门，从最显著的到最不显著的，从](img/B18420_06_162.png) 从以下开始：
- en: '![](img/B18420_12_031.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![初始化状态，s，为](img/B18420_12_031.png)'
- en: 'We add the CROT gates from most significant to least significant, starting
    at ![](img/B18420_07_009.png), and doubling the denominator of the parameter as
    we move down each qubit:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从最显著的量子位开始，添加CROT门，从最显著的到最不显著的，从 ![添加CROT门，从最显著的到最不显著的，从](img/B18420_07_009.png)
    开始，并且随着我们向下移动到每个量子位，参数的分母加倍：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then repeat this as we traverse from the current qubit down to the next
    qubit—in this case, *q*[0]:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们重复这个过程，当我们从当前量子位遍历到下一个量子位时——在这种情况下，*q*[0]：
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we are traversing down, the denominator on the parameter is doubling in
    size as well, such that the next parameter ![](img/B18420_06_162.png) is as follows
    (note that all qubits are initialized to the state ![](img/B18420_05_004.png):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向下遍历，参数的分母也在加倍，下一个参数 ![添加CROT门，从最显著的到最不显著的，从](img/B18420_06_162.png) 如下（注意，所有量子位都初始化为
    ![添加CROT门，从最显著的到最不显著的，从](img/B18420_05_004.png) 的状态）：
- en: '![](img/B18420_12_035.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![初始化状态，s，为](img/B18420_12_035.png)'
- en: 'This renders the following circuit, which now includes the Hadamard gate and
    the two CROT gates:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这渲染了以下电路，现在包括Hadamard门和两个CROT门：
- en: '![](img/B18420_12_02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用QFT对其进行变换](img/B18420_12_02.png)'
- en: 'Figure 12.2: The first set of transformations starting from the most significant
    qubit'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：从最显著的量子位开始的第一个变换集
- en: 'That completes the first level, which dealt with the most significant qubit.
    We will now move down to the next qubit (the second most significant qubit) and
    repeat the process of adding a Hadamard gate, followed by CROT(q) gates, where
    the phase rotations get smaller as we traverse down each qubit. Let’s continue
    to the next qubit:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了第一级，处理了最显著的量子位。我们现在将向下移动到下一个量子位（第二最显著的量子位），并重复添加Hadamard门的过程，然后添加CROT(q)门，其中相位旋转随着我们向下遍历每个量子位而减小。让我们继续到下一个量子位：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the same as *step 4* of adding a Hadamard gate; now, we apply the control
    rotation gate in the same manner as we did earlier and then draw the circuit:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这与*步骤4*添加Hadamard门相同；现在，我们以与之前相同的方式应用控制旋转门，然后绘制电路：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will complete the second transformation, which will render the following
    circuit, which starts with a Hadamard gate and then appends the CROT gates afterward:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完成第二次变换，这将生成以下电路，它以Hadamard门开始，然后附加CROT门：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_12_03.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![计算机的截图  描述由低置信度自动生成](img/B18420_12_03.png)'
- en: 'Figure 12.3: The next transformation set starting at the next qubit down'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：从下一个量子比特开始的下一个变换集
- en: 'Next, we will run our transformation on the last qubit, and then draw the circuit:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将对最后一个量子比特运行变换，然后绘制电路：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since this is the last qubit and the least significant qubit, it has no lower
    levels, so we complete the CROT phase of the QFT. This renders the following circuit
    so far:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是最后一个量子比特，也是最低有效位量子比特，它没有更低的级别，所以我们完成了QFT的CROT相位。这生成了以下电路：
- en: '![A screenshot of a graph  Description automatically generated with medium
    confidence](img/B18420_12_04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![一个图形的截图  描述由中等置信度自动生成](img/B18420_12_04.png)'
- en: 'Figure 12.4: The final transformation of our QFT circuit'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：我们QFT电路的最终变换
- en: Finally, once we have set all the rotations, we need to apply swap gates to
    reverse our results. We need to do this to complete the QFT and set the values
    in the proper order. The swap is performed from the outermost qubits moving inward
    until you reach the last two qubits in the middle (if the total number of qubits
    is even), or until you reach the last two pairs with a single qubit in the middle
    (if the total number of qubits is odd).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们设置了所有旋转，我们需要应用交换门来反转我们的结果。我们需要这样做以完成QFT并按正确的顺序设置值。交换是从最外层的量子比特向内进行，直到达到中间的最后两个量子比特（如果量子比特总数是偶数），或者直到达到中间的最后两个带有单个量子比特的配对（如果量子比特总数是奇数）。
- en: 'To simplify this, we can create a function that will swap the outer qubits
    and work its way toward the middle. In this case, since we only have three qubits,
    we will only swap the outer two qubits, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个过程，我们可以创建一个函数来交换外层量子比特，并逐步向中间工作。在这种情况下，因为我们只有三个量子比特，所以我们只会交换外层的两个量子比特，如下所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can run our quantum circuit through the `add_swap_gates` function and
    complete the circuit:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过`add_swap_gates`函数运行我们的量子电路，并完成电路：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will render our QFT circuit, which encodes our `''110''` value, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成我们的QFT电路，它编码了我们的`'110'`值，如下所示：
- en: '![A screenshot of a graph  Description automatically generated with medium
    confidence](img/B18420_12_05.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![一个图形的截图  描述由中等置信度自动生成](img/B18420_12_05.png)'
- en: 'Figure 12.5: The QFT circuit that encodes ‘110’'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：编码‘110’的QFT电路
- en: Let’s include some helper functions, similar to the functions we created in
    the previous chapter, that will run on either simulators or quantum systems. This
    time, we will include an option to select the number of shots.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们包含一些辅助函数，类似于我们在上一章中创建的函数，这些函数可以在模拟器或量子系统上运行。这次，我们将包括一个选项来选择射击次数。
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To visualize our QFT results, we can execute the preceding circuit using the
    state vector simulator to see our final QFT encoding for each qubit:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了可视化我们的量子场论（QFT）结果，我们可以使用状态向量模拟器执行前面的电路，以查看每个量子比特的最终QFT编码：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code results in the following encoding for each qubit:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码为每个量子比特生成以下编码：
- en: '![Figure 14.10 – A Bloch sphere representation of the ''110'' QFT encoded value
    ](img/B18420_12_06.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10 – ''110'' QFT编码值的布洛赫球体表示](img/B18420_12_06.png)'
- en: 'Figure 12.6: A Bloch sphere representation of the ‘110’ QFT encoded value'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：编码值为‘110’的QFT的布洛赫球体表示
- en: Note that q[0] (q[2] before the swap) has rotated ![](img/B18420_12_036.png)
    (which is a Hadamard (H) plus a ![](img/B18420_12_037.png) rotation), q[1] has
    rotated ![](img/B18420_12_038.png)(H), and *q*[2] (q[0] before the swap) has rotated
    0, mainly due to q[0] having a value of 0 before the swap because it was initialized
    to ![](img/B18420_07_007.png).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，q[0]（交换前的q[2]）旋转了![](img/B18420_12_036.png)（这是一个Hadamard（H）加上![](img/B18420_12_037.png)旋转），q[1]旋转了![](img/B18420_12_038.png)(H)，而*q*[2]（交换前的q[0]）旋转了0，这主要是因为交换前q[0]的值为0，因为它被初始化为![](img/B18420_07_007.png)。
- en: 'Note that each qubit is in a superposition state and varies by phase based
    on the `''110''` encoded value. We can also represent this using the `qsphere`
    object, which will have the same information, only represented in a single sphere
    object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个量子比特都处于叠加态，并且根据编码的`'110'`值按相位变化。我们还可以使用`qsphere`对象来表示这一点，它将包含相同的信息，只是在一个单独的球体对象中表示：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the following diagram, we can see that the information is encoded into the
    QSphere and has its encoded representation in the phase and state vector indicated
    by the color wheel and QSphere, respectively:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到信息被编码到QSphere中，并且其编码表示分别由颜色轮和QSphere指示的相位和状态向量：
- en: '![Chart, radar chart  Description automatically generated](img/B18420_12_07.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图表，雷达图  描述自动生成](img/B18420_12_07.png)'
- en: 'Figure 12.7: A QSphere representation of the QFT representation of the ‘110’
    state'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：'110'状态的QFT表示的QSphere表示
- en: Note that the colors indicate the phase of each state specified in the results
    where, at the time of this writing, green indicates ![](img/B18420_12_036.png)-degree
    phase rotation for rotation states ‘000’ and ‘100’.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，颜色表示结果中每个状态的相位，在撰写本文时，绿色表示对旋转状态‘000’和‘100’进行-度相位旋转![img/B18420_12_036.png]
- en: Congratulations! You have just completed encoding your first QFT! This is an
    algorithm that you will see in many other algorithms that depend on periodic functionality.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了你的第一个QFT编码！这是一个你将在许多依赖周期性功能的算法中看到的算法。
- en: In this section, we learned about the QFT algorithm and implemented it as well.
    One thing we have not covered, but which is important to mention, is that the
    QFT also has an inverse function called the **Inverse Quantum Fourier Transform**
    (**IQFT**). This is quite simply the reverse of the QFT and in essence transforms
    the quantum state from the quantum Fourier basis back to the computational basis.
    This is done, as described, by reversing the functionality which was performed
    when transforming the QFT which includes reverse rotations. That is to say, if
    we rotated a qubit ![](img/B18420_12_041.png), then when performing an IQFT, we
    would rotate the qubit by the same angle, only this time in the opposite direction,
    i.e. ![](img/B18420_12_042.png).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了QFT算法，并实现了它。有一件事我们没有涉及，但很重要，那就是QFT还有一个逆函数，称为**逆量子傅里叶变换**（**IQFT**）。这很简单，就是QFT的逆过程，本质上是将量子状态从量子傅里叶基转换回计算基。这是通过反转在转换QFT时执行的功能来完成的，包括反向旋转。也就是说，如果我们旋转了一个量子比特![img/B18420_12_041.png]，那么在执行IQFT时，我们会以相同的角度旋转量子比特，但这次是相反的方向，即![img/B18420_12_042.png]。
- en: With an understanding of the basis of state transformation, you are now able
    to leverage this in many periodic functions and algorithms, such as estimating
    eigenvalues or unitary matrices and factoring discrete logarithms.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解状态转换的基础，你现在能够利用这在许多周期性函数和算法中，例如估计特征值或单位矩阵，以及分解离散对数。
- en: 'Next, we will look at one of the more famous search algorithms: **Grover’s
    algorithm**.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一个更著名的搜索算法："Grover算法"。
- en: Learning about Grover’s search algorithm
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Grover搜索算法
- en: Search algorithms are unique in that they can be leveraged by various algorithms
    to find information, whether in a data repository or a list of values, such as
    features in an image. The advantage with quantum, of course, is in the potential
    for speeding up the search. **Grover’s algorithm** is one such example. It uses
    a well-known technique that allows the use of interference to amplify certain
    states in our quantum circuit in a way that will increase the amplitude of the
    value we are searching for and decrease those that we are not. Let’s start, as
    always, by describing the problem, where each state is analogous to an entry in
    an unordered list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法的独特之处在于，它们可以被各种算法利用来查找信息，无论是在数据存储库还是在值列表中，例如图像中的特征。当然，量子计算的优势在于加速搜索的潜力。"Grover算法"就是一个这样的例子。它使用一种众所周知的技术，允许使用干涉来放大我们量子电路中的某些状态，从而增加我们正在搜索的值的振幅，并减少我们不需要的值。让我们像往常一样，先描述问题，其中每个状态都类似于无序列表中的一个条目。
- en: Understanding the problem
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解问题
- en: 'The problem here is also very simple: we are given a set of states where all
    states are set to 0, except one state which is set to 1\. We wish to identify
    which one of those states is set to 1.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题也非常简单：我们给定了一组状态，其中所有状态都设置为0，除了一个状态设置为1。我们希望识别出哪个状态被设置为1。
- en: Classically, this can be done in, in the best case, 1 step, if the first value
    is set. In the worst case, it would take *N* steps, where *N* is the total number
    of states and the last state is set. This means that on average, it will take
    *N/2* steps to find the value as we would need to check each value individually.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典情况下，如果第一个值被设置，这可以在最佳情况下一步完成。在最坏的情况下，需要*N*步，其中*N*是总状态数，最后一个状态被设置。这意味着平均来说，需要*N/2*步来找到值，因为我们需要逐个检查每个值。
- en: Clearly, this is not ideal if our set is a very large list. We need to find
    a better way to find our value. This is where, in 1996, Lov Grover came in and
    discovered a way to solve this problem with his now-famous quantum algorithm.
    We’ll step through the implementation of Grover’s algorithm as we try to search
    for a value in a three-qubit circuit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们的集合是一个非常长的列表，这并不是理想的。我们需要找到一种更好的方法来找到我们的值。这就是在1996年，Lov Grover出现并发现了一种使用他现在著名的量子算法来解决这个问题的方法。当我们尝试在一个三量子比特电路中搜索一个值时，我们将逐步实现Grover算法。
- en: 'To describe this problem using functions, we can state the following, given
    a function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用函数描述这个问题，我们可以陈述以下内容，给定一个函数：
- en: '![](img/B18420_12_043.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_12_043.png)'
- en: From the preceding equation, ![](img/B18420_12_044.png) for all cases of *x*
    except for a specific case, *x**, such that ![](img/B18420_12_045.png). Find the
    value of *x**. Since we will be working with qubits, let’s select a value *N*,
    such that *N* = 2^n.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方程中，对于所有除了特定情况*x*以外的*x*的情况，![](img/B18420_12_044.png)。找出*x*的值。由于我们将使用量子比特，让我们选择一个值*N*，使得*N*
    = 2^n。
- en: Now that we have defined our problem, let’s step through Grover’s search algorithm.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的问题，让我们逐步通过Grover的搜索算法。
- en: Understanding Grover’s search algorithm
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Grover的搜索算法
- en: Grover’s algorithm is similar to the Deutsch-Jozsa and Bernstein-Vazirani algorithms
    in that it too leverages an oracle. However, note that the example given here
    illustrates a very simple oracle where we know the tagged state beforehand. This
    is done for demonstration purposes here; however, in real-world applications,
    the oracle will not only be more complex, but we will also have no idea which
    state will be tagged.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Grover算法与Deutsch-Jozsa和Bernstein-Vazirani算法类似，因为它也利用了预言机。然而，请注意，这里给出的例子展示了一个非常简单的预言机，我们事先知道标记的状态。这是为了演示目的；然而，在实际应用中，预言机不仅会更复杂，而且我们也不知道哪个状态会被标记。
- en: Another similarity between Deutsch-Josza and Grover’s algorithm is that Grover’s
    also leverages interference in a way that it will increase the amplitude of the
    state we are searching for while decreasing all other states, which in turn increases
    the speed by ![](img/B18420_12_046.png), where *N* is the number of states to
    search. This means that rather than iterating through each value within N, we
    take an exponential speedup, similar to what we did with Deutsch-Josza.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Deutsch-Josza和Grover算法之间的另一个相似之处是，Grover也以某种方式利用了干涉，它会增加我们正在搜索的状态的振幅，同时减少所有其他状态，这反过来又通过![](img/B18420_12_046.png)增加了速度，其中*N*是要搜索的状态数。这意味着我们不需要迭代N中的每个值，而是获得指数级的加速，类似于我们在Deutsch-Jozsa中做的那样。
- en: We’ll begin by explaining Grover’s search process in order to obtain an understanding
    of how it works. For a deeper description of the mathematics behind this, I recommend
    the book *Dancing with Qubits* by Robert S. Sutor, which covers this in greater
    detail.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释Grover的搜索过程，以便了解它是如何工作的。对于这个背后的数学的更深入描述，我推荐Robert S. Sutor的书籍《与量子比特共舞》，它对此有更详细的介绍。
- en: Grover’s search algorithm can be broken down into two main components—perhaps
    three, if you count initializing all qubits into superposition and adding measurements
    at the end—but that is something that most quantum algorithms do, so we’ll just
    stick to the two main points. The first is referred to as **Grover’s oracle**,
    and the second is the **Grover diffusion operator**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Grover的搜索算法可以分为两个主要组件——如果你把初始化所有量子比特到叠加态和在最后添加测量算子算作第三个组件的话，那么就是三个——但这是大多数量子算法都会做的事情，所以我们将只关注两个主要点。第一个被称为**Grover的预言机**，第二个是**Grover扩散算子**。
- en: 'In this example, we will describe a two-qubit system that, when placed in superposition
    by applying a Hadamard gate to each qubit, provides four possible states—**00**,
    **01**, **10**, and **11**—as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将描述一个双量子比特系统，当通过给每个量子比特应用Hadamard门将其置于叠加态时，提供四种可能的状态——**00**、**01**、**10**和**11**——如下所示：
- en: '![A graph with numbers and lines  Description automatically generated with
    medium confidence](img/B18420_12_08.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有数字和线的图表  中度置信度自动生成](img/B18420_12_08.png)'
- en: 'Figure 12.8: Two qubits in a superposition state'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：两个处于叠加状态的反转量子比特
- en: When in this state, the average equals the probability amplitude, which in this
    case is **0.25**, as indicated by the dotted line across the top of each state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于这种状态时，平均值等于概率振幅，在这种情况下是**0.25**，如每个状态顶部的虚线所示。
- en: For this example, we’ll say the state that we wish to search for is the state
    `'10'`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们假设我们想要搜索的状态是状态`'10'`。
- en: 'The first component is the **oracle**, *U*[f]. This is where we generally tag
    the value we are searching for. By tagging, I mean we will signal that the state
    that we are searching for will be identified by simply changing the sign of the
    state from positive to negative. The transition would be as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是**oracles**，*U*[f]。这是我们通常标记我们正在寻找的值的地方。通过标记，我的意思是我们将发出信号，即我们正在寻找的状态将通过简单地改变状态的符号从正变为负来识别。过渡将如下所示：
- en: '![A graph with blue squares  Description automatically generated](img/B18420_12_09.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有蓝色方块的图表  描述自动生成](img/B18420_12_09.png)'
- en: 'Figure 12.9: Changing the sign of the state to negative'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：将状态符号改为负
- en: Now that we have changed the sign, we can’t, unfortunately, just measure and
    go at this point—mainly because, as we know, the probability amplitudes are squared,
    so our results would all still be equal, which does not provide us with any new
    information about what we are searching for. However, since we are working with
    amplitudes, we can leverage interference here by increasing the amplitude of the
    state we tagged and decreasing the amplitude of the other states. *How do we do
    this?* By incorporating the second component of Grover’s search, the **diffusion
    operator**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经改变了符号，不幸的是，我们在这个点上不能只是进行测量然后继续——主要是因为，正如我们所知，概率振幅是平方的，所以我们的结果仍然都会相等，这并没有给我们提供任何关于我们正在寻找的信息的新信息。然而，由于我们正在处理振幅，我们可以通过增加我们标记的状态的振幅并减少其他状态的振幅来利用干涉。*我们如何做到这一点？*
    通过结合Grover搜索的第二部分，即**扩散算子**。
- en: 'The second component of Grover’s algorithm is the **Grover diffusion operator**.
    Here, we will be performing a mathematical step known as *inversion about the
    mean*. What this does is invert the distance between the average and the peak
    of each state. This is analogous to having each state flip reflectively about
    the average mean. Visually, the transition will be as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Grover算法的第二部分是**Grover扩散算子**。在这里，我们将执行一个称为*关于平均值的反转*的数学步骤。这样做的作用是反转每个状态的平均值与峰值之间的距离。这相当于每个状态相对于平均值进行反射翻转。直观上看，过渡将如下所示：
- en: '![A graph with blue squares and numbers  Description automatically generated](img/B18420_12_10.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有蓝色方块和数字的图表  描述自动生成](img/B18420_12_10.png)'
- en: 'Figure 12.10: Inversion about the mean amplifies the states constructively
    and destructively'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：关于平均值的反转以建设性和破坏性方式放大状态
- en: As we can see from the results of performing the inversion about the mean, the
    amplification of the tagged state is now significantly higher than the other states.
    If we were to now take a measurement, we would see that the result with the higher
    probability is the state we are searching for. Keep in mind, of course, that this
    is all done with a single query to our quantum circuit!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从对平均值进行反转操作的结果中我们可以看出，标记状态的放大现在显著高于其他状态。如果我们现在进行测量，我们会看到结果中概率更高的状态就是我们正在寻找的状态。当然，记住，这一切都是通过对我们量子电路的单次查询完成的！
- en: One thing to note is that when the number of states, *N*, is large, this means
    we will need to repeat the diffusion operator steps (and not the oracle constructor
    steps) multiple times, which is what constructs and destructs the amplitudes.
    The number of times to optimize the results is ![](img/B18420_12_047.png), where
    *n* is the number of qubits.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，当状态的数量，*N*，很大时，这意味着我们需要多次重复扩散算子步骤（而不是或acles构造步骤），这是构建和破坏振幅的过程。优化结果所需的次数是
    ![](img/B18420_12_047.png)，其中 *n* 是量子比特的数量。
- en: Let’s implement Grover’s search algorithm next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来实现Grover搜索算法。
- en: Implementing Grover’s search algorithm
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Grover搜索算法
- en: 'As usual, we’ll explain each step described in the previous section while we
    work through the algorithm step by step. To start, create a new Qiskit notebook
    for this example and work through the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，当我们逐步通过算法时，我们将解释上一节中描述的每个步骤。首先，为这个例子创建一个新的Qiskit笔记本，并逐步完成以下步骤：
- en: 'We’ll begin by declaring the value we want to set. Let’s set the value to `110`.
    This way, we can use a three-qubit circuit to implement Grover’s algorithm and
    place all the qubits in superposition by adding a Hadamard gate to each qubit:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明我们想要设置的值。让我们将值设置为`110`。这样，我们可以使用一个三量子比特电路来实现Grover算法，并通过在每个量子比特上添加一个H门来使所有量子比特处于叠加态：
- en: '[PRE14]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will render our initialized circuit:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成我们的初始化电路：
- en: '![Figure 14.15 – Initialized quantum circuit in superposition ](img/B18420_12_11.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图14.15 – 初始化的叠加量子电路](img/B18420_12_11.png)'
- en: 'Figure 12.11: Initialized quantum circuit in superposition'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：初始化的叠加量子电路
- en: 'Next, we want to encode the state that we want to search—in this case, it is
    the state ![](img/B18420_12_048.png). Here, we will reverse the state and encode
    `N` in the circuit:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要编码我们想要搜索的态——在这种情况下，它是态![img/B18420_12_048.png](img/B18420_12_048.png)。在这里，我们将反转态并在电路中编码`N`：
- en: '[PRE15]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For each step, we will add a barrier so that we can see the process rendered:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一步，我们都会添加一个障碍，以便我们可以看到渲染的过程：
- en: '![Figure 14.16 – Encoding our state ''110'', we mark the ''0'' qubits in the
    state with an X gate ](img/B18420_12_12.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图14.16 – 编码我们的状态''110''，我们用X门标记状态中的''0''量子比特](img/B18420_12_12.png)'
- en: 'Figure 12.12: Encoding our state ‘110’, we mark the ‘0’ qubits in the state
    with an X gate'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：编码我们的状态‘110’，我们用X门标记状态中的‘0’量子比特
- en: 'Next, we will create Grover’s oracle. What we will do here is first set the
    most significant qubit in a superposition state, followed by a CNOT gate where
    the target is the most significant qubit, and the source is all the other qubits.
    Then, place another Hadamard gate on the most significant qubit to complete the
    oracle. This will negate the state that we set in the previous source cell, ![](img/B18420_12_021.png):'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建Grover的或门。我们在这里要做的首先是设置最显著量子比特的叠加态，然后是一个目标为最显著量子比特、源为所有其他量子比特的CNOT门。然后，在最显著量子比特上放置另一个H门来完成或门。这将否定我们在上一个源单元格中设置的态，![img/B18420_12_021.png](img/B18420_12_021.png)：
- en: '[PRE16]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code renders the following circuit, which we see sets the two
    CNOT gates in our oracle surrounded by **H** gates on the most significant qubit:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下电路，我们可以看到它设置了围绕最显著量子比特的**H**门的我们或门中的两个CNOT门：
- en: '![Figure 14.17 – Applying Grover''s oracle to the circuit ](img/B18420_12_13.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图14.17 – 将Grover的或门应用于电路](img/B18420_12_13.png)'
- en: 'Figure 12.13: Applying Grover’s oracle to the circuit'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：将Grover的或门应用于电路
- en: 'Now, we want to reset the state that we are searching in the circuit so that
    it returns to the superposition value:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要将电路中我们正在搜索的态重置，使其返回到叠加值：
- en: '[PRE17]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code completes Grover’s oracle, which we described earlier as
    the first component of Grover’s search algorithm:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码完成了我们之前描述的Grover或门，它是Grover搜索算法的第一个组件：
- en: '![Figure 14.18 – The first component of Grover''s search algorithm ](img/B18420_12_14.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图14.18 – Grover搜索算法的第一个组件](img/B18420_12_14.png)'
- en: 'Figure 12.14: The first component of Grover’s search algorithm'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：Grover搜索算法的第一个组件
- en: 'Next, we will implement the second component, the Grover diffusion operator.
    We start by applying all the qubits in a superposition state:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现第二个组件，Grover扩散算子。我们首先将所有量子比特置于叠加态：
- en: '[PRE18]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This renders the following superposition state, followed by Grover’s oracle:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下叠加态，然后是Grover的或门：
- en: '![Chart, box and whisker chart  Description automatically generated](img/B18420_12_15.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图表，箱线图  描述自动生成](img/B18420_12_15.png)'
- en: 'Figure 12.15: The first step in the Grover diffusion operator: apply H gates
    to all qubits'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：Grover扩散算子的第一步：对所有量子比特应用H门
- en: 'Next, we will flip all the 0-state qubits to their negative phase. Here, the
    most significant qubit is set as the target of the two CNOT gates:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将翻转所有0态量子比特到它们的负相。在这里，最显著量子比特被设置为两个CNOT门的目标：
- en: '[PRE19]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This renders the next step in the diffusion operator—that is, inversion about
    the mean:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染扩散算器的下一步——即关于平均值的反转：
- en: '![Figure 14.20 – The second step of the diffusion operator to invert about
    the mean ](img/B18420_12_16.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图14.20 – 扩散算子的第二步，关于平均值的反转](img/B18420_12_16.png)'
- en: 'Figure 12.16: The second step of the diffusion operator: to invert about the
    mean'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16：扩散算子的第二步：关于平均值的反转
- en: 'Finally, we wrap up the Grover diffusion operator by applying the first step
    in reverse. Since we applied a set of H gates across all qubits, followed by a
    set of X gates, also across all qubits, we will reverse this in the following
    manner. Apply X gates across all qubits, then apply H gates across all qubits:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过逆向应用第一步来总结 Grover 扩散算子。由于我们在所有量子位上应用了一组 H 门，随后又应用了一组 X 门，也是跨所有量子位，我们将在以下方式中逆转这一过程。首先在所有量子位上应用
    X 门，然后应用所有量子位上的 H 门：
- en: '[PRE20]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code completes the Grover diffusion operator component of the
    quantum circuit:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码完成了量子电路的 Grover 扩散算子组件：
- en: '![Figure 14.21 – The complete Grover''s algorithm circuit ](img/B18420_12_17.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.21 – 完整的 Grover 算法电路](img/B18420_12_17.png)'
- en: 'Figure 12.17: The complete Grover’s algorithm circuit'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17：完整的 Grover 算法电路
- en: To determine the ideal number of times to repeat the diffusion operator, `n`,
    we simply need to compute n as follows,
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定重复扩散算子的理想次数 `n`，我们只需按照以下方式计算 n，
- en: '![](img/B18420_12_050.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_12_050.png](img/B18420_12_050.png)'
- en: where N is the number of (log N) qubits N=4 for two qubits; In this example,
    we should add a second diffusion operator to bring the error down from 3% to 1%.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 N 是量子位数量（log N），对于两个量子位，N=4；在这个例子中，我们应该添加第二个扩散算子，将错误率从 3% 降低到 1%。
- en: 'Now, we’ll just add measurement operators and prepare to run the circuit on
    the backend, but first on a local simulator on your device:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加测量算子并准备在后端运行电路，但首先在您的设备上的本地模拟器上：
- en: '[PRE21]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code will prepare the following quantum circuit to run on either
    a simulator or quantum computer:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将准备以下量子电路，以便在模拟器或量子计算机上运行：
- en: '![Figure 14.22 – The complete quantum circuit ready to run on a simulator or
    quantum system ](img/B18420_12_18.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.22 – 准备在模拟器或量子系统上运行的完整量子电路](img/B18420_12_18.png)'
- en: 'Figure 12.18: The complete quantum circuit ready to run on a simulator or quantum
    system'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18：准备在模拟器或量子系统上运行的完整量子电路
- en: 'We’ll start by running the function we created to execute our circuit using
    the Sampler primitive:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先运行我们创建的用于执行电路的函数，使用 Sampler 原语：
- en: '[PRE22]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After executing the circuit, this will print and plot our results as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行电路后，这将按照以下方式打印和绘制我们的结果：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following figure, we can see that the state we are searching has the
    higher probability, a quasi-probability of 0.559%, whereas all the other states
    have a significantly lower probability of around 0.05%:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到我们正在搜索的状态具有更高的概率，准概率为 0.559%，而所有其他状态的概率显著较低，约为 0.05%：
- en: '![Figure 14.23 – Results of executing Grover''s search of state 110 on a quantum
    simulator ](img/B18420_12_19.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.23 – 在量子模拟器上执行 Grover 搜索状态 110 的结果](img/B18420_12_19.png)'
- en: 'Figure 12.19: Results of executing Grover’s search of state 110 on a Sampler'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19：在 Sampler 上执行 Grover 搜索状态 110 的结果
- en: Success! As expected, our Grover’s algorithm implementation has found the state
    within a single query.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！正如预期的那样，我们的 Grover 算法实现在一个查询内找到了状态。
- en: Now, let’s try it on a quantum device. We’ll select the quantum computer that
    is the least busy and operational and has the number of qubits necessary to run
    our quantum circuit.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在一个量子设备上尝试。我们将选择最不繁忙且可操作的量子计算机，并且具有运行我们的量子电路所需的量子位数量。
- en: '[PRE24]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code will print out the least busy quantum computer and assign
    it to the `backend` variable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打印出最不繁忙的量子计算机并将其分配给 `backend` 变量。
- en: 'We can now execute this as we did previously with the simulator, then print
    and plot the results:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以像之前使用模拟器一样执行它，然后打印和绘制结果：
- en: '[PRE25]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once completed, you should see something similar to the following output:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，你应该会看到以下类似的输出：
- en: '[PRE26]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now plot the quasi distribution of the results on a graph using the
    following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下方法在图上绘制结果的准分布：
- en: '[PRE27]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will display the following output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![A graph with numbers and a bar  Description automatically generated](img/B18420_12_20.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![带有数字和条形的图表 描述自动生成](img/B18420_12_20.png)'
- en: 'Figure 12.20: Probability distribution'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.20：概率分布
- en: This, of course, depends on the device itself as each system is different from
    one another. However, the results should be clear that the state with the highest
    probability is the state that we are searching for—in this case, ![](img/B18420_12_021.png).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这取决于设备本身，因为每个系统都彼此不同。然而，结果应该是清晰的，即概率最高的状态就是我们正在寻找的状态——在这种情况下，![img/B18420_12_021.png](img/B18420_12_021.png)。
- en: As we can see here, the result with the highest probability is the state we
    are searching for, and the other states have a lower probability. We can see enough
    of a difference between each state to observe that the Grover’s search algorithm
    that we implemented does indeed identify the state we are searching for. You might
    also want to try this with a larger value N, just so you can observe the results.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，概率最高的状态就是我们正在寻找的状态，其他状态的概率较低。我们可以观察到每个状态之间的足够差异，以观察到我们实现的Grover搜索算法确实识别了我们正在寻找的状态。您也可以尝试使用更大的值N，这样您就可以观察到结果。
- en: Congratulations! You have successfully implemented a variety of quantum algorithms,
    which are foundational to understanding how quantum computers are different in
    how they solve problems compared to classical systems and how they have the potential
    to solve real-world problems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经成功实现了多种量子算法，这些算法是理解量子计算机如何与经典系统在解决问题上的不同，以及它们如何有可能解决现实世界问题的基石。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There are many algorithms that implement many of the techniques we covered in
    this and the previous chapter on quantum algorithms, many of which you will see
    used in other algorithms, such as the **quantum amplitude estimation** and **variational
    quantum eigensolver** algorithms, and so on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法实现了我们在本章和上一章量子算法章节中讨论的许多技术，其中许多您将在其他算法中看到使用，例如**量子振幅估计**和**变分量子本征值求解器**算法等。
- en: I do strongly suggest trying variations of these algorithms yourself to get
    a better feel and understanding of how they work.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您亲自尝试这些算法的变体，以更好地了解它们的工作原理。
- en: In the next and final chapter, we will look at the features that are built into
    Qiskit, which allow you as a researcher or developer to leverage them to create
    your own quantum algorithms. You will gain the skills to integrate these algorithms
    into your existing research or applications without having to worry about developing
    circuits, mitigating against noise, or any of the other components that make up
    an algorithm in Qiskit. This book has already done the heavy lifting for you,
    so you can simply implement the algorithm and process the results as you see fit.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将探讨Qiskit内置的功能，这些功能允许您作为研究人员或开发者利用它们来创建自己的量子算法。您将获得将算法集成到现有研究或应用中的技能，而无需担心开发电路、降低噪声或构成Qiskit中算法的其他任何组件。这本书已经为您做了大量工作，因此您可以简单地实现算法，并按您的需求处理结果。
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What other problems can you solve using periodic functions?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用周期函数可以解决哪些其他问题？
- en: Implement QFT on a five-qubit state—for example, `'10110'`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在五量子比特状态上实现QFT——例如，`'10110'`。
- en: 'Using Grover’s algorithm, find the following states: `''101''`, `''001''`,
    and `''010''`.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Grover算法找到以下状态：`'101'`，`'001'`，和`'010'`。
- en: How many iterations of Grover’s diffusion operator would you need to run to
    find the state ![](img/B18420_12_052.png)?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要运行多少次Grover的扩散算子才能找到![img/B18420_12_052.png](img/B18420_12_052.png)的状态？
- en: Rerun the Grover’s search example. Only repeat Grover’s diffusion operator twice
    and note the difference in the result. What do you see that is different? What
    would you expect to change if you ran it more than three times?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行Grover搜索示例。只重复Grover的扩散算子两次，并注意结果的不同。您看到了什么不同之处？如果您运行超过三次，您预计会发生什么变化？
- en: Join us on Discord
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](Chapter_12.xhtml)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](Chapter_12.xhtml)'
- en: '![](img/QR_Code2617625996838265933.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![img/QR_Code2617625996838265933.png](img/QR_Code2617625996838265933.png)'
