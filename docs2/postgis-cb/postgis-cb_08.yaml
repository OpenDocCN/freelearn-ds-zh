- en: PostGIS Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostGIS 编程
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing PostGIS vector data with Psycopg
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Psycopg 编写 PostGIS 向量数据
- en: Writing PostGIS vector data with OGR Python bindings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OGR Python 绑定编写 PostGIS 向量数据
- en: Writing PostGIS functions with PL/Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PL/Python 编写 PostGIS 函数
- en: Geocoding and reverse geocoding using the GeoNames datasets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GeoNames 数据集进行地理编码和反向地理编码
- en: Geocoding using the OSM datasets with trigrams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OSM 数据集和 trigrams 进行地理编码
- en: Geocoding with geopy and PL/Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 geopy 和 PL/Python 进行地理编码
- en: Importing NetCDF datasets with Python and GDAL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 和 GDAL 导入 NetCDF 数据集
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: There are several ways to write PostGIS programs, and in this chapter we will
    see a few of them. You will mainly use the Python language throughout this chapter.
    Python is a fantastic language with a plethora of GIS and scientific libraries
    that can be combined with PostGIS to write awesome geospatial applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以编写 PostGIS 程序，在本章中我们将看到其中的一些。你将主要在本章中使用 Python 语言。Python 是一种出色的语言，拥有大量的
    GIS 和科学库，可以与 PostGIS 结合编写出色的地理空间应用程序。
- en: 'If you are new to Python, you can quickly get productive with these excellent
    web resources:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触 Python，你可以通过这些优秀的网络资源快速变得高效：
- en: The official Python tutorial at [http://docs.python.org/2/tutorial/](http://docs.python.org/2/tutorial/)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的 Python 教程在 [http://docs.python.org/2/tutorial/](http://docs.python.org/2/tutorial/)
- en: The popular *Dive into Python* book at [http://www.diveintopython.net/](http://www.diveintopython.net/)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行的 *深入 Python* 书籍在 [http://www.diveintopython.net/](http://www.diveintopython.net/)
- en: 'You can combine Python with some excellent and popular libraries, such as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Python 与一些优秀且流行的库结合起来，例如：
- en: '**Psycopg**: This is the most complete and popular Python DB API implementation
    for PostgreSQL; see [http://initd.org/psycopg/](http://initd.org/psycopg/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Psycopg**：这是最完整且最受欢迎的 PostgreSQL Python DB API 实现；请参阅 [http://initd.org/psycopg/](http://initd.org/psycopg/)'
- en: '**GDAL**: Used to unchain the powerful GDAL library in your Python scripts;
    see [http://www.gdal.org/gdal_tutorial.html](http://www.gdal.org/gdal_tutorial.html)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GDAL**：用于在 Python 脚本中解锁强大的 GDAL 库；请参阅 [http://www.gdal.org/gdal_tutorial.html](http://www.gdal.org/gdal_tutorial.html)'
- en: '**requests**: This is a handy Python standard library to manage HTTP stuff,
    such as opening URLs'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**requests**：这是一个方便的 Python 标准库，用于管理 HTTP 事务，例如打开 URL'
- en: '**simplejson**: This is a simple and fast JSON encoder/decoder'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**simplejson**：这是一个简单且快速的 JSON 编码器/解码器'
- en: 'The recipes in this chapter will cover some other useful geospatial Python
    libraries that are worthy of being looked at if you are developing a geospatial
    application. Under these Python libraries, the following libraries are included:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱将涵盖一些其他有用的地理空间 Python 库，如果你正在开发地理空间应用程序，这些库值得一看。在这些 Python 库中，包括以下库：
- en: '**Shapely**: This is a Python interface to the GEOS library for the manipulation
    and analysis of planar geometric objects: [http://toblerity.github.io/shapely/](http://toblerity.github.io/shapely/)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Shapely**：这是用于操作和分析平面几何对象的 GEOS 库的 Python 接口：[http://toblerity.github.io/shapely/](http://toblerity.github.io/shapely/)'
- en: '**Fiona**: This is a very light OGR Python API, which can be used as an alternative
    to the OGR bindings used in this chapter to manage vector datasets: [https://github.com/Toblerity/Fiona](https://github.com/Toblerity/Fiona)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fiona**：这是一个非常轻量级的 OGR Python API，可以用作本章中使用的 OGR 绑定的替代品，以管理向量数据集：[https://github.com/Toblerity/Fiona](https://github.com/Toblerity/Fiona)'
- en: '**Rasterio**: This a Pythonic GDAL Python API, which can be used as an alternative
    to the GDAL bindings used in this chapter in order to manage raster datasets:
    [https://github.com/mapbox/rasterio](https://github.com/mapbox/rasterio)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rasterio**：这是一个 Pythonic 的 GDAL Python API，可以用作本章中使用的 GDAL 绑定的替代品，以管理栅格数据集：[https://github.com/mapbox/rasterio](https://github.com/mapbox/rasterio)'
- en: '**pyproj**: This is the Python interface to the PROJ.4 library: [https://pypi.python.org/pypi/pyproj](https://pypi.python.org/pypi/pyproj)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pyproj**：这是到 PROJ.4 库的 Python 接口：[https://pypi.python.org/pypi/pyproj](https://pypi.python.org/pypi/pyproj)'
- en: '**Rtree**: This is a `ctype` Python wrapper to the `libspatialindex` library,
    providing several spatial indexing features that can be extremely useful for some
    kinds of geospatial development: [http://toblerity.github.io/rtree/](http://toblerity.github.io/rtree/)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rtree**：这是 `ctype` Python 包装器到 `libspatialindex` 库，提供了一些对某些类型的地理空间开发非常有用的空间索引功能：[http://toblerity.github.io/rtree/](http://toblerity.github.io/rtree/)'
- en: In the first recipe, you will write a program that uses Python and its utilities
    such as `psycopg`, `requests`, and `simplejson` to fetch weather data from the
    web and import it in PostGIS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个小节中，你将编写一个程序，使用Python及其实用工具（如`psycopg`、`requests`和`simplejson`）从网络获取天气数据并将其导入PostGIS。
- en: In the second recipe, we will drive you to use Python and the GDAL OGR Python
    bindings library to create a script for geocoding a list of place names using
    one of the GeoNames web services.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个小节中，我们将引导你使用Python和GDAL OGR Python绑定库创建一个脚本，用于使用GeoNames网络服务之一对地名列表进行地理编码。
- en: You will then write a Python function for PostGIS using the PL/Python language
    to query the [http://openweathermap.org/](http://openweathermap.org/) web services,
    already used in the first recipe, to calculate the weather for a PostGIS geometry
    from within a PostgreSQL function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将使用PL/Python语言为PostGIS编写一个Python函数，查询[http://openweathermap.org/](http://openweathermap.org/) 网络服务，该服务已在第一个小节中使用，以计算PostGIS几何体的天气情况，并在PostgreSQL函数内部进行。
- en: In the fourth recipe, you will create two PL/pgSQL PostGIS functions that will
    let you perform geocoding and reverse geocoding using the GeoNames datasets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个小节中，你将创建两个PL/pgSQL PostGIS函数，这些函数将允许你使用GeoNames数据集执行地理编码和反向地理编码。
- en: After this, there is a recipe in which you will use the `OpenStreetMap` street
    datasets imported in PostGIS to implement a very basic Python class in order to
    provide a geocode implementation to the class's consumer using PostGIS trigram
    support.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，有一个小节，你将使用导入到PostGIS中的`OpenStreetMap`街道数据集，使用Python实现一个非常基本的Python类，以便为类的消费者提供使用PostGIS三重支持的地标实现。
- en: The sixth recipe will show you how to create a PL/Python function using the
    geopy library to geocode addresses using a web geocoding API such as Google Maps,
    Yahoo! Maps, Geocoder, GeoNames, and others.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个小节将展示如何使用geopy库创建一个PL/Python函数，使用网络地理编码API（如Google Maps、Yahoo! Maps、Geocoder、GeoNames等）进行地址地理编码。
- en: In the last recipe of this chapter, you will create a Python script to import
    data from the `netCDF` format to PostGIS using the GDAL Python bindings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个小节中，你将创建一个Python脚本，使用GDAL Python绑定将`netCDF`格式的数据导入PostGIS。
- en: Let's see some notes before starting with the recipes in this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章的小节之前，让我们先看看一些注意事项。
- en: 'If you are using Linux or macOS, follow these steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Linux或macOS，请按照以下步骤操作：
- en: 'Create a Python `virtualenv` ([http://www.virtualenv.org/en/latest/](http://www.virtualenv.org/en/latest/))
    to keep a Python-isolated environment to be used for all the Python recipes in
    this book and activate it. Create it in a central directory, as you will need
    to use it for most of the Python recipes in this book:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Python `virtualenv` ([http://www.virtualenv.org/en/latest/](http://www.virtualenv.org/en/latest/))，以保持一个Python隔离环境，用于本书中所有Python小节的Python脚本，并激活它。请在中央目录中创建它，因为你将需要使用它来编写本书中大多数Python小节的Python脚本：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once activated, you can install the Python libraries you will need for the
    recipes in this chapter:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦激活，你就可以安装本章小节所需的Python库：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are new to the virtual environment and you are wondering where the libraries
    have been installed, you should find everything in the `virtualenv` directory
    in our development box. You can find the libraries using the following command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你刚开始使用虚拟环境，并且想知道库安装在哪里，你应该在我们的开发箱中的`virtualenv`目录中找到所有内容。你可以使用以下命令查找库：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you are wondering what is going on with the previous command lines, then
    `virtualenv` is a tool that will be used to create isolated Python environments,
    and you can find more information about this tool at [http://www.virtualenv.org](http://www.virtualenv.org),
    while `pip` ([http://www.pip-installer.org](http://www.pip-installer.org)) is
    a package management system used to install and manage software packages written
    in Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道前面的命令行发生了什么，那么`virtualenv`是一个用于创建隔离Python环境的工具，你可以在[http://www.virtualenv.org](http://www.virtualenv.org)上找到更多关于这个工具的信息，而`pip`
    ([http://www.pip-installer.org](http://www.pip-installer.org))是一个用于安装和管理用Python编写的软件包的包管理系统。
- en: 'If you are using Windows, follow these steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Windows，请按照以下步骤操作：
- en: The easiest way to get Python and all the libraries needed for the recipes in
    this chapter is to use **OSGeo4W**, a popular binary distribution of open source
    geospatial software for Windows. You can download it from [http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取Python以及本章小节所需的所有库的最简单方法是使用**OSGeo4W**，它是Windows上流行的开源地理空间软件的二进制发行版。你可以从[http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/)下载它。
- en: In our Windows box the OSGeo4W shell, at the time of writing this book comes
    with Python 2.7, GDAL 2.2 Python bindings, simplejson, psycopg2, and numpy. You
    will only need to install geopy.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编写这本书的时候，Windows盒子中的OSGeo4W shell附带Python 2.7，GDAL 2.2 Python绑定，simplejson，psycopg2和numpy。你只需要安装geopy。
- en: 'The easiest way to install geopy and to eventually add more Python libraries
    to the OSGeo4W shell is to install `setuptools` and `pip` by following the instructions
    found at [http://www.pip-installer.org/en/latest/installing.html](http://www.pip-installer.org/en/latest/installing.html).
    Open the OSGeo4W shell and just enter the following commands:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装geopy以及最终向OSGeo4W shell添加更多Python库的最简单方法是按照[http://www.pip-installer.org/en/latest/installing.html](http://www.pip-installer.org/en/latest/installing.html)中找到的说明安装`setuptools`和`pip`。打开OSGeo4W
    shell，只需输入以下命令：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing PostGIS vector data with Psycopg
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Psycopg编写PostGIS矢量数据
- en: In this recipe, you will use Python combined with Psycopg, the most popular
    PostgreSQL database library for Python, in order to write some data to PostGIS
    using the SQL language.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将使用Python结合Psycopg，这是Python中最流行的PostgreSQL数据库库，以便使用SQL语言将一些数据写入PostGIS。
- en: You will write a procedure to import weather data for the most populated US
    cities. You will import such weather data from [http://www.openweatherdata.org/](http://www.openweatherdata.org/),
    which is a web service that provides free weather data and a forecast API. The
    procedure you are going to write will iterate each major USA city and get the
    actual temperature for it from the closest weather stations using the [http://www.openweatherdata.org/](http://www.openweatherdata.org/)
    web service API, getting the output in JSON format. (In case you are new to the
    JSON format, you can find details about it at [http://www.json.org/](http://www.json.org/).)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写一个过程来导入美国人口最多的城市的气象数据。你将从[http://www.openweatherdata.org/](http://www.openweatherdata.org/)导入此类气象数据，这是一个提供免费气象数据和预报API的Web服务。你将要编写的过程将迭代每个主要美国城市，并使用[http://www.openweatherdata.org/](http://www.openweatherdata.org/)
    Web服务API从最近的气象站获取其实际温度，以JSON格式获取输出。（如果你对JSON格式不熟悉，可以在[http://www.json.org/](http://www.json.org/)找到有关它的详细信息。）
- en: You will also generate a new PostGIS layer with the 10 closest weather stations
    to each city.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将生成一个新的PostGIS图层，包含每个城市最近的10个气象站。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a database schema for the recipes in this chapter using the following
    command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为本章的菜谱创建数据库模式：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Download the USA cities'' shapefile from the [https://nationalmap.gov/](https://nationalmap.gov/)
    website at [http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz)
    (this archive is also included in the book''s dataset that is available with the
    code bundle), extract it to `working/chp08`, and import it in PostGIS, filtering
    out cities with less than 100,000 inhabitants:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://nationalmap.gov/](https://nationalmap.gov/)网站下载USA城市的shapefile，地址为[http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz)（此存档也包含在本书的数据集中，与代码包一起提供），将其提取到`working/chp08`，并在PostGIS中导入它，过滤掉人口少于100,000的城市：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a `real` field to store the temperature for each city using the following
    command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为每个城市添加一个存储温度的`real`字段：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you are on Linux, ensure that you follow the initial instructions in this
    chapter and create a Python virtual environment in order to keep a Python-isolated
    environment to be used for all the Python recipes in this book. Then, activate
    it:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用Linux，请确保遵循本章的初始说明并创建一个Python虚拟环境，以便为本书中所有Python菜谱保持一个Python隔离的环境。然后，激活它：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Carry out the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create the following table to host weather stations'' data:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下表格以存储气象站的数据：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create an account at [https://openweathermap.org](https://openweathermap.org)
    to get an API key. Then, check the JSON response for the web service you are going
    to use. If you want the 10 closest weather stations from a point (the city centroid),
    the request you need to run is as follows (test it in a browser): [http://api.openweathermap.org/data/2.5/find?lat=55&lon=37&cnt=10&appid=YOURKEY](http://api.openweathermap.org/data/2.5/find?lat=55&lon=37&cnt=10&appid=YOURKEY)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://openweathermap.org](https://openweathermap.org)创建一个账户以获取API密钥。然后，检查你将要使用的Web服务的JSON响应。如果你想从一个点（城市质心）获取最近的10个气象站，你需要运行的请求如下（在浏览器中测试它）：[http://api.openweathermap.org/data/2.5/find?lat=55&lon=37&cnt=10&appid=YOURKEY](http://api.openweathermap.org/data/2.5/find?lat=55&lon=37&cnt=10&appid=YOURKEY)
- en: 'You should get the following JSON response (the closest 10 stations and their
    relative data are ordered by their distance from the point coordinates, which
    in this case are `lon=37` and `lat=55`):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该得到以下 JSON 响应（最近的 10 个站点及其相对数据按距离点坐标的顺序排列，在这种情况下，坐标为 `lon=37` 和 `lat=55`）：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, create the Python program that will provide the desired output and name
    it `get_weather_data.py`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个将提供所需输出的 Python 程序，并将其命名为 `get_weather_data.py`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the Python program:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Python 程序：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Check the output of the Python program you just wrote. Open the two PostGIS
    layers, `cities` and `wstations`, with your favorite GIS desktop tool and investigate
    the results. The following screenshot shows how it looks in QGIS:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你刚刚编写的 Python 程序的输出。使用你最喜欢的 GIS 桌面工具打开两个 PostGIS 图层 `cities` 和 `wstations`，并调查结果。以下截图显示了在
    QGIS 中的样子：
- en: '![](img/d7c91e45-c87e-4835-9a31-c493c8b59bce.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7c91e45-c87e-4835-9a31-c493c8b59bce.png)'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**Psycopg** is the most popular PostgreSQL adapter for Python, and it can be
    used to create Python scripts that send SQL commands to PostGIS. In this recipe,
    you created a Python script that queries weather data from the [https://openweathermap.org/](https://openweathermap.org/)
    web server using the popular **JSON** format to get the output data and then used
    that data to update two PostGIS layers.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Psycopg** 是 Python 中最流行的 PostgreSQL 适配器，它可以用来创建发送 SQL 命令到 PostGIS 的 Python
    脚本。在这个菜谱中，你创建了一个 Python 脚本，使用流行的 **JSON** 格式从 [https://openweathermap.org/](https://openweathermap.org/)
    网络服务器查询天气数据，然后使用这些数据更新两个 PostGIS 图层。'
- en: For one of the layers, `cities`, the weather data is used to update the `temperature`
    field using the temperature data of the weather station closest to the city. For
    this purpose, you used an `UPDATE SQL` command. The other layer, `wstations`,
    is updated every time a new weather station is identified from the weather data
    and inserted in the layer. In this case, you used an `INSERT SQL` statement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其中一个图层 `cities`，使用离城市最近的气象站的温度数据来更新 `temperature` 字段。为此，你使用了 `UPDATE SQL`
    命令。另一个图层 `wstations` 在从气象数据中识别到新的气象站并将其插入图层时更新。在这种情况下，你使用了 `INSERT SQL` 语句。
- en: This is a quick overview of the script's behavior (you can find more details
    in the comments within the Python code). In the beginning, a PostgreSQL connection
    is created using the Psycopg `connection` object. The `connection` object is created
    using the main connection parameters (`dbname`, `user`, and `password`, while
    default values for `server name` and `port` are not specified; instead, `localhost`
    and `5432` are used). The connection behavior is set to `auto commit` so that
    any SQL performed by Psycopg will be run immediately and will not be embedded
    in a transaction.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对脚本行为的快速概述（更多详细信息可以在 Python 代码中的注释中找到）。一开始，使用 Psycopg 的 `connection` 对象创建了一个
    PostgreSQL 连接。`connection` 对象是通过主要连接参数（`dbname`、`user` 和 `password`）创建的，而 `server
    name` 和 `port` 的默认值未指定；相反，使用 `localhost` 和 `5432`。连接行为设置为 `auto commit`，这样 Psycopg
    执行的任何 SQL 都将立即运行，而不会嵌入事务中。
- en: Using a cursor, you first iterate all of the records in the `cities` PostGIS
    layer; for each of the cities, you need to get the temperature from the [https://openweathermap.org/](https://openweathermap.org/)
    web server. For this purpose, for each city you make a call to the `GetWeatherData`
    method, passing the coordinates of the city to it. The method queries the server
    using the `requests` library and parses the JSON response using the `simplejson`
    Python library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用游标，你首先迭代 `cities` PostGIS 图层中的所有记录；对于每个城市，你需要从 [https://openweathermap.org/](https://openweathermap.org/)
    网络服务器获取温度。为此，对于每个城市，你调用 `GetWeatherData` 方法，并将城市的坐标传递给它。该方法使用 `requests` 库查询服务器，并使用
    `simplejson` Python 库解析 JSON 响应。
- en: You should send the URL request to a `try...catch` block. This way, if there
    is any issue with the web service (internet connection not available, or any HTTP
    status codes different from 200, or whatever else), the process can safely continue
    with the data of the next city (iteration).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将 URL 请求发送到 `try...catch` 块。这样，如果网络服务（互联网连接不可用、HTTP 状态码不同于 200 或其他任何问题）出现任何问题，进程可以安全地继续使用下一个城市的（迭代）数据。
- en: The JSON response contains, as per the request, the information about the 10
    weather stations closest to the city. You will use the information of the first
    weather station, the closest one to the city, to set the `temperature` field for
    the city.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 响应包含根据请求的信息，关于城市最近的 10 个气象站。你将使用离城市最近的第一个气象站的信息来设置城市的 `temperature` 字段。
- en: You then iterate all of the `station` JSON objects, and by using the `AddWeatherStation`
    method, you create a weather station in the `wstation` PostGIS layer, but only
    if a weather station with the same `id` does not exist.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将迭代所有的 `station` JSON 对象，并使用 `AddWeatherStation` 方法在 `wstation` PostGIS
    图层中创建一个气象站，但前提是不存在具有相同 `id` 的气象站。
- en: Writing PostGIS vector data with OGR Python bindings
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OGR Python 绑定写入 PostGIS 向量数据
- en: In this recipe, you will use Python and the Python bindings of the GDAL/OGR
    library to create a script for geocoding a list of the names of places using one
    of the GeoNames web services ([http://www.geonames.org/export/ws-overview.html](http://www.geonames.org/export/ws-overview.html)).
    You will use the **Wikipedia Fulltext Search** web service ([http://www.geonames.org/export/wikipedia-webservice.html#wikipediaSearch](http://www.geonames.org/export/wikipedia-webservice.html#wikipediaSearch)),
    which for a given search string returns the coordinates of the places matching
    that search string as the output, and some other useful attributes from Wikipedia,
    including the Wikipedia `page title` and `url`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将使用 Python 和 GDAL/OGR 库的 Python 绑定来创建一个脚本来使用 GeoNames 网络服务之一对地点名称列表进行地理编码（[http://www.geonames.org/export/ws-overview.html](http://www.geonames.org/export/ws-overview.html)）。你将使用
    **Wikipedia Fulltext Search** 网络服务（[http://www.geonames.org/export/wikipedia-webservice.html#wikipediaSearch](http://www.geonames.org/export/wikipedia-webservice.html#wikipediaSearch)），该服务对于给定的搜索字符串返回匹配该搜索字符串的地点坐标作为输出，以及来自维基百科的一些其他有用属性，包括维基百科的
    `页面标题` 和 `url`。
- en: The script should first create a PostGIS point layer named `wikiplaces` in which
    all of the locations and their attributes returned by the web service will be
    stored.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先应该创建一个名为 `wikiplaces` 的 PostGIS 点图层，其中将存储由网络服务返回的所有位置及其属性。
- en: This recipe should give you the basis to use other similar web services, such
    as Google Maps, Yahoo! BOSS Geo Services, and so on, to get results in a similar
    way.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱应该为你提供使用其他类似网络服务的基础，例如 Google Maps、Yahoo! BOSS Geo Services 等，以类似的方式获取结果。
- en: 'Before you start, please note the terms of use of GeoNames: [http://www.geonames.org/export/](http://www.geonames.org/export/).
    In a few words, at the time of writing, you have a 30,000 credits'' daily limit
    per application (identified by the `username` parameter); the hourly limit is
    2,000 credits. A credit is a web service request hit for most services.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请注意 GeoNames 的使用条款：[http://www.geonames.org/export/](http://www.geonames.org/export/)。简而言之，在撰写本文时，每个应用程序（通过
    `username` 参数识别）每天有 30,000 个信用额的限制；每小时限制为 2,000 个信用额。信用额是大多数服务的网络服务请求命中。
- en: You will generate the PostGIS table containing the geocoded place names using
    the GDAL/OGR Python bindings ([http://trac.osgeo.org/gdal/wiki/GdalOgrInPython](http://trac.osgeo.org/gdal/wiki/GdalOgrInPython)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 GDAL/OGR Python 绑定（[http://trac.osgeo.org/gdal/wiki/GdalOgrInPython](http://trac.osgeo.org/gdal/wiki/GdalOgrInPython)）生成包含地理编码地点名称的
    PostGIS 表。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To access GeoNames web services, you need to create a user at [http://www.geonames.org/login](http://www.geonames.org/login).
    The user we created for this recipe is `postgis`; you will need to change it with
    your username whenever you query the GeoNames web service URL.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问 GeoNames 网络服务，你需要在 [http://www.geonames.org/login](http://www.geonames.org/login)
    创建一个用户。我们为这个菜谱创建的用户是 `postgis`；每次查询 GeoNames 网络服务 URL 时，你需要将其更改为你的用户名。
- en: If you are using Windows, be sure to have OSGeo4W installed as suggested in
    the initial instructions of this chapter.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，请确保已按照本章初始说明中建议安装 OSGeo4W。
- en: 'If you are using Linux, follow the initial instructions for this chapter, create
    a Python `virtualenv` in order to keep a Python-isolated environment to be used
    for all the Python recipes in this book, and activate it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux，请遵循本章的初始说明，创建一个 Python `virtualenv`，以便为本书中所有 Python 菜谱保持一个独立的
    Python 环境，并激活它：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once activated, if you still haven''t done so, you have to install the `gdal`
    and `simplejson` Python packages needed for this recipe:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦激活，如果你还没有这样做，你必须安装此菜谱所需的 `gdal` 和 `simplejson` Python 包：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Carry out the following steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: First, test the web services and their JSON output yourself with the following
    request (change the `q` and `username` parameters as you wish): [http://api.geonames.org/wikipediaSearchJSON?formatted=true&q=london&maxRows=10&username=postgis&style=full](http://api.geonames.org/wikipediaSearchJSON?formatted=true&q=london&maxRows=10&username=postgis&style=full).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下请求自行测试网络服务和它们的 JSON 输出（根据需要更改 `q` 和 `username` 参数）：[http://api.geonames.org/wikipediaSearchJSON?formatted=true&q=london&maxRows=10&username=postgis&style=full](http://api.geonames.org/wikipediaSearchJSON?formatted=true&q=london&maxRows=10&username=postgis&style=full).
- en: 'You should get the following JSON output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下 JSON 输出：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see from the JSON output for the GeoNames web service, for a given
    query string (a location name), you get a list of Wikipedia pages related to that
    location in JSON format. For each JSON object representing a Wikipedia page, you
    can get access to the attributes, such as the `page title`, `summary`, `url`,
    and the `coordinates` of the location.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您从 GeoNames 网络服务的 JSON 输出中看到的，对于给定的查询字符串（一个位置名称），您会得到一个与该位置相关的 Wikipedia 页面的列表，格式为
    JSON。对于代表 Wikipedia 页面的每个 JSON 对象，您可以访问属性，例如 `page title`（页面标题）、`summary`（摘要）、`url`
    和位置的 `coordinates`（坐标）。
- en: 'Now, create a text file named `working/chp08/names.txt` with the names of places
    you would like to geocode from the Wikipedia Fulltext Search web services. Add
    some place names, for example (in Windows, use a text editor such as Notepad):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `working/chp08/names.txt` 的文本文件，其中包含您希望从 Wikipedia 全文搜索网络服务中地理编码的位置名称。添加一些地点名称，例如（在
    Windows 中，使用记事本等文本编辑器）：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, create a file named `import_places.py` under `working/chp08/` and add
    to it the Python script for this recipe. The following is how the script should
    look (you should be able to follow it by reading the inline comments and the *How
    it works...* section):'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `working/chp08/` 下创建一个名为 `import_places.py` 的文件，并将此菜谱的 Python 脚本添加到其中。以下是如何编写脚本（您应该可以通过阅读内联注释和
    *How it works...* 部分来理解它）：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, execute the Python script:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行 Python 脚本：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/e839b9f9-2cfe-4277-98de-15c07c383925.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e839b9f9-2cfe-4277-98de-15c07c383925.png)'
- en: 'Test whether the table was correctly created and populated using SQL and use
    your favorite GIS desktop tool to display the layer:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SQL 测试表是否正确创建并填充，并使用您喜欢的 GIS 桌面工具显示该层：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/139bfbcb-f27b-4e99-b0d5-d99f60ee79b7.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/139bfbcb-f27b-4e99-b0d5-d99f60ee79b7.png)'
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: How it works...
- en: This Python script uses the `requests` and `simplejson` libraries to fetch data
    from the GeoNames `wikipediaSearchJSON` web service, and the GDAL/OGR library
    to store geographic information inside the PostGIS database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Python 脚本使用 `requests` 和 `simplejson` 库从 GeoNames 的 `wikipediaSearchJSON`
    网络服务获取数据，并使用 GDAL/OGR 库在 PostGIS 数据库中存储地理信息。
- en: First, you create a PostGIS point table to store the geographic data. This is
    made using the GDAL/OGR bindings. You need to instantiate an OGR PostGIS driver
    ([http://www.gdal.org/drv_pg.html](http://www.gdal.org/drv_pg.html)) from where
    it is possible to instantiate a dataset to connect to your `postgis_cookbook`
    database using a specified connection string.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您创建一个 PostGIS 点表来存储地理数据。这是使用 GDAL/OGR 绑定完成的。您需要实例化一个 OGR PostGIS 驱动程序（[http://www.gdal.org/drv_pg.html](http://www.gdal.org/drv_pg.html)），从该驱动程序可以实例化一个数据集以使用指定的连接字符串连接到您的
    `postgis_cookbook` 数据库。
- en: The `update` parameter in the connection string specifies to the GDAL driver
    that you will open the dataset for updating.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串中的 `update` 参数指定 GDAL 驱动程序您将打开数据集以进行更新。
- en: From the PostGIS dataset, we created a PostGIS layer named `wikiplaces` that
    will store points (`geom_type=ogr.wkbPoint`) using the *WGS 84* spatial reference
    system (`srs.ImportFromEPSG(4326)`). When creating the layer, we specified other
    parameters as well, such as `dimension` (`3`, as you want to store the `z` values),
    `GEOMETRY_NAME` (name of the geometric field), and `schema`. After creating the
    layer, you can use the `CreateField` layer method to create all the fields that
    are needed to store the information. Each field will have a specific `name` and
    `datatype` (all of them are `ogr.OFTString` in this case).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PostGIS 数据集中，我们创建了一个名为 `wikiplaces` 的 PostGIS 层，该层将使用 *WGS 84* 空间参考系统（`srs.ImportFromEPSG(4326)`）存储点（`geom_type=ogr.wkbPoint`）。在创建层时，我们还指定了其他参数，例如
    `dimension`（`3`，因为你想存储 `z` 值），`GEOMETRY_NAME`（几何字段的名称）和 `schema`。创建层后，你可以使用 `CreateField`
    层方法创建所有存储信息所需的字段。每个字段都将有一个特定的 `name` 和 `datatype`（在这种情况下，所有这些都是 `ogr.OFTString`）。
- en: After the layer has been created (note that we need to have the `pg_ds` and
    `pg_layer` objects always in context for the whole script, as noted at [http://trac.osgeo.org/gdal/wiki/PythonGotchas](http://trac.osgeo.org/gdal/wiki/PythonGotchas)),
    you can query the GeoNames web services for each place name in the `names.txt`
    file using the `urllib2` library.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 层创建完成后（请注意，我们需要在整个脚本中始终保持`pg_ds`和`pg_layer`对象处于上下文中，正如在[http://trac.osgeo.org/gdal/wiki/PythonGotchas](http://trac.osgeo.org/gdal/wiki/PythonGotchas)中所述），您可以使用`urllib2`库查询`names.txt`文件中每个地点名称的GeoNames网络服务。
- en: We parsed the JSON response using the `simplejson` library, then iterated the
    JSON objects list and added a feature to the PostGIS layer for each of the objects
    in the JSON output. For each element, we created a feature with a point `wkt`
    geometry (using the `lng`, `lat`, and `elevation` object attributes) using the
    `ogr.CreateGeometryFromWkt` method, and updated the other fields using the other
    object attributes returned by GeoNames, using the feature `setField` method (`title`,
    `countryCode`, and so on).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`simplejson`库解析了JSON响应，然后迭代了JSON对象列表，并为JSON输出中的每个对象在PostGIS层中添加了一个特征。对于每个元素，我们使用`ogr.CreateGeometryFromWkt`方法创建了一个具有点`wkt`几何形状的特征（使用`lng`、`lat`和`elevation`对象属性），并使用特征`setField`方法（`title`、`countryCode`等）更新了其他字段，使用GeoNames返回的其他对象属性。
- en: 'You can get more information on programming with GDAL Python bindings by using
    the following great resource by *Chris Garrard*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下由*Chris Garrard*提供的优秀资源获取更多关于使用GDAL Python绑定的编程信息：
- en: '[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)'
- en: Writing PostGIS functions with PL/Python
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PL/Python编写PostGIS函数
- en: In this recipe, you will write a Python function for PostGIS using the PL/Python
    language. The PL/Python procedural language allows you to write PostgreSQL functions
    with the Python language.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将使用PL/Python语言为PostGIS编写一个Python函数。PL/Python过程语言允许您使用Python语言编写PostgreSQL函数。
- en: You will use Python to query the [http://openweathermap.org/](http://openweathermap.org/) web
    services, already used in a previous recipe, to get the weather for a PostGIS
    geometry from within a PostgreSQL function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用Python查询[http://openweathermap.org/](http://openweathermap.org/)网络服务，这些服务已在之前的菜谱中使用，以从PostgreSQL函数内部获取PostGIS几何形状的天气。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Verify your PostgreSQL server installation has PL/Python support. In Windows,
    this should be already included, but this is not the default if you are using,
    for example, Ubuntu 16.04 LTS, so you will most likely need to install it:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的PostgreSQL服务器安装是否具有PL/Python支持。在Windows上，这应该已经包含在内，但如果您使用的是例如Ubuntu 16.04
    LTS，则这不是默认设置，因此您可能需要安装它：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Install PL/Python on the database (you could consider installing it in your
    `template1` database; in this way, every newly created database will have PL/Python
    support by default):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库上安装PL/Python（您可以考虑在`template1`数据库中安装它；这样，每个新创建的数据库都将默认具有PL/Python支持）：
- en: 'You could alternatively add PL/Python support to your database, using the `createlang`
    shell command (this is the only way if you are using PostgreSQL version 9.1 or
    lower):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择使用`createlang` shell命令将PL/Python支持添加到您的数据库中（如果您使用的是PostgreSQL版本9.1或更低版本，这是唯一的方法）：
- en: '`$ createlang plpythonu postgis_cookbook`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ createlang plpythonu postgis_cookbook`'
- en: '`$ psql -U me postgis_cookbook`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ psql -U me postgis_cookbook`'
- en: '`postgis_cookbook=# CREATE EXTENSION plpythonu;`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`postgis_cookbook=# CREATE EXTENSION plpythonu;`'
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Carry out the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: In this recipe, as with the previous one, you will use a [http://openweathermap.org/](http://openweathermap.org/)
    web service to get the temperature for a point from the closest weather station.
    The request you need to run (test it in a browser) is [http://api.openweathermap.org/data/2.5/find?lat=55&lon=37&cnt=10&appid=YOURKEY](http://api.openweathermap.org/data/2.5/find?lat=55&lon=37&cnt=10&appid=YOURKEY).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个菜谱中，就像上一个菜谱一样，您将使用一个[http://openweathermap.org/](http://openweathermap.org/)网络服务来获取从最近的气象站获取的温度。您需要运行的请求（在浏览器中测试它）是[http://api.openweathermap.org/data/2.5/find?lat=55&lon=37&cnt=10&appid=YOURKEY](http://api.openweathermap.org/data/2.5/find?lat=55&lon=37&cnt=10&appid=YOURKEY)。
- en: 'You should get the following JSON output (the closest weather station''s data
    from which you will read the temperature to the point, with the coordinates of
    the given longitude and latitude):'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该得到以下JSON输出（从最近的气象站读取的温度数据，该数据与您提供的经纬度点最接近）：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the following PostgreSQL function in Python, using the PL/Python language:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中使用PL/Python语言创建以下PostgreSQL函数：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, test your function; for example, get the temperature from the weather
    station closest to Wat Pho Templum in Bangkok:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试你的函数；例如，获取曼谷Wat Pho Templum附近气象站的温度：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want to get the temperature for the point features in a PostGIS table,
    you can use the coordinates of each feature''s geometry:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要获取PostGIS表中点特征的温度，你可以使用每个特征的几何体的坐标：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now it would be nice if our function could accept not only the coordinates
    of a point, but also a true PostGIS geometry as well as an input parameter. For
    the temperature of a feature, you could return the temperature of the weather
    station closest to the centroid of the feature geometry. You can easily get this
    behavior using function overloading. Add a new function, with the same name, supporting
    a PostGIS geometry directly as an input parameter. In the body of the function,
    call the previous function, passing the coordinates of the centroid of the geometry.
    Note that in this case, you can write the function without using Python, with
    the PL/PostgreSQL language:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在如果我们的函数能够接受一个点的坐标，同时也能接受一个真正的PostGIS几何体以及一个输入参数那就太好了。对于某个特征的温度，你可以返回离该特征几何体质心最近的气象站的温度。你可以通过函数重载轻松实现这种行为。添加一个新的函数，具有相同的名称，直接支持PostGIS几何体作为输入参数。在函数体中，调用之前的函数，传递几何体质心的坐标。请注意，在这种情况下，你可以使用PL/PostgreSQL语言而不使用Python编写函数：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, test the function, passing a PostGIS geometry to the function:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试这个函数，传递一个PostGIS几何体给函数：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you use the function on a PostGIS layer, you can pass the feature''s geometries
    to the function directly, using the overloaded function written in the PL/PostgreSQL
    language:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在一个PostGIS图层上使用这个函数，你可以直接传递特征的几何体给函数，使用用PL/PostgreSQL语言编写的重载函数：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you wrote a Python function in PostGIS, using the PL/Python
    language. Using Python inside PostgreSQL and PostGIS functions gives you the great
    advantage of being able to use any Python library you wish. Therefore, you will
    be able to write much more powerful functions compared to those written using
    the standard PL/PostgreSQL language.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你使用PL/Python语言在PostGIS中编写了一个Python函数。在PostgreSQL和PostGIS函数中使用Python给你带来了巨大的优势，即能够使用你想要的任何Python库。因此，你将能够编写比使用标准PL/PostgreSQL语言编写的函数更强大的函数。
- en: In fact, in this case, you used the `urllib2` and `simplejson` Python libraries
    to query a web service from within a PostgreSQL function—this would be an impossible
    operation to do using plain PL/PostgreSQL. You have also seen how to overload
    functions in order to provide the function's user a different way to access the
    function, using input parameters in a different way.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这种情况下，你使用了`urllib2`和`simplejson`Python库在PostgreSQL函数中查询一个网络服务——这将是使用纯PL/PostgreSQL无法完成的操作。你也已经看到了如何通过使用不同的输入参数方式来重载函数，以便为函数的用户提供不同的访问函数的方式。
- en: Geocoding and reverse geocoding using the GeoNames datasets
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GeoNames数据集进行地理编码和反向地理编码
- en: In this recipe, you will write two PL/PostgreSQL PostGIS functions that will
    let you perform geocoding and reverse geocoding using the GeoNames datasets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将编写两个PL/PostgreSQL PostGIS函数，这将允许你使用GeoNames数据集执行地理编码和反向地理编码。
- en: GeoNames is a database of place names in the world, containing over 8 million
    records that are available for download free of charge. For the purpose of this
    recipe, you will download a part of the database, load it in PostGIS, and then
    use it within two functions to perform geocoding and reverse geocoding. **Geocoding**
    is the process of finding coordinates from geographical data, such as an address
    or a place name, while **reverse geocoding** is the process of finding geographical
    data, such as an address or place name, from its coordinates.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GeoNames是一个包含世界上地名数据库，包含超过800万条记录，这些记录可以免费下载。为了这个菜谱的目的，你将下载数据库的一部分，将其加载到PostGIS中，然后在使用两个函数进行地理编码和反向地理编码。**地理编码**是从地理数据（如地址或地名）中查找坐标的过程，而**反向地理编码**是从坐标中查找地理数据（如地址或地名）的过程。
- en: You are going to write the two functions using PL/pgSQL, which adds on top of
    the PostgreSQL SQL commands the ability to tie more commands and queries together,
    a bunch of control structures, cursors, error management, and other goodness.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用PL/pgSQL编写这两个函数，它是在PostgreSQL SQL命令的基础上添加了更多的命令和查询组合的能力、一系列控制结构、游标、错误管理和其他优点。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download a GeoNames dataset. At the time of writing, you can find some of the
    datasets ready to be downloaded from [http://download.geonames.org/export/dump/](http://download.geonames.org/export/dump/).
    You may decide which dataset you want to use; if you want to follow this recipe,
    it will be enough to download the Italian dataset, `IT.zip` (included in the book's
    dataset, in the `chp08` directory).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下载GeoNames数据集。在撰写本文时，你可以从[http://download.geonames.org/export/dump/](http://download.geonames.org/export/dump/)下载一些准备好的数据集。你可以决定使用哪个数据集；如果你想遵循这个食谱，下载意大利数据集`IT.zip`（包含在本书的数据集中，位于`chp08`目录中）就足够了。
- en: If you want to download the full GeoNames dataset, you need to download the
    `allCountries.zip` file; it will take longer as it is about 250 MB.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要下载完整的GeoNames数据集，你需要下载`allCountries.zip`文件；由于它大约有250MB，所以下载时间会更长。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Carry out the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Unzip the `IT.zip` file to the `working/chp08` directory. Two files will be
    extracted: the `readme.txt` file that contains information on the GeoNames database
    structure—you can read it to get some more information—and the `IT.txt` file,
    which is a `.csv` file containing all the GeoNames entities for Italy. As suggested
    in the `readme.txt` file, the content of the CSV file is composed of records with
    the following attributes:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IT.zip`文件解压到`working/chp08`目录。将提取两个文件：包含GeoNames数据库结构信息的`readme.txt`文件——你可以阅读它以获取更多信息——以及包含意大利所有GeoNames实体的`.csv`文件`IT.txt`。如`readme.txt`文件中建议的，CSV文件的内容由以下属性组成的记录组成：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Get an overview of this CSV dataset, using `ogrinfo`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ogrinfo`获取此CSV数据集的概览：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/37ab3ab7-3de1-4e6a-8766-fe4fe01b6e85.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37ab3ab7-3de1-4e6a-8766-fe4fe01b6e85.png)'
- en: 'You could query the `IT.txt` file as an OGR entity. For example, analyze one
    of the dataset features, as shown in the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将`IT.txt`文件作为OGR实体查询。例如，分析数据集的一个特征，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](img/d93ac89a-d5aa-40dd-a285-10dc580af64a.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d93ac89a-d5aa-40dd-a285-10dc580af64a.png)'
- en: 'For your purpose, you just need the `name`, `asciiname`, `latitude`, and `longitude`
    attributes. You will import the file to PostGIS using the CSV OGR driver ([http://www.gdal.org/drv_csv.html](http://www.gdal.org/drv_csv.html)).
    Use the `ogr2ogr` command to import this GeoNames dataset in PostGIS:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于你的目的，你只需要`name`、`asciiname`、`latitude`和`longitude`属性。你将使用CSV OGR驱动程序将文件导入PostGIS（[http://www.gdal.org/drv_csv.html](http://www.gdal.org/drv_csv.html)）。使用`ogr2ogr`命令将此GeoNames数据集导入PostGIS：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Try to query the new `geonames` table in PostGIS to see if the process works
    correctly:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试查询PostGIS中的新`geonames`表，以查看过程是否正确工作：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, create a PL/PostgreSQL function that will return the five place names
    closest to the given point and their coordinates (reverse geocoding):'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个PL/PostgreSQL函数，该函数将返回给定点的五个最近地点及其坐标（反向地理编码）：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Query the new function. You can specify the number of results you want by passing
    the optional `num_results` input parameter:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询新函数。你可以通过传递可选的`num_results`输入参数来指定你想要的结果数量：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is the output for this query:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该查询的输出：
- en: '![](img/d3aadd6e-c073-40b7-97f5-6af6abf6c0a9.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3aadd6e-c073-40b7-97f5-6af6abf6c0a9.png)'
- en: 'If you don''t specify the `num``_results` optional parameter, it will default
    to five results:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有指定`num_results`可选参数，它将默认为五个结果：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And you will get the following rows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下行：
- en: '![](img/885f1bfc-c639-4bc3-b80e-820ac913d97e.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/885f1bfc-c639-4bc3-b80e-820ac913d97e.png)'
- en: 'Now, create a PL/pgSQL function that will return a list of place names and
    geometries containing a text search in their name field (geocoding):'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个PL/pgSQL函数，该函数将返回包含其名称字段中文本搜索的地点名称和几何形状的列表（地理编码）：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Query this second function to check if it is working properly:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询第二个函数以检查它是否正常工作：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](img/2c7d1318-9afa-40bf-953b-9ba113f1b229.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c7d1318-9afa-40bf-953b-9ba113f1b229.png)'
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you wrote two PostgreSQL functions to perform geocoding and
    reverse geocoding. For both the functions, you defined a set of input and output
    parameters, and after some PL/PostgreSQL processing, you returned a set of records
    to the function client, given by executing a query.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你编写了两个PostgreSQL函数来执行地理编码和反向地理编码。对于这两个函数，你定义了一组输入和输出参数，并在一些PL/PostgreSQL处理之后，通过执行查询将一组记录返回给函数客户端。
- en: As the input parameters, the `Get_Closest_PlaceNames` function accepts a PostGIS
    geometry and an optional `num_results` parameter that is set to a default of 5
    in case the function caller does not provide it. The output of this function is
    `SETOF RECORD`, which is returned after running a query in the function body (defined
    by the `$$` notation). Here, the query finds the places closest to the centroid
    of the input geometry. This is done using an indexed nearest neighbor search (KNN
    index), a new feature available in PostGIS 2.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入参数，`Get_Closest_PlaceNames`函数接受一个PostGIS几何形状和一个可选的`num_results`参数，如果没有由函数调用者提供，则默认设置为5。这个函数的输出是`SETOF
    RECORD`，在函数体（由`$$`符号定义）中运行查询后返回。在这里，查询找到输入几何形状的重心最近的地点。这是通过索引最近邻搜索（KNN索引）完成的，这是PostGIS
    2中的一项新功能。
- en: The `Find_PlaceNames` function accepts as the input parameters a search string
    to look for and an optional `num_results` parameter, which in this case is also
    set to a default of `5` if not provided by the function caller. The output is
    a `SETOF RECORD`, which is returned after running a query that uses the `to_tsquery`
    PostgreSQL text search function. The results of the query are the places from
    the database that contain the `search_string` value in the name field.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find_PlaceNames`函数接受作为输入参数的搜索字符串以及一个可选的`num_results`参数，在此情况下，如果没有由函数调用者提供，则默认设置为`5`。输出是一个`SETOF
    RECORD`，在运行使用`to_tsquery` PostgreSQL文本搜索函数的查询后返回。查询的结果是从数据库中包含在名称字段中的`search_string`值的地点。'
- en: Geocoding using the OSM datasets with trigrams
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OSM数据集和三元组进行地理编码
- en: 'In this recipe, you will use **OpenStreetMap** streets'' datasets imported
    in PostGIS to implement a very basic Python class in order to provide geocoding
    features to the class'' consumer. The geocode engine will be based on the implementation
    of the PostgreSQL trigrams provided by the `contrib` module of PostgreSQL: `pg_trgm`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将使用导入到PostGIS中的**OpenStreetMap**街道数据集来实现一个基本的Python类，以便为类的消费者提供地理编码功能。地理编码引擎将基于PostgreSQL的`contrib`模块提供的PostgreSQL三元组的实现：`pg_trgm`。
- en: A trigram is a group of three consecutive characters contained in a string,
    and it is a very effective way to measure the similarity of two strings by counting
    the number of trigrams they have in common.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 三元组是字符串中包含的三个连续字符的组合，通过计算两个字符串共有的三元组的数量，这是一种非常有效的方式来衡量两个字符串的相似度。
- en: This recipe aims to be a very basic sample to implement some kinds of geocoding
    functionalities (it will just return one or more points from a street name), but
    it could be extended to support more advanced features.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱旨在提供一个非常基础的示例来实现一些地理编码功能（它将仅从街道名称返回一个或多个点），但它可以被扩展以支持更高级的功能。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, make sure you have the latest GDAL, at least version 1.10,
    as you will use it with the `ogr2ogr` the OGR OSM driver ([http://www.gdal.org/drv_osm.html](http://www.gdal.org/drv_osm.html)):'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，请确保你有最新的GDAL，至少版本1.10，因为你将使用`ogr2ogr` OGR OSM驱动程序（[http://www.gdal.org/drv_osm.html](http://www.gdal.org/drv_osm.html)）：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you will use PostgreSQL trigrams, install the PostgreSQL `contrib` package
    (which includes `pg_trgm`). The Windows EDB installer should already include this.
    In an Ubuntu 12.4 box, the following command will help you to do it:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你将使用PostgreSQL三元组，你需要安装PostgreSQL的`contrib`包（它包括`pg_trgm`）。Windows EDB安装程序应该已经包括这个包。在Ubuntu
    12.4盒子上，以下命令将帮助你完成它：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Make sure to add the `pg_trgm` extension to the database:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将`pg_trgm`扩展添加到数据库中：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will need to use some OSM datasets included in the source for this chapter.
    (in the `data/chp08` book's dataset directory). If you are using Windows, be sure
    to have installed the OSGeo4W suite, as suggested in the initial instructions
    for this chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要使用包含在本章源中的某些OSM数据集。（在`data/chp08`书籍数据集目录中）。如果你使用Windows，请确保已经安装了如本章初始说明中所建议的OSGeo4W套件。
- en: 'If you are using Linux, follow the initial instructions for this chapter and
    create a Python virtual environment in order to keep a Python-isolated environment
    to be used for all the Python recipes of this book. Then, activate it as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux，请遵循本章的初始说明，创建一个 Python 虚拟环境，以保持一个用于本书所有 Python 脚本的 Python 隔离环境。然后，按照以下方式激活它：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the environment has been activated, if you still haven''t done so, you
    can install the Python packages needed for this recipe:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦环境被激活，如果你还没有这样做，你可以安装这个菜谱所需的 Python 包：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Carry out the following steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, check out how the OSM `.pbf` file is built using `ogrinfo`. PBF is a
    binary format intended as an alternative to the OSM XML format, mainly because
    it is much smaller. As you must have noticed, it is composed of several layers—you
    will export the `lines` layer to PostGIS as that layer contains the street names
    that you will use for the overall geocoding process:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `ogrinfo` 检查 OSM `.pbf` 文件是如何构建的。PBF 是一种二进制格式，旨在作为 OSM XML 格式的替代品，主要是因为它要小得多。正如你可能已经注意到的，它由几个层组成——你将导出
    `lines` 层到 PostGIS，因为这个层包含你将用于整体地理编码过程的街道名称：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Export the lines'' OSM features to a PostGIS table, using `ogr2ogr` (`ogr2ogr`,
    as always, will implicitly create the GiST index that is needed by the `pg_trgm`
    module to run):'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ogr2ogr` 将行 OSM 特征导出到 PostGIS 表中（`ogr2ogr`，像往常一样，将隐式创建 `pg_trgm` 模块运行所需的
    GiST 索引）：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now try a trigram matching to identify the road names similar to a given search
    text, using a query such as the following. Note that the `similarity` function
    returns a value that decreases from `1` to `0` as the similarity of the word decreases
    (with `1`, the strings are identical; with `0`, they are totally different):'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试使用以下查询进行三元组匹配以识别与给定搜索文本相似的街道名称。注意，`similarity` 函数返回一个值，该值随着单词相似性的降低而从 `1`
    减少到 `0`（`1` 时字符串相同；`0` 时字符串完全不同）：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![](img/e54ab1a5-61ee-44b3-b120-653b6206aaa8.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e54ab1a5-61ee-44b3-b120-653b6206aaa8.png)'
- en: 'As a variant, you will use the following query to complete the recipe (in this
    case, when the weight is 0, the strings are identical):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为变体，你将使用以下查询来完成菜谱（在这种情况下，当权重为 0 时，字符串相同）：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](img/6075ff38-c013-4785-9269-c431ec2e6447.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6075ff38-c013-4785-9269-c431ec2e6447.png)'
- en: 'We will use the last query as the SQL core of a Python class, which will provide
    geocoding features to the consumer, using the layer we just imported in PostGIS
    (`chp08.osm_roads`). First, create a file named `osmgeocoder.py` and add the following
    class to it:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用最后一个查询作为 Python 类的 SQL 核心部分，该类将为消费者提供地理编码功能，使用我们刚刚导入到 PostGIS 中的层（`chp08.osm_roads`）。首先，创建一个名为
    `osmgeocoder.py` 的文件，并将以下类添加到其中：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, add the `__main__` check to provide the class user a method to directly
    use the geocoder from the command line:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加 `__main__` 检查，为类用户提供一个直接从命令行使用地理编码器的方法：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now you can test the class by calling the script, as shown here:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以通过调用脚本测试这个类，如下所示：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So, now that you wrote a class that can be used to geocode street names, let''s
    suppose that another user wants to use it to geocode a file with a list of street
    names in order to import it in a new PostGIS layer. Here is how the user could
    do this (try this as well). First, create a `streets.txt` file with a list of
    street names; for example:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在你已经编写了一个可以用于地理编码街道名称的类，假设另一个用户想要使用它来地理编码一个包含街道名称列表的文件，以便将其导入新的 PostGIS
    层。以下是用户可以这样做的方法（也尝试一下）。首先，创建一个名为 `streets.txt` 的文件，其中包含街道名称列表；例如：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, create a file named `geocode_streets.py` and add this Python code to it
    (you are going to use the `OSMGeocoder` class to geocode the street name list,
    and GDAL/OGR to create a new PostGIS layer for storing the geocoded points for
    the street names):'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `geocode_streets.py` 的文件，并将以下 Python 代码添加到其中（你将使用 `OSMGeocoder` 类来地理编码街道名称列表，并使用
    GDAL/OGR 创建一个新的 PostGIS 层来存储街道名称的地理编码点）：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the preceding script, and then check with your favorite PostgreSQL client
    or with a GIS desktop tool if the points for the street names were correctly geocoded:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的脚本，然后使用你喜欢的 PostgreSQL 客户端或 GIS 桌面工具检查街道名称的点是否正确进行了地理编码：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For this recipe, you first imported an OSM dataset to PostGIS with `ogr2ogr`,
    using the GDAL OSM driver.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你首先使用 GDAL OSM 驱动程序，通过 `ogr2ogr` 将 OSM 数据集导入到 PostGIS 中。
- en: Then, you created a Python class, `OSMGeocoder`, to provide very basic support
    to the class consumer for geocoding street names, using the OSM data imported
    in PostGIS. For this purpose, you used the trigram support included in PostgreSQL
    with the `pg_trgm contrib` module.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建了一个 Python 类，`OSMGeocoder`，为类消费者提供对地理编码街道名称的基本支持，使用的是导入到 PostGIS 中的 OSM
    数据。为此，你使用了 PostgreSQL 中的 trigram 支持以及 `pg_trgm contrib` 模块。
- en: 'The class that you have written is mainly composed of two methods: the `__init__`
    method, where the connection parameters must be passed in order to instantiate
    an `OSMGeocoder` object, and the `geocode` method. The `geocode` method accepts
    an input parameter, `placename`, and creates a connection to the PostGIS database
    using the Psycopg2 library in order to execute a query to find the streets in
    the database with a name similar to the `placename` parameter.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的类主要由两个方法组成：`__init__` 方法，其中必须传入连接参数以实例化一个 `OSMGeocoder` 对象，以及 `geocode`
    方法。`geocode` 方法接受一个输入参数 `placename`，并使用 Psycopg2 库连接到 PostGIS 数据库，以执行查询以找到与 `placename`
    参数名称相似的街道。
- en: The class can be consumed both from the command line, using the `__name__ ==
    '__main__'` code block, or from an external Python code. You tried both approaches.
    In the latter, you created another Python script, where you imported the `OSMGeocoder`
    class combined with the GDAL/OGR Python bindings to generate a new PostGIS point
    layer with features resulted from a list of geocoded street names.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以从命令行使用 `__name__ == '__main__'` 代码块或从外部 Python 代码中消费。你尝试了这两种方法。在后一种方法中，你创建了一个新的
    Python 脚本，在其中导入了 `OSMGeocoder` 类，并结合 GDAL/OGR Python 绑定来生成一个新的 PostGIS 点层，该层包含来自地理编码街道名称列表的特征。
- en: Geocoding with geopy and PL/Python
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 geopy 和 PL/Python 进行地理编码
- en: In this recipe, you will geocode addresses using web geocoding APIs, such as
    Google Maps, Yahoo! Maps, Geocoder, GeoNames, and so on. Be sure to read the terms
    of service of these APIs carefully before using them in production.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将使用网络地理编码 API（如 Google Maps、Yahoo! Maps、Geocoder、GeoNames 等）来地理编码地址。在使用这些
    API 进行生产之前，请务必仔细阅读其服务条款。
- en: The `geopy` Python library ([https://github.com/geopy/geopy](https://github.com/geopy/geopy))
    offers convenient uniform access to all of these web services. Therefore, you
    will use it to create a PL/Python PostgreSQL function that can be used in your
    SQL commands to query all of these engines.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`geopy` Python 库（[https://github.com/geopy/geopy](https://github.com/geopy/geopy)）提供了对所有这些网络服务的方便统一访问。因此，你将使用它来创建一个
    PL/Python PostgreSQL 函数，该函数可以在你的 SQL 命令中使用，以查询所有这些引擎。'
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install `geopy` globally. (You cannot use a virtual environment in this case,
    as the user running the PostgreSQL service needs to access it on its Python path.)
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局安装 `geopy`。在这种情况下，你不能使用虚拟环境，因为运行 PostgreSQL 服务的用户需要通过其 Python 路径访问它。
- en: 'In a Debian/Ubuntu box, it is as easy as typing the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian/Ubuntu 系统中，操作就像输入以下命令一样简单：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In Windows, you can use the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，你可以使用以下命令：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you still have not used PL/Python, verify whether your PostgreSQL server
    installation supports it. The Windows EDB installer should already include support,
    but this is not the default if you are using, for example, Ubuntu 16.04 LTS, so
    you most likely need to install it:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有使用 PL/Python，请验证你的 PostgreSQL 服务器安装是否支持它。Windows EDB 安装程序应该已经包含了支持，但如果你使用的是例如
    Ubuntu 16.04 LTS，那么这并不是默认设置，所以你很可能需要安装它：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Install PL/Python in the database (you could consider installing it in the
    `template1` database; this way, every newly created database will have PL/Python
    support by default):'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库中安装 PL/Python（你可以考虑在 `template1` 数据库中安装它；这样，每个新创建的数据库都将默认支持 PL/Python）：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Alternatively, you could add PL/Python support to your database, using the `createlang` shell
    command (this is the only way if you are using PostgreSQL Version 9.1 and lower):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用 `createlang` 命令行来为你的数据库添加 PL/Python 支持（如果你使用的是 PostgreSQL 版本 9.1 及以下，这是唯一的方法）：
- en: '`$ createlang plpythonu postgis_cookbook`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ createlang plpythonu postgis_cookbook`'
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Carry out the following steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'As the first test, open your favorite SQL client (`psql` or `pgAdmin`), and
    write a very basic PL/Python function, just using the GoogleV3 geocoding API with
    `geopy`. The function will accept the address string as an input parameter and,
    after importing `geopy`, it will instantiate a `geopy` Google Geocoder, run the
    geocode process, and then return the point geometry, using the `ST_GeomFromText`
    function and the `geopy` output:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一个测试，打开你喜欢的 SQL 客户端（`psql` 或 `pgAdmin`），编写一个非常基本的 PL/Python 函数，仅使用 `geopy`
    的 GoogleV3 地理编码 API。该函数将接受地址字符串作为输入参数，并在导入 `geopy` 后，实例化一个 `geopy` Google 地理编码器，运行地理编码过程，然后使用
    `ST_GeomFromText` 函数和 `geopy` 输出返回点几何：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After creating the function, try to test it:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数后，尝试测试它：
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, you will make the function a little bit more sophisticated. First, you
    will add another input parameter to let the user specify the geocode API engine
    (defaulting to GoogleV3). Then, using the Python `try...except` block, you will
    try to add some kind of error management in case the geopy Geocoder cannot manage
    to return valid results for any reason:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将使函数变得更加复杂。首先，你将添加另一个输入参数，让用户指定地理编码 API 引擎（默认为 GoogleV3）。然后，使用 Python 的
    `try...except` 块，你将尝试添加某种错误管理，以防 geopy 地理编码器无法返回有效结果：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Test the new version of your function without specifying the parameter for
    the API. In such a case, it should default to the Google API:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不指定 API 参数的情况下测试你函数的新版本。在这种情况下，它应该默认为 Google API：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you test it by specifying a different API, it should return the result processed
    for the given API. For example:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你通过指定不同的 API 进行测试，它应该返回针对给定 API 处理的结果。例如：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As a bonus step, create a table in PostgreSQL with street addresses, and generate
    a new point PostGIS layer storing the geocoded points returned by the Geocode
    function.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为额外步骤，在 PostgreSQL 中创建一个包含街道地址的表，并生成一个新的点 PostGIS 层，存储 Geocode 函数返回的地理编码点。
- en: How it works...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You wrote a PL/Python function to geocode an address. For this purpose, you
    used the `geopy` Python library, which lets you query several geocoding APIs in
    the same manner.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写了一个 PL/Python 函数来对地址进行地理编码。为此，你使用了 `geopy` Python 库，它允许你以相同的方式查询多个地理编码 API。
- en: Using geopy, you need to instantiate a `geocoder` object with a given API and
    query it to get the results, such as a place name and a couple of coordinates.
    You can use the `plpy` module utilities to run a query on the database using the
    PostGIS `ST_GeomFromText` function, and log informative messages and warnings
    for the user.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 geopy，你需要使用给定的 API 实例化一个 `geocoder` 对象，并查询它以获取结果，例如地点名称和一对坐标。你可以使用 `plpy`
    模块工具在数据库上运行查询，使用 PostGIS 的 `ST_GeomFromText` 函数，并为用户记录信息性消息和警告。
- en: If the geocoding process fails, you return a `NULL` geometry to the user with
    a warning message, using a `try..except` Python block.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果地理编码过程失败，你将使用 `try..except` Python 块向用户返回一个带有警告信息的 `NULL` 几何形状。
- en: Importing NetCDF datasets with Python and GDAL
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 和 GDAL 导入 NetCDF 数据集
- en: In this recipe, you will write a Python script to import data from the NetCDF
    format to PostGIS.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将编写一个 Python 脚本来从 NetCDF 格式导入数据到 PostGIS。
- en: NetCDF is an open standard format, widely used for scientific applications,
    and can contain multiple raster datasets, each composed of a spectrum of bands.
    For this purpose, you will use the GDAL Python bindings and the popular NumPy
    ([http://www.numpy.org/](http://www.numpy.org/)) scientific library.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: NetCDF 是一个开放标准格式，广泛用于科学应用，可以包含多个栅格数据集，每个数据集由一系列波段组成。为此，你将使用 GDAL Python 绑定和流行的
    NumPy ([http://www.numpy.org/](http://www.numpy.org/)) 科学库。
- en: Getting ready
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you are using Windows, be sure to install OSGeo4W, as suggested in the initial
    instructions for this chapter. This will include Python and GDAL Python bindings
    with NumPy support.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Windows，请确保安装 OSGeo4W，正如本章初始说明中所建议的。这将包括 Python 和 GDAL Python 绑定，以及支持
    NumPy。
- en: 'For Linux users, in case you did not do it yet, follow the initial instructions
    for this chapter and create a Python virtual environment in order to keep a Python-isolated
    environment to be used for all the Python recipes in this book. Then, activate
    it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 用户，如果你还没有这样做，请遵循本章初始说明，创建一个 Python 虚拟环境，以保持一个用于本书中所有 Python 脚本的 Python
    隔离环境。然后，激活它：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For this recipe, you need the GDAL Python bindings and NumPy, the latter being
    needed by a GDAL method (`ReadAsArray`) for arrays. In the most likely case, you
    have already installed GDAL in your virtual environment as you have been using
    it for other recipes, so be sure to remove it and reinstall it after installing
    NumPy. In fact, GDAL needs to be compiled with NumPy support if you want to use
    its array''s features:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，您需要GDAL Python绑定和NumPy，后者是GDAL方法（`ReadAsArray`）所需的数组。在最可能的情况下，您已经将GDAL安装在了您的虚拟环境中，因为您一直在使用它来运行其他菜谱，所以请确保在安装NumPy后将其移除并重新安装。实际上，如果您想使用其数组功能，GDAL需要与NumPy支持一起编译：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For the purpose of this recipe, you will use a sample dataset from NOAA **Earth
    System Research Laboratory** (**ESRL**). The excellent ESRL web portal offers
    a plethora of data in the NetCDF format to be freely downloaded. For example,
    download the following dataset from the ESRL CPC Soil Moisture data repository
    (you can find, as usual, a copy of this dataset in the book's dataset directory
    for this chapter): [https://www.esrl.noaa.gov/psd/data/gridded/data.cpcsoil.html](https://www.esrl.noaa.gov/psd/data/gridded/data.cpcsoil.html).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了这个菜谱的目的，您将使用NOAA **地球系统研究实验室**（**ESRL**）的样本数据集。ESRL的优秀网络门户提供了大量NetCDF格式的数据，可以免费下载。例如，从ESRL
    CPC土壤湿度数据存储库下载以下数据集（您可以在本书的数据集目录中找到这个数据集的副本）：[https://www.esrl.noaa.gov/psd/data/gridded/data.cpcsoil.html](https://www.esrl.noaa.gov/psd/data/gridded/data.cpcsoil.html)。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Carry out the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'As the first step, investigate the NetCDF format of the dataset you downloaded
    using `gdalinfo`. This kind of dataset is composed of several subdatasets, as
    you may have realized by looking at the `gdalinfo` output:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，使用`gdalinfo`调查您下载的数据集的NetCDF格式。这类数据集由几个子数据集组成，您可能已经通过查看`gdalinfo`输出意识到了这一点：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![](img/595b0036-e52e-4066-bd6b-84032572cfb1.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/595b0036-e52e-4066-bd6b-84032572cfb1.png)'
- en: 'Use `gdalinfo` to investigate one of the file''s subdatasets. The syntax that
    the NetCDF GDAL driver ([http://www.gdal.org/frmt_netcdf.html](http://www.gdal.org/frmt_netcdf.html))
    uses is to append a colon followed by the variable name at the end of the filename.
    For example, try to figure out how many bands the `soilw` subdataset is composed
    of. This subdataset, representing `lwe_thickness_of_soil_moisture_content`, is
    composed of 12 bands. Each band, according to the information derived by its metadata,
    represents the CPC Monthly Soil Moisture for a given month. The month is identified
    by the `NETCDF_DIM_time` metadata value, which is the number of days from the
    beginning of the year (`0` for January, `31` for February, `59` for March, and
    so on):'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gdalinfo`调查文件的一个子数据集。NetCDF GDAL驱动程序（[http://www.gdal.org/frmt_netcdf.html](http://www.gdal.org/frmt_netcdf.html)）使用的语法是在文件名末尾附加一个冒号，后跟变量名。例如，尝试找出`soilw`子数据集由多少个波段组成。这个子数据集代表`lwe_thickness_of_soil_moisture_content`，由12个波段组成。根据其元数据获得的信息，每个波段代表给定月份的CPC月度土壤湿度。月份由`NETCDF_DIM_time`元数据值标识，这是从年初开始的天数（`1月为0`，`2月为31`，`3月为59`，等等）：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![](img/91f75db2-f04e-488e-927f-034fcabc25f8.png)'''
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/91f75db2-f04e-488e-927f-034fcabc25f8.png)'
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'What you are going to do is create a Python script using GDAL and NumPy. You
    will read a given NetCDF dataset, iterate its subdatasets, and then iterate each
    subdataset''s bands. For each subdataset, you will create a point PostGIS layer,
    and you will add a field for each band in order to store the band values in the
    layer table. Then, you will iterate the band''s cells, and for each cell, you
    will add a point in the layer with the corresponding band''s values. Therefore,
    create a `netcdf2postgis.py` file and add the following Python code to it:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将要执行的操作是创建一个使用GDAL和NumPy的Python脚本。您将读取一个给定的NetCDF数据集，迭代其子数据集，然后迭代每个子数据集的波段。对于每个子数据集，您将创建一个点PostGIS层，并为每个波段添加一个字段以在层表中存储波段值。然后，您将迭代波段的单元格，并为每个单元格在层中添加一个带有相应波段值的点。因此，创建一个`netcdf2postgis.py`文件，并将以下Python代码添加到其中：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To run the `netcdf2postgis` method from the command line, add the entry point
    for the script. The code will check whether the script user is correctly using
    the three required parameters, which are the NetCDF file path, the GDAL PostGIS
    connection string, and a prefix/suffix to use for table names in PostGIS:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从命令行运行`netcdf2postgis`方法，请添加脚本的入口点。代码将检查脚本用户是否正确使用了三个必需的参数，这些参数是NetCDF文件路径、GDAL
    PostGIS连接字符串以及用于PostGIS中表名的前缀/后缀：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Run the script. Be sure to use the correct NetCDF file path, GDAL PostGIS connection
    string (check the format at [http://www.gdal.org/drv_pg.html](http://www.gdal.org/drv_pg.html)),
    and a table prefix that has to be appended to the table names for tables that
    will be created in PostGIS:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。请确保使用正确的 NetCDF 文件路径、GDAL PostGIS 连接字符串（请检查格式在 [http://www.gdal.org/drv_pg.html](http://www.gdal.org/drv_pg.html)），以及必须附加到将在
    PostGIS 中创建的表名的表前缀：
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'At the end of the process, check the results by opening one of the output PostGIS
    tables using your favorite GIS desktop tool. The following screenshot shows how
    it looks in the QGIS `soilw` layer with the original NetCDF dataset behind it:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在过程结束时，通过使用您最喜欢的 GIS 桌面工具打开其中一个输出 PostGIS 表来检查结果。以下截图显示了它在 QGIS `soilw` 图层中的样子，其背后是原始的
    NetCDF 数据集：
- en: '![](img/c91741bf-91cd-4ad3-8fac-98b45e2400ee.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c91741bf-91cd-4ad3-8fac-98b45e2400ee.png)'
- en: How it works...
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have used Python with GDAL and NumPy in order to create a command-line utility
    to import a NetCDF dataset into PostGIS.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用 Python 和 GDAL 以及 NumPy 创建了一个命令行实用程序，用于将 NetCDF 数据集导入到 PostGIS。
- en: A NetCDF dataset is composed of multiple subdatasets, and each subdataset is
    composed of multiple raster bands. Each band is composed of cells. This structure
    should be clear to you after investigating a sample NetCDF dataset using the `gdalinfo`
    GDAL command tool.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: NetCDF 数据集由多个子数据集组成，每个子数据集由多个栅格波段组成。每个波段由单元格组成。在调查一个示例 NetCDF 数据集后，使用 `gdalinfo`
    GDAL 命令工具，这种结构应该对您来说很清晰。
- en: There are several approaches to exporting cell values to PostGIS. The approach
    you adopted here is to generate a PostGIS point layer for each subdataset, which
    is composed of one field for each subdataset band. You then iterated the raster
    cells and appended a point to the PostGIS layer with the values read from each
    cell band.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将单元格值导出到 PostGIS。您在这里采用的方法是为每个子数据集生成一个 PostGIS 点图层，该图层由每个子数据集波段的一个字段组成。然后，您迭代栅格单元格，并将从每个单元格波段读取的值附加到
    PostGIS 图层中。
- en: The way you do this with Python is by using the GDAL Python bindings. For reading,
    you open the NetCDF dataset, and for updating, you open the PostGIS database,
    using the correct GDAL and OGR drivers. Then, you iterate the NetCDF subdatasets,
    using the `GetSubDatasets` method, and create a PostGIS table named `NetCDF subdataset
    variable` (with the prefix) for each subdataset, using the `CreateLayer` method.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 Python 的方式是通过使用 GDAL Python 绑定。对于读取，您打开 NetCDF 数据集，对于更新，您打开 PostGIS 数据库，使用正确的
    GDAL 和 OGR 驱动程序。然后，您使用 `GetSubDatasets` 方法迭代 NetCDF 子数据集，并使用 `CreateLayer` 方法为每个子数据集创建一个名为
    `NetCDF 子数据集变量`（带有前缀）的 PostGIS 表。
- en: For each subdataset, you iterate its bands, using the `GetRasterBand` method.
    To read each band, you run the `ReadAsArray` method which uses NumPy to get the
    band as an array.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个子数据集，您使用 `GetRasterBand` 方法迭代其波段。为了读取每个波段，您运行 `ReadAsArray` 方法，该方法使用 NumPy
    将波段作为数组获取。
- en: For each band, you create a field in the PostGIS layer with the correct field
    data type that will be able to store the band's values. To choose the correct
    data type, you investigate the band's data type, using the `DataType` property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个波段，您在 PostGIS 图层中创建一个字段，该字段具有正确的字段数据类型，可以存储波段的值。为了选择正确的数据类型，您调查波段的数据类型，使用
    `DataType` 属性。
- en: Finally, you iterate the raster cells, by reading the correct *x* and *y* coordinates
    using the subdataset transform parameters, available via the `GetGeoTransform`
    method. For each cell, you create a point with the `CreateGeometryFromWkt` method,
    then set the field values, and read from the band array using the `SetField` feature
    method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您通过使用子数据集变换参数（通过 `GetGeoTransform` 方法获取）读取正确的 *x* 和 *y* 坐标来迭代栅格单元格。对于每个单元格，您使用
    `CreateGeometryFromWkt` 方法创建一个点，然后设置字段值，并使用 `SetField` 功能方法从波段数组中读取。
- en: Finally, you append the new point to the PostGIS layer using the `CreateFeature`
    method.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您使用 `CreateFeature` 方法将新点附加到 PostGIS 图层。
