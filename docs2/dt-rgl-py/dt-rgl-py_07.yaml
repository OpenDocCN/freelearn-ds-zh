- en: '*Chapter 7*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*'
- en: Advanced Web Scraping and Data Gathering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级网络爬虫和数据收集
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Make use of `requests` and `BeautifulSoup` to read various web pages and gather
    data from them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `requests` 和 `BeautifulSoup` 读取各种网页并从中收集数据
- en: Perform read operations on XML files and the web using an Application Program
    Interface (API)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序程序接口 (API) 对 XML 文件和网页执行读取操作
- en: Make use of regex techniques to scrape useful information from a large and messy
    text corpus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用正则表达式技术从大量杂乱无章的文本语料库中抓取有用信息
- en: In this chapter, you will learn how to gather data from web pages, XML files,
    and APIs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何从网页、XML 文件和 API 中收集数据。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: The previous chapter covered how to create a successful data wrangling pipeline.
    In this chapter, we will build a real-life web scraper using all of the techniques
    that we have learned so far. This chapter builds on the foundation of `BeautifulSoup`
    and introduces various methods for scraping a web page and using an API to gather
    data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了如何创建一个成功的数据整理管道。在本章中，我们将使用我们迄今为止所学到的所有技术构建一个实际的网络爬虫。本章建立在 `BeautifulSoup`
    的基础上，并介绍了各种抓取网页和使用 API 收集数据的方法。
- en: The Basics of Web Scraping and the Beautiful Soup Library
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络爬虫和 Beautiful Soup 库的基础
- en: 'In today''s connected world, one of the most valued and widely used skill for
    a data wrangling professional is the ability to extract and read data from web
    pages and databases hosted on the web. Most organizations host data on the cloud
    (public or private), and the majority of web microservices these days provide
    some kind of API for the external users to access data:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今这个互联互通的世界里，对于数据整理专业人士来说，最宝贵和最广泛使用的技能之一是能够从托管在网上的网页和数据库中提取和读取数据。大多数组织将数据托管在云端（公共或私有），而如今的大多数网络微服务都为外部用户提供了一些类型的
    API 以访问数据：
- en: '![Figure 7.1: Data Wrangling HTTP request and XML/JSON reply](img/C11065_07_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：数据整理 HTTP 请求和 XML/JSON 响应](img/C11065_07_01.jpg)'
- en: 'Figure 7.1: Data wrangling HTTP request and an XML/JSON reply'
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.1：数据整理 HTTP 请求和 XML/JSON 响应
- en: It is necessary that, as a data wrangling engineer, you know about the structure
    of web pages and Python libraries so that you are able to extract data from a
    web page. The World Wide Web is an ever-growing, ever-changing universe, in which
    different data exchange protocols and formats are used. A few of these are widely
    used and have become standard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据整理工程师，了解网页结构和 Python 库的结构是必要的，这样你才能从网页中提取数据。万维网是一个不断增长、不断变化的宇宙，其中使用了不同的数据交换协议和格式。其中一些被广泛使用并已成为标准。
- en: Libraries in Python
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 库
- en: Python comes equipped with built-in modules, such as `urllib 3`, which that
    can place HTTP requests over the internet and receive data from the cloud. However,
    these modules operate at a lower level and require deeper knowledge of HTTP protocols,
    encoding, and requests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 配备了内置模块，如 `urllib 3`，这些模块可以在互联网上放置 HTTP 请求并从云端接收数据。然而，这些模块在较低级别运行，需要更深入地了解
    HTTP 协议、编码和请求。
- en: 'We will take advantage of two Python libraries in this chapter: `Requests`
    and `BeautifulSoup`. To avoid dealing with HTTP methods on a lower level, we will
    use the `Requests` library. It is an API built on top of pure Python web utility
    libraries, which makes placing HTTP requests easy and intuitive.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用两个 Python 库：`Requests` 和 `BeautifulSoup`。为了避免在较低级别处理 HTTP 方法，我们将使用
    `Requests` 库。它是一个建立在纯 Python 网络实用库之上的 API，这使得放置 HTTP 请求变得简单直观。
- en: '**BeautifulSoup** is one of the most popular HTML parser packages. It parses
    the HTML content you pass on and builds a detailed tree of all tags and markups
    within the page for easy and intuitive traversal. This tree can be used by a programmer
    to look for certain markup elements (for example, a table, a hyperlink, or a blob
    of text within a particular div ID) to scrape useful data.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**BeautifulSoup** 是最受欢迎的 HTML 解析包之一。它解析你传递的 HTML 内容，并在页面内构建一个详细的标签和标记树，以便于直观地遍历。这个树可以被程序员用来查找特定的标记元素（例如，一个表格、一个超链接或特定
    div ID 内的文本块）以抓取有用的数据。'
- en: 'Exercise 81: Using the Requests Library to Get a Response from the Wikipedia
    Home Page'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 81：使用 Requests 库从维基百科主页获取响应
- en: The Wikipedia home page consists of many elements and scripts, all of which
    are a mix of HTML, CSS, and JavaScript code blocks. To read the home page of Wikipedia
    and extract some useful textual information, we need to move step by step, as
    we are not interested in all of the code or markup tags; only some selected portions
    of text.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科主页由许多元素和脚本组成，这些都是HTML、CSS和JavaScript代码块的混合。为了读取维基百科的主页并提取一些有用的文本信息，我们需要逐步进行，因为我们不感兴趣的是所有代码或标记标签；只对文本的某些选定部分感兴趣。
- en: In this exercise, we will peel off the layers of HTML/CSS/JavaScript to pry
    away the information we are interested in.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将剥离HTML/CSS/JavaScript层，以获取我们感兴趣的信息。
- en: 'Import the `requests` library:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`requests`库：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Assign the home page URL to a variable, `wiki_home`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主页URL分配给一个变量，`wiki_home`：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the `get` method from the `requests` library to get a response from this
    page:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`requests`库的`get`方法从该页面获取响应：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To get information about the response object, enter the following code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取响应对象的信息，请输入以下代码：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is a model data structure that's defined in the `requests` library.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在`requests`库中定义的模型数据结构。
- en: The web is an extremely dynamic place. It is possible that the home page of
    Wikipedia will have changed by the time somebody uses your code, or that a particular
    web server will be down and your request will essentially fail. If you proceed
    to write more complex and elaborate code without checking the status of your request,
    then all that subsequent work will be fruitless.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网是一个极其动态的地方。有可能在某人使用你的代码时，维基百科的主页已经改变，或者特定的Web服务器可能已经关闭，你的请求将基本上失败。如果你在未检查请求状态的情况下继续编写更复杂和详尽的代码，那么所有后续的工作都将徒劳无功。
- en: 'A web page request generally comes back with various codes. Here are some of
    the common codes you may encounter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Web页面请求通常会返回各种代码。以下是一些你可能遇到的常见代码：
- en: '![Figure 7.2: Web requests and their description](img/C11065_07_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：Web请求及其描述](img/C11065_07_02.jpg)'
- en: 'Figure 7.2: Web requests and their description'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.2：Web请求及其描述
- en: So, we write a function to check the code and print out messages as needed.
    These kinds of small helper/utility functions are incredibly useful for complex
    projects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们编写一个函数来检查代码并根据需要打印出消息。这类小型辅助/实用函数对于复杂项目来说非常有用。
- en: 'Exercise 82: Checking the Status of the Web Request'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习82：检查Web请求的状态
- en: Next, we will write a small utility function to check the status of the response.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个小型实用函数来检查响应的状态。
- en: 'We will start by getting into the a habit of writing small functions to accomplish
    small modular tasks, instead of writing long scripts, which are hard to debug
    and track:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先养成编写小型函数来完成小型模块化任务的习惯，而不是编写长脚本，因为长脚本难以调试和跟踪：
- en: 'Create a `status_check` function by using the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建`status_check`函数：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that, along with printing the appropriate message, we are returning either
    1 or -1 from this function. This is important.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，除了打印适当的消息外，我们从这个函数返回1或-1。这很重要。
- en: 'Check the response using the `status_check` command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`status_check`命令检查响应：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 7.3 : The output of status_check](img/C11065_07_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：状态检查的输出](img/C11065_07_03.jpg)'
- en: 'Figure 7.3 : The output of status_check'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.3：状态检查的输出
- en: In this chapter, we will not use these returned values, but later, for more
    complex programming activity, you will proceed only if you get one as the return
    value for this function, that is, you will write a conditional statement to check
    the return value and then execute the subsequent code based on that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会使用这些返回值，但在以后的更复杂的编程活动中，你只有在获得此函数的返回值时才会继续进行，也就是说，你将编写一个条件语句来检查返回值，然后根据该值执行后续代码。
- en: Checking the Encoding of the Web Page
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查网页编码
- en: We can also write a utility function to check the encoding of the web page.
    Various encodings are possible with any HTML document, although the most popular
    is UTF-8\. Some of the most popular encodings are ASCII, Unicode, and UTF-8\.
    ASCII is the simplest, but it cannot capture the complex symbols used in various
    spoken and written languages all over the world, so UTF-8 has become the almost
    universal standard in web development these days.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编写一个实用函数来检查网页的编码。任何HTML文档都有可能的编码，尽管最流行的是UTF-8。一些最流行的编码包括ASCII、Unicode和UTF-8。ASCII是最简单的，但它无法捕获世界上各种口语和书面语言中使用的复杂符号，因此UTF-8已经成为当今网络开发的几乎通用标准。
- en: 'When we run this function on the Wikipedia home page, we get back the particular
    encoding type that''s used for that page. This function, like the previous one,
    takes the `requests` response object as an argument and returns a value:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在维基百科主页上运行此函数时，我们得到该页使用的特定编码类型。这个函数与前面的函数类似，它接受`requests`响应对象作为参数并返回一个值：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Check the response:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 检查响应：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, UTF-8 denotes the most popular character encoding scheme that's used in
    the digital medium and on the web today. It employs variable-length encoding with
    1-4 bytes, thereby representing all Unicode characters in various languages around
    the world.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，UTF-8表示目前数字媒体和互联网上最流行的字符编码方案。它采用1-4字节的可变长度编码，从而可以表示世界上各种语言的Unicode字符。
- en: 'Exercise 83: Creating a Function to Decode the Contents of the Response and
    Check its Length'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习83：创建一个函数来解码响应内容并检查其长度
- en: 'The final aim of this series of steps is to get a page''s contents as a blob
    of text or as a string object that Python can process afterward. Over the internet,
    data streams move in an encoded format. Therefore, we need to decode the content
    of the response object. For this purpose, we need to perform the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列步骤的最终目的是获取一个页面的内容作为一个文本块或字符串对象，以便Python之后进行处理。在互联网上，数据流以编码格式移动。因此，我们需要解码响应对象的内容。为此，我们需要执行以下步骤：
- en: 'Write a utility function to decode the contents of the response:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实用函数来解码响应的内容：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Check the type of the decoded object:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查解码对象的类型：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We finally got a string object by reading the HTML page!
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最终通过读取HTML页面得到了一个字符串对象！
- en: Note
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the answer in this chapter and in the exercise in Jupyter notebook
    may vary because of updates that have been made to the Wikipedia page.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，本章和Jupyter笔记本中的练习答案可能因维基百科页面的更新而有所不同。
- en: 'Check the length of the object and try printing some of it:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查对象的长度并尝试打印其中的一部分：
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you print the first 10,000 characters of this string, it will look some
    similar to this:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你打印这个字符串的前10,000个字符，它看起来会类似于这样：
- en: '![Figure 7.4: Output showing a mixed blob of HTML markup tags, text and element
    names, and properties](img/C11065_07_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：显示混合的HTML标记标签、文本和元素名称以及属性的输出](img/C11065_07_04.jpg)'
- en: 'Figure 7.4: Output showing a mixed blob of HTML markup tags, text and element
    names, and properties'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.4：显示混合的HTML标记标签、文本和元素名称以及属性的输出
- en: Obviously, this is a mixed blob of various HTML markup tags, text, and elements
    names/properties. We cannot hope to extract meaningful information from this without
    using sophisticated functions or methods. Fortunately, the `BeautifulSoup` library
    provides such methods, and we will see how to use them next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个由各种HTML标记标签、文本和元素名称/属性组成的混合体。如果不使用复杂的函数或方法，我们无法从中提取有意义的信息。幸运的是，`BeautifulSoup`库提供了这样的方法，我们将在下一节中看到如何使用它们。
- en: 'Exercise 84: Extracting Human-Readable Text From a BeautifulSoup Object'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习84：从BeautifulSoup对象中提取可读文本
- en: 'It turns out that a `BeautifulSoup` object has a `text` method, which can be
    used just to extract text:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，`BeautifulSoup`对象有一个`text`方法，可以用来提取文本：
- en: 'Import the package and then pass on the whole string (HTML content) to a method
    for parsing:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入包，然后将整个字符串（HTML内容）传递给一个用于解析的方法：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Execute the following code in your notebook:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的笔记本中执行以下代码：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Find the type of the `txt_dmp:`
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`txt_dmp:`的类型
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Find the length of the `txt_dmp:`
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`txt_dmp:`的长度
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, the length of the text dump is much smaller than the raw HTML's string
    length. This is because `bs4` has parsed through the HTML and extracted only human-readable
    text for further processing.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，文本输出的长度比原始HTML字符串的长度小得多。这是因为`bs4`已经解析了HTML并提取了仅用于进一步处理的人读文本。
- en: Print the initial portion of this text.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印这个文本的初始部分。
- en: '[PRE21]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will see something similar to the following:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到类似以下的内容：
- en: '![Figure 7.5: Output showing the initial portion of text](img/C11065_07_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：显示文本初始部分的输出](img/C11065_07_05.jpg)'
- en: 'Figure 7.5: Output showing the initial portion of text'
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.5：显示文本初始部分的输出
- en: Extracting Text from a Section
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一个部分提取文本
- en: 'Now, let''s move on to a more exciting data wrangling task. If you open the
    Wikipedia home page, you are likely to see a section called **From today''s featured
    article**. This is an excerpt from the day''s prominent article, which is randomly
    selected and promoted on the home page. In fact, this article can also change
    throughout the day:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行一个更有趣的数据处理任务。如果你打开维基百科首页，你可能会看到一个名为**今日特色文章**的部分。这是当天突出文章的摘录，该文章是随机选择并在首页推广的。实际上，这篇文章在一天中也可能发生变化：
- en: '![Figure 7.6: Sample Wikipedia page highlighting the “From today’s featured
    article” section](img/C11065_07_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：示例维基百科页面突出显示“今日特色文章”部分](img/C11065_07_06.jpg)'
- en: 'Figure 7.6: Sample Wikipedia page highlighting the "From today''s featured
    article" section'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.6：示例维基百科页面突出显示“今日特色文章”部分
- en: You need to extract the text from this section. There are number of ways to
    accomplish this task. We will go through a simple and intuitive method for doing
    so here.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从这个部分提取文本。有几种方法可以完成这个任务。在这里，我们将介绍一种简单直观的方法。
- en: 'First, we try to identify two indices – the start index and end index of the
    string, which demarcate the start and end of the text we are interested in. In
    the next screenshot, the indices are shown:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试识别两个索引——字符串的开始索引和结束索引，它们标志着我们感兴趣的文本的开始和结束。在下一张屏幕截图中，索引如下所示：
- en: '![Figure 7.7: Wikipedia page highlighting the text to be extracted](img/C11065_07_07.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：维基百科页面突出显示要提取的文本](img/C11065_07_07.jpg)'
- en: 'Figure 7.7: Wikipedia page highlighting the text to be extracted'
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.7：维基百科页面突出显示要提取的文本
- en: 'The following code accomplishes the extraction:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码完成了提取：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note, that we have to add the length of the `From today's featured article`
    string to `idx1` and then pass that as the starting index. This is because idx1
    finds where the *From today's featured article* string starts, not ends.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须将“今日特色文章”字符串的长度添加到`idx1`中，然后将它作为起始索引传递。这是因为`idx1`找到的是“今日特色文章”字符串的开始位置，而不是结束位置。
- en: 'It prints out something like this (this is a sample output):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印出类似以下的内容（这是一个示例输出）：
- en: '![Figure 7.8: The extracted text](img/C11065_07_08.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8：提取的文本](img/C11065_07_08.jpg)'
- en: 'Figure 7.8: The extracted text'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.8：提取的文本
- en: Extracting Important Historical Events that Happened on Today's Date
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取今天日期发生的重要历史事件
- en: 'Next, we will try to extract the text corresponding to the important historical
    events that happened on today''s date. This can generally be found at the bottom-right
    corner as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试提取与今天日期发生的重要历史事件的文本。这通常可以在以下屏幕截图的右下角找到：
- en: '![Figure 7.9: Wikipedia page highlighting the “On this day” section](img/C11065_07_09.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9：维基百科页面突出显示“历史上的今天”部分](img/C11065_07_09.jpg)'
- en: 'Figure 7.9: Wikipedia page highlighting the "On this day" section'
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.9：维基百科页面突出显示“历史上的今天”部分
- en: 'So, can we apply the same technique as we did for "**From today''s featured
    article**"? Apparently not, because there is text just below where we want our
    extraction to end, which is not fixed, unlike in the previous case. Note that,
    in the previous exercise, the fixed string "**Recently featured**" occurs at the
    exact place where we want the extraction to stop. So, we could use it in our code.
    However, we cannot do that in this case, and the reason for this is illustrated
    in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能否应用与之前对“**今日特色文章**”所用的相同技术？显然不行，因为在我们想要提取结束的地方下面有文本，这与之前的情况不同。注意，在前面的练习中，固定的字符串“**最近推荐**”正好出现在我们想要提取停止的地方。因此，我们可以在代码中使用它。然而，在这种情况下，我们不能这样做，原因如下面的屏幕截图所示：
- en: '![Figure 7.10: Wikipedia page highlighting the text to be extracted](img/C11065_07_10.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10：维基百科页面突出显示要提取的文本](img/C11065_07_10.jpg)'
- en: 'Figure 7.10: Wikipedia page highlighting the text to be extracted'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.10：突出显示要提取的维基百科页面文本
- en: 'So, in this section, we just want to find out what the text looks like around
    the main content we are interested in. For that, we must find out the start of
    the string "On this day" and print out the next 1,000 characters, using the following
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们只想找出围绕我们感兴趣的主要内容的文本看起来是什么样子。为此，我们必须找出字符串“On this day”的起始位置，并使用以下命令打印出接下来的1,000个字符：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This looks as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '![Figure 7.11: Output of the "On this day" section from Wikipedia](img/C11065_07_11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11：维基百科“On this day”部分的输出](img/C11065_07_11.jpg)'
- en: 'Figure 7.11: Output of the "On this day" section from Wikipedia'
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.11：维基百科“On this day”部分的输出
- en: To address this issue, we need to think differently and use some other methods
    from BeautifulSoup (and write another utility function).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要换一种思维方式，并使用一些BeautifulSoup（以及编写另一个实用函数）的其他方法。
- en: 'Exercise 85: Using Advanced BS4 Techniques to Extract Relevant Text'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习85：使用高级BS4技术提取相关文本
- en: 'HTML pages are made of many markup tags, such as <div>, which denotes a division
    of text/images, or <ul>, which denotes lists. We can take advantage of this structure
    and look at the element that contains the text we are interested in. In the Mozilla
    Firefox browser, we can easily do this by right-clicking and selecting the "**Inspect
    Element**" option:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面由许多标记标签组成，例如<div>，表示文本/图像的分区，或者<ul>，表示列表。我们可以利用这种结构来查看包含我们感兴趣文本的元素。在Mozilla
    Firefox浏览器中，我们可以通过右键单击并选择“**检查元素**”选项来轻松完成此操作：
- en: '![Figure 7.12: Inspecting elements on Wikipedia](img/C11065_07_12.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12：在维基百科上检查元素](img/C11065_07_12.jpg)'
- en: 'Figure 7.12: Inspecting elements on Wikipedia'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.12：在维基百科上检查元素
- en: 'As you hover over this with the mouse, you will see different portions of the
    page being highlighted. By doing this, it is easy to discover the precise block
    of markup text, that is responsible for the textual information we are interested
    in. Here, we can see that a certain `<ul>` block contains the text:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用鼠标悬停在这个上面时，你会看到页面上的不同部分被突出显示。通过这样做，可以轻松地发现负责我们感兴趣文本信息的精确标记文本块。在这里，我们可以看到某个`<ul>`块包含以下文本：
- en: '![](img/C11065_07_13.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_07_13.jpg)'
- en: 'Figure 7.13: Identifying the HTML block that contains text'
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.13：识别包含文本的HTML块
- en: 'Now, it is prudent to find the `<div>` tag that contains this `<ul>` block
    within it. By looking around the same screen as before, we find the `<div>` and
    also its ID:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，找到包含这个`<ul>`块的`<div>`标签是明智的。通过查看之前的相同屏幕，我们找到了`<div>`及其ID：
- en: '![Figure 7.14: The tag ul containing the text](img/C11065_07_14.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图7.14：包含文本的ul标签](img/C11065_07_14.jpg)'
- en: 'Figure 7.14: The <ul> tag containing the text'
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.14：包含文本的<ul>标签
- en: Use the `find_all` method from BeautifulSoup, which scans all the tags of the
    HTML page (and their sub-elements) to find and extract the text associated with
    this particular `<div>` element.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用BeautifulSoup的`find_all`方法，该方法扫描HTML页面的所有标签（及其子元素）以找到并提取与特定`<div>`元素相关的文本。
- en: Note
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Note how we are utilizing the 'mp-otd' ID of the <div> to identify it among
    tens of other <div> elements.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们如何利用`mp-otd` ID的`<div>`来在数十个其他`<div>`元素中识别它。
- en: The `find_all` method returns a `NavigableString` class, which has a useful
    `text` method associated with it for extraction.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`find_all`方法返回一个`NavigableString`类，该类与其关联一个有用的`text`方法，用于提取。'
- en: 'To put these ideas together, we will create an empty list and append the text
    from the `NavigableString` class to this list as we traverse the page:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将这些想法结合起来，我们将创建一个空列表，并在遍历页面时将`NavigableString`类的文本追加到这个列表中：
- en: '[PRE24]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, if we examine the `text_list` list, we will see that it has three elements.
    If we print the elements, separated by a marker, we will see that the text we
    are interested in appears as the first element!
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们检查`text_list`列表，我们会看到它有三个元素。如果我们按标记打印这些元素，我们会看到我们感兴趣的文本作为第一个元素出现！
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, it is the first element of the list that we are interested
    in. However, the exact position will depend on the web page.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们感兴趣的是列表的第一个元素。然而，确切的位置将取决于网页。
- en: 'The output is as follows:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 7.15: The text highlighted](img/C11065_07_15.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15：高亮的文本](img/C11065_07_15.jpg)'
- en: 'Figure 7.15: The text highlighted'
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.15：高亮的文本
- en: 'Exercise 86: Creating a Compact Function to Extract the "On this Day" Text
    from the Wikipedia Home Page'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习86：创建一个紧凑的函数从维基百科主页提取“On this Day”文本
- en: 'As we discussed before, it is always good to try to functionalize specific
    tasks, particularly in a web scraping application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，尝试将特定任务功能化总是好的，尤其是在网络爬虫应用程序中：
- en: 'Create a function, whose only job is to take the URL (as a string) and to return
    the text corresponding to the **On this day** section. The benefit of such a functional
    approach is that you can call this function from any Python script and use it
    anywhere in another program as a standalone module:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，其唯一任务是接受URL（作为字符串）并返回与**On this day**部分对应的文本。这种功能方法的优点是你可以从任何Python脚本中调用这个函数，并在另一个程序中的任何地方将其用作独立模块：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Extract the text from the "On this day" section on the Wikipedia home page.
    Accept the Wikipedia home page URL as a string. A default URL is provided:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从维基百科主页的“On this day”部分提取文本。接受维基百科主页URL作为字符串。提供了一个默认的URL：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note how this function utilizes the status check and prints out an error message
    if the request failed. When we test this function with an intentionally incorrect
    URL, it behaves as expected:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意这个函数如何利用状态检查，如果请求失败，则打印出错误信息。当我们用故意错误的URL测试这个函数时，它表现得如预期：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Reading Data from XML
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从XML中读取数据
- en: XML, or Extensible Markup Language, is a web markup language that's similar
    to HTML but with significant flexibility (on the part of the user) built in, such
    as the ability to define your own tags. It was one of the most hyped technologies
    in the 1990s and early 2000s. It is a meta-language, that is, a language that
    allows us to define other languages using its mechanics, such as RSS, MathML (a
    mathematical markup language widely used for web publication and the display of
    math-heavy technical information), and so on. XML is also heavily used in regular
    data exchanges over the web, and as a data wrangling professional, you should
    have enough familiarity with its basic features to tap into the data flow pipeline
    whenever you need to extract data for your project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: XML，或可扩展标记语言，是一种类似于HTML但具有显著灵活性的网络标记语言（对于用户而言），例如能够定义自己的标签。它是20世纪90年代和21世纪初最被炒作的技术之一。它是一种元语言，也就是说，一种允许我们使用其机制定义其他语言的语言，例如RSS、MathML（一种广泛用于网络发布和显示数学密集型技术信息的数学标记语言），等等。XML在互联网上的常规数据交换中也得到了广泛使用，作为一名数据整理专业人士，你应该对其基本特性有足够的了解，以便在需要为项目提取数据时随时能够访问数据流管道。
- en: 'Exercise 87: Creating an XML File and Reading XML Element Objects'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习87：创建XML文件和读取XML元素对象
- en: 'Let''s create some random data to understand the XML data format better. Type
    in the following code snippets:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些随机数据，以便更好地理解XML数据格式。输入以下代码片段：
- en: 'Create an XML file using the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建XML文件：
- en: '[PRE29]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is a triple-quoted string or multiline string. If you print this object,
    you will get the following output. This is an XML-formatted data string in a tree
    structure, as we will see soon, when we parse the structure and tease apart the
    individual parts:![Figure 7.16: The XML file output](img/C11065_07_16.jpg)'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个三引号字符串或多行字符串。如果你打印这个对象，你会得到以下输出。这是一个以树结构格式化的XML数据字符串，正如我们很快就会看到的，当我们解析结构并分离出各个部分时：![图7.16：XML文件输出](img/C11065_07_16.jpg)
- en: 'Figure 7.16: The XML file output'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.16：XML文件输出
- en: 'To process and wrangle with the data, we have to read it as an `Element` object
    using the Python XML parser engine:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理和整理数据，我们必须使用Python XML解析器引擎将其读取为`Element`对象：
- en: '[PRE30]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE31]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Exercise 88: Finding Various Elements of Data within a Tree (Element)'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习88：在树（元素）中查找各种数据元素
- en: 'We can use the `find` method to search for various pieces of useful data within
    an XML element object and print them (or use them in whatever processing code
    we want) using the `text` method. We can also use the `get` method to extract
    the specific attribute we want:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`find`方法在XML元素对象中搜索各种有用的数据，并使用`text`方法打印它们（或在我们想要的任何处理代码中使用它们）。我们还可以使用`get`方法提取我们想要的特定属性：
- en: 'Use the `find` method to find `Name`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find`方法查找`Name`：
- en: '[PRE32]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use the `find` method to find `Surname`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find`方法查找`Surname`：
- en: '[PRE33]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use the `find` method to find `Phone`. Note the use of the `strip` method to
    strip away any trailing spaces/blanks:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find`方法查找`Phone`。注意使用`strip`方法去除任何尾随空格/空白：
- en: '[PRE34]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output will be as follows:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE35]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use the `find` method to find `email status` and `actual email`. Note the use
    of the `get` method to extract the status:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find`方法查找`email status`和`actual email`。注意使用`get`方法提取状态：
- en: '[PRE36]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output will be as follows:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE37]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Reading from a Local XML File into an ElementTree Object
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将本地 XML 文件读取到 ElementTree 对象中
- en: We can also read from an XML file (saved locally on disk).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从 XML 文件（保存在磁盘上）中读取。
- en: This is a fairly common situation where a frontend web scraping module has already
    downloaded a lot of XML files by reading a table of data on the web and now the
    data wrangler needs to parse through this XML file to extract meaningful pieces
    of numerical and textual data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当常见的情况，其中前端网络抓取模块已经通过读取网页上的数据表下载了大量的 XML 文件，现在数据整理者需要解析这个 XML 文件以提取有意义的数值和文本数据。
- en: 'We have a file associated with this chapter, called "`xml1.xml`". Please make
    sure you have the file in the same directory that you are running your Jupyter
    Notebook from:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个与本章相关的文件，称为 "`xml1.xml`"。请确保您有该文件，并且它与您从 Jupyter Notebook 运行的目录相同：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note how we use the `parse` method to read this XML file. This is slightly different
    than using the `fromstring` method used in the previous exercise, where we were
    directly reading from a string object. This produces an `ElementTree` object instead
    of a simple `Element`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用 `parse` 方法来读取这个 XML 文件。这与之前练习中使用的 `fromstring` 方法略有不同，当时我们是直接从一个字符串对象中读取。这会产生一个
    `ElementTree` 对象而不是一个简单的 `Element`。
- en: 'The idea of building a tree-like object is the same as in the domains of computer
    science and programming:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 构建树形对象的想法与计算机科学和编程领域相同：
- en: There is a root
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个根节点
- en: There are children objects attached to the root
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点附加有子对象
- en: There could be multiple levels, that is, children of children recursively going
    down
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在多个级别，即子节点的子节点递归向下
- en: All of the nodes of the tree (root and children alike) have attributes attached
    to them that contain data
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树中的所有节点（根节点和子节点）都附加有包含数据的属性
- en: Tree traversal algorithms can be used to search for a particular attribute
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用树遍历算法来搜索特定的属性
- en: If provided, special methods can be used to probe a node deeper
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供，可以使用特殊方法来深入探测一个节点
- en: 'Exercise 89: Traversing the Tree, Finding the Root, and Exploring all Child
    Nodes and their Tags and Attributes'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 89：遍历树，找到根节点，并探索所有子节点及其标签和属性
- en: 'Every node in the XML tree has tags and attributes. The idea is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: XML 树中的每个节点都有标签和属性。其思路如下：
- en: '![](img/C11065_07_17.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_07_17.jpg)'
- en: 'Figure 7.17: Finding the root and child nodes of an XML tag'
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.17：找到 XML 标签的根节点和子节点
- en: 'Explore these tags and attributes using the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码探索这些标签和属性：
- en: '[PRE39]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output will be as follows:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 7.18: The output showing the extracted XML tags](img/C11065_07_18.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18：显示提取的 XML 标签的输出](img/C11065_07_18.jpg)'
- en: 'Figure 7.18: The output showing the extracted XML tags'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.18：显示提取的 XML 标签的输出
- en: Note
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that every XML data file could follow a different naming or structural
    format, but using an element tree approach puts the data into a somewhat structured
    flow that can be explored systematically. Still, it is best to examine the raw
    XML file structure once and understand (even if at a high level) the data format
    before attempting automatic extractions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个 XML 数据文件可能遵循不同的命名或结构格式，但使用元素树方法将数据放入一种结构化的流程中，可以系统地探索。然而，最好在尝试自动提取之前先检查原始
    XML 文件结构一次，并理解（即使是在高层次上）数据格式。
- en: 'Exercise 90: Using the `text` Method to Extract Meaningful Data'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 90：使用 `text` 方法提取有意义的数据
- en: 'We can almost think of the XML tree as a **list of lists** and index it accordingly:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以将 XML 树视为一个**列表的列表**，并相应地进行索引：
- en: 'Access the element `root[0][2]` by using the following code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码通过访问 `root[0][2]` 来获取元素：
- en: '[PRE40]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output will be as follows:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE41]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, this points to the '`gdppc`' piece of data. Here, '`gdppc`' is the tag and
    the actual GDP/per capita data is attached to this tag.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，这指向了 '`gdppc`' 这部分数据。在这里，"`gdppc`" 是标签，实际的人均 GDP 数据附着在这个标签上。
- en: 'Use the `text` method to access the data:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `text` 方法来访问数据：
- en: '[PRE42]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output will be as follows:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Use the `tag` method to access `gdppc`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `tag` 方法来访问 `gdppc`：
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output will be as follows:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Check `root[0]`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `root[0]`：
- en: '[PRE46]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will be as follows:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE47]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Check the tag:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查标签：
- en: '[PRE48]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output will be as follows:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE49]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can use the `attrib` method to access it:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用 `attrib` 方法来访问它：
- en: '[PRE50]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output will be as follows:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE51]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So, `root[0]` is again an element, but it has different a set of tags and attributes
    than `root[0][2]`. This is expected because they are all part of the tree as nodes,
    but each is associated with a different level of data.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，`root[0]` 仍然是一个元素，但它与 `root[0][2]` 具有不同的标签和属性集。这是预期的，因为它们都是树的一部分，作为节点，但每个节点都与不同级别的数据相关联。
- en: This last piece of code output is interesting because it returns a dictionary
    object. Therefore, we can just index it by its keys. We will do that in the next
    exercise.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最后输出很有趣，因为它返回一个字典对象。因此，我们可以通过其键来索引它。我们将在下一个练习中这样做。
- en: Extracting and Printing the GDP/Per Capita Information Using a Loop
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用循环提取和打印GDP/人均信息
- en: 'Now that we know how to read the GDP/per capita data and how to get a dictionary
    back from the tree, we can easily construct a simple dataset by running a loop
    over the tree:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何读取GDP/人均数据，以及如何从树中获取字典，我们可以通过在树上运行循环轻松构建一个简单的数据集：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can put these in a DataFrame or CSV file for saving to a local disk or further
    processing, such as a simple plot!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些数据放入DataFrame或CSV文件中，以便保存到本地磁盘或进行进一步处理，例如简单的绘图！
- en: 'Exercise 91: Finding All the Neighboring Countries for each Country and Printing
    Them'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习91：为每个国家找到所有邻近国家并打印它们
- en: As we mentioned before, there are efficient search algorithms for tree structures,
    and one such method for XML trees is `findall`. We can use this, for this example,
    to find all the neighbors a country has and print them out.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，对于树结构有高效的搜索算法，对于XML树的一种方法就是 `findall`。我们可以使用这个方法，在这个例子中，找到国家所有的邻近国家并将它们打印出来。
- en: 'Why do we need to use `findall` over find? Well, because not all the countries
    have an equal number of neighbors and `findall` searches for all the data with
    that tag that is associated with a particular node, and we want to traverse all
    of them:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要使用 `findall` 而不是 `find` 呢？因为不是所有国家都有相同数量的邻近国家，而 `findall` 会搜索与特定节点相关联的具有该标签的所有数据，而我们想要遍历所有这些数据：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output looks something like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '![](img/C11065_07_19.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_07_19.jpg)'
- en: 'Figure 7.19: The output that''s generated by using findall'
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.19：使用findall生成的输出
- en: 'Exercise 92: A Simple Demo of Using XML Data Obtained by Web Scraping'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习92：使用通过网络抓取获得的XML数据的一个简单演示
- en: 'In the last topic of this chapter, we learned about simple web scraping using
    the `requests` library. So far, we have worked with static XML data, that is,
    data from a local file or a string object we''ve scripted. Now, it is time to
    combine our learning and read XML data directly over the internet (as you are
    expected to do almost all the time):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后主题中，我们学习了使用 `requests` 库进行简单的网络抓取。到目前为止，我们一直在处理静态XML数据，即来自本地文件或我们编写的字符串对象的数据。现在，是时候将我们的学习结合起来，直接从互联网上读取XML数据了（正如你预期的那样，你几乎总是这样做）：
- en: 'We will try to read a cooking recipe from a website called [http://www.recipepuppy.com/](http://www.recipepuppy.com/),
    which aggregates links to various other sites with the recipe:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试从一个名为 [http://www.recipepuppy.com/](http://www.recipepuppy.com/) 的网站上读取烹饪食谱，该网站聚合了各种其他网站的食谱链接：
- en: '[PRE55]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This code will ask the user for input. You have to enter the name of a food
    item. For example, ''chicken tikka'':![Figure 7.20: Demo of scraping from XML
    data](img/C11065_07_20.jpg)'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码将要求用户输入。你必须输入一个食品项目的名称。例如，'chicken tikka'：![图7.20：从XML数据中抓取的演示](img/C11065_07_20.jpg)
- en: 'Figure 7.20: Demo of scraping from XML data'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.20：从XML数据中抓取的演示
- en: 'We get back data in XML format and read and decode it before creating an XML
    tree out of it:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到的是XML格式的数据，在创建XML树之前，我们需要读取和解析它：
- en: '[PRE56]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can use another useful method, called `iter`, which basically iterates
    over the nodes under an element. If we traverse the tree and extract the text,
    we get the following output:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用另一个有用的方法，称为 `iter`，它基本上遍历一个元素下的节点。如果我们遍历树并提取文本，我们得到以下输出：
- en: '[PRE57]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 7.21: The output that’s generated by using iter](img/C11065_07_21.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.21：使用iter生成的输出](img/C11065_07_21.jpg)'
- en: 'Figure 7.21: The output that''s generated by using iter'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.21：使用iter生成的输出
- en: We can use the find method to search for the appropriate attribute and extract
    its content. This is the reason it is important to scan through the XML data manually
    and check what attributes are used. Remember, this means scanning the raw string
    data, not the tree structure.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用find方法搜索适当的属性并提取其内容。这就是为什么手动扫描XML数据并检查使用了哪些属性很重要的原因。记住，这意味着扫描原始字符串数据，而不是树结构。
- en: 'Print the raw string data:![Figure 7.22: The output showing the extracted href
    tags'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印原始字符串数据：![图7.22：显示提取的href标签的输出结果
- en: '](img/C11065_07_22.jpg)'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C11065_07_22.jpg)'
- en: 'Figure 7.22: The output showing the extracted href tags'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.22：显示提取的href标签的输出结果
- en: Now we know what tags to search for.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们知道要搜索哪些标签。
- en: 'Print all the hyperlinks in the XML data:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印XML数据中的所有超链接：
- en: '[PRE58]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note the use of `h!=None` and `t!=None`. These are difficult to expect when
    you first run this kind of code. You may get an error because some of the tags
    may return a `None` object, that is, they were empty for some reason in this XML
    data stream. This kind of situation is fairly common and cannot be anticipated
    beforehand. You have to use your Python knowledge and programming intuition to
    get around it if you receive such an error. Here, we are just checking for the
    type of the object and if it is not a `None`, then we need to extract the text
    associated with it.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`h!=None`和`t!=None`的使用。当你第一次运行这类代码时，这些可能难以预料。你可能会遇到错误，因为一些标签可能返回一个`None`对象，即它们在这个XML数据流中由于某种原因而为空。这种情况相当常见，无法事先预料。如果你收到这样的错误，你必须使用你的Python知识和编程直觉来解决这个问题。在这里，我们只是在检查对象的类型，如果它不是`None`，那么我们需要提取与它相关的文本。
- en: 'The final output is as follows:'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终输出如下：
- en: '![Figure 7.23: The output showing the final output](img/C11065_07_23.jpg)'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.23：显示最终输出的输出结果](img/C11065_07_23.jpg)'
- en: 'Figure 7.23: The output showing the final output'
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.23：显示最终输出的输出结果
- en: Reading Data from an API
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从API读取数据
- en: Fundamentally, an API or Application Programming Interface is some kind of interface
    to a computing resource (for example, an operating system or database table),
    which has a set of exposed methods (function calls) that allow a programmer to
    access particular data or internal features of that resource.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，API或应用程序编程接口是一种对计算资源（例如，操作系统或数据库表）的接口，它提供了一套公开的方法（函数调用），允许程序员访问该资源的特定数据或内部功能。
- en: A web API is, as the name suggests, an API over the web. Note that it is not
    a specific technology or programming framework, but an architectural concept.
    Think of an API like a fast food restaurant's customer service center. Internally,
    there are many food items, raw materials, cooking resources, and recipe management
    systems, but all you see are fixed menu items on the board and you can only interact
    through those items. It is like a port that can be accessed using an HTTP protocol
    and is able to deliver data and services if used properly.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 网络API，正如其名所示，是在网络上的API。请注意，它不是一种特定的技术或编程框架，而是一种架构概念。想象一下API就像快餐店的客户服务中心。内部有许多食品、原材料、烹饪资源和食谱管理系统，但你所能看到的是固定的菜单项，而你只能通过这些项进行交互。它就像一个可以通过HTTP协议访问的端口，如果使用得当，能够提供数据和服务。
- en: Web APIs are extremely popular these days for all kinds of data services. In
    the very first chapter, we talked about how UC San Diego's data science team pulls
    data from Twitter feeds to analyze occurrence of forest fires. For this, they
    do not go to twitter.com and scrape the data by looking at HTML pages and text.
    Instead, they use the Twitter API, which sends this data continuously in a streaming
    format.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 网络API在当今各种数据服务中极为流行。在第一章中，我们讨论了加州大学圣地亚哥分校的数据科学团队如何从Twitter动态中提取数据来分析森林火灾的发生情况。为此，他们不去twitter.com，通过查看HTML页面和文本来抓取数据。相反，他们使用Twitter
    API，该API以流式格式连续发送这些数据。
- en: Therefore, it is very important for a data wrangling professional to understand
    the basics of data extraction from a web API as you are extremely likely to find
    yourself in a situation where large quantities of data must be read through an
    API interface for processing and wrangling. These days, most APIs stream data
    out in JSON format. In this chapter, we will use a free API to read some information
    about various countries around the world in JSON format and process it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于数据整理专业人员来说，了解从网络API中提取数据的基本知识非常重要，因为你极有可能发现自己处于必须通过API接口读取大量数据进行处理和整理的情况。如今，大多数API以JSON格式流式传输数据。在本章中，我们将使用一个免费的API以JSON格式读取有关世界各地各种国家的信息，并进行处理。
- en: 'We will use Python''s built-in `urllib` module for this topic, along with pandas
    to make a DataFrame. So, we can import them now. We will also import Python''s
    `JSON` module:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python的内置`urllib`模块以及pandas来创建DataFrame。因此，我们现在可以导入它们。我们还将导入Python的`JSON`模块：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Defining the Base URL (or API Endpoint)
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义基本URL（或API端点）
- en: 'First, we need to set the base URL. When we are dealing with API microservices,
    this is often called the **API endpoint**. Therefore, look for such a phrase in
    the web service portal you are interested in and use the endpoint URL they give
    you:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置基本URL。当我们处理API微服务时，这通常被称为**API端点**。因此，在你感兴趣的网站服务门户中寻找这样的短语，并使用他们提供的端点URL：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: API-based microservices are extremely dynamic in nature in terms of what and
    how they offer their service and data. It can change at any time. At the time
    of this chapter planning, we found this particular API to be a nice choice for
    extracting data easily and without using authorization keys (login or special
    API keys).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 基于API的微服务在提供服务和数据方面具有极高的动态性。它可以随时改变。在规划本章内容时，我们发现这个特定的API是一个很好的选择，可以轻松地提取数据，而且无需使用授权密钥（登录或特殊API密钥）。
- en: For most APIs, however, you need to have your own API key. You get that by registering
    with their service. A basic usage (up to a fixed number of requests or a data
    flow limit) is often free, but after that you will be charged. To register for
    an API key, you often need to enter credit card information.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大多数API，你需要有自己的API密钥。通过注册他们的服务来获取。基本使用（直到固定数量的请求或数据流限制）通常是免费的，但之后你将需要付费。为了注册API密钥，你通常需要输入信用卡信息。
- en: We wanted to avoid all that hassle to teach you the basics and that's why we
    chose this example, which does not require such authorization. But, depending
    on what kind of data you will encounter in your work, please be prepared to learn
    about using an API key.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免所有这些麻烦来教你们基础知识，这就是为什么我们选择了这个例子，它不需要这样的授权。但是，根据你工作中会遇到的数据类型，请准备好学习如何使用API密钥。
- en: 'Exercise 93: Defining and Testing a Function to Pull Country Data from an API'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 93：定义和测试从API中提取国家数据的函数
- en: 'This particular API serves basic information about countries around the world:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的API提供了关于世界各地国家的基本信息：
- en: 'Define a function to pull out data when we pass the name of a country as an
    argument. The crux of the operation is contained in the following two lines of
    code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，当我们传递一个国家的名称作为参数时，从中提取数据。操作的核心包含在以下两行代码中：
- en: '[PRE61]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The first line of code appends the country name as a string to the base URL
    and the second line sends a `get` request to the API endpoint. If all goes well,
    we get back the data, decode it, and read it as a JSON file. This whole exercise
    is coded in the following function, along with some error-handling code wrapped
    around the basic actions we talked about previously:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行代码将国家名称作为字符串追加到基本URL上，第二行向API端点发送一个`get`请求。如果一切顺利，我们会收到数据，对其进行解码，并将其作为JSON文件读取。整个练习的代码如下，包括围绕我们之前讨论的基本操作的一些错误处理代码：
- en: '[PRE62]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Test this function by passing some arguments. We pass a correct name and an
    erroneous name. The response is as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递一些参数来测试这个函数。我们传递一个正确的名称和一个错误的名称。响应如下：
- en: Note
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This is an example of rudimentary error handling. You have to think about various
    possibilities and put in such code to catch and gracefully respond to user input
    when you are building a real-life web or enterprise application.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个基本的错误处理示例。你必须考虑各种可能性，并在构建实际的Web或企业应用程序时编写这样的代码来捕获并优雅地响应用户输入。
- en: '![Figure 7.24: Input arguments](img/C11065_07_24.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.24：输入参数](img/C11065_07_24.jpg)'
- en: 'Figure 7.24: Input arguments'
  id: totrans-295
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.24：输入参数
- en: Using the Built-In JSON Library to Read and Examine Data
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置 JSON 库读取和检查数据
- en: As we have already mentioned, JSON looks a lot like a Python dictionary.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，JSON看起来很像Python字典。
- en: 'In this exercise, we will use Python''s `json` module to read raw data in that
    format and see what we can process further:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Python的`json`模块来读取该格式的原始数据，并查看我们可以进一步处理的内容：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output will be as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So, we get a list back when we use the `loads` method from the `json` module.
    It reads a string datatype into a list of dictionaries. In this case, we get only
    one element in the list, so we extract that and check its type to make sure it
    is a dictionary.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们使用`json`模块的`loads`方法时，我们得到一个列表。它将字符串数据类型读入字典列表。在这种情况下，我们列表中只有一个元素，所以我们提取它并检查其类型，以确保它是一个字典。
- en: 'We can quickly check the keys of the dictionary, that is the JSON data (note
    that a full screenshot is not shown here). We can see the relevant country data,
    such as calling codes, population, area, time zones, borders, and so on:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速检查字典的键，即 JSON 数据（注意这里没有显示完整的截图）。我们可以看到相关的国家数据，例如电话区号、人口、面积、时区、边界等：
- en: '![Figure 7.25: The output of dict_keys](img/C11065_07_25.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.25：dict_keys 的输出](img/C11065_07_25.jpg)'
- en: 'Figure 7.25: The output of dict_keys'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.25：dict_keys 的输出
- en: Printing All the Data Elements
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印所有数据元素
- en: 'This task is extremely simple given that we have a dictionary at our disposal!
    All we have to do is iterate over the dictionary and print the keys/items pair
    one by one:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有字典可用的情况下，这项任务极其简单！我们只需要遍历字典，逐个打印键/项对：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 7.26: The output using dict](img/C11065_07_26.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.26：使用 dict 的输出](img/C11065_07_26.jpg)'
- en: 'Figure 7.26: The output using dict'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.26：使用 dict 的输出
- en: Note that the items in the dictionary are not of the same type, that is, they
    are not similar objects. Some are floating-point numbers, such as the area, many
    are simple strings, but some are lists or even lists of dictionaries!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到字典中的项不是同一类型的，也就是说，它们不是相似的对象。有些是浮点数，例如面积，许多是简单的字符串，但有些是列表或甚至是列表的列表！
- en: This is fairly common with JSON data. The internal data structure of JSON can
    be arbitrarily complex and multilevel, that is, you can have a dictionary of lists
    of dictionaries of dictionaries of lists of lists…. and so on.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 JSON 数据中相当常见。JSON 的内部数据结构可以是任意复杂和多层级的，也就是说，你可以有一个字典，其中包含列表的字典的字典的列表的列表……等等。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is clear, therefore, that there is no universal method or processing function
    for JSON data format, and you have to write custom loops and functions to extract
    data from such a dictionary object based on your particular needs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显，没有针对 JSON 数据格式的通用方法或处理函数，你必须根据你的特定需求编写自定义循环和函数来从这种字典对象中提取数据。
- en: 'Now, we will write a small loop to extract the languages spoken in Switzerland.
    First, let''s examine the dictionary closely and see where the language data is:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个小循环来提取瑞士使用的语言。首先，让我们仔细检查字典，看看语言数据在哪里：
- en: '![](img/C11065_07_27.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_07_27.jpg)'
- en: 'Figure 7.27: The tags'
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.27：标签
- en: So, the data is embedded inside a list of dictionaries, which is accessed by
    a particular key of the main dictionary.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据嵌套在一个字典的列表中，通过主字典的特定键来访问。
- en: 'We can write simple two-line code to extract this data:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写简单的两行代码来提取这些数据：
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 7.28: The output showing the languages](img/C11065_07_28.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.28：显示语言的输出](img/C11065_07_28.jpg)'
- en: 'Figure 7.28: The output showing the languages'
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.28：显示语言的输出
- en: Using a Function that Extracts a DataFrame Containing Key Information
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用提取包含关键信息的 DataFrame 的函数
- en: 'Here, we are interested in writing a function that can take a list of countries
    and return a pandas DataFrame with some key information:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们感兴趣的是编写一个函数，该函数可以接受一个国家列表，并返回一个包含一些关键信息的 pandas DataFrame：
- en: Capital
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首都
- en: Region
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地区
- en: Sub-region
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子区域
- en: Population
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人口
- en: Latitude/longitude
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纬度/经度
- en: Area
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面积
- en: Gini index
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基尼系数
- en: Time zones
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时区
- en: Currencies
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货币
- en: Languages
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言
- en: Note
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This is the kind of wrapper function you are generally expected to write in
    real-life data wrangling tasks, that is, a utility function that can take a user
    argument and output a useful data structure (or a mini database type object) with
    key information extracted over the internet about the item the user is interested
    in.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是在实际数据处理任务中通常期望你编写的包装函数，即一个实用函数，它可以接受用户参数，并输出一个包含从互联网上提取的关键信息的有用数据结构（或小型数据库类型对象）。
- en: 'We will show you the whole function first and then discuss some key points
    about it. It is a slightly complex and long piece of code. However, based on your
    Python- based data wrangling knowledge, you should be able to examine this function
    closely and understand what it is doing:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示整个函数，然后讨论一些关于它的关键点。这是一段稍微复杂且较长的代码。然而，基于你基于 Python 的数据处理知识，你应该能够仔细检查这个函数并理解它在做什么：
- en: '[PRE67]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code has been truncated here. Please find the entire code at the following
    GitHub link and code bundle folder link [https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Chapter07/Exercise93-94/Chapter%207%20Topic%203%20Exercises.ipynb](https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Lesson07/Exercise93-94/Lesson%207%20Topic%203%20Exercises.ipynb).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在这里被截断。请在此 GitHub 链接和代码包文件夹链接中找到整个代码 [https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Chapter07/Exercise93-94/Chapter%207%20Topic%203%20Exercises.ipynb](https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Lesson07/Exercise93-94/Lesson%207%20Topic%203%20Exercises.ipynb)。
- en: 'Here are some of the key points about this function:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个函数的一些关键点：
- en: It starts by building an empty dictionary of lists. This is the chosen format
    for finally passing to the pandas `DataFrame` method, which can accept such a
    format and returns a nice DataFrame with column names set to the dictionary keys'
    names.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它首先构建一个空的列表字典。这是最终传递给 pandas `DataFrame` 方法的格式，该方法可以接受这种格式并返回一个带有列名设置为字典键名的漂亮
    DataFrame。
- en: We use the previously defined `get_country_data` function to extract data for
    each country in the user-defined list. For this, we simply iterate over the list
    and call this function.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用之前定义的 `get_country_data` 函数来提取用户定义列表中每个国家的数据。为此，我们只需遍历列表并调用此函数。
- en: We check the output of the `get_country_data` function. If, for some reason,
    it returns a `None` object, we will know that the API reading was not successful,
    and we will print out a suitable message. Again, this is an example of an error-handling
    mechanism and you must have them in your code. Without such small error checking
    code, your application won't be robust enough for the occasional incorrect input
    or API malfunction!
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查 `get_country_data` 函数的输出。如果由于某种原因它返回一个 `None` 对象，我们将知道 API 读取没有成功，并且我们将打印出一条合适的消息。再次强调，这是一个错误处理机制的例子，你必须在代码中包含它们。没有这样的小错误检查代码，你的应用程序将不足以应对偶尔的错误输入或
    API 故障！
- en: For many data types, we simply extract the data from the main JSON dictionary
    and append it to the corresponding list in our data dictionary.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于许多数据类型，我们只需从主 JSON 字典中提取数据并将其追加到我们数据字典中相应的列表中。
- en: However, for special data types, such as time zones, currencies, and languages,
    we write a special loop to extract the data without error.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，对于特殊的数据类型，例如时区、货币和语言，我们编写一个特殊的循环来提取数据而不会出错。
- en: We also take care of the fact that these special data types can have a variable
    length, that is, some countries may have multiple spoken languages, but most will
    have only one entry. So, we check whether the length of the list is greater than
    one and handle the data accordingly.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还注意这些特殊数据类型可能有可变长度，也就是说，一些国家可能有多种官方语言，但大多数只有一个条目。因此，我们检查列表的长度是否大于一个，并相应地处理数据。
- en: 'Exercise 94: Testing the Function by Building a Small Database of Countries''
    Information'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 94：通过构建国家信息的小型数据库来测试函数
- en: 'Finally, we test this function by passing a list of country names:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过传递一个国家名称列表来测试这个函数：
- en: To test its robustness, we pass in an erroneous name – such as 'Turmeric' in
    this case!
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试其鲁棒性，我们传入一个错误的名字——例如，在这种情况下是“姜黄”!
- en: 'See the output… it detected that it did not get any data back for the incorrect
    entry and printed out a suitable message. The key is that, if you do not have
    the error checking and handling code in your function, then it will stop execution
    on that entry and will not return the expected mini database. To avoid this behavior,
    such error handling code is invaluable:'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看输出……它检测到对于错误的条目没有返回任何数据，并打印出一条合适的消息。关键是，如果你在函数中没有错误检查和处理代码，那么它将在该条目上停止执行，并且不会返回预期的迷你数据库。为了避免这种行为，这种错误处理代码是无价的：
- en: '![](img/C11065_07_29.jpg)'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/C11065_07_29.jpg)'
- en: 'Figure 7.29: The incorrect entry highlighted'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.29：错误的条目被突出显示
- en: 'Finally, the output is a pandas DataFrame, which is as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，输出是一个 pandas DataFrame，如下所示：
- en: '![Figure 7.30: The data extracted correctly](img/C11065_07_30.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.30：正确提取的数据](img/C11065_07_30.jpg)'
- en: 'Figure 7.30: The data extracted correctly'
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7.30：正确提取的数据
- en: Fundamentals of Regular Expressions (RegEx)
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式（RegEx）基础
- en: '**Reg**ular **ex**pressions or **regex** are used to identify whether a pattern
    exists in a given sequence of characters a (string) or not. They help in manipulating
    textual data, which is often a prerequisite for data science projects that involve
    text mining.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则**表达式或**regex**用于确定给定字符序列a（字符串）中是否存在模式。它们有助于操作文本数据，这对于涉及文本挖掘的数据科学项目通常是先决条件。'
- en: Regex in the Context of Web Scraping
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式在网页抓取中的应用
- en: Web pages are often full of text and while there are some methods in `BeautifulSoup`
    or XML parser to extract raw text, there is no method for the intelligent analysis
    of that text. If, as a data wrangler, you are looking for a particular piece of
    data (for example, email IDs or phone numbers in a special format), you have to
    do a lot of string manipulation on a large corpus to extract email IDs or phone
    numbers. RegEx are very powerful and save data wrangling professional a lot of
    time and effort with string manipulation because they can search for complex textual
    patterns with wildcards of an arbitrary length.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 网页通常充满了文本，虽然`BeautifulSoup`或XML解析器中有些方法可以提取原始文本，但没有用于智能分析这些文本的方法。如果你作为一个数据整理员，正在寻找特定的数据（例如，特殊格式的电子邮件ID或电话号码），你必须在大规模语料库上进行大量字符串操作来提取电子邮件ID或电话号码。正则表达式非常强大，通过它们可以搜索任意长度的通配符复杂文本模式，因此可以节省数据整理专业人员大量时间和精力。
- en: 'RegEx is like a mini-programming language in itself and common ideas are used
    not only Python, but in all widely used web app languages like JavaScript, PHP,
    Perl, and so on. The RegEx module is in-built in Python, and you can import it
    by using the following code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式本身就像是一种小程序设计语言，其常见思想不仅用于Python，还用于所有广泛使用的Web应用程序语言，如JavaScript、PHP、Perl等。Python中的正则表达式模块是内置的，你可以使用以下代码导入它：
- en: '[PRE68]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Exercise 95: Using the match Method to Check Whether a Pattern matches a String/Sequence'
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习95：使用match方法检查模式是否与字符串/序列匹配
- en: 'One of the most common regex methods is `match`. This is used to check for
    an exact or partial match at a beginning of the string (by default):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的正则表达式方法之一是`match`。这用于检查字符串开头是否存在精确或部分匹配（默认情况下）：
- en: 'Import the RegEx module:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入正则表达式模块：
- en: '[PRE69]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Define a string and a pattern:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个字符串和一个模式：
- en: '[PRE70]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Write a conditional expression to check for a match:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个条件表达式来检查匹配：
- en: '[PRE71]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The preceding code should give an affirmative answer, that is, "Matches!".
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码应该给出肯定回答，即“匹配！”。
- en: 'Test this with a string that only differs in the first letter by making it
    lowercase:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用仅第一个字母不同且转换为小写的字符串进行测试：
- en: '[PRE72]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output is as follows:'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE73]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using the Compile Method to Create a Regex Program
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用编译方法创建正则表达式程序
- en: In a program or module, if we are making heavy use of a particular pattern,
    then it is better to use the `compile` method and create a regex program and then
    call methods on this program.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序或模块中，如果我们正在大量使用特定的模式，那么使用`compile`方法创建正则表达式程序并调用该程序的方法会更好。
- en: 'Here is how you compile a regex program:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何编译正则表达式程序的方法：
- en: '[PRE74]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output is as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE75]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This code produced an `SRE.Match` object that has a `span` of (0,6) and the
    matched string of 'Python'. The span here simply denotes the start and end indices
    of the pattern that was matched. These indices may come in handy in a text mining
    program where the subsequent code uses the indices for further search or decision-making
    purposes. We will see some examples of that later.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成一个`SRE.Match`对象，其`span`为（0,6）和匹配的字符串为'Python'。这里的span简单地表示匹配模式的起始和结束索引。这些索引在文本挖掘程序中可能很有用，后续代码可以使用这些索引进行进一步搜索或决策。我们稍后会看到一些例子。
- en: 'Exercise 96: Compiling Programs to Match Objects'
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习96：将程序编译以匹配对象
- en: 'Compiled objects act like functions in that they return `None` if the pattern
    does not match. Here, we are going to check that by writing a simple conditional.
    This concept will come in handy later when we write a small utility function to
    check for the type of the returned object from regex-compiled programs and act
    accordingly. We cannot be sure whether a pattern will match a given string or
    whether it will appear in a corpus of the text (if we are searching for the pattern
    anywhere within the text). Depending on the situation, we may encounter `Match`
    objects or `None` as the returned value, and we have to handle this gracefully:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 编译对象的行为类似于函数，如果模式不匹配，则返回 `None`。在这里，我们将通过编写一个简单的条件来检查这一点。这个概念在稍后编写一个小型实用函数来检查正则表达式编译程序返回的对象类型并相应地处理时会很有用。我们无法确定一个模式是否会匹配给定的字符串，或者它是否会在文本的语料库中（如果我们正在搜索文本中的任何位置）出现。根据情况，我们可能会遇到
    `Match` 对象或 `None` 作为返回值，我们必须优雅地处理这种情况：
- en: '[PRE76]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Use the `compile` function in RegEx:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正则表达式的 `compile` 函数：
- en: '[PRE77]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Match it with the first string:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与第一个字符串进行匹配：
- en: '[PRE78]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output is as follows:'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE79]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Match it with the second string:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与第二个字符串进行匹配：
- en: '[PRE80]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is as follows:'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE81]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Exercise 97: Using Additional Parameters in Match to Check for Positional Matching'
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 97：在匹配中使用附加参数以检查位置匹配
- en: 'By default, `match` looks for pattern matching at the beginning of the given
    string. But sometimes, we need to check matching at a specific location in the
    string:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`match` 在给定字符串的开始处查找模式匹配。但有时，我们需要检查字符串中的特定位置的匹配：
- en: 'Match `y` for the second position:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第二个位置匹配为 `y`：
- en: '[PRE82]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is as follows:'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE83]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Check for a pattern called `thon` starting from `pos=2`, that is, the third
    character:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `pos=2` 开始检查名为 `thon` 的模式，即第三个字符：
- en: '[PRE84]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is as follows:'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE85]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Find a match in a different string by using the following command:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在另一个字符串中查找匹配项：
- en: '[PRE86]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is as follows:'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE87]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Finding the Number of Words in a List That End with "ing"
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找列表中以 "ing" 结尾的单词数量
- en: 'Suppose we want to find out if a given string has the last three letters: ''ing''.
    This kind of query may come up in a text analytics/text mining program where somebody
    is interested in finding instances of present continuous tense words, which are
    highly likely to end with ''ing''. However, other nouns may also end with ''ing''
    (as we will see in this example):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找出一个给定的字符串是否有最后三个字母：'ing'。这种查询可能会出现在文本分析/文本挖掘程序中，有人对查找现在进行时态单词的实例感兴趣，这些单词很可能以
    'ing' 结尾。然而，其他名词也可能以 'ing' 结尾（正如我们将在本例中看到的那样）：
- en: '[PRE88]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Create a `for` loop to find words ending with ''ing'':'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `for` 循环以查找以 'ing' 结尾的单词：
- en: '[PRE89]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output is as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE90]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It looks plain and simple, and you may well wonder what the purpose of using
    a special regex module for this is. A simple string method should have been sufficient.
    Yes, it would have been OK for this particular example, but the whole point of
    using regex is to be able to use very complex string patterns that are not at
    all obvious when it comes to how they are written using simple string methods.
    We will see the real power of regex compared to string methods shortly. But before
    that, let's explore another of the most commonly used methods, called `search`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来很简单，你可能想知道为什么需要使用特殊的正则表达式模块来做这件事。简单的字符串方法应该就足够了。是的，对于这个特定的例子来说，这样做是可以的，但使用正则表达式的全部意义在于能够使用非常复杂的字符串模式，这些模式在用简单的字符串方法编写时并不明显。我们很快就会看到正则表达式与字符串方法相比的真正威力。但在那之前，让我们探索另一个最常用的方法，称为
    `search`。
- en: 'Exercise 98: The search Method in Regex'
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 98：正则表达式中的搜索方法
- en: '`Search` and `match` are related concepts and they both return the same Match
    object. The real difference between them is that **match works for only the first
    match** (either at the beginning of the string or at a specified position, as
    we saw in the previous exercises), whereas **search looks for the pattern anywhere
    in the string** and returns the appropriate position if it finds a match:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`Search` 和 `match` 是相关概念，它们都返回相同的 Match 对象。它们之间的真正区别在于 **match 只对第一个匹配项有效**（要么在字符串的开始处，要么在指定的位置，就像我们在前面的练习中看到的那样），而
    **search 在字符串的任何位置查找模式**，如果找到匹配项，则返回相应的位置：'
- en: 'Use the `compile` method to find matching strings:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `compile` 方法查找匹配的字符串：
- en: '[PRE91]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output is as follows:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE92]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Search the string by using the following command:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令搜索字符串：
- en: '[PRE93]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: As you can see, the `match` method returns `None` for the input `spring`, and
    we had to write code to print that out explicitly (because in Jupyter notebook,
    nothing will show up for a None object). But `search` returns a `Match` object
    with `span=(3,6)` as it finds the `ing` pattern spanning those positions.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，`match` 方法对于输入 `spring` 返回 `None`，因此我们必须编写代码来显式地打印出来（因为在 Jupyter 笔记本中，对于
    `None` 对象将不会显示任何内容）。但 `search` 方法返回一个 `Match` 对象，其 `span=(3,6)` 表示它找到了跨越这些位置的
    `ing` 模式。
- en: Similarly, for the `Ringtone` string, it finds the correct position of the match
    and returns `span=(1,4)`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于 `Ringtone` 字符串，它找到匹配的正确位置并返回 `span=(1,4)`。
- en: 'Exercise 99: Using the span Method of the `Match` Object to Locate the Position
    of the Matched Pattern'
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 99：使用 `Match` 对象的 `span` 方法定位匹配模式的起始位置
- en: As you will understand by now, the `span` contained in the `Match` object is
    useful for locating the exact position of the pattern as it appears in the string.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过现在您应该理解，`Match` 对象中包含的 `span` 对于定位模式在字符串中出现的确切位置非常有用。
- en: Intitialize `prog` with pattern ing.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模式 ing 初始化 `prog`。
- en: '[PRE94]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Create a function to return a tuple of start and end positions of match.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来返回匹配的起始和结束位置的元组。
- en: '[PRE95]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Print the words ending with ing in the start or end position.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印以 ing 结尾的单词在起始或结束位置。
- en: '[PRE96]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The output is as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE97]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Exercise 100: Examples of Single Character Pattern Matching with search'
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 100：使用 search 进行单字符模式匹配的示例
- en: 'Now, we will start getting into the real usage of regex with examples of various
    useful pattern matching. First, we will explore single-character matching. We
    will also use the `group` method, which essentially returns the matched pattern
    in a string format so that we can print and process it easily:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过各种有用模式的示例来真正开始学习正则表达式的使用。首先，我们将探索单字符匹配。我们还将使用 `group` 方法，它本质上以字符串格式返回匹配的模式，这样我们就可以轻松地打印和处理它：
- en: 'Dot (.) matches any single character except a newline character:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点（.）匹配任何单个字符，除了换行符：
- en: '[PRE98]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output is as follows:'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE99]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '`\w` (lowercase w) matches any single letter, digit, or underscore:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\w`（小写 w）匹配任何单个字母、数字或下划线：'
- en: '[PRE100]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output is as follows:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE101]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '`\W` (uppercase W) matches anything not covered with `\w:`'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\W`（大写 W）匹配任何未被 `\w` 覆盖的内容：'
- en: '[PRE102]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is as follows:'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE103]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '`\s` (lowercase s) matches a single whitespace character, such as a space,
    newline, tab, or return:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\s`（小写 s）匹配单个空白字符，例如空格、换行符、制表符或回车：'
- en: '[PRE104]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output is as follows:'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE105]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`\d` matches numerical digits 0 – 9:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\d` 匹配数字 0 – 9：'
- en: '[PRE106]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The output is as follows:'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE107]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Exercise 101: Examples of Pattern Matching at the Start or End of a String'
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 101：字符串开头或结尾模式匹配的示例
- en: 'In this exercise, we will match patterns with strings. The focus is to find
    out whether the pattern is present at the start or the end of the string:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用字符串匹配模式。重点是找出模式是否存在于字符串的开头或结尾：
- en: 'Write a function to handle cases where match is not found, that is, to handle
    `None` objects as returns:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来处理找不到匹配的情况，即处理返回的 `None` 对象：
- en: '[PRE108]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Use `^` (Caret) to match a pattern at the start of the string:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `^`（上标）来匹配字符串开头的模式：
- en: '[PRE109]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Use `$` (dollar sign) to match a pattern at the end of the string:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `$`（美元符号）来匹配字符串结尾的模式：
- en: '[PRE110]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The output is as follows:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE111]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Exercise 102: Examples of Pattern Matching with Multiple Characters'
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 102：多字符模式匹配的示例
- en: Now, we will turn to more exciting and useful pattern matching with examples
    of multiple characters matching. You should start seeing and appreciating the
    real power of regex by now.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将转向更令人兴奋和有用的多字符匹配模式，通过示例来展示。现在，您应该开始看到并欣赏正则表达式的真正力量。
- en: 'Note:'
  id: totrans-475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: For these examples and exercises, also try to think how you would implement
    them without regex, that is, by using simple string methods and any other logic
    that you can think of. Then, compare that solution to the ones implemented with
    regex for brevity and efficiency.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例和练习，也要尝试思考如果没有正则表达式，您会如何实现它们，即通过使用简单的字符串方法和您能想到的任何其他逻辑。然后，将那种解决方案与使用正则表达式实现的解决方案进行比较，以体现简洁性和效率。
- en: 'Use `*` to match 0 or more repetitions of the preceding `RE`:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `*` 来匹配前面 `RE` 的 0 或更多重复：
- en: '[PRE112]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output is as follows:'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE113]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Using `+` causes the resulting RE to match 1 or more repetitions of the preceding
    RE:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `+` 会导致结果正则表达式匹配前面正则表达式的 1 或更多重复：
- en: '[PRE114]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output is as follows:'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE115]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '`?` causes the resulting RE to match precisely 0 or 1 repetitions of the preceding
    RE:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`?` 使得结果 RE 精确匹配前面 RE 的 0 或 1 次重复：'
- en: '[PRE116]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE117]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Exercise 103: Greedy versus Non-Greedy Matching'
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 103：贪婪与非贪婪匹配
- en: 'The standard (default) mode of pattern matching in regex is greedy, that is,
    the program tries to match as much as it can. Sometimes, this behavior is natural,
    but, in some cases, you may want to match minimally:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: regex 中模式匹配的标准（默认）模式是贪婪的，也就是说，程序尝试尽可能多地匹配。有时，这种行为是自然的，但在某些情况下，你可能希望最小化匹配：
- en: 'The greedy way of matching a string is as follows:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配字符串的贪婪方式如下：
- en: '[PRE118]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The output is as follows:'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE119]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'So, the preceding regex found both tags with the <> pattern, but what if we
    wanted to match the first tag only and stop there. We can use `?` by inserting
    it after any regex expression to make it non-greedy:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，前面找到的 regex 匹配了具有 <> 模式的两个标签，但如果我们只想匹配第一个标签并停止，我们可以通过在任意 regex 表达式后插入 `?`
    来使其非贪婪：
- en: '[PRE120]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output is as follows:'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE121]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Exercise 104: Controlling Repetitions to Match'
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 104：控制重复以匹配
- en: 'In many situations, we want to have precise control over how many repetitions
    of the pattern we want to match in a text. This can be done in a few ways, which
    we will show examples of here:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们希望精确控制文本中要匹配的模式重复次数。这可以通过几种方式完成，以下我们将展示一些示例：
- en: '`{m}` specifies exactly `m` copies of RE to match. Fewer matches cause a non-match
    and returns `None:`'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{m}` 指定精确匹配 `m` 次的 RE。更少的匹配会导致不匹配并返回 `None`：'
- en: '[PRE122]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is as follows:'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE123]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '`{m,n}` specifies exactly `m` to `n` copies of `RE` to match:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{m,n}` 指定精确匹配 `m` 到 `n` 次的 `RE`：'
- en: '[PRE124]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output is as follows:'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE125]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Omitting `m` specifies a lower bound of zero:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 省略 `m` 指定下界为零：
- en: '[PRE126]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The output is as follows:'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE127]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Omitting `n` specifies an infinite upper bound:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 省略 `n` 指定无限上界：
- en: '[PRE128]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The output is as follows:'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE129]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`{m,n}?` specifies `m` to `n` copies of RE to match in a non-greedy fashion:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{m,n}?` 指定非贪婪方式匹配 RE 的 `m` 到 `n` 次复制：'
- en: '[PRE130]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The output is as follows:'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE131]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Exercise 105: Sets of Matching Characters'
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 105：匹配字符集
- en: 'To match an arbitrarily complex pattern, we need to be able to include a logical
    combination of characters together as a bunch. Regex gives us that kind of capability:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配任意复杂的模式，我们需要能够将字符的逻辑组合作为一个整体包括进来。Regex 给我们提供了这种能力：
- en: 'The following examples demonstrate such uses of regex. `[x,y,z]` matches x,
    y, or z:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例展示了 regex 的这种用法。`[x,y,z]` 匹配 x、y 或 z：
- en: '[PRE132]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The output will be as follows:'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE133]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: A range of characters can be matched inside the set using -. This is one of
    the most widely used regex techniques!
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用 `-` 在集合内匹配字符范围。这是最广泛使用的 regex 技术之一！
- en: 'Suppose we want to pick out an email address from a text. Email addresses are
    generally of the form `<some name>@<some domain name>.<some domain identifier>`:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想要从文本中提取电子邮件地址。电子邮件地址通常具有以下形式 `<some name>@<some domain name>.<some domain
    identifier>`：
- en: '[PRE134]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The output is as follows:'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE135]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Look at the regex pattern inside the [ … ]. It is ''`a-zA-Z''`. This covers
    all alphabets, including lowercase and uppercase! With this one simple regex,
    you are able to match any (pure) alphabetical string for that part of the email.
    Now, the next pattern is ''`@`'', which is added to the previous regex by a ''`+`''
    character. This is the way to build up a complex regex: by adding/stacking up
    individual regex patterns. We also use the same `[a-zA-Z]` for the email domain
    name and add a ''`.com`'' at the end to complete the pattern as a valid email
    address. Why \.? Because, by itself, DOT (.) is used as a special modifier in
    regex, but here we want to use DOT (.) just as DOT (.), not as a modifier. So,
    we need to precede it by a ''\''.'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看 [ … ] 内部的 regex 模式。它是 '`a-zA-Z'`。这涵盖了所有字母，包括小写和大写！通过这个简单的 regex，你能够匹配任何（纯）字母字符串作为电子邮件该部分的匹配。接下来，下一个模式是
    '`@`'，它通过一个 '`+' 字符添加到前面的 regex 中。这是构建复杂 regex 的方法：通过添加/堆叠单个 regex 模式。我们也使用相同的
    `[a-zA-Z]` 作为电子邮件域名，并在末尾添加 `'`.com'` 以完成模式，使其成为一个有效的电子邮件地址。为什么是 `\.`？因为，单独的 DOT
    (.) 在 regex 中用作特殊修饰符，但在这里我们只想使用 DOT (.) 作为 DOT (.)，而不是修饰符。因此，我们需要在它之前加上一个 `\`。
- en: So, with this regex, we could extract the first email address perfectly but
    got '`No match`' with the second one.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，使用这个 regex，我们可以完美地提取第一个电子邮件地址，但第二个却得到了 `'No match'`。
- en: What happened with the second email ID?
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个电子邮件 ID 发生了什么？
- en: The regex could not capture it because it had the number '12' in the name! That
    pattern is not captured by the expression [a-zA-Z].
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式无法捕获它，因为它在名称中包含了数字 '12'！这个模式没有被表达式 [a-zA-Z] 捕获。
- en: 'Let''s change that and add the digits as well:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们改变它并添加数字：
- en: '[PRE136]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The output is as follows:'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE137]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Now, we catch the first email ID perfectly. But what's going on with the second
    one? Again, we got a mismatch. The reason is that we changed the .com to .org
    in that email, and in our regex expression, that portion was hardcoded as `.com`,
    so it did not find a match.
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们完美地捕获了第一个电子邮件ID。但第二个电子邮件ID发生了什么？再次，我们得到了一个不匹配。原因是我们在那个电子邮件中将 .com 改为了 .org，而在我们的正则表达式表达式中，这部分被硬编码为
    `.com`，因此它没有找到匹配项。
- en: 'Let''s try to address this in the following regex:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在下面的正则表达式中尝试解决这个问题：
- en: '[PRE138]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output is as follows:'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE139]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In this regex, we used the fact that most domain identifiers have 2 or 3 characters,
    so we used `[a-zA-Z]{2,3}` to capture that.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个正则表达式中，我们使用了这样一个事实，即大多数域名标识符有2到3个字符，所以我们使用了 `[a-zA-Z]{2,3}` 来捕获它。
- en: What happened with the second email ID? This is an example of the small tweaks
    that you can make to stay ahead of telemarketers who want to scrape online forums
    or any other corpus of text and extract your email ID. If you do not want your
    email to be found, you can change `@` to `[AT]` and . to `[DOT]` ,and hopefully
    that can beat some regex techniques (but not all)!
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个电子邮件ID发生了什么？这是一个示例，说明你可以进行一些小的调整，以领先于想要从在线论坛或其他文本库中抓取并提取你的电子邮件ID的推销员。如果你不希望你的电子邮件被找到，你可以将
    `@` 改为 `[AT]`，将 . 改为 `[DOT]`，并希望这可以击败一些正则表达式技术（但不是所有技术）！
- en: 'Exercise 106: The use of OR in Regex using the OR Operator'
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习106：使用OR操作符在正则表达式中的使用
- en: 'Because regex patterns are like complex and compact logical constructors themselves,
    it makes perfect sense that we want to combine them to construct even more complex
    programs when needed. We can do that by using the `|` operator:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 因为正则表达式模式本身就像复杂而紧凑的逻辑构造器，所以当我们需要构建更复杂的程序时，我们想要将它们组合起来，这是完全有道理的。我们可以通过使用 `|`
    操作符来实现这一点：
- en: 'The following example demonstrates the use of the OR operator:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例演示了使用OR操作符的使用：
- en: '[PRE140]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The output is as follows:'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE141]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: So, here, we are trying to extract patterns of 10-digit numbers that could be
    phone numbers. Note the use of `{10}` to denote exactly 10-digit numbers in the
    pattern. But the second number could not be matched for obvious reasons – it had
    '-' symbols inserted in between groups of numbers.
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在这里，我们试图提取可能是电话号码的10位数字的模式。注意模式中使用 `{10}` 来表示正好10位数字。但第二个数字由于明显的原因无法匹配——它在数字组之间插入了破折号。
- en: 'Use multiple smaller regexes and logically combine them by using the following
    command:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个较小的正则表达式，并通过以下命令逻辑组合它们：
- en: '[PRE142]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The output is as follows:'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE143]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Phone numbers are written in a myriad of ways and if you search on the web,
    you will see examples of very complex regexes (written not only in Python but
    other widely used languages, for web apps such as JavaScript, C++, PHP, Perl,
    and so on) for capturing phone numbers.
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电话号码以无数种方式书写，如果你在网上搜索，你会看到非常复杂的正则表达式示例（不仅是在Python中，还在其他广泛使用的语言中，如JavaScript、C++、PHP、Perl等，用于捕获电话号码）。
- en: 'Create four strings and execute `print_match` on them:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建四个字符串并在它们上执行 `print_match`：
- en: '[PRE144]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The output is as follows:'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE145]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '`The findall` Method'
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`findall` 方法'
- en: The last regex method that we will learn in this chapter is `findall`. Essentially,
    it is a **search-and-aggregate** method, that is, it puts all the instances that
    match with the regex pattern in a given text and returns them in a list. This
    is extremely useful, as we can just count the length of the returned list to count
    the number of occurrences or pick and use the returned pattern-matched words one
    by one as we see fit.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习的最后一个正则表达式方法是 `findall`。本质上，它是一个**搜索和聚合**方法，也就是说，它将所有与正则表达式模式匹配的实例放入给定的文本中，并以列表的形式返回它们。这非常有用，因为我们只需计算返回列表的长度就可以计算出现的次数，或者我们可以根据需要逐个选择并使用返回的模式匹配词。
- en: Note that, although we are giving short examples of single sentences in this
    chapter, you will often deal with a large corpus of text when using a RegEx.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管在本章中我们给出了单个句子的简短示例，但使用正则表达式时，你通常会处理大量的文本。
- en: 'In those cases you are likely to get many matches from a single regex pattern
    search. For all of those cases, the `findall` method is going to be the most useful:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可能会从单个正则表达式模式搜索中获得许多匹配项。对于所有这些情况，`findall` 方法将是最有用的：
- en: '[PRE146]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The output is as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE147]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Activity 9: Extracting the Top 100 eBooks from Gutenberg'
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 9：从古腾堡提取前 100 本电子书
- en: Project Gutenberg encourages the creation and distribution of eBooks by encouraging
    volunteer efforts to digitize and archive cultural works. This activity aims to
    scrape the URL of Project Gutenberg's Top 100 eBooks to identify the eBooks' links.
    It uses BeautifulSoup4 to parse the HTML and regular expression code to identify
    the Top 100 eBook file numbers.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 古腾堡项目通过鼓励志愿者努力数字化和归档文化作品来鼓励电子书创作和分发。本活动的目的是抓取古腾堡前 100 本电子书的 URL 以识别电子书的链接。它使用
    BeautifulSoup4 解析 HTML 并使用正则表达式代码来识别前 100 本电子书的文件编号。
- en: You can use those book ID numbers to download the book into your local drive
    if you want.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将书籍下载到本地驱动器，可以使用那些书籍 ID 号。
- en: Head over to the supplied Jupyter notebook (in the GitHub repository) to work
    on this activity.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 前往提供的 Jupyter 笔记本（在 GitHub 仓库中）进行此活动的操作。
- en: 'These are the steps that will help you solve this activity:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您解决此活动：
- en: Import the necessary libraries, including `regex` and `beautifulsoup`.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库，包括 `regex` 和 `beautifulsoup`。
- en: Check the SSL certificate.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 SSL 证书。
- en: Read the HTML from the URL.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 URL 读取 HTML。
- en: Write a small function to check the status of the web request.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个小函数来检查网络请求的状态。
- en: Decode the response and pass this on to BeautifulSoup for HTML parsing.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码响应并将此传递给 BeautifulSoup 进行 HTML 解析。
- en: Find all the `href` tags and store them in the list of links. Check what the
    list looks like – print the first 30 elements.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到所有的 `href` 标签并将它们存储在链接列表中。检查列表看起来像什么——打印前 30 个元素。
- en: Use a regular expression to find the numeric digits in these links. These are
    the file numbers for the top 100 eBooks.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正则表达式在这些链接中找到数字。这些是前 100 本电子书的文件编号。
- en: Initialize the empty list to hold the file numbers over an appropriate range
    and use `regex` to find the numeric digits in the link `href` string. Use the
    `findall` method.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个空列表来存储文件编号，在适当的范围内，并使用 `regex` 在 `href` 字符串中找到数字，使用 `findall` 方法。
- en: What does the `soup` object's text look like? Use the .`text` method and print
    only the first 2,000 characters (do not print the whole thing, as it is too long).
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`soup` 对象的文本看起来是什么样子？使用 `.text` 方法并仅打印前 2,000 个字符（不要打印整个内容，因为它太长了）。'
- en: Search in the extracted text (using a regular expression) from the soup object
    to find the names of the top 100 eBooks (yesterday's ranking).
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从 `soup` 对象提取的文本（使用正则表达式）中搜索以找到前 100 本电子书的名称（昨天的排名）。
- en: Create a starting index. It should point at the text *Top 100 Ebooks yesterday*.
    Use the `splitlines` method of soup.text. It splits the lines of text of the soup
    object.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个起始索引。它应该指向文本 *Top 100 Ebooks yesterday*。使用 soup.text 的 `splitlines` 方法。它将
    soup 对象的文本行分割成行。
- en: 'Loop 1-100 to add the strings of the next 100 lines to this temporary list.
    Hint: use the `splitlines` method.'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环 1-100，将下一 100 行的字符串添加到这个临时列表中。提示：使用 `splitlines` 方法。
- en: Use a regular expression to extract only text from the name strings and append
    it to an empty list. Use `match` and `span` to find the indices and use them.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正则表达式从名称字符串中提取仅文本并将其附加到空列表中。使用 `match` 和 `span` 找到索引并使用它们。
- en: Note
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 315.
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 315 页找到。
- en: 'Activity 10: Building Your Own Movie Database by Reading an API'
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 10：通过读取 API 构建自己的电影数据库
- en: In this activity, you will build a complete movie database by communicating
    and interfacing with a free API. You will learn about obtaining a unique user
    key that must be used when your program tries to access the API. This activity
    will teach you general chapters about working with an API, which are fairly common
    for other highly popular API services such as Google or Twitter. Therefore, after
    doing this exercise, you will be confident about writing more complex programs
    to scrape data from such services.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将通过与免费 API 进行通信和接口来构建一个完整的电影数据库。您将了解在程序尝试访问 API 时必须使用的唯一用户密钥。此活动将教授您有关使用
    API 的一般章节，这对于其他非常流行的 API 服务（如 Google 或 Twitter）来说相当常见。因此，完成此练习后，您将自信地编写更复杂的程序来从这些服务中抓取数据。
- en: 'The aims of this activity are as follows:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目标如下：
- en: To retrieve and print basic data about a movie (the title is entered by the
    user) from the web (OMDb database)
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络（OMDb 数据库）检索并打印关于一部电影（标题由用户输入）的基本数据
- en: If a poster of the movie can be found, it downloads the file and saves it at
    a user-specified location
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到电影的海报，它将下载文件并保存在用户指定的位置
- en: 'These are the steps that will help you solve this activity:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您解决这个活动：
- en: Import `urllib.request`, `urllib.parse`, `urllib.error`, and `json`.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `urllib.request`、`urllib.parse`、`urllib.error` 和 `json`。
- en: Load the secret API key (you have to get one from the OMDb website and use that;
    it has a daily limit of 1,000) from a JSON file stored in the same folder in a
    variable, by using `json.loads.`
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从同一文件夹中存储的 JSON 文件中加载秘密 API 密钥（您必须从 OMDb 网站获取一个并使用它；它有每日 1,000 次的限制），通过使用 `json.loads()`
    将其存储在一个变量中。
- en: Obtain a key and store it in JSON as `APIkeys.json`.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个密钥并将其存储在 JSON 中的 `APIkeys.json`。
- en: Open the `APIkeys.json` file.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `APIkeys.json` 文件。
- en: Assign the OMDb portal ([http://www.omdbapi.com/?](http://www.omdbapi.com/?))
    as a string to a variable.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 OMDb 站点（[http://www.omdbapi.com/?](http://www.omdbapi.com/?)）作为一个字符串赋值给一个变量。
- en: Create a variable called `apikey` with the last portion of the URL (`&apikey=secretapikey`),
    where `secretapikey` is your own API key.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `apikey` 的变量，其值为 URL 的最后一部分（`&apikey=secretapikey`），其中 `secretapikey`
    是您自己的 API 密钥。
- en: Write a utility function called `print_json` to print the movie data from a
    JSON file (which we will get from the portal).
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `print_json` 的实用函数，用于从 JSON 文件（我们将从该门户获取）打印电影数据。
- en: Write a utility function to download a poster of the movie based on the information
    from the JSON dataset and save it in your local folder. Use the `os` module. The
    poster data is stored in the JSON key `Poster`. Use the Python command to open
    a file and write the poster data. Close the file after you're done. This function
    will save the poster data as an image file.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实用函数，根据 JSON 数据集中的信息下载电影的海报，并将其保存在您的本地文件夹中。使用 `os` 模块。海报数据存储在 JSON 键 `Poster`
    中。使用 Python 命令打开文件并写入海报数据。完成后关闭文件。此函数将海报数据保存为图像文件。
- en: Write a utility function called `search_movie` to search for a movie by its
    name, print the downloaded `JSON` data, and save the movie poster in the local
    folder. Use a `try-except` loop for this. Use the previously created `serviceurl`
    and `apikey` variables. You have to pass on a dictionary with a key, `t`, and
    the movie name as the corresponding value to the `urllib.parse.urlencode()` function
    and then add the `serviceurl` and `apikey` to the output of the function to construct
    the full URL. This URL will be used to access the data. The `JSON` data has a
    key called `Response`. If it is `True`, that means the read was successful. Check
    this before processing the data. If it's not successful, then print the `JSON`
    key `Error`, which will contain the appropriate error message returned by the
    movie database.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `search_movie` 的实用函数，通过电影名称搜索电影，打印下载的 `JSON` 数据，并将电影海报保存在本地文件夹中。使用 `try-except`
    循环。使用之前创建的 `serviceurl` 和 `apikey` 变量。您必须将包含键 `t` 和电影名称作为相应值的字典传递给 `urllib.parse.urlencode()`
    函数，然后将 `serviceurl` 和 `apikey` 添加到函数的输出中，以构造完整的 URL。此 URL 将用于访问数据。`JSON` 数据有一个名为
    `Response` 的键。如果是 `True`，则表示读取成功。在处理数据之前检查这一点。如果不成功，则打印 `JSON` 键 `Error`，其中将包含电影数据库返回的适当错误消息。
- en: Test the `search_movie` function by entering `Titanic`.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 `Titanic` 测试 `search_movie` 函数。
- en: Test the `search_movie` function by entering `"Random_error"` (obviously, this
    will not be found, and you should be able to check whether your error catching
    code is working properly).
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 `"Random_error"`（显然，这将找不到，你应该能够检查你的错误捕获代码是否正常工作）来测试 `search_movie` 函数。
- en: 'Note:'
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: The solution for this activity can be found on page 320.
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第 320 页找到。
- en: Summary
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through several important concepts and learning modules
    related to advanced data gathering and web scraping. We started by reading data
    from web pages using two of the most popular Python libraries – `requests` and
    `BeautifulSoup`. In this task, we utilized the previous chapter's knowledge about
    the general structure of HTML pages and their interaction with Python code. We
    extracted meaningful data from the Wikipedia home page during this process.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与高级数据收集和网络抓取相关的重要概念和学习模块。我们首先使用两个最流行的 Python 库——`requests` 和 `BeautifulSoup`
    从网页中读取数据。在这个任务中，我们利用了上一章关于 HTML 页面的一般结构和它们与 Python 代码交互的知识。在这个过程中，我们从维基百科主页中提取了有意义的资料。
- en: Then, we learned how to read data from XML and JSON files, two of the most widely
    used data streaming/exchange formats on the web. For the XML part, we showed you
    how to traverse the tree-structure data string efficiently to extract key information.
    For the JSON part, we mixed it with reading data from the web using an API (Application
    Program Interface). The API we consumed was RESTful, which is one of the major
    standards in Web API.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何从XML和JSON文件中读取数据，这两种格式是网络中最广泛使用的两种数据流/交换格式。对于XML部分，我们向您展示了如何高效地遍历树形结构数据字符串以提取关键信息。对于JSON部分，我们将它与使用API（应用程序接口）从网络中读取数据结合起来。我们使用的API是RESTful的，这是Web
    API的主要标准之一。
- en: At the end of this chapter, we went through a detailed exercise of using regex
    techniques in tricky string-matching problems to scrape useful information from
    a large and messy text corpus, parsed from HTML. This chapter should come in extremely
    handy for string and text processing tasks in your data wrangling career.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们详细练习了使用正则表达式技术在复杂的字符串匹配问题中提取有用信息，这些信息是从HTML解析的大规模杂乱文本语料库中获得的。这一章对于你在数据处理职业生涯中的字符串和文本处理任务将非常有用。
- en: In the next chapter, we will learn about databases with Python.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Python进行数据库操作。
