- en: Geospatial REST API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理空间 REST API
- en: Publishing data for consumption on the web is a major component of modern GIS.
    To transfer data from remote servers to remote clients, most geospatial publishing
    software stacks use **Representational State Transfer** (**REST**) web services.
    In response to web requests for specific data resources, REST services return
    **JavaScript Object Notation** (**JSON**)-encoded data to the requesting client
    machine. The web services are combined in an application programming interface,
    or API, which will contain the endpoints that represent each data resource available
    for querying.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上发布数据以供消费是现代 GIS 的一个重要组成部分。为了将数据从远程服务器传输到远程客户端，大多数地理空间发布软件堆栈都使用 **表示状态转移**（REST）网络服务。对于特定数据资源的网络请求，REST
    服务将 **JavaScript 对象表示法**（JSON）编码的数据返回给请求的客户端机器。这些网络服务组合成一个应用程序编程接口，或 API，其中将包含代表每个可查询数据资源的端点。
- en: By combining a Python web framework with **object-relational mapping** (**ORM**)
    and a PostGIS backend, we can create a custom REST API that will respond to web
    requests with JSON. For this exercise, we will use the Flask web framework and
    the SQLAlchemy module with GeoAlchemy2 providing spatial ORM capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 Python 网络框架、**对象关系映射**（ORM）和 PostGIS 后端，我们可以创建一个自定义的 REST API，该 API 将以
    JSON 格式响应网络请求。在这个练习中，我们将使用 Flask 网络框架和 SQLAlchemy 模块，以及 GeoAlchemy2 提供的空间 ORM
    功能。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: REST API components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API 组件
- en: JSON response formatting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 响应格式化
- en: How to process `GET`, `POST`, `PUT`, and `DELETE` request methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理 `GET`、`POST`、`PUT` 和 `DELETE` 请求方法
- en: Performing geospatial operations using the API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 API 执行地理空间操作
- en: How to deploy a Flask website using IIS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 IIS 部署 Flask 网站
- en: Writing a REST API in Python
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中编写 REST API
- en: To understand the components of a REST API with JSON response, we will utilize
    the Flask web framework, a PostgreSQL/PostGIS database, and SQLAlchemy and GeoAlchemy2
    for ORM queries. Flask will be used to create the URL endpoints for the API. PostGIS
    will store the data in tables defined by SQLAlchemy models, which define the column
    types for all columns except the geometry columns, which are defined by GeoAlchemy2
    column types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解具有 JSON 响应的 REST API 的组件，我们将利用 Flask 网络框架、PostgreSQL/PostGIS 数据库、SQLAlchemy
    和 GeoAlchemy2 进行 ORM 查询。Flask 将用于创建 API 的 URL 端点。PostGIS 将将数据存储在由 SQLAlchemy 模型定义的表中，这些模型定义了所有列的类型，除了由
    GeoAlchemy2 列类型定义的几何列。
- en: REST
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: 'REST is a standard for web services, designed to accept requests and parameters
    and return a representation of that data, usually in a JSON format but sometimes
    in XML or HTML format. APIs that use REST architecture must meet these architectural
    constraints:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一种用于网络服务的标准，旨在接受请求和参数，并返回数据的表示，通常以 JSON 格式，但有时也以 XML 或 HTML 格式。使用 REST
    架构的 API 必须满足以下架构约束：
- en: Client-server interactions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器交互
- en: Statelessness
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Cacheablitity
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存能力
- en: Uniform interface
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一接口
- en: Layered system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统
- en: The client (a web browser or a remote computer) will send a request to a server
    at a designated URL endpoint. The request can include parameters that limit the
    data objects returned, much like conditionals in an SQL statement. It is stateless,
    meaning that each request must contain the request parameters and cannot refer
    to the results of another request. The data returned must be explicitly marked
    as cacheable or non-cacheable, to allow clients to decide if the data can be stored,
    or must be requested when required. When data is requested, all available API
    endpoints relating to the data (including links for adding or deleting data, if
    available) are returned as links along with the data representation. The underlying
    architecture of the server is not revealed by the API and can be manipulated (machines
    added or removed) without any change in the API structure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端（一个网页浏览器或远程计算机）将向指定 URL 端点的服务器发送请求。请求可以包含参数，这些参数限制了返回的数据对象，就像 SQL 语句中的条件语句一样。它是无状态的，意味着每个请求都必须包含请求参数，并且不能引用另一个请求的结果。返回的数据必须明确标记为可缓存或不可缓存，以便客户端决定数据是否可以存储，或者是否在需要时请求。当请求数据时，所有与数据相关的可用
    API 端点（包括添加或删除数据的链接，如果有的话）都作为链接与数据表示一起返回。API 的底层架构不会通过 API 揭示，并且可以在不改变 API 结构的情况下进行操作（添加或删除机器）。
- en: JSON
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: JSON is designed to be understood by humans and machines alike. JavaScript data
    objects are easily generated from Python dictionaries, as they use the same key
    value structure and curly bracket notation. Python contains a built-in library
    for generating JSON (the `json` module), and web frameworks such as Flask also
    include code for generating JSON responses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JSON旨在被人类和机器 alike理解。JavaScript数据对象可以轻松地从Python字典生成，因为它们使用相同的键值结构和花括号表示法。Python包含一个用于生成JSON的内置库（`json`模块），而Web框架如Flask也包含生成JSON响应的代码。
- en: Multiple JSON standards exist for geospatial data, including GeoJSON and Esri
    JSON. Within this chapter, the REST API will use the GeoJSON format to respond
    to requests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地理空间数据，存在多个JSON标准，包括GeoJSON和Esri JSON。在本章中，REST API将使用GeoJSON格式来响应请求。
- en: 'Read more about GeoJSON here: [http://geojson.org/](http://geojson.org/).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于GeoJSON的信息：[http://geojson.org/](http://geojson.org/)。
- en: Python for REST API
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python用于REST API
- en: Python is a fantastic language for writing a REST API. It has modules that allow
    for database queries and others that process the HTTP web requests into the URL
    and parameter components. Using these modules, the requested resource is retrieved
    from the database and returns the data as JSON using modules that convert between
    Python dictionaries and JSON objects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python是编写REST API的绝佳语言。它包含允许进行数据库查询的模块，以及其他将HTTP Web请求处理成URL和参数组件的模块。使用这些模块，可以从数据库中检索请求的资源，并使用在Python字典和JSON对象之间进行转换的模块将数据作为JSON返回。
- en: While a Python-based API can be built using the standard library, using a web
    framework to build the API will speed up the development time and enable component
    modules to be added as needed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用标准库构建基于Python的API，但使用Web框架来构建API将加快开发速度，并允许根据需要添加组件模块。
- en: Flask
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask
- en: Flask is a good choice for a Python web framework for a REST API. Partnered
    with SQLAlchemy and GeoAlchemy2 (see [Chapter 11](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml), *Flask
    and GeoAlchemy2*, for more information on both), it allows the REST URL endpoints
    to be paired with a view (a Python function) that will process the request in
    different ways depending on the request method (such as `GET` and  `POST`, to
    name two examples) and return JSON data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是Python Web框架构建REST API的一个好选择。与SQLAlchemy和GeoAlchemy2（见第11章，*Flask和GeoAlchemy2*，了解更多关于这两个库的信息）配合使用，它允许将REST
    URL端点与视图（一个Python函数）配对，该视图将根据请求方法（例如`GET`和`POST`，仅举两个例子）以不同的方式处理请求并返回JSON数据。
- en: REST modules
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST模块
- en: 'As Flask is built to be extensible, there are many add-on modules that are
    designed to ease the creation of REST APIs. These include:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flask旨在可扩展，因此有许多旨在简化REST API创建的附加模块。这些包括：
- en: Flask-RESTful ([https://flask-restful.readthedocs.io/en/latest/](https://flask-restful.readthedocs.io/en/latest/))
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-RESTful ([https://flask-restful.readthedocs.io/en/latest/](https://flask-restful.readthedocs.io/en/latest/))
- en: Eve ([http://python-eve.org/](http://python-eve.org/)), which is built on top
    of Flask and Cerberus
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eve ([http://python-eve.org/](http://python-eve.org/))，它建立在Flask和Cerberus之上
- en: Flask-REST-JSONAPI ([https://github.com/miLibris/flask-rest-jsonapi](https://github.com/miLibris/flask-rest-jsonapi))
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-REST-JSONAPI ([https://github.com/miLibris/flask-rest-jsonapi](https://github.com/miLibris/flask-rest-jsonapi))
- en: This chapter will use vanilla Flask capabilities, along with SQLAlchemy and
    GeoAlchemy2 for database queries, to illustrate the basics of API creation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用纯Flask功能，结合SQLAlchemy和GeoAlchemy2进行数据库查询，以说明API创建的基本原理。
- en: Other frameworks
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他框架
- en: Django and GeoDjango (covered in [Chapter 12](a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml),
    *GeoDjango*) are used extensively for REST API creation. With its batteries-included
    design motto, Django allows for easy API development. The Django REST framework
    adds easy API publication to the code base.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Django和GeoDjango（在第12章，*GeoDjango*中介绍）被广泛用于创建REST API。遵循其“内置电池”的设计理念，Django允许轻松地进行API开发。Django
    REST框架简化了代码库中的API发布。
- en: 'Explore the Django REST Framework here: [http://www.django-rest-framework.org/](http://www.django-rest-framework.org/).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里探索Django REST框架：[http://www.django-rest-framework.org/](http://www.django-rest-framework.org/)。
- en: Variables in Flask URLs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask URL中的变量
- en: When using Flask for URL processing, it is useful to understand how to add variables
    into URLs, as each resource may be requested using an ID or string identifier
    (for example, a state name). Flask URLs use placeholders to pass data into function
    parameters and utilize it as variables within the view for each endpoint. Using
    a converter, numerical data can be assigned a type within the placeholder; the
    default is a string type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Flask进行URL处理时，了解如何将变量添加到URL中是有用的，因为每个资源可能使用ID或字符串标识符（例如，州名）进行请求。Flask URL使用占位符将数据传递到函数参数中，并在每个端点的视图中将其作为变量使用。使用转换器，可以在占位符中为数值数据分配类型；默认类型是字符串类型。
- en: Number converters
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字转换器
- en: 'In this example, a placeholder with a converter for an integer ID is added
    at the end of the URL. By adding `int:` before the placeholder variable (`arena_id`),
    the ID can be used to query the `Arena` model/database table using the `get(id)`
    method of `session.query`, which expects an integer. If the datatype converter
    is not specified in the placeholder, the `arena_id` variable will contain a string
    character and won''t be used by the `get(id)` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，在URL末尾添加了一个带有整数ID转换器的占位符。通过在占位符变量（`arena_id`）之前添加`int:`，可以使用ID通过`session.query`的`get(id)`方法查询`Arena`模型/数据库表，该方法期望一个整数。如果占位符中没有指定数据类型转换器，`arena_id`变量将包含字符串字符，并且不会被`get(id)`方法使用：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the parameter datatype specified, the requested `arena` object is returned
    by the ORM query and can be processed for a response.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定了参数数据类型后，ORM查询将返回请求的`arena`对象，并可以对其进行处理以生成响应。
- en: Other data converters
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他数据转换器
- en: 'Besides integers, which use the converter `int`, floating point data can be
    converted using `float`, and URL data can be converted using `path`. Strings,
    which use the converter `string`, are the default.  In this case, a `float` value
    is captured and used to compare against `county` geometry areas. As the SRID for
    this data is in WKID, the area is in an odd format, but this query will work:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了整数，可以使用`float`转换浮点数据，使用`path`转换URL数据。字符串（使用转换器`string`）是默认的。在这种情况下，捕获并使用一个`float`值来与`county`几何体面积进行比较。由于此数据的SRID在WKID中，面积以奇特的格式表示，但此查询将有效：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the value captured from the URL variable is compared to the
    `county` geometry using the `ST_Area` function, which borrows from PostGIS spatial
    SQL.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，从URL变量捕获的值使用`ST_Area`函数与`county`几何体进行比较，该函数借鉴了PostGIS空间SQL。
- en: Read more about GeoAlchemy2 spatial functionality, and its use of spatial SQL,
    here: [http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html](http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于GeoAlchemy2空间功能及其使用空间SQL的信息：[http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html](http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html)。
- en: Request methods
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求方法
- en: When using a REST API, multiple HTTP request methods can be utilized. The `GET`
    method is used to request data, the `POST` method is used to add new data, the `PUT` method
    is used to update data, and the `DELETE` method is used to remove data from the
    database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用REST API时，可以充分利用多种HTTP请求方法。`GET`方法用于请求数据，`POST`方法用于添加新数据，`PUT`方法用于更新数据，而`DELETE`方法用于从数据库中删除数据。
- en: GET
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET
- en: 'For Flask URL endpoints, `GET` requests are specified using the method `GET`.
    Data can be passed as an argument and accessed using `request.args`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Flask URL端点，使用`GET`请求指定方法`GET`。数据可以作为参数传递，并通过`request.args`访问：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The response data, processed into a list of Python dictionaries using a list
    comprehension, is added to another Python dictionary, and then converted to JSON
    using `jsonify` from Flask.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应数据通过列表推导式处理成Python字典列表，然后添加到另一个Python字典中，并使用Flask的`jsonify`将其转换为JSON。
- en: POST
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST
- en: 'The `POST` requests carry data that can be processed to add to a database.
    To differentiate a `POST` request, the Flask requests object has the `method`
    property, which can be checked to see if the request method was `GET` or `POST`.
    If we create a `form` (called `AddForm`) to add new `arenas` to the `Arenas` table,
    we could process the data submitted as a `POST` request and add it the database
    using the session manager:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`请求携带的数据可以处理以添加到数据库中。为了区分`POST`请求，Flask请求对象有一个`method`属性，可以检查请求方法是否为`GET`或`POST`。如果我们创建一个`form`（称为`AddForm`）来向`Arenas`表添加新的`arenas`，我们可以处理作为`POST`请求提交的数据，并使用会话管理器将其添加到数据库中：'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As this method will accept both `GET` and `POST` requests, it sends a different
    response based on each request method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法将接受 `GET` 和 `POST` 请求，因此它根据每个请求方法发送不同的响应。
- en: Other available request methods
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他可用的请求方法
- en: While `GET` and `POST` are the main request methods, others are available for
    processing data. For the example API, we will only use `GET`, and `POST`, and
    `DELETE`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `GET` 和 `POST` 是主要请求方法，但还有其他方法可用于处理数据。对于示例 API，我们只会使用 `GET`、`POST` 和 `DELETE`。
- en: PUT
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT
- en: Similar to a `POST` request, a `PUT` request will carry data to update or add
    to a database. It will attempt to update the data multiple times to ensure complete
    transmission of the update.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `POST` 请求类似，`PUT` 请求将携带数据以更新或添加到数据库中。它将尝试多次更新数据以确保更新完全传输。
- en: DELETE
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE
- en: 'The `DELETE` method will remove a resource from the specified endpoint, for
    example, deleting an `arena` from the `Arenas` table. It requires a record identifier
    to specify the resource to be removed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 方法将从指定的端点删除资源，例如，从 `Arenas` 表中删除一个 `arena`。它需要一个记录标识符来指定要删除的资源：'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The REST API application
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是一个 REST API 应用程序
- en: To enable access to a database of NBA Arenas, US States, US Counties, and US
    Congressional Districts, we will build a REST API. The API will allow for queries
    about tables and about specific table resources, that is, rows of data. It will
    also allow for geospatial queries.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问 NBA 场馆、美国州、美国县和美国国会选区的数据库，我们将构建一个 REST API。该 API 将允许查询表和特定表资源，即数据行。它还将允许进行地理空间查询。
- en: Application components
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: 'The components of this application include:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的组件包括：
- en: The database, created in [Chapter 11](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml), 
    *Flask and GeoAlchemy2*, which contains the tables for NBA Arenas, US States,
    US Counties, and US Congressional Districts
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 11 章](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml) 中创建的数据库，*Flask 和 GeoAlchemy2*，其中包含
    NBA 场馆、美国州、美国县和美国国会选区的表
- en: The `app.py` file, which initiates the application when called by a Python executable
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py` 文件，当通过 Python 可执行文件调用时，它将启动应用程序'
- en: The `application` folder, which contains the application code and folders
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application` 文件夹，它包含应用程序代码和文件夹'
- en: The `__init__.py` file, which makes the `application` folder into a module,
    defines the Flask object and connects to the database
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py` 文件，它使 `application` 文件夹成为一个模块，定义 Flask 对象并连接到数据库'
- en: The `views.py` file, which defines the API endpoints, the view functions, and
    the return responses
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views.py` 文件，它定义了 API 端点、视图函数和返回的响应'
- en: The `models.py` file, which defines the database table models as Python classes
    that subclass from SQLAlchemy
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.py` 文件，它定义了数据库表模型作为从 SQLAlchemy 继承的 Python 类'
- en: The `forms.py` file, which defines the HTML forms
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forms.py` 文件，它定义了 HTML 表单'
- en: The `static` and `templates` folders, which contain templates and data
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 和 `templates` 文件夹，它们包含模板和数据'
- en: Application folder and file structure
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序文件夹和文件结构
- en: 'The example REST API requires specific files and folders to be created. The
    outer folder, called `arenaapp`, will contain the `app.py` file and the folder
    called `application`. Create the folder called `arenaapp`. Inside of it, create
    a folder called `application`. Inside of `application`, create the folders `static` and `templates`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 REST API 需要创建特定的文件和文件夹。外部文件夹，称为 `arenaapp`，将包含 `app.py` 文件和名为 `application`
    的文件夹。创建名为 `arenaapp` 的文件夹。在其内部，创建一个名为 `application` 的文件夹。在 `application` 内部，创建
    `static` 和 `templates` 文件夹：
- en: '![](img/0ac1faae-182b-48c2-8d4b-36df91aa8089.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ac1faae-182b-48c2-8d4b-36df91aa8089.png)'
- en: 'The other files, `views.py`, `models.py`, and `forms.py`, will be located inside
    of `application`. Two folders, `static` and `templates`, will store application
    data and HTML forms:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文件，`views.py`、`models.py` 和 `forms.py`，将位于 `application` 内部。两个文件夹 `static`
    和 `templates` 将存储应用程序数据和 HTML 表单：
- en: '![](img/0c2891c3-592b-4374-8a1d-c5a6e57bc6ed.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c2891c3-592b-4374-8a1d-c5a6e57bc6ed.png)'
- en: app.py
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: app.py
- en: 'Using an IDE or text editor, create a file inside `arenaapp` called `app.py`. Open
    this file and add the following lines; this file will be run by the Python executable
    to initiate the REST API application:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 或文本编辑器，在 `arenaapp` 内创建一个名为 `app.py` 的文件。打开此文件并添加以下行；此文件将由 Python 可执行文件运行以启动
    REST API 应用程序：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `__init__.py` file allows the `application` folder to be imported by `app.py`,
    allowing the Flask object `app ` and its `app.run()` method to be called.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 文件允许 `application` 文件夹被 `app.py` 导入，从而允许调用 Flask 对象 `app` 及其
    `app.run()` 方法。'
- en: __init__.py
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __init__.py
- en: 'Within the `application` folder, create a file called `__init__.py`. Inside
    of the file, add the following code (while adjusting the username and password
    to your specific database credentials:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application`文件夹内，创建一个名为`__init__.py`的文件。在文件内，添加以下代码（同时调整用户名和密码以匹配您的特定数据库凭据）：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Within this file, the Flask object, `app`, is created and configured. To connect
    to the database, a connection string is used and stored in the `app.config` dictionary
    as the `'SQLALCHEMY_DATABASE_URI'`. Remember to add the username and password
    into the connection string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，创建了Flask对象`app`并进行了配置。为了连接到数据库，使用了一个连接字符串并将其存储在`app.config`字典中的`'SQLALCHEMY_DATABASE_URI'`。请记住将用户名和密码添加到连接字符串中。
- en: The database
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: This will connect to the database created in [Chapter 11](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml),
    *Flask and GeoAlchemy2*.  It is generated from shapefiles that have been imported
    and structured to match the models described as we proceed. To ensure that the
    application will work, be sure that the database has been created and that the
    shapefiles were imported.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连接到在[第11章](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml)中创建的数据库，*Flask和GeoAlchemy2*。它是由导入并结构化以匹配我们逐步描述的模型的shapefiles生成的。为了确保应用程序能够工作，请确保已创建数据库并且已导入shapefiles。
- en: models.py
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: models.py
- en: Within `models.py`, the SQLAlchemy and GeoAlchemy2 modules are imported and
    the database session is initiated. The database models have their schemas defined
    as Python classes, allowing for queries and data updates.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models.py`中，导入了SQLAlchemy和GeoAlchemy2模块，并初始化了数据库会话。数据库模型以其Python类形式定义了模式，允许查询和数据更新。
- en: Importing required modules
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入所需的模块
- en: 'These modules enable the application to define the models and connect to the
    database:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块使应用程序能够定义模型并连接到数据库：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Declaring the session
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明会话
- en: 'From the `app.config` dictionary, the database connection string is passed
    to the `create_engine` function. Once `engine` is bound to the `sessionmaker`,
    a `session` can be initiated:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从`app.config`字典中，将数据库连接字符串传递给`create_engine`函数。一旦`engine`绑定到`sessionmaker`，就可以启动一个`session`：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A Python class called `Base` is created from the `declarative_base()` function.
    The `Base` class is then used to subclass all application classes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从`declarative_base()`函数创建了一个名为`Base`的Python类。然后使用`Base`类来子类化所有应用程序类。
- en: Declaring the models
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明模型
- en: 'For the models, all of the field types (for example, `Integer`, `String`, and `Float`)
    are defined using SQLAlchemy ORM-column classes, except for the geometry columns,
    which use the GeoAlchemy2  `Geometry` class. The `Geometry` class requires a geometry
    type and SRID:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型，所有字段类型（例如，`Integer`、`String`和`Float`）都使用SQLAlchemy ORM列类定义，除了几何列，它们使用GeoAlchemy2的`Geometry`类。`Geometry`类需要一个几何类型和SRID：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `County` class has a primary key field and a `name` field, as well as fields
    that define the many-to-one relationship with the `State` class. Instead of a
    `POINT` geometry type, it uses `MULTIPOLYGON`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`County`类有一个主键字段和一个`name`字段，以及定义与`State`类多对一关系的字段。它使用`MULTIPOLYGON`而不是`POINT`几何类型：'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `District` class represents US Congressional Districts. Stored with a `MULTIPOLYGON`
    geometry type and an SRID of `4326`, it has a many-to-one relationship with the
    `State` class. Each `district` stored is linked to the state in which it resides:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`District`类代表美国国会选区。以`MULTIPOLYGON`几何类型和SRID为`4326`存储，它与`State`类有一个多对一的关系。每个存储的`district`都与它所在的州相关联：'
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `State` class has one-to-many relationships with the `County` and `District`
    classes respectively, defined using the `relationship` function. It also has a
    `MULTIPOLYGON` geometry column with an SRID of `4326`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`State`类分别与`County`和`District`类具有一对一和一对多关系，使用`relationship`函数定义。它还有一个`MULTIPOLYGON`几何列，SRID为`4326`：'
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the fields and relationships defined, the next step is to create the REST
    API endpoints and write the views that will query the database and return GeoJSON
    responses.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了字段和关系后，下一步是创建REST API端点和编写查询数据库并返回GeoJSON响应的视图。
- en: forms.py
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: forms.py
- en: 'To capture data from the user, such as a new `arena`, a form will be used.
    Create a file called `forms.py` inside the `application` folder, and add the following
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获用户数据，例如一个新的`arena`，将使用表单。在`application`文件夹内创建一个名为`forms.py`的文件，并添加以下代码：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code will add the fields to a template, which will be discussed in the
    section on using `POST` methods. It will allow for code to be entered from an
    HTML template and passed to the server to add a new `arena`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将字段添加到模板中，这将在使用`POST`方法的章节中讨论。它将允许从HTML模板中输入代码并将其传递到服务器以添加新的`arena`。
- en: views.py
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: views.py
- en: The API endpoints and processing are contained within `views.py`. The views
    are imported within `__init__.py` to make them available to the `app` object.
    Open an IDE and save a file called `views.py` inside the `application` folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: API端点和处理包含在`views.py`中。视图在`__init__.py`中导入，以便它们对`app`对象可用。打开IDE并在`application`文件夹中保存一个名为`views.py`的文件。
- en: Importing modules
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入模块
- en: 'To enable the processing of web requests, we need to import functionality from
    Flask, GeoAlchemy2, and Shapely, a Python module for creating and processing geospatial
    data. We will also `import` the models and forms:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用Web请求的处理，我们需要从Flask、GeoAlchemy2和Shapely（一个用于创建和处理地理空间数据的Python模块）导入功能。我们还将导入模型和表单：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Base URL
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础URL
- en: 'Each API pattern can be different, but should generally include a base URL
    that indicates the API version and should link to the other endpoints available
    within the API. This application will use a base URL pattern of `nba`*/*`api`*/*`v0.1`.
    In this case, the home URL (`''/''`) will `redirect` to the base URL of the API:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个API模式可能不同，但通常应包括一个基础URL，该URL指示API版本，并应链接到API中可用的其他端点。此应用程序将使用基础URL模式`nba`*/*`api`*/*`v0.1`。在这种情况下，主页URL（`'/'`）将重定向到API的基础URL：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The endpoints for each of the following sections are available from the base
    URL. Each resource URL can be constructed by adding the resource-specific endpoint
    to the base URL.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下述各节中的端点均从基础URL提供。每个资源URL可以通过将资源特定的端点添加到基础URL来构建。
- en: Arenas
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arenas
- en: To request data from the `Arenas` table, we will define API endpoints and use
    view functions to query the `Arenas` model. Each response will be a package as
    GeoJSON. This endpoint (`'/arena'`) will return a GeoJSON response, which will
    vary based on the presence of variables added to the URL. These variables include
    arena ID and name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Arenas`表请求数据，我们将定义API端点并使用视图函数查询`Arenas`模型。每个响应都将作为一个GeoJSON包返回。此端点（`'/arena'`）将返回一个GeoJSON响应，该响应将根据添加到URL中的变量的存在而变化。这些变量包括arenas
    ID和名称。
- en: Getting all arenas
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有arenas
- en: 'To generate a response containing a representation of all `arenas`, a query
    is made using the SQLAlchemy ORM. To convert the query results into GeoJSON, a list
    comprehension is used to generate a list of dictionaries that describe each `arena`
    returned from the ORM query. The resulting list (`data`) is then added to a dictionary,
    which is converted from a Python dictionary to a JSON object using the `jsonify`
    function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成包含所有`arenas`表示的响应，使用SQLAlchemy ORM进行查询。为了将查询结果转换为GeoJSON，使用列表推导来生成一个字典列表，这些字典描述了从ORM查询返回的每个`arena`。然后，将生成的列表（`data`）添加到一个字典中，使用`jsonify`函数将该Python字典转换为JSON对象：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `name` and `id` field is returned, as well as the `longitude` and `latitude`.
    To limit the amount of data transmitted, the `latitude` and `longitude` are rounded
    to `6` decimals.  The low amount of precision required to describe the location
    of an `arena` makes this a reasonable limitation. While point data types are easier
    to return given that they consist of only two points, producing less data, polygon
    and polyline data are much larger and require more precision.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`name`和`id`字段，以及`longitude`和`latitude`。为了限制传输的数据量，将`latitude`和`longitude`四舍五入到`6`位小数。描述`arena`位置所需的高精度要求使得这种限制是合理的。由于点数据类型仅由两个点组成，产生的数据较少，因此更容易返回。而多边形和多段线数据则更大，需要更高的精度。
- en: 'Compared to loops, list comprehensions decrease the processing time required
    for iterating over lists. Learn more about list comprehensions here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与循环相比，列表推导减少了迭代列表所需的处理时间。在此处了解更多关于列表推导的信息：
- en: '[https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions. ](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions. ](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)'
- en: Getting arenas by ID
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过ID获取arenas
- en: 'By adding a numeric ID to the `arena` endpoint, the specific `arena` will be
    located and returned. The `session.query` method `get` is used to retrieve the
    requested `arena` object:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`arena`端点添加一个数字ID，可以定位并返回特定的`arena`。使用`session.query`方法的`get`来检索请求的`arena`对象：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The selected `arena` is added to a dictionary inside a list, which is then added
    to a dictionary and returned as JSON `data`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的`arena`被添加到列表中的一个字典内，然后该字典被添加到另一个字典中，并以JSON `data`的形式返回。
- en: Getting arenas by name
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称获取竞技场
- en: 'An `arena` can be requested by `name` at this endpoint. By utilizing a query
    condition, known as a `filter`, an `arena` matching the `name` provided will be
    retrieved. To add flexibility, a `like` operator is used (along with a `"%"` wildcard
    operator) to make it possible for the `arena` `name` entered to be complete. Instead,
    the string entered will be used to `filter` the query and return only `arena`
    objects whose names start with the string entered:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`name`在此端点请求`arena`。通过利用称为`filter`的查询条件，可以检索到与提供的`name`匹配的`arena`。为了增加灵活性，使用了一个`like`运算符（以及一个`"%"`通配符运算符），使得输入的`arena`
    `name`可以是完整的。相反，输入的字符串将被用于`filter`查询，并仅返回名称以该字符串开头的`arena`对象：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A list comprehension is used to generate the `arena` dictionaries. Here is
    an example of a response to a string query to the `arena` endpoint:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式生成`arena`字典。以下是对`arena`端点进行字符串查询的响应示例：
- en: '![](img/5c9a2ed6-0822-4ca2-a9a5-336bedb5c3c5.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c9a2ed6-0822-4ca2-a9a5-336bedb5c3c5.png)'
- en: A geospatial query
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理空间查询
- en: 'By adding one more URL component, the API is spatially enabled. Passing an
    `arena` ID and adding `"/intersect"` will use spatial queries to find data describing
    the requested NBA Arena. In this view function, the `County` and `District` tables
    are queried using an `intersect` `filter` (that is, the `county` containing the
    `arena` is identified using a point in polygon function). The underlying state
    is retrieved using a table relation between the `county` and the `state`. All
    of the geometry and the selected fields are returned:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个额外的URL组件，API被启用空间查询。传递一个`arena` ID并添加`"/intersect"`将使用空间查询来查找描述请求的NBA竞技场的数据。在此视图函数中，使用`intersect`
    `filter`（即，使用点在多边形函数中识别包含`arena`的`县`）查询`县`和`区`表。使用`县`和`州`之间的表关系检索基础州。返回所有几何形状和所选字段：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To ensure that the function is valid, the `if` conditional checks if the `arena`
    is inside a US `county`; if not, the `county`, `district`, and `state` objects
    are not used. Instead, the request is redirected to the non-geospatial query view
    function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保函数有效，`if`条件检查`arena`是否在美`县`内；如果不是，则不使用`县`、`区`和`州`对象。相反，请求被重定向到非地理空间查询视图函数。
- en: States
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 州
- en: The US States data can be large, due to the many vertices that make up each
    `state`. Within the endpoint for the `states`, we will add some URL parameters
    that will enable us to decide the geometry of each requested `state` should be
    returned.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个`州`由许多顶点组成，因此美国州数据可能很大。在`states`端点中，我们将添加一些URL参数，使我们能够决定返回的每个请求`州`的几何形状。
- en: Getting all states
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有州
- en: 'By checking for a URL argument in the `request.args` dictionary, and then checking
    if the argument evaluates as true, we can determine if all of the `state` geometries
    should be returned. The GeoJSON response is generated from the state''s geometry
    by using the `to_shape` function and the `shapely.geometry.geo.mapping` (shortened
    to `smapping`) function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`request.args`字典中的URL参数，然后检查该参数是否评估为真，我们可以确定是否应返回所有`州`的几何形状。GeoJSON响应是通过使用`to_shape`函数和`shapely.geometry.geo.mapping`（简称为`smapping`）函数从州的几何形状生成的：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the `geometry` argument or parameter is not included, the geometry will be
    represented as truncated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不包括`geometry`参数或参数，几何形状将表示为截断。
- en: Getting a state by ID
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过ID获取州
- en: 'To get a specific `state` using the primary key ID of the `state`, we can add
    a URL variable that will check for an integer ID. It is returned with the `geometry`
    as a `geojson`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`州`的主键ID获取特定的`州`，我们可以添加一个URL变量来检查整数ID。它以`geojson`的形式返回，包括`geometry`：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Getting a state by name
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称获取州
- en: 'Using a `filter` will allow for a URL variable to be used as a `query` `filter`.
    The string variable will be checked against the state `name` field in the database
    table, and uses a `like` operator to do a fuzzy comparison (that is, it will get
    all `states` that start with `''M''` if the `state_name` variable is `''M''`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter`将允许使用URL变量作为`query` `filter`。字符串变量将与数据库表中的`state` `name`字段进行比较，并使用`like`运算符进行模糊比较（即，如果`state_name`变量是`'M'`，则将获取所有以`'M'`开头的`states`）：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function has no URL parameters and will return the specified fields and
    `geometry` of the selected states.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数没有URL参数，并将返回所选州的指定字段和`geometry`。
- en: Getting arenas by state
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过州获取场馆
- en: 'This function uses spatial analysis to find all `arenas` that are contained
    by the `state`. The `state` is identified by the ID, and the URL component within
    which it will select all `arenas` whose `geometry` is within the `state` `geometry`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用空间分析来查找所有被`state`包含的`arenas`。`state`通过ID识别，URL组件将选择所有`geometry`在`state`
    `geometry`内的`arenas`：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The data returned will include the state `data` and `data` for all `arenas`,
    as GeoJSON allows for multiple datatypes to be packaged as a feature collection.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据将包括州的`data`和所有`arenas`的`data`，因为GeoJSON允许将多个数据类型打包为一个要素集合。
- en: Counties
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 县
- en: 'Similar to the `State` database table, this will retrieve all of the `county`
    data. It accepts a `geometry` parameter to decide if it will return the `geometry`
    of each `county`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与`State`数据库表类似，这将检索所有`county`数据。它接受一个`geometry`参数来决定是否返回每个`county`的`geometry`：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Getting a county by ID
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过ID获取县
- en: 'After retrieving all counties using the `get_counties` function, the ID of
    a specific `county` can be passed to this function. Using `session.query.(County).get(county_id)`
    allows for the retrieval of the `county` of interest:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`get_counties`函数检索所有县之后，可以将特定`county`的ID传递给此函数。使用`session.query.County.get(county_id)`可以检索感兴趣的`county`：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Getting a county by name
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称获取县
- en: 'Again, we can use a URL variable to collect a string, and use the string supplied
    for a query filter. If `Wash` is used as the URL variable `county_name`, the query
    will find all `counties` with names that start with `Wash`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以使用URL变量来收集一个字符串，并使用提供的字符串作为查询过滤器。如果使用`Wash`作为URL变量`county_name`，查询将找到所有以`Wash`开头的`counties`：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `filter` method can be used on spatial fields as well as non-spatial fields.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法可以用于空间字段以及非空间字段。'
- en: Districts
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区域
- en: Districts can be similarly added to the API. In this case, we will add a geometry
    parameter to decide if the geometry should be returned. This allows for the requesting
    machine or browser to get all of the districts and their IDs, which can be used
    to get the individual district in the next section, or to get all of the data
    at once, as needed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 区域可以被类似地添加到API中。在这种情况下，我们将添加一个几何参数来决定是否应该返回几何信息。这允许请求的机器或浏览器获取所有区域及其ID，这些ID可以用于在下一节中获取单个区域，或者根据需要一次性获取所有数据。
- en: Getting all districts
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有区域
- en: 'This endpoint, (`''/district''`), will query against the `District` model using
    `session.query(District).all()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点（`'/district'`）将使用`session.query(District).all()`对`District`模型进行查询：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Getting a district by ID
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过ID获取区域
- en: 'Passing the integer `district` ID will return only the requested representation
    of the `district`. The `geometry` is converted to GeoJSON format using `shapely`
    and the `to_shape` method from `geoalchemy2.shape`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递整数`district` ID，将仅返回请求的`district`表示。`geometry`使用`shapely`和`geoalchemy2.shape`中的`to_shape`方法转换为GeoJSON格式：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Getting a district by name
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称获取区域
- en: 'In this case, the `name` of the district is the congressional `district` number.
    There is a `name` field, but it contains the name of the elected representative
    from that `district`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，区域的`name`是国会区域编号。存在一个`name`字段，但它包含该区域的当选代表的姓名：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All of these methods can be adjusted to include more parameters. Try adding
    in conditionals that check for fields to return, or another conditional. All URL
    parameter arguments are added after a question mark (`'?'`) in the query.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都可以调整以包含更多参数。尝试添加检查返回字段的条件或另一个条件。所有URL参数都添加在查询后的问号（`'?'`）之后。
- en: API POST endpoints
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API POST端点
- en: 'Adding an `arena` can be accomplished using both JSON data and using an HTML
    form. In this section, we''ll create an HTML template, use the `AddForm` from
    `forms.py`, and use it to collect data from the `Leaflet.js` map included in [Chapter
    12](a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml), *GeoDjango*, code bundle. It
    also uses the library jQuery to allow the user to click on the map at any location,
    thus updating the `longitude` and `latitude` data from the map:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON数据和HTML表单都可以添加`arena`。在本节中，我们将创建一个HTML模板，使用`forms.py`中的`AddForm`，并使用它从[第12章](a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml)，*GeoDjango*代码包中包含的`Leaflet.js`地图收集数据。它还使用jQuery库允许用户点击地图上的任何位置，从而更新地图的`longitude`和`latitude`数据：
- en: '![](img/3d47507c-fec2-4274-b8c2-21b86bfeff40.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d47507c-fec2-4274-b8c2-21b86bfeff40.png)'
- en: New arenas
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新场馆
- en: To add new arenas to the database `Arena` table, a view function for processing
    and a Jinja2 HTML template will be created and used. The function will determine
    the request method and will send the appropriate response to the request. If it
    is a `GET` request, it will send an HTML template with the `AddForm` form. From
    the HTML template, filling in the data and pushing the button will submit a `POST`
    request, which will go to the same view function, and will use the submitted data
    to add a new row to the `Arena` table.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新的 `arena` 添加到数据库的 `Arena` 表中，将创建一个用于处理请求的视图函数和一个 Jinja2 HTML 模板，并使用它们。该函数将确定请求方法，并将适当的响应发送给请求。如果是一个
    `GET` 请求，它将发送一个包含 `AddForm` 表单的 HTML 模板。从 HTML 模板中，填写数据并点击按钮将提交一个 `POST` 请求，该请求将转到相同的视图函数，并使用提交的数据在
    `Arena` 表中添加一行新数据。
- en: The view function
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图函数
- en: 'The view function that will process the request accepts both `GET` and `POST`
    request methods. The endpoint `''/add''` is used in this case, though it could
    have been anything that differentiated it from the `arena` endpoint:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将处理请求的视图函数接受 `GET` 和 `POST` 请求方法。在这种情况下使用端点 `'/add'`，尽管它可以是任何与 `arena` 端点区分开来的东西：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once the button is pushed, the data is submitted. The view function will determine
    what to do based on the request method—if it is a `POST` request, the data submitted
    in the `form` will be used to create a new `arena` object, and the session manager
    will save the object, adding it to the database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦按钮被按下，数据就会被提交。视图函数将根据请求方法确定要执行的操作——如果是一个 `POST` 请求，则 `form` 中提交的数据将用于创建一个新的
    `arena` 对象，并且会话管理器将保存该对象，并将其添加到数据库中。
- en: The addarena.html head
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: addarena.html 的头部
- en: 'Next, let''s create the template called `addarena.html`, which will be added
    to the `templates` folder inside the `application` folder. At the top of the HTML
    file, in the head section, add the CSS, JavaScript, and jQuery libraries:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 `addarena.html` 的模板，该模板将被添加到 `application` 文件夹内的 `templates` 文件夹中。在
    HTML 文件的顶部，在 head 部分，添加 CSS、JavaScript 和 jQuery 库：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The addarena.html script
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: addarena.html 脚本
- en: 'Create the map `<div>` section and add the JavaScript that will enable map
    interactivity. If the map is clicked on, the JavaScript function `showMapClick`
    (which accepts an event `*e*`  as a parameter) will move the marker. Within the
    function, jQuery is used to set the value of the `latitude` and `longitude` `form`
    elements, getting the values from the event argument''s `e.latlng` method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建地图 `<div>` 部分，并添加将启用地图交互性的 JavaScript。如果地图被点击，JavaScript 函数 `showMapClick`（它接受一个事件
    `*e*` 作为参数）将移动标记。在函数内部，使用 jQuery 设置 `latitude` 和 `longitude` `form` 元素的值，从事件参数的
    `e.latlng` 方法获取值：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The addarena.html form
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: addarena.html 表单
- en: 'The `form` data will be submitted with the `POST` method. Once the Add Arena
    button is pushed, the data inside the entry forms are submitted:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`form` 数据将以 `POST` 方法提交。一旦按下“添加 Arena”按钮，表单中的数据就会被提交：'
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Clicking on the button will submit the data to the view function. The data
    will be processed, and a success JSON message returned:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮将数据提交给视图函数。数据将被处理，并返回一个成功的 JSON 消息：
- en: '![](img/b9892c1f-af5c-4d01-9343-aef4bc325fc3.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9892c1f-af5c-4d01-9343-aef4bc325fc3.png)'
- en: Sending a POST request using the requests library
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 requests 库发送 POST 请求
- en: 'A new arena can be added using a web request, avoiding the need to use the
    HTML template. Here is a demonstration of a request using the `requests` library:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Web 请求添加一个新的 `arena`，避免使用 HTML 模板。以下是一个使用 `requests` 库进行请求的演示：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The POST request is sent to the `'/add'` endpoint, along with the required `form`
    parameters, as a Python dictionary.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将 POST 请求发送到 `'/add'` 端点，同时附带所需的 `form` 参数，作为一个 Python 字典。
- en: Deleting an arena
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除 arena
- en: 'Deleting an `arena` (or another resource) can also be done using a view function
    and a specific endpoint:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个 `arena`（或另一个资源）也可以通过视图函数和特定的端点来完成：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To delete an `arena`, send a request using the `delete` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个 `arena`，发送一个使用 `delete` 方法的请求：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Running the REST API locally
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行 REST API
- en: 'To run this API application locally, the `app.py` script is passed to the Python
    executable. This will start the built-in web server on the local machine:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地运行此 API 应用程序，将 `app.py` 脚本传递给 Python 可执行文件。这将启动本地机器上的内置 Web 服务器：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once the server is running, navigate to the API endpoint to get responses from
    the view functions. If the application is complete, however, the local server
    won't be powerful enough to handle the API requests. Instead, deployment on a
    production web server is required.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，导航到API端点以从视图函数获取响应。然而，如果应用程序是完整的，本地的服务器可能不足以处理API请求。相反，需要在生产Web服务器上进行部署。
- en: Deploying Flask to IIS
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Flask部署到IIS
- en: To deploy the new API application on a Microsoft Server with **Internet Information
    Services** (**IIS**) installed, we have to download some Python code, and an IIS
    module called **FastCGI**. Once configured, the application will respond to web
    requests from any allowed machine.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了**互联网信息服务**（**IIS**）的Microsoft服务器上部署新的API应用程序，我们需要下载一些Python代码，以及一个名为**FastCGI**的IIS模块。一旦配置完成，应用程序将能够响应来自任何允许的机器的Web请求。
- en: Flask and web servers
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask和Web服务器
- en: While Flask includes a local web server for testing purposes, it is not designed
    for production deployments. Flask works best with web servers like Apache or IIS.
    While there is a lot of literature on how to deploy Flask with Apache, it is less
    common to find good instructions on how to deploy it using IIS. As most GIS professionals
    work with Windows servers or have access to them, these instructions will focus
    on deployment with IIS 7.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Flask包含一个用于测试目的的本地Web服务器，但它并不是为生产部署而设计的。Flask与Apache或IIS等Web服务器配合得最好。虽然关于如何使用Apache部署Flask的文献很多，但关于如何使用IIS部署它的良好说明却很少见。由于大多数GIS专业人员使用Windows服务器或可以访问它们，这些说明将专注于使用IIS
    7进行部署。
- en: WSGI
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WSGI
- en: The **Web Server Gateway Interface** (**WSGI**) is a Python specification that
    allows for a Python executable to be used to respond to web requests. WSGI is
    built into Python web frameworks such as Flask and Django.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web服务器网关接口**（**WSGI**）是一个Python规范，它允许Python可执行文件用于响应Web请求。WSGI内置在Flask和Django等Python
    Web框架中。'
- en: To enable the use of the Flask web framework to serve web pages, some configuration
    of IIS is required, including the installation of an IIS **Common Gateway Interface**
    (**CGI**) module called FastCGI, and the installation of a Python module called
    **WFastCGI**. With these two additions, the IIS web server will connect to the
    code behind the API application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Flask Web框架用于服务Web页面，需要对IIS进行一些配置，包括安装一个名为**FastCGI**的IIS**公共网关接口**（**CGI**）模块，以及安装一个名为**WFastCGI**的Python模块。有了这两个添加项，IIS
    Web服务器将连接到API应用程序背后的代码。
- en: Installing the WFastCGI module and FastCGI
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装WFastCGI模块和FastCGI
- en: 'Use the Web Platform Installer, available here: [http://www.microsoft.com/web/downloads/platform.aspx](http://www.microsoft.com/web/downloads/platform.aspx)
    (if it''s not already installed). Use the search bar in the top-right, and enter
    `WFastCGI`. The search results will appear and will list available WFastCGI versions
    for both Python 2.x and Python 3.x. Select the version for Python 3.6 and run
    the installer.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此处可用的Web平台安装程序：[http://www.microsoft.com/web/downloads/platform.aspx](http://www.microsoft.com/web/downloads/platform.aspx)（如果尚未安装）。使用右上角的搜索栏，输入`WFastCGI`。搜索结果将出现，并列出适用于Python
    2.x和Python 3.x的可用WFastCGI版本。选择Python 3.6的版本并运行安装程序。
- en: This installation adds two important components to the required tech stack.
    The FastCGI module is added to IIS, and the WFastCGI Python code is added to a
    new Python installation. This new installation will be added at `C:\Python36`,
    unless there is an existing version in that location (not counting Python versions
    within an ArcGIS10.X Python installation).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此安装向所需的技栈添加了两个重要组件。FastCGI模块被添加到IIS中，WFastCGI Python代码被添加到一个新的Python安装中。这个新安装将添加到`C:\Python36`，除非该位置已存在版本（不包括ArcGIS10.X
    Python安装中的Python版本）。
- en: Within this new installation, a file called `wfastcgi.py` is added in the `C:\Python36\Scripts`
    (or equivalent) folder. This file should be copied into the site folder, next
    to the `app.py` file.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新安装中，`C:\Python36\Scripts`（或等效）文件夹中添加了一个名为`wfastcgi.py`的文件。这个文件应该被复制到站点文件夹中，紧挨着`app.py`文件。
- en: Configuring FastCGI
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置FastCGI
- en: 'Open IIS, and click on the Default Web Site. Within the features view of the
    Content Pane, select the Handler Mappings icon. Double-click to open it. Select
    Add Module Mapping from the right pane. When the Add Module Mapping interface
    appears, enter the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 打开IIS，点击默认网站。在内容窗格的功能视图中，选择处理器映射图标。双击打开它。从右侧窗格中选择添加模块映射。当添加模块映射界面出现时，输入以下内容：
- en: Add an asterisk (`*`) to the request path entry.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求路径条目中添加一个星号（`*`）。
- en: Select the FastCGI module from the Module Selection List.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模块选择列表中选择 FastCGI 模块。
- en: If you copied the `wfastcgi.py` file into the code path and the code is at `C:\website`,
    enter this into the executable entry: `C:\Python36\python.exe|C:\website\wfastcgi.py`.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您已将 `wfastcgi.py` 文件复制到代码路径，并且代码位于 `C:\website`，请在可执行条目中输入以下内容：`C:\Python36\python.exe|C:\website\wfastcgi.py`。
- en: 'Optionally, the `wfastcgi.py` file in the `Scripts` folder can be used. Here
    is the setup: `C:\Python36\python.exe|C:\Python36\Scripts\wfastcgi.py`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，可以使用 `Scripts` 文件夹中的 `wfastcgi.py` 文件。设置如下：`C:\Python36\python.exe|C:\Python36\Scripts\wfastcgi.py`。
- en: 'Click on Request Restrictions and uncheck the Invoke handler only if request
    is mapped to: if it is checked. Click OK.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击请求限制，并取消选中仅当请求映射到时调用处理器的复选框（如果已选中）。点击确定。
- en: Click OK on the Add Module Mapping interface.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加模块映射界面中点击确定。
- en: Click Yes on the confirmation.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在确认对话框中点击是。
- en: Root server settings and Environment Variables
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根服务器设置和环境变量
- en: Go to the `root` server settings and click on the FastCGI Settings icon. Double-click
    on the argument that matches the path added in the previous section. The Edit
    FastCGI Application interface will open.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前往根服务器设置，并点击 FastCGI 设置图标。双击与上一节中添加的路径匹配的参数。将打开编辑 FastCGI 应用程序界面。
- en: Click on the EnvironmentVariables (Collection) entry. An ellipsis (...) will
    appear. Double-click on the ellipsis to edit the environment variables.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击环境变量（集合）条目。将出现省略号 (...)。双击省略号以编辑环境变量。
- en: Click the Add button to add a new variable.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击添加按钮以添加一个新变量。
- en: Add `PYTHONPATH` to the Name entry.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `PYTHONPATH` 添加到名称条目中。
- en: Add the path to the site code (for example `C:\website\`) to the value entry.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将网站代码的路径（例如 `C:\website\`）添加到值条目中。
- en: Click the Add button to add a second variable.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击添加按钮以添加第二个变量。
- en: Add `WSGI_HANDLER` to the Name entry.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `WSGI_HANDLER` 添加到名称条目中。
- en: If the site is controlled by a file called `app.py`, add `app.app` to the value
    entry (replacing `.py` with `.app`).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网站由名为 `app.py` 的文件控制，将 `app.app` 添加到值条目中（将 `.py` 替换为 `.app`）。
- en: Once the variables have been added, push OK. Push OK in the Edit FastCGI Application.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦添加了变量，请点击确定。在编辑 FastCGI 应用程序时也请点击确定。
- en: The site should now be live. Navigate to a REST endpoint using a browser to
    confirm that the site loads as expected.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 网站现在应该已经上线。使用浏览器导航到 REST 端点以确认网站按预期加载。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Creating an API with REST specifications is easy with Python web frameworks.
    Flask makes it simple to coordinate the URL endpoints with request methods and
    response types. With built-in JSON capabilities, and with the use of the SQLAlchemy
    and GeoAlchemy2 ORMs, Flask is a perfect framework for creating a geospatial REST
    API.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 网络框架创建具有 REST 规范的 API 很简单。Flask 使得协调 URL 端点与请求方法和响应类型变得简单。凭借内置的 JSON
    功能，以及使用 SQLAlchemy 和 GeoAlchemy2 ORM，Flask 是创建地理空间 REST API 的完美框架。
- en: In the next chapter, we will cover the use of the CARTOframes module for cloud
    visualization of geospatial data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍使用 CARTOframes 模块进行地理空间数据的云可视化。
