- en: Chapter 14. Web Scraping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章。网络爬取
- en: R provides a platform with easy access to statistical computing and data analysis.
    Given a data set, it is handy to perform data transformation and apply analytic
    models and numeric methods with either flexible data structures or high performance,
    as discussed in previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: R 提供了一个易于访问统计计算和数据分析的平台。给定一个数据集，使用灵活的数据结构或高性能，可以方便地进行数据转换并应用分析模型和数值方法，如前几章所述。
- en: 'However, the input data set is not always as immediately available as tables
    provided by well-organized commercial databases. Sometimes, we have to collect
    data by ourselves. Web content is an important source of data for a wide range
    of research fields. To collect (scrape or harvest) data from the Internet, we
    need appropriate techniques and tools. In this chapter, we''ll introduce the basic
    knowledge and tools of web scraping, including:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，输入数据集并不总是像有组织商业数据库提供的表格那样立即可用。有时，我们必须自己收集数据。网络内容是众多研究领域的重要数据来源。为了从互联网收集（爬取或收割）数据，我们需要适当的技术和工具。在本章中，我们将介绍网络爬取的基本知识和工具，包括：
- en: Looking inside web pages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看网页内部
- en: Learning CSS and XPath selector
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 CSS 和 XPath 选择器
- en: Analyzing HTML code and extracting data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 HTML 代码并提取数据
- en: Looking inside web pages
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看网页内部
- en: 'Web pages are made to present information. The following screenshot shows a
    simple web page located at `data/simple-page.html` that has a heading and a paragraph:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网页是为了展示信息而制作的。以下截图显示了位于 `data/simple-page.html` 的简单网页，它包含一个标题和一个段落：
- en: '![Looking inside web pages](img/image_14_001.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![查看网页内部](img/image_14_001.jpg)'
- en: 'All modern web browsers support such web pages. If you open `data/simple-page.html`
    with any text editor, it will show the code behind the web page as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代网络浏览器都支持此类网页。如果你用任何文本编辑器打开 `data/simple-page.html`，它将显示网页背后的代码如下：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is an example of HTML (Hyper Text Markup Language). It is
    the most widely used language on the Internet. Different from any programming
    language to be finally translated into computer instructions, HTML describes the
    layout and content of a web page, and web browsers are designed to render the
    code into a web page according to web standards.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是 HTML（超文本标记语言）的一个示例。它是互联网上使用最广泛的语言。与任何最终被翻译成计算机指令的编程语言不同，HTML 描述了网页的布局和内容，而网络浏览器被设计成根据网络标准将代码渲染成网页。
- en: Modern web browsers use the first line of HTML to determine which standard is
    used to render the web page. In this case, the latest standard, HTML 5, is used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络浏览器使用 HTML 的第一行来确定使用哪种标准来渲染网页。在这种情况下，使用的是最新的标准，HTML 5。
- en: If you read through the code, you'll probably notice that HTML is nothing but
    a nested structure of tags such as `<html>`, `<title>`, `<body>`, `<h1>`, and `<p>`.
    Each tag begins with `<tag>` and is closed with `</tag>`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读代码，你可能会注意到 HTML 仅仅是一系列嵌套的标签，如 `<html>`、`<title>`、`<body>`、`<h1>` 和 `<p>`。每个标签以
    `<tag>` 开头，并以 `</tag>` 结尾。
- en: In fact, these tags are not arbitrarily named, nor are they allowed to contain
    other arbitrary tags. Each has a specific meaning to the web browser and is only
    allowed to contain a subset of tags, or even none.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些标签并不是随意命名的，也不允许它们包含其他任意标签。每个标签对网络浏览器都有特定的含义，并且只允许包含标签的子集，甚至没有任何标签。
- en: The `<html>` tag is the root element of all HTML. It most commonly contains
    `<head>` and `<body>`. The `<head>` tag usually contains `<title>` to show on
    the title bar and browser tabs and other metadata of the web page, while `<body>`
    plays the main role in determining the layout and contents of the web page.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`<html>` 标签是所有 HTML 的根元素。它通常包含 `<head>` 和 `<body>`。`<head>` 标签通常包含 `<title>`
    以显示在标题栏和浏览器标签页上，以及网页的其他元数据，而 `<body>` 在确定网页布局和内容方面扮演主要角色。'
- en: 'In the `<body>` tag, tags can be nested more freely. The simple page only contains
    a level-1 heading (`<h1>`) and a paragraph (`<p>`) while the following web page
    contains a table with two rows and two columns:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<body>` 标签中，标签可以更自由地嵌套。简单的页面只包含一级标题 (`<h1>`) 和一个段落 (`<p>`)，而下面的网页包含一个有两行两列的表格：
- en: '![Looking inside web pages](img/image_14_002.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![查看网页内部](img/image_14_002.jpg)'
- en: 'The HTML code behind the web page is stored in `data/single-table.html`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网页背后的 HTML 代码存储在 `data/single-table.html` 中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that a `<table>` tag is structured row by row: `<tr>` represents a table
    row, `<th>` a table header cell, and `<td>` a table cell.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`<table>` 标签是按行构建的：`<tr>` 代表表格行，`<th>` 代表表头单元格，`<td>` 代表表格单元格。
- en: Also notice that an HTML element such as `<table>` may have additional attributes
    in the form of `<table attr1="value1" attr2="value2">`. The attributes are not
    arbitrarily defined. Instead, each has a specific meaning according to the standard.
    In the preceding code, `id` is the identifier of the table and `border` controls
    its border width.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，HTML元素如`<table>`可能有额外的属性，形式为`<table attr1="value1" attr2="value2">`。这些属性不是任意定义的。相反，每个属性都有根据标准指定的特定含义。在前面代码中，`id`是表格的标识符，`border`控制其边框宽度。
- en: 'The following page looks different from the previous ones in that it shows
    some styling of contents:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下页面与之前的页面不同，因为它显示了内容的某些样式：
- en: '![Looking inside web pages](img/image_14_003.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![查看网页内部](img/image_14_003.jpg)'
- en: 'If you take a look at its source code at `data/simple-products.html`, you''ll
    find some new tags such as `<div>` (a section), `<ul>` (unrecorded list), `<li>`
    (list item), and `<span>` (also a section used for applying styles); additionally,
    many HTML elements have an attribute called `style` to define their appearance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看其源代码`data/simple-products.html`，你会发现一些新的标签，如`<div>`（一个部分），`<ul>`（未记录的列表），`<li>`（列表项），以及`<span>`（也是一个用于应用样式的部分）；此外，许多HTML元素都有一个名为`style`的属性来定义其外观：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Values in style is written in the form of `property1: value1; property2: value2;`.
    However, the styles of the list items are a bit redundant because all product
    names share the same style and this is also true for all product prices. The following
    HTML at `data/products.html` uses CSS (**Cascading Style Sheets**) instead to
    avoid redundant styling definitions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '样式值以`property1: value1; property2: value2;`的形式书写。然而，列表项的样式有些冗余，因为所有产品名称都共享相同的样式，这也适用于所有产品价格。以下`data/products.html`中的HTML使用CSS（**层叠样式表**）来避免冗余的样式定义：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we add `<style>` in `<head>` to declare a global stylesheet in the
    web page. We also switch `style` to `class` for content elements (`div`, `li`,
    and `span`) to use those pre-defined styles. The syntax of CSS is briefly introduced
    in the following code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`<head>`中添加了`<style>`来声明网页中的全局样式表。我们还把内容元素（`div`、`li`和`span`）的`style`切换到`class`，以使用这些预定义的样式。CSS的语法在以下代码中简要介绍。
- en: 'Match all `<h1>` elements:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配所有`<h1>`元素：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Match all elements with the `product-list` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配所有具有`product-list`类的元素：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Match all elements with the `product-list` class, and then match all nested
    elements with the `name` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配所有具有`product-list`类的元素，然后匹配所有嵌套的具有`name`类的元素：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Match all elements with the `product-list` class, then match all nested `<li>`
    elements with the `selected` class, and finally match all nested elements with
    the `name` class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配所有具有`product-list`类的元素，然后匹配所有嵌套的`<li>`元素具有`selected`类，最后匹配所有嵌套的具有`name`类的元素：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that simply using `style` cannot achieve this. The following screenshot
    shows the rendered web page:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仅使用`style`无法实现这一点。以下截图显示了渲染的网页：
- en: '![Looking inside web pages](img/image_14_004.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![查看网页内部](img/image_14_004.jpg)'
- en: 'Each CSS entry consists of a CSS selector (for example, `.product-list`) to
    match HTML elements and the styles (for example, `color: red;`) to apply. CSS
    selectors are not only used to apply styling, but are also commonly used to extract
    contents from web pages so the HTML elements of interest are properly matched.
    This is an underlying technique behind web scraping.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '每个CSS条目由一个CSS选择器（例如，`.product-list`）组成，用于匹配HTML元素，以及要应用的样式（例如，`color: red;`）。CSS选择器不仅用于应用样式，而且通常用于从网页中提取内容，以便正确匹配感兴趣的HTML元素。这是网络爬取背后的基本技术。'
- en: 'CSS is much richer than demonstrated in the preceding code. For web scraping,
    we use the following examples to show the most commonly used CSS selectors:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CSS比前面代码中展示的要丰富得多。对于网络爬取，我们使用以下示例来展示最常用的CSS选择器：
- en: '| **Syntax** | **Match** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | **匹配** |'
- en: '| `*` | All elements |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 所有元素 |'
- en: '| `h1, h2, h3` | `<h1>`,`<h2>`,`<h3>` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `h1, h2, h3` | `<h1>`,`<h2>`,`<h3>` |'
- en: '| `#table1` | `<* id="table1">` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `#table1` | `<* id="table1">` |'
- en: '| `.product-list` | `<* class="product-list">` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `.product-list` | `<* class="product-list">` |'
- en: '| `div#container` | `<div id="container">` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `div#container` | `<div id="container">` |'
- en: '| `div a` | `<div><a>` and `<div><p><a>` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `div a` | `<div><a>`和`<div><p><a>` |'
- en: '| `div > a` | `<div><a>` but not`<div><p><a>` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `div > a` | `<div><a>`，但不包括`<div><p><a>` |'
- en: '| `div > a.new` | `<div><a class="new">` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `div > a.new` | `<div><a class="new">` |'
- en: '| `ul > li:first-child` | First `<li>` in`<ul>` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `ul > li:first-child` | `<ul>`中的第一个`<li>` |'
- en: '| `ul > li:last-child` | Last `<li>` in`<ul>` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `ul > li:last-child` | `<ul>`中的最后一个`<li>` |'
- en: '| `ul > li:nth-child(3)` | 3rd `<li>` in`<ul>` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `ul > li:nth-child(3)` | `<ul>`中的第三个`<li>` |'
- en: '| `p + *` | Next element of `<p>` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `p + *` | `<p>` 的下一个元素 |'
- en: '| `img[title]` | `<img>` with title attribute |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `img[title]` | 带有标题属性的 `<img>` |'
- en: '| `table[border=1]` | <table border="1"> |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `table[border=1]` | `<table border="1">` |'
- en: In each level, `tag#id.class[]` can be used with `tag`, `#id.class`, and `[]`
    optionally. For more information on CSS selectors, visit [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors).
    To learn more about HTML tags, visit [http://www.w3schools.com/tags/](http://www.w3schools.com/tags/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个级别，`tag#id.class[]` 可以与 `tag`、`#id.class` 以及可选的 `[]` 一起使用。有关 CSS 选择器的更多信息，请访问
    [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors)。要了解更多关于
    HTML 标签的信息，请访问 [http://www.w3schools.com/tags/](http://www.w3schools.com/tags/).
- en: Extracting data from web pages using CSS selectors
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CSS 选择器从网页中提取数据
- en: 'In R, the easiest-to-use package for web scraping is `rvest`. Run the following
    code to install the package from CRAN:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，用于网络抓取的最易用的包是 `rvest`。运行以下代码从 CRAN 安装该包：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, we load the package and use `read_html()` to read `data/single-table.html`
    and try to extract the table from the web page:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载包并使用 `read_html()` 读取 `data/single-table.html` 并尝试从网页中提取表格：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that `single_table_page` is a parsed HTML document, which is a nested data
    structure of HTML nodes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`single_table_page` 是一个解析后的 HTML 文档，它是一个嵌套的 HTML 节点数据结构。
- en: 'A typical process for scraping information from such a web page using `rvest`
    functions is: First, locate the HTML nodes from which we need to extract data.
    Then, use either the CSS selector or XPath expression to filter the HTML nodes
    so that the nodes we need are selected and those we don''t need are omitted. Finally,
    use proper selectors with `html_nodes()` to take a subset of nodes, `html_attrs()`
    to extract attributes, and `html_text()` to extract text from the parsed web page.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rvest` 函数从此类网页抓取信息的典型过程是：首先，定位我们需要从中提取数据的 HTML 节点。然后，使用 CSS 选择器或 XPath 表达式过滤
    HTML 节点，以便所需的节点被选中，而不需要的节点被省略。最后，使用适当的选择器通过 `html_nodes()` 获取节点子集，`html_attrs()`
    提取属性，以及 `html_text()` 从解析的网页中提取文本。
- en: 'The package also provides simple functions that directly extract data from
    a web page and return a data frame. For example, to extract all `<table>` elements
    from it, we directly call `html_table()`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该包还提供了直接从网页中提取数据并返回数据框的简单函数。例如，要从中提取所有 `<table>` 元素，我们直接调用 `html_table()`：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To extract the first `<table>` element, we use `html_node()` to select the
    first node with the CSS selector `table` and then use `html_table()` with the
    node to get a data frame:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取第一个 `<table>` 元素，我们使用 `html_node()` 通过 CSS 选择器 `table` 选择第一个节点，然后使用 `html_table()`
    与节点一起获取数据框：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A more natural way to do this is to use pipelines, just like using `%>%` with
    `dplyr` functions introduced in [Chapter 12](ch12.html "Chapter 12. Data Manipulation"),
    *Data Manipulation*. Recall that `%>%` basically evaluates `x %>% f(...)` as `f(x,
    ...)` so that a nested call can be unnested and become much more readable. The
    preceding code can be rewritten as the following using `%>%`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个更自然的方法是使用管道，就像使用 `dplyr` 函数中的 `%>%` 一样，如第 12 章中介绍的 [Chapter 12](ch12.html
    "第 12 章。数据操作")，*数据操作*。回想一下，`%>%` 实际上评估 `x %>% f(...)` 为 `f(x, ...)`，这样嵌套调用可以展开并变得更加易读。前面的代码可以重写为以下使用
    `%>%`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we read `data/products.html` and use `html_nodes()` to match the `<span
    class="name">` nodes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们读取 `data/products.html` 并使用 `html_nodes()` 匹配 `<span class="name">` 节点：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the nodes we want to select are of the `name` class in `<li>` nodes
    of a node of the `product-list` class, therefore we can use `.product-list li.name`
    to select all such nodes. Go through the CSS table if you feel you are not familiar
    with the notation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们想要选择的节点是 `product-list` 类节点中的 `<li>` 节点的 `name` 类，因此我们可以使用 `.product-list
    li.name` 来选择所有这样的节点。如果你对这种表示法不熟悉，请查看 CSS 表。
- en: 'To extract the contents from the selected nodes, we use `html_text()`, which
    returns a character vector:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要从选定的节点中提取内容，我们使用 `html_text()`，它返回一个字符向量：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly, the following code extracts the product prices:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下代码提取产品价格：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, `html_nodes()` returns a collection of HTML nodes while
    `html_text()` is smart enough to extract the inner text from each HTML node and
    returns a character vector.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`html_nodes()` 返回一组 HTML 节点，而 `html_text()` 足够智能，可以从每个 HTML 节点中提取内部文本，并返回一个字符向量。
- en: 'Note that these prices are still in their raw format represented by a string
    rather than number. The following code extracts the same data and transforms it
    into a more useful form:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些价格仍然以原始格式表示为字符串，而不是数字。以下代码提取相同的数据并将其转换为更有用的形式：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the intermediate results of selected nodes can be stored as a variable
    and used repeatedly. Then the subsequent `html_nodes()` and `html_node()` calls
    only match the inner nodes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所选节点的中间结果可以存储为变量并重复使用。然后后续的 `html_nodes()` 和 `html_node()` 调用仅匹配内部节点。
- en: Since product prices should be numeric values, we use `gsub()` to remove `$`
    from the raw prices and convert the results to a numeric vector. The call of `gsub()`
    in the pipeline is somehow special because the previous result (represented by
    `.`) should be put to the third argument instead of the first one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于产品价格应该是数值，我们使用 `gsub()` 从原始价格中删除 `$` 并将结果转换为数值向量。在管道中 `gsub()` 的调用有些特殊，因为前一个结果（用
    `.` 表示）应该放在第三个参数而不是第一个参数。
- en: In this case, `.product-list li .name` can be reduced to `.name` and the same
    also applies to `.product-list li .price`. In practice, however, a CSS class may
    be used extensively and such a general selector may match too many elements that
    are not desired. Therefore, it is better to use a more descriptive and sufficiently
    strict selector to match the interested nodes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`.product-list li .name` 可以简化为 `.name`，同样也适用于 `.product-list li .price`。然而，在实际应用中，CSS
    类可能被广泛使用，这样的通用选择器可能会匹配到太多不希望匹配的元素。因此，最好使用更描述性和足够严格的选择器来匹配感兴趣的节点。
- en: Learning XPath selectors
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 XPath 选择器
- en: In the previous section, we learned about CSS selectors and how to use them
    as well as functions provided by the `rvest` package to extract contents from
    web pages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了 CSS 选择器以及如何使用它们，以及 `rvest` 包提供的函数来从网页中提取内容。
- en: CSS selectors are powerful enough to serve most needs of HTML node matching.
    However, sometimes an even more powerful technique is required to select nodes
    that meet more special conditions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 选择器足够强大，可以满足大多数 HTML 节点匹配的需求。然而，有时需要更强大的技术来选择满足更特殊条件的节点。
- en: 'Take a look at the following web page a bit more complex than `data/products.html`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下网页，它比 `data/products.html` 稍微复杂一些：
- en: '![Learning XPath selectors](img/image_14_005.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![学习 XPath 选择器](img/image_14_005.jpg)'
- en: 'This web page is stored as a standalone HTML file at `data/new-products.html`.
    The full source code is long we will only show the `<body>`. here. Please go through
    the source code to get an impression of its structure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网页存储在 `data/new-products.html` 的独立 HTML 文件中。完整的源代码很长，我们只显示 `<body>` 部分。请查看源代码以了解其结构：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The source code of the web page contains a stylesheet and a product list of
    detailed information. Each product has a description and more properties to show.
    In the following code, we load the web page as we did in the previous examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的源代码包含样式表和详细信息的商品列表。每个商品都有一个描述和更多属性以显示。在以下代码中，我们以与之前示例相同的方式加载网页：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The structure of the HTML code is simple and clear. Before digging into XPath,
    we need to know a little about XML. Well-written and well-organized HTML documents
    can be basically regarded as a specialization of **XML** (**eXtensive Markup Language**)
    documents. Different from HTML, XML allows arbitrary tags and attributes. The
    following is a simple XML document:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 代码的结构简单明了。在深入研究 XPath 之前，我们需要了解一些关于 XML 的知识。编写良好且组织有序的 HTML 文档基本上可以被视为
    **XML**（**扩展标记语言**）文档的专门化。与 HTML 不同，XML 允许任意标签和属性。以下是一个简单的 XML 文档：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: XPath is a technique designed for extracting data from XML documents. In this
    section, we compare XPath expressions with CSS selectors and see how they can
    be useful to extract data from web pages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: XPath 是一种专为从 XML 文档中提取数据而设计的技巧。在本节中，我们将比较 XPath 表达式与 CSS 选择器，并了解它们如何有助于从网页中提取数据。
- en: 'The `html_node()` and `html_nodes()` support XPath expressions via the `xpath=`
    argument. The following table shows some important comparisons between CSS selectors
    and equivalent XPath expressions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`html_node()` 和 `html_nodes()` 通过 `xpath=` 参数支持 XPath 表达式。以下表格显示了 CSS 选择器和等效
    XPath 表达式之间的一些重要比较：'
- en: '| **CSS** | **XPath** | **Match** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **CSS** | **XPath** | **匹配** |'
- en: '| `li > *` | `//li/*` | All children of `<li>` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `li > *` | `//li/*` | `<li>` 的所有子节点 |'
- en: '| `li[attr]` | `//li[@attr]` | All `<li>` with `attr` attribute |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `li[attr]` | `//li[@attr]` | 所有具有 `attr` 属性的 `<li>` |'
- en: '| `li[attr=value]` | `//li[@attr=''value'']` | `<li attr="value">` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `li[attr=value]` | `//li[@attr=''value'']` | `<li attr="value">` |'
- en: '| `li#item` | `//li[@id=''item'']` | `<li id="item">` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `li#item` | `//li[@id=''item'']` | `<li id="item">` |'
- en: '| `li.info` | `//li[contains(@class,''info'')]` | `<li class="info">` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `li.info` | `//li[contains(@class,''info'')]` | `<li class="info">` |'
- en: '| `li:first-child` | `//li[1]` | First `<li>` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `li:first-child` | `//li[1]` | 第一个`<li>` |'
- en: '| `li:last-child` | `//li[last()]` | Last `<li>` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `li:last-child` | `//li[last()]` | 最后一个`<li>` |'
- en: '| `li:nth-child(n)` | `//li[n]` | `n` ^(th)`<li>` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `li:nth-child(n)` | `//li[n]` | 第`n`个`<li>` |'
- en: '| (N/A) | `//p[a]` | All `<p>` with a child `<a>` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| (N/A) | `//p[a]` | 所有包含子`<a>`的`<p>`元素 |'
- en: '| (N/A) | `//p[position() <= 5]` | The first five `<p>` nodes |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| (N/A) | `//p[position() <= 5]` | 前五个`<p>`节点 |'
- en: '| (N/A) | `//p[last()-2]` | The last third last `<p>` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| (N/A) | `//p[last()-2]` | 最后第三个`<p>` |'
- en: '| (N/A) | `//li[value>0.5]` | All `<li>` with child `<value>` whose value `>
    0.5` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| (N/A) | `//li[value>0.5]` | 所有具有子`<value>`且其值`> 0.5`的`<li>`元素 |'
- en: Note that CSS selectors usually match nodes at all sub-levels. In XPath, `//` tag
    and `/` tag are defined to match nodes differently. More specifically, `//` tag
    refers to `<tag>` nodes at all sub-levels while `/` tag only refers to `<tag>`
    nodes at the first sub-level.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CSS选择器通常匹配所有子级别的节点。在XPath中，`//`标签和`/`标签被定义为以不同的方式匹配节点。更具体地说，`//`标签指的是所有子级别的`<tag>`节点，而`/`标签仅指第一子级别的`<tag>`节点。
- en: 'To demonstrate the usage, the following are some examples:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示用法，以下是一些示例：
- en: 'Select all `<p>` nodes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有`<p>`节点：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Select all `<li>` with the `class` attribute:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有具有`class`属性的`<li>`元素：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Select all `<li>` as children of `<div id="list"><ul>`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`<div id="list"><ul>`的子元素`<li>`：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Select all `<span class="name">` as children of `<li>` inside `<div id="list">`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`<div id="list">`内部`<li>`的子元素`<span class="name">`：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Select all `<span class="name">` as children in `<li class="selected">`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<li class="selected">`中，选择所有作为子元素的`<span class="name">`：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All the preceding examples can be achieved with equivalent CSS selectors. The
    following examples, however, are not possible with CSS selectors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述示例都可以用等效的CSS选择器实现。然而，以下示例无法用CSS选择器实现。
- en: 'Select all `<div>` with a child `<p>`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有具有子`<p>`的`<div>`：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Select all `<span class="info-value">Good</span>`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有`<span class="info-value">Good</span>`：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Select all product names with good quality:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有品质优良的产品名称：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Select all product names with a duration greater than three years:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有持续时间超过三年的产品名称：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: XPath is very flexible and can be a powerful tool to match nodes in web pages.
    To learn more, visit [http://www.w3schools.com/xsl/xpath_syntax.aspac](http://www.w3schools.com/xsl/xpath_syntax.aspac).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: XPath非常灵活，可以成为匹配网页节点的一个强大工具。要了解更多信息，请访问[http://www.w3schools.com/xsl/xpath_syntax.aspac](http://www.w3schools.com/xsl/xpath_syntax.aspac)。
- en: Analysing HTML code and extracting data
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析HTML代码和提取数据
- en: In the previous sections, we learned the basics of HTML, CSS, and XPath. To
    scrape real-world web pages, the problem now becomesa question of writing the
    proper CSS or XPath selectors. In this section, we introduce some simple ways
    to figure out working selectors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了HTML、CSS和XPath的基础知识。为了抓取现实世界的网页，现在的问题变成了编写正确的CSS或XPath选择器。在本节中，我们将介绍一些简单的方法来确定有效选择器。
- en: 'Suppose we want to scrape all available R packages at [https://cran.rstudio.com/web/packages/available_packages_by_name.html](https://cran.rstudio.com/web/packages/available_packages_by_name.html).
    The web page looks simple. To figure out the selector expression, right-click
    on the table and select **Inspect Element** in the context menu, which should
    be available in most modern web browsers:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要抓取[https://cran.rstudio.com/web/packages/available_packages_by_name.html](https://cran.rstudio.com/web/packages/available_packages_by_name.html)上所有可用的R包。网页看起来很简单。为了确定选择器表达式，在表格上右键单击，并在上下文菜单中选择**检查元素**，这通常在大多数现代网络浏览器中可用：
- en: '![Analysing HTML code and extracting data](img/image_14_006.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码和提取数据](img/image_14_006.jpg)'
- en: 'Then the inspector panel shows up and we can see the underlying HTML of the
    web page. In Firefox and Chrome, the selected node is highlighted so it can be
    located more easily:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会出现检查器面板，我们可以看到网页的底层HTML。在Firefox和Chrome中，选中的节点会被突出显示，以便更容易定位：
- en: '![Analysing HTML code and extracting data](img/image_14_007.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码和提取数据](img/image_14_007.jpg)'
- en: 'The HTML contains a unique `<table>` so we can directly use `table` to select
    it and use `html_table()` to extract it out as a data frame:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: HTML中包含一个唯一的`<table>`，因此我们可以直接使用`table`来选择它，并使用`html_table()`将其提取出来作为数据框：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that the original table has no headers. The resulted data frame uses default
    headers instead and the first row is empty. The following code is written to fix
    these problems:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原始表格没有标题。结果的数据框使用默认标题，并且第一行是空的。以下代码是为了修复这些问题：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next example is to extract the latest stock price of MSFT at [http://finance.yahoo.com/quote/MSFT](http://finance.yahoo.com/quote/MSFT).
    Using the element inspector, we find that the price is contained by a `<span>`
    with very long classes that are generated by the program:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子是提取MSFT在[http://finance.yahoo.com/quote/MSFT](http://finance.yahoo.com/quote/MSFT)的最新股价。使用元素检查器，我们发现价格包含在一个由程序生成的非常长的类别的`<span>`中：
- en: '![Analysing HTML code and extracting data](img/image_14_008.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码和提取数据](img/image_14_008.jpg)'
- en: 'Looking several levels up, we can find a path, `div#quote-header-info > section
    > span`, to navigate to this very node. Therefore, we can use this CSS selector
    to find and extract the stock price:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 向上查看几个层级，我们可以找到一个路径，`div#quote-header-info > section > span`，用来导航到这个节点。因此，我们可以使用这个CSS选择器来查找并提取股价：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On the right side of the web page, there is a table of corporate key statistics:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页的右侧，有一个公司关键统计数据的表格：
- en: '![Analysing HTML code and extracting data](img/image_14_009.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码和提取数据](img/image_14_009.jpg)'
- en: 'Before extracting it out, we again inspect the table and its enclosing nodes,
    and try to find a selector that navigates to this table:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取之前，我们再次检查表格及其包围的节点，并尝试找到一个选择器可以导航到这个表格：
- en: '![Analysing HTML code and extracting data](img/image_14_010.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码和提取数据](img/image_14_010.jpg)'
- en: 'It is obvious that the `<table>` of interest is enclosed by a `<div id="key-statistics"`.
    Thus we can directly use `#key-statistics table` to match the table node and turn
    it into a data frame:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，感兴趣的`<table>`被一个`<div id="key-statistics">`包围。因此，我们可以直接使用`#key-statistics
    table`来匹配表格节点并将其转换为数据框：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With similar techniques, we can create a function that returns the company
    name and price given a stock ticker symbol (for example, `MSFT`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的技术，我们可以创建一个函数，根据股票代码（例如，`MSFT`）返回公司名称和价格：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The CSS selectors are restrictive enough to navigate to the right HTML nodes.
    To test this function, we run the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: CSS选择器足够限制性，可以导航到正确的HTML节点。为了测试这个函数，我们运行以下代码：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Another example is scraping top R questions at [http://stackoverflow.com/questions/tagged/r?sort=votes](http://stackoverflow.com/questions/tagged/r?sort=votes),
    shown as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是抓取[http://stackoverflow.com/questions/tagged/r?sort=votes](http://stackoverflow.com/questions/tagged/r?sort=votes)上的顶级R问题，如下所示：
- en: '![Analysing HTML code and extracting data](img/image_14_011.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码和提取数据](img/image_14_011.jpg)'
- en: 'With a similar method, it is easy to find out that the question list is contained
    by a container whose `id` is `questions`. Therefore, we can load the page and
    select and store the question container with `#questions`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的方法，很容易发现问题列表包含在一个`id`为`questions`的容器中。因此，我们可以加载页面并使用`#questions`选择器和存储问题容器：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To extract the question titles, we take a closer look at the HTML structure
    behind the first question:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取问题标题，我们仔细查看第一个问题的HTML结构：
- en: '![Analysing HTML code and extracting data](img/image_14_012.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码和提取数据](img/image_14_012.jpg)'
- en: 'It is easy to find out that each question title is contained in `<div class="summary"><h3>`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易发现每个问题标题都包含在`<div class="summary"><h3>`中：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that `<a class="question-hyperlink">` also provides an even easier CSS
    selector that returns the same results:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`<a class="question-hyperlink">`也提供了一个更简单的CSS选择器，可以返回相同的结果：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we are also interested in the votes of each question, we can again inspect
    the votes and see how they can be described with a CSS selector:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对每个问题的投票也感兴趣，我们可以再次检查投票，看看它们如何用CSS选择器描述：
- en: '![Analysing HTML code and extracting data](img/image_14_013.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码和提取数据](img/image_14_013.jpg)'
- en: 'Fortunately, all vote panels share the same structure and it is quite straightforward
    to find out their pattern. Each question is contained in a `<div>` with the `question-summary`
    class in which the vote is in a `<span>` with the `.vote-count-post` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，所有投票面板具有相同的结构，并且找出它们的模式相当直接。每个问题都包含在一个具有`question-summary`类的`<div>`中，其中投票在一个具有`.vote-count-post`类的`<span>`中：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similarly, the following code extracts the number of answers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下代码提取了答案的数量：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we go ahead with extracting the tags of each question, it becomes a bit tricky
    because different questions may have different numbers of tags. In the following
    code, we first select the tag containers of all questions and extract the tags
    in each container by iteration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续提取每个问题的标签，这会变得有点棘手，因为不同的问题可能有不同数量的标签。在下面的代码中，我们首先选择所有问题的标签容器，并通过迭代提取每个容器中的标签。
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All the preceding scraping happens in one web page. What if we need to collect
    data across multiple web pages? Suppose we visit the page of each question (for
    example, [http://stackoverflow.com/q/5963269/2906900](http://stackoverflow.com/q/5963269/2906900)).
    Notice that there is an info box on the up-right. We need to extract such info
    boxes of each question in list:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前序抓取都在一个网页中完成。如果我们需要跨多个网页收集数据怎么办？假设我们访问每个问题的页面（例如，[http://stackoverflow.com/q/5963269/2906900](http://stackoverflow.com/q/5963269/2906900)）。注意，右上角有一个信息框。我们需要提取列表中每个问题的此类信息框：
- en: '![Analysing HTML code and extracting data](img/image_14_014.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![分析HTML代码并提取数据](img/image_14_014.jpg)'
- en: 'Inspecting tells us `#qinfo` is the key of the info box on each question page.
    Then we can select all question hyperlinks, extract the URLs of all questions,
    iterate over them, read each question page, and extract the info box using that
    key:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 检查告诉我们 `#qinfo` 是每个问题页面上信息框的关键。然后我们可以选择所有问题超链接，提取所有问题的URL，遍历它们，读取每个问题页面，并使用该键提取信息框：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Besides all these, `rvest` also supports creating an HTTP session to simulate
    page navigation. To learn more, read the `rvest` documentation. For many scraping
    tasks, you can also simplify the finding of selectors by using the tools provided
    by [http://selectorgadget.com/](http://selectorgadget.com/).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些，`rvest` 还支持创建HTTP会话以模拟页面导航。要了解更多信息，请阅读`rvest`文档。对于许多抓取任务，你也可以通过使用[http://selectorgadget.com/](http://selectorgadget.com/)提供的工具来简化选择器的查找。
- en: There are more advanced techniques of web scraping such as dealing with AJAX
    and dynamic web pages using JavaScript, but they are beyond the scope of this
    chapter. For more usage, read the documentation for the `rvest` package.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 网络抓取还有更多高级技术，如使用JavaScript处理AJAX和动态网页，但这些内容超出了本章的范围。更多用法，请参阅`rvest`包的文档。
- en: Note that `rvest` is largely inspired by Python packages Robobrowser and BeautifulSoup.
    These packages are more powerful and thus popular in web scraping in some aspects
    than `rvest`. If the source is complex and large in scale, you might do well to
    learn to use these Python packages. Go to [https://www.crummy.com/software/BeautifulSoup/](https://www.crummy.com/software/BeautifulSoup/)
    for more information.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`rvest` 主要受到Python包Robobrowser和BeautifulSoup的启发。这些包在某些方面比`rvest`更强大，因此在某些方面的网络抓取中更受欢迎。如果源代码复杂且规模大，你可能需要学习如何使用这些Python包。更多信息请访问[https://www.crummy.com/software/BeautifulSoup/](https://www.crummy.com/software/BeautifulSoup/)。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how web pages are written in HTML and stylized by
    CSS. CSS selectors can be used to match HTML nodes so that their contents can
    be extracted. Well-written HTML documents can also be queried by XPath Expression,
    which has more features and is more flexible. Then we learned how to use the element
    inspector in modern web browsers to figure out a restrictive selector to match
    the HTML nodes of interest so that the needed data can be extracted from web pages.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了网页是如何用HTML编写的，以及如何通过CSS进行样式化。CSS选择器可以用来匹配HTML节点，以便提取其内容。编写良好的HTML文档也可以通过XPath表达式进行查询，它具有更多功能和更大的灵活性。然后我们学习了如何使用现代网络浏览器的元素检查器来确定一个限制性选择器来匹配感兴趣的HTML节点，从而可以从网页中提取所需的数据。
- en: In this next chapter, we will learn a series of techniques that boost your productivity,
    from R Markdown documents, diagrams, to interactive shiny apps. These tools make
    it much easier to create quality, reproducible, and interactive documents, which
    are very nice ways to present data, ideas, and prototypes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一系列提高你生产力的技术，从R Markdown文档、图表到交互式shiny应用。这些工具使得创建高质量、可重复和交互式的文档变得容易得多，这是展示数据、思想和原型的好方法。
